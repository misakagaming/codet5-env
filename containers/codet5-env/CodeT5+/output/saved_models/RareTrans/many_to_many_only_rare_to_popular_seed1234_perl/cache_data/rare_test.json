{"id": 383061, "name": "Table creation_Postal addresses", "source": "Translate Perl to Python: use DBI;\n\nmy $db = DBI->connect('DBI:mysql:database:server','login','password');\n\nmy $statment = <<EOF;\nCREATE TABLE `Address` (\n    `addrID`       int(11)     NOT NULL   auto_increment,\n    `addrStreet`   varchar(50) NOT NULL   default '',\n    `addrCity`     varchar(25) NOT NULL   default '',\n    `addrState`    char(2)     NOT NULL   default '',\n    `addrZIP`      char(10)    NOT NULL   default '',\n    PRIMARY KEY (`addrID`)\n);\nEOF\n\nmy $exec = $db->prepare($statment);\n$exec->execute;\n", "target": ">>> import sqlite3\n>>> conn = sqlite3.connect(':memory:')\n>>> conn.execute()\n<sqlite3.Cursor object at 0x013265C0>\n>>>\n"}
{"id": 383062, "name": "Sorting algorithms_Cycle sort", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub cycleSort :prototype(@) {\n\tmy ($array) = @_;\n\tmy $writes = 0;\n\t\n\tmy @alreadysorted;\n\t\n\t\n\tfor my $start ( 0 .. $\n\t\tnext if $alreadysorted[$start];\n\t\tmy $item = $array->[$start];\n\t\t\n\t\t\n\t\tmy $pos = $start + grep $array->[$_] lt $item, $start + 1 .. $\n\t\t\n\t\tnext if $pos == $start;\n\t\t\n\t\t\n\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\n\t\t\n\t\t($array->[ $pos ], $item) = ($item, $array->[ $pos ]);\n\t\t++$writes;\n\n\t\t\n\t\tdo {\n\t\t\t\n\t\t\t$pos = $start + grep $array->[$_] lt $item, $start+1 .. $\n\t\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\t\n\t\t\t($array->[ $pos ] , $item ) = ($item, $array->[ $pos ]);\n\t\t\t\n\t\t\t$alreadysorted[ $pos ] = 1;\n\t\t\t++$writes;\n\t\t\t\n\t\t} while $pos != $start;\n\t}\n\t$writes;\n}\n\nuse List::Util 'shuffle';\nmy @test = shuffle( ('a'..'z') x 2 );\nprint \"Before sorting: @test\\n\";\nprint \"There were \", cycleSort( \\@test ), \" writes\\n\";\nprint \"After  sorting: @test\\n\";\n", "target": "def cycleSort(vector):\n    \"Sort a vector in place and return the number of writes.\"\n    writes = 0\n \n    \n    for cycleStart, item in enumerate(vector):\n \n        \n        pos = cycleStart\n        for item2 in vector[cycleStart + 1:]:\n            if item2 < item:\n                pos += 1\n \n        \n        if pos == cycleStart:\n            continue\n \n        \n        while item == vector[pos]:\n            pos += 1\n        vector[pos], item = item, vector[pos]\n        writes += 1\n \n        \n        while pos != cycleStart:\n \n            \n            pos = cycleStart\n            for item2 in vector[cycleStart + 1:]:\n                if item2 < item:\n                    pos += 1\n \n            \n            while item == vector[pos]:\n                pos += 1\n            vector[pos], item = item, vector[pos]\n            writes += 1\n \n    return writes\n\n\nif __name__ == '__main__':\n    x = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\n    xcopy = x[::]\n    writes = cycleSort(xcopy)\n    if xcopy != sorted(x):\n        print('Wrong order!')\n    else:\n        print('%r\\nIs correctly sorted using cycleSort to'\n              '\\n%r\\nUsing %i writes.' % (x, xcopy, writes))\n"}
{"id": 383063, "name": "Sorting algorithms_Cycle sort", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub cycleSort :prototype(@) {\n\tmy ($array) = @_;\n\tmy $writes = 0;\n\t\n\tmy @alreadysorted;\n\t\n\t\n\tfor my $start ( 0 .. $\n\t\tnext if $alreadysorted[$start];\n\t\tmy $item = $array->[$start];\n\t\t\n\t\t\n\t\tmy $pos = $start + grep $array->[$_] lt $item, $start + 1 .. $\n\t\t\n\t\tnext if $pos == $start;\n\t\t\n\t\t\n\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\n\t\t\n\t\t($array->[ $pos ], $item) = ($item, $array->[ $pos ]);\n\t\t++$writes;\n\n\t\t\n\t\tdo {\n\t\t\t\n\t\t\t$pos = $start + grep $array->[$_] lt $item, $start+1 .. $\n\t\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\t\n\t\t\t($array->[ $pos ] , $item ) = ($item, $array->[ $pos ]);\n\t\t\t\n\t\t\t$alreadysorted[ $pos ] = 1;\n\t\t\t++$writes;\n\t\t\t\n\t\t} while $pos != $start;\n\t}\n\t$writes;\n}\n\nuse List::Util 'shuffle';\nmy @test = shuffle( ('a'..'z') x 2 );\nprint \"Before sorting: @test\\n\";\nprint \"There were \", cycleSort( \\@test ), \" writes\\n\";\nprint \"After  sorting: @test\\n\";\n", "target": "def cycleSort(vector):\n    \"Sort a vector in place and return the number of writes.\"\n    writes = 0\n \n    \n    for cycleStart, item in enumerate(vector):\n \n        \n        pos = cycleStart\n        for item2 in vector[cycleStart + 1:]:\n            if item2 < item:\n                pos += 1\n \n        \n        if pos == cycleStart:\n            continue\n \n        \n        while item == vector[pos]:\n            pos += 1\n        vector[pos], item = item, vector[pos]\n        writes += 1\n \n        \n        while pos != cycleStart:\n \n            \n            pos = cycleStart\n            for item2 in vector[cycleStart + 1:]:\n                if item2 < item:\n                    pos += 1\n \n            \n            while item == vector[pos]:\n                pos += 1\n            vector[pos], item = item, vector[pos]\n            writes += 1\n \n    return writes\n\n\nif __name__ == '__main__':\n    x = [0, 1, 2, 2, 2, 2, 1, 9, 3.5, 5, 8, 4, 7, 0, 6]\n    xcopy = x[::]\n    writes = cycleSort(xcopy)\n    if xcopy != sorted(x):\n        print('Wrong order!')\n    else:\n        print('%r\\nIs correctly sorted using cycleSort to'\n              '\\n%r\\nUsing %i writes.' % (x, xcopy, writes))\n"}
{"id": 383064, "name": "Twin primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Primesieve;\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nprintf \"Twin prime pairs less than %14s: %s\\n\", comma(10**$_), comma count_twins(1, 10**$_) for 1..10;\n", "target": "primes = [2, 3, 5, 7, 11, 13, 17, 19]\n\n\ndef count_twin_primes(limit: int) -> int:\n    global primes\n    if limit > primes[-1]:\n        ram_limit = primes[-1] + 90000000 - len(primes)\n        reasonable_limit = min(limit, primes[-1] ** 2, ram_limit) - 1\n\n        while reasonable_limit < limit:\n            ram_limit = primes[-1] + 90000000 - len(primes)\n            if ram_limit > primes[-1]:\n                reasonable_limit = min(limit, primes[-1] ** 2, ram_limit)\n            else:\n                reasonable_limit = min(limit, primes[-1] ** 2)\n\n            sieve = list({x for prime in primes for x in\n                          range(primes[-1] + prime - (primes[-1] % prime), reasonable_limit, prime)})\n            primes += [x - 1 for i, x in enumerate(sieve) if i and x - 1 != sieve[i - 1] and x - 1 < limit]\n\n    count = len([(x, y) for (x, y) in zip(primes, primes[1:]) if x + 2 == y])\n\n    return count\n\n\ndef test(limit: int):\n    count = count_twin_primes(limit)\n    print(f\"Number of twin prime pairs less than {limit} is {count}\\n\")\n\n\ntest(10)\ntest(100)\ntest(1000)\ntest(10000)\ntest(100000)\ntest(1000000)\ntest(10000000)\ntest(100000000)\n"}
{"id": 383065, "name": "Brazilian numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory qw<is_prime>;\nuse constant Inf  => 1e10;\n\nsub is_Brazilian {\n    my($n) = @_;\n    return 1 if $n > 6 && 0 == $n%2;\n    LOOP: for (my $base = 2; $base < $n - 1; ++$base) {\n        my $digit;\n        my $nn = $n;\n        while (1) {\n            my $x = $nn % $base;\n            $digit //= $x;\n            next LOOP if $digit != $x;\n            $nn = int $nn / $base;\n            if ($nn < $base) {\n                return 1 if $digit == $nn;\n                next LOOP;\n            }\n        }\n    }\n}\n\nmy $upto = 20;\n\nprint \"First $upto Brazilian numbers:\\n\";\nmy $n = 0;\nprint do { $n < $upto ? (is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto odd Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!($_%2) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto prime Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!is_prime($_) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383066, "name": "Brazilian numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory qw<is_prime>;\nuse constant Inf  => 1e10;\n\nsub is_Brazilian {\n    my($n) = @_;\n    return 1 if $n > 6 && 0 == $n%2;\n    LOOP: for (my $base = 2; $base < $n - 1; ++$base) {\n        my $digit;\n        my $nn = $n;\n        while (1) {\n            my $x = $nn % $base;\n            $digit //= $x;\n            next LOOP if $digit != $x;\n            $nn = int $nn / $base;\n            if ($nn < $base) {\n                return 1 if $digit == $nn;\n                next LOOP;\n            }\n        }\n    }\n}\n\nmy $upto = 20;\n\nprint \"First $upto Brazilian numbers:\\n\";\nmy $n = 0;\nprint do { $n < $upto ? (is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto odd Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!($_%2) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto prime Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!is_prime($_) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383067, "name": "Recaman's sequence", "source": "Translate Perl to Python: use bignum;\n\n$max = 1000;\n$remaining += $_ for 1..$max;\n\nmy @recamans = 0;\nmy $previous = 0;\n\nwhile ($remaining > 0) {\n   $term++;\n   my $this = $previous - $term;\n   $this = $previous + $term unless $this > 0 and !$seen{$this};\n   push @recamans, $this;\n   $dup = $term if !$dup and defined $seen{$this};\n   $remaining -= $this if $this <= $max and ! defined $seen{$this};\n   $seen{$this}++;\n   $previous = $this;\n}\n\nprint \"First fifteen terms of Recaman's sequence: \" . join(' ', @recamans[0..14]) . \"\\n\";\nprint \"First duplicate at term: a[$dup]\\n\";\nprint \"Range 0..1000 covered by terms up to a[$term]\\n\";\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 383068, "name": "Recaman's sequence", "source": "Translate Perl to Python: use bignum;\n\n$max = 1000;\n$remaining += $_ for 1..$max;\n\nmy @recamans = 0;\nmy $previous = 0;\n\nwhile ($remaining > 0) {\n   $term++;\n   my $this = $previous - $term;\n   $this = $previous + $term unless $this > 0 and !$seen{$this};\n   push @recamans, $this;\n   $dup = $term if !$dup and defined $seen{$this};\n   $remaining -= $this if $this <= $max and ! defined $seen{$this};\n   $seen{$this}++;\n   $previous = $this;\n}\n\nprint \"First fifteen terms of Recaman's sequence: \" . join(' ', @recamans[0..14]) . \"\\n\";\nprint \"First duplicate at term: a[$dup]\\n\";\nprint \"Range 0..1000 covered by terms up to a[$term]\\n\";\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 383069, "name": "Y combinator", "source": "Translate Perl to Python: sub Y { my $f = shift;                                \n    sub { my $x = shift; $x->($x) }->(                \n\tsub {my $y = shift; $f->(sub {$y->($y)(@_)})} \n    )\n}\nmy $fac = sub {my $f = shift;\n    sub {my $n = shift; $n < 2 ? 1 : $n * $f->($n-1)}\n};\nmy $fib = sub {my $f = shift;\n    sub {my $n = shift; $n == 0 ? 0 : $n == 1 ? 1 : $f->($n-1) + $f->($n-2)}\n};\nfor my $f ($fac, $fib) {\n    print join(' ', map Y($f)->($_), 0..9), \"\\n\";\n}\n", "target": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))\n>>> [ Y(fac)(i) for i in range(10) ]\n[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))\n>>> [ Y(fib)(i) for i in range(10) ]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"}
{"id": 383070, "name": "Total circles area", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::AllUtils <min max>;\n\nmy @circles = (\n    [ 1.6417233788,  1.6121789534, 0.0848270516],\n    [-1.4944608174,  1.2077959613, 1.1039549836],\n    [ 0.6110294452, -0.6907087527, 0.9089162485],\n    [ 0.3844862411,  0.2923344616, 0.2375743054],\n    [-0.2495892950, -0.3832854473, 1.0845181219],\n    [ 1.7813504266,  1.6178237031, 0.8162655711],\n    [-0.1985249206, -0.8343333301, 0.0538864941],\n    [-1.7011985145, -0.1263820964, 0.4776976918],\n    [-0.4319462812,  1.4104420482, 0.7886291537],\n    [ 0.2178372997, -0.9499557344, 0.0357871187],\n    [-0.6294854565, -1.3078893852, 0.7653357688],\n    [ 1.7952608455,  0.6281269104, 0.2727652452],\n    [ 1.4168575317,  1.0683357171, 1.1016025378],\n    [ 1.4637371396,  0.9463877418, 1.1846214562],\n    [-0.5263668798,  1.7315156631, 1.4428514068],\n    [-1.2197352481,  0.9144146579, 1.0727263474],\n    [-0.1389358881,  0.1092805780, 0.7350208828],\n    [ 1.5293954595,  0.0030278255, 1.2472867347],\n    [-0.5258728625,  1.3782633069, 1.3495508831],\n    [-0.1403562064,  0.2437382535, 1.3804956588],\n    [ 0.8055826339, -0.0482092025, 0.3327165165],\n    [-0.6311979224,  0.7184578971, 0.2491045282],\n    [ 1.4685857879, -0.8347049536, 1.3670667538],\n    [-0.6855727502,  1.6465021616, 1.0593087096],\n    [ 0.0152957411,  0.0638919221, 0.9771215985],\n);\n\nmy $x_min = min map { $_->[0] - $_->[2] } @circles;\nmy $x_max = max map { $_->[0] + $_->[2] } @circles;\nmy $y_min = min map { $_->[1] - $_->[2] } @circles;\nmy $y_max = max map { $_->[1] + $_->[2] } @circles;\n\nmy $box_side = 500;\nmy $dx = ($x_max - $x_min) / $box_side;\nmy $dy = ($y_max - $y_min) / $box_side;\nmy $count = 0;\n\nfor my $r (0..$box_side) {\n    my $y = $y_min + $r * $dy;\n    for my $c (0..$box_side) {\n        my $x = $x_min + $c * $dx;\n        for my $c (@circles) {\n            $count++ and last if ($x - $$c[0])**2 + ($y - $$c[1])**2 <= $$c[2]**2\n        }\n    }\n}\n\nprintf \"Approximated area:\u00a0%.9f\\n\", $count * $dx * $dy;\n", "target": "from collections import namedtuple\n\nCircle = namedtuple(\"Circle\", \"x y r\")\n\ncircles = [\n    Circle( 1.6417233788,  1.6121789534, 0.0848270516),\n    Circle(-1.4944608174,  1.2077959613, 1.1039549836),\n    Circle( 0.6110294452, -0.6907087527, 0.9089162485),\n    Circle( 0.3844862411,  0.2923344616, 0.2375743054),\n    Circle(-0.2495892950, -0.3832854473, 1.0845181219),\n    Circle( 1.7813504266,  1.6178237031, 0.8162655711),\n    Circle(-0.1985249206, -0.8343333301, 0.0538864941),\n    Circle(-1.7011985145, -0.1263820964, 0.4776976918),\n    Circle(-0.4319462812,  1.4104420482, 0.7886291537),\n    Circle( 0.2178372997, -0.9499557344, 0.0357871187),\n    Circle(-0.6294854565, -1.3078893852, 0.7653357688),\n    Circle( 1.7952608455,  0.6281269104, 0.2727652452),\n    Circle( 1.4168575317,  1.0683357171, 1.1016025378),\n    Circle( 1.4637371396,  0.9463877418, 1.1846214562),\n    Circle(-0.5263668798,  1.7315156631, 1.4428514068),\n    Circle(-1.2197352481,  0.9144146579, 1.0727263474),\n    Circle(-0.1389358881,  0.1092805780, 0.7350208828),\n    Circle( 1.5293954595,  0.0030278255, 1.2472867347),\n    Circle(-0.5258728625,  1.3782633069, 1.3495508831),\n    Circle(-0.1403562064,  0.2437382535, 1.3804956588),\n    Circle( 0.8055826339, -0.0482092025, 0.3327165165),\n    Circle(-0.6311979224,  0.7184578971, 0.2491045282),\n    Circle( 1.4685857879, -0.8347049536, 1.3670667538),\n    Circle(-0.6855727502,  1.6465021616, 1.0593087096),\n    Circle( 0.0152957411,  0.0638919221, 0.9771215985)]\n\ndef main():\n    \n    x_min = min(c.x - c.r for c in circles)\n    x_max = max(c.x + c.r for c in circles)\n    y_min = min(c.y - c.r for c in circles)\n    y_max = max(c.y + c.r for c in circles)\n\n    box_side = 500\n\n    dx = (x_max - x_min) / box_side\n    dy = (y_max - y_min) / box_side\n\n    count = 0\n\n    for r in xrange(box_side):\n        y = y_min + r * dy\n        for c in xrange(box_side):\n            x = x_min + c * dx\n            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)\n                   for circle in circles):\n                count += 1\n\n    print \"Approximated area:\", count * dx * dy\n\nmain()\n"}
{"id": 383071, "name": "Total circles area", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::AllUtils <min max>;\n\nmy @circles = (\n    [ 1.6417233788,  1.6121789534, 0.0848270516],\n    [-1.4944608174,  1.2077959613, 1.1039549836],\n    [ 0.6110294452, -0.6907087527, 0.9089162485],\n    [ 0.3844862411,  0.2923344616, 0.2375743054],\n    [-0.2495892950, -0.3832854473, 1.0845181219],\n    [ 1.7813504266,  1.6178237031, 0.8162655711],\n    [-0.1985249206, -0.8343333301, 0.0538864941],\n    [-1.7011985145, -0.1263820964, 0.4776976918],\n    [-0.4319462812,  1.4104420482, 0.7886291537],\n    [ 0.2178372997, -0.9499557344, 0.0357871187],\n    [-0.6294854565, -1.3078893852, 0.7653357688],\n    [ 1.7952608455,  0.6281269104, 0.2727652452],\n    [ 1.4168575317,  1.0683357171, 1.1016025378],\n    [ 1.4637371396,  0.9463877418, 1.1846214562],\n    [-0.5263668798,  1.7315156631, 1.4428514068],\n    [-1.2197352481,  0.9144146579, 1.0727263474],\n    [-0.1389358881,  0.1092805780, 0.7350208828],\n    [ 1.5293954595,  0.0030278255, 1.2472867347],\n    [-0.5258728625,  1.3782633069, 1.3495508831],\n    [-0.1403562064,  0.2437382535, 1.3804956588],\n    [ 0.8055826339, -0.0482092025, 0.3327165165],\n    [-0.6311979224,  0.7184578971, 0.2491045282],\n    [ 1.4685857879, -0.8347049536, 1.3670667538],\n    [-0.6855727502,  1.6465021616, 1.0593087096],\n    [ 0.0152957411,  0.0638919221, 0.9771215985],\n);\n\nmy $x_min = min map { $_->[0] - $_->[2] } @circles;\nmy $x_max = max map { $_->[0] + $_->[2] } @circles;\nmy $y_min = min map { $_->[1] - $_->[2] } @circles;\nmy $y_max = max map { $_->[1] + $_->[2] } @circles;\n\nmy $box_side = 500;\nmy $dx = ($x_max - $x_min) / $box_side;\nmy $dy = ($y_max - $y_min) / $box_side;\nmy $count = 0;\n\nfor my $r (0..$box_side) {\n    my $y = $y_min + $r * $dy;\n    for my $c (0..$box_side) {\n        my $x = $x_min + $c * $dx;\n        for my $c (@circles) {\n            $count++ and last if ($x - $$c[0])**2 + ($y - $$c[1])**2 <= $$c[2]**2\n        }\n    }\n}\n\nprintf \"Approximated area:\u00a0%.9f\\n\", $count * $dx * $dy;\n", "target": "from collections import namedtuple\n\nCircle = namedtuple(\"Circle\", \"x y r\")\n\ncircles = [\n    Circle( 1.6417233788,  1.6121789534, 0.0848270516),\n    Circle(-1.4944608174,  1.2077959613, 1.1039549836),\n    Circle( 0.6110294452, -0.6907087527, 0.9089162485),\n    Circle( 0.3844862411,  0.2923344616, 0.2375743054),\n    Circle(-0.2495892950, -0.3832854473, 1.0845181219),\n    Circle( 1.7813504266,  1.6178237031, 0.8162655711),\n    Circle(-0.1985249206, -0.8343333301, 0.0538864941),\n    Circle(-1.7011985145, -0.1263820964, 0.4776976918),\n    Circle(-0.4319462812,  1.4104420482, 0.7886291537),\n    Circle( 0.2178372997, -0.9499557344, 0.0357871187),\n    Circle(-0.6294854565, -1.3078893852, 0.7653357688),\n    Circle( 1.7952608455,  0.6281269104, 0.2727652452),\n    Circle( 1.4168575317,  1.0683357171, 1.1016025378),\n    Circle( 1.4637371396,  0.9463877418, 1.1846214562),\n    Circle(-0.5263668798,  1.7315156631, 1.4428514068),\n    Circle(-1.2197352481,  0.9144146579, 1.0727263474),\n    Circle(-0.1389358881,  0.1092805780, 0.7350208828),\n    Circle( 1.5293954595,  0.0030278255, 1.2472867347),\n    Circle(-0.5258728625,  1.3782633069, 1.3495508831),\n    Circle(-0.1403562064,  0.2437382535, 1.3804956588),\n    Circle( 0.8055826339, -0.0482092025, 0.3327165165),\n    Circle(-0.6311979224,  0.7184578971, 0.2491045282),\n    Circle( 1.4685857879, -0.8347049536, 1.3670667538),\n    Circle(-0.6855727502,  1.6465021616, 1.0593087096),\n    Circle( 0.0152957411,  0.0638919221, 0.9771215985)]\n\ndef main():\n    \n    x_min = min(c.x - c.r for c in circles)\n    x_max = max(c.x + c.r for c in circles)\n    y_min = min(c.y - c.r for c in circles)\n    y_max = max(c.y + c.r for c in circles)\n\n    box_side = 500\n\n    dx = (x_max - x_min) / box_side\n    dy = (y_max - y_min) / box_side\n\n    count = 0\n\n    for r in xrange(box_side):\n        y = y_min + r * dy\n        for c in xrange(box_side):\n            x = x_min + c * dx\n            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)\n                   for circle in circles):\n                count += 1\n\n    print \"Approximated area:\", count * dx * dy\n\nmain()\n"}
{"id": 383072, "name": "Factorions", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory qw/factorial todigits/;\n\nmy $limit = 1500000;\n\nfor my $b (9 .. 12) {\n    print \"Factorions in base $b:\\n\";\n    $_ == factorial($_) and print \"$_ \" for 0..$b-1;\n\n    for my $i (1 .. int $limit/$b) {\n        my $sum;\n        my $prod = $i * $b;\n\n        for (reverse todigits($i, $b)) {\n            $sum += factorial($_);\n            $sum = 0 && last if $sum > $prod;\n        }\n\n        next if $sum == 0;\n        ($sum + factorial($_) == $prod + $_) and print $prod+$_ . ' ' for 0..$b-1;\n    }\n    print \"\\n\\n\";\n}\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 383073, "name": "Factorions", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory qw/factorial todigits/;\n\nmy $limit = 1500000;\n\nfor my $b (9 .. 12) {\n    print \"Factorions in base $b:\\n\";\n    $_ == factorial($_) and print \"$_ \" for 0..$b-1;\n\n    for my $i (1 .. int $limit/$b) {\n        my $sum;\n        my $prod = $i * $b;\n\n        for (reverse todigits($i, $b)) {\n            $sum += factorial($_);\n            $sum = 0 && last if $sum > $prod;\n        }\n\n        next if $sum == 0;\n        ($sum + factorial($_) == $prod + $_) and print $prod+$_ . ' ' for 0..$b-1;\n    }\n    print \"\\n\\n\";\n}\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 383074, "name": "Sum of divisors", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisor_sum';\n\nmy @x;\npush @x, scalar divisor_sum($_) for 1..100;\n\nsay \"Divisor sums - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 383075, "name": "Sum of divisors", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisor_sum';\n\nmy @x;\npush @x, scalar divisor_sum($_) for 1..100;\n\nsay \"Divisor sums - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 383076, "name": "Order by pair comparisons", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nsub ask\n  {\n  while( 1 )\n    {\n    print \"Compare $a to $b [<,=,>]: \";\n    <STDIN> =~ /[<=>]/ and return +{qw( < -1 = 0 > 1 )}->{$&};\n    }\n  }\n\nmy @sorted = sort ask qw( violet red green indigo blue yellow orange );\nprint \"sorted: @sorted\\n\";\n", "target": "def _insort_right(a, x, q):\n    \n\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        q += 1\n        less = input(f\"{q:2}: IS {x:>6} LESS-THAN {a[mid]:>6}\u00a0? y/n: \").strip().lower() == 'y'\n        if less: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n    return q\n\ndef order(items):\n    ordered, q = [], 0\n    for item in items:\n        q = _insort_right(ordered, item, q)\n    return ordered, q\n\nif __name__ == '__main__':\n    items = 'violet red green indigo blue yellow orange'.split()\n    ans, questions = order(items)\n    print('\\n' + ' '.join(ans))\n"}
{"id": 383077, "name": "Fermat numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint try=>\"GMP\";\nuse ntheory qw<factor>;\n\nmy @Fermats = map { 2**(2**$_) + 1 } 0..9;\n\nmy $sub = 0;\nsay 'First 10 Fermat numbers:';\nprintf \"F%s = %s\\n\", $sub++, $_ for @Fermats;\n\n$sub = 0;\nsay \"\\nFactors of first few Fermat numbers:\";\nfor my $f (map { [factor($_)] } @Fermats[0..8]) {\n   printf \"Factors of F%s: %s\\n\", $sub++, @$f == 1 ? 'prime' : join ' ', @$f\n}\n", "target": "def factors(x):\n    factors = []\n    i = 2\n    s = int(x ** 0.5)\n    while i < s:\n        if x % i == 0:\n            factors.append(i)\n            x = int(x / i)\n            s = int(x ** 0.5)\n        i += 1\n    factors.append(x)\n    return factors\n\nprint(\"First 10 Fermat numbers:\")\nfor i in range(10):\n    fermat = 2 ** 2 ** i + 1\n    print(\"F{} = {}\".format(chr(i + 0x2080) , fermat))\n\nprint(\"\\nFactors of first few Fermat numbers:\")\nfor i in range(10):\n    fermat = 2 ** 2 ** i + 1\n    fac = factors(fermat)\n    if len(fac) == 1:\n        print(\"F{} -> IS PRIME\".format(chr(i + 0x2080)))\n    else:\n        print(\"F{} -> FACTORS: {}\".format(chr(i + 0x2080), fac))\n"}
{"id": 383078, "name": "Sorting algorithms_Bead sort", "source": "Translate Perl to Python: sub beadsort {\n    my @data = @_;\n\n    my @columns;\n    my @rows;\n\n    for my $datum (@data) {\n        for my $column ( 0 .. $datum-1 ) {\n            ++ $rows[ $columns[$column]++ ];\n        }\n    }\n\n    return reverse @rows;\n}\n\nbeadsort 5, 7, 1, 3, 1, 1, 20;\n", "target": "\nfrom itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))\n"}
{"id": 383079, "name": "Casting out nines", "source": "Translate Perl to Python: sub co9 {  \n  my $n = shift;\n  return $n if $n < 10;\n  my $sum = 0; $sum += $_ for split(//,$n);\n  co9($sum);\n}\n\nsub showadd {\n  my($n,$m) = @_;\n  print \"( $n [\",co9($n),\"] + $m [\",co9($m),\"] ) [\",co9(co9($n)+co9($m)),\"]\", \n        \"   =   \", $n+$m,\" [\",co9($n+$m),\"]\\n\";\n}\n\nsub co9filter {\n  my $base = shift;\n  die unless $base >= 2;\n  my($beg, $end, $basem1) = (1, $base*$base-1, $base-1);\n  my @list = grep { $_ % $basem1 == $_*$_ % $basem1 } $beg .. $end;\n  ($end, scalar(@list), @list);\n}\n\nprint \"Part 1: Create a simple filter and demonstrate using simple example.\\n\";\nshowadd(6395, 1259);\n\nprint \"\\nPart 2: Use this to filter a range with co9(k) == co9(k^2).\\n\";\nprint join(\" \", grep { co9($_) == co9($_*$_) } 1..99), \"\\n\";\n\nprint \"\\nPart 3: Use efficient method on range.\\n\";\nfor my $base (10, 17) {\n  my($N, $n, @l) = co9filter($base);\n  printf \"[@l]\\nIn base %d, trying %d numbers instead of %d saves\u00a0%.4f%%\\n\\n\",\n         $base, $n, $N, 100-($n/$N)*100;\n}\n", "target": "\n\n\n\ndef CastOut(Base=10, Start=1, End=999999):\n  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]\n  x,y = divmod(Start, Base-1)\n  while True:\n    for n in ran:\n      k = (Base-1)*x + n\n      if k < Start:\n        continue\n      if k > End:\n        return\n      yield k\n    x += 1\n\nfor V in CastOut(Base=16,Start=1,End=255):\n  print(V, end=' ')\n"}
{"id": 383080, "name": "Casting out nines", "source": "Translate Perl to Python: sub co9 {  \n  my $n = shift;\n  return $n if $n < 10;\n  my $sum = 0; $sum += $_ for split(//,$n);\n  co9($sum);\n}\n\nsub showadd {\n  my($n,$m) = @_;\n  print \"( $n [\",co9($n),\"] + $m [\",co9($m),\"] ) [\",co9(co9($n)+co9($m)),\"]\", \n        \"   =   \", $n+$m,\" [\",co9($n+$m),\"]\\n\";\n}\n\nsub co9filter {\n  my $base = shift;\n  die unless $base >= 2;\n  my($beg, $end, $basem1) = (1, $base*$base-1, $base-1);\n  my @list = grep { $_ % $basem1 == $_*$_ % $basem1 } $beg .. $end;\n  ($end, scalar(@list), @list);\n}\n\nprint \"Part 1: Create a simple filter and demonstrate using simple example.\\n\";\nshowadd(6395, 1259);\n\nprint \"\\nPart 2: Use this to filter a range with co9(k) == co9(k^2).\\n\";\nprint join(\" \", grep { co9($_) == co9($_*$_) } 1..99), \"\\n\";\n\nprint \"\\nPart 3: Use efficient method on range.\\n\";\nfor my $base (10, 17) {\n  my($N, $n, @l) = co9filter($base);\n  printf \"[@l]\\nIn base %d, trying %d numbers instead of %d saves\u00a0%.4f%%\\n\\n\",\n         $base, $n, $N, 100-($n/$N)*100;\n}\n", "target": "\n\n\n\ndef CastOut(Base=10, Start=1, End=999999):\n  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]\n  x,y = divmod(Start, Base-1)\n  while True:\n    for n in ran:\n      k = (Base-1)*x + n\n      if k < Start:\n        continue\n      if k > End:\n        return\n      yield k\n    x += 1\n\nfor V in CastOut(Base=16,Start=1,End=255):\n  print(V, end=' ')\n"}
{"id": 383081, "name": "Simple database", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\nuse feature qw{ say };\n\nuse JSON::PP;\nuse Time::Piece;\n\nuse constant {\n    NAME     => 0,\n    CATEGORY => 1,\n    DATE     => 2,\n    DB       => 'simple-db',\n};\n\nmy $operation = shift // \"\";\n\nmy %dispatch = (\n    n => \\&add_new,\n    l => \\&print_latest,\n    L => \\&print_latest_for_categories,\n    a => \\&print_all,\n);\n\nif ($dispatch{$operation}) {\n    $dispatch{$operation}->(@ARGV);\n} else {\n    die \"Invalid option. Use one of n, l, L, a.\\n\"\n}\n\nsub add_new {\n    my ($name, $category, $date) = @_;\n    my $db = eval { load() } || {};\n    if (defined $date) {\n        eval { 'Time::Piece'->strptime($date, '%Y-%m-%d'); 1 }\n            or die \"Invalid date format: YYYY-MM-DD.\\n\";\n\n    } else {\n        $date //= localtime->ymd;\n    }\n\n    my @ids = keys %{ $db->{by_id} };\n    my $max_id = max(num => @ids) || 0;\n    $db->{by_id}{ ++$max_id } = [ $name, $category, $date ];\n    save($db);\n}\n\nsub print_latest {\n    build_indexes( my $db = load(), 0, 1 );\n    _print_latest($db);\n}\n\nsub _print_latest {\n    my ($db, $category) = @_;\n    my @dates = keys %{ $db->{by_date} };\n    @dates = grep {\n        grep $db->{by_id}{$_}[CATEGORY] eq $category,\n            @{ $db->{by_date}{$_} };\n    } @dates if defined $category;\n\n    my $last_date = max(str => @dates);\n    say for map $db->{by_id}{$_}[NAME],\n            grep ! defined $category\n                 || $db->{by_id}{$_}[CATEGORY] eq $category,\n            @{ $db->{by_date}{$last_date} };\n}\n\nsub max {\n    my $type = shift;\n    my $max = $_[0];\n    { num => sub { $_ >  $max },\n      str => sub { $_ gt $max},\n    }->{$type}->() and $max = $_\n        for @_[ 1 .. $\n    return $max\n}\n\nsub print_latest_for_categories {\n    build_indexes( my $db = load(), 1, 1 );\n\n    for my $category (sort keys %{ $db->{by_category} }){\n        say \"* $category\";\n        _print_latest($db, $category);\n    }\n}\n\nsub print_all {\n    build_indexes( my $db = load(), 0, 1 );\n\n    for my $date (sort keys %{ $db->{by_date} }) {\n        for my $id (@{ $db->{by_date}{$date} }) {\n            say $db->{by_id}{$id}[NAME];\n        }\n    }\n}\n\nsub load {\n    open my $in, '<', DB or die \"Can't open database: $!\\n\";\n    local $/;\n    return { by_id => decode_json(<$in>) };\n}\n\nsub save {\n    my ($db) = @_;\n    open my $out, '>', DB or die \"Can't save database: $!\\n\";\n    print {$out} encode_json($db->{by_id});\n    close $out;\n}\n\nsub build_indexes {\n    my ($db, $by_category, $by_date) = @_;\n    for my $id (keys %{ $db->{by_id} }) {\n        push @{ $db->{by_category}{ $db->{by_id}{$id}[CATEGORY] } }, $id\n            if $by_category;\n        push @{ $db->{by_date}{ $db->{by_id}{$id}[DATE] } }, $id\n            if $by_date;\n    }\n}\n", "target": "\n\n\n\nimport argparse\nfrom argparse import Namespace\nimport datetime\nimport shlex\n\n\ndef parse_args():\n    'Set up, parse, and return arguments'\n    \n    parser = argparse.ArgumentParser(epilog=globals()['__doc__'])\n\n    parser.add_argument('command', choices='add pl plc pa'.split(),\n                        help=)\n    parser.add_argument('-d', '--description',\n                        help='A description of the item. (e.g., title, name)')\n    parser.add_argument('-t', '--tag',\n                        help=(\n                              ))\n    parser.add_argument('-f', '--field', nargs=2, action='append', \n                        help='Other optional fields with value (can be repeated)')\n\n    return parser\n\ndef do_add(args, dbname):\n    'Add a new entry'\n    if args.description is None:\n        args.description = ''\n    if args.tag is None:\n        args.tag = ''\n    del args.command\n    print('Writing record to %s' % dbname)\n    with open(dbname, 'a') as db:\n        db.write('%r\\n' % args)\n    \ndef do_pl(args, dbname):\n    'Print the latest entry'\n    print('Getting last record from %s' % dbname)\n    with open(dbname, 'r') as db:\n        for line in db: pass\n    record = eval(line)\n    del record._date\n    print(str(record))\n    \ndef do_plc(args, dbname):\n    'Print the latest entry for each category/tag'\n    print('Getting latest record for each tag from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    tags = set(record.tag for record in records)\n    records.reverse()\n    for record in records:\n        if record.tag in tags:\n            del record._date\n            print(str(record))\n            tags.discard(record.tag)\n            if not tags: break\n\ndef do_pa(args, dbname):\n    'Print all entries sorted by a date'\n    print('Getting all records by date from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    for record in records:\n        del record._date\n        print(str(record))\n\ndef test():\n    import time\n    parser = parse_args()\n    for cmdline in [\n                    ,\n                    ,\n                    ,\n                    ,\n                    ,\n                    ]:\n        args = parser.parse_args(shlex.split(cmdline))\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n        time.sleep(0.5)\n\n\n    \ndo_command = dict(add=do_add, pl=do_pl, plc=do_plc, pa=do_pa)\ndbname = '_simple_db_db.py'\n\n\nif __name__ == '__main__':\n    if 0:\n        test()\n    else:\n        parser = parse_args()\n        args = parser.parse_args()\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n"}
{"id": 383082, "name": "Keyboard macros", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Term::ReadKey;\n\nReadMode 4; \n\nsub logger { my($message) = @_; print \"$message\\n\" }\n\nwhile (1) {\n    if (my $c = ReadKey 0) { \n        if ($c eq 'q') { logger \"QUIT\"; last }\n        elsif ($c =~ /\\n|\\r/) { logger \"CR\" }\n        elsif ($c eq \"j\") { logger \"down\" }\n        elsif ($c eq \"k\") { logger \"up\" }\n        elsif ($c eq \"h\") { logger \"left\" }\n        elsif ($c eq \"l\") { logger \"right\" }\n\n        elsif ($c eq \"J\") { logger \"DOWN\" }\n        elsif ($c eq \"K\") { logger \"UP\" }\n        elsif ($c eq \"H\") { logger \"LEFT\" }\n        elsif ($c eq \"L\") { logger \"RIGHT\" }\n\n        elsif ($c eq \"\\e\") { \n            my $esc  = ReadKey 0;\n               $esc .= ReadKey 0;\n            if    ($esc eq \"[A\") { logger \"up\" }\n            elsif ($esc eq \"[B\") { logger \"down\" }\n            elsif ($esc eq \"[C\") { logger \"right\" }\n            elsif ($esc eq \"[D\") { logger \"left\" }\n            elsif ($esc eq \"[5\") { logger \"page up\" }\n            elsif ($esc eq \"[6\") { logger \"page down\" }\n            else { logger \"Unrecognized escape: $esc\"; }\n        }\n\n        else { logger \"you typed: $c\"; }\n    }\n}\n\nReadMode 0; \n", "target": "\nimport curses\n\ndef print_message():\n    stdscr.addstr('This is the message.\\n')\n\nstdscr = curses.initscr()\ncurses.noecho()\ncurses.cbreak()\nstdscr.keypad(1)\n\nstdscr.addstr('CTRL+P for message or q to quit.\\n')\nwhile True:\n    c = stdscr.getch()\n    if c == 16: print_message()\n    elif c == ord('q'): break\n\ncurses.nocbreak()\nstdscr.keypad(0)\ncurses.echo()\ncurses.endwin()\n"}
{"id": 383083, "name": "Tau function", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy @x;\npush @x, scalar divisors($_) for 1..100;\n\nsay \"Tau function - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 383084, "name": "Tau function", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy @x;\npush @x, scalar divisors($_) for 1..100;\n\nsay \"Tau function - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 383085, "name": "M\u00f6bius function", "source": "Translate Perl to Python: use utf8;\nuse strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'uniq';\n\nsub prime_factors {\n    my ($n, $d, @factors) = (shift, 1);\n    while ($n > 1 and $d++) {\n        $n /= $d, push @factors, $d until $n % $d;\n    }\n    @factors\n}\n\nsub \u03bc {\n    my @p = prime_factors(shift);\n    @p == uniq(@p) ? 0 == @p%2 ? 1 : -1 : 0;\n}\n\nmy @m\u00f6ebius;\npush @m\u00f6ebius, \u03bc($_) for 1 .. (my $upto = 199);\n\nsay \"M\u00f6bius sequence - First $upto terms:\\n\" .\n    (' 'x4 . sprintf \"@{['%4d' x $upto]}\", @m\u00f6ebius) =~ s/((.){80})/$1\\n/gr;\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\ndef isPrime(n) :\n \n    if (n < 2) :\n        return False\n    for i in range(2, n + 1) :\n        if (i * i <= n and n % i == 0) :\n            return False\n    return True\n \ndef mobius(N) :\n     \n    \n    if (N == 1) :\n        return 1\n \n    \n    \n    \n    p = 0\n    for i in range(1, N + 1) :\n        if (N % i == 0 and\n                isPrime(i)) :\n \n            \n            \n            if (N % (i * i) == 0) :\n                return 0\n            else :\n \n                \n                \n                p = p + 1\n \n    \n    \n    \n    \n    if(p % 2 != 0) :\n        return -1\n    else :\n        return 1\n \n\nprint(\"Mobius numbers from 1..99:\")\n      \nfor i in range(1, 100):\n  print(f\"{mobius(i):>4}\", end = '')\n\n  if i % 20 == 0: print()\n\n\n"}
{"id": 383086, "name": "Coprime triplets", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <state say>;\nuse ntheory 'gcd';\nuse List::Util 'first';\nuse List::Lazy 'lazy_list';\nuse enum qw(False True);\nuse constant Inf => 1e5;\n\nmy $ct = lazy_list {\n    state @c = (1, 2);\n    state %seen = (1 => True, 2 => True);\n    state $min = 3;\n    my $g = $c[-2] * $c[-1];\n    my $n = first { !$seen{$_} and gcd($_,$g) == 1 } $min .. Inf;\n    $seen{$n} = True;\n    $min = first { !$seen{$_} } $min .. Inf;\n    push @c, $n;\n    shift @c\n};\n\nmy @ct;\ndo { push @ct, $ct->next() } until $ct[-1] > 50; pop @ct;\nsay join ' ', @ct\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\ndef Gcd(v1, v2):\n    a, b = v1, v2\n    if (a < b):\n        a, b = v2, v1\n    r = 1\n    while (r != 0):\n        r = a % b\n        if (r != 0):\n            a = b\n            b = r\n    return b\n\n\na = [1, 2]\n\nn = 3\n\nwhile (n < 50):\n    gcd1 = Gcd(n, a[-1])\n    gcd2 = Gcd(n, a[-2])\n    \n    \n    if (gcd1 == 1 and gcd2 == 1 and not(n in a)):\n        \n        a.append(n)\n        n = 3\n    else:\n        \n        n += 1\n\n\nfor i in range(0, len(a)):\n    if (i % 10 == 0):\n        print('')\n    print(\"%4d\" % a[i], end = '');\n    \n\nprint(\"\\n\\nNumber of elements in coprime triplets = \" + str(len(a)), end = \"\\n\")\n"}
{"id": 383087, "name": "Coprime triplets", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <state say>;\nuse ntheory 'gcd';\nuse List::Util 'first';\nuse List::Lazy 'lazy_list';\nuse enum qw(False True);\nuse constant Inf => 1e5;\n\nmy $ct = lazy_list {\n    state @c = (1, 2);\n    state %seen = (1 => True, 2 => True);\n    state $min = 3;\n    my $g = $c[-2] * $c[-1];\n    my $n = first { !$seen{$_} and gcd($_,$g) == 1 } $min .. Inf;\n    $seen{$n} = True;\n    $min = first { !$seen{$_} } $min .. Inf;\n    push @c, $n;\n    shift @c\n};\n\nmy @ct;\ndo { push @ct, $ct->next() } until $ct[-1] > 50; pop @ct;\nsay join ' ', @ct\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\ndef Gcd(v1, v2):\n    a, b = v1, v2\n    if (a < b):\n        a, b = v2, v1\n    r = 1\n    while (r != 0):\n        r = a % b\n        if (r != 0):\n            a = b\n            b = r\n    return b\n\n\na = [1, 2]\n\nn = 3\n\nwhile (n < 50):\n    gcd1 = Gcd(n, a[-1])\n    gcd2 = Gcd(n, a[-2])\n    \n    \n    if (gcd1 == 1 and gcd2 == 1 and not(n in a)):\n        \n        a.append(n)\n        n = 3\n    else:\n        \n        n += 1\n\n\nfor i in range(0, len(a)):\n    if (i % 10 == 0):\n        print('')\n    print(\"%4d\" % a[i], end = '');\n    \n\nprint(\"\\n\\nNumber of elements in coprime triplets = \" + str(len(a)), end = \"\\n\")\n"}
{"id": 383088, "name": "Curzon numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'powmod';\n\nsub curzon {\n    my($base,$cnt) = @_;\n    my($n,@C) = 0;\n    while (++$n) {\n        my $r = $base * $n;\n        push @C, $n if powmod($base, $n, $r + 1) == $r;\n        return @C if $cnt == @C;\n    }\n}\n\nmy $upto = 50;\nfor my $k (<2 4 6 8 10>) {\n    my @C = curzon $k, 1000;\n    print \"First $upto Curzon numbers using a base of $k:\\n\" .\n    (sprintf \"@{['%5d' x $upto]}\", @C[0..$upto-1]) =~ s/.{100}/$&\\n/gr;\n    printf \"%50s\\n\\n\", \"Thousandth: $C[-1]\"\n}\n", "target": "def is_Curzon(n, k):\n    r = k * n\n    return pow(k, n, r + 1) == r\n\nfor k in [2, 4, 6, 8, 10]:\n    n, curzons = 1, []\n    while len(curzons) < 1000:\n        if is_Curzon(n, k):\n            curzons.append(n)\n        n += 1\n    print(f'Curzon numbers with k = {k}:')\n    for i, c in enumerate(curzons[:50]):\n        print(f'{c: 5,}', end='\\n' if (i + 1) % 25 == 0 else '')\n    print(f'    Thousandth Curzon with k = {k}: {curzons[999]}.\\n')\n"}
{"id": 383089, "name": "Curzon numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'powmod';\n\nsub curzon {\n    my($base,$cnt) = @_;\n    my($n,@C) = 0;\n    while (++$n) {\n        my $r = $base * $n;\n        push @C, $n if powmod($base, $n, $r + 1) == $r;\n        return @C if $cnt == @C;\n    }\n}\n\nmy $upto = 50;\nfor my $k (<2 4 6 8 10>) {\n    my @C = curzon $k, 1000;\n    print \"First $upto Curzon numbers using a base of $k:\\n\" .\n    (sprintf \"@{['%5d' x $upto]}\", @C[0..$upto-1]) =~ s/.{100}/$&\\n/gr;\n    printf \"%50s\\n\\n\", \"Thousandth: $C[-1]\"\n}\n", "target": "def is_Curzon(n, k):\n    r = k * n\n    return pow(k, n, r + 1) == r\n\nfor k in [2, 4, 6, 8, 10]:\n    n, curzons = 1, []\n    while len(curzons) < 1000:\n        if is_Curzon(n, k):\n            curzons.append(n)\n        n += 1\n    print(f'Curzon numbers with k = {k}:')\n    for i, c in enumerate(curzons[:50]):\n        print(f'{c: 5,}', end='\\n' if (i + 1) % 25 == 0 else '')\n    print(f'    Thousandth Curzon with k = {k}: {curzons[999]}.\\n')\n"}
{"id": 383090, "name": "Mertens function", "source": "Translate Perl to Python: use utf8;\nuse strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'uniq';\n\nsub prime_factors {\n    my ($n, $d, @factors) = (shift, 1);\n    while ($n > 1 and $d++) {\n        $n /= $d, push @factors, $d until $n % $d;\n    }\n    @factors\n}\n\nsub \u03bc {\n    my @p = prime_factors(shift);\n    @p == uniq(@p) ? 0 == @p%2 ? 1 : -1 : 0\n}\n\nsub progressive_sum {\n    my @sum = shift @_;\n    push @sum, $sum[-1] + $_ for @_;\n    @sum\n}\n\nmy($upto, $show, @m\u00f6ebius) = (1000, 199, ());\npush @m\u00f6ebius, \u03bc($_) for 1..$upto;\nmy @mertens = progressive_sum @m\u00f6ebius;\n\nsay \"Mertens sequence - First $show terms:\\n\" .\n    (' 'x4 . sprintf \"@{['%4d' x $show]}\", @mertens[0..$show-1]) =~ s/((.){80})/$1\\n/gr .\n    sprintf(\"\\nEquals zero %3d times between 1 and $upto\", scalar grep { ! $_ } @mertens) .\n    sprintf \"\\nCrosses zero%3d times between 1 and $upto\", scalar grep { ! $mertens[$_-1] and $mertens[$_] } 1 .. @mertens;\n", "target": "def mertens(count):\n    \n    m = [None, 1]\n    for n in range(2, count+1):\n        m.append(1)\n        for k in range(2, n+1):\n            m[n] -= m[n//k]\n    return m\n    \n\nms = mertens(1000)\n\nprint(\"The first 99 Mertens numbers are:\")\nprint(\"  \", end=' ')\ncol = 1\nfor n in ms[1:100]:\n    print(\"{:2d}\".format(n), end=' ')\n    col += 1\n    if col == 10:\n        print()\n        col = 0\n        \nzeroes = sum(x==0 for x in ms)\ncrosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))\nprint(\"M(N) equals zero {} times.\".format(zeroes))\nprint(\"M(N) crosses zero {} times.\".format(crosses))\n"}
{"id": 383091, "name": "Product of divisors", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @products = ( 1 ) x 51;\nfor my $n ( 1 .. 50 )\n  {\n  $n % $_ or $products[$n] *= $_ for 1 .. $n;\n  }\nprintf '' . (('%11d' x 5) . \"\\n\") x 10, @products[1 .. 50];\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 383092, "name": "Product of divisors", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @products = ( 1 ) x 51;\nfor my $n ( 1 .. 50 )\n  {\n  $n % $_ or $products[$n] *= $_ for 1 .. $n;\n  }\nprintf '' . (('%11d' x 5) . \"\\n\") x 10, @products[1 .. 50];\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 383093, "name": "Playing cards", "source": "Translate Perl to Python: package Playing_Card_Deck;\n\nuse strict;\nuse warnings;\n\n@Playing_Card_Deck::suits = qw\n   [Diamonds Clubs Hearts Spades];\n@Playing_Card_Deck::pips = qw\n   [Two Three Four Five Six Seven Eight Nine Ten\n    Jack King Queen Ace];\n\n\n\n\n\nsub new\n\n {my $invocant = shift;\n  my $class = ref($invocant) || $invocant;\n  my @cards;\n  foreach my $suit (@Playing_Card_Deck::suits)\n     {foreach my $pip (@Playing_Card_Deck::pips)\n         {push(@cards, {suit => $suit, pip => $pip});}}\n  return bless([@cards], $class);}\n\nsub deal\n\n\n {return %{ shift( @{shift()} ) };}\n\nsub shuffle\n\n\n\n {our @deck; local *deck = shift;\n    \n  for (my $n = $\n     {my $k = int rand($n + 1);\n      @deck[$k, $n] = @deck[$n, $k] if $k != $n;}}\n\nsub print_cards\n\n {print \"$_->{pip} of $_->{suit}\\n\" foreach @{shift()};}\n", "target": "import random\n\nclass Card(object):\n    suits = (\"Clubs\",\"Hearts\",\"Spades\",\"Diamonds\")\n    pips = (\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"Jack\",\"Queen\",\"King\",\"Ace\")\n\n    def __init__(self, pip,suit):\n        self.pip=pip\n        self.suit=suit\n\n    def __str__(self):\n        return \"%s %s\"%(self.pip,self.suit)\n\nclass Deck(object):\n    def __init__(self):\n        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]\n\n    def __str__(self):\n        return \"[%s]\"%\", \".join( (str(card) for card in self.deck))\n\n    def shuffle(self):\n        random.shuffle(self.deck)\n\n    def deal(self):\n        self.shuffle()  \n        return self.deck.pop(0)\n"}
{"id": 383094, "name": "Coprimes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'gcd';\n\nprintf \"%7s %s\\n\", (gcd(@$_) == 1 ? 'Coprime' : ''), join ', ', @$_\n     for [21,15], [17,23], [36,12], [18,29], [60,15], [21,22,25,31,143];\n", "target": "\n\nfrom math import gcd\n\n\n\ndef coprime(a, b):\n    \n    return 1 == gcd(a, b)\n\n\n\n\ndef main():\n    \n\n    print([\n        xy for xy in [\n            (21, 15), (17, 23), (36, 12),\n            (18, 29), (60, 15)\n        ]\n        if coprime(*xy)\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383095, "name": "Coprimes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'gcd';\n\nprintf \"%7s %s\\n\", (gcd(@$_) == 1 ? 'Coprime' : ''), join ', ', @$_\n     for [21,15], [17,23], [36,12], [18,29], [60,15], [21,22,25,31,143];\n", "target": "\n\nfrom math import gcd\n\n\n\ndef coprime(a, b):\n    \n    return 1 == gcd(a, b)\n\n\n\n\ndef main():\n    \n\n    print([\n        xy for xy in [\n            (21, 15), (17, 23), (36, 12),\n            (18, 29), (60, 15)\n        ]\n        if coprime(*xy)\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383096, "name": "Perfect totient numbers", "source": "Translate Perl to Python: use ntheory qw(euler_phi);\n\nsub phi_iter {\n    my($p) = @_;\n    euler_phi($p) + ($p == 2 ? 0 : phi_iter(euler_phi($p)));\n}\n\nmy @perfect;\nfor (my $p = 2; @perfect < 20 ; ++$p) {\n    push @perfect, $p if $p == phi_iter($p);\n}\n\nprintf \"The first twenty perfect totient numbers:\\n%s\\n\", join ' ', @perfect;\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 383097, "name": "Perfect totient numbers", "source": "Translate Perl to Python: use ntheory qw(euler_phi);\n\nsub phi_iter {\n    my($p) = @_;\n    euler_phi($p) + ($p == 2 ? 0 : phi_iter(euler_phi($p)));\n}\n\nmy @perfect;\nfor (my $p = 2; @perfect < 20 ; ++$p) {\n    push @perfect, $p if $p == phi_iter($p);\n}\n\nprintf \"The first twenty perfect totient numbers:\\n%s\\n\", join ' ', @perfect;\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 383098, "name": "Lah numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(factorial);\nuse List::Util qw(max);\n\nsub Lah {\n    my($n, $k) = @_;\n    return factorial($n) if $k == 1;\n    return 1 if $k == $n;\n    return 0 if $k > $n;\n    return 0 if $k < 1 or $n < 1;\n    (factorial($n) * factorial($n - 1)) / (factorial($k) * factorial($k - 1)) / factorial($n - $k)\n}\n\nmy $upto = 12;\nmy $mx   = 1 + length max map { Lah(12,$_) } 0..$upto;\n\nsay 'Unsigned Lah numbers:  L(n, k):';\nprint 'n\\k' . sprintf \"%${mx}s\"x(1+$upto).\"\\n\", 0..1+$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    map { printf \"%${mx}d\", Lah($row, $_) } 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the L(100, *) row:\";\nsay max map { Lah(100,$_) } 0..100;\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383099, "name": "Lah numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(factorial);\nuse List::Util qw(max);\n\nsub Lah {\n    my($n, $k) = @_;\n    return factorial($n) if $k == 1;\n    return 1 if $k == $n;\n    return 0 if $k > $n;\n    return 0 if $k < 1 or $n < 1;\n    (factorial($n) * factorial($n - 1)) / (factorial($k) * factorial($k - 1)) / factorial($n - $k)\n}\n\nmy $upto = 12;\nmy $mx   = 1 + length max map { Lah(12,$_) } 0..$upto;\n\nsay 'Unsigned Lah numbers:  L(n, k):';\nprint 'n\\k' . sprintf \"%${mx}s\"x(1+$upto).\"\\n\", 0..1+$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    map { printf \"%${mx}d\", Lah($row, $_) } 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the L(100, *) row:\";\nsay max map { Lah(100,$_) } 0..100;\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383100, "name": "Two sum", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub two_sum{\n  my($sum,@numbers) = @_;\n  my $i = 0;\n  my $j = $\n  my @indices;\n  while ($i < $j) {\n    if    ($numbers[$i] + $numbers[$j] == $sum) { push @indices, ($i, $j); $i++; }\n    elsif ($numbers[$i] + $numbers[$j]  < $sum) { $i++ }\n    else                                        { $j-- }\n  }\n  return @indices\n}\n\nmy @numbers = <0 2 11 19 90>;\nmy @indices = two_sum(21, @numbers);\nsay join(', ', @indices) || 'No match';\n\n@indices = two_sum(25, @numbers);\nsay join(', ', @indices) || 'No match';\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 383101, "name": "Two sum", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub two_sum{\n  my($sum,@numbers) = @_;\n  my $i = 0;\n  my $j = $\n  my @indices;\n  while ($i < $j) {\n    if    ($numbers[$i] + $numbers[$j] == $sum) { push @indices, ($i, $j); $i++; }\n    elsif ($numbers[$i] + $numbers[$j]  < $sum) { $i++ }\n    else                                        { $j-- }\n  }\n  return @indices\n}\n\nmy @numbers = <0 2 11 19 90>;\nmy @indices = two_sum(21, @numbers);\nsay join(', ', @indices) || 'No match';\n\n@indices = two_sum(25, @numbers);\nsay join(', ', @indices) || 'No match';\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 383102, "name": "Sorting algorithms_Cocktail sort with shifting bounds", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub cocktail_sort {\n    my @a = @_;\n    my ($min, $max) = (0, $\n    while (1) {\n        my $swapped_forward = 0;\n        for my $i ($min .. $max) {\n            if ($a[$i] gt $a[$i+1]) {\n                @a[$i, $i+1] = @a[$i+1, $i];\n                $swapped_forward = 1\n            }\n        }\n        last if not $swapped_forward;\n        $max -= 1;\n\n        my $swapped_backward = 0;\n        for my $i (reverse $min .. $max) {\n            if ($a[$i] gt $a[$i+1]) {\n                @a[$i, $i+1] = @a[$i+1, $i];\n                $swapped_backward = 1;\n            }\n        }\n        last if not $swapped_backward;\n        $min += 1;\n    }\n    @a\n}\n\nsay join ' ', cocktail_sort( <t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g> );\n", "target": "\n            \ndef cocktailshiftingbounds(A):\n    beginIdx = 0\n    endIdx = len(A) - 1\n    \n    while beginIdx <= endIdx:\n        newBeginIdx = endIdx\n        newEndIdx = beginIdx\n        for ii in range(beginIdx,endIdx):\n            if A[ii] > A[ii + 1]:\n                A[ii+1], A[ii] = A[ii], A[ii+1]\n                newEndIdx = ii\n                \n        endIdx = newEndIdx\n    \n        for ii in range(endIdx,beginIdx-1,-1):\n            if A[ii] > A[ii + 1]:\n                A[ii+1], A[ii] = A[ii], A[ii+1]\n                newBeginIdx = ii\n        \n        beginIdx = newBeginIdx + 1\n            \ntest1 = [7, 6, 5, 9, 8, 4, 3, 1, 2, 0]\ncocktailshiftingbounds(test1)\nprint(test1)\n \ntest2=list('big fjords vex quick waltz nymph')\ncocktailshiftingbounds(test2)\nprint(''.join(test2))\n"}
{"id": 383103, "name": "Terminal control_Unicode output", "source": "Translate Perl to Python: die \"Terminal can't handle UTF-8\"\n    unless $ENV{LC_ALL} =~ /utf-8/i or $ENV{LC_CTYPE} =~ /utf-8/i or $ENV{LANG} =~ /utf-8/i;\n\nprint \"\u25b3 \\n\";\n", "target": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")\n"}
{"id": 383104, "name": "Terminal control_Unicode output", "source": "Translate Perl to Python: die \"Terminal can't handle UTF-8\"\n    unless $ENV{LC_ALL} =~ /utf-8/i or $ENV{LC_CTYPE} =~ /utf-8/i or $ENV{LANG} =~ /utf-8/i;\n\nprint \"\u25b3 \\n\";\n", "target": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")\n"}
{"id": 383105, "name": "Unprimeable numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\nuse enum qw(False True);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub is_unprimeable {\n    my($n) = @_;\n    return False if is_prime($n);\n    my $chrs = length $n;\n    for my $place (0..$chrs-1) {\n        my $pow = 10**($chrs - $place - 1);\n        my $this = substr($n, $place, 1) * $pow;\n        map { return False if $this != $_ and is_prime($n - $this + $_ * $pow) } 0..9;\n     }\n     True\n}\n\nmy($n, @ups);\ndo { push @ups, $n if is_unprimeable(++$n); } until @ups == 600;\nsay \"First 35 unprimeables:\\n\" . join ' ', @ups[0..34];\nprintf \"\\n600th unprimeable: %s\\n\", comma $ups[599];\n\nmap {\n    my $x = $_;\n    while ($x += 10) { last if is_unprimeable($x) }\n    say \"First unprimeable that ends with $_: \" . sprintf \"%9s\", comma $x;\n} 0..9;\n", "target": "from itertools import count, islice\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n, _seen={0: False, 1: False}):\n    def _isprime(n):\n        for p in primes():\n            if p*p > n:\n                return True\n            if n%p == 0:\n                return False\n\n    if n not in _seen:\n        _seen[n] = _isprime(n)\n    return _seen[n]\n\ndef unprime():\n    for a in count(1):\n        d = 1\n        while d <= a:\n            base = (a//(d*10))*(d*10) + (a%d) \n            if any(isprime(y) for y in range(base, base + d*10, d)):\n                break\n            d *= 10\n        else:\n            yield a\n\n\nprint('First 35:')\nprint(' '.join(str(i) for i in islice(unprime(), 35)))\n\nprint('\\nThe 600-th:')\nprint(list(islice(unprime(), 599, 600))[0])\nprint()\n\nfirst, need = [False]*10, 10\nfor p in unprime():\n    i = p%10\n    if first[i]: continue\n\n    first[i] = p\n    need -= 1\n    if not need:\n        break\n\nfor i,v in enumerate(first):\n    print(f'{i} ending: {v}')\n"}
{"id": 383106, "name": "Tau number", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy(@x,$n);\n\ndo { push(@x,$n) unless $n % scalar(divisors(++$n)) } until 100 == @x;\n\nsay \"Tau numbers - first 100:\\n\" .\n    ((sprintf \"@{['%5d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "def tau(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans, i, j = 0, 1, 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans += 1\n            j = n//i\n            if j != i:\n                ans += 1\n        i += 1\n    return ans\n\ndef is_tau_number(n):\n    assert(isinstance(n, int))\n    if n <= 0:\n        return False\n    return 0 == n%tau(n)\n\nif __name__ == \"__main__\":\n    n = 1\n    ans = []\n    while len(ans) < 100:\n        if is_tau_number(n):\n            ans.append(n)\n        n += 1\n    print(ans)\n"}
{"id": 383107, "name": "Primes whose sum of digits is 25", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\nuse ntheory 'is_prime';\n\nmy($limit, @p25) = 5000;\nis_prime($_) and 25 == sum(split '', $_) and push @p25, $_ for 1..$limit;\nsay @p25 . \" primes < $limit with digital sum 25:\\n\" . join ' ', @p25;\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef primesWithGivenDigitSum(below, n):\n    \n    return list(\n        takewhile(\n            lambda x: below > x,\n            (\n                x for x in primes()\n                if n == sum(int(c) for c in str(x))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n    matches = primesWithGivenDigitSum(5000, 25)\n    print(\n        str(len(matches)) + (\n            ' primes below 5000 with a decimal digit sum of 25:\\n'\n        )\n    )\n    print(\n        '\\n'.join([\n            ' '.join([str(x).rjust(4, ' ') for x in xs])\n            for xs in chunksOf(4)(matches)\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383108, "name": "Primes whose sum of digits is 25", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\nuse ntheory 'is_prime';\n\nmy($limit, @p25) = 5000;\nis_prime($_) and 25 == sum(split '', $_) and push @p25, $_ for 1..$limit;\nsay @p25 . \" primes < $limit with digital sum 25:\\n\" . join ' ', @p25;\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef primesWithGivenDigitSum(below, n):\n    \n    return list(\n        takewhile(\n            lambda x: below > x,\n            (\n                x for x in primes()\n                if n == sum(int(c) for c in str(x))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n    matches = primesWithGivenDigitSum(5000, 25)\n    print(\n        str(len(matches)) + (\n            ' primes below 5000 with a decimal digit sum of 25:\\n'\n        )\n    )\n    print(\n        '\\n'.join([\n            ' '.join([str(x).rjust(4, ' ') for x in xs])\n            for xs in chunksOf(4)(matches)\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383109, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy @queue = my @primedigits = ( 2, 3, 5, 7 );\nmy $numbers;\n\nwhile( my $n = shift @queue )\n  {\n  if( eval $n == 13 )\n    {\n    $numbers .= $n =~ tr/+//dr . \" \";\n    }\n  elsif( eval $n < 13 )\n    {\n    push @queue, map \"$n+$_\", @primedigits;\n    }\n  }\nprint $numbers =~ s/.{1,80}\\K /\\n/gr;\n", "target": "from collections import deque\n\ndef prime_digits_sum(r):\n    q = deque([(r, 0)])\n    while q:\n        r, n = q.popleft()\n        for d in 2, 3, 5, 7:\n            if d >= r:\n                if d == r: yield n + d\n                break\n            q.append((r - d, (n + d) * 10))\n\nprint(*prime_digits_sum(13))\n"}
{"id": 383110, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy @queue = my @primedigits = ( 2, 3, 5, 7 );\nmy $numbers;\n\nwhile( my $n = shift @queue )\n  {\n  if( eval $n == 13 )\n    {\n    $numbers .= $n =~ tr/+//dr . \" \";\n    }\n  elsif( eval $n < 13 )\n    {\n    push @queue, map \"$n+$_\", @primedigits;\n    }\n  }\nprint $numbers =~ s/.{1,80}\\K /\\n/gr;\n", "target": "from collections import deque\n\ndef prime_digits_sum(r):\n    q = deque([(r, 0)])\n    while q:\n        r, n = q.popleft()\n        for d in 2, 3, 5, 7:\n            if d >= r:\n                if d == r: yield n + d\n                break\n            q.append((r - d, (n + d) * 10))\n\nprint(*prime_digits_sum(13))\n"}
{"id": 383111, "name": "Deepcopy", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\nuse Storable;\nuse Data::Dumper;\n\nmy $src = { foo => 0, bar => [0, 1] };\n$src->{baz} = $src;\nmy $dst = Storable::dclone($src);\nprint Dumper($src);\nprint Dumper($dst);\n", "target": "import copy\ndeepcopy_of_obj = copy.deepcopy(obj)\n"}
{"id": 383112, "name": "Deepcopy", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\nuse Storable;\nuse Data::Dumper;\n\nmy $src = { foo => 0, bar => [0, 1] };\n$src->{baz} = $src;\nmy $dst = Storable::dclone($src);\nprint Dumper($src);\nprint Dumper($dst);\n", "target": "import copy\ndeepcopy_of_obj = copy.deepcopy(obj)\n"}
{"id": 383113, "name": "Circular primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'min';\nuse ntheory 'is_prime';\n\nsub rotate { my($i,@a) = @_; join '', @a[$i .. @a-1, 0 .. $i-1] }\n\nsub isCircular {\n    my ($n) = @_;\n    return 0 unless is_prime($n);\n    my @circular = split //, $n;\n    return 0 if min(@circular) < $circular[0];\n    for (1 .. scalar @circular) {\n        my $r = join '', rotate($_,@circular);\n        return 0 unless is_prime($r) and $r >= $n;\n    }\n    1\n}\n\nsay \"The first 19 circular primes are:\";\nfor ( my $i = 1, my $count = 0; $count < 19; $i++ ) {\n    ++$count and print \"$i \" if isCircular($i);\n}\n\nsay \"\\n\\nThe next 4 circular primes, in repunit format, are:\";\nfor ( my $i = 7, my $count = 0; $count < 4; $i++ ) {\n    ++$count and say \"R($i)\" if is_prime 1 x $i\n}\n\nsay \"\\nRepunit testing:\";\n\nfor (5003, 9887, 15073, 25031, 35317, 49081) {\n    say \"R($_): Prime? \" . (is_prime 1 x $_ ? 'True' : 'False');\n}\n", "target": "import random\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n\n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n\n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True\n\n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n\n    return True\n\ndef isPrime(n: int) -> bool:\n    \n    \n    if (n <= 1) :\n        return False\n    if (n <= 3) :\n        return True\n    \n    \n    if (n % 2 == 0 or n % 3 == 0) :\n        return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\ndef rotations(n: int)-> set((int,)):\n    \n    a = str(n)\n    return set(int(a[i:] + a[:i]) for i in range(len(a)))\n\ndef isCircular(n: int) -> bool:\n    \n    return all(isPrime(int(o)) for o in rotations(n))\n\nfrom itertools import product\n\ndef main():\n    result = [2, 3, 5, 7]\n    first = '137'\n    latter = '1379'\n    for i in range(1, 6):\n        s = set(int(''.join(a)) for a in product(first, *((latter,) * i)))\n        while s:\n            a = s.pop()\n            b = rotations(a)\n            if isCircular(a):\n                result.append(min(b))\n            s -= b\n    result.sort()\n    return result\n\nassert [2, 3, 5, 7, 11, 13, 17, 37, 79, 113, 197, 199, 337, 1193, 3779, 11939, 19937, 193939, 199933] == main()\n\n\nrepunit = lambda n: int('1' * n)\n\ndef repmain(n: int) -> list:\n    \n    result = []\n    i = 2\n    while len(result) < n:\n        if is_Prime(repunit(i)):\n            result.append(i)\n        i += 1\n    return result\n\nassert [2, 19, 23, 317, 1031] == repmain(5)\n\n\n"}
{"id": 383114, "name": "Frobenius numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <nth_prime primes>;\nuse List::MoreUtils qw(slide);\n\n\nmy(@F,$n);\ndo { ++$n and push @F, nth_prime($n) * nth_prime($n+1) - (nth_prime($n) + nth_prime($n+1)) } until $F[-1] >= 10000;\nsay \"$\n\n\nmy $limit = 10_000;\nsay \"\\n\" . join ' ', grep { $_ < $limit } slide { $a * $b - $a - $b } @{primes($limit)};\n", "target": "\n\ndef isPrime(v):\n  if v <= 1:\n    return False\n  if v < 4:\n    return True\n  if v % 2 == 0:\n    return False\n  if v < 9:\n    return True\n  if v % 3 == 0:\n    return False\n  else:\n    r = round(pow(v,0.5))\n    f = 5\n    while f <= r:\n      if v % f == 0 or v % (f + 2) == 0:\n        return False\n      f += 6\n    return True\n\npn = 2\nn = 0\nfor i in range(3, 9999, 2):\n  if isPrime(i):\n    n += 1\n    f = (pn * i) - pn - i\n    if f > 10000:\n      break\n    print (n, ' => ', f)\n    pn = i\n"}
{"id": 383115, "name": "Frobenius numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <nth_prime primes>;\nuse List::MoreUtils qw(slide);\n\n\nmy(@F,$n);\ndo { ++$n and push @F, nth_prime($n) * nth_prime($n+1) - (nth_prime($n) + nth_prime($n+1)) } until $F[-1] >= 10000;\nsay \"$\n\n\nmy $limit = 10_000;\nsay \"\\n\" . join ' ', grep { $_ < $limit } slide { $a * $b - $a - $b } @{primes($limit)};\n", "target": "\n\ndef isPrime(v):\n  if v <= 1:\n    return False\n  if v < 4:\n    return True\n  if v % 2 == 0:\n    return False\n  if v < 9:\n    return True\n  if v % 3 == 0:\n    return False\n  else:\n    r = round(pow(v,0.5))\n    f = 5\n    while f <= r:\n      if v % f == 0 or v % (f + 2) == 0:\n        return False\n      f += 6\n    return True\n\npn = 2\nn = 0\nfor i in range(3, 9999, 2):\n  if isPrime(i):\n    n += 1\n    f = (pn * i) - pn - i\n    if f > 10000:\n      break\n    print (n, ' => ', f)\n    pn = i\n"}
{"id": 383116, "name": "Sorting algorithms_Permutation sort", "source": "Translate Perl to Python: sub psort {\n        my ($x, $d) = @_;\n\n        unless ($d //= $\n                $x->[$_] < $x->[$_ - 1] and return for 1 .. $\n                return 1\n        }\n        \n        for (0 .. $d) {\n                unshift @$x, splice @$x, $d, 1;\n                next if $x->[$d] < $x->[$d - 1];\n                return 1 if psort($x, $d - 1);\n        }\n}\n\nmy @a = map+(int rand 100), 0 .. 10;\nprint \"Before:\\t@a\\n\";\npsort(\\@a);\nprint \"After:\\t@a\\n\"\n", "target": "from itertools import permutations\n\nin_order = lambda s: all(x <= s[i+1] for i,x in enumerate(s[:-1]))\nperm_sort = lambda s: (p for p in permutations(s) if in_order(p)).next()\n"}
{"id": 383117, "name": "Integer roots", "source": "Translate Perl to Python: use bigint;\n\nsub integer_root {\n    our($a,$b) = @_;\n    our $a1 = $a - 1;\n    my $c = 1;\n    my $d = f($c);\n    my $e = f($d);\n    ($c, $d, $e) = ($d, $e, f($e)) until $c==$d || $c==$e;\n    return $d < $e ? $d : $e;\n\n    sub f { ($a1*$_[0]+$b/$_[0]**$a1)/$a }\n}\n\nprint integer_root( 3, 8), \"\\n\";\nprint integer_root( 3, 9), \"\\n\";\nprint integer_root( 2, 2 * 100 ** 2000), \"\\n\";\n", "target": "def root(a, b):\n    if b < 2:\n        return b\n    a1 = a - 1\n    c = 1\n    d = (a1 * c + b // (c ** a1)) // a\n    e = (a1 * d + b // (d ** a1)) // a\n    while c not in (d, e):\n        c, d, e = d, e, (a1 * e + b // (e ** a1)) // a\n    return min(d, e)\n\n\nprint(\"First 2,001 digits of the square root of two:\\n{}\".format(\n    root(2, 2 * 100 ** 2000)\n))\n"}
{"id": 383118, "name": "Integer roots", "source": "Translate Perl to Python: use bigint;\n\nsub integer_root {\n    our($a,$b) = @_;\n    our $a1 = $a - 1;\n    my $c = 1;\n    my $d = f($c);\n    my $e = f($d);\n    ($c, $d, $e) = ($d, $e, f($e)) until $c==$d || $c==$e;\n    return $d < $e ? $d : $e;\n\n    sub f { ($a1*$_[0]+$b/$_[0]**$a1)/$a }\n}\n\nprint integer_root( 3, 8), \"\\n\";\nprint integer_root( 3, 9), \"\\n\";\nprint integer_root( 2, 2 * 100 ** 2000), \"\\n\";\n", "target": "def root(a, b):\n    if b < 2:\n        return b\n    a1 = a - 1\n    c = 1\n    d = (a1 * c + b // (c ** a1)) // a\n    e = (a1 * d + b // (d ** a1)) // a\n    while c not in (d, e):\n        c, d, e = d, e, (a1 * e + b // (e ** a1)) // a\n    return min(d, e)\n\n\nprint(\"First 2,001 digits of the square root of two:\\n{}\".format(\n    root(2, 2 * 100 ** 2000)\n))\n"}
{"id": 383119, "name": "Fortunate numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util <first uniq>;\nuse ntheory qw<pn_primorial is_prime>;\n\nmy $upto = 50;\nmy @candidates;\nfor my $p ( map { pn_primorial($_) } 1..2*$upto ) {\n    push @candidates, first { is_prime($_ + $p) } 2..100*$upto;\n}\n\nmy @fortunate = sort { $a <=> $b } uniq grep { is_prime $_ } @candidates;\n\nprint \"First $upto distinct fortunate numbers:\\n\" .\n    (sprintf \"@{['%6d' x $upto]}\", @fortunate) =~ s/(.{60})/$1\\n/gr;\n", "target": "from sympy.ntheory.generate import primorial\nfrom sympy.ntheory import isprime\n\ndef fortunate_number(n):\n    \n    \n    \n    i = 3\n    primorial_ = primorial(n)\n    while True:\n        if isprime(primorial_ + i):\n            return i\n        i += 2\n\nfortunate_numbers = set()\nfor i in range(1, 76):\n    fortunate_numbers.add(fortunate_number(i))\n\n\nfirst50 = sorted(list(fortunate_numbers))[:50]\n\nprint('The first 50 fortunate numbers:')\nprint(('{:<3} ' * 10).format(*(first50[:10])))\nprint(('{:<3} ' * 10).format(*(first50[10:20])))\nprint(('{:<3} ' * 10).format(*(first50[20:30])))\nprint(('{:<3} ' * 10).format(*(first50[30:40])))\nprint(('{:<3} ' * 10).format(*(first50[40:])))\n"}
{"id": 383120, "name": "Modulinos", "source": "Translate Perl to Python: \n\n\npackage Life;\n\nuse strict;\nuse warnings;\n\nsub meaning_of_life {\n\treturn 42;\n}\n\nunless(caller) {\n\tprint \"Main: The meaning of life is \" . meaning_of_life() . \"\\n\";\n}\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 383121, "name": "Modulinos", "source": "Translate Perl to Python: \n\n\npackage Life;\n\nuse strict;\nuse warnings;\n\nsub meaning_of_life {\n\treturn 42;\n}\n\nunless(caller) {\n\tprint \"Main: The meaning of life is \" . meaning_of_life() . \"\\n\";\n}\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 383122, "name": "Function frequency", "source": "Translate Perl to Python: use PPI::Tokenizer;\nmy $Tokenizer = PPI::Tokenizer->new( '/path/to/your/script.pl' );\nmy %counts;\nwhile (my $token = $Tokenizer->get_token) {\n    \n    if ($token =~ /\\A[\\$\\@\\%*[:alpha:]]/) {\n        $counts{$token}++;\n    }\n}\nmy @desc_by_occurrence =\n    sort {$counts{$b} <=> $counts{$a} || $a cmp $b}\n         keys(%counts);\nmy @top_ten_by_occurrence = @desc_by_occurrence[0 .. 9];\nforeach my $token (@top_ten_by_occurrence) {\n    print $counts{$token}, \"\\t\", $token, \"\\n\";\n}\n", "target": "import ast\n\nclass CallCountingVisitor(ast.NodeVisitor):\n\n    def __init__(self):\n        self.calls = {}\n\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Name):\n            fun_name = node.func.id\n            call_count = self.calls.get(fun_name, 0)\n            self.calls[fun_name] = call_count + 1\n        self.generic_visit(node)\n\nfilename = input('Enter a filename to parse: ')\nwith open(filename, encoding='utf-8') as f:\n    contents = f.read()\nroot = ast.parse(contents, filename=filename) \nvisitor = CallCountingVisitor()\nvisitor.visit(root)\ntop10 = sorted(visitor.calls.items(), key=lambda x: x[1], reverse=True)[:10]\nfor name, count in top10:\n    print(name,'called',count,'times')\n"}
{"id": 383123, "name": "Table creation", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse DBI;\n \nmy $dbh = DBI->connect(\"dbi:SQLite:dbname=:memory:\");\n\n$dbh->do(\"CREATE TABLE stocks (\n   date TEXT, trans TEXT, symbol TEXT, qty REAL, price REAL \n)\");\n\nmy $sth = $dbh->prepare( \"INSERT INTO stocks VALUES (?,?,?,?,?)\" );\n\nmy @DATA = ( '\"2006-01-05\",\"BUY\", \"RHAT\",  100, 35.14',\n             '\"2006-03-28\",\"BUY\",  \"IBM\", 1000, 45.00',\n             '\"2006-04-05\",\"BUY\",\"MSOFT\", 1000, 72.00',\n             '\"2006-04-06\",\"SELL\", \"IBM\",  500,  53.00' );\n\nfor ( @DATA ) { $sth->execute( split /,/ ) or die }\n\n$sth = $dbh->prepare(\"SELECT * FROM stocks ORDER BY price\") or die;\n\n$sth->execute();\n\nmy $format = \"%-15s\u00a0%-15s\u00a0%-15s\u00a0%-15s\u00a0%-15s\\n\";\n\nprintf $format, $sth->{NAME}->@* ;\n\nprint '=' x 75 , \"\\n\";\n\nwhile ( my @row = $sth->fetchrow_array ) { printf $format, @row }\n", "target": ">>> import sqlite3\n>>> conn = sqlite3.connect(':memory:')\n>>> c = conn.cursor()\n>>> c.execute()\n<sqlite3.Cursor object at 0x013263B0>\n>>> \nc.execute()\n\n<sqlite3.Cursor object at 0x013263B0>\n>>> for t in [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),\n          ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),\n          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),\n         ]:\n\tc.execute('insert into stocks values (?,?,?,?,?)', t)\n\n\t\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n>>> \n>>> c = conn.cursor()\n>>> c.execute('select * from stocks order by price')\n<sqlite3.Cursor object at 0x01326530>\n>>> for row in c:\n\tprint row\n\n\t\n(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.140000000000001)\n(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)\n(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)\n(u'2006-04-05', u'BUY', u'MSOFT', 1000.0, 72.0)\n>>>\n"}
{"id": 383124, "name": "Table creation", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse DBI;\n \nmy $dbh = DBI->connect(\"dbi:SQLite:dbname=:memory:\");\n\n$dbh->do(\"CREATE TABLE stocks (\n   date TEXT, trans TEXT, symbol TEXT, qty REAL, price REAL \n)\");\n\nmy $sth = $dbh->prepare( \"INSERT INTO stocks VALUES (?,?,?,?,?)\" );\n\nmy @DATA = ( '\"2006-01-05\",\"BUY\", \"RHAT\",  100, 35.14',\n             '\"2006-03-28\",\"BUY\",  \"IBM\", 1000, 45.00',\n             '\"2006-04-05\",\"BUY\",\"MSOFT\", 1000, 72.00',\n             '\"2006-04-06\",\"SELL\", \"IBM\",  500,  53.00' );\n\nfor ( @DATA ) { $sth->execute( split /,/ ) or die }\n\n$sth = $dbh->prepare(\"SELECT * FROM stocks ORDER BY price\") or die;\n\n$sth->execute();\n\nmy $format = \"%-15s\u00a0%-15s\u00a0%-15s\u00a0%-15s\u00a0%-15s\\n\";\n\nprintf $format, $sth->{NAME}->@* ;\n\nprint '=' x 75 , \"\\n\";\n\nwhile ( my @row = $sth->fetchrow_array ) { printf $format, @row }\n", "target": ">>> import sqlite3\n>>> conn = sqlite3.connect(':memory:')\n>>> c = conn.cursor()\n>>> c.execute()\n<sqlite3.Cursor object at 0x013263B0>\n>>> \nc.execute()\n\n<sqlite3.Cursor object at 0x013263B0>\n>>> for t in [('2006-03-28', 'BUY', 'IBM', 1000, 45.00),\n          ('2006-04-05', 'BUY', 'MSOFT', 1000, 72.00),\n          ('2006-04-06', 'SELL', 'IBM', 500, 53.00),\n         ]:\n\tc.execute('insert into stocks values (?,?,?,?,?)', t)\n\n\t\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n<sqlite3.Cursor object at 0x013263B0>\n>>> \n>>> c = conn.cursor()\n>>> c.execute('select * from stocks order by price')\n<sqlite3.Cursor object at 0x01326530>\n>>> for row in c:\n\tprint row\n\n\t\n(u'2006-01-05', u'BUY', u'RHAT', 100.0, 35.140000000000001)\n(u'2006-03-28', u'BUY', u'IBM', 1000.0, 45.0)\n(u'2006-04-06', u'SELL', u'IBM', 500.0, 53.0)\n(u'2006-04-05', u'BUY', u'MSOFT', 1000.0, 72.0)\n>>>\n"}
{"id": 383125, "name": "Nice primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse ntheory 'is_prime';\nuse List::Util qw(sum);\n\nsub digital_root {\n    my ($n) = @_;\n    do { $n = sum split '', $n } until 1 == length $n;\n    $n\n}\n\nmy($low, $high, $cnt, @nice_primes) = (500,1000);\nis_prime($_) and is_prime(digital_root($_)) and push @nice_primes, $_ for $low+1 .. $high-1;\n\n$cnt = @nice_primes;\nprint \"Nice primes between $low and $high (total of $cnt):\\n\" .\n(sprintf \"@{['%5d' x $cnt]}\", @nice_primes[0..$cnt-1]) =~ s/(.{55})/$1\\n/gr;\n", "target": "nicePrimes( s, e ) = { local( m );\n    forprime( p = s, e,\n        m = p;                      \\\\\n        while( m > 9,               \\\\   m == p mod 9\n            m = sumdigits( m ) );   \\\\\n        if( isprime( m ),\n            print1( p, \" \" ) ) ); \n}\n"}
{"id": 383126, "name": "Nice primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse ntheory 'is_prime';\nuse List::Util qw(sum);\n\nsub digital_root {\n    my ($n) = @_;\n    do { $n = sum split '', $n } until 1 == length $n;\n    $n\n}\n\nmy($low, $high, $cnt, @nice_primes) = (500,1000);\nis_prime($_) and is_prime(digital_root($_)) and push @nice_primes, $_ for $low+1 .. $high-1;\n\n$cnt = @nice_primes;\nprint \"Nice primes between $low and $high (total of $cnt):\\n\" .\n(sprintf \"@{['%5d' x $cnt]}\", @nice_primes[0..$cnt-1]) =~ s/(.{55})/$1\\n/gr;\n", "target": "nicePrimes( s, e ) = { local( m );\n    forprime( p = s, e,\n        m = p;                      \\\\\n        while( m > 9,               \\\\   m == p mod 9\n            m = sumdigits( m ) );   \\\\\n        if( isprime( m ),\n            print1( p, \" \" ) ) ); \n}\n"}
{"id": 383127, "name": "Find the last Sunday of each month", "source": "Translate Perl to Python: \nuse strict ;\nuse warnings ;\nuse DateTime ;\n\nfor my $i( 1..12 ) {\n   my $date = DateTime->last_day_of_month( year => $ARGV[ 0 ] , \n\t month => $i ) ;\n   while ( $date->dow != 7 ) {\n      $date = $date->subtract( days => 1 ) ;\n   }\n   my $ymd = $date->ymd ;\n   print \"$ymd\\n\" ;\n}\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 383128, "name": "Find the last Sunday of each month", "source": "Translate Perl to Python: \nuse strict ;\nuse warnings ;\nuse DateTime ;\n\nfor my $i( 1..12 ) {\n   my $date = DateTime->last_day_of_month( year => $ARGV[ 0 ] , \n\t month => $i ) ;\n   while ( $date->dow != 7 ) {\n      $date = $date->subtract( days => 1 ) ;\n   }\n   my $ymd = $date->ymd ;\n   print \"$ymd\\n\" ;\n}\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 383129, "name": "Random Latin squares", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'shuffle';\n\nsub random_ls {\n    my($n) = @_;\n    my(@cols,@symbols,@ls_sym);\n\n    \n    my @ls = [0,];\n    for my $i (1..$n-1) {\n        @{$ls[$i]} = @{$ls[0]};\n        splice(@{$ls[$_]}, $_, 0, $i) for 0..$i;\n    }\n\n    \n    @cols = shuffle 0..$n-1;\n    @ls = map [ @{$_}[@cols] ], @ls[shuffle 0..$n-1];\n\n    \n    @symbols = shuffle( ('A'..'Z')[0..$n-1] );\n    push @ls_sym, [@symbols[@$_]] for @ls;\n    @ls_sym\n}\n\nsub display {\n    my $str;\n    $str .= join(' ', @$_) . \"\\n\" for @_;\n    $str\n}\n\nsay display random_ls($_) for 2..5, 5;\n", "target": "from random import choice, shuffle\nfrom copy import deepcopy\n\ndef rls(n):\n    if n <= 0:\n        return []\n    else:\n        symbols = list(range(n))\n        square = _rls(symbols)\n        return _shuffle_transpose_shuffle(square)\n\n\ndef _shuffle_transpose_shuffle(matrix):\n    square = deepcopy(matrix)\n    shuffle(square)\n    trans = list(zip(*square))\n    shuffle(trans)\n    return trans\n\n\ndef _rls(symbols):\n    n = len(symbols)\n    if n == 1:\n        return [symbols]\n    else:\n        sym = choice(symbols)\n        symbols.remove(sym)\n        square = _rls(symbols)\n        square.append(square[0].copy())\n        for i in range(n):\n            square[i].insert(i, sym)\n        return square\n\ndef _to_text(square):\n    if square:\n        width = max(len(str(sym)) for row in square for sym in row)\n        txt = '\\n'.join(' '.join(f\"{sym:>{width}}\" for sym in row)\n                        for row in square)\n    else:\n        txt = ''\n    return txt\n\ndef _check(square):\n    transpose = list(zip(*square))\n    assert _check_rows(square) and _check_rows(transpose), \\\n        \"Not a Latin square\"\n\ndef _check_rows(square):\n    if not square:\n        return True\n    set_row0 = set(square[0])\n    return all(len(row) == len(set(row)) and set(row) == set_row0\n               for row in square)\n\n\nif __name__ == '__main__':\n    for i in [3, 3,  5, 5, 12]:\n        square = rls(i)\n        print(_to_text(square))\n        _check(square)\n        print()\n"}
{"id": 383130, "name": "Teacup rim text", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util qw(uniqstr any);\n\nmy(%words,@teacups,%seen);\n\nopen my $fh, '<', 'ref/wordlist.10000';\nwhile (<$fh>) {\n    chomp(my $w = uc $_);\n    next if length $w < 3;\n    push @{$words{join '', sort split //, $w}}, $w;}\n\nfor my $these (values %words) {\n    next if @$these < 3;\n    MAYBE: for (@$these) {\n        my $maybe = $_;\n        next if $seen{$_};\n        my @print;\n        for my $i (0 .. length $maybe) {\n            if (any { $maybe eq $_ } @$these) {\n                push @print, $maybe;\n                $maybe = substr($maybe,1) . substr($maybe,0,1)\n            } else {\n                @print = () and next MAYBE\n            }\n        }\n        if (@print) {\n            push @teacups, [@print];\n            $seen{$_}++ for @print;\n        }\n    }\n}\n\nsay join ', ', uniqstr @$_ for sort @teacups;\n", "target": "\n\nfrom itertools import chain, groupby\nfrom os.path import expanduser\nfrom functools import reduce\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        concatMap(circularGroup)(\n            anagrams(3)(\n                \n                lines(readFile('~/mitWords.txt'))\n            )\n        )\n    ))\n\n\n\ndef anagrams(n):\n    \n    def go(ws):\n        def f(xs):\n            return [\n                [snd(x) for x in xs]\n            ] if n <= len(xs) >= len(xs[0][0]) else []\n        return concatMap(f)(groupBy(fst)(sorted(\n            [(''.join(sorted(w)), w) for w in ws],\n            key=fst\n        )))\n    return go\n\n\n\ndef circularGroup(ws):\n    \n    lex = set(ws)\n    iLast = len(ws) - 1\n    \n    \n    (i, blnCircular) = until(\n        lambda tpl: tpl[1] or (tpl[0] > iLast)\n    )(\n        lambda tpl: (1 + tpl[0], isCircular(lex)(ws[tpl[0]]))\n    )(\n        (0, False)\n    )\n    return [' -> '.join(allRotations(ws[i]))] if blnCircular else []\n\n\n\ndef isCircular(lexicon):\n    \n    def go(w):\n        def f(tpl):\n            (i, _, x) = tpl\n            return (1 + i, x in lexicon, rotated(x))\n\n        iLast = len(w) - 1\n        return until(\n            lambda tpl: iLast < tpl[0] or (not tpl[1])\n        )(f)(\n            (0, True, rotated(w))\n        )[1]\n    return go\n\n\n\ndef allRotations(w):\n    \n    return takeIterate(len(w) - 1)(\n        rotated\n    )(w)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef groupBy(f):\n    \n    def go(xs):\n        return [\n            list(x[1]) for x in groupby(xs, key=f)\n        ]\n    return go\n\n\n\ndef lines(s):\n    \n    return s.splitlines()\n\n\n\ndef mapAccumL(f):\n    \n    def go(a, x):\n        tpl = f(a[0], x)\n        return (tpl[0], a[1] + [tpl[1]])\n    return lambda acc: lambda xs: (\n        reduce(go, xs, (acc, []))\n    )\n\n\n\ndef readFile(fp):\n    \n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\ndef rotated(s):\n    \n    return s[1:] + s[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef takeIterate(n):\n    \n    def go(f):\n        def g(x):\n            def h(a, i):\n                v = f(a) if i else x\n                return (v, v)\n            return mapAccumL(h)(x)(\n                range(0, 1 + n)\n            )[1]\n        return g\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383131, "name": "Fairshare between two and more", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::AnyNum qw(sum polymod);\n\nsub fairshare {\n    my($b, $n) = @_;\n    sprintf '%3d'x$n, map { sum ( polymod($_, $b, $b )) % $b } 0 .. $n-1;\n}\n\nfor (<2 3 5 11>) {\n    printf \"%3s:%s\\n\", $_, fairshare($_, 25);\n}\n", "target": "from itertools import count, islice\n\ndef _basechange_int(num, b):\n    \n    if num == 0:\n        return [0]\n    result = []\n    while num != 0:\n        num, d = divmod(num, b)\n        result.append(d)\n    return result[::-1]\n\ndef fairshare(b=2):\n    for i in count():\n        yield sum(_basechange_int(i, b)) % b\n\nif __name__ == '__main__':\n    for b in (2, 3, 5, 11):\n        print(f\"{b:>2}: {str(list(islice(fairshare(b), 25)))[1:-1]}\")\n"}
{"id": 383132, "name": "Esthetic numbers", "source": "Translate Perl to Python: use 5.020;\nuse warnings;\nuse experimental qw(signatures);\n\nuse ntheory qw(fromdigits todigitstring);\n\nsub generate_esthetic ($root, $upto, $callback, $base = 10) {\n\n    my $v = fromdigits($root, $base);\n\n    return if ($v > $upto);\n    $callback->($v);\n\n    my $t = $root->[-1];\n\n    __SUB__->([@$root, $t + 1], $upto, $callback, $base) if ($t + 1 < $base);\n    __SUB__->([@$root, $t - 1], $upto, $callback, $base) if ($t - 1 >= 0);\n}\n\nsub between_esthetic ($from, $upto, $base = 10) {\n    my @list;\n    foreach my $k (1 .. $base - 1) {\n        generate_esthetic([$k], $upto,\n            sub($n) { push(@list, $n) if ($n >= $from) }, $base);\n    }\n    sort { $a <=> $b } @list;\n}\n\nsub first_n_esthetic ($n, $base = 10) {\n    for (my $m = $n * $n ; 1 ; $m *= $base) {\n        my @list = between_esthetic(1, $m, $base);\n        return @list[0 .. $n - 1] if @list >= $n;\n    }\n}\n\nforeach my $base (2 .. 16) {\n    say \"\\n$base-esthetic numbers at indices ${\\(4*$base)}..${\\(6*$base)}:\";\n    my @list = first_n_esthetic(6 * $base, $base);\n    say join(' ', map { todigitstring($_, $base) } @list[4*$base-1 .. $\n}\n\nsay \"\\nBase 10 esthetic numbers between 1,000 and 9,999:\";\nfor (my @list = between_esthetic(1e3, 1e4) ; @list ;) {\n    say join(' ', splice(@list, 0, 20));\n}\n\nsay \"\\nBase 10 esthetic numbers between 100,000,000 and 130,000,000:\";\nfor (my @list = between_esthetic(1e8, 1.3e8) ; @list ;) {\n    say join(' ', splice(@list, 0, 9));\n}\n", "target": "from collections import deque\nfrom itertools import dropwhile, islice, takewhile\nfrom textwrap import wrap\nfrom typing import Iterable, Iterator\n\n\nDigits = str  \n\n\ndef esthetic_nums(base: int) -> Iterator[int]:\n    \n    queue: deque[tuple[int, int]] = deque()\n    queue.extendleft((d, d) for d in range(1, base))\n    while True:\n        num, lsd = queue.pop()\n        yield num\n        new_lsds = (d for d in (lsd - 1, lsd + 1) if 0 <= d < base)\n        num *= base  \n        queue.extendleft((num + d, d) for d in new_lsds)\n\n\ndef to_digits(num: int, base: int) -> Digits:\n    \n    digits: list[str] = []\n    while num:\n        num, d = divmod(num, base)\n        digits.append(\"0123456789abcdef\"[d])\n    return \"\".join(reversed(digits)) if digits else \"0\"\n\n\ndef pprint_it(it: Iterable[str], indent: int = 4, width: int = 80) -> None:\n    \n    joined = \", \".join(it)\n    lines = wrap(joined, width=width - indent)\n    for line in lines:\n        print(f\"{indent*' '}{line}\")\n    print()\n\n\ndef task_2() -> None:\n    nums: Iterator[int]\n    for base in range(2, 16 + 1):\n        start, stop = 4 * base, 6 * base\n        nums = esthetic_nums(base)\n        nums = islice(nums, start - 1, stop)  \n        print(\n            f\"Base-{base} esthetic numbers from \"\n            f\"index {start} through index {stop} inclusive:\\n\"\n        )\n        pprint_it(to_digits(num, base) for num in nums)\n\n\ndef task_3(lower: int, upper: int, base: int = 10) -> None:\n    nums: Iterator[int] = esthetic_nums(base)\n    nums = dropwhile(lambda num: num < lower, nums)\n    nums = takewhile(lambda num: num <= upper, nums)\n    print(\n        f\"Base-{base} esthetic numbers with \"\n        f\"magnitude between {lower:,} and {upper:,}:\\n\"\n    )\n    pprint_it(to_digits(num, base) for num in nums)\n\n\nif __name__ == \"__main__\":\n    print(\"======\\nTask 2\\n======\\n\")\n    task_2()\n\n    print(\"======\\nTask 3\\n======\\n\")\n    task_3(1_000, 9_999)\n\n    print(\"======\\nTask 4\\n======\\n\")\n    task_3(100_000_000, 130_000_000)\n"}
{"id": 383133, "name": "Descending primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nprint join('', sort map { sprintf \"%9d\", $_ } grep /./ && is_prime($_),\n  glob join '', map \"{$_,}\", reverse 1 .. 9) =~ s/.{45}\\K/\\n/gr;\n", "target": "from sympy import isprime\n\ndef descending(xs=range(10)):\n    for x in xs:\n        yield x\n        yield from descending(x*10 + d for d in range(x%10))\n\nfor i, p in enumerate(sorted(filter(isprime, descending()))):\n    print(f'{p:9d}', end=' ' if (1 + i)%8 else '\\n')\n\nprint()\n"}
{"id": 383134, "name": "Permutations by swapping", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\n\n\n\n\n\n\n\n\n\n\n\nsub perms :prototype(&@) {\n   my $callback = shift;\n   my @perm = map [$_, -1], @_;\n   $perm[0][1] = 0;\n\n   my $sign = 1;\n   while( ) {\n      $callback->($sign, map $_->[0], @perm);\n      $sign *= -1;\n\n      my ($chosen, $index) = (-1, -1);\n      for my $i ( 0 .. $\n         ($chosen, $index) = ($perm[$i][0], $i)\n           if $perm[$i][1] and $perm[$i][0] > $chosen;\n      }\n      return if $index == -1;\n\n      my $direction = $perm[$index][1];\n      my $next = $index + $direction;\n\n      @perm[ $index, $next ] = @perm[ $next, $index ];\n\n      if( $next <= 0 or $next >= $\n         $perm[$next][1] = 0;\n      } elsif( $perm[$next + $direction][0] > $chosen ) {\n         $perm[$next][1] = 0;\n      }\n\n      for my $i ( 0 .. $next - 1 ) {\n         $perm[$i][1] = +1 if $perm[$i][0] > $chosen;\n      }\n      for my $i ( $next + 1 .. $\n         $perm[$i][1] = -1 if $perm[$i][0] > $chosen;\n      }\n   }\n}\n\nmy $n = shift(@ARGV) || 4;\n\nperms {\n   my ($sign, @perm) = @_;\n   print \"[\", join(\", \", @perm), \"]\";\n   print $sign < 0 ? \" => -1\\n\" : \" => +1\\n\";   \n} 1 .. $n;\n", "target": "from operator import itemgetter\n \nDEBUG = False \n \ndef spermutations(n):\n    \n    sign = 1\n    p = [[i, 0 if i == 0 else -1] \n         for i in range(n)]\n \n    if DEBUG: print ' \n    yield tuple(pp[0] for pp in p), sign\n \n    while any(pp[1] for pp in p): \n        i1, (n1, d1) = max(((i, pp) for i, pp in enumerate(p) if pp[1]),\n                           key=itemgetter(1))\n        sign *= -1\n        if d1 == -1:\n            \n            i2 = i1 - 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == 0 or p[i2 - 1][0] > n1:\n                \n                p[i2][1] = 0\n        elif d1 == 1:\n            \n            i2 = i1 + 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == n - 1 or p[i2 + 1][0] > n1:\n                \n                p[i2][1] = 0\n        if DEBUG: print ' \n        yield tuple(pp[0] for pp in p), sign\n \n        for i3, pp in enumerate(p):\n            n3, d3 = pp\n            if n3 > n1:\n                pp[1] = 1 if i3 < i2 else -1\n                if DEBUG: print ' \n \n \nif __name__ == '__main__':\n    from itertools import permutations\n \n    for n in (3, 4):\n        print '\\nPermutations and sign of %i items' % n\n        sp = set()\n        for i in spermutations(n):\n            sp.add(i[0])\n            print('Perm: %r Sign: %2i' % i)\n            \n        \n        p = set(permutations(range(n)))\n        assert sp == p, 'Two methods of generating permutations do not agree'\n"}
{"id": 383135, "name": "RPG attributes generator", "source": "Translate Perl to Python: use strict;\nuse List::Util 'sum';\n\nmy ($min_sum, $hero_attr_min, $hero_count_min) = <75 15 3>;\nmy @attr_names = <Str Int Wis Dex Con Cha>;\n\nsub heroic { scalar grep { $_ >= $hero_attr_min } @_ }\n\nsub roll_skip_lowest {\n    my($dice, $sides) = @_;\n    sum( (sort map { 1 + int rand($sides) } 1..$dice)[1..$dice-1] );\n}\n\nmy @attr;\ndo {\n    @attr = map { roll_skip_lowest(6,4) } @attr_names;\n} until sum(@attr) >= $min_sum and heroic(@attr) >= $hero_count_min;\n\nprintf \"%s = %2d\\n\", $attr_names[$_], $attr[$_] for 0..$\nprintf \"Sum = %d, with %d attributes >= $hero_attr_min\\n\", sum(@attr), heroic(@attr);\n", "target": "import random\nrandom.seed()\nattributes_total = 0\ncount = 0\n\nwhile attributes_total < 75 or count < 2:\n    attributes = []\n\n    for attribute in range(0, 6):\n        rolls = []\n        \n        for roll in range(0, 4):\n            result = random.randint(1, 6)\n            rolls.append(result)\n        \n        sorted_rolls = sorted(rolls)\n        largest_3 = sorted_rolls[1:]\n        rolls_total = sum(largest_3)\n        \n        if rolls_total >= 15:\n            count += 1\n        \n        attributes.append(rolls_total)\n\n    attributes_total = sum(attributes)\n    \nprint(attributes_total, attributes)\n"}
{"id": 383136, "name": "Kolakoski sequence", "source": "Translate Perl to Python: sub kolakoski {\n    my($terms,@seed) = @_;\n    my @k;\n    my $k = $seed[0] == 1 ? 1 : 0;\n    if ($k == 1) { @k = (1, split //, (($seed[1]) x $seed[1])) }\n    else         { @k = ($seed[0]) x $seed[0] }\n    do {\n        $k++;\n        push @k, ($seed[$k % @seed]) x $k[$k];\n    } until $terms <= @k;\n    @k[0..$terms-1]\n}\n\nsub rle {\n    (my $string = join '', @_) =~ s/((.)\\2*)/length $1/eg;\n    split '', $string\n}\n\nfor ([20,1,2], [20,2,1], [30,1,3,1,2], [30,1,3,2,1]) {\n    $terms = shift @$_;\n    print \"\\n$terms members of the series generated from [@$_] is:\\n\";\n    print join(' ', @kolakoski = kolakoski($terms, @$_)) . \"\\n\";\n    $status = join('', @rle = rle(@kolakoski)) eq join('', @kolakoski[0..$\n    print \"Looks like a Kolakoski sequence?: $status\\n\";\n}\n", "target": "import itertools\n\ndef cycler(start_items):\n\treturn itertools.cycle(start_items).__next__\n\ndef _kolakoski_gen(start_items):\n    s, k = [], 0\n    c = cycler(start_items)\n    while True:\n        c_next = c()\n        s.append(c_next)\n        sk = s[k]\n        yield sk\n        if sk > 1:\n            s += [c_next] * (sk - 1)\n        k += 1\n\ndef kolakoski(start_items=(1, 2), length=20):\n    return list(itertools.islice(_kolakoski_gen(start_items), length))\n\ndef _run_len_encoding(truncated_series):\n    return [len(list(group)) for grouper, group in itertools.groupby(truncated_series)][:-1]\n\ndef is_series_eq_its_rle(series):\n    rle = _run_len_encoding(series)\n    return (series[:len(rle)] == rle) if rle else not series\n\nif __name__ == '__main__':\n    for start_items, length in [((1, 2), 20), ((2, 1), 20), \n                                ((1, 3, 1, 2), 30), ((1, 3, 2, 1), 30)]:\n        print(f'\\n\n        s = kolakoski(start_items, length)\n        print(f'  {s}')\n        ans = 'YES' if is_series_eq_its_rle(s) else 'NO'\n        print(f'  Does it look like a Kolakoski sequence: {ans}')\n"}
{"id": 383137, "name": "Variable declaration reset", "source": "Translate Perl to Python: @s = <1 2 2 3 4 4 5>;\nfor ($i = 0; $i < 7; $i++) {\n    $curr = $s[$i];\n    if ($i > 1 and $curr == $prev) { print \"$i\\n\" }\n    $prev = $curr;\n}\n", "target": "s = [1, 2, 2, 3, 4, 4, 5]\n \nfor i in range(len(s)):\n    curr = s[i]\n    if i > 0 and curr == prev:\n        print(i)\n    prev = curr\n"}
{"id": 383138, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'divisors';\n\nprint \"First 15 terms of OEIS: A005179\\n\";\nfor my $n (1..15) {\n    my $l = 0;\n    while (++$l) {\n        print \"$l \" and last if $n == divisors($l);\n    }\n}\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    n = 0\n    while True:\n        n += 1\n        ii = 0\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 383139, "name": "Sparkline in unicode", "source": "Translate Perl to Python: binmode(STDOUT, \":utf8\");\nour @sparks=map {chr} 0x2581 .. 0x2588;\nsub sparkline :prototype(@) {\n    my @n=map {0+$_} grep {length} @_ or return \"\";\n    my($min,$max)=($n[0])x2;\n    if (@n>1) {\n        for (@n[1..$\n            if    ($_<$min) { $min=$_ }\n            elsif ($_>$max) { $max=$_ }\n        }\n    }\n    my $sparkline=\"\";\n    for(@n) {\n        my $height=int( $max==$min ? @sparks/2\u00a0: ($_-$min)/($max-$min)*@sparks );\n        $height=$\n        $sparkline.=$sparks[$height];\n    }\n    my $summary=sprintf \"%d values; range %s..%s\", scalar(@n), $min, $max;\n    return wantarray ? ($summary, \"\\n\", $sparkline, \"\\n\") : $sparkline;\n}\n\n\n\n\n\n\n\n\nprint sparkline( split /[\\s,]+/ ) while <>;\n", "target": "\n\n\nbar = '\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588'\nbarcount = len(bar)\n\ndef sparkline(numbers):\n    mn, mx = min(numbers), max(numbers)\n    extent = mx - mn\n    sparkline = ''.join(bar[min([barcount - 1,\n                                 int((n - mn) / extent * barcount)])]\n                        for n in numbers)\n    return mn, mx, sparkline\n\nif __name__ == '__main__':\n    import re\n    \n    for line in (\"0 0 1 1; 0 1 19 20; 0 999 4000 4999 7000 7999;\"\n                 \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1;\"\n                 \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5 \").split(';'):\n        print(\"\\nNumbers:\", line)\n        numbers = [float(n) for n in re.split(r'[\\s,]+', line.strip())]\n        mn, mx, sp = sparkline(numbers)\n        print('  min: %5f; max: %5f' % (mn, mx))\n        print(\"  \" + sp)\n"}
{"id": 383140, "name": "Levenshtein distance_Alignment", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse List::Util qw(min);\n \nsub levenshtein_distance_alignment {\n    my @s = ('^', split //, shift);\n    my @t = ('^', split //, shift);\n \n    my @A;\n    @{$A[$_][0]}{qw(d s t)} = ($_, join('', @s[1 .. $_]), ('~' x $_)) for 0 .. $\n    @{$A[0][$_]}{qw(d s t)} = ($_, ('-' x $_), join '', @t[1 .. $_])  for 0 .. $\n    for my $i (1 .. $\n        for my $j (1 .. $\n\t    if ($s[$i] ne $t[$j]) {\n\t\t$A[$i][$j]{d} = 1 + (\n\t\t    my $min = min $A[$i-1][$j]{d}, $A[$i][$j-1]{d}, $A[$i-1][$j-1]{d}\n\t\t);\n\t\t@{$A[$i][$j]}{qw(s t)} =\n\t\t$A[$i-1][$j]{d} == $min ? ($A[$i-1][$j]{s}.$s[$i], $A[$i-1][$j]{t}.'-') :\n\t\t$A[$i][$j-1]{d} == $min ? ($A[$i][$j-1]{s}.'-', $A[$i][$j-1]{t}.$t[$j]) :\n\t\t($A[$i-1][$j-1]{s}.$s[$i], $A[$i-1][$j-1]{t}.$t[$j]);\n\t    }\n            else {\n\t\t@{$A[$i][$j]}{qw(d s t)} = (\n\t\t    $A[$i-1][$j-1]{d},\n\t\t    $A[$i-1][$j-1]{s}.$s[$i],\n\t\t    $A[$i-1][$j-1]{t}.$t[$j]\n\t\t);\n            }\n        }\n    }\n    return @{$A[-1][-1]}{'s', 't'};\n}\n \nprint  join \"\\n\", levenshtein_distance_alignment \"rosettacode\", \"raisethysword\";\n", "target": "from difflib import ndiff\n\ndef levenshtein(str1, str2):\n    result = \"\"\n    pos, removed = 0, 0\n    for x in ndiff(str1, str2):\n        if pos<len(str1) and str1[pos] == x[2]:\n          pos += 1\n          result += x[2]\n          if x[0] == \"-\":\n              removed += 1\n          continue\n        else:\n          if removed > 0:\n            removed -=1\n          else:\n            result += \"-\"\n    print(result)\n\nlevenshtein(\"place\",\"palace\")\nlevenshtein(\"rosettacode\",\"raisethysword\")\n"}
{"id": 383141, "name": "Longest increasing subsequence", "source": "Translate Perl to Python: use strict;\n\nsub lis {\n    my @l = map [], 1 .. @_;\n    push @{$l[0]}, +$_[0];\n    for my $i (1 .. @_-1) {\n        for my $j (0 .. $i - 1) {\n            if ($_[$j] < $_[$i] and @{$l[$i]} < @{$l[$j]} + 1) {\n                $l[$i] = [ @{$l[$j]} ];\n            }\n        }\n        push @{$l[$i]}, $_[$i];\n    }\n    my ($max, $l) = (0, []);\n    for (@l) {\n        ($max, $l) = (scalar(@$_), $_) if @$_ > $max;\n    }\n    return @$l;\n}\n\nprint join ' ', lis 3, 2, 6, 4, 5, 1;\nprint join ' ', lis 0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15;\n", "target": "def longest_increasing_subsequence(X):\n    \n    N = len(X)\n    P = [0] * N\n    M = [0] * (N+1)\n    L = 0\n    for i in range(N):\n       lo = 1\n       hi = L\n       while lo <= hi:\n           mid = (lo+hi)//2\n           if (X[M[mid]] < X[i]):\n               lo = mid+1\n           else:\n               hi = mid-1\n    \n       newL = lo\n       P[i] = M[newL-1]\n       M[newL] = i\n    \n       if (newL > L):\n           L = newL\n    \n    S = []\n    k = M[L]\n    for i in range(L-1, -1, -1):\n        S.append(X[k])\n        k = P[k]\n    return S[::-1]\n\nif __name__ == '__main__':\n    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:\n        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))\n"}
{"id": 383142, "name": "Metaprogramming", "source": "Translate Perl to Python: package UnicodeEllipsis;\n\nuse Filter::Simple;\n\nFILTER_ONLY code => sub { s/\u2026/../g };\n", "target": "from macropy.core.macros import *\nfrom macropy.core.quotes import macros, q, ast, u\n\nmacros = Macros()\n\n@macros.expr\ndef expand(tree, **kw):\n    addition = 10\n    return q[lambda x: x * ast[tree] + u[addition]]\n"}
{"id": 383143, "name": "Odd and square numbers", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse ntheory qw( is_square );\n\nprint join( ' ', grep $_ & 1 && is_square($_), 100 .. 999 ), \"\\n\";\n", "target": "import math\nszamok=[]\nlimit = 1000\n\nfor i in range(1,int(math.ceil(math.sqrt(limit))),2):\n    num = i*i\n    if (num < 1000 and num > 99):\n        szamok.append(num)\n\nprint(szamok)\n"}
{"id": 383144, "name": "Words from neighbour ones", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\n@ARGV = 'unixdict.txt';\nmy $skew = join '', map { s/^.{9}\\K.+//r } my @words = grep length() > 9, <>;\nmy %dict = map { $_ => 1 } grep length == 10, @words;\nmy %seen;\nmy $nextch = '.{10}(\\\\w)' x 8;\nwhile( $skew =~ /^(\\w)(?=$nextch)/gms )\n  {\n  my $new = join '', @{^CAPTURE}, \"\\n\";\n  $dict{$new} and !$seen{$new}++ and print $new;\n  }\n", "target": "\n\nimport urllib.request\nfrom collections import Counter\n \nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n \ndictionary = open(\"unixdict.txt\",\"r\")\n \nwordList = dictionary.read().split('\\n')\n \ndictionary.close()\n \nfilteredWords = [chosenWord for chosenWord in wordList if len(chosenWord)>=9]\n\nfor word in filteredWords[:-9]:\n  position = filteredWords.index(word)\n  newWord = \"\".join([filteredWords[position+i][i] for i in range(0,9)])\n  if newWord in filteredWords:\n   print(newWord)\n"}
{"id": 383145, "name": "Sum of square and cube digits of an integer are primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime vecsum );\n\nmy @results = grep\n  is_prime( vecsum( split //, $_ ** 2 ) ) &&\n  is_prime( vecsum( split //, $_ ** 3 ) ), 1 .. 100;\nprint \"@results\\n\";\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef digSum(n, b):\n    s = 0\n    while n:\n        s += (n % b)\n        n = n // b\n    return s\n\nif __name__ == '__main__':\n    for n in range(11, 99):\n        if isPrime(digSum(n**3, 10)) and isPrime(digSum(n**2, 10)):\n            print(n, end = \"  \")\n"}
{"id": 383146, "name": "Dynamic variable names", "source": "Translate Perl to Python: print \"Enter a variable name: \";\n$varname = <STDIN>; \nchomp($varname);\n$$varname = 42; \n                \n                \nprint \"$foo\\n\"; \n", "target": ">>> name = raw_input(\"Enter a variable name: \")\nEnter a variable name: X\n>>> globals()[name] = 42\n>>> X\n42\n"}
{"id": 383147, "name": "Odd squarefree semiprimes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy (@primes, @found) = grep $_ & 1 && (1 x $_) !~ /^(11+)\\1+$/, 3 .. 999 / 3;\n\"@primes\" =~ /\\b(\\d+)\\b.*?\\b(\\d+)\\b(?{ $found[$1 * $2] = $1 * $2 })(*FAIL)/;\nprint \"@{[ grep $_, @found[3 .. 999] ]}\\n\" =~ s/.{75}\\K /\\n/gr;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    for p in range(3, 999):\n        if not isPrime(p):            \n            continue\n        for q in range(p+1, 1000//p):\n            if not isPrime(q):\n                continue\n            print(p*q, end = \" \");\n"}
{"id": 383148, "name": "Odd squarefree semiprimes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy (@primes, @found) = grep $_ & 1 && (1 x $_) !~ /^(11+)\\1+$/, 3 .. 999 / 3;\n\"@primes\" =~ /\\b(\\d+)\\b.*?\\b(\\d+)\\b(?{ $found[$1 * $2] = $1 * $2 })(*FAIL)/;\nprint \"@{[ grep $_, @found[3 .. 999] ]}\\n\" =~ s/.{75}\\K /\\n/gr;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    for p in range(3, 999):\n        if not isPrime(p):            \n            continue\n        for q in range(p+1, 1000//p):\n            if not isPrime(q):\n                continue\n            print(p*q, end = \" \");\n"}
{"id": 383149, "name": "Primes with digits in nondecreasing order", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @want = grep ! /(.)(.)(??{$1 > $2\u00a0? ''\u00a0: '(*FAIL)'})/, @{ primes(1000) };\nprint \"@want\" =~ s/.{50}\\K /\\n/gr . \"\\n\\ncount: \" . @want . \"\\n\";\n", "target": "\n\nfrom operator import le\nfrom itertools import takewhile\n\n\n\ndef monotonicDigits(base):\n    \n    def go(n):\n        return monotonic(le)(\n            showIntAtBase(base)(digitFromInt)(n)('')\n        )\n    return go\n\n\n\ndef monotonic(op):\n    \n    def go(xs):\n        return all(map(op, xs, xs[1:]))\n    return go\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in takewhile(\n            lambda n: 1000 > n,\n            filter(monotonicDigits(10), primes())\n        )\n    ]\n    w = len(xs[-1])\n    print(f'{len(xs)} matches for base 10:\\n')\n    print('\\n'.join(\n        ' '.join(row) for row in chunksOf(10)([\n            x.rjust(w, ' ') for x in xs\n        ])\n    ))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitFromInt(n):\n    \n    return '0123456789abcdefghijklmnopqrstuvwxyz'[n] if (\n        0 <= n < 36\n    ) else '?'\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383150, "name": "Primes with digits in nondecreasing order", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @want = grep ! /(.)(.)(??{$1 > $2\u00a0? ''\u00a0: '(*FAIL)'})/, @{ primes(1000) };\nprint \"@want\" =~ s/.{50}\\K /\\n/gr . \"\\n\\ncount: \" . @want . \"\\n\";\n", "target": "\n\nfrom operator import le\nfrom itertools import takewhile\n\n\n\ndef monotonicDigits(base):\n    \n    def go(n):\n        return monotonic(le)(\n            showIntAtBase(base)(digitFromInt)(n)('')\n        )\n    return go\n\n\n\ndef monotonic(op):\n    \n    def go(xs):\n        return all(map(op, xs, xs[1:]))\n    return go\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in takewhile(\n            lambda n: 1000 > n,\n            filter(monotonicDigits(10), primes())\n        )\n    ]\n    w = len(xs[-1])\n    print(f'{len(xs)} matches for base 10:\\n')\n    print('\\n'.join(\n        ' '.join(row) for row in chunksOf(10)([\n            x.rjust(w, ' ') for x in xs\n        ])\n    ))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitFromInt(n):\n    \n    return '0123456789abcdefghijklmnopqrstuvwxyz'[n] if (\n        0 <= n < 36\n    ) else '?'\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383151, "name": "Brilliant numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils <max head firstidx uniqint>;\nuse ntheory <primes is_semiprime forsetproduct>;\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nmy(@B,@Br);\nfor my $oom (1..5) {\n    my @P = grep { $oom == length } @{primes(10**$oom)};\n    forsetproduct { is_semiprime($_[0] * $_[1]) and push @B, $_[0] * $_[1] } \\@P, \\@P;\n    @Br = uniqint sort { $a <=> $b } @Br, @B;\n}\n\nsay \"First 100 brilliant numbers:\\n\" . table 10, head 100, @Br;\n\nfor my $oom (1..9) {\n    my $key = firstidx { $_ > 10**$oom } @Br;\n    printf \"First >= %13s is position %9s in the series: %13s\\n\", comma(10**$oom), comma($key), comma $Br[$key];\n}\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 383152, "name": "Brilliant numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils <max head firstidx uniqint>;\nuse ntheory <primes is_semiprime forsetproduct>;\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nmy(@B,@Br);\nfor my $oom (1..5) {\n    my @P = grep { $oom == length } @{primes(10**$oom)};\n    forsetproduct { is_semiprime($_[0] * $_[1]) and push @B, $_[0] * $_[1] } \\@P, \\@P;\n    @Br = uniqint sort { $a <=> $b } @Br, @B;\n}\n\nsay \"First 100 brilliant numbers:\\n\" . table 10, head 100, @Br;\n\nfor my $oom (1..9) {\n    my $key = firstidx { $_ > 10**$oom } @Br;\n    printf \"First >= %13s is position %9s in the series: %13s\\n\", comma(10**$oom), comma($key), comma $Br[$key];\n}\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 383153, "name": "Calkin-Wilf sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature qw(say state);\n\nuse ntheory      'fromdigits';\nuse List::Lazy   'lazy_list';\nuse Math::AnyNum ':overload';\n\nmy $calkin_wilf = lazy_list { state @cw = 1; push @cw, 1 / ( (2 * int $cw[0]) + 1 - $cw[0] ); shift @cw };\n\nsub r2cf {\n  my($num, $den) = @_;\n  my($n, @cf);\n  my $f = sub { return unless $den;\n               my $q = int($num/$den);\n               ($num, $den) = ($den, $num - $q*$den);\n               $q;\n             };\n  push @cf, $n while defined($n = $f->());\n  reverse @cf;\n}\n\nsub r2cw {\n    my($num, $den) = @_;\n    my $bits;\n    my @f = r2cf($num, $den);\n    $bits .= ($_%2 ? 0 : 1) x $f[$_] for 0..$\n    fromdigits($bits, 2);\n}\n\nsay 'First twenty terms of the Calkin-Wilf sequence:';\nprintf \"%s \", $calkin_wilf->next() for 1..20;\nsay \"\\n\\n83116/51639 is at index: \" . r2cw(83116,51639);\n", "target": "from fractions import Fraction\nfrom math import floor\nfrom itertools import islice, groupby\n\n\ndef cw():\n    a = Fraction(1)\n    while True:\n        yield a\n        a = 1 / (2 * floor(a) + 1 - a)\n\ndef r2cf(rational):\n    num, den = rational.numerator, rational.denominator\n    while den:\n        num, (digit, den) = den, divmod(num, den)\n        yield digit\n\ndef get_term_num(rational):\n    ans, dig, pwr = 0, 1, 0\n    for n in r2cf(rational):\n        for _ in range(n):\n            ans |= dig << pwr\n            pwr += 1\n        dig ^= 1\n    return ans\n\n          \nif __name__ == '__main__':\n    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))\n    x = Fraction(83116, 51639)\n    print(f\"\\n{x} is the {get_term_num(x):_}'th term.\")\n"}
{"id": 383154, "name": "Calkin-Wilf sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature qw(say state);\n\nuse ntheory      'fromdigits';\nuse List::Lazy   'lazy_list';\nuse Math::AnyNum ':overload';\n\nmy $calkin_wilf = lazy_list { state @cw = 1; push @cw, 1 / ( (2 * int $cw[0]) + 1 - $cw[0] ); shift @cw };\n\nsub r2cf {\n  my($num, $den) = @_;\n  my($n, @cf);\n  my $f = sub { return unless $den;\n               my $q = int($num/$den);\n               ($num, $den) = ($den, $num - $q*$den);\n               $q;\n             };\n  push @cf, $n while defined($n = $f->());\n  reverse @cf;\n}\n\nsub r2cw {\n    my($num, $den) = @_;\n    my $bits;\n    my @f = r2cf($num, $den);\n    $bits .= ($_%2 ? 0 : 1) x $f[$_] for 0..$\n    fromdigits($bits, 2);\n}\n\nsay 'First twenty terms of the Calkin-Wilf sequence:';\nprintf \"%s \", $calkin_wilf->next() for 1..20;\nsay \"\\n\\n83116/51639 is at index: \" . r2cw(83116,51639);\n", "target": "from fractions import Fraction\nfrom math import floor\nfrom itertools import islice, groupby\n\n\ndef cw():\n    a = Fraction(1)\n    while True:\n        yield a\n        a = 1 / (2 * floor(a) + 1 - a)\n\ndef r2cf(rational):\n    num, den = rational.numerator, rational.denominator\n    while den:\n        num, (digit, den) = den, divmod(num, den)\n        yield digit\n\ndef get_term_num(rational):\n    ans, dig, pwr = 0, 1, 0\n    for n in r2cf(rational):\n        for _ in range(n):\n            ans |= dig << pwr\n            pwr += 1\n        dig ^= 1\n    return ans\n\n          \nif __name__ == '__main__':\n    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))\n    x = Fraction(83116, 51639)\n    print(f\"\\n{x} is the {get_term_num(x):_}'th term.\")\n"}
{"id": 383155, "name": "Order disjoint list items", "source": "Translate Perl to Python: sub dsort {\n        my ($m, $n) = @_;\n        my %h;\n        $h{$_}++ for @$n;\n        map $h{$_}-- > 0 ? shift @$n : $_, @$m;\n}\n\nfor (split \"\\n\", <<\"IN\")\n        the cat sat on the mat  | mat cat\n        the cat sat on the mat  | cat mat\n        A B C A B C A B C       | C A C A\n        A B C A B D A B E       | E A D A\n        A B                     | B\n        A B                     | B A\n        A B B A                 | B A\nIN\n{\n\n        my ($a, $b) = map([split], split '\\|');\n        print \"@$a | @$b -> @{[dsort($a, $b)]}\\n\";\n}\n", "target": "from __future__ import print_function\n\ndef order_disjoint_list_items(data, items):\n    \n    itemindices = []\n    for item in set(items):\n        itemcount = items.count(item)\n        \n        lastindex = [-1]\n        for i in range(itemcount):\n            lastindex.append(data.index(item, lastindex[-1] + 1))\n        itemindices += lastindex[1:]\n    itemindices.sort()\n    for index, item in zip(itemindices, items):\n        data[index] = item\n\nif __name__ == '__main__':\n    tostring = ' '.join\n    for data, items in [ (str.split('the cat sat on the mat'), str.split('mat cat')),\n                         (str.split('the cat sat on the mat'), str.split('cat mat')),\n                         (list('ABCABCABC'), list('CACA')),\n                         (list('ABCABDABE'), list('EADA')),\n                         (list('AB'), list('B')),\n                         (list('AB'), list('BA')),\n                         (list('ABBA'), list('BA')),\n                         (list(''), list('')),\n                         (list('A'), list('A')),\n                         (list('AB'), list('')),\n                         (list('ABBA'), list('AB')),\n                         (list('ABAB'), list('AB')),\n                         (list('ABAB'), list('BABA')),\n                         (list('ABCCBA'), list('ACAC')),\n                         (list('ABCCBA'), list('CACA')),\n                       ]:\n        print('Data M: %-24r Order N: %-9r' % (tostring(data), tostring(items)), end=' ')\n        order_disjoint_list_items(data, items)\n        print(\"-> M' %r\" % tostring(data))\n"}
{"id": 383156, "name": "Prime words", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy $pat = join '', grep +(1 x ord) !~ /^(11+)\\1+$/, 'a'..'z', 'A'..'Z';\n@ARGV = 'unixdict.txt';\nprint join('', grep /^[$pat]+$/, <>) =~ tr/\\n/ /r =~ s/.{1,71}\\K /\\n/gr;\n", "target": "for i in range(65,123):\n  check = 1\n  for j in range(2,i):\n    if i%j == 0:\n     check = 0\n  if check==1:\n   print(chr(i),end='')\n"}
{"id": 383157, "name": "Prime words", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy $pat = join '', grep +(1 x ord) !~ /^(11+)\\1+$/, 'a'..'z', 'A'..'Z';\n@ARGV = 'unixdict.txt';\nprint join('', grep /^[$pat]+$/, <>) =~ tr/\\n/ /r =~ s/.{1,71}\\K /\\n/gr;\n", "target": "for i in range(65,123):\n  check = 1\n  for j in range(2,i):\n    if i%j == 0:\n     check = 0\n  if check==1:\n   print(chr(i),end='')\n"}
{"id": 383158, "name": "Palindromic primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\n$_ == reverse and (1 x $_ ) !~ /^(11+)\\1+$/ and print \"$_ \" for 2 .. 1e3;\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef palindromicPrimes():\n    \n    def p(n):\n        s = str(n)\n        return s == s[::-1]\n    return (n for n in primes() if p(n))\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        str(x) for x in takewhile(\n            lambda n: 1000 > n,\n            palindromicPrimes()\n        )\n    ))\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383159, "name": "Palindromic primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\n$_ == reverse and (1 x $_ ) !~ /^(11+)\\1+$/ and print \"$_ \" for 2 .. 1e3;\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef palindromicPrimes():\n    \n    def p(n):\n        s = str(n)\n        return s == s[::-1]\n    return (n for n in primes() if p(n))\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        str(x) for x in takewhile(\n            lambda n: 1000 > n,\n            palindromicPrimes()\n        )\n    ))\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383160, "name": "Sylvester's sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'reduce';\nuse Math::AnyNum ':overload';\nlocal $Math::AnyNum::PREC = 845;\n\nmy(@S,$sum);\npush @S, 1 + reduce { $a * $b } @S for 0..10;\nshift @S;\n$sum += 1/$_ for @S;\n\nsay \"First 10 elements of Sylvester's sequence: @S\";\nsay \"\\nSum of the reciprocals of first 10 elements: \" . float $sum;\n", "target": "\n\nfrom functools import reduce\nfrom itertools import count, islice\n\n\n\ndef sylvester():\n    \n    def go(n):\n        return 1 + reduce(\n            lambda a, x: a * go(x),\n            range(0, n),\n            1\n        ) if 0 != n else 2\n\n    return map(go, count(0))\n\n\n\n\ndef main():\n    \n\n    print(\"First 10 terms of OEIS A000058:\")\n    xs = list(islice(sylvester(), 10))\n    print('\\n'.join([\n        str(x) for x in xs\n    ]))\n\n    print(\"\\nSum of the reciprocals of the first 10 terms:\")\n    print(\n        reduce(lambda a, x: a + 1 / x, xs, 0)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383161, "name": "Harmonic series", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Math::AnyNum ':overload';\nuse List::AllUtils 'firstidx';\n\nmy(@H,$n) = 0;\ndo { ++$n and push @H, $H[-1] + 1/$n } until $H[-1] >= 10;\nshift @H;\n\nsay 'First twenty harmonic numbers as rationals:';\nmy $c = 0;\nprintf(\"%20s\", $_) and (not ++$c%5) and print \"\\n\" for @H[0..19];\n\nsay \"\\nIndex of first value (zero based):\";\nfor my $i (1..10) {\n    printf \"  greater than %2d: %5s\\n\", $i, firstidx { $_ > $i } @H;\n}\n", "target": "from  fractions import Fraction\n\ndef harmonic_series():\n    n, h = Fraction(1), Fraction(1)\n    while True:\n        yield h\n        h += 1 / (n + 1)\n        n += 1\n\nif __name__ == '__main__':\n    from itertools import islice\n    for n, d in (h.as_integer_ratio() for h in islice(harmonic_series(), 20)):\n        print(n, '/', d)\n"}
{"id": 383162, "name": "Interactive programming (repl)", "source": "Translate Perl to Python: $ perl -de1\n\nLoading DB routines from perl5db.pl version 1.3\nEditor support available.\n\nEnter h or `h h' for help, or `man perldebug' for more help.\n\nmain::(-e:1):   1\n  DB<1> sub f {my ($s1, $s2, $sep) = @_; $s1 . $sep . $sep . $s2}\n\n  DB<2> p f('Rosetta', 'Code', ':')\nRosetta::Code\n  DB<3> q\n", "target": "python\nPython 2.6.1 (r261:67517, Dec  4 2008, 16:51:00) [MSC v.1500 32 bit (Intel)] on\nwin32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> def f(string1, string2, separator):\n\treturn separator.join([string1, '', string2])\n\n>>> f('Rosetta', 'Code', ':')\n'Rosetta::Code'\n>>>\n"}
{"id": 383163, "name": "Runtime evaluation_In an environment", "source": "Translate Perl to Python: sub eval_with_x\n   {my $code = shift;\n    my $x = shift;\n    my $first = eval $code;\n    $x = shift;\n    return eval($code) - $first;}\n \nprint eval_with_x('3 * $x', 5, 10), \"\\n\"; \n", "target": ">>> def eval_with_x(code, a, b):\n\treturn eval(code, {'x':b}) - eval(code, {'x':a})\n\n>>> eval_with_x('2 ** x', 3, 5)\n24\n"}
{"id": 383164, "name": "Runtime evaluation_In an environment", "source": "Translate Perl to Python: sub eval_with_x\n   {my $code = shift;\n    my $x = shift;\n    my $first = eval $code;\n    $x = shift;\n    return eval($code) - $first;}\n \nprint eval_with_x('3 * $x', 5, 10), \"\\n\"; \n", "target": ">>> def eval_with_x(code, a, b):\n\treturn eval(code, {'x':b}) - eval(code, {'x':a})\n\n>>> eval_with_x('2 ** x', 3, 5)\n24\n"}
{"id": 383165, "name": "Reverse the gender of a string", "source": "Translate Perl to Python: my %swaps = (\n    'she'  => 'he',\n    'his'  => 'her',\n);\n\n$swaps{         $swaps{$_} } =         $_ for keys %swaps; \n$swaps{ ucfirst $swaps{$_} } = ucfirst $_ for keys %swaps; \n\nsub gender_swap {\n    my($s) = @_;\n    $s =~ s/\\b$_\\b/_$swaps{$_}/g for keys %swaps; \n    $s =~ s/_//g;                                 \n    $s;\n}\n\n$original = qq{She was this soul sherpa. She took his heart! They say she's going to put me on a shelf.\\n};\nprint $swapped  = gender_swap($original);\nprint $reverted = gender_swap($swapped);\n", "target": "\n\n \nimport re\nmale2female=u\n \nre_nl=re.compile(r\",[ \\n]*\")\nm2f=[ tok.split(\" \") for tok in re_nl.split(male2female) ]\n \nswitch={}\nwords=[]\n \n \nre_plural=re.compile(\"E*S$\")\nre_ES=re.compile(\"ES$\")\n \ndef gen_pluralize(m,f):\n\n  yield re_plural.sub(\"\",m),re_plural.sub(\"\",f)\n  yield re_ES.sub(\"es\",m),re_ES.sub(\"es\",f)\n  yield re_plural.sub(\"s\",m),re_plural.sub(\"s\",f)\n \ndef gen_capitalize_pluralize(m,f):\n  for m,f in gen_pluralize(m,f):\n    yield m.capitalize(), f.capitalize()\n    yield m,f\n \ndef gen_switch_role_capitalize_pluralize(m,f):\n  for m,f in gen_capitalize_pluralize(m,f):\n    yield m,f\n    yield f,m\n \nfor m,f in m2f:\n  for xy,xx in gen_switch_role_capitalize_pluralize(m,f):\n    if xy not in switch: \n      switch[xy]=xx\n      words.append(xy)\n \nwords=\"|\".join(words)\n \nre_word=re.compile(ur\"\\b(\"+words+ur\")\\b\")\n \ntext=u\n \n \ndef rev_gender(text):\n  text=re_word.split(text)\n  return \"\".join([ word+switch[gen] for word,gen in zip(text[::2],text[1::2])])+text[-1]\n \nprint rev_gender(text)\n"}
{"id": 383166, "name": "Reverse the gender of a string", "source": "Translate Perl to Python: my %swaps = (\n    'she'  => 'he',\n    'his'  => 'her',\n);\n\n$swaps{         $swaps{$_} } =         $_ for keys %swaps; \n$swaps{ ucfirst $swaps{$_} } = ucfirst $_ for keys %swaps; \n\nsub gender_swap {\n    my($s) = @_;\n    $s =~ s/\\b$_\\b/_$swaps{$_}/g for keys %swaps; \n    $s =~ s/_//g;                                 \n    $s;\n}\n\n$original = qq{She was this soul sherpa. She took his heart! They say she's going to put me on a shelf.\\n};\nprint $swapped  = gender_swap($original);\nprint $reverted = gender_swap($swapped);\n", "target": "\n\n \nimport re\nmale2female=u\n \nre_nl=re.compile(r\",[ \\n]*\")\nm2f=[ tok.split(\" \") for tok in re_nl.split(male2female) ]\n \nswitch={}\nwords=[]\n \n \nre_plural=re.compile(\"E*S$\")\nre_ES=re.compile(\"ES$\")\n \ndef gen_pluralize(m,f):\n\n  yield re_plural.sub(\"\",m),re_plural.sub(\"\",f)\n  yield re_ES.sub(\"es\",m),re_ES.sub(\"es\",f)\n  yield re_plural.sub(\"s\",m),re_plural.sub(\"s\",f)\n \ndef gen_capitalize_pluralize(m,f):\n  for m,f in gen_pluralize(m,f):\n    yield m.capitalize(), f.capitalize()\n    yield m,f\n \ndef gen_switch_role_capitalize_pluralize(m,f):\n  for m,f in gen_capitalize_pluralize(m,f):\n    yield m,f\n    yield f,m\n \nfor m,f in m2f:\n  for xy,xx in gen_switch_role_capitalize_pluralize(m,f):\n    if xy not in switch: \n      switch[xy]=xx\n      words.append(xy)\n \nwords=\"|\".join(words)\n \nre_word=re.compile(ur\"\\b(\"+words+ur\")\\b\")\n \ntext=u\n \n \ndef rev_gender(text):\n  text=re_word.split(text)\n  return \"\".join([ word+switch[gen] for word,gen in zip(text[::2],text[1::2])])+text[-1]\n \nprint rev_gender(text)\n"}
{"id": 383167, "name": "Index finite lists of positive integers", "source": "Translate Perl to Python: use bigint;\nuse ntheory qw(fromdigits todigitstring);\nuse feature 'say';\n\nsub rank   { join   '', fromdigits(join('a',@_), 11) }\nsub unrank { split 'a', todigitstring(@_[0],     11) }\n\nsay join ' ', @n = qw<12 11 0 7 9 15 15 5 7 13 5 5>;\nsay $n = rank(@n);\nsay join ' ', unrank $n;\n", "target": "def rank(x): return int('a'.join(map(str, [1] + x)), 11)\n\ndef unrank(n):\n\ts = ''\n\twhile n: s,n = \"0123456789a\"[n%11] + s, n//11\n\treturn map(int, s.split('a'))[1:]\n\nl = [1, 2, 3, 10, 100, 987654321]\nprint l\nn = rank(l)\nprint n\nl = unrank(n)\nprint l\n"}
{"id": 383168, "name": "Generate random numbers without repeating a value", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( shuffle );\n\nprint \"@{[ shuffle 1 .. 20 ]}\\n\" for 1 .. 5;\n", "target": "import random\n\nprint(random.sample(range(1, 21), 20))\n"}
{"id": 383169, "name": "Safe and Sophie Germain primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( forprimes is_prime);\n\nmy @want;\nforprimes { is_prime(2 * $_ + 1) and (50 == push @want, $_)\n  and print(\"@want\\n\" =~ s/.{65}\\K /\\n/gr) + exit } 2, 1e9;\n", "target": "print(\"working...\")\nrow = 0\nlimit = 1500\nSophie = []\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\nfor n in range(2,limit):\n\tp = 2*n + 1\n\tif isPrime(n) and isPrime(p):\n\t\tSophie.append(n)\n\nprint(\"Found \",end = \"\")\nprint(len(Sophie),end = \"\")\nprint(\" Safe and Sophie primes.\")\n\nprint(Sophie)\nprint(\"done...\")\n"}
{"id": 383170, "name": "Safe and Sophie Germain primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( forprimes is_prime);\n\nmy @want;\nforprimes { is_prime(2 * $_ + 1) and (50 == push @want, $_)\n  and print(\"@want\\n\" =~ s/.{65}\\K /\\n/gr) + exit } 2, 1e9;\n", "target": "print(\"working...\")\nrow = 0\nlimit = 1500\nSophie = []\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\nfor n in range(2,limit):\n\tp = 2*n + 1\n\tif isPrime(n) and isPrime(p):\n\t\tSophie.append(n)\n\nprint(\"Found \",end = \"\")\nprint(len(Sophie),end = \"\")\nprint(\" Safe and Sophie primes.\")\n\nprint(Sophie)\nprint(\"done...\")\n"}
{"id": 383171, "name": "Goldbach's comet", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::Util 'max';\nuse GD::Graph::bars;\nuse ntheory 'is_prime';\n\nsub table { my $t = shift() * (my $c = 1 + max map {length} @_); ( sprintf( ('%'.$c.'s')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub G {\n    my($n) = @_;\n    scalar grep { is_prime($_) and is_prime($n - $_) } 2 .. $n/2;\n}\n\nmy @y;\npush @y, G(2*$_ + 4) for my @x = 0..1999;\n\nsay $_ for table 10, @y;\nprintf \"G $_: %d\", G($_) for 1e6;\n\nmy @data = ( \\@x, \\@y);\nmy $graph = GD::Graph::bars->new(1200, 400);\n$graph->set(\n    title          => q/Goldbach's Comet/,\n    y_max_value    => 170,\n    x_tick_number  => 10,\n    r_margin       => 10,\n    dclrs          => [ 'blue' ],\n) or die $graph->error;\nmy $gd = $graph->plot(\\@data) or die $graph->error;\n\nopen my $fh, '>', 'goldbachs-comet.png';\nbinmode $fh;\nprint $fh $gd->png();\nclose $fh;\n", "target": "from matplotlib.pyplot import scatter, show\nfrom sympy import isprime\n\ndef g(n):\n    assert n > 2 and n % 2 == 0, 'n in goldbach function g(n) must be even'          \n    count = 0\n    for i in range(1, n//2 + 1):\n        if isprime(i) and isprime(n - i):\n            count += 1\n    return count\n\nprint('The first 100 G numbers are:')\n \ncol = 1\nfor n in range(4, 204, 2):\n    print(str(g(n)).ljust(4), end = '\\n' if (col % 10 == 0) else '')\n    col += 1\n\nprint('\\nThe value of G(1000000) is', g(1_000_000))\n \nx = range(4, 4002, 2)\ny = [g(i) for i in x]\ncolors = [[\"red\", \"blue\", \"green\"][(i // 2) % 3] for i in x]\nscatter([i // 2 for i in x], y, marker='.', color = colors)\nshow()\n"}
{"id": 383172, "name": "Cyclops numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\nuse List::AllUtils 'firstidx';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nmy @cyclops = 0;\nfor my $exp (0..3) {\n    my @oom = grep { ! /0/ } 10**$exp .. 10**($exp+1)-1;\n    for my $l (@oom) {\n        for my $r (@oom) {\n            push @cyclops, $l . '0' . $r;\n        }\n    }\n}\n\nmy @prime_cyclops = grep { is_prime $_           } @cyclops;\nmy @prime_blind   = grep { is_prime $_ =~ s/0//r } @prime_cyclops;\nmy @prime_palindr = grep { $_ eq reverse $_      } @prime_cyclops;\n\nmy $upto = 50;\nmy $over = 10_000_000;\n\nfor (\n  ['', @cyclops],\n  ['prime', @prime_cyclops],\n  ['blind prime', @prime_blind],\n  ['palindromic prime', @prime_palindr]) {\n    my($text,@values) = @$_;\n    my $i = firstidx { $_ > $over } @values;\n    say \"First $upto $text cyclops numbers:\\n\" .\n        (sprintf \"@{['%8d' x $upto]}\", @values[0..$upto-1]) =~ s/(.{80})/$1\\n/gr;\n    printf \"First $text number > %s: %s at (zero based) index: %s\\n\\n\", map { comma($_) } $over, $values[$i], $i;\n}\n", "target": "from sympy import isprime\n\n\ndef print50(a, width=8):\n    for i, n in enumerate(a):\n        print(f'{n: {width},}', end='\\n' if (i + 1) % 10 == 0 else '')\n\n\ndef generate_cyclops(maxdig=9):\n    yield 0\n    for d in range((maxdig + 1) // 2):\n        arr = [str(i) for i in range(10**d, 10**(d+1)) if not('0' in str(i))]\n        for left in arr:\n            for right in arr:\n                yield int(left + '0' + right)\n\n\ndef generate_prime_cyclops():\n    for c in generate_cyclops():\n        if isprime(c):\n            yield c\n\n\ndef generate_blind_prime_cyclops():\n    for c in generate_prime_cyclops():\n        cstr = str(c)\n        mid = len(cstr) // 2\n        if isprime(int(cstr[:mid] + cstr[mid+1:])):\n            yield c\n\n\ndef generate_palindromic_cyclops(maxdig=9):\n    for d in range((maxdig + 1) // 2):\n        arr = [str(i) for i in range(10**d, 10**(d+1)) if not('0' in str(i))]\n        for s in arr:\n            yield int(s + '0' + s[::-1])\n\n\ndef generate_palindromic_prime_cyclops():\n    for c in generate_palindromic_cyclops():\n        if isprime(c):\n            yield c\n\n\nprint('The first 50 cyclops numbers are:')\ngen = generate_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 prime cyclops numbers are:')\ngen = generate_prime_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next prime cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 blind prime cyclops numbers are:')\ngen = generate_blind_prime_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_blind_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next blind prime cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 palindromic prime cyclops numbers are:')\ngen = generate_palindromic_prime_cyclops()\nprint50([next(gen) for _ in range(50)], 11)\nfor i, c in enumerate(generate_palindromic_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next palindromic prime cyclops number after 10,000,000 is {c} at position {i}.')\n        break\n"}
{"id": 383173, "name": "Conjugate a Latin verb", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nbinmode STDOUT, ':utf8';\n\nsub conjugate {\n    my($verb) = shift;\n    join \"\\n\", map { $verb . $_ } qw<\u014d \u0101s at \u0101mus \u0101tis ant>;\n}\n\nfor my $infinitive ('am\u0101re', 'dare') {\n    say \"\\nPresent active indicative conjugation of infinitive $infinitive.\";\n    my($verb) = $infinitive =~ /^ (\\w+) [a\u0101] re $/x;\n    say $verb ? conjugate $verb : \"Sorry, don't know how to conjugate $infinitive\"\n", "target": "\n\n \ndef conjugate(infinitive): \n    if not infinitive[-3:] == \"are\":\n        print(\"'\", infinitive, \"' non prima coniugatio verbi.\\n\", sep='')\n        return False\n    \n    stem = infinitive[0:-3]\n    if len(stem) == 0:\n        print(\"\\'\", infinitive, \"\\' non satis diu conjugatus\\n\", sep='')\n        return False\n\n    print(\"Praesens indicativi temporis of '\", infinitive, \"':\", sep='') \n    for ending in (\"o\", \"as\", \"at\", \"amus\", \"atis\", \"ant\"):\n        print(\"     \", stem, ending, sep='')\n    print()\n \n \nif __name__ == '__main__':\n    for infinitive in (\"amare\", \"dare\", \"qwerty\", \"are\"):\n        conjugate(infinitive)\n"}
{"id": 383174, "name": "Conjugate a Latin verb", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nbinmode STDOUT, ':utf8';\n\nsub conjugate {\n    my($verb) = shift;\n    join \"\\n\", map { $verb . $_ } qw<\u014d \u0101s at \u0101mus \u0101tis ant>;\n}\n\nfor my $infinitive ('am\u0101re', 'dare') {\n    say \"\\nPresent active indicative conjugation of infinitive $infinitive.\";\n    my($verb) = $infinitive =~ /^ (\\w+) [a\u0101] re $/x;\n    say $verb ? conjugate $verb : \"Sorry, don't know how to conjugate $infinitive\"\n", "target": "\n\n \ndef conjugate(infinitive): \n    if not infinitive[-3:] == \"are\":\n        print(\"'\", infinitive, \"' non prima coniugatio verbi.\\n\", sep='')\n        return False\n    \n    stem = infinitive[0:-3]\n    if len(stem) == 0:\n        print(\"\\'\", infinitive, \"\\' non satis diu conjugatus\\n\", sep='')\n        return False\n\n    print(\"Praesens indicativi temporis of '\", infinitive, \"':\", sep='') \n    for ending in (\"o\", \"as\", \"at\", \"amus\", \"atis\", \"ant\"):\n        print(\"     \", stem, ending, sep='')\n    print()\n \n \nif __name__ == '__main__':\n    for infinitive in (\"amare\", \"dare\", \"qwerty\", \"are\"):\n        conjugate(infinitive)\n"}
{"id": 383175, "name": "Prime numbers which contain 123", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @hundredthousand = grep /123/, @{ primes(1e5) };\nmy $million = grep /123/, @{ primes(1e6) };\nprint \"@hundredthousand\\n\\nmillion count is $million\\n\" =~ s/.{70}\\K /\\n/gr;\n", "target": "\n\ndef prime(limite, mostrar):\n    global columna\n    columna = 0\n    \n    for n in range(limite):\n        strn = str(n)\n        if isPrime(n) and ('123' in str(n)):\n            columna += 1                \n            if mostrar == True:\n                print(n, end=\"  \");\n                if columna % 8 == 0:\n                    print('')\n    return columna\n\n\nif __name__ == \"__main__\":\n    print(\"N\u00fameros primos que contienen 123:\")\n    limite = 100000\n    prime(limite, True)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n    limite = 1000000\n    prime(limite, False)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n"}
{"id": 383176, "name": "Prime numbers which contain 123", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @hundredthousand = grep /123/, @{ primes(1e5) };\nmy $million = grep /123/, @{ primes(1e6) };\nprint \"@hundredthousand\\n\\nmillion count is $million\\n\" =~ s/.{70}\\K /\\n/gr;\n", "target": "\n\ndef prime(limite, mostrar):\n    global columna\n    columna = 0\n    \n    for n in range(limite):\n        strn = str(n)\n        if isPrime(n) and ('123' in str(n)):\n            columna += 1                \n            if mostrar == True:\n                print(n, end=\"  \");\n                if columna % 8 == 0:\n                    print('')\n    return columna\n\n\nif __name__ == \"__main__\":\n    print(\"N\u00fameros primos que contienen 123:\")\n    limite = 100000\n    prime(limite, True)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n    limite = 1000000\n    prime(limite, False)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n"}
{"id": 383177, "name": "Prime triplets", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse ntheory qw( is_prime twin_primes );\n\nis_prime($_ + 6) and printf \"%5d\" x 3 . \"\\n\", $_, $_ + 2, $_ + 6\n  for @{ twin_primes( 5500 ) };\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for p in range(3, 5499, 2):\n        if not isPrime(p+6):\n            continue\n        if not isPrime(p+2):\n            continue\n        if not isPrime(p):\n            continue\n        print(f'[{p} {p+2} {p+6}]')\n"}
{"id": 383178, "name": "Prime triplets", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse ntheory qw( is_prime twin_primes );\n\nis_prime($_ + 6) and printf \"%5d\" x 3 . \"\\n\", $_, $_ + 2, $_ + 6\n  for @{ twin_primes( 5500 ) };\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for p in range(3, 5499, 2):\n        if not isPrime(p+6):\n            continue\n        if not isPrime(p+2):\n            continue\n        if not isPrime(p):\n            continue\n        print(f'[{p} {p+2} {p+6}]')\n"}
{"id": 383179, "name": "Neighbour primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory <next_prime is_prime>;\n\nmy $p = 2;\ndo {\n    my $q = next_prime($p);\n    printf \"%3d%5d%8d\\n\", $p, $q, $p*$q+2 if is_prime $p*$q+2;\n    $p = $q;\n} until $p >= 500;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    print(\"p        q       pq+2\")\n    print(\"-----------------------\")\n    for p in range(2, 499):\n        if not isPrime(p):\n            continue\n        q = p + 1\n        while not isPrime(q):\n            q += 1\n        if not isPrime(2 + p*q):\n            continue \n        print(p, \"\\t\", q, \"\\t\", 2+p*q)\n"}
{"id": 383180, "name": "Neighbour primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory <next_prime is_prime>;\n\nmy $p = 2;\ndo {\n    my $q = next_prime($p);\n    printf \"%3d%5d%8d\\n\", $p, $q, $p*$q+2 if is_prime $p*$q+2;\n    $p = $q;\n} until $p >= 500;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    print(\"p        q       pq+2\")\n    print(\"-----------------------\")\n    for p in range(2, 499):\n        if not isPrime(p):\n            continue\n        q = p + 1\n        while not isPrime(q):\n            q += 1\n        if not isPrime(2 + p*q):\n            continue \n        print(p, \"\\t\", q, \"\\t\", 2+p*q)\n"}
{"id": 383181, "name": "Collect and sort square numbers in ascending order from three lists", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_square );\nuse List::Util qw( sum );\n\nmy @lists = (\n  [3,4,34,25,9,12,36,56,36],\n  [2,8,81,169,34,55,76,49,7],\n  [75,121,75,144,35,16,46,35]);\n\nmy $sum = sum my @squares = grep is_square($_), sort { $a <=> $b } map @$_, @lists;\nprint \"sum $sum  -  @squares\\n\";\n", "target": "import math\n\nprint(\"working...\")\nlist = [(3,4,34,25,9,12,36,56,36),(2,8,81,169,34,55,76,49,7),(75,121,75,144,35,16,46,35)]\nSquares = []\n\ndef issquare(x):\n\tfor p in range(x):\n\t\tif x == p*p:\n\t\t\treturn 1\nfor n in range(3):\n\tfor m in range(len(list[n])):\n\t\tif issquare(list[n][m]):\n\t\t\tSquares.append(list[n][m])\n\nSquares.sort()\nprint(Squares)\nprint(\"done...\")\n"}
{"id": 383182, "name": "Collect and sort square numbers in ascending order from three lists", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_square );\nuse List::Util qw( sum );\n\nmy @lists = (\n  [3,4,34,25,9,12,36,56,36],\n  [2,8,81,169,34,55,76,49,7],\n  [75,121,75,144,35,16,46,35]);\n\nmy $sum = sum my @squares = grep is_square($_), sort { $a <=> $b } map @$_, @lists;\nprint \"sum $sum  -  @squares\\n\";\n", "target": "import math\n\nprint(\"working...\")\nlist = [(3,4,34,25,9,12,36,56,36),(2,8,81,169,34,55,76,49,7),(75,121,75,144,35,16,46,35)]\nSquares = []\n\ndef issquare(x):\n\tfor p in range(x):\n\t\tif x == p*p:\n\t\t\treturn 1\nfor n in range(3):\n\tfor m in range(len(list[n])):\n\t\tif issquare(list[n][m]):\n\t\t\tSquares.append(list[n][m])\n\nSquares.sort()\nprint(Squares)\nprint(\"done...\")\n"}
{"id": 383183, "name": "Wordiff", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'min';\n\nmy %cache;\nsub leven {\n    my ($s, $t) = @_;\n    return length($t) if $s eq '';\n    return length($s) if $t eq '';\n    $cache{$s}{$t} //=\n      do {\n        my ($s1, $t1) = (substr($s, 1), substr($t, 1));\n        (substr($s, 0, 1) eq substr($t, 0, 1))\n          ? leven($s1, $t1)\n          : 1 + min(\n                    leven($s1, $t1),\n                    leven($s,  $t1),\n                    leven($s1, $t ),\n            );\n      };\n}\n\nprint \"What is your name?\"; my $name = <STDIN>;\n$name = 'Number 6';\nsay \"What is your quest? Never mind that, I will call you '$name'\";\nsay 'Hey! I am not a number, I am a free man!';\n\nmy @starters = grep { length() < 6 } my @words = grep { /.{2,}/ } split \"\\n\", `cat unixdict.txt`;\n\nmy(%used,@possibles,$guess);\nmy $rounds = 0;\nmy $word = say $starters[ rand $\n\nwhile () {\n    say \"Word in play: $word\";\n    $used{$word} = 1;\n    @possibles = ();\n    for my $w (@words) {\n        next if abs(length($word) - length($w)) > 1;\n        push @possibles, $w if leven($word, $w) == 1 and ! defined $used{$w};\n    }\n    print \"Your word? \"; $guess = <STDIN>;  chomp $guess;\n    last unless grep { $guess eq $_ } @possibles;\n    $rounds++;\n    $word = $guess;\n}\n\nmy $already = defined $used{$guess} ? \" '$guess' was already played but\" : '';\n\nif (@possibles) { say \"\\nSorry $name,${already} one of <@possibles> would have continued the game.\" }\nelse            { say \"\\nGood job $name,${already} there were no possible words to play.\"                }\nsay \"You made it through $rounds rounds.\";\n", "target": "\n\nfrom typing import List, Tuple, Dict, Set\nfrom itertools import cycle, islice\nfrom collections import Counter\nimport re\nimport random\nimport urllib\n\ndict_fname = 'unixdict.txt'\ndict_url1 = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'    \ndict_url2 = 'https://raw.githubusercontent.com/dwyl/english-words/master/words.txt'  \n\nword_regexp = re.compile(r'^[a-z]{3,}$')    \n\n\ndef load_dictionary(fname: str=dict_fname) -> Set[str]:\n    \"Return appropriate words from a dictionary file\"\n    with open(fname) as f:\n        return {lcase for lcase in (word.strip().lower() for word in f)\n                if word_regexp.match(lcase)}\n\ndef load_web_dictionary(url: str) -> Set[str]:\n    \"Return appropriate words from a dictionary web page\"\n    words = urllib.request.urlopen(url).read().decode().strip().lower().split()\n    return {word for word in words if word_regexp.match(word)}\n\n\ndef get_players() -> List[str]:\n    \"Return inputted ordered list of contestant names.\"\n    names = input('Space separated list of contestants: ')\n    return [n.capitalize() for n in names.strip().split()]\n\ndef is_wordiff(wordiffs: List[str], word: str, dic: Set[str], comment=True) -> bool:\n    \"Is word a valid wordiff from wordiffs[-1]\u00a0?\"\n    if word not in dic:\n        if comment: \n            print('That word is not in my dictionary')\n        return False\n    if word in wordiffs:\n        if comment: \n            print('That word was already used.')\n        return False\n    if len(word) < len(wordiffs[-1]):\n        return is_wordiff_removal(word, wordiffs[-1], comment)\n    elif len(word) > len(wordiffs[-1]):\n        return is_wordiff_insertion(word, wordiffs[-1], comment)\n    \n    return is_wordiff_change(word, wordiffs[-1], comment)\n\n        \ndef is_wordiff_removal(word: str, prev: str, comment=True) -> bool:\n    \"Is word derived from prev by removing one letter?\"\n    ...\n    ans = word in {prev[:i] + prev[i+1:] for i in range(len(prev))}\n    if not ans:\n        if comment: \n            print('Word is not derived from previous by removal of one letter.')\n    return ans\n\n        \ndef is_wordiff_insertion(word: str, prev: str, comment=True) -> bool:\n    \"Is word derived from prev by adding one letter?\"\n    diff = Counter(word) - Counter(prev)\n    diffcount = sum(diff.values())\n    if diffcount != 1:\n        if comment: \n            print('More than one character insertion difference.')\n        return False\n    \n    insert = list(diff.keys())[0] \n    ans =  word in {prev[:i] + insert + prev[i:] for i in range(len(prev) + 1)}\n    if not ans:\n        if comment: \n            print('Word is not derived from previous by insertion of one letter.')\n    return ans\n\n        \ndef is_wordiff_change(word: str, prev: str, comment=True) -> bool:\n    \"Is word derived from prev by changing exactly one letter?\"\n    ...\n    diffcount = sum(w != p for w, p in zip(word, prev))\n    if diffcount != 1:\n        if comment: \n            print('More or less than exactly one character changed.')\n        return False\n    return True\n\ndef could_have_got(wordiffs: List[str], dic: Set[str]):\n    return (word for word in (dic - set(wordiffs)) \n            if is_wordiff(wordiffs, word, dic, comment=False))\n\nif __name__ == '__main__':\n    dic = load_web_dictionary(dict_url2)\n    dic_3_4 = [word for word in dic if len(word) in {3, 4}]\n    start = random.choice(dic_3_4)\n    wordiffs = [start]\n    players = get_players()\n    for name in cycle(players):\n        word = input(f\"{name}: Input a wordiff from {wordiffs[-1]!r}: \").strip()\n        if is_wordiff(wordiffs, word, dic):\n            wordiffs.append(word)\n        else:\n            print(f'YOU HAVE LOST {name}!')\n            print(\"Could have used:\", \n                  ', '.join(islice(could_have_got(wordiffs, dic), 10)), '...')\n            break\n"}
{"id": 383184, "name": "Composite numbers k with no single digit factors whose factors are all substrings of k", "source": "Translate Perl to Python:  use strict;\nuse warnings;\nuse ntheory qw<is_prime factor gcd>;\n\nmy($values,$cnt);\nLOOP: for (my $k = 11; $k < 1E10; $k += 2) {\n    next if 1 < gcd($k,2*3*5*7) or is_prime $k;\n    map { next if index($k, $_) < 0 } factor $k;\n    $values .= sprintf \"%10d\", $k;\n    last LOOP if ++$cnt == 20;\n}\nprint $values =~ s/.{1,100}\\K/\\n/gr;\n", "target": "from sympy import isprime, factorint\n\ndef contains_its_prime_factors_all_over_7(n):\n    if n < 10 or isprime(n):\n        return False\n    strn = str(n)\n    pfacs = factorint(n).keys()\n    return all(f > 9 and str(f) in strn for f in pfacs)\n\nfound = 0\nfor n in range(1_000_000_000):\n    if contains_its_prime_factors_all_over_7(n):\n        found += 1\n        print(f'{n: 12,}', end = '\\n' if found % 10 == 0 else '')\n        if found == 20:\n            break\n"}
{"id": 383185, "name": "Composite numbers k with no single digit factors whose factors are all substrings of k", "source": "Translate Perl to Python:  use strict;\nuse warnings;\nuse ntheory qw<is_prime factor gcd>;\n\nmy($values,$cnt);\nLOOP: for (my $k = 11; $k < 1E10; $k += 2) {\n    next if 1 < gcd($k,2*3*5*7) or is_prime $k;\n    map { next if index($k, $_) < 0 } factor $k;\n    $values .= sprintf \"%10d\", $k;\n    last LOOP if ++$cnt == 20;\n}\nprint $values =~ s/.{1,100}\\K/\\n/gr;\n", "target": "from sympy import isprime, factorint\n\ndef contains_its_prime_factors_all_over_7(n):\n    if n < 10 or isprime(n):\n        return False\n    strn = str(n)\n    pfacs = factorint(n).keys()\n    return all(f > 9 and str(f) in strn for f in pfacs)\n\nfound = 0\nfor n in range(1_000_000_000):\n    if contains_its_prime_factors_all_over_7(n):\n        found += 1\n        print(f'{n: 12,}', end = '\\n' if found % 10 == 0 else '')\n        if found == 20:\n            break\n"}
{"id": 383186, "name": "Magic constant", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @twenty = map $_ * ( $_ ** 2 + 1 ) / 2, 3 .. 22;\nprint \"first twenty: @twenty\\n\\n\" =~ s/.{50}\\K /\\n/gr;\n\nmy $thousandth = 1002 * ( 1002 ** 2 + 1 ) / 2;\nprint \"thousandth: $thousandth\\n\\n\";\n\nprint \"10**N   order\\n\";\nfor my $i ( 1 .. 20 )\n  {\n  printf \"%3d %9d\\n\", $i, (10 ** $i * 2) ** ( 1 / 3 ) + 1;\n  }\n", "target": "\n\ndef a(n):\n    n += 2\n    return n*(n**2 + 1)/2\n \ndef inv_a(x):\n    k = 0\n    while k*(k**2+1)/2+2 < x:\n        k+=1\n    return k\n\n \nif __name__ == '__main__':\n    print(\"The first 20 magic constants are:\");\n    for n in range(1, 20):\n        print(int(a(n)), end = \" \");\n    print(\"\\nThe 1,000th magic constant is:\",int(a(1000)));\n     \n    for e in range(1, 20):\n        print(f'10^{e}: {inv_a(10**e)}');\n"}
{"id": 383187, "name": "Cullen and Woodall numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse ntheory 'is_prime';\nuse constant Inf  => 1e10;\n\nsub cullen {\n    my($n,$c) = @_;\n    ($n * 2**$n) + $c;\n}\n\nmy($m,$n);\n\n($m,$n) = (20,0);\nprint \"First $m Cullen numbers:\\n\";\nprint do { $n < $m ? (++$n and cullen($_,1) . ' ') : last } for 1 .. Inf;\n\n($m,$n) = (20,0);\nprint \"\\n\\nFirst $m Woodall numbers:\\n\";\nprint do { $n < $m ? (++$n and cullen($_,-1) . ' ') : last } for 1 .. Inf;\n\n($m,$n) = (5,0);\nprint \"\\n\\nFirst $m Cullen primes: (in terms of n)\\n\";\nprint do { $n < $m ? (!!is_prime(cullen $_,1) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\n($m,$n) = (12,0);\nprint \"\\n\\nFirst $m Woodall primes: (in terms of n)\\n\";\nprint do { $n < $m ? (!!is_prime(cullen $_,-1) and ++$n and \"$_ \") : last } for 1 .. Inf;\n", "target": "print(\"working...\")\nprint(\"First 20 Cullen numbers:\")\n\nfor n in range(1,21):\n    num = n*pow(2,n)+1\n    print(str(num),end= \" \")\n\nprint()\nprint(\"First 20 Woodall numbers:\")\n\nfor n in range(1,21):\n    num = n*pow(2,n)-1\n    print(str(num),end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 383188, "name": "Long literals, with continuations", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy $longliteral = join ' ', split ' ', <<END;\nhydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine\nneon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon\npotassium calcium scandium titanium vanadium chromium manganese iron cobalt\nnickel copper zinc gallium germanium arsenic selenium bromine krypton rubidium\nstrontium yttrium zirconium niobium molybdenum technetium ruthenium rhodium\npalladium silver cadmium indium tin antimony tellurium iodine xenon cesium\nbarium lanthanum cerium praseodymium neodymium promethium samarium europium\ngadolinium terbium dysprosium holmium erbium thulium ytterbium lutetium hafnium\ntantalum tungsten rhenium osmium iridium platinum gold mercury thallium lead\nbismuth polonium astatine radon francium radium actinium thorium protactinium\nuranium neptunium plutonium americium curium berkelium californium einsteinium\nfermium mendelevium nobelium lawrencium rutherfordium dubnium seaborgium\nbohrium hassium meitnerium darmstadtium roentgenium copernicium nihonium\nflerovium moscovium livermorium tennessine oganesson\nEND\n\nmy $version = 'Tue Feb  2 22:30:48 UTC 2021';\nmy $count = my @elements = split ' ', $longliteral;\nmy $last = $elements[-1];\n\nprint <<END;\n      version: $version\nelement count: $count\n last element: $last\nEND\n", "target": "\n\nrevision = \"October 13th 2020\"\n\n\n\n\nelements = (\n    \"hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine \"\n    \"neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon \"\n    \"potassium calcium scandium titanium vanadium chromium manganese iron \"\n    \"cobalt nickel copper zinc gallium germanium arsenic selenium bromine \"\n    \"krypton rubidium strontium yttrium zirconium niobium molybdenum \"\n    \"technetium ruthenium rhodium palladium silver cadmium indium tin \"\n    \"antimony tellurium iodine xenon cesium barium lanthanum cerium \"\n    \"praseodymium neodymium promethium samarium europium gadolinium terbium \"\n    \"dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum \"\n    \"tungsten rhenium osmium iridium platinum gold mercury thallium lead \"\n    \"bismuth polonium astatine radon francium radium actinium thorium \"\n    \"protactinium uranium neptunium plutonium americium curium berkelium \"\n    \"californium einsteinium fermium mendelevium nobelium lawrencium \"\n    \"rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium \"\n    \"roentgenium copernicium nihonium flerovium moscovium livermorium \"\n    \"tennessine oganesson\"\n)\n\n\ndef report():\n    \n    items = elements.split()\n\n    print(f\"Last revision date: {revision}\")\n    print(f\"Number of elements: {len(items)}\")\n    print(f\"Last element     \u00a0: {items[-1]}\")\n\n\nif __name__ == \"__main__\":\n    report()\n"}
{"id": 383189, "name": "Hex words", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( nsort_by uniq );\n\nsub root\n  {\n  local $_ = shift;\n  $_ = eval while s/\\B/+/g;\n  return $_;\n  }\n\nmy @bydecimal = grep +(uniq /[a-f]/g)[3],\n  my @byroot = map { sprintf \"%10s %10d %3d\\n\", $_, hex $_, root hex $_\n  } do { local(@ARGV, $/) = 'unixdict.txt'; <> =~ /^[a-f]{4,}$/gm };\n\nprint +(nsort_by { (split ' ')[2] } @byroot),\n  \"total count = @{[ scalar @byroot ]} and @{[ scalar @bydecimal\n  ]} have at least 4 distinct digits\\n\",\n  reverse nsort_by { (split ' ')[1] } @bydecimal;\n", "target": "def digroot(n):\n    while n > 9:\n        n = sum([int(d) for d in str(n)])\n    return n\n\nwith open('unixdict.txt') as f:\n    lines = [w.strip() for w in f.readlines()]\n    words = [w for w in lines if len(w) >= 4 and all(c in 'abcdef' for c in w)]\n    results = [[w, int(w, 16)] for w in words]\n    for a in results:\n        a.append(digroot(a[1]))\n        \n    print(f\"Hex words in unixdict.txt:\\nRoot  Word      Base 10\\n\", \"-\"*22)\n    for a in sorted(results, key=lambda x:x[2]):\n        print(f\"{a[2]}     {a[0]:6}{a[1]:10}\")\n        \n    print(\"Total count of these words:\", len(results))\n    print(\"\\nHex words with > 3 distinct letters:\\nRoot  Word      Base 10\\n\", \"-\"*22)\n    results = [a for a in results if len(set(str(a[0]))) > 3]\n    for a in sorted(results, key=lambda x:x[2]):\n        print(f\"{a[2]}     {a[0]:6}{a[1]:10}\")\n        \n    print(\"Total count of those words:\", len(results))\n"}
{"id": 383190, "name": "Find minimum number of coins that make a given value", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy @denominations = <200 100 50 20 10 5 2 1>;\n\nsub change {\n    my $n = shift;\n    my @a;\n    push(@a, int $n/$_) and $n %= $_ for @denominations;\n    @a\n}\n\nmy @amounts = change 988;\nfor (0 .. $\n    printf \"%1d * %3d\\n\", $amounts[$_], $denominations[$_]\n}\n", "target": "def makechange(denominations = [1,2,5,10,20,50,100,200], total = 988):\n    print(f\"Available denominations: {denominations}. Total is to be: {total}.\")\n    coins, remaining = sorted(denominations, reverse=True), total\n    for n in range(len(coins)):\n        coinsused, remaining = divmod(remaining, coins[n])\n        if coinsused > 0:\n            print(\"   \", coinsused, \"*\", coins[n])\n\nmakechange()\n"}
{"id": 383191, "name": "Longest palindromic substrings", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nprint \"Longest Palindrome For $_ = @{[ longestpalindrome($_) ]}\\n\"\n  for qw(babaccd rotator reverse forever several palindrome abaracadabra);\n\nsub longestpalindrome\n  {\n  my @best = {\"''\" => 0};\n  pop =~ /(.+) .? (??{reverse $1}) (?{ $best[length $&]{$&}++ }) (*FAIL)/x;\n  keys %{pop @best};\n  }\n", "target": "\n\n\n\ndef longestPalindromes(s):\n    \n    k = s.lower()\n    palindromes = [\n        palExpansion(k)(ab) for ab\n        in palindromicNuclei(k)\n    ]\n    maxLength = max([\n        len(x) for x in palindromes\n    ]) if palindromes else 1\n    return (\n        [\n            x for x in palindromes if maxLength == len(x)\n        ] if palindromes else list(s),\n        maxLength\n    ) if s else ([], 0)\n\n\n\ndef palindromicNuclei(s):\n    \n    cs = list(s)\n    return [\n        \n        (i, 1 + i) for (i, (a, b))\n        in enumerate(zip(cs, cs[1:]))\n        if a == b\n    ] + [\n        \n        (i, 2 + i) for (i, (a, b, c))\n        in enumerate(zip(cs, cs[1:], cs[2:]))\n        if a == c\n    ]\n\n\n\ndef palExpansion(s):\n    \n    iEnd = len(s) - 1\n\n    def limit(ij):\n        i, j = ij\n        return 0 == i or iEnd == j or s[i-1] != s[j+1]\n\n    def expansion(ij):\n        i, j = ij\n        return (i - 1, 1 + j)\n\n    def go(ij):\n        ab = until(limit)(expansion)(ij)\n        return s[ab[0]:ab[1] + 1]\n    return go\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(repr)(\n            longestPalindromes\n        )([\n            'three old rotators',\n            'never reverse',\n            'stable was I ere I saw elbatrosses',\n            'abracadabra',\n            'drome',\n            'the abbatial palace',\n            ''\n        ])\n    )\n\n\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\n\n\n\ndef fTable(s):\n    \n    def gox(xShow):\n        def gofx(fxShow):\n            def gof(f):\n                def goxs(xs):\n                    ys = [xShow(x) for x in xs]\n                    w = max(map(len, ys))\n\n                    def arrowed(x, y):\n                        return y.rjust(w, ' ') + ' -> ' + (\n                            fxShow(f(x))\n                        )\n                    return s + '\\n' + '\\n'.join(\n                        map(arrowed, xs, ys)\n                    )\n                return goxs\n            return gof\n        return gofx\n    return gox\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383192, "name": "Find squares n where n+1 is prime", "source": "Translate Perl to Python: \nuse strict; \nuse warnings;\nuse ntheory qw( primes is_square );\n\nmy @answer = grep is_square($_), map $_ - 1, @{ primes(1000) };\nprint \"@answer\\n\";\n", "target": "limit = 1000\nprint(\"working...\")\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(1,x+1):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit-1):\n\tif issquare(n) and isprime(n+1):\n\t\tprint(n,end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 383193, "name": "Find squares n where n+1 is prime", "source": "Translate Perl to Python: \nuse strict; \nuse warnings;\nuse ntheory qw( primes is_square );\n\nmy @answer = grep is_square($_), map $_ - 1, @{ primes(1000) };\nprint \"@answer\\n\";\n", "target": "limit = 1000\nprint(\"working...\")\n\ndef isprime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(1,x+1):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit-1):\n\tif issquare(n) and isprime(n+1):\n\t\tprint(n,end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 383194, "name": "Read a file character by character_UTF8", "source": "Translate Perl to Python: binmode STDOUT, ':utf8';  \n\nopen my $fh, \"<:encoding(UTF-8)\", \"input.txt\" or die \"$!\\n\";\n\nwhile (read $fh, my $char, 1) {\n    printf \"got character $char [U+%04x]\\n\", ord $char;\n}\n\nclose $fh;\n", "target": "def get_next_character(f):\n  \n  c = f.read(1)\n  while c:\n    while True:\n      try:\n        yield c.decode('utf-8')\n      except UnicodeDecodeError:\n        \n        \n        c += f.read(1)\n      else:\n        \n        c = f.read(1)\n        break\n\n\nwith open(\"input.txt\",\"rb\") as f:\n    for c in get_next_character(f):\n        print(c)\n"}
{"id": 383195, "name": "Window management", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\nuse Tk;\n\nmy $mw;\nmy $win;\nmy $lab;\n\n\nsub openWin {\n\tif( $win ) {\n\t\t$win->deiconify;\n\t\t$win->wm('state', 'normal');\n\t} else {\n\t\teval { $win->destroy } if $win;\n\t\t$win = $mw->Toplevel;\n\t\t$win->Label(-text => \"This is the window being manipulated\")\n\t\t\t->pack(-fill => 'both', -expand => 1);\n\t\t$lab->configure(-text => \"The window object is:\\n$win\");\n\t}\n}\n\n\nsub closeWin {\n\treturn unless $win;\n\t$win->destroy;\n\t$lab->configure(-text => '');\n\tundef $win;\n}\n\n\nsub minimizeWin {\n\treturn unless $win;\n\t$win->iconify;\n}\n\n\nsub maximizeWin {\n\treturn unless $win;\n\t$win->wm('state', 'zoomed');\n\teval { $win->wmAttribute(-zoomed => 1) }; \n}\n\n\nsub moveWin {\n\treturn unless $win;\n\tmy ($x, $y) = $win->geometry() =~ /\\+(\\d+)\\+(\\d+)\\z/ or die;\n\t$_ += 10 for $x, $y;\n\t$win->geometry(\"+$x+$y\");\n}\n\n\nsub resizeWin {\n\treturn unless $win;\n\tmy ($w, $h) = $win->geometry() =~ /^(\\d+)x(\\d+)/ or die;\n\t$_ += 10 for $w, $h;\n\t$win->geometry($w . \"x\" . $h);\n}\n\n$mw = MainWindow->new;\nfor my $label0 ($mw->Label(-text => 'Window handle:')) {\n\t$lab = $mw->Label(-text => '');\n\t$label0->grid($lab);\n}\n\nmy @binit = ('Open/Restore' => \\&openWin, Close => \\&closeWin,\n\tMinimize => \\&minimizeWin, Maximize => \\&maximizeWin,\n\tMove => \\&moveWin, Resize => \\&resizeWin);\n\nwhile( my ($text, $callback) = splice @binit, 0, 2 ) {\n\t$mw->Button(-text => $text, -command => $callback)->grid('-');\n}\n\nMainLoop();\n\n", "target": "from tkinter import *\nimport tkinter.messagebox\n\ndef maximise():\n\t\n\troot.geometry(\"{}x{}+{}+{}\".format(root.winfo_screenwidth(), root.winfo_screenheight(), 0, 0))\n\t\ndef minimise():\n\t\n\troot.iconify()\n\t\ndef delete():\n\t\n\tif tkinter.messagebox.askokcancel(\"OK/Cancel\",\"Are you sure?\"):\n\t\troot.quit()\n\t\nroot = Tk()\n\nmx=Button(root,text=\"maximise\",command=maximise)\nmx.grid()\nmx.bind(maximise)\n\nmn=Button(root,text=\"minimise\",command=minimise)\nmn.grid()\nmn.bind(minimise)\n\n\nroot.protocol(\"WM_DELETE_WINDOW\",delete)\n\nmainloop()\n"}
{"id": 383196, "name": "Galton box animation", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse List::Util 'any';\nuse Time::HiRes qw(sleep);\nuse List::AllUtils <pairwise pairs>;\n\nuse utf8;\nbinmode STDOUT, ':utf8';\n\nmy $coins      = shift || 100;\nmy $peg_lines  = shift || 13;\nmy $row_count  = $peg_lines;\nmy $peg        = '^';\nmy @coin_icons = (\"\\N{UPPER HALF BLOCK}\", \"\\N{LOWER HALF BLOCK}\");\n\nmy @coins = (undef) x (3 + $row_count + 4);\nmy @stats = (0) x ($row_count * 2);\n$coins[0] = 0; \n\nwhile (1) {\n    my $active = 0;\n    \n    $stats[$coins[-1] + $row_count]++ if defined $coins[-1];\n\n    \n    for my $line (reverse 1..(3+$row_count+3) ) {\n        my $coinpos = $coins[$line - 1];\n\n        \n        if (! defined $coinpos) {\n            $coins[$line] = undef\n        } elsif (hits_peg($coinpos, $line)) {\n            \n            $active = 1;\n            $coinpos += rand() < .5 ? -1 : 1;\n            $coins[$line] = $coinpos\n        } else {\n            \n            $active = 1;\n            $coins[$line] = $coinpos;\n        }\n    }\n    \n    if (defined $coins[0]) {\n        $coins[0] = undef;\n    } elsif (--$coins > 0) {\n        $coins[0] = 0\n    }\n\n    for (<0 1>) {\n        display_board(\\@coins, \\@stats, $_);\n        sleep .1;\n    }\n    exit unless $active;\n}\n\nsub display_board {\n    my($p_ref, $s_ref, $halfstep) = @_;\n    my @positions = @$p_ref;\n    my @stats     = @$s_ref;\n    my $coin      = $coin_icons[$halfstep];\n\n    my @board = do {\n        my @tmpl;\n\n        sub out {\n            my(@stuff) = split '', shift;\n            my @line;\n            push @line, ord($_) for @stuff;\n            [@line];\n        }\n\n        push @tmpl, out(\"  \" . \" \"x(2 * $row_count)) for 1..3;\n        my @a = reverse 1..$row_count;\n        my @b = 1..$row_count;\n        my @pairs = pairwise { ($a, $b) } @a, @b;\n        for ( pairs @pairs ) {\n            my ( $spaces, $pegs ) = @$_;\n            push @tmpl, out(\"  \" . \" \"x$spaces . join(' ',($peg) x $pegs) . \" \"x$spaces);\n        }\n        push @tmpl, out(\"  \" . \" \"x(2 * $row_count)) for 1..4;\n        @tmpl;\n    };\n\n    my $midpos = $row_count + 2;\n\n    our @output;\n    {\n        \n        sub printnl { my($foo) = @_; push @output, $foo . \"\\n\" }\n        sub printl  { my($foo) = @_; push @output, $foo        }\n\n        \n        printnl(\"\") for 0..9;\n\n        \n        for my $line (0..$\n            my $pos = $positions[$line];\n            next unless defined $pos;\n            $board[$line][$pos + $midpos] = ord($coin);\n        }\n        \n        for my $line (@board) {\n            printnl join '', map { chr($_) } @$line;\n        }\n\n        \n        my $padding = 0;\n        while (any {$_> 0} @stats) {\n            $padding++;\n            printl \"  \";\n            for my $i (0..$\n                if ($stats[$i] == 1) {\n                        printl \"\\N{UPPER HALF BLOCK}\";\n                        $stats[$i]--;\n                } elsif ($stats[$i] <= 0) {\n                        printl \" \";\n                        $stats[$i] = 0\n                } else {\n                        printl \"\\N{FULL BLOCK}\";\n                        $stats[$i]--; $stats[$i]--;\n                }\n            }\n            printnl(\"\");\n        }\n        printnl(\"\") for $padding..(10-1);\n    }\n\n    print join('', @output) . \"\\n\";\n}\n\nsub hits_peg {\n    my($x, $y) = @_;\n    3 <= $y && $y < (3 + $row_count) and -($y - 2) <= $x && $x <= $y - 2\n        ? not 0 == ($x - $y) % 2\n        : 0\n}\n", "target": "\n\nimport sys, os\nimport random\nimport time\n\ndef print_there(x, y, text):\n     sys.stdout.write(\"\\x1b7\\x1b[%d;%df%s\\x1b8\" % (x, y, text))\n     sys.stdout.flush()\n\n\nclass Ball():\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        \n    def update(self):\n        self.x += random.randint(0,1)\n        self.y += 1\n\n    def fall(self):\n        self.y +=1\n\n\nclass Board():\n    def __init__(self, width, well_depth, N):\n        self.balls = []\n        self.fallen = [0] * (width + 1)\n        self.width = width\n        self.well_depth = well_depth\n        self.N = N\n        self.shift = 4\n        \n    def update(self):\n        for ball in self.balls:\n            if ball.y < self.width:\n                ball.update()\n            elif ball.y < self.width + self.well_depth - self.fallen[ball.x]:\n                ball.fall()\n            elif ball.y == self.width + self.well_depth - self.fallen[ball.x]:\n                self.fallen[ball.x] += 1\n            else:\n                pass\n                \n    def balls_on_board(self):\n        return len(self.balls) - sum(self.fallen)\n                \n    def add_ball(self):\n        if(len(self.balls) <= self.N):\n            self.balls.append(Ball())\n\n    def print_board(self):\n        for y in range(self.width + 1):\n            for x in range(y):\n                print_there( y + 1 ,self.width - y + 2*x + self.shift + 1, \"\n    def print_ball(self, ball):\n        if ball.y <= self.width:\n            x = self.width - ball.y + 2*ball.x + self.shift\n        else:\n            x = 2*ball.x + self.shift\n        y = ball.y + 1\n        print_there(y, x, \"*\")\n         \n    def print_all(self):\n        print(chr(27) + \"[2J\")\n        self.print_board();\n        for ball in self.balls:\n            self.print_ball(ball)\n\n\ndef main():\n    board = Board(width = 15, well_depth = 5, N = 10)\n    board.add_ball() \n    while(board.balls_on_board() > 0):\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.add_ball()\n\n\nif __name__==\"__main__\":\n    main()\n"}
{"id": 383197, "name": "Primes - allocate descendants to their ancestors", "source": "Translate Perl to Python: use List::Util qw(sum uniq);\nuse ntheory qw(nth_prime);\n\nmy $max = 99;\nmy %tree;\n\nsub allocate {\n    my($n, $i, $sum,, $prod) = @_;\n    $i //= 0; $sum //= 0; $prod //= 1;\n\n    for my $k (0..$max) {\n        next if $k < $i;\n        my $p = nth_prime($k+1);\n        if (($sum + $p) <= $max) {\n            allocate($n, $k, $sum + $p, $prod * $p);\n        } else {\n            last if $sum == $prod;\n            $tree{$sum}{descendants}{$prod} = 1;\n            $tree{$prod}{ancestor} = [uniq $sum, @{$tree{$sum}{ancestor}}] unless $prod > $max || $sum == 0;\n            last;\n        }\n    }\n}\n\nsub abbrev { \n    my(@d) = @_;\n    return @d if @d < 11;\n    @d[0 .. 4], '...', @d[-5 .. -1];\n}\n\nallocate($_) for 1 .. $max;\n\nfor (1 .. 15, 46, $max) {\n    printf \"%2d, %2d Ancestors:\u00a0%-15s\", $_, (scalar uniq @{$tree{$_}{ancestor}}),\n        '[' . join(' ',uniq @{$tree{$_}{ancestor}}) . ']';\n    my $dn = 0; my $dl = '';\n    if ($tree{$_}{descendants}) {\n        $dn = keys %{$tree{$_}{descendants}};\n        $dl = join ' ', abbrev(sort { $a <=> $b } keys %{$tree{$_}{descendants}});\n    }\n    printf \"%5d Descendants: %s\", $dn, \"[$dl]\\n\";\n}\n\nmap { for my $k (keys %{$tree{$_}{descendants}}) { $total += $tree{$_}{descendants}{$k} } } 1..$max;\nprint \"\\nTotal descendants: $total\\n\";\n", "target": "from __future__ import print_function\nfrom itertools import takewhile\n\nmaxsum = 99\n\ndef get_primes(max):\n    if max < 2:\n        return []\n    lprimes = [2]\n    for x in range(3, max + 1, 2):\n        for p in lprimes:\n            if x % p == 0:\n                break\n        else:\n            lprimes.append(x)\n    return lprimes\n\ndescendants = [[] for _ in range(maxsum + 1)]\nancestors = [[] for _ in range(maxsum + 1)]\n\nprimes = get_primes(maxsum)\n\nfor p in primes:\n    descendants[p].append(p)\n    for s in range(1, len(descendants) - p):\n        descendants[s + p] += [p * pr for pr in descendants[s]]\n\nfor p in primes + [4]:\n    descendants[p].pop()\n\ntotal = 0\nfor s in range(1, maxsum + 1):\n    descendants[s].sort()\n    for d in takewhile(lambda x: x <= maxsum, descendants[s]):\n        ancestors[d] = ancestors[s] + [s]\n    print([s], \"Level:\", len(ancestors[s]))\n    print(\"Ancestors:\", ancestors[s] if len(ancestors[s]) else \"None\")\n    print(\"Descendants:\", len(descendants[s]) if len(descendants[s]) else \"None\")\n    if len(descendants[s]):\n        print(descendants[s])\n    print()\n    total += len(descendants[s])\n\nprint(\"Total descendants\", total)\n"}
{"id": 383198, "name": "Smallest square that begins with n", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse constant Inf => 10e12; \n\nfor my $n (1..49) {\n   do { printf \"%2d: %3d^2 = %5d\\n\", $n, $_, $_**2 and last if $_**2 =~ /^$n/ } for 1..Inf\n}\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383199, "name": "Smallest square that begins with n", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse constant Inf => 10e12; \n\nfor my $n (1..49) {\n   do { printf \"%2d: %3d^2 = %5d\\n\", $n, $_, $_**2 and last if $_**2 =~ /^$n/ } for 1..Inf\n}\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383200, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Perl to Python: sub circlesort {\n    our @x; local *x = shift;\n    my($beg,$end) = @_;\n\n    my $swaps = 0;\n    if ($beg < $end) {\n        my $lo = $beg;\n        my $hi = $end;\n        while ($lo < $hi) {\n            if ($x[$lo] > $x[$hi]) { \n                @x[$lo,$hi] = @x[$hi,$lo];\n                ++$swaps;\n            }\n            ++$hi if --$hi == ++$lo\n        }\n        $swaps += circlesort(\\@x, $beg, $hi);\n        $swaps += circlesort(\\@x, $lo, $end);\n    }\n    $swaps;\n}\n\nmy @a = <16 35 -64 -29 46 36 -1 -99 20 100 59 26 76 -78 39 85 -7 -81 25 88>;\nwhile (circlesort(\\@a, 0, $\n", "target": "\n\n\n\n\ndef circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':\n    \n    n = R-L\n    if n < 2:\n        return 0\n    swaps = 0\n    m = n//2\n    for i in range(m):\n        if A[R-(i+1)] < A[L+i]:\n            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)\n            swaps += 1\n    if (n & 1) and (A[L+m] < A[L+m-1]):\n        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)\n        swaps += 1\n    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R)\n\ndef circle_sort(L:list)->'sort A in place, returning the number of swaps':\n    swaps = 0\n    s = 1\n    while s:\n        s = circle_sort_backend(L, 0, len(L))\n        swaps += s\n    return swaps\n\n\nif __name__ == '__main__':\n    from random import shuffle\n    for i in range(309):\n        L = list(range(i))\n        M = L[:]\n        shuffle(L)\n        N = L[:]\n        circle_sort(L)\n        if L != M:\n            print(len(L))\n            print(N)\n            print(L)\n"}
{"id": 383201, "name": "Word wheel", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\n$_ = <<END;\n                    N  D  E\n                    O  K  G\n                    E  L  W\nEND\n\nmy $file = do { local(@ARGV, $/) = 'unixdict.txt'; <> };\nmy $length = my @letters = lc =~ /\\w/g;\nmy $center = $letters[@letters / 2];\nmy $toomany = (join '', sort @letters) =~ s/(.)\\1*/\n  my $count = length \"$1$&\"; \"(?!(?:.*$1){$count})\" /ger;\nmy $valid = qr/^(?=.*$center)$toomany([@letters]{3,$length}$)$/m;\n\nmy @words = $file =~ /$valid/g;\n\nprint @words . \" words for\\n$_\\n@words\\n\" =~ s/.{60}\\K /\\n/gr;\n", "target": "import urllib.request\nfrom collections import Counter\n\n\nGRID = \n\n\ndef getwords(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    \"Return lowercased words of 3 to 9 characters\"\n    words = urllib.request.urlopen(url).read().decode().strip().lower().split()\n    return (w for w in words if 2 < len(w) < 10)\n\ndef solve(grid, dictionary):\n    gridcount = Counter(grid)\n    mid = grid[4]\n    return [word for word in dictionary\n            if mid in word and not (Counter(word) - gridcount)]\n\n\nif __name__ == '__main__':\n    chars = ''.join(GRID.strip().lower().split())\n    found = solve(chars, dictionary=getwords())\n    print('\\n'.join(found))\n"}
{"id": 383202, "name": "Brace expansion", "source": "Translate Perl to Python: sub brace_expand {\n    my $input = shift;\n    my @stack = ([my $current = ['']]);\n    \n    while ($input =~ /\\G ((?:[^\\\\{,}]++ | \\\\(?:.|\\z))++ | . )/gx) {\n        if ($1 eq '{') {\n            push @stack, [$current = ['']];\n        }\n        elsif ($1 eq ',' && @stack > 1) {\n            push @{$stack[-1]}, ($current = ['']);\n        }\n        elsif ($1 eq '}' && @stack > 1) {\n            my $group = pop @stack;\n            $current = $stack[-1][-1];\n            \n            \n            @{$group->[0]} = map { \"{$_}\" } @{$group->[0]} if @$group == 1;\n            \n            @$current = map {\n                my $c = $_;\n                map { map { $c . $_ } @$_ } @$group;\n            } @$current;\n        }\n        else { $_ .= $1 for @$current; }\n    }\n    \n    \n    while (@stack > 1) {\n        my $right = pop @{$stack[-1]};\n        my $sep;\n        if (@{$stack[-1]}) { $sep = ',' }\n        else               { $sep = '{'; pop @stack }\n        $current = $stack[-1][-1];\n        @$current = map {\n            my $c = $_;\n            map { $c . $sep . $_ } @$right;\n        } @$current;\n    }\n    \n    return @$current;\n}\n", "target": "def getitem(s, depth=0):\n    out = [\"\"]\n    while s:\n        c = s[0]\n        if depth and (c == ',' or c == '}'):\n            return out,s\n        if c == '{':\n            x = getgroup(s[1:], depth+1)\n            if x:\n                out,s = [a+b for a in out for b in x[0]], x[1]\n                continue\n        if c == '\\\\' and len(s) > 1:\n            s, c = s[1:], c + s[1]\n\n        out, s = [a+c for a in out], s[1:]\n\n    return out,s\n\ndef getgroup(s, depth):\n    out, comma = [], False\n    while s:\n        g,s = getitem(s, depth)\n        if not s: break\n        out += g\n\n        if s[0] == '}':\n            if comma: return out, s[1:]\n            return ['{' + a + '}' for a in out], s[1:]\n\n        if s[0] == ',':\n            comma,s = True, s[1:]\n\n    return None\n\n\nfor s in .split('\\n'):\n    print \"\\n\\t\".join([s] + getitem(s)[0]) + \"\\n\"\n"}
{"id": 383203, "name": "Intersecting number wheels", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub get_next {\n    my($w,%wheels) = @_;\n    my $wh = \\@{$wheels{$w}}; \n    my $value = $$wh[0][$$wh[1]];\n    $$wh[1] = ($$wh[1]+1) % @{$$wh[0]};\n    defined $wheels{$value} ? get_next($value,%wheels) : $value;\n}\n\nsub spin_wheels {\n    my(%wheels) = @_;\n    say \"$_: \" . join ', ', @{${$wheels{$_}}[0]} for sort keys %wheels;\n    print get_next('A', %wheels) . ' ' for 1..20; print \"\\n\\n\";\n}\n\nspin_wheels(%$_) for\n(\n {'A' => [['1', '2', '3'], 0]},\n {'A' => [['1', 'B', '2'], 0], 'B' => [['3', '4'], 0]},\n {'A' => [['1', 'D', 'D'], 0], 'D' => [['6', '7', '8'], 0]},\n {'A' => [['1', 'B', 'C'], 0], 'B' => [['3', '4'], 0], 'C' => [['5', 'B'], 0]},\n);\n", "target": "from itertools import islice\n\nclass INW():\n    \n\n    def __init__(self, **wheels):\n        self._wheels = wheels\n        self.isect = {name: self._wstate(name, wheel) \n                      for name, wheel in wheels.items()}\n    \n    def _wstate(self, name, wheel):\n        \"Wheel state holder\"\n        assert all(val in self._wheels for val in wheel if type(val) == str), \\\n               f\"ERROR: Interconnected wheel not found in {name}: {wheel}\"\n        pos = 0\n        ln = len(wheel)\n        while True:\n            nxt, pos = wheel[pos % ln], pos + 1\n            yield next(self.isect[nxt]) if type(nxt) == str else nxt\n                \n    def __iter__(self):\n        base_wheel_name = next(self.isect.__iter__())\n        yield from self.isect[base_wheel_name]\n        \n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self._wheels})\"\n    \n    def __str__(self):\n        txt = \"Intersecting Number Wheel group:\"\n        for name, wheel in self._wheels.items():\n            txt += f\"\\n  {name+':':4}\" + ' '.join(str(v) for v in wheel)\n        return txt\n\ndef first(iter, n):\n    \"Pretty print first few terms\"\n    return ' '.join(f\"{nxt}\" for nxt in islice(iter, n))\n\nif __name__ == '__main__':\n    for group in[\n      {'A': (1, 2, 3)},\n      {'A': (1, 'B', 2),\n       'B': (3, 4)},\n      {'A': (1, 'D', 'D'),\n       'D': (6, 7, 8)},\n      {'A': (1, 'B', 'C'),\n       'B': (3, 4),\n       'C': (5, 'B')}, \n     ]:\n        w = INW(**group)\n        print(f\"{w}\\n  Generates:\\n    {first(w, 20)} ...\\n\")\n"}
{"id": 383204, "name": "Intersecting number wheels", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub get_next {\n    my($w,%wheels) = @_;\n    my $wh = \\@{$wheels{$w}}; \n    my $value = $$wh[0][$$wh[1]];\n    $$wh[1] = ($$wh[1]+1) % @{$$wh[0]};\n    defined $wheels{$value} ? get_next($value,%wheels) : $value;\n}\n\nsub spin_wheels {\n    my(%wheels) = @_;\n    say \"$_: \" . join ', ', @{${$wheels{$_}}[0]} for sort keys %wheels;\n    print get_next('A', %wheels) . ' ' for 1..20; print \"\\n\\n\";\n}\n\nspin_wheels(%$_) for\n(\n {'A' => [['1', '2', '3'], 0]},\n {'A' => [['1', 'B', '2'], 0], 'B' => [['3', '4'], 0]},\n {'A' => [['1', 'D', 'D'], 0], 'D' => [['6', '7', '8'], 0]},\n {'A' => [['1', 'B', 'C'], 0], 'B' => [['3', '4'], 0], 'C' => [['5', 'B'], 0]},\n);\n", "target": "from itertools import islice\n\nclass INW():\n    \n\n    def __init__(self, **wheels):\n        self._wheels = wheels\n        self.isect = {name: self._wstate(name, wheel) \n                      for name, wheel in wheels.items()}\n    \n    def _wstate(self, name, wheel):\n        \"Wheel state holder\"\n        assert all(val in self._wheels for val in wheel if type(val) == str), \\\n               f\"ERROR: Interconnected wheel not found in {name}: {wheel}\"\n        pos = 0\n        ln = len(wheel)\n        while True:\n            nxt, pos = wheel[pos % ln], pos + 1\n            yield next(self.isect[nxt]) if type(nxt) == str else nxt\n                \n    def __iter__(self):\n        base_wheel_name = next(self.isect.__iter__())\n        yield from self.isect[base_wheel_name]\n        \n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self._wheels})\"\n    \n    def __str__(self):\n        txt = \"Intersecting Number Wheel group:\"\n        for name, wheel in self._wheels.items():\n            txt += f\"\\n  {name+':':4}\" + ' '.join(str(v) for v in wheel)\n        return txt\n\ndef first(iter, n):\n    \"Pretty print first few terms\"\n    return ' '.join(f\"{nxt}\" for nxt in islice(iter, n))\n\nif __name__ == '__main__':\n    for group in[\n      {'A': (1, 2, 3)},\n      {'A': (1, 'B', 2),\n       'B': (3, 4)},\n      {'A': (1, 'D', 'D'),\n       'D': (6, 7, 8)},\n      {'A': (1, 'B', 'C'),\n       'B': (3, 4),\n       'C': (5, 'B')}, \n     ]:\n        w = INW(**group)\n        print(f\"{w}\\n  Generates:\\n    {first(w, 20)} ...\\n\")\n"}
{"id": 383205, "name": "Color of a screen pixel", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse GD;\n\nmy $file = '/tmp/one-pixel-screen-capture.png';\n\nsystem \"screencapture -R 123,456,1,1 $file\";\n\nmy $image = GD::Image->newFromPng($file);\nmy $index = $image->getPixel(0,0);\nmy($red,$green,$blue) = $image->rgb($index);\nprint \"RGB: $red, $green, $blue\\n\";\n\nunlink $file;\n", "target": "def get_pixel_colour(i_x, i_y):\n\timport win32gui\n\ti_desktop_window_id = win32gui.GetDesktopWindow()\n\ti_desktop_window_dc = win32gui.GetWindowDC(i_desktop_window_id)\n\tlong_colour = win32gui.GetPixel(i_desktop_window_dc, i_x, i_y)\n\ti_colour = int(long_colour)\n\twin32gui.ReleaseDC(i_desktop_window_id,i_desktop_window_dc)\n\treturn (i_colour & 0xff), ((i_colour >> 8) & 0xff), ((i_colour >> 16) & 0xff)\n\nprint (get_pixel_colour(0, 0))\n"}
{"id": 383206, "name": "Yahoo! search interface", "source": "Translate Perl to Python: package YahooSearch;\n\nuse Encode;\nuse HTTP::Cookies;  \nuse WWW::Mechanize;\n\n\n\nsub apply (&$)\n {my $f = shift; local $_ = shift; $f->(); return $_;}\n\n\n\nmy $search_prefs = 'v=1&n=100&sm=' .\n    apply {s/([^a-zA-Z0-9])/sprintf '%%%02X', ord $1/ge}\n    join '|',\n    map {'!' . $_}\n    qw(hsb Zq0 XbM sss dDO VFM RQh uZ0 Fxe yCl GP4 FZK yNC mEG niH);\nmy $cookies = HTTP::Cookies->new;\n$cookies->set_cookie(0, 'sB', $search_prefs, '/', 'search.yahoo.com');\n\nmy $mech = new WWW::Mechanize\n   (cookie_jar => $cookies,\n    stack_depth => 0);\n\nsub read_page\n {my ($next, $page, @results) =\n     ($mech->find_link(text => 'Next >')->url,\n      decode 'iso-8859-1', $mech->content);\n  while ($page =~ m\n         {<h3> <a \\s class=\"yschttl \\s spt\" \\s\n          href=\" ([^\"]+) \" \\s* >                \n          (.+?) </a>\n          .+?\n          <div \\s class=\"abstr\">\n          (.+?) </div>}xg)\n     {push @results, {url => $1, title => $2, content => $3};\n      foreach ( @{$results[-1]}{qw(title content)} )\n         {s/<.+?>//g;\n          $_ = encode 'utf8', $_;}}\n  return $next, \\@results;}\n\n\n\nsub new\n {my $invocant = shift;\n  my $class = ref($invocant) || $invocant;\n  $mech->get('http://search.yahoo.com/search?p=' . apply\n     {s/([^a-zA-Z0-9 ])/sprintf '%%%02X', ord $1/ge;\n      s/ /+/g;}\n    shift);\n  my ($next, $results) = read_page();\n  return bless {link_to_next => $next, results => $results}, $class;}\n\nsub results\n {@{shift()->{results}};}\n\nsub next_page\n {my $invocant = shift;\n  my $next = $invocant->{link_to_next};\n  unless ($next)\n     {$invocant->{results} = [];\n      return undef;}\n  $mech->get($next);\n  ($next, my $results) = read_page();\n  $invocant->{link_to_next} = $next;\n  $invocant->{results} = $results;\n  return 1;}\n", "target": "import urllib\nimport re\n\ndef fix(x):\n    p = re.compile(r'<[^<]*?>')\n    return p.sub('', x).replace('&amp;', '&')\n \nclass YahooSearch:\n    def __init__(self, query, page=1):       \n        self.query = query\n        self.page = page\n        self.url = \"http://search.yahoo.com/search?p=%s&b=%s\" %(self.query, ((self.page - 1) * 10 + 1))\n        self.content = urllib.urlopen(self.url).read()        \n \n    def getresults(self):\n        self.results = []\n \n        for i in re.findall('<a class=\"yschttl spt\" href=\".+?\">(.+?)</a></h3></div>(.+?)</div>.*?<span class=url>(.+?)</span>', self.content):\n \n            title = fix(i[0])\n            content = fix(i[1])\n            url = fix(i[2])\n \n            self.results.append(YahooResult(title, content, url))\n \n        return self.results\n \n    def getnextpage(self):\n        return YahooSearch(self.query, self.page+1)\n \n    search_results = property(fget=getresults)\n    nextpage = property(fget=getnextpage)\n \nclass YahooResult:\n    def __init__(self,title,content,url):\n        self.title = title\n        self.content = content\n        self.url = url\n \n\n \nx = YahooSearch(\"test\")\n \nfor result in x.search_results:\n    print result.title\n"}
{"id": 383207, "name": "Circles of given radius through two points", "source": "Translate Perl to Python: use strict;\n\nsub circles {\n    my ($x1, $y1, $x2, $y2, $r) = @_;\n\n    return \"Radius is zero\" if $r == 0;\n    return \"Coincident points gives infinite number of circles\" if $x1 == $x2 and $y1 == $y2;\n\n    \n    my ($dx, $dy) = ($x2 - $x1, $y2 - $y1);\n    my $q = sqrt($dx**2 + $dy**2);\n    return \"Separation of points greater than diameter\" if $q > 2*$r;\n\n    \n    my ($x3, $y3) = (($x1 + $x2) / 2, ($y1 + $y2) / 2);\n    \n    my $d = sqrt($r**2-($q/2)**2);\n\n    \n    sprintf '(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f)',\n        $x3 - $d*$dy/$q, $y3 + $d*$dx/$q,\n        $x3 + $d*$dy/$q, $y3 - $d*$dx/$q;\n}\n\nmy @arr = (\n    [0.1234, 0.9876, 0.8765, 0.2345, 2.0],\n    [0.0000, 2.0000, 0.0000, 0.0000, 1.0],\n    [0.1234, 0.9876, 0.1234, 0.9876, 2.0],\n    [0.1234, 0.9876, 0.8765, 0.2345, 0.5],\n    [0.1234, 0.9876, 0.1234, 0.9876, 0.0]\n);\n\nprintf \"(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f) with radius\u00a0%.1f: %s\\n\", @$_[0..4], circles @$_ for @arr;\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 383208, "name": "Circles of given radius through two points", "source": "Translate Perl to Python: use strict;\n\nsub circles {\n    my ($x1, $y1, $x2, $y2, $r) = @_;\n\n    return \"Radius is zero\" if $r == 0;\n    return \"Coincident points gives infinite number of circles\" if $x1 == $x2 and $y1 == $y2;\n\n    \n    my ($dx, $dy) = ($x2 - $x1, $y2 - $y1);\n    my $q = sqrt($dx**2 + $dy**2);\n    return \"Separation of points greater than diameter\" if $q > 2*$r;\n\n    \n    my ($x3, $y3) = (($x1 + $x2) / 2, ($y1 + $y2) / 2);\n    \n    my $d = sqrt($r**2-($q/2)**2);\n\n    \n    sprintf '(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f)',\n        $x3 - $d*$dy/$q, $y3 + $d*$dx/$q,\n        $x3 + $d*$dy/$q, $y3 - $d*$dx/$q;\n}\n\nmy @arr = (\n    [0.1234, 0.9876, 0.8765, 0.2345, 2.0],\n    [0.0000, 2.0000, 0.0000, 0.0000, 1.0],\n    [0.1234, 0.9876, 0.1234, 0.9876, 2.0],\n    [0.1234, 0.9876, 0.8765, 0.2345, 0.5],\n    [0.1234, 0.9876, 0.1234, 0.9876, 0.0]\n);\n\nprintf \"(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f) with radius\u00a0%.1f: %s\\n\", @$_[0..4], circles @$_ for @arr;\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 383209, "name": "Vampire number", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\nuse feature qw(say);\n\nsub fangs {\n    my $vampire = shift;\n    my $length  = length 0 + $vampire;\n    return if $length % 2;\n    my $fang_length = $length / 2;\n    my $from        = '1' . '0' x ($fang_length - 1);\n    my $to          = '9' x $fang_length;\n    my $sorted      = join q(), sort split //, $vampire;\n    my @fangs;\n    for my $f1 ($from .. 1 + sqrt $vampire) {\n        next if $vampire % $f1;\n        my $f2 = $vampire / $f1;\n        next if $sorted ne join q(), sort split //, $f1 . $f2;\n        next if 2 == grep '0' eq substr($_, -1 , 1), $f1, $f2; \n        push @fangs, [$f1, $f2];\n    }\n    return @fangs;\n}\n\nmy $count = 0;\nmy $i     = 9;\nwhile ($count < 25) {\n    $i++;\n    my @f = fangs($i);\n    $count++, say join ' ', \"$count. $i:\", map \"[@$_]\", @f if @f;\n}\n\nsay join ' ', $_, map \"[@$_]\", fangs($_) for 16758243290880, 24959017348650, 14593825548650;\n", "target": "from __future__ import division\n\nimport math\nfrom operator import mul\nfrom itertools import product\nfrom functools import reduce\n\n\ndef fac(n):\n    \n    step = lambda x: 1 + x*4 - (x//2)*2\n    maxq = int(math.floor(math.sqrt(n)))\n    d = 1\n    q = n % 2 == 0 and 2 or 3 \n    while q <= maxq and n % q != 0:\n        q = step(d)\n        d += 1\n    res = []\n    if q <= maxq:\n        res.extend(fac(n//q))\n        res.extend(fac(q)) \n    else: res=[n]\n    return res\n\ndef fact(n):\n    \n    res = fac(n)\n    return [(c, res.count(c)) for c in set(res)]\n\ndef divisors(n):\n    'Returns all the divisors of n'\n    factors = fact(n)   \n    primes, maxpowers = zip(*factors)\n    powerranges = (range(m+1) for m in maxpowers)\n    powers = product(*powerranges)\n    return (\n        reduce(mul,\n               (prime**power for prime, power in zip(primes, powergroup)),\n               1)\n        for powergroup in powers)\n    \ndef vampire(n):\n    fangsets = set( frozenset([d, n//d])\n                    for d in divisors(n)\n                    if (len(str(d)) == len(str(n))/2.\n                        and sorted(str(d) + str(n//d)) == sorted(str(n))\n                        and (str(d)[-1] == 0) + (str(n//d)[-1] == 0) <=1) )\n    return sorted(tuple(sorted(fangs)) for fangs in fangsets)\n    \n\nif __name__ == '__main__':\n    print('First 25 vampire numbers')\n    count = n = 0\n    while count <25:\n        n += 1\n        fangpairs = vampire(n)\n        if fangpairs:\n            count += 1\n            print('%i: %r' % (n, fangpairs))\n    print('\\nSpecific checks for fangpairs')\n    for n in (16758243290880, 24959017348650, 14593825548650):\n        fangpairs = vampire(n)\n        print('%i: %r' % (n, fangpairs))\n"}
{"id": 383210, "name": "Mind boggling card trick", "source": "Translate Perl to Python: sub trick {\n    my(@deck) = @_;\n    my $result .= sprintf \"%-28s @deck\\n\", 'Starting deck:';\n\n    my(@discard, @red, @black);\n    deal(\\@deck, \\@discard, \\@red, \\@black);\n\n    $result .= sprintf \"%-28s @red\\n\", 'Red     pile:';\n    $result .= sprintf \"%-28s @black\\n\", 'Black   pile:';\n\n    my $n = int rand(+@red < +@black ? +@red : +@black);\n    swap(\\@red, \\@black, $n);\n\n    $result .= sprintf \"Red pile   after %2d swapped: @red\\n\", $n;\n    $result .= sprintf \"Black pile after %2d swapped: @black\\n\", $n;\n\n    $result .= sprintf \"Red in Red, Black in Black:  %d = %d\\n\", (scalar grep {/R/} @red), scalar grep {/B/} @black;\n    return \"$result\\n\";\n}\n\nsub deal {\n    my($c, $d, $r, $b) = @_;\n    while (@$c) {\n        my $top = shift @$c;\n        if ($top eq 'R') { push @$r, shift @$c }\n        else             { push @$b, shift @$c }\n        push @$d, $top;\n    }\n}\n\nsub swap {\n    my($r, $b, $n) = @_;\n    push @$r, splice @$b, 0, $n;\n    push @$b, splice @$r, 0, $n;\n}\n\n@deck = split '', 'RB' x 26;               \nprint trick(@deck);\n@deck = split '', 'RRBB' x 13;             \nprint trick(@deck);\n@deck = sort @deck;                        \nprint trick(@deck);\n@deck = sort { -1 + 2*int(rand 2) } @deck; \nprint trick(@deck);\n", "target": "import random\n\n\nn = 52\nBlack, Red = 'Black', 'Red'\nblacks = [Black] * (n // 2) \nreds = [Red] * (n // 2)\npack = blacks + reds\n\nrandom.shuffle(pack)\n\n\nblack_stack, red_stack, discard = [], [], []\nwhile pack:\n    top = pack.pop()\n    if top == Black:\n        black_stack.append(pack.pop())\n    else:\n        red_stack.append(pack.pop())\n    discard.append(top)\nprint('(Discards:', ' '.join(d[0] for d in discard), ')\\n')\n\n\n\nmax_swaps = min(len(black_stack), len(red_stack))\n\nswap_count = random.randint(0, max_swaps)\nprint('Swapping', swap_count)\n\ndef random_partition(stack, count):\n    \"Partition the stack into 'count' randomly selected members and the rest\"\n    sample = random.sample(stack, count)\n    rest = stack[::]\n    for card in sample:\n        rest.remove(card)\n    return rest, sample\n\nblack_stack, black_swap = random_partition(black_stack, swap_count)\nred_stack, red_swap = random_partition(red_stack, swap_count)\n\n\nblack_stack += red_swap\nred_stack += black_swap\n\n\nif black_stack.count(Black) == red_stack.count(Red):\n    print('Yeha! The mathematicians assertion is correct.')\nelse:\n    print('Whoops - The mathematicians (or my card manipulations) are flakey')\n"}
{"id": 383211, "name": "Mind boggling card trick", "source": "Translate Perl to Python: sub trick {\n    my(@deck) = @_;\n    my $result .= sprintf \"%-28s @deck\\n\", 'Starting deck:';\n\n    my(@discard, @red, @black);\n    deal(\\@deck, \\@discard, \\@red, \\@black);\n\n    $result .= sprintf \"%-28s @red\\n\", 'Red     pile:';\n    $result .= sprintf \"%-28s @black\\n\", 'Black   pile:';\n\n    my $n = int rand(+@red < +@black ? +@red : +@black);\n    swap(\\@red, \\@black, $n);\n\n    $result .= sprintf \"Red pile   after %2d swapped: @red\\n\", $n;\n    $result .= sprintf \"Black pile after %2d swapped: @black\\n\", $n;\n\n    $result .= sprintf \"Red in Red, Black in Black:  %d = %d\\n\", (scalar grep {/R/} @red), scalar grep {/B/} @black;\n    return \"$result\\n\";\n}\n\nsub deal {\n    my($c, $d, $r, $b) = @_;\n    while (@$c) {\n        my $top = shift @$c;\n        if ($top eq 'R') { push @$r, shift @$c }\n        else             { push @$b, shift @$c }\n        push @$d, $top;\n    }\n}\n\nsub swap {\n    my($r, $b, $n) = @_;\n    push @$r, splice @$b, 0, $n;\n    push @$b, splice @$r, 0, $n;\n}\n\n@deck = split '', 'RB' x 26;               \nprint trick(@deck);\n@deck = split '', 'RRBB' x 13;             \nprint trick(@deck);\n@deck = sort @deck;                        \nprint trick(@deck);\n@deck = sort { -1 + 2*int(rand 2) } @deck; \nprint trick(@deck);\n", "target": "import random\n\n\nn = 52\nBlack, Red = 'Black', 'Red'\nblacks = [Black] * (n // 2) \nreds = [Red] * (n // 2)\npack = blacks + reds\n\nrandom.shuffle(pack)\n\n\nblack_stack, red_stack, discard = [], [], []\nwhile pack:\n    top = pack.pop()\n    if top == Black:\n        black_stack.append(pack.pop())\n    else:\n        red_stack.append(pack.pop())\n    discard.append(top)\nprint('(Discards:', ' '.join(d[0] for d in discard), ')\\n')\n\n\n\nmax_swaps = min(len(black_stack), len(red_stack))\n\nswap_count = random.randint(0, max_swaps)\nprint('Swapping', swap_count)\n\ndef random_partition(stack, count):\n    \"Partition the stack into 'count' randomly selected members and the rest\"\n    sample = random.sample(stack, count)\n    rest = stack[::]\n    for card in sample:\n        rest.remove(card)\n    return rest, sample\n\nblack_stack, black_swap = random_partition(black_stack, swap_count)\nred_stack, red_swap = random_partition(red_stack, swap_count)\n\n\nblack_stack += red_swap\nred_stack += black_swap\n\n\nif black_stack.count(Black) == red_stack.count(Red):\n    print('Yeha! The mathematicians assertion is correct.')\nelse:\n    print('Whoops - The mathematicians (or my card manipulations) are flakey')\n"}
{"id": 383212, "name": "Cistercian numerals", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @pts = ('', qw( 01 23 03 12 012 13 013 132 0132) );\nmy @dots = qw( 4-0 8-0 4-4 8-4 );\n\nmy @images = map { sprintf(\"%-9s\\n\", \"$_:\") . draw($_) }\n  0, 1, 20, 300, 4000, 5555, 6789, 1133;\nfor ( 1 .. 13 )\n  {\n  s/(.+)\\n/ print \" $1\"; '' /e for @images;\n  print \"\\n\";\n  }\n\nsub draw\n  {\n  my $n = shift;\n  local $_ = \"    \n  my $quadrant = 0;\n  for my $digit ( reverse split //, sprintf \"%04d\", $n )\n    {\n    my ($oldx, $oldy);\n    for my $cell ( split //, $pts[$digit] )\n      {\n      my ($x, $y) = split /-/, $dots[$cell];\n      if( defined $oldx )\n        {\n        my $dirx = $x <=> $oldx;\n        my $diry = $y <=> $oldy;\n        for my $place ( 0 .. 3 )\n          {\n          substr $_, $oldx + $oldy * 10, 1, '\n          $oldx += $dirx;\n          $oldy += $diry;\n          }\n        }\n      ($oldx, $oldy) = ($x, $y);\n      }\n    s/.+/ reverse $& /ge;\n    ++$quadrant & 1 or $_ = join '', reverse /.+\\n/g;\n    }\n  return $_;\n  }\n", "target": "\n\n\n\n\ndef _init():\n    \"digit sections for forming numbers\"\n    digi_bits = .strip()\n\n    lines = [[d.replace('.', ' ') for d in ln.strip().split()]\n             for ln in digi_bits.strip().split('\\n')\n             if '\n    formats = '<2 >2 <2 >2'.split()\n    digits = [[f\"{dig:{f}}\" for dig in line]\n              for f, line in zip(formats, lines)]\n\n    return digits\n\n_digits = _init()\n\n\n\ndef _to_digits(n):\n    assert 0 <= n < 10_000 and int(n) == n\n    \n    return [int(digit) for digit in f\"{int(n):04}\"][::-1]\n\ndef num_to_lines(n):\n    global _digits\n    d = _to_digits(n)\n    lines = [\n        ''.join((_digits[1][d[1]], '\u2503',  _digits[0][d[0]])),\n        ''.join((_digits[0][   0], '\u2503',  _digits[0][   0])),\n        ''.join((_digits[3][d[3]], '\u2503',  _digits[2][d[2]])),\n        ]\n    \n    return lines\n\ndef cjoin(c1, c2, spaces='   '):\n    return [spaces.join(by_row) for by_row in zip(c1, c2)]\n\n\nif __name__ == '__main__':\n    \n    \n    \n    \n    for pow10 in range(4):    \n        step = 10 ** pow10\n        print(f'\\nArabic {step}-to-{9*step} by {step} in Cistercian:\\n')\n        lines = num_to_lines(step)\n        for n in range(step*2, step*10, step):\n            lines = cjoin(lines, num_to_lines(n))\n        print('\\n'.join(lines))\n    \n\n    numbers = [0, 5555, 6789, 6666]\n    print(f'\\nArabic {str(numbers)[1:-1]} in Cistercian:\\n')\n    lines = num_to_lines(numbers[0])\n    for n in numbers[1:]:\n        lines = cjoin(lines, num_to_lines(n))\n    print('\\n'.join(lines))\n"}
{"id": 383213, "name": "Cistercian numerals", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @pts = ('', qw( 01 23 03 12 012 13 013 132 0132) );\nmy @dots = qw( 4-0 8-0 4-4 8-4 );\n\nmy @images = map { sprintf(\"%-9s\\n\", \"$_:\") . draw($_) }\n  0, 1, 20, 300, 4000, 5555, 6789, 1133;\nfor ( 1 .. 13 )\n  {\n  s/(.+)\\n/ print \" $1\"; '' /e for @images;\n  print \"\\n\";\n  }\n\nsub draw\n  {\n  my $n = shift;\n  local $_ = \"    \n  my $quadrant = 0;\n  for my $digit ( reverse split //, sprintf \"%04d\", $n )\n    {\n    my ($oldx, $oldy);\n    for my $cell ( split //, $pts[$digit] )\n      {\n      my ($x, $y) = split /-/, $dots[$cell];\n      if( defined $oldx )\n        {\n        my $dirx = $x <=> $oldx;\n        my $diry = $y <=> $oldy;\n        for my $place ( 0 .. 3 )\n          {\n          substr $_, $oldx + $oldy * 10, 1, '\n          $oldx += $dirx;\n          $oldy += $diry;\n          }\n        }\n      ($oldx, $oldy) = ($x, $y);\n      }\n    s/.+/ reverse $& /ge;\n    ++$quadrant & 1 or $_ = join '', reverse /.+\\n/g;\n    }\n  return $_;\n  }\n", "target": "\n\n\n\n\ndef _init():\n    \"digit sections for forming numbers\"\n    digi_bits = .strip()\n\n    lines = [[d.replace('.', ' ') for d in ln.strip().split()]\n             for ln in digi_bits.strip().split('\\n')\n             if '\n    formats = '<2 >2 <2 >2'.split()\n    digits = [[f\"{dig:{f}}\" for dig in line]\n              for f, line in zip(formats, lines)]\n\n    return digits\n\n_digits = _init()\n\n\n\ndef _to_digits(n):\n    assert 0 <= n < 10_000 and int(n) == n\n    \n    return [int(digit) for digit in f\"{int(n):04}\"][::-1]\n\ndef num_to_lines(n):\n    global _digits\n    d = _to_digits(n)\n    lines = [\n        ''.join((_digits[1][d[1]], '\u2503',  _digits[0][d[0]])),\n        ''.join((_digits[0][   0], '\u2503',  _digits[0][   0])),\n        ''.join((_digits[3][d[3]], '\u2503',  _digits[2][d[2]])),\n        ]\n    \n    return lines\n\ndef cjoin(c1, c2, spaces='   '):\n    return [spaces.join(by_row) for by_row in zip(c1, c2)]\n\n\nif __name__ == '__main__':\n    \n    \n    \n    \n    for pow10 in range(4):    \n        step = 10 ** pow10\n        print(f'\\nArabic {step}-to-{9*step} by {step} in Cistercian:\\n')\n        lines = num_to_lines(step)\n        for n in range(step*2, step*10, step):\n            lines = cjoin(lines, num_to_lines(n))\n        print('\\n'.join(lines))\n    \n\n    numbers = [0, 5555, 6789, 6666]\n    print(f'\\nArabic {str(numbers)[1:-1]} in Cistercian:\\n')\n    lines = num_to_lines(numbers[0])\n    for n in numbers[1:]:\n        lines = cjoin(lines, num_to_lines(n))\n    print('\\n'.join(lines))\n"}
{"id": 383214, "name": "Poker hand analyser", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse utf8;\nuse feature 'say';\nuse open qw<:encoding(utf-8) :std>;\n \npackage Hand {\n    sub describe {\n        my $str = pop;\n        my $hand = init($str);\n        return \"$str: INVALID\" if !$hand;\n        return analyze($hand);\n    }\n \n    sub init {\n        (my $str = lc shift) =~ tr/234567891jqka\u2665\u2666\u2663\u2660//cd;\n        return if $str !~ m/\\A (?: [234567891jqka] [\u2665\u2666\u2663\u2660] ){5} \\z/x;\n        for (my ($i, $cnt) = (0, 0); $i < 10; $i += 2, $cnt = 0) {\n            my $try = substr $str, $i, 2;\n            ++$cnt while $str =~ m/$try/g;\n            return if $cnt > 1;\n        }\n        my $suits = $str =~ tr/234567891jqka//dr;\n        my $ranks = $str =~ tr/\u2665\u2666\u2663\u2660//dr;\n        return {\n            hand  => $str,\n            suits => $suits,\n            ranks => $ranks,\n        };\n    }\n \n    sub analyze {\n        my $hand = shift;\n        my @ranks = split //, $hand->{ranks};\n        my %cards;\n        for (@ranks) {\n            $_ = 10, next if $_ eq '1';\n            $_ = 11, next if $_ eq 'j';\n            $_ = 12, next if $_ eq 'q';\n            $_ = 13, next if $_ eq 'k';\n            $_ = 14, next if $_ eq 'a';\n        } continue {\n            ++$cards{ $_ };\n        }\n        my $kicker = 0;\n        my (@pairs, $set, $quads, $straight, $flush);\n \n        while (my ($card, $count) = each %cards) {\n            if ($count == 1) {\n                $kicker = $card if $kicker < $card;\n            }\n            elsif ($count == 2) {\n                push @pairs, $card;\n            }\n            elsif ($count == 3) {\n                $set = $card;\n            }\n            elsif ($count == 4) {\n                $quads = $card;\n            }\n            else {\n                die \"Five of a kind? Cheater!\\n\";\n            }\n        }\n        $flush    = 1 if $hand->{suits} =~ m/\\A (.) \\1 {4}/x;\n        $straight = check_straight(@ranks);\n        return get_high($kicker, \\@pairs, $set, $quads, $straight, $flush,);\n    }\n \n    sub check_straight {\n        my $sequence = join ' ', sort { $a <=> $b } @_;\n        return 1       if index('2 3 4 5 6 7 8 9 10 11 12 13 14', $sequence) != -1;\n        return 'wheel' if index('2 3 4 5 14 6 7 8 9 10 11 12 13', $sequence) ==  0;\n        return undef;\n    }\n \n    sub get_high {\n        my ($kicker, $pairs, $set, $quads, $straight, $flush) = @_;\n        $kicker = to_s($kicker, 's');\n        return 'straight-flush: Royal Flush!'\n            if $straight && $flush && $kicker eq 'Ace' && $straight ne 'wheel';\n        return \"straight-flush: Steel Wheel!\"\n            if $straight && $flush && $straight eq 'wheel';\n        return \"straight-flush: $kicker high\"\n            if $straight && $flush;\n        return 'four-of-a-kind: '. to_s($quads, 'p')\n            if $quads;\n        return 'full-house: '. to_s($set, 'p') .' full of '. to_s($pairs->[0], 'p')\n            if $set && @$pairs;\n        return \"flush: $kicker high\"\n            if $flush;\n        return 'straight: Wheel!'\n            if $straight && $straight eq 'wheel';\n        return \"straight: $kicker high\"\n            if $straight;\n        return 'three-of-a-kind: '. to_s($set, 'p')\n            if $set;\n        return 'two-pairs: '. to_s($pairs->[0], 'p') .' and '. to_s($pairs->[1], 'p')\n            if @$pairs == 2;\n        return 'one-pair: '. to_s($pairs->[0], 'p')\n            if @$pairs == 1;\n        return \"high-card: $kicker\";\n    }\n \n    my %to_str = (\n         2 => 'Two',    3 => 'Three', 4 => 'Four',  5 => 'Five', 6 => 'Six',\n         7 => 'Seven',  8 => 'Eight', 9 => 'Nine', 10 => 'Ten', 11 => 'Jack',\n        12 => 'Queen', 13 => 'King', 14 => 'Ace',\n    );\n    my %to_str_diffs = (2 => 'Deuces', 6 => 'Sixes',);\n \n    sub to_s {\n        my ($num, $verb) = @_;\n        \n        if ($verb =~ m/\\A p/xi) {\n            return $to_str_diffs{ $num } if $to_str_diffs{ $num };\n            return $to_str{ $num } .'s';\n        }\n        return $to_str{ $num };\n    }\n}\n \nmy @cards = (\n    '10\u2665 j\u2665  q\u2665 k\u2665 a\u2665',\n    '2\u2665  3\u2665  4\u2665 5\u2665 a\u2665',\n    '2\u2665  2\u2663  2\u2666 3\u2663 2\u2660',\n    '10\u2665 K\u2665  K\u2666 K\u2663 10\u2666',\n    'q\u2663  10\u2663 7\u2663 6\u2663 3\u2663',\n    '5\u2663  10\u2663 7\u2663 6\u2663 4\u2663',\n    '9\u2665  10\u2665 q\u2665 k\u2665 j\u2663',\n    'a\u2665  a\u2663  3\u2663 4\u2663 5\u2666',\n    '2\u2665  2\u2666  2\u2663 k\u2663 q\u2666',\n    '6\u2665  7\u2665  6\u2666 j\u2663 j\u2666',\n    '2\u2665  6\u2665  2\u2666 3\u2663 3\u2666',\n    '7\u2665  7\u2660  k\u2660 3\u2666 10\u2660',\n    '4\u2665  4\u2660  k\u2660 2\u2666 10\u2660',\n    '2\u2665  5\u2665  j\u2666 8\u2663 9\u2660',\n    '2\u2665  5\u2665  7\u2666 8\u2663 9\u2660',\n    'a\u2665  a\u2665  3\u2663 4\u2663 5\u2666', \n);\n \nsay Hand::describe($_) for @cards;\n", "target": ":- initialization(main).\n\n\nfaces([a,k,q,j,10,9,8,7,6,5,4,3,2]).\n\nface(F) :- faces(Fs), member(F,Fs).\nsuit(S) :- member(S, ['\u2665','\u2666','\u2663','\u2660']).\n\n\nbest_hand(Cards,H) :-\n    straight_flush(Cards,C) -> H = straight-flush(C)\n  ; many_kind(Cards,F,4)    -> H = four-of-a-kind(F)\n  ; full_house(Cards,F1,F2) -> H = full-house(F1,F2)\n  ; flush(Cards,S)          -> H = flush(S)\n  ; straight(Cards,F)       -> H = straight(F)\n  ; many_kind(Cards,F,3)    -> H = three-of-a-kind(F)\n  ; two_pair(Cards,F1,F2)   -> H = two-pair(F1,F2)\n  ; many_kind(Cards,F,2)    -> H = one-pair(F)\n  ; many_kind(Cards,F,1)    -> H = high-card(F)\n  ;                            H = invalid\n  .\n\nstraight_flush(Cards, c(F,S)) :- straight(Cards,F), flush(Cards,S).\n\nfull_house(Cards,F1,F2) :-\n    many_kind(Cards,F1,3), many_kind(Cards,F2,2), F1 \\= F2.\n\nflush(Cards,S) :- maplist(has_suit(S), Cards).\nhas_suit(S, c(_,S)).\n\nstraight(Cards,F) :-\n    select(c(F,_), Cards, Cs), pred_face(F,F1), straight(Cs,F1).\nstraight([],_).\npred_face(F,F1) :- F = 2 -> F1 = a ; faces(Fs), append(_, [F,F1|_], Fs).\n\ntwo_pair(Cards,F1,F2) :-\n    many_kind(Cards,F1,2), many_kind(Cards,F2,2), F1 \\= F2.\n\nmany_kind(Cards,F,N) :-\n    face(F), findall(_, member(c(F,_), Cards), Xs), length(Xs,N).\n\n\n% utils/parser\nparse_line(Cards)  --> \" \", parse_line(Cards).\nparse_line([C|Cs]) --> parse_card(C), parse_line(Cs).\nparse_line([])     --> [].\n\nparse_card(c(F,S)) --> parse_face(F), parse_suit(S).\n\nparse_suit(S,In,Out) :- suit(S), atom_codes(S,Xs), append(Xs,Out,In).\nparse_face(F,In,Out) :- face(F), face_codes(F,Xs), append(Xs,Out,In).\n\nface_codes(F,Xs) :- number(F) -> number_codes(F,Xs) ; atom_codes(F,Xs).\n\n\n% tests\ntest(\" 2\u2665  2\u2666 2\u2663 k\u2663  q\u2666\").\ntest(\" 2\u2665  5\u2665 7\u2666 8\u2663  9\u2660\").\ntest(\" a\u2665  2\u2666 3\u2663 4\u2663  5\u2666\").\ntest(\" 2\u2665  3\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 7\u2666 7\u2663  7\u2660\").\ntest(\"10\u2665  j\u2665 q\u2665 k\u2665  a\u2665\").\ntest(\" 4\u2665  4\u2660 k\u2660 5\u2666 10\u2660\").\ntest(\" q\u2663 10\u2663 7\u2663 6\u2663  4\u2663\").\n\nrun_tests :-\n    test(Line), phrase(parse_line(Cards), Line), best_hand(Cards,H)\n  , write(Cards), write('\\t'), write(H), nl\n  .\nmain :- findall(_, run_tests, _), halt.\n"}
{"id": 383215, "name": "Poker hand analyser", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse utf8;\nuse feature 'say';\nuse open qw<:encoding(utf-8) :std>;\n \npackage Hand {\n    sub describe {\n        my $str = pop;\n        my $hand = init($str);\n        return \"$str: INVALID\" if !$hand;\n        return analyze($hand);\n    }\n \n    sub init {\n        (my $str = lc shift) =~ tr/234567891jqka\u2665\u2666\u2663\u2660//cd;\n        return if $str !~ m/\\A (?: [234567891jqka] [\u2665\u2666\u2663\u2660] ){5} \\z/x;\n        for (my ($i, $cnt) = (0, 0); $i < 10; $i += 2, $cnt = 0) {\n            my $try = substr $str, $i, 2;\n            ++$cnt while $str =~ m/$try/g;\n            return if $cnt > 1;\n        }\n        my $suits = $str =~ tr/234567891jqka//dr;\n        my $ranks = $str =~ tr/\u2665\u2666\u2663\u2660//dr;\n        return {\n            hand  => $str,\n            suits => $suits,\n            ranks => $ranks,\n        };\n    }\n \n    sub analyze {\n        my $hand = shift;\n        my @ranks = split //, $hand->{ranks};\n        my %cards;\n        for (@ranks) {\n            $_ = 10, next if $_ eq '1';\n            $_ = 11, next if $_ eq 'j';\n            $_ = 12, next if $_ eq 'q';\n            $_ = 13, next if $_ eq 'k';\n            $_ = 14, next if $_ eq 'a';\n        } continue {\n            ++$cards{ $_ };\n        }\n        my $kicker = 0;\n        my (@pairs, $set, $quads, $straight, $flush);\n \n        while (my ($card, $count) = each %cards) {\n            if ($count == 1) {\n                $kicker = $card if $kicker < $card;\n            }\n            elsif ($count == 2) {\n                push @pairs, $card;\n            }\n            elsif ($count == 3) {\n                $set = $card;\n            }\n            elsif ($count == 4) {\n                $quads = $card;\n            }\n            else {\n                die \"Five of a kind? Cheater!\\n\";\n            }\n        }\n        $flush    = 1 if $hand->{suits} =~ m/\\A (.) \\1 {4}/x;\n        $straight = check_straight(@ranks);\n        return get_high($kicker, \\@pairs, $set, $quads, $straight, $flush,);\n    }\n \n    sub check_straight {\n        my $sequence = join ' ', sort { $a <=> $b } @_;\n        return 1       if index('2 3 4 5 6 7 8 9 10 11 12 13 14', $sequence) != -1;\n        return 'wheel' if index('2 3 4 5 14 6 7 8 9 10 11 12 13', $sequence) ==  0;\n        return undef;\n    }\n \n    sub get_high {\n        my ($kicker, $pairs, $set, $quads, $straight, $flush) = @_;\n        $kicker = to_s($kicker, 's');\n        return 'straight-flush: Royal Flush!'\n            if $straight && $flush && $kicker eq 'Ace' && $straight ne 'wheel';\n        return \"straight-flush: Steel Wheel!\"\n            if $straight && $flush && $straight eq 'wheel';\n        return \"straight-flush: $kicker high\"\n            if $straight && $flush;\n        return 'four-of-a-kind: '. to_s($quads, 'p')\n            if $quads;\n        return 'full-house: '. to_s($set, 'p') .' full of '. to_s($pairs->[0], 'p')\n            if $set && @$pairs;\n        return \"flush: $kicker high\"\n            if $flush;\n        return 'straight: Wheel!'\n            if $straight && $straight eq 'wheel';\n        return \"straight: $kicker high\"\n            if $straight;\n        return 'three-of-a-kind: '. to_s($set, 'p')\n            if $set;\n        return 'two-pairs: '. to_s($pairs->[0], 'p') .' and '. to_s($pairs->[1], 'p')\n            if @$pairs == 2;\n        return 'one-pair: '. to_s($pairs->[0], 'p')\n            if @$pairs == 1;\n        return \"high-card: $kicker\";\n    }\n \n    my %to_str = (\n         2 => 'Two',    3 => 'Three', 4 => 'Four',  5 => 'Five', 6 => 'Six',\n         7 => 'Seven',  8 => 'Eight', 9 => 'Nine', 10 => 'Ten', 11 => 'Jack',\n        12 => 'Queen', 13 => 'King', 14 => 'Ace',\n    );\n    my %to_str_diffs = (2 => 'Deuces', 6 => 'Sixes',);\n \n    sub to_s {\n        my ($num, $verb) = @_;\n        \n        if ($verb =~ m/\\A p/xi) {\n            return $to_str_diffs{ $num } if $to_str_diffs{ $num };\n            return $to_str{ $num } .'s';\n        }\n        return $to_str{ $num };\n    }\n}\n \nmy @cards = (\n    '10\u2665 j\u2665  q\u2665 k\u2665 a\u2665',\n    '2\u2665  3\u2665  4\u2665 5\u2665 a\u2665',\n    '2\u2665  2\u2663  2\u2666 3\u2663 2\u2660',\n    '10\u2665 K\u2665  K\u2666 K\u2663 10\u2666',\n    'q\u2663  10\u2663 7\u2663 6\u2663 3\u2663',\n    '5\u2663  10\u2663 7\u2663 6\u2663 4\u2663',\n    '9\u2665  10\u2665 q\u2665 k\u2665 j\u2663',\n    'a\u2665  a\u2663  3\u2663 4\u2663 5\u2666',\n    '2\u2665  2\u2666  2\u2663 k\u2663 q\u2666',\n    '6\u2665  7\u2665  6\u2666 j\u2663 j\u2666',\n    '2\u2665  6\u2665  2\u2666 3\u2663 3\u2666',\n    '7\u2665  7\u2660  k\u2660 3\u2666 10\u2660',\n    '4\u2665  4\u2660  k\u2660 2\u2666 10\u2660',\n    '2\u2665  5\u2665  j\u2666 8\u2663 9\u2660',\n    '2\u2665  5\u2665  7\u2666 8\u2663 9\u2660',\n    'a\u2665  a\u2665  3\u2663 4\u2663 5\u2666', \n);\n \nsay Hand::describe($_) for @cards;\n", "target": ":- initialization(main).\n\n\nfaces([a,k,q,j,10,9,8,7,6,5,4,3,2]).\n\nface(F) :- faces(Fs), member(F,Fs).\nsuit(S) :- member(S, ['\u2665','\u2666','\u2663','\u2660']).\n\n\nbest_hand(Cards,H) :-\n    straight_flush(Cards,C) -> H = straight-flush(C)\n  ; many_kind(Cards,F,4)    -> H = four-of-a-kind(F)\n  ; full_house(Cards,F1,F2) -> H = full-house(F1,F2)\n  ; flush(Cards,S)          -> H = flush(S)\n  ; straight(Cards,F)       -> H = straight(F)\n  ; many_kind(Cards,F,3)    -> H = three-of-a-kind(F)\n  ; two_pair(Cards,F1,F2)   -> H = two-pair(F1,F2)\n  ; many_kind(Cards,F,2)    -> H = one-pair(F)\n  ; many_kind(Cards,F,1)    -> H = high-card(F)\n  ;                            H = invalid\n  .\n\nstraight_flush(Cards, c(F,S)) :- straight(Cards,F), flush(Cards,S).\n\nfull_house(Cards,F1,F2) :-\n    many_kind(Cards,F1,3), many_kind(Cards,F2,2), F1 \\= F2.\n\nflush(Cards,S) :- maplist(has_suit(S), Cards).\nhas_suit(S, c(_,S)).\n\nstraight(Cards,F) :-\n    select(c(F,_), Cards, Cs), pred_face(F,F1), straight(Cs,F1).\nstraight([],_).\npred_face(F,F1) :- F = 2 -> F1 = a ; faces(Fs), append(_, [F,F1|_], Fs).\n\ntwo_pair(Cards,F1,F2) :-\n    many_kind(Cards,F1,2), many_kind(Cards,F2,2), F1 \\= F2.\n\nmany_kind(Cards,F,N) :-\n    face(F), findall(_, member(c(F,_), Cards), Xs), length(Xs,N).\n\n\n% utils/parser\nparse_line(Cards)  --> \" \", parse_line(Cards).\nparse_line([C|Cs]) --> parse_card(C), parse_line(Cs).\nparse_line([])     --> [].\n\nparse_card(c(F,S)) --> parse_face(F), parse_suit(S).\n\nparse_suit(S,In,Out) :- suit(S), atom_codes(S,Xs), append(Xs,Out,In).\nparse_face(F,In,Out) :- face(F), face_codes(F,Xs), append(Xs,Out,In).\n\nface_codes(F,Xs) :- number(F) -> number_codes(F,Xs) ; atom_codes(F,Xs).\n\n\n% tests\ntest(\" 2\u2665  2\u2666 2\u2663 k\u2663  q\u2666\").\ntest(\" 2\u2665  5\u2665 7\u2666 8\u2663  9\u2660\").\ntest(\" a\u2665  2\u2666 3\u2663 4\u2663  5\u2666\").\ntest(\" 2\u2665  3\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 7\u2666 7\u2663  7\u2660\").\ntest(\"10\u2665  j\u2665 q\u2665 k\u2665  a\u2665\").\ntest(\" 4\u2665  4\u2660 k\u2660 5\u2666 10\u2660\").\ntest(\" q\u2663 10\u2663 7\u2663 6\u2663  4\u2663\").\n\nrun_tests :-\n    test(Line), phrase(parse_line(Cards), Line), best_hand(Cards,H)\n  , write(Cards), write('\\t'), write(H), nl\n  .\nmain :- findall(_, run_tests, _), halt.\n"}
{"id": 383216, "name": "Fibonacci word_fractal", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse GD;\n\nmy @fword = ( undef, 1, 0 );\n\nsub fword {\n\tmy $n = shift;\n\treturn $fword[$n] if $n<3;\n\treturn $fword[$n] //= fword($n-1).fword($n-2);\n}\n\nmy $size = 3000;\nmy $im = GD::Image->new($size,$size);\nmy $white = $im->colorAllocate(255,255,255);\nmy $black = $im->colorAllocate(0,0,0);       \n$im->transparent($white);\n$im->interlaced('true');\n\nmy @pos   = (0,0);\nmy @dir   = (0,5);\nmy @steps = split //, fword 23;\nmy $i     = 1;\nfor( @steps ) {\n\tmy @next = ( $pos[0]+$dir[0], $pos[1]+$dir[1] );\n\t$im->line( @pos, @next, $black );\n\t@dir = (  $dir[1], -$dir[0] ) if 0==$_ && 1==$i%2; \n\t@dir = ( -$dir[1],  $dir[0] ) if 0==$_ && 0==$i%2; \n\t$i++;\n\t@pos = @next;\n}\n\nopen my $out, \">\", \"fword.png\" or die \"Cannot open output file.\\n\";\nbinmode $out;\nprint $out $im->png;\nclose $out;\n", "target": "from functools import wraps\nfrom turtle import *\n\ndef memoize(obj):\n    cache = obj.cache = {}\n    @wraps(obj)\n    def memoizer(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in cache:\n            cache[key] = obj(*args, **kwargs)\n        return cache[key]\n    return memoizer\n\n@memoize\ndef fibonacci_word(n):\n    assert n > 0\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"0\"\n    return fibonacci_word(n - 1) + fibonacci_word(n - 2)\n\ndef draw_fractal(word, step):\n    for i, c in enumerate(word, 1):\n        forward(step)\n        if c == \"0\":\n            if i % 2 == 0:\n                left(90)\n            else:\n                right(90)\n\ndef main():\n    n = 25 \n    step = 1 \n    width = 1050 \n    height = 1050 \n    w = fibonacci_word(n)\n\n    setup(width=width, height=height)\n    speed(0)\n    setheading(90)\n    left(90)\n    penup()\n    forward(500)\n    right(90)\n    backward(500)\n    pendown()\n    tracer(10000)\n    hideturtle()\n\n    draw_fractal(w, step)\n\n    \n    getscreen().getcanvas().postscript(file=\"fibonacci_word_fractal.eps\")\n    exitonclick()\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383217, "name": "Penney's game", "source": "Translate Perl to Python: \nuse 5.020;\nuse strict;\nuse warnings;\n\n\nbinaryRand() == 0 ? flipCoin(userFirst()) : flipCoin(compFirst());\n\n\nsub binaryRand\n{\n    return int(rand(2));\n}\n\nsub convert\n{\n    my $randNum = binaryRand();\n    if($randNum == 0)\n    {\n        return \"T\"\n    }\n    else\n    {\n        return \"H\";\n    }\n}\n\n\nsub uSeq\n{\n    print(\"Please enter a sequence of 3 of \\\"H\\\" and \\\"T\\\". EG: HHT\\n>\");\n    my $uString = <STDIN>;\n\n    while(1)\n    {\n        \n        chomp($uString);\n        $uString = uc $uString;\n        \n        if(length $uString == 3 && (substr($uString, 0, 1) =~ /[HT]/ &&\n                                    substr($uString, 1, 1) =~ /[HT]/ &&\n                                    substr($uString, 2, 1) =~ /[HT]/))\n        {\n            last;\n        }\n        else\n        {\n            print(\"Error, try again. \\n\");\n            print(\"Please enter a sequence of 3 of \\\"H\\\" and \\\"T\\\". EG: HHT\\n\");\n            $uString = <STDIN>;\n        }\n    }\n    return $uString;\n}\n\n\nsub compFirst\n{\n    my $cSeq;\n    \n    for(my $i = 0; $i < 3; $i++)\n    {\n        $cSeq = $cSeq . convert();\n    }\n\n    print(\"The computer guesses first:\\ncomp- $cSeq\\n\");\n    my $uSeq = uSeq();\n    print(\"user- $uSeq\\n\");\n    my @seqArr = ($uSeq, $cSeq);\n    return @seqArr;\n}\n\n\nsub userFirst\n{\n    print(\"The user quesses first:\\n\");\n    my $uSeq = uSeq();\n    my $cSeq;\n    \n    my $middle = substr($uSeq, 1, 1);\n    $middle eq \"H\" ? $cSeq = \"T\" : $cSeq = \"H\";\n    $cSeq = $cSeq . substr($uSeq, 0, 2); \n\n    print(\"user- $uSeq\\ncomp- $cSeq\\n\");\n    my @seqArr = ($uSeq, $cSeq);\n    return @seqArr; \n}\n\n\nsub flipCoin\n{\n    my ($uSeq, $cSeq) = @_;\n    my $coin;\n    while(1)\n    {\n        $coin = $coin . convert();\n        if($coin =~ m/$uSeq/)\n        {\n            print(\"The sequence of tosses was: $coin\\n\");\n            say(\"The player wins! \");\n            last;\n        }\n        elsif($coin =~ m/$cSeq/)\n        {\n            print(\"The sequence of tosses was: $coin\\n\");\n            say(\"The computer wins! \");\n            last;\n        }\n    }\n}\n", "target": "from __future__ import print_function\nimport random\nfrom time import sleep\n\nfirst = random.choice([True, False])\n\nyou = ''\nif first:\n    me = ''.join(random.sample('HT'*3, 3))\n    print('I choose first and will win on first seeing {} in the list of tosses'.format(me))\n    while len(you) != 3 or any(ch not in 'HT' for ch in you) or you == me:\n        you = input('What sequence of three Heads/Tails will you win with: ')\nelse:\n    while len(you) != 3 or any(ch not in 'HT' for ch in you):\n        you = input('After you: What sequence of three Heads/Tails will you win with: ')\n    me = ('H' if you[1] == 'T' else 'T') + you[:2]\n    print('I win on first seeing {} in the list of tosses'.format(me))\n    \nprint('Rolling:\\n  ', end='')\nrolled = ''\nwhile True:\n    rolled += random.choice('HT')\n    print(rolled[-1], end='')\n    if rolled.endswith(you):\n        print('\\n  You win!')\n        break\n    if rolled.endswith(me):\n        print('\\n  I win!')\n        break\n    sleep(1)    \n"}
{"id": 383218, "name": "Sierpinski triangle_Graphical", "source": "Translate Perl to Python: my $levels = 6;\nmy $side   = 512;\nmy $height = get_height($side);\n\nsub get_height { my($side) = @_; $side * sqrt(3) / 2 }\n\nsub triangle {\n    my($x1, $y1, $x2, $y2, $x3, $y3, $fill, $animate) = @_;\n    my $svg;\n    $svg .= qq{<polygon points=\"$x1,$y1 $x2,$y2 $x3,$y3\"};\n    $svg .= qq{ style=\"fill: $fill; stroke-width: 0;\"} if $fill;\n    $svg .= $animate\n        ? qq{>\\n  <animate attributeType=\"CSS\" attributeName=\"opacity\"\\n  values=\"1;0;1\" keyTimes=\"0;.5;1\" dur=\"20s\" repeatCount=\"indefinite\" />\\n</polygon>\\n}\n        : ' />';\n    return $svg;\n}\n\nsub fractal {\n    my( $x1, $y1, $x2, $y2, $x3, $y3, $r ) = @_;\n    my $svg;\n    $svg .= triangle( $x1, $y1, $x2, $y2, $x3, $y3 );\n    return $svg unless --$r;\n    my $side = abs($x3 - $x2) / 2;\n    my $height = get_height($side);\n    $svg .= fractal( $x1, $y1-$height*2, $x1-$side/2, $y1-3*$height, $x1+$side/2, $y1-3*$height, $r);\n    $svg .= fractal( $x2, $y1, $x2-$side/2, $y1-$height, $x2+$side/2, $y1-$height, $r);\n    $svg .= fractal( $x3, $y1, $x3-$side/2, $y1-$height, $x3+$side/2, $y1-$height, $r);\n}\n\nopen my $fh, '>', 'run/sierpinski_triangle.svg';\nprint $fh <<'EOD',\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<defs>\n  <radialGradient id=\"basegradient\" cx=\"50%\" cy=\"65%\" r=\"50%\" fx=\"50%\" fy=\"65%\">\n    <stop offset=\"10%\" stop-color=\"\n    <stop offset=\"60%\" stop-color=\"\n    <stop offset=\"99%\" stop-color=\"\n  </radialGradient>\n</defs>\nEOD\n\ntriangle( $side/2, 0, 0, $height, $side, $height, 'url(\ntriangle( $side/2, 0, 0, $height, $side, $height, '\n'<g style=\"fill: \nfractal( $side/2, $height, $side*3/4, $height/2, $side/4, $height/2, $levels ),\n'</g></svg>';\n", "target": "\nimport turtle as t\ndef sier(n,length):\n    if n == 0:\n        return\n    for i in range(3):\n        sier(n - 1, length / 2)\n        t.fd(length)\n        t.rt(120)\n"}
{"id": 383219, "name": "Sierpinski triangle_Graphical", "source": "Translate Perl to Python: my $levels = 6;\nmy $side   = 512;\nmy $height = get_height($side);\n\nsub get_height { my($side) = @_; $side * sqrt(3) / 2 }\n\nsub triangle {\n    my($x1, $y1, $x2, $y2, $x3, $y3, $fill, $animate) = @_;\n    my $svg;\n    $svg .= qq{<polygon points=\"$x1,$y1 $x2,$y2 $x3,$y3\"};\n    $svg .= qq{ style=\"fill: $fill; stroke-width: 0;\"} if $fill;\n    $svg .= $animate\n        ? qq{>\\n  <animate attributeType=\"CSS\" attributeName=\"opacity\"\\n  values=\"1;0;1\" keyTimes=\"0;.5;1\" dur=\"20s\" repeatCount=\"indefinite\" />\\n</polygon>\\n}\n        : ' />';\n    return $svg;\n}\n\nsub fractal {\n    my( $x1, $y1, $x2, $y2, $x3, $y3, $r ) = @_;\n    my $svg;\n    $svg .= triangle( $x1, $y1, $x2, $y2, $x3, $y3 );\n    return $svg unless --$r;\n    my $side = abs($x3 - $x2) / 2;\n    my $height = get_height($side);\n    $svg .= fractal( $x1, $y1-$height*2, $x1-$side/2, $y1-3*$height, $x1+$side/2, $y1-3*$height, $r);\n    $svg .= fractal( $x2, $y1, $x2-$side/2, $y1-$height, $x2+$side/2, $y1-$height, $r);\n    $svg .= fractal( $x3, $y1, $x3-$side/2, $y1-$height, $x3+$side/2, $y1-$height, $r);\n}\n\nopen my $fh, '>', 'run/sierpinski_triangle.svg';\nprint $fh <<'EOD',\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<defs>\n  <radialGradient id=\"basegradient\" cx=\"50%\" cy=\"65%\" r=\"50%\" fx=\"50%\" fy=\"65%\">\n    <stop offset=\"10%\" stop-color=\"\n    <stop offset=\"60%\" stop-color=\"\n    <stop offset=\"99%\" stop-color=\"\n  </radialGradient>\n</defs>\nEOD\n\ntriangle( $side/2, 0, 0, $height, $side, $height, 'url(\ntriangle( $side/2, 0, 0, $height, $side, $height, '\n'<g style=\"fill: \nfractal( $side/2, $height, $side*3/4, $height/2, $side/4, $height/2, $levels ),\n'</g></svg>';\n", "target": "\nimport turtle as t\ndef sier(n,length):\n    if n == 0:\n        return\n    for i in range(3):\n        sier(n - 1, length / 2)\n        t.fd(length)\n        t.rt(120)\n"}
{"id": 383220, "name": "Nonoblock", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"\\n$_\", tr/\\n/=/cr;\n  my ($cells, @blocks) = split;\n  my $letter = 'A';\n  $_ = join '.', map { $letter++ x $_ } @blocks;\n  $cells < length and print(\"no solution\\n\"), next;\n  $_ .= '.' x ($cells - length) . \"\\n\";\n  1 while print, s/^(\\.*)\\b(.*?)\\b(\\w+)\\.\\B/$2$1.$3/;\n  }\n\n", "target": "def nonoblocks(blocks, cells):\n    if not blocks or blocks[0] == 0:\n        yield [(0, 0)]\n    else:\n        assert sum(blocks) + len(blocks)-1 <= cells, \\\n            'Those blocks will not fit in those cells'\n        blength, brest = blocks[0], blocks[1:]      \n        minspace4rest = sum(1+b for b in brest)     \n        \n        for bpos in range(0, cells - minspace4rest - blength + 1):\n            if not brest:\n                \n                yield [(bpos, blength)]\n            else:\n                \n                \n                \n                offset = bpos + blength +1\n                nonoargs = (brest, cells - offset)  \n                \n                for subpos in nonoblocks(*nonoargs):\n                    \n                    rest = [(offset + bp, bl) for bp, bl in subpos]\n                    \n                    vec = [(bpos, blength)] + rest\n                    yield vec\n\ndef pblock(vec, cells):\n    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'\n    vector = ['_'] * cells\n    for ch, (bp, bl) in enumerate(vec, ord('A')):\n        for i in range(bp, bp + bl):\n            vector[i] = chr(ch) if vector[i] == '_' else'?'\n    return '|' + '|'.join(vector) + '|'\n\n\nif __name__ == '__main__':\n    for blocks, cells in (\n            ([2, 1], 5),\n            ([], 5),\n            ([8], 10),\n            ([2, 3, 2, 3], 15),\n           \n           \n           \n            ([2, 3], 5),\n            ):\n        print('\\nConfiguration:\\n    %s \n        print('  Possibilities:')\n        for i, vector in enumerate(nonoblocks(blocks, cells)):\n            print('   ', pblock(vector, cells))\n        print('  A total of %i Possible configurations.' % (i+1))\n"}
{"id": 383221, "name": "Nonoblock", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"\\n$_\", tr/\\n/=/cr;\n  my ($cells, @blocks) = split;\n  my $letter = 'A';\n  $_ = join '.', map { $letter++ x $_ } @blocks;\n  $cells < length and print(\"no solution\\n\"), next;\n  $_ .= '.' x ($cells - length) . \"\\n\";\n  1 while print, s/^(\\.*)\\b(.*?)\\b(\\w+)\\.\\B/$2$1.$3/;\n  }\n\n", "target": "def nonoblocks(blocks, cells):\n    if not blocks or blocks[0] == 0:\n        yield [(0, 0)]\n    else:\n        assert sum(blocks) + len(blocks)-1 <= cells, \\\n            'Those blocks will not fit in those cells'\n        blength, brest = blocks[0], blocks[1:]      \n        minspace4rest = sum(1+b for b in brest)     \n        \n        for bpos in range(0, cells - minspace4rest - blength + 1):\n            if not brest:\n                \n                yield [(bpos, blength)]\n            else:\n                \n                \n                \n                offset = bpos + blength +1\n                nonoargs = (brest, cells - offset)  \n                \n                for subpos in nonoblocks(*nonoargs):\n                    \n                    rest = [(offset + bp, bl) for bp, bl in subpos]\n                    \n                    vec = [(bpos, blength)] + rest\n                    yield vec\n\ndef pblock(vec, cells):\n    'Prettyprints each run of blocks with a different letter A.. for each block of filled cells'\n    vector = ['_'] * cells\n    for ch, (bp, bl) in enumerate(vec, ord('A')):\n        for i in range(bp, bp + bl):\n            vector[i] = chr(ch) if vector[i] == '_' else'?'\n    return '|' + '|'.join(vector) + '|'\n\n\nif __name__ == '__main__':\n    for blocks, cells in (\n            ([2, 1], 5),\n            ([], 5),\n            ([8], 10),\n            ([2, 3, 2, 3], 15),\n           \n           \n           \n            ([2, 3], 5),\n            ):\n        print('\\nConfiguration:\\n    %s \n        print('  Possibilities:')\n        for i, vector in enumerate(nonoblocks(blocks, cells)):\n            print('   ', pblock(vector, cells))\n        print('  A total of %i Possible configurations.' % (i+1))\n"}
{"id": 383222, "name": "Eban numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Lingua::EN::Numbers qw(num2en);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub e_ban {\n    my($power) = @_;\n    my @n;\n    for (1..10**$power) {\n        next unless 0 == $_%2;\n        next if $_ =~ /[789]/ or /[12].$/ or /[135]..$/ or /[135]...$/ or /[135].....$/;\n        push @n, $_ unless num2en($_) =~ /e/;\n    }\n    @n;\n}\n\nmy @OK = e_ban(my $max = 7);\n\nmy @a = grep { $_ <= 1000 } @OK;\nsay \"Number of eban numbers up to and including 1000: @{[1+$\nsay join(', ',@a);\nsay '';\n\nmy @b = grep { $_ >= 1000 && $_ <= 4000 } @OK;\nsay \"Number of eban numbers between 1000 and 4000 (inclusive): @{[1+$\nsay join(', ',@b);\nsay '';\n\nfor my $exp (4..$max) {\n    my $n = + grep { $_ <= 10**$exp } @OK;\n    printf \"Number of eban numbers and %10s: %d\\n\", comma(10**$exp), $n;\n}\n", "target": "\n\n\n\nimport inflect\nimport time\n\nbefore = time.perf_counter()\n\np = inflect.engine()\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers between 1000 and 4000 (inclusive):')\nprint(' ')\n\ncount = 0\n\nfor i in range(1000,4001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 100000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,100001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\nafter = time.perf_counter()\n\nprint(\" \")\nprint(\"Run time in seconds: \"+str(after - before))\n"}
{"id": 383223, "name": "Eban numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Lingua::EN::Numbers qw(num2en);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub e_ban {\n    my($power) = @_;\n    my @n;\n    for (1..10**$power) {\n        next unless 0 == $_%2;\n        next if $_ =~ /[789]/ or /[12].$/ or /[135]..$/ or /[135]...$/ or /[135].....$/;\n        push @n, $_ unless num2en($_) =~ /e/;\n    }\n    @n;\n}\n\nmy @OK = e_ban(my $max = 7);\n\nmy @a = grep { $_ <= 1000 } @OK;\nsay \"Number of eban numbers up to and including 1000: @{[1+$\nsay join(', ',@a);\nsay '';\n\nmy @b = grep { $_ >= 1000 && $_ <= 4000 } @OK;\nsay \"Number of eban numbers between 1000 and 4000 (inclusive): @{[1+$\nsay join(', ',@b);\nsay '';\n\nfor my $exp (4..$max) {\n    my $n = + grep { $_ <= 10**$exp } @OK;\n    printf \"Number of eban numbers and %10s: %d\\n\", comma(10**$exp), $n;\n}\n", "target": "\n\n\n\nimport inflect\nimport time\n\nbefore = time.perf_counter()\n\np = inflect.engine()\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers between 1000 and 4000 (inclusive):')\nprint(' ')\n\ncount = 0\n\nfor i in range(1000,4001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 100000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,100001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\nafter = time.perf_counter()\n\nprint(\" \")\nprint(\"Run time in seconds: \"+str(after - before))\n"}
{"id": 383224, "name": "Mayan numerals", "source": "Translate Perl to Python: use ntheory qw/fromdigits todigitstring/;\n\nmy $t_style = '\"border-collapse: separate; text-align: center; border-spacing: 3px 0px;\"';\nmy $c_style = '\"border: solid black 2px;background-color: \n  'border-radius: 1em;-moz-border-radius: 1em;-webkit-border-radius: 1em;'.\n  'vertical-align: bottom;width: 3.25em;\"';\n\nsub cartouches {\n    my($num, @digits) = @_;\n    my $render;\n    for my $d (@digits) {\n        $render .= \"| style=$c_style | $_\\n\" for glyphs(@$d);\n    }\n    chomp $render;\n    join \"\\n\", \"\\{| style=$t_style\", \"|+ $num\", '|-', $render, '|}'\n}\n\nsub glyphs {\n    return '\u0398' unless $_[0] || $_[1];\n    join '<br>', '\u25cf' x $_[0], ('\u2500\u2500\u2500') x $_[1];\n}\n\nsub mmod {\n    my($n,$b) = @_;\n    my @nb;\n    return 0 unless $n;\n    push @nb, fromdigits($_, $b) for split '', todigitstring($n, $b);\n    return @nb;\n}\n\nfor $n (qw<4005 8017 326205 886205 26960840421>) {\n    push @output, cartouches($n, map { [reverse mmod($_,5)] } mmod($n,20) );\n}\n\nprint join \"\\n<br>\\n\", @output;\n", "target": "\n\nfrom functools import (reduce)\n\n\n\n\n\ndef mayanNumerals(n):\n    \n    return showIntAtBase(20)(\n        mayanDigit\n    )(n)([])\n\n\n\ndef mayanDigit(n):\n    \n    if 0 < n:\n        r = n % 5\n        return [\n            (['\u25cf' * r] if 0 < r else []) +\n            (['\u2501\u2501'] * (n // 5))\n        ]\n    else:\n        return ['\u0398']\n\n\n\ndef mayanFramed(n):\n    \n    return 'Mayan ' + str(n) + ':\\n\\n' + (\n        wikiTable({\n            'class': 'wikitable',\n            'style': cssFromDict({\n                'text-align': 'center',\n                'background-color': '\n                'color': '\n                'border': '2px solid silver'\n            }),\n            'colwidth': '3em',\n            'cell': 'vertical-align: bottom;'\n        })([[\n            '<br>'.join(col) for col in mayanNumerals(n)\n        ]])\n    )\n\n\n\n\n\ndef main():\n    \n    print(\n        main.__doc__ + ':\\n\\n' +\n        '\\n'.join(mayanFramed(n) for n in [\n            4005, 8017, 326205, 886205, 1081439556,\n            1000000, 1000000000\n        ])\n    )\n\n\n\n\n\ndef wikiTable(opts):\n    \n    def colWidth():\n        return 'width:' + opts['colwidth'] + '; ' if (\n            'colwidth' in opts\n        ) else ''\n\n    def cellStyle():\n        return opts['cell'] if 'cell' in opts else ''\n\n    return lambda rows: '{| ' + reduce(\n        lambda a, k: (\n            a + k + '=\"' + opts[k] + '\" ' if (\n                k in opts\n            ) else a\n        ),\n        ['class', 'style'],\n        ''\n    ) + '\\n' + '\\n|-\\n'.join(\n        '\\n'.join(\n            ('|' if (\n                0 != i and ('cell' not in opts)\n            ) else (\n                '|style=\"' + colWidth() + cellStyle() + '\"|'\n            )) + (\n                str(x) or ' '\n            ) for x in row\n        ) for i, row in enumerate(rows)\n    ) + '\\n|}\\n\\n'\n\n\n\n\n\ndef cssFromDict(dct):\n    \n    return reduce(\n        lambda a, k: a + k + ':' + dct[k] + '; ',\n        dct.keys(),\n        ''\n    )\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383225, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Perl to Python: use bigint;\n\nfor $sailors (1..15) { check( $sailors, coconuts( 0+$sailors ) ) }\n\nsub is_valid {\n    my($sailors, $nuts) = @_;\n    return 0, 0 if $sailors == 1 and $nuts == 1;\n    my @shares;\n    for (1..$sailors) {\n        return () unless ($nuts % $sailors) == 1;\n        push @shares, int ($nuts-1)/$sailors;\n        $nuts -= (1 + int $nuts/$sailors);\n    }\n    push @shares, int $nuts/$sailors;\n    return @shares if !($nuts % $sailors);\n}\n\nsub check {\n    my($sailors, $coconuts) = @_;\n    my @suffix = ('th', 'st', 'nd', 'rd', ('th') x 6, ('th') x 10);\n    my @piles = is_valid($sailors, $coconuts);\n    if (@piles) {\n        print \"\\nSailors $sailors: Coconuts $coconuts:\\n\";\n        for my $k (0..-1 + $\n             print $k+1 . $suffix[$k+1] . \" takes \" . $piles[$k] . \", gives 1 to the monkey.\\n\"\n        }\n        print \"The next morning, each sailor takes \" . $piles[-1] . \"\\nwith none left over for the monkey.\\n\";\n        return 1\n    }\n    return 0\n}\n\nsub coconuts {\n    my($sailors) = @_;\n    if ($sailors % 2 == 0 ) { ($sailors ** $sailors - 1) * ($sailors - 1) }\n    else                    {  $sailors ** $sailors      -  $sailors + 1  }\n}\n", "target": "def monkey_coconuts(sailors=5):\n    \"Parameterised the number of sailors using an inner loop including the last mornings case\"    \n    nuts = sailors\n    while True:\n        n0, wakes = nuts, []\n        for sailor in range(sailors + 1):\n            portion, remainder = divmod(n0, sailors)\n            wakes.append((n0, portion, remainder))\n            if portion <= 0 or remainder != (1 if sailor != sailors else 0):\n                nuts += 1\n                break\n            n0 = n0 - portion - remainder\n        else:\n            break\n    return nuts, wakes\n\nif __name__ == \"__main__\":\n    for sailors in [5, 6]:\n        nuts, wake_stats = monkey_coconuts(sailors)\n        print(\"\\nFor %i sailors the initial nut count is %i\" % (sailors, nuts))\n        print(\"On each waking, the nut count, portion taken, and monkeys share are:\\n \", \n              ',\\n  '.join(repr(ws) for ws in wake_stats))\n"}
{"id": 383226, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Perl to Python: use bigint;\n\nfor $sailors (1..15) { check( $sailors, coconuts( 0+$sailors ) ) }\n\nsub is_valid {\n    my($sailors, $nuts) = @_;\n    return 0, 0 if $sailors == 1 and $nuts == 1;\n    my @shares;\n    for (1..$sailors) {\n        return () unless ($nuts % $sailors) == 1;\n        push @shares, int ($nuts-1)/$sailors;\n        $nuts -= (1 + int $nuts/$sailors);\n    }\n    push @shares, int $nuts/$sailors;\n    return @shares if !($nuts % $sailors);\n}\n\nsub check {\n    my($sailors, $coconuts) = @_;\n    my @suffix = ('th', 'st', 'nd', 'rd', ('th') x 6, ('th') x 10);\n    my @piles = is_valid($sailors, $coconuts);\n    if (@piles) {\n        print \"\\nSailors $sailors: Coconuts $coconuts:\\n\";\n        for my $k (0..-1 + $\n             print $k+1 . $suffix[$k+1] . \" takes \" . $piles[$k] . \", gives 1 to the monkey.\\n\"\n        }\n        print \"The next morning, each sailor takes \" . $piles[-1] . \"\\nwith none left over for the monkey.\\n\";\n        return 1\n    }\n    return 0\n}\n\nsub coconuts {\n    my($sailors) = @_;\n    if ($sailors % 2 == 0 ) { ($sailors ** $sailors - 1) * ($sailors - 1) }\n    else                    {  $sailors ** $sailors      -  $sailors + 1  }\n}\n", "target": "def monkey_coconuts(sailors=5):\n    \"Parameterised the number of sailors using an inner loop including the last mornings case\"    \n    nuts = sailors\n    while True:\n        n0, wakes = nuts, []\n        for sailor in range(sailors + 1):\n            portion, remainder = divmod(n0, sailors)\n            wakes.append((n0, portion, remainder))\n            if portion <= 0 or remainder != (1 if sailor != sailors else 0):\n                nuts += 1\n                break\n            n0 = n0 - portion - remainder\n        else:\n            break\n    return nuts, wakes\n\nif __name__ == \"__main__\":\n    for sailors in [5, 6]:\n        nuts, wake_stats = monkey_coconuts(sailors)\n        print(\"\\nFor %i sailors the initial nut count is %i\" % (sailors, nuts))\n        print(\"On each waking, the nut count, portion taken, and monkeys share are:\\n \", \n              ',\\n  '.join(repr(ws) for ws in wake_stats))\n"}
{"id": 383227, "name": "Bitmap_Read an image through a pipe", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Imager;\n\nmy $raw;\n\nopen my $fh, '-|', 'cat Lenna50.jpg' or die;\nbinmode $fh;\nwhile ( sysread $fh , my $chunk , 1024 ) { $raw .= $chunk }\nclose $fh;\n\nmy $enable = $Imager::formats{\"jpeg\"}; \n\nmy $IO = Imager::io_new_buffer $raw or die;\nmy $im = Imager::File::JPEG::i_readjpeg_wiol $IO or die;\n\nopen my $fh2, '>', 'output.ppm' or die;\nbinmode $fh2;\nmy $IO2 = Imager::io_new_fd(fileno $fh2);\nImager::i_writeppm_wiol $im, $IO2 ;\nclose $fh2;\nundef($im);\n", "target": "\n\nfrom PIL import Image\n\n\n\nim = Image.open(\"boxes_1.jpg\")\nim.save(\"boxes_1v2.ppm\")\n"}
{"id": 383228, "name": "Nautical bell", "source": "Translate Perl to Python: use utf8;\nbinmode STDOUT, \":utf8\";\nuse DateTime;\n\n$| = 1; \n\nmy @watch = <Middle Morning Forenoon Afternoon Dog First>;\nmy @ordinal = <One Two Three Four Five Six Seven Eight>;\n\nmy $thishour;\nmy $thisminute = '';\n\nwhile () {\n    my $utc = DateTime->now( time_zone => 'UTC' );\n    if ($utc->minute =~ /^(00|30)$/ and $utc->minute != $thisminute) {\n        $thishour   = $utc->hour;\n        $thisminute = $utc->minute;\n        bell($thishour, $thisminute);\n    }\n    printf \"%s%02d:%02d:%02d\", \"\\r\", $utc->hour, $utc->minute, $utc->second;\n    sleep(1);\n}\n\nsub bell {\n    my($hour, $minute) = @_;\n\n    my $bells = (($hour % 4) * 2 + int $minute/30) || 8;\n    printf \"%s%02d:%02d%9s watch,%6s Bell%s Gone: \\t\", \"\\b\" x 9, $hour, $minute,\n       $watch[(int($hour/4) - (0==($minute + $hour % 4)) + 6) % 6],\n       $ordinal[$bells - 1], $bells == 1 ? '' : 's';\n    chime($bells);\n}\n\nsub chime {\n    my($count) = shift;\n    for (1..int($count/2)) {\n        print \"\\a\u266b \"; sleep .25;\n        print \"\\a\";   sleep .75;\n    }\n    if ($count % 2) {\n        print \"\\a\u266a\";  sleep 1;\n    }\n    print \"\\n\";\n}\n", "target": "import time, calendar, sched, winsound\n\nduration = 750      \nfreq = 1280         \nbellchar = \"\\u2407\"\nwatches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',')\n\ndef gap(n=1):\n    time.sleep(n * duration / 1000)\noff = gap\n \ndef on(n=1):\n    winsound.Beep(freq, n * duration)\n \ndef bong():\n    on(); off(0.5)\n\ndef bongs(m):\n    for i in range(m):\n        print(bellchar, end=' ')\n        bong()\n        if i % 2:\n            print('  ', end='')\n            off(0.5)\n    print('')\n        \nscheds =  sched.scheduler(time.time, time.sleep)\n\ndef ships_bell(now=None):\n    def adjust_to_half_hour(atime):\n        atime[4] = (atime[4] // 30) * 30\n        atime[5] = 0\n        return atime\n\n    debug = now is not None\n    rightnow = time.gmtime()\n    if not debug:\n        now = adjust_to_half_hour( list(rightnow) )\n    then = now[::]\n    then[4] += 30\n    hr, mn = now[3:5]\n    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)\n    b += 1\n    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')\n    if debug:\n        print(\"%02i:%02i, %-20s %s\" % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')\n    else:\n        print(\"%02i:%02i, %-20s %s\" % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')\n    bongs(b)\n    if not debug:\n        scheds.enterabs(calendar.timegm(then), 0, ships_bell)\n        \n        scheds.run()\n\ndef dbg_tester():\n    for h in range(24):\n        for m in (0, 30):\n            if (h,m) == (24,30): break\n            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )\n        \n    \nif __name__ == '__main__':\n    ships_bell()\n"}
{"id": 383229, "name": "Nautical bell", "source": "Translate Perl to Python: use utf8;\nbinmode STDOUT, \":utf8\";\nuse DateTime;\n\n$| = 1; \n\nmy @watch = <Middle Morning Forenoon Afternoon Dog First>;\nmy @ordinal = <One Two Three Four Five Six Seven Eight>;\n\nmy $thishour;\nmy $thisminute = '';\n\nwhile () {\n    my $utc = DateTime->now( time_zone => 'UTC' );\n    if ($utc->minute =~ /^(00|30)$/ and $utc->minute != $thisminute) {\n        $thishour   = $utc->hour;\n        $thisminute = $utc->minute;\n        bell($thishour, $thisminute);\n    }\n    printf \"%s%02d:%02d:%02d\", \"\\r\", $utc->hour, $utc->minute, $utc->second;\n    sleep(1);\n}\n\nsub bell {\n    my($hour, $minute) = @_;\n\n    my $bells = (($hour % 4) * 2 + int $minute/30) || 8;\n    printf \"%s%02d:%02d%9s watch,%6s Bell%s Gone: \\t\", \"\\b\" x 9, $hour, $minute,\n       $watch[(int($hour/4) - (0==($minute + $hour % 4)) + 6) % 6],\n       $ordinal[$bells - 1], $bells == 1 ? '' : 's';\n    chime($bells);\n}\n\nsub chime {\n    my($count) = shift;\n    for (1..int($count/2)) {\n        print \"\\a\u266b \"; sleep .25;\n        print \"\\a\";   sleep .75;\n    }\n    if ($count % 2) {\n        print \"\\a\u266a\";  sleep 1;\n    }\n    print \"\\n\";\n}\n", "target": "import time, calendar, sched, winsound\n\nduration = 750      \nfreq = 1280         \nbellchar = \"\\u2407\"\nwatches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',')\n\ndef gap(n=1):\n    time.sleep(n * duration / 1000)\noff = gap\n \ndef on(n=1):\n    winsound.Beep(freq, n * duration)\n \ndef bong():\n    on(); off(0.5)\n\ndef bongs(m):\n    for i in range(m):\n        print(bellchar, end=' ')\n        bong()\n        if i % 2:\n            print('  ', end='')\n            off(0.5)\n    print('')\n        \nscheds =  sched.scheduler(time.time, time.sleep)\n\ndef ships_bell(now=None):\n    def adjust_to_half_hour(atime):\n        atime[4] = (atime[4] // 30) * 30\n        atime[5] = 0\n        return atime\n\n    debug = now is not None\n    rightnow = time.gmtime()\n    if not debug:\n        now = adjust_to_half_hour( list(rightnow) )\n    then = now[::]\n    then[4] += 30\n    hr, mn = now[3:5]\n    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)\n    b += 1\n    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')\n    if debug:\n        print(\"%02i:%02i, %-20s %s\" % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')\n    else:\n        print(\"%02i:%02i, %-20s %s\" % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')\n    bongs(b)\n    if not debug:\n        scheds.enterabs(calendar.timegm(then), 0, ships_bell)\n        \n        scheds.run()\n\ndef dbg_tester():\n    for h in range(24):\n        for m in (0, 30):\n            if (h,m) == (24,30): break\n            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )\n        \n    \nif __name__ == '__main__':\n    ships_bell()\n"}
{"id": 383230, "name": "Musical scale", "source": "Translate Perl to Python: use MIDI::Simple;\n\n\nset_tempo 500_000;\n\n\nn 60; n 62; n 64; n 65; n 67; n 69; n 71; n 72;\n\nwrite_score 'scale.mid';\n", "target": ">>> import winsound\n>>> for note in [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]:\n\twinsound.Beep(int(note+.5), 500)\t\n>>>\n"}
{"id": 383231, "name": "Musical scale", "source": "Translate Perl to Python: use MIDI::Simple;\n\n\nset_tempo 500_000;\n\n\nn 60; n 62; n 64; n 65; n 67; n 69; n 71; n 72;\n\nwrite_score 'scale.mid';\n", "target": ">>> import winsound\n>>> for note in [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]:\n\twinsound.Beep(int(note+.5), 500)\t\n>>>\n"}
{"id": 383232, "name": "Polyspiral", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse Tk;\nuse List::Util qw( min );\n\nmy $size = 500;\nmy ($width, $height, $x, $y, $dist);\nmy $angleinc = 0;\nmy $active = 0;\nmy $wait = 1000 / 30;\nmy $radian = 90 / atan2 1, 0;\n\nmy $mw = MainWindow->new;\n$mw->title( 'Polyspiral' );\nmy $c = $mw->Canvas( -width => $size, -height => $size,\n  -relief => 'raised', -borderwidth => 2,\n  )->pack(-fill => 'both', -expand => 1);\n$mw->bind('<Configure>' => sub { $width = $c->width; $height = $c->height;\n  $dist = min($width, $height) ** 2 / 4 } );\n$mw->Button(-text => $_->[0], -command => $_->[1],\n  )->pack(-side => 'right') for\n  [ Exit => sub {$mw->destroy} ],\n  [ 'Start / Pause' => sub { $active ^= 1; step() } ];\n\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub step\n  {\n  $active or return;\n  my @pts = ($x = $width >> 1, $y = $height >> 1);\n  my $length = 5;\n  my $angle = $angleinc;\n  $angleinc += 0.05 / $radian;\n  while( ($x - $width / 2)**2 + ($y - $height / 2)**2 < $dist && @pts < 300 )\n    {\n    push @pts, $x, $y;\n    $x += $length * cos($angle);\n    $y += $length * sin($angle);\n    $length += 3;\n    $angle += $angleinc;\n    }\n  $c->delete('all');\n  $c->createLine( @pts );\n  $mw->after($wait => \\&step);\n  }\n", "target": "import math\n\nimport pygame\nfrom pygame.locals import *\n\npygame.init()\nscreen = pygame.display.set_mode((1024, 600))\n\npygame.display.set_caption(\"Polyspiral\")\n\nincr = 0\n\nrunning = True\n\nwhile running:\n\tpygame.time.Clock().tick(60)\n\tfor event in pygame.event.get():\n\t\tif event.type==QUIT:\n\t\t\trunning = False\n\t\t\tbreak\n\n\tincr = (incr + 0.05) % 360\n\tx1 = pygame.display.Info().current_w / 2\n\ty1 = pygame.display.Info().current_h / 2\n\tlength = 5\n\tangle = incr\n\n\tscreen.fill((255,255,255))\n\n\tfor i in range(1,151):\n\t\tx2 = x1 + math.cos(angle) * length\n\t\ty2 = y1 + math.sin(angle) * length\n\t\tpygame.draw.line(screen, (255,0,0), (x1, y1), (x2, y2), 1)\n\t\t\n\t\tx1, y1 = x2, y2\n\t\tlength += 3\n\t\tangle = (angle + incr) % 360\n\n\tpygame.display.flip()\n"}
{"id": 383233, "name": "Polyspiral", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse Tk;\nuse List::Util qw( min );\n\nmy $size = 500;\nmy ($width, $height, $x, $y, $dist);\nmy $angleinc = 0;\nmy $active = 0;\nmy $wait = 1000 / 30;\nmy $radian = 90 / atan2 1, 0;\n\nmy $mw = MainWindow->new;\n$mw->title( 'Polyspiral' );\nmy $c = $mw->Canvas( -width => $size, -height => $size,\n  -relief => 'raised', -borderwidth => 2,\n  )->pack(-fill => 'both', -expand => 1);\n$mw->bind('<Configure>' => sub { $width = $c->width; $height = $c->height;\n  $dist = min($width, $height) ** 2 / 4 } );\n$mw->Button(-text => $_->[0], -command => $_->[1],\n  )->pack(-side => 'right') for\n  [ Exit => sub {$mw->destroy} ],\n  [ 'Start / Pause' => sub { $active ^= 1; step() } ];\n\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub step\n  {\n  $active or return;\n  my @pts = ($x = $width >> 1, $y = $height >> 1);\n  my $length = 5;\n  my $angle = $angleinc;\n  $angleinc += 0.05 / $radian;\n  while( ($x - $width / 2)**2 + ($y - $height / 2)**2 < $dist && @pts < 300 )\n    {\n    push @pts, $x, $y;\n    $x += $length * cos($angle);\n    $y += $length * sin($angle);\n    $length += 3;\n    $angle += $angleinc;\n    }\n  $c->delete('all');\n  $c->createLine( @pts );\n  $mw->after($wait => \\&step);\n  }\n", "target": "import math\n\nimport pygame\nfrom pygame.locals import *\n\npygame.init()\nscreen = pygame.display.set_mode((1024, 600))\n\npygame.display.set_caption(\"Polyspiral\")\n\nincr = 0\n\nrunning = True\n\nwhile running:\n\tpygame.time.Clock().tick(60)\n\tfor event in pygame.event.get():\n\t\tif event.type==QUIT:\n\t\t\trunning = False\n\t\t\tbreak\n\n\tincr = (incr + 0.05) % 360\n\tx1 = pygame.display.Info().current_w / 2\n\ty1 = pygame.display.Info().current_h / 2\n\tlength = 5\n\tangle = incr\n\n\tscreen.fill((255,255,255))\n\n\tfor i in range(1,151):\n\t\tx2 = x1 + math.cos(angle) * length\n\t\ty2 = y1 + math.sin(angle) * length\n\t\tpygame.draw.line(screen, (255,0,0), (x1, y1), (x2, y2), 1)\n\t\t\n\t\tx1, y1 = x2, y2\n\t\tlength += 3\n\t\tangle = (angle + incr) % 360\n\n\tpygame.display.flip()\n"}
{"id": 383234, "name": "Merge and aggregate datasets", "source": "Translate Perl to Python: \nmy $fmt = '|\u00a0%-11s' x 5 . \"|\\n\";\nprintf $fmt, qw( PATIENT_ID LASTNAME LAST_VISIT SCORE_SUM SCORE_AVG);\nmy ($names, $visits) = do { local $/; split /^\\n/m, <DATA> };\nmy %score;\nfor ( $visits =~ /^\\d.*/gm )\n  {\n  my ($id, undef, $score) = split /,/;\n  $score{$id} //= ['', ''];\n  $score and $score{$id}[0]++, $score{$id}[1] += $score;\n  }\nfor ( sort $names =~ /^\\d.*/gm )\n  {\n  my ($id, $name) = split /,/;\n  printf $fmt, $id, $name, ( sort $visits =~ /^$id,(.*?),/gm, '' )[-1],\n    $score{$id}[0]\n      ? ( $score{$id}[1], $score{$id}[1] / $score{$id}[0])\n      : ('', '');\n  }\n\n", "target": "\n\n\nimport pandas as pd\n\n\ndf_patients = pd.read_csv (r'patients.csv', sep = \",\", decimal=\".\")\ndf_visits = pd.read_csv (r'visits.csv', sep = \",\", decimal=\".\")\n\n\n\n\ndf_visits['VISIT_DATE'] = pd.to_datetime(df_visits['VISIT_DATE'])\n\n\ndf_merge = df_patients.merge(df_visits, on='PATIENT_ID', how='left')\n\n\ndf_group = df_merge.groupby(['PATIENT_ID','LASTNAME'], as_index=False)\n\n\ndf_result = df_group.agg({'VISIT_DATE': 'max', 'SCORE': [lambda x: x.sum(min_count=1),'mean']})\n\nprint(df_result)\n"}
{"id": 383235, "name": "Voronoi diagram", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Imager;\n\nmy %type = (\n     Taxicab   => sub { my($px, $py, $x, $y) = @_; abs($px - $x)    + abs($py - $y)    },\n     Euclidean => sub { my($px, $py, $x, $y) = @_;    ($px - $x)**2 +    ($py - $y)**2 },\n     Minkowski => sub { my($px, $py, $x, $y) = @_; abs($px - $x)**3 + abs($py - $y)**3 },\n);\n\nmy($xmax, $ymax) = (400, 400);\nmy @domains;\nfor (1..30) {\n    push @domains, {\n        x   => int 5 + rand $xmax-10,\n        y   => int 5 + rand $ymax-10,\n        rgb => [int rand 255, int rand 255, int rand 255]\n    }\n}\n\nfor my $type (keys %type) {\n    our $img = Imager->new(xsize => $xmax, ysize => $ymax, channels => 3);\n    voronoi($type, $xmax, $ymax, @domains);\n    dot(1,@domains);\n    $img->write(file => \"voronoi-$type.png\");\n\n    sub voronoi {\n        my($type, $xmax, $ymax, @d) = @_;\n        for my $x (0..$xmax) {\n            for my $y (0..$ymax) {\n                my $i = 0;\n                my $d = 10e6;\n                for (0..$\n                    my $dd = &{$type{$type}}($d[$_]{'x'}, $d[$_]{'y'}, $x, $y);\n                    if ($dd < $d) { $d = $dd; $i = $_ }\n                }\n                $img->setpixel(x => $x, y => $y, color => $d[$i]{rgb} );\n            }\n        }\n    }\n\n    sub dot {\n        my($radius, @d) = @_;\n        for (0..$\n            my $dx = $d[$_]{'x'};\n            my $dy = $d[$_]{'y'};\n            for my $x ($dx-$radius .. $dx+$radius) {\n                for my $y ($dy-$radius .. $dy+$radius) {\n                    $img->setpixel(x => $x, y => $y, color => [0,0,0]);\n                }\n            }\n        }\n    }\n}\n", "target": "def setup():\n    size(500, 500)\n    generate_voronoi_diagram(width, height, 25)\n    saveFrame(\"VoronoiDiagram.png\")\n\ndef generate_voronoi_diagram(w, h, num_cells):\n    nx, ny, nr, ng, nb = [], [], [], [], [] \n    for i in range(num_cells):\n        nx.append(int(random(w)))\n        ny.append(int(random(h)))\n        nr.append(int(random(256)))\n        ng.append(int(random(256)))\n        nb.append(int(random(256)))\n    for y in range(h):\n        for x in range(w):\n            dmin = dist(0, 0, w - 1, h - 1)\n            j = -1\n            for i in range(num_cells):\n                d = dist(0, 0, nx[i] - x, ny[i] - y)\n                if d < dmin:\n                    dmin = d\n                    j = i\n            set(x, y, color(nr[j], ng[j], nb[j]))\n"}
{"id": 383236, "name": "Voronoi diagram", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Imager;\n\nmy %type = (\n     Taxicab   => sub { my($px, $py, $x, $y) = @_; abs($px - $x)    + abs($py - $y)    },\n     Euclidean => sub { my($px, $py, $x, $y) = @_;    ($px - $x)**2 +    ($py - $y)**2 },\n     Minkowski => sub { my($px, $py, $x, $y) = @_; abs($px - $x)**3 + abs($py - $y)**3 },\n);\n\nmy($xmax, $ymax) = (400, 400);\nmy @domains;\nfor (1..30) {\n    push @domains, {\n        x   => int 5 + rand $xmax-10,\n        y   => int 5 + rand $ymax-10,\n        rgb => [int rand 255, int rand 255, int rand 255]\n    }\n}\n\nfor my $type (keys %type) {\n    our $img = Imager->new(xsize => $xmax, ysize => $ymax, channels => 3);\n    voronoi($type, $xmax, $ymax, @domains);\n    dot(1,@domains);\n    $img->write(file => \"voronoi-$type.png\");\n\n    sub voronoi {\n        my($type, $xmax, $ymax, @d) = @_;\n        for my $x (0..$xmax) {\n            for my $y (0..$ymax) {\n                my $i = 0;\n                my $d = 10e6;\n                for (0..$\n                    my $dd = &{$type{$type}}($d[$_]{'x'}, $d[$_]{'y'}, $x, $y);\n                    if ($dd < $d) { $d = $dd; $i = $_ }\n                }\n                $img->setpixel(x => $x, y => $y, color => $d[$i]{rgb} );\n            }\n        }\n    }\n\n    sub dot {\n        my($radius, @d) = @_;\n        for (0..$\n            my $dx = $d[$_]{'x'};\n            my $dy = $d[$_]{'y'};\n            for my $x ($dx-$radius .. $dx+$radius) {\n                for my $y ($dy-$radius .. $dy+$radius) {\n                    $img->setpixel(x => $x, y => $y, color => [0,0,0]);\n                }\n            }\n        }\n    }\n}\n", "target": "def setup():\n    size(500, 500)\n    generate_voronoi_diagram(width, height, 25)\n    saveFrame(\"VoronoiDiagram.png\")\n\ndef generate_voronoi_diagram(w, h, num_cells):\n    nx, ny, nr, ng, nb = [], [], [], [], [] \n    for i in range(num_cells):\n        nx.append(int(random(w)))\n        ny.append(int(random(h)))\n        nr.append(int(random(256)))\n        ng.append(int(random(256)))\n        nb.append(int(random(256)))\n    for y in range(h):\n        for x in range(w):\n            dmin = dist(0, 0, w - 1, h - 1)\n            j = -1\n            for i in range(num_cells):\n                d = dist(0, 0, nx[i] - x, ny[i] - y)\n                if d < dmin:\n                    dmin = d\n                    j = i\n            set(x, y, color(nr[j], ng[j], nb[j]))\n"}
{"id": 383237, "name": "Active Directory_Connect", "source": "Translate Perl to Python: use Net::LDAP;\n\nmy $ldap = Net::LDAP->new('ldap://ldap.example.com') or die $@;\nmy $mesg = $ldap->bind( $bind_dn, password => $bind_pass );\n", "target": "import ldap\n\nl = ldap.initialize(\"ldap://ldap.example.com\")\ntry:\n    l.protocol_version = ldap.VERSION3\n    l.set_option(ldap.OPT_REFERRALS, 0)\n\n    bind = l.simple_bind_s(\"me@example.com\", \"password\")\nfinally:\n    l.unbind()\n"}
{"id": 383238, "name": "Knapsack problem_Bounded", "source": "Translate Perl to Python: \n\nuse strict;\n\nmy $raw = <<'TABLE';\nmap     \t9       150     1\ncompass \t13      35      1\nwater   \t153     200     2\nsandwich        50      60      2\nglucose \t15      60      2\ntin     \t68      45      3\nbanana  \t27      60      3\napple  \t\t39      40      3\ncheese  \t23      30      1\nbeer    \t52      10      1\nsuntancream     11      70      1\ncamera  \t32      30      1\nT-shirt \t24      15      2\ntrousers        48      10      2\numbrella        73      40      1\nw_trousers     \t42      70      1\nw_overcoat  \t43      75      1\nnote-case       22      80      1\nsunglasses      7       20      1\ntowel   \t18      12      2\nsocks   \t4       50      1\nbook    \t30      10      2\nTABLE\n \nmy @items;\nfor (split \"\\n\", $raw) {\n        my @x = split /\\s+/;\n\tpush @items, {\n\t\tname\t=> $x[0],\n\t\tweight\t=> $x[1],\n\t\tvalue\t=> $x[2],\n\t\tquant\t=> $x[3],\n\t}\n}\n\nmy $max_weight = 400;\n\nmy %cache;\nsub pick {\n\tmy ($weight, $pos) = @_;\n\tif ($pos < 0 or $weight <= 0) {\n\t\treturn 0, 0, []\n\t}\n\n\t@{ $cache{$weight, $pos} //= [do{\t\n\t\tmy $item = $items[$pos];\n\t\tmy ($bv, $bi, $bw, $bp) = (0, 0, 0, []);\n\n\t\tfor my $i (0 .. $item->{quant}) {\n\t\t\tlast if $i * $item->{weight} > $weight;\n\t\t\tmy ($v, $w, $p) = pick($weight - $i * $item->{weight}, $pos - 1);\n\t\t\tnext if ($v += $i * $item->{value}) <= $bv;\n\n\t\t\t($bv, $bi, $bw, $bp) = ($v, $i, $w, $p);\n\t\t}\n\n\t\tmy @picked = ( @$bp, $bi );\n\t\t$bv, $bw + $bi * $item->{weight}, \\@picked\n\t}]}\n}\n\nmy ($v, $w, $p) = pick($max_weight, $\nfor (0 .. $\n\tif ($p->[$_] > 0) {\n\t\tprint \"$p->[$_] of $items[$_]{name}\\n\";\n\t}\n}\nprint \"Value: $v; Weight: $w\\n\";\n", "target": "\n\nimport strformat\nimport tables\n\n\ntype Item = tuple[name: string; weight, value, pieces: int]\n\n\nconst Items: seq[Item] = @[(\"map\", 9, 150, 1),\n                           (\"compass\", 13, 35, 1),\n                           (\"water\", 153, 200, 2),\n                           (\"sandwich\", 50, 60, 2),\n                           (\"glucose\", 15, 60, 2),\n                           (\"tin\", 68, 45, 3),\n                           (\"banana\", 27, 60, 3),\n                           (\"apple\", 39, 40, 3),\n                           (\"cheese\", 23, 30, 1),\n                           (\"beer\", 52, 10, 3),\n                           (\"suntan cream\", 11, 70, 1),\n                           (\"camera\", 32, 30, 1),\n                           (\"T-shirt\", 24, 15, 2),\n                           (\"trousers\", 48, 10, 2),\n                           (\"umbrella\", 73, 40, 1),\n                           (\"waterproof trousers\", 42, 70, 1),\n                           (\"waterproof overclothes\", 43, 75, 1),\n                           (\"note-case\", 22, 80, 1),\n                           (\"sunglasses\", 7, 20, 1),\n                           (\"towel\", 18, 12, 2),\n                           (\"socks\", 4, 50, 1),\n                           (\"book\", 30, 10, 2)\n                          ]\n\ntype\n\n  \n  Number = range[0..Items.high]\n\n  \n  ExpandedItem = tuple[num: Number; weight, value: int]\n\n\n\n\nproc expandedItems(items: seq[Item]): seq[ExpandedItem] =\n  \n  for idx, item in Items:\n    for _ in 1..item.pieces:\n      result.add((idx.Number, item.weight, item.value))\n\nconst ItemList = expandedItems(Items)\n\ntype\n\n  \n  ExpandedIndex = 0..ItemList.high\n\n  \n  Choice = tuple[indexes: set[ExpandedIndex]; weight, value: int]\n\n\nvar cache: Table[tuple[index, weight: int], Choice]\n\n\n\n\nproc select(idx, weightLimit: int): Choice =\n  \n\n  if idx < 0 or weightLimit == 0:\n    return\n\n  if (idx, weightLimit) in cache:\n    return cache[(idx, weightLimit)]\n\n  let weight = ItemList[idx].weight\n  if weight > weightLimit:\n    return select(idx - 1, weightLimit)\n\n  \n  result = select(idx - 1, weightLimit)\n\n  \n  var result1 = select(idx - 1, weightLimit - weight)\n  inc result1.value, ItemList[idx].value\n\n  \n  if result1.value > result.value:\n    result = (result1.indexes + {idx.ExpandedIndex}, result1.weight + weight, result1.value)\n\n  cache[(idx, weightLimit)] = result\n\n\n\nlet (indexes, weight, value) = select(ItemList.high, 400)\n\n\nvar pieces = newSeq[int](Items.len)\nfor idx in indexes:\n  inc pieces[ItemList[idx].num]\n\necho \"List of items:\"\nfor num in 0..Items.high:\n  if pieces[num] > 0:\n    echo fmt\"\u2013 {pieces[num]} of {Items[num].pieces} {Items[num].name}\"\necho \"\"\necho \"Total weight: \", weight\necho \"Total value: \", value\n"}
{"id": 383239, "name": "SOAP", "source": "Translate Perl to Python: use SOAP::Lite;\n\nprint SOAP::Lite\n  -> service('http://example.com/soap/wsdl')\n  -> soapFunc(\"hello\");\nprint SOAP::Lite\n  -> service('http://example.com/soap/wsdl')\n  -> anotherSoapFunc(34234);\n", "target": "from SOAPpy import WSDL \nproxy = WSDL.Proxy(\"http://example.com/soap/wsdl\")\nresult = proxy.soapFunc(\"hello\")\nresult = proxy.anotherSoapFunc(34234)\n"}
{"id": 383240, "name": "Parse command-line arguments", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Getopt::Long qw(GetOptions);\nmy $output_path;\nmy $verbose = '';\nmy $length = 24;\n\nGetOptions(\n    \"length=i\" => \\$length,\n    \"output|o=s\" => \\$output_path,\n    \"verbose!\" => \\$verbose,\n) or die (\"Error in command line arguments\");\n\nprint \"Outputting to '\", ($output_path // '(undefined)'), \"' path, with \",\n    ($verbose ? \"Verbosity\" : \"No verbosity\"),\n    \" and a length of $length.\\n\";\n", "target": "from optparse import OptionParser\n[...]\nparser = OptionParser()\nparser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                  help=\"write report to FILE\", metavar=\"FILE\")\nparser.add_option(\"-q\", \"--quiet\",\n                  action=\"store_false\", dest=\"verbose\", default=True,\n                  help=\"don't print status messages to stdout\")\n\n(options, args) = parser.parse_args()\n\nexample:\n\n<yourscript> --file=outfile -q\n"}
{"id": 383241, "name": "Parse command-line arguments", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Getopt::Long qw(GetOptions);\nmy $output_path;\nmy $verbose = '';\nmy $length = 24;\n\nGetOptions(\n    \"length=i\" => \\$length,\n    \"output|o=s\" => \\$output_path,\n    \"verbose!\" => \\$verbose,\n) or die (\"Error in command line arguments\");\n\nprint \"Outputting to '\", ($output_path // '(undefined)'), \"' path, with \",\n    ($verbose ? \"Verbosity\" : \"No verbosity\"),\n    \" and a length of $length.\\n\";\n", "target": "from optparse import OptionParser\n[...]\nparser = OptionParser()\nparser.add_option(\"-f\", \"--file\", dest=\"filename\",\n                  help=\"write report to FILE\", metavar=\"FILE\")\nparser.add_option(\"-q\", \"--quiet\",\n                  action=\"store_false\", dest=\"verbose\", default=True,\n                  help=\"don't print status messages to stdout\")\n\n(options, args) = parser.parse_args()\n\nexample:\n\n<yourscript> --file=outfile -q\n"}
{"id": 383242, "name": "Solve a Hidato puzzle", "source": "Translate Perl to Python: use strict;\nuse List::Util 'max';\n\nour (@grid, @known, $n);\n\nsub show_board {\n\tfor my $r (@grid) {\n\t\tprint map(!defined($_)\t? '   ' : $_\n\t\t\t\t\t? sprintf(\"%3d\", $_)\n\t\t\t\t\t: ' __'\n\t\t\t, @$r), \"\\n\"\n\t}\n}\n\nsub parse_board {\n\t@grid = map{[map(/^_/ ? 0 : /^\\./ ? undef: $_, split ' ')]}\n\t\t\tsplit \"\\n\", shift();\n\tfor my $y (0 .. $\n\t\tfor my $x (0 .. $\n\t\t\t$grid[$y][$x] > 0\n\t\t\t\tand $known[$grid[$y][$x]] = \"$y,$x\";\n\t\t}\n\t}\n\t$n = max(map { max @$_ } @grid);\n}\n\nsub neighbors {\n\tmy ($y, $x) = @_;\n\tmy @out;\n\tfor (\t[-1, -1], [-1, 0], [-1, 1],\n\t\t[ 0, -1],\t   [ 0, 1],\n\t\t[ 1, -1], [ 1, 0], [ 1, 1])\n\t{\n\t\tmy $y1 = $y + $_->[0];\n\t\tmy $x1 = $x + $_->[1];\n\t\tnext if $x1 < 0 || $y1 < 0;\n\t\tnext unless defined $grid[$y1][$x1];\n\t\tpush @out, \"$y1,$x1\";\n\t}\n\t@out\n}\n\nsub try_fill {\n\tmy ($v, $coord) = @_;\n\treturn 1\tif $v > $n;\n\n\tmy ($y, $x) = split ',', $coord;\n\tmy $old = $grid[$y][$x];\n\n\treturn\tif $old && $old != $v;\n\treturn\tif exists $known[$v] and $known[$v] ne $coord;\n\n\t$grid[$y][$x] = $v;\n\tprint \"\\033[0H\";\n\tshow_board();\n\n\ttry_fill($v + 1, $_) && return 1\n\t\t\tfor neighbors($y, $x);\n\n\t$grid[$y][$x] = $old;\n\treturn\n}\n\nparse_board \n\n\n\n\n\n\n\n\n\n\t\"__ 33 35 __ __ .. .. .. .\n\t __ __ 24 22 __ .. .. .. .\n\t __ __ __ 21 __ __ .. .. .\n\t __ 26 __ 13 40 11 .. .. .\n\t 27 __ __ __  9 __  1 .. .\n\t .   . __ __ 18 __ __ .. .\n\t .  ..  .  . __  7 __ __ .\n\t .  .. .. ..  .  .  5 __ .\";\n\nprint \"\\033[2J\";\ntry_fill(1, $known[1]);\n", "target": "board = []\ngiven = []\nstart = None\n\ndef setup(s):\n    global board, given, start\n    lines = s.splitlines()\n    ncols = len(lines[0].split())\n    nrows = len(lines)\n    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]\n\n    for r, row in enumerate(lines):\n        for c, cell in enumerate(row.split()):\n            if cell == \"__\" :\n                board[r + 1][c + 1] = 0\n                continue\n            elif cell == \".\":\n                continue \n            else:\n                val = int(cell)\n                board[r + 1][c + 1] = val\n                given.append(val)\n                if val == 1:\n                    start = (r + 1, c + 1)\n    given.sort()\n\ndef solve(r, c, n, next=0):\n    if n > given[-1]:\n        return True\n    if board[r][c] and board[r][c] != n:\n        return False\n    if board[r][c] == 0 and given[next] == n:\n        return False\n\n    back = 0\n    if board[r][c] == n:\n        next += 1\n        back = n\n\n    board[r][c] = n\n    for i in xrange(-1, 2):\n        for j in xrange(-1, 2):\n            if solve(r + i, c + j, n + 1, next):\n                return True\n    board[r][c] = back\n    return False\n\ndef print_board():\n    d = {-1: \"  \", 0: \"__\"}\n    bmax = max(max(r) for r in board)\n    form = \"%\" + str(len(str(bmax)) + 1) + \"s\"\n    for r in board[1:-1]:\n        print \"\".join(form % d.get(c, str(c)) for c in r[1:-1])\n\nhi = \n\nsetup(hi)\nprint_board()\nsolve(start[0], start[1], 1)\nprint\nprint_board()\n"}
{"id": 383243, "name": "Solve a Hidato puzzle", "source": "Translate Perl to Python: use strict;\nuse List::Util 'max';\n\nour (@grid, @known, $n);\n\nsub show_board {\n\tfor my $r (@grid) {\n\t\tprint map(!defined($_)\t? '   ' : $_\n\t\t\t\t\t? sprintf(\"%3d\", $_)\n\t\t\t\t\t: ' __'\n\t\t\t, @$r), \"\\n\"\n\t}\n}\n\nsub parse_board {\n\t@grid = map{[map(/^_/ ? 0 : /^\\./ ? undef: $_, split ' ')]}\n\t\t\tsplit \"\\n\", shift();\n\tfor my $y (0 .. $\n\t\tfor my $x (0 .. $\n\t\t\t$grid[$y][$x] > 0\n\t\t\t\tand $known[$grid[$y][$x]] = \"$y,$x\";\n\t\t}\n\t}\n\t$n = max(map { max @$_ } @grid);\n}\n\nsub neighbors {\n\tmy ($y, $x) = @_;\n\tmy @out;\n\tfor (\t[-1, -1], [-1, 0], [-1, 1],\n\t\t[ 0, -1],\t   [ 0, 1],\n\t\t[ 1, -1], [ 1, 0], [ 1, 1])\n\t{\n\t\tmy $y1 = $y + $_->[0];\n\t\tmy $x1 = $x + $_->[1];\n\t\tnext if $x1 < 0 || $y1 < 0;\n\t\tnext unless defined $grid[$y1][$x1];\n\t\tpush @out, \"$y1,$x1\";\n\t}\n\t@out\n}\n\nsub try_fill {\n\tmy ($v, $coord) = @_;\n\treturn 1\tif $v > $n;\n\n\tmy ($y, $x) = split ',', $coord;\n\tmy $old = $grid[$y][$x];\n\n\treturn\tif $old && $old != $v;\n\treturn\tif exists $known[$v] and $known[$v] ne $coord;\n\n\t$grid[$y][$x] = $v;\n\tprint \"\\033[0H\";\n\tshow_board();\n\n\ttry_fill($v + 1, $_) && return 1\n\t\t\tfor neighbors($y, $x);\n\n\t$grid[$y][$x] = $old;\n\treturn\n}\n\nparse_board \n\n\n\n\n\n\n\n\n\n\t\"__ 33 35 __ __ .. .. .. .\n\t __ __ 24 22 __ .. .. .. .\n\t __ __ __ 21 __ __ .. .. .\n\t __ 26 __ 13 40 11 .. .. .\n\t 27 __ __ __  9 __  1 .. .\n\t .   . __ __ 18 __ __ .. .\n\t .  ..  .  . __  7 __ __ .\n\t .  .. .. ..  .  .  5 __ .\";\n\nprint \"\\033[2J\";\ntry_fill(1, $known[1]);\n", "target": "board = []\ngiven = []\nstart = None\n\ndef setup(s):\n    global board, given, start\n    lines = s.splitlines()\n    ncols = len(lines[0].split())\n    nrows = len(lines)\n    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]\n\n    for r, row in enumerate(lines):\n        for c, cell in enumerate(row.split()):\n            if cell == \"__\" :\n                board[r + 1][c + 1] = 0\n                continue\n            elif cell == \".\":\n                continue \n            else:\n                val = int(cell)\n                board[r + 1][c + 1] = val\n                given.append(val)\n                if val == 1:\n                    start = (r + 1, c + 1)\n    given.sort()\n\ndef solve(r, c, n, next=0):\n    if n > given[-1]:\n        return True\n    if board[r][c] and board[r][c] != n:\n        return False\n    if board[r][c] == 0 and given[next] == n:\n        return False\n\n    back = 0\n    if board[r][c] == n:\n        next += 1\n        back = n\n\n    board[r][c] = n\n    for i in xrange(-1, 2):\n        for j in xrange(-1, 2):\n            if solve(r + i, c + j, n + 1, next):\n                return True\n    board[r][c] = back\n    return False\n\ndef print_board():\n    d = {-1: \"  \", 0: \"__\"}\n    bmax = max(max(r) for r in board)\n    form = \"%\" + str(len(str(bmax)) + 1) + \"s\"\n    for r in board[1:-1]:\n        print \"\".join(form % d.get(c, str(c)) for c in r[1:-1])\n\nhi = \n\nsetup(hi)\nprint_board()\nsolve(start[0], start[1], 1)\nprint\nprint_board()\n"}
{"id": 383244, "name": "Sorting algorithms_Strand sort", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub merge {\n    my ($x, $y) = @_;\n    my @out;\n    while (@$x and @$y) {\n        my $t = $x->[-1] <=> $y->[-1];\n        if    ($t == 1)  { unshift @out, pop @$x }\n        elsif ($t == -1) { unshift @out, pop @$y }\n        else             { splice @out, 0, 0, pop(@$x), pop(@$y) }\n    }\n    @$x, @$y, @out\n}\n\nsub strand {\n    my $x = shift;\n    my @out = shift @$x // return;\n    for (-@$x .. -1) {\n        push @out, splice @$x, $_, 1 if $x->[$_] >= $out[-1];\n    }\n    @out\n}\n\nsub strand_sort {\n    my @x = @_;\n    my(@out, @strand);\n    @out = merge \\@out, \\@strand while @strand = strand(\\@x);\n    @out\n}\n\nmy @a = map (int rand(100), 1 .. 10);\nsay \"Before @a\";\n@a = strand_sort(@a);\nsay \"After  @a\";\n", "target": "def merge_list(a, b):\n\tout = []\n\twhile len(a) and len(b):\n\t\tif a[0] < b[0]:\n\t\t\tout.append(a.pop(0))\n\t\telse:\n\t\t\tout.append(b.pop(0))\n\tout += a\n\tout += b\n\treturn out\n\ndef strand(a):\n\ti, s = 0, [a.pop(0)]\n\twhile i < len(a):\n\t\tif a[i] > s[-1]:\n\t\t\ts.append(a.pop(i))\n\t\telse:\n\t\t\ti += 1\n\treturn s\n\ndef strand_sort(a):\n\tout = strand(a)\n\twhile len(a):\n\t\tout = merge_list(out, strand(a))\n\treturn out\n\nprint strand_sort([1, 6, 3, 2, 1, 7, 5, 3])\n"}
{"id": 383245, "name": "Angles (geometric), normalization and conversion", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse POSIX 'fmod';\n\nmy $tau = 2 * 4*atan2(1, 1);\nmy @units = (\n    { code => 'd', name => 'degrees' , number =>  360 },\n    { code => 'g', name => 'gradians', number =>  400 },\n    { code => 'm', name => 'mills'   , number => 6400 },\n    { code => 'r', name => 'radians' , number => $tau },\n);\n\nmy %cvt;\nfor my $a (@units) {\n  for my $b (@units) {\n    $cvt{ \"${$a}{code}2${$b}{code}\" } = sub {\n        my($angle) = shift;\n        my $norm = fmod($angle,${$a}{number}); \n        $norm -= ${$a}{number} if $angle < 0;\n        $norm * ${$b}{number} / ${$a}{number}\n        }\n  }\n}\n\nprintf '%s'. '%12s'x4 . \"\\n\", '     Angle Unit    ', <Degrees Gradians Mills Radians>;\nfor my $angle (-2, -1, 0, 1, 2, $tau, 16, 360/$tau, 360-1, 400-1, 6400-1, 1_000_000) {\n    print \"\\n\";\n    for my $from (@units) {\n        my @sub_keys = map { \"${$from}{code}2${$_}{code}\" } @units;\n        my @results  = map { &{$cvt{$_}}($angle) } @sub_keys;\n        printf '%10g\u00a0%-8s' . '%12g'x4 . \"\\n\", $angle, ${$from}{name}, @results;\n    }\n}\n", "target": "PI = 3.141592653589793\nTWO_PI = 6.283185307179586\n\ndef normalize2deg(a):\n  while a < 0: a += 360\n  while a >= 360: a -= 360\n  return a\ndef normalize2grad(a):\n  while a < 0: a += 400\n  while a >= 400: a -= 400\n  return a\ndef normalize2mil(a):\n  while a < 0: a += 6400\n  while a >= 6400: a -= 6400\n  return a\ndef normalize2rad(a):\n  while a < 0: a += TWO_PI\n  while a >= TWO_PI: a -= TWO_PI\n  return a\n\ndef deg2grad(a): return a * 10.0 / 9.0\ndef deg2mil(a): return a * 160.0 / 9.0\ndef deg2rad(a): return a * PI / 180.0\n\ndef grad2deg(a): return a * 9.0 / 10.0\ndef grad2mil(a): return a * 16.0\ndef grad2rad(a): return a * PI / 200.0\n\ndef mil2deg(a): return a * 9.0 / 160.0\ndef mil2grad(a): return a / 16.0\ndef mil2rad(a): return a * PI / 3200.0\n\ndef rad2deg(a): return a * 180.0 / PI\ndef rad2grad(a): return a * 200.0 / PI\ndef rad2mil(a): return a * 3200.0 / PI\n"}
{"id": 383246, "name": "XML_XPath", "source": "Translate Perl to Python: use XML::XPath qw();\n\nmy $x = XML::XPath->new('<inventory ... </inventory>');\n\n[$x->findnodes('//item[1]')->get_nodelist]->[0];\nprint $x->findnodes_as_string('//price');\n$x->findnodes('//name')->get_nodelist;\n", "target": "\n\nfrom xml.dom import minidom\n\nxmlfile = file(\"test3.xml\") \nxmldoc = minidom.parse(xmlfile).documentElement \nxmldoc = minidom.parseString(\"<inventory title=\"OmniCorp Store \n\t\n\ni = xmldoc.getElementsByTagName(\"item\") \nfirstItemElement = i[0] \n\n\nfor j in xmldoc.getElementsByTagName(\"price\"): \n\tprint j.childNodes[0].data \n\n\nnamesArray = xmldoc.getElementsByTagName(\"name\")\n"}
{"id": 383247, "name": "HTTPS_Authenticated", "source": "Translate Perl to Python: use LWP::UserAgent qw();\nmy $ua = LWP::UserAgent->new;\nmy $netloc = 'http://www.buddhism-dict.net/cgi-bin/xpr-dealt.pl:80';\n$ua->credentials(\n   $netloc,\n   'CJK-E and Buddhist Dictionaries', \n   'guest',  \n   '',       \n);\nmy $response = $ua->get($netloc);\n\nuse WWW::Mechanize qw();\nmy $mech = WWW::Mechanize->new;\n$mech->get('https://login.yahoo.com/');\n$mech->submit_form(with_fields => {\n    login         => 'XXXXXX',\n    passwd        => 'YYYYYY',\n    '.persistent' => 'y',  \n});\n", "target": "\n\n\nfrom mechanize import Browser\n\nUSER_AGENT = \"Mozilla/5.0 (X11; U; Linux i686; tr-TR; rv:1.8.1.9) Gecko/20071102 Pardus/2007 Firefox/2.0.0.9\"\n\nbr = Browser()\nbr.addheaders = [(\"User-agent\", USER_AGENT)]\n\n\n\n\n\n\nbr.open(\"https://www.facebook.com\")\n\nbr.select_form(\"loginform\")\nbr['email'] = \"xxxxxxx@xxxxx.com\"\nbr['pass'] = \"xxxxxxxxx\"\nbr['persistent'] = [\"1\"]\n\nresponse = br.submit()\nprint response.read()\n"}
{"id": 383248, "name": "Ranking methods", "source": "Translate Perl to Python: my %scores = (\n    'Solomon' => 44,\n    'Jason'   => 42,\n    'Errol'   => 42,\n    'Garry'   => 41,\n    'Bernard' => 41,\n    'Barry'   => 41,\n    'Stephen' => 39\n);\n\nsub tiers {\n    my(%s) = @_; my(%h);\n    push @{$h{$s{$_}}}, $_ for keys %s;\n    @{\\%h}{reverse sort keys %h};\n}\n\nsub standard {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n        $rank += @$players;\n    }\n    return $result;\n}\n\nsub modified {\n    my(%s) = @_; my($result);\n    my $rank = 0;\n    for my $players (tiers %s) {\n        $rank += @$players;\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n    }\n    return $result;\n}\n\nsub dense {\n    my(%s) = @_; my($n,$result);\n    $result .= sprintf \"%d %s\\n\", ++$n, join(', ', sort @$_) for tiers %s;\n    return $result;\n}\n\nsub ordinal {\n    my(%s) = @_; my($n,$result);\n    for my $players (tiers %s) {\n        $result .= sprintf \"%d %s\\n\", ++$n, $_ for sort @$players;\n    }\n    return $result;\n}\n\nsub fractional {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        my $beg = $rank;\n        my $end = $rank += @$players;\n        my $avg = 0;\n        $avg += $_/@$players for $beg .. $end-1;\n        $result .= sprintf \"%3.1f %s\\n\", $avg, join ', ', sort @$players;\n    }\n    return $result;\n}\n\nprint \"Standard:\\n\"    .   standard(%scores) . \"\\n\";\nprint \"Modified:\\n\"    .   modified(%scores) . \"\\n\";\nprint \"Dense:\\n\"       .      dense(%scores) . \"\\n\";\nprint \"Ordinal:\\n\"     .    ordinal(%scores) . \"\\n\";\nprint \"Fractional:\\n\"  . fractional(%scores) . \"\\n\";\n", "target": "def mc_rank(iterable, start=1):\n    \n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n"}
{"id": 383249, "name": "Update a configuration file", "source": "Translate Perl to Python: use warnings;\nuse strict;\n\nmy $needspeeling         = 0;\nmy $seedsremoved         = 1;\nmy $numberofstrawberries = 62000;\nmy $numberofbananas      = 1024;\nmy $favouritefruit       = 'bananas';\n\nmy @out;\n\nsub config {\n    my (@config) = <DATA>;\n    push @config, \"NUMBEROFSTRAWBERRIES $numberofstrawberries\\n\"\n        unless grep { /^;*[ \\t]*NUMBEROFSTRAWBERRIES\\b/; } @config;\n\n    foreach my $line (@config) {\n\n        if (substr($line, 0, 1) eq '\n            push @out, $line;\n            next;\n        }\n\n        next if $line =~ /^[;\\t ]+$/;\n\n        my ($option, $option_name);\n\n        if ($line =~ /^([A-Z]+[0-9]*)/) {\n            $option_name = lc $1;\n            $option      = eval \"\\\\\\$$option_name\";\n            my $value = eval \"\\${$option_name}\";\n\n            if ($value) {\n                $$option = $value;\n            }\n            else {\n                $line    = '; ' . $line;\n                $$option = undef;\n            }\n        }\n        elsif ($line =~ /^;+\\s*([A-Z]+[0-9]*)/) {\n            $option_name = lc $1;\n            $option      = eval \"\\\\\\$$option_name\";\n            my $value = eval \"\\${$option_name}\";\n\n            if ($value) {\n                $line =~ s/^;+\\s*//;\n                $$option = $value == 1 ? '' : $value;\n            }\n            else {\n                $$option = undef;\n            }\n        }\n\n        if (defined $$option) {\n            push @out, \"\\U$option_name\\E $$option\\n\"\n                unless grep { /^\\U$option_name\\E\\b/; } @out;\n        }\n        else {\n            $line =~ s/\\s*[^[:ascii:]]+\\s*$//;\n            $line =~ s/[[:cntrl:]\\s]+$//;\n            push(@out, \"$line\\n\");\n        }\n    }\n}\n\nconfig();\n\nmy $file = join('', @out);\n$file =~ s/\\n{3,}/\\n\\n/g;\n\nprint $file;\n\n", "target": "\n\n\n\n\nimport re\nimport string\n\n\n\n\n\nDISABLED_PREFIX = ';'\n\n\n\n\n\nclass Option(object):\n    \n\n    \n    def __init__(self, name, value=None, disabled=False,\n                 disabled_prefix=DISABLED_PREFIX):\n        \n        self.name = str(name)\n        self.value = value\n        self.disabled = bool(disabled)\n        self.disabled_prefix = disabled_prefix\n\n    \n    def __str__(self):\n        \n        disabled = ('', '%s ' % self.disabled_prefix)[self.disabled]\n        value = (' %s' % self.value, '')[self.value is None]\n        return ''.join((disabled, self.name, value))\n\n    \n    def get(self):\n        \n        enabled = not bool(self.disabled)\n        if self.value is None:\n            value = enabled\n        else:\n            value = enabled and self.value\n        return value\n\n    \n\n\n\nclass Config(object):\n    \n    \n    reOPTION = r'^\\s*(?P<disabled>%s*)\\s*(?P<name>\\w+)(?:\\s+(?P<value>.+?))?\\s*$'\n\n    \n    def __init__(self, fname=None, disabled_prefix=DISABLED_PREFIX):\n        \n        self.disabled_prefix = disabled_prefix\n        self.contents = []          \n        self.options = {}           \n        self.creOPTION = re.compile(self.reOPTION % self.disabled_prefix)\n        if fname:\n            self.parse_file(fname)\n\n    \n    def __str__(self):\n        \n        return '\\n'.join(map(str, self.contents))\n\n    \n    def parse_file(self, fname):\n        \n        with open(fname) as f:\n            self.parse_lines(f)\n        return self\n\n    \n    def parse_lines(self, lines):\n        \n        for line in lines:\n            self.parse_line(line)\n        return self\n\n    \n    def parse_line(self, line):\n        \n        s = ''.join(c for c in line.strip() if c in string.printable) \n        moOPTION = self.creOPTION.match(s)\n        if moOPTION:\n            name = moOPTION.group('name').upper()\n            if not name in self.options:\n                self.add_option(name, moOPTION.group('value'),\n                                moOPTION.group('disabled'))\n        else:\n            if not s.startswith(self.disabled_prefix):\n                self.contents.append(line.rstrip())\n        return self\n\n    \n    def add_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = Option(name, value, disabled)\n        self.options[name] = opt\n        self.contents.append(opt)\n        return opt\n\n    \n    def set_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = self.options.get(name)\n        if opt:\n            opt.value = value\n            opt.disabled = disabled\n        else:\n            opt = self.add_option(name, value, disabled)\n        return opt\n\n    \n    def enable_option(self, name, value=None):\n        \n        return self.set_option(name, value, False)\n\n    \n    def disable_option(self, name, value=None):\n        \n        return self.set_option(name, value, True)\n\n    \n    def get_option(self, name):\n        \n        opt = self.options.get(name.upper())\n        value = opt.get() if opt else None\n        return value\n\n\n\n\n\nif __name__ == '__main__':\n    import sys\n    cfg = Config(sys.argv[1] if len(sys.argv) > 1 else None)\n    cfg.disable_option('needspeeling')\n    cfg.enable_option('seedsremoved')\n    cfg.enable_option('numberofbananas', 1024)\n    cfg.enable_option('numberofstrawberries', 62000)\n    print cfg\n"}
{"id": 383250, "name": "Straddling checkerboard", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util <min max>;\n\nmy(%encode,%decode,@table);\n\nsub build {\n    my($u,$v,$alphabet) = @_;\n    my(@flat_board,%p2c,%c2p);\n    my $numeric_escape = '/';\n\n    @flat_board = split '', uc $alphabet;\n    splice @flat_board, min($u,$v), 0, undef;\n    splice @flat_board, max($u,$v), 0, undef;\n\n    push @table, [' ', 0..9];\n    push @table, [' ', map { defined $_ ? $_ : ' '} @flat_board[ 0 ..  9] ];\n    push @table, [$u,  @flat_board[10 .. 19]];\n    push @table, [$v,  @flat_board[20 .. 29]];\n\n    my @nums = my @order = 0..9;\n    push @nums, (map { +\"$u$_\" } @order), map { +\"$v$_\" } @order;\n\n    @c2p{@nums} = @flat_board;\n    for (keys %c2p) { delete $c2p{$_} unless defined $c2p{$_} }\n    @p2c{values %c2p} = keys %c2p;\n    $p2c{$_} = $p2c{$numeric_escape} . $_ for 0..9;\n    while (my ($k, $v) = each %p2c) {\n        $encode{$k} = $v;\n        $decode{$v} = $k unless $k eq $numeric_escape;\n    }\n}\n\nsub decode {\n    my($string) = @_;\n    my $keys = join '|', keys %decode;\n    $string =~ s/($keys)/$decode{$1}/gr;\n}\n\nsub encode {\n    my($string) = uc shift;\n    $string =~ s\n}\n\nmy $sc = build(3, 7, 'HOLMESRTABCDFGIJKNPQUVWXYZ./');\nsay join  ' ', @$_ for @table;\nsay '';\nsay 'Original: ', my $original = 'One night-it was on the twentieth of March, 1888-I was returning';\nsay 'Encoded:  ', my $en = encode($original);\nsay 'Decoded:  ', decode($en);\n", "target": "T = [[\"79\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n     [\"\",   \"H\", \"O\", \"L\", \"\",  \"M\", \"E\", \"S\", \"\",  \"R\", \"T\"],\n     [\"3\",  \"A\", \"B\", \"C\", \"D\", \"F\", \"G\", \"I\", \"J\", \"K\", \"N\"],\n     [\"7\",  \"P\", \"Q\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \".\", \"/\"]]\n\ndef straddle(s):\n    return \"\".join(L[0]+T[0][L.index(c)] for c in s.upper() for L in T if c in L)\n\ndef unstraddle(s):\n    s = iter(s)\n    for c in s:\n        if c in [T[2][0], T[3][0]]:\n            i = [T[2][0], T[3][0]].index(c)\n            n = T[2 + i][T[0].index(s.next())]\n            yield s.next() if n == \"/\" else n\n        else:\n            yield T[1][T[0].index(c)]\n\nO = \"One night-it was on the twentieth of March, 1888-I was returning\"\nprint \"Encoded:\", straddle(O)\nprint \"Decoded:\", \"\".join(unstraddle(straddle(O)))\n"}
{"id": 383251, "name": "I before E except after C", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\n\nsub result {\n    my ($support, $against) = @_;\n    my $ratio  = sprintf '%.2f', $support / $against;\n    my $result = $ratio >= 2;\n    print \"$support / $against = $ratio. \", 'NOT ' x !$result, \"PLAUSIBLE\\n\";\n    return $result;\n}\n\nmy @keys  = qw(ei cei ie cie);\nmy %count;\n\nwhile (<>) {\n    for my $k (@keys) {\n        $count{$k}++ if -1 != index $_, $k;\n    }\n}\n\nmy ($support, $against, $result);\n\nprint 'I before E when not preceded by C: ';\n$support = $count{ie} - $count{cie};\n$against = $count{ei} - $count{cei};\n$result += result($support, $against);\n\nprint 'E before I when preceded by C: ';\n$support = $count{cei};\n$against = $count{cie};\n$result += result($support, $against);\n\nprint 'Overall: ', 'NOT ' x ($result < 2), \"PLAUSIBLE.\\n\";\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 383252, "name": "I before E except after C", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\n\nsub result {\n    my ($support, $against) = @_;\n    my $ratio  = sprintf '%.2f', $support / $against;\n    my $result = $ratio >= 2;\n    print \"$support / $against = $ratio. \", 'NOT ' x !$result, \"PLAUSIBLE\\n\";\n    return $result;\n}\n\nmy @keys  = qw(ei cei ie cie);\nmy %count;\n\nwhile (<>) {\n    for my $k (@keys) {\n        $count{$k}++ if -1 != index $_, $k;\n    }\n}\n\nmy ($support, $against, $result);\n\nprint 'I before E when not preceded by C: ';\n$support = $count{ie} - $count{cie};\n$against = $count{ei} - $count{cei};\n$result += result($support, $against);\n\nprint 'E before I when preceded by C: ';\n$support = $count{cei};\n$against = $count{cie};\n$result += result($support, $against);\n\nprint 'Overall: ', 'NOT ' x ($result < 2), \"PLAUSIBLE.\\n\";\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 383253, "name": "Abelian sandpile model", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'bitwise';\n\nmy ($high, $wide) = split ' ', qx(stty size);\nmy $mask = \"\\0\" x $wide . (\"\\0\" . \"\\177\" x ($wide - 2) . \"\\0\") x ($high - 5) .\n  \"\\0\" x $wide;\nmy $pile = $mask =~ s/\\177/ rand() < 0.02\u00a0? chr 64 + rand 20\u00a0: \"\\0\" /ger;\n\nfor (1 .. 1e6)\n  {\n  print \"\\e[H\", $pile =~ tr/\\0-\\177/ 1-~/r, \"\\n$_\";\n  my $add = $pile =~ tr/\\1-\\177/\\0\\0\\0\\200/r; \n  $add =~ /\\200/ or last;\n  $pile =~ tr/\\4-\\177/\\0-\\173/; \n  for (\"\\0$add\", \"\\0\" x $wide . $add, substr($add, 1), substr $add, $wide)\n    {\n    $pile |.= $_;\n    $pile =~ tr/\\200-\\377/\\1-\\176/; \n    $pile &.= $mask;\n    }\n  select undef, undef, undef, 0.1; \n  }\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"}
{"id": 383254, "name": "Abelian sandpile model", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'bitwise';\n\nmy ($high, $wide) = split ' ', qx(stty size);\nmy $mask = \"\\0\" x $wide . (\"\\0\" . \"\\177\" x ($wide - 2) . \"\\0\") x ($high - 5) .\n  \"\\0\" x $wide;\nmy $pile = $mask =~ s/\\177/ rand() < 0.02\u00a0? chr 64 + rand 20\u00a0: \"\\0\" /ger;\n\nfor (1 .. 1e6)\n  {\n  print \"\\e[H\", $pile =~ tr/\\0-\\177/ 1-~/r, \"\\n$_\";\n  my $add = $pile =~ tr/\\1-\\177/\\0\\0\\0\\200/r; \n  $add =~ /\\200/ or last;\n  $pile =~ tr/\\4-\\177/\\0-\\173/; \n  for (\"\\0$add\", \"\\0\" x $wide . $add, substr($add, 1), substr $add, $wide)\n    {\n    $pile |.= $_;\n    $pile =~ tr/\\200-\\377/\\1-\\176/; \n    $pile &.= $mask;\n    }\n  select undef, undef, undef, 0.1; \n  }\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"}
{"id": 383255, "name": "Xiaolin Wu's line algorithm", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\n\nsub plot {\n\tmy ($x, $y, $c) = @_;\n\tprintf \"plot %d %d\u00a0%.1f\\n\", $x, $y, $c if $c;\n}\n\nsub ipart {\n\tint shift;\n}\n\nsub round {\n\tint( 0.5 + shift );\n}\n\nsub fpart {\n\tmy $x = shift;\n\t$x - int $x;\n}\n\nsub rfpart {\n\t1 - fpart(shift);\n}\n \nsub drawLine {\n\tmy ($x0, $y0, $x1, $y1) = @_;\n\n\tmy $plot = \\&plot;\n\n\tif( abs($y1 - $y0) > abs($x1 - $x0) ) {\n\t\t$plot = sub { plot( @_[1, 0, 2] ) };\n\t\t($x0, $y0, $x1, $y1) = ($y0, $x0, $y1, $x1);\n\t}\n\n\tif( $x0 > $x1 ) {\n\t\t($x0, $x1, $y0, $y1) = ($x1, $x0, $y1, $y0);\n\t}\n\n\tmy $dx = $x1 - $x0;\n\tmy $dy = $y1 - $y0;\n\tmy $gradient = $dy / $dx;\n\n\tmy @xends;\n\tmy $intery;\n\n\t\n\tfor my $xy ([$x0, $y0], [$x1, $y1]) {\n\t\tmy ($x, $y) = @$xy;\n\t\tmy $xend = round($x);\n\t\tmy $yend = $y + $gradient * ($xend - $x);\n\t\tmy $xgap = rfpart($x + 0.5);\n\n\t\tmy $x_pixel = $xend;\n\t\tmy $y_pixel = ipart($yend);\n\t\tpush @xends, $x_pixel;\n\n\t\t$plot->($x_pixel, $y_pixel  , rfpart($yend) * $xgap);\n\t\t$plot->($x_pixel, $y_pixel+1,  fpart($yend) * $xgap);\n\t\tnext if defined $intery;\n\t\t\n\t\t$intery = $yend + $gradient;\n\t}\n\n\t\n\n\tfor my $x ( $xends[0] + 1 .. $xends[1] - 1 ) {\n\t\t$plot->($x, ipart ($intery),  rfpart($intery));\n\t\t$plot->($x, ipart ($intery)+1, fpart($intery));\n\t\t$intery += $gradient;\n\t}\n}\n\nif( $0 eq __FILE__ ) {\n\tdrawLine( 0, 1, 10, 2 );\n}\n", "target": "\nfrom __future__ import division\nimport sys\n\nfrom PIL import Image\n\n\ndef _fpart(x):\n    return x - int(x)\n\ndef _rfpart(x):\n    return 1 - _fpart(x)\n\ndef putpixel(img, xy, color, alpha=1):\n    \n    compose_color = lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg))\n    c = compose_color(img.getpixel(xy), color)\n    img.putpixel(xy, c)\n\ndef draw_line(img, p1, p2, color):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    dx, dy = x2-x1, y2-y1\n    steep = abs(dx) < abs(dy)\n    p = lambda px, py: ((px,py), (py,px))[steep]\n\n    if steep:\n        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx\n    if x2 < x1:\n        x1, x2, y1, y2 = x2, x1, y2, y1\n\n    grad = dy/dx\n    intery = y1 + _rfpart(x1) * grad\n    def draw_endpoint(pt):\n        x, y = pt\n        xend = round(x)\n        yend = y + grad * (xend - x)\n        xgap = _rfpart(x + 0.5)\n        px, py = int(xend), int(yend)\n        putpixel(img, p(px, py), color, _rfpart(yend) * xgap)\n        putpixel(img, p(px, py+1), color, _fpart(yend) * xgap)\n        return px\n\n    xstart = draw_endpoint(p(*p1)) + 1\n    xend = draw_endpoint(p(*p2))\n\n    for x in range(xstart, xend):\n        y = int(intery)\n        putpixel(img, p(x, y), color, _rfpart(intery))\n        putpixel(img, p(x, y+1), color, _fpart(intery))\n        intery += grad\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print 'usage: python xiaolinwu.py [output-file]'\n        sys.exit(-1)\n\n    blue = (0, 0, 255)\n    yellow = (255, 255, 0)\n    img = Image.new(\"RGB\", (500,500), blue)\n    for a in range(10, 431, 60):\n        draw_line(img, (10, 10), (490, a), yellow)\n        draw_line(img, (10, 10), (a, 490), yellow)\n    draw_line(img, (10, 10), (490, 490), yellow)\n    filename = sys.argv[1]\n    img.save(filename)\n    print 'image saved to', filename\n"}
{"id": 383256, "name": "Next highest int from digits", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint;\nuse List::Util 'first';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub next_greatest_index {\n    my($str) = @_;\n    my @i = reverse split //, $str;\n    @i-1 - (1 + first { $i[$_] > $i[$_+1] } 0 .. @i-1);\n}\n\nsub next_greatest_integer {\n    my($num) = @_;\n    my $numr;\n    return 0 if length $num < 2;\n    return ($numr = 0 + reverse $num) > $num ? $numr : 0 if length $num == 2;\n    return 0 unless my $i = next_greatest_index( $num ) // 0;\n    my $digit = substr($num, $i, 1);\n    my @rest  = sort split '', substr($num, $i);\n    my $next  = first { $rest[$_] > $digit } 1..@rest;\n    join '', substr($num, 0, $i), (splice(@rest, $next, 1)), @rest;\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:';\n\nfor (0, 9, 12, 21, 12453, 738440, 45072010, 95322020, 9589776899767587796600, 3345333) {\n    printf \"%30s  ->  %s\\n\", comma($_), comma next_greatest_integer $_;\n}\n", "target": "def closest_more_than(n, lst):\n    \"(index of) closest int from lst, to n that is also > n\"\n    large = max(lst) + 1\n    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))\n\ndef nexthigh(n):\n    \"Return nxt highest number from n's digits using scan & re-order\"\n    assert n == int(abs(n)), \"n >= 0\"\n    this = list(int(digit) for digit in str(int(n)))[::-1]\n    mx = this[0]\n    for i, digit in enumerate(this[1:], 1):\n        if digit < mx:\n            mx_index = closest_more_than(digit, this[:i + 1])\n            this[mx_index], this[i] = this[i], this[mx_index]\n            this[:i] = sorted(this[:i], reverse=True)\n            return int(''.join(str(d) for d in this[::-1]))\n        elif digit > mx:\n            mx, mx_index = digit, i\n    return 0\n\n\nif __name__ == '__main__':\n    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,\n              9589776899767587796600]:\n        print(f\"{x:>12_d} -> {nexthigh(x):>12_d}\")\n"}
{"id": 383257, "name": "Next highest int from digits", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint;\nuse List::Util 'first';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub next_greatest_index {\n    my($str) = @_;\n    my @i = reverse split //, $str;\n    @i-1 - (1 + first { $i[$_] > $i[$_+1] } 0 .. @i-1);\n}\n\nsub next_greatest_integer {\n    my($num) = @_;\n    my $numr;\n    return 0 if length $num < 2;\n    return ($numr = 0 + reverse $num) > $num ? $numr : 0 if length $num == 2;\n    return 0 unless my $i = next_greatest_index( $num ) // 0;\n    my $digit = substr($num, $i, 1);\n    my @rest  = sort split '', substr($num, $i);\n    my $next  = first { $rest[$_] > $digit } 1..@rest;\n    join '', substr($num, 0, $i), (splice(@rest, $next, 1)), @rest;\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:';\n\nfor (0, 9, 12, 21, 12453, 738440, 45072010, 95322020, 9589776899767587796600, 3345333) {\n    printf \"%30s  ->  %s\\n\", comma($_), comma next_greatest_integer $_;\n}\n", "target": "def closest_more_than(n, lst):\n    \"(index of) closest int from lst, to n that is also > n\"\n    large = max(lst) + 1\n    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))\n\ndef nexthigh(n):\n    \"Return nxt highest number from n's digits using scan & re-order\"\n    assert n == int(abs(n)), \"n >= 0\"\n    this = list(int(digit) for digit in str(int(n)))[::-1]\n    mx = this[0]\n    for i, digit in enumerate(this[1:], 1):\n        if digit < mx:\n            mx_index = closest_more_than(digit, this[:i + 1])\n            this[mx_index], this[i] = this[i], this[mx_index]\n            this[:i] = sorted(this[:i], reverse=True)\n            return int(''.join(str(d) for d in this[::-1]))\n        elif digit > mx:\n            mx, mx_index = digit, i\n    return 0\n\n\nif __name__ == '__main__':\n    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,\n              9589776899767587796600]:\n        print(f\"{x:>12_d} -> {nexthigh(x):>12_d}\")\n"}
{"id": 383258, "name": "Simulate input_Keyboard", "source": "Translate Perl to Python: $target = \"/dev/pts/51\"; \n\n$TIOCSTI = 0x5412 ; \nopen(TTY,\">$target\") or die \"cannot open $target\" ; \n$b=\"sleep 99334 &\\015\"; \n@c=split(\"\",$b); \nsleep(2); \nforeach $a ( @c ) { ioctl(TTY,$TIOCSTI,$a); select(undef,undef,undef,0.1);} ; \nprint \"DONE\\n\";\n", "target": "import autopy\nautopy.key.type_string(\"Hello, world!\") \nautopy.key.type_string(\"Hello, world!\", wpm=60) \nautopy.key.tap(autopy.key.Code.RETURN)\nautopy.key.tap(autopy.key.Code.F1)\nautopy.key.tap(autopy.key.Code.LEFT_ARROW)\n"}
{"id": 383259, "name": "Four is magic", "source": "Translate Perl to Python: use Lingua::EN::Numbers qw(num2en);\n\nsub cardinal {\n    my($n) = @_;\n    (my $en = num2en($n)) =~ s/\\ and|,//g;\n    $en;\n}\n\nsub magic {\n    my($int) = @_;\n    my $str;\n    while () {\n       $str .= cardinal($int) . \" is \";\n       if ($int == 4) {\n           $str .= \"magic.\\n\";\n           last\n       } else {\n           $int = length cardinal($int);\n           $str .= cardinal($int) . \", \";\n       }\n   }\n   ucfirst $str;\n}\n\nprint magic($_) for 0, 4, 6, 11, 13, 75, 337, -164, 9_876_543_209;\n", "target": "import random\nfrom collections import OrderedDict\n\nnumbers = {  \n    1: 'one',\n    2: 'two',\n    3: 'three',\n    4: 'four',\n    5: 'five',\n    6: 'six',\n    7: 'seven',\n    8: 'eight',\n    9: 'nine',\n    10: 'ten',\n    11: 'eleven',\n    12: 'twelve',\n    13: 'thirteen',\n    14: 'fourteen',\n    15: 'fifteen',\n    16: 'sixteen',\n    17: 'seventeen',\n    18: 'eighteen',\n    19: 'nineteen',\n    20: 'twenty',\n    30: 'thirty',\n    40: 'forty',\n    50: 'fifty',\n    60: 'sixty',\n    70: 'seventy',\n    80: 'eighty',\n    90: 'ninety',\n    100: 'hundred',\n    1000: 'thousand',\n    10 ** 6: 'million',\n    10 ** 9: 'billion',\n    10 ** 12: 'trillion',\n    10 ** 15: 'quadrillion',\n    10 ** 18: 'quintillion',\n    10 ** 21: 'sextillion',\n    10 ** 24: 'septillion',\n    10 ** 27: 'octillion',\n    10 ** 30: 'nonillion',\n    10 ** 33: 'decillion',\n    10 ** 36: 'undecillion',\n    10 ** 39: 'duodecillion',\n    10 ** 42: 'tredecillion',\n    10 ** 45: 'quattuordecillion',\n    10 ** 48: 'quinquadecillion',\n    10 ** 51: 'sedecillion',\n    10 ** 54: 'septendecillion',\n    10 ** 57: 'octodecillion',\n    10 ** 60: 'novendecillion',\n    10 ** 63: 'vigintillion',\n    10 ** 66: 'unvigintillion',\n    10 ** 69: 'duovigintillion',\n    10 ** 72: 'tresvigintillion',\n    10 ** 75: 'quattuorvigintillion',\n    10 ** 78: 'quinquavigintillion',\n    10 ** 81: 'sesvigintillion',\n    10 ** 84: 'septemvigintillion',\n    10 ** 87: 'octovigintillion',\n    10 ** 90: 'novemvigintillion',\n    10 ** 93: 'trigintillion',\n    10 ** 96: 'untrigintillion',\n    10 ** 99: 'duotrigintillion',\n    10 ** 102: 'trestrigintillion',\n    10 ** 105: 'quattuortrigintillion',\n    10 ** 108: 'quinquatrigintillion',\n    10 ** 111: 'sestrigintillion',\n    10 ** 114: 'septentrigintillion',\n    10 ** 117: 'octotrigintillion',\n    10 ** 120: 'noventrigintillion',\n    10 ** 123: 'quadragintillion',\n    10 ** 153: 'quinquagintillion',\n    10 ** 183: 'sexagintillion',\n    10 ** 213: 'septuagintillion',\n    10 ** 243: 'octogintillion',\n    10 ** 273: 'nonagintillion',\n    10 ** 303: 'centillion',\n    10 ** 306: 'uncentillion',\n    10 ** 309: 'duocentillion',\n    10 ** 312: 'trescentillion',\n    10 ** 333: 'decicentillion',\n    10 ** 336: 'undecicentillion',\n    10 ** 363: 'viginticentillion',\n    10 ** 366: 'unviginticentillion',\n    10 ** 393: 'trigintacentillion',\n    10 ** 423: 'quadragintacentillion',\n    10 ** 453: 'quinquagintacentillion',\n    10 ** 483: 'sexagintacentillion',\n    10 ** 513: 'septuagintacentillion',\n    10 ** 543: 'octogintacentillion',\n    10 ** 573: 'nonagintacentillion',\n    10 ** 603: 'ducentillion',\n    10 ** 903: 'trecentillion',\n    10 ** 1203: 'quadringentillion',\n    10 ** 1503: 'quingentillion',\n    10 ** 1803: 'sescentillion',\n    10 ** 2103: 'septingentillion',\n    10 ** 2403: 'octingentillion',\n    10 ** 2703: 'nongentillion',\n    10 ** 3003: 'millinillion'\n}\nnumbers = OrderedDict(sorted(numbers.items(), key=lambda t: t[0], reverse=True))\n\n\ndef string_representation(i: int) -> str:\n    \n    if i == 0:\n        return 'zero'\n\n    words = ['negative'] if i < 0 else []\n    working_copy = abs(i)\n\n    for key, value in numbers.items():\n        if key <= working_copy:\n            times = int(working_copy / key)\n\n            if key >= 100:\n                words.append(string_representation(times))\n\n            words.append(value)\n            working_copy -= times * key\n\n        if working_copy == 0:\n            break\n\n    return ' '.join(words)\n\n\ndef next_phrase(i: int):\n    \n    while not i == 4:  \n        str_i = string_representation(i)\n        len_i = len(str_i)\n\n        yield str_i, 'is', string_representation(len_i)\n\n        i = len_i\n\n    \n    yield string_representation(i), 'is', 'magic'\n\n\ndef magic(i: int) -> str:\n    phrases = []\n\n    for phrase in next_phrase(i):\n        phrases.append(' '.join(phrase))\n\n    return f'{\", \".join(phrases)}.'.capitalize()\n\n\nif __name__ == '__main__':\n\n    for j in (random.randint(0, 10 ** 3) for i in range(5)):\n        print(j, ':\\n', magic(j), '\\n')\n\n    for j in (random.randint(-10 ** 24, 10 ** 24) for i in range(2)):\n        print(j, ':\\n', magic(j), '\\n')\n"}
{"id": 383260, "name": "Two bullet roulette", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @cyl;\nmy $shots = 6;\n\nsub load  {\n    push @cyl, shift @cyl while $cyl[1];\n    $cyl[1] = 1;\n    push @cyl, shift @cyl\n}\n\nsub spin  { push @cyl, shift @cyl for 0 .. int rand @cyl }\nsub fire  { push @cyl, shift @cyl; $cyl[0] }\n\nsub LSLSFSF {\n    @cyl = (0) x $shots;\n    load, spin, load, spin;\n    return 1 if fire;\n    spin;\n    fire\n}\n\nsub LSLSFF {\n    @cyl = (0) x $shots;\n    load, spin, load, spin;\n    fire or fire\n}\n\nsub LLSFSF {\n    @cyl = (0) x $shots;\n    load, load, spin;\n    return 1 if fire;\n    spin;\n    fire\n}\n\nsub LLSFF {\n    @cyl = (0) x $shots;\n    load, load, spin;\n    fire or fire\n}\n\nmy $trials = 10000;\n\nfor my $ref (<LSLSFSF LSLSFF LLSFSF LLSFF>) {\n    no strict 'refs';\n    my $total = 0;\n    $total += &$ref for 1..$trials;\n    printf \"%7s\u00a0%.2f%%\\n\", $ref, $total / $trials * 100;\n}\n", "target": "\nimport numpy as np\n\nclass Revolver:\n    \n\n    def __init__(self):\n        \n        self.cylinder = np.array([False] * 6)\n\n    def unload(self):\n        \n        self.cylinder[:] = False\n\n    def load(self):\n        \n        while self.cylinder[1]:\n            self.cylinder[:] = np.roll(self.cylinder, 1)\n        self.cylinder[1] = True\n\n    def spin(self):\n        \n        self.cylinder[:] = np.roll(self.cylinder, np.random.randint(1, high=7))\n\n    def fire(self):\n        \n        shot = self.cylinder[0]\n        self.cylinder[:] = np.roll(self.cylinder, 1)\n        return shot\n\n    def LSLSFSF(self):\n        \n        self.unload()\n        self.load()\n        self.spin()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        self.spin()\n        if self.fire():\n            return True\n        return False\n\n    def LSLSFF(self):\n        \n        self.unload()\n        self.load()\n        self.spin()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        if self.fire():\n            return True\n        return False\n\n    def LLSFSF(self):\n        \n        self.unload()\n        self.load()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        self.spin()\n        if self.fire():\n            return True\n        return False\n\n    def LLSFF(self):\n        \n        self.unload()\n        self.load()\n        self.load()\n        self.spin()\n        if self.fire():\n            return True\n        if self.fire():\n            return True\n        return False\n\n\nif __name__ == '__main__':\n\n    REV = Revolver()\n    TESTCOUNT = 100000\n    for (name, method) in [['load, spin, load, spin, fire, spin, fire', REV.LSLSFSF],\n                           ['load, spin, load, spin, fire, fire', REV.LSLSFF],\n                           ['load, load, spin, fire, spin, fire', REV.LLSFSF],\n                           ['load, load, spin, fire, fire', REV.LLSFF]]:\n\n        percentage = 100 * sum([method() for _ in range(TESTCOUNT)]) / TESTCOUNT\n        print(\"Method\", name, \"produces\", percentage, \"per cent deaths.\")\n"}
{"id": 383261, "name": "Sierpinski pentagon", "source": "Translate Perl to Python: use ntheory qw(todigits);\nuse Math::Complex;\n\n$sides = 5;\n$order = 5;\n$dim   = 250;\n$scale = ( 3 - 5**.5 ) / 2;\npush @orders, ((1 - $scale) * $dim) * $scale ** $_ for 0..$order-1;\n\nopen $fh, '>', 'sierpinski_pentagon.svg';\nprint $fh qq|<svg height=\"@{[$dim*2]}\" width=\"@{[$dim*2]}\" style=\"fill:blue\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\\n|;\n\n$tau = 2 * 4*atan2(1, 1);\npush @vertices, cis( $_ * $tau / $sides ) for 0..$sides-1;\n\nfor $i (0 .. -1+$sides**$order)  {\n    @base5 = todigits($i,5);\n    @i = ( ((0)x(-1+$sides-$\n    @v = @vertices[@i];\n    $vector = 0;\n    $vector += $v[$_] * $orders[$_] for 0..$\n\n    my @points;\n    for (@vertices) {\n        $v = $vector + $orders[-1] * (1 - $scale) * $_;\n        push @points, sprintf '%.3f\u00a0%.3f', $v->Re, $v->Im;\n    }\n    print $fh pgon(@points);\n}\n\nsub cis  { Math::Complex->make(cos($_[0]), sin($_[0])) }\nsub pgon { my(@q)=@_; qq|<polygon points=\"@q\" transform=\"translate($dim,$dim) rotate(-18)\"/>\\n| }\n\nprint $fh '</svg>';\nclose $fh;\n", "target": "from turtle import *\nimport math\nspeed(0)      \nhideturtle()  \n\npart_ratio = 2 * math.cos(math.radians(72))\nside_ratio = 1 / (part_ratio + 2)\n\nhide_turtles = True   \npath_color = \"black\"  \nfill_color = \"black\"  \n\n\ndef pentagon(t, s):\n  t.color(path_color, fill_color)\n  t.pendown()\n  t.right(36)\n  t.begin_fill()\n  for i in range(5):\n    t.forward(s)\n    t.right(72)\n  t.end_fill()\n\n\ndef sierpinski(i, t, s):\n  t.setheading(0)\n  new_size = s * side_ratio\n  \n  if i > 1:\n    i -= 1\n    \n    \n    for j in range(4):\n      t.right(36)\n      short = s * side_ratio / part_ratio\n      dist = [short, s, s, short][j]\n      \n      \n      spawn = Turtle()\n      if hide_turtles:spawn.hideturtle()\n      spawn.penup()\n      spawn.setposition(t.position())\n      spawn.setheading(t.heading())\n      spawn.forward(dist)\n      \n      \n      sierpinski(i, spawn, new_size)\n    \n    \n    sierpinski(i, t, new_size)\n    \n  else:\n    \n    pentagon(t, s)\n    \n    del t\n\ndef main():\n  t = Turtle()\n  t.hideturtle()\n  t.penup()\n  screen = t.getscreen()\n  y = screen.window_height()\n  t.goto(0, y/2-20)\n  \n  i = 5       \n  size = 300  \n  \n  \n  size *= part_ratio\n  \n  \n  sierpinski(i, t, size)\n\nmain()\n"}
{"id": 383262, "name": "Zhang-Suen thinning algorithm", "source": "Translate Perl to Python: use v5.36.0;\nno warnings 'uninitialized';\nuse List::Util qw(sum min);\n\n$source = <<'END';\n............................................................\n..\n..\n..\n..\n....\n....\n....\n....\n....\n....\n....\n....\n..\n..\n..\n..\n............................................................\nEND\n\nfor $line (split \"\\n\", $source) {\n    push @lines, [map { 1 & ord $_ } split '', $line]\n}\n\n$v = @lines;\n$h = @{$lines[0]};\npush @black, @$_ for @lines;\n@p8 = ((-$h-1), (-$h+0), (-$h+1),                    \n          0-1,              0+1,\n         $h-1,    $h+0,    $h+1)[1,2,4,7,6,5,3,0];   \n\n\n@cand = grep { $black[$_] } map { my $x = $_; map $_*$h + $x, 1..$v-2 } 1..$h-2;\n\ndo {\n    sub seewhite ($w1,$w2) {\n        my @results;\n        sub cycles (@neighbors) { my $c; $c += $neighbors[$_] < $neighbors[($_+1)%8] for 0..$\n        sub blacks (@neighbors) { sum @neighbors }\n        @prior = @cand; @cand = ();\n        for $p (@prior) {\n            @n = @black[map { $_+$p } @p8];\n            if (cycles(@n) == 1 and 2 <= sum(blacks(@n)) and sum(blacks(@n)) <= 6 and min(@n[@$w1]) == 0 and min(@n[@$w2]) == 0) {\n                push @results, $p;\n            } else {\n                push @cand, $p\n            }\n        }\n        @results\n    }\n\n    @goners1 = seewhite [0,2,4], [2,4,6]; @black[@goners1] = 0 x @goners1;\n    @goners2 = seewhite [0,2,6], [0,4,6]; @black[@goners2] = 0 x @goners2;\n} while @goners1 or @goners2;\n\nwhile (@black) { push @thinned, join '', qw<. \n\nsay join \"\\n\", @thinned;\n", "target": "\n\n\nbeforeTxt = \n\n\nsmallrc01 = \n\nrc01 = \n\ndef intarray(binstring):\n    \n    return [[1 if ch == '1' else 0 for ch in line] \n            for line in binstring.strip().split()]\n\ndef chararray(intmatrix):\n    \n    return '\\n'.join(''.join(str(p) for p in row) for row in intmatrix)\n\ndef toTxt(intmatrix):\n    Return 8-neighbours of point p1 of picture, in order'''\n    i = image\n    x1, y1, x_1, y_1 = x+1, y-1, x-1, y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n\ndef transitions(neighbours):\n    n = neighbours + neighbours[0:1]    \n    return sum((n1, n2) == (0, 1) for n1, n2 in zip(n, n[1:]))\n\ndef zhangSuen(image):\n    changing1 = changing2 = [(-1, -1)]\n    while changing1 or changing2:\n        \n        changing1 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P4 * P6 * P8 == 0 and   \n                    P2 * P4 * P6 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing1.append((x,y))\n        for x, y in changing1: image[y][x] = 0\n        \n        changing2 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P2 * P6 * P8 == 0 and   \n                    P2 * P4 * P8 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing2.append((x,y))\n        for x, y in changing2: image[y][x] = 0\n        \n        \n    return image\n            \n\nif __name__ == '__main__':\n    for picture in (beforeTxt, smallrc01, rc01):\n        image = intarray(picture)\n        print('\\nFrom:\\n%s' % toTxt(image))\n        after = zhangSuen(image)\n        print('\\nTo thinned:\\n%s' % toTxt(after))\n"}
{"id": 383263, "name": "Generate Chess960 starting position", "source": "Translate Perl to Python: sub rnd($) { int(rand(shift)) }\n\nsub empties { grep !$_[0][$_], 0 .. 7 }\n\nsub chess960 {\n\tmy @s = (undef) x 8;\n\t@s[2*rnd(4), 1 + 2*rnd(4)] = qw/B B/;\n\n\tfor (qw/Q N N/) {\n\t\tmy @idx = empties \\@s;\n\t\t$s[$idx[rnd(@idx)]] = $_;\n\t}\n\n\t@s[empties \\@s] = qw/R K R/;\n\t@s\n}\nprint \"@{[chess960]}\\n\" for 0 .. 10;\n", "target": ">>> from itertools import permutations\n>>> pieces = 'KQRrBbNN'\n>>> starts = {''.join(p).upper() for p in permutations(pieces)\n                     if p.index('B') % 2 != p.index('b') % 2 \t\t\n                     and ( p.index('r') < p.index('K') < p.index('R')\t\n                           or p.index('R') < p.index('K') < p.index('r') ) }\n>>> len(starts)\n960\n>>> starts.pop()\n'QNBRNKRB'\n>>>\n"}
{"id": 383264, "name": "UPC", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub decode_UPC {\n    my($line) = @_;\n    my(%pattern_to_digit_1,%pattern_to_digit_2,@patterns1,@patterns2,@digits,$sum);\n\n    for my $p ('   \n        push @patterns1, $p;\n        push @patterns2, $p =~ tr/\n    }\n\n    $pattern_to_digit_1{$patterns1[$_]} = $_ for 0..$\n    $pattern_to_digit_2{$patterns2[$_]} = $_ for 0..$\n\n     my $re = '\\s*\n              \"(?<match1>(?:@{[join '|', @patterns1]}){6})\" .\n              '\\s*\n              \"(?<match2>(?:@{[join '|', @patterns2]}){6})\" .\n              '\\s*\n     $line =~ /^$re$/g || return;\n\n    my($match1,$match2) = ($+{match1}, $+{match2});\n    push @digits, $pattern_to_digit_1{$_} for $match1 =~ /(.{7})/g;\n    push @digits, $pattern_to_digit_2{$_} for $match2 =~ /(.{7})/g;\n    $sum += (3,1)[$_%2] * $digits[$_] for 0..11;\n    $sum % 10 ? '' : join '', @digits;\n}\n\nmy @lines = (\n    '         \n     '        \n    '         \n      '       \n    '         \n   '          \n    '         \n     '        \n    '         \n     '        \n);\n\nfor my $line (@lines) {\n    say decode_UPC($line)\n     // decode_UPC(join '', reverse split '', $line)\n     // 'Invalid';\n}\n", "target": "\nimport itertools\nimport re\n\nRE_BARCODE = re.compile(\n    r\"^(?P<s_quiet> +)\"  \n    r\"(?P<s_guard>\n    r\"(?P<left>[ \n    r\"(?P<m_guard> \n    r\"(?P<right>[ \n    r\"(?P<e_guard>\n    r\"(?P<e_quiet> +)$\"  \n)\n\nLEFT_DIGITS = {\n    (0, 0, 0, 1, 1, 0, 1): 0,\n    (0, 0, 1, 1, 0, 0, 1): 1,\n    (0, 0, 1, 0, 0, 1, 1): 2,\n    (0, 1, 1, 1, 1, 0, 1): 3,\n    (0, 1, 0, 0, 0, 1, 1): 4,\n    (0, 1, 1, 0, 0, 0, 1): 5,\n    (0, 1, 0, 1, 1, 1, 1): 6,\n    (0, 1, 1, 1, 0, 1, 1): 7,\n    (0, 1, 1, 0, 1, 1, 1): 8,\n    (0, 0, 0, 1, 0, 1, 1): 9,\n}\n\nRIGHT_DIGITS = {\n    (1, 1, 1, 0, 0, 1, 0): 0,\n    (1, 1, 0, 0, 1, 1, 0): 1,\n    (1, 1, 0, 1, 1, 0, 0): 2,\n    (1, 0, 0, 0, 0, 1, 0): 3,\n    (1, 0, 1, 1, 1, 0, 0): 4,\n    (1, 0, 0, 1, 1, 1, 0): 5,\n    (1, 0, 1, 0, 0, 0, 0): 6,\n    (1, 0, 0, 0, 1, 0, 0): 7,\n    (1, 0, 0, 1, 0, 0, 0): 8,\n    (1, 1, 1, 0, 1, 0, 0): 9,\n}\n\n\nMODULES = {\n    \" \": 0,\n    \"\n}\n\nDIGITS_PER_SIDE = 6\nMODULES_PER_DIGIT = 7\n\n\nclass ParityError(Exception):\n    \n\n\nclass ChecksumError(Exception):\n    \n\n\ndef group(iterable, n):\n    \n    args = [iter(iterable)] * n\n    return tuple(itertools.zip_longest(*args))\n\n\ndef parse(barcode):\n    \n    match = RE_BARCODE.match(barcode)\n\n    \n    \n    left = group((MODULES[c] for c in match.group(\"left\")), MODULES_PER_DIGIT)\n    right = group((MODULES[c] for c in match.group(\"right\")), MODULES_PER_DIGIT)\n\n    \n    left, right = check_parity(left, right)\n\n    \n    return tuple(\n        itertools.chain(\n            (LEFT_DIGITS[d] for d in left),\n            (RIGHT_DIGITS[d] for d in right),\n        )\n    )\n\n\ndef check_parity(left, right):\n    \n    \n    \n    \n    left_parity = sum(sum(d) % 2 for d in left)\n    right_parity = sum(sum(d) % 2 for d in right)\n\n    \n    \n    if left_parity == 0 and right_parity == DIGITS_PER_SIDE:\n        _left = tuple(tuple(reversed(d)) for d in reversed(right))\n        right = tuple(tuple(reversed(d)) for d in reversed(left))\n        left = _left\n    elif left_parity != DIGITS_PER_SIDE or right_parity != 0:\n        \n        error = tuple(\n            itertools.chain(\n                (LEFT_DIGITS.get(d, \"_\") for d in left),\n                (RIGHT_DIGITS.get(d, \"_\") for d in right),\n            )\n        )\n        raise ParityError(\" \".join(str(d) for d in error))\n\n    return left, right\n\n\ndef checksum(digits):\n    \n    odds = (digits[i] for i in range(0, 11, 2))\n    evens = (digits[i] for i in range(1, 10, 2))\n\n    check_digit = (sum(odds) * 3 + sum(evens)) % 10\n\n    if check_digit != 0:\n        check_digit = 10 - check_digit\n\n    if digits[-1] != check_digit:\n        raise ChecksumError(str(check_digit))\n\n    return check_digit\n\n\ndef main():\n    barcodes = [\n        \"         \n        \"        \n        \"         \n        \"       \n        \"         \n        \"          \n        \"         \n        \"        \n        \"         \n        \"        \n        \"        \n    ]\n\n    for barcode in barcodes:\n        try:\n            digits = parse(barcode)\n        except ParityError as err:\n            print(f\"{err} parity error!\")\n            continue\n\n        try:\n            check_digit = checksum(digits)\n        except ChecksumError as err:\n            print(f\"{' '.join(str(d) for d in digits)} checksum error! ({err})\")\n            continue\n\n        print(f\"{' '.join(str(d) for d in digits)}\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 383265, "name": "Write to Windows event log", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Win32::EventLog;\nmy $handle = Win32::EventLog->new(\"Application\");\n\nmy $event = {\n\tComputer \t=>\t$ENV{COMPUTERNAME},\n\tSource\t\t=> \t'Rosettacode',\n\tEventType \t=> \tEVENTLOG_INFORMATION_TYPE,\n\tCategory  \t=> \t'test',\n\tEventID \t=> \t0,\n\tData \t\t=> \t'a test for rosettacode',\n\tStrings \t=> \t'a string test for rosettacode',\n};\n$handle->Report($event);\n", "target": "import win32api\nimport win32con\nimport win32evtlog\nimport win32security\nimport win32evtlogutil\n\nph = win32api.GetCurrentProcess()\nth = win32security.OpenProcessToken(ph, win32con.TOKEN_READ)\nmy_sid = win32security.GetTokenInformation(th, win32security.TokenUser)[0]\n\napplicationName = \"My Application\"\neventID = 1\ncategory = 5\t\nmyType = win32evtlog.EVENTLOG_WARNING_TYPE\ndescr = [\"A warning\", \"An even more dire warning\"]\ndata = \"Application\\0Data\".encode(\"ascii\")\n\nwin32evtlogutil.ReportEvent(applicationName, eventID, eventCategory=category, \n\teventType=myType, strings=descr, data=data, sid=my_sid)\n"}
{"id": 383266, "name": "Spelling of ordinal numbers", "source": "Translate Perl to Python: use Lingua::EN::Numbers 'num2en_ordinal';\n\nprintf \"%16s\u00a0: %s\\n\", $_, num2en_ordinal(0+$_) for\n    <1 2 3 4 5 11 65 100 101 272 23456 8007006005004003 123 00123.0 '00123.0' 1.23e2 '1.23e2'>;\n", "target": "irregularOrdinals = {\n\t\"one\":    \"first\",\n\t\"two\":    \"second\",\n\t\"three\":  \"third\",\n\t\"five\":   \"fifth\",\n\t\"eight\":  \"eighth\",\n\t\"nine\":   \"ninth\",\n\t\"twelve\": \"twelfth\",\n}\n\ndef num2ordinal(n):\n    conversion = int(float(n))\n    num = spell_integer(conversion)\n    hyphen = num.rsplit(\"-\", 1)\n    num = num.rsplit(\" \", 1)\n    delim = \" \"\n    if len(num[-1]) > len(hyphen[-1]):\n        num = hyphen\n        delim = \"-\"\n    \n    if num[-1] in irregularOrdinals:\n        num[-1] = delim + irregularOrdinals[num[-1]]\n    elif num[-1].endswith(\"y\"):\n        num[-1] = delim + num[-1][:-1] + \"ieth\"\n    else:\n        num[-1] = delim + num[-1] + \"th\"\n    return \"\".join(num)\n    \nif __name__ == \"__main__\":\n    tests = \"1  2  3  4  5  11  65  100  101  272  23456  8007006005004003 123   00123.0   1.23e2\".split()\n    for num in tests:\n        print(\"{} => {}\".format(num, num2ordinal(num)))\n\n\n\n\nTENS = [None, None, \"twenty\", \"thirty\", \"forty\",\n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\nSMALL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n         \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n         \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n         \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\nHUGE = [None, None] + [h + \"illion\" \n                       for h in (\"m\", \"b\", \"tr\", \"quadr\", \"quint\", \"sext\", \n                                  \"sept\", \"oct\", \"non\", \"dec\")]\n \ndef nonzero(c, n, connect=''):\n    return \"\" if n == 0 else connect + c + spell_integer(n)\n \ndef last_and(num):\n    if ',' in num:\n        pre, last = num.rsplit(',', 1)\n        if ' and ' not in last:\n            last = ' and' + last\n        num = ''.join([pre, ',', last])\n    return num\n \ndef big(e, n):\n    if e == 0:\n        return spell_integer(n)\n    elif e == 1:\n        return spell_integer(n) + \" thousand\"\n    else:\n        return spell_integer(n) + \" \" + HUGE[e]\n \ndef base1000_rev(n):\n    \n    \n    while n != 0:\n        n, r = divmod(n, 1000)\n        yield r\n \ndef spell_integer(n):\n    if n < 0:\n        return \"minus \" + spell_integer(-n)\n    elif n < 20:\n        return SMALL[n]\n    elif n < 100:\n        a, b = divmod(n, 10)\n        return TENS[a] + nonzero(\"-\", b)\n    elif n < 1000:\n        a, b = divmod(n, 100)\n        return SMALL[a] + \" hundred\" + nonzero(\" \", b, ' and')\n    else:\n        num = \", \".join([big(e, x) for e, x in\n                         enumerate(base1000_rev(n)) if x][::-1])\n        return last_and(num)\n"}
{"id": 383267, "name": "Parse an IP Address", "source": "Translate Perl to Python: sub parse_v4 {\n    my ($ip, $port) = @_;\n    my @quad = split(/\\./, $ip);\n\n    return unless @quad == 4;\n    for (@quad) { return if ($_ > 255) }\n\n    if (!length $port) { $port = -1 }\n    elsif ($port =~ /^(\\d+)$/) { $port = $1 }\n    else { return }\n\n    my $h = join '' => map(sprintf(\"%02x\", $_), @quad);\n    return $h, $port\n}\n\nsub parse_v6 {\n    my $ip = shift;\n    my $omits;\n\n    return unless $ip =~ /^[\\da-f:.]+$/i; \n\n    $ip =~ s/^:/0:/;\n    $omits = 1 if $ip =~ s/::/:z:/g;\n    return if $ip =~ /z.*z/;    \n\n    my $v4 = '';\n    my $len = 8;\n\n    if ($ip =~ s/:((?:\\d+\\.){3}\\d+)$//) {\n        \n        ($v4) = parse_v4($1)    or return;\n        $len -= 2;\n\n    }\n    \n    return unless $ip =~ /^[:a-fz\\d]+$/i;\n\n    my @h = split(/:/, $ip);\n    return if @h + $omits > $len;   \n\n    @h = map( $_ eq 'z' ? (0) x ($len - @h + 1) : ($_), @h);\n    return join('' => map(sprintf(\"%04x\", hex($_)), @h)).$v4;\n}\n\nsub parse_ip {\n    my $str = shift;\n    $str =~ s/^\\s*//;\n    $str =~ s/\\s*$//;\n\n    if ($str =~ s/^((?:\\d+\\.)+\\d+)(?::(\\d+))?$//) {\n        return 'v4', parse_v4($1, $2);\n    }\n\n    my ($ip, $port);\n    if ($str =~ /^\\[(.*?)\\]:(\\d+)$/) {\n        $port = $2;\n        $ip = parse_v6($1);\n    } else {\n        $port = -1;\n        $ip = parse_v6($str);\n    }\n\n    return unless $ip;\n    return 'v6', $ip, $port;\n}\n\nfor (qw/127.0.0.1 127.0.0.1:80\n   \u00a0::1\n    [::1]:80\n    2605:2700:0:3::4713:93e3\n    [2605:2700:0:3::4713:93e3]:80\n   \u00a0::ffff:192.168.0.1\n    [::ffff:192.168.0.1]:22\n   \u00a0::ffff:127.0.0.0.1\n    a::b::1/)\n{\n    print \"$_\\n\\t\";\n    my ($ver, $ip, $port) = parse_ip($_)\n        or print \"parse error\\n\" and next;\n\n    print \"$ver $ip\\tport $port\\n\\n\";\n}\n", "target": "from ipaddress import ip_address\nfrom urllib.parse import urlparse\n\ntests = [\n    \"127.0.0.1\",\n    \"127.0.0.1:80\",\n    \"::1\",\n    \"[::1]:80\",\n    \"::192.168.0.1\",\n    \"2605:2700:0:3::4713:93e3\",\n    \"[2605:2700:0:3::4713:93e3]:80\" ]\n\ndef parse_ip_port(netloc):\n    try:\n        ip = ip_address(netloc)\n        port = None\n    except ValueError:\n        parsed = urlparse('//{}'.format(netloc))\n        ip = ip_address(parsed.hostname)\n        port = parsed.port\n    return ip, port\n\nfor address in tests:\n    ip, port = parse_ip_port(address)\n    hex_ip = {4:'{:08X}', 6:'{:032X}'}[ip.version].format(int(ip))\n    print(\"{:39s}  {:>32s}  IPv{}  port={}\".format(\n        str(ip), hex_ip, ip.version, port ))\n"}
{"id": 383268, "name": "Long stairs", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy $sumseconds = my $sumsizes = my $runs = 0;\nfor ( 1 .. 1e4 )\n  {\n  $runs++;\n  my $behind = 0;\n  my $ahead =  100;\n  my $seconds = 0;\n  while( $ahead  > 0 )\n    {\n    rand() <= ($ahead / ($behind + $ahead)) ? $ahead++ : $behind++ for 1 .. 5;\n    $behind++; \n    $ahead--;\n    $seconds++;\n    $_ == 1 and 600 <= $seconds <= 609 and\n      print \"step $seconds: $behind behind, $ahead ahead\\n\";\n    }\n  $sumsizes += $behind;\n  $sumseconds += $seconds;\n  }\nprintf \"\\naverage stair length %d average seconds %d\\n\",\n  $sumsizes / $runs, $sumseconds / $runs;\n", "target": "\n\nfrom numpy import mean\nfrom random import sample\n\ndef gen_long_stairs(start_step, start_length, climber_steps, add_steps):\n    secs, behind, total = 0, start_step, start_length\n    while True:\n        behind += climber_steps\n        behind += sum([behind > n for n in sample(range(total), add_steps)])\n        total += add_steps\n        secs += 1\n        yield (secs, behind, total)\n        \n\nls = gen_long_stairs(1, 100, 1, 5)\n\nprint(\"Seconds  Behind  Ahead\\n----------------------\")\nwhile True:\n    secs, pos, len = next(ls)\n    if 600 <= secs < 610:\n        print(secs, \"     \", pos, \"   \", len - pos)\n    elif secs == 610:\n        break\n\nprint(\"\\nTen thousand trials to top:\")\ntimes, heights = [], []\nfor trial in range(10_000):\n    trialstairs = gen_long_stairs(1, 100, 1, 5)\n    while True:\n        sec, step, height = next(trialstairs)\n        if step >= height:\n            times.append(sec)\n            heights.append(height)\n            break\n\nprint(\"Mean time:\", mean(times), \"secs. Mean height:\", mean(heights))\n"}
{"id": 383269, "name": "Largest prime factor", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub f {\n    my($n) = @_;\n    $n % $_ or return $_, f($n/$_) for 2..$n\n}\n\nsay +(f 600851475143)[-2]\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    n = 600851475143\n    j = 3\n    while not isPrime(n):\n        if n % j == 0:\n            n /= j\n        j += 2\n    print(n);\n"}
{"id": 383270, "name": "Getting the number of decimal places", "source": "Translate Perl to Python: use bignum;\n\nprintf \"Fractional precision: %2s  Number: %s\\n\", length((split /\\./, $_)[1]) // 0, $_\n    for 9, 12.345, <12.3450>, 0.1234567890987654321, 1/3, 1.5**63;\n", "target": "In [6]: def dec(n):\n   ...:     return len(n.rsplit('.')[-1]) if '.' in n else 0\n\nIn [7]: dec('12.345')\nOut[7]: 3\n\nIn [8]: dec('12.3450')\nOut[8]: 4\n\nIn [9]:\n"}
{"id": 383271, "name": "Vibrating rectangles", "source": "Translate Perl to Python: use utf8;\nbinmode STDOUT, \":utf8\";\nuse Time::HiRes qw(sleep);\n\n%r = ('tl' => qw<\u250c>, 'tr' => qw<\u2510>, 'h' => qw<\u2500>, 'v' => qw<\u2502>, 'bl' => qw<\u2514>, 'br' => qw<\u2518>);\n@colors = (\"\\e[1;31m\", \"\\e[1;32m\", \"\\e[1;33m\", \"\\e[1;34m\", \"\\e[1;35m\", \"\\e[1;36m\");\n\nprint \"\\e[?25l\"; \n\n$SIG{INT} = sub { print \"\\e[0H\\e[0J\\e[?25h\"; exit; }; \n\nwhile (1) {\n    @c = palette() unless $n % 16;\n    rect($_, 31-$_) for 0..15;\n    display(@vibe);\n    sleep .20;\n    push @c, $c[0]; shift @c;\n    $n++;\n}\n\nsub palette {\n    my @c = sort { -1 + 2*int(rand 2) } @colors;\n    ($c[0], $c[1], $c[2]) x 12;\n}\n\nsub rect {\n    my ($b, $e) = @_;\n    my $c = $c[$b % @c];\n    my @bb = ($c.$r{tl}, (($r{h})x($e-$b-1)), $r{tr}.\"\\e[0m\");\n    my @ee = ($c.$r{bl}, (($r{h})x($e-$b-1)), $r{br}.\"\\e[0m\");\n    $vibe[$b][$_] = shift @bb for $b .. $e;\n    $vibe[$e][$_] = shift @ee for $b .. $e;\n    $vibe[$_][$b] = $vibe[$_][$e] = $c.$r{v}.\"\\e[0m\" for $b+1 .. $e-1;\n}\n\nsub display {\n    my(@rect) = @_;\n    print \"\\e[0H\\e[0J\\n\\n\";\n    for my $row (@rect) {\n        print \"\\t\\t\\t\";\n        print $_ // ' ' for @$row;\n        print \"\\n\";\n    }\n}\n", "target": "import turtle\nfrom itertools import cycle\nfrom time import sleep\n\ndef rect(t, x, y):\n    x2, y2 = x/2, y/2\n    t.setpos(-x2, -y2)\n    t.pendown()\n    for pos in [(-x2, y2), (x2, y2), (x2, -y2), (-x2, -y2)]: \n        t.goto(pos)\n    t.penup()\n\ndef rects(t, colour, wait_between_rect=0.1):\n    for x in range(550, 0, -25):\n        t.color(colour)\n        rect(t, x, x*.75)\n        sleep(wait_between_rect)\n\ntl=turtle.Turtle()\nscreen=turtle.Screen()\nscreen.setup(620,620)\nscreen.bgcolor('black')\nscreen.title('Rosetta Code Vibrating Rectangles')\ntl.pensize(3)\ntl.speed(0)\ntl.penup()\ntl.ht() \ncolours = 'red green blue orange white yellow'.split()\nfor colour in cycle(colours):\n    rects(tl, colour)\n    sleep(0.5)\n"}
{"id": 383272, "name": "Minimum number of cells after, before, above and below NxN squares", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util qw( max min );\n\nfor my $N (0, 1, 2, 6, 9, 23) {\n    my $fmt = ('%' . (1+length int $N/2) . 'd') x $N . \"\\n\";\n    print \"$N x $N distance to nearest edge:\\n\";\n    for my $row ( 0 .. $N-1 ) {\n        my @cols = map { min $_, $row, $N-1 - max $_, $row } 0 .. $N-1;\n        printf $fmt, @cols;\n    }\n    print \"\\n\";\n}\n", "target": "def min_cells_matrix(siz):\n    return [[min(row, col, siz - row - 1, siz - col - 1) for col in range(siz)] for row in range(siz)]\n\ndef display_matrix(mat):\n    siz = len(mat)\n    spaces = 2 if siz < 20 else 3 if siz < 200 else 4\n    print(f\"\\nMinimum number of cells after, before, above and below {siz} x {siz} square:\")\n    for row in range(siz):\n        print(\"\".join([f\"{n:{spaces}}\" for n in mat[row]]))\n\ndef test_min_mat():\n    for siz in [23, 10, 9, 2, 1]:\n        display_matrix(min_cells_matrix(siz))\n\nif __name__ == \"__main__\":\n    test_min_mat()\n"}
{"id": 383273, "name": "Maximum difference between adjacent elements of list", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse List::Util qw( reduce max );\n\nmy @list = (1,8,2,-3,0,1,1,-2.3,0,5.5,8,6,2,9,11,10,3);\n\nmy %diffs;\nreduce { $diffs{ abs $a - $b } .= \" $a,$b\"; $b } @list;\nmy $max = max keys %diffs;\nprint \"$_ ==> $max\\n\" for split ' ', $diffs{ $max };\n", "target": "\n\n\n\ndef maxDeltas(ns):\n    \n    pairs = [\n        (abs(a - b), (a, b)) for a, b\n        in zip(ns, ns[1:])\n    ]\n    delta = max(pairs, key=lambda ab: ab[0])[0]\n\n    return [\n        ab for ab in pairs\n        if delta == ab[0]\n    ]\n\n\n\n\ndef main():\n    \n\n    maxPairs = maxDeltas([\n        1, 8, 2, -3, 0, 1, 1, -2.3, 0,\n        5.5, 8, 6, 2, 9, 11, 10, 3\n    ])\n\n    for ab in maxPairs:\n        print(ab)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383274, "name": "Solve a Hopido puzzle", "source": "Translate Perl to Python: \n\nuse strict;             \nuse warnings;\n\n$_ = do { local $/; <DATA> };\ns/./$&$&/g;             \nmy $w = /\\n/ && $-[0];\nmy $wd = 3 * $w + 1;    \nmy $wr = 2 * $w + 8;    \nmy $wl = 2 * $w - 8;    \nplace($_, '00');\ndie \"No solution\\n\";\n\nsub place\n  {\n  (local $_, my $last) = @_;\n  (my $new = $last)++;\n  /$last.{10}(?=00)/g   and place( s/\\G00/$new/r, $new ); \n  /(?=00.{10}$last)/g   and place( s/\\G00/$new/r, $new ); \n  /$last.{$wd}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wd}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wr}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wr}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wl}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wl}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /00/ and return;\n  print \"Solution\\n\\n\", s/  / /gr =~ s/0\\B/ /gr;\n  exit;\n  }\n\n", "target": "from sys import stdout\n\nneighbours = [[2, 2], [-2, 2], [2, -2], [-2, -2], [3, 0], [0, 3], [-3, 0], [0, -3]]\ncnt = 0\npWid = 0\npHei = 0\n\n\ndef is_valid(a, b):\n    return -1 < a < pWid and -1 < b < pHei\n\n\ndef iterate(pa, x, y, v):\n    if v > cnt:\n        return 1\n\n    for i in range(len(neighbours)):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if is_valid(a, b) and pa[a][b] == 0:\n            pa[a][b] = v\n            r = iterate(pa, a, b, v + 1)\n            if r == 1:\n                return r\n            pa[a][b] = 0\n    return 0\n\n\ndef solve(pz, w, h):\n    global cnt, pWid, pHei\n\n    pa = [[-1 for j in range(h)] for i in range(w)]\n    f = 0\n    pWid = w\n    pHei = h\n    for j in range(h):\n        for i in range(w):\n            if pz[f] == \"1\":\n                pa[i][j] = 0\n                cnt += 1\n            f += 1\n\n    for y in range(h):\n        for x in range(w):\n            if pa[x][y] == 0:\n                pa[x][y] = 1\n                if 1 == iterate(pa, x, y, 2):\n                    return 1, pa\n                pa[x][y] = 0\n\n    return 0, pa\n\nr = solve(\"011011011111111111111011111000111000001000\", 7, 6)\nif r[0] == 1:\n    for j in range(6):\n        for i in range(7):\n            if r[1][i][j] == -1:\n                stdout.write(\"   \")\n            else:\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n        print()\nelse:\n    stdout.write(\"No solution!\")\n"}
{"id": 383275, "name": "Solve a Hopido puzzle", "source": "Translate Perl to Python: \n\nuse strict;             \nuse warnings;\n\n$_ = do { local $/; <DATA> };\ns/./$&$&/g;             \nmy $w = /\\n/ && $-[0];\nmy $wd = 3 * $w + 1;    \nmy $wr = 2 * $w + 8;    \nmy $wl = 2 * $w - 8;    \nplace($_, '00');\ndie \"No solution\\n\";\n\nsub place\n  {\n  (local $_, my $last) = @_;\n  (my $new = $last)++;\n  /$last.{10}(?=00)/g   and place( s/\\G00/$new/r, $new ); \n  /(?=00.{10}$last)/g   and place( s/\\G00/$new/r, $new ); \n  /$last.{$wd}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wd}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wr}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wr}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wl}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wl}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /00/ and return;\n  print \"Solution\\n\\n\", s/  / /gr =~ s/0\\B/ /gr;\n  exit;\n  }\n\n", "target": "from sys import stdout\n\nneighbours = [[2, 2], [-2, 2], [2, -2], [-2, -2], [3, 0], [0, 3], [-3, 0], [0, -3]]\ncnt = 0\npWid = 0\npHei = 0\n\n\ndef is_valid(a, b):\n    return -1 < a < pWid and -1 < b < pHei\n\n\ndef iterate(pa, x, y, v):\n    if v > cnt:\n        return 1\n\n    for i in range(len(neighbours)):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if is_valid(a, b) and pa[a][b] == 0:\n            pa[a][b] = v\n            r = iterate(pa, a, b, v + 1)\n            if r == 1:\n                return r\n            pa[a][b] = 0\n    return 0\n\n\ndef solve(pz, w, h):\n    global cnt, pWid, pHei\n\n    pa = [[-1 for j in range(h)] for i in range(w)]\n    f = 0\n    pWid = w\n    pHei = h\n    for j in range(h):\n        for i in range(w):\n            if pz[f] == \"1\":\n                pa[i][j] = 0\n                cnt += 1\n            f += 1\n\n    for y in range(h):\n        for x in range(w):\n            if pa[x][y] == 0:\n                pa[x][y] = 1\n                if 1 == iterate(pa, x, y, 2):\n                    return 1, pa\n                pa[x][y] = 0\n\n    return 0, pa\n\nr = solve(\"011011011111111111111011111000111000001000\", 7, 6)\nif r[0] == 1:\n    for j in range(6):\n        for i in range(7):\n            if r[1][i][j] == -1:\n                stdout.write(\"   \")\n            else:\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n        print()\nelse:\n    stdout.write(\"No solution!\")\n"}
{"id": 383276, "name": "Solve a Numbrix puzzle", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEND\n\nmy $gap = /.\\n/ * $-[0];\nprint;\ns/ (?=\\d\\b)/0/g;\nmy $max = sprintf \"%02d\", tr/0-9// / 2;\n\nsolve( '01', $_ );\n\nsub solve\n  {\n  my ($have, $in) = @_;\n  $have eq $max and exit !print \"solution\\n\", $in =~ s/\\b0/ /gr;\n  if( $in =~ ++(my $want = $have) )\n    {\n    $in =~ /($have|$want)( |.{$gap})($have|$want)/s and solve($want, $in);\n    }\n  else\n    {\n    ($_ = $in) =~ s/$have \\K00/$want/          and solve( $want, $_ ); \n    ($_ = $in) =~ s/$have.{$gap}\\K00/$want/s   and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?= $have)/$want/        and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?=.{$gap}$have)/$want/s and solve( $want, $_ ); \n    }\n  }\n", "target": "from sys import stdout\nneighbours = [[-1, 0], [0, -1], [1, 0], [0, 1]]\nexists = []\nlastNumber = 0\nwid = 0\nhei = 0\n\n\ndef find_next(pa, x, y, z):\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == z:\n                return a, b\n\n    return -1, -1\n\n\ndef find_solution(pa, x, y, z):\n    if z > lastNumber:\n        return 1\n    if exists[z] == 1:\n        s = find_next(pa, x, y, z)\n        if s[0] < 0:\n            return 0\n        return find_solution(pa, s[0], s[1], z + 1)\n\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == 0:\n                pa[a][b] = z\n                r = find_solution(pa, a, b, z + 1)\n                if r == 1:\n                    return 1\n                pa[a][b] = 0\n\n    return 0\n\n\ndef solve(pz, w, h):\n    global lastNumber, wid, hei, exists\n\n    lastNumber = w * h\n    wid = w\n    hei = h\n    exists = [0 for j in range(lastNumber + 1)]\n\n    pa = [[0 for j in range(h)] for i in range(w)]\n    st = pz.split()\n    idx = 0\n    for j in range(h):\n        for i in range(w):\n            if st[idx] == \".\":\n                idx += 1\n            else:\n                pa[i][j] = int(st[idx])\n                exists[pa[i][j]] = 1\n                idx += 1\n\n    x = 0\n    y = 0\n    t = w * h + 1\n    for j in range(h):\n        for i in range(w):\n            if pa[i][j] != 0 and pa[i][j] < t:\n                t = pa[i][j]\n                x = i\n                y = j\n\n    return find_solution(pa, x, y, t + 1), pa\n\n\ndef show_result(r):\n    if r[0] == 1:\n        for j in range(hei):\n            for i in range(wid):\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n            print()\n    else:\n        stdout.write(\"No Solution!\\n\")\n\n    print()\n\n\nr = solve(\". . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17\"\n          \" . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1  2 . . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\". . . . . . . . . . 11 12 15 18 21 62 61 . .  6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37\"\n          \" .  1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\"17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . .  63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55\"\n          \" . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45\", 9, 9)\nshow_result(r)\n"}
{"id": 383277, "name": "Solve a Numbrix puzzle", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEND\n\nmy $gap = /.\\n/ * $-[0];\nprint;\ns/ (?=\\d\\b)/0/g;\nmy $max = sprintf \"%02d\", tr/0-9// / 2;\n\nsolve( '01', $_ );\n\nsub solve\n  {\n  my ($have, $in) = @_;\n  $have eq $max and exit !print \"solution\\n\", $in =~ s/\\b0/ /gr;\n  if( $in =~ ++(my $want = $have) )\n    {\n    $in =~ /($have|$want)( |.{$gap})($have|$want)/s and solve($want, $in);\n    }\n  else\n    {\n    ($_ = $in) =~ s/$have \\K00/$want/          and solve( $want, $_ ); \n    ($_ = $in) =~ s/$have.{$gap}\\K00/$want/s   and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?= $have)/$want/        and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?=.{$gap}$have)/$want/s and solve( $want, $_ ); \n    }\n  }\n", "target": "from sys import stdout\nneighbours = [[-1, 0], [0, -1], [1, 0], [0, 1]]\nexists = []\nlastNumber = 0\nwid = 0\nhei = 0\n\n\ndef find_next(pa, x, y, z):\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == z:\n                return a, b\n\n    return -1, -1\n\n\ndef find_solution(pa, x, y, z):\n    if z > lastNumber:\n        return 1\n    if exists[z] == 1:\n        s = find_next(pa, x, y, z)\n        if s[0] < 0:\n            return 0\n        return find_solution(pa, s[0], s[1], z + 1)\n\n    for i in range(4):\n        a = x + neighbours[i][0]\n        b = y + neighbours[i][1]\n        if wid > a > -1 and hei > b > -1:\n            if pa[a][b] == 0:\n                pa[a][b] = z\n                r = find_solution(pa, a, b, z + 1)\n                if r == 1:\n                    return 1\n                pa[a][b] = 0\n\n    return 0\n\n\ndef solve(pz, w, h):\n    global lastNumber, wid, hei, exists\n\n    lastNumber = w * h\n    wid = w\n    hei = h\n    exists = [0 for j in range(lastNumber + 1)]\n\n    pa = [[0 for j in range(h)] for i in range(w)]\n    st = pz.split()\n    idx = 0\n    for j in range(h):\n        for i in range(w):\n            if st[idx] == \".\":\n                idx += 1\n            else:\n                pa[i][j] = int(st[idx])\n                exists[pa[i][j]] = 1\n                idx += 1\n\n    x = 0\n    y = 0\n    t = w * h + 1\n    for j in range(h):\n        for i in range(w):\n            if pa[i][j] != 0 and pa[i][j] < t:\n                t = pa[i][j]\n                x = i\n                y = j\n\n    return find_solution(pa, x, y, t + 1), pa\n\n\ndef show_result(r):\n    if r[0] == 1:\n        for j in range(hei):\n            for i in range(wid):\n                stdout.write(\" {:0{}d}\".format(r[1][i][j], 2))\n            print()\n    else:\n        stdout.write(\"No Solution!\\n\")\n\n    print()\n\n\nr = solve(\". . . . . . . . . . . 46 45 . 55 74 . . . 38 . . 43 . . 78 . . 35 . . . . . 71 . . . 33 . . . 59 . . . 17\"\n          \" . . . . . 67 . . 18 . . 11 . . 64 . . . 24 21 . 1  2 . . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\". . . . . . . . . . 11 12 15 18 21 62 61 . .  6 . . . . . 60 . . 33 . . . . . 57 . . 32 . . . . . 56 . . 37\"\n          \" .  1 . . . 73 . . 38 . . . . . 72 . . 43 44 47 48 51 76 77 . . . . . . . . . .\", 9, 9)\nshow_result(r)\n\nr = solve(\"17 . . . 11 . . . 59 . 15 . . 6 . . 61 . . . 3 . . .  63 . . . . . . 66 . . . . 23 24 . 68 67 78 . 54 55\"\n          \" . . . . 72 . . . . . . 35 . . . 49 . . . 29 . . 40 . . 47 . 31 . . . 39 . . . 45\", 9, 9)\nshow_result(r)\n"}
{"id": 383278, "name": "Respond to an unknown method call", "source": "Translate Perl to Python: package Example;\nsub new {\n    bless {}\n}\nsub foo {\n    print \"this is foo\\n\";\n}\nsub bar {\n    print \"this is bar\\n\";\n}\nsub AUTOLOAD {\n    my $name = $Example::AUTOLOAD;\n    my ($self, @args) = @_;\n    print \"tried to handle unknown method $name\\n\";\n    if (@args) {\n        print \"it had arguments: @args\\n\";\n    }\n}\nsub DESTROY {}          \n                        \n                        \n \npackage main;\nmy $example = Example->new;\n \n$example->foo;          \n$example->bar;          \n$example->grill;        \n$example->ding(\"dong\"); \n                        \n", "target": "class Example(object):\n    def foo(self):\n        print(\"this is foo\")\n    def bar(self):\n        print(\"this is bar\")\n    def __getattr__(self, name):\n        def method(*args):\n            print(\"tried to handle unknown method \" + name)\n            if args:\n                print(\"it had arguments: \" + str(args))\n        return method\n\nexample = Example()\n\nexample.foo()        \nexample.bar()        \nexample.grill()      \nexample.ding(\"dong\") \n                     \n"}
{"id": 383279, "name": "Arithmetic evaluation", "source": "Translate Perl to Python: sub ev\n\n\n {my $exp = shift;\n  \n  \n  $exp =~ tr {0-9.+-/*()} {}cd;\n  return ev_ast(astize($exp));}\n\n {my $balanced_paren_regex;\n  $balanced_paren_regex = qr\n     {\\( ( [^()]+ | (??{$balanced_paren_regex}) )+ \\)}x;\n  \n  \n  \n  sub astize\n  \n  \n  \n   {my $exp = shift;\n    \n    $exp =~ /[^0-9.]/ or return $exp;\n    \n    \n    $exp = substr($exp, 1, -1)\n        while $exp =~ /\\A($balanced_paren_regex)\\z/;\n    \n    my @paren_contents;\n    $exp =~ s {($balanced_paren_regex)}\n              {push(@paren_contents, $1);\n               \"[p$\n    \n    \n    $exp =~ m{(.+) ([+-]) (.+)}x or\n        $exp =~ m{(.+) ([*/]) (.+)}x or\n        \n        \n        die \"Eh?: [$exp]\\n\";\n    my ($op, $lo, $ro) = ($2, $1, $3);\n    \n    s {\\[p(\\d+)\\]} {($paren_contents[$1])}eg\n        foreach $lo, $ro;\n    \n    return [$op, astize($lo), astize($ro)];}}\n\n {my %ops =\n     ('+' => sub {$_[0] + $_[1]},\n      '-' => sub {$_[0] - $_[1]},\n      '*' => sub {$_[0] * $_[1]},\n      '/' => sub {$_[0] / $_[1]});\n  \n  sub ev_ast\n  \n  \n   {my $ast = shift;\n    \n    ref $ast or return $ast;\n    \n    my ($op, @operands) = @$ast;\n    $_ = ev_ast($_) foreach @operands;\n    return $ops{$op}->(@operands);}}\n", "target": "import operator\n\nclass AstNode(object):\n   def __init__( self, opr, left, right ):\n      self.opr = opr\n      self.l = left\n      self.r = right\n\n   def eval(self):\n      return self.opr(self.l.eval(), self.r.eval())\n\nclass LeafNode(object):\n   def __init__( self, valStrg ):\n      self.v = int(valStrg)\n\n   def eval(self):\n      return self.v\n\nclass Yaccer(object):\n   def __init__(self):\n      self.operstak = []\n      self.nodestak =[]\n      self.__dict__.update(self.state1)\n\n   def v1( self, valStrg ):\n      \n      self.nodestak.append( LeafNode(valStrg))\n      self.__dict__.update(self.state2)\n      \n\n   def o2( self, operchar ):\n      \n      def openParen(a,b):\n         return 0\t\t\n\n      opDict= { '+': ( operator.add, 2, 2 ),\n         '-': (operator.sub, 2, 2 ),\n         '*': (operator.mul, 3, 3 ),\n         '/': (operator.div, 3, 3 ),\n         '^': ( pow,         4, 5 ),  \n         '(': ( openParen,   0, 8 )\n         }\n      operPrecidence = opDict[operchar][2]\n      self.redeuce(operPrecidence)\n\n      self.operstak.append(opDict[operchar])\n      self.__dict__.update(self.state1)\n      \n\n   def syntaxErr(self, char ):\n      \n      print 'parse error - near operator \"%s\"' %char\n\n   def pc2( self,operchar ):\n      \n      \n      self.redeuce( 1 )\n      if len(self.operstak)>0:\n         self.operstak.pop()\t\t\n      else:\n         print 'Error - no open parenthesis matches close parens.'\n      self.__dict__.update(self.state2)\n\n   def end(self):\n      self.redeuce(0)\n      return self.nodestak.pop()\n\n   def redeuce(self, precidence):\n      while len(self.operstak)>0:\n         tailOper = self.operstak[-1]\n         if tailOper[1] < precidence: break\n\n         tailOper = self.operstak.pop()\n         vrgt = self.nodestak.pop()\n         vlft= self.nodestak.pop()\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\n         \n\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\n\n\ndef Lex( exprssn, p ):\n   bgn = None\n   cp = -1\n   for c in exprssn:\n      cp += 1\n      if c in '+-/*^()':         \n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         if c=='(': p.po(p, c)\n         elif c==')':p.pc(p, c)\n         else: p.o(p, c)\n      elif c in ' \\t':\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n      elif c in '0123456789':\n         if bgn is None:\n            bgn = cp\n      else:\n         print 'Invalid character in expression'\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         \n   if bgn is not None:\n      p.v(p, exprssn[bgn:cp+1])\n      bgn = None\n   return p.end()\n\n\nexpr = raw_input(\"Expression:\")\nastTree = Lex( expr, Yaccer())\nprint expr, '=',astTree.eval()\n"}
{"id": 383280, "name": "Arithmetic evaluation", "source": "Translate Perl to Python: sub ev\n\n\n {my $exp = shift;\n  \n  \n  $exp =~ tr {0-9.+-/*()} {}cd;\n  return ev_ast(astize($exp));}\n\n {my $balanced_paren_regex;\n  $balanced_paren_regex = qr\n     {\\( ( [^()]+ | (??{$balanced_paren_regex}) )+ \\)}x;\n  \n  \n  \n  sub astize\n  \n  \n  \n   {my $exp = shift;\n    \n    $exp =~ /[^0-9.]/ or return $exp;\n    \n    \n    $exp = substr($exp, 1, -1)\n        while $exp =~ /\\A($balanced_paren_regex)\\z/;\n    \n    my @paren_contents;\n    $exp =~ s {($balanced_paren_regex)}\n              {push(@paren_contents, $1);\n               \"[p$\n    \n    \n    $exp =~ m{(.+) ([+-]) (.+)}x or\n        $exp =~ m{(.+) ([*/]) (.+)}x or\n        \n        \n        die \"Eh?: [$exp]\\n\";\n    my ($op, $lo, $ro) = ($2, $1, $3);\n    \n    s {\\[p(\\d+)\\]} {($paren_contents[$1])}eg\n        foreach $lo, $ro;\n    \n    return [$op, astize($lo), astize($ro)];}}\n\n {my %ops =\n     ('+' => sub {$_[0] + $_[1]},\n      '-' => sub {$_[0] - $_[1]},\n      '*' => sub {$_[0] * $_[1]},\n      '/' => sub {$_[0] / $_[1]});\n  \n  sub ev_ast\n  \n  \n   {my $ast = shift;\n    \n    ref $ast or return $ast;\n    \n    my ($op, @operands) = @$ast;\n    $_ = ev_ast($_) foreach @operands;\n    return $ops{$op}->(@operands);}}\n", "target": "import operator\n\nclass AstNode(object):\n   def __init__( self, opr, left, right ):\n      self.opr = opr\n      self.l = left\n      self.r = right\n\n   def eval(self):\n      return self.opr(self.l.eval(), self.r.eval())\n\nclass LeafNode(object):\n   def __init__( self, valStrg ):\n      self.v = int(valStrg)\n\n   def eval(self):\n      return self.v\n\nclass Yaccer(object):\n   def __init__(self):\n      self.operstak = []\n      self.nodestak =[]\n      self.__dict__.update(self.state1)\n\n   def v1( self, valStrg ):\n      \n      self.nodestak.append( LeafNode(valStrg))\n      self.__dict__.update(self.state2)\n      \n\n   def o2( self, operchar ):\n      \n      def openParen(a,b):\n         return 0\t\t\n\n      opDict= { '+': ( operator.add, 2, 2 ),\n         '-': (operator.sub, 2, 2 ),\n         '*': (operator.mul, 3, 3 ),\n         '/': (operator.div, 3, 3 ),\n         '^': ( pow,         4, 5 ),  \n         '(': ( openParen,   0, 8 )\n         }\n      operPrecidence = opDict[operchar][2]\n      self.redeuce(operPrecidence)\n\n      self.operstak.append(opDict[operchar])\n      self.__dict__.update(self.state1)\n      \n\n   def syntaxErr(self, char ):\n      \n      print 'parse error - near operator \"%s\"' %char\n\n   def pc2( self,operchar ):\n      \n      \n      self.redeuce( 1 )\n      if len(self.operstak)>0:\n         self.operstak.pop()\t\t\n      else:\n         print 'Error - no open parenthesis matches close parens.'\n      self.__dict__.update(self.state2)\n\n   def end(self):\n      self.redeuce(0)\n      return self.nodestak.pop()\n\n   def redeuce(self, precidence):\n      while len(self.operstak)>0:\n         tailOper = self.operstak[-1]\n         if tailOper[1] < precidence: break\n\n         tailOper = self.operstak.pop()\n         vrgt = self.nodestak.pop()\n         vlft= self.nodestak.pop()\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\n         \n\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\n\n\ndef Lex( exprssn, p ):\n   bgn = None\n   cp = -1\n   for c in exprssn:\n      cp += 1\n      if c in '+-/*^()':         \n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         if c=='(': p.po(p, c)\n         elif c==')':p.pc(p, c)\n         else: p.o(p, c)\n      elif c in ' \\t':\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n      elif c in '0123456789':\n         if bgn is None:\n            bgn = cp\n      else:\n         print 'Invalid character in expression'\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         \n   if bgn is not None:\n      p.v(p, exprssn[bgn:cp+1])\n      bgn = None\n   return p.end()\n\n\nexpr = raw_input(\"Expression:\")\nastTree = Lex( expr, Yaccer())\nprint expr, '=',astTree.eval()\n"}
{"id": 383281, "name": "Sierpinski curve", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\nmy $rule = 'XF+F+XF--F--XF+F+X';\nmy $S = 'F--F--XF--F--XF';\n$S =~ s/X/$rule/g for 1..5;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = pi/4;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/4; }\n    elsif (/\\-/) { $theta -= pi/4; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import hsv_to_rgb as hsv\n\ndef curve(axiom, rules, angle, depth):\n    for _ in range(depth):\n        axiom = ''.join(rules[c] if c in rules else c for c in axiom)\n\n    a, x, y = 0, [0], [0]\n    for c in axiom:\n        match c:\n            case '+':\n                a += 1\n            case '-':\n                a -= 1\n            case 'F' | 'G':\n                x.append(x[-1] + np.cos(a*angle*np.pi/180))\n                y.append(y[-1] + np.sin(a*angle*np.pi/180))\n\n    l = len(x)\n    \n    for i in range(l - 1):\n        plt.plot(x[i:i+2], y[i:i+2], color=hsv([i/l, 1, .7]))\n    plt.gca().set_aspect(1)\n    plt.show()\n\ncurve('F--XF--F--XF', {'X': 'XF+G+XF--F--XF+G+X'}, 45, 5)\n\n\n\n\n"}
{"id": 383282, "name": "Sierpinski curve", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\nmy $rule = 'XF+F+XF--F--XF+F+X';\nmy $S = 'F--F--XF--F--XF';\n$S =~ s/X/$rule/g for 1..5;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = pi/4;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/4; }\n    elsif (/\\-/) { $theta -= pi/4; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.colors import hsv_to_rgb as hsv\n\ndef curve(axiom, rules, angle, depth):\n    for _ in range(depth):\n        axiom = ''.join(rules[c] if c in rules else c for c in axiom)\n\n    a, x, y = 0, [0], [0]\n    for c in axiom:\n        match c:\n            case '+':\n                a += 1\n            case '-':\n                a -= 1\n            case 'F' | 'G':\n                x.append(x[-1] + np.cos(a*angle*np.pi/180))\n                y.append(y[-1] + np.sin(a*angle*np.pi/180))\n\n    l = len(x)\n    \n    for i in range(l - 1):\n        plt.plot(x[i:i+2], y[i:i+2], color=hsv([i/l, 1, .7]))\n    plt.gca().set_aspect(1)\n    plt.show()\n\ncurve('F--XF--F--XF', {'X': 'XF+G+XF--F--XF+G+X'}, 45, 5)\n\n\n\n\n"}
{"id": 383283, "name": "Selectively replace multiple instances of a character within a string", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub transmogrify {\n    my($str, %sub) = @_;\n    for my $l (keys %sub) {\n        $str =~ s/$l/$_/ for split '', $sub{$l};\n        $str =~ s/_/$l/g;\n    }\n    $str\n}\n\nmy $word = 'abracadabra';\nsay \"$word -> \" . transmogrify $word, 'a' => 'AB_CD', 'r' => '_F', 'b' => 'E';\n", "target": "from collections import defaultdict\n\nrep = {'a' : {1 : 'A', 2 : 'B', 4 : 'C', 5 : 'D'}, 'b' : {1 : 'E'}, 'r' : {2 : 'F'}}\n \ndef trstring(oldstring, repdict):\n    seen, newchars = defaultdict(lambda:1, {}), []\n    for c in oldstring:\n        i = seen[c]\n        newchars.append(repdict[c][i] if c in repdict and i in repdict[c] else c)\n        seen[c] += 1\n    return ''.join(newchars)\n\nprint('abracadabra ->', trstring('abracadabra', rep))\n"}
{"id": 383284, "name": "Selectively replace multiple instances of a character within a string", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub transmogrify {\n    my($str, %sub) = @_;\n    for my $l (keys %sub) {\n        $str =~ s/$l/$_/ for split '', $sub{$l};\n        $str =~ s/_/$l/g;\n    }\n    $str\n}\n\nmy $word = 'abracadabra';\nsay \"$word -> \" . transmogrify $word, 'a' => 'AB_CD', 'r' => '_F', 'b' => 'E';\n", "target": "from collections import defaultdict\n\nrep = {'a' : {1 : 'A', 2 : 'B', 4 : 'C', 5 : 'D'}, 'b' : {1 : 'E'}, 'r' : {2 : 'F'}}\n \ndef trstring(oldstring, repdict):\n    seen, newchars = defaultdict(lambda:1, {}), []\n    for c in oldstring:\n        i = seen[c]\n        newchars.append(repdict[c][i] if c in repdict and i in repdict[c] else c)\n        seen[c] += 1\n    return ''.join(newchars)\n\nprint('abracadabra ->', trstring('abracadabra', rep))\n"}
{"id": 383285, "name": "Nested templated data", "source": "Translate Perl to Python: sub fulfill {\n    my   @payloads;\n    push @payloads, 'Payload\n    my      @result;\n    push    @result, ref $_ eq 'ARRAY' ? [@payloads[@$_]] : @payloads[$_] for @{@_[0]};\n    return [@result];\n}\n\nsub formatted {\n    my $result;\n    $result .= ref $_ eq 'ARRAY' ? '[ \"'. join('\", \"', @$_) . '\" ], ' : qq{\"$_\"} for @{@_[0]};\n    return '[ ' . $result . \" ]\\n\";\n}\n\nprint formatted fulfill( [[1,2], [ 3,4,1], 5] );\nprint formatted fulfill( [[1,2], [10,4,1], 5] );\n", "target": "from pprint import pprint as pp\n\nclass Template():\n    def __init__(self, structure):\n        self.structure = structure\n        self.used_payloads, self.missed_payloads = [], []\n    \n    def inject_payload(self, id2data):\n        \n        def _inject_payload(substruct, i2d, used, missed):\n            used.extend(i2d[x] for x in substruct if type(x) is not tuple and x in i2d)\n            missed.extend(f'??\n                          for x in substruct if type(x) is not tuple and x not in i2d)\n            return tuple(_inject_payload(x, i2d, used, missed) \n                           if type(x) is tuple \n                           else i2d.get(x, f'??\n                         for x in substruct)\n                           \n        ans = _inject_payload(self.structure, id2data, \n                              self.used_payloads, self.missed_payloads)\n        self.unused_payloads = sorted(set(id2data.values()) \n                                      - set(self.used_payloads))\n        self.missed_payloads = sorted(set(self.missed_payloads))\n        return ans\n\nif __name__ == '__main__':\n    index2data = {p: f'Payload\n    print(\"\n    print('\\n  '.join(list(index2data.values())))\n    for structure in [\n     (((1, 2),\n       (3, 4, 1),\n       5),),\n    \n     (((1, 2),\n       (10, 4, 1),\n       5),)]:\n        print(\"\\n\\n\n        pp(structure, width=13)\n        print(\"\\n TEMPLATE WITH PAYLOADS:\")\n        t = Template(structure)\n        out = t.inject_payload(index2data)\n        pp(out)\n        print(\"\\n UNUSED PAYLOADS:\\n  \", end='')\n        unused = t.unused_payloads\n        print('\\n  '.join(unused) if unused else '-')\n        print(\" MISSING PAYLOADS:\\n  \", end='')\n        missed = t.missed_payloads\n        print('\\n  '.join(missed) if missed else '-')\n"}
{"id": 383286, "name": "Range modifications", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy $ranges;\n\nwhile( <DATA> )\n  {\n  my ($cmd) = /(\\S.*\\S)/ or print \"\\n\";\n  $ranges = /Start with \"(.*)\"/ ? $1 :\n    /add (\\d+)/ ? add($1) :\n    /remove (\\d+)/ ? remove($1) :\n    $ranges;\n  $cmd and printf qq(%35s  ->  \"%s\"\\n), $cmd, $ranges;\n  }\n\nsub add\n  {\n  my $n = shift;\n  s/^$/$n-$n/                                              \n    or s/-@{[$n-1]},@{[$n+1]}\\b//                          \n    or s/\\b@{[$n+1]}-/$n-/                                 \n    or s/-@{[$n-1]}\\b/-$n/                                 \n    or s/^(?=(\\d+)-(??{$n < $1\u00a0? ''\u00a0: 'X'}))/$n-$n,/       \n    or s/-(\\d+)\\K$(??{$1 < $n\u00a0? ''\u00a0: 'X'})/,$n-$n/         \n    or s/\\b(\\d+),(\\d+)\\b(??{$1 < $n-1 && $n < $2+1\u00a0? ''\u00a0: 'X'\n      })/$1,$n-$n,$2/                                      \n    for $ranges;\n  $ranges;\n  }\n\nsub remove\n  {\n  my $n = shift;\n  s/^$n-$n,?|,$n-$n\\b//                                    \n    or s/\\b$n(?=-)/$n+1/e                                  \n    or s/-\\K$n\\b/$n-1/e                                    \n    or s/\\b(\\d+)-(\\d+)\\b(??{$1 < $n && $n < $2\u00a0? ''\u00a0: 'X'\n      })/$1-@{[$n-1]},@{[$n+1]}-$2/                        \n    for $ranges;\n  $ranges;\n  }\n\n", "target": "class Sequence():\n    \n    def __init__(self, sequence_string):\n        self.ranges = self.to_ranges(sequence_string)\n        assert self.ranges == sorted(self.ranges), \"Sequence order error\"\n        \n    def to_ranges(self, txt):\n        return [[int(x) for x in r.strip().split('-')]\n                for r in txt.strip().split(',') if r]\n    \n    def remove(self, rem):\n        ranges = self.ranges\n        for i, r in enumerate(ranges):\n            if r[0] <= rem <= r[1]:\n                if r[0] == rem:     \n                    if r[1] > rem:\n                        r[0] += 1\n                    else:\n                        del ranges[i]\n                elif r[1] == rem:   \n                    if r[0] < rem:\n                        r[1] -= 1\n                    else:\n                        del ranges[i]\n                else:               \n                    r[1], splitrange = rem - 1, [rem + 1, r[1]]\n                    ranges.insert(i + 1, splitrange)\n                break\n            if r[0] > rem:  \n                break\n        return self\n            \n    def add(self, add):\n        ranges = self.ranges\n        for i, r in enumerate(ranges):\n            if r[0] <= add <= r[1]:     \n                break\n            elif r[0] - 1 == add:      \n                r[0] = add\n                break\n            elif r[1] + 1 == add:      \n                r[1] = add\n                break\n            elif r[0] > add:      \n                ranges.insert(i, [add, add])\n                break\n        else:\n            ranges.append([add, add])\n            return self\n        return self.consolidate()\n    \n    def consolidate(self):\n        \"Combine overlapping ranges\"\n        ranges = self.ranges\n        for this, that in zip(ranges, ranges[1:]):\n            if this[1] + 1 >= that[0]:  \n                if this[1] >= that[1]:  \n                    this[:], that[:] = [], this\n                else:   \n                    this[:], that[:] = [], [this[0], that[1]]\n        ranges[:] = [r for r in ranges if r]\n        return self\n    def __repr__(self):\n        rr = self.ranges\n        return \",\".join(f\"{r[0]}-{r[1]}\" for r in rr)\n\ndef demo(opp_txt):\n    by_line = opp_txt.strip().split('\\n')\n    start = by_line.pop(0)\n    ex = Sequence(start.strip().split()[-1][1:-1])    \n    lines = [line.strip().split() for line in by_line]\n    opps = [((ex.add if word[0] == \"add\" else ex.remove), int(word[1]))\n            for word in lines]\n    print(f\"Start: \\\"{ex}\\\"\")\n    for op, val in opps:\n        print(f\"    {op.__name__:>6} {val:2} => {op(val)}\")\n    print()\n                    \nif __name__ == '__main__':\n    demo()\n    demo()\n    demo()\n"}
{"id": 383287, "name": "Make a backup file", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub backup {\n    my($filepath,$limit,$ext) = @_;\n    my $abs = readlink $filepath // $filepath; \n    for my $bnum (reverse 1 .. $limit-1) {\n        rename \"$abs$ext$bnum\", \"$abs$ext\" . ++$bnum if -e \"$abs$ext$bnum\";\n    }\n\n    if (-e $abs) {\n        if ($limit > 0) {\n            my $orig = $abs . $ext . '1';\n            rename $abs, $orig;\n            open(IN,  '<', $orig) or die \"can't open $orig: $!\";\n            open(OUT, '>', $abs)  or die \"can't open $abs: $!\";\n\n            my $blksize = (stat IN)[11] || 2**14;          \n            my $buf;\n            while (my $len = sysread IN, $buf, $blksize) {\n                die \"System read error: $!\\n\" if !defined $len;\n                my $offset = 0;\n                while ($len) {          \n                    defined(my $written = syswrite OUT, $buf, $len, $offset)\n                        or die \"System write error: $!\\n\";\n                    $len    -= $written;\n                    $offset += $written;\n                };\n            }\n            close(IN);\n            close(OUT);\n        }\n    } else {\n        warn \"File not found: $abs\" and return 0;\n    }\n    $abs\n}\n\n\nbackup($0,3,'.bk');\n", "target": "import os\ntargetfile = \"pycon-china\"\nos.rename(os.path.realpath(targetfile), os.path.realpath(targetfile)+\".bak\")\nf = open(os.path.realpath(targetfile), \"w\")\nf.write(\"this task was solved during a talk about rosettacode at the PyCon China in 2011\")\nf.close()\n"}
{"id": 383288, "name": "Make a backup file", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub backup {\n    my($filepath,$limit,$ext) = @_;\n    my $abs = readlink $filepath // $filepath; \n    for my $bnum (reverse 1 .. $limit-1) {\n        rename \"$abs$ext$bnum\", \"$abs$ext\" . ++$bnum if -e \"$abs$ext$bnum\";\n    }\n\n    if (-e $abs) {\n        if ($limit > 0) {\n            my $orig = $abs . $ext . '1';\n            rename $abs, $orig;\n            open(IN,  '<', $orig) or die \"can't open $orig: $!\";\n            open(OUT, '>', $abs)  or die \"can't open $abs: $!\";\n\n            my $blksize = (stat IN)[11] || 2**14;          \n            my $buf;\n            while (my $len = sysread IN, $buf, $blksize) {\n                die \"System read error: $!\\n\" if !defined $len;\n                my $offset = 0;\n                while ($len) {          \n                    defined(my $written = syswrite OUT, $buf, $len, $offset)\n                        or die \"System write error: $!\\n\";\n                    $len    -= $written;\n                    $offset += $written;\n                };\n            }\n            close(IN);\n            close(OUT);\n        }\n    } else {\n        warn \"File not found: $abs\" and return 0;\n    }\n    $abs\n}\n\n\nbackup($0,3,'.bk');\n", "target": "import os\ntargetfile = \"pycon-china\"\nos.rename(os.path.realpath(targetfile), os.path.realpath(targetfile)+\".bak\")\nf = open(os.path.realpath(targetfile), \"w\")\nf.write(\"this task was solved during a talk about rosettacode at the PyCon China in 2011\")\nf.close()\n"}
{"id": 383289, "name": "Rosetta Code_Fix code tags", "source": "Translate Perl to Python: my @langs = qw(ada cpp-qt pascal lscript z80 visualprolog\nhtml4strict cil objc asm progress teraterm hq9plus genero tsql\nemail pic16 tcl apt_sources io apache vhdl avisynth winbatch\nvbnet ini scilab ocaml-brief sas actionscript3 qbasic perl bnf\ncobol powershell php kixtart visualfoxpro mirc make javascript\ncpp sdlbasic cadlisp php-brief rails verilog xml csharp\nactionscript nsis bash typoscript freebasic dot applescript\nhaskell dos oracle8 cfdg glsl lotusscript mpasm latex sql klonec\nruby ocaml smarty python oracle11 caddcl robots groovy smalltalk\ndiff fortran cfm lua modula3 vb autoit java text scala\nlotusformulas pixelbender reg _div whitespace providex asp css\nlolcode lisp inno mysql plsql matlab oobas vim delphi xorg_conf\ngml prolog bf per scheme mxml d basic4gl m68k gnuplot idl abap\nintercal c_mac thinbasic java5 xpp boo klonecpp blitzbasic eiffel\npovray c gettext);\n\nmy $text = join \"\", <STDIN>;\nmy $slang=\"/lang\";\nfor (@langs) {\n    $text =~ s|<$_>|<lang $_>|g;\n    $text =~ s|</$_>|<$slang>|g;\n}\n\n$text =~ s|<code (.+?)>(.*?)</code>|<lang $1>$2<$slang>|sg;\n\nprint $text;\n", "target": "\n\nfrom re import sub\n\ntesttexts = [\n,\n    ,\n    ]\n\nfor txt in testtexts:\n    text2 = sub(r'<lang\\s+\\\"?([\\w\\d\\s]+)\\\"?\\s?>', r'<syntaxhighlight lang=\\1>', txt)\n    text2 = sub(r'<lang\\s*>', r'<syntaxhighlight lang=text>', text2)\n    text2 = sub(r'</lang\\s*>', r'\n"}
{"id": 383290, "name": "War card game", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( shuffle );\n\nmy %rank;\n@rank{ 2 .. 9, qw(t j q k a) } = 1 .. 13; \nlocal $_ = join '', shuffle\n  map { my $f = $_; map $f.$_, qw( S H C D ) } 2 .. 9, qw( a t j q k );\nsubstr $_, 52, 0, \"\\n\"; \nmy $war = '';\nmy $cnt = 0;\n$cnt++ while print( /(.*)\\n(.*)/ && \"one: $1\\ntwo: $2\\n\\n\" ),\n  s/^((.).)(.*)\\n((?!\\2)(.).)(.*)$/ my $win = $war; $war = ''; \n    $rank{$2} > $rank{$5}\u00a0? \"$3$1$4$win\\n$6\"\u00a0: \"$3\\n$6$4$1$win\" /e\n  ||\n  s/^(.{4})(.*)\\n(.{4})(.*)$/ print \"WAR!!!\\n\\n\"; $war .= \"$1$3\";\n    \"$2\\n$4\" /e; \nprint \"player '\", /^.{10}/ ? 'one' : 'two', \"' wins in $cnt moves\\n\";\n", "target": "\n\nfrom numpy.random import shuffle\n\nSUITS = ['\u2663', '\u2666', '\u2665', '\u2660']\nFACES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\nDECK = [f + s for f in FACES for s in SUITS]\nCARD_TO_RANK = dict((DECK[i], (i + 3) // 4) for i in range(len(DECK)))\n\n\nclass WarCardGame:\n    \n    def __init__(self):\n        deck = DECK.copy()\n        shuffle(deck)\n        self.deck1, self.deck2 = deck[:26], deck[26:]\n        self.pending = []\n\n    def turn(self):\n        \n        if len(self.deck1) == 0 or len(self.deck2) == 0:\n            return self.gameover()\n\n        card1, card2 = self.deck1.pop(0), self.deck2.pop(0)\n        rank1, rank2 = CARD_TO_RANK[card1], CARD_TO_RANK[card2]\n        print(\"{:10}{:10}\".format(card1, card2), end='')\n        if rank1 > rank2:\n            print('Player 1 takes the cards.')\n            self.deck1.extend([card1, card2])\n            self.deck1.extend(self.pending)\n            self.pending = []\n        elif rank1 < rank2:\n            print('Player 2 takes the cards.')\n            self.deck2.extend([card2, card1])\n            self.deck2.extend(self.pending)\n            self.pending = []\n        else:  \n            print('Tie!')\n            if len(self.deck1) == 0 or len(self.deck2) == 0:\n                return self.gameover()\n\n            card3, card4 = self.deck1.pop(0), self.deck2.pop(0)\n            self.pending.extend([card1, card2, card3, card4])\n            print(\"{:10}{:10}\".format(\"?\", \"?\"), 'Cards are face down.', sep='')\n            return self.turn()\n\n        return True\n\n    def gameover(self):\n        \n        if len(self.deck2) == 0:\n            if len(self.deck1) == 0:\n                print('\\nGame ends as a tie.')\n            else:\n                print('\\nPlayer 1 wins the game.')\n        else:\n            print('\\nPlayer 2 wins the game.')\n\n        return False\n\n\nif __name__ == '__main__':\n    WG = WarCardGame()\n    while WG.turn():\n        continue\n"}
{"id": 383291, "name": "War card game", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( shuffle );\n\nmy %rank;\n@rank{ 2 .. 9, qw(t j q k a) } = 1 .. 13; \nlocal $_ = join '', shuffle\n  map { my $f = $_; map $f.$_, qw( S H C D ) } 2 .. 9, qw( a t j q k );\nsubstr $_, 52, 0, \"\\n\"; \nmy $war = '';\nmy $cnt = 0;\n$cnt++ while print( /(.*)\\n(.*)/ && \"one: $1\\ntwo: $2\\n\\n\" ),\n  s/^((.).)(.*)\\n((?!\\2)(.).)(.*)$/ my $win = $war; $war = ''; \n    $rank{$2} > $rank{$5}\u00a0? \"$3$1$4$win\\n$6\"\u00a0: \"$3\\n$6$4$1$win\" /e\n  ||\n  s/^(.{4})(.*)\\n(.{4})(.*)$/ print \"WAR!!!\\n\\n\"; $war .= \"$1$3\";\n    \"$2\\n$4\" /e; \nprint \"player '\", /^.{10}/ ? 'one' : 'two', \"' wins in $cnt moves\\n\";\n", "target": "\n\nfrom numpy.random import shuffle\n\nSUITS = ['\u2663', '\u2666', '\u2665', '\u2660']\nFACES = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']\nDECK = [f + s for f in FACES for s in SUITS]\nCARD_TO_RANK = dict((DECK[i], (i + 3) // 4) for i in range(len(DECK)))\n\n\nclass WarCardGame:\n    \n    def __init__(self):\n        deck = DECK.copy()\n        shuffle(deck)\n        self.deck1, self.deck2 = deck[:26], deck[26:]\n        self.pending = []\n\n    def turn(self):\n        \n        if len(self.deck1) == 0 or len(self.deck2) == 0:\n            return self.gameover()\n\n        card1, card2 = self.deck1.pop(0), self.deck2.pop(0)\n        rank1, rank2 = CARD_TO_RANK[card1], CARD_TO_RANK[card2]\n        print(\"{:10}{:10}\".format(card1, card2), end='')\n        if rank1 > rank2:\n            print('Player 1 takes the cards.')\n            self.deck1.extend([card1, card2])\n            self.deck1.extend(self.pending)\n            self.pending = []\n        elif rank1 < rank2:\n            print('Player 2 takes the cards.')\n            self.deck2.extend([card2, card1])\n            self.deck2.extend(self.pending)\n            self.pending = []\n        else:  \n            print('Tie!')\n            if len(self.deck1) == 0 or len(self.deck2) == 0:\n                return self.gameover()\n\n            card3, card4 = self.deck1.pop(0), self.deck2.pop(0)\n            self.pending.extend([card1, card2, card3, card4])\n            print(\"{:10}{:10}\".format(\"?\", \"?\"), 'Cards are face down.', sep='')\n            return self.turn()\n\n        return True\n\n    def gameover(self):\n        \n        if len(self.deck2) == 0:\n            if len(self.deck1) == 0:\n                print('\\nGame ends as a tie.')\n            else:\n                print('\\nPlayer 1 wins the game.')\n        else:\n            print('\\nPlayer 2 wins the game.')\n\n        return False\n\n\nif __name__ == '__main__':\n    WG = WarCardGame()\n    while WG.turn():\n        continue\n"}
{"id": 383292, "name": "Determine sentence type", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Lingua::Sentence;\n\nmy $para1 = <<'EOP';\nhi there, how are you today? I'd like to present to you the washing machine\n9001. You have been nominated to win one of these! Just make sure you don't\nbreak it\nEOP\n\nmy $para2 = <<'EOP';\nJust because there are punctuation characters like \"?\", \"!\" or especially \".\"\npresent, it doesn't necessarily mean you have reached the end of a sentence,\ndoes it Mr. Magoo? The syntax highlighting here for Perl isn't bad at all.\nEOP\n\nmy $splitter = Lingua::Sentence->new(\"en\");\nfor my $text ($para1, $para2) {\n  for my $s (split /\\n/, $splitter->split( $text =~ s/\\n//gr ) {\n    print \"$s| \";\n    if    ($s =~ /!$/)  { say 'E' }\n    elsif ($s =~ /\\?$/) { say 'Q' }\n    elsif ($s =~ /\\.$/) { say 'S' }\n    else                { say 'N' }\n  }\n}\n", "target": "import re\n\ntxt = \n\ndef haspunctotype(s):\n    return 'S' if '.' in s else 'E' if '!' in s else 'Q' if '?' in s else 'N'\n\ntxt = re.sub('\\n', '', txt)\npars = [s.strip() for s in re.split(\"(?:(?:(?<=[\\?\\!\\.])(?:))|(?:(?:)(?=[\\?\\!\\.])))\", txt)]\nif len(pars) % 2:\n    pars.append('')  \nfor i in range(0, len(pars)-1, 2):\n    print((pars[i] + pars[i + 1]).ljust(54), \"==>\", haspunctotype(pars[i + 1]))\n"}
{"id": 383293, "name": "Random sentence from book", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy $book = do { local (@ARGV, $/) = 'waroftheworlds.txt'; <> };\nmy (%one, %two);\n\ns/^.*?START OF THIS\\N*\\n//s, s/END OF THIS.*//s,\n  tr/a-zA-Z.!?/ /c, tr/ / /s for $book;\n\nmy $qr = qr/(\\b\\w+\\b|[.!?])/;\n$one{$1}{$2}++, $two{$1}{$2}{$3}++ while $book =~ /$qr(?= *$qr *$qr)/g;\n\nsub weightedpick\n  {\n  my $href = shift;\n  my @weightedpick = map { ($_) x $href->{$_} } keys %$href;\n  $weightedpick[rand @weightedpick];\n  }\n\nsub sentence\n  {\n  my @sentence = qw( .\u00a0!\u00a0? )[rand 3];\n  push @sentence, weightedpick( $one{ $sentence[0] } );\n  push @sentence, weightedpick( $two{ $sentence[-2] }{ $sentence[-1] } )\n    while $sentence[-1] =~ /\\w/;\n  shift @sentence;\n  \"@sentence\\n\\n\" =~ s/\\w\\K (?=[st]\\b)/'/gr =~ s/ (?=[.!?]\\n)//r\n    =~ s/.{60,}?\\K /\\n/gr;\n  }\n\nprint sentence() for 1 .. 10;\n", "target": "from urllib.request import urlopen\nimport re\nfrom string import punctuation\nfrom collections import Counter, defaultdict\nimport random\n\n\n\ntext_url = 'http://www.gutenberg.org/files/36/36-0.txt'\ntext_start = 'No one would have believed'\n\nsentence_ending = '.!?'\nsentence_pausing = ',;:'\n\ndef read_book(text_url, text_start) -> str:\n    with urlopen(text_url) as book:\n        text = book.read().decode('utf-8')\n    return text[text.index(text_start):]\n\ndef remove_punctuation(text: str, keep=sentence_ending+sentence_pausing)-> str:\n    \"Remove punctuation, keeping some\"\n    to_remove = ''.join(set(punctuation) - set(keep))\n    text = text.translate(str.maketrans(to_remove, ' ' * len(to_remove))).strip()\n    text = re.sub(fr\"[^a-zA-Z0-9{keep}\\n ]+\", ' ', text)\n    \n    if keep:\n        text = re.sub(f\"([{keep}])+\", r\" \\1 \", text).strip()\n    if text[-1] not in sentence_ending:\n        text += ' .'\n    return text.lower()\n\ndef word_follows_words(txt_with_pauses_and_endings):\n    \"return dict of freq of words following one/two words\"\n    words = ['.'] + txt_with_pauses_and_endings.strip().split()\n\n    \n    word2next = defaultdict(lambda :defaultdict(int))\n    word2next2 = defaultdict(lambda :defaultdict(int))\n    for lh, rh in zip(words, words[1:]):\n        word2next[lh][rh] += 1\n    for lh, mid, rh in zip(words, words[1:], words[2:]):\n        word2next2[(lh, mid)][rh] += 1\n\n    return dict(word2next), dict(word2next2)\n\ndef gen_sentence(word2next, word2next2) -> str:\n\n    s = ['.']\n    s += random.choices(*zip(*word2next[s[-1]].items()))\n    while True:\n        s += random.choices(*zip(*word2next2[(s[-2], s[-1])].items()))\n        if s[-1] in sentence_ending:\n            break\n\n    s  = ' '.join(s[1:]).capitalize()\n    s = re.sub(fr\" ([{sentence_ending+sentence_pausing}])\", r'\\1', s)\n    s = re.sub(r\" re\\b\", \"'re\", s)\n    s = re.sub(r\" s\\b\", \"'s\", s)\n    s = re.sub(r\"\\bi\\b\", \"I\", s)\n\n    return s\n\nif __name__ == \"__main__\":\n    txt_with_pauses_and_endings = remove_punctuation(read_book(text_url, text_start))\n    word2next, word2next2 = word_follows_words(txt_with_pauses_and_endings)\n    \n    sentence = gen_sentence(word2next, word2next2)\n    print(sentence)\n"}
{"id": 383294, "name": "Sort an outline at every level", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nfor my $test ( split /^(?=\n  {\n  my ( $id, $outline ) = $test =~ /(\\V*?\\n)(.*)/s;\n  my $sorted = validateandsort( $outline, $id =~ /descend/ );\n  print $test, '=' x 20, \" answer:\\n$sorted\\n\";\n  }\n\nsub validateandsort\n  {\n  my ($outline, $descend) = @_;\n  $outline =~ /^\\h*(?: \\t|\\t )/m and\n    return \"ERROR: mixed tab and space indentaion\\n\";\n  my $adjust = 0;\n  $adjust++ while $outline =~ s/^(\\h*)\\H.*\\n\\1\\K\\h(?=\\H)//m\n    or $outline =~ s/^(\\h*)(\\h)\\H.*\\n\\1\\K(?=\\H)/$2/m;\n  $adjust and print \"WARNING: adjusting indentation on some lines\\n\";\n  return levelsort($outline, $descend);\n  }\n\nsub levelsort       \n  {\n  my ($section, $descend) = @_;\n  my @parts;\n  while( $section =~ / ((\\h*) .*\\n) ( (?:\\2\\h.*\\n)* )/gx )\n    {\n    my ($head, $rest) = ($1, $3);\n    push @parts, $head . ( $rest and levelsort($rest, $descend) );\n    }\n  join '', $descend ? reverse sort @parts : sort @parts;\n  }\n\n", "target": "\n\n\nfrom itertools import chain, product, takewhile, tee\nfrom functools import cmp_to_key, reduce\n\n\n\n\n\n\n\ndef sortedOutline(cmp):\n    \n    def go(outlineText):\n        indentTuples = indentTextPairs(\n            outlineText.splitlines()\n        )\n        return bindLR(\n            minimumIndent(enumerate(indentTuples))\n        )(lambda unitIndent: Right(\n            outlineFromForest(\n                unitIndent,\n                nest(foldTree(\n                    lambda x: lambda xs: Node(x)(\n                        sorted(xs, key=cmp_to_key(cmp))\n                    )\n                )(Node('')(\n                    forestFromIndentLevels(\n                        indentLevelsFromLines(\n                            unitIndent\n                        )(indentTuples)\n                    )\n                )))\n            )\n        ))\n    return go\n\n\n\n\ndef main():\n    \n\n    ascending = comparing(root)\n    descending = flip(ascending)\n\n    spacedOutline = \n\n    tabbedOutline = \n\n    confusedOutline = \n\n    raggedOutline = \n\n    def displaySort(kcmp):\n        \n        k, cmp = kcmp\n        return [\n            tested(cmp, k, label)(\n                outline\n            ) for (label, outline) in [\n                ('4-space indented', spacedOutline),\n                ('tab indented', tabbedOutline),\n                ('Unknown 1', confusedOutline),\n                ('Unknown 2', raggedOutline)\n            ]\n        ]\n\n    def tested(cmp, cmpName, outlineName):\n        \n        def go(outline):\n            print('\\n' + outlineName, cmpName + ':')\n            either(print)(print)(\n                sortedOutline(cmp)(outline)\n            )\n        return go\n\n    \n    ap([\n        displaySort\n    ])([\n        (\"(A -> Z)\", ascending),\n        (\"(Z -> A)\", descending)\n    ])\n\n\n\n\n\ndef forestFromIndentLevels(tuples):\n    \n    def go(xs):\n        if xs:\n            intIndent, v = xs[0]\n            firstTreeLines, rest = span(\n                lambda x: intIndent < x[0]\n            )(xs[1:])\n            return [Node(v)(go(firstTreeLines))] + go(rest)\n        else:\n            return []\n    return go(tuples)\n\n\n\n\ndef indentLevelsFromLines(indentUnit):\n    \n    def go(xs):\n        w = len(indentUnit)\n        return [\n            (len(x[0]) // w, x[1])\n            for x in xs\n        ]\n    return go\n\n\n\ndef indentTextPairs(xs):\n    \n    def indentAndText(s):\n        pfx = list(takewhile(lambda c: c.isspace(), s))\n        return (pfx, s[len(pfx):])\n    return [indentAndText(x) for x in xs]\n\n\n\ndef outlineFromForest(tabString, forest):\n    \n    def go(indent):\n        def serial(node):\n            return [indent + root(node)] + list(\n                concatMap(\n                    go(tabString + indent)\n                )(nest(node))\n            )\n        return serial\n    return '\\n'.join(\n        concatMap(go(''))(forest)\n    )\n\n\n\n\n\n\ndef minimumIndent(indexedPrefixes):\n    \n    (xs, ts) = tee(indexedPrefixes)\n    (ys, zs) = tee(ts)\n\n    def mindentLR(charSet):\n        if list(charSet):\n            def w(x):\n                return len(x[1][0])\n\n            unit = min(filter(w, ys), key=w)[1][0]\n            unitWidth = len(unit)\n\n            def widthCheck(a, ix):\n                \n                wx = len(ix[1][0])\n                return a if (a or 0 == wx) else (\n                    ix[0] if 0 != wx % unitWidth else a\n                )\n            oddLine = reduce(widthCheck, zs, None)\n            return Left(\n                'Inconsistent indentation width at line ' + (\n                    str(1 + oddLine)\n                )\n            ) if oddLine else Right(''.join(unit))\n        else:\n            return Right('')\n\n    def tabSpaceCheck(a, ics):\n        \n        charSet = a[0].union(set(ics[1][0]))\n        return a if a[1] else (\n            charSet, ics[0] if 1 < len(charSet) else None\n        )\n\n    indentCharSet, mbAnomalyLine = reduce(\n        tabSpaceCheck, xs, (set([]), None)\n    )\n    return bindLR(\n        Left(\n            'Mixed indent characters found in line ' + str(\n                1 + mbAnomalyLine\n            )\n        ) if mbAnomalyLine else Right(list(indentCharSet))\n    )(mindentLR)\n\n\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\ndef Node(v):\n    \n    return lambda xs: {'type': 'Tree', 'root': v, 'nest': xs}\n\n\n\ndef ap(fs):\n    \n    def go(xs):\n        return [\n            f(x) for (f, x)\n            in product(fs, xs)\n        ]\n    return go\n\n\n\ndef bindLR(m):\n    \n    def go(mf):\n        return (\n            mf(m.get('Right')) if None is m.get('Left') else m\n        )\n    return go\n\n\n\ndef comparing(f):\n    \n    def go(x, y):\n        fx = f(x)\n        fy = f(y)\n        return -1 if fx < fy else (1 if fx > fy else 0)\n    return go\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef flip(f):\n    \n    return lambda a, b: f(b, a)\n\n\n\ndef foldTree(f):\n    \n    def go(node):\n        return f(root(node))([\n            go(x) for x in nest(node)\n        ])\n    return go\n\n\n\ndef nest(t):\n    \n    return t.get('nest')\n\n\n\ndef root(t):\n    \n    return t.get('root')\n\n\n\ndef span(p):\n    \n    def match(ab):\n        b = ab[1]\n        return not b or not p(b[0])\n\n    def f(ab):\n        a, b = ab\n        return a + [b[0]], b[1:]\n\n    def go(xs):\n        return until(match)(f)(([], xs))\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383295, "name": "Display an outline as a nested table", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy @rows;\nmy $row = -1;\nmy $width = 0;\nmy $color = 0;\nour $bg = 'e0ffe0';\n\nparseoutline( do { local $/; <DATA> =~ s/\\t/  /gr } );\n\nprint \"<table border=1 cellspacing=0>\\n\";\nfor ( @rows )\n  {\n  my $start = 0;\n  print \"  <tr>\\n\";\n  for ( @$_ ) \n    {\n    my ($data, $col, $span, $bg) = @$_;\n    print \"    <td></td>\\n\" x ( $col - $start ),\n      \"    <td colspan=$span align=center bgcolor=\n    $start = $col + $span;\n    }\n  print \"    <td></td>\\n\" x ( $width - $start ), \"  </tr>\\n\";\n  }\nprint \"</table>\\n\";\n\nsub parseoutline\n  {\n  ++$row;\n  while( $_[0] =~ /^( *)(.*)\\n((?:\\1 .*\\n)*)/gm )\n    {\n    my ($head, $body, $col) = ($2, $3, $width);\n    $row == 1 and local $bg = qw( ffffe0 ffe0e0 )[ $color ^= 1];\n    if( length $body ) { parseoutline( $body ) } else { ++$width }\n    push @{ $rows[$row] }, [ $head, $col, $width - $col, $bg ];\n    }\n  --$row;\n  }\n\n", "target": "\n\nimport itertools\nimport re\nimport sys\n\nfrom collections import deque\nfrom typing import NamedTuple\n\n\nRE_OUTLINE = re.compile(r\"^((?: |\\t)*)(.+)$\", re.M)\n\nCOLORS = itertools.cycle(\n    [\n        \"\n        \"\n        \"\n        \"\n        \"\n    ]\n)\n\n\nclass Node:\n    def __init__(self, indent, value, parent, children=None):\n        self.indent = indent\n        self.value = value\n        self.parent = parent\n        self.children = children or []\n\n        self.color = None\n\n    def depth(self):\n        if self.parent:\n            return self.parent.depth() + 1\n        return -1\n\n    def height(self):\n        \n        if not self.children:\n            return 0\n        return max(child.height() for child in self.children) + 1\n\n    def colspan(self):\n        if self.leaf:\n            return 1\n        return sum(child.colspan() for child in self.children)\n\n    @property\n    def leaf(self):\n        return not bool(self.children)\n\n    def __iter__(self):\n        \n        q = deque()\n        q.append(self)\n        while q:\n            node = q.popleft()\n            yield node\n            q.extend(node.children)\n\n\nclass Token(NamedTuple):\n    indent: int\n    value: str\n\n\ndef tokenize(outline):\n    \n    for match in RE_OUTLINE.finditer(outline):\n        indent, value = match.groups()\n        yield Token(len(indent), value)\n\n\ndef parse(outline):\n    \n    \n    tokens = list(tokenize(outline))\n\n    \n    temp_root = Node(-1, \"\", None)\n    _parse(tokens, 0, temp_root)\n\n    \n    root = temp_root.children[0]\n    pad_tree(root, root.height())\n\n    return root\n\n\ndef _parse(tokens, index, node):\n    \n    \n    if index >= len(tokens):\n        return\n\n    token = tokens[index]\n\n    if token.indent == node.indent:\n        \n        current = Node(token.indent, token.value, node.parent)\n        node.parent.children.append(current)\n        _parse(tokens, index + 1, current)\n\n    elif token.indent > node.indent:\n        \n        current = Node(token.indent, token.value, node)\n        node.children.append(current)\n        _parse(tokens, index + 1, current)\n\n    elif token.indent < node.indent:\n        \n        _parse(tokens, index, node.parent)\n\n\ndef pad_tree(node, height):\n    \n    if node.leaf and node.depth() < height:\n        pad_node = Node(node.indent + 1, \"\", node)\n        node.children.append(pad_node)\n\n    for child in node.children:\n        pad_tree(child, height)\n\n\ndef color_tree(node):\n    \n    if not node.value:\n        node.color = \"\n    elif node.depth() <= 1:\n        node.color = next(COLORS)\n    else:\n        node.color = node.parent.color\n\n    for child in node.children:\n        color_tree(child)\n\n\ndef table_data(node):\n    \n    indent = \"    \"\n\n    if node.colspan() > 1:\n        colspan = f'colspan=\"{node.colspan()}\"'\n    else:\n        colspan = \"\"\n\n    if node.color:\n        style = f'style=\"background-color: {node.color};\"'\n    else:\n        style = \"\"\n\n    attrs = \" \".join([colspan, style])\n    return f\"{indent}<td{attrs}>{node.value}</td>\"\n\n\ndef html_table(tree):\n    \n    \n    table_cols = tree.colspan()\n\n    \n    row_cols = 0\n\n    \n    buf = [\"<table style='text-align: center;'>\"]\n\n    \n    for node in tree:\n        if row_cols == 0:\n            buf.append(\"  <tr>\")\n\n        buf.append(table_data(node))\n        row_cols += node.colspan()\n\n        if row_cols == table_cols:\n            buf.append(\"  </tr>\")\n            row_cols = 0\n\n    buf.append(\"</table>\")\n    return \"\\n\".join(buf)\n\n\ndef wiki_table_data(node):\n    \n    if not node.value:\n        return \"|  |\"\n\n    if node.colspan() > 1:\n        colspan = f\"colspan={node.colspan()}\"\n    else:\n        colspan = \"\"\n\n    if node.color:\n        style = f'style=\"background: {node.color};\"'\n    else:\n        style = \"\"\n\n    attrs = \" \".join([colspan, style])\n    return f\"| {attrs} | {node.value}\"\n\n\ndef wiki_table(tree):\n    \n    \n    table_cols = tree.colspan()\n\n    \n    row_cols = 0\n\n    \n    buf = ['{| class=\"wikitable\" style=\"text-align: center;\"']\n\n    for node in tree:\n        if row_cols == 0:\n            buf.append(\"|-\")\n\n        buf.append(wiki_table_data(node))\n        row_cols += node.colspan()\n\n        if row_cols == table_cols:\n            row_cols = 0\n\n    buf.append(\"|}\")\n    return \"\\n\".join(buf)\n\n\ndef example(table_format=\"wiki\"):\n    \n\n    outline = (\n        \"Display an outline as a nested table.\\n\"\n        \"    Parse the outline to a tree,\\n\"\n        \"        measuring the indent of each line,\\n\"\n        \"        translating the indentation to a nested structure,\\n\"\n        \"        and padding the tree to even depth.\\n\"\n        \"    count the leaves descending from each node,\\n\"\n        \"        defining the width of a leaf as 1,\\n\"\n        \"        and the width of a parent node as a sum.\\n\"\n        \"            (The sum of the widths of its children)\\n\"\n        \"    and write out a table with 'colspan' values\\n\"\n        \"        either as a wiki table,\\n\"\n        \"        or as HTML.\"\n    )\n\n    tree = parse(outline)\n    color_tree(tree)\n\n    if table_format == \"wiki\":\n        print(wiki_table(tree))\n    else:\n        print(html_table(tree))\n\n\nif __name__ == \"__main__\":\n    args = sys.argv[1:]\n\n    if len(args) == 1:\n        table_format = args[0]\n    else:\n        table_format = \"wiki\"\n\n    example(table_format)\n"}
{"id": 383296, "name": "Smallest multiple", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( lcm );\n\nprint \"for $_, it's @{[ lcm(1 .. $_) ]}\\n\" for 10, 20;\n", "target": "\n\nfrom math import gcd\nfrom functools import reduce\n\n\ndef lcm(a, b):\n    \n    return 0 if 0 == a or 0 == b else (\n        abs(a * b) // gcd(a, b)\n    )\n\n\nfor i in [10, 20, 200, 2000]:\n    print(str(i) + ':', reduce(lcm, range(1, i + 1)))\n"}
{"id": 383297, "name": "Find first missing positive", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse List::Util qw( first );\n\nmy @tests = ( [1,2,0], [3,4,-1,1], [7,8,9,11,12],\n  [3, 4, 1, 1], [1, 2, 3, 4, 5], [-6, -5, -2, -1], [5, -5], [-2], [1], []);\n\nfor my $test ( @tests )\n  {\n  print \"[ @$test ]  ==>  \",\n    first { not { map { $_ => 1 } @$test }->{$_}  } 1 .. @$test + 1;\n  }\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstGap(xs):\n    \n    return next(x for x in count(1) if x not in xs)\n\n\n\n\ndef main():\n    \n    print('\\n'.join([\n        f'{repr(xs)} -> {firstGap(xs)}' for xs in [\n            [1, 2, 0],\n            [3, 4, -1, 1],\n            [7, 8, 9, 11, 12]\n        ]\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383298, "name": "Find adjacent primes which differ by a square integer", "source": "Translate Perl to Python: \n\nuse strict;    \nuse warnings;\nuse ntheory qw( primes is_square );\n\nmy $primeref = primes(1e6);\nfor my $i (1 .. $\n    (my $diff = $primeref->[$i] - $primeref->[$i - 1]) > 36 or next;\n    is_square($diff) and print \"$primeref->[$i] - $primeref->[$i - 1] = $diff\\n\";\n}\n", "target": "import math\nprint(\"working...\")\nlimit = 1000000\nPrimes = []\noldPrime = 0\nnewPrime = 0\nx = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(x):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit):\n    if isPrime(n):\n       Primes.append(n)\n\nfor n in range(2,len(Primes)):\n    pr1 = Primes[n]\n    pr2 = Primes[n-1]\n    diff = pr1 - pr2\n    flag = issquare(diff)\n    if (flag == 1 and diff > 36):\n       print(str(pr1) + \" \" + str(pr2) + \" diff = \" + str(diff))\n\nprint(\"done...\")\n"}
{"id": 383299, "name": "Find adjacent primes which differ by a square integer", "source": "Translate Perl to Python: \n\nuse strict;    \nuse warnings;\nuse ntheory qw( primes is_square );\n\nmy $primeref = primes(1e6);\nfor my $i (1 .. $\n    (my $diff = $primeref->[$i] - $primeref->[$i - 1]) > 36 or next;\n    is_square($diff) and print \"$primeref->[$i] - $primeref->[$i - 1] = $diff\\n\";\n}\n", "target": "import math\nprint(\"working...\")\nlimit = 1000000\nPrimes = []\noldPrime = 0\nnewPrime = 0\nx = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(x):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit):\n    if isPrime(n):\n       Primes.append(n)\n\nfor n in range(2,len(Primes)):\n    pr1 = Primes[n]\n    pr2 = Primes[n-1]\n    diff = pr1 - pr2\n    flag = issquare(diff)\n    if (flag == 1 and diff > 36):\n       print(str(pr1) + \" \" + str(pr2) + \" diff = \" + str(diff))\n\nprint(\"done...\")\n"}
{"id": 383300, "name": "Compiler_syntax analyzer", "source": "Translate Perl to Python: \n\nuse strict;   \nuse warnings; \n\nmy $h = qr/\\G\\s*\\d+\\s+\\d+\\s+/;  \n\nsub error { die \"*** Expected @_ at \" . (/\\G(.*\\n)/ ?\n  $1 =~ s/^\\s*(\\d+)\\s+(\\d+)\\s+/line $1 character $2 got /r : \"EOF\\n\") }\n\nsub want { /$h \\Q$_[1]\\E.*\\n/gcx ? shift : error \"'$_[1]'\" }\n\nlocal $_ = join '', <>;\nprint want stmtlist(), 'End_of_input';\n\nsub stmtlist\n  {\n  /(?=$h (RightBrace|End_of_input))/gcx and return \";\\n\";\n  my ($stmt, $stmtlist) = (stmt(), stmtlist());\n  $stmtlist eq \";\\n\" ? $stmt : \"Sequence\\n$stmt$stmtlist\";\n  }\n\nsub stmt\n  {\n  /$h Semicolon\\n/gcx ? \";\\n\" :\n    /$h Identifier \\s+ (\\w+) \\n/gcx ? want(\"Assign\\nIdentifier\\t$1\\n\",\n      'Op_assign') . want expr(0), 'Semicolon' :\n    /$h Keyword_while \\n/gcx ? \"While\\n\" . parenexp() . stmt() :\n    /$h Keyword_if \\n/gcx ?  \"If\\n\" . parenexp() . \"If\\n\" . stmt() .\n      (/$h Keyword_else \\n/gcx ? stmt() : \";\\n\") :\n    /$h Keyword_print \\n/gcx ? want('', 'LeftParen') .\n      want want(printlist(), 'RightParen'), 'Semicolon' :\n    /$h Keyword_putc \\n/gcx ? want \"Prtc\\n\" . parenexp() . \";\\n\", 'Semicolon' :\n    /$h LeftBrace \\n/gcx ? want stmtlist(), 'RightBrace' :\n    error 'A STMT';\n  }\n\nsub parenexp { want('', 'LeftParen') . want expr(0), 'RightParen' } \n\nsub printlist\n  {\n  my $ast = /$h String \\s+ (\".*\") \\n/gcx ?\n    \"Prts\\nString\\t\\t$1\\n;\\n\" : \"Prti\\n\" . expr(0) . \";\\n\";\n  /$h Comma \\n/gcx ? \"Sequence\\n$ast\" . printlist() : $ast;\n  }\n\nsub expr               \n  {\n  my $ast =                                        \n    /$h Integer \\s+ (\\d+) \\n/gcx ? \"Integer\\t\\t$1\\n\" :\n    /$h Identifier \\s+ (\\w+) \\n/gcx ? \"Identifier\\t$1\\n\" :\n    /$h LeftParen \\n/gcx ? want expr(0), 'RightParen' :\n    /$h Op_(negate|subtract) \\n/gcx ? \"Negate\\n\" . expr(8) . \";\\n\" :\n    /$h Op_not \\n/gcx ? \"Not\\n\" . expr(8) . \";\\n\" :\n    /$h Op_add \\n/gcx ? expr(8) :\n    error \"A PRIMARY\";\n  $ast =                                           \n    $_[0] <= 7 && /$h Op_multiply \\n/gcx ? \"Multiply\\n$ast\" . expr(8) :\n    $_[0] <= 7 && /$h Op_divide \\n/gcx ? \"Divide\\n$ast\" . expr(8) :\n    $_[0] <= 7 && /$h Op_mod \\n/gcx ? \"Mod\\n$ast\" . expr(8) :\n    $_[0] <= 6 && /$h Op_add \\n/gcx ? \"Add\\n$ast\" . expr(7) :\n    $_[0] <= 6 && /$h Op_subtract \\n/gcx ? \"Subtract\\n$ast\" . expr(7) :\n    $_[0] == 5 && /(?=$h Op_(less|greater)(equal)? \\n)/gcx ? error 'NO ASSOC' :\n    $_[0] <= 5 && /$h Op_lessequal \\n/gcx ? \"LessEqual\\n$ast\" . expr(5) :\n    $_[0] <= 5 && /$h Op_less \\n/gcx ? \"Less\\n$ast\" . expr(5) :\n    $_[0] <= 5 && /$h Op_greater \\n/gcx ? \"Greater\\n$ast\" . expr(5) :\n    $_[0] <= 5 && /$h Op_greaterequal \\n/gcx ?  \"GreaterEqual\\n$ast\" . expr(5) :\n    $_[0] == 3 && /(?=$h Op_(not)?equal \\n)/gcx ? error 'NO ASSOC' :\n    $_[0] <= 3 && /$h Op_equal \\n/gcx ? \"Equal\\n$ast\" . expr(3) :\n    $_[0] <= 3 && /$h Op_notequal \\n/gcx ? \"NotEqual\\n$ast\" . expr(3) :\n    $_[0] <= 1 && /$h Op_and \\n/gcx ? \"And\\n$ast\" . expr(2) :\n    $_[0] <= 0 && /$h Op_or \\n/gcx ? \"Or\\n$ast\" . expr(1) :\n    return $ast while 1;\n  }\n", "target": "def expr(p)\n    if tok is \"(\"\n        x = paren_expr()\n    elif tok in [\"-\", \"+\", \"!\"]\n        gettok()\n        y = expr(precedence of operator)\n        if operator was \"+\"\n            x = y\n        else\n            x = make_node(operator, y)\n    elif tok is an Identifier\n        x = make_leaf(Identifier, variable name)\n        gettok()\n    elif tok is an Integer constant\n        x = make_leaf(Integer, integer value)\n        gettok()\n    else\n        error()\n\n    while tok is a binary operator and precedence of tok >= p\n        save_tok = tok\n        gettok()\n        q = precedence of save_tok\n        if save_tok is not right associative\n            q += 1\n        x = make_node(Operator save_tok represents, x, expr(q))\n\n    return x\n\ndef paren_expr()\n    expect(\"(\")\n    x = expr(0)\n    expect(\")\")\n    return x\n\ndef stmt()\n    t = NULL\n    if accept(\"if\")\n        e = paren_expr()\n        s = stmt()\n        t = make_node(If, e, make_node(If, s, accept(\"else\") ? stmt() : NULL))\n    elif accept(\"putc\")\n        t = make_node(Prtc, paren_expr())\n        expect(\";\")\n    elif accept(\"print\")\n        expect(\"(\")\n        repeat\n            if tok is a string\n                e = make_node(Prts, make_leaf(String, the string))\n                gettok()\n            else\n                e = make_node(Prti, expr(0))\n\n            t = make_node(Sequence, t, e)\n        until not accept(\",\")\n        expect(\")\")\n        expect(\";\")\n    elif tok is \";\"\n        gettok()\n    elif tok is an Identifier\n        v = make_leaf(Identifier, variable name)\n        gettok()\n        expect(\"=\")\n        t = make_node(Assign, v, expr(0))\n        expect(\";\")\n    elif accept(\"while\")\n        e = paren_expr()\n        t = make_node(While, e, stmt()\n    elif accept(\"{\")\n        while tok not equal \"}\" and tok not equal end-of-file\n            t = make_node(Sequence, t, stmt())\n        expect(\"}\")\n    elif tok is end-of-file\n        pass\n    else\n        error()\n    return t\n\ndef parse()\n    t = NULL\n    gettok()\n    repeat\n        t = make_node(Sequence, t, stmt())\n    until tok is end-of-file\n    return t\n"}
{"id": 383301, "name": "Compiler_syntax analyzer", "source": "Translate Perl to Python: \n\nuse strict;   \nuse warnings; \n\nmy $h = qr/\\G\\s*\\d+\\s+\\d+\\s+/;  \n\nsub error { die \"*** Expected @_ at \" . (/\\G(.*\\n)/ ?\n  $1 =~ s/^\\s*(\\d+)\\s+(\\d+)\\s+/line $1 character $2 got /r : \"EOF\\n\") }\n\nsub want { /$h \\Q$_[1]\\E.*\\n/gcx ? shift : error \"'$_[1]'\" }\n\nlocal $_ = join '', <>;\nprint want stmtlist(), 'End_of_input';\n\nsub stmtlist\n  {\n  /(?=$h (RightBrace|End_of_input))/gcx and return \";\\n\";\n  my ($stmt, $stmtlist) = (stmt(), stmtlist());\n  $stmtlist eq \";\\n\" ? $stmt : \"Sequence\\n$stmt$stmtlist\";\n  }\n\nsub stmt\n  {\n  /$h Semicolon\\n/gcx ? \";\\n\" :\n    /$h Identifier \\s+ (\\w+) \\n/gcx ? want(\"Assign\\nIdentifier\\t$1\\n\",\n      'Op_assign') . want expr(0), 'Semicolon' :\n    /$h Keyword_while \\n/gcx ? \"While\\n\" . parenexp() . stmt() :\n    /$h Keyword_if \\n/gcx ?  \"If\\n\" . parenexp() . \"If\\n\" . stmt() .\n      (/$h Keyword_else \\n/gcx ? stmt() : \";\\n\") :\n    /$h Keyword_print \\n/gcx ? want('', 'LeftParen') .\n      want want(printlist(), 'RightParen'), 'Semicolon' :\n    /$h Keyword_putc \\n/gcx ? want \"Prtc\\n\" . parenexp() . \";\\n\", 'Semicolon' :\n    /$h LeftBrace \\n/gcx ? want stmtlist(), 'RightBrace' :\n    error 'A STMT';\n  }\n\nsub parenexp { want('', 'LeftParen') . want expr(0), 'RightParen' } \n\nsub printlist\n  {\n  my $ast = /$h String \\s+ (\".*\") \\n/gcx ?\n    \"Prts\\nString\\t\\t$1\\n;\\n\" : \"Prti\\n\" . expr(0) . \";\\n\";\n  /$h Comma \\n/gcx ? \"Sequence\\n$ast\" . printlist() : $ast;\n  }\n\nsub expr               \n  {\n  my $ast =                                        \n    /$h Integer \\s+ (\\d+) \\n/gcx ? \"Integer\\t\\t$1\\n\" :\n    /$h Identifier \\s+ (\\w+) \\n/gcx ? \"Identifier\\t$1\\n\" :\n    /$h LeftParen \\n/gcx ? want expr(0), 'RightParen' :\n    /$h Op_(negate|subtract) \\n/gcx ? \"Negate\\n\" . expr(8) . \";\\n\" :\n    /$h Op_not \\n/gcx ? \"Not\\n\" . expr(8) . \";\\n\" :\n    /$h Op_add \\n/gcx ? expr(8) :\n    error \"A PRIMARY\";\n  $ast =                                           \n    $_[0] <= 7 && /$h Op_multiply \\n/gcx ? \"Multiply\\n$ast\" . expr(8) :\n    $_[0] <= 7 && /$h Op_divide \\n/gcx ? \"Divide\\n$ast\" . expr(8) :\n    $_[0] <= 7 && /$h Op_mod \\n/gcx ? \"Mod\\n$ast\" . expr(8) :\n    $_[0] <= 6 && /$h Op_add \\n/gcx ? \"Add\\n$ast\" . expr(7) :\n    $_[0] <= 6 && /$h Op_subtract \\n/gcx ? \"Subtract\\n$ast\" . expr(7) :\n    $_[0] == 5 && /(?=$h Op_(less|greater)(equal)? \\n)/gcx ? error 'NO ASSOC' :\n    $_[0] <= 5 && /$h Op_lessequal \\n/gcx ? \"LessEqual\\n$ast\" . expr(5) :\n    $_[0] <= 5 && /$h Op_less \\n/gcx ? \"Less\\n$ast\" . expr(5) :\n    $_[0] <= 5 && /$h Op_greater \\n/gcx ? \"Greater\\n$ast\" . expr(5) :\n    $_[0] <= 5 && /$h Op_greaterequal \\n/gcx ?  \"GreaterEqual\\n$ast\" . expr(5) :\n    $_[0] == 3 && /(?=$h Op_(not)?equal \\n)/gcx ? error 'NO ASSOC' :\n    $_[0] <= 3 && /$h Op_equal \\n/gcx ? \"Equal\\n$ast\" . expr(3) :\n    $_[0] <= 3 && /$h Op_notequal \\n/gcx ? \"NotEqual\\n$ast\" . expr(3) :\n    $_[0] <= 1 && /$h Op_and \\n/gcx ? \"And\\n$ast\" . expr(2) :\n    $_[0] <= 0 && /$h Op_or \\n/gcx ? \"Or\\n$ast\" . expr(1) :\n    return $ast while 1;\n  }\n", "target": "def expr(p)\n    if tok is \"(\"\n        x = paren_expr()\n    elif tok in [\"-\", \"+\", \"!\"]\n        gettok()\n        y = expr(precedence of operator)\n        if operator was \"+\"\n            x = y\n        else\n            x = make_node(operator, y)\n    elif tok is an Identifier\n        x = make_leaf(Identifier, variable name)\n        gettok()\n    elif tok is an Integer constant\n        x = make_leaf(Integer, integer value)\n        gettok()\n    else\n        error()\n\n    while tok is a binary operator and precedence of tok >= p\n        save_tok = tok\n        gettok()\n        q = precedence of save_tok\n        if save_tok is not right associative\n            q += 1\n        x = make_node(Operator save_tok represents, x, expr(q))\n\n    return x\n\ndef paren_expr()\n    expect(\"(\")\n    x = expr(0)\n    expect(\")\")\n    return x\n\ndef stmt()\n    t = NULL\n    if accept(\"if\")\n        e = paren_expr()\n        s = stmt()\n        t = make_node(If, e, make_node(If, s, accept(\"else\") ? stmt() : NULL))\n    elif accept(\"putc\")\n        t = make_node(Prtc, paren_expr())\n        expect(\";\")\n    elif accept(\"print\")\n        expect(\"(\")\n        repeat\n            if tok is a string\n                e = make_node(Prts, make_leaf(String, the string))\n                gettok()\n            else\n                e = make_node(Prti, expr(0))\n\n            t = make_node(Sequence, t, e)\n        until not accept(\",\")\n        expect(\")\")\n        expect(\";\")\n    elif tok is \";\"\n        gettok()\n    elif tok is an Identifier\n        v = make_leaf(Identifier, variable name)\n        gettok()\n        expect(\"=\")\n        t = make_node(Assign, v, expr(0))\n        expect(\";\")\n    elif accept(\"while\")\n        e = paren_expr()\n        t = make_node(While, e, stmt()\n    elif accept(\"{\")\n        while tok not equal \"}\" and tok not equal end-of-file\n            t = make_node(Sequence, t, stmt())\n        expect(\"}\")\n    elif tok is end-of-file\n        pass\n    else\n        error()\n    return t\n\ndef parse()\n    t = NULL\n    gettok()\n    repeat\n        t = make_node(Sequence, t, stmt())\n    until tok is end-of-file\n    return t\n"}
{"id": 383302, "name": "Snake and ladder", "source": "Translate Perl to Python: \nmy %snl =( 4, 14,  9, 31, 17,  7, 20, 38, 28, 84, 40, 59, 51, 67, 54, 34,\n          62, 19, 63, 81, 64, 60, 71, 91, 87, 24, 93, 73, 95, 75, 99, 78);\n\n@players = (1, 1, 1, 1); \n\nwhile () {\n    for $player (0..$\n       $turn_count++;\n       turn(\\$players[$player], $player + 1, $turn_count);\n    }\n}\n\nsub turn {\n    my($square, $player) = @_;\n    if ($player == @players) { print \"You are on square $$square. Hit enter to roll the die:\"; <> }\n    my $roll = 1 + int rand 6;\n    my $turn = $$square + $roll;\n    print \"Player $player on square %2d rolls a $roll\", $$square;\n    if ($turn > 100) {\n       print \" but cannot move. Next players turn.\\n\";\n       return\n    }\n    if ($snl{$turn}) {\n        $$square = $snl{$turn};\n        if ($turn > $$square) {\n           print \". Oops! Landed on a snake. Slither down to $$square.\\n\"\n        } else {\n           print \". Yay! Landed on a ladder. Climb up to $$square.\\n\"\n        }\n    } else {\n        $$square = $turn;\n        print \" and moves to square $$square\\n\";\n    }\n    if ($$square == 100) {print \"Player $player wins after $turn_count turns.\\n\"; exit }\n    return\n}\n", "target": "import random\nimport sys\n\nsnl = {\n    4: 14,\n    9: 31,\n    17: 7,\n    20: 38,\n    28: 84,\n    40: 59,\n    51: 67,\n    54: 34,\n    62: 19,\n    63: 81,\n    64: 60,\n    71: 91,\n    87: 24,\n    93: 73,\n    95: 75,\n    99: 78\n}\nsixesRollAgain = True\n\ndef turn(player, square):\n    while True:\n        roll = random.randint(1,6)\n        sys.stdout.write(\"Player {0} on square {1}, rolls a {2}\".format(player, square, roll))\n        if square + roll > 100:\n            print \" but cannot move.\"\n        else:\n            square += roll\n            print \" and moves to square {0}\".format(square)\n            if square == 100:\n                return 100\n            next = snl.get(square, square)\n            if square < next:\n                print \"Yay! landed on a ladder. Climb up to {0}.\".format(next)\n                if square == 100:\n                    return 100\n                square = next\n            elif square > next:\n                print \"Oops! Landed on a snake. Slither down to {0}.\".format(next)\n                square = next\n        if roll < 6 or not sixesRollAgain:\n            return square\n        print \"Rolled a 6 so roll again.\"\n\ndef main():\n    players = [1, 1, 1]\n    while True:\n        for i in range(0, 3):\n            ns = turn(i+1, players[i])\n            if ns == 100:\n                print \"Player {0} wins!\".format(i+1)\n                return\n            players[i] = ns;\n            print\n\nmain()\n"}
{"id": 383303, "name": "Snake and ladder", "source": "Translate Perl to Python: \nmy %snl =( 4, 14,  9, 31, 17,  7, 20, 38, 28, 84, 40, 59, 51, 67, 54, 34,\n          62, 19, 63, 81, 64, 60, 71, 91, 87, 24, 93, 73, 95, 75, 99, 78);\n\n@players = (1, 1, 1, 1); \n\nwhile () {\n    for $player (0..$\n       $turn_count++;\n       turn(\\$players[$player], $player + 1, $turn_count);\n    }\n}\n\nsub turn {\n    my($square, $player) = @_;\n    if ($player == @players) { print \"You are on square $$square. Hit enter to roll the die:\"; <> }\n    my $roll = 1 + int rand 6;\n    my $turn = $$square + $roll;\n    print \"Player $player on square %2d rolls a $roll\", $$square;\n    if ($turn > 100) {\n       print \" but cannot move. Next players turn.\\n\";\n       return\n    }\n    if ($snl{$turn}) {\n        $$square = $snl{$turn};\n        if ($turn > $$square) {\n           print \". Oops! Landed on a snake. Slither down to $$square.\\n\"\n        } else {\n           print \". Yay! Landed on a ladder. Climb up to $$square.\\n\"\n        }\n    } else {\n        $$square = $turn;\n        print \" and moves to square $$square\\n\";\n    }\n    if ($$square == 100) {print \"Player $player wins after $turn_count turns.\\n\"; exit }\n    return\n}\n", "target": "import random\nimport sys\n\nsnl = {\n    4: 14,\n    9: 31,\n    17: 7,\n    20: 38,\n    28: 84,\n    40: 59,\n    51: 67,\n    54: 34,\n    62: 19,\n    63: 81,\n    64: 60,\n    71: 91,\n    87: 24,\n    93: 73,\n    95: 75,\n    99: 78\n}\nsixesRollAgain = True\n\ndef turn(player, square):\n    while True:\n        roll = random.randint(1,6)\n        sys.stdout.write(\"Player {0} on square {1}, rolls a {2}\".format(player, square, roll))\n        if square + roll > 100:\n            print \" but cannot move.\"\n        else:\n            square += roll\n            print \" and moves to square {0}\".format(square)\n            if square == 100:\n                return 100\n            next = snl.get(square, square)\n            if square < next:\n                print \"Yay! landed on a ladder. Climb up to {0}.\".format(next)\n                if square == 100:\n                    return 100\n                square = next\n            elif square > next:\n                print \"Oops! Landed on a snake. Slither down to {0}.\".format(next)\n                square = next\n        if roll < 6 or not sixesRollAgain:\n            return square\n        print \"Rolled a 6 so roll again.\"\n\ndef main():\n    players = [1, 1, 1]\n    while True:\n        for i in range(0, 3):\n            ns = turn(i+1, players[i])\n            if ns == 100:\n                print \"Player {0} wins!\".format(i+1)\n                return\n            players[i] = ns;\n            print\n\nmain()\n"}
{"id": 383304, "name": "Farey sequence", "source": "Translate Perl to Python: use warnings;\nuse strict;\nuse Math::BigRat;\nuse ntheory qw/euler_phi vecsum/;\n\nsub farey {\n  my $N = shift;\n  my @f;\n  my($m0,$n0, $m1,$n1) = (0, 1, 1, $N);\n  push @f, Math::BigRat->new(\"$m0/$n0\");\n  push @f, Math::BigRat->new(\"$m1/$n1\");\n  while ($f[-1] < 1) {\n    my $m = int( ($n0 + $N) / $n1) * $m1 - $m0;\n    my $n = int( ($n0 + $N) / $n1) * $n1 - $n0;\n    ($m0,$n0, $m1,$n1) = ($m1,$n1, $m,$n);\n    push @f, Math::BigRat->new(\"$m/$n\");\n  }\n  @f;\n}\nsub farey_count { 1 + vecsum(euler_phi(1, shift)); }\n\nfor (1 .. 11) {\n  my @f = map { join \"/\", $_->parts }   \n          farey($_);\n  print \"F$_: [@f]\\n\";\n}\nfor (1 .. 10, 100000) {\n  print \"F${_}00: \", farey_count(100*$_), \" members\\n\";\n}\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 383305, "name": "Farey sequence", "source": "Translate Perl to Python: use warnings;\nuse strict;\nuse Math::BigRat;\nuse ntheory qw/euler_phi vecsum/;\n\nsub farey {\n  my $N = shift;\n  my @f;\n  my($m0,$n0, $m1,$n1) = (0, 1, 1, $N);\n  push @f, Math::BigRat->new(\"$m0/$n0\");\n  push @f, Math::BigRat->new(\"$m1/$n1\");\n  while ($f[-1] < 1) {\n    my $m = int( ($n0 + $N) / $n1) * $m1 - $m0;\n    my $n = int( ($n0 + $N) / $n1) * $n1 - $n0;\n    ($m0,$n0, $m1,$n1) = ($m1,$n1, $m,$n);\n    push @f, Math::BigRat->new(\"$m/$n\");\n  }\n  @f;\n}\nsub farey_count { 1 + vecsum(euler_phi(1, shift)); }\n\nfor (1 .. 11) {\n  my @f = map { join \"/\", $_->parts }   \n          farey($_);\n  print \"F$_: [@f]\\n\";\n}\nfor (1 .. 10, 100000) {\n  print \"F${_}00: \", farey_count(100*$_), \" members\\n\";\n}\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 383306, "name": "Aliquot sequence classifications", "source": "Translate Perl to Python: use ntheory qw/divisor_sum/;\n\nsub aliquot {\n  my($n, $maxterms, $maxn) = @_;\n  $maxterms = 16 unless defined $maxterms;\n  $maxn = 2**47 unless defined $maxn;\n\n  my %terms = ($n => 1);\n  my @allterms = ($n);\n  for my $term (2 .. $maxterms) {\n    $n = divisor_sum($n)-$n;\n    \n    last if $n > $maxn;\n    return (\"terminates\",@allterms, 0) if $n == 0;\n    if (defined $terms{$n}) {\n      return (\"perfect\",@allterms)  if $term == 2 && $terms{$n} == 1;\n      return (\"amicible\",@allterms) if $term == 3 && $terms{$n} == 1;\n      return (\"sociable-\".($term-1),@allterms) if $term >  3 && $terms{$n} == 1;\n      return (\"aspiring\",@allterms) if $terms{$n} == $term-1;\n      return (\"cyclic-\".($term-$terms{$n}),@allterms)   if $terms{$n} < $term-1;\n    }\n    $terms{$n} = $term;\n    push @allterms, $n;\n  }\n  (\"non-term\",@allterms);\n}\n\nfor my $n (1..10) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\nprint \"\\n\";\nfor my $n (qw/11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080/) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 383307, "name": "Aliquot sequence classifications", "source": "Translate Perl to Python: use ntheory qw/divisor_sum/;\n\nsub aliquot {\n  my($n, $maxterms, $maxn) = @_;\n  $maxterms = 16 unless defined $maxterms;\n  $maxn = 2**47 unless defined $maxn;\n\n  my %terms = ($n => 1);\n  my @allterms = ($n);\n  for my $term (2 .. $maxterms) {\n    $n = divisor_sum($n)-$n;\n    \n    last if $n > $maxn;\n    return (\"terminates\",@allterms, 0) if $n == 0;\n    if (defined $terms{$n}) {\n      return (\"perfect\",@allterms)  if $term == 2 && $terms{$n} == 1;\n      return (\"amicible\",@allterms) if $term == 3 && $terms{$n} == 1;\n      return (\"sociable-\".($term-1),@allterms) if $term >  3 && $terms{$n} == 1;\n      return (\"aspiring\",@allterms) if $terms{$n} == $term-1;\n      return (\"cyclic-\".($term-$terms{$n}),@allterms)   if $terms{$n} < $term-1;\n    }\n    $terms{$n} = $term;\n    push @allterms, $n;\n  }\n  (\"non-term\",@allterms);\n}\n\nfor my $n (1..10) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\nprint \"\\n\";\nfor my $n (qw/11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080/) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 383308, "name": "Implicit type conversion", "source": "Translate Perl to Python: print  1  + '2';  \nprint '1' + '2';  \nprint  1  .  1;   \n\n$a = 1;\n$b = 2;\nsay \"$a+$b\";  \n\n\nsay hex int( (2 . 0 x '2') ** substr 98.5, '2', '2' ) . 'beef'; \n", "target": "from fractions import Fraction\nfrom decimal import Decimal, getcontext\ngetcontext().prec = 60\nfrom itertools import product\n\ncasting_functions = [int, float, complex,   \n                     Fraction, Decimal,     \n                     hex, oct, bin,         \n                     bool,                  \n                     iter,                  \n                     list, tuple, range,    \n                     str, bytes,            \n                     bytearray,             \n                     set, frozenset,        \n                     dict,                  \n                    ]\n\nexamples_of_types = [0, 42, \n                     0.0 -0.0, 12.34, 56.0, \n                     (0+0j), (1+2j), (1+0j), (78.9+0j), (0+1.2j),\n                     Fraction(0, 1), Fraction(22, 7), Fraction(4, 2), \n                     Decimal('0'),\n                     Decimal('3.14159265358979323846264338327950288419716939937510'),\n                     Decimal('1'), Decimal('1.5'),\n                     True, False,\n                     iter(()), iter([1, 2, 3]), iter({'A', 'B', 'C'}), \n                     iter([[1, 2], [3, 4]]), iter((('a', 1), (2, 'b'))),\n                     [], [1, 2], [[1, 2], [3, 4]],\n                     (), (1, 'two', (3+0j)), (('a', 1), (2, 'b')),\n                     range(0), range(3),\n                     \"\", \"A\", \"ABBA\", \"Mil\u00fc\",\n                     b\"\", b\"A\", b\"ABBA\",\n                     bytearray(b\"\"), bytearray(b\"A\"), bytearray(b\"ABBA\"),\n                     set(), {1, 'two', (3+0j), (4, 5, 6)},\n                     frozenset(), frozenset({1, 'two', (3+0j), (4, 5, 6)}),\n                     {}, {1: 'one', 'two': (2+3j), ('RC', 3): None} \n                    ]\nif __name__ == '__main__':\n    print('Common Python types/type casting functions:')\n    print('  ' + '\\n  '.join(f.__name__ for f in casting_functions))\n    print('\\nExamples of those types:')\n    print('  ' + '\\n  '.join('%-26s %r' % (type(e), e) for e in examples_of_types))\n    print('\\nCasts of the examples:')\n    for f, e in product(casting_functions, examples_of_types):\n        try:\n            ans = f(e)\n        except BaseException:\n            ans = 'EXCEPTION RAISED!'\n        print('%-60s -> %r' % ('%s(%r)' % (f.__name__, e), ans))\n"}
{"id": 383309, "name": "Implicit type conversion", "source": "Translate Perl to Python: print  1  + '2';  \nprint '1' + '2';  \nprint  1  .  1;   \n\n$a = 1;\n$b = 2;\nsay \"$a+$b\";  \n\n\nsay hex int( (2 . 0 x '2') ** substr 98.5, '2', '2' ) . 'beef'; \n", "target": "from fractions import Fraction\nfrom decimal import Decimal, getcontext\ngetcontext().prec = 60\nfrom itertools import product\n\ncasting_functions = [int, float, complex,   \n                     Fraction, Decimal,     \n                     hex, oct, bin,         \n                     bool,                  \n                     iter,                  \n                     list, tuple, range,    \n                     str, bytes,            \n                     bytearray,             \n                     set, frozenset,        \n                     dict,                  \n                    ]\n\nexamples_of_types = [0, 42, \n                     0.0 -0.0, 12.34, 56.0, \n                     (0+0j), (1+2j), (1+0j), (78.9+0j), (0+1.2j),\n                     Fraction(0, 1), Fraction(22, 7), Fraction(4, 2), \n                     Decimal('0'),\n                     Decimal('3.14159265358979323846264338327950288419716939937510'),\n                     Decimal('1'), Decimal('1.5'),\n                     True, False,\n                     iter(()), iter([1, 2, 3]), iter({'A', 'B', 'C'}), \n                     iter([[1, 2], [3, 4]]), iter((('a', 1), (2, 'b'))),\n                     [], [1, 2], [[1, 2], [3, 4]],\n                     (), (1, 'two', (3+0j)), (('a', 1), (2, 'b')),\n                     range(0), range(3),\n                     \"\", \"A\", \"ABBA\", \"Mil\u00fc\",\n                     b\"\", b\"A\", b\"ABBA\",\n                     bytearray(b\"\"), bytearray(b\"A\"), bytearray(b\"ABBA\"),\n                     set(), {1, 'two', (3+0j), (4, 5, 6)},\n                     frozenset(), frozenset({1, 'two', (3+0j), (4, 5, 6)}),\n                     {}, {1: 'one', 'two': (2+3j), ('RC', 3): None} \n                    ]\nif __name__ == '__main__':\n    print('Common Python types/type casting functions:')\n    print('  ' + '\\n  '.join(f.__name__ for f in casting_functions))\n    print('\\nExamples of those types:')\n    print('  ' + '\\n  '.join('%-26s %r' % (type(e), e) for e in examples_of_types))\n    print('\\nCasts of the examples:')\n    for f, e in product(casting_functions, examples_of_types):\n        try:\n            ans = f(e)\n        except BaseException:\n            ans = 'EXCEPTION RAISED!'\n        print('%-60s -> %r' % ('%s(%r)' % (f.__name__, e), ans))\n"}
{"id": 383310, "name": "Compiler_code generator", "source": "Translate Perl to Python: \n\nuse strict;   \nuse warnings; \n\nmy $stringcount = my $namecount = my $pairsym = my $pc = 0;\nmy (%strings, %names);\nmy %opnames = qw( Less lt LessEqual le Multiply mul Subtract sub Divide div\n  GreaterEqual ge Equal eq Greater gt NotEqual ne Negate neg );\n\nsub tree\n  {\n  my ($A, $B) = ( '_' . ++$pairsym, '_' . ++$pairsym ); \n  my $line = <> // return '';\n  (local $_, my $arg) = $line =~ /^(\\w+|;)\\s+(.*)/ or die \"bad input $line\";\n  /Identifier/ ? \"fetch [@{[ $names{$arg} //= $namecount++ ]}]\\n\" :\n    /Sequence/ ? tree() . tree() :\n    /Integer/  ? \"push  $arg\\n\" :\n    /String/   ? \"push  @{[ $strings{$arg} //= $stringcount++ ]}\\n\" :\n    /Assign/   ? join '', reverse tree() =~ s/fetch/store/r, tree() :\n    /While/    ? \"$A:\\n@{[ tree() ]}jz    $B\\n@{[ tree() ]}jmp   $A\\n$B:\\n\" :\n    /If/       ? tree() . \"jz    $A\\n@{[\u00a0!<> . \n                  tree() ]}jmp   $B\\n$A:\\n@{[ tree() ]}$B:\\n\" :\n    /;/        ? '' :\n    tree() . tree() . ($opnames{$_} // lc) . \"\\n\";\n  }\n\n$_ = tree() . \"halt\\n\";\n\ns/^jmp\\s+(\\S+)\\n(_\\d+:\\n)\\1:\\n/$2/gm;                \ns/^(?=[a-z]\\w*(.*))/                                 \n  (sprintf(\"%4d \", $pc), $pc += $1\u00a0? 5\u00a0: 1)[0] /gem;\nmy %labels = /^(_\\d+):(?=(?:\\n_\\d+:)*\\n *(\\d+) )/gm; \ns/^ *(\\d+) j(?:z|mp) *\\K(_\\d+)$/ (@{[                \n  $labels{$2} - $1 - 1]}) $labels{$2}/gm;\ns/^_\\d+.*\\n//gm;                                     \n\nprint \"Datasize: $namecount Strings: $stringcount\\n\";\nprint \"$_\\n\" for sort { $strings{$a} <=> $strings{$b} } keys %strings;\nprint;\n", "target": "def load_ast()\n    line = readline()\n    \n    line_list = tokenize the line, respecting double quotes\n\n    text = line_list[0] \n\n    if text == \";\"\n        return None\n\n    node_type = text \n\n    \n    \n    \n    if len(line_list) > 1\n        return make_leaf(node_type, line_list[1])\n\n    left = load_ast()\n    right = load_ast()\n    return make_node(node_type, left, right)\n"}
{"id": 383311, "name": "Compiler_code generator", "source": "Translate Perl to Python: \n\nuse strict;   \nuse warnings; \n\nmy $stringcount = my $namecount = my $pairsym = my $pc = 0;\nmy (%strings, %names);\nmy %opnames = qw( Less lt LessEqual le Multiply mul Subtract sub Divide div\n  GreaterEqual ge Equal eq Greater gt NotEqual ne Negate neg );\n\nsub tree\n  {\n  my ($A, $B) = ( '_' . ++$pairsym, '_' . ++$pairsym ); \n  my $line = <> // return '';\n  (local $_, my $arg) = $line =~ /^(\\w+|;)\\s+(.*)/ or die \"bad input $line\";\n  /Identifier/ ? \"fetch [@{[ $names{$arg} //= $namecount++ ]}]\\n\" :\n    /Sequence/ ? tree() . tree() :\n    /Integer/  ? \"push  $arg\\n\" :\n    /String/   ? \"push  @{[ $strings{$arg} //= $stringcount++ ]}\\n\" :\n    /Assign/   ? join '', reverse tree() =~ s/fetch/store/r, tree() :\n    /While/    ? \"$A:\\n@{[ tree() ]}jz    $B\\n@{[ tree() ]}jmp   $A\\n$B:\\n\" :\n    /If/       ? tree() . \"jz    $A\\n@{[\u00a0!<> . \n                  tree() ]}jmp   $B\\n$A:\\n@{[ tree() ]}$B:\\n\" :\n    /;/        ? '' :\n    tree() . tree() . ($opnames{$_} // lc) . \"\\n\";\n  }\n\n$_ = tree() . \"halt\\n\";\n\ns/^jmp\\s+(\\S+)\\n(_\\d+:\\n)\\1:\\n/$2/gm;                \ns/^(?=[a-z]\\w*(.*))/                                 \n  (sprintf(\"%4d \", $pc), $pc += $1\u00a0? 5\u00a0: 1)[0] /gem;\nmy %labels = /^(_\\d+):(?=(?:\\n_\\d+:)*\\n *(\\d+) )/gm; \ns/^ *(\\d+) j(?:z|mp) *\\K(_\\d+)$/ (@{[                \n  $labels{$2} - $1 - 1]}) $labels{$2}/gm;\ns/^_\\d+.*\\n//gm;                                     \n\nprint \"Datasize: $namecount Strings: $stringcount\\n\";\nprint \"$_\\n\" for sort { $strings{$a} <=> $strings{$b} } keys %strings;\nprint;\n", "target": "def load_ast()\n    line = readline()\n    \n    line_list = tokenize the line, respecting double quotes\n\n    text = line_list[0] \n\n    if text == \";\"\n        return None\n\n    node_type = text \n\n    \n    \n    \n    if len(line_list) > 1\n        return make_leaf(node_type, line_list[1])\n\n    left = load_ast()\n    right = load_ast()\n    return make_node(node_type, left, right)\n"}
{"id": 383312, "name": "Mersenne primes", "source": "Translate Perl to Python: use ntheory qw/forprimes is_mersenne_prime/;\nforprimes { is_mersenne_prime($_) && say } 1e9;\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 383313, "name": "Mersenne primes", "source": "Translate Perl to Python: use ntheory qw/forprimes is_mersenne_prime/;\nforprimes { is_mersenne_prime($_) && say } 1e9;\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 383314, "name": "Cubic special primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse  ntheory 'is_prime';\n\nmy @sp = my $previous = 2;\ndo {\n    my($next,$n);\n    while () { last if is_prime( $next = $previous + ++$n**3 ) }\n    push @sp, $next;\n    $previous = $next;\n} until $sp[-1] >= 15000;\n\npop @sp and say join ' ', @sp;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    p = 2\n    n = 1\n\n    print(\"2\",end = \" \")\n    while True:\n        if isPrime(p + n**3):\n            p += n**3\n            n = 1\n            print(p,end = \" \")\n        else:\n            n += 1\n        if p + n**3 >= 15000:\n            break\n"}
{"id": 383315, "name": "Cubic special primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse  ntheory 'is_prime';\n\nmy @sp = my $previous = 2;\ndo {\n    my($next,$n);\n    while () { last if is_prime( $next = $previous + ++$n**3 ) }\n    push @sp, $next;\n    $previous = $next;\n} until $sp[-1] >= 15000;\n\npop @sp and say join ' ', @sp;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    p = 2\n    n = 1\n\n    print(\"2\",end = \" \")\n    while True:\n        if isPrime(p + n**3):\n            p += n**3\n            n = 1\n            print(p,end = \" \")\n        else:\n            n += 1\n        if p + n**3 >= 15000:\n            break\n"}
{"id": 383316, "name": "Sexy primes", "source": "Translate Perl to Python: use ntheory qw/prime_iterator is_prime/;\n\nsub tuple_tail {\n    my($n,$cnt,@array) = @_;\n    $n = @array if $n > @array;\n    my @tail;\n    for (1..$n) {\n        my $p = $array[-$n+$_-1];\n        push @tail, \"(\" . join(\" \", map { $p+6*$_ } 0..$cnt-1) . \")\";\n    }\n    return @tail;\n}\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    ($s = reverse $s) =~ s/^,//;\n    return $s;\n}\n\nsub sexy_string { my $p = shift; is_prime($p+6) || is_prime($p-6) ? 'sexy' : 'unsexy' }\n\nmy $max = 1_000_035;\nmy $cmax = comma $max;\n\nmy $iter = prime_iterator;\nmy $p = $iter->();\nmy %primes;\npush @{$primes{sexy_string($p)}}, $p;\nwhile ( ($p = $iter->()) < $max) {\n    push @{$primes{sexy_string($p)}}, $p;\n    $p+ 6 < $max && is_prime($p+ 6) ? push @{$primes{'pair'}},       $p : next;\n    $p+12 < $max && is_prime($p+12) ? push @{$primes{'triplet'}},    $p : next;\n    $p+18 < $max && is_prime($p+18) ? push @{$primes{'quadruplet'}}, $p : next;\n    $p+24 < $max && is_prime($p+24) ? push @{$primes{'quintuplet'}}, $p : next;\n}\n\nprint \"Total primes less than $cmax: \" . comma(@{$primes{'sexy'}} + @{$primes{'unsexy'}}) . \"\\n\\n\";\n\nfor (['pair', 2], ['triplet', 3], ['quadruplet', 4], ['quintuplet', 5]) {\n    my($sexy,$cnt) = @$_;\n    print \"Number of sexy prime ${sexy}s less than $cmax: \" . comma(scalar @{$primes{$sexy}}) . \"\\n\";\n    print \"   Last 5 sexy prime ${sexy}s less than $cmax: \" . join(' ', tuple_tail(5,$cnt,@{$primes{$sexy}})) . \"\\n\";\n    print \"\\n\";\n}\n\nprint \"Number of unsexy primes less than $cmax: \". comma(scalar @{$primes{unsexy}}) . \"\\n\";\nprint \"  Last 10 unsexy primes less than $cmax: \". join(' ', @{$primes{unsexy}}[-10..-1]) . \"\\n\";\n", "target": "LIMIT = 1_000_035\ndef primes2(limit=LIMIT):\n    if limit < 2: return []\n    if limit < 3: return [2]\n    lmtbf = (limit - 3) // 2\n    buf = [True] * (lmtbf + 1)\n    for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n        if buf[i]:\n            p = i + i + 3\n            s = p * (i + 1) + i\n            buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]\n\nprimes = primes2(LIMIT +6)\nprimeset = set(primes)\nprimearray = [n in primeset for n in range(LIMIT)]\n\n\ns = [[] for x in range(4)]\nunsexy = []\n\nfor p in primes:\n    if p > LIMIT:\n        break\n    if p + 6 in primeset and p + 6 < LIMIT:\n        s[0].append((p, p+6))\n    elif p + 6 in primeset:\n        break\n    else:\n        if p - 6 not in primeset:\n            unsexy.append(p)\n        continue\n    if p + 12 in primeset and p + 12 < LIMIT:\n        s[1].append((p, p+6, p+12))\n    else:\n        continue\n    if p + 18 in primeset and p + 18 < LIMIT:\n        s[2].append((p, p+6, p+12, p+18))\n    else:\n        continue\n    if p + 24 in primeset and p + 24 < LIMIT:\n        s[3].append((p, p+6, p+12, p+18, p+24))\n\n\nprint('\"SEXY\" PRIME GROUPINGS:')\nfor sexy, name in zip(s, 'pairs triplets quadruplets quintuplets'.split()):\n    print(f'  {len(sexy)} {na (not isPrime(n-6))))) |> Array.ofSeq\nprintfn \"There are %d unsexy primes less than 1,000,035. The last 10 are:\" n.Length\nArray.skip (n.Length-10) n |> Array.iter(fun n->printf \"%d \" n); printfn \"\"\nlet ni=pCache |> Seq.takeWhile(fun n->nme} ending with ...')\n    for sx in sexy[-5:]:\n        print('   ',sx)\n\nprint(f'\\nThere are {len(unsexy)} unsexy primes ending with ...')\nfor usx in unsexy[-10:]:\n    print(' ',usx)\n"}
{"id": 383317, "name": "Taxicab numbers", "source": "Translate Perl to Python: my($beg, $end) = (@ARGV==0) ? (1,25) : (@ARGV==1) ? (1,shift) : (shift,shift);\n\nmy $lim = 1e14;  \nmy @basis = map { $_*$_*$_ } (1 .. int($lim ** (1.0/3.0) + 1));\nmy $paira = 2;  \n\nmy ($segsize, $low, $high, $i) = (500_000_000, 0, 0, 0);\n\nwhile ($i < $end) {\n  $low = $high+1;\n  die \"lim too low\" if $low > $lim;\n  $high = $low + $segsize - 1;\n  $high = $lim if $high > $lim;\n  foreach my $p (_find_pairs_segment(\\@basis, $paira, $low, $high,\n                 sub { sprintf(\"%4d^3 + %4d^3\", $_[0], $_[1]) })    ) {\n    $i++;\n    next if $i < $beg;\n    last if $i > $end;\n    my $n = shift @$p;\n    printf \"%4d: %10d  = %s\\n\", $i, $n, join(\"  = \", @$p);\n  }\n}\n\nsub _find_pairs_segment {\n  my($p, $len, $start, $end, $formatsub) = @_;\n  my $plen = $\n\n  my %allpairs;\n  foreach my $i (0 .. $plen) {\n    my $pi = $p->[$i];\n    next if ($pi+$p->[$plen]) < $start;\n    last if (2*$pi) > $end;\n    foreach my $j ($i .. $plen) {\n      my $sum = $pi + $p->[$j];\n      next if $sum < $start;\n      last if $sum > $end;\n      push @{ $allpairs{$sum} }, $i, $j;\n    }\n    \n    \n  }\n\n  my @retlist;\n  foreach my $list (grep { scalar @$_ >= $len*2 } values %allpairs) {\n    my $n = $p->[$list->[0]] + $p->[$list->[1]];\n    my @pairlist;\n    while (@$list) {\n      push @pairlist, $formatsub->(1 + shift @$list, 1 + shift @$list);\n    }\n    push @retlist, [$n, @pairlist];\n  }\n  @retlist = sort { $a->[0] <=> $b->[0] } @retlist;\n  return @retlist;\n}\n", "target": "from collections import defaultdict\nfrom itertools import product\nfrom pprint import pprint as pp\n\ncube2n = {x**3:x for x in range(1, 1201)}\nsum2cubes = defaultdict(set)\nfor c1, c2 in product(cube2n, cube2n):\n\tif c1 >= c2: sum2cubes[c1 + c2].add((cube2n[c1], cube2n[c2]))\n\t\ntaxied = sorted((k, v) for k,v in sum2cubes.items() if len(v) >= 2)\n\n\nfor t in enumerate(taxied[:25], 1):\n    pp(t)\nprint('...')    \nfor t in enumerate(taxied[2000-1:2000+6], 2000):\n    pp(t)\n"}
{"id": 383318, "name": "Strong and weak primes", "source": "Translate Perl to Python: use ntheory qw(primes vecfirst);\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    $s =~ s/,(-?)$/$1/;\n    $s = reverse $s;\n}\n\nsub below { my ($m, @a) = @_; vecfirst { $a[$_] > $m } 0..$\n\nmy (@strong, @weak, @balanced);\nmy @primes = @{ primes(10_000_019) };\n\nfor my $k (1 .. $\n    my $x = ($primes[$k - 1] + $primes[$k + 1]) / 2;\n    if    ($x > $primes[$k]) { push @weak,     $primes[$k] }\n    elsif ($x < $primes[$k]) { push @strong,   $primes[$k] }\n    else                     { push @balanced, $primes[$k] }\n}\n\nfor ([\\@strong,   'strong',   36, 1e6, 1e7],\n     [\\@weak,     'weak',     37, 1e6, 1e7],\n     [\\@balanced, 'balanced', 28, 1e6, 1e7]) {\n    my($pr, $type, $d, $c1, $c2) = @$_;\n    print \"\\nFirst $d $type primes:\\n\", join ' ', map { comma $_ } @$pr[0..$d-1], \"\\n\";\n    print \"Count of $type primes <=  @{[comma $c1]}:  \" . comma below($c1,@$pr) . \"\\n\";\n    print \"Count of $type primes <= @{[comma $c2]}: \"   . comma scalar @$pr . \"\\n\";\n}\n", "target": "import numpy as np\n\ndef primesfrom2to(n):\n    \n    \n    sieve = np.ones(n//3 + (n%6==2), dtype=np.bool)\n    sieve[0] = False\n    for i in range(int(n**0.5)//3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[      ((k*k)//3)      ::2*k] = False\n            sieve[(k*k+4*k-2*k*(i&1))//3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]\n\np = primes10m   = primesfrom2to(10_000_000)\ns = strong10m   = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t > (s + u) / 2]\nw = weak10m     = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t < (s + u) / 2]\nb = balanced10m = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t == (s + u) / 2]\n\nprint('The first   36   strong primes:', s[:36])\nprint('The   count   of the strong primes below   1,000,000:',\n      sum(1 for p in s if p < 1_000_000))\nprint('The   count   of the strong primes below  10,000,000:', len(s))\nprint('\\nThe first   37   weak primes:', w[:37])\nprint('The   count   of the weak   primes below   1,000,000:',\n      sum(1 for p in w if p < 1_000_000))\nprint('The   count   of the weak   primes below  10,000,000:', len(w))\nprint('\\n\\nThe first   10 balanced primes:', b[:10])\nprint('The   count   of balanced   primes below   1,000,000:',\n      sum(1 for p in b if p < 1_000_000))\nprint('The   count   of balanced   primes below  10,000,000:', len(b))\nprint('\\nTOTAL primes below   1,000,000:',\n      sum(1 for pr in p if pr < 1_000_000))\nprint('TOTAL primes below  10,000,000:', len(p))\n"}
{"id": 383319, "name": "Left factorials", "source": "Translate Perl to Python: \nuse 5.010;\nuse strict;\nuse warnings;\nuse bigint;\n\nsub leftfact {\n\tmy ($n) = @_;\n\tstate $cached = 0;\n\tstate $factorial = 1;\n\tstate $leftfact = 0;\n\tif( $n < $cached ) {\n\t\t($cached, $factorial, $leftfact) = (0, 1, 0);\n\t}\n\twhile( $n > $cached ) {\n\t\t$leftfact += $factorial;\n\t\t$factorial *= ++$cached;\n\t}\n\treturn $leftfact;\n}\n\nprintf \"!%d = %s\\n\", $_, leftfact($_) for 0 .. 10, map $_*10, 2..11;\nprintf \"!%d has %d digits.\\n\", $_, length leftfact($_) for map $_*1000, 1..10;\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 383320, "name": "Left factorials", "source": "Translate Perl to Python: \nuse 5.010;\nuse strict;\nuse warnings;\nuse bigint;\n\nsub leftfact {\n\tmy ($n) = @_;\n\tstate $cached = 0;\n\tstate $factorial = 1;\n\tstate $leftfact = 0;\n\tif( $n < $cached ) {\n\t\t($cached, $factorial, $leftfact) = (0, 1, 0);\n\t}\n\twhile( $n > $cached ) {\n\t\t$leftfact += $factorial;\n\t\t$factorial *= ++$cached;\n\t}\n\treturn $leftfact;\n}\n\nprintf \"!%d = %s\\n\", $_, leftfact($_) for 0 .. 10, map $_*10, 2..11;\nprintf \"!%d has %d digits.\\n\", $_, length leftfact($_) for map $_*1000, 1..10;\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 383321, "name": "Strange unique prime triplets", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'sum';\nuse ntheory <primes is_prime>;\nuse Algorithm::Combinatorics 'combinations';\n\nfor my $n (30, 1000) {\n    printf \"Found %d strange unique prime triplets up to $n.\\n\",\n        scalar grep { is_prime(sum @$_) } combinations(primes($n), 3);\n}\n", "target": "from sympy import primerange\n\ndef strange_triplets(mx: int = 30) -> None:\n    primes = list(primerange(0, mx))\n    primes3 = set(primerange(0, 3 * mx))\n    for i, n in enumerate(primes):\n        for j, m in enumerate(primes[i + 1:], i + 1):\n            for p in primes[j + 1:]:\n                if n + m + p in primes3:\n                    yield n, m, p\n\nfor c, (n, m, p) in enumerate(strange_triplets(), 1):\n    print(f\"{c:2}: {n:2}+{m:2}+{p:2} = {n + m + p}\")\n\nmx = 1_000\nprint(f\"\\nIf n, m, p < {mx:_} finds {sum(1 for _ in strange_triplets(mx)):_}\")\n"}
{"id": 383322, "name": "Strange unique prime triplets", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'sum';\nuse ntheory <primes is_prime>;\nuse Algorithm::Combinatorics 'combinations';\n\nfor my $n (30, 1000) {\n    printf \"Found %d strange unique prime triplets up to $n.\\n\",\n        scalar grep { is_prime(sum @$_) } combinations(primes($n), 3);\n}\n", "target": "from sympy import primerange\n\ndef strange_triplets(mx: int = 30) -> None:\n    primes = list(primerange(0, mx))\n    primes3 = set(primerange(0, 3 * mx))\n    for i, n in enumerate(primes):\n        for j, m in enumerate(primes[i + 1:], i + 1):\n            for p in primes[j + 1:]:\n                if n + m + p in primes3:\n                    yield n, m, p\n\nfor c, (n, m, p) in enumerate(strange_triplets(), 1):\n    print(f\"{c:2}: {n:2}+{m:2}+{p:2} = {n + m + p}\")\n\nmx = 1_000\nprint(f\"\\nIf n, m, p < {mx:_} finds {sum(1 for _ in strange_triplets(mx)):_}\")\n"}
{"id": 383323, "name": "Motzkin numbers", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nsub motzkin\n  {\n  my $N = shift;\n  my @m = ( 0, 1, 1 );\n  for my $i ( 3 .. $N )\n    {\n    $m[$i] = ($m[$i - 1] * (2 * $i - 1) + $m[$i - 2] * (3 * $i - 6)) / ($i + 1);\n    }\n  return splice @m, 1;\n  }\n\nprint \"  n          M[n]\\n\";\nmy $count = 0;\nfor ( motzkin(42) )\n  {\n  printf \"%3d%25s  %s\\n\", $count++, s/\\B(?=(\\d\\d\\d)+$)/,/gr,\n    is_prime($_) ? 'prime' : '';\n  }\n", "target": "\n\nfrom sympy import isprime\n\n\ndef motzkin(num_wanted):\n    \n    mot = [1] * (num_wanted + 1)\n    for i in range(2, num_wanted + 1):\n        mot[i] = (mot[i-1]*(2*i+1) + mot[i-2]*(3*i-3)) // (i + 2)\n    return mot\n\n\ndef print_motzkin_table(N=41):\n    \n    print(\n        \" n          M[n]             Prime?\\n-----------------------------------\")\n    for i, e in enumerate(motzkin(N)):\n        print(f'{i : 3}{e : 24,}', isprime(e))\n\n\nprint_motzkin_table()\n"}
{"id": 383324, "name": "Special neighbor primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( primes is_prime );\n\nmy @primes = @{ primes(100) };\nfor ( 1 .. $\n  {\n  is_prime( $@ = $primes[$_-1] + $primes[$_] - 1 ) and\n    printf \"%2d + %2d - 1 = %3d\\n\", $primes[$_-1], $primes[$_], $@;\n  }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef nextPrime(n):\n    \n    if n == 0:\n        return 2\n    if n < 3:\n        return n + 1\n    q = n + 2\n    while not isPrime(q):\n        q += 2\n    return q\n\n\nif __name__ == \"__main__\":\n    for p1 in range(3,100,2):\n        p2 = nextPrime(p1)\n        if isPrime(p1) and p2 < 100 and isPrime(p1 + p2 - 1):\n            print(p1,'\\t', p2,'\\t', p1 + p2 - 1)\n"}
{"id": 383325, "name": "Special neighbor primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( primes is_prime );\n\nmy @primes = @{ primes(100) };\nfor ( 1 .. $\n  {\n  is_prime( $@ = $primes[$_-1] + $primes[$_] - 1 ) and\n    printf \"%2d + %2d - 1 = %3d\\n\", $primes[$_-1], $primes[$_], $@;\n  }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef nextPrime(n):\n    \n    if n == 0:\n        return 2\n    if n < 3:\n        return n + 1\n    q = n + 2\n    while not isPrime(q):\n        q += 2\n    return q\n\n\nif __name__ == \"__main__\":\n    for p1 in range(3,100,2):\n        p2 = nextPrime(p1)\n        if isPrime(p1) and p2 < 100 and isPrime(p1 + p2 - 1):\n            print(p1,'\\t', p2,'\\t', p1 + p2 - 1)\n"}
{"id": 383326, "name": "Strange plus numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\n\nmy($low, $high) = (100, 500);\nmy $n = my @SP = grep { my @d = split ''; is_prime $d[0]+$d[1] and is_prime $d[1]+$d[2] } $low+1 .. $high-1;\nsay \"Between $low and $high there are $n strange-plus numbers:\\n\" .\n    (sprintf \"@{['%4d' x $n]}\", @SP[0..$n-1]) =~ s/(.{80})/$1\\n/gr;\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 383327, "name": "Strange plus numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\n\nmy($low, $high) = (100, 500);\nmy $n = my @SP = grep { my @d = split ''; is_prime $d[0]+$d[1] and is_prime $d[1]+$d[2] } $low+1 .. $high-1;\nsay \"Between $low and $high there are $n strange-plus numbers:\\n\" .\n    (sprintf \"@{['%4d' x $n]}\", @SP[0..$n-1]) =~ s/(.{80})/$1\\n/gr;\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 383328, "name": "Smarandache prime-digital sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\nuse ntheory qw<is_prime>;\nuse Lingua::EN::Numbers qw(num2en_ordinal);\n\nmy @prime_digits = <2 3 5 7>;\nmy @spds = grep { is_prime($_) && /^[@{[join '',@prime_digits]}]+$/ } 1..100;\nmy @p    = map { $_+3, $_+7 } map { 10*$_ } @prime_digits;\n\nwhile ($\n    state $o++;\n    my $oom = 10**(1+$o);\n    my @q;\n    for my $l (@prime_digits) {\n        push @q, map { $l*$oom + $_ } @p;\n    }\n    push @spds, grep { is_prime($_) } @p = @q;\n}\n\nsay 'Smarandache prime-digitals:';\nprintf \"%22s: %s\\n\", ucfirst(num2en_ordinal($_)), $spds[$_-1] for 1..25, 100, 1000, 10_000, 100_000;\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef is_prime(n):\n    return len(divisors(n)) == 2\n\n\ndef digit_check(n):\n    if len(str(n))<2:\n        return True\n    else:\n        for digit in str(n):\n            if not is_prime(int(digit)):\n                return False\n        return True\n\n\ndef sequence(max_n=None):\n    ii = 0\n    n = 0\n    while True:\n        ii += 1\n        if is_prime(ii):\n            if max_n is not None:\n                if n>max_n:\n                    break\n            if digit_check(ii):\n                n += 1\n                yield ii\n\n\nif __name__ == '__main__':\n    generator = sequence(100)\n    for index, item in zip(range(1, 16), generator):\n        print(index, item)\n    for index, item in zip(range(16, 100), generator):\n        pass\n    print(100, generator.__next__())\n"}
{"id": 383329, "name": "Plasma effect", "source": "Translate Perl to Python: use Imager;\n\nsub plasma {\n    my ($w, $h) = @_;\n\n    my $img = Imager->new(xsize => $w, ysize => $h);\n\n    for my $x (0 .. $w-1) {\n        for my $y (0 .. $h-1) {\n            my $hue = 4 + sin($x/19) + sin($y/9) + sin(($x+$y)/25) + sin(sqrt($x**2 + $y**2)/8);\n            $img->setpixel(x => $x, y => $y, color => {hsv => [360 * $hue / 8, 1, 1]});\n        }\n    }\n\n    return $img;\n}\n\nmy $img = plasma(400, 400);\n$img->write(file => 'plasma-perl.png');\n", "target": "\n\npal = [0] * 128\nr = 42\ng = 84\nb = 126\nrd = gd = bd = False\n\ndef setup():\n    global buffer\n    size(600, 600)\n    frameRate(25)\n    buffer = [None] * width * height\n    for x in range(width):\n        for y in range(width):\n            value = int(((128 + (128 * sin(x / 32.0)))\n                         + (128 + (128 * cos(y / 32.0)))\n                         + (128 + (128 * sin(sqrt((x * x + y * y)) / 32.0)))) / 4)\n            buffer[x + y * width] = value\n\ndef draw():\n    global r, g, b, rd, gd, bd\n    if r > 128: rd = True\n    if not rd: r += 1\n    else: r-=1\n    if r < 0: rd = False\n    if g > 128: gd = True\n    if not gd: g += 1\n    else: g- = 1\n    if r < 0: gd = False \n    if b > 128: bd = True\n    if not bd: b += 1\n    else: b- = 1\n    if b < 0: bd = False\n \n    for i in range(128):\n          s_1 = sin(i * PI / 25)\n          s_2 = sin(i * PI / 50 + PI / 4)\n          pal[i] = color(r + s_1 * 128, g + s_2 * 128, b + s_1 * 128)\n\n    loadPixels()\n    for i, b in enumerate(buffer):\n          pixels[i] = pal[(b + frameCount) % 127]\n    updatePixels()\n"}
{"id": 383330, "name": "Square-free integers", "source": "Translate Perl to Python: use ntheory qw/is_square_free moebius/;\n\nsub square_free_count {\n    my ($n) = @_;\n    my $count = 0;\n    foreach my $k (1 .. sqrt($n)) {\n        $count += moebius($k) * int($n / $k**2);\n    }\n    return $count;\n}\n\nprint \"Square\u2500free numbers between 1 and 145:\\n\";\nprint join(' ', grep { is_square_free($_) } 1 .. 145), \"\\n\";\n\nprint \"\\nSquare-free numbers between 10^12 and 10^12 + 145:\\n\";\nprint join(' ', grep { is_square_free($_) } 1e12 .. 1e12 + 145), \"\\n\";\n\nprint \"\\n\";\nforeach my $n (2 .. 6) {\n    my $c = square_free_count(10**$n);\n    print \"The number of square-free numbers between 1 and 10^$n (inclusive) is: $c\\n\";\n}\n", "target": "import math\n\ndef SquareFree ( _number ) :\n\tmax = (int) (math.sqrt ( _number ))\n\n\tfor root in range ( 2, max+1 ):\t\t\t\t\t\n\t\tif 0 == _number % ( root * root ):\n\t\t\treturn False\n\n\treturn True\n\ndef ListSquareFrees( _start, _end ):\n\tcount = 0\n\tfor i in range ( _start, _end+1 ):\n\t\tif True == SquareFree( i ):\n\t\t\tprint ( \"{}\\t\".format(i), end=\"\" )\n\t\t\tcount += 1\n\n\tprint ( \"\\n\\nTotal count of square-free numbers between {} and {}: {}\".format(_start, _end, count))\n\nListSquareFrees( 1, 100 )\nListSquareFrees( 1000000000000, 1000000000145 )\n"}
{"id": 383331, "name": "Self numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util qw(max sum);\n\nmy ($i, $pow, $digits, $offset, $lastSelf, @selfs)\n = ( 1,   10,       1,       9,         0,       );\n\nmy $final = 50;\n\nwhile () {\n   my $isSelf = 1;\n   my $sum = my $start = sum split //, max(($i-$offset), 0);\n   for ( my $j = $start; $j < $i; $j++ ) {\n      if ($j+$sum == $i) { $isSelf = 0 ; last }\n      ($j+1)%10 != 0 ? $sum++ : ( $sum = sum split '', ($j+1) );\n   }\n\n   if ($isSelf) {\n      push @selfs, $lastSelf = $i;\n      last if @selfs == $final;\n   }\n\n   next unless ++$i % $pow == 0;\n   $pow *= 10;\n   $offset = 9 * $digits++\n}\n\nsay \"The first 50 self numbers are:\\n\" . join ' ', @selfs;\n", "target": "class DigitSumer :\n    def __init__(self): \n        sumdigit = lambda n : sum( map( int,str( n )))\n        self.t = [sumdigit( i ) for i in xrange( 10000 )]\n    def __call__ ( self,n ):\n        r = 0\n        while n >= 10000 :\n            n,q = divmod( n,10000 )\n            r += self.t[q]\n        return r + self.t[n] \n\n\ndef self_numbers ():\n    d = DigitSumer()\n    s = set([])\n    i = 1\n    while 1 :\n        n = i + d( i )\n        if i in s :\n            s.discard( i )\n        else:\n            yield i\n        s.add( n )\n        i += 1\n\nimport time\np = 100\nt = time.time()\nfor i,s in enumerate( self_numbers(),1 ):\n    if i <= 50 : \n        print s,\n        if i == 50 : print\n    if i == p :\n        print '%7.1f sec  %9dth = %d'%( time.time()-t,i,s )\n        p *= 10\n"}
{"id": 383332, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'sum';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nmy ($index, $last, $gap, $count) = (0, 0, 0, 0);\nmy $threshold = 10_000_000;\n\nprint \"Gap    Index of gap  Starting Niven\\n\";\nwhile (1) {\n    $count++;\n    next unless 0 == $count % sum split //, $count;\n    if ((my $diff = $count - $last) > $gap) {\n        $gap = $diff;\n        printf \"%3d %15s %15s\\n\", $gap, $index > 1 ? comma $index : 1, $last > 1 ? comma $last : 1;\n    }\n    $last = $count;\n    last if ++$index >= $threshold;\n}\n", "target": "\n\n\n\n\n\ndef digit_sum(n, sum):\n    sum += 1\n    while n > 0 and n % 10 == 0:\n        sum -= 9\n        n /= 10\n    \n    return sum\n    \nprevious = 1\ngap = 0\nsum = 0\nniven_index = 0\ngap_index = 1\n \nprint(\"Gap index  Gap    Niven index    Niven number\")\n\nniven = 1\n\nwhile gap_index <= 22:\n    sum = digit_sum(niven, sum)\n    if niven % sum == 0:\n        if niven > previous + gap:\n            gap = niven - previous;\n            print('{0:9d} {1:4d}  {2:13d}     {3:11d}'.format(gap_index, gap, niven_index, previous))\n            gap_index += 1\n        previous = niven\n        niven_index += 1\n    niven += 1\n"}
{"id": 383333, "name": "Old Russian measure of length", "source": "Translate Perl to Python: sub convert {\n    my($magnitude, $unit) = @_;\n     my %factor = (\n        tochka     => 0.000254,\n        liniya     => 0.00254,\n        diuym      => 0.0254,\n        vershok    => 0.04445,\n        piad       => 0.1778,\n        fut        => 0.3048,\n        arshin     => 0.7112,\n        sazhen     => 2.1336,\n        versta     => 1066.8,\n        milia      => 7467.6,\n        centimeter => 0.01,\n        meter      => 1.0,\n        kilometer  => 1000.0,\n    );\n\n    my $base= $magnitude * $factor{$unit};\n    my $result .= \"$magnitude $unit to:\\n\";\n    for (sort { $factor{$a} <=> $factor{$b} } keys %factor) {\n        $result .= sprintf \"%10s: %s\\n\", $_, sigdig($base / $factor{$_}, 5) unless $_ eq $unit\n    }\n    return $result;\n}\n\nsub sigdig {\n    my($num,$sig) = @_;\n    return $num unless $num =~ /\\./;\n\n    $num =~ /([1-9]\\d*\\.?\\d*)/;\n    my $prefix = $`;\n    my $match  = $&;\n    $sig++ if $match =~ /\\./;\n    my $digits = substr $match, 0, $sig;\n    my $nextd  = substr $match, $sig, 1;\n    $digits =~ s/(.)$/{1+$1}/e if $nextd > 5;\n    return $prefix . $digits;\n}\n\nprint convert(1,'meter'), \"\\n\\n\";\nprint convert(1,'milia'), \"\\n\";\n", "target": "from sys import argv\n \nunit2mult = {\"arshin\": 0.7112, \"centimeter\": 0.01,     \"diuym\":   0.0254,\n             \"fut\":    0.3048, \"kilometer\":  1000.0,   \"liniya\":  0.00254,\n             \"meter\":  1.0,    \"milia\":      7467.6,   \"piad\":    0.1778,\n             \"sazhen\": 2.1336, \"tochka\":     0.000254, \"vershok\": 0.04445,\n             \"versta\": 1066.8}\n \nif __name__ == '__main__':\n    assert len(argv) == 3, 'ERROR. Need two arguments - number then units'\n    try:\n        value = float(argv[1])\n    except:\n        print('ERROR. First argument must be a (float) number')\n        raise\n    unit = argv[2]\n    assert unit in unit2mult, ( 'ERROR. Only know the following units: ' \n                                + ' '.join(unit2mult.keys()) )\n\n    print(\"%g %s to:\" % (value, unit))\n    for unt, mlt in sorted(unit2mult.items()):\n        print('  %10s: %g' % (unt, value * unit2mult[unit] / mlt))\n"}
{"id": 383334, "name": "Minimum multiple of m where digital sum equals m", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( sumdigits );\n\nmy @answers = map\n  {\n  my $m = 1;\n  $m++ until sumdigits($m*$_) == $_;\n  $m;\n  } 1 .. 70;\nprint \"@answers\\n\\n\" =~ s/.{65}\\K /\\n/gr;\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef a131382():\n    \n    return (\n        elemIndex(x)(\n            productDigitSums(x)\n        ) for x in count(1)\n    )\n\n\n\ndef productDigitSums(n):\n    \n    return (digitSum(n * x) for x in count(0))\n\n\n\n\ndef main():\n    \n\n    print(\n        table(10)([\n            str(x) for x in islice(\n                a131382(),\n                40\n            )\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitSum(n):\n    \n    return sum(int(x) for x in list(str(n)))\n\n\n\ndef elemIndex(x):\n    \n    def go(xs):\n        try:\n            return next(\n                i for i, v in enumerate(xs) if x == v\n            )\n        except StopIteration:\n            return None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383335, "name": "Pancake numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub pancake {\n    my($n) = @_;\n    my ($gap, $sum, $adj) = (2, 2, -1);\n    while ($sum < $n) { $sum += $gap = $gap * 2 - 1 and $adj++ }\n    $n + $adj;\n}\n\nmy $out;\n$out .= sprintf \"p(%2d) = %2d \", $_, pancake $_ for 1..20;\nsay $out =~ s/.{1,55}\\K /\\n/gr;\n\n\nsub pancake2 {\n    my ($n) = @_;\n    my $numStacks = 1;\n    my @goalStack = 1 .. $n;\n    my %newStacks = my %stacks = (join(' ',@goalStack), 0);\n    for my $k (1..1000) {\n        my %nextStacks;\n        for my $pos (2..$n) {\n            for my $key (keys %newStacks) {\n                my @arr = split ' ', $key;\n                my $cakes = join ' ', (reverse @arr[0..$pos-1]), @arr[$pos..$\n                $nextStacks{$cakes} = $k unless $stacks{$cakes};\n            }\n        }\n        %stacks = (%stacks, (%newStacks = %nextStacks));\n        my $perms    = scalar %stacks;\n        my %inverted = reverse %stacks;\n        return $k-1, $inverted{(sort keys %inverted)[-1]} if $perms == $numStacks;\n        $numStacks = $perms;\n   }\n}\n\nsay \"\\nThe maximum number of flips to sort a given number of elements is:\";\nfor my $n (1..9) {\n    my ($a,$b) = pancake2($n);\n    say \"pancake($n) = $a example: $b\";\n}\n", "target": "\nimport time\n\nfrom collections import deque\nfrom operator import itemgetter\nfrom typing import Tuple\n\nPancakes = Tuple[int, ...]\n\n\ndef flip(pancakes: Pancakes, position: int) -> Pancakes:\n    \n    return tuple([*reversed(pancakes[:position]), *pancakes[position:]])\n\n\ndef pancake(n: int) -> Tuple[Pancakes, int]:\n    \n    init_stack = tuple(range(1, n + 1))\n    stack_flips = {init_stack: 0}\n    queue = deque([init_stack])\n\n    while queue:\n        stack = queue.popleft()\n        flips = stack_flips[stack] + 1\n\n        for i in range(2, n + 1):\n            flipped = flip(stack, i)\n            if flipped not in stack_flips:\n                stack_flips[flipped] = flips\n                queue.append(flipped)\n\n    return max(stack_flips.items(), key=itemgetter(1))\n\n\nif __name__ == \"__main__\":\n    start = time.time()\n\n    for n in range(1, 10):\n        pancakes, p = pancake(n)\n        print(f\"pancake({n}) = {p:>2}. Example: {list(pancakes)}\")\n\n    print(f\"\\nTook {time.time() - start:.3} seconds.\")\n"}
{"id": 383336, "name": "Pythagorean quadruples", "source": "Translate Perl to Python: my $N = 2200;\npush @sq, $_**2 for 0 .. $N;\nmy @not = (0) x $N;\n@not[0] = 1;\n\n\nfor my $d (1 .. $N) {\n    my $last = 0;\n    for my $a (reverse ceiling($d/3) .. $d) {\n        for my $b (1 .. ceiling($a/2)) {\n            my $ab = $sq[$a] + $sq[$b];\n            last if $ab > $sq[$d];\n            my $x = sqrt($sq[$d] - $ab);\n            if ($x == int $x) {\n                $not[$d] = 1;\n                $last = 1;\n                last\n            }\n        }\n        last if $last;\n    }\n}\n\nsub ceiling { int $_[0] + 1 - 1e-15 }\n\nfor (0 .. $\n    $result .= \"$_ \" unless $not[$_]\n}\nprint \"$result\\n\"\n", "target": "def quad(top=2200):\n    r = [False] * top\n    ab = [False] * (top * 2)**2\n    for a in range(1, top):\n        for b in range(a, top):\n            ab[a * a + b * b] = True\n    s = 3\n    for c in range(1, top):\n        s1, s, s2 = s, s + 2, s + 2\n        for d in range(c + 1, top):\n            if ab[s1]:\n                r[d] = True\n            s1 += s2\n            s2 += 2\n    return [i for i, val in enumerate(r) if not val and i]\n    \nif __name__ == '__main__':\n    n = 2200\n    print(f\"Those values of d in 1..{n} that can't be represented: {quad(n)}\")\n"}
{"id": 383337, "name": "Sum and product puzzle", "source": "Translate Perl to Python: use List::Util qw(none);\n\nsub grep_unique {\n    my($by, @list) = @_;\n    my @seen;\n    for (@list) {\n        my $x = &$by(@$_);\n        $seen[$x]= defined $seen[$x] ? 0 : join ' ', @$_;\n    }\n    grep { $_ } @seen;\n}\n\nsub sums {\n    my($n) = @_;\n    my @sums;\n    push @sums, [$_, $n - $_] for 2 .. int $n/2;\n    @sums;\n}\n\nsub sum     { $_[0] + $_[1] }\nsub product { $_[0] * $_[1] }\n\nfor $i (2..97) {\n    push @all_pairs, map { [$i, $_] } $i + 1..98\n}\n\n\n%p_unique = map { $_ => 1 } grep_unique(\\&product, @all_pairs);\nfor my $p (@all_pairs) {\n    push @s_pairs, [@$p] if none { $p_unique{join ' ', @$_} } sums sum @$p;\n}\n\n\n@p_pairs = map { [split ' ', $_] } grep_unique(\\&product, @s_pairs);\n\n\n@final_pair = grep_unique(\\&sum, @p_pairs);\n\nprintf \"X = %d, Y = %d\\n\", split ' ', $final_pair[0];\n", "target": "\n\nfrom collections import Counter\n\ndef decompose_sum(s):\n    return [(a,s-a) for a in range(2,int(s/2+1))]\n\n\nall_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100)\n\n\nproduct_counts = Counter(c*d for c,d in all_pairs)\nunique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)\ns_pairs = [(a,b) for a,b in all_pairs if\n    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))]\n\n\nproduct_counts = Counter(c*d for c,d in s_pairs)\np_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1]\n\n\nsum_counts = Counter(c+d for c,d in p_pairs)\nfinal_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1]\n\nprint(final_pairs)\n"}
{"id": 383338, "name": "Superpermutation minimisation", "source": "Translate Perl to Python: use ntheory qw/forperm/;\nfor my $len (1..8) {\n  my($pre, $post, $t) = (\"\",\"\");\n  forperm {\n    $t = join \"\",@_;\n    $post .= $t      unless index($post ,$t) >= 0;\n    $pre = $t . $pre unless index($pre, $t) >= 0;\n  } $len;\n  printf \"%2d: %8d %8d\\n\", $len, length($pre), length($post);\n}\n", "target": "\"Generate a short Superpermutation of n characters A... as a string using various algorithms.\"\n\n\nfrom __future__ import print_function, division\n\nfrom itertools import permutations\nfrom math import factorial\nimport string\nimport datetime\nimport gc\n\n\n\nMAXN = 7\n\n\ndef s_perm0(n):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in permutations(allchars)]\n    sp, tofind = allperms[0], set(allperms[1:])\n    while tofind:\n        for skip in range(1, n):\n            for trial_add in (''.join(p) for p in permutations(sp[-n:][:skip])):\n                \n                trial_perm = (sp + trial_add)[-n:]\n                if trial_perm in tofind:\n                    \n                    sp += trial_add\n                    tofind.discard(trial_perm)\n                    trial_add = None    \n                    break\n            if trial_add is None:\n                break\n    assert all(perm in sp for perm in allperms) \n    return sp\n\ndef s_perm1(n):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in sorted(permutations(allchars))]\n    perms, sp = allperms[::], ''\n    while perms:\n        nxt = perms.pop()\n        if nxt not in sp:\n            sp += nxt\n    assert all(perm in sp for perm in allperms)\n    return sp\n\ndef s_perm2(n):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in sorted(permutations(allchars))]\n    perms, sp = allperms[::], ''\n    while perms:\n        nxt = perms.pop(0)\n        if nxt not in sp:\n            sp += nxt\n        if perms:\n            nxt = perms.pop(-1)\n            if nxt not in sp:\n                sp += nxt\n    assert all(perm in sp for perm in allperms)\n    return sp\n\ndef _s_perm3(n, cmp):\n    \n    allchars = string.ascii_uppercase[:n]\n    allperms = [''.join(p) for p in sorted(permutations(allchars))]\n    perms, sp = allperms[::], ''\n    while perms:\n        lastn = sp[-n:]\n        nxt = cmp(perms,\n                  key=lambda pm:\n                    sum((ch1 == ch2) for ch1, ch2 in zip(pm, lastn)))\n        perms.remove(nxt)\n        if nxt not in sp:\n            sp += nxt\n    assert all(perm in sp for perm in allperms)\n    return sp\n\ndef s_perm3_max(n):\n    \n    return _s_perm3(n, max)\n\ndef s_perm3_min(n):\n    \n    return _s_perm3(n, min)\n\n\nlongest = [factorial(n) * n for n in range(MAXN + 1)]\nweight, runtime = {}, {}\nprint(__doc__)\nfor algo in [s_perm0, s_perm1, s_perm2, s_perm3_max, s_perm3_min]:\n    print('\\n\n    print(algo.__doc__)\n    weight[algo.__name__], runtime[algo.__name__] = 1, datetime.timedelta(0)\n    for n in range(1, MAXN + 1):\n        gc.collect()\n        gc.disable()\n        t = datetime.datetime.now()\n        sp = algo(n)\n        t = datetime.datetime.now() - t\n        gc.enable()\n        runtime[algo.__name__] += t\n        lensp = len(sp)\n        wt = (lensp / longest[n]) ** 2\n        print('  For N=%i: SP length %5i Max: %5i Weight: %5.2f'\n              % (n, lensp, longest[n], wt))\n        weight[algo.__name__] *= wt\n    weight[algo.__name__] **= 1 / n  \n    weight[algo.__name__] = 1 / weight[algo.__name__]\n    print('%*s Overall Weight: %5.2f in %.1f seconds.'\n          % (29, '', weight[algo.__name__], runtime[algo.__name__].total_seconds()))\n\nprint('\\n\nprint('\\n'.join('%12s (%.3f)' % kv for kv in\n                sorted(weight.items(), key=lambda keyvalue: -keyvalue[1])))\n      \nprint('\\n\nprint('\\n'.join('%12s (%.3f)' % (k, v.total_seconds()) for k, v in\n                sorted(runtime.items(), key=lambda keyvalue: keyvalue[1])))\n"}
{"id": 383339, "name": "Test integerness", "source": "Translate Perl to Python: use Math::Complex;\n\nsub is_int {\n    my $number = shift;\n    \n    if (ref $number eq 'Math::Complex') {\n        return 0 if $number->Im != 0;\n        $number = $number->Re;\n    }\n    \n    return int($number) == $number;\n}\n\nfor (5, 4.1, sqrt(2), sqrt(4), 1.1e10, 3.0-0.0*i, 4-3*i, 5.6+0*i) {\n    printf \"%20s is%s an integer\\n\", $_, (is_int($_) ? \"\" : \" NOT\");\n}\n", "target": ">>> def isint(f): \n    return complex(f).imag == 0 and complex(f).real.is_integer()\n\n>>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))]\n[True, True, True, False, False, False]\n\n>>> \n...\n>>> isint(25.000000)\nTrue\n>>> isint(24.999999)\nFalse\n>>> isint(25.000100)\nFalse\n>>> isint(-2.1e120)\nTrue\n>>> isint(-5e-2)\nFalse\n>>> isint(float('nan'))\nFalse\n>>> isint(float('inf'))\nFalse\n>>> isint(5.0+0.0j)\nTrue\n>>> isint(5-5j)\nFalse\n"}
{"id": 383340, "name": "Sum of two adjacent numbers are primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'is_prime';\n\nmy($n,$c);\nwhile () { is_prime(1 + 2*++$n) and printf \"%2d + %2d = %2d\\n\", $n, $n+1, 1+2*$n and ++$c == 20 and last }\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == \"__main__\":\n    n = 0\n    num = 0\n\n    print('The first 20 pairs of numbers whose sum is prime:') \n    while True:\n        n += 1\n        suma = 2*n+1\n        if isPrime(suma):\n            num += 1\n            if num < 21:\n                print('{:2}'.format(n), \"+\", '{:2}'.format(n+1), \"=\", '{:2}'.format(suma))\n            else:\n                break\n"}
{"id": 383341, "name": "Largest difference between adjacent primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Primesieve qw(generate_primes);\n\nfor my $n (2..8) {\n    my @primes = generate_primes (1, 10**$n);\n    my($max,$p,$diff) = 0;\n    map { ($diff = $primes[$_] - $primes[$_-1]) > $max and ($max,$p) = ($diff,$_-1) } 1..$\n    printf \"Largest prime gap up to %d: %d - between %d and %d.\\n\", 10**$n, $max, @primes[$p,$p+1];\n}\n", "target": "print(\"working...\")\nlimit = 1000000\nres1 = 0\nres2 = 0\nmaxOld = 0\nnewDiff = 0\noldDiff = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\nfor n in range(limit):\n    newDiff = n - maxOld\n    if isprime(n):\n       if (newDiff > oldDiff):\n       \t  res1 = n\n       \t  res2 = maxOld\n          oldDiff = newDiff\n       maxOld = n\n\ndiff = res1 - res2\nprint(res1)\nprint(res2)\nprint(\"Largest difference is = \",end=\"\")\nprint(diff)\nprint(\"done...\")\n"}
{"id": 383342, "name": "Linux CPU utilization", "source": "Translate Perl to Python: $last_total = 0;\n$last_idle  = 0;\n\nwhile () {\n    @cpu = split /\\s+/, `head -1 /proc/stat`;\n    shift @cpu;\n    $this_total  = 0;\n    $this_total += $_ for @cpu;\n    $delta_total = $this_total - $last_total;\n    $this_idle   = $cpu[3]     - $last_idle;\n    $delta_idle  = $this_idle  - $last_idle;\n    $last_total  = $this_total;\n    $last_idle   = $this_idle;\n    printf \"Utilization: %0.1f%%\\n\", 100 * (1 - $delta_idle / $delta_total);\n    sleep 1;\n}\n", "target": "from __future__ import print_function\nfrom time import sleep\n\n\nlast_idle = last_total = 0\nwhile True:\n    with open('/proc/stat') as f:\n        fields = [float(column) for column in f.readline().strip().split()[1:]]\n    idle, total = fields[3], sum(fields)\n    idle_delta, total_delta = idle - last_idle, total - last_total\n    last_idle, last_total = idle, total\n    utilisation = 100.0 * (1.0 - idle_delta / total_delta)\n    print('%5.1f%%' % utilisation, end='\\r')\n    sleep(5)\n"}
{"id": 383343, "name": "Ulam numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say state>;\n\nsub ulam {\n    my($n) = @_;\n    state %u     = (1 => 1, 2 => 1);\n    state @ulams = <0 1 2>; \n\n    return $ulams[$n] if $ulams[$n];\n\n    $n++;\n    my $i = 3;\n\n    while () {\n        my $count = 0;\n \n            $u{ $i - $ulams[$_] }\n        and $ulams[$_] != $i - $ulams[$_]\n        and $count++ > 2\n        and last\n            for 0..$\n\n            $count == 2\n        and push(@ulams,$i)\n        and $u{$i} = 1\n        and @ulams == $n\n        and last;\n\n        $i++;\n    }\n    $ulams[$n-1];\n}\n\nprintf \"The %dth Ulam number is: %d\\n\", 10**$_, ulam(10**$_) for 1..4;\n", "target": "import time\n\ndef ulam(n):\n    if n <= 2:\n        return n\n    mx = 1352000\n    lst = [1, 2] + [0] * mx\n    sums = [0] * (mx * 2 + 1)\n    sums[3] = 1\n    size = 2\n    while size < n:\n        query = lst[size-1] + 1\n        while True:\n            if sums[query] == 1:\n                for i in range(size):\n                    sum = query + lst[i]\n                    t = sums[sum] + 1\n                    if t <= 2:\n                        sums[sum] = t\n                lst[size], size = query, size + 1\n                break\n            query += 1\n    return query\n \nt0 = time.time()\nfor p in range(5):\n    n = 10**p\n    print(f\"The {n}{'th' if n!=1 else 'st'} Ulam number is {ulam(n)}\")\n\nprint(\"\\nElapsed time:\", time.time() - t0)\n"}
{"id": 383344, "name": "Ramsey's theorem", "source": "Translate Perl to Python: use ntheory qw(forcomb);\nuse Math::Cartesian::Product;\n\n$n = 17;\npush @a, [(0) x $n] for 0..$n-1;\n$a[$_][$_] = '-' for 0..$n-1;\n\nfor $x (cartesian {@_} [(0..$n-1)], [(1,2,4,8)]) {\n    $i = @$x[0];\n    $k = @$x[1];\n    $j = ($i + $k) % $n;\n    $a[$i][$j] = $a[$j][$i] = 1;\n}\n\nforcomb {\n    my $l = 0;\n    @i = @_;\n    forcomb { $l += $a[ $i[$_[0]] ][ $i[$_[1]] ]; } (4,2);\n    die \"Bogus!\" unless 0 < $l and $l < 6;\n} ($n,4);\n\nprint join(' ' ,@$_) . \"\\n\" for @a;\nprint 'OK'\n", "target": "range17 = range(17)\na = [['0'] * 17 for i in range17]\nidx = [0] * 4\n\n\ndef find_group(mark, min_n, max_n, depth=1):\n    if (depth == 4):\n        prefix = \"\" if (mark == '1') else \"un\"\n        print(\"Fail, found totally {}connected group:\".format(prefix))\n        for i in range(4):\n            print(idx[i])\n        return True\n\n    for i in range(min_n, max_n):\n        n = 0\n        while (n < depth):\n            if (a[idx[n]][i] != mark):\n                break\n            n += 1\n\n        if (n == depth):\n            idx[n] = i\n            if (find_group(mark, 1, max_n, depth + 1)):\n                return True\n\n    return False\n\n\nif __name__ == '__main__':\n    for i in range17:\n        a[i][i] = '-'\n    for k in range(4):\n        for i in range17:\n            j = (i + pow(2, k)) % 17\n            a[i][j] = a[j][i] = '1'\n\n    \n    \n\n    for row in a:\n        print(' '.join(row))\n\n    for i in range17:\n        idx[0] = i\n        if (find_group('1', i + 1, 17) or find_group('0', i + 1, 17)):\n            print(\"no good\")\n            exit()\n\n    print(\"all good\")\n"}
{"id": 383345, "name": "Smallest power of 6 whose decimal expansion contains n", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'first';\nuse Math::AnyNum ':overload';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nfor my $n (0..21, 314159) {\n    my $e = first { 6**$_ =~ /$n/ } 0..1000;\n    printf \"%7d:  6^%-3s  %s\\n\", $n, $e, comma 6**$e;\n}\n", "target": "def smallest_six(n):\n    p = 1\n    while str(n) not in str(p): p *= 6\n    return p\n    \nfor n in range(22):\n    print(\"{:2}: {}\".format(n, smallest_six(n)))\n"}
{"id": 383346, "name": "Summation of primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( primes );\nuse List::Util qw( sum );\n\nprint sum( @{ primes( 2e6 ) } ), \"\\n\";\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    suma = 2\n    n = 1\n    for i in range(3, 2000000, 2):\n        if isPrime(i):\n            suma += i\n            n+=1 \n    print(suma)\n"}
{"id": 383347, "name": "Safe primes and unsafe primes", "source": "Translate Perl to Python: use ntheory qw(forprimes is_prime);\n\nmy $upto = 1e7;\nmy %class = ( safe => [], unsafe => [2] );\n\nforprimes {\n    push @{$class{ is_prime(($_-1)>>1) ? 'safe' : 'unsafe' }}, $_;\n} 3, $upto;\n\nfor (['safe', 35], ['unsafe', 40]) {\n    my($type, $quantity) = @$_;\n    print  \"The first $quantity $type primes are:\\n\";\n    print join(\" \", map { comma($class{$type}->[$_-1]) } 1..$quantity), \"\\n\";\n    for my $q ($upto/10, $upto) {\n        my $n = scalar(grep { $_ <= $q } @{$class{$type}});\n        printf \"The number of $type primes up to %s: %s\\n\", comma($q), comma($n);\n    }\n}\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    $s =~ s/,(-?)$/$1/;\n    $s = reverse $s;\n}\n", "target": "primes =[]\nsp =[]\nusp=[]\nn = 10000000\nif 2<n:\n    primes.append(2)\nfor i in range(3,n+1,2):\n    for j in primes:\n        if(j>i/2) or (j==primes[-1]):\n            primes.append(i)\n            if((i-1)/2) in primes:\n                sp.append(i)\n                break\n            else:\n                usp.append(i)\n                break\n        if (i%j==0):\n            break\n\nprint('First 35 safe primes are:\\n' , sp[:35])\nprint('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')\nprint('There are '+str(len(sp))+' safe primes below 10,000,000')\nprint('First 40 unsafe primes:\\n',usp[:40])\nprint('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')\nprint('There are '+str(len(usp))+' safe primes below 10,000,000')\n"}
{"id": 383348, "name": "Hash join", "source": "Translate Perl to Python: use Data::Dumper qw(Dumper);\n\nsub hashJoin {\n    my ($table1, $index1, $table2, $index2) = @_;\n    my %h;\n    \n    foreach my $s (@$table1) {\n\tpush @{ $h{$s->[$index1]} }, $s;\n    }\n    \n    map { my $r = $_;\n\t  map [$_, $r], @{ $h{$r->[$index2]} }\n    } @$table2;\n}\n\n@table1 = ([27, \"Jonah\"],\n           [18, \"Alan\"],\n           [28, \"Glory\"],\n           [18, \"Popeye\"],\n           [28, \"Alan\"]);\n@table2 = ([\"Jonah\", \"Whales\"],\n           [\"Jonah\", \"Spiders\"],\n           [\"Alan\", \"Ghosts\"],\n           [\"Alan\", \"Zombies\"],\n           [\"Glory\", \"Buffy\"]);\n\n$Data::Dumper::Indent = 0;\nforeach my $row (hashJoin(\\@table1, 1, \\@table2, 0)) {\n    print Dumper($row), \"\\n\";\n}\n", "target": "from collections import defaultdict\n\ndef hashJoin(table1, index1, table2, index2):\n    h = defaultdict(list)\n    \n    for s in table1:\n        h[s[index1]].append(s)\n    \n    return [(s, r) for r in table2 for s in h[r[index2]]]\n\ntable1 = [(27, \"Jonah\"),\n          (18, \"Alan\"),\n          (28, \"Glory\"),\n          (18, \"Popeye\"),\n          (28, \"Alan\")]\ntable2 = [(\"Jonah\", \"Whales\"),\n          (\"Jonah\", \"Spiders\"),\n          (\"Alan\", \"Ghosts\"),\n          (\"Alan\", \"Zombies\"),\n          (\"Glory\", \"Buffy\")]\n\nfor row in hashJoin(table1, 1, table2, 0):\n    print(row)\n"}
{"id": 383349, "name": "Giuga numbers", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( factor forcomposites );\nuse List::Util qw( all );\n\nforcomposites\n  {\n  my $n = $_;\n  all { ($n / $_ - 1) % $_ == 0 } factor $n and print \"$n\\n\";\n  } 4, 67000;\n", "target": "\n\nfrom math import sqrt\n\ndef isGiuga(m):\n    n = m\n    f = 2\n    l = sqrt(n)\n    while True:\n        if n % f == 0:\n            if ((m / f) - 1) % f != 0:\n                return False\n            n /= f\n            if f > n:\n                return True\n        else:\n            f += 1\n            if f > l:\n                return False\n\n\nif __name__ == '__main__':\n    n = 3\n    c = 0\n    print(\"The first 4 Giuga numbers are: \")\n    while c < 4:\n        if isGiuga(n):\n            c += 1\n            print(n)\n        n += 1\n"}
{"id": 383350, "name": "Permutations with repetitions", "source": "Translate Perl to Python: use Algorithm::Combinatorics qw/tuples_with_repetition/;\nprint join(\" \", map { \"[@$_]\" } tuples_with_repetition([qw/A B C/],2)), \"\\n\";\n", "target": "\n\nfrom itertools import product\n\n\n\ndef replicateM(n):\n    \n    def rep(m):\n        def go(x):\n            return [[]] if 1 > x else (\n                liftA2List(lambda a, b: [a] + b)(m)(go(x - 1))\n            )\n        return go(n)\n    return lambda m: rep(m)\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(showList)(\n\n            replicateM(2)\n\n        )([[1, 2, 3], 'abc'])\n    )\n\n\n\n\n\ndef liftA2List(f):\n    \n    return lambda xs: lambda ys: [\n        f(*xy) for xy in product(xs, ys)\n    ]\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(\n        showList(x) if isinstance(x, list) else repr(x) for x in xs\n    ) + ']'\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383351, "name": "Permutations with repetitions", "source": "Translate Perl to Python: use Algorithm::Combinatorics qw/tuples_with_repetition/;\nprint join(\" \", map { \"[@$_]\" } tuples_with_repetition([qw/A B C/],2)), \"\\n\";\n", "target": "\n\nfrom itertools import product\n\n\n\ndef replicateM(n):\n    \n    def rep(m):\n        def go(x):\n            return [[]] if 1 > x else (\n                liftA2List(lambda a, b: [a] + b)(m)(go(x - 1))\n            )\n        return go(n)\n    return lambda m: rep(m)\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(showList)(\n\n            replicateM(2)\n\n        )([[1, 2, 3], 'abc'])\n    )\n\n\n\n\n\ndef liftA2List(f):\n    \n    return lambda xs: lambda ys: [\n        f(*xy) for xy in product(xs, ys)\n    ]\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(\n        showList(x) if isinstance(x, list) else repr(x) for x in xs\n    ) + ']'\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383352, "name": "Quadrat special primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse  ntheory 'is_prime';\n\nmy @sp = my $previous = 2;\ndo {\n    my($next,$n);\n    while () { last if is_prime( $next = $previous + ++$n**2 ) }\n    push @sp, $next;\n    $previous = $next;\n} until $sp[-1] >= 16000;\n\npop @sp and say ((sprintf '%-7d'x@sp, @sp) =~ s/.{1,$\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 2\n    j = 1\n    print(2, end = \" \");\n    while True:\n        while True:\n            if isPrime(p + j*j):\n                break\n            j += 1\n        p += j*j\n        if p > 16000:\n            break\n        print(p, end = \" \");\n        j = 1\n"}
{"id": 383353, "name": "Quadrat special primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse  ntheory 'is_prime';\n\nmy @sp = my $previous = 2;\ndo {\n    my($next,$n);\n    while () { last if is_prime( $next = $previous + ++$n**2 ) }\n    push @sp, $next;\n    $previous = $next;\n} until $sp[-1] >= 16000;\n\npop @sp and say ((sprintf '%-7d'x@sp, @sp) =~ s/.{1,$\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 2\n    j = 1\n    print(2, end = \" \");\n    while True:\n        while True:\n            if isPrime(p + j*j):\n                break\n            j += 1\n        p += j*j\n        if p > 16000:\n            break\n        print(p, end = \" \");\n        j = 1\n"}
{"id": 383354, "name": "Compiler_virtual machine interpreter", "source": "Translate Perl to Python: \n\n\nuse strict; \nuse warnings;\nuse integer;\n\nmy ($binary, $pc, @stack, @data) = ('', 0);\n\n<> =~ /Strings: (\\d+)/ or die \"bad header\";\nmy @strings = map <> =~ tr/\\n\"\"//dr =~ s/\\\\(.)/$1 eq 'n'\u00a0? \"\\n\"\u00a0: $1/ger, 1..$1;\n\nsub value { unpack 'l', substr $binary, ($pc += 4) - 4, 4 }\n\nmy @ops = (\n  [ halt  => sub { exit } ],\n  [ add   => sub { $stack[-2] += pop @stack } ],\n  [ sub   => sub { $stack[-2] -= pop @stack } ],\n  [ mul   => sub { $stack[-2] *= pop @stack } ],\n  [ div   => sub { $stack[-2] /= pop @stack } ],\n  [ mod   => sub { $stack[-2] %= pop @stack } ],\n  [ not   => sub { $stack[-1] = $stack[-1] ? 0 : 1 } ],\n  [ neg   => sub { $stack[-1] = - $stack[-1] } ],\n  [ and   => sub { $stack[-2] &&= $stack[-1]; pop @stack } ],\n  [ or    => sub { $stack[-2] ||= $stack[-1]; pop @stack } ],\n  [ lt    => sub { $stack[-1] = $stack[-2] <  pop @stack ? 1 : 0 } ],\n  [ gt    => sub { $stack[-1] = $stack[-2] >  pop @stack ? 1 : 0 } ],\n  [ le    => sub { $stack[-1] = $stack[-2] <= pop @stack ? 1 : 0 } ],\n  [ ge    => sub { $stack[-1] = $stack[-2] >= pop @stack ? 1 : 0 } ],\n  [ ne    => sub { $stack[-1] = $stack[-2] != pop @stack ? 1 : 0 } ],\n  [ eq    => sub { $stack[-1] = $stack[-2] == pop @stack ? 1 : 0 } ],\n  [ prts  => sub { print $strings[pop @stack] } ],\n  [ prti  => sub { print pop @stack } ],\n  [ prtc  => sub { print chr pop @stack } ],\n  [ store => sub { $data[value()] = pop @stack } ],\n  [ fetch => sub { push @stack, $data[value()] // 0 } ],\n  [ push  => sub { push @stack, value() } ],\n  [ jmp   => sub { $pc += value() - 4 } ],\n  [ jz    => sub { $pc += pop @stack ? 4 : value() - 4 } ],\n  );\nmy %op2n = map { $ops[$_][0], $_ } 0..$\n\nwhile(<>)\n  {\n  /^ *\\d+ +(\\w+)/ or die \"bad line $_\";                 \n  $binary .= chr( $op2n{$1} // die \"$1 not defined\" ) . \n    (/\\((-?\\d+)\\)|(\\d+)]?$/ and pack 'l', $+);          \n  }\n\n$ops[vec($binary, $pc++, 8)][1]->() while 1;            \n", "target": "def run_vm(data_size)\n    int stack[data_size + 1000]\n    set stack[0..data_size - 1] to 0\n    int pc = 0\n    while True:\n        op = code[pc]\n        pc += 1\n\n        if op == FETCH:\n            stack.append(stack[bytes_to_int(code[pc:pc+word_size])[0]]);\n            pc += word_size\n        elif op == STORE:\n            stack[bytes_to_int(code[pc:pc+word_size])[0]] = stack.pop();\n            pc += word_size\n        elif op == PUSH:\n            stack.append(bytes_to_int(code[pc:pc+word_size])[0]);\n            pc += word_size\n        elif op == ADD:   stack[-2] += stack[-1]; stack.pop()\n        elif op == SUB:   stack[-2] -= stack[-1]; stack.pop()\n        elif op == MUL:   stack[-2] *= stack[-1]; stack.pop()\n        elif op == DIV:   stack[-2] /= stack[-1]; stack.pop()\n        elif op == MOD:   stack[-2] %= stack[-1]; stack.pop()\n        elif op == LT:    stack[-2] = stack[-2] <  stack[-1]; stack.pop()\n        elif op == GT:    stack[-2] = stack[-2] >  stack[-1]; stack.pop()\n        elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()\n        elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()\n        elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()\n        elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()\n        elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()\n        elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()\n        elif op == NEG:   stack[-1] = -stack[-1]\n        elif op == NOT:   stack[-1] = not stack[-1]\n        elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]\n        elif op == JZ:    if stack.pop() then pc += word_size else pc += bytes_to_int(code[pc:pc+word_size])[0]\n        elif op == PRTC:  print stack[-1] as a character; stack.pop()\n        elif op == PRTS:  print the constant string referred to by stack[-1]; stack.pop()\n        elif op == PRTI:  print stack[-1] as an integer; stack.pop()\n        elif op == HALT:  break\n"}
{"id": 383355, "name": "Compiler_virtual machine interpreter", "source": "Translate Perl to Python: \n\n\nuse strict; \nuse warnings;\nuse integer;\n\nmy ($binary, $pc, @stack, @data) = ('', 0);\n\n<> =~ /Strings: (\\d+)/ or die \"bad header\";\nmy @strings = map <> =~ tr/\\n\"\"//dr =~ s/\\\\(.)/$1 eq 'n'\u00a0? \"\\n\"\u00a0: $1/ger, 1..$1;\n\nsub value { unpack 'l', substr $binary, ($pc += 4) - 4, 4 }\n\nmy @ops = (\n  [ halt  => sub { exit } ],\n  [ add   => sub { $stack[-2] += pop @stack } ],\n  [ sub   => sub { $stack[-2] -= pop @stack } ],\n  [ mul   => sub { $stack[-2] *= pop @stack } ],\n  [ div   => sub { $stack[-2] /= pop @stack } ],\n  [ mod   => sub { $stack[-2] %= pop @stack } ],\n  [ not   => sub { $stack[-1] = $stack[-1] ? 0 : 1 } ],\n  [ neg   => sub { $stack[-1] = - $stack[-1] } ],\n  [ and   => sub { $stack[-2] &&= $stack[-1]; pop @stack } ],\n  [ or    => sub { $stack[-2] ||= $stack[-1]; pop @stack } ],\n  [ lt    => sub { $stack[-1] = $stack[-2] <  pop @stack ? 1 : 0 } ],\n  [ gt    => sub { $stack[-1] = $stack[-2] >  pop @stack ? 1 : 0 } ],\n  [ le    => sub { $stack[-1] = $stack[-2] <= pop @stack ? 1 : 0 } ],\n  [ ge    => sub { $stack[-1] = $stack[-2] >= pop @stack ? 1 : 0 } ],\n  [ ne    => sub { $stack[-1] = $stack[-2] != pop @stack ? 1 : 0 } ],\n  [ eq    => sub { $stack[-1] = $stack[-2] == pop @stack ? 1 : 0 } ],\n  [ prts  => sub { print $strings[pop @stack] } ],\n  [ prti  => sub { print pop @stack } ],\n  [ prtc  => sub { print chr pop @stack } ],\n  [ store => sub { $data[value()] = pop @stack } ],\n  [ fetch => sub { push @stack, $data[value()] // 0 } ],\n  [ push  => sub { push @stack, value() } ],\n  [ jmp   => sub { $pc += value() - 4 } ],\n  [ jz    => sub { $pc += pop @stack ? 4 : value() - 4 } ],\n  );\nmy %op2n = map { $ops[$_][0], $_ } 0..$\n\nwhile(<>)\n  {\n  /^ *\\d+ +(\\w+)/ or die \"bad line $_\";                 \n  $binary .= chr( $op2n{$1} // die \"$1 not defined\" ) . \n    (/\\((-?\\d+)\\)|(\\d+)]?$/ and pack 'l', $+);          \n  }\n\n$ops[vec($binary, $pc++, 8)][1]->() while 1;            \n", "target": "def run_vm(data_size)\n    int stack[data_size + 1000]\n    set stack[0..data_size - 1] to 0\n    int pc = 0\n    while True:\n        op = code[pc]\n        pc += 1\n\n        if op == FETCH:\n            stack.append(stack[bytes_to_int(code[pc:pc+word_size])[0]]);\n            pc += word_size\n        elif op == STORE:\n            stack[bytes_to_int(code[pc:pc+word_size])[0]] = stack.pop();\n            pc += word_size\n        elif op == PUSH:\n            stack.append(bytes_to_int(code[pc:pc+word_size])[0]);\n            pc += word_size\n        elif op == ADD:   stack[-2] += stack[-1]; stack.pop()\n        elif op == SUB:   stack[-2] -= stack[-1]; stack.pop()\n        elif op == MUL:   stack[-2] *= stack[-1]; stack.pop()\n        elif op == DIV:   stack[-2] /= stack[-1]; stack.pop()\n        elif op == MOD:   stack[-2] %= stack[-1]; stack.pop()\n        elif op == LT:    stack[-2] = stack[-2] <  stack[-1]; stack.pop()\n        elif op == GT:    stack[-2] = stack[-2] >  stack[-1]; stack.pop()\n        elif op == LE:    stack[-2] = stack[-2] <= stack[-1]; stack.pop()\n        elif op == GE:    stack[-2] = stack[-2] >= stack[-1]; stack.pop()\n        elif op == EQ:    stack[-2] = stack[-2] == stack[-1]; stack.pop()\n        elif op == NE:    stack[-2] = stack[-2] != stack[-1]; stack.pop()\n        elif op == AND:   stack[-2] = stack[-2] and stack[-1]; stack.pop()\n        elif op == OR:    stack[-2] = stack[-2] or  stack[-1]; stack.pop()\n        elif op == NEG:   stack[-1] = -stack[-1]\n        elif op == NOT:   stack[-1] = not stack[-1]\n        elif op == JMP:   pc += bytes_to_int(code[pc:pc+word_size])[0]\n        elif op == JZ:    if stack.pop() then pc += word_size else pc += bytes_to_int(code[pc:pc+word_size])[0]\n        elif op == PRTC:  print stack[-1] as a character; stack.pop()\n        elif op == PRTS:  print the constant string referred to by stack[-1]; stack.pop()\n        elif op == PRTI:  print stack[-1] as an integer; stack.pop()\n        elif op == HALT:  break\n"}
{"id": 383356, "name": "Euclid-Mullin sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <factor vecprod vecmin>;\n\nmy @Euclid_Mullin = 2;\npush @Euclid_Mullin, vecmin factor (1 + vecprod @Euclid_Mullin) for 2..16+11;\n\nsay \"First sixteen: @Euclid_Mullin[ 0..15]\";\nsay \"Next eleven:   @Euclid_Mullin[16..26]\";\n", "target": "\n\nfrom primePy import primes\n\ndef euclid_mullin():\n    \n    total = 1\n    while True:\n        next_iter = primes.factor(total + 1)\n        total *= next_iter\n        yield next_iter\n\nGEN = euclid_mullin()\nprint('First 16 Euclid-Mullin numbers:', ', '.join(str(next(GEN)) for _ in range(16)))\n"}
{"id": 383357, "name": "Euclid-Mullin sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <factor vecprod vecmin>;\n\nmy @Euclid_Mullin = 2;\npush @Euclid_Mullin, vecmin factor (1 + vecprod @Euclid_Mullin) for 2..16+11;\n\nsay \"First sixteen: @Euclid_Mullin[ 0..15]\";\nsay \"Next eleven:   @Euclid_Mullin[16..26]\";\n", "target": "\n\nfrom primePy import primes\n\ndef euclid_mullin():\n    \n    total = 1\n    while True:\n        next_iter = primes.factor(total + 1)\n        total *= next_iter\n        yield next_iter\n\nGEN = euclid_mullin()\nprint('First 16 Euclid-Mullin numbers:', ', '.join(str(next(GEN)) for _ in range(16)))\n"}
{"id": 383358, "name": "Hourglass puzzle", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'bitwise';\n\nfindinterval( $_, 4, 7 ) for 1 .. 20;\n\nsub findinterval\n  {\n  my ($want, $hour1, $hour2) = @_;\n  local $_ = (('1' |. ' ' x $hour1) x $hour2 | ('2' |. ' ' x $hour2) x $hour1) x $want;\n  print /(?=\\d).{$want}(?=\\d)/\n    ? \"To get $want minute@{[$want == 1\u00a0? ''\u00a0: 's'\n      ]}, Start at time $-[0] and End at time $+[0]\\n\"\n    : \"$want is not possible\\n\";\n  }\n", "target": "def hourglass_puzzle():\n    t4 = 0\n    while t4 < 10_000:\n        t7_left = 7 - t4 % 7\n        if t7_left == 9 - 4:\n            break\n        t4 += 4\n    else:\n        print('Not found')\n        return \n    print(f)\n \nhourglass_puzzle()\n"}
{"id": 383359, "name": "Hourglass puzzle", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'bitwise';\n\nfindinterval( $_, 4, 7 ) for 1 .. 20;\n\nsub findinterval\n  {\n  my ($want, $hour1, $hour2) = @_;\n  local $_ = (('1' |. ' ' x $hour1) x $hour2 | ('2' |. ' ' x $hour2) x $hour1) x $want;\n  print /(?=\\d).{$want}(?=\\d)/\n    ? \"To get $want minute@{[$want == 1\u00a0? ''\u00a0: 's'\n      ]}, Start at time $-[0] and End at time $+[0]\\n\"\n    : \"$want is not possible\\n\";\n  }\n", "target": "def hourglass_puzzle():\n    t4 = 0\n    while t4 < 10_000:\n        t7_left = 7 - t4 % 7\n        if t7_left == 9 - 4:\n            break\n        t4 += 4\n    else:\n        print('Not found')\n        return \n    print(f)\n \nhourglass_puzzle()\n"}
{"id": 383360, "name": "Largest product in a grid", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( max );\n\n$_ = <<END;\n08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08\n49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00\n81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65\n52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91\n22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80\n24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50\n32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70\n67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21\n24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72\n21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95\n78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92\n16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57\n86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58\n19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40\n04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66\n88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69\n04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36\n20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16\n20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54\n01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48\nEND\n\nmy $score = 0;\nfor my $gap ( qr/ /, qr/.{58}/s )\n  {\n  $score = max $score, $1 * $2 * $3 * $4\n    while /(?=(\\d\\d)$gap(\\d\\d)$gap(\\d\\d)$gap(\\d\\d))/g;\n  }\nprint \"max is $score\\n\";\n", "target": "\n\nfrom math import prod\n\ndef maxproduct(mat, length):\n    \n    nrow, ncol = len(mat), len(mat[0])\n    maxprod, maxrow, maxcol, arr = 0, [0, 0], [0, 0], [0]\n    for row in range(nrow):\n        for col in range(ncol):\n            row2, col2 = row + length, col + length\n            if row < nrow - length:\n                array = [r[col] for r in mat[row:row2]]\n                pro = prod(array)\n                if pro > maxprod:\n                    maxprod, maxrow, maxcol, arr = pro, [row, row2], col, array\n            if col < ncol - length:\n                pro = prod(mat[row][col:col2])\n                if pro > maxprod:\n                    maxprod, maxrow, maxcol, arr = pro, row, [col, col2], mat[row][col:col2]\n\n    print(f\"The max {length}-product is {maxprod}, product of {arr} at row {maxrow}, col {maxcol}.\")\n\nMATRIX = [\n    [ 8,  2, 22, 97, 38, 15,  0, 40,  0, 75,  4,  5,  7, 78, 52, 12, 50, 77, 91,  8],\n    [49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48,  4, 56, 62,  0],\n    [81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30,  3, 49, 13, 36, 65],\n    [52, 70, 95, 23,  4, 60, 11, 42, 69, 24, 68, 56,  1, 32, 56, 71, 37,  2, 36, 91],\n    [22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80],\n    [24, 47, 32, 60, 99,  3, 45,  2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50],\n    [32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70],\n    [67, 26, 20, 68,  2, 62, 12, 20, 95, 63, 94, 39, 63,  8, 40, 91, 66, 49, 94, 21],\n    [24, 55, 58,  5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72],\n    [21, 36, 23,  9, 75,  0, 76, 44, 20, 45, 35, 14,  0, 61, 33, 97, 34, 31, 33, 95],\n    [78, 17, 53, 28, 22, 75, 31, 67, 15, 94,  3, 80,  4, 62, 16, 14,  9, 53, 56, 92],\n    [16, 39,  5, 42, 96, 35, 31, 47, 55, 58, 88, 24,  0, 17, 54, 24, 36, 29, 85, 57],\n    [86, 56,  0, 48, 35, 71, 89,  7,  5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58],\n    [19, 80, 81, 68,  5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77,  4, 89, 55, 40],\n    [ 4, 52,  8, 83, 97, 35, 99, 16,  7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66],\n    [88, 36, 68, 87, 57, 62, 20, 72,  3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69],\n    [ 4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18,  8, 46, 29, 32, 40, 62, 76, 36],\n    [20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74,  4, 36, 16],\n    [20, 73, 35, 29, 78, 31, 90,  1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57,  5, 54],\n    [ 1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52,  1, 89, 19, 67, 48]\n]\n\nfor n in range(2, 6):\n    maxproduct(MATRIX, n)\n"}
{"id": 383361, "name": "Terminal control_Preserve screen", "source": "Translate Perl to Python: print \"\\033[?1049h\\033[H\";\nprint \"Alternate screen buffer\\n\";\n\nfor (my $i = 5; $i > 0; --$i) {\n    print \"going back in $i...\\n\";\n    sleep(1);\n}\n\nprint \"\\033[?1049l\";\n", "target": "\n\nimport time\n\nprint \"\\033[?1049h\\033[H\"\nprint \"Alternate buffer!\"\n\nfor i in xrange(5, 0, -1):\n    print \"Going back in:\", i\n    time.sleep(1)\n\nprint \"\\033[?1049l\"\n"}
{"id": 383362, "name": "Find largest left truncatable prime in a given base", "source": "Translate Perl to Python: use ntheory qw/:all/;\nuse Math::GMPz;\n\nsub lltp {\n  my($n, $b, $best) = (shift, Math::GMPz->new(1));\n  my @v = map { Math::GMPz->new($_) } @{primes($n-1)};\n  while (@v) {\n    $best = vecmax(@v);\n    $b *= $n;\n    my @u;\n    foreach my $vi (@v) {\n      push @u, grep { is_prob_prime($_) } map { $vi + $_*$b } 1 .. $n-1;\n    }\n    @v = @u;\n  }\n  die unless is_provable_prime($best);\n  $best;\n}\n\nprintf \"%2d %s\\n\", $_, lltp($_)  for 3 .. 17;\n", "target": "import random\n\ndef is_probable_prime(n,k):\n    \n    if n==0 or n==1:\n        return False\n    if n==2:\n        return True\n    if n % 2 == 0:\n        return False\n    s = 0\n    d = n-1\n\n    while True:\n        quotient, remainder = divmod(d, 2)\n        if remainder == 1:\n            break\n        s += 1\n        d = quotient\n\n    def try_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True \n \n    for i in range(k):\n        a = random.randrange(2, n)\n        if try_composite(a):\n            return False\n \n    return True \n    \n    \ndef largest_left_truncatable_prime(base):    \n    radix = 0\n    candidates = [0]\n    while True:\n        new_candidates=[]\n        multiplier = base**radix\n        for i in range(1,base):\n            new_candidates += [x+i*multiplier for x in candidates if is_probable_prime(x+i*multiplier,30)]\n        if len(new_candidates)==0:\n            return max(candidates)\n        candidates = new_candidates\n        radix += 1\n\nfor b in range(3,24):\n    print(\"%d:%d\\n\" % (b,largest_left_truncatable_prime(b)))\n"}
{"id": 383363, "name": "Speech synthesis", "source": "Translate Perl to Python: use Speech::Synthesis;\n\n($engine) = Speech::Synthesis->InstalledEngines();\n($voice) = Speech::Synthesis->InstalledVoices(engine => $engine);\n\nSpeech::Synthesis\n  ->new(engine => $engine, voice => $voice->{id})\n  ->speak(\"This is an example of speech synthesis.\");\n", "target": "import pyttsx\n\nengine = pyttsx.init()\nengine.say(\"It was all a dream.\")\nengine.runAndWait()\n"}
{"id": 383364, "name": "24 game_Solve", "source": "Translate Perl to Python: \n\nsub permute :prototype(&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 383365, "name": "24 game_Solve", "source": "Translate Perl to Python: \n\nsub permute :prototype(&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 383366, "name": "Main step of GOST 28147-89", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'fromdigits';\n\n\nmy @sbox = (\n    [4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3],\n    [14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9],\n    [5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11],\n    [7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3],\n    [6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2],\n    [4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14],\n    [13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12],\n    [1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12]\n);\n\nsub rol32 {\n    my($y, $n) = @_;\n    ($y << $n) % 2**32 | ($y >> (32 - $n))\n}\n\nsub GOST_round {\n    my($R, $K) = @_;\n    my $a = ($R + $K) % 2**32;\n    my $b = fromdigits([map { $sbox[$_][($a >> (4*$_))%16] } reverse 0..7],16);\n    rol32($b,11);\n}\n\nsub feistel_step {\n    my($F, $L, $R, $K) = @_;\n    $R, $L ^ &$F($R, $K)\n}\n\nmy @input = (0x21, 0x04, 0x3B, 0x04, 0x30, 0x04, 0x32, 0x04);\nmy @key   = (0xF9, 0x04, 0xC1, 0xE2);\n\nmy $R = fromdigits([reverse @input[0..3]], 256); \nmy $L = fromdigits([reverse @input[4..7]], 256); \nmy $K = fromdigits([reverse @key        ], 256);\n\n($L,$R) = feistel_step(\\&GOST_round, $L, $R, $K);\n\nprintf '%02X ', (($L << 32) + $R >> (8*$_))%256 for 0..7;\nprint \"\\n\";\n", "target": "k8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n"}
{"id": 383367, "name": "Hough transform", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Imager;\n\nuse constant pi => 3.14159265;\n\nsub hough {\n    my($im)     = shift;\n    my($width)  = shift || 460;\n    my($height) = shift || 360;\n    $height = 2 * int $height/2;\n \n    $height = 2 * int $height/2;\n    my($xsize, $ysize) = ($im->getwidth, $im->getheight);\n    my $ht = Imager->new(xsize => $width, ysize => $height);\n    my @canvas;\n    for my $i (0..$height-1) { for my $j (0..$width-1) { $canvas[$i][$j] = 255 } }\n    $ht->box(filled => 1, color => 'white');\n\n    my $rmax = sqrt($xsize**2 + $ysize**2);\n    my $dr   = 2 * $rmax / $height;\n    my $dth  = pi / $width;\n\n    for my $x (0..$xsize-1) {\n      for my $y (0..$ysize-1) {\n        my $col = $im->getpixel(x => $x, y => $y);\n        my($r,$g,$b) = $col->rgba;\n        next if $r==255; \n        for my $k (0..$width) {\n            my $th = $dth*$k;\n            my $r2 = ($x*cos($th) + $y*sin($th));\n            my $iry = ($height/2 + int($r2/$dr + 0.5));\n            $ht->setpixel(x => $k, y => $iry, color => [ ($canvas[$iry][$k]--) x 3] );\n        }\n      }\n    }\n    return $ht;\n}\n\nmy $img = Imager->new;\n$img->read(file => 'ref/pentagon.png') or die \"Cannot read: \", $img->errstr;\nmy $ht = hough($img);\n$ht->write(file => 'hough_transform.png');\n", "target": "from math import hypot, pi, cos, sin\nfrom PIL import Image\n\n\ndef hough(im, ntx=460, mry=360):\n    \"Calculate Hough transform.\"\n    pim = im.load()\n    nimx, mimy = im.size\n    mry = int(mry/2)*2          \n    him = Image.new(\"L\", (ntx, mry), 255)\n    phim = him.load()\n\n    rmax = hypot(nimx, mimy)\n    dr = rmax / (mry/2)\n    dth = pi / ntx\n\n    for jx in xrange(nimx):\n        for iy in xrange(mimy):\n            col = pim[jx, iy]\n            if col == 255: continue\n            for jtx in xrange(ntx):\n                th = dth * jtx\n                r = jx*cos(th) + iy*sin(th)\n                iry = mry/2 + int(r/dr+0.5)\n                phim[jtx, iry] -= 1\n    return him\n\n\ndef test():\n    \"Test Hough transform with pentagon.\"\n    im = Image.open(\"pentagon.png\").convert(\"L\")\n    him = hough(im)\n    him.save(\"ho5.bmp\")\n\n\nif __name__ == \"__main__\": test()\n"}
{"id": 383368, "name": "First class environments", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Safe;\n\nsub hail_next {\n    my $n = shift;\n    return 1 if $n == 1;\n    return $n * 3 + 1 if $n % 2;\n    $n / 2;\n};\n \nmy @enviornments;\nfor my $initial ( 1..12 ) {\n   my $env = Safe->new;\n   ${ $env->varglob('value') } = $initial;\n   ${ $env->varglob('count') } = 0;\n   $env->share('&hail_next');\n   $env->reval(q{\n      sub task {\n         return if $value == 1;\n         $value = hail_next( $value );\n         ++$count;\n      }\n   });\n   push @enviornments, $env;\n}\n\nmy @value_refs = map $_->varglob('value'), @enviornments;\nmy @tasks = map $_->varglob('task'), @enviornments;\nwhile( grep { $$_ != 1 } @value_refs ) {\n    printf \"%4s\", $$_ for @value_refs;\n    print \"\\n\";\n    $_->() for @tasks;\n}\n \nprint \"Counts\\n\";\n \nprintf \"%4s\", ${$_->varglob('count')} for @enviornments;\nprint \"\\n\";\n", "target": "environments = [{'cnt':0, 'seq':i+1} for i in range(12)]\n\ncode = \n\nwhile any(env['seq'] > 1 for env in environments):\n    for env in environments:\n        exec(code, globals(), env)\n    print()\n\nprint('Counts')\nfor env in environments:\n    print('% 4d' % env['cnt'], end='')\nprint()\n"}
{"id": 383369, "name": "Video display modes", "source": "Translate Perl to Python: $| = 1;\n\nmy @info = `xrandr -q`;\n$info[0] =~ /current (\\d+) x (\\d+)/;\nmy $current = \"$1x$2\";\n\nmy @resolutions;\nfor (@info) {\n    push @resolutions, $1 if /^\\s+(\\d+x\\d+)/\n}\n\nsystem(\"xrandr -s $resolutions[-1]\");\nprint \"Current resolution $resolutions[-1].\\n\";\nfor (reverse 1 .. 9) {\n    print \"\\rChanging back in $_ seconds...\";\n    sleep 1;\n}\nsystem(\"xrandr -s $current\");\nprint \"\\rResolution returned to $current.\\n\";\n", "target": "import win32api\nimport win32con\nimport pywintypes\ndevmode=pywintypes.DEVMODEType()\ndevmode.PelsWidth=640\ndevmode.PelsHeight=480\ndevmode.Fields=win32con.DM_PELSWIDTH | win32con.DM_PELSHEIGHT\nwin32api.ChangeDisplaySettings(devmode,0)\n"}
{"id": 383370, "name": "Video display modes", "source": "Translate Perl to Python: $| = 1;\n\nmy @info = `xrandr -q`;\n$info[0] =~ /current (\\d+) x (\\d+)/;\nmy $current = \"$1x$2\";\n\nmy @resolutions;\nfor (@info) {\n    push @resolutions, $1 if /^\\s+(\\d+x\\d+)/\n}\n\nsystem(\"xrandr -s $resolutions[-1]\");\nprint \"Current resolution $resolutions[-1].\\n\";\nfor (reverse 1 .. 9) {\n    print \"\\rChanging back in $_ seconds...\";\n    sleep 1;\n}\nsystem(\"xrandr -s $current\");\nprint \"\\rResolution returned to $current.\\n\";\n", "target": "import win32api\nimport win32con\nimport pywintypes\ndevmode=pywintypes.DEVMODEType()\ndevmode.PelsWidth=640\ndevmode.PelsHeight=480\ndevmode.Fields=win32con.DM_PELSWIDTH | win32con.DM_PELSHEIGHT\nwin32api.ChangeDisplaySettings(devmode,0)\n"}
{"id": 383371, "name": "Terminal control_Positional read", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Curses;\n\ninitscr or die;\n\nmy $win = Curses->new;\n\nforeach my $row (0..9) {\n   $win->addstr( $row , 0, join('', map { chr(int(rand(50)) + 41) } (0..9)))\n};\n\nmy $icol = 3 - 1;\nmy $irow = 6 - 1;\n\nmy $ch = $win->inch($irow,$icol);\n\n$win->addstr( $irow, $icol+10, 'Character at column 3, row 6 = '.$ch );\n\n$win->addstr( LINES() - 2, 2, \"Press any key to exit...\" );\n\n$win->getch;\n\nendwin;\n", "target": "import curses\nfrom random import randint\n\n\n\nstdscr = curses.initscr()\nfor rows in range(10):\n    line = ''.join([chr(randint(41, 90)) for i in range(10)])\n    stdscr.addstr(line + '\\n')\n\n\nicol = 3 - 1\nirow = 6 - 1\nch = stdscr.instr(irow, icol, 1).decode(encoding=\"utf-8\")\n\n\nstdscr.move(irow, icol + 10)\nstdscr.addstr('Character at column 3, row 6 = ' + ch + '\\n')\nstdscr.getch()\n\ncurses.endwin()\n"}
{"id": 383372, "name": "Tonelli-Shanks algorithm", "source": "Translate Perl to Python: use bigint;\nuse ntheory qw(is_prime powmod kronecker);\n\nsub tonelli_shanks {\n    my($n,$p) = @_;\n    return if kronecker($n,$p) <= 0;\n    my $Q = $p - 1;\n    my $S = 0;\n    $Q >>= 1 and $S++ while 0 == $Q%2;\n    return powmod($n,int(($p+1)/4), $p) if $S == 1;\n\n    my $c;\n    for $n (2..$p) {\n        next if kronecker($n,$p) >= 0;\n        $c = powmod($n, $Q, $p);\n        last;\n    }\n\n    my $R = powmod($n, ($Q+1) >> 1, $p ); \n    my $t = powmod($n, $Q, $p );\n    while (($t-1) % $p) {\n        my $b;\n        my $t2 = $t**2 % $p;\n        for (1 .. $S) {\n            if (0 == ($t2-1)%$p) {\n                $b = powmod($c, 1 << ($S-1-$_), $p);\n                $S = $_;\n                last;\n            }\n            $t2 = $t2**2 % $p;\n        }\n        $R = ($R * $b) % $p;\n        $c = $b**2 % $p;\n        $t = ($t * $c) % $p;\n    }\n    $R;\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (1030, 10009),\n    (1032, 10009),\n    (44402, 100049),\n    (665820697, 1000000009),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n    $n = shift @tests;\n    $p = shift @tests;\n    my $t = tonelli_shanks($n, $p);\n    if (!$t or ($t**2 - $n) % $p) {\n        printf \"No solution for (%d, %d)\\n\", $n, $p;\n    } else {\n        printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $t, $p-$t, $p;\n    }\n}\n", "target": "def legendre(a, p):\n    return pow(a, (p - 1) // 2, p)\n\ndef tonelli(n, p):\n    assert legendre(n, p) == 1, \"not a square (mod p)\"\n    q = p - 1\n    s = 0\n    while q % 2 == 0:\n        q //= 2\n        s += 1\n    if s == 1:\n        return pow(n, (p + 1) // 4, p)\n    for z in range(2, p):\n        if p - 1 == legendre(z, p):\n            break\n    c = pow(z, q, p)\n    r = pow(n, (q + 1) // 2, p)\n    t = pow(n, q, p)\n    m = s\n    t2 = 0\n    while (t - 1) % p != 0:\n        t2 = (t * t) % p\n        for i in range(1, m):\n            if (t2 - 1) % p == 0:\n                break\n            t2 = (t2 * t2) % p\n        b = pow(c, 1 << (m - i - 1), p)\n        r = (r * b) % p\n        c = (b * b) % p\n        t = (t * c) % p\n        m = i\n    return r\n\nif __name__ == '__main__':\n    ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049),\n\t     (665820697, 1000000009), (881398088036, 1000000000039),\n             (41660815127637347468140745042827704103445750172002, 10**50 + 577)]\n    for n, p in ttest:\n        r = tonelli(n, p)\n        assert (r * r - n) % p == 0\n        print(\"n = %d p = %d\" % (n, p))\n        print(\"\\t  roots\u00a0: %d %d\" % (r, p - r))\n"}
{"id": 383373, "name": "Tonelli-Shanks algorithm", "source": "Translate Perl to Python: use bigint;\nuse ntheory qw(is_prime powmod kronecker);\n\nsub tonelli_shanks {\n    my($n,$p) = @_;\n    return if kronecker($n,$p) <= 0;\n    my $Q = $p - 1;\n    my $S = 0;\n    $Q >>= 1 and $S++ while 0 == $Q%2;\n    return powmod($n,int(($p+1)/4), $p) if $S == 1;\n\n    my $c;\n    for $n (2..$p) {\n        next if kronecker($n,$p) >= 0;\n        $c = powmod($n, $Q, $p);\n        last;\n    }\n\n    my $R = powmod($n, ($Q+1) >> 1, $p ); \n    my $t = powmod($n, $Q, $p );\n    while (($t-1) % $p) {\n        my $b;\n        my $t2 = $t**2 % $p;\n        for (1 .. $S) {\n            if (0 == ($t2-1)%$p) {\n                $b = powmod($c, 1 << ($S-1-$_), $p);\n                $S = $_;\n                last;\n            }\n            $t2 = $t2**2 % $p;\n        }\n        $R = ($R * $b) % $p;\n        $c = $b**2 % $p;\n        $t = ($t * $c) % $p;\n    }\n    $R;\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (1030, 10009),\n    (1032, 10009),\n    (44402, 100049),\n    (665820697, 1000000009),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n    $n = shift @tests;\n    $p = shift @tests;\n    my $t = tonelli_shanks($n, $p);\n    if (!$t or ($t**2 - $n) % $p) {\n        printf \"No solution for (%d, %d)\\n\", $n, $p;\n    } else {\n        printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $t, $p-$t, $p;\n    }\n}\n", "target": "def legendre(a, p):\n    return pow(a, (p - 1) // 2, p)\n\ndef tonelli(n, p):\n    assert legendre(n, p) == 1, \"not a square (mod p)\"\n    q = p - 1\n    s = 0\n    while q % 2 == 0:\n        q //= 2\n        s += 1\n    if s == 1:\n        return pow(n, (p + 1) // 4, p)\n    for z in range(2, p):\n        if p - 1 == legendre(z, p):\n            break\n    c = pow(z, q, p)\n    r = pow(n, (q + 1) // 2, p)\n    t = pow(n, q, p)\n    m = s\n    t2 = 0\n    while (t - 1) % p != 0:\n        t2 = (t * t) % p\n        for i in range(1, m):\n            if (t2 - 1) % p == 0:\n                break\n            t2 = (t2 * t2) % p\n        b = pow(c, 1 << (m - i - 1), p)\n        r = (r * b) % p\n        c = (b * b) % p\n        t = (t * c) % p\n        m = i\n    return r\n\nif __name__ == '__main__':\n    ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049),\n\t     (665820697, 1000000009), (881398088036, 1000000000039),\n             (41660815127637347468140745042827704103445750172002, 10**50 + 577)]\n    for n, p in ttest:\n        r = tonelli(n, p)\n        assert (r * r - n) % p == 0\n        print(\"n = %d p = %d\" % (n, p))\n        print(\"\\t  roots\u00a0: %d %d\" % (r, p - r))\n"}
{"id": 383374, "name": "Truth table", "source": "Translate Perl to Python: \n\nsub truth_table {\n    my $s = shift;\n    my (%seen, @vars);\n    for ($s =~ /([a-zA-Z_]\\w*)/g) {\n        $seen{$_} //= do { push @vars, $_; 1 };\n    }\n\n    print \"\\n\", join(\"\\t\", @vars, $s), \"\\n\", '-' x 40, \"\\n\";\n    @vars = map(\"\\$$_\", @vars);\n\n    $s =~ s/([a-zA-Z_]\\w*)/\\$$1/g;\n    $s = \"print(\".join(',\"\\t\", ', map(\"($_?'T':'F')\", @vars, $s)).\",\\\"\\\\n\\\")\";\n    $s = \"for my $_ (0, 1) { $s }\" for (reverse @vars);\n    eval $s;\n}\n\ntruth_table 'A ^ A_1';\ntruth_table 'foo & bar | baz';\ntruth_table 'Jim & (Spock ^ Bones) | Scotty';\n", "target": "from itertools import product\n\nwhile True:\n    bexp = input('\\nBoolean expression: ')\n    bexp = bexp.strip()\n    if not bexp:\n        print(\"\\nThank you\")\n        break\n    code = compile(bexp, '<string>', 'eval')\n    names = code.co_names\n    print('\\n' + ' '.join(names), ':', bexp)\n    for values in product(range(2), repeat=len(names)):\n        env = dict(zip(names, values))\n        print(' '.join(str(v) for v in values), ':', eval(code, env))\n"}
{"id": 383375, "name": "Truth table", "source": "Translate Perl to Python: \n\nsub truth_table {\n    my $s = shift;\n    my (%seen, @vars);\n    for ($s =~ /([a-zA-Z_]\\w*)/g) {\n        $seen{$_} //= do { push @vars, $_; 1 };\n    }\n\n    print \"\\n\", join(\"\\t\", @vars, $s), \"\\n\", '-' x 40, \"\\n\";\n    @vars = map(\"\\$$_\", @vars);\n\n    $s =~ s/([a-zA-Z_]\\w*)/\\$$1/g;\n    $s = \"print(\".join(',\"\\t\", ', map(\"($_?'T':'F')\", @vars, $s)).\",\\\"\\\\n\\\")\";\n    $s = \"for my $_ (0, 1) { $s }\" for (reverse @vars);\n    eval $s;\n}\n\ntruth_table 'A ^ A_1';\ntruth_table 'foo & bar | baz';\ntruth_table 'Jim & (Spock ^ Bones) | Scotty';\n", "target": "from itertools import product\n\nwhile True:\n    bexp = input('\\nBoolean expression: ')\n    bexp = bexp.strip()\n    if not bexp:\n        print(\"\\nThank you\")\n        break\n    code = compile(bexp, '<string>', 'eval')\n    names = code.co_names\n    print('\\n' + ' '.join(names), ':', bexp)\n    for values in product(range(2), repeat=len(names)):\n        env = dict(zip(names, values))\n        print(' '.join(str(v) for v in values), ':', eval(code, env))\n"}
{"id": 383376, "name": "Set of real numbers", "source": "Translate Perl to Python: use utf8;\n\n\n\n\n\n\npackage BNum;\n\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'<=>'\t=> \\&_cmp,\n);\n\nsub new {\n\tmy $self = shift;\n\tbless [@_], ref $self || $self\n}\n\nsub flip {\n\tmy @a = @{+shift};\n\t$a[2] = !$a[2];\n\tbless \\@a\n}\n\nmy $brackets = qw/ [ ( ) ] /;\nsub _str {\n\tmy $v = sprintf \"%.2f\", $_[0][0];\n\t$_[0][2]\n\t\t? $v . ($_[0][1] == 1 ? \"]\" : \")\")\n\t\t: ($_[0][1] == 1 ? \"(\" : \"[\" ) . $v;\n}\n\nsub _cmp {\n\tmy ($a, $b, $swap) = @_;\n\n\t\n\tif ($swap) { return -_ncmp($a, $b) }\n\tif (!ref $b || !$b->isa(__PACKAGE__)) { return _ncmp($a, $b) }\n\n\t$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]\n}\n\nsub _ncmp {\n\t\n\tmy ($a, $b) = @_;\n\t$a->[0] <=> $b || $a->[1] <=> 0\n}\n\npackage RealSet;\nuse Carp;\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'|'\t=> \\&_or,\n\t'&'\t=> \\&_and,\n\t'~'\t=> \\&_neg,\n\t'-'\t=> \\&_diff,\n\t'bool'\t=> \\&not_empty, \n);\n\nmy %pm = qw/ [ -1 ( 1 ) -1 ] 1 /;\nsub range {\n\tmy ($cls, $a, $b, $spec) = @_;\n\t$spec =~ /^( \\[ | \\( )( \\) | \\] )$/x\tor croak \"bad spec $spec\";\n\n\t$a = BNum->new($a, $pm{$1}, 0);\n\t$b = BNum->new($b, $pm{$2}, 1);\n\tnormalize($a < $b ? [$a, $b] : [])\n}\n\nsub normalize {\n\tmy @a = @{+shift};\n\t\n\t\n\t\n\tfor (my $i = $\n\t\tsplice @a, $i - 1, 2\n\t\t\tif $a[$i] <= $a[$i - 1]\n\t}\n\tbless \\@a\n}\n\nsub not_empty { scalar @{ normalize shift } }\n\nsub _str {\n\tmy (@a, @s) = @{+shift}\t\tor return '()';\n\tjoin \" \u222a \", map { shift(@a).\", \".shift(@a) } 0 .. $\n}\n\nsub _or {\n\t\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? () : ($_)\n\t\t\t\t: $d++ ? () : ($_) }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _neg {\n\tnormalize [\n\t\tBNum->new('-inf', 1, 0),\n\t\tmap($_->flip, @{+shift}),\n\t\tBNum->new('inf', -1, 1),\n\t]\n}\n\nsub _and {\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? ($_) : ()\n\t\t\t\t: $d++ ? ($_) : () }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _diff { shift() & ~shift() }\n\nsub has {\n\tmy ($a, $b) = @_;\n\tfor (my $i = 0; $i < $\n\t\treturn 1 if $a->[$i] <= $b && $b <= $a->[$i + 1]\n\t}\n\treturn 0\n}\n\nsub len {\n\tmy ($a, $l) = shift;\n\tfor (my $i = 0; $i < $\n\t\t$l += $a->[$i+1][0] - $a->[$i][0]\n\t}\n\treturn $l\n}\n\npackage main;\nuse List::Util 'reduce';\n\nsub rng { RealSet->range(@_) }\nmy @sets = (\n\trng(0, 1, '(]') | rng(0, 2, '[)'),\n\trng(0, 2, '[)') & rng(0, 2, '(]'),\n\trng(0, 3, '[)') - rng(0, 1, '()'),\n\trng(0, 3, '[)') - rng(0, 1, '[]'),\n);\n\nfor my $i (0 .. $\n\tprint \"Set $i = \", $sets[$i], \": \";\n\tfor (0 .. 2) {\n\t\tprint \"has $_; \" if $sets[$i]->has($_);\n\t}\n\tprint \"\\n\";\n}\n\n\nprint \"\\n\nsub brev { \n\tmy $x = shift;\n\treturn $x if length $x < 60;\n\tsubstr($x, 0, 30).\" ... \".substr($x, -30, 30)\n}\n\n\nmy $x = reduce { $a | $b }\n\tmap(rng(sqrt($_ + 1./6), sqrt($_ + 5./6), '()'), 0 .. 101);\n$x &= rng(0, 10, '()');\n\nprint \"A\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x\u00b2)| > 1/2 }',\n\t\"\\n\\t= \", brev($x), \"\\n\";\n\nmy $y = reduce { $a | $b }\n\tmap { rng($_ + 1./6, $_ + 5./6, '()') } 0 .. 11;\n$y &= rng(0, 10, '()');\n\nprint \"B\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x)| > 1/2 }',\n\t\"\\n\\t= \", brev($y), \"\\n\";\n\nmy $z = $x - $y;\nprint \"A - B\\t= \", brev($z), \"\\n\\tlength = \", $z->len, \"\\n\";\nprint $z ? \"not empty\\n\" : \"empty\\n\";\n", "target": "class Setr():\n    def __init__(self, lo, hi, includelo=True, includehi=False):\n        self.eqn = \"(%i<%sX<%s%i)\" % (lo,\n                                      '=' if includelo else '',\n                                      '=' if includehi else '',\n                                      hi)\n\n    def __contains__(self, X):\n        return eval(self.eqn, locals())\n\n    \n    def __or__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sor%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __and__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __sub__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand not%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    def __repr__(self):\n        return \"Setr%s\" % self.eqn\n\n\nsets = [\n    Setr(0,1, 0,1) | Setr(0,2, 1,0),\n    Setr(0,2, 1,0) & Setr(1,2, 0,1),\n    Setr(0,3, 1,0) - Setr(0,1, 0,0),\n    Setr(0,3, 1,0) - Setr(0,1, 1,1),\n]\nsettexts = '(0, 1] \u222a [0, 2);[0, 2) \u2229 (1, 2];[0, 3) \u2212 (0, 1);[0, 3) \u2212 [0, 1]'.split(';')\n\nfor s,t in zip(sets, settexts):\n    print(\"Set %s %s. %s\" % (t,\n                             ', '.join(\"%scludes %i\"\n                                     % ('in' if v in s else 'ex', v)\n                                     for v in range(3)),\n                             s.eqn))\n"}
{"id": 383377, "name": "Set of real numbers", "source": "Translate Perl to Python: use utf8;\n\n\n\n\n\n\npackage BNum;\n\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'<=>'\t=> \\&_cmp,\n);\n\nsub new {\n\tmy $self = shift;\n\tbless [@_], ref $self || $self\n}\n\nsub flip {\n\tmy @a = @{+shift};\n\t$a[2] = !$a[2];\n\tbless \\@a\n}\n\nmy $brackets = qw/ [ ( ) ] /;\nsub _str {\n\tmy $v = sprintf \"%.2f\", $_[0][0];\n\t$_[0][2]\n\t\t? $v . ($_[0][1] == 1 ? \"]\" : \")\")\n\t\t: ($_[0][1] == 1 ? \"(\" : \"[\" ) . $v;\n}\n\nsub _cmp {\n\tmy ($a, $b, $swap) = @_;\n\n\t\n\tif ($swap) { return -_ncmp($a, $b) }\n\tif (!ref $b || !$b->isa(__PACKAGE__)) { return _ncmp($a, $b) }\n\n\t$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]\n}\n\nsub _ncmp {\n\t\n\tmy ($a, $b) = @_;\n\t$a->[0] <=> $b || $a->[1] <=> 0\n}\n\npackage RealSet;\nuse Carp;\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'|'\t=> \\&_or,\n\t'&'\t=> \\&_and,\n\t'~'\t=> \\&_neg,\n\t'-'\t=> \\&_diff,\n\t'bool'\t=> \\&not_empty, \n);\n\nmy %pm = qw/ [ -1 ( 1 ) -1 ] 1 /;\nsub range {\n\tmy ($cls, $a, $b, $spec) = @_;\n\t$spec =~ /^( \\[ | \\( )( \\) | \\] )$/x\tor croak \"bad spec $spec\";\n\n\t$a = BNum->new($a, $pm{$1}, 0);\n\t$b = BNum->new($b, $pm{$2}, 1);\n\tnormalize($a < $b ? [$a, $b] : [])\n}\n\nsub normalize {\n\tmy @a = @{+shift};\n\t\n\t\n\t\n\tfor (my $i = $\n\t\tsplice @a, $i - 1, 2\n\t\t\tif $a[$i] <= $a[$i - 1]\n\t}\n\tbless \\@a\n}\n\nsub not_empty { scalar @{ normalize shift } }\n\nsub _str {\n\tmy (@a, @s) = @{+shift}\t\tor return '()';\n\tjoin \" \u222a \", map { shift(@a).\", \".shift(@a) } 0 .. $\n}\n\nsub _or {\n\t\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? () : ($_)\n\t\t\t\t: $d++ ? () : ($_) }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _neg {\n\tnormalize [\n\t\tBNum->new('-inf', 1, 0),\n\t\tmap($_->flip, @{+shift}),\n\t\tBNum->new('inf', -1, 1),\n\t]\n}\n\nsub _and {\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? ($_) : ()\n\t\t\t\t: $d++ ? ($_) : () }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _diff { shift() & ~shift() }\n\nsub has {\n\tmy ($a, $b) = @_;\n\tfor (my $i = 0; $i < $\n\t\treturn 1 if $a->[$i] <= $b && $b <= $a->[$i + 1]\n\t}\n\treturn 0\n}\n\nsub len {\n\tmy ($a, $l) = shift;\n\tfor (my $i = 0; $i < $\n\t\t$l += $a->[$i+1][0] - $a->[$i][0]\n\t}\n\treturn $l\n}\n\npackage main;\nuse List::Util 'reduce';\n\nsub rng { RealSet->range(@_) }\nmy @sets = (\n\trng(0, 1, '(]') | rng(0, 2, '[)'),\n\trng(0, 2, '[)') & rng(0, 2, '(]'),\n\trng(0, 3, '[)') - rng(0, 1, '()'),\n\trng(0, 3, '[)') - rng(0, 1, '[]'),\n);\n\nfor my $i (0 .. $\n\tprint \"Set $i = \", $sets[$i], \": \";\n\tfor (0 .. 2) {\n\t\tprint \"has $_; \" if $sets[$i]->has($_);\n\t}\n\tprint \"\\n\";\n}\n\n\nprint \"\\n\nsub brev { \n\tmy $x = shift;\n\treturn $x if length $x < 60;\n\tsubstr($x, 0, 30).\" ... \".substr($x, -30, 30)\n}\n\n\nmy $x = reduce { $a | $b }\n\tmap(rng(sqrt($_ + 1./6), sqrt($_ + 5./6), '()'), 0 .. 101);\n$x &= rng(0, 10, '()');\n\nprint \"A\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x\u00b2)| > 1/2 }',\n\t\"\\n\\t= \", brev($x), \"\\n\";\n\nmy $y = reduce { $a | $b }\n\tmap { rng($_ + 1./6, $_ + 5./6, '()') } 0 .. 11;\n$y &= rng(0, 10, '()');\n\nprint \"B\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x)| > 1/2 }',\n\t\"\\n\\t= \", brev($y), \"\\n\";\n\nmy $z = $x - $y;\nprint \"A - B\\t= \", brev($z), \"\\n\\tlength = \", $z->len, \"\\n\";\nprint $z ? \"not empty\\n\" : \"empty\\n\";\n", "target": "class Setr():\n    def __init__(self, lo, hi, includelo=True, includehi=False):\n        self.eqn = \"(%i<%sX<%s%i)\" % (lo,\n                                      '=' if includelo else '',\n                                      '=' if includehi else '',\n                                      hi)\n\n    def __contains__(self, X):\n        return eval(self.eqn, locals())\n\n    \n    def __or__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sor%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __and__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __sub__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand not%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    def __repr__(self):\n        return \"Setr%s\" % self.eqn\n\n\nsets = [\n    Setr(0,1, 0,1) | Setr(0,2, 1,0),\n    Setr(0,2, 1,0) & Setr(1,2, 0,1),\n    Setr(0,3, 1,0) - Setr(0,1, 0,0),\n    Setr(0,3, 1,0) - Setr(0,1, 1,1),\n]\nsettexts = '(0, 1] \u222a [0, 2);[0, 2) \u2229 (1, 2];[0, 3) \u2212 (0, 1);[0, 3) \u2212 [0, 1]'.split(';')\n\nfor s,t in zip(sets, settexts):\n    print(\"Set %s %s. %s\" % (t,\n                             ', '.join(\"%scludes %i\"\n                                     % ('in' if v in s else 'ex', v)\n                                     for v in range(3)),\n                             s.eqn))\n"}
{"id": 383378, "name": "State name puzzle", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\nuse feature qw{ say };\n\n\nsub uniq {\n    my %uniq;\n    undef @uniq{ @_ };\n    return keys %uniq\n}\n\n\nsub puzzle {\n    my @states = uniq(@_);\n\n    my %pairs;\n    for my $state1 (@states) {\n        for my $state2 (@states) {\n            next if $state1 le $state2;\n            my $both = join q(),\n                       grep ' ' ne $_,\n                       sort split //,\n                       lc \"$state1$state2\";\n            push @{ $pairs{$both} }, [ $state1, $state2 ];\n        }\n    }\n\n    for my $pair (keys %pairs) {\n        next if 2 > @{ $pairs{$pair} };\n\n        for my $pair1 (@{ $pairs{$pair} }) {\n            for my $pair2 (@{ $pairs{$pair} }) {\n                next if 4 > uniq(@$pair1, @$pair2)\n                     or $pair1->[0] lt $pair2->[0];\n\n                say join ' = ', map { join ' + ', @$_ } $pair1, $pair2;\n            }\n        }\n    }\n}\n\nmy @states = ( 'Alabama', 'Alaska', 'Arizona', 'Arkansas',\n               'California', 'Colorado', 'Connecticut', 'Delaware',\n               'Florida', 'Georgia', 'Hawaii',\n               'Idaho', 'Illinois', 'Indiana', 'Iowa',\n               'Kansas', 'Kentucky', 'Louisiana',\n               'Maine', 'Maryland', 'Massachusetts', 'Michigan',\n               'Minnesota', 'Mississippi', 'Missouri', 'Montana',\n               'Nebraska', 'Nevada', 'New Hampshire', 'New Jersey',\n               'New Mexico', 'New York', 'North Carolina', 'North Dakota',\n               'Ohio', 'Oklahoma', 'Oregon',\n               'Pennsylvania', 'Rhode Island',\n               'South Carolina', 'South Dakota', 'Tennessee', 'Texas',\n               'Utah', 'Vermont', 'Virginia',\n               'Washington', 'West Virginia', 'Wisconsin', 'Wyoming',\n             );\n\nmy @fictious = ( 'New Kory', 'Wen Kory', 'York New', 'Kory New', 'New Kory' );\n\nsay scalar @states, ' states:';\npuzzle(@states);\n\nsay @states + @fictious, ' states:';\npuzzle(@states, @fictious);\n", "target": "from collections import defaultdict\n\nstates = [\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\",\n\"California\", \"Colorado\", \"Connecticut\", \"Delaware\", \"Florida\",\n\"Georgia\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\", \"Iowa\", \"Kansas\",\n\"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\", \"Massachusetts\",\n\"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\", \"Montana\",\n\"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\", \"New Mexico\",\n\"New York\", \"North Carolina\", \"North Dakota\", \"Ohio\", \"Oklahoma\",\n\"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n\"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n\"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\",\n\n\n]\n\nstates = sorted(set(states))\n\nsmap = defaultdict(list)\nfor i, s1 in enumerate(states[:-1]):\n    for s2 in states[i + 1:]:\n        smap[\"\".join(sorted(s1 + s2))].append(s1 + \" + \" + s2)\n\nfor pairs in sorted(smap.itervalues()):\n    if len(pairs) > 1:\n        print \" = \".join(pairs)\n"}
{"id": 383379, "name": "Super-d numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\n\nsub super {\n    my $d = shift;\n    my $run = $d x $d;\n    my @super;\n    my $i = 0;\n    my $n = 0;\n    while ( $i < 10 ) {\n        if (index($n ** $d * $d, $run) > -1) {\n            push @super, $n;\n            ++$i;\n        }\n        ++$n;\n    }\n    @super;\n}\n \nsay \"\\nFirst 10 super-$_ numbers:\\n\", join ' ', super($_) for 2..6;\n", "target": "from itertools import islice, count\n\ndef superd(d):\n    if d != int(d) or not 2 <= d <= 9:\n        raise ValueError(\"argument must be integer from 2 to 9 inclusive\")\n    tofind = str(d) * d\n    for n in count(2):\n        if tofind in str(d * n ** d):\n            yield n\n\nif __name__ == '__main__':\n    for d in range(2, 9):\n        print(f\"{d}:\", ', '.join(str(n) for n in islice(superd(d), 10)))\n"}
{"id": 383380, "name": "Super-d numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\n\nsub super {\n    my $d = shift;\n    my $run = $d x $d;\n    my @super;\n    my $i = 0;\n    my $n = 0;\n    while ( $i < 10 ) {\n        if (index($n ** $d * $d, $run) > -1) {\n            push @super, $n;\n            ++$i;\n        }\n        ++$n;\n    }\n    @super;\n}\n \nsay \"\\nFirst 10 super-$_ numbers:\\n\", join ' ', super($_) for 2..6;\n", "target": "from itertools import islice, count\n\ndef superd(d):\n    if d != int(d) or not 2 <= d <= 9:\n        raise ValueError(\"argument must be integer from 2 to 9 inclusive\")\n    tofind = str(d) * d\n    for n in count(2):\n        if tofind in str(d * n ** d):\n            yield n\n\nif __name__ == '__main__':\n    for d in range(2, 9):\n        print(f\"{d}:\", ', '.join(str(n) for n in islice(superd(d), 10)))\n"}
{"id": 383381, "name": "Padovan sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <state say>;\nuse List::Lazy 'lazy_list';\n\nmy $p = 1.32471795724474602596;\nmy $s = 1.0453567932525329623;\nmy %rules = (A => 'B', B => 'C', C => 'AB');\n\nmy $pad_recur = lazy_list { state @p = (1, 1, 1, 2); push @p, $p[1]+$p[2]; shift @p };\n\nsub pad_floor { int 1/2 + $p**($_<3\u00a0? 1\u00a0: $_-2) / $s }\n\nmy($l, $m, $n) = (10, 20, 32);\n\nmy(@pr, @pf);\npush @pr, $pad_recur->next() for 1 .. $n; say join ' ', @pr[0 .. $m-1];\npush @pf,  pad_floor($_)     for 1 .. $n; say join ' ', @pf[0 .. $m-1];\n\nmy @L = 'A';\npush @L, join '', @rules{split '', $L[-1]} for 1 .. $n;\nsay join ' ', @L[0 .. $l-1];\n\n$pr[$_] == $pf[$_] and $pr[$_] == length $L[$_] or die \"Uh oh, n=$_: $pr[$_] vs $pf[$_] vs \" . length $L[$_] for 0 .. $n-1;\nsay '100% agreement among all 3 methods.';\n", "target": "from math import floor\nfrom collections import deque\nfrom typing import Dict, Generator\n\n\ndef padovan_r() -> Generator[int, None, None]:\n    last = deque([1, 1, 1], 4)\n    while True:\n        last.append(last[-2] + last[-3])\n        yield last.popleft()\n\n_p, _s = 1.324717957244746025960908854, 1.0453567932525329623\n\ndef padovan_f(n: int) -> int:\n    return floor(_p**(n-1) / _s + .5)\n\ndef padovan_l(start: str='A',\n             rules: Dict[str, str]=dict(A='B', B='C', C='AB')\n             ) -> Generator[str, None, None]:\n    axiom = start\n    while True:\n        yield axiom\n        axiom = ''.join(rules[ch] for ch in axiom)\n\n\nif __name__ == \"__main__\":\n    from itertools import islice\n\n    print(\"The first twenty terms of the sequence.\")\n    print(str([padovan_f(n) for n in range(20)])[1:-1])\n\n    r_generator = padovan_r()\n    if all(next(r_generator) == padovan_f(n) for n in range(64)):\n        print(\"\\nThe recurrence and floor based algorithms match to n=63 .\")\n    else:\n        print(\"\\nThe recurrence and floor based algorithms DIFFER!\")\n\n    print(\"\\nThe first 10 L-system string-lengths and strings\")\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    print('\\n'.join(f\"  {len(string):3} {repr(string)}\"\n                    for string in islice(l_generator, 10)))\n\n    r_generator = padovan_r()\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    if all(len(next(l_generator)) == padovan_f(n) == next(r_generator)\n           for n in range(32)):\n        print(\"\\nThe L-system, recurrence and floor based algorithms match to n=31 .\")\n    else:\n        print(\"\\nThe L-system, recurrence and floor based algorithms DIFFER!\")\n"}
{"id": 383382, "name": "Monads_Maybe monad", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Data::Monad::Maybe;\n\nsub safeReciprocal { ( $_[0] == 0 ) ? nothing : just(  1 /  $_[0] )   }\n\nsub safeRoot       { ( $_[0] <  0 ) ? nothing : just( sqrt( $_[0] ) ) }\n\nsub safeLog        { ( $_[0] <= 0 ) ? nothing : just( log ( $_[0] ) ) }\n\nprint join(' ', map {\n   my $safeLogRootReciprocal = just($_)->flat_map( \\&safeReciprocal )\n                                       ->flat_map( \\&safeRoot       )\n                                       ->flat_map( \\&safeLog        );\n   $safeLogRootReciprocal->is_nothing ? \"NaN\" : $safeLogRootReciprocal->value;\n} (-2, -1, -0.5, 0, exp (-1), 1, 2, exp(1), 3, 4, 5) ), \"\\n\";\n", "target": "\nfrom __future__ import annotations\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import TypeVar\nfrom typing import Union\n\n\nT = TypeVar(\"T\")\n\n\nclass Maybe(Generic[T]):\n    def __init__(self, value: Union[Optional[T], Maybe[T]] = None):\n        if isinstance(value, Maybe):\n            self.value: Optional[T] = value.value\n        else:\n            self.value = value\n\n    def __rshift__(self, func: Callable[[Optional[T]], Maybe[Any]]):\n        return self.bind(func)\n\n    def bind(self, func: Callable[[Optional[T]], Maybe[Any]]) -> Maybe[Any]:\n        return func(self.value)\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}({self.value!r})\"\n\n\ndef plus_one(value: Optional[int]) -> Maybe[int]:\n    if value is not None:\n        return Maybe[int](value + 1)\n    return Maybe[int](None)\n\n\ndef currency(value: Optional[int]) -> Maybe[str]:\n    if value is not None:\n        return Maybe[str](f\"${value}.00\")\n    return Maybe[str](None)\n\n\nif __name__ == \"__main__\":\n    test_cases = [1, 99, None, 4]\n\n    for case in test_cases:\n        m_int = Maybe[int](case)\n        result = m_int >> plus_one >> currency\n        \n        \n        print(f\"{str(case):<4} -> {result}\")\n"}
{"id": 383383, "name": "Monads_List monad", "source": "Translate Perl to Python: use strict;\nuse feature 'say';\nuse Data::Monad::List;\n\n\nmy @cartesian = [(\n    list_flat_map_multi { scalar_list(join '', @_) }\n        scalar_list(0..1),\n        scalar_list(0..1),\n        scalar_list(0..1)\n)->scalars];\nsay join \"\\n\", @{shift @cartesian};\n\nsay '';\n\n\nmy @triples = [(\n    list_flat_map_multi { scalar_list(\n            { $_[0] < $_[1] && $_[0]**2+$_[1]**2 == $_[2]**2 ? join(',',@_) : () }\n        ) }\n        scalar_list(1..10),\n        scalar_list(1..10),\n        scalar_list(1..10)\n)->scalars];\n\nfor (@{shift @triples}) {\n    say keys %$_ if keys %$_;\n}\n", "target": "\nfrom __future__ import annotations\nfrom itertools import chain\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\nclass MList(List[T]):\n    @classmethod\n    def unit(cls, value: Iterable[T]) -> MList[T]:\n        return cls(value)\n\n    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return MList(chain.from_iterable(map(func, self)))\n\n    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return self.bind(func)\n\n\nif __name__ == \"__main__\":\n    \n    print(\n        MList([1, 99, 4])\n        .bind(lambda val: MList([val + 1]))\n        .bind(lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList([1, 99, 4])\n        >> (lambda val: MList([val + 1]))\n        >> (lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList(range(1, 6)).bind(\n            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))\n        )\n    )\n\n    \n    print(\n        MList(range(1, 26)).bind(\n            lambda x: MList(range(x + 1, 26)).bind(\n                lambda y: MList(range(y + 1, 26)).bind(\n                    lambda z: MList([(x, y, z)])\n                    if x * x + y * y == z * z\n                    else MList([])\n                )\n            )\n        )\n    )\n"}
{"id": 383384, "name": "Textonyms", "source": "Translate Perl to Python: my $src = 'unixdict.txt';\n\n\nopen $fh, \"<\", $src;\n@words = grep { /^[a-zA-Z]+$/ } <$fh>;\nmap { tr/A-Z/a-z/ } @words;\n\n\nmap { tr/abcdefghijklmnopqrstuvwxyz/22233344455566677778889999/ } @dials = @words;\n\n\n@dials = grep {!$h{$_}++} @dials;\n@textonyms = grep { $h{$_} > 1 } @dials;\n\nprint \"There are @{[scalar @words]} words in '$src' which can be represented by the digit key mapping.\nThey require @{[scalar @dials]} digit combinations to represent them.\n@{[scalar @textonyms]} digit combinations represent Textonyms.\";\n", "target": "from collections import defaultdict\nimport urllib.request\n\nCH2NUM = {ch: str(num) for num, chars in enumerate('abc def ghi jkl mno pqrs tuv wxyz'.split(), 2) for ch in chars}\nURL = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\n\n\ndef getwords(url):\n return urllib.request.urlopen(url).read().decode(\"utf-8\").lower().split()\n\ndef mapnum2words(words):\n    number2words = defaultdict(list)\n    reject = 0\n    for word in words:\n        try:\n            number2words[''.join(CH2NUM[ch] for ch in word)].append(word)\n        except KeyError:\n            \n            reject += 1\n    return dict(number2words), reject\n\ndef interactiveconversions():\n    global inp, ch, num\n    while True:\n        inp = input(\"\\nType a number or a word to get the translation and textonyms: \").strip().lower()\n        if inp:\n            if all(ch in '23456789' for ch in inp):\n                if inp in num2words:\n                    print(\"  Number {0} has the following textonyms in the dictionary: {1}\".format(inp, ', '.join(\n                        num2words[inp])))\n                else:\n                    print(\"  Number {0} has no textonyms in the dictionary.\".format(inp))\n            elif all(ch in CH2NUM for ch in inp):\n                num = ''.join(CH2NUM[ch] for ch in inp)\n                print(\"  Word {0} is{1} in the dictionary and is number {2} with textonyms: {3}\".format(\n                    inp, ('' if inp in wordset else \"n't\"), num, ', '.join(num2words[num])))\n            else:\n                print(\"  I don't understand %r\" % inp)\n        else:\n            print(\"Thank you\")\n            break\n\n\nif __name__ == '__main__':\n    words = getwords(URL)\n    print(\"Read %i words from %r\" % (len(words), URL))\n    wordset = set(words)\n    num2words, reject = mapnum2words(words)\n    morethan1word = sum(1 for w in num2words if len(num2words[w]) > 1)\n    maxwordpernum = max(len(values) for values in num2words.values())\n    print(.format(len(words) - reject, URL, len(num2words), morethan1word))\n\n    print(\"\\nThe numbers mapping to the most words map to %i words each:\" % maxwordpernum)\n    maxwpn = sorted((key, val) for key, val in num2words.items() if len(val) == maxwordpernum)\n    for num, wrds in maxwpn:\n        print(\"  %s maps to: %s\" % (num, ', '.join(wrds)))\n\n    interactiveconversions()\n"}
{"id": 383385, "name": "Minesweeper game", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\n\n{   package Local::Field;\n\n    use constant {\n        REAL  => 0,\n        SHOW  => 1,\n        COUNT => 2,\n    };\n\n    sub new {\n        my ($class, $width, $height, $percent) = @_;\n        my $field;\n        for my $x (1 .. $width) {\n            for my $y (1 .. $height) {\n                $field->[$x - 1][$y - 1][REAL] = ' ';\n                $field->[$x - 1][$y - 1][SHOW] = '.';\n            }\n        }\n        for (1 .. $percent / 100 * $width * $height) {\n            my ($x, $y) = map int rand $_, $width, $height;\n            redo if 'm' eq $field->[$x][$y][REAL];\n            $field->[$x][$y][REAL] = 'm';\n            for my $i ($x - 1 .. $x + 1) {\n                for my $j ($y - 1 .. $y + 1) {\n                    $field->[$i][$j][COUNT]++\n                        if $i >= 0 and $j >= 0\n                        and $i <= $\n                }\n            }\n        }\n        bless $field, $class;\n    }\n\n\n    sub show {\n        my ($self) = @_;\n        print \"\\n  \";\n        printf '%2d ', $_ + 1 for 0 .. $\n        print \"\\n\";\n\n        for my $row (0 .. $\n            printf '%2d ', 1 + $row;\n            for my $column (0 .. $\n                print $self->[$column][$row][SHOW], '  ';\n            }\n            print \"\\n\";\n        }\n    }\n\n\n    sub mark {\n        my ($self, $x, $y) = @_;\n        $_-- for $x, $y;\n\n        if ('.' eq $self->[$x][$y][SHOW]) {\n            $self->[$x][$y][SHOW] = '?';\n\n        } elsif ('?' eq $self->[$x][$y][SHOW]) {\n            $self->[$x][$y][SHOW] = '.';\n        }\n    }\n\n\n    sub end {\n        my $self = shift;\n        for my $y (0 .. $\n            for my $x (0 .. $\n                $self->[$x][$y][SHOW] = '!' if '.' eq $self->[$x][$y][SHOW]\n                    and 'm' eq $self->[$x][$y][REAL];\n                $self->[$x][$y][SHOW] = 'x' if '?' eq $self->[$x][$y][SHOW]\n                    and 'm' ne $self->[$x][$y][REAL];\n            }\n        }\n        $self->show;\n        exit;\n    }\n\n    sub _declassify {\n        my ($self, $x, $y) = @_;\n        return if '.' ne $self->[$x][$y][SHOW];\n        if (' ' eq $self->[$x][$y][REAL] and '.' eq $self->[$x][$y][SHOW]) {\n            $self->[$x][$y][SHOW] = $self->[$x][$y][COUNT] || ' ';\n        }\n        return if ' ' ne $self->[$x][$y][SHOW];\n\n        for my $i ($x - 1 .. $x + 1) {\n            next if $i < 0 or $i > $\n            for my $j ($y - 1 .. $y + 1) {\n                next if $j < 0 or $j > $\n                no warnings 'recursion';\n                $self->_declassify($i, $j);\n            }\n        }\n    }\n\n\n    sub clear {\n        my ($self, $x, $y) = @_;\n        $_-- for $x, $y;\n        return unless '.' eq $self->[$x][$y][SHOW];\n\n        print \"You lost.\\n\" and $self->end if 'm' eq $self->[$x][$y][REAL];\n\n        $self->_declassify($x, $y);\n    }\n\n\n    sub remain {\n        my $self = shift;\n        my $unclear = 0;\n        for my $column (@$self) {\n            for my $cell (@$column) {\n                $unclear++ if '.' eq $cell->[SHOW];\n            }\n        }\n        return $unclear;\n    }\n\n}\n\nsub help {\n    print << '__HELP__';\nCommands:\nh     ... help\nq     ... quit\nm X Y ... mark/unmark X Y\nc X Y ... clear X Y\n__HELP__\n}\n\n\nmy ($width, $height, $percent) = @ARGV;\n$width   ||= 6;\n$height  ||= 4;\n$percent ||= 15;\n\nmy $field = 'Local::Field'->new($width, $height, $percent);\n\nmy $help = 1;\nwhile (1) {\n    $field->show;\n    help() if $help;\n    $help = 0;\n    my $remain = $field->remain;\n    last if 0 == $remain;\n    print \"Cells remaining: $remain.\\n\";\n    my $command = <STDIN>;\n    exit if $command =~ /^q/i;\n\n    if ($command =~ /^m.*?([0-9]+).*?([0-9]+)/i) {\n        $field->mark($1, $2);\n\n    } elsif ($command =~ /^c.*?([0-9]+).*?([0-9]+)/i) {\n        $field->clear($1, $2);\n\n    } elsif ($command =~ /^h/i) {\n        $help = 1;\n\n    } else {\n        print \"Huh?\\n\";\n    }\n}\nprint \"You won!\\n\";\n", "target": "\n\n\ngridsize  = (6, 4)\nminerange = (0.2, 0.6)\n\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\n    \nimport random\nfrom itertools import product\nfrom pprint import pprint as pp\n\n\ndef gridandmines(gridsize=gridsize, minerange=minerange):\n    xgrid, ygrid = gridsize\n    minmines, maxmines = minerange\n    minecount = xgrid * ygrid    \n    minecount = random.randint(int(minecount*minmines), int(minecount*maxmines))\n    grid = set(product(range(xgrid), range(ygrid)))\n    mines = set(random.sample(grid, minecount))\n    show = {xy:'.' for xy in grid}\n    return grid, mines, show\n\ndef printgrid(show, gridsize=gridsize):\n    xgrid, ygrid = gridsize\n    grid = '\\n'.join(''.join(show[(x,y)] for x in range(xgrid))\n                     for y in range(ygrid))\n    print( grid )\n\ndef resign(showgrid, mines, markedmines):\n    for m in mines:\n        showgrid[m] = 'Y' if m in markedmines else 'N'\n\ndef clear(x,y, showgrid, grid, mines, markedmines):\n    if showgrid[(x, y)] == '.':\n        xychar = str(sum(1\n                         for xx in (x-1, x, x+1)\n                         for yy in (y-1, y, y+1)\n                         if (xx, yy) in mines ))\n        if xychar == '0': xychar = '.'\n        showgrid[(x,y)] = xychar\n        for xx in (x-1, x, x+1):\n            for yy in (y-1, y, y+1):\n                xxyy = (xx, yy)\n                if ( xxyy != (x, y)\n                     and xxyy in grid\n                     and xxyy not in mines | markedmines ):\n                    clear(xx, yy, showgrid, grid, mines, markedmines)\n\nif __name__ == '__main__':\n    grid, mines, showgrid = gridandmines()\n    markedmines = set([])\n    print( __doc__ )\n    print( '\\nThere are %i true mines of fixed position in the grid\\n' % len(mines) )\n    printgrid(showgrid)\n    while markedmines != mines:\n        inp = raw_input('m x y/c x y/p/r: ').strip().split()\n        if inp:\n            if inp[0] == 'm':\n                x, y = [int(i)-1 for i in inp[1:3]]\n                if (x,y) in markedmines:\n                    markedmines.remove((x,y))\n                    showgrid[(x,y)] = '.'\n                else:\n                    markedmines.add((x,y))\n                    showgrid[(x,y)] = '?'\n            elif inp[0] == 'p':\n                printgrid(showgrid)\n            elif inp[0] == 'c':\n                x, y = [int(i)-1 for i in inp[1:3]]\n                if (x,y) in mines | markedmines:\n                    print( '\\nKLABOOM!! You hit a mine.\\n' )\n                    resign(showgrid, mines, markedmines)\n                    printgrid(showgrid)\n                    break\n                clear(x,y, showgrid, grid, mines, markedmines)\n                printgrid(showgrid)\n            elif inp[0] == 'r':\n                print( '\\nResigning!\\n' )\n                resign(showgrid, mines, markedmines)\n                printgrid(showgrid)\n                break\n    \n    print( '\\nYou got %i and missed %i of the %i mines'\n           % (len(mines.intersection(markedmines)),\n              len(markedmines.difference(mines)),\n              len(mines)) )\n"}
{"id": 383386, "name": "Church numerals", "source": "Translate Perl to Python: use 5.020;\nuse feature qw<signatures>;\nno warnings qw<experimental::signatures>;\n\nuse constant zero  => sub ($f) {\n                      sub ($x) { $x }};\n\nuse constant succ  => sub ($n) {\n                      sub ($f) {\n                      sub ($x) { $f->($n->($f)($x)) }}};\n\nuse constant add   => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($f)($n->($f)($x)) }}}};\n\nuse constant mult  => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($n->($f))($x) }}}};\n\nuse constant power => sub ($b) {\n                      sub ($e) { $e->($b) }};\n\nuse constant countup   => sub ($i) { $i + 1 };\nuse constant countdown => sub ($i) { $i == 0 ? zero : succ->( __SUB__->($i - 1) ) };\nuse constant to_int    => sub ($f) { $f->(countup)->(0) };\nuse constant from_int  => sub ($x) { countdown->($x) };\n\nuse constant three => succ->(succ->(succ->(zero)));\nuse constant four  => from_int->(4);\n\nsay join ' ', map { to_int->($_) } (\n    add  ->( three )->( four  ),\n    mult ->( three )->( four  ),\n    power->( four  )->( three ),\n    power->( three )->( four  ),\n);\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383387, "name": "Church numerals", "source": "Translate Perl to Python: use 5.020;\nuse feature qw<signatures>;\nno warnings qw<experimental::signatures>;\n\nuse constant zero  => sub ($f) {\n                      sub ($x) { $x }};\n\nuse constant succ  => sub ($n) {\n                      sub ($f) {\n                      sub ($x) { $f->($n->($f)($x)) }}};\n\nuse constant add   => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($f)($n->($f)($x)) }}}};\n\nuse constant mult  => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($n->($f))($x) }}}};\n\nuse constant power => sub ($b) {\n                      sub ($e) { $e->($b) }};\n\nuse constant countup   => sub ($i) { $i + 1 };\nuse constant countdown => sub ($i) { $i == 0 ? zero : succ->( __SUB__->($i - 1) ) };\nuse constant to_int    => sub ($f) { $f->(countup)->(0) };\nuse constant from_int  => sub ($x) { countdown->($x) };\n\nuse constant three => succ->(succ->(succ->(zero)));\nuse constant four  => from_int->(4);\n\nsay join ' ', map { to_int->($_) } (\n    add  ->( three )->( four  ),\n    mult ->( three )->( four  ),\n    power->( four  )->( three ),\n    power->( three )->( four  ),\n);\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383388, "name": "Reflection_List methods", "source": "Translate Perl to Python: package Nums;\n\nuse overload ('<=>' => \\&compare);\nsub new     { my $self = shift; bless [@_] }\nsub flip    { my @a = @_; 1/$a }\nsub double  { my @a = @_; 2*$a }\nsub compare { my ($a, $b) = @_; abs($a) <=> abs($b) }\n\nmy $a = Nums->new(42);\nprint \"$_\\n\" for %{ref ($a).\"::\" });\n", "target": "import inspect\n\n\nclass Super(object):\n  def __init__(self, name):\n    self.name = name\n  \n  def __str__(self):\n    return \"Super(%s)\" % (self.name,)\n  \n  def doSup(self):\n    return 'did super stuff'\n  \n  @classmethod\n  def cls(cls):\n    return 'cls method (in sup)'\n  \n  @classmethod\n  def supCls(cls):\n    return 'Super method'\n  \n  @staticmethod\n  def supStatic():\n    return 'static method'\n\nclass Other(object):\n  def otherMethod(self):\n    return 'other method'\n\nclass Sub(Other, Super):\n  def __init__(self, name, *args):\n    super(Sub, self).__init__(name);\n    self.rest = args;\n    self.methods = {}\n  \n  def __dir__(self):\n    return list(set( \\\n        sum([dir(base) for base in type(self).__bases__], []) \\\n        + type(self).__dict__.keys() \\\n        + self.__dict__.keys() \\\n        + self.methods.keys() \\\n      ))\n  \n  def __getattr__(self, name):\n    if name in self.methods:\n      if callable(self.methods[name]) and self.methods[name].__code__.co_argcount > 0:\n        if self.methods[name].__code__.co_varnames[0] == 'self':\n          return self.methods[name].__get__(self, type(self))\n        if self.methods[name].__code__.co_varnames[0] == 'cls':\n          return self.methods[name].__get__(type(self), type)\n      return self.methods[name]\n    raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, name))\n  \n  def __str__(self):\n    return \"Sub(%s)\" % self.name\n  \n  def doSub():\n    return 'did sub stuff'\n  \n  @classmethod\n  def cls(cls):\n    return 'cls method (in Sub)'\n  \n  @classmethod\n  def subCls(cls):\n    return 'Sub method'\n  \n  @staticmethod\n  def subStatic():\n    return 'Sub method'\n\nsup = Super('sup')\nsub = Sub('sub', 0, 'I', 'two')\nsub.methods['incr'] = lambda x: x+1\nsub.methods['strs'] = lambda self, x: str(self) * x\n\n\n[method for method in dir(sub) if callable(getattr(sub, method))]\n\n[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == sub]\n\n\n[method for method in dir(sub) if callable(getattr(sub, method)) and hasattr(getattr(sub, method), '__self__') and getattr(sub, method).__self__ == type(sub)]\n\n\n[method for method in dir(sub) if callable(getattr(sub, method)) and type(getattr(sub, method)) == type(lambda:nil)]\n\n\n\ninspect.getmembers(sub, predicate=inspect.ismethod)\n\nmap(lambda t: t[0], inspect.getmembers(sub, predicate=inspect.ismethod))\n\n"}
{"id": 383389, "name": "Send an unknown method call", "source": "Translate Perl to Python: package Example;\nsub new {\n    bless {}\n}\nsub foo {\n    my ($self, $x) = @_;\n    return 42 + $x;\n}\n\npackage main;\nmy $name = \"foo\";\nprint Example->new->$name(5), \"\\n\"; \n", "target": "class Example(object):\n     def foo(self, x):\n             return 42 + x\n\nname = \"foo\"\ngetattr(Example(), name)(5)      \n"}
{"id": 383390, "name": "Topic variable", "source": "Translate Perl to Python: print sqrt . \" \" for (4, 16, 64)\n", "target": ">>> 3\n3\n>>> _*_, _**0.5\n(9, 1.7320508075688772)\n>>>\n"}
{"id": 383391, "name": "Topic variable", "source": "Translate Perl to Python: print sqrt . \" \" for (4, 16, 64)\n", "target": ">>> 3\n3\n>>> _*_, _**0.5\n(9, 1.7320508075688772)\n>>>\n"}
{"id": 383392, "name": "Bitcoin_public point to address", "source": "Translate Perl to Python: use Crypt::RIPEMD160;\nuse Digest::SHA qw(sha256);\nuse Encode::Base58::GMP;\n\nsub public_point_to_address {\n    my $ec   = join '', '04', @_;                    \n\n    my $octets   = pack 'C*', map { hex } unpack('(a2)65', $ec);      \n    my $hash     = chr(0) . Crypt::RIPEMD160->hash(sha256 $octets);   \n    my $checksum = substr sha256(sha256 $hash), 0, 4;                 \n    my $hex      = join '', '0x',                                     \n                   map { sprintf \"%02X\", $_ }\n                   unpack 'C*', $hash.$checksum;\n    return '1' . sprintf \"%32s\", encode_base58($hex, 'bitcoin');      \n}\n\nsay public_point_to_address\n    '50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n    '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'\n    ;\n", "target": "\n\nimport binascii\nimport functools\nimport hashlib\n\ndigits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef b58(n):\n    return b58(n//58) + digits58[n%58:n%58+1] if n else b''\n\ndef public_point_to_address(x, y):\n    c = b'\\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)\n    r = hashlib.new('ripemd160')\n    r.update(hashlib.sha256(c).digest())\n    c = b'\\x00' + r.digest()\n    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()\n    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))\n\nif __name__ == '__main__':\n    print(public_point_to_address(\n        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))\n"}
{"id": 383393, "name": "Bitcoin_public point to address", "source": "Translate Perl to Python: use Crypt::RIPEMD160;\nuse Digest::SHA qw(sha256);\nuse Encode::Base58::GMP;\n\nsub public_point_to_address {\n    my $ec   = join '', '04', @_;                    \n\n    my $octets   = pack 'C*', map { hex } unpack('(a2)65', $ec);      \n    my $hash     = chr(0) . Crypt::RIPEMD160->hash(sha256 $octets);   \n    my $checksum = substr sha256(sha256 $hash), 0, 4;                 \n    my $hex      = join '', '0x',                                     \n                   map { sprintf \"%02X\", $_ }\n                   unpack 'C*', $hash.$checksum;\n    return '1' . sprintf \"%32s\", encode_base58($hex, 'bitcoin');      \n}\n\nsay public_point_to_address\n    '50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n    '2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'\n    ;\n", "target": "\n\nimport binascii\nimport functools\nimport hashlib\n\ndigits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef b58(n):\n    return b58(n//58) + digits58[n%58:n%58+1] if n else b''\n\ndef public_point_to_address(x, y):\n    c = b'\\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)\n    r = hashlib.new('ripemd160')\n    r.update(hashlib.sha256(c).digest())\n    c = b'\\x00' + r.digest()\n    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()\n    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))\n\nif __name__ == '__main__':\n    print(public_point_to_address(\n        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))\n"}
{"id": 383394, "name": "Canonicalize CIDR", "source": "Translate Perl to Python: \nuse v5.16;\nuse Socket qw(inet_aton inet_ntoa);\n\n\nif (!@ARGV) {\n   chomp(@ARGV = <>);\n}\n\nfor (@ARGV) {\n\n  \n  my ($dotted, $size) = split m\n\n  \n  my $binary = sprintf \"%032b\", unpack('N', inet_aton $dotted);\n\n  \n  substr($binary, $size) = 0 x (32 - $size);\n\n  \n  $dotted = inet_ntoa(pack 'B32', $binary);\n\n  \n  say \"$dotted/$size\";\n}\n", "target": "\n\n\n\nimport sys\nfrom socket import inet_aton, inet_ntoa\nfrom struct import pack, unpack\n\nargs = sys.argv[1:]\nif len(args) == 0:\n    args = sys.stdin.readlines()\n\nfor cidr in args:\n   \n   dotted, size_str = cidr.split('/')\n   size = int(size_str)\n\n   numeric = unpack('!I', inet_aton(dotted))[0]  \n   binary = f'{numeric:\n   prefix = binary[:size + 2]                    \n                                                 \n                                                 \n\n   canon_binary = prefix + '0' * (32 - size)     \n   canon_numeric = int(canon_binary, 2)          \n   canon_dotted = inet_ntoa(pack('!I',\n                            (canon_numeric)))    \n   print(f'{canon_dotted}/{size}')               \n"}
{"id": 383395, "name": "Canonicalize CIDR", "source": "Translate Perl to Python: \nuse v5.16;\nuse Socket qw(inet_aton inet_ntoa);\n\n\nif (!@ARGV) {\n   chomp(@ARGV = <>);\n}\n\nfor (@ARGV) {\n\n  \n  my ($dotted, $size) = split m\n\n  \n  my $binary = sprintf \"%032b\", unpack('N', inet_aton $dotted);\n\n  \n  substr($binary, $size) = 0 x (32 - $size);\n\n  \n  $dotted = inet_ntoa(pack 'B32', $binary);\n\n  \n  say \"$dotted/$size\";\n}\n", "target": "\n\n\n\nimport sys\nfrom socket import inet_aton, inet_ntoa\nfrom struct import pack, unpack\n\nargs = sys.argv[1:]\nif len(args) == 0:\n    args = sys.stdin.readlines()\n\nfor cidr in args:\n   \n   dotted, size_str = cidr.split('/')\n   size = int(size_str)\n\n   numeric = unpack('!I', inet_aton(dotted))[0]  \n   binary = f'{numeric:\n   prefix = binary[:size + 2]                    \n                                                 \n                                                 \n\n   canon_binary = prefix + '0' * (32 - size)     \n   canon_numeric = int(canon_binary, 2)          \n   canon_dotted = inet_ntoa(pack('!I',\n                            (canon_numeric)))    \n   print(f'{canon_dotted}/{size}')               \n"}
{"id": 383396, "name": "Sequence of primorial primes", "source": "Translate Perl to Python: use ntheory \":all\";\nmy $i = 0;\nfor (1..1e6) { \n  my $n = pn_primorial($_);\n  if (is_prime($n-1) || is_prime($n+1)) {\n    print \"$_\\n\";\n    last if ++$i >= 20;\n  }\n}\n", "target": "import pyprimes\n\ndef primorial_prime(_pmax=500):\n    isprime = pyprimes.isprime\n    n, primo = 0, 1\n    for prime in pyprimes.nprimes(_pmax):\n        n, primo = n+1, primo * prime\n        if isprime(primo-1) or isprime(primo+1):\n            yield n\n        \nif __name__ == '__main__':\n    \n    pyprimes.warn_probably = False  \n    for i, n in zip(range(20), primorial_prime()):\n        print('Primorial prime %2i at primorial index: %3i' % (i+1, n))\n"}
{"id": 383397, "name": "Combinations and permutations", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nshowoff( \"Permutations\", \\&P, \"P\", 1 .. 12 );\nshowoff( \"Combinations\", \\&C, \"C\", map $_*10, 1..6 );\nshowoff( \"Permutations\", \\&P_big, \"P\", 5, 50, 500, 1000, 5000, 15000 );\nshowoff( \"Combinations\", \\&C_big, \"C\", map $_*100, 1..10 );\n\nsub showoff {\n\tmy ($text, $code, $fname, @n) = @_;\n\tprint \"\\nA sample of $text from $n[0] to $n[-1]\\n\";\n\tfor my $n ( @n ) {\n\t\tmy $k = int( $n / 3 );\n\t\tprint $n, \" $fname $k = \", $code->($n, $k), \"\\n\";\n\t}\n}\n\nsub P {\n\tmy ($n, $k) = @_;\n\tmy $x = 1;\n\t$x *= $_ for $n - $k + 1 .. $n ;\n\t$x;\n}\n\nsub P_big {\n\tmy ($n, $k) = @_;\n\tmy $x = 0;\n\t$x += log($_) for $n - $k + 1 .. $n ;\n\teshow($x);\n}\n\nsub C {\n\tmy ($n, $k) = @_;\n\tmy $x = 1;\n\t$x *= ($n - $_ + 1) / $_ for 1 .. $k;\n\t$x;\n}\n\nsub C_big {\n\tmy ($n, $k) = @_;\n\tmy $x = 0;\n\t$x += log($n - $_ + 1) - log($_) for 1 .. $k;\n\texp($x);\n}\n\nsub eshow {\n\tmy ($x) = @_;\n\tmy $e = int( $x / log(10) );\n\tsprintf \"%.8Fe%+d\", exp($x - $e * log(10)), $e;\n}\n", "target": "from __future__ import print_function\n\nfrom scipy.misc import factorial as fact\nfrom scipy.misc import comb\n\ndef perm(N, k, exact=0):\n    return comb(N, k, exact) * fact(k, exact)\n\nexact=True\nprint('Sample Perms 1..12')\nfor N in range(1, 13):\n    k = max(N-2, 1)\n    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\\n')\n          \nprint('\\n\\nSample Combs 10..60')\nfor N in range(10, 61, 10):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\\n')\n\nexact=False\nprint('\\n\\nSample Perms 5..1500 Using FP approximations')\nfor N in [5, 15, 150, 1500, 15000]:\n    k = N-2\n    print('%iP%i =' % (N, k), perm(N, k, exact))\n          \nprint('\\nSample Combs 100..1000 Using FP approximations')\nfor N in range(100, 1001, 100):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact))\n"}
{"id": 383398, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Perl to Python: use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   \nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 383399, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Perl to Python: use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   \nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 383400, "name": "Window creation_X11", "source": "Translate Perl to Python: \nuse strict;\nuse X11::Protocol;\n\nmy $X = X11::Protocol->new;\n\nmy $window = $X->new_rsrc;\n$X->CreateWindow ($window,\n                  $X->root,         \n                  'InputOutput',    \n                  0,                \n                  0,                \n                  0,0,              \n                  300,100,          \n                  0,                \n                  background_pixel => $X->black_pixel,\n                  event_mask       => $X->pack_event_mask('Exposure',\n                                                          'ButtonPress'),\n                 );\n\nmy $gc = $X->new_rsrc;\n$X->CreateGC ($gc, $window,\n              foreground => $X->white_pixel);\n\n$X->{'event_handler'} = sub {\n  my %event = @_;\n  my $event_name = $event{'name'};\n\n  if ($event_name eq 'Expose') {\n    $X->PolyRectangle ($window, $gc, [ 10,10,     \n                                       30,20 ]);  \n    $X->PolyText8 ($window, $gc,\n                   10, 55,    \n                   [ 0,  \n                     'Hello ... click mouse button to exit.' ]);\n\n  } elsif ($event_name eq 'ButtonPress') {\n    exit 0;\n  }\n};\n\n$X->MapWindow ($window);\nfor (;;) {\n  $X->handle_input;\n}\n", "target": "from Xlib import X, display\n\nclass Window:\n    def __init__(self, display, msg):\n        self.display = display\n        self.msg = msg\n        \n        self.screen = self.display.screen()\n        self.window = self.screen.root.create_window(\n            10, 10, 100, 100, 1,\n            self.screen.root_depth,\n            background_pixel=self.screen.white_pixel,\n            event_mask=X.ExposureMask | X.KeyPressMask,\n            )\n        self.gc = self.window.create_gc(\n            foreground = self.screen.black_pixel,\n            background = self.screen.white_pixel,\n            )\n\n        self.window.map()\n\n    def loop(self):\n        while True:\n            e = self.display.next_event()\n                \n            if e.type == X.Expose:\n                self.window.fill_rectangle(self.gc, 20, 20, 10, 10)\n                self.window.draw_text(self.gc, 10, 50, self.msg)\n            elif e.type == X.KeyPress:\n                raise SystemExit\n\n                \nif __name__ == \"__main__\":\n    Window(display.Display(), \"Hello, World!\").loop()\n"}
{"id": 383401, "name": "Long primes", "source": "Translate Perl to Python: use ntheory qw/divisors powmod is_prime/;\n\nsub is_long_prime {\n    my($p) = @_;\n    return 0 unless is_prime($p);\n    for my $d (divisors($p-1)) {\n        return $d+1 == $p if powmod(10, $d, $p) == 1;\n    }\n    0;\n}\n\nprint \"Long primes \u2264 500:\\n\";\nprint join(' ', grep {is_long_prime($_) } 1 .. 500), \"\\n\\n\";\n\nfor my $n (500, 1000, 2000, 4000, 8000, 16000, 32000, 64000) {\n    printf \"Number of long primes \u2264 $n: %d\\n\",  scalar grep { is_long_prime($_) } 1 .. $n;\n}\n", "target": "def sieve(limit):\n    primes = []\n    c = [False] * (limit + 1) \n    \n    p = 3\n    while True:\n        p2 = p * p\n        if p2 > limit: break\n        for i in range(p2, limit, 2 * p): c[i] = True\n        while True:\n            p += 2\n            if not c[p]: break\n\n    for i in range(3, limit, 2):\n        if not c[i]: primes.append(i)\n    return primes\n\n\ndef findPeriod(n):\n    r = 1\n    for i in range(1, n): r = (10 * r) % n\n    rr = r\n    period = 0\n    while True:\n        r = (10 * r) % n\n        period += 1\n        if r == rr: break\n    return period\n\nprimes = sieve(64000)\nlongPrimes = []\nfor prime in primes:\n    if findPeriod(prime) == prime - 1:\n        longPrimes.append(prime)\nnumbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]\ncount = 0\nindex = 0\ntotals = [0] * len(numbers)\nfor longPrime in longPrimes:\n    if longPrime > numbers[index]:\n        totals[index] = count\n        index += 1\n    count += 1\ntotals[-1] = count\nprint('The long primes up to 500 are:')\nprint(str(longPrimes[:totals[0]]).replace(',', ''))\nprint('\\nThe number of long primes up to:')\nfor (i, total) in enumerate(totals):\n    print('  %5d is %d' % (numbers[i], total))\n"}
{"id": 383402, "name": "Biorhythms", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse DateTime;\n\nuse constant PI => 2 * atan2(1, 0);\n\nmy %cycles = ( 'Physical' => 23, 'Emotional' => 28, 'Mental' => 33 );\nmy @Q = ( ['up and rising',    'peak'],\n          ['up but falling',   'transition'],\n          ['down and falling', 'valley'],\n          ['down but rising',  'transition']\n        );\n\nmy $target = DateTime->new(year=>1863, month=>11, day=>19);\nmy $bday   = DateTime->new(year=>1809, month=> 2, day=>12);\n\nmy $days   = $bday->delta_days( $target )->in_units('days');\n\nprint \"Day $days:\\n\";\nfor my $label (sort keys %cycles) {\n    my($length) = $cycles{$label};\n    my $position = $days % $length;\n    my $quadrant = int $position / $length * 4;\n    my $percentage = int(sin($position / $length * 2 * PI )*1000)/10;\n    my $description;\n    if    (    $percentage  >  95) { $description = 'peak' }\n    elsif (    $percentage  < -95) { $description = 'valley' }\n    elsif (abs($percentage) <   5) { $description = 'critical transition' }\n    else {\n        my $transition = $target->clone->add( days => (int(($quadrant + 1)/4 * $length) - $position))->ymd;\n        my ($trend, $next) = @{$Q[$quadrant]};\n        $description = sprintf \"%5.1f%% ($trend, next $next $transition)\", $percentage;\n    }\n    printf \"%-13s %2d: %s\", \"$label day\\n\", $position, $description;\n}\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 383403, "name": "Biorhythms", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse DateTime;\n\nuse constant PI => 2 * atan2(1, 0);\n\nmy %cycles = ( 'Physical' => 23, 'Emotional' => 28, 'Mental' => 33 );\nmy @Q = ( ['up and rising',    'peak'],\n          ['up but falling',   'transition'],\n          ['down and falling', 'valley'],\n          ['down but rising',  'transition']\n        );\n\nmy $target = DateTime->new(year=>1863, month=>11, day=>19);\nmy $bday   = DateTime->new(year=>1809, month=> 2, day=>12);\n\nmy $days   = $bday->delta_days( $target )->in_units('days');\n\nprint \"Day $days:\\n\";\nfor my $label (sort keys %cycles) {\n    my($length) = $cycles{$label};\n    my $position = $days % $length;\n    my $quadrant = int $position / $length * 4;\n    my $percentage = int(sin($position / $length * 2 * PI )*1000)/10;\n    my $description;\n    if    (    $percentage  >  95) { $description = 'peak' }\n    elsif (    $percentage  < -95) { $description = 'valley' }\n    elsif (abs($percentage) <   5) { $description = 'critical transition' }\n    else {\n        my $transition = $target->clone->add( days => (int(($quadrant + 1)/4 * $length) - $position))->ymd;\n        my ($trend, $next) = @{$Q[$quadrant]};\n        $description = sprintf \"%5.1f%% ($trend, next $next $transition)\", $percentage;\n    }\n    printf \"%-13s %2d: %s\", \"$label day\\n\", $position, $description;\n}\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 383404, "name": "Primorial numbers", "source": "Translate Perl to Python: use ntheory qw(pn_primorial);\n\nsay \"First ten primorials: \", join \", \", map { pn_primorial($_) } 0..9;\n\nsay \"primorial(10^$_) has \".(length pn_primorial(10**$_)).\" digits\" for 1..6;\n", "target": "from pyprimes import nprimes\nfrom functools import reduce\n\n\nprimelist = list(nprimes(1000001))    \n\ndef primorial(n):\n    return reduce(int.__mul__, primelist[:n], 1)\n\nif __name__ == '__main__':\n    print('First ten primorals:', [primorial(n) for n in range(10)])\n    for e in range(7):\n        n = 10**e\n        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))\n"}
{"id": 383405, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nsub isEgyption{\n    my $nr = int($_[0]);\n    my $de = int($_[1]);\n    if($nr == 0 or $de == 0){\n\t\n\treturn;\n    }\n    if($de % $nr == 0){\n\t\n\tprintf \"1/\" . int($de/$nr);\n\treturn;\n    }\n    if($nr % $de == 0){\n\t\n\tprintf $nr/$de;\n\treturn;\n    }\n    if($nr > $de){\n        printf int($nr/$de) . \" + \";\n\tisEgyption($nr%$de, $de);\n\treturn;\n    }\n    \n    my $tmp = int($de/$nr) + 1;\n    printf \"1/\" . $tmp . \" + \";\n    isEgyption($nr*$tmp-$de, $de*$tmp);\n}\n\nmy $nrI = 2014;\nmy $deI = 59;\nprintf \"\\nEgyptian Fraction Representation of \" . $nrI . \"/\" . $deI . \" is: \\n\\n\";\nisEgyption($nrI,$deI);\n", "target": "from fractions import Fraction\nfrom math import ceil\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '%s/%s' % (self.numerator, self.denominator)\n\ndef ef(fr):\n    ans = []\n    if fr >= 1:\n        if fr.denominator == 1:\n            return [[int(fr)], Fr(0, 1)]\n        intfr = int(fr)\n        ans, fr = [[intfr]], fr - intfr\n    x, y = fr.numerator, fr.denominator\n    while x != 1:\n        ans.append(Fr(1, ceil(1/fr)))\n        fr = Fr(-y % x, y* ceil(1/fr))\n        x, y = fr.numerator, fr.denominator\n    ans.append(fr)\n    return ans\n\nif __name__ == '__main__':\n    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:\n        print('%r \u2500\u25ba %s' % (fr, ' '.join(str(x) for x in ef(fr))))\n    lenmax = denommax = (0, None) \n    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):\n        e = ef(fr)\n        \n        elen, edenom = len(e), e[-1].denominator\n        if elen > lenmax[0]:\n            lenmax = (elen, fr, e)\n        if edenom > denommax[0]:\n            denommax = (edenom, fr, e)\n    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))\n    dstr = str(denommax[0])\n    print('Denominator max is %r with %i digits %s...%s' %\n          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))\n"}
{"id": 383406, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nsub isEgyption{\n    my $nr = int($_[0]);\n    my $de = int($_[1]);\n    if($nr == 0 or $de == 0){\n\t\n\treturn;\n    }\n    if($de % $nr == 0){\n\t\n\tprintf \"1/\" . int($de/$nr);\n\treturn;\n    }\n    if($nr % $de == 0){\n\t\n\tprintf $nr/$de;\n\treturn;\n    }\n    if($nr > $de){\n        printf int($nr/$de) . \" + \";\n\tisEgyption($nr%$de, $de);\n\treturn;\n    }\n    \n    my $tmp = int($de/$nr) + 1;\n    printf \"1/\" . $tmp . \" + \";\n    isEgyption($nr*$tmp-$de, $de*$tmp);\n}\n\nmy $nrI = 2014;\nmy $deI = 59;\nprintf \"\\nEgyptian Fraction Representation of \" . $nrI . \"/\" . $deI . \" is: \\n\\n\";\nisEgyption($nrI,$deI);\n", "target": "from fractions import Fraction\nfrom math import ceil\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '%s/%s' % (self.numerator, self.denominator)\n\ndef ef(fr):\n    ans = []\n    if fr >= 1:\n        if fr.denominator == 1:\n            return [[int(fr)], Fr(0, 1)]\n        intfr = int(fr)\n        ans, fr = [[intfr]], fr - intfr\n    x, y = fr.numerator, fr.denominator\n    while x != 1:\n        ans.append(Fr(1, ceil(1/fr)))\n        fr = Fr(-y % x, y* ceil(1/fr))\n        x, y = fr.numerator, fr.denominator\n    ans.append(fr)\n    return ans\n\nif __name__ == '__main__':\n    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:\n        print('%r \u2500\u25ba %s' % (fr, ' '.join(str(x) for x in ef(fr))))\n    lenmax = denommax = (0, None) \n    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):\n        e = ef(fr)\n        \n        elen, edenom = len(e), e[-1].denominator\n        if elen > lenmax[0]:\n            lenmax = (elen, fr, e)\n        if edenom > denommax[0]:\n            denommax = (edenom, fr, e)\n    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))\n    dstr = str(denommax[0])\n    print('Denominator max is %r with %i digits %s...%s' %\n          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))\n"}
{"id": 383407, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Perl to Python: use List::Util qw(sum);\nuse constant pi => 3.14159265;\n\nsub legendre_pair {\n    my($n, $x) = @_;\n    if ($n == 1) { return $x, 1 }\n    my ($m1, $m2) = legendre_pair($n - 1, $x);\n    my $u = 1 - 1 / $n;\n    (1 + $u) * $x * $m1 - $u * $m2, $m1;\n}\n\nsub legendre {\n    my($n, $x) = @_;\n    (legendre_pair($n, $x))[0]\n}\n\nsub legendre_prime {\n    my($n, $x) = @_;\n    if ($n == 0) { return 0 }\n    if ($n == 1) { return 1 }\n    my ($m0, $m1) = legendre_pair($n, $x);\n    ($m1 - $x * $m0) * $n / (1 - $x**2);\n}\n\nsub approximate_legendre_root {\n    my($n, $k) = @_;\n    my $t = (4*$k - 1) / (4*$n + 2);\n    (1 - ($n - 1) / (8 * $n**3)) * cos(pi * $t);\n}\n\nsub newton_raphson {\n    my($n, $r) = @_;\n    while (abs(my $dr = - legendre($n,$r) / legendre_prime($n,$r)) >= 2e-16) {\n        $r += $dr;\n    }\n    $r;\n}\n\nsub legendre_root {\n    my($n, $k) = @_;\n    newton_raphson($n, approximate_legendre_root($n, $k));\n}\n\nsub weight {\n    my($n, $r) = @_;\n    2 / ((1 - $r**2) * legendre_prime($n, $r)**2)\n}\n\nsub nodes {\n    my($n) = @_;\n    my %node;\n    $node{'0'} = weight($n, 0) if 0 != $n%2;\n    for (1 .. int $n/2) {\n        my $r = legendre_root($n, $_);\n        my $w = weight($n, $r);\n        $node{$r} = $w; $node{-$r} = $w;\n    }\n    return %node\n}\n\nsub quadrature {\n    our($n, $a, $b) = @_;\n    sub scale { ($_[0] * ($b - $a) + $a + $b) / 2 }\n    %nodes = nodes($n);\n    ($b - $a) / 2 * sum map { $nodes{$_} * exp(scale($_)) } keys %nodes;\n}\n\nprintf(\"Gauss-Legendre %2d-point quadrature \u222b\u208b\u2083\u207a\u00b3 exp(x) dx \u2248\u00a0%.13f\\n\", $_, quadrature($_, -3, +3) )\n        for 5 .. 10, 20;\n", "target": "from numpy import *\n \n\n\ndef Legendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0+1.0\n\telif (n==1):\n\t\treturn x\n\telse:\n\t\treturn ((2.0*n-1.0)*x*Legendre(n-1,x)-(n-1)*Legendre(n-2,x))/n\n \n\n\ndef DLegendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0\n\telif (n==1):\n\t\treturn x*0+1.0\n\telse:\n\t\treturn (n/(x**2-1.0))*(x*Legendre(n,x)-Legendre(n-1,x))\n\n\ndef LegendreRoots(polyorder,tolerance=1e-20):\n\tif polyorder<2:\n\t\terr=1 \n\telse:\n\t\troots=[]\n\t\t\n\t\tfor i in range(1,int(polyorder)/2 +1):\n\t\t\tx=cos(pi*(i-0.25)/(polyorder+0.5))\n\t\t\terror=10*tolerance\n\t\t        iters=0\n\t\t        while (error>tolerance) and (iters<1000):\n\t\t                dx=-Legendre(polyorder,x)/DLegendre(polyorder,x)\n\t\t                x=x+dx\n\t\t                iters=iters+1\n\t\t                error=abs(dx)\n\t\t\troots.append(x)\n\t\t\n\t\troots=array(roots)\n\t\tif polyorder%2==0:\n\t\t\troots=concatenate( (-1.0*roots, roots[::-1]) )\n\t\telse:\n\t\t\troots=concatenate( (-1.0*roots, [0.0], roots[::-1]) )\n\t\terr=0 \n\treturn [roots, err]\n\n\ndef GaussLegendreWeights(polyorder):\n\tW=[]\n\t[xis,err]=LegendreRoots(polyorder)\n\tif err==0:\n\t\tW=2.0/( (1.0-xis**2)*(DLegendre(polyorder,xis)**2) )\n\t\terr=0\n\telse:\n\t\terr=1 \n\treturn [W, xis, err]\n\n\n\n\n\n\ndef GaussLegendreQuadrature(func, polyorder, a, b):\n\t[Ws,xs, err]= GaussLegendreWeights(polyorder)\n\tif err==0:\n\t\tans=(b-a)*0.5*sum( Ws*func( (b-a)*0.5*xs+ (b+a)*0.5 ) )\n\telse: \n\t\t\n\t\terr=1\n\t\tans=None\n\treturn [ans,err]\n\n\ndef func(x):\n\treturn exp(x)\n\n\n \norder=5\n[Ws,xs,err]=GaussLegendreWeights(order)\nif err==0:\n\tprint \"Order   \u00a0: \", order\n\tprint \"Roots   \u00a0: \", xs\n\tprint \"Weights \u00a0: \", Ws\nelse:\n\tprint \"Roots/Weights evaluation failed\"\n \n\n[ans,err]=GaussLegendreQuadrature(func , order, -3,3)\nif err==0:\n\tprint \"Integral\u00a0: \", ans\nelse:\n\tprint \"Integral evaluation failed\"\n"}
{"id": 383408, "name": "Color quantization", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Imager;\n\nmy $img = Imager->new;\n$img->read(file => 'frog.png');\nmy $img16 = $img->to_paletted({ max_colors => 16});\n$img16->write(file => \"frog-16.png\")\n", "target": "from PIL import Image\n\nif __name__==\"__main__\":\n\tim = Image.open(\"frog.png\")\n\tim2 = im.quantize(16)\n\tim2.show()\n"}
{"id": 383409, "name": "Cut a rectangle", "source": "Translate Perl to Python: use strict;\nuse warnings;\nmy @grid = 0;\n \nmy ($w, $h, $len);\nmy $cnt = 0;\n \nmy @next;\nmy @dir = ([0, -1], [-1, 0], [0, 1], [1, 0]);\n\nsub walk {\n    my ($y, $x) = @_;\n\n    if (!$y || $y == $h || !$x || $x == $w) {\n\t$cnt += 2;\n\treturn;\n    }\n\n    my $t = $y * ($w + 1) + $x;\n    $grid[$_]++ for $t, $len - $t;\n \n    for my $i (0 .. 3) {\n\tif (!$grid[$t + $next[$i]]) {\n\t    walk($y + $dir[$i]->[0], $x + $dir[$i]->[1]);\n\t}\n    }\n \n    $grid[$_]-- for $t, $len - $t;\n}\n \nsub solve {\n    my ($hh, $ww, $recur) = @_;\n    my ($t, $cx, $cy, $x);\n    ($h, $w) = ($hh, $ww);\n \n    if ($h & 1) { ($t, $w, $h) = ($w, $h, $w); }\n    if ($h & 1) { return 0; }\n    if ($w == 1) { return 1; }\n    if ($w == 2) { return $h; }\n    if ($h == 2) { return $w; }\n \n    {\n\tuse integer;\n\t($cy, $cx) = ($h / 2, $w / 2);\n    }\n \n    $len = ($h + 1) * ($w + 1);\n    @grid = ();\n    $grid[$len--] = 0;\n \n    @next = (-1, -$w - 1, 1, $w + 1);\n \n    if ($recur) { $cnt = 0; }\n    for ($x = $cx + 1; $x < $w; $x++) {\n\t$t = $cy * ($w + 1) + $x;\n\t@grid[$t, $len - $t] = (1, 1);\n\twalk($cy - 1, $x);\n    }\n    $cnt++;\n \n    if ($h == $w) {\n\t$cnt *= 2;\n    } elsif (!($w & 1) && $recur) {\n\tsolve($w, $h);\n    }\n \n    return $cnt;\n}\n \nsub MAIN {\n    print \"ok\\n\";\n    my ($y, $x);\n    for my $y (1 .. 10) {\n\tfor my $x (1 .. $y) {\n\t    if (!($x & 1) || !($y & 1)) {\n\t\tprintf(\"%d x %d: %d\\n\", $y, $x, solve($y, $x, 1));\n\t    }\n\t}\n    }\n}\n\nMAIN();\n", "target": "def cut_it(h, w):\n    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))\n    if h % 2: h, w = w, h\n    if h % 2: return 0\n    if w == 1: return 1\n    count = 0\n\n    next = [w + 1, -w - 1, -1, 1]\n    blen = (h + 1) * (w + 1) - 1\n    grid = [False] * (blen + 1)\n\n    def walk(y, x, count):\n        if not y or y == h or not x or x == w:\n            return count + 1\n\n        t = y * (w + 1) + x\n        grid[t] = grid[blen - t] = True\n\n        if not grid[t + next[0]]:\n            count = walk(y + dirs[0][0], x + dirs[0][1], count)\n        if not grid[t + next[1]]:\n            count = walk(y + dirs[1][0], x + dirs[1][1], count)\n        if not grid[t + next[2]]:\n            count = walk(y + dirs[2][0], x + dirs[2][1], count)\n        if not grid[t + next[3]]:\n            count = walk(y + dirs[3][0], x + dirs[3][1], count)\n\n        grid[t] = grid[blen - t] = False\n        return count\n\n    t = h // 2 * (w + 1) + w // 2\n    if w % 2:\n        grid[t] = grid[t + 1] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        res = count\n        count = 0\n        count = walk(h // 2 - 1, w // 2, count)\n        return res + count * 2\n    else:\n        grid[t] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        if h == w:\n            return count * 2\n        count = walk(h // 2 - 1, w // 2, count)\n        return count\n\ndef main():\n    for w in xrange(1, 10):\n        for h in xrange(1, w + 1):\n            if not((w * h) % 2):\n                print \"%d x %d: %d\" % (w, h, cut_it(w, h))\n\nmain()\n"}
{"id": 383410, "name": "Cut a rectangle", "source": "Translate Perl to Python: use strict;\nuse warnings;\nmy @grid = 0;\n \nmy ($w, $h, $len);\nmy $cnt = 0;\n \nmy @next;\nmy @dir = ([0, -1], [-1, 0], [0, 1], [1, 0]);\n\nsub walk {\n    my ($y, $x) = @_;\n\n    if (!$y || $y == $h || !$x || $x == $w) {\n\t$cnt += 2;\n\treturn;\n    }\n\n    my $t = $y * ($w + 1) + $x;\n    $grid[$_]++ for $t, $len - $t;\n \n    for my $i (0 .. 3) {\n\tif (!$grid[$t + $next[$i]]) {\n\t    walk($y + $dir[$i]->[0], $x + $dir[$i]->[1]);\n\t}\n    }\n \n    $grid[$_]-- for $t, $len - $t;\n}\n \nsub solve {\n    my ($hh, $ww, $recur) = @_;\n    my ($t, $cx, $cy, $x);\n    ($h, $w) = ($hh, $ww);\n \n    if ($h & 1) { ($t, $w, $h) = ($w, $h, $w); }\n    if ($h & 1) { return 0; }\n    if ($w == 1) { return 1; }\n    if ($w == 2) { return $h; }\n    if ($h == 2) { return $w; }\n \n    {\n\tuse integer;\n\t($cy, $cx) = ($h / 2, $w / 2);\n    }\n \n    $len = ($h + 1) * ($w + 1);\n    @grid = ();\n    $grid[$len--] = 0;\n \n    @next = (-1, -$w - 1, 1, $w + 1);\n \n    if ($recur) { $cnt = 0; }\n    for ($x = $cx + 1; $x < $w; $x++) {\n\t$t = $cy * ($w + 1) + $x;\n\t@grid[$t, $len - $t] = (1, 1);\n\twalk($cy - 1, $x);\n    }\n    $cnt++;\n \n    if ($h == $w) {\n\t$cnt *= 2;\n    } elsif (!($w & 1) && $recur) {\n\tsolve($w, $h);\n    }\n \n    return $cnt;\n}\n \nsub MAIN {\n    print \"ok\\n\";\n    my ($y, $x);\n    for my $y (1 .. 10) {\n\tfor my $x (1 .. $y) {\n\t    if (!($x & 1) || !($y & 1)) {\n\t\tprintf(\"%d x %d: %d\\n\", $y, $x, solve($y, $x, 1));\n\t    }\n\t}\n    }\n}\n\nMAIN();\n", "target": "def cut_it(h, w):\n    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))\n    if h % 2: h, w = w, h\n    if h % 2: return 0\n    if w == 1: return 1\n    count = 0\n\n    next = [w + 1, -w - 1, -1, 1]\n    blen = (h + 1) * (w + 1) - 1\n    grid = [False] * (blen + 1)\n\n    def walk(y, x, count):\n        if not y or y == h or not x or x == w:\n            return count + 1\n\n        t = y * (w + 1) + x\n        grid[t] = grid[blen - t] = True\n\n        if not grid[t + next[0]]:\n            count = walk(y + dirs[0][0], x + dirs[0][1], count)\n        if not grid[t + next[1]]:\n            count = walk(y + dirs[1][0], x + dirs[1][1], count)\n        if not grid[t + next[2]]:\n            count = walk(y + dirs[2][0], x + dirs[2][1], count)\n        if not grid[t + next[3]]:\n            count = walk(y + dirs[3][0], x + dirs[3][1], count)\n\n        grid[t] = grid[blen - t] = False\n        return count\n\n    t = h // 2 * (w + 1) + w // 2\n    if w % 2:\n        grid[t] = grid[t + 1] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        res = count\n        count = 0\n        count = walk(h // 2 - 1, w // 2, count)\n        return res + count * 2\n    else:\n        grid[t] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        if h == w:\n            return count * 2\n        count = walk(h // 2 - 1, w // 2, count)\n        return count\n\ndef main():\n    for w in xrange(1, 10):\n        for h in xrange(1, w + 1):\n            if not((w * h) % 2):\n                print \"%d x %d: %d\" % (w, h, cut_it(w, h))\n\nmain()\n"}
{"id": 383411, "name": "Cuban primes", "source": "Translate Perl to Python: use feature 'say';\nuse ntheory 'is_prime';\n\nsub cuban_primes {\n    my ($n) = @_;\n\n    my @primes;\n    for (my $k = 1 ; ; ++$k) {\n        my $p = 3 * $k * ($k + 1) + 1;\n        if (is_prime($p)) {\n            push @primes, $p;\n            last if @primes >= $n;\n        }\n    }\n\n    return @primes;\n}\n\nsub commify {\n    scalar reverse join ',', unpack '(A3)*', reverse shift;\n}\n\nmy @c = cuban_primes(200);\n\nwhile (@c) {\n    say join ' ', map { sprintf \"%9s\", commify $_ } splice(@c, 0, 10);\n}\n\nsay '';\nfor my $n (1 .. 6) {\n    say \"10^$n-th cuban prime is: \", commify((cuban_primes(10**$n))[-1]);\n}\n", "target": "import datetime\nimport math\n\nprimes = [ 3, 5 ]\n\ncutOff = 200\n\nbigUn =  100_000\nchunks = 50\nlittle = bigUn / chunks\n\ntn = \" cuban prime\"\nprint (\"The first {:,}{}s:\".format(cutOff, tn))\n\nc = 0\nshowEach = True\nu = 0\nv = 1\nst = datetime.datetime.now()\n\nfor i in range(1, int(math.pow(2,20))):\n\tfound = False\n\tu += 6\n\tv += u\n\tmx = int(math.sqrt(v))\n\t\n\tfor item in primes:\n\t\tif (item > mx):\n\t\t\tbreak\n\t\tif (v % item == 0):\n\t\t\tfound = True\n\t\t\tbreak\n\t\n\tif (found == 0):\n\t\tc += 1\n\t\tif (showEach):\n\t\t\tz = primes[-1]\n\t\t\twhile (z <= v - 2):\n\t\t\t\tz += 2\n\t\t\t\t\n\t\t\t\tfnd = False\n\t\t\t\tfor item in primes:\n\t\t\t\t\tif (item > mx):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif (z % item == 0):\n\t\t\t\t\t\tfnd = True\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\tif (not fnd):\n\t\t\t\t\tprimes.append(z)\n\t\t\t\n\t\t\tprimes.append(v)\n\t\t\tprint(\"{:>11,}\".format(v), end='')\n\t\t\t\n\t\t\tif (c % 10 == 0):\n\t\t\t\tprint(\"\");\n\t\t\tif (c == cutOff):\n\t\t\t\tshowEach = False\n\t\t\t\tprint (\"Progress to the {:,}th {}:\".format(bigUn, tn), end='')\n\t\tif (c % little == 0):\n\t\t\tprint('.', end='')\n\t\tif (c == bigUn):\n\t\t\tbreak\n\nprint(\"\");\nprint (\"The {:,}th{} is {:,}\".format(c, tn, v))\nprint(\"Computation time was {} seconds\".format((datetime.datetime.now() - st).seconds))\n"}
{"id": 383412, "name": "Chaos game", "source": "Translate Perl to Python: use Imager;\n\nmy $width  = 1000;\nmy $height = 1000;\n\nmy @points = (\n    [ $width/2,         0],\n    [        0, $height-1],\n    [$height-1, $height-1],\n);\n\nmy $img = Imager->new(\n                      xsize    => $width,\n                      ysize    => $height,\n                      channels => 3,\n                     );\n\nmy $color = Imager::Color->new('\nmy $r = [int(rand($width)), int(rand($height))];\n\nforeach my $i (1 .. 100000) {\n    my $p = $points[rand @points];\n\n    my $h = [\n        int(($p->[0] + $r->[0]) / 2),\n        int(($p->[1] + $r->[1]) / 2),\n    ];\n\n    $img->setpixel(\n        x     => $h->[0],\n        y     => $h->[1],\n        color => $color,\n    );\n\n    $r = $h;\n}\n\n$img->write(file => 'chaos_game_triangle.png');\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 383413, "name": "Chaos game", "source": "Translate Perl to Python: use Imager;\n\nmy $width  = 1000;\nmy $height = 1000;\n\nmy @points = (\n    [ $width/2,         0],\n    [        0, $height-1],\n    [$height-1, $height-1],\n);\n\nmy $img = Imager->new(\n                      xsize    => $width,\n                      ysize    => $height,\n                      channels => 3,\n                     );\n\nmy $color = Imager::Color->new('\nmy $r = [int(rand($width)), int(rand($height))];\n\nforeach my $i (1 .. 100000) {\n    my $p = $points[rand @points];\n\n    my $h = [\n        int(($p->[0] + $r->[0]) / 2),\n        int(($p->[1] + $r->[1]) / 2),\n    ];\n\n    $img->setpixel(\n        x     => $h->[0],\n        y     => $h->[1],\n        color => $color,\n    );\n\n    $r = $h;\n}\n\n$img->write(file => 'chaos_game_triangle.png');\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 383414, "name": "World Cup group stage", "source": "Translate Perl to Python: use Math::Cartesian::Product;\n\n@scoring = (0, 1, 3);\npush @histo, [(0) x 10] for 1..4;\npush @aoa,    [(0,1,2)] for 1..6;\n\nfor $results (cartesian {@_} @aoa) {\n    my @s;\n    my @g = ([0,1],[0,2],[0,3],[1,2],[1,3],[2,3]);\n    for (0..$\n        $r = $results->[$_];\n        $s[$g[$_][0]] += $scoring[$r];\n        $s[$g[$_][1]] += $scoring[2 - $r];\n    }\n\n    my @ss = sort @s;\n    $histo[$_][$ss[$_]]++ for 0..$\n}\n\n$fmt = ('%3d ') x 10 . \"\\n\";\nprintf $fmt, @$_ for reverse @histo;\n", "target": "from itertools import product, combinations, izip\n\nscoring = [0, 1, 3]\nhisto = [[0] * 10 for _ in xrange(4)]\n\nfor results in product(range(3), repeat=6):\n    s = [0] * 4\n    for r, g in izip(results, combinations(range(4), 2)):\n        s[g[0]] += scoring[r]\n        s[g[1]] += scoring[2 - r]\n\n    for h, v in izip(histo, sorted(s)):\n        h[v] += 1\n\nfor x in reversed(histo):\n    print x\n"}
{"id": 383415, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Perl to Python: my %prec = (\n    '^' => 4,\n    '*' => 3,\n    '/' => 3,\n    '+' => 2,\n    '-' => 2,\n    '(' => 1\n);\n\nmy %assoc = (\n    '^' => 'right',\n    '*' => 'left',\n    '/' => 'left',\n    '+' => 'left',\n    '-' => 'left'\n);\n\nsub shunting_yard {\n    my @inp = split ' ', $_[0];\n    my @ops;\n    my @res;\n\n    my $report = sub { printf \"%25s   \u00a0%-7s %10s %s\\n\", \"@res\", \"@ops\", $_[0], \"@inp\" };\n    my $shift  = sub { $report->(\"shift @_\");  push @ops, @_ };\n    my $reduce = sub { $report->(\"reduce @_\"); push @res, @_ };\n\n    while (@inp) {\n        my $token = shift @inp;\n        if    ( $token =~ /\\d/ ) { $reduce->($token) }\n        elsif ( $token eq '(' )  { $shift->($token) }\n        elsif ( $token eq ')' ) {\n            while ( @ops and \"(\" ne ( my $x = pop @ops ) ) { $reduce->($x) }\n        } else {\n            my $newprec = $prec{$token};\n            while (@ops) {\n                my $oldprec = $prec{ $ops[-1] };\n                last if $newprec > $oldprec;\n                last if $newprec == $oldprec and $assoc{$token} eq 'right';\n                $reduce->( pop @ops );\n            }\n            $shift->($token);\n        }\n    }\n    $reduce->( pop @ops ) while @ops;\n    @res;\n}\n\nlocal $, = \" \";\nprint shunting_yard '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3';\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\n\nOpInfo = namedtuple('OpInfo', 'prec assoc')\nL, R = 'Left Right'.split()\n\nops = {\n '^': OpInfo(prec=4, assoc=R),\n '*': OpInfo(prec=3, assoc=L),\n '/': OpInfo(prec=3, assoc=L),\n '+': OpInfo(prec=2, assoc=L),\n '-': OpInfo(prec=2, assoc=L),\n '(': OpInfo(prec=9, assoc=L),\n ')': OpInfo(prec=0, assoc=L),\n }\n\nNUM, LPAREN, RPAREN = 'NUMBER ( )'.split()\n\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    tokenvals = []\n    for token in tokens:\n        if token in ops:\n            tokenvals.append((token, ops[token]))\n        \n        \n        else:    \n            tokenvals.append((NUM, token))\n    return tokenvals\n\ndef shunting(tokenvals):\n    outq, stack = [], []\n    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]\n    for token, val in tokenvals:\n        note = action = ''\n        if token is NUM:\n            action = 'Add number to output'\n            outq.append(val)\n            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        elif token in ops:\n            t1, (p1, a1) = token, val\n            v = t1\n            note = 'Pop ops from stack to output' \n            while stack:\n                t2, (p2, a2) = stack[-1]\n                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):\n                    if t1 != RPAREN:\n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            break\n                    else:        \n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            stack.pop()\n                            action = '(Pop & discard \"(\")'\n                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                            break\n                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                    v = note = ''\n                else:\n                    note = ''\n                    break\n                note = '' \n            note = '' \n            if t1 != RPAREN:\n                stack.append((token, val))\n                action = 'Push op token to stack'\n            else:\n                action = 'Discard \")\"'\n            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n    note = 'Drain stack to output'\n    while stack:\n        v = ''\n        t2, (p2, a2) = stack[-1]\n        action = '(Pop op)'\n        stack.pop()\n        outq.append(t2)\n        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        v = note = ''\n    return table\n\nif __name__ == '__main__':\n    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'\n    print( 'For infix expression: %r\\n' % infix )\n    rp = shunting(get_input(infix))\n    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output RPN is: %r' % rp[-1][2])\n"}
{"id": 383416, "name": "Perlin noise", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse experimental 'signatures';\n\nuse constant permutation => qw{\n 151 160 137  91  90  15 131  13 201  95  96  53 194 233   7 225 140  36 103  30  69\n 142   8  99  37 240  21  10  23 190   6 148 247 120 234  75   0  26 197  62  94 252\n 219 203 117  35  11  32  57 177  33  88 237 149  56  87 174  20 125 136 171 168  68\n 175  74 165  71 134 139  48  27 166  77 146 158 231  83 111 229 122  60 211 133 230\n 220 105  92  41  55  46 245  40 244 102 143  54  65  25  63 161   1 216  80  73 209\n  76 132 187 208  89  18 169 200 196 135 130 116 188 159  86 164 100 109 198 173 186\n   3  64  52 217 226 250 124 123   5 202  38 147 118 126 255  82  85 212 207 206  59\n 227  47  16  58  17 182 189  28  42 223 183 170 213 119 248 152   2  44 154 163  70\n 221 153 101 155 167  43 172   9 129  22  39 253  19  98 108 110  79 113 224 232 178\n 185 112 104 218 246  97 228 251  34 242 193 238 210 144  12 191 179 162 241  81  51\n 145 235 249  14 239 107  49 192 214  31 181 199 106 157 184  84 204 176 115 121  50\n  45 127   4 150 254 138 236 205  93 222 114  67  29  24  72 243 141 128 195  78  66\n 215  61 156 180};\nuse constant p => permutation, permutation;\n\nsub floor ($x) { my $xi = int($x); return $x < $xi ? $xi - 1 : $xi }\n\nsub fade ($t) { $t**3 * ($t * ($t * 6 - 15) + 10) }\n\nsub lerp ($t, $a, $b) { $a + $t * ($b - $a) }\n\nsub grad ($h, $x, $y, $z) {\n    $h &= 15;\n    my $u = $h < 8 ? $x : $y;\n    my $v = $h < 4 ? $y : ($h == 12 or $h == 14) ? $x : $z;\n    (($h & 1) == 0 ? $u : -$u) + (($h & 2) == 0 ? $v : -$v);\n}\n\nsub noise ($x, $y, $z) {\n    my ($X, $Y, $Z) = map { 255 & floor $_ } $x,       $y,       $z;\n    my ($u, $v, $w) = map {        fade $_ } $x -= $X, $y -= $Y, $z -= $Z;\n    my $A = (p)[$X] + $Y;\n    my ($AA, $AB) = ( (p)[$A] + $Z, (p)[$A + 1] + $Z );\n    my $B = (p)[$X + 1] + $Y;\n    my ($BA, $BB) = ( (p)[$B] + $Z, (p)[$B + 1] + $Z );   \n    lerp($w, lerp($v, lerp($u, grad((p)[$AA    ], $x    , $y    , $z     ),\n                               grad((p)[$BA    ], $x - 1, $y    , $z     )),\n                      lerp($u, grad((p)[$AB    ], $x    , $y - 1, $z     ),\n                               grad((p)[$BB    ], $x - 1, $y - 1, $z     ))),\n             lerp($v, lerp($u, grad((p)[$AA + 1], $x    , $y    , $z - 1 ),\n                               grad((p)[$BA + 1], $x - 1, $y    , $z - 1 )),\n                      lerp($u, grad((p)[$AB + 1], $x    , $y - 1, $z - 1 ),\n                               grad((p)[$BB + 1], $x - 1, $y - 1, $z - 1 ))));\n}\n\nprint noise 3.14, 42, 7;\n", "target": "import math\n\ndef perlin_noise(x, y, z):\n    X = math.floor(x) & 255                  \n    Y = math.floor(y) & 255                  \n    Z = math.floor(z) & 255\n    x -= math.floor(x)                                \n    y -= math.floor(y)                                \n    z -= math.floor(z)\n    u = fade(x)                                \n    v = fade(y)                                \n    w = fade(z)\n    A = p[X  ]+Y; AA = p[A]+Z; AB = p[A+1]+Z      \n    B = p[X+1]+Y; BA = p[B]+Z; BB = p[B+1]+Z      \n \n    return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                   grad(p[BA  ], x-1, y  , z   )), \n                           lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                   grad(p[BB  ], x-1, y-1, z   ))),\n                   lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                   grad(p[BA+1], x-1, y  , z-1 )), \n                           lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                   grad(p[BB+1], x-1, y-1, z-1 ))))\n                                   \ndef fade(t): \n    return t ** 3 * (t * (t * 6 - 15) + 10)\n    \ndef lerp(t, a, b):\n    return a + t * (b - a)\n    \ndef grad(hash, x, y, z):\n    h = hash & 15                      \n    u = x if h<8 else y                \n    v = y if h<4 else (x if h in (12, 14) else z)\n    return (u if (h&1) == 0 else -u) + (v if (h&2) == 0 else -v)\n\np = [None] * 512\npermutation = [151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]\nfor i in range(256):\n    p[256+i] = p[i] = permutation[i]\n\nif __name__ == '__main__':\n    print(\"%1.17f\" % perlin_noise(3.14, 42, 7))\n"}
{"id": 383417, "name": "Sine wave", "source": "Translate Perl to Python: use Audio::NoiseGen qw(play sine);\n\nAudio::NoiseGen::init() || die 'No access to sound hardware?';\n\nalarm 5;\nplay( gen => sine( freq => 440 ) );\n", "target": "\n\nimport os\nfrom math import pi, sin\n\n\nau_header = bytearray(\n            [46, 115, 110, 100,   \n              0,   0,   0,  24,   \n            255, 255, 255, 255,   \n              0,   0,   0,   3,   \n              0,   0, 172,  68,   \n              0,   0,   0,   1])  \n\ndef f(x, freq):\n    \"Compute sine wave as 16-bit integer\"\n    return round(32000 * sin(2 * pi * freq * x / 44100)) % 65536\n\ndef play_sine(freq=440, duration=5, oname=\"pysine.au\"):\n    \"Play a sine wave for `duration` seconds\"\n    out = open(oname, 'wb')\n    out.write(au_header)\n    v = [f(x, freq) for x in range(duration * 44100 + 1)]\n    s = []\n    for i in v:\n        s.append(i >> 8)\n        s.append(i % 256)\n    out.write(bytearray(s))\n    out.close()\n    os.system(\"vlc \" + oname)   \n\nplay_sine()\n"}
{"id": 383418, "name": "A_ search algorithm", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( nsort_by );\n\nsub distance\n  {\n  my ($r1, $c1, $r2, $c2) = split /[, ]/, \"@_\";\n  sqrt( ($r1-$r2)**2 + ($c1-$c2)**2 );\n  }\n\nmy $start = '0,0';\nmy $finish = '7,7';\nmy %barrier = map {$_, 100}\n  split ' ', '2,4 2,5 2,6 3,6 4,6 5,6 5,5 5,4 5,3 5,2 4,2 3,2';\nmy %values = ( $start, 0 );\nmy @new = [ $start, 0 ];\nmy %from;\nmy $mid;\nwhile( ! exists $values{$finish} and @new )\n  {\n  my $pick = (shift @new)->[0];\n  for my $n ( nsort_by { distance($_, $finish) } \n    grep !/-|8/ && ! exists $values{$_},\n    glob $pick =~ s/\\d+/{@{[$&-1]},$&,@{[$&+1]}}/gr\n    )\n    {\n    $from{$n} = $pick;\n    $values{$n} = $values{$pick} + ( $barrier{$n} // 1 );\n    my $new = [ $n, my $dist = $values{$n} ];\n    my $low = 0; \n    my $high = @new;\n    $new[$mid = $low + $high >> 1][1] <= $dist\n      ? ($low = $mid + 1) : ($high = $mid) while $low < $high;\n    splice @new, $low, 0, $new; \n    }\n  }\n\nmy $grid = \"s.......\\n\" . ('.' x 8 . \"\\n\") x 7;\nsubstr $grid, /,/ * $` * 9 + $', 1, 'b' for keys %barrier;\nmy @path = my $pos = $finish; \nwhile( $pos ne $start )\n  {\n  substr $grid, $pos =~ /,/ ? $` * 9 + $' : die, 1, 'x';\n  unshift @path, $pos = $from{$pos};\n  }\nprint \"$grid\\nvalue $values{$finish}  path @path\\n\";\n", "target": "from __future__ import print_function\nimport matplotlib.pyplot as plt\n\nclass AStarGraph(object):\n\t\n\n\tdef __init__(self):\n\t\tself.barriers = []\n\t\tself.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\n\n\tdef heuristic(self, start, goal):\n\t\t\n\t\t\n\t\tD = 1\n\t\tD2 = 1\n\t\tdx = abs(start[0] - goal[0])\n\t\tdy = abs(start[1] - goal[1])\n\t\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\n\tdef get_vertex_neighbours(self, pos):\n\t\tn = []\n\t\t\n\t\tfor dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\n\t\t\tx2 = pos[0] + dx\n\t\t\ty2 = pos[1] + dy\n\t\t\tif x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\n\t\t\t\tcontinue\n\t\t\tn.append((x2, y2))\n\t\treturn n\n\n\tdef move_cost(self, a, b):\n\t\tfor barrier in self.barriers:\n\t\t\tif b in barrier:\n\t\t\t\treturn 100 \n\t\treturn 1 \n\ndef AStarSearch(start, end, graph):\n\n\tG = {} \n\tF = {} \n\n\t\n\tG[start] = 0\n\tF[start] = graph.heuristic(start, end)\n\n\tclosedVertices = set()\n\topenVertices = set([start])\n\tcameFrom = {}\n\n\twhile len(openVertices) > 0:\n\t\t\n\t\tcurrent = None\n\t\tcurrentFscore = None\n\t\tfor pos in openVertices:\n\t\t\tif current is None or F[pos] < currentFscore:\n\t\t\t\tcurrentFscore = F[pos]\n\t\t\t\tcurrent = pos\n\n\t\t\n\t\tif current == end:\n\t\t\t\n\t\t\tpath = [current]\n\t\t\twhile current in cameFrom:\n\t\t\t\tcurrent = cameFrom[current]\n\t\t\t\tpath.append(current)\n\t\t\tpath.reverse()\n\t\t\treturn path, F[end] \n\n\t\t\n\t\topenVertices.remove(current)\n\t\tclosedVertices.add(current)\n\n\t\t\n\t\tfor neighbour in graph.get_vertex_neighbours(current):\n\t\t\tif neighbour in closedVertices:\n\t\t\t\tcontinue \n\t\t\tcandidateG = G[current] + graph.move_cost(current, neighbour)\n\n\t\t\tif neighbour not in openVertices:\n\t\t\t\topenVertices.add(neighbour) \n\t\t\telif candidateG >= G[neighbour]:\n\t\t\t\tcontinue \n\n\t\t\t\n\t\t\tcameFrom[neighbour] = current\n\t\t\tG[neighbour] = candidateG\n\t\t\tH = graph.heuristic(neighbour, end)\n\t\t\tF[neighbour] = G[neighbour] + H\n\n\traise RuntimeError(\"A* failed to find a solution\")\n\nif __name__==\"__main__\":\n\tgraph = AStarGraph()\n\tresult, cost = AStarSearch((0,0), (7,7), graph)\n\tprint (\"route\", result)\n\tprint (\"cost\", cost)\n\tplt.plot([v[0] for v in result], [v[1] for v in result])\n\tfor barrier in graph.barriers:\n\t\tplt.plot([v[0] for v in barrier], [v[1] for v in barrier])\n\tplt.xlim(-1,8)\n\tplt.ylim(-1,8)\n\tplt.show()\n"}
{"id": 383419, "name": "A_ search algorithm", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( nsort_by );\n\nsub distance\n  {\n  my ($r1, $c1, $r2, $c2) = split /[, ]/, \"@_\";\n  sqrt( ($r1-$r2)**2 + ($c1-$c2)**2 );\n  }\n\nmy $start = '0,0';\nmy $finish = '7,7';\nmy %barrier = map {$_, 100}\n  split ' ', '2,4 2,5 2,6 3,6 4,6 5,6 5,5 5,4 5,3 5,2 4,2 3,2';\nmy %values = ( $start, 0 );\nmy @new = [ $start, 0 ];\nmy %from;\nmy $mid;\nwhile( ! exists $values{$finish} and @new )\n  {\n  my $pick = (shift @new)->[0];\n  for my $n ( nsort_by { distance($_, $finish) } \n    grep !/-|8/ && ! exists $values{$_},\n    glob $pick =~ s/\\d+/{@{[$&-1]},$&,@{[$&+1]}}/gr\n    )\n    {\n    $from{$n} = $pick;\n    $values{$n} = $values{$pick} + ( $barrier{$n} // 1 );\n    my $new = [ $n, my $dist = $values{$n} ];\n    my $low = 0; \n    my $high = @new;\n    $new[$mid = $low + $high >> 1][1] <= $dist\n      ? ($low = $mid + 1) : ($high = $mid) while $low < $high;\n    splice @new, $low, 0, $new; \n    }\n  }\n\nmy $grid = \"s.......\\n\" . ('.' x 8 . \"\\n\") x 7;\nsubstr $grid, /,/ * $` * 9 + $', 1, 'b' for keys %barrier;\nmy @path = my $pos = $finish; \nwhile( $pos ne $start )\n  {\n  substr $grid, $pos =~ /,/ ? $` * 9 + $' : die, 1, 'x';\n  unshift @path, $pos = $from{$pos};\n  }\nprint \"$grid\\nvalue $values{$finish}  path @path\\n\";\n", "target": "from __future__ import print_function\nimport matplotlib.pyplot as plt\n\nclass AStarGraph(object):\n\t\n\n\tdef __init__(self):\n\t\tself.barriers = []\n\t\tself.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\n\n\tdef heuristic(self, start, goal):\n\t\t\n\t\t\n\t\tD = 1\n\t\tD2 = 1\n\t\tdx = abs(start[0] - goal[0])\n\t\tdy = abs(start[1] - goal[1])\n\t\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\n\tdef get_vertex_neighbours(self, pos):\n\t\tn = []\n\t\t\n\t\tfor dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\n\t\t\tx2 = pos[0] + dx\n\t\t\ty2 = pos[1] + dy\n\t\t\tif x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\n\t\t\t\tcontinue\n\t\t\tn.append((x2, y2))\n\t\treturn n\n\n\tdef move_cost(self, a, b):\n\t\tfor barrier in self.barriers:\n\t\t\tif b in barrier:\n\t\t\t\treturn 100 \n\t\treturn 1 \n\ndef AStarSearch(start, end, graph):\n\n\tG = {} \n\tF = {} \n\n\t\n\tG[start] = 0\n\tF[start] = graph.heuristic(start, end)\n\n\tclosedVertices = set()\n\topenVertices = set([start])\n\tcameFrom = {}\n\n\twhile len(openVertices) > 0:\n\t\t\n\t\tcurrent = None\n\t\tcurrentFscore = None\n\t\tfor pos in openVertices:\n\t\t\tif current is None or F[pos] < currentFscore:\n\t\t\t\tcurrentFscore = F[pos]\n\t\t\t\tcurrent = pos\n\n\t\t\n\t\tif current == end:\n\t\t\t\n\t\t\tpath = [current]\n\t\t\twhile current in cameFrom:\n\t\t\t\tcurrent = cameFrom[current]\n\t\t\t\tpath.append(current)\n\t\t\tpath.reverse()\n\t\t\treturn path, F[end] \n\n\t\t\n\t\topenVertices.remove(current)\n\t\tclosedVertices.add(current)\n\n\t\t\n\t\tfor neighbour in graph.get_vertex_neighbours(current):\n\t\t\tif neighbour in closedVertices:\n\t\t\t\tcontinue \n\t\t\tcandidateG = G[current] + graph.move_cost(current, neighbour)\n\n\t\t\tif neighbour not in openVertices:\n\t\t\t\topenVertices.add(neighbour) \n\t\t\telif candidateG >= G[neighbour]:\n\t\t\t\tcontinue \n\n\t\t\t\n\t\t\tcameFrom[neighbour] = current\n\t\t\tG[neighbour] = candidateG\n\t\t\tH = graph.heuristic(neighbour, end)\n\t\t\tF[neighbour] = G[neighbour] + H\n\n\traise RuntimeError(\"A* failed to find a solution\")\n\nif __name__==\"__main__\":\n\tgraph = AStarGraph()\n\tresult, cost = AStarSearch((0,0), (7,7), graph)\n\tprint (\"route\", result)\n\tprint (\"cost\", cost)\n\tplt.plot([v[0] for v in result], [v[1] for v in result])\n\tfor barrier in graph.barriers:\n\t\tplt.plot([v[0] for v in barrier], [v[1] for v in barrier])\n\tplt.xlim(-1,8)\n\tplt.ylim(-1,8)\n\tplt.show()\n"}
{"id": 383420, "name": "Nonogram solver", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $file = 'nonogram_problems.txt';\nopen my $fd, '<', $file or die \"$! opening $file\";\n\nwhile(my $row = <$fd> )\n  {\n  $row =~ /\\S/ or next;\n  my $column = <$fd>;\n  my @rpats = makepatterns($row);\n  my @cpats = makepatterns($column);\n  my @rows = ( '.' x @cpats ) x @rpats;\n  for( my $prev = ''; $prev ne \"@rows\"; )\n    {\n    $prev = \"@rows\";\n    try(\\@rows, \\@rpats);\n    my @cols = map { join '', map { s/.//; $& } @rows } 0..$\n    try(\\@cols, \\@cpats);\n    @rows = map { join '', map { s/.//; $& } @cols } 0..$\n    }\n  print \"\\n\", \"@rows\" =~ /\\./ ? \"Failed\\n\" : map { tr/01/.\n  }\n\nsub try\n  {\n  my ($lines, $patterns) = @_;\n  for my $i ( 0 .. $\n    {\n    while( $lines->[$i] =~ /\\./g )\n      {\n      for my $try ( 0, 1 )\n        {\n        $lines->[$i] =~ s/.\\G/$try/r =~ $patterns->[$i] or\n          $lines->[$i] =~ s// 1 - $try /e;\n        }\n      }\n    }\n  }\n\nsub makepatterns {                         \n    map { qr/^$_$/                          \n        } map {  '[0.]*'                    \n               . join('[0.]+',              \n                       map { \"[1.]{$_}\"     \n                           } map { -64+ord  \n                                 } split // \n                     )\n               . '[0.]*'                    \n              } split ' ', shift;           \n}\n", "target": "from itertools import izip\n\ndef gen_row(w, s):\n    \n    def gen_seg(o, sp):\n        if not o:\n            return [[2] * sp]\n        return [[2] * x + o[0] + tail\n                for x in xrange(1, sp - len(o) + 2)\n                for tail in gen_seg(o[1:], sp - x)]\n\n    return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]\n\n\ndef deduce(hr, vr):\n    \n    def allowable(row):\n        return reduce(lambda a, b: [x | y for x, y in izip(a, b)], row)\n\n    def fits(a, b):\n        return all(x & y for x, y in izip(a, b))\n\n    def fix_col(n):\n        \n        c = [x[n] for x in can_do]\n        cols[n] = [x for x in cols[n] if fits(x, c)]\n        for i, x in enumerate(allowable(cols[n])):\n            if x != can_do[i][n]:\n                mod_rows.add(i)\n                can_do[i][n] &= x\n\n    def fix_row(n):\n        \n        c = can_do[n]\n        rows[n] = [x for x in rows[n] if fits(x, c)]\n        for i, x in enumerate(allowable(rows[n])):\n            if x != can_do[n][i]:\n                mod_cols.add(i)\n                can_do[n][i] &= x\n\n    def show_gram(m):\n        \n        \n        for x in m:\n            print \" \".join(\"x\n        print\n\n    w, h = len(vr), len(hr)\n    rows = [gen_row(w, x) for x in hr]\n    cols = [gen_row(h, x) for x in vr]\n    can_do = map(allowable, rows)\n\n    \n    mod_rows, mod_cols = set(), set(xrange(w))\n\n    while mod_cols:\n        for i in mod_cols:\n            fix_col(i)\n        mod_cols = set()\n        for i in mod_rows:\n            fix_row(i)\n        mod_rows = set()\n\n    if all(can_do[i][j] in (1, 2) for j in xrange(w) for i in xrange(h)):\n        print \"Solution would be unique\" \n    else:\n        print \"Solution may not be unique, doing exhaustive search:\"\n\n    \n    \n    \n    out = [0] * h\n\n    def try_all(n = 0):\n        if n >= h:\n            for j in xrange(w):\n                if [x[j] for x in out] not in cols[j]:\n                    return 0\n            show_gram(out)\n            return 1\n        sol = 0\n        for x in rows[n]:\n            out[n] = x\n            sol += try_all(n + 1)\n        return sol\n\n    n = try_all()\n    if not n:\n        print \"No solution.\"\n    elif n == 1:\n        print \"Unique solution.\"\n    else:\n        print n, \"solutions.\"\n    print\n\n\ndef solve(p, show_runs=True):\n    s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]\n         for l in p.splitlines()]\n    if show_runs:\n        print \"Horizontal runs:\", s[0]\n        print \"Vertical runs:\", s[1]\n    deduce(s[0], s[1])\n\n\ndef main():\n    \n    fn = \"nonogram_problems.txt\"\n    for p in (x for x in open(fn).read().split(\"\\n\\n\") if x):\n        solve(p)\n\n    print \"Extra example not solvable by deduction alone:\"\n    solve(\"B B A A\\nB B A A\")\n\n    print \"Extra example where there is no solution:\"\n    solve(\"B A A\\nA A A\")\n\nmain()\n"}
{"id": 383421, "name": "Nonogram solver", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $file = 'nonogram_problems.txt';\nopen my $fd, '<', $file or die \"$! opening $file\";\n\nwhile(my $row = <$fd> )\n  {\n  $row =~ /\\S/ or next;\n  my $column = <$fd>;\n  my @rpats = makepatterns($row);\n  my @cpats = makepatterns($column);\n  my @rows = ( '.' x @cpats ) x @rpats;\n  for( my $prev = ''; $prev ne \"@rows\"; )\n    {\n    $prev = \"@rows\";\n    try(\\@rows, \\@rpats);\n    my @cols = map { join '', map { s/.//; $& } @rows } 0..$\n    try(\\@cols, \\@cpats);\n    @rows = map { join '', map { s/.//; $& } @cols } 0..$\n    }\n  print \"\\n\", \"@rows\" =~ /\\./ ? \"Failed\\n\" : map { tr/01/.\n  }\n\nsub try\n  {\n  my ($lines, $patterns) = @_;\n  for my $i ( 0 .. $\n    {\n    while( $lines->[$i] =~ /\\./g )\n      {\n      for my $try ( 0, 1 )\n        {\n        $lines->[$i] =~ s/.\\G/$try/r =~ $patterns->[$i] or\n          $lines->[$i] =~ s// 1 - $try /e;\n        }\n      }\n    }\n  }\n\nsub makepatterns {                         \n    map { qr/^$_$/                          \n        } map {  '[0.]*'                    \n               . join('[0.]+',              \n                       map { \"[1.]{$_}\"     \n                           } map { -64+ord  \n                                 } split // \n                     )\n               . '[0.]*'                    \n              } split ' ', shift;           \n}\n", "target": "from itertools import izip\n\ndef gen_row(w, s):\n    \n    def gen_seg(o, sp):\n        if not o:\n            return [[2] * sp]\n        return [[2] * x + o[0] + tail\n                for x in xrange(1, sp - len(o) + 2)\n                for tail in gen_seg(o[1:], sp - x)]\n\n    return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]\n\n\ndef deduce(hr, vr):\n    \n    def allowable(row):\n        return reduce(lambda a, b: [x | y for x, y in izip(a, b)], row)\n\n    def fits(a, b):\n        return all(x & y for x, y in izip(a, b))\n\n    def fix_col(n):\n        \n        c = [x[n] for x in can_do]\n        cols[n] = [x for x in cols[n] if fits(x, c)]\n        for i, x in enumerate(allowable(cols[n])):\n            if x != can_do[i][n]:\n                mod_rows.add(i)\n                can_do[i][n] &= x\n\n    def fix_row(n):\n        \n        c = can_do[n]\n        rows[n] = [x for x in rows[n] if fits(x, c)]\n        for i, x in enumerate(allowable(rows[n])):\n            if x != can_do[n][i]:\n                mod_cols.add(i)\n                can_do[n][i] &= x\n\n    def show_gram(m):\n        \n        \n        for x in m:\n            print \" \".join(\"x\n        print\n\n    w, h = len(vr), len(hr)\n    rows = [gen_row(w, x) for x in hr]\n    cols = [gen_row(h, x) for x in vr]\n    can_do = map(allowable, rows)\n\n    \n    mod_rows, mod_cols = set(), set(xrange(w))\n\n    while mod_cols:\n        for i in mod_cols:\n            fix_col(i)\n        mod_cols = set()\n        for i in mod_rows:\n            fix_row(i)\n        mod_rows = set()\n\n    if all(can_do[i][j] in (1, 2) for j in xrange(w) for i in xrange(h)):\n        print \"Solution would be unique\" \n    else:\n        print \"Solution may not be unique, doing exhaustive search:\"\n\n    \n    \n    \n    out = [0] * h\n\n    def try_all(n = 0):\n        if n >= h:\n            for j in xrange(w):\n                if [x[j] for x in out] not in cols[j]:\n                    return 0\n            show_gram(out)\n            return 1\n        sol = 0\n        for x in rows[n]:\n            out[n] = x\n            sol += try_all(n + 1)\n        return sol\n\n    n = try_all()\n    if not n:\n        print \"No solution.\"\n    elif n == 1:\n        print \"Unique solution.\"\n    else:\n        print n, \"solutions.\"\n    print\n\n\ndef solve(p, show_runs=True):\n    s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]\n         for l in p.splitlines()]\n    if show_runs:\n        print \"Horizontal runs:\", s[0]\n        print \"Vertical runs:\", s[1]\n    deduce(s[0], s[1])\n\n\ndef main():\n    \n    fn = \"nonogram_problems.txt\"\n    for p in (x for x in open(fn).read().split(\"\\n\\n\") if x):\n        solve(p)\n\n    print \"Extra example not solvable by deduction alone:\"\n    solve(\"B B A A\\nB B A A\")\n\n    print \"Extra example where there is no solution:\"\n    solve(\"B A A\\nA A A\")\n\nmain()\n"}
{"id": 383422, "name": "Almkvist-Giullera formula for pi", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature qw(say);\nuse Math::AnyNum qw(:overload factorial);\n\nsub almkvist_giullera_integral {\n    my($n) = @_;\n    (32 * (14*$n * (38*$n + 9) + 9) * factorial(6*$n)) / (3*factorial($n)**6);\n}\n\nsub almkvist_giullera {\n    my($n) = @_;\n    almkvist_giullera_integral($n) / (10**(6*$n + 3));\n}\n\nsub almkvist_giullera_pi {\n    my ($prec) = @_;\n\n    local $Math::AnyNum::PREC = 4*($prec+1);\n\n    my $sum = 0;\n    my $target = '';\n\n    for (my $n = 0; ; ++$n) {\n        $sum += almkvist_giullera($n);\n        my $curr = ($sum**-.5)->as_dec;\n        return $target if ($curr eq $target);\n        $target = $curr;\n    }\n}\n\nsay 'First 10 integer portions: ';\nsay \"$_  \" . almkvist_giullera_integral($_) for 0..9;\n\nmy $precision = 70;\n\nprintf(\"\u03c0 to %s decimal places is:\\n%s\\n\",\n    $precision, almkvist_giullera_pi($precision));\n", "target": "import mpmath as mp\n\nwith mp.workdps(72):\n\n    def integer_term(n):\n        p = 532 * n * n + 126 * n + 9\n        return (p * 2**5 * mp.factorial(6 * n)) / (3 * mp.factorial(n)**6)\n\n    def exponent_term(n):\n        return -(mp.mpf(\"6.0\") * n + 3)\n\n    def nthterm(n):\n        return integer_term(n) * mp.mpf(\"10.0\")**exponent_term(n)\n\n\n    for n in range(10):\n        print(\"Term \", n, '  ', int(integer_term(n)))\n\n\n    def almkvist_guillera(floatprecision):\n        summed, nextadd = mp.mpf('0.0'), mp.mpf('0.0')\n        for n in range(100000000):\n            nextadd = summed + nthterm(n)\n            if abs(nextadd - summed) < 10.0**(-floatprecision):\n                break\n\n            summed = nextadd\n\n        return nextadd\n\n\n    print('\\n\u03c0 to 70 digits is ', end='')\n    mp.nprint(mp.mpf(1.0 / mp.sqrt(almkvist_guillera(70))), 71)\n    print('mpmath \u03c0 is       ', end='')\n    mp.nprint(mp.pi, 71)\n"}
{"id": 383423, "name": "Almkvist-Giullera formula for pi", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature qw(say);\nuse Math::AnyNum qw(:overload factorial);\n\nsub almkvist_giullera_integral {\n    my($n) = @_;\n    (32 * (14*$n * (38*$n + 9) + 9) * factorial(6*$n)) / (3*factorial($n)**6);\n}\n\nsub almkvist_giullera {\n    my($n) = @_;\n    almkvist_giullera_integral($n) / (10**(6*$n + 3));\n}\n\nsub almkvist_giullera_pi {\n    my ($prec) = @_;\n\n    local $Math::AnyNum::PREC = 4*($prec+1);\n\n    my $sum = 0;\n    my $target = '';\n\n    for (my $n = 0; ; ++$n) {\n        $sum += almkvist_giullera($n);\n        my $curr = ($sum**-.5)->as_dec;\n        return $target if ($curr eq $target);\n        $target = $curr;\n    }\n}\n\nsay 'First 10 integer portions: ';\nsay \"$_  \" . almkvist_giullera_integral($_) for 0..9;\n\nmy $precision = 70;\n\nprintf(\"\u03c0 to %s decimal places is:\\n%s\\n\",\n    $precision, almkvist_giullera_pi($precision));\n", "target": "import mpmath as mp\n\nwith mp.workdps(72):\n\n    def integer_term(n):\n        p = 532 * n * n + 126 * n + 9\n        return (p * 2**5 * mp.factorial(6 * n)) / (3 * mp.factorial(n)**6)\n\n    def exponent_term(n):\n        return -(mp.mpf(\"6.0\") * n + 3)\n\n    def nthterm(n):\n        return integer_term(n) * mp.mpf(\"10.0\")**exponent_term(n)\n\n\n    for n in range(10):\n        print(\"Term \", n, '  ', int(integer_term(n)))\n\n\n    def almkvist_guillera(floatprecision):\n        summed, nextadd = mp.mpf('0.0'), mp.mpf('0.0')\n        for n in range(100000000):\n            nextadd = summed + nthterm(n)\n            if abs(nextadd - summed) < 10.0**(-floatprecision):\n                break\n\n            summed = nextadd\n\n        return nextadd\n\n\n    print('\\n\u03c0 to 70 digits is ', end='')\n    mp.nprint(mp.mpf(1.0 / mp.sqrt(almkvist_guillera(70))), 71)\n    print('mpmath \u03c0 is       ', end='')\n    mp.nprint(mp.pi, 71)\n"}
{"id": 383424, "name": "Lychrel numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse English;\nuse Const::Fast;\nuse Math::AnyNum qw(:overload);\n\nconst my $n_max       => 10_000;\nconst my $iter_cutoff => 500;\nmy(@seq_dump, @seed_lychrels, @related_lychrels);\n\nfor (my $n=1; $n<=$n_max; $n++) {\n    my @seq = lychrel_sequence($n);\n    if ($iter_cutoff == scalar @seq) {\n        if (has_overlap(\\@seq, \\@seq_dump)) { push @related_lychrels, $n }\n        else                                { push @seed_lychrels,    $n }\n        @seq_dump = set_union(\\@seq_dump, \\@seq);\n    }\n}\n\nprintf \"%45s %s\\n\", \"Number of seed Lychrels <= $n_max:\",        scalar @seed_lychrels;\nprintf \"%45s %s\\n\", \"Seed Lychrels <= $n_max:\",              join ', ', @seed_lychrels;\nprintf \"%45s %s\\n\", \"Number of related Lychrels <= $n_max:\",     scalar @related_lychrels;\nprintf \"%45s %s\\n\", \"Palindromes among seed and related <= $n_max:\",      \n                    join ', ', sort {$a <=> $b} grep { is_palindrome($ARG) } @seed_lychrels, @related_lychrels;\n\nsub lychrel_sequence {\n    my $n = shift;\n    my @seq;\n    for (1 .. $iter_cutoff) {\n        return if is_palindrome($n = next_n($n));\n        push @seq, $n;\n    }\n    @seq;\n}\n\nsub next_n        { my $n = shift; $n  + reverse($n) }\nsub is_palindrome { my $n = shift; $n eq reverse($n) }\n\nsub has_overlap {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a};\n    exists $h{$_} and return 1 for @{$b};\n    0;\n}\n\nsub set_union {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a}, @{$b};\n    keys %h;\n}\n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 383425, "name": "Lychrel numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse English;\nuse Const::Fast;\nuse Math::AnyNum qw(:overload);\n\nconst my $n_max       => 10_000;\nconst my $iter_cutoff => 500;\nmy(@seq_dump, @seed_lychrels, @related_lychrels);\n\nfor (my $n=1; $n<=$n_max; $n++) {\n    my @seq = lychrel_sequence($n);\n    if ($iter_cutoff == scalar @seq) {\n        if (has_overlap(\\@seq, \\@seq_dump)) { push @related_lychrels, $n }\n        else                                { push @seed_lychrels,    $n }\n        @seq_dump = set_union(\\@seq_dump, \\@seq);\n    }\n}\n\nprintf \"%45s %s\\n\", \"Number of seed Lychrels <= $n_max:\",        scalar @seed_lychrels;\nprintf \"%45s %s\\n\", \"Seed Lychrels <= $n_max:\",              join ', ', @seed_lychrels;\nprintf \"%45s %s\\n\", \"Number of related Lychrels <= $n_max:\",     scalar @related_lychrels;\nprintf \"%45s %s\\n\", \"Palindromes among seed and related <= $n_max:\",      \n                    join ', ', sort {$a <=> $b} grep { is_palindrome($ARG) } @seed_lychrels, @related_lychrels;\n\nsub lychrel_sequence {\n    my $n = shift;\n    my @seq;\n    for (1 .. $iter_cutoff) {\n        return if is_palindrome($n = next_n($n));\n        push @seq, $n;\n    }\n    @seq;\n}\n\nsub next_n        { my $n = shift; $n  + reverse($n) }\nsub is_palindrome { my $n = shift; $n eq reverse($n) }\n\nsub has_overlap {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a};\n    exists $h{$_} and return 1 for @{$b};\n    0;\n}\n\nsub set_union {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a}, @{$b};\n    keys %h;\n}\n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 383426, "name": "Check Machin-like formulas", "source": "Translate Perl to Python: use Math::BigRat try=>\"GMP\";\n\nsub taneval {\n  my($coef,$f) = @_;\n  $f = Math::BigRat->new($f) unless ref($f);\n  return 0 if $coef == 0;\n  return $f if $coef == 1;\n  return -taneval(-$coef, $f) if $coef < 0;\n  my($a,$b) = ( taneval($coef>>1, $f), taneval($coef-($coef>>1),$f) );\n  ($a+$b)/(1-$a*$b);\n}\n\nsub tans {\n  my @xs=@_;\n  return taneval(@{$xs[0]}) if scalar(@xs)==1;\n  my($a,$b) = ( tans(@xs[0..($\n  ($a+$b)/(1-$a*$b);\n}\n\nsub test {\n  printf \"%5s (%s)\\n\", (tans(@_)==1)?\"OK\":\"Error\", join(\" \",map{\"[@$_]\"} @_);\n}\n\ntest([1,'1/2'], [1,'1/3']);\ntest([2,'1/3'], [1,'1/7']);\ntest([4,'1/5'], [-1,'1/239']);\ntest([5,'1/7'],[2,'3/79']);\ntest([5,'29/278'],[7,'3/79']);\ntest([1,'1/2'],[1,'1/5'],[1,'1/8']);\ntest([4,'1/5'],[-1,'1/70'],[1,'1/99']);\ntest([5,'1/7'],[4,'1/53'],[2,'1/4443']);\ntest([6,'1/8'],[2,'1/57'],[1,'1/239']);\ntest([8,'1/10'],[-1,'1/239'],[-4,'1/515']);\ntest([12,'1/18'],[8,'1/57'],[-5,'1/239']);\ntest([16,'1/21'],[3,'1/239'],[4,'3/1042']);\ntest([22,'1/28'],[2,'1/443'],[-5,'1/1393'],[-10,'1/11018']);\ntest([22,'1/38'],[17,'7/601'],[10,'7/8149']);\ntest([44,'1/57'],[7,'1/239'],[-12,'1/682'],[24,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12944']);\n", "target": "import re\nfrom fractions import Fraction\nfrom pprint import pprint as pp\n\n\nequationtext = \n\ndef parse_eqn(equationtext=equationtext):\n    eqn_re = re.compile(r)\n\n    found = eqn_re.findall(equationtext)\n    machins, part = [], []\n    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):\n        if lhs and part:\n            machins.append(part)\n            part = []\n        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),\n                       Fraction(int(numer), (int(denom) if denom else 1)) ) )\n    machins.append(part)\n    return machins\n\n\ndef tans(xs):\n    xslen = len(xs)\n    if xslen == 1:\n        return tanEval(*xs[0])\n    aa, bb = xs[:xslen//2], xs[xslen//2:]\n    a, b = tans(aa), tans(bb)\n    return (a + b) / (1 - a * b)\n\ndef tanEval(coef, f):\n    if coef == 1:\n        return f\n    if coef < 0:\n        return -tanEval(-coef, f)\n    ca = coef // 2\n    cb = coef - ca\n    a, b = tanEval(ca, f), tanEval(cb, f)\n    return (a + b) / (1 - a * b)\n\n\nif __name__ == '__main__':\n    machins = parse_eqn()\n    \n    for machin, eqn in zip(machins, equationtext.split('\\n')):\n        ans = tans(machin)\n        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))\n"}
{"id": 383427, "name": "Check Machin-like formulas", "source": "Translate Perl to Python: use Math::BigRat try=>\"GMP\";\n\nsub taneval {\n  my($coef,$f) = @_;\n  $f = Math::BigRat->new($f) unless ref($f);\n  return 0 if $coef == 0;\n  return $f if $coef == 1;\n  return -taneval(-$coef, $f) if $coef < 0;\n  my($a,$b) = ( taneval($coef>>1, $f), taneval($coef-($coef>>1),$f) );\n  ($a+$b)/(1-$a*$b);\n}\n\nsub tans {\n  my @xs=@_;\n  return taneval(@{$xs[0]}) if scalar(@xs)==1;\n  my($a,$b) = ( tans(@xs[0..($\n  ($a+$b)/(1-$a*$b);\n}\n\nsub test {\n  printf \"%5s (%s)\\n\", (tans(@_)==1)?\"OK\":\"Error\", join(\" \",map{\"[@$_]\"} @_);\n}\n\ntest([1,'1/2'], [1,'1/3']);\ntest([2,'1/3'], [1,'1/7']);\ntest([4,'1/5'], [-1,'1/239']);\ntest([5,'1/7'],[2,'3/79']);\ntest([5,'29/278'],[7,'3/79']);\ntest([1,'1/2'],[1,'1/5'],[1,'1/8']);\ntest([4,'1/5'],[-1,'1/70'],[1,'1/99']);\ntest([5,'1/7'],[4,'1/53'],[2,'1/4443']);\ntest([6,'1/8'],[2,'1/57'],[1,'1/239']);\ntest([8,'1/10'],[-1,'1/239'],[-4,'1/515']);\ntest([12,'1/18'],[8,'1/57'],[-5,'1/239']);\ntest([16,'1/21'],[3,'1/239'],[4,'3/1042']);\ntest([22,'1/28'],[2,'1/443'],[-5,'1/1393'],[-10,'1/11018']);\ntest([22,'1/38'],[17,'7/601'],[10,'7/8149']);\ntest([44,'1/57'],[7,'1/239'],[-12,'1/682'],[24,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12944']);\n", "target": "import re\nfrom fractions import Fraction\nfrom pprint import pprint as pp\n\n\nequationtext = \n\ndef parse_eqn(equationtext=equationtext):\n    eqn_re = re.compile(r)\n\n    found = eqn_re.findall(equationtext)\n    machins, part = [], []\n    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):\n        if lhs and part:\n            machins.append(part)\n            part = []\n        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),\n                       Fraction(int(numer), (int(denom) if denom else 1)) ) )\n    machins.append(part)\n    return machins\n\n\ndef tans(xs):\n    xslen = len(xs)\n    if xslen == 1:\n        return tanEval(*xs[0])\n    aa, bb = xs[:xslen//2], xs[xslen//2:]\n    a, b = tans(aa), tans(bb)\n    return (a + b) / (1 - a * b)\n\ndef tanEval(coef, f):\n    if coef == 1:\n        return f\n    if coef < 0:\n        return -tanEval(-coef, f)\n    ca = coef // 2\n    cb = coef - ca\n    a, b = tanEval(ca, f), tanEval(cb, f)\n    return (a + b) / (1 - a * b)\n\n\nif __name__ == '__main__':\n    machins = parse_eqn()\n    \n    for machin, eqn in zip(machins, equationtext.split('\\n')):\n        ans = tans(machin)\n        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))\n"}
{"id": 383428, "name": "Find Chess960 starting position identifier", "source": "Translate Perl to Python: use v5.36;\nuse List::AllUtils 'indexes';\n\nsub sp_id ($setup) {\n    8 == length $setup                          or return 'Illegal position: should have exactly eight pieces';\n    1 == @{[ $setup =~ /$_/g ]}                 or return \"Illegal position: should have exactly one $_\"        for <K Q>;\n    2 == @{[ $setup =~ /$_/g ]}                 or return \"Illegal position: should have exactly two $_\\'s\"     for <B N R>;\n    $setup =~ m/R .* K .* R/x                   or return 'Illegal position: King not between rooks.';\n    index($setup,'B')%2 != rindex($setup,'B')%2 or return 'Illegal position: Bishops not on opposite colors.';\n\n    my @knights = indexes { 'N' eq $_ } split '', $setup =~ s/[QB]//gr;\n    my $knight  = indexes { join('', @knights) eq $_ } <01 02 03 04 12 13 14 23 24 34>; \n    my @bishops = indexes { 'B' eq $_ } split '', $setup;\n    my $dark    = int ((grep { $_ % 2 == 0 } @bishops)[0]) / 2;\n    my $light   = int ((grep { $_ % 2 == 1 } @bishops)[0]) / 2;\n    my $queen   = index(($setup =~ s/B//gr), 'Q');\n\n    int 4*(4*(6*$knight + $queen)+$dark)+$light;\n}\n\nsay \"$_ \" . sp_id($_) for <QNRBBNKR RNBQKBNR RQNBBKRN RNQBBKRN QNBRBNKR>;\n", "target": "\ndef validate_position(candidate: str):\n    assert (\n        len(candidate) == 8\n    ), f\"candidate position has invalide len = {len(candidate)}\"\n\n    valid_pieces = {\"R\": 2, \"N\": 2, \"B\": 2, \"Q\": 1, \"K\": 1}\n    assert {\n        piece for piece in candidate\n    } == valid_pieces.keys(), f\"candidate position contains invalid pieces\"\n    for piece_type in valid_pieces.keys():\n        assert (\n            candidate.count(piece_type) == valid_pieces[piece_type]\n        ), f\"piece type '{piece_type}' has invalid count\"\n\n    bishops_pos = [index for index, \n                   value in enumerate(candidate) if value == \"B\"]\n    assert (\n        bishops_pos[0] % 2 != bishops_pos[1] % 2\n    ), f\"candidate position has both bishops in the same color\"\n\n    assert [piece for piece in candidate if piece in \"RK\"] == [\n        \"R\",\n        \"K\",\n        \"R\",\n    ], \"candidate position has K outside of RR\"\n\n\ndef calc_position(start_pos: str):\n    try:\n        validate_position(start_pos)\n    except AssertionError:\n        raise AssertionError\n    \n    subset_step1 = [piece for piece in start_pos if piece not in \"QB\"]\n    nights_positions = [\n        index for index, value in enumerate(subset_step1) if value == \"N\"\n    ]\n    nights_table = {\n        (0, 1): 0,\n        (0, 2): 1,\n        (0, 3): 2,\n        (0, 4): 3,\n        (1, 2): 4,\n        (1, 3): 5,\n        (1, 4): 6,\n        (2, 3): 7,\n        (2, 4): 8,\n        (3, 4): 9,\n    }\n    N = nights_table.get(tuple(nights_positions))\n\n    \n    subset_step2 = [piece for piece in start_pos if piece != \"B\"]\n    Q = subset_step2.index(\"Q\")\n\n    \n    dark_squares = [\n        piece for index, piece in enumerate(start_pos) if index in range(0, 9, 2)\n    ]\n    light_squares = [\n        piece for index, piece in enumerate(start_pos) if index in range(1, 9, 2)\n    ]\n    D = dark_squares.index(\"B\")\n    L = light_squares.index(\"B\")\n\n    return 4 * (4 * (6*N + Q) + D) + L\n\nif __name__ == '__main__':\n    for example in [\"QNRBBNKR\", \"RNBQKBNR\", \"RQNBBKRN\", \"RNQBBKRN\"]:\n        print(f'Position: {example}; Chess960 PID= {calc_position(example)}')\n"}
{"id": 383429, "name": "Names to numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nbinmode STDOUT, ':utf8';\n\nmy $phrases_with_numbers = <<'END';\nOne Hundred and One Dalmatians\nTwo Thousand and One: A Space Odyssey\n\nFour  Score  And  Seven  Years  Ago\ntwelve dozen is one hundred forty-four, aka one gross\ntwo hundred pairs of socks\nAlways give one hundred and ten percent effort\nChange due: zero dollars and thirty-seven cents\n\nOne hour, fifty-nine minutes, forty point two seconds\n\u03c0 \u2245 three point one four one five nine\nEND\n\nmy $pure_numbers = <<'END';\nTwenty Nineteen\nTwo Thousand Nineteen\nTwo Thousand Zero Hundred and Nineteen\nTwo Thousand Ten Nine\n\none thousand one\nninety nine thousand nine hundred ninety nine\nfive hundred and twelve thousand, six hundred and nine\ntwo billion, one hundred\n\nOne Thousand One Hundred Eleven\nEleven Hundred Eleven\none hundred eleven billion one hundred eleven\nEight Thousand Eight Hundred Eighty-Eight\nEighty-Eight Hundred Eighty-Eight\n\none quadrillion, two trillion, three billion, four million, five thousand six\nEND\n\nmy %nums = (\n    zero        => 0,   one       => 1,     two      => 2,    three    => 3,\n    four        => 4,   five      => 5,     six      => 6,    seven    => 7,\n    eight       => 8,   nine      => 9,     ten      => 10,   eleven   => 11,\n    twelve      => 12,  thirteen  => 13,    fourteen => 14,   fifteen  => 15,\n    sixteen     => 16,  seventeen => 17,    eighteen => 18,   nineteen => 19,\n    twenty      => 20,  thirty    => 30,    forty    => 40,   fifty    => 50,\n    sixty       => 60,  seventy   => 70,    eighty   => 80,   ninety   => 90,\n    hundred     => 100, thousand  => 1_000, million  => 1_000_000,\n    billion     => 1_000_000_000,           trillion => 1_000_000_000_000,\n    quadrillion => 1_000_000_000_000_000\n);\n\n\nmy $groups = qr/\\d{4}|\\d{7}|\\d{10}|\\d{13}|\\d{16}/;\n\nsub sum {\n    my($values) = @_;\n    my $sum = 0;\n    $sum += $_ for split ' ', $values;\n    $sum;\n}\n\nsub squeeze {\n    my($str) = @_;\n    $str =~ s/[\\-\\s]+/ /g;\n    $str =~ s/^\\s*(.*?)\\s*$/$1/r;\n}\n\n\nsub comma {\n    my($i) = @_;\n    return $i if length($i) < 5;\n    reverse ((reverse $i) =~ s/(.{3})/$1,/gr) =~ s/^,//r\n}\n\nsub numify {\n    my($str) = @_;\n\n    $str =~ tr/A-Z/a-z/;\n    $str = squeeze($str);\n\n    $str =~ s/(.)([[:punct:]])/$1 $2/g;\n\n    foreach my $key (keys %nums) { $str =~ s/ \\b $key \\b /$nums{$key}/gx }\n\n    $str =~ s/(\\d+) \\s+ (?=\\d)/$1/gx if $str =~ /point (\\d )+/;\n    $str =~ s/(\\d+) \\s+ score / $1 * 20 /egx;\n\n    $str =~ s/(\\d) (?:,|and) (\\d)/$1 $2/g;\n\n    $str =~ s/\\b (\\d) \\s+ 100 \\s+ (\\d\\d) \\s+ (\\d) \\s+    ($groups) \\b / ($1 * 100 + $2 + $3) * $4 /egx;\n    $str =~ s/\\b (\\d) \\s+ 100 \\s+ (\\d{1,2}) \\s+          ($groups) \\b / ($1 * 100 + $2) * $3      /egx;\n    $str =~ s/\\b (\\d) \\s+ 100 \\s+                        ($groups) \\b /  $1 * 100 * $2            /egx;\n    $str =~ s/\\b      \\s+ 100 \\s+ (\\d\\d) \\s+ (\\d) \\s+    ($groups) \\b / ($1 + 100 + $2) * $3      /egx;\n    $str =~ s/\\b      \\s+ 100 \\s+ (\\d{1,2}) \\s+          ($groups) \\b / ($1 + 100     ) * $2      /egx;\n    $str =~ s/\\b      \\s+ 100 \\s+                        ($groups) \\b /  $1 * 100                 /egx;\n    $str =~ s/\\b                  (\\d\\d) \\s+ (\\d) \\s+    ($groups) \\b / ($1 + $2) * $3            /egx;\n    $str =~ s/\\b                  (\\d{1,2}) \\s+          ($groups) \\b /  $1 * $2                  /egx;\n    $str =~ s/\\b                  (\\d\\d) \\s+ (\\d) \\s+ 100          \\b / ($1 + $2) * 100           /egx;\n    $str =~ s/\\b                  (\\d{1,2}) \\s+ 100                \\b /  $1 * 100                 /egx;\n    $str =~ s/\\b                  (\\d{2}) \\s+ (\\d{2})              \\b /  $1 * 100 + $2            /egx;\n\n    $str =~ s/((?:\\d+ )*\\d+)/sum $1/eg;\n\n    $str =~ s/(\\d+) \\s+ pairs.of        /   $1 *  2 /egx;\n    $str =~ s/(\\d+) \\s+ dozen           /   $1 * 12 /egx;\n    $str =~ s/(\\d+) \\s+ point \\s+ (\\d+) /   $1.$2   /gx;\n    $str =~ s/(\\d+) \\s+ percent         /   $1%     /gx;\n    $str =~ s/(\\d+) \\s+ dollars         / \\$$1      /gx;\n    $str =~ s/(\\d+) \\s+ cents           /   $1\u00a2     /gx;\n\n    squeeze $str;\n}\n\nsay $_ . ' --> ' .       numify($_) for grep { $_ } split \"\\n\", $phrases_with_numbers;\nsay $_ . ' --> ' . comma numify($_) for grep { $_ } split \"\\n\", $pure_numbers;\n", "target": "from spell_integer import spell_integer, SMALL, TENS, HUGE\n\ndef int_from_words(num):\n    words = num.replace(',','').replace(' and ', ' ').replace('-', ' ').split()\n    if words[0] == 'minus':\n        negmult = -1\n        words.pop(0)\n    else:\n        negmult = 1\n    small, total = 0, 0\n    for word in words:\n        if word in SMALL:\n            small += SMALL.index(word)\n        elif word in TENS:\n            small += TENS.index(word) * 10\n        elif word == 'hundred':\n            small *= 100\n        elif word == 'thousand':\n            total += small * 1000\n            small = 0\n        elif word in HUGE:\n            total += small * 1000 ** HUGE.index(word)\n            small = 0\n        else:\n            raise ValueError(\"Don't understand %r part of %r\" % (word, num))\n    return negmult * (total + small)\n\n\nif __name__ == '__main__':\n    \n    for n in range(-10000, 10000, 17):\n        assert n == int_from_words(spell_integer(n))\n\n    for n in range(20):\n        assert 13**n == int_from_words(spell_integer(13**n))\n    \n    print('\\n\n    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):\n        txt = spell_integer(n)\n        num = int_from_words(txt)\n        print('%+4i <%s> %s' % (n, '==' if n == num else '??', txt))\n    print('')  \n    \n    n = 201021002001\n    while n:\n        txt = spell_integer(n)\n        num = int_from_words(txt)\n        print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))\n        n //= -10\n    txt = spell_integer(n)\n    num = int_from_words(txt)\n    print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))\n    print('')\n"}
{"id": 383430, "name": "The ISAAC cipher", "source": "Translate Perl to Python: use warnings;\nuse strict;\nuse Math::Random::ISAAC;\n\nmy $message = \"a Top Secret secret\";\nmy $key = \"this is my secret key\";\n\nmy $enc = xor_isaac($key, $message);\nmy $dec = xor_isaac($key, join \"\", pack \"H*\", $enc);\n\nprint \"Message: $message\\n\";\nprint \"Key   \u00a0: $key\\n\";\nprint \"XOR   \u00a0: $enc\\n\";\nprint \"XOR dcr: \", join(\"\", pack \"H*\", $dec), \"\\n\";\n\nsub xor_isaac {\n  my($key, $msg) = @_;\n\n  \n  my $rng = Math::Random::ISAAC->new( map { ord } split \"\",$key );\n\n  \n  my @iranda = map { $_ % 95 + 32 }  \n               reverse               \n               map { $rng->irand }   \n               0..255;               \n  \n  join \"\", map { sprintf \"%02X\",$_ }         \n           map { ord($_) ^ shift(@iranda) }  \n           split \"\", $msg;                   \n}\n", "target": "import random\nimport collections\n\nINT_MASK = 0xFFFFFFFF       \n\nclass IsaacRandom(random.Random):\n    \n\n    def seed(self, seed=None):\n        \n        def mix():\n            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK\n            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK\n            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK\n            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK\n            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK\n            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK\n            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK\n            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK\n        \n        super().seed(0) \n        if seed is not None:\n            if isinstance(seed, str):\n                seed = [ord(x) for x in seed]\n            elif isinstance(seed, collections.Iterable):\n                seed = [x & INT_MASK for x in seed]\n            elif isinstance(seed, int):\n                val = abs(seed)\n                seed = []\n                while val:\n                    seed.append(val & INT_MASK)\n                    val >>= 32\n            else:\n                raise TypeError('Seed must be string, integer or iterable of integer')\n            \n            \n            if len(seed)>256:\n                del seed[256:]\n            elif len(seed)<256:\n                seed.extend([0]*(256-len(seed)))\n                \n        self.aa = self.bb = self.cc = 0\n        self.mm = []\n        init_state = [0x9e3779b9]*8\n        \n        for _ in range(4):\n            mix()\n        \n        for i in range(0, 256, 8):\n            if seed is not None:\n                for j in range(8):\n                    init_state[j] += seed[i+j]\n                    init_state[j] &= INT_MASK\n            mix()\n            self.mm += init_state\n                \n        if seed is not None:\n            for i in range(0, 256, 8):\n                for j in range(8):\n                    init_state[j] += self.mm[i+j]\n                    init_state[j] &= INT_MASK\n                mix()\n                for j in range(8):\n                    self.mm[i+j] = init_state[j]\n                \n        self.rand_count = 256\n        self.rand_result = [0]*256\n        \n    def getstate(self):\n        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result\n    \n    def setstate(self, state):\n        super().setstate(state[0])\n        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state \n        \n    def _generate(self):\n        \n        \n        self.cc = (self.cc + 1) & INT_MASK\n        self.bb = (self.bb + self.cc) & INT_MASK\n        \n        for i in range(256):\n            x = self.mm[i]\n            mod = i & 3\n            if mod==0:\n                self.aa ^= ((self.aa << 13) & INT_MASK)\n            elif mod==1:\n                self.aa ^= (self.aa >> 6)\n            elif mod==2:\n                self.aa ^= ((self.aa << 2) & INT_MASK)\n            else: \n                self.aa ^= (self.aa >> 16)\n            self.aa = (self.mm[i^128] + self.aa) & INT_MASK\n            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK\n            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK\n            \n        self.rand_count = 0\n        \n    def next_int(self):\n        \n        if self.rand_count == 256:\n            self._generate()\n        result = self.rand_result[self.rand_count]\n        self.rand_count += 1\n        return result\n        \n    def getrandbits(self, k):\n        \n        result = 0\n        ints_needed = (k+31)//32\n        ints_used = 0\n        while ints_used < ints_needed:\n            if self.rand_count == 256:\n                self._generate()\n            ints_to_take = min(256-self.rand_count, ints_needed)\n            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:\n                result = (result << 32) | val\n            self.rand_count += ints_to_take\n            ints_used += ints_to_take\n        result &= ((1<<k)-1)    \n        return result\n    \n    def random(self):\n        \n        \n        return self.getrandbits(53) * (2**-53)\n    \n    def rand_char(self):\n        \n        return self.next_int() % 95 + 32\n    \n    def vernam(self, msg):\n        \n        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)\n    \n    \n    ENCIPHER = 'encipher'\n    DECIPHER = 'decipher'\n    \n    @staticmethod\n    def _caesar(ciphermode, ch, shift, modulo, start):\n        if ciphermode == IsaacRandom.DECIPHER:\n            shift = -shift\n        n = ((ch-start)+shift) % modulo\n        if n<0:\n            n += modulo\n        return start+n\n    \n    def caesar(self, ciphermode, msg, modulo, start):\n        \n        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg)\n        \nif __name__=='__main__':\n    import binascii\n    \n    def hexify(b):\n        return binascii.hexlify(b).decode('ascii').upper()\n    \n    MOD = 95\n    START = 32\n    \n    msg = 'a Top Secret secret'\n    key = 'this is my secret key'\n    isaac_random = IsaacRandom(key)\n    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))\n    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)\n    isaac_random.seed(key)\n    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')\n    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')\n    \n    print('Message:', msg)\n    print('Key   \u00a0:', key)\n    print('XOR   \u00a0:', hexify(vernam_encoded))\n    print('XOR dcr:', vernam_decoded)\n    print('MOD   \u00a0:', hexify(caesar_encoded))\n    print('MOD dcr:', caesar_decoded)\n"}
{"id": 383431, "name": "The ISAAC cipher", "source": "Translate Perl to Python: use warnings;\nuse strict;\nuse Math::Random::ISAAC;\n\nmy $message = \"a Top Secret secret\";\nmy $key = \"this is my secret key\";\n\nmy $enc = xor_isaac($key, $message);\nmy $dec = xor_isaac($key, join \"\", pack \"H*\", $enc);\n\nprint \"Message: $message\\n\";\nprint \"Key   \u00a0: $key\\n\";\nprint \"XOR   \u00a0: $enc\\n\";\nprint \"XOR dcr: \", join(\"\", pack \"H*\", $dec), \"\\n\";\n\nsub xor_isaac {\n  my($key, $msg) = @_;\n\n  \n  my $rng = Math::Random::ISAAC->new( map { ord } split \"\",$key );\n\n  \n  my @iranda = map { $_ % 95 + 32 }  \n               reverse               \n               map { $rng->irand }   \n               0..255;               \n  \n  join \"\", map { sprintf \"%02X\",$_ }         \n           map { ord($_) ^ shift(@iranda) }  \n           split \"\", $msg;                   \n}\n", "target": "import random\nimport collections\n\nINT_MASK = 0xFFFFFFFF       \n\nclass IsaacRandom(random.Random):\n    \n\n    def seed(self, seed=None):\n        \n        def mix():\n            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK\n            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK\n            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK\n            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK\n            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK\n            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK\n            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK\n            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK\n        \n        super().seed(0) \n        if seed is not None:\n            if isinstance(seed, str):\n                seed = [ord(x) for x in seed]\n            elif isinstance(seed, collections.Iterable):\n                seed = [x & INT_MASK for x in seed]\n            elif isinstance(seed, int):\n                val = abs(seed)\n                seed = []\n                while val:\n                    seed.append(val & INT_MASK)\n                    val >>= 32\n            else:\n                raise TypeError('Seed must be string, integer or iterable of integer')\n            \n            \n            if len(seed)>256:\n                del seed[256:]\n            elif len(seed)<256:\n                seed.extend([0]*(256-len(seed)))\n                \n        self.aa = self.bb = self.cc = 0\n        self.mm = []\n        init_state = [0x9e3779b9]*8\n        \n        for _ in range(4):\n            mix()\n        \n        for i in range(0, 256, 8):\n            if seed is not None:\n                for j in range(8):\n                    init_state[j] += seed[i+j]\n                    init_state[j] &= INT_MASK\n            mix()\n            self.mm += init_state\n                \n        if seed is not None:\n            for i in range(0, 256, 8):\n                for j in range(8):\n                    init_state[j] += self.mm[i+j]\n                    init_state[j] &= INT_MASK\n                mix()\n                for j in range(8):\n                    self.mm[i+j] = init_state[j]\n                \n        self.rand_count = 256\n        self.rand_result = [0]*256\n        \n    def getstate(self):\n        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result\n    \n    def setstate(self, state):\n        super().setstate(state[0])\n        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state \n        \n    def _generate(self):\n        \n        \n        self.cc = (self.cc + 1) & INT_MASK\n        self.bb = (self.bb + self.cc) & INT_MASK\n        \n        for i in range(256):\n            x = self.mm[i]\n            mod = i & 3\n            if mod==0:\n                self.aa ^= ((self.aa << 13) & INT_MASK)\n            elif mod==1:\n                self.aa ^= (self.aa >> 6)\n            elif mod==2:\n                self.aa ^= ((self.aa << 2) & INT_MASK)\n            else: \n                self.aa ^= (self.aa >> 16)\n            self.aa = (self.mm[i^128] + self.aa) & INT_MASK\n            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK\n            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK\n            \n        self.rand_count = 0\n        \n    def next_int(self):\n        \n        if self.rand_count == 256:\n            self._generate()\n        result = self.rand_result[self.rand_count]\n        self.rand_count += 1\n        return result\n        \n    def getrandbits(self, k):\n        \n        result = 0\n        ints_needed = (k+31)//32\n        ints_used = 0\n        while ints_used < ints_needed:\n            if self.rand_count == 256:\n                self._generate()\n            ints_to_take = min(256-self.rand_count, ints_needed)\n            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:\n                result = (result << 32) | val\n            self.rand_count += ints_to_take\n            ints_used += ints_to_take\n        result &= ((1<<k)-1)    \n        return result\n    \n    def random(self):\n        \n        \n        return self.getrandbits(53) * (2**-53)\n    \n    def rand_char(self):\n        \n        return self.next_int() % 95 + 32\n    \n    def vernam(self, msg):\n        \n        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)\n    \n    \n    ENCIPHER = 'encipher'\n    DECIPHER = 'decipher'\n    \n    @staticmethod\n    def _caesar(ciphermode, ch, shift, modulo, start):\n        if ciphermode == IsaacRandom.DECIPHER:\n            shift = -shift\n        n = ((ch-start)+shift) % modulo\n        if n<0:\n            n += modulo\n        return start+n\n    \n    def caesar(self, ciphermode, msg, modulo, start):\n        \n        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg)\n        \nif __name__=='__main__':\n    import binascii\n    \n    def hexify(b):\n        return binascii.hexlify(b).decode('ascii').upper()\n    \n    MOD = 95\n    START = 32\n    \n    msg = 'a Top Secret secret'\n    key = 'this is my secret key'\n    isaac_random = IsaacRandom(key)\n    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))\n    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)\n    isaac_random.seed(key)\n    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')\n    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')\n    \n    print('Message:', msg)\n    print('Key   \u00a0:', key)\n    print('XOR   \u00a0:', hexify(vernam_encoded))\n    print('XOR dcr:', vernam_decoded)\n    print('MOD   \u00a0:', hexify(caesar_encoded))\n    print('MOD dcr:', caesar_decoded)\n"}
{"id": 383432, "name": "Permutations_Rank of a permutation", "source": "Translate Perl to Python: use ntheory qw/:all/;\n\nmy $n = 3;\nprint \"    Iterate Lexicographic rank/unrank of $n objects\\n\";\nfor my $k (0 .. factorial($n)-1) {\n  my @perm = numtoperm($n, $k);\n  my $rank = permtonum(\\@perm);\n  die unless $rank == $k;\n  printf \"%2d --> [@perm] --> %2d\\n\", $k, $rank;\n}\nprint \"\\n\";\n\nprint \"    Four 12-object random permutations using ranks\\n\";\nprint join(\" \", numtoperm(12,urandomm(factorial(12)))), \"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 12-object random permutations using randperm\\n\";\nprint join(\" \", randperm(12)),\"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 4-object random permutations of 100k objects using randperm\\n\";\nprint join(\" \", randperm(100000,4)),\"\\n\"  for 1..4;\n", "target": "from math import factorial as fact\nfrom random import randrange\nfrom textwrap import wrap\n\ndef identity_perm(n): \n    return list(range(n))\n\ndef unranker1(n, r, pi):\n    while n > 0:\n        n1, (rdivn, rmodn) = n-1, divmod(r, n)\n        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]\n        n = n1\n        r = rdivn\n    return pi\n\ndef init_pi1(n, pi): \n    pi1 = [-1] * n\n    for i in range(n): \n        pi1[pi[i]] = i\n    return pi1\n\ndef ranker1(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s + n * ranker1(n1, pi, pi1)\n\ndef unranker2(n, r, pi):\n    while n > 0:\n        n1 = n-1\n        s, rmodf = divmod(r, fact(n1))\n        pi[n1], pi[s] = pi[s], pi[n1]\n        n = n1\n        r = rmodf\n    return pi\n\ndef ranker2(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s * fact(n1) + ranker2(n1, pi, pi1)\n\ndef get_random_ranks(permsize, samplesize):    \n    perms = fact(permsize)\n    ranks = set()\n    while len(ranks) < samplesize:\n        ranks |= set( randrange(perms) \n                      for r in range(samplesize - len(ranks)) )\n    return ranks    \n\ndef test1(comment, unranker, ranker):    \n    n, samplesize, n2 = 3, 4, 12\n    print(comment)\n    perms = []\n    for r in range(fact(n)):\n        pi = identity_perm(n)\n        perm = unranker(n, r, pi)\n        perms.append((r, perm))\n    for r, pi in perms:\n        pi1 = init_pi1(n, pi)\n        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))\n    print('\\n  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))\n    print('')\n\ndef test2(comment, unranker):    \n    samplesize, n2 = 4, 144\n    print(comment)\n    print('  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + '\\n      '.join(wrap(repr(unranker(n2, r, pi)))))\n    print('')\n\nif __name__ == '__main__':\n    test1('First ordering:', unranker1, ranker1)\n    test1('Second ordering:', unranker2, ranker2)\n    test2('First ordering, large number of perms:', unranker1)\n"}
{"id": 383433, "name": "Permutations_Rank of a permutation", "source": "Translate Perl to Python: use ntheory qw/:all/;\n\nmy $n = 3;\nprint \"    Iterate Lexicographic rank/unrank of $n objects\\n\";\nfor my $k (0 .. factorial($n)-1) {\n  my @perm = numtoperm($n, $k);\n  my $rank = permtonum(\\@perm);\n  die unless $rank == $k;\n  printf \"%2d --> [@perm] --> %2d\\n\", $k, $rank;\n}\nprint \"\\n\";\n\nprint \"    Four 12-object random permutations using ranks\\n\";\nprint join(\" \", numtoperm(12,urandomm(factorial(12)))), \"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 12-object random permutations using randperm\\n\";\nprint join(\" \", randperm(12)),\"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 4-object random permutations of 100k objects using randperm\\n\";\nprint join(\" \", randperm(100000,4)),\"\\n\"  for 1..4;\n", "target": "from math import factorial as fact\nfrom random import randrange\nfrom textwrap import wrap\n\ndef identity_perm(n): \n    return list(range(n))\n\ndef unranker1(n, r, pi):\n    while n > 0:\n        n1, (rdivn, rmodn) = n-1, divmod(r, n)\n        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]\n        n = n1\n        r = rdivn\n    return pi\n\ndef init_pi1(n, pi): \n    pi1 = [-1] * n\n    for i in range(n): \n        pi1[pi[i]] = i\n    return pi1\n\ndef ranker1(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s + n * ranker1(n1, pi, pi1)\n\ndef unranker2(n, r, pi):\n    while n > 0:\n        n1 = n-1\n        s, rmodf = divmod(r, fact(n1))\n        pi[n1], pi[s] = pi[s], pi[n1]\n        n = n1\n        r = rmodf\n    return pi\n\ndef ranker2(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s * fact(n1) + ranker2(n1, pi, pi1)\n\ndef get_random_ranks(permsize, samplesize):    \n    perms = fact(permsize)\n    ranks = set()\n    while len(ranks) < samplesize:\n        ranks |= set( randrange(perms) \n                      for r in range(samplesize - len(ranks)) )\n    return ranks    \n\ndef test1(comment, unranker, ranker):    \n    n, samplesize, n2 = 3, 4, 12\n    print(comment)\n    perms = []\n    for r in range(fact(n)):\n        pi = identity_perm(n)\n        perm = unranker(n, r, pi)\n        perms.append((r, perm))\n    for r, pi in perms:\n        pi1 = init_pi1(n, pi)\n        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))\n    print('\\n  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))\n    print('')\n\ndef test2(comment, unranker):    \n    samplesize, n2 = 4, 144\n    print(comment)\n    print('  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + '\\n      '.join(wrap(repr(unranker(n2, r, pi)))))\n    print('')\n\nif __name__ == '__main__':\n    test1('First ordering:', unranker1, ranker1)\n    test1('Second ordering:', unranker2, ranker2)\n    test2('First ordering, large number of perms:', unranker1)\n"}
{"id": 383434, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse POSIX qw(fmod);\nuse Perl6::GatherTake;\n\nuse constant ln2ln10 => log(2) / log(10);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub ordinal_digit {\n    my($d) = $_[0] =~ /(.)$/;\n    $d eq '1' ? 'st' : $d eq '2' ? 'nd' : $d eq '3' ? 'rd' : 'th'\n}\n\nsub startswith12 {\n    my($nth) = @_;\n    state $i = 0;\n    state $n = 0;\n    while (1) {\n      next unless '1.2' eq substr(( 10 ** fmod(++$i * ln2ln10, 1) ), 0, 3);\n      return $i if ++$n eq $nth;\n    }\n}\n\nsub startswith123 {\n    my $pre = '1.23';\n    my ($this, $count) = (0, 0);\n\n    gather {\n      while (1) {\n        if ($this == 196) {\n            $this = 289;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 485) {\n            $this = 196;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 289) {\n            $this = 196\n        } elsif ($this ==  90) {\n            $this = 289\n        } elsif ($this ==   0) {\n            $this = 90;\n        }\n        take $count += $this;\n      }\n    }\n}\n\nmy $start_123 = startswith123(); \n\nsub p {\n    my($prefix,$nth) = @_;\n    $prefix eq '12' ? startswith12($nth) : $start_123->[$nth-1];\n}\n\nfor ([12, 1], [12, 2], [123, 45], [123, 12345], [123, 678910]) {\n    my($prefix,$nth) = @$_;\n    printf \"%-15s %9s power of two (2^n) that starts with %5s is at n = %s\\n\", \"p($prefix, $nth):\",\n        comma($nth) . ordinal_digit($nth), \"'$prefix'\", comma p($prefix, $nth);\n}\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 383435, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse POSIX qw(fmod);\nuse Perl6::GatherTake;\n\nuse constant ln2ln10 => log(2) / log(10);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub ordinal_digit {\n    my($d) = $_[0] =~ /(.)$/;\n    $d eq '1' ? 'st' : $d eq '2' ? 'nd' : $d eq '3' ? 'rd' : 'th'\n}\n\nsub startswith12 {\n    my($nth) = @_;\n    state $i = 0;\n    state $n = 0;\n    while (1) {\n      next unless '1.2' eq substr(( 10 ** fmod(++$i * ln2ln10, 1) ), 0, 3);\n      return $i if ++$n eq $nth;\n    }\n}\n\nsub startswith123 {\n    my $pre = '1.23';\n    my ($this, $count) = (0, 0);\n\n    gather {\n      while (1) {\n        if ($this == 196) {\n            $this = 289;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 485) {\n            $this = 196;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 289) {\n            $this = 196\n        } elsif ($this ==  90) {\n            $this = 289\n        } elsif ($this ==   0) {\n            $this = 90;\n        }\n        take $count += $this;\n      }\n    }\n}\n\nmy $start_123 = startswith123(); \n\nsub p {\n    my($prefix,$nth) = @_;\n    $prefix eq '12' ? startswith12($nth) : $start_123->[$nth-1];\n}\n\nfor ([12, 1], [12, 2], [123, 45], [123, 12345], [123, 678910]) {\n    my($prefix,$nth) = @$_;\n    printf \"%-15s %9s power of two (2^n) that starts with %5s is at n = %s\\n\", \"p($prefix, $nth):\",\n        comma($nth) . ordinal_digit($nth), \"'$prefix'\", comma p($prefix, $nth);\n}\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 383436, "name": "Stirling numbers of the second kind", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling2 {\n    my($n, $k) = @_;\n    my $n1 = $n - 1;\n    return 1 if     $n1 == $k;\n    return 0 unless $n1 && $k;\n    state %seen;\n    return ($seen{\"{$n1}|{$k}\"  } //= Stirling2($n1,$k  ) * $k) +\n           ($seen{\"{$n1}|{$k-1}\"} //= Stirling2($n1,$k-1))\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling2($upto+1,$_) } 0..$upto+1;\n\nsay 'Unsigned Stirling2 numbers of the second kind: S2(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (1..$upto+1) {\n    printf '%-3d', $row-1;\n    printf \"%${width}d\", Stirling2($row, $_) for 0..$row-1;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S2(100, *) row:\";\nsay max map { Stirling2(101,$_) } 0..100;\n", "target": "computed = {}\n\ndef sterling2(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif (n > 0 and k == 0) or (n == 0 and k > 0):\n\t\treturn 0\n\tif n == k:\n\t\treturn 1\n\tif k > n:\n\t\treturn 0\n\tresult = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Stirling numbers of the second kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling2(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S2(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling2(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 383437, "name": "Stirling numbers of the second kind", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling2 {\n    my($n, $k) = @_;\n    my $n1 = $n - 1;\n    return 1 if     $n1 == $k;\n    return 0 unless $n1 && $k;\n    state %seen;\n    return ($seen{\"{$n1}|{$k}\"  } //= Stirling2($n1,$k  ) * $k) +\n           ($seen{\"{$n1}|{$k-1}\"} //= Stirling2($n1,$k-1))\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling2($upto+1,$_) } 0..$upto+1;\n\nsay 'Unsigned Stirling2 numbers of the second kind: S2(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (1..$upto+1) {\n    printf '%-3d', $row-1;\n    printf \"%${width}d\", Stirling2($row, $_) for 0..$row-1;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S2(100, *) row:\";\nsay max map { Stirling2(101,$_) } 0..100;\n", "target": "computed = {}\n\ndef sterling2(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif (n > 0 and k == 0) or (n == 0 and k > 0):\n\t\treturn 0\n\tif n == k:\n\t\treturn 1\n\tif k > n:\n\t\treturn 0\n\tresult = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Stirling numbers of the second kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling2(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S2(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling2(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 383438, "name": "Cipolla's algorithm", "source": "Translate Perl to Python: use bigint;\nuse ntheory qw(is_prime);\n\nsub Legendre {\n    my($n,$p) = @_;\n    return -1 unless $p != 2 && is_prime($p);\n    my $x = ($n->as_int())->bmodpow(int(($p-1)/2), $p); \n    if    ($x==0) { return  0 }\n    elsif ($x==1) { return  1 }\n    else          { return -1 }\n}\n\nsub Cipolla {\n    my($n, $p) = @_;\n    return undef if Legendre($n,$p) != 1;\n\n    my $w2;\n    my $a = 0;\n    $a++ until Legendre(($w2 = ($a**2 - $n) % $p), $p) < 0;\n\n    my %r = ( x=> 1,  y=> 0 );\n    my %s = ( x=> $a, y=> 1 );\n    my $i = $p + 1;\n    while (1 <= ($i >>= 1)) {\n        %r = ( x => (($r{x} * $s{x} + $r{y} * $s{y} * $w2) % $p),\n               y => (($r{x} * $s{y} + $s{x} * $r{y})       % $p)\n             ) if $i % 2;\n        %s = ( x => (($s{x} * $s{x} + $s{y} * $s{y} * $w2) % $p),\n               y => (($s{x} * $s{y} + $s{x} * $s{y})       % $p)\n             )\n    }\n    $r{y} ? undef : $r{x}\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (8218, 10007),\n    (8219, 10007),\n    (331575, 1000003),\n    (665165880, 1000000007),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n   $n = shift @tests;\n   $p = shift @tests;\n   my $r = Cipolla($n, $p);\n   $r ? printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $r, $p-$r, $p\n      : print  \"No solution for ($n, $p)\\n\"\n}\n", "target": "\n\ndef convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))\n"}
{"id": 383439, "name": "Cipolla's algorithm", "source": "Translate Perl to Python: use bigint;\nuse ntheory qw(is_prime);\n\nsub Legendre {\n    my($n,$p) = @_;\n    return -1 unless $p != 2 && is_prime($p);\n    my $x = ($n->as_int())->bmodpow(int(($p-1)/2), $p); \n    if    ($x==0) { return  0 }\n    elsif ($x==1) { return  1 }\n    else          { return -1 }\n}\n\nsub Cipolla {\n    my($n, $p) = @_;\n    return undef if Legendre($n,$p) != 1;\n\n    my $w2;\n    my $a = 0;\n    $a++ until Legendre(($w2 = ($a**2 - $n) % $p), $p) < 0;\n\n    my %r = ( x=> 1,  y=> 0 );\n    my %s = ( x=> $a, y=> 1 );\n    my $i = $p + 1;\n    while (1 <= ($i >>= 1)) {\n        %r = ( x => (($r{x} * $s{x} + $r{y} * $s{y} * $w2) % $p),\n               y => (($r{x} * $s{y} + $s{x} * $r{y})       % $p)\n             ) if $i % 2;\n        %s = ( x => (($s{x} * $s{x} + $s{y} * $s{y} * $w2) % $p),\n               y => (($s{x} * $s{y} + $s{x} * $s{y})       % $p)\n             )\n    }\n    $r{y} ? undef : $r{x}\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (8218, 10007),\n    (8219, 10007),\n    (331575, 1000003),\n    (665165880, 1000000007),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n   $n = shift @tests;\n   $p = shift @tests;\n   my $r = Cipolla($n, $p);\n   $r ? printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $r, $p-$r, $p\n      : print  \"No solution for ($n, $p)\\n\"\n}\n", "target": "\n\ndef convertToBase(n, b):\n\tif(n < 2):\n\t\treturn [n];\n\ttemp = n;\n\tans = [];\n\twhile(temp != 0):\n\t\tans = [temp % b]+ ans;\n\t\ttemp /= b;\n\treturn ans;\n\n\n\n\ndef cipolla(n,p):\n\tn %= p\n\tif(n == 0 or n == 1):\n\t\treturn (n,-n%p)\n\tphi = p - 1\n\tif(pow(n, phi/2, p) != 1):\n\t\treturn ()\n\tif(p%4 == 3):\n\t\tans = pow(n,(p+1)/4,p)\n\t\treturn (ans,-ans%p)\n\taa = 0\n\tfor i in xrange(1,p):\n\t\ttemp = pow((i*i-n)%p,phi/2,p)\n\t\tif(temp == phi):\n\t\t\taa = i\n\t\t\tbreak;\n\texponent = convertToBase((p+1)/2,2)\n\tdef cipollaMult((a,b),(c,d),w,p):\n\t\treturn ((a*c+b*d*w)%p,(a*d+b*c)%p)\n\tx1 = (aa,1)\n\tx2 = cipollaMult(x1,x1,aa*aa-n,p)\n\tfor i in xrange(1,len(exponent)):\n\t\tif(exponent[i] == 0):\n\t\t\tx2 = cipollaMult(x2,x1,aa*aa-n,p)\n\t\t\tx1 = cipollaMult(x1,x1,aa*aa-n,p)\n\t\telse:\n\t\t\tx1 = cipollaMult(x1,x2,aa*aa-n,p)\n\t\t\tx2 = cipollaMult(x2,x2,aa*aa-n,p)\n\treturn (x1[0],-x1[0]%p)\n\nprint \"Roots of 2 mod 7: \" +str(cipolla(2,7))\nprint \"Roots of 8218 mod 10007: \" +str(cipolla(8218,10007))\nprint \"Roots of 56 mod 101: \" +str(cipolla(56,101))\nprint \"Roots of 1 mod 11: \" +str(cipolla(1,11))\nprint \"Roots of 8219 mod 10007: \" +str(cipolla(8219,10007))\n"}
{"id": 383440, "name": "Pierpont primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint try=>\"GMP\";\nuse ntheory qw<is_prime>;\n\n\nsub min_index { my $b = $_[my $i = 0]; $_[$_] < $b && ($b = $_[$i = $_]) for 0..$\n\nsub iter1 { my $m = shift; my $e = 0; return sub { $m ** $e++;    } }\nsub iter2 { my $m = shift; my $e = 1; return sub { $m * ($e *= 2) } }\n\nsub pierpont {\n    my($max ) = shift || die 'Must specify count of primes to generate.';\n    my($kind) = @_ ? shift : 1;\n    die \"Unknown type: $kind. Must be one of 1 (default) or 2\" unless $kind == 1 || $kind == 2;\n    $kind = -1 if $kind == 2;\n\n    my $po3     = 3;\n    my $add_one = 3;\n    my @iterators;\n    push @iterators, iter1(2);\n    push @iterators, iter1(3); $iterators[1]->();\n    my @head = ($iterators[0]->(), $iterators[1]->());\n\n    my @pierpont;\n    do {\n        my $key = min_index(@head);\n        my $min = $head[$key];\n        push @pierpont, $min + $kind if is_prime($min + $kind);\n\n        $head[$key] = $iterators[$key]->();\n\n        if ($min >= $add_one) {\n            push @iterators, iter2($po3);\n            $add_one = $head[$\n            $po3 *= 3;\n        }\n    } until @pierpont == $max;\n    @pierpont;\n}\n\nmy @pierpont_1st = pierpont(250,1);\nmy @pierpont_2nd = pierpont(250,2);\n\nsay \"First 50 Pierpont primes of the first kind:\";\nmy $fmt = \"%9d\"x10 . \"\\n\";\nfor my $row (0..4) { printf $fmt, map { $pierpont_1st[10*$row + $_] } 0..9 }\nsay \"\\nFirst 50 Pierpont primes of the second kind:\";\nfor my $row (0..4) { printf $fmt, map { $pierpont_2nd[10*$row + $_] } 0..9 }\n\nsay \"\\n250th Pierpont prime of the first kind:    \" . $pierpont_1st[249];\nsay \"\\n250th Pierpont prime of the second kind: \"   . $pierpont_2nd[249];\n", "target": "import random\n\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n\n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n\n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True  \n\n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n\n    return True\n\ndef pierpont(ulim, vlim, first):\n    p = 0\n    p2 = 1\n    p3 = 1\n    pp = []\n    for v in xrange(vlim):\n        for u in xrange(ulim):\n            p = p2 * p3\n            if first:\n                p = p + 1\n            else:\n                p = p - 1\n            if is_Prime(p):\n                pp.append(p)\n            p2 = p2 * 2\n        p3 = p3 * 3\n        p2 = 1\n    pp.sort()\n    return pp\n\ndef main():\n    print \"First 50 Pierpont primes of the first kind:\"\n    pp = pierpont(120, 80, True)\n    for i in xrange(50):\n        print \"%8d \" % pp[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"First 50 Pierpont primes of the second kind:\"\n    pp2 = pierpont(120, 80, False)\n    for i in xrange(50):\n        print \"%8d \" % pp2[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"250th Pierpont prime of the first kind:\", pp[249]\n    print \"250th Pierpont prime of the second kind:\", pp2[249]\n\nmain()\n"}
{"id": 383441, "name": "N-smooth numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw<primes>;\nuse List::Util qw<min>;\n\n\nuse Math::GMPz; \n\nsub smooth_numbers {\n\n    my @m = map { Math::GMPz->new($_) } @_;     \n    my @s;\n    push @s, [1] for 0..$\n\n    return sub {\n    my $n = $s[0][0];\n    $n = min $n, $s[$_][0] for 1..$\n    for (0..$\n            shift @{$s[$_]} if $s[$_][0] == $n;\n            push @{$s[$_]}, $n * $m[$_]\n        }\n        return $n\n    }\n}\n\nsub abbrev {\n    my($n) = @_;\n    return $n if length($n) <= 50;\n    substr($n,0,10) . \"...(@{[length($n) - 2*10]} digits omitted)...\" . substr($n, -10, 10)\n}\n\nmy @primes = @{primes(10_000)};\n\nmy $start = 3000; my $cnt = 3;\nfor my $n_smooth (0..9) {\n    say \"\\nFirst 25, and ${start}th through @{[$start+2]}nd $primes[$n_smooth]-smooth numbers:\";\n    my $s = smooth_numbers(@primes[0..$n_smooth]);\n    my @S25;\n    push @S25, $s->() for 1..25;\n    say join ' ', @S25;\n\n    my @Sm; my $c = 25;\n    do {\n        my $sn = $s->();\n        push @Sm, abbrev($sn) if ++$c >= $start;\n    } until @Sm == $cnt;\n    say join ' ', @Sm;\n}\n\n$start = 30000; $cnt = 20;\nfor my $n_smooth (95..97) { \n    say \"\\n${start}th through @{[$start+$cnt-1]}th $primes[$n_smooth]-smooth numbers:\";\n    my $s = smooth_numbers(@primes[0..$n_smooth]);\n    my(@Sm,$c);\n    do {\n        my $sn = $s->();\n        push @Sm, $sn if ++$c >= $start;\n    } until @Sm == $cnt;\n    say join ' ', @Sm;\n}\n", "target": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n\ndef isPrime(n):\n    if n < 2:\n        return False\n\n    for i in primes:\n        if n == i:\n            return True\n        if n % i == 0:\n            return False\n        if i * i > n:\n            return True\n    print \"Oops,\", n, \" is too large\"\n\ndef init():\n    s = 24\n    while s < 600:\n        if isPrime(s - 1) and s - 1 > primes[-1]:\n            primes.append(s - 1)\n        if isPrime(s + 1) and s + 1 > primes[-1]:\n            primes.append(s + 1)\n        s += 6\n\ndef nsmooth(n, size):\n    if n < 2 or n > 521:\n        raise Exception(\"n\")\n    if size < 1:\n        raise Exception(\"n\")\n\n    bn = n\n    ok = False\n    for prime in primes:\n        if bn == prime:\n            ok = True\n            break\n    if not ok:\n        raise Exception(\"must be a prime number: n\")\n\n    ns = [0] * size\n    ns[0] = 1\n\n    next = []\n    for prime in primes:\n        if prime > bn:\n            break\n        next.append(prime)\n\n    indicies = [0] * len(next)\n    for m in xrange(1, size):\n        ns[m] = min(next)\n        for i in xrange(0, len(indicies)):\n            if ns[m] == next[i]:\n                indicies[i] += 1\n                next[i] = primes[i] * ns[indicies[i]]\n\n    return ns\n\ndef main():\n    init()\n\n    for p in primes:\n        if p >= 30:\n            break\n        print \"The first\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 25)\n        print\n\n    for p in primes[1:]:\n        if p >= 30:\n            break\n        print \"The 3000 to 3202\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 3002)[2999:]\n        print\n\n    for p in [503, 509, 521]:\n        print \"The 30000 to 3019\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 30019)[29999:]\n        print\n\nmain()\n"}
{"id": 383442, "name": "Partition an integer x into n primes", "source": "Translate Perl to Python: use ntheory \":all\";\n\nsub prime_partition {\n  my($num, $parts) = @_;\n  return is_prime($num) ? [$num] : undef if $parts == 1;\n  my @p = @{primes($num)};\n  my $r;\n  forcomb { lastfor, $r = [@p[@_]] if vecsum(@p[@_]) == $num; } @p, $parts;\n  $r;\n}\n\nforeach my $test ([18,2], [19,3], [20,4], [99807,1], [99809,1], [2017,24], [22699,1], [22699,2], [22699,3], [22699,4], [40355,3]) {\n  my $partar = prime_partition(@$test);\n  printf \"Partition %5d into %2d prime piece%s %s\\n\", $test->[0], $test->[1], ($test->[1] == 1) ? \": \" : \"s:\", defined($partar) ? join(\"+\",@$partar) : \"not possible\";\n}\n", "target": "from itertools import combinations as cmb\n\n\ndef isP(n):\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    return all(n % x > 0 for x in range(3, int(n ** 0.5) + 1, 2))\n\n\ndef genP(n):\n    p = [2]\n    p.extend([x for x in range(3, n + 1, 2) if isP(x)])\n    return p\n\n\ndata = [\n    (99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),\n    (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]\n\n\nfor n, cnt in data:\n    ci = iter(cmb(genP(n), cnt))\n    while True:\n        try:\n            c = next(ci)\n            if sum(c) == n:\n                print(' '.join(\n                    [repr((n, cnt)), \"->\", '+'.join(str(s) for s in c)]\n                ))\n                break\n        except StopIteration:\n            print(repr((n, cnt)) + \" -> Not possible\")\n            break\n"}
{"id": 383443, "name": "Zeckendorf arithmetic", "source": "Translate Perl to Python: use v5.36;\n\npackage Zeckendorf;\nuse overload qw(\"\" zstring + zadd - zsub ++ zinc -- zdec * zmul / zdiv ge zge);\n\nsub new ($class, $value) {\n    bless \\$value, ref $class || $class;\n}\n\nsub zinc ($self, $, $) {\n    local $_ = $$self;\n    s/0$/1/ or s/(?:^|0)1$/10/;\n    1 while s/(?:^|0)11/100/;\n    $$self = $self->new( s/^0+\\B//r )\n}\n\nsub zdec ($self, $, $) {\n    local $_ = $$self;\n    1 while s/100(?=0*$)/011/;\n    s/1$/0/ || s/10$/01/;\n    $$self = $self->new( s/^0+\\B//r )\n}\n\nsub zadd ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    $x++, $y-- while $$y;\n    $x\n}\n\nsub zsub ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    $x--, $y-- while $$y;\n    $x\n}\n\nsub zmul ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    my $product = Zeckendorf->new(0);\n    $product = $product + $x, $y-- while $y;\n    $product\n}\n\nsub zdiv ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    my $quotient = Zeckendorf->new(0);\n    $quotient++, $x = $x - $y while $x ge $y;\n    $quotient\n}\n\nsub zge ($self, $other, $) {\n    my $l; $l = length $$other if length $other > ($l = length $$self);\n    0 x ($l - length $$self) . $$self ge 0 x ($l - length $$other) . $$other;\n}\n\nsub asdecimal ($self) {\n    my($aa, $bb, $n) = (1, 1, 0);\n    for ( reverse split '', $$self ) {\n        $n += $bb * $_;\n        ($aa, $bb) = ($bb, $aa + $bb);\n    }\n    $n\n}\n\nsub fromdecimal ($self, $value) {\n    my $z = $self->new(0);\n    $z++ for 1 .. $value;\n    $z\n}\n\nsub zstring { ${ shift() } }\n\npackage main;\n\nfor ( split /\\n/, <<END ) \n  1 + 1\n  10 + 10\n  10100 + 1010\n  10100 - 1010\n  10100 * 1010\n  100010 * 100101\n  10100 / 1010\n  101000 / 1000\n  100001000001 / 100010\n  100001000001 / 100101\nEND\n  {\n  my ($left, $op, $right) = split;\n  my ($x, $y) = map Zeckendorf->new($_), $left, $right;\n  my $answer =\n    $op eq '+' ? $x + $y :\n    $op eq '-' ? $x - $y :\n    $op eq '*' ? $x * $y :\n    $op eq '/' ? $x / $y :\n    die \"bad op <$op>\";\n    printf \"%12s %s\u00a0%-9s => %12s  in Zeckendorf\\n\", $x, $op, $y, $answer;\n    printf \"%12d %s\u00a0%-9d => %12d  in decimal\\n\\n\",\n    $x->asdecimal, $op, $y->asdecimal, $answer->asdecimal;\n  }\n", "target": "import copy\n\nclass Zeckendorf:\n    def __init__(self, x='0'):\n        q = 1\n        i = len(x) - 1\n        self.dLen = int(i / 2)\n        self.dVal = 0\n        while i >= 0:\n            self.dVal = self.dVal + (ord(x[i]) - ord('0')) * q\n            q = q * 2\n            i = i -1\n\n    def a(self, n):\n        i = n\n        while True:\n            if self.dLen < i:\n                self.dLen = i\n            j = (self.dVal >> (i * 2)) & 3\n            if j == 0 or j == 1:\n                return\n            if j == 2:\n                if (self.dVal >> ((i + 1) * 2) & 1) != 1:\n                    return\n                self.dVal = self.dVal + (1 << (i * 2 + 1))\n                return\n            if j == 3:\n                temp = 3 << (i * 2)\n                temp = temp ^ -1\n                self.dVal = self.dVal & temp\n                self.b((i + 1) * 2)\n            i = i + 1\n\n    def b(self, pos):\n        if pos == 0:\n            self.inc()\n            return\n        if (self.dVal >> pos) & 1 == 0:\n            self.dVal = self.dVal + (1 << pos)\n            self.a(int(pos / 2))\n            if pos > 1:\n                self.a(int(pos / 2) - 1)\n        else:\n            temp = 1 << pos\n            temp = temp ^ -1\n            self.dVal = self.dVal & temp\n            self.b(pos + 1)\n            self.b(pos - (2 if pos > 1 else 1))\n\n    def c(self, pos):\n        if (self.dVal >> pos) & 1 == 1:\n            temp = 1 << pos\n            temp = temp ^ -1\n            self.dVal = self.dVal & temp\n            return\n        self.c(pos + 1)\n        if pos > 0:\n            self.b(pos - 1)\n        else:\n            self.inc()\n\n    def inc(self):\n        self.dVal = self.dVal + 1\n        self.a(0)\n\n    def __add__(self, rhs):\n        copy = self\n        rhs_dVal = rhs.dVal\n        limit = (rhs.dLen + 1) * 2\n        for gn in range(0, limit):\n            if ((rhs_dVal >> gn) & 1) == 1:\n                copy.b(gn)\n        return copy\n\n    def __sub__(self, rhs):\n        copy = self\n        rhs_dVal = rhs.dVal\n        limit = (rhs.dLen + 1) * 2\n        for gn in range(0, limit):\n            if (rhs_dVal >> gn) & 1 == 1:\n                copy.c(gn)\n        while (((copy.dVal >> ((copy.dLen * 2) & 31)) & 3) == 0) or (copy.dLen == 0):\n            copy.dLen = copy.dLen - 1\n        return copy\n\n    def __mul__(self, rhs):\n        na = copy.deepcopy(rhs)\n        nb = copy.deepcopy(rhs)\n        nr = Zeckendorf()\n        dVal = self.dVal\n        for i in range(0, (self.dLen + 1) * 2):\n            if ((dVal >> i) & 1) > 0:\n                nr = nr + nb\n            nt = copy.deepcopy(nb)\n            nb = nb + na\n            na = copy.deepcopy(nt)\n        return nr\n\n    def __str__(self):\n        dig = [\"00\", \"01\", \"10\"]\n        dig1 = [\"\", \"1\", \"10\"]\n\n        if self.dVal == 0:\n            return '0'\n        idx = (self.dVal >> ((self.dLen * 2) & 31)) & 3\n        sb = dig1[idx]\n        i = self.dLen - 1\n        while i >= 0:\n            idx = (self.dVal >> (i * 2)) & 3\n            sb = sb + dig[idx]\n            i = i - 1\n        return sb\n\n\nprint \"Addition:\"\ng = Zeckendorf(\"10\")\ng = g + Zeckendorf(\"10\")\nprint g\ng = g + Zeckendorf(\"10\")\nprint g\ng = g + Zeckendorf(\"1001\")\nprint g\ng = g + Zeckendorf(\"1000\")\nprint g\ng = g + Zeckendorf(\"10101\")\nprint g\nprint\n\nprint \"Subtraction:\"\ng = Zeckendorf(\"1000\")\ng = g - Zeckendorf(\"101\")\nprint g\ng = Zeckendorf(\"10101010\")\ng = g - Zeckendorf(\"1010101\")\nprint g\nprint\n\nprint \"Multiplication:\"\ng = Zeckendorf(\"1001\")\ng = g * Zeckendorf(\"101\")\nprint g\ng = Zeckendorf(\"101010\")\ng = g + Zeckendorf(\"101\")\nprint g\n"}
{"id": 383444, "name": "Stirling numbers of the first kind", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling1 {\n    my($n, $k) = @_;\n    return 1 unless $n || $k;\n    return 0 unless $n && $k;\n    state %seen;\n    return ($seen{\"{$n-1}|{$k-1}\"} //= Stirling1($n-1, $k-1)) +\n           ($seen{\"{$n-1}|{$k}\"  } //= Stirling1($n-1, $k  )) * ($n-1)\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling1($upto,$_) } 0..$upto;\n\nsay 'Unsigned Stirling1 numbers of the first kind: S1(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    printf \"%${width}d\", Stirling1($row, $_) for 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S1(100, *) row:\";\nsay max map { Stirling1(100,$_) } 0..100;\n", "target": "computed = {}\n\ndef sterling1(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif n > 0 and k == 0:\n\t\treturn 0\n\tif k > n:\n\t\treturn 0\n\tresult = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Unsigned Stirling numbers of the first kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling1(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S1(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling1(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 383445, "name": "Stirling numbers of the first kind", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling1 {\n    my($n, $k) = @_;\n    return 1 unless $n || $k;\n    return 0 unless $n && $k;\n    state %seen;\n    return ($seen{\"{$n-1}|{$k-1}\"} //= Stirling1($n-1, $k-1)) +\n           ($seen{\"{$n-1}|{$k}\"  } //= Stirling1($n-1, $k  )) * ($n-1)\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling1($upto,$_) } 0..$upto;\n\nsay 'Unsigned Stirling1 numbers of the first kind: S1(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    printf \"%${width}d\", Stirling1($row, $_) for 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S1(100, *) row:\";\nsay max map { Stirling1(100,$_) } 0..100;\n", "target": "computed = {}\n\ndef sterling1(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif n > 0 and k == 0:\n\t\treturn 0\n\tif k > n:\n\t\treturn 0\n\tresult = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Unsigned Stirling numbers of the first kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling1(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S1(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling1(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 383446, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::MoreUtils qw(firstidx minmax);\n\nmy $epsilon = 1;\n\nsub norm {\n    my(@list) = @_;\n    my $sum;\n    $sum += $_**2 for @list;\n    sqrt($sum)\n}\n\nsub perpendicular_distance {\n    our(@start,@end,@point);\n    local(*start,*end,*point) = (shift, shift, shift);\n    return 0 if $start[0]==$point[0] && $start[1]==$point[1]\n             or   $end[0]==$point[0] &&   $end[1]==$point[1];\n    my ( $dx,  $dy)  = (  $end[0]-$start[0],  $end[1]-$start[1]);\n    my ($dpx, $dpy)  = ($point[0]-$start[0],$point[1]-$start[1]);\n    my $t = norm($dx, $dy);\n    $dx /= $t;\n    $dy /= $t;\n    norm($dpx - $dx*($dx*$dpx + $dy*$dpy), $dpy - $dy*($dx*$dpx + $dy*$dpy));\n}\n\nsub Ramer_Douglas_Peucker {\n    my(@points) = @_;\n    return @points if @points == 2;\n    my @d;\n    push @d, perpendicular_distance(@points[0, -1, $_]) for 0..@points-1;\n    my(undef,$dmax) = minmax @d;\n    my $index = firstidx { $_ == $dmax } @d;\n    if ($dmax > $epsilon) {\n        my @lo = Ramer_Douglas_Peucker( @points[0..$index]);\n        my @hi = Ramer_Douglas_Peucker( @points[$index..$\n        return  @lo[0..@lo-2], @hi;\n    }\n    @points[0, -1];\n}\n\nsay '(' . join(' ', @$_) . ') '\n    for Ramer_Douglas_Peucker( [0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9] )\n", "target": "from __future__ import print_function\nfrom shapely.geometry import LineString\n \nif __name__==\"__main__\":\n\tline = LineString([(0,0),(1,0.1),(2,-0.1),(3,5),(4,6),(5,7),(6,8.1),(7,9),(8,9),(9,9)])\n\tprint (line.simplify(1.0, preserve_topology=False))\n"}
{"id": 383447, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::MoreUtils qw(firstidx minmax);\n\nmy $epsilon = 1;\n\nsub norm {\n    my(@list) = @_;\n    my $sum;\n    $sum += $_**2 for @list;\n    sqrt($sum)\n}\n\nsub perpendicular_distance {\n    our(@start,@end,@point);\n    local(*start,*end,*point) = (shift, shift, shift);\n    return 0 if $start[0]==$point[0] && $start[1]==$point[1]\n             or   $end[0]==$point[0] &&   $end[1]==$point[1];\n    my ( $dx,  $dy)  = (  $end[0]-$start[0],  $end[1]-$start[1]);\n    my ($dpx, $dpy)  = ($point[0]-$start[0],$point[1]-$start[1]);\n    my $t = norm($dx, $dy);\n    $dx /= $t;\n    $dy /= $t;\n    norm($dpx - $dx*($dx*$dpx + $dy*$dpy), $dpy - $dy*($dx*$dpx + $dy*$dpy));\n}\n\nsub Ramer_Douglas_Peucker {\n    my(@points) = @_;\n    return @points if @points == 2;\n    my @d;\n    push @d, perpendicular_distance(@points[0, -1, $_]) for 0..@points-1;\n    my(undef,$dmax) = minmax @d;\n    my $index = firstidx { $_ == $dmax } @d;\n    if ($dmax > $epsilon) {\n        my @lo = Ramer_Douglas_Peucker( @points[0..$index]);\n        my @hi = Ramer_Douglas_Peucker( @points[$index..$\n        return  @lo[0..@lo-2], @hi;\n    }\n    @points[0, -1];\n}\n\nsay '(' . join(' ', @$_) . ') '\n    for Ramer_Douglas_Peucker( [0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9] )\n", "target": "from __future__ import print_function\nfrom shapely.geometry import LineString\n \nif __name__==\"__main__\":\n\tline = LineString([(0,0),(1,0.1),(2,-0.1),(3,5),(4,6),(5,7),(6,8.1),(7,9),(8,9),(9,9)])\n\tprint (line.simplify(1.0, preserve_topology=False))\n"}
{"id": 383448, "name": "Bilinear interpolation", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse GD;\n\nmy $image = GD::Image->newFromPng('color_wheel.png');\n$image->interpolationMethod( ['GD_BILINEAR_FIXED'] );\nmy($width,$height) = $image->getBounds();\nmy $image2 = $image->copyScaleInterpolated( 1.6*$width, 1.6*$height );\n\n$image2->_file('color_wheel_interpolated.png');\n", "target": "\nimport numpy as np\nfrom scipy.misc import imread, imshow\nfrom scipy import ndimage\n\ndef GetBilinearPixel(imArr, posX, posY):\n\tout = []\n\n\t\n\tmodXi = int(posX)\n\tmodYi = int(posY)\n\tmodXf = posX - modXi\n\tmodYf = posY - modYi\n\tmodXiPlusOneLim = min(modXi+1,imArr.shape[1]-1)\n\tmodYiPlusOneLim = min(modYi+1,imArr.shape[0]-1)\n\n\t\n\tfor chan in range(imArr.shape[2]):\n\t\tbl = imArr[modYi, modXi, chan]\n\t\tbr = imArr[modYi, modXiPlusOneLim, chan]\n\t\ttl = imArr[modYiPlusOneLim, modXi, chan]\n\t\ttr = imArr[modYiPlusOneLim, modXiPlusOneLim, chan]\n\t\n\t\t\n\t\tb = modXf * br + (1. - modXf) * bl\n\t\tt = modXf * tr + (1. - modXf) * tl\n\t\tpxf = modYf * t + (1. - modYf) * b\n\t\tout.append(int(pxf+0.5))\n\n\treturn out\n\nif __name__==\"__main__\":\n\t\n\tim = imread(\"test.jpg\", mode=\"RGB\")\n\tenlargedShape = list(map(int, [im.shape[0]*1.6, im.shape[1]*1.6, im.shape[2]]))\n\tenlargedImg = np.empty(enlargedShape, dtype=np.uint8)\n\trowScale = float(im.shape[0]) / float(enlargedImg.shape[0])\n\tcolScale = float(im.shape[1]) / float(enlargedImg.shape[1])\n\n\tfor r in range(enlargedImg.shape[0]):\n\t\tfor c in range(enlargedImg.shape[1]):\n\t\t\torir = r * rowScale \n\t\t\toric = c * colScale\n\t\t\tenlargedImg[r, c] = GetBilinearPixel(im, oric, orir)\n\n\timshow(enlargedImg)\n"}
{"id": 383449, "name": "Bilinear interpolation", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse GD;\n\nmy $image = GD::Image->newFromPng('color_wheel.png');\n$image->interpolationMethod( ['GD_BILINEAR_FIXED'] );\nmy($width,$height) = $image->getBounds();\nmy $image2 = $image->copyScaleInterpolated( 1.6*$width, 1.6*$height );\n\n$image2->_file('color_wheel_interpolated.png');\n", "target": "\nimport numpy as np\nfrom scipy.misc import imread, imshow\nfrom scipy import ndimage\n\ndef GetBilinearPixel(imArr, posX, posY):\n\tout = []\n\n\t\n\tmodXi = int(posX)\n\tmodYi = int(posY)\n\tmodXf = posX - modXi\n\tmodYf = posY - modYi\n\tmodXiPlusOneLim = min(modXi+1,imArr.shape[1]-1)\n\tmodYiPlusOneLim = min(modYi+1,imArr.shape[0]-1)\n\n\t\n\tfor chan in range(imArr.shape[2]):\n\t\tbl = imArr[modYi, modXi, chan]\n\t\tbr = imArr[modYi, modXiPlusOneLim, chan]\n\t\ttl = imArr[modYiPlusOneLim, modXi, chan]\n\t\ttr = imArr[modYiPlusOneLim, modXiPlusOneLim, chan]\n\t\n\t\t\n\t\tb = modXf * br + (1. - modXf) * bl\n\t\tt = modXf * tr + (1. - modXf) * tl\n\t\tpxf = modYf * t + (1. - modYf) * b\n\t\tout.append(int(pxf+0.5))\n\n\treturn out\n\nif __name__==\"__main__\":\n\t\n\tim = imread(\"test.jpg\", mode=\"RGB\")\n\tenlargedShape = list(map(int, [im.shape[0]*1.6, im.shape[1]*1.6, im.shape[2]]))\n\tenlargedImg = np.empty(enlargedShape, dtype=np.uint8)\n\trowScale = float(im.shape[0]) / float(enlargedImg.shape[0])\n\tcolScale = float(im.shape[1]) / float(enlargedImg.shape[1])\n\n\tfor r in range(enlargedImg.shape[0]):\n\t\tfor c in range(enlargedImg.shape[1]):\n\t\t\torir = r * rowScale \n\t\t\toric = c * colScale\n\t\t\tenlargedImg[r, c] = GetBilinearPixel(im, oric, orir)\n\n\timshow(enlargedImg)\n"}
{"id": 383450, "name": "Vector", "source": "Translate Perl to Python: use v5.36;\n\npackage Vector;\nuse Moose;\nuse overload '+'  => \\&add,\n             '-'  => \\&sub,\n             '*'  => \\&mul,\n             '/'  => \\&div,\n             '\"\"' => \\&stringify;\n\nhas 'x' => (is =>'rw', isa => 'Num', required => 1);\nhas 'y' => (is =>'rw', isa => 'Num', required => 1);\n\nsub add ($a, $b, $) { Vector->new( x => $a->x + $b->x, y => $a->y + $b->y) }\nsub sub ($a, $b, $) { Vector->new( x => $a->x - $b->x, y => $a->y - $b->y) }\nsub mul ($a, $b, $) { Vector->new( x => $a->x * $b,    y => $a->y * $b)    }\nsub div ($a, $b, $) { Vector->new( x => $a->x / $b,    y => $a->y / $b)    }\nsub stringify ($self, $, $) { '(' . $self->x . ',' . $self->y . ')' }\n\npackage main;\n\nmy $a = Vector->new(x => 5, y => 7);\nmy $b = Vector->new(x => 2, y => 3);\nsay \"a:    $a\";\nsay \"b:    $b\";\nsay \"a+b:  \",$a+$b;\nsay \"a-b:  \",$a-$b;\nsay \"a*11: \",$a*11;\nsay \"a/2:  \",$a/2;\n", "target": "v1 = PVector(5, 7)\nv2 = PVector(2, 3)\n\nprintln('{} {} {} {}\\n'.format( v1.x, v1.y, v1.mag(), v1.heading()))\n\n\nprintln(v1 + v2) \nprintln(v1 - v2) \nprintln(v1 * 11) \nprintln(v1 / 2)  \nprintln('')\n\n\nprintln(v1.sub(v1))  \nprintln(v1.add(v2))  \nprintln(v1.mult(10)) \nprintln(v1.div(10))  \n"}
{"id": 383451, "name": "Elliptic curve arithmetic", "source": "Translate Perl to Python: package EC;\n{\n    our ($A, $B) = (0, 7);\n    package EC::Point;\n    sub new { my $class = shift; bless [ @_ ], $class }\n    sub zero { bless [], shift }\n    sub x { shift->[0] }; sub y { shift->[1] };\n    sub double {\n        my $self = shift;\n        return $self unless @$self;\n        my $L = (3 * $self->x**2) / (2*$self->y);\n        my $x = $L**2 - 2*$self->x;\n        bless [ $x, $L * ($self->x - $x) - $self->y ], ref $self;\n    }\n    use overload\n    '==' => sub { my ($p, $q) = @_; $p->x == $q->x and $p->y == $q->y },\n    '+' => sub {\n        my ($p, $q) = @_;\n        return $p->double if $p == $q;\n        return $p unless @$q;\n        return $q unless @$p;\n        my $slope = ($q->y - $p->y) / ($q->x - $p->x);\n        my $x = $slope**2 - $p->x - $q->x;\n        bless [ $x, $slope * ($p->x - $x)  - $p->y ], ref $p;\n    },\n    q{\"\"} => sub {\n        my $self = shift;\n        return @$self\n        ? sprintf \"EC-point at x=%f, y=%f\", @$self\n        : 'EC point at infinite';\n    }\n}\n\npackage Test;\nmy $p = +EC::Point->new(-($EC::B - 1)**(1/3), 1);\nmy $q = +EC::Point->new(-($EC::B - 4)**(1/3), 2);\nmy $s = $p + $q, \"\\n\";\nprint \"$_\\n\" for $p, $q, $s;\nprint \"check alignment... \";\nprint abs(($q->x - $p->x)*(-$s->y - $p->y) - ($q->y - $p->y)*($s->x - $p->x)) < 0.001\n    ? \"ok\" : \"wrong\";\n", "target": "\n\nclass Point:\n    b = 7\n    def __init__(self, x=float('inf'), y=float('inf')):\n        self.x = x\n        self.y = y\n\n    def copy(self):\n        return Point(self.x, self.y)\n\n    def is_zero(self):\n        return self.x > 1e20 or self.x < -1e20\n\n    def neg(self):\n        return Point(self.x, -self.y)\n\n    def dbl(self):\n        if self.is_zero():\n            return self.copy()\n        try:\n            L = (3 * self.x * self.x) / (2 * self.y)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - 2 * self.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def add(self, q):\n        if self.x == q.x and self.y == q.y:\n            return self.dbl()\n        if self.is_zero():\n            return q.copy()\n        if q.is_zero():\n            return self.copy()\n        try:\n            L = (q.y - self.y) / (q.x - self.x)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - self.x - q.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def mul(self, n):\n        p = self.copy()\n        r = Point()\n        i = 1\n        while i <= n:\n            if i&n:\n                r = r.add(p)\n            p = p.dbl()\n            i <<= 1\n        return r\n\n    def __str__(self):\n        return \"({:.3f}, {:.3f})\".format(self.x, self.y)\n\ndef show(s, p):\n    print(s, \"Zero\" if p.is_zero() else p)\n\ndef from_y(y):\n    n = y * y - Point.b\n    x = n**(1./3) if n>=0 else -((-n)**(1./3))\n    return Point(x, y)\n\n\na = from_y(1)\nb = from_y(2)\nshow(\"a =\", a)\nshow(\"b =\", b)\nc = a.add(b)\nshow(\"c = a + b =\", c)\nd = c.neg()\nshow(\"d = -c =\", d)\nshow(\"c + d =\", c.add(d))\nshow(\"a + b + d =\", a.add(b.add(d)))\nshow(\"a * 12345 =\", a.mul(12345))\n"}
{"id": 383452, "name": "Elliptic curve arithmetic", "source": "Translate Perl to Python: package EC;\n{\n    our ($A, $B) = (0, 7);\n    package EC::Point;\n    sub new { my $class = shift; bless [ @_ ], $class }\n    sub zero { bless [], shift }\n    sub x { shift->[0] }; sub y { shift->[1] };\n    sub double {\n        my $self = shift;\n        return $self unless @$self;\n        my $L = (3 * $self->x**2) / (2*$self->y);\n        my $x = $L**2 - 2*$self->x;\n        bless [ $x, $L * ($self->x - $x) - $self->y ], ref $self;\n    }\n    use overload\n    '==' => sub { my ($p, $q) = @_; $p->x == $q->x and $p->y == $q->y },\n    '+' => sub {\n        my ($p, $q) = @_;\n        return $p->double if $p == $q;\n        return $p unless @$q;\n        return $q unless @$p;\n        my $slope = ($q->y - $p->y) / ($q->x - $p->x);\n        my $x = $slope**2 - $p->x - $q->x;\n        bless [ $x, $slope * ($p->x - $x)  - $p->y ], ref $p;\n    },\n    q{\"\"} => sub {\n        my $self = shift;\n        return @$self\n        ? sprintf \"EC-point at x=%f, y=%f\", @$self\n        : 'EC point at infinite';\n    }\n}\n\npackage Test;\nmy $p = +EC::Point->new(-($EC::B - 1)**(1/3), 1);\nmy $q = +EC::Point->new(-($EC::B - 4)**(1/3), 2);\nmy $s = $p + $q, \"\\n\";\nprint \"$_\\n\" for $p, $q, $s;\nprint \"check alignment... \";\nprint abs(($q->x - $p->x)*(-$s->y - $p->y) - ($q->y - $p->y)*($s->x - $p->x)) < 0.001\n    ? \"ok\" : \"wrong\";\n", "target": "\n\nclass Point:\n    b = 7\n    def __init__(self, x=float('inf'), y=float('inf')):\n        self.x = x\n        self.y = y\n\n    def copy(self):\n        return Point(self.x, self.y)\n\n    def is_zero(self):\n        return self.x > 1e20 or self.x < -1e20\n\n    def neg(self):\n        return Point(self.x, -self.y)\n\n    def dbl(self):\n        if self.is_zero():\n            return self.copy()\n        try:\n            L = (3 * self.x * self.x) / (2 * self.y)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - 2 * self.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def add(self, q):\n        if self.x == q.x and self.y == q.y:\n            return self.dbl()\n        if self.is_zero():\n            return q.copy()\n        if q.is_zero():\n            return self.copy()\n        try:\n            L = (q.y - self.y) / (q.x - self.x)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - self.x - q.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def mul(self, n):\n        p = self.copy()\n        r = Point()\n        i = 1\n        while i <= n:\n            if i&n:\n                r = r.add(p)\n            p = p.dbl()\n            i <<= 1\n        return r\n\n    def __str__(self):\n        return \"({:.3f}, {:.3f})\".format(self.x, self.y)\n\ndef show(s, p):\n    print(s, \"Zero\" if p.is_zero() else p)\n\ndef from_y(y):\n    n = y * y - Point.b\n    x = n**(1./3) if n>=0 else -((-n)**(1./3))\n    return Point(x, y)\n\n\na = from_y(1)\nb = from_y(2)\nshow(\"a =\", a)\nshow(\"b =\", b)\nc = a.add(b)\nshow(\"c = a + b =\", c)\nd = c.neg()\nshow(\"d = -c =\", d)\nshow(\"c + d =\", c.add(d))\nshow(\"a + b + d =\", a.add(b.add(d)))\nshow(\"a * 12345 =\", a.mul(12345))\n"}
{"id": 383453, "name": "Chebyshev coefficients", "source": "Translate Perl to Python: use constant PI => 2 * atan2(1, 0);\n\nsub chebft {\n  my($func, $a, $b, $n) = @_;\n  my($bma, $bpa) = ( 0.5*($b-$a), 0.5*($b+$a) );\n\n  my @pin = map { ($_ + 0.5) * (PI/$n) } 0..$n-1;\n  my @f   = map { $func->( cos($_) * $bma + $bpa ) } @pin;\n  my @c   = (0) x $n;\n  for my $j (0 .. $n-1) {\n      $c[$j] += $f[$_] * cos($j * $pin[$_]) for 0..$n-1;\n      $c[$j] *= (2.0/$n);\n  }\n  @c\n}\n\nprintf \"%+13.7e\\n\", $_ for chebft(sub{cos($_[0])}, 0, 1, 10);\n", "target": "import math\n\ndef test_func(x):\n    return math.cos(x)\n\ndef mapper(x, min_x, max_x, min_to, max_to):\n    return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to\n\ndef cheb_coef(func, n, min, max):\n    coef = [0.0] * n\n    for i in xrange(n):\n        f = func(mapper(math.cos(math.pi * (i + 0.5) / n), -1, 1, min, max)) * 2 / n\n        for j in xrange(n):\n            coef[j] += f * math.cos(math.pi * j * (i + 0.5) / n)\n    return coef\n\ndef cheb_approx(x, n, min, max, coef):\n    a = 1\n    b = mapper(x, min, max, -1, 1)\n    c = float('nan')\n    res = coef[0] / 2 + coef[1] * b\n\n    x = 2 * b\n    i = 2\n    while i < n:\n        c = x * b - a\n        res = res + coef[i] * c\n        (a, b) = (b, c)\n        i += 1\n\n    return res\n\ndef main():\n    N = 10\n    min = 0\n    max = 1\n    c = cheb_coef(test_func, N, min, max)\n\n    print \"Coefficients:\"\n    for i in xrange(N):\n        print \" % lg\" % c[i]\n\n    print \"\\n\\nApproximation:\\n    x      func(x)       approx      diff\"\n    for i in xrange(20):\n        x = mapper(i, 0.0, 20.0, min, max)\n        f = test_func(x)\n        approx = cheb_approx(x, N, min, max, c)\n        print \"%1.3f %10.10f %10.10f % 4.2e\" % (x, f, approx, approx - f)\n\n    return None\n\nmain()\n"}
{"id": 383454, "name": "Burrows\u2013Wheeler transform", "source": "Translate Perl to Python: use utf8;\nbinmode STDOUT, \":utf8\";\n\nuse constant STX => '\ud83d\udc4d ';\n\nsub transform {\n    my($s) = @_;\n    my($t);\n    warn \"String can't contain STX character.\" and exit if $s =~ /STX/;\n    $s = STX . $s;\n    $t .= substr($_,-1,1) for sort map { rotate($s,$_) } 1..length($s);\n    return $t;\n}\n\nsub rotate { my($s,$n) = @_; join '', (split '', $s)[$n..length($s)-1, 0..$n-1] }\n\nsub \u026f\u0279o\u025fsu\u0250\u0279\u0287 {\n    my($s) = @_;\n    my @s = split '', $s;\n    my @t = sort @s;\n    map { @t = sort map { $s[$_] . $t[$_] } 0..length($s)-1 } 1..length($s)-1;\n    for (@t) {\n        next unless /${\\(STX)}$/;  \n        chop $_ and return $_\n    }\n}\n\nfor $phrase (qw<BANANA dogwood SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES>,\n    'TO BE OR NOT TO BE OR WANT TO BE OR NOT?') {\n    push @res, 'Original:            '. $phrase;\n    push @res, 'Transformed:         '. transform $phrase;\n    push @res, 'Inverse transformed: '. \u026f\u0279o\u025fsu\u0250\u0279\u0287 transform $phrase;\n    push @res, '';\n}\n\nprint join \"\\n\", @res;\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 383455, "name": "Burrows\u2013Wheeler transform", "source": "Translate Perl to Python: use utf8;\nbinmode STDOUT, \":utf8\";\n\nuse constant STX => '\ud83d\udc4d ';\n\nsub transform {\n    my($s) = @_;\n    my($t);\n    warn \"String can't contain STX character.\" and exit if $s =~ /STX/;\n    $s = STX . $s;\n    $t .= substr($_,-1,1) for sort map { rotate($s,$_) } 1..length($s);\n    return $t;\n}\n\nsub rotate { my($s,$n) = @_; join '', (split '', $s)[$n..length($s)-1, 0..$n-1] }\n\nsub \u026f\u0279o\u025fsu\u0250\u0279\u0287 {\n    my($s) = @_;\n    my @s = split '', $s;\n    my @t = sort @s;\n    map { @t = sort map { $s[$_] . $t[$_] } 0..length($s)-1 } 1..length($s)-1;\n    for (@t) {\n        next unless /${\\(STX)}$/;  \n        chop $_ and return $_\n    }\n}\n\nfor $phrase (qw<BANANA dogwood SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES>,\n    'TO BE OR NOT TO BE OR WANT TO BE OR NOT?') {\n    push @res, 'Original:            '. $phrase;\n    push @res, 'Transformed:         '. transform $phrase;\n    push @res, 'Inverse transformed: '. \u026f\u0279o\u025fsu\u0250\u0279\u0287 transform $phrase;\n    push @res, '';\n}\n\nprint join \"\\n\", @res;\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 383456, "name": "Card shuffles", "source": "Translate Perl to Python: sub overhand {\n    our @cards; local *cards = shift;\n    my(@splits,@shuffle);\n    my $x = int +@cards / 5;\n    push @splits, (1..$x)[int rand $x] for 1..+@cards;\n    while (@cards) {\n        push @shuffle, [splice @cards, 0, shift @splits];\n    }\n    @cards = flatten(reverse @shuffle);\n}\n\nsub flatten { map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_ }\n\nsub riffle {\n    our @cards; local *cards = shift;\n    splice @cards, @cards/2 - $_, 0, pop @cards for 0 .. (@cards/2)-1;\n}\n\n@cards = 1..20;\noverhand(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n\n@cards = 1..20;\nriffle(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n", "target": "import random\n\ndef riffleShuffle(va, flips):\n    nl = va\n    for n in range(flips):\n        \n        cutPoint = len(nl)/2 + random.choice([-1, 1]) * random.randint(0, len(va)/10)\n\n        \n        left = nl[0:cutPoint]\n        right = nl[cutPoint:]\n\n        del nl[:]\n        while (len(left) > 0 and len(right) > 0):\n            \n            \n            \n            if (random.uniform(0, 1) >= len(left) / len(right) / 2):\n                nl.append(right.pop(0))\n            else:\n                nl.append(left.pop(0))\n        if (len(left) > 0):\n            nl = nl + left\n        if (len(right) > 0):\n            nl = nl + right\n    return nl\n\ndef overhandShuffle(va, passes):\n    mainHand = va\n    for n in range(passes):\n        otherHand = []\n        while (len(mainHand) > 0):\n            \n            cutSize = random.randint(0, len(va) / 5) + 1\n            temp = []\n\n            \n            i=0\n            while (i<cutSize and len(mainHand) > 0):\n                temp.append(mainHand.pop(0))\n                i = i + 1\n\n            \n            if (random.uniform(0, 1) >= 0.1):\n                \n                otherHand = temp + otherHand\n            else:\n                otherHand = otherHand + temp\n        \n        mainHand = otherHand\n    return mainHand\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 10)\nprint\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 1)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 10)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 1)\nprint\n\nprint \"Library shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nrandom.shuffle(nums)\nprint nums\nprint\n"}
{"id": 383457, "name": "Card shuffles", "source": "Translate Perl to Python: sub overhand {\n    our @cards; local *cards = shift;\n    my(@splits,@shuffle);\n    my $x = int +@cards / 5;\n    push @splits, (1..$x)[int rand $x] for 1..+@cards;\n    while (@cards) {\n        push @shuffle, [splice @cards, 0, shift @splits];\n    }\n    @cards = flatten(reverse @shuffle);\n}\n\nsub flatten { map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_ }\n\nsub riffle {\n    our @cards; local *cards = shift;\n    splice @cards, @cards/2 - $_, 0, pop @cards for 0 .. (@cards/2)-1;\n}\n\n@cards = 1..20;\noverhand(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n\n@cards = 1..20;\nriffle(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n", "target": "import random\n\ndef riffleShuffle(va, flips):\n    nl = va\n    for n in range(flips):\n        \n        cutPoint = len(nl)/2 + random.choice([-1, 1]) * random.randint(0, len(va)/10)\n\n        \n        left = nl[0:cutPoint]\n        right = nl[cutPoint:]\n\n        del nl[:]\n        while (len(left) > 0 and len(right) > 0):\n            \n            \n            \n            if (random.uniform(0, 1) >= len(left) / len(right) / 2):\n                nl.append(right.pop(0))\n            else:\n                nl.append(left.pop(0))\n        if (len(left) > 0):\n            nl = nl + left\n        if (len(right) > 0):\n            nl = nl + right\n    return nl\n\ndef overhandShuffle(va, passes):\n    mainHand = va\n    for n in range(passes):\n        otherHand = []\n        while (len(mainHand) > 0):\n            \n            cutSize = random.randint(0, len(va) / 5) + 1\n            temp = []\n\n            \n            i=0\n            while (i<cutSize and len(mainHand) > 0):\n                temp.append(mainHand.pop(0))\n                i = i + 1\n\n            \n            if (random.uniform(0, 1) >= 0.1):\n                \n                otherHand = temp + otherHand\n            else:\n                otherHand = otherHand + temp\n        \n        mainHand = otherHand\n    return mainHand\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 10)\nprint\n\nprint \"Riffle shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint riffleShuffle(nums, 1)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 10)\nprint\n\nprint \"Overhand shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nprint overhandShuffle(nums, 1)\nprint\n\nprint \"Library shuffle\"\nnums = [x+1 for x in range(21)]\nprint nums\nrandom.shuffle(nums)\nprint nums\nprint\n"}
{"id": 383458, "name": "Faulhaber's triangle", "source": "Translate Perl to Python: use 5.010;\nuse List::Util qw(sum);\nuse Math::BigRat try => 'GMP';\nuse ntheory qw(binomial bernfrac);\n\nsub faulhaber_triangle {\n    my ($p) = @_;\n    map {\n        Math::BigRat->new(bernfrac($_))\n          * binomial($p, $_)\n          / $p\n    } reverse(0 .. $p-1);\n}\n\n\nforeach my $p (1 .. 10) {\n    say map { sprintf(\"%6s\", $_) } faulhaber_triangle($p);\n}\n\n\nmy $p = 17;\nmy $n = Math::BigInt->new(1000);\nmy @r = faulhaber_triangle($p+1);\nsay \"\\n\", sum(map { $r[$_] * $n**($_ + 1) } 0 .. $\n", "target": "\n\nfrom itertools import accumulate, chain, count, islice\nfrom fractions import Fraction\n\n\n\ndef faulhaberTriangle(m):\n    \n    def go(rs, n):\n        def f(x, y):\n            return Fraction(n, x) * y\n        xs = list(map(f, islice(count(2), m), rs))\n        return [Fraction(1 - sum(xs), 1)] + xs\n\n    return list(accumulate(\n        [[]] + list(islice(count(0), 1 + m)),\n        go\n    ))[1:]\n\n\n\ndef faulhaberSum(p, n):\n    \n    def go(x, y):\n        return y * (n ** x)\n\n    return sum(\n        map(go, count(1), faulhaberTriangle(p)[-1])\n    )\n\n\n\ndef main():\n    \n\n    fs = faulhaberTriangle(9)\n    print(\n        fTable(__doc__ + ':\\n')(str)(\n            compose(concat)(\n                fmap(showRatio(3)(3))\n            )\n        )(\n            index(fs)\n        )(range(0, len(fs)))\n    )\n    print('')\n    print(\n        faulhaberSum(17, 1000)\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def gox(xShow):\n        def gofx(fxShow):\n            def gof(f):\n                def goxs(xs):\n                    ys = [xShow(x) for x in xs]\n                    w = max(map(len, ys))\n\n                    def arrowed(x, y):\n                        return y.rjust(w, ' ') + ' -> ' + (\n                            fxShow(f(x))\n                        )\n                    return s + '\\n' + '\\n'.join(\n                        map(arrowed, xs, ys)\n                    )\n                return goxs\n            return gof\n        return gofx\n    return gox\n\n\n\n\n\ndef compose(g):\n    \n    return lambda f: lambda x: g(f(x))\n\n\n\n\ndef concat(xs):\n    \n    def f(ys):\n        zs = list(chain(*ys))\n        return ''.join(zs) if isinstance(ys[0], str) else zs\n\n    return (\n        f(xs) if isinstance(xs, list) else (\n            chain.from_iterable(xs)\n        )\n    ) if xs else []\n\n\n\ndef fmap(f):\n    \n    def go(xs):\n        return list(map(f, xs))\n\n    return go\n\n\n\ndef index(xs):\n    \n    return lambda n: None if 0 > n else (\n        xs[n] if (\n            hasattr(xs, \"__getitem__\")\n        ) else next(islice(xs, n, None))\n    )\n\n\n\ndef showRatio(m):\n    \n    def go(n):\n        def f(r):\n            d = r.denominator\n            return str(r.numerator).rjust(m, ' ') + (\n                ('/' + str(d).ljust(n, ' ')) if 1 != d else (\n                    ' ' * (1 + n)\n                )\n            )\n        return f\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383459, "name": "Paraffins", "source": "Translate Perl to Python: use Math::GMPz;\n\nmy $nmax = 250;\nmy $nbranches = 4;\n\nmy @rooted   = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @unrooted = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @c        = map { Math::GMPz->new(0) } 0 .. $nbranches-1;\n\nsub tree {\n  my($br, $n, $l, $sum, $cnt) = @_;\n  for my $b ($br+1 .. $nbranches) {\n    $sum += $n;\n    return if $sum > $nmax || ($l*2 >= $sum && $b >= $nbranches);\n    if ($b == $br+1) {\n      $c[$br] = $rooted[$n] * $cnt;\n    } else {\n      $c[$br] *= $rooted[$n] + $b - $br - 1;\n      $c[$br] /= $b - $br;\n    }\n    $unrooted[$sum] += $c[$br] if $l*2 < $sum;\n    return if $b >= $nbranches;\n    $rooted[$sum] += $c[$br];\n    for my $m (reverse 1 .. $n-1) {\n      next if $sum+$m > $nmax;\n      tree($b, $m, $l, $sum, $c[$br]);\n    }\n  }\n}\n\nsub bicenter {\n  my $s = shift;\n  $unrooted[$s] += $rooted[$s/2] * ($rooted[$s/2]+1) / 2  unless $s & 1;\n}\n\nfor my $n (1 .. $nmax) {\n  tree(0, $n, $n, 1, Math::GMPz->new(1));\n  bicenter($n);\n  print \"$n: $unrooted[$n]\\n\";\n}\n", "target": "try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\nMAX_N = 300\nBRANCH = 4\n\nra = [0] * MAX_N\nunrooted = [0] * MAX_N\n\ndef tree(br, n, l, sum = 1, cnt = 1):\n    global ra, unrooted, MAX_N, BRANCH\n    for b in xrange(br + 1, BRANCH + 1):\n        sum += n\n        if sum >= MAX_N:\n            return\n\n        \n        if l * 2 >= sum and b >= BRANCH:\n            return\n\n        if b == br + 1:\n            c = ra[n] * cnt\n        else:\n            c = c * (ra[n] + (b - br - 1)) / (b - br)\n\n        if l * 2 < sum:\n            unrooted[sum] += c\n\n        if b < BRANCH:\n            ra[sum] += c;\n            for m in range(1, n):\n                tree(b, m, l, sum, c)\n\ndef bicenter(s):\n    global ra, unrooted\n    if not (s & 1):\n        aux = ra[s / 2]\n        unrooted[s] += aux * (aux + 1) / 2\n\n\ndef main():\n    global ra, unrooted, MAX_N\n    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1\n\n    for n in xrange(1, MAX_N):\n        tree(0, n, n)\n        bicenter(n)\n        print \"%d: %d\" % (n, unrooted[n])\n\nmain()\n"}
{"id": 383460, "name": "Paraffins", "source": "Translate Perl to Python: use Math::GMPz;\n\nmy $nmax = 250;\nmy $nbranches = 4;\n\nmy @rooted   = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @unrooted = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @c        = map { Math::GMPz->new(0) } 0 .. $nbranches-1;\n\nsub tree {\n  my($br, $n, $l, $sum, $cnt) = @_;\n  for my $b ($br+1 .. $nbranches) {\n    $sum += $n;\n    return if $sum > $nmax || ($l*2 >= $sum && $b >= $nbranches);\n    if ($b == $br+1) {\n      $c[$br] = $rooted[$n] * $cnt;\n    } else {\n      $c[$br] *= $rooted[$n] + $b - $br - 1;\n      $c[$br] /= $b - $br;\n    }\n    $unrooted[$sum] += $c[$br] if $l*2 < $sum;\n    return if $b >= $nbranches;\n    $rooted[$sum] += $c[$br];\n    for my $m (reverse 1 .. $n-1) {\n      next if $sum+$m > $nmax;\n      tree($b, $m, $l, $sum, $c[$br]);\n    }\n  }\n}\n\nsub bicenter {\n  my $s = shift;\n  $unrooted[$s] += $rooted[$s/2] * ($rooted[$s/2]+1) / 2  unless $s & 1;\n}\n\nfor my $n (1 .. $nmax) {\n  tree(0, $n, $n, 1, Math::GMPz->new(1));\n  bicenter($n);\n  print \"$n: $unrooted[$n]\\n\";\n}\n", "target": "try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\nMAX_N = 300\nBRANCH = 4\n\nra = [0] * MAX_N\nunrooted = [0] * MAX_N\n\ndef tree(br, n, l, sum = 1, cnt = 1):\n    global ra, unrooted, MAX_N, BRANCH\n    for b in xrange(br + 1, BRANCH + 1):\n        sum += n\n        if sum >= MAX_N:\n            return\n\n        \n        if l * 2 >= sum and b >= BRANCH:\n            return\n\n        if b == br + 1:\n            c = ra[n] * cnt\n        else:\n            c = c * (ra[n] + (b - br - 1)) / (b - br)\n\n        if l * 2 < sum:\n            unrooted[sum] += c\n\n        if b < BRANCH:\n            ra[sum] += c;\n            for m in range(1, n):\n                tree(b, m, l, sum, c)\n\ndef bicenter(s):\n    global ra, unrooted\n    if not (s & 1):\n        aux = ra[s / 2]\n        unrooted[s] += aux * (aux + 1) / 2\n\n\ndef main():\n    global ra, unrooted, MAX_N\n    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1\n\n    for n in xrange(1, MAX_N):\n        tree(0, n, n)\n        bicenter(n)\n        print \"%d: %d\" % (n, unrooted[n])\n\nmain()\n"}
{"id": 383461, "name": "NYSIIS", "source": "Translate Perl to Python: sub no_suffix {\n    my($name) = @_;\n    $name =~ s/\\h([JS]R)|([IVX]+)$//i;\n    return uc $name;\n}\n\nsub nysiis {\n    my($name) = @_;\n    local($_) = uc $name;\n\n    s/[^A-Z]//g;\n    s/^MAC/MCC/;\n    s/^P[FH]/FF/;\n    s/^SCH/SSS/;\n    s/^KN/N/;\n    s/[IE]E$/Y/;\n    s/[DRN]T$/D/;\n    s/[RN]D$/D/;\n    s/(.)EV/$1AF/g;\n    s/(.)[AEIOU]+/$1A/g;\n    s/(.)Q/$1G/g;\n    s/(.)Z/$1S/g;\n    s/(.)M/$1N/g;\n    s/(.)KN/$1N/g;\n    s/(.)K/$1C/g;\n    s/(.)SCH/$1S/g;\n    s/(.)PF/$1F/g;\n    s/(.)K/$1C/g;\n    s/(.)H([^AEIOU])/$1$2/g;\n    s/([^AEIOU])H/$1/g;\n    s/(.)W/$1/g;\n    s/AY$/Y/;\n    s/S$//;\n    s/A$//;\n    s/(.)\\1+/$1/g;\n    return $_;\n}\n\nfor (\n    \"knight\",     \"mitchell\",  \"o'daniel\",    \"brown sr\",   \"browne III\",\n    \"browne IV\",  \"O'Banion\",  \"Mclaughlin\",  \"McCormack\",  \"Chapman\",\n    \"Silva\",      \"McDonald\",  \"Lawson\",      \"Jacobs\",     \"Greene\",\n    \"O'Brien\",    \"Morrison\",  \"Larson\",      \"Willis\",     \"Mackenzie\",\n    \"Carr\",       \"Lawrence\",  \"Matthews\",    \"Richards\",   \"Bishop\",\n    \"Franklin\",   \"McDaniel\",  \"Harper\",      \"Lynch\",      \"Watkins\",\n    \"Carlson\",    \"Wheeler\",   \"Louis XVI\"\n) {\n    my $nysiis = nysiis no_suffix $_;\n    $nysiis =~ s/^(......)(.*)$/$1\\[$2\\]/ if length($nysiis) > 6;\n    printf \"%10s,  %s\\n\", $_, $nysiis;\n}\n", "target": "import re\n\n_vowels = 'AEIOU'\n\ndef replace_at(text, position, fromlist, tolist):\n    for f, t in zip(fromlist, tolist):\n        if text[position:].startswith(f):\n            return ''.join([text[:position],\n                            t,\n                            text[position+len(f):]])\n    return text\n\ndef replace_end(text, fromlist, tolist):\n    for f, t in zip(fromlist, tolist):\n        if text.endswith(f):\n            return text[:-len(f)] + t\n    return text\n\ndef nysiis(name):\n    name = re.sub(r'\\W', '', name).upper()\n    name = replace_at(name, 0, ['MAC', 'KN', 'K', 'PH', 'PF', 'SCH'],\n                               ['MCC', 'N',  'C', 'FF', 'FF', 'SSS'])\n    name = replace_end(name, ['EE', 'IE', 'DT', 'RT', 'RD', 'NT', 'ND'],\n                             ['Y',  'Y',  'D',  'D',  'D',  'D',  'D'])\n    key, key1 = name[0], ''\n    i = 1\n    while i < len(name):\n        \n        n_1, n = name[i-1], name[i]\n        n1_ = name[i+1] if i+1 < len(name) else ''\n        name = replace_at(name, i, ['EV'] + list(_vowels), ['AF'] + ['A']*5)\n        name = replace_at(name, i, 'QZM', 'GSN')\n        name = replace_at(name, i, ['KN', 'K'], ['N', 'C'])\n        name = replace_at(name, i, ['SCH', 'PH'], ['SSS', 'FF'])\n        if n == 'H' and (n_1 not in _vowels or n1_ not in _vowels):\n            name = ''.join([name[:i], n_1, name[i+1:]])\n        if n == 'W' and n_1 in _vowels:\n            name = ''.join([name[:i], 'A', name[i+1:]])\n        if key and key[-1] != name[i]:\n            key += name[i]\n        i += 1\n    key = replace_end(key, ['S', 'AY', 'A'], ['', 'Y', ''])\n    return key1 + key\n\nif __name__ == '__main__':\n    names = ['Bishop', 'Carlson', 'Carr', 'Chapman', 'Franklin',\n             'Greene', 'Harper', 'Jacobs', 'Larson', 'Lawrence',\n             'Lawson', 'Louis, XVI', 'Lynch', 'Mackenzie', 'Matthews',\n             'McCormack', 'McDaniel', 'McDonald', 'Mclaughlin', 'Morrison',\n             \"O'Banion\", \"O'Brien\", 'Richards', 'Silva', 'Watkins',\n             'Wheeler', 'Willis', 'brown, sr', 'browne, III', 'browne, IV',\n             'knight', 'mitchell', \"o'daniel\"]\n    for name in names:\n        print('%15s: %s' % (name, nysiis(name)))\n"}
{"id": 383462, "name": "NYSIIS", "source": "Translate Perl to Python: sub no_suffix {\n    my($name) = @_;\n    $name =~ s/\\h([JS]R)|([IVX]+)$//i;\n    return uc $name;\n}\n\nsub nysiis {\n    my($name) = @_;\n    local($_) = uc $name;\n\n    s/[^A-Z]//g;\n    s/^MAC/MCC/;\n    s/^P[FH]/FF/;\n    s/^SCH/SSS/;\n    s/^KN/N/;\n    s/[IE]E$/Y/;\n    s/[DRN]T$/D/;\n    s/[RN]D$/D/;\n    s/(.)EV/$1AF/g;\n    s/(.)[AEIOU]+/$1A/g;\n    s/(.)Q/$1G/g;\n    s/(.)Z/$1S/g;\n    s/(.)M/$1N/g;\n    s/(.)KN/$1N/g;\n    s/(.)K/$1C/g;\n    s/(.)SCH/$1S/g;\n    s/(.)PF/$1F/g;\n    s/(.)K/$1C/g;\n    s/(.)H([^AEIOU])/$1$2/g;\n    s/([^AEIOU])H/$1/g;\n    s/(.)W/$1/g;\n    s/AY$/Y/;\n    s/S$//;\n    s/A$//;\n    s/(.)\\1+/$1/g;\n    return $_;\n}\n\nfor (\n    \"knight\",     \"mitchell\",  \"o'daniel\",    \"brown sr\",   \"browne III\",\n    \"browne IV\",  \"O'Banion\",  \"Mclaughlin\",  \"McCormack\",  \"Chapman\",\n    \"Silva\",      \"McDonald\",  \"Lawson\",      \"Jacobs\",     \"Greene\",\n    \"O'Brien\",    \"Morrison\",  \"Larson\",      \"Willis\",     \"Mackenzie\",\n    \"Carr\",       \"Lawrence\",  \"Matthews\",    \"Richards\",   \"Bishop\",\n    \"Franklin\",   \"McDaniel\",  \"Harper\",      \"Lynch\",      \"Watkins\",\n    \"Carlson\",    \"Wheeler\",   \"Louis XVI\"\n) {\n    my $nysiis = nysiis no_suffix $_;\n    $nysiis =~ s/^(......)(.*)$/$1\\[$2\\]/ if length($nysiis) > 6;\n    printf \"%10s,  %s\\n\", $_, $nysiis;\n}\n", "target": "import re\n\n_vowels = 'AEIOU'\n\ndef replace_at(text, position, fromlist, tolist):\n    for f, t in zip(fromlist, tolist):\n        if text[position:].startswith(f):\n            return ''.join([text[:position],\n                            t,\n                            text[position+len(f):]])\n    return text\n\ndef replace_end(text, fromlist, tolist):\n    for f, t in zip(fromlist, tolist):\n        if text.endswith(f):\n            return text[:-len(f)] + t\n    return text\n\ndef nysiis(name):\n    name = re.sub(r'\\W', '', name).upper()\n    name = replace_at(name, 0, ['MAC', 'KN', 'K', 'PH', 'PF', 'SCH'],\n                               ['MCC', 'N',  'C', 'FF', 'FF', 'SSS'])\n    name = replace_end(name, ['EE', 'IE', 'DT', 'RT', 'RD', 'NT', 'ND'],\n                             ['Y',  'Y',  'D',  'D',  'D',  'D',  'D'])\n    key, key1 = name[0], ''\n    i = 1\n    while i < len(name):\n        \n        n_1, n = name[i-1], name[i]\n        n1_ = name[i+1] if i+1 < len(name) else ''\n        name = replace_at(name, i, ['EV'] + list(_vowels), ['AF'] + ['A']*5)\n        name = replace_at(name, i, 'QZM', 'GSN')\n        name = replace_at(name, i, ['KN', 'K'], ['N', 'C'])\n        name = replace_at(name, i, ['SCH', 'PH'], ['SSS', 'FF'])\n        if n == 'H' and (n_1 not in _vowels or n1_ not in _vowels):\n            name = ''.join([name[:i], n_1, name[i+1:]])\n        if n == 'W' and n_1 in _vowels:\n            name = ''.join([name[:i], 'A', name[i+1:]])\n        if key and key[-1] != name[i]:\n            key += name[i]\n        i += 1\n    key = replace_end(key, ['S', 'AY', 'A'], ['', 'Y', ''])\n    return key1 + key\n\nif __name__ == '__main__':\n    names = ['Bishop', 'Carlson', 'Carr', 'Chapman', 'Franklin',\n             'Greene', 'Harper', 'Jacobs', 'Larson', 'Lawrence',\n             'Lawson', 'Louis, XVI', 'Lynch', 'Mackenzie', 'Matthews',\n             'McCormack', 'McDaniel', 'McDonald', 'Mclaughlin', 'Morrison',\n             \"O'Banion\", \"O'Brien\", 'Richards', 'Silva', 'Watkins',\n             'Wheeler', 'Willis', 'brown, sr', 'browne, III', 'browne, IV',\n             'knight', 'mitchell', \"o'daniel\"]\n    for name in names:\n        print('%15s: %s' % (name, nysiis(name)))\n"}
{"id": 383463, "name": "Faulhaber's formula", "source": "Translate Perl to Python: use 5.014;\nuse Math::Algebra::Symbols;\n\nsub bernoulli_number {\n    my ($n) = @_;\n\n    return 0 if $n > 1 && $n % 2;\n\n    my @A;\n    for my $m (0 .. $n) {\n        $A[$m] = symbols(1) / ($m + 1);\n\n        for (my $j = $m ; $j > 0 ; $j--) {\n            $A[$j - 1] = $j * ($A[$j - 1] - $A[$j]);\n        }\n    }\n\n    return $A[0];\n}\n\nsub binomial {\n    my ($n, $k) = @_;\n    return 1 if $k == 0 || $n == $k;\n    binomial($n - 1, $k - 1) + binomial($n - 1, $k);\n}\n\nsub faulhaber_s_formula {\n    my ($p) = @_;\n\n    my $formula = 0;\n    for my $j (0 .. $p) {\n        $formula += binomial($p + 1, $j)\n                 *  bernoulli_number($j)\n                 *  symbols('n')**($p + 1 - $j);\n    }\n\n    (symbols(1) / ($p + 1) * $formula)\n        =~ s/\\$n/n/gr =~ s/\\*\\*/^/gr =~ s/\\*/ /gr;\n}\n\nforeach my $i (0 .. 9) {\n    say \"$i: \", faulhaber_s_formula($i);\n}\n", "target": "from fractions import Fraction\n\ndef nextu(a):\n    n = len(a)\n    a.append(1)\n    for i in range(n - 1, 0, -1):\n        a[i] = i * a[i] + a[i - 1]\n    return a\n\ndef nextv(a):\n    n = len(a) - 1\n    b = [(1 - n) * x for x in a]\n    b.append(1)\n    for i in range(n):\n        b[i + 1] += a[i]\n    return b\n\ndef sumpol(n):\n    u = [0, 1]\n    v = [[1], [1, 1]]\n    yield [Fraction(0), Fraction(1)]\n    for i in range(1, n):\n        v.append(nextv(v[-1]))\n        t = [0] * (i + 2)\n        p = 1\n        for j, r in enumerate(u):\n            r = Fraction(r, j + 1)\n            for k, s in enumerate(v[j + 1]):\n                t[k] += r * s\n        yield t\n        u = nextu(u)\n\ndef polstr(a):\n    s = \"\"\n    q = False\n    n = len(a) - 1\n    for i, x in enumerate(reversed(a)):\n        i = n - i\n        if i < 2:\n            m = \"n\" if i == 1 else \"\"\n        else:\n            m = \"n^%d\" % i\n        c = str(abs(x))\n        if i > 0:\n            if c == \"1\":\n                c = \"\"\n            else:\n                m = \" \" + m\n        if x != 0:\n            if q:\n                t = \" + \" if x > 0 else \" - \"\n                s += \"%s%s%s\" % (t, c, m)\n            else:\n                t = \"\" if x > 0 else \"-\"\n                s = \"%s%s%s\" % (t, c, m)\n                q = True\n    if q:\n        return s\n    else:\n        return \"0\"\n\nfor i, p in enumerate(sumpol(10)):\n    print(i, \":\", polstr(p))\n"}
{"id": 383464, "name": "Active Directory_Search for a user", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Net::LDAP;\n\nmy $ldap = Net::LDAP->new( 'ldap://ldap.forumsys.com' )  or  die \"$@\";\n\nmy $mesg = $ldap->bind( \"cn=read-only-admin,dc=example,dc=com\",\n                        password => \"password\"                  );\n              \n$mesg->code and die $mesg->error;\n\nmy $srch = $ldap->search( base   => \"dc=example,dc=com\",\n                          filter => \"(|(uid=gauss))\"     );\n\n$srch->code and die $srch->error;\n\nforeach my $entry ($srch->entries) { $entry->dump }\n\n$mesg = $ldap->unbind;\n", "target": "Import-Module ActiveDirectory\n\n$searchData = \"user name\"\n$searchBase = \"DC=example,DC=com\"\n\n\nget-aduser -Filter((DistinguishedName -eq $searchdata) -or (UserPrincipalName -eq $searchdata) -or (SamAccountName -eq $searchdata)) -SearchBase $searchBase\n"}
{"id": 383465, "name": "Prime conspiracy", "source": "Translate Perl to Python: use ntheory qw/forprimes nth_prime/;\n\nmy $upto = 1_000_000;\nmy %freq;\nmy($this_digit,$last_digit)=(2,0);\n\nforprimes {\n  ($last_digit,$this_digit) = ($this_digit, $_ % 10);\n  $freq{$last_digit . $this_digit}++;\n} 3,nth_prime($upto);\n\nprint \"$upto first primes.  Transitions prime\u00a0% 10 \u2192 next-prime\u00a0% 10.\\n\";\nprintf \"%s \u2192 %s count:\\t%7d\\tfrequency: %4.2f\u00a0%%\\n\",\n  substr($_,0,1), substr($_,1,1), $freq{$_}, 100*$freq{$_}/$upto\n    for sort keys %freq;\n", "target": "def isPrime(n):\n    if n < 2:\n        return False\n    if n % 2 == 0:\n        return n == 2\n    if n % 3 == 0:\n        return n == 3\n\n    d = 5\n    while d * d <= n:\n        if n % d == 0:\n            return False\n        d += 2\n\n        if n % d == 0:\n            return False\n        d += 4\n    return True\n\ndef generatePrimes():\n    yield 2\n    yield 3\n\n    p = 5\n    while p > 0:\n        if isPrime(p):\n            yield p\n        p += 2\n        if isPrime(p):\n            yield p\n        p += 4\n\ng = generatePrimes()\ntransMap = {}\nprev = None\nlimit = 1000000\nfor _ in xrange(limit):\n    prime = next(g)\n    if prev:\n        transition = (prev, prime %10)\n        if transition in transMap:\n            transMap[transition] += 1\n        else:\n            transMap[transition] = 1\n    prev = prime % 10\n\nprint \"First {:,} primes. Transitions prime\u00a0% 10 > next-prime\u00a0% 10.\".format(limit)\nfor trans in sorted(transMap):\n    print \"{0} -> {1} count {2:5} frequency: {3}%\".format(trans[0], trans[1], transMap[trans], 100.0 * transMap[trans] / limit)\n"}
{"id": 383466, "name": "List rooted trees", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub bagchain {\n    my($x, $n, $bb, $start) = @_;\n    return [@$x] unless $n;\n\n    my @sets;\n    $start //= 0;\n    for my $i ($start .. @$bb-1) {\n        my($c, $s) = @{$$bb[$i]};\n        push @sets, bagchain([$$x[0] + $c, $$x[1] . $s], $n-$c, $bb, $i) if $c <= $n\n    }\n    @sets\n}\n\nsub bags {\n    my($n) = @_;\n    return [0, ''] unless $n;\n\n    my(@upto,@sets);\n    push @upto, bags($_) for reverse 1 .. $n-1;\n    for ( bagchain([0, ''], $n-1, \\@upto) ) {\n        my($c,$s) = @$_;\n        push @sets, [$c+1, '(' . $s . ')']\n    }\n    @sets;\n}\n\nsub replace_brackets {\n    my $bags;\n    my $depth = 0;\n    for my $b (split //, $_[0]) {\n        if ($b eq '(') { $bags .= (qw<( [ {>)[$depth++ % 3] }\n        else           { $bags .= (qw<) ] }>)[--$depth % 3] }\n    }\n    $bags\n}\n\nsay replace_brackets $$_[1] for bags(5);\n", "target": "def bags(n,cache={}):\n\tif not n: return [(0, \"\")]\n\n\tupto = sum([bags(x) for x in range(n-1, 0, -1)], [])\n\treturn [(c+1, '('+s+')') for c,s in bagchain((0, \"\"), n-1, upto)]\n\ndef bagchain(x, n, bb, start=0):\n\tif not n: return [x]\n\n\tout = []\n\tfor i in range(start, len(bb)):\n\t\tc,s = bb[i]\n\t\tif c <= n: out += bagchain((x[0] + c, x[1] + s), n-c, bb, i)\n\treturn out\n\n\ndef replace_brackets(s):\n\tdepth,out = 0,[]\n\tfor c in s:\n\t\tif c == '(':\n\t\t\tout.append(\"([{\"[depth%3])\n\t\t\tdepth += 1\n\t\telse:\n\t\t\tdepth -= 1\n\t\t\tout.append(\")]}\"[depth%3])\n\treturn \"\".join(out)\n\nfor x in bags(5): print(replace_brackets(x[1]))\n"}
{"id": 383467, "name": "Elementary cellular automaton_Random number generator", "source": "Translate Perl to Python: package Automaton {\n    sub new {\n    my $class = shift;\n    my $rule = [ reverse split //, sprintf \"%08b\", shift ];\n    return bless { rule => $rule, cells => [ @_ ] }, $class;\n    }\n    sub next {\n    my $this = shift;\n    my @previous = @{$this->{cells}};\n    $this->{cells} = [\n        @{$this->{rule}}[\n        map {\n          4*$previous[($_ - 1) % @previous]\n        + 2*$previous[$_]\n        +   $previous[($_ + 1) % @previous]\n        } 0 .. @previous - 1\n        ]\n    ];\n    return $this;\n    }\n    use overload\n    q{\"\"} => sub {\n    my $this = shift;\n    join '', map { $_ ? '\n    };\n}\n\nmy $a = Automaton->new(30, 1, map 0, 1 .. 100);\n\nfor my $n (1 .. 10) {\n    my $sum = 0;\n    for my $b (1 .. 8) {\n\t$sum = $sum * 2 + $a->{cells}[0];\n\t$a->next;\n    }\n    print $sum, $n == 10 ? \"\\n\" : \" \";\n}\n", "target": "from elementary_cellular_automaton import eca, eca_wrap\n\ndef rule30bytes(lencells=100):\n    cells = '1' + '0' * (lencells - 1)\n    gen = eca(cells, 30)\n    while True:\n        yield int(''.join(next(gen)[0] for i in range(8)), 2)\n\nif __name__ == '__main__':\n    print([b for i,b in zip(range(10), rule30bytes())])\n"}
{"id": 383468, "name": "Lucky and even lucky numbers", "source": "Translate Perl to Python: use Perl6::GatherTake;\n\nsub luck {\nmy($a,$b) = @_;\n\ngather {\n    my $i = $b;\n    my(@taken,@rotor,$j);\n\n    take 0; \n    push @taken, take $a;\n\n    while () {\n        for ($j = 0; $j < @rotor; $j++) {\n            --$rotor[$j] or last;\n        }\n        if ($j < @rotor) {\n            $rotor[$j] = $taken[$j+1];\n        }\n        else {\n            take $i;\n            push @taken, $i;\n            push @rotor, $i - @taken;\n        }\n        $i += 2;\n    }\n}\n}\n\n\n$j = shift || usage();\n$k = shift || ',';\n$l = shift || 'lucky';\nusage() unless $k =~ /,|-?\\d+/;\nusage() unless $l =~ /^(even)?lucky$/i;\nsub usage { print \"Args must be:  j [,|k|-k] [lucky|evenlucky]\\n\" and exit }\n\n\nmy $lucky = $l =~ /^l/i ? luck(1,3) : luck(2,4);\n\n\nif ($k eq ',') {\n    print $lucky->[$j]\n} elsif ($k > $j) {\n    print $lucky->[$_] . ' ' for $j..$k\n} elsif ($k < 0) {\n    while () { last if abs($k) < $lucky->[$i++] } \n    print join ' ', grep { $_ >= $j and $_ <= abs($k) } @$lucky\n}\n\nprint \"\\n\"\n", "target": "from __future__ import print_function\n\ndef lgen(even=False, nmax=1000000):\n    start = 2 if even else 1\n    n, lst = 1, list(range(start, nmax + 1, 2))\n    lenlst = len(lst)\n    yield lst[0]\n    while n < lenlst and lst[n] < lenlst:\n        yield lst[n]\n        n, lst = n + 1, [j for i,j in enumerate(lst, 1) if i % lst[n]]\n        lenlst = len(lst)\n    \n    for i in lst[n:]:\n        yield i\n"}
{"id": 383469, "name": "Imaginary base numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse Math::Complex;\nuse List::AllUtils qw(sum mesh);\nuse ntheory qw<todigitstring fromdigits>;\n\nsub zip {\n    my($a,$b) = @_;\n    my($la, $lb) = (length $a, length $b);\n    my $l = '0' x abs $la - $lb;\n    $a .= $l if $la < $lb;\n    $b .= $l if $lb < $la;\n    (join('', mesh(@{[split('',$a),]}, @{[split('',$b),]})) =~ s/0+$//r) or 0;\n}\n\nsub base_i {\n    my($num,$radix,$precision) = @_;\n    die unless $radix > -37 and $radix < -1;\n    return '0' unless $num;\n    my $value  = $num;\n    my $result = '';\n    my $place  = 0;\n    my $upper_bound = 1 / (-$radix + 1);\n    my $lower_bound = $radix * $upper_bound;\n\n    $value = $num / $radix ** ++$place until $lower_bound <= $value and $value < $upper_bound;\n\n    while (($value or $place > 0) and $place > $precision) {\n        my $digit = int $radix * $value - $lower_bound;\n        $value    =  $radix * $value - $digit;\n        $result  .= '.' unless $place or not index($result, '.');\n        $result  .= $digit == -$radix ? todigitstring($digit-1, -$radix) . '0' : (todigitstring($digit, -$radix) or '0');\n        $place--;\n    }\n    $result\n}\n\nsub base_c {\n    my($num, $radix, $precision) = @_;\n    die \"Base $radix out of range\" unless\n        (-6 <= $radix->Im or $radix->Im <= -2) or (2 <= $radix->Im or $radix->Im <= 6);\n    my ($re,$im);\n    defined $num->Im ? ($re, $im) = ($num->Re, $num->Im) : $re = $num;\n    my ($re_wh, $re_fr) = split /\\./, base_i(  $re,               -1 * int($radix->Im**2), $precision);\n    my ($im_wh, $im_fr) = split /\\./, base_i( ($im/($radix->Im)), -1 * int($radix->Im**2), $precision);\n    $_ //= '' for $re_fr, $im_fr;\n\n    my $whole = reverse zip scalar reverse($re_wh), scalar reverse($im_wh);\n    my $fraction = zip $im_fr, $re_fr;\n    $fraction eq 0 ? \"$whole\" : \"$whole.$fraction\"\n}\n\nsub parse_base {\n    my($str, $radix) = @_;\n    return -1 * parse_base( substr($str,1), $radix) if substr($str,0,1) eq '-';\n    my($whole, $frac) = split /\\./, $str;\n    my $fraction = 0;\n    my $k = 0;\n    $fraction = sum map { (fromdigits($_, int $radix->Im**2) || 0) * $radix ** -($k++ +1) } split '', $frac\n        if $frac;\n    $k = 0;\n    $fraction + sum map { (fromdigits($_, int $radix->Im**2) || 0) * $radix ** $k++  } reverse split '', $whole;\n}\n\nfor (\n    [  0*i,  2*i], [1+0*i,  2*i], [5+0*i,      2*i], [ -13+0*i, 2*i],\n    [  9*i,  2*i], [ -3*i,  2*i], [7.75-7.5*i, 2*i], [0.25+0*i, 2*i],\n    [5+5*i,  2*i], [5+5*i,  3*i], [5+5*i,  4*i], [5+5*i,  5*i], [5+5*i,  6*i],\n    [5+5*i, -2*i], [5+5*i, -3*i], [5+5*i, -4*i], [5+5*i, -5*i], [5+5*i, -6*i]\n) {\n    my($v,$r) = @$_;\n    my $ibase = base_c($v, $r, -6);\n    my $rt = cplx parse_base($ibase, $r);\n    $rt->display_format('format' => '%.2f');\n    printf \"base(%3s): %10s  => %9s  => %13s\\n\", $r, $v, $ibase, $rt;\n}\n\nsay '';\nsay 'base( 6i): 31432.6219135802-2898.5266203704*i => ' .\n         base_c(31432.6219135802-2898.5266203704*i, 0+6*i, -3);\n", "target": "import math\nimport re\n\ndef inv(c):\n    denom = c.real * c.real + c.imag * c.imag\n    return complex(c.real / denom, -c.imag / denom)\n\nclass QuaterImaginary:\n    twoI = complex(0, 2)\n    invTwoI = inv(twoI)\n\n    def __init__(self, str):\n        if not re.match(\"^[0123.]+$\", str) or str.count('.') > 1:\n            raise Exception('Invalid base 2i number')\n        self.b2i = str\n\n    def toComplex(self):\n        pointPos = self.b2i.find('.')\n        posLen = len(self.b2i) if (pointPos < 0) else pointPos\n        sum = complex(0, 0)\n        prod = complex(1, 0)\n        for j in xrange(0, posLen):\n            k = int(self.b2i[posLen - 1 - j])\n            if k > 0:\n                sum += prod * k\n            prod *= QuaterImaginary.twoI\n        if pointPos != -1:\n            prod = QuaterImaginary.invTwoI\n            for j in xrange(posLen + 1, len(self.b2i)):\n                k = int(self.b2i[j])\n                if k > 0:\n                    sum += prod * k\n                prod *= QuaterImaginary.invTwoI\n        return sum\n\n    def __str__(self):\n        return str(self.b2i)\n\ndef toQuaterImaginary(c):\n    if c.real == 0.0 and c.imag == 0.0:\n        return QuaterImaginary(\"0\")\n\n    re = int(c.real)\n    im = int(c.imag)\n    fi = -1\n    ss = \"\"\n    while re != 0:\n        re, rem = divmod(re, -4)\n        if rem < 0:\n            rem += 4\n            re += 1\n        ss += str(rem) + '0'\n    if im != 0:\n        f = c.imag / 2\n        im = int(math.ceil(f))\n        f = -4 * (f - im)\n        index = 1\n        while im != 0:\n            im, rem = divmod(im, -4)\n            if rem < 0:\n                rem += 4\n                im += 1\n            if index < len(ss):\n                ss[index] = str(rem)\n            else:\n                ss += '0' + str(rem)\n            index = index + 2\n        fi = int(f)\n    ss = ss[::-1]\n    if fi != -1:\n        ss += '.' + str(fi)\n    ss = ss.lstrip('0')\n    if ss[0] == '.':\n        ss = '0' + ss\n    return QuaterImaginary(ss)\n\nfor i in xrange(1,17):\n    c1 = complex(i, 0)\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}     \".format(c1, qi, c2),\n\n    c1 = -c1\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}\".format(c1, qi, c2)\nprint\n\nfor i in xrange(1,17):\n    c1 = complex(0, i)\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}     \".format(c1, qi, c2),\n\n    c1 = -c1\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}\".format(c1, qi, c2)\n\nprint \"done\"\n"}
{"id": 383470, "name": "Statistics_Normal distribution", "source": "Translate Perl to Python: use constant pi => 3.14159265;\nuse List::Util qw(sum reduce min max);\n\nsub normdist {\n    my($m, $sigma) = @_;\n    my $r = sqrt -2 * log rand;\n    my $theta = 2 * pi * rand;\n    $r * cos($theta) * $sigma + $m;\n}\n\n$size = 100000; $mean = 50; $stddev = 4;\n\npush @dataset, normdist($mean,$stddev) for 1..$size;\n\nmy $m = sum(@dataset) / $size;\nprint \"m = $m\\n\";\n\nmy $sigma = sqrt( (reduce { $a + $b **2 } 0,@dataset) / $size - $m**2 );\nprint \"sigma = $sigma\\n\";\n\n    $hash{int $_}++ for @dataset;\n    my $scale = 180 * $stddev / $size;\n    my @subbar = < \u23b8 \u258f \u258e \u258d \u258c \u258b \u258a \u2589 \u2588 >;\n    for $i (min(@dataset)..max(@dataset)) {\n        my $x = ($hash{$i} // 0) * $scale;\n        my $full = int $x;\n        my $part = 8 * ($x - $full);\n        my $t1 = '\u2588' x $full;\n        my $t2 = $subbar[$part];\n        print \"$i\\t$t1$t2\\n\";\n    }\n", "target": "from __future__ import division\nimport matplotlib.pyplot as plt \nimport random\n\nmean, stddev, size = 50, 4, 100000\ndata = [random.gauss(mean, stddev) for c in range(size)]\n\nmn = sum(data) / size\nsd = (sum(x*x for x in data) / size \n      - (sum(data) / size) ** 2) ** 0.5\n\nprint(\"Sample mean = %g; Stddev = %g; max = %g; min = %g for %i values\" \n      % (mn, sd, max(data), min(data), size))\n\nplt.hist(data,bins=50)\n"}
{"id": 383471, "name": "Vogel's approximation method", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( max_by nsort_by min );\n\nmy $data = <<END;\nA=30 B=20 C=70 D=30 E=60\nW=50 X=60 Y=50 Z=50\nAW=16 BW=16 CW=13 DW=22 EW=17\nAX=14 BX=14 CX=13 DX=19 EX=15\nAY=19 BY=19 CY=20 DY=23 EY=50\nAZ=50 BZ=12 CZ=50 DZ=15 EZ=11\nEND\nmy $table = sprintf +('%4s' x 6 . \"\\n\") x 5,\n  map {my $t = $_; map \"$_$t\", '', 'A' .. 'E' } '' , 'W' .. 'Z';\n\nmy ($cost, %assign) = (0);\nwhile( $data =~ /\\b\\w=\\d/ )\n  {\n  my @penalty;\n  for ( $data =~ /\\b(\\w)=\\d/g )\n    {\n    my @all = map /(\\d+)/, nsort_by { /\\d+/ && $& }\n      grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n      $data =~ /$_\\w=\\d+|\\w$_=\\d+/g;\n    push @penalty, [ $_, ($all[1] // 0) - $all[0] ];\n    }\n  my $rc = (max_by { $_->[1] } nsort_by\n    { my $x = $_->[0]; $data =~ /(?:$x\\w|\\w$x)=(\\d+)/ && $1 } @penalty)->[0];\n  my @lowest = nsort_by { /\\d+/ && $& }\n    grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n    $data =~ /$rc\\w=\\d+|\\w$rc=\\d+/g;\n  my ($t, $c) = $lowest[0] =~ /(.)(.)/;\n  my $allocate = min $data =~ /\\b[$t$c]=(\\d+)/g;\n  $table =~ s/$t$c/ sprintf \"%2d\", $allocate/e;\n  $cost += $data =~ /$t$c=(\\d+)/ && $1 * $allocate;\n  $data =~ s/\\b$_=\\K\\d+/ $& - $allocate || '' /e for $t, $c;\n  }\nprint \"cost $cost\\n\\n\", $table =~ s/[A-Z]{2}/--/gr;\n", "target": "from collections import defaultdict\n\ncosts  = {'W': {'A': 16, 'B': 16, 'C': 13, 'D': 22, 'E': 17},\n          'X': {'A': 14, 'B': 14, 'C': 13, 'D': 19, 'E': 15},\n          'Y': {'A': 19, 'B': 19, 'C': 20, 'D': 23, 'E': 50},\n          'Z': {'A': 50, 'B': 12, 'C': 50, 'D': 15, 'E': 11}}\ndemand = {'A': 30, 'B': 20, 'C': 70, 'D': 30, 'E': 60}\ncols = sorted(demand.iterkeys())\nsupply = {'W': 50, 'X': 60, 'Y': 50, 'Z': 50}\nres = dict((k, defaultdict(int)) for k in costs)\ng = {}\nfor x in supply:\n    g[x] = sorted(costs[x].iterkeys(), key=lambda g: costs[x][g])\nfor x in demand:\n    g[x] = sorted(costs.iterkeys(), key=lambda g: costs[g][x])\n\nwhile g:\n    d = {}\n    for x in demand:\n        d[x] = (costs[g[x][1]][x] - costs[g[x][0]][x]) if len(g[x]) > 1 else costs[g[x][0]][x]\n    s = {}\n    for x in supply:\n        s[x] = (costs[x][g[x][1]] - costs[x][g[x][0]]) if len(g[x]) > 1 else costs[x][g[x][0]]\n    f = max(d, key=lambda n: d[n])\n    t = max(s, key=lambda n: s[n])\n    t, f = (f, g[f][0]) if d[f] > s[t] else (g[t][0], t)\n    v = min(supply[f], demand[t])\n    res[f][t] += v\n    demand[t] -= v\n    if demand[t] == 0:\n        for k, n in supply.iteritems():\n            if n != 0:\n                g[k].remove(t)\n        del g[t]\n        del demand[t]\n    supply[f] -= v\n    if supply[f] == 0:\n        for k, n in demand.iteritems():\n            if n != 0:\n                g[k].remove(f)\n        del g[f]\n        del supply[f]\n\nfor n in cols:\n    print \"\\t\", n,\nprint\ncost = 0\nfor g in sorted(costs):\n    print g, \"\\t\",\n    for n in cols:\n        y = res[g][n]\n        if y != 0:\n            print y,\n        cost += y * costs[g][n]\n        print \"\\t\",\n    print\nprint \"\\n\\nTotal Cost = \", cost\n"}
{"id": 383472, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::AnyNum qw(:overload as_bin digits2num);\n\nfor my $x (1..10, 95..105, 297, 576, 594, 891, 909, 999) {\n    my $y;\n    if ($x =~ /^9+$/) { $y = digits2num([(1) x (9 * length $x)],2)  } \n    else              { while (1) { last unless as_bin(++$y) % $x } }\n    printf \"%4d: %28s  %s\\n\", $x, as_bin($y), as_bin($y)/$x;\n}\n", "target": "def getA004290(n):\n    if n < 2:\n        return 1\n    arr = [[0 for _ in range(n)] for _ in range(n)]\n    arr[0][0] = 1\n    arr[0][1] = 1\n    m = 0\n    while True:\n        m += 1\n        if arr[m - 1][-10 ** m % n] == 1:\n            break\n        arr[m][0] = 1\n        for k in range(1, n):\n            arr[m][k] = max([arr[m - 1][k], arr[m - 1][k - 10 ** m % n]])\n    r = 10 ** m\n    k = -r % n\n    for j in range((m - 1), 0, -1):\n        if arr[j - 1][k] == 0:\n            r = r + 10 ** j\n            k = (k - 10 ** j) % n   \n    if k == 1:\n        r += 1\n    return r\n \nfor n in [i for i in range(1, 11)] + \\\n          [i for i in range(95, 106)] + \\\n          [297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878]:\n    result = getA004290(n)\n    print(f\"A004290({n}) = {result} = {n} * {result // n})\")\n"}
{"id": 383473, "name": "Weird numbers", "source": "Translate Perl to Python: use strict;\nuse feature 'say';\n\nuse List::Util 'sum';\nuse POSIX 'floor';\nuse Algorithm::Combinatorics 'subsets';\nuse ntheory <is_prime divisors>;\n\nsub abundant {\n    my($x) = @_;\n    my $s = sum( my @l = is_prime($x) ? 1 : grep { $x != $_ } divisors($x) );\n    $s > $x ? ($s, sort { $b <=> $a } @l) : ();\n}\n\nmy(@weird,$n);\nwhile () {\n    $n++;\n    my ($sum, @div) = abundant($n);\n    next unless $sum;        \n    next if $sum / $n > 1.1; \n\n    if ($n >= 10430 and (! int $n%70) and is_prime(int $n/70)) {\n        \n    } else {\n        my $next;\n        my $l = shift @div;\n        my $iter = subsets(\\@div);\n        while (my $s = $iter->next) {\n            ++$next and last if sum(@$s) == $n - $l;\n        }\n        next if $next;\n    }\n    push @weird, $n;\n    last if @weird == 25;\n}\n\nsay \"The first 25 weird numbers:\\n\" . join ' ', @weird;\n", "target": "\n\nfrom itertools import chain, count, islice, repeat\nfrom functools import reduce\nfrom math import sqrt\nfrom time import time\n\n\n\ndef weirds():\n    \n    def go(n):\n        ds = descPropDivs(n)\n        d = sum(ds) - n\n        return [n] if 0 < d and not hasSum(d, ds) else []\n    return concatMap(go)(count(1))\n\n\n\ndef hasSum(n, xs):\n    \n    def go(n, xs):\n        if xs:\n            h, t = xs[0], xs[1:]\n            if n < h:  \n                return go(n, t)\n            else:\n                \n                \n                \n                \n                return n == h or go(n - h, t) or go(n, t)\n        else:\n            return False\n    return go(n, xs)\n\n\n\ndef descPropDivs(n):\n    \n    root = sqrt(n)\n    intRoot = int(root)\n    blnSqr = root == intRoot\n    lows = [x for x in range(1, 1 + intRoot) if 0 == n % x]\n    return [\n        n // x for x in (\n            lows[1:-1] if blnSqr else lows[1:]\n        )\n    ] + list(reversed(lows))\n\n\n\n\n\ndef main():\n    \n\n    start = time()\n    n = 50\n    xs = take(n)(weirds())\n\n    print(\n        (tabulated('First ' + str(n) + ' weird numbers:\\n')(\n            lambda i: str(1 + i)\n        )(str)(5)(\n            index(xs)\n        )(range(0, n)))\n    )\n    print(\n        '\\nApprox computation time: ' +\n        str(int(1000 * (time() - start))) + ' ms'\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n\ndef compose(g):\n    \n    return lambda f: lambda x: g(f(x))\n\n\n\ndef concatMap(f):\n    \n    return lambda xs: chain.from_iterable(map(f, xs))\n\n\n\ndef index(xs):\n    \n    return lambda n: None if 0 > n else (\n        xs[n] if (\n            hasattr(xs, \"__getitem__\")\n        ) else next(islice(xs, n, None))\n    )\n\n\n\ndef paddedMatrix(v):\n    \n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n\ndef paddedRows(n):\n    \n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n\ndef showColumns(n):\n    \n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col))\n\n        q, r = divmod(len(xs), n)\n        return unlines(map(\n            fit,\n            transpose(paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(\n                    xs\n                )\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\n\n\n\n\ndef tabulated(s):\n    \n    def go(xShow, fxShow, intCols, f, xs):\n        w = max(map(compose(len)(xShow), xs))\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + fxShow(f(x)) for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, list)\n        else list(islice(xs, n))\n    )\n\n\n\ndef transpose(m):\n    \n    if m:\n        inner = type(m[0])\n        z = zip(*m)\n        return (type(m))(\n            map(inner, z) if tuple != inner else z\n        )\n    else:\n        return m\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\ndef until(p):\n    \n    def go(f, x):\n        v = x\n        while not p(v):\n            v = f(v)\n        return v\n    return lambda f: lambda x: go(f, x)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383474, "name": "ASCII art diagram converter", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\nEND\n\nmy $template;\nmy @names;\nwhile( /\\| *(\\w+) */g )\n  {\n  printf \"%10s is %2d bits\\n\", $1, my $length = length($&) / 3;\n  push @names, $1;\n  $template .= \"A$length \";\n  }\n\nmy $input = '78477bbf5496e12e1bf169a4'; \n\nmy %datastructure;\n@datastructure{ @names } = unpack $template, unpack 'B*', pack 'H*', $input;\n\nprint \"\\ntemplate = $template\\n\\n\";\nuse Data::Dump 'dd'; dd 'datastructure', \\%datastructure;\n", "target": "\n\ndef validate(diagram):\n\n    \n    \n    rawlines = diagram.splitlines()\n    lines = []\n    for line in rawlines:\n        if line != '':\n            lines.append(line)\n            \n    \n            \n    if len(lines) == 0:\n        print('diagram has no non-empty lines!')\n        return None\n        \n    width = len(lines[0])\n    cols = (width - 1) // 3\n    \n    if cols not in [8, 16, 32, 64]: \n        print('number of columns should be 8, 16, 32 or 64')\n        return None\n        \n    if len(lines)%2 == 0:\n        print('number of non-empty lines should be odd')\n        return None\n    \n    if lines[0] != (('+--' * cols)+'+'):\n            print('incorrect header line')\n            return None\n\n    for i in range(len(lines)):\n        line=lines[i]\n        if i == 0:\n            continue\n        elif i%2 == 0:\n            if line != lines[0]:\n                print('incorrect separator line')\n                return None\n        elif len(line) != width:\n            print('inconsistent line widths')\n            return None\n        elif line[0] != '|' or line[width-1] != '|':\n            print(\"non-separator lines must begin and end with '|'\")    \n            return None\n    \n    return lines\n\n\n\ndef decode(lines):\n    print(\"Name     Bits  Start  End\")\n    print(\"=======  ====  =====  ===\")\n    \n    startbit = 0\n    \n    results = []\n    \n    for line in lines:\n        infield=False\n        for c in line:\n            if not infield and c == '|':\n                infield = True\n                spaces = 0\n                name = ''\n            elif infield:\n                if c == ' ':\n                    spaces += 1\n                elif c != '|':\n                    name += c\n                else:\n                    bits = (spaces + len(name) + 1) // 3\n                    endbit = startbit + bits - 1\n                    print('{0:7}    {1:2d}     {2:2d}   {3:2d}'.format(name, bits, startbit, endbit))\n                    reslist = [name, bits, startbit, endbit]\n                    results.append(reslist)\n                    spaces = 0\n                    name = ''\n                    startbit += bits\n                    \n    return results\n                        \ndef unpack(results, hex):\n    print(\"\\nTest string in hex:\")\n    print(hex)\n    print(\"\\nTest string in binary:\")\n    bin = f'{int(hex, 16):0>{4*len(hex)}b}'\n    print(bin)\n    print(\"\\nUnpacked:\\n\")\n    print(\"Name     Size  Bit pattern\")\n    print(\"=======  ====  ================\")\n    for r in results:\n        name = r[0]\n        size = r[1]\n        startbit = r[2]\n        endbit = r[3]\n        bitpattern = bin[startbit:endbit+1]\n        print('{0:7}    {1:2d}  {2:16}'.format(name, size, bitpattern))\n\n\ndiagram = \n\nlines = validate(diagram)\n\nif lines == None:\n    print(\"No lines returned\")\nelse:\n    print(\" \")\n    print(\"Diagram after trimming whitespace and removal of blank lines:\")\n    print(\" \")\n    for line in lines:\n        print(line)\n        \n    print(\" \")\n    print(\"Decoded:\")\n    print(\" \")\n\n    results = decode(lines)    \n    \n    \n    \n    hex = \"78477bbf5496e12e1bf169a4\" \n    \n    unpack(results, hex)\n"}
{"id": 383475, "name": "Peaceful chess queen armies", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $m = shift // 4;\nmy $n = shift // 5;\nmy %seen;\nmy $gaps = join '|', qr/-*/, map qr/.{$_}(?:-.{$_})*/s, $n-1, $n, $n+1;\nmy $attack = qr/(\\w)(?:$gaps)(?!\\1)\\w/;\n\nplace( scalar ('-' x $n . \"\\n\") x $n );\nprint \"No solution to $m $n\\n\";\n\nsub place\n  {\n  local $_ = shift;\n  $seen{$_}++ || /$attack/ and return; \n  (my $have = tr/WB//) < $m * 2 or exit !print \"Solution to $m $n\\n\\n$_\";\n  place( s/-\\G/ qw(W B)[$have\u00a0% 2] /er ) while /-/g; \n  }\n", "target": "from itertools import combinations, product, count\nfrom functools import lru_cache, reduce\n\n\n_bbullet, _wbullet = '\\u2022\\u25E6'\n_or = set.__or__\n\ndef place(m, n):\n    \"Place m black and white queens, peacefully, on an n-by-n board\"\n    board = set(product(range(n), repeat=2))  \n    placements = {frozenset(c) for c in combinations(board, m)}\n    for blacks in placements:\n        black_attacks = reduce(_or, \n                               (queen_attacks_from(pos, n) for pos in blacks), \n                               set())\n        for whites in {frozenset(c)     \n                       for c in combinations(board - black_attacks, m)}:\n            if not black_attacks & whites:\n                return blacks, whites\n    return set(), set()\n\n@lru_cache(maxsize=None)\ndef queen_attacks_from(pos, n):\n    x0, y0 = pos\n    a = set([pos])    \n    a.update((x, y0) for x in range(n))    \n    a.update((x0, y) for y in range(n))    \n    \n    for x1 in range(n):\n        \n        y1 = y0 -x0 +x1\n        if 0 <= y1 < n: \n            a.add((x1, y1))\n        \n        y1 = y0 +x0 -x1\n        if 0 <= y1 < n: \n            a.add((x1, y1))\n    return a\n\ndef pboard(black_white, n):\n    \"Print board\"\n    if black_white is None: \n        blk, wht = set(), set()\n    else:\n        blk, wht = black_white\n    print(f\"\n          f\"on a {n}-by-{n} board:\", end='')\n    for x, y in product(range(n), repeat=2):\n        if y == 0:\n            print()\n        xy = (x, y)\n        ch = ('?' if xy in blk and xy in wht \n              else 'B' if xy in blk\n              else 'W' if xy in wht\n              else _bbullet if (x + y)%2 else _wbullet)\n        print('%s' % ch, end='')\n    print()\n\nif __name__ == '__main__':\n    n=2\n    for n in range(2, 7):\n        print()\n        for m in count(1):\n            ans = place(m, n)\n            if ans[0]:\n                pboard(ans, n)\n            else:\n                print (f\"\n                break\n    \n    print('\\n')\n    m, n = 5, 7\n    ans = place(m, n)\n    pboard(ans, n)\n"}
{"id": 383476, "name": "Sequence_ nth number with exactly n divisors", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse bigint;\nuse ntheory <nth_prime is_prime divisors>;\n\nmy $limit = 20;\n\nprint \"First $limit terms of OEIS:A073916\\n\";\n\nfor my $n (1..$limit) {\n    if ($n > 4 and is_prime($n)) {\n        print nth_prime($n)**($n-1) . ' ';\n    } else {\n        my $i = my $x = 0;\n        while (1) {\n            my $nn = $n%2 ? ++$x**2 : ++$x;\n            next unless $n == divisors($nn) and ++$i == $n;\n            print \"$nn \" and last;\n      }\n    }\n}\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef is_prime(n):\n    return len(divisors(n)) == 2\n\n\ndef primes():\n    ii = 1\n    while True:\n        ii += 1\n        if is_prime(ii):\n            yield ii\n\n\ndef prime(n):\n    generator = primes()\n    for ii in range(n - 1):\n        generator.__next__()\n    return generator.__next__()\n\n\ndef n_divisors(n):\n    ii = 0\n    while True:\n        ii += 1\n        if len(divisors(ii)) == n:\n            yield ii\n\n\ndef sequence(max_n=None):\n    if max_n is not None:\n        for ii in range(1, max_n + 1):\n            if is_prime(ii):\n                yield prime(ii) ** (ii - 1)\n            else:\n                generator = n_divisors(ii)\n                for jj, out in zip(range(ii - 1), generator):\n                    pass\n                yield generator.__next__()\n    else:\n        ii = 1\n        while True:\n            ii += 1\n            if is_prime(ii):\n                yield prime(ii) ** (ii - 1)\n            else:\n                generator = n_divisors(ii)\n                for jj, out in zip(range(ii - 1), generator):\n                    pass\n                yield generator.__next__()\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 383477, "name": "Readline interface", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Term::ReadLine;\nuse POSIX;\n\nmy $term = Term::ReadLine->new( 'simple Perl shell' );\nmy $attribs = $term->Attribs;\n$attribs->{completion_append_character}     = ' ';\n$attribs->{attempted_completion_function}   = \\&attempt_perl_completion;\n$attribs->{completion_display_matches_hook} = \\&perl_symbol_display_match_list;\n\nwhile (defined(my $command = &reader)) {\n    my @result = eval (\"package main; $command\");\n    print \"$_\\n\" for @result;\n}\n\nsub reader {\n    my $command = $term->readline('> ');\n    $term->addhistory($command) if $command;\n    $command;\n}\n\nsub perl_symbol_display_match_list {\n    my($matches, $num_matches, $max_length) = @_;\n    map { $_ =~ s/^((\\$\n    $term->display_match_list($matches);\n    $term->forced_update_display;\n}\n\nsub attempt_perl_completion {\n    my ($text, $line, $start, $end) = @_;\n    $term->completion_matches($text, \\&perl_symbol_completion_function);\n}\n\nuse vars qw($i @matches $prefix);\nsub perl_symbol_completion_function {\n    my($text, $state) = @_;\n    my %type = ('$' => 'SCALAR', '*' => 'SCALAR', '@' => 'ARRAY', '$\n\n    if ($state) {\n        $i++;\n    } else {\n        my ($pre, $pkg, $sym);\n        $i = 0;\n\n        no strict qw(refs);\n        ($prefix, $pre, $pkg) = ($text =~ m/^((\\$\n        @matches = grep /::$/, $pkg ? keys %$pkg : keys %::;\n        $pkg = '::' unless $pkg;\n        @matches = (@matches, grep (/^\\w+$/ && ($sym = $pkg . $_, defined *$sym{$type{$pre}}), keys %$pkg));\n    }\n    my $entry;\n    for (; $i <= $\n        $entry = $prefix . $matches[$i];\n        return $entry if ($entry =~ /^\\Q$text/);\n    }\n    undef;\n}\n", "target": "\n\n\n\n\n\n\nimport readline\n\nwhile True:\n    try:\n        print(input('> '))\n    except:\n        break\n"}
{"id": 383478, "name": "Just in time processing on a character stream", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse ntheory qw/fromdigits todigitstring/;\n\nmy $key = 'perl5';\nsrand fromdigits($key,36) % 2**63;\n\nmy @stream;\n\nsub stream {\n    my($i) = shift;\n    state @chars;\n    push @chars, chr($_) for 14..127;\n    $stream[$i] = $chars[rand 1+127-14] unless $stream[$i];\n}\n\nsub jit_encode {\n    my($str) = shift;\n    my $i = 0;\n    my $last = 0;\n    my $enc = '';\n    for my $c (split '', $str) {\n        my $h;\n        my $l = '';\n        ++$i until $c eq stream($i);\n        my $o = $i - $last;\n        $l    = $o % 26;\n        $h    = $o - $l if $o > 26;\n        $l   += 10;\n        $enc .= ($h ? uc todigitstring($h,36) : '') . lc todigitstring($l,36);\n        $last = $i;\n    }\n    $enc\n}\n\nsub jit_decode {\n    my($str) = shift;\n    my @matches = $str =~ /((.*?) ([a-z]))/gx;\n    my $dec = '';\n    my $i = 0;\n    for my $j (0 .. @matches/3 - 1) {\n        my $o = ( fromdigits($matches[3*$j+1],36) - 10 // 0) +\n                ( fromdigits($matches[3*$j+2],36)      // 0);\n        $i   += $o;\n        $dec .= $stream[$i];\n    }\n    $dec\n}\n\nmy $enc = jit_encode('The slithey toves did gyre and gimble in the wabe');\nsay my $result = \"Encoded\\n$enc\\n\\nDecoded\\n\" . jit_decode($enc);\n", "target": "import sys\n\nclass UserInput:\n    def __init__(self,chunk):\n        self.formFeed = int(chunk[0])\n        self.lineFeed = int(chunk[1])\n        self.tab = int(chunk[2])\n        self.space = int(chunk[3])\n\n    def __str__(self):\n        return \"(ff=%d; lf=%d; tb=%d; sp%d)\" % (self.formFeed,self.lineFeed,self.tab,self.space)\n\ndef chunks(l,n):\n    for i in xrange(0, len(l), n):\n        yield l[i:i+n]\n\ndef getUserInput():\n    h = \"0 18 0 0 0 68 0 1 0 100 0 32 0 114 0 45 0 38 0 26 0 16 0 21 0 17 0 59 0 11 \"\\\n        \"0 29 0 102 0 0 0 10 0 50 0 39 0 42 0 33 0 50 0 46 0 54 0 76 0 47 0 84 2 28\"\n    ha = h.split()\n    return [UserInput(chunk) for chunk in chunks(ha, 4)]\n\ndef decode(filename,uiList):\n    f = open(filename, \"r\")\n    text = f.read()\n\n    def decode2(ui):\n        f = 0\n        l = 0\n        t = 0\n        s = 0\n        for c in text:\n            if f == ui.formFeed and l == ui.lineFeed and t == ui.tab and s == ui.space:\n                if c == '!':\n                    return False\n                sys.stdout.write(c)\n                return True\n            if c == '\\u000c':\n                f=f+1\n                l=0\n                t=0\n                s=0\n            elif c == '\\n':\n                l=l+1\n                t=0\n                s=0\n            elif c == '\\t':\n                t=t+1\n                s=0\n            else:\n                s=s+1\n        return False\n\n    for ui in uiList:\n        if not decode2(ui):\n            break\n    print\n\n\n\nuiList = getUserInput()\ndecode(\"theRaven.txt\", uiList)\n"}
{"id": 383479, "name": "Print debugging statement", "source": "Translate Perl to Python: use Carp;\n\n$str = 'Resistance'; carp \"'$str' is futile.\"; print \"\\n\";\n\ndoodle($str); print \"\\n\";\n\nfiddle(7);\n\nsub doodle { my ($str) = @_; carp \"'$str' is still futile.\" }\n\nsub fiddle { faddle(2*shift) }\nsub faddle { fuddle(3*shift) }\nsub fuddle { ( carp(\"'$_[0]', interesting number.\") ); }\n", "target": "import logging, logging.handlers\n\nLOG_FILENAME = \"logdemo.log\"\nFORMAT_STRING = \"%(levelname)s:%(asctime)s:%(name)s:%(funcName)s:line-%(lineno)d: %(message)s\"\nLOGLEVEL = logging.DEBUG\n\n\ndef print_squares(number):\n    logger.info(\"In print_squares\")\n    for i in range(number):\n        print(\"square of {0} is {1}\".format(i , i*i))\n        logger.debug(f'square of {i} is {i*i}')\n\ndef print_cubes(number):\n    logger.info(\"In print_cubes\")\n    for j in range(number):\n        print(\"cube of {0} is {1}\".format(j, j*j*j))\n        logger.debug(f'cube of {j} is {j*j*j}')\n\nif __name__ == \"__main__\":\n\n    logger = logging.getLogger(\"logdemo\")\n    logger.setLevel(LOGLEVEL)\n    handler = logging.FileHandler(LOG_FILENAME)\n    handler.setFormatter(logging.Formatter(FORMAT_STRING))\n    logger.addHandler(handler)\n\n    print_squares(10)\n    print_cubes(10)\n\n    logger.info(\"All done\")\n"}
{"id": 383480, "name": "Montgomery reduction", "source": "Translate Perl to Python: use bigint;\nuse ntheory qw(powmod);\n\nsub msb {\n  my ($n, $base) = (shift, 0);\n  $base++ while $n >>= 1;\n  $base;\n}\n\nsub montgomery_reduce {\n    my($m, $a) = @_;\n    for (0 .. msb($m)) {\n        $a += $m if $a & 1;\n        $a >>= 1\n    }\n    $a % $m\n}\n\nmy $m  = 750791094644726559640638407699;\nmy $t1 = 323165824550862327179367294465482435542970161392400401329100;\n\nmy $r1 = 440160025148131680164261562101;\nmy $r2 = 435362628198191204145287283255;\n\nmy $x1 = 540019781128412936473322405310;\nmy $x2 = 515692107665463680305819378593;\n\nprintf \"Original x1:       %s\\n\", $x1;\nprintf \"Recovered from r1: %s\\n\", montgomery_reduce($m, $r1);\nprintf \"Original x2:       %s\\n\", $x2;\nprintf \"Recovered from r2: %s\\n\", montgomery_reduce($m, $r2);\n\nprint \"\\nMontgomery  computation x1**x2 mod m: \";\nmy $prod = montgomery_reduce($m, $t1/$x1);\nmy $base = montgomery_reduce($m, $t1);\n\nfor (my $exponent = $x2; $exponent >= 0; $exponent >>= 1) {\n    $prod = montgomery_reduce($m, $prod * $base) if $exponent & 1;\n    $base = montgomery_reduce($m, $base * $base);\n    last if $exponent == 0;\n}\n\nprint montgomery_reduce($m, $prod) . \"\\n\";\nprintf \"Built-in op computation x1**x2 mod m: %s\\n\", powmod($x1, $x2, $m);\n", "target": "class Montgomery:\n    BASE = 2\n\n    def __init__(self, m):\n        self.m = m\n        self.n = m.bit_length()\n        self.rrm = (1 << (self.n * 2)) % m\n\n    def reduce(self, t):\n        a = t\n        for i in xrange(self.n):\n            if (a & 1) == 1:\n                a = a + self.m\n            a = a >> 1\n        if a >= self.m:\n            a = a - self.m\n        return a\n\n\nm = 750791094644726559640638407699\nx1 = 540019781128412936473322405310\nx2 = 515692107665463680305819378593\n\nmont = Montgomery(m)\nt1 = x1 * mont.rrm\nt2 = x2 * mont.rrm\n\nr1 = mont.reduce(t1)\nr2 = mont.reduce(t2)\nr = 1 << mont.n\n\nprint \"b\u00a0: \", Montgomery.BASE\nprint \"n\u00a0: \", mont.n\nprint \"r\u00a0: \", r\nprint \"m\u00a0: \", mont.m\nprint \"t1: \", t1\nprint \"t2: \", t2\nprint \"r1: \", r1\nprint \"r2: \", r2\nprint\nprint \"Original x1      \u00a0:\", x1\nprint \"Recovered from r1\u00a0:\", mont.reduce(r1)\nprint \"Original x2      \u00a0:\", x2\nprint \"Recovered from r2\u00a0:\", mont.reduce(r2)\n\nprint \"\\nMontgomery computation of x1 ^ x2 mod m:\"\nprod = mont.reduce(mont.rrm)\nbase = mont.reduce(x1 * mont.rrm)\nexp = x2\nwhile exp.bit_length() > 0:\n    if (exp & 1) == 1:\n        prod = mont.reduce(prod * base)\n    exp = exp >> 1\n    base = mont.reduce(base * base)\nprint mont.reduce(prod)\nprint \"\\nAlternate computation of x1 ^ x2 mod m\u00a0:\"\nprint pow(x1, x2, m)\n"}
{"id": 383481, "name": "Finite state machine", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy ($state, $action, %fsm) = 'ready';\nwhile( <DATA> )\n  {\n  my ($start, $action, $end, $message) = split ' ', $_, 4;\n  $fsm{$start}{$action} = { next => $end, message => $message || \"\\n\" };\n  }\n\nwhile( $state ne 'exit' )\n  {\n  print \"in state $state\\n\";\n  do\n    {\n    ($action) = grep $_ eq 'IMPLICIT', my @actions = sort keys %{$fsm{$state}};\n    if( not $action )\n      {\n      print \"Enter \", join(' or ', @actions), \"\u00a0: \";\n      chomp($action = uc <STDIN>);\n      }\n    }\n  until $fsm{$state}{$action};\n  print $fsm{$state}{$action}{message};\n  $state = $fsm{$state}{$action}{next};\n  }\n\n\n", "target": "\n\nstates = {  'ready':{\n                'prompt' : 'Machine ready: (d)eposit, or (q)uit?',\n                'responses' : ['d','q']},\n            'waiting':{\n                'prompt' : 'Machine waiting: (s)elect, or (r)efund?',\n                'responses' : ['s','r']},\n            'dispense' : {\n                'prompt' : 'Machine dispensing: please (r)emove product',\n                'responses' : ['r']},\n            'refunding' : {\n                'prompt' : 'Refunding money',\n                'responses' : []},\n            'exit' :{}\n          }\ntransitions = { 'ready': { \n                    'd': 'waiting',\n                    'q': 'exit'},\n                'waiting' : {\n                    's' : 'dispense',\n                    'r' : 'refunding'},\n                'dispense' : {\n                    'r' : 'ready'},\n                'refunding' : {\n                    '' : 'ready'}}\n\ndef Acceptor(prompt, valids):\n    \n    if not valids: \n        print(prompt)\n        return ''\n    else:\n        while True:\n            resp = input(prompt)[0].lower()\n            if resp in valids:\n                return resp\n\ndef finite_state_machine(initial_state, exit_state):\n    response = True\n    next_state = initial_state\n    current_state = states[next_state]\n    while response != exit_state:\n        response = Acceptor(current_state['prompt'], current_state['responses'])\n        next_state = transitions[next_state][response]\n        current_state = states[next_state]\n\nif __name__ == \"__main__\":\n    finite_state_machine('ready','q')\n"}
{"id": 383482, "name": "Sokoban", "source": "Translate Perl to Python: \nuse strict;\nuse warnings qw(FATAL all);\nmy @initial = split /\\n/, <<'';\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=for\nspace is an empty square\n\n@ is the player\n$ is a box\n. is a goal\n+ is the player on a goal\n* is a box on a goal\n=cut\n\n\nmy $cols = length($initial[0]);\nmy $initial = join '', @initial;\nmy $size = length($initial);\ndie unless $size == $cols * @initial;\n\nsub WALL() { 1 }\nsub PLAYER() { 2 }\nsub BOX() { 4 }\nsub GOAL() { 8 }\n\nmy %input = (\n\t' ' => 0, '\n\t'.' => GOAL, '+' => PLAYER|GOAL, '*' => BOX|GOAL,\n);\nmy %output = reverse(%input);\n\nsub packed_initial {\n\tmy $ret = '';\n\tvec( $ret, $_, 4 ) = $input{substr $initial, $_, 1}\n\t\tfor( 0 .. $size-1 );\n\t$ret;\n}\n\nsub printable_board {\n\tmy $board = shift;\n\tmy @c = @output{map vec($board, $_, 4), 0 .. $size-1};\n\tmy $ret = '';\n\twhile( my @row = splice @c, 0, $cols ) {\n\t\t$ret .= join '', @row, \"\\n\";\n\t}\n\t$ret;\n}\n\nmy $packed = packed_initial();\n\nmy @udlr = qw(u d l r);\nmy @UDLR = qw(U D L R);\nmy @deltas = (-$cols, +$cols, -1, +1);\n\nmy %fseen;\nINIT_FORWARD: {\n\t$initial =~ /(\\@|\\+)/ or die;\n\tuse vars qw(@ftodo @fnext);\n\t@ftodo = ([\"\", $packed,  $-[0]]);\n\t$fseen{$packed} = '';\n}\n\nmy %rseen;\nINIT_REVERSE: {\n\tmy $goal = $packed;\n\tvec($goal, $ftodo[0][2], 4) -= PLAYER;\n\tmy @u = grep { my $t = vec($goal, $_, 4); $t & GOAL and not $t & BOX } 0 .. $size-1;\n\tmy @b = grep { my $t = vec($goal, $_, 4); $t & BOX and not $t & GOAL } 0 .. $size-1;\n\tdie unless @u == @b;\n\tvec($goal, $_, 4) += BOX for @u;\n\tvec($goal, $_, 4) -= BOX for @b;\n\tuse vars qw(@rtodo @rnext);\n\tFINAL_PLACE: for my $player (0 .. $size-1) {\n\t\tnext if vec($goal, $player, 4);\n\t\tFIND_GOAL: {\n\t\t\tvec($goal, $player + $_, 4) & GOAL and last FIND_GOAL for @deltas;\n\t\t\tnext FINAL_PLACE;\n\t\t}\n\t\tmy $a_goal = $goal;\n\t\tvec($a_goal, $player, 4) += PLAYER;\n\t\tpush @rtodo, [\"\", $a_goal, $player ];\n\t\t$rseen{$a_goal} = '';\n\t\t\n\t}\n}\n\nmy $movelen = -1;\nmy ($solution);\nMAIN: while( @ftodo and @rtodo ) {\n\n\tFORWARD: {\n\t\tmy ($moves, $level, $player) = @{pop @ftodo};\n\t\tdie unless vec($level, $player, 4) & PLAYER;\n\n\t\tfor my $dir_num (0 .. 3) {\n\t\t\tmy $delta = $deltas[$dir_num];\n\t\t\tmy @loc = map $player + $delta * $_, 0 .. 2;\n\t\t\tmy @val = map vec($level, $_, 4), @loc;\n\n\t\t\tnext if $val[1] & WALL or ($val[1] & BOX and $val[2] & (BOX|WALL));\n\t\t\t\n\t\t\tmy $new = $level;\n\t\t\tvec($new, $loc[0], 4) -= PLAYER;\n\t\t\tvec($new, $loc[1], 4) += PLAYER;\n\t\t\tmy $nmoves;\n\t\t\tif( $val[1] & BOX ) {\n\t\t\t\tvec($new, $loc[1], 4) -= BOX;\n\t\t\t\tvec($new, $loc[2], 4) += BOX;\n\t\t\t\t$nmoves = $moves . $UDLR[$dir_num];\n\t\t\t} else {\n\t\t\t\t$nmoves = $moves . $udlr[$dir_num];\n\t\t\t}\n\t\t\t\n\t\t\tnext if exists $fseen{$new};\n\t\t\t$fseen{$new} = $nmoves;\n\n\t\t\tpush @fnext, [ $nmoves, $new, $loc[1] ];\n\n\t\t\texists $rseen{$new} or next;\n\t\t\t\n\t\t\t$solution = $new;\n\t\t\tlast MAIN;\n\t\t}\n\n\t\tlast FORWARD if @ftodo;\n\t\tuse vars qw(*ftodo *fnext);\n\t\t(*ftodo, *fnext) = (\\@fnext, \\@ftodo);\n\t} \n\t\n\tBACKWARD: {\n\t\tmy ($moves, $level, $player) = @{pop @rtodo};\n\t\tdie \"<$level>\" unless vec($level, $player, 4) & PLAYER;\n\n\t\tfor my $dir_num (0 .. 3) {\n\t\t\tmy $delta = $deltas[$dir_num];\n\t\t\t\n\t\t\tmy @loc = map $player + $delta * $_, -1 .. 1;\n\t\t\tmy @val = map vec($level, $_, 4), @loc;\n\n\t\t\t\n\t\t\tnext if $val[0] & (WALL|BOX);\n\t\t\tmy $new = $level;\n\t\t\tvec($new, $loc[0], 4) += PLAYER;\n\t\t\tvec($new, $loc[1], 4) -= PLAYER;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif( $val[2] & BOX ) {\n\t\t\t\tmy $pull = $new;\n\t\t\t\tvec($pull, $loc[2], 4) -= BOX;\n\t\t\t\tvec($pull, $loc[1], 4) += BOX;\n\t\t\t\tgoto RWALK if exists $rseen{$pull};\n\t\t\t\tmy $pmoves = $UDLR[$dir_num] . $moves;\n\t\t\t\t$rseen{$pull} = $pmoves;\n\t\t\t\tpush @rnext, [$pmoves, $pull, $loc[0]];\n\t\t\t\tgoto RWALK unless exists $fseen{$pull};\n\t\t\t\tprint \"Doing pull\\n\";\n\t\t\t\t$solution = $pull;\n\t\t\t\tlast MAIN;\n\t\t\t}\n\t\t\tRWALK:\n\t\t\tnext if exists $rseen{$new}; \n\t\t\tmy $wmoves = $udlr[$dir_num] . $moves;\n\t\t\t$rseen{$new} = $wmoves;\n\t\t\tpush @rnext, [$wmoves, $new, $loc[0]];\n\t\t\tnext unless exists $fseen{$new};\n\t\t\tprint \"Rwalk\\n\";\n\t\t\t$solution = $new;\n\t\t\tlast MAIN;\n\t\t}\n\n\t\tlast BACKWARD if @rtodo;\n\t\tuse vars qw(*rtodo *rnext);\n\t\t(*rtodo, *rnext) = (\\@rnext, \\@rtodo);\n\t} \n}\n\nif( $solution ) {\n\tmy $fmoves = $fseen{$solution};\n\tmy $rmoves = $rseen{$solution};\n\tprint \"Solution found!\\n\";\n\tprint \"Time: \", (time() - $^T), \" seconds\\n\";\n\tprint \"Moves: $fmoves $rmoves\\n\";\n\tprint \"Move Length: \", length($fmoves . $rmoves), \"\\n\";\n\tprint \"Middle Board: \\n\", printable_board($solution);\n} else {\n\tprint \"No solution found!\\n\";\n}\n", "target": "from array import array\nfrom collections import deque\nimport psyco\n\ndata = []\nnrows = 0\npx = py = 0\nsdata = \"\"\nddata = \"\"\n\ndef init(board):\n    global data, nrows, sdata, ddata, px, py\n    data = filter(None, board.splitlines())\n    nrows = max(len(r) for r in data)\n\n    maps = {' ':' ', '.': '.', '@':' ', '\n    mapd = {' ':' ', '.': ' ', '@':'@', '\n\n    for r, row in enumerate(data):\n        for c, ch in enumerate(row):\n            sdata += maps[ch]\n            ddata += mapd[ch]\n            if ch == '@':\n                px = c\n                py = r\n\ndef push(x, y, dx, dy, data):\n    if sdata[(y+2*dy) * nrows + x+2*dx] == '\n       data[(y+2*dy) * nrows + x+2*dx] != ' ':\n        return None\n\n    data2 = array(\"c\", data)\n    data2[y * nrows + x] = ' '\n    data2[(y+dy) * nrows + x+dx] = '@'\n    data2[(y+2*dy) * nrows + x+2*dx] = '*'\n    return data2.tostring()\n\ndef is_solved(data):\n    for i in xrange(len(data)):\n        if (sdata[i] == '.') != (data[i] == '*'):\n            return False\n    return True\n\ndef solve():\n    open = deque([(ddata, \"\", px, py)])\n    visited = set([ddata])\n    dirs = ((0, -1, 'u', 'U'), ( 1, 0, 'r', 'R'),\n            (0,  1, 'd', 'D'), (-1, 0, 'l', 'L'))\n\n    lnrows = nrows\n    while open:\n        cur, csol, x, y = open.popleft()\n\n        for di in dirs:\n            temp = cur\n            dx, dy = di[0], di[1]\n\n            if temp[(y+dy) * lnrows + x+dx] == '*':\n                temp = push(x, y, dx, dy, temp)\n                if temp and temp not in visited:\n                    if is_solved(temp):\n                        return csol + di[3]\n                    open.append((temp, csol + di[3], x+dx, y+dy))\n                    visited.add(temp)\n            else:\n                if sdata[(y+dy) * lnrows + x+dx] == '\n                   temp[(y+dy) * lnrows + x+dx] != ' ':\n                    continue\n\n                data2 = array(\"c\", temp)\n                data2[y * lnrows + x] = ' '\n                data2[(y+dy) * lnrows + x+dx] = '@'\n                temp = data2.tostring()\n\n                if temp not in visited:\n                    if is_solved(temp):\n                        return csol + di[2]\n                    open.append((temp, csol + di[2], x+dx, y+dy))\n                    visited.add(temp)\n\n    return \"No solution\"\n\n\nlevel = \"\"\"\\\n\n\n\n\n\n\n\n\n\npsyco.full()\ninit(level)\nprint level, \"\\n\\n\", solve()\n"}
{"id": 383483, "name": "Zumkeller numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <is_prime divisor_sum divisors vecsum forcomb lastfor>;\n\nsub in_columns {\n    my($columns, $values) = @_;\n    my @v = split ' ', $values;\n    my $width = int(80/$columns);\n    printf \"%${width}d\"x$columns.\"\\n\", @v[$_*$columns .. -1+(1+$_)*$columns] for 0..-1+@v/$columns;\n    print \"\\n\";\n}\n\nsub is_Zumkeller {\n    my($n) = @_;\n    return 0 if is_prime($n);\n    my @divisors = divisors($n);\n    return 0 unless @divisors > 2 && 0 == @divisors % 2;\n    my $sigma = divisor_sum($n);\n    return 0 unless 0 == $sigma%2 && ($sigma/2) >= $n;\n    if (1 == $n%2) {\n        return 1\n    } else {\n        my $Z = 0;\n        forcomb { $Z++, lastfor if vecsum(@divisors[@_]) == $sigma/2 } @divisors;\n        return $Z;\n    }\n}\n\nuse constant Inf  => 1e10;\n\nsay 'First 220 Zumkeller numbers:';\nmy $n = 0; my $z;\n$z .= do { $n < 220 ? (is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(20, $z);\n\nsay 'First 40 odd Zumkeller numbers:';\n$n = 0; $z = '';\n$z .= do { $n < 40 ? (!!($_%2) and is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(10, $z);\n\nsay 'First 40 odd Zumkeller numbers not divisible by 5:';\n$n = 0; $z = '';\n$z .= do { $n < 40 ? (!!($_%2 and $_%5) and is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(10, $z);\n", "target": "from sympy import divisors\n\nfrom sympy.combinatorics.subsets import Subset\n\ndef isZumkeller(n):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s/2:\n        for x in range(1, 2**len(d)):\n            if sum(Subset.unrank_binary(x, d).subset) == s/2:\n                return True\n\n    return False\n\n\n\ndef printZumkellers(N, oddonly=False):\n    nprinted = 0\n    for n in range(1, 10**5):\n        if (oddonly == False or n % 2) and isZumkeller(n):\n            print(f'{n:>8}', end='')\n            nprinted += 1\n            if nprinted % 10 == 0:\n                print()\n            if nprinted >= N:\n                return\n\n\nprint(\"220 Zumkeller numbers:\")\nprintZumkellers(220)\nprint(\"\\n\\n40 odd Zumkeller numbers:\")\nprintZumkellers(40, True)\n"}
{"id": 383484, "name": "Commatizing numbers", "source": "Translate Perl to Python: @input = (\n    ['pi=3.14159265358979323846264338327950288419716939937510582097494459231', ' ', 5],\n    ['The author has two Z$100000000000000 Zimbabwe notes (100 trillion).', '.'],\n    ['-in Aus$+1411.8millions'],\n    ['===US$0017440 millions=== (in 2000 dollars)'],\n    ['123.e8000 is pretty big.'],\n    ['The land area of the earth is  57268900(29% of the surface)  square miles.'],\n    ['Ain\\'t no numbers in this here words, nohow, no way, Jose.'],\n    ['James was never known as  0000000007'],\n    ['Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.'],\n    ['   $-140000\u00b1100  millions.'],\n    ['5/9/1946 was a good year for some.']\n);\n\nfor $i (@input) {\n    $old = @$i[0];\n    $new = commatize(@$i);\n    printf(\"%s\\n%s\\n\\n\", $old, $new) if $old ne $new;\n}\n\nsub commatize {\n    my($str,$sep,$by) = @_;\n    $sep = ',' unless $sep;\n    $by  = 3   unless $by;\n\n    $str =~ s/                      \n            (?<![eE\\/])             \n            ([1-9]\\d{$by,})         \n            /c_ins($1,$by,$sep)/ex; \n    return $str;\n}\n\nsub c_ins {\n    my($s,$by,$sep) = @_;\n    ($c = reverse $s) =~ s/(.{$by})/$1$sep/g;\n    $c =~ s/$sep$//;\n    return reverse $c;\n}\n", "target": "import re as RegEx\n\n\ndef Commatize( _string, _startPos=0, _periodLen=3, _separator=\",\" ):\n\toutString = \"\"\n\tstrPos = 0\n\tmatches = RegEx.findall( \"[0-9]*\", _string )\n\n\tfor match in matches[:-1]:\n\t\tif not match:\n\t\t\toutString += _string[ strPos ]\n\t\t\tstrPos += 1\n\t\telse:\n\t\t\tif len(match) > _periodLen:\n\t\t\t\tleadIn = match[:_startPos]\n\t\t\t\tperiods =  [ match [ i:i + _periodLen ] for i in range ( _startPos, len ( match ), _periodLen ) ]\n\t\t\t\toutString += leadIn + _separator.join( periods )\n\t\t\telse:\n\t\t\t\toutString += match\n\n\t\t\tstrPos += len( match )\n\n\treturn outString\n\n\n\nprint ( Commatize( \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\", 0, 5, \" \" ) )\nprint ( Commatize( \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\", 0, 3, \".\" ))\nprint ( Commatize( \"\\\"-in Aus$+1411.8millions\\\"\" ))\nprint ( Commatize( \"===US$0017440 millions=== (in 2000 dollars)\" ))\nprint ( Commatize( \"123.e8000 is pretty big.\" ))\nprint ( Commatize( \"The land area of the earth is 57268900(29% of the surface) square miles.\" ))\nprint ( Commatize( \"Ain't no numbers in this here words, nohow, no way, Jose.\" ))\nprint ( Commatize( \"James was never known as 0000000007\" ))\nprint ( Commatize( \"Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.\" ))\nprint ( Commatize( \"\u2422\u2422\u2422$-140000\u00b1100 millions.\" ))\nprint ( Commatize( \"6/9/1946 was a good year for some.\" ))\n"}
{"id": 383485, "name": "Rare numbers", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse integer;\n\nmy $count = 0;\nmy @squares;\nfor my $large ( 0 .. 1e5 )\n  {\n  my $largesquared = $squares[$large] = $large * $large; \n  for my $small ( 0 .. $large - 1 )\n    {\n    my $n = $largesquared + $squares[$small];\n    2 * $large * $small == reverse $n or next;\n    printf \"%12s %s\\n\", $n, scalar reverse $n;\n    $n == reverse $n and die \"oops!\"; \n    ++$count >= 5 and exit;\n    }\n  }\n", "target": "\n\n\n\nfrom math import floor, sqrt\nfrom datetime import datetime\n\ndef main():\n\tstart = datetime.now()\n\tfor i in xrange(1, 10 ** 11):\n\t\tif rare(i):\n\t\t\tprint \"found a rare:\", i\n\tend = datetime.now()\n\tprint \"time elapsed:\", end - start\n\ndef is_square(n):\n\ts = floor(sqrt(n + 0.5))\n\treturn s * s == n\n\ndef reverse(n):\n\treturn int(str(n)[::-1])\n\ndef is_palindrome(n):\n\treturn n == reverse(n)\n\ndef rare(n):\n\tr = reverse(n)\n\treturn ( \n\t\tnot is_palindrome(n) and \n\t\tn > r and\n\t\tis_square(n+r) and is_square(n-r)\n\t)\n\nif __name__ == '__main__':\n\tmain()\n"}
{"id": 383486, "name": "Suffix tree", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Data::Dumper;\n \nsub classify {\n    my $h = {};\n    for (@_) { push @{$h->{substr($_,0,1)}}, $_ }\n    return $h;\n}\nsub suffixes {\n    my $str = shift;\n    map { substr $str, $_ } 0 .. length($str) - 1;\n}\nsub suffix_tree {\n    return +{} if @_ == 0;\n    return +{ $_[0] => +{} } if @_ == 1;\n    my $h = {};\n    my $classif = classify @_;\n    for my $key (keys %$classif) {\n        my $subtree = suffix_tree(\n            map { substr $_, 1 } @{$classif->{$key}}\n        );\n        my @subkeys = keys %$subtree;\n        if (@subkeys == 1) {\n            my ($subkey) = @subkeys;\n            $h->{\"$key$subkey\"} = $subtree->{$subkey};\n        } else { $h->{$key} = $subtree }\n    }\n    return $h;\n}\nprint +Dumper suffix_tree suffixes 'banana$';\n", "target": "class Node:\n    def __init__(self, sub=\"\", children=None):\n        self.sub = sub\n        self.ch = children or []\n\nclass SuffixTree:\n    def __init__(self, str):\n        self.nodes = [Node()]\n        for i in range(len(str)):\n            self.addSuffix(str[i:])\n\n    def addSuffix(self, suf):\n        n = 0\n        i = 0\n        while i < len(suf):\n            b = suf[i]\n            x2 = 0\n            while True:\n                children = self.nodes[n].ch\n                if x2 == len(children):\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(suf[i:], []))\n                    self.nodes[n].ch.append(n2)\n                    return\n                n2 = children[x2]\n                if self.nodes[n2].sub[0] == b:\n                    break\n                x2 = x2 + 1\n\n            \n            sub2 = self.nodes[n2].sub\n            j = 0\n            while j < len(sub2):\n                if suf[i + j] != sub2[j]:\n                    \n                    n3 = n2\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(sub2[:j], [n3]))\n                    self.nodes[n3].sub = sub2[j:] \n                    self.nodes[n].ch[x2] = n2\n                    break \n                j = j + 1\n            i = i + j   \n            n = n2      \n\n    def visualize(self):\n        if len(self.nodes) == 0:\n            print \"<empty>\"\n            return\n\n        def f(n, pre):\n            children = self.nodes[n].ch\n            if len(children) == 0:\n                print \"--\", self.nodes[n].sub\n                return\n            print \"+-\", self.nodes[n].sub\n            for c in children[:-1]:\n                print pre, \"+-\",\n                f(c, pre + \" | \")\n            print pre, \"+-\",\n            f(children[-1], pre + \"  \")\n\n        f(0, \"\")\n\nSuffixTree(\"banana$\").visualize()\n"}
{"id": 383487, "name": "Suffix tree", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Data::Dumper;\n \nsub classify {\n    my $h = {};\n    for (@_) { push @{$h->{substr($_,0,1)}}, $_ }\n    return $h;\n}\nsub suffixes {\n    my $str = shift;\n    map { substr $str, $_ } 0 .. length($str) - 1;\n}\nsub suffix_tree {\n    return +{} if @_ == 0;\n    return +{ $_[0] => +{} } if @_ == 1;\n    my $h = {};\n    my $classif = classify @_;\n    for my $key (keys %$classif) {\n        my $subtree = suffix_tree(\n            map { substr $_, 1 } @{$classif->{$key}}\n        );\n        my @subkeys = keys %$subtree;\n        if (@subkeys == 1) {\n            my ($subkey) = @subkeys;\n            $h->{\"$key$subkey\"} = $subtree->{$subkey};\n        } else { $h->{$key} = $subtree }\n    }\n    return $h;\n}\nprint +Dumper suffix_tree suffixes 'banana$';\n", "target": "class Node:\n    def __init__(self, sub=\"\", children=None):\n        self.sub = sub\n        self.ch = children or []\n\nclass SuffixTree:\n    def __init__(self, str):\n        self.nodes = [Node()]\n        for i in range(len(str)):\n            self.addSuffix(str[i:])\n\n    def addSuffix(self, suf):\n        n = 0\n        i = 0\n        while i < len(suf):\n            b = suf[i]\n            x2 = 0\n            while True:\n                children = self.nodes[n].ch\n                if x2 == len(children):\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(suf[i:], []))\n                    self.nodes[n].ch.append(n2)\n                    return\n                n2 = children[x2]\n                if self.nodes[n2].sub[0] == b:\n                    break\n                x2 = x2 + 1\n\n            \n            sub2 = self.nodes[n2].sub\n            j = 0\n            while j < len(sub2):\n                if suf[i + j] != sub2[j]:\n                    \n                    n3 = n2\n                    \n                    n2 = len(self.nodes)\n                    self.nodes.append(Node(sub2[:j], [n3]))\n                    self.nodes[n3].sub = sub2[j:] \n                    self.nodes[n].ch[x2] = n2\n                    break \n                j = j + 1\n            i = i + j   \n            n = n2      \n\n    def visualize(self):\n        if len(self.nodes) == 0:\n            print \"<empty>\"\n            return\n\n        def f(n, pre):\n            children = self.nodes[n].ch\n            if len(children) == 0:\n                print \"--\", self.nodes[n].sub\n                return\n            print \"+-\", self.nodes[n].sub\n            for c in children[:-1]:\n                print pre, \"+-\",\n                f(c, pre + \" | \")\n            print pre, \"+-\",\n            f(children[-1], pre + \"  \")\n\n        f(0, \"\")\n\nSuffixTree(\"banana$\").visualize()\n"}
{"id": 383488, "name": "Reflection_List properties", "source": "Translate Perl to Python: {\n     package Point;\n     use Class::Spiffy -base;\n\n     field 'x';\n     field 'y';\n}\n\n{\n     package Circle;\n     use base qw(Point);\n     field 'r';\n}\n\nmy $p1 = Point->new(x => 8, y => -5);\nmy $c1 = Circle->new(r => 4);\nmy $c2 = Circle->new(x => 1, y => 2, r => 3);\n\nuse Data::Dumper;\nsay Dumper $p1;\nsay Dumper $c1;\nsay Dumper $c2;\n", "target": "class Parent(object):\n    __priv = 'private'\n    \n    def __init__(self, name):\n        self.name = name\n    \n    def __repr__(self):\n        return '%s(%s)' % (type(self).__name__, self.name)\n    \n    def doNothing(self):\n        pass\n\nimport re\n\nclass Child(Parent):\n    \n    __rePrivate = re.compile('^_(Child|Parent)__')\n    \n    __reBleh = re.compile('\\Wbleh$')\n    @property\n    def reBleh(self):\n        return self.__reBleh\n    \n    def __init__(self, name, *args):\n        super(Child, self).__init__(name)\n        self.args = args\n    \n    def __dir__(self):\n        myDir = filter(\n            \n            lambda p: not self.__rePrivate.match(p),\n            list(set( \\\n                sum([dir(base) for base in type(self).__bases__], []) \\\n                + type(self).__dict__.keys() \\\n                + self.__dict__.keys() \\\n            )))\n        return myDir + map(\n            \n            lambda p: p + '_bleh',\n            filter(\n                \n                lambda p: (p[:2] != '__' or p[-2:] != '__') and not callable(getattr(self, p)),\n                myDir))\n    \n    def __getattr__(self, name):\n        if name[-5:] == '_bleh':\n            \n            return str(getattr(self, name[:-5])) + ' bleh'\n        if hasattr(super(Child, chld), '__getattr__'):\n            return super(Child, self).__getattr__(name)\n        raise AttributeError(\"'%s' object has no attribute '%s'\" % (type(self).__name__, name))\n    \n    def __setattr__(self, name, value):\n        if name[-5:] == '_bleh':\n            \n            if not (hasattr(self, name[:-5]) and callable(getattr(self, name[:-5]))):\n                setattr(self, name[:-5], self.reBleh.sub('', value))\n        elif hasattr(super(Child, self), '__setattr__'):\n            super(Child, self).__setattr__(name, value)\n        elif hasattr(self, '__dict__'):\n            self.__dict__[name] = value\n    \n    def __repr__(self):\n        return '%s(%s, %s)' % (type(self).__name__, self.name, str(self.args).strip('[]()'))\n    \n    def doStuff(self):\n        return (1+1.0/1e6) ** 1e6\n\npar = Parent('par')\npar.parent = True\ndir(par)\n\ninspect.getmembers(par)\n\n\nchld = Child('chld', 0, 'I', 'two')\nchld.own = \"chld's own\"\ndir(chld)\n\ninspect.getmembers(chld)\n\n"}
{"id": 383489, "name": "Eertree", "source": "Translate Perl to Python: $str = \"eertree\";\n\nfor $n (1 .. length($str)) {\n   for $m (1 .. length($str)) {\n      $strrev = \"\";\n      $strpal = substr($str, $n-1, $m);\n      if ($strpal ne \"\") {\n         for $p (reverse 1 .. length($strpal)) {\n            $strrev .= substr($strpal, $p-1, 1);\n         }\n         ($strpal eq $strrev) and push @pal, $strpal;\n      }\n   }\n}\n\nprint join ' ', grep {not $seen{$_}++} @pal, \"\\n\";\n", "target": "\nfrom __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)\n"}
{"id": 383490, "name": "Eertree", "source": "Translate Perl to Python: $str = \"eertree\";\n\nfor $n (1 .. length($str)) {\n   for $m (1 .. length($str)) {\n      $strrev = \"\";\n      $strpal = substr($str, $n-1, $m);\n      if ($strpal ne \"\") {\n         for $p (reverse 1 .. length($strpal)) {\n            $strrev .= substr($strpal, $p-1, 1);\n         }\n         ($strpal eq $strrev) and push @pal, $strpal;\n      }\n   }\n}\n\nprint join ' ', grep {not $seen{$_}++} @pal, \"\\n\";\n", "target": "\nfrom __future__ import print_function\n\nclass Node(object):\n\tdef __init__(self):\n\t\tself.edges = {} \n\t\tself.link = None \n\t\tself.len = 0 \n\nclass Eertree(object):\n\tdef __init__(self):\n\t\tself.nodes = []\n\t\t\n\t\tself.rto = Node() \n\t\tself.rte = Node() \n\n\t\t\n\t\tself.rto.link = self.rte.link = self.rto;\n\t\tself.rto.len = -1\n\t\tself.rte.len = 0\n\t\tself.S = [0] \n\t\tself.maxSufT = self.rte \n\n\tdef get_max_suffix_pal(self, startNode, a):\n\t\t\n\t\t\n\t\t\n\t\tu = startNode\n\t\ti = len(self.S)\n\t\tk = u.len\n\t\twhile id(u) != id(self.rto) and self.S[i - k - 1] != a:\n\t\t\tassert id(u) != id(u.link) \n\t\t\tu = u.link\n\t\t\tk = u.len\n\n\t\treturn u\n\t\n\tdef add(self, a):\n\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tQ = self.get_max_suffix_pal(self.maxSufT, a)\n\n\t\t\n\t\tcreateANewNode = not a in Q.edges\n\n\t\tif createANewNode:\n\t\t\t\n\t\t\tP = Node()\n\t\t\tself.nodes.append(P)\n\t\t\tP.len = Q.len + 2\n\t\t\tif P.len == 1:\n\t\t\t\t\n\t\t\t\tP.link = self.rte\n\t\t\telse:\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tP.link = self.get_max_suffix_pal(Q.link, a).edges[a]\n\n\t\t\t\n\t\t\tQ.edges[a] = P\n\n\t\t\n\t\tself.maxSufT = Q.edges[a]\n\n\t\t\n\t\tself.S.append(a)\n\n\t\treturn createANewNode\n\t\n\tdef get_sub_palindromes(self, nd, nodesToHere, charsToHere, result):\n\t\t\n\t\t\n\n\t\t\n\t\tfor lnkName in nd.edges:\n\t\t\tnd2 = nd.edges[lnkName] \n\t\t\tself.get_sub_palindromes(nd2, nodesToHere+[nd2], charsToHere+[lnkName], result)\n\n\t\t\n\t\tif id(nd) != id(self.rto) and id(nd) != id(self.rte): \n\t\t\ttmp = \"\".join(charsToHere)\n\t\t\tif id(nodesToHere[0]) == id(self.rte): \n\t\t\t\tassembled = tmp[::-1] + tmp\n\t\t\telse: \n\t\t\t\tassembled = tmp[::-1] + tmp[1:]\n\t\t\tresult.append(assembled)\n\nif __name__==\"__main__\":\n\tst = \"eertree\"\n\tprint (\"Processing string\", st)\n\teertree = Eertree()\n\tfor ch in st:\n\t\teertree.add(ch)\n\n\tprint (\"Number of sub-palindromes:\", len(eertree.nodes))\n\n\t\n\tresult = []\n\teertree.get_sub_palindromes(eertree.rto, [eertree.rto], [], result) \n\teertree.get_sub_palindromes(eertree.rte, [eertree.rte], [], result) \n\tprint (\"Sub-palindromes:\", result)\n"}
{"id": 383491, "name": "Base58Check encoding", "source": "Translate Perl to Python: use Math::BigInt;\n\nsub encode_base58 {\n    my ($num) = @_;\n    $num = Math::BigInt->new($num);\n\n    my $chars = [qw(\n    1 2 3 4 5 6 7 8 9\n    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z\n    a b c d e f g h i j k   m n o p q r s t u v w x y z\n    )];\n\n    my $base58;\n    while ($num->is_pos) {\n        my ($quotient, $remainder) = $num->bdiv(58);\n        $base58 = $chars->[$remainder] . $base58;\n    }\n    $base58\n}\n\nprintf \"%56s -> %s\\n\", $_, encode_base58(+$_)\n    for qw(\n     25420294593250030202636073700053352635053786165627414518\n     0x61\n     0x626262\n     0x636363\n     0x73696d706c792061206c6f6e6720737472696e67\n     0x516b6fcd0f\n     0xbf4f89001e670274dd\n     0x572e4794\n     0xecac89cad93923c02321\n     0x10c8511e\n    );\n", "target": "ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef convertToBase58(num):\n    sb = ''\n    while (num > 0):\n        r = num % 58\n        sb = sb + ALPHABET[r]\n        num = num // 58;\n    return sb[::-1]\n\ns = 25420294593250030202636073700053352635053786165627414518\nb = convertToBase58(s)\nprint(\"%-56d -> %s\" % (s, b))\n\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\nfor num in hash_arr:\n    b = convertToBase58(num)\n    print(\"0x%-54x -> %s\" % (num, b))\n"}
{"id": 383492, "name": "Base58Check encoding", "source": "Translate Perl to Python: use Math::BigInt;\n\nsub encode_base58 {\n    my ($num) = @_;\n    $num = Math::BigInt->new($num);\n\n    my $chars = [qw(\n    1 2 3 4 5 6 7 8 9\n    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z\n    a b c d e f g h i j k   m n o p q r s t u v w x y z\n    )];\n\n    my $base58;\n    while ($num->is_pos) {\n        my ($quotient, $remainder) = $num->bdiv(58);\n        $base58 = $chars->[$remainder] . $base58;\n    }\n    $base58\n}\n\nprintf \"%56s -> %s\\n\", $_, encode_base58(+$_)\n    for qw(\n     25420294593250030202636073700053352635053786165627414518\n     0x61\n     0x626262\n     0x636363\n     0x73696d706c792061206c6f6e6720737472696e67\n     0x516b6fcd0f\n     0xbf4f89001e670274dd\n     0x572e4794\n     0xecac89cad93923c02321\n     0x10c8511e\n    );\n", "target": "ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef convertToBase58(num):\n    sb = ''\n    while (num > 0):\n        r = num % 58\n        sb = sb + ALPHABET[r]\n        num = num // 58;\n    return sb[::-1]\n\ns = 25420294593250030202636073700053352635053786165627414518\nb = convertToBase58(s)\nprint(\"%-56d -> %s\" % (s, b))\n\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\nfor num in hash_arr:\n    b = convertToBase58(num)\n    print(\"0x%-54x -> %s\" % (num, b))\n"}
{"id": 383493, "name": "Latin Squares in reduced form", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy $n = 0;\nmy $count;\nour @perms;\n\nwhile( ++$n <= 7 )\n  {\n  $count = 0;\n  @perms = perm( my $start = join '', 1 .. $n );\n  find( $start );\n  print \"order $n size $count total @{[$count * fact($n) * fact($n-1)]}\\n\\n\";\n  }\n\nsub find\n  {\n  @_ >= $n and return $count += ($n != 4) || print join \"\\n\", @_, \"\\n\";\n  local @perms = grep 0 == ($_[-1] ^ $_) =~ tr/\\0//, @perms;\n  my $row = @_ + 1;\n  find( @_, $_ ) for grep /^$row/, @perms;\n  }\n\nsub fact { $_[0] > 1 ? $_[0] * fact($_[0] - 1) : 1 }\n\nsub perm\n  {\n  my $s = shift;\n  length $s <= 1 ? $s :\n    map { my $f = $_; map \"$f$_\", perm( $s =~ s/$_//r ) } split //, $s;\n  }\n", "target": "def dList(n, start):\n    start -= 1 \n    a = range(n)\n    a[start] = a[0]\n    a[0] = start\n    a[1:] = sorted(a[1:])\n    first = a[1]\n    \n    r = []\n    def recurse(last):\n        if (last == first):\n            \n            \n            \n            for j,v in enumerate(a[1:]):\n                if j + 1 == v:\n                    return \n            b = [x + 1 for x in a]\n            r.append(b)\n            return\n        for i in xrange(last, 0, -1):\n            a[i], a[last] = a[last], a[i]\n            recurse(last - 1)\n            a[i], a[last] = a[last], a[i]\n    recurse(n - 1)\n    return r\n\ndef printSquare(latin,n):\n    for row in latin:\n        print row\n    print\n\ndef reducedLatinSquares(n,echo):\n    if n <= 0:\n        if echo:\n            print []\n        return 0\n    elif n == 1:\n        if echo:\n            print [1]\n        return 1\n\n    rlatin = [None] * n\n    for i in xrange(n):\n        rlatin[i] = [None] * n\n    \n    for j in xrange(0, n):\n        rlatin[0][j] = j + 1\n\n    class OuterScope:\n        count = 0\n    def recurse(i):\n        rows = dList(n, i)\n\n        for r in xrange(len(rows)):\n            rlatin[i - 1] = rows[r]\n            justContinue = False\n            k = 0\n            while not justContinue and k < i - 1:\n                for j in xrange(1, n):\n                    if rlatin[k][j] == rlatin[i - 1][j]:\n                        if r < len(rows) - 1:\n                            justContinue = True\n                            break\n                        if i > 2:\n                            return\n                k += 1\n            if not justContinue:\n                if i < n:\n                    recurse(i + 1)\n                else:\n                    OuterScope.count += 1\n                    if echo:\n                        printSquare(rlatin, n)\n\n    \n    recurse(2)\n    return OuterScope.count\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    prod = 1\n    for i in xrange(2, n + 1):\n        prod *= i\n    return prod\n\nprint \"The four reduced latin squares of order 4 are:\\n\"\nreducedLatinSquares(4,True)\n\nprint \"The size of the set of reduced latin squares for the following orders\"\nprint \"and hence the total number of latin squares of these orders are:\\n\"\nfor n in xrange(1, 7):\n    size = reducedLatinSquares(n, False)\n    f = factorial(n - 1)\n    f *= f * n * size\n    print \"Order %d: Size %-4d x %d! x %d! => Total %d\" % (n, size, n, n - 1, f)\n"}
{"id": 383494, "name": "Kosaraju", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub kosaraju {\n    our(%k) = @_;\n    our %g = ();\n    our %h;\n    my $i = 0;\n    $g{$_}     = $i++ for sort keys %k;\n    $h{$g{$_}} = $_   for      keys %g; \n\n    our(%visited, @stack, @transpose, @connected);\n    sub visit {\n        my($u) = @_;\n        unless ($visited{$u}) {\n            $visited{$u} = 1;\n            for my $v (@{$k{$u}}) {\n                visit($v);\n                push @{$transpose[$g{$v}]}, $u;\n            }\n            push @stack, $u;\n        }\n    }\n\n    sub assign {\n        my($u, $root) = @_;\n        if ($visited{$u}) {\n            $visited{$u} = 0;\n            $connected[$g{$u}] = $root;\n            assign($_, $root) for @{$transpose[$g{$u}]};\n        }\n    }\n\n    visit($_) for sort keys %g;\n    assign($_, $_) for reverse @stack;\n\n    my %groups;\n    for my $i (0..$\n        my $id = $g{$connected[$i]};\n        push @{$groups{$id}}, $h{$i};\n    }\n    say join ' ', @{$groups{$_}} for sort keys %groups;\n}\n\nmy %test1 = (\n    0 => [1],\n    1 => [2],\n    2 => [0],\n    3 => [1, 2, 4],\n    4 => [3, 5],\n    5 => [2, 6],\n    6 => [5],\n    7 => [4, 6, 7]\n);\n\nmy %test2 = (\n   'Andy' => ['Bart'],\n   'Bart' => ['Carl'],\n   'Carl' => ['Andy'],\n   'Dave' => [<Bart Carl Earl>],\n   'Earl' => [<Dave Fred>],\n   'Fred' => [<Carl Gary>],\n   'Gary' => ['Fred'],\n   'Hank' => [<Earl Gary Hank>]\n);\n\nkosaraju(%test1);\nsay '';\nkosaraju(%test2);\n", "target": "def kosaraju(g):\n    class nonlocal: pass\n\n    \n    size = len(g)\n\n    vis = [False]*size \n    l = [0]*size\n    nonlocal.x = size\n    t = [[]]*size   \n\n    def visit(u):\n        if not vis[u]:\n            vis[u] = True\n            for v in g[u]:\n                visit(v)\n                t[v] = t[v] + [u]\n            nonlocal.x = nonlocal.x - 1\n            l[nonlocal.x] = u\n\n    \n    for u in range(len(g)):\n        visit(u)\n    c = [0]*size\n\n    def assign(u, root):\n        if vis[u]:\n            vis[u] = False\n            c[u] = root\n            for v in t[u]:\n                assign(v, root)\n\n    \n    for u in l:\n        assign(u, u)\n\n    return c\n\ng = [[1], [2], [0], [1,2,4], [3,5], [2,6], [5], [4,6,7]]\nprint kosaraju(g)\n"}
{"id": 383495, "name": "Word search", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <bitwise>;\nuse Path::Tiny;\nuse List::Util qw( shuffle );\n\nmy $size = 10;\nmy $s1 = $size + 1;\n$_ = <<END;\n.....R....\n......O...\n.......S..\n........E.\nT........T\n.A........\n..C.......\n...O......\n....D.....\n.....E....\nEND\n\nmy @words = shuffle path('/usr/share/dict/words')->slurp =~ /^[a-z]{3,7}$/gm;\nmy @played;\nmy %used;\n\nfor my $word ( (@words) x 5 )\n  {\n  my ($pat, $start, $end, $mask, $nulls) = find( $word );\n  defined $pat or next;\n  $used{$word}++ and next; \n  $nulls //= '';\n  my $expand = $word =~ s/\\B/$nulls/gr;\n  my $pos = $start;\n  if( $start > $end )\n    {\n    $pos = $end;\n    $expand = reverse $expand;\n    }\n  substr $_, $pos, length $mask,\n    (substr( $_, $pos, length $mask ) &. ~. \"$mask\") |. \"$expand\";\n  push @played, join ' ', $word, $start, $end;\n  tr/.// > 0 or last;\n  }\n\nprint \"   0 1 2 3 4 5 6 7 8 9\\n\\n\";\nmy $row = 0;\nprint s/(?<=.)(?=.)/ /gr =~ s/^/ $row++ . '  ' /gemr;\nprint \"\\nNumber of words: \", @played . \"\\n\\n\";\nmy @where = map\n  {\n  my ($word, $start, $end) = split;\n  sprintf \"%11s %s\", $word, $start < $end\n    ? \"(@{[$start\u00a0% $s1]},@{[int $start / $s1]})->\" .\n      \"(@{[$end\u00a0% $s1 - 1]},@{[int $end / $s1]})\"\n    : \"(@{[$start\u00a0% $s1 - 1]},@{[int $start / $s1]})->\" .\n      \"(@{[$end\u00a0% $s1]},@{[int $end / $s1]})\";\n  } sort @played;\nprint splice(@where, 0, 3), \"\\n\" while @where;\ntr/.// and die \"incomplete\";\n\nsub find\n  {\n  my ($word) = @_;\n  my $n = length $word;\n  my $nm1 = $n - 1;\n  my %pats;\n\n  for my $space ( 0, $size - 1 .. $size + 1 )\n    {\n    my $nulls = \"\\0\" x $space;\n    my $mask = \"\\xff\" . ($nulls . \"\\xff\") x $nm1; \n    my $gap = qr/.{$space}/s;\n    while( /(?=(.(?:$gap.){$nm1}))/g )\n      {\n      my $pat = ($1 &. $mask) =~ tr/\\0//dr;\n      $pat =~ tr/.// or next;\n      my $pos = \"$-[1] $+[1]\";\n      $word =~ /$pat/ or reverse($word) =~ /$pat/ or next;\n      push @{ $pats{$pat} }, \"$pos $mask $nulls\";\n      }\n    }\n\n  for my $key ( sort keys %pats )\n    {\n    if( $word =~ /^$key$/ )\n      {\n      my @all = @{ $pats{$key} };\n      return $key, split ' ', $all[ rand @all ];\n      }\n    elsif( (reverse $word) =~ /^$key$/ )\n      {\n      my @all = @{ $pats{$key} };\n      my @parts = split ' ', $all[ rand @all ];\n      return $key, @parts[ 1, 0, 2, 3]\n      }\n    }\n\n  return undef;\n  }\n", "target": "import re\nfrom random import shuffle, randint\n\ndirs = [[1, 0], [0, 1], [1, 1], [1, -1], [-1, 0], [0, -1], [-1, -1], [-1, 1]]\nn_rows = 10\nn_cols = 10\ngrid_size = n_rows * n_cols\nmin_words = 25\n\n\nclass Grid:\n    def __init__(self):\n        self.num_attempts = 0\n        self.cells = [['' for _ in range(n_cols)] for _ in range(n_rows)]\n        self.solutions = []\n\n\ndef read_words(filename):\n    max_len = max(n_rows, n_cols)\n\n    words = []\n    with open(filename, \"r\") as file:\n        for line in file:\n            s = line.strip().lower()\n            if re.match(r'^[a-z]{3,' + re.escape(str(max_len)) + r'}$', s) is not None:\n                words.append(s)\n\n    return words\n\n\ndef place_message(grid, msg):\n    msg = re.sub(r'[^A-Z]', \"\", msg.upper())\n\n    message_len = len(msg)\n    if 0 < message_len < grid_size:\n        gap_size = grid_size // message_len\n\n        for i in range(0, message_len):\n            pos = i * gap_size + randint(0, gap_size)\n            grid.cells[pos // n_cols][pos % n_cols] = msg[i]\n\n        return message_len\n\n    return 0\n\n\ndef try_location(grid, word, direction, pos):\n    r = pos // n_cols\n    c = pos % n_cols\n    length = len(word)\n\n    \n    if (dirs[direction][0] == 1 and (length + c) > n_cols) or \\\n       (dirs[direction][0] == -1 and (length - 1) > c) or \\\n       (dirs[direction][1] == 1 and (length + r) > n_rows) or \\\n       (dirs[direction][1] == -1 and (length - 1) > r):\n        return 0\n\n    rr = r\n    cc = c\n    i = 0\n    overlaps = 0\n\n    \n    while i < length:\n        if grid.cells[rr][cc] != '' and grid.cells[rr][cc] != word[i]:\n            return 0\n        cc += dirs[direction][0]\n        rr += dirs[direction][1]\n        i += 1\n\n    rr = r\n    cc = c\n    i = 0\n    \n    while i < length:\n        if grid.cells[rr][cc] == word[i]:\n            overlaps += 1\n        else:\n            grid.cells[rr][cc] = word[i]\n\n        if i < length - 1:\n            cc += dirs[direction][0]\n            rr += dirs[direction][1]\n\n        i += 1\n\n    letters_placed = length - overlaps\n    if letters_placed > 0:\n        grid.solutions.append(\"{0:<10} ({1},{2})({3},{4})\".format(word, c, r, cc, rr))\n\n    return letters_placed\n\n\ndef try_place_word(grid, word):\n    rand_dir = randint(0, len(dirs))\n    rand_pos = randint(0, grid_size)\n\n    for direction in range(0, len(dirs)):\n        direction = (direction + rand_dir) % len(dirs)\n\n        for pos in range(0, grid_size):\n            pos = (pos + rand_pos) % grid_size\n\n            letters_placed = try_location(grid, word, direction, pos)\n            if letters_placed > 0:\n                return letters_placed\n\n    return 0\n\n\ndef create_word_search(words):\n    grid = None\n    num_attempts = 0\n\n    while num_attempts < 100:\n        num_attempts += 1\n        shuffle(words)\n\n        grid = Grid()\n        message_len = place_message(grid, \"Rosetta Code\")\n        target = grid_size - message_len\n\n        cells_filled = 0\n        for word in words:\n            cells_filled += try_place_word(grid, word)\n            if cells_filled == target:\n                if len(grid.solutions) >= min_words:\n                    grid.num_attempts = num_attempts\n                    return grid\n                else:\n                    break \n\n    return grid\n\n\ndef print_result(grid):\n    if grid is None or grid.num_attempts == 0:\n        print(\"No grid to display\")\n        return\n\n    size = len(grid.solutions)\n\n    print(\"Attempts: {0}\".format(grid.num_attempts))\n    print(\"Number of words: {0}\".format(size))\n\n    print(\"\\n     0  1  2  3  4  5  6  7  8  9\\n\")\n    for r in range(0, n_rows):\n        print(\"{0}   \".format(r), end='')\n        for c in range(0, n_cols):\n            print(\" %c \" % grid.cells[r][c], end='')\n        print()\n    print()\n\n    for i in range(0, size - 1, 2):\n        print(\"{0}   {1}\".format(grid.solutions[i], grid.solutions[i+1]))\n\n    if size % 2 == 1:\n        print(grid.solutions[size - 1])\n\n\nif __name__ == \"__main__\":\n    print_result(create_word_search(read_words(\"unixdict.txt\")))\n"}
{"id": 383496, "name": "Markov chain text generator", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $file = shift || 'alice_oz.txt';\nmy $n    = shift || 3;\nmy $max  = shift || 200;\n\nsub build_dict {\n    my ($n, @words) = @_;\n    my %dict;\n    for my $i (0 .. $\n        my @prefix = @words[$i .. $i+$n-1];\n        push @{$dict{join ' ', @prefix}}, $words[$i+$n];\n    }\n    return %dict;\n}\n\nsub pick1 { $_[rand @_] }\n\nmy $text = do {\n    open my $fh, '<', $file;\n    local $/;\n    <$fh>;\n};\n\nmy @words = split ' ', $text;\npush @words, @words[0..$n-1];\nmy %dict  = build_dict($n, @words);\nmy @rotor = @words[0..$n-1];\nmy @chain = @rotor;\n\nfor (1 .. $max) {\n    my $new = pick1(@{$dict{join ' ', @rotor}});\n    shift @rotor;\n    push @rotor, $new;\n    push @chain, $new;\n}\n\nprint join(' ', @chain) . \"\\n\";\n", "target": "import random, sys\n\ndef makerule(data, context):\n    \n    rule = {}\n    words = data.split(' ')\n    index = context\n    \n    for word in words[index:]:\n        key = ' '.join(words[index-context:index])\n        if key in rule:\n            rule[key].append(word)\n        else:\n            rule[key] = [word]\n        index += 1\n\n    return rule\n\n\ndef makestring(rule, length):    \n    \n    oldwords = random.choice(list(rule.keys())).split(' ') \n    string = ' '.join(oldwords) + ' '\n    \n    for i in range(length):\n        try:\n            key = ' '.join(oldwords)\n            newword = random.choice(rule[key])\n            string += newword + ' '\n\n            for word in range(len(oldwords)):\n                oldwords[word] = oldwords[(word + 1) % len(oldwords)]\n            oldwords[-1] = newword\n\n        except KeyError:\n            return string\n    return string\n\n\nif __name__ == '__main__':\n    with open(sys.argv[1], encoding='utf8') as f:\n        data = f.read()\n    rule = makerule(data, int(sys.argv[2]))\n    string = makestring(rule, int(sys.argv[3]))\n    print(string)\n"}
{"id": 383497, "name": "Arithmetic coding_As a generalized change of radix", "source": "Translate Perl to Python: use Math::BigInt (try => 'GMP');\n\nsub cumulative_freq {\n    my ($freq) = @_;\n\n    my %cf;\n    my $total = Math::BigInt->new(0);\n    foreach my $c (sort keys %$freq) {\n        $cf{$c} = $total;\n        $total += $freq->{$c};\n    }\n\n    return %cf;\n}\n\nsub arithmethic_coding {\n    my ($str, $radix) = @_;\n    my @chars = split(//, $str);\n\n    \n    my %freq;\n    $freq{$_}++ for @chars;\n\n    \n    my %cf = cumulative_freq(\\%freq);\n\n    \n    my $base = Math::BigInt->new(scalar @chars);\n\n    \n    my $L = Math::BigInt->new(0);\n\n    \n    my $pf = Math::BigInt->new(1);\n\n    \n    \n    foreach my $c (@chars) {\n        $L->bmuladd($base, $cf{$c} * $pf);\n        $pf->bmul($freq{$c});\n    }\n\n    \n    my $U = $L + $pf;\n\n    my $pow = Math::BigInt->new($pf)->blog($radix);\n    my $enc = ($U - 1)->bdiv(Math::BigInt->new($radix)->bpow($pow));\n\n    return ($enc, $pow, \\%freq);\n}\n\nsub arithmethic_decoding {\n    my ($enc, $radix, $pow, $freq) = @_;\n\n    \n    $enc *= $radix**$pow;\n\n    \n    my $base = Math::BigInt->new(0);\n    $base += $_ for values %{$freq};\n\n    \n    my %cf = cumulative_freq($freq);\n\n    \n    my %dict;\n    while (my ($k, $v) = each %cf) {\n        $dict{$v} = $k;\n    }\n\n    \n    my $lchar;\n    foreach my $i (0 .. $base - 1) {\n        if (exists $dict{$i}) {\n            $lchar = $dict{$i};\n        }\n        elsif (defined $lchar) {\n            $dict{$i} = $lchar;\n        }\n    }\n\n    \n    my $decoded = '';\n    for (my $pow = $base**($base - 1) ; $pow > 0 ; $pow /= $base) {\n        my $div = $enc / $pow;\n\n        my $c  = $dict{$div};\n        my $fv = $freq->{$c};\n        my $cv = $cf{$c};\n\n        $enc = ($enc - $pow * $cv) / $fv;\n        $decoded .= $c;\n    }\n\n    \n    return $decoded;\n}\n\nmy $radix = 10;    \n\nforeach my $str (qw(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT)) {\n    my ($enc, $pow, $freq) = arithmethic_coding($str, $radix);\n    my $dec = arithmethic_decoding($enc, $radix, $pow, $freq);\n\n    printf(\"%-25s=> %19s * %d^%s\\n\", $str, $enc, $radix, $pow);\n\n    if ($str ne $dec) {\n        die \"\\tHowever that is incorrect!\";\n    }\n}\n", "target": "from collections import Counter\n\ndef cumulative_freq(freq):\n    cf = {}\n    total = 0\n    for b in range(256):\n        if b in freq:\n            cf[b] = total\n            total += freq[b]\n    return cf\n\ndef arithmethic_coding(bytes, radix):\n\n    \n    freq = Counter(bytes)\n\n    \n    cf = cumulative_freq(freq)\n\n    \n    base = len(bytes)\n\n    \n    lower = 0\n\n    \n    pf = 1\n\n    \n    \n    for b in bytes:\n        lower = lower*base + cf[b]*pf\n        pf *= freq[b]\n\n    \n    upper = lower+pf\n\n    pow = 0\n    while True:\n        pf //= radix\n        if pf==0: break\n        pow += 1\n\n    enc = (upper-1) // radix**pow\n    return enc, pow, freq\n\ndef arithmethic_decoding(enc, radix, pow, freq):\n\n    \n    enc *= radix**pow;\n\n    \n    base = sum(freq.values())\n\n    \n    cf = cumulative_freq(freq)\n\n    \n    dict = {}\n    for k,v in cf.items():\n        dict[v] = k\n\n    \n    lchar = None\n    for i in range(base):\n        if i in dict:\n            lchar = dict[i]\n        elif lchar is not None:\n            dict[i] = lchar\n\n    \n    decoded = bytearray()\n    for i in range(base-1, -1, -1):\n        pow = base**i\n        div = enc//pow\n\n        c  = dict[div]\n        fv = freq[c]\n        cv = cf[c]\n\n        rem = (enc - pow*cv) // fv\n\n        enc = rem\n        decoded.append(c)\n\n    \n    return bytes(decoded)\n\nradix = 10      \n\nfor str in b'DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT'.split():\n    enc, pow, freq = arithmethic_coding(str, radix)\n    dec = arithmethic_decoding(enc, radix, pow, freq)\n\n    print(\"%-25s=> %19s * %d^%s\" % (str, enc, radix, pow))\n\n    if str != dec:\n    \traise Exception(\"\\tHowever that is incorrect!\")\n"}
{"id": 383498, "name": "Playfair cipher", "source": "Translate Perl to Python: use Math::Cartesian::Product;\n\n\nsub playfair {\n    our($key,$from) = @_;\n    $from //= 'J';\n    our $to = $from eq 'J' ? 'I' : '';\n    my(%ENC,%DEC,%seen,@m);\n\n    sub canon {\n        my($str) = @_;\n        $str =~ s/[^[:alpha:]]//g;\n        $str =~ s/$from/$to/gi;\n        uc $str;\n    }\n\n    my @uniq = grep { ! $seen{$_}++ } split '', canon($key . join '', 'A'..'Z');\n    while (@uniq) { push @m, [splice @uniq, 0, 5] }\n\n    \n    for my $r (@m)  {\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ @$r[$i] . @$r[$j] } =  @$r[($i+1)%5] . @$r[($j+1)%5];\n        }\n    }\n\n    \n    for my $c (0..4) {\n        my @c = map { @$_[$c] } @m;\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ $c[$i] . $c[$j] } = $c[($i+1)%5] . $c[($j+1)%5];\n        }\n    }\n\n    \n    for my $x (cartesian {@_} [0..4], [0..4], [0..4], [0..4]) {\n        my($i1,$j1,$i2,$j2) = @$x;\n        next if $i1 == $i2 or $j1 == $j2;\n        $ENC{ $m[$i1][$j1] . $m[$i2][$j2] } = $m[$i1][$j2] . $m[$i2][$j1];\n    }\n\n    \n     while (my ($k, $v) = each %ENC) { $DEC{$v} = $k }\n\n    \n    return\n    sub { my($red) = @_; \n        my $str = canon($red);\n\n        my @list;\n        while ($str =~ /(.)(?(?=\\1)|(.?))/g) {\n            push @list, substr($str,$-[0], $-[2] ? 2 : 1);\n        }\n        join ' ', map { length($_)==1 ? $ENC{$_.'X'} : $ENC{$_} } @list;\n    },\n    sub { my($black) = @_; \n        join ' ', map { $DEC{$_} } canon($black) =~ /../g;\n    }\n}\n\nmy($encode,$decode) = playfair('Playfair example');\n\nmy $orig  = \"Hide the gold in...the TREESTUMP!!!\";\nmy $black = &$encode($orig);\nmy $red   = &$decode($black);\nprint \" orig:\\t$orig\\n\";\nprint \"black:\\t$black\\n\";\nprint \"  red:\\t$red\\n\";\n", "target": "from string import ascii_uppercase\nfrom itertools import product\nfrom re import findall\n\ndef uniq(seq):\n    seen = {}\n    return [seen.setdefault(x, x) for x in seq if x not in seen]\n\ndef partition(seq, n):\n    return [seq[i : i + n] for i in xrange(0, len(seq), n)]\n\n\n\ndef playfair(key, from_ = 'J', to = None):\n    if to is None:\n        to = 'I' if from_ == 'J' else ''\n\n    def canonicalize(s):\n        return filter(str.isupper, s.upper()).replace(from_, to)\n\n    \n    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)\n\n    \n    enc = {}\n\n    \n    for row in m:\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]\n\n    \n    for c in zip(*m):\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]\n\n    \n    for i1, j1, i2, j2 in product(xrange(5), repeat=4):\n        if i1 != i2 and j1 != j2:\n            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]\n\n    \n    dec = dict((v, k) for k, v in enc.iteritems())\n\n    def sub_enc(txt):\n        lst = findall(r\"(.)(?:(?!\\1)(.))?\", canonicalize(txt))\n        return \" \".join(enc[a + (b if b else 'X')] for a, b in lst)\n\n    def sub_dec(encoded):\n        return \" \".join(dec[p] for p in partition(canonicalize(encoded), 2))\n\n    return sub_enc, sub_dec\n\n\n(encode, decode) = playfair(\"Playfair example\")\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprint \"Original:\", orig\nenc = encode(orig)\nprint \"Encoded:\", enc\nprint \"Decoded:\", decode(enc)\n"}
{"id": 383499, "name": "Playfair cipher", "source": "Translate Perl to Python: use Math::Cartesian::Product;\n\n\nsub playfair {\n    our($key,$from) = @_;\n    $from //= 'J';\n    our $to = $from eq 'J' ? 'I' : '';\n    my(%ENC,%DEC,%seen,@m);\n\n    sub canon {\n        my($str) = @_;\n        $str =~ s/[^[:alpha:]]//g;\n        $str =~ s/$from/$to/gi;\n        uc $str;\n    }\n\n    my @uniq = grep { ! $seen{$_}++ } split '', canon($key . join '', 'A'..'Z');\n    while (@uniq) { push @m, [splice @uniq, 0, 5] }\n\n    \n    for my $r (@m)  {\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ @$r[$i] . @$r[$j] } =  @$r[($i+1)%5] . @$r[($j+1)%5];\n        }\n    }\n\n    \n    for my $c (0..4) {\n        my @c = map { @$_[$c] } @m;\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ $c[$i] . $c[$j] } = $c[($i+1)%5] . $c[($j+1)%5];\n        }\n    }\n\n    \n    for my $x (cartesian {@_} [0..4], [0..4], [0..4], [0..4]) {\n        my($i1,$j1,$i2,$j2) = @$x;\n        next if $i1 == $i2 or $j1 == $j2;\n        $ENC{ $m[$i1][$j1] . $m[$i2][$j2] } = $m[$i1][$j2] . $m[$i2][$j1];\n    }\n\n    \n     while (my ($k, $v) = each %ENC) { $DEC{$v} = $k }\n\n    \n    return\n    sub { my($red) = @_; \n        my $str = canon($red);\n\n        my @list;\n        while ($str =~ /(.)(?(?=\\1)|(.?))/g) {\n            push @list, substr($str,$-[0], $-[2] ? 2 : 1);\n        }\n        join ' ', map { length($_)==1 ? $ENC{$_.'X'} : $ENC{$_} } @list;\n    },\n    sub { my($black) = @_; \n        join ' ', map { $DEC{$_} } canon($black) =~ /../g;\n    }\n}\n\nmy($encode,$decode) = playfair('Playfair example');\n\nmy $orig  = \"Hide the gold in...the TREESTUMP!!!\";\nmy $black = &$encode($orig);\nmy $red   = &$decode($black);\nprint \" orig:\\t$orig\\n\";\nprint \"black:\\t$black\\n\";\nprint \"  red:\\t$red\\n\";\n", "target": "from string import ascii_uppercase\nfrom itertools import product\nfrom re import findall\n\ndef uniq(seq):\n    seen = {}\n    return [seen.setdefault(x, x) for x in seq if x not in seen]\n\ndef partition(seq, n):\n    return [seq[i : i + n] for i in xrange(0, len(seq), n)]\n\n\n\ndef playfair(key, from_ = 'J', to = None):\n    if to is None:\n        to = 'I' if from_ == 'J' else ''\n\n    def canonicalize(s):\n        return filter(str.isupper, s.upper()).replace(from_, to)\n\n    \n    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)\n\n    \n    enc = {}\n\n    \n    for row in m:\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]\n\n    \n    for c in zip(*m):\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]\n\n    \n    for i1, j1, i2, j2 in product(xrange(5), repeat=4):\n        if i1 != i2 and j1 != j2:\n            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]\n\n    \n    dec = dict((v, k) for k, v in enc.iteritems())\n\n    def sub_enc(txt):\n        lst = findall(r\"(.)(?:(?!\\1)(.))?\", canonicalize(txt))\n        return \" \".join(enc[a + (b if b else 'X')] for a, b in lst)\n\n    def sub_dec(encoded):\n        return \" \".join(dec[p] for p in partition(canonicalize(encoded), 2))\n\n    return sub_enc, sub_dec\n\n\n(encode, decode) = playfair(\"Playfair example\")\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprint \"Original:\", orig\nenc = encode(orig)\nprint \"Encoded:\", enc\nprint \"Decoded:\", decode(enc)\n"}
{"id": 383500, "name": "Elementary cellular automaton_Infinite length", "source": "Translate Perl to Python: sub evolve {\n\tmy ($rule, $pattern) = @_;\n\tmy $offset = 0;\n\n\twhile (1) {\n\t\tmy ($l, $r, $st);\n\t\t$pattern =~ s/^((.)\\g2*)/$2$2/ and $l = $2, $offset -= length($2);\n\t\t$pattern =~ s/(.)\\g1*$/$1$1/   and $r = $1;\n\n\t\t$st = $pattern;\n\n\t\t$pattern =~ tr/01/.\n\t\tprintf \"%5d| %s%s\\n\", $offset, ' ' x (40 + $offset), $pattern;\n\n\t\t$pattern = join '', map(1 & ($rule>>oct \"0b$_\"),\n\t\t\t\t$l x 3,\n\t\t\t\tmap(substr($st, $_, 3), 0 .. length($st)-3),\n\t\t\t\t$r x 3);\n\t}\n}\n\nevolve(90, \"010\");\n", "target": "def _notcell(c):\n    return '0' if c == '1' else '1'\n\ndef eca_infinite(cells, rule):\n    lencells = len(cells)\n    rulebits = '{0:08b}'.format(rule)\n    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}\n    c = cells\n    while True:\n        yield c\n        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    \n\n        c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))\n        \n\nif __name__ == '__main__':\n    lines = 25\n    for rule in (90, 30):\n        print('\\nRule: %i' % rule)\n        for i, c in zip(range(lines), eca_infinite('1', rule)):\n            print('%2i: %s%s' % (i, ' '*(lines - i), c.replace('0', '.').replace('1', '\n"}
{"id": 383501, "name": "Word break problem", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy @words = <a o is pi ion par per sip miss able>;\nprint \"$_: \" . word_break($_,@words) . \"\\n\" for <a aa amiss parable opera operable inoperable permission mississippi>;\n\nsub word_break {\n    my($word,@dictionary) = @_;\n    my @matches;\n    my $one_of = join '|', @dictionary;\n    @matches = $word =~ /^ ($one_of) ($one_of)? ($one_of)? ($one_of)? $/x; \n    return join(' ', grep {$_} @matches) || \"(not possible)\";\n}\n", "target": "\n\nfrom itertools import (chain)\n\n\n\ndef stringParse(lexicon):\n    \n    return lambda s: Node(s)(\n        tokenTrees(lexicon)(s)\n    )\n\n\n\ndef tokenTrees(wds):\n    \n    def go(s):\n        return [Node(s)([])] if s in wds else (\n            concatMap(nxt(s))(wds)\n        )\n\n    def nxt(s):\n        return lambda w: parse(\n            w, go(s[len(w):])\n        ) if s.startswith(w) else []\n\n    def parse(w, xs):\n        return [Node(w)(xs)] if xs else xs\n\n    return lambda s: go(s)\n\n\n\ndef showParse(tree):\n    \n    def showTokens(x):\n        xs = x['nest']\n        return ' ' + x['root'] + (showTokens(xs[0]) if xs else '')\n    parses = tree['nest']\n    return tree['root'] + ':\\n' + (\n        '\\n'.join(\n            map(showTokens, parses)\n        ) if parses else ' ( Not parseable in terms of these words )'\n    )\n\n\n\n\ndef main():\n    \n\n    lexicon = 'a bc abc cd b'.split()\n    testSamples = 'abcd abbc abcbcd acdbc abcdd'.split()\n\n    print(unlines(\n        map(\n            showParse,\n            map(\n                stringParse(lexicon),\n                testSamples\n            )\n        )\n    ))\n\n\n\n\n\ndef Node(v):\n    \n    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}\n\n\n\ndef concatMap(f):\n    \n    return lambda xs: list(\n        chain.from_iterable(map(f, xs))\n    )\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383502, "name": "Create an object_Native demonstration", "source": "Translate Perl to Python: use strict;\n\npackage LockedHash;\nuse parent 'Tie::Hash';\nuse Carp;\n\nsub TIEHASH {\n\tmy $cls = shift;\n\tmy %h = @_;\n\tbless \\%h, ref $cls || $cls;\n}\n\nsub STORE {\n\tmy ($self, $k, $v) = @_;\n\tcroak \"Can't add key $k\" unless exists $self->{$k};\n\t$self->{$k} = $v;\n}\n\nsub FETCH {\n\tmy ($self, $k) = @_;\n\tcroak \"No key $k\" unless exists $self->{$k};\n\t$self->{$k};\n}\n\nsub DELETE {\n\tmy ($self, $k) = @_;\n\tcroak \"No key $k\" unless exists $self->{$k};\n\t$self->{$k} = 0;\n}\n\nsub CLEAR { } \nsub EXISTS { exists shift->{+shift} }\n\nsub FIRSTKEY {\n\tmy $self = shift;\n\tkeys %$self;\n\teach %$self;\n}\n\nsub NEXTKEY {\n\tmy $self = shift;\n\teach %$self;\n}\n\nsub lock_hash :prototype(\\%) {\n\tmy $ref = shift;\n\ttie(%$ref, __PACKAGE__, %$ref);\n}\n\n1;\n\nmy %h = (a => 3, b => 4, c => 5);\n\n\nLockedHash::lock_hash(%h);\n\n\nfor (sort keys %h) { print \"$_ => $h{$_}\\n\"; }\n\n\ndelete $h{b};\nprint \"\\nafter deleting b: b => $h{b}\\n\";\n\n\n$h{a} = 100;\nprint \"\\na => $h{a}\\n\";\n\n\neval { $h{x} = 1 };\nif ($@) { print \"Operation error: $@\" }\n", "target": "from collections import UserDict\nimport copy\n\nclass Dict(UserDict):\n    \n    def __init__(self, dict=None, **kwargs):\n        self.__init = True\n        super().__init__(dict, **kwargs)\n        self.default = copy.deepcopy(self.data)\n        self.__init = False\n    \n    def __delitem__(self, key):\n        if key in self.default:\n            self.data[key] = self.default[key]\n        else:\n            raise NotImplementedError\n\n    def __setitem__(self, key, item):\n        if self.__init:\n            super().__setitem__(key, item)\n        elif key in self.data:\n            self.data[key] = item\n        else:\n            raise KeyError\n\n    def __repr__(self):\n        return \"%s(%s)\" % (type(self).__name__, super().__repr__())\n    \n    def fromkeys(cls, iterable, value=None):\n        if self.__init:\n            super().fromkeys(cls, iterable, value)\n        else:\n            for key in iterable:\n                if key in self.data:\n                    self.data[key] = value\n                else:\n                    raise KeyError\n\n    def clear(self):\n        self.data.update(copy.deepcopy(self.default))\n\n    def pop(self, key, default=None):\n        raise NotImplementedError\n\n    def popitem(self):\n        raise NotImplementedError\n\n    def update(self, E, **F):\n        if self.__init:\n            super().update(E, **F)\n        else:\n            haskeys = False\n            try:\n                keys = E.keys()\n                haskeys = Ture\n            except AttributeError:\n                pass\n            if haskeys:\n                for key in keys:\n                    self[key] = E[key]\n            else:\n                for key, val in E:\n                    self[key] = val\n            for key in F:\n                self[key] = F[key]\n\n    def setdefault(self, key, default=None):\n        if key not in self.data:\n            raise KeyError\n        else:\n            return super().setdefault(key, default)\n"}
{"id": 383503, "name": "Decimal floating point number to binary", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub dec2bin {\n    my($l,$r) = split /\\./, shift;\n    my $int  = unpack('B*',  pack('N',               $l ));\n    my $frac = unpack('B32', pack('N',4294967296 * \".$r\"));\n    \"$int.$frac\" =~ s/^0*(.*?)0*$/$1/r;\n}\n\nsub bin2dec {\n    my($l,$r) = split /\\./, shift;\n    my $frac = my $i = 0;\n    --$i, $frac += $_ * 2**$i for split '', $r;\n    eval('0b'.$l) + $frac;\n}\n\nsay dec2bin(23.34375);\nsay bin2dec('1011.11101');\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 383504, "name": "Decimal floating point number to binary", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub dec2bin {\n    my($l,$r) = split /\\./, shift;\n    my $int  = unpack('B*',  pack('N',               $l ));\n    my $frac = unpack('B32', pack('N',4294967296 * \".$r\"));\n    \"$int.$frac\" =~ s/^0*(.*?)0*$/$1/r;\n}\n\nsub bin2dec {\n    my($l,$r) = split /\\./, shift;\n    my $frac = my $i = 0;\n    --$i, $frac += $_ * 2**$i for split '', $r;\n    eval('0b'.$l) + $frac;\n}\n\nsay dec2bin(23.34375);\nsay bin2dec('1011.11101');\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 383505, "name": "Free polyominoes enumeration", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy @new = \"\n\nfor my $N ( 2 .. 10 )\n  {\n  @new = find( @new );\n  my %allbest;\n  $allbest{best($_)}++ for @new;\n  my @show = @new = sort keys %allbest;\n  printf \"rank: %2d  count: %d\\n\\n\", $N, scalar @show;\n  if( @show <= 12 )\n    {\n    my $fmt = join '', map({ /\\n/; '%' . ($+[0] + 1) . 's' } @show), \"\\n\";\n    grep $_, @show and printf $fmt, map s/(.*)\\n// && $1, @show for 0 .. $N;\n    print \"\\n\";\n    }\n  }\n\nsub bare\n  {\n  local $_ = shift;\n  s/^ *\\n//gm;\n  s/^ //gm until /^\n  s/ $//gm until /\n  $_;\n  }\n\nsub transpose\n  {\n  local $_ = shift;\n  my $t = '';\n  $t .= \"\\n\" while s/^./ $t .= $&; '' /gem;\n  $t;\n  }\n\nsub rotate\n  {\n  local $_ = shift;\n  my $t = '';\n  $t .= \"\\n\" while s/.$/ $t .= $&; '' /gem;\n  $t;\n  }\n\nsub best\n  {\n  my %all = (shift, 1);\n  for my $p (keys %all)\n    {\n    $all{ my $tmp = rotate $p }++;\n    $all{ rotate $tmp }++;\n    }\n  $all{ transpose $_ }++ for keys %all;\n  $all{ s/(.+)/reverse $1/ger }++ for keys %all;        \n  (sort keys %all)[-1];\n  }\n\nsub find\n  {\n  my @before = @_;\n  my %new;\n  for my $p ( @before )\n    {\n    local $_ = $p;\n    s/^/ /gm;\n    s/\\n/ \\n/g;\n    my $line = s/\\n.*/\\n/sr =~ tr/\\n/ /cr;\n    $_ = $line . $_ . $line;\n    my $n = -1 + length $line;\n    my $gap = qr/.{$n}/s;\n    $new{ bare \"$`\n    $new{ bare \"$`\n    $new{ bare \"$`\n    $new{ bare \"$`\n    }\n  keys %new;\n  }\n", "target": "from itertools import imap, imap, groupby, chain, imap\nfrom operator import itemgetter\nfrom sys import argv\nfrom array import array\n\ndef concat_map(func, it):\n    return list(chain.from_iterable(imap(func, it)))\n\ndef minima(poly):\n    \n    return (min(pt[0] for pt in poly), min(pt[1] for pt in poly))\n\ndef translate_to_origin(poly):\n    (minx, miny) = minima(poly)\n    return [(x - minx, y - miny) for (x, y) in poly]\n\nrotate90   = lambda (x, y): ( y, -x)\nrotate180  = lambda (x, y): (-x, -y)\nrotate270  = lambda (x, y): (-y,  x)\nreflect    = lambda (x, y): (-x,  y)\n\ndef rotations_and_reflections(poly):\n    \n    return (poly,\n            map(rotate90, poly),\n            map(rotate180, poly),\n            map(rotate270, poly),\n            map(reflect, poly),\n            [reflect(rotate90(pt)) for pt in poly],\n            [reflect(rotate180(pt)) for pt in poly],\n            [reflect(rotate270(pt)) for pt in poly])\n\ndef canonical(poly):\n    return min(sorted(translate_to_origin(pl)) for pl in rotations_and_reflections(poly))\n\ndef unique(lst):\n    lst.sort()\n    return map(next, imap(itemgetter(1), groupby(lst)))\n\n\ncontiguous = lambda (x, y): [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\ndef new_points(poly):\n    \n    return unique([pt for pt in concat_map(contiguous, poly) if pt not in poly])\n\ndef new_polys(poly):\n    return unique([canonical(poly + [pt]) for pt in new_points(poly)])\n\nmonomino = [(0, 0)]\nmonominoes = [monomino]\n\ndef rank(n):\n    \n    assert n >= 0\n    if n == 0: return []\n    if n == 1: return monominoes\n    return unique(concat_map(new_polys, rank(n - 1)))\n\ndef text_representation(poly):\n    \n    min_pt = minima(poly)\n    max_pt = (max(p[0] for p in poly), max(p[1] for p in poly))\n    table = [array('c', ' ') * (max_pt[1] - min_pt[1] + 1)\n             for _ in xrange(max_pt[0] - min_pt[0] + 1)]\n    for pt in poly:\n        table[pt[0] - min_pt[0]][pt[1] - min_pt[1]] = '\n    return \"\\n\".join(row.tostring() for row in table)\n\ndef main():\n    print [len(rank(n)) for n in xrange(1, 11)]\n\n    n = int(argv[1]) if (len(argv) == 2) else 5\n    print \"\\nAll free polyominoes of rank %d:\" % n\n\n    for poly in rank(n):\n        print text_representation(poly), \"\\n\"\n\nmain()\n"}
{"id": 383506, "name": "Natural sorting", "source": "Translate Perl to Python: use feature 'fc';\nuse Unicode::Normalize;\n\nsub natural_sort {\n    my @items = map {\n        my $str = fc(NFKD($_));\n        $str =~ s/\\s+/ /;\n        $str =~ s/|^(?:the|a|an) \\b|\\p{Nonspacing_Mark}| $//g;\n        my @fields = $str =~ /(?!\\z) ([^0-9]*+) ([0-9]*+)/gx;\n        [$_, \\@fields]\n    } @_;\n    return map { $_->[0] } sort {\n        my @x = @{$a->[1]};\n        my @y = @{$b->[1]};\n        my $numeric;\n        while (@x && @y) {\n            my ($x, $y) = (shift @x, shift @y);\n            return (($numeric = !$numeric) ? $x cmp $y : $x <=> $y or next);\n        }\n        return @x <=> @y;\n    } @items;\n}\n", "target": "\n\n\n\nfrom itertools import groupby\nfrom unicodedata import decomposition, name\nfrom pprint import pprint as pp\n\ncommonleaders = ['the'] \nreplacements = {u'\u00df': 'ss',  \n                u'\u017f': 's',\n                u'\u0292': 's',\n                }\n\nhexdigits = set('0123456789abcdef')\ndecdigits = set('0123456789')   \n\ndef splitchar(c):\n    ' De-ligature. De-accent a char'\n    de = decomposition(c)\n    if de:\n        \n        de = [d for d in de.split()\n                  if all(c.lower()\n                         in hexdigits for c in d)]\n        n = name(c, c).upper()\n        \n        if len(de)> 1 and 'PRECEDE' in n:\n            \n            de[1], de[0] = de[0], de[1]\n        tmp = [ unichr(int(k, 16)) for k in de]\n        base, others = tmp[0], tmp[1:]\n        if 'LIGATURE' in n:\n            \n            base += others.pop(0)\n    else:\n        base = c\n    return base\n    \n\ndef sortkeygen(s):\n    \n    \n    s = unicode(s).strip()\n    \n    s = ' '.join(s.split())\n    \n    s = s.lower()\n    \n    words = s.split()\n    if len(words) > 1 and words[0] in commonleaders:\n        s = ' '.join( words[1:])\n    \n    s = ''.join(splitchar(c) for c in s)\n    \n    s = ''.join( replacements.get(ch, ch) for ch in s )\n    \n    s = [ int(\"\".join(g)) if isinteger else \"\".join(g)\n          for isinteger,g in groupby(s, lambda x: x in decdigits)]\n\n    return s\n\ndef naturalsort(items):\n    \n    return sorted(items, key=sortkeygen)\n\nif __name__ == '__main__':\n    import string\n    \n    ns = naturalsort\n\n    print '\\n\n    txt = ['%signore leading spaces: 2%+i' % (' '*i, i-2) for i in range(4)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['ignore m.a.s%s spaces: 2%+i' % (' '*i, i-2) for i in range(4)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['Equiv.%sspaces: 3%+i' % (ch, i-3)\n           for i,ch in enumerate(reversed(string.whitespace))]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    s = 'CASE INDEPENENT'\n    txt = [s[:i].lower() + s[i:] + ': 3%+i' % (i-3) for i in range(1,5)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['foo100bar99baz0.txt', 'foo100bar10baz0.txt',\n           'foo1000bar99baz10.txt', 'foo1000bar99baz9.txt']\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['The Wind in the Willows','The 40th step more',\n                         'The 39 steps', 'Wanda']\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['Equiv. %s accents: 2%+i' % (ch, i-2)\n           for i,ch in enumerate(u'\\xfd\\xddyY')]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = [u'\\462 ligatured ij', 'no ligature',]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n    \n    print '\\n\n    s = u'\u0292\u017f\u00dfs' \n    txt = ['Start with an %s: 2%+i' % (ch, i-2)\n           for i,ch in enumerate(s)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; print '\\n'.join(sorted(txt))\n    print 'Naturally sorted:'; print '\\n'.join(ns(txt))\n"}
{"id": 383507, "name": "Canny edge detector", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse lib '/home/hkdtam/lib';\nuse Image::EdgeDetect;\n\nmy $detector = Image::EdgeDetect->new();\n$detector->process('./input.jpg', './output.jpg') or die; \n", "target": "\nimport numpy as np\nfrom scipy.ndimage.filters import convolve, gaussian_filter\nfrom scipy.misc import imread, imshow\n\t\ndef CannyEdgeDetector(im, blur = 1, highThreshold = 91, lowThreshold = 31):\n\tim = np.array(im, dtype=float) \n \n\t\n\tim2 = gaussian_filter(im, blur)\n\n\t\n\tim3h = convolve(im2,[[-1,0,1],[-2,0,2],[-1,0,1]]) \n\tim3v = convolve(im2,[[1,2,1],[0,0,0],[-1,-2,-1]])\n\n\t\n\tgrad = np.power(np.power(im3h, 2.0) + np.power(im3v, 2.0), 0.5)\n\ttheta = np.arctan2(im3v, im3h)\n\tthetaQ = (np.round(theta * (5.0 / np.pi)) + 5) % 5 \n\n\t\n\tgradSup = grad.copy()\n\tfor r in range(im.shape[0]):\n\t\tfor c in range(im.shape[1]):\n\t\t\t\n\t\t\tif r == 0 or r == im.shape[0]-1 or c == 0 or c == im.shape[1] - 1:\n\t\t\t\tgradSup[r, c] = 0\n\t\t\t\tcontinue\n\t\t\ttq = thetaQ[r, c] % 4\n\n\t\t\tif tq == 0: \n\t\t\t\tif grad[r, c] <= grad[r, c-1] or grad[r, c] <= grad[r, c+1]:\n\t\t\t\t\tgradSup[r, c] = 0\n\t\t\tif tq == 1: \n\t\t\t\tif grad[r, c] <= grad[r-1, c+1] or grad[r, c] <= grad[r+1, c-1]:\n\t\t\t\t\tgradSup[r, c] = 0\n\t\t\tif tq == 2: \n\t\t\t\tif grad[r, c] <= grad[r-1, c] or grad[r, c] <= grad[r+1, c]:\n\t\t\t\t\tgradSup[r, c] = 0\n\t\t\tif tq == 3: \n\t\t\t\tif grad[r, c] <= grad[r-1, c-1] or grad[r, c] <= grad[r+1, c+1]:\n\t\t\t\t\tgradSup[r, c] = 0\n\n\t\n\tstrongEdges = (gradSup > highThreshold)\n\n\t\n\tthresholdedEdges = np.array(strongEdges, dtype=np.uint8) + (gradSup > lowThreshold)\n\n\t\n\t\n\tfinalEdges = strongEdges.copy()\n\tcurrentPixels = []\n\tfor r in range(1, im.shape[0]-1):\n\t\tfor c in range(1, im.shape[1]-1):\t\n\t\t\tif thresholdedEdges[r, c] != 1:\n\t\t\t\tcontinue \n\t\t\t\n\t\t\t\n\t\t\tlocalPatch = thresholdedEdges[r-1:r+2,c-1:c+2]\n\t\t\tpatchMax = localPatch.max()\n\t\t\tif patchMax == 2:\n\t\t\t\tcurrentPixels.append((r, c))\n\t\t\t\tfinalEdges[r, c] = 1\n\n\t\n\twhile len(currentPixels) > 0:\n\t\tnewPix = []\n\t\tfor r, c in currentPixels:\n\t\t\tfor dr in range(-1, 2):\n\t\t\t\tfor dc in range(-1, 2):\n\t\t\t\t\tif dr == 0 and dc == 0: continue\n\t\t\t\t\tr2 = r+dr\n\t\t\t\t\tc2 = c+dc\n\t\t\t\t\tif thresholdedEdges[r2, c2] == 1 and finalEdges[r2, c2] == 0:\n\t\t\t\t\t\t\n\t\t\t\t\t\tnewPix.append((r2, c2))\n\t\t\t\t\t\tfinalEdges[r2, c2] = 1\n\t\tcurrentPixels = newPix\n\n\treturn finalEdges\n\nif __name__==\"__main__\":\n\tim = imread(\"test.jpg\", mode=\"L\") \n\tfinalEdges = CannyEdgeDetector(im)\n\timshow(finalEdges)\n"}
{"id": 383508, "name": "Deconvolution_2D+", "source": "Translate Perl to Python: use feature 'say';\nuse ntheory qw/forsetproduct/;\n\n\nsub deconvolve_N {\n    our @g; local *g = shift;\n    our @f; local *f = shift;\n    my @df = shape(@f);\n    my @dg = shape(@g);\n    my @hsize;\n    push @hsize, $dg[$_] - $df[$_] + 1 for 0..$\n    my @toSolve = map { [row(\\@g, \\@f, \\@hsize, $_)] } coords(shape(@g));\n    rref( \\@toSolve );\n\n    my @h;\n    my $n = 0;\n    for (coords(@hsize)) {\n        my($k,$j,$i) = split ' ', $_;\n        $h[$i][$j][$k] = $toSolve[$n++][-1];\n    }\n    @h;\n}\n\nsub row {\n    our @g;      local *g      = shift;\n    our @f;      local *f      = shift;\n    our @hsize;  local *hsize  = shift;\n    my @gc = reverse split ' ', shift;\n\n    my @row;\n    my @fdim = shape(@f);\n    for (coords(@hsize)) {\n        my @hc = reverse split ' ', $_;\n        my @fc;\n        for my $i (0..$\n            my $window = $gc[$i] - $hc[$i];\n            push(@fc, $window), next if 0 <= $window && $window < $fdim[$i];\n        }\n        push @row, $\n    }\n    push @row, $g [$gc[0]] [$gc[1]] [$gc[2]];\n    return @row;\n}\n\nsub rref {\n  our @m; local *m = shift;\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n\n      ++$lead;}\n}\n\n\nsub coords {\n    my(@dimensions) = reverse @_;\n    my(@ranges,@coords);\n    push @ranges, [0..$_-1] for @dimensions;\n    forsetproduct { push @coords, \"@_\" } @ranges;\n    @coords;\n}\n\nsub shape {\n    my(@dim);\n    push @dim, scalar @_;\n    push @dim, shape(@{$_[0]}) if 'ARRAY' eq ref $_[0];\n    @dim;\n}\n\n\n\nsub pretty_print {\n    my($i, @a) = @_;\n    if ('ARRAY' eq ref $a[0]) {\n        say ' 'x$i, '[';\n        pretty_print($i+2, @$_) for @a;\n        say ' 'x$i, ']', $i ? ',' : '';\n    } else {\n        say ' 'x$i, '[', sprintf(\"@{['%5s'x@a]}\",@a), ']', $i ? ',' : '';\n    }\n}\n\nmy @f = (\n  [\n    [ -9,  5, -8 ],\n    [  3,  5,  1 ],\n  ],\n  [\n    [ -1, -7,  2 ],\n    [ -5, -6,  6 ],\n  ],\n  [\n    [  8,  5,  8 ],\n    [ -2, -6, -4 ],\n  ]\n);\n\nmy @g = (\n  [\n    [  54,  42,  53, -42,  85, -72 ],\n    [  45,-170,  94, -36,  48,  73 ],\n    [ -39,  65,-112, -16, -78, -72 ],\n    [   6, -11,  -6,  62,  49,   8 ],\n  ],\n  [\n    [ -57,  49, -23,  52,-135,  66 ],\n    [ -23, 127, -58,  -5,-118,  64 ],\n    [  87, -16, 121,  23, -41, -12 ],\n    [ -19,  29,  35,-148, -11,  45 ],\n  ],\n  [\n    [ -55,-147,-146, -31,  55,  60 ],\n    [ -88, -45, -28,  46, -26,-144 ],\n    [ -12,-107, -34, 150, 249,  66 ],\n    [  11, -15, -34,  27, -78, -50 ],\n  ],\n  [\n    [  56,  67, 108,   4,   2, -48 ],\n    [  58,  67,  89,  32,  32,  -8 ],\n    [ -42, -31,-103, -30, -23,  -8 ],\n    [   6,   4, -26, -10,  26,  12 ],\n  ]\n);\n\nmy @h  = deconvolve_N( \\@g, \\@f );\nmy @ff = deconvolve_N( \\@g, \\@h );\n\nmy $d = scalar shape(@g);\nprint \"${d}D arrays:\\n\";\nprint \"h =\\n\";\npretty_print(0,@h);\nprint \"\\nff =\\n\";\npretty_print(0,@ff);\n", "target": "\n\nimport numpy\nimport pprint\n\nh =  [\n      [[-6, -8, -5, 9], [-7, 9, -6, -8], [2, -7, 9, 8]], \n      [[7, 4, 4, -6], [9, 9, 4, -4], [-3, 7, -2, -3]]]\nf =  [\n      [[-9, 5, -8], [3, 5, 1]], \n      [[-1, -7, 2], [-5, -6, 6]], \n      [[8, 5, 8],[-2, -6, -4]]]\ng =  [\n      [\n         [54, 42, 53, -42, 85, -72], \n         [45, -170, 94, -36, 48, 73], \n         [-39, 65, -112, -16, -78, -72], \n         [6, -11, -6, 62, 49, 8]], \n      [\n         [-57, 49, -23, 52, -135, 66], \n         [-23, 127, -58, -5, -118, 64], \n         [87, -16, 121, 23, -41, -12], \n         [-19, 29, 35, -148, -11, 45]], \n      [\n         [-55, -147, -146, -31, 55, 60], \n         [-88, -45, -28, 46, -26, -144], \n         [-12, -107, -34, 150, 249, 66], \n         [11, -15, -34, 27, -78, -50]], \n      [\n         [56, 67, 108, 4, 2, -48], \n         [58, 67, 89, 32, 32, -8], \n         [-42, -31, -103, -30, -23, -8],\n         [6, 4, -26, -10, 26, 12]]]\n      \ndef trim_zero_empty(x):\n    \n    \n    if len(x) > 0:\n        if type(x[0]) != numpy.ndarray:\n            \n            return list(numpy.trim_zeros(x))\n        else:\n            \n            new_x = []\n            for l in x:\n               tl = trim_zero_empty(l)\n               if len(tl) > 0:\n                   new_x.append(tl)\n            return new_x\n    else:\n        \n        return x\n       \ndef deconv(a, b):\n    \n    \n    \n\n    ffta = numpy.fft.fftn(a)\n    \n    \n    \n    \n    ashape = numpy.shape(a)\n    \n    \n    \n\n    fftb = numpy.fft.fftn(b,ashape)\n    \n    \n\n    fftquotient = ffta / fftb\n    \n    \n    \n\n    c = numpy.fft.ifftn(fftquotient)\n    \n    \n    \n\n    trimmedc = numpy.around(numpy.real(c),decimals=6)\n    \n    \n    \n    \n    cleanc = trim_zero_empty(trimmedc)\n                \n    return cleanc\n    \nprint(\"deconv(g,h)=\")\n\npprint.pprint(deconv(g,h))\n\nprint(\" \")\n\nprint(\"deconv(g,f)=\")\n\npprint.pprint(deconv(g,f))\n"}
{"id": 383509, "name": "OpenWebNet password", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse integer; \n\nsub own_password {\n    my($password, $nonce) = @_;\n    my $n1 = 0;\n    my $n2 = $password;\n    for my $d (split //, $nonce) {\n        if      ($d == 1) {\n            $n1   = ($n2 & 0xFFFFFF80) >> 7;\n            $n2 <<= 25;\n        } elsif ($d == 2) {\n            $n1   = ($n2 & 0xFFFFFFF0) >> 4;\n            $n2 <<= 28;\n        } elsif ($d == 3) {\n            $n1   = ($n2 & 0xFFFFFFF8) >> 3;\n            $n2 <<= 29;\n        } elsif ($d == 4) {\n            $n1   = $n2 << 1;\n            $n2 >>= 31;\n        } elsif ($d == 5) {\n            $n1   = $n2 << 5;\n            $n2 >>= 27;\n        } elsif ($d == 6) {\n            $n1   = $n2 << 12;\n            $n2 >>= 20;\n        } elsif ($d == 7) {\n            $n1 = ($n2 & 0x0000FF00) | (($n2 & 0x000000FF) << 24) | (($n2 & 0x00FF0000) >> 16);\n            $n2 = ($n2 & 0xFF000000) >> 8;\n        } elsif ($d == 8) {\n            $n1 = ($n2 & 0x0000FFFF) << 16 | $n2 >> 24;\n            $n2 = ($n2 & 0x00FF0000) >> 8;\n        } elsif ($d == 9) {\n            $n1 = ~$n2;\n        } else {\n            $n1 = $n2\n        }\n        $n1 = ($n1 | $n2) & 0xFFFFFFFF if $d != 0 and $d != 9;\n        $n2 = $n1;\n    }\n    $n1\n}\n\nsay own_password( 12345, 603356072 );\nsay own_password( 12345, 410501656 );\nsay own_password( 12345, 630292165 );\n", "target": "def ownCalcPass (password, nonce, test=False) :\n    start = True    \n    num1 = 0\n    num2 = 0\n    password = int(password)\n    if test:\n        print(\"password: %08x\" % (password))\n    for c in nonce :\n        if c != \"0\":\n            if start:\n                num2 = password\n            start = False\n        if test:\n            print(\"c: %s num1: %08x num2: %08x\" % (c, num1, num2))\n        if c == '1':\n            num1 = (num2 & 0xFFFFFF80) >> 7\n            num2 = num2 << 25\n        elif c == '2':\n            num1 = (num2 & 0xFFFFFFF0) >> 4\n            num2 = num2 << 28\n        elif c == '3':\n            num1 = (num2 & 0xFFFFFFF8) >> 3\n            num2 = num2 << 29\n        elif c == '4':\n            num1 = num2 << 1\n            num2 = num2 >> 31\n        elif c == '5':\n            num1 = num2 << 5\n            num2 = num2 >> 27\n        elif c == '6':\n            num1 = num2 << 12\n            num2 = num2 >> 20\n        elif c == '7':\n            num1 = num2 & 0x0000FF00 | (( num2 & 0x000000FF ) << 24 ) | (( num2 & 0x00FF0000 ) >> 16 )\n            num2 = ( num2 & 0xFF000000 ) >> 8\n        elif c == '8':\n            num1 = (num2 & 0x0000FFFF) << 16 | ( num2 >> 24 )\n            num2 = (num2 & 0x00FF0000) >> 8\n        elif c == '9':\n            num1 = ~num2\n        else :\n            num1 = num2\n\n        num1 &= 0xFFFFFFFF\n        num2 &= 0xFFFFFFFF\n        if (c not in \"09\"):\n            num1 |= num2\n        if test:\n            print(\"     num1: %08x num2: %08x\" % (num1, num2))\n        num2 = num1\n    return num1\n\ndef test_passwd_calc(passwd, nonce, expected):\n    res = ownCalcPass(passwd, nonce, False)\n    m = passwd+' '+nonce+' '+str(res)+' '+str(expected)\n    if res == int(expected) :\n        print('PASS '+m)\n    else :\n        print('FAIL '+m)\n\nif __name__ == '__main__':\n    test_passwd_calc('12345','603356072','25280520')\n    test_passwd_calc('12345','410501656','119537670')\n    test_passwd_calc('12345','630292165','4269684735')\n"}
{"id": 383510, "name": "Particle swarm optimization", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse constant PI  => 2 * atan2(1, 0);\nuse constant Inf => 1e10;\n\nsub pso_init {\n    my(%y) = @_;\n    my $d = @{$y{'min'}};\n    my $n = $y{'n'};\n\n    $y{'gbval'} = Inf;\n    $y{'gbpos'} = [(Inf) x $d];\n    $y{'bval'}  = [(Inf) x $n];\n    $y{'bpos'}  = [($y{'min'}) x $n];\n    $y{'pos'}   = [($y{'min'}) x $n];\n    $y{'vel'}   = [([(0) x $d]) x $n];\n\n    %y\n}\n\nsub pso {\n    my($fn, %y) = @_;\n    my $p      = $y{'p'};\n    my $n      = $y{'n'};\n    my $d      = @{$y{'min'}};\n    my @bpos   = ($y{'min'}) x $n;\n    my $gbval  = Inf;\n    my $rand_g = rand;\n    my (@pos, @vel, @v, @gbpos, @bval);\n\n    for my $j (0 .. $n-1) {\n        $v[$j] = &$fn(@{$y{'pos'}[$j]}); \n\n        \n        if ($v[$j] < $y{'bval'}[$j]) {\n            $bpos[$j] = $y{'pos'}[$j];\n            $bval[$j] = $v[$j];\n        } else {\n            $bpos[$j] = $y{'bpos'}[$j];\n            $bval[$j] = $y{'bval'}[$j];\n        }\n        if ($bval[$j] < $gbval) {\n            @gbpos = @{$bpos[$j]};\n            $gbval = $bval[$j];\n        }\n    }\n\n    \n    for my $j (0 .. $n-1) {\n        my $rand_p = rand;\n        my $ok = 1;\n        for my $k (0 .. $d-1) {\n            $vel[$j][$k] = $$p{'omega'} * $y{'vel'}[$j][$k]\n                       + $$p{'phi_p'} * $rand_p * ($bpos[$j][$k] - $y{'pos'}[$j][$k])\n                       + $$p{'phi_g'} * $rand_g * ($gbpos[$k]    - $y{'pos'}[$j][$k]);\n            $pos[$j][$k] = $y{'pos'}[$j][$k] + $vel[$j][$k];\n            $ok = ($y{'min'}[$k] < $pos[$j][$k]) && ($pos[$j][$k] < $y{'max'}[$k]) && $ok;\n        }\n        next if $ok;\n        $pos[$j][$_] = $y{'min'}[$_] + ($y{'max'}[$_] - $y{'min'}[$_]) * rand for 0 .. $d-1;\n    }\n    return {gbpos => \\@gbpos, gbval => $gbval, bpos => \\@bpos, bval => \\@bval, pos => \\@pos, vel => \\@vel,\n               min => $y{'min'}, max => $y{'max'}, p=> $y{'p'}, n => $n};\n}\n\nsub report {\n    my($function_name, %state) = @_;\n    say $function_name;\n    say 'Global best position: ' . sprintf \"%.5f\u00a0%.5f\", @{$state{'gbpos'}};\n    say 'Global best value:    ' . sprintf \"%.5f\",      $state{'gbval'};\n    say '';\n}\n\n\nsub mccormick {\n    my($a,$b) = @_;\n    sin($a+$b) + ($a-$b)**2 + (1 + 2.5*$b - 1.5*$a)\n}\n\nmy %state = pso_init( (\n    min => [-1.5, -3],\n    max => [4, 4],\n    n   => 100,\n    p   => {omega => 0, phi_p => 0.6, phi_g => 0.3},\n) );\n%state = %{pso(\\&mccormick, %state)} for 1 .. 40;\nreport('McCormick', %state);\n\n\nsub michalewicz {\n    my(@x) = @_;\n    my $sum;\n    my $m = 10;\n    for my $i (1..@x) {\n        my $j = $x[$i - 1];\n        my $k = sin($i * $j**2/PI);\n        $sum += sin($j) * $k**(2*$m)\n    }\n    -$sum\n}\n\n%state = pso_init( (\n    min => [0, 0],\n    max => [PI, PI],\n    n   => 1000,\n    p   => {omega => 0.3, phi_p => 0.3, phi_g => 0.3},\n) );\n%state = %{pso(\\&michalewicz, %state)} for 1 .. 30;\nreport('Michalewicz', %state);\n", "target": "import math\nimport random\n\nINFINITY = 1 << 127\nMAX_INT = 1 << 31\n\nclass Parameters:\n    def __init__(self, omega, phip, phig):\n        self.omega = omega\n        self.phip = phip\n        self.phig = phig\n\nclass State:\n    def __init__(self, iter, gbpos, gbval, min, max, parameters, pos, vel, bpos, bval, nParticles, nDims):\n        self.iter = iter\n        self.gbpos = gbpos\n        self.gbval = gbval\n        self.min = min\n        self.max = max\n        self.parameters = parameters\n        self.pos = pos\n        self.vel = vel\n        self.bpos = bpos\n        self.bval = bval\n        self.nParticles = nParticles\n        self.nDims = nDims\n\n    def report(self, testfunc):\n        print \"Test Function\u00a0:\", testfunc\n        print \"Iterations   \u00a0:\", self.iter\n        print \"Global Best Position\u00a0:\", self.gbpos\n        print \"Global Best Value   \u00a0: %.16f\" % self.gbval\n\ndef uniform01():\n    v = random.random()\n    assert 0.0 <= v and v < 1.0\n    return v\n\ndef psoInit(min, max, parameters, nParticles):\n    nDims = len(min)\n    pos = [min[:]] * nParticles\n    vel = [[0.0] * nDims] * nParticles\n    bpos = [min[:]] * nParticles\n    bval = [INFINITY] * nParticles\n    iter = 0\n    gbpos = [INFINITY] * nDims\n    gbval = INFINITY\n    return State(iter, gbpos, gbval, min, max, parameters, pos, vel, bpos, bval, nParticles, nDims);\n\ndef pso(fn, y):\n    p = y.parameters\n    v = [0.0] * (y.nParticles)\n    bpos = [y.min[:]] * (y.nParticles)\n    bval = [0.0] * (y.nParticles)\n    gbpos = [0.0] * (y.nDims)\n    gbval = INFINITY\n    for j in xrange(0, y.nParticles):\n        \n        v[j] = fn(y.pos[j])\n        \n        if v[j] < y.bval[j]:\n            bpos[j] = y.pos[j][:]\n            bval[j] = v[j]\n        else:\n            bpos[j] = y.bpos[j][:]\n            bval[j] = y.bval[j]\n        if bval[j] < gbval:\n            gbval = bval[j]\n            gbpos = bpos[j][:]\n    rg = uniform01()\n    pos = [[None] * (y.nDims)] * (y.nParticles)\n    vel = [[None] * (y.nDims)] * (y.nParticles)\n    for j in xrange(0, y.nParticles):\n        \n        rp = uniform01()\n        ok = True\n        vel[j] = [0.0] * (len(vel[j]))\n        pos[j] = [0.0] * (len(pos[j]))\n        for k in xrange(0, y.nDims):\n            vel[j][k] = p.omega * y.vel[j][k] \\\n                      + p.phip * rp * (bpos[j][k] - y.pos[j][k]) \\\n                      + p.phig * rg * (gbpos[k] - y.pos[j][k])\n            pos[j][k] = y.pos[j][k] + vel[j][k]\n            ok = ok and y.min[k] < pos[j][k] and y.max[k] > pos[j][k]\n        if not ok:\n            for k in xrange(0, y.nDims):\n                pos[j][k] = y.min[k] + (y.max[k] - y.min[k]) * uniform01()\n    iter = 1 + y.iter\n    return State(iter, gbpos, gbval, y.min, y.max, y.parameters, pos, vel, bpos, bval, y.nParticles, y.nDims);\n\ndef iterate(fn, n, y):\n    r = y\n    old = y\n    if n == MAX_INT:\n        while True:\n            r = pso(fn, r)\n            if r == old:\n                break\n            old = r\n    else:\n        for _ in xrange(0, n):\n            r = pso(fn, r)\n    return r\n\ndef mccormick(x):\n    (a, b) = x\n    return math.sin(a + b) + (a - b) * (a - b) + 1.0 + 2.5 * b - 1.5 * a\n\ndef michalewicz(x):\n    m = 10\n    d = len(x)\n    sum = 0.0\n    for i in xrange(1, d):\n        j = x[i - 1]\n        k = math.sin(i * j * j / math.pi)\n        sum += math.sin(j) * k ** (2.0 * m)\n    return -sum\n\ndef main():\n    state = psoInit([-1.5, -3.0], [4.0, 4.0], Parameters(0.0, 0.6, 0.3), 100)\n    state = iterate(mccormick, 40, state)\n    state.report(\"McCormick\")\n    print \"f(-.54719, -1.54719)\u00a0: %.16f\" % (mccormick([-.54719, -1.54719]))\n\n    print\n\n    state = psoInit([0.0, 0.0], [math.pi, math.pi], Parameters(0.3, 0.3, 0.3), 1000)\n    state = iterate(michalewicz, 30, state)\n    state.report(\"Michalewicz (2D)\")\n    print \"f(2.20, 1.57)       \u00a0: %.16f\" % (michalewicz([2.2, 1.57]))\n\nmain()\n"}
{"id": 383511, "name": "Solve triangle solitare puzzle", "source": "Translate Perl to Python: @start = qw<\n        0\n       1 1\n      1 1 1\n     1 1 1 1\n    1 1 1 1 1\n>;\n\n@moves = (\n    [ 0, 1, 3], [ 0, 2, 5], [ 1, 3, 6],\n    [ 1, 4, 8], [ 2, 4, 7], [ 2, 5, 9],\n    [ 3, 4, 5], [ 3, 6,10], [ 3, 7,12],\n    [ 4, 7,11], [ 4, 8,13], [ 5, 8,12],\n    [ 5, 9,14], [ 6, 7, 8], [ 7, 8, 9],\n    [10,11,12], [11,12,13], [12,13,14]\n);\n\n$format .= (\" \" x (5-$_)) . (\"%d \" x $_) . \"\\n\" for 1..5;\n\nsub solve {\n    my ($move, $turns, @board) = @_;\n    $turns = 1 unless $turns;\n    return \"\\nSolved\" if $turns + 1 == @board;\n    return undef if $board[$$move[1]] == 0;\n    my $valid = do  {\n        if ($board[$$move[0]] == 0) {\n            return undef if $board[$$move[2]] == 0;\n            \"\\nmove $$move[2] to $$move[0]\\n\";\n        } else {\n            return undef if $board[$$move[2]] == 1;\n            \"\\nmove $$move[0] to $$move[2]\\n\";\n        }\n    };\n\n    my $new_result;\n    my @new_layout = @board;\n    @new_layout[$_] = 1 - @new_layout[$_] for @$move;\n    for $this_move (@moves) {\n        $new_result = solve(\\@$this_move, $turns + 1, @new_layout);\n        last if $new_result\n    }\n    $new_result ? \"$valid\\n\" . sprintf($format, @new_layout) . $new_result : $new_result}\n\n$result = \"Starting with\\n\\n\" . sprintf($format, @start), \"\\n\";\n\nfor $this_move (@moves) {\n    $result .= solve(\\@$this_move, 1, @start);\n    last if $result\n}\n\nprint $result ? $result : \"No solution found\";\n", "target": "\n\n\ndef DrawBoard(board):\n  peg = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n  for n in xrange(1,16):\n    peg[n] = '.'\n    if n in board:\n      peg[n] = \"%X\" % n\n  print \"     %s\" % peg[1]\n  print \"    %s %s\" % (peg[2],peg[3])\n  print \"   %s %s %s\" % (peg[4],peg[5],peg[6])\n  print \"  %s %s %s %s\" % (peg[7],peg[8],peg[9],peg[10])\n  print \" %s %s %s %s %s\" % (peg[11],peg[12],peg[13],peg[14],peg[15])\n\n\n\ndef RemovePeg(board,n):\n  board.remove(n)\n\n\ndef AddPeg(board,n):\n  board.append(n)\n\n\ndef IsPeg(board,n):\n  return n in board\n\n\n\nJumpMoves = { 1: [ (2,4),(3,6) ],  \n              2: [ (4,7),(5,9)  ],\n              3: [ (5,8),(6,10) ],\n              4: [ (2,1),(5,6),(7,11),(8,13) ],\n              5: [ (8,12),(9,14) ],\n              6: [ (3,1),(5,4),(9,13),(10,15) ],\n              7: [ (4,2),(8,9)  ],\n              8: [ (5,3),(9,10) ],\n              9: [ (5,2),(8,7)  ],\n             10: [ (9,8) ],\n             11: [ (12,13) ],\n             12: [ (8,5),(13,14) ],\n             13: [ (8,4),(9,6),(12,11),(14,15) ],\n             14: [ (9,5),(13,12)  ],\n             15: [ (10,6),(14,13) ]\n            }\n\nSolution = []\n\n\n\ndef Solve(board):\n  \n  if len(board) == 1:\n    return board \n  \n  for peg in xrange(1,16): \n    if IsPeg(board,peg):\n      movelist = JumpMoves[peg]\n      for over,land in movelist:\n        if IsPeg(board,over) and not IsPeg(board,land):\n          saveboard = board[:] \n          RemovePeg(board,peg)\n          RemovePeg(board,over)\n          AddPeg(board,land) \n\n          Solution.append((peg,over,land))\n\n          board = Solve(board)\n          if len(board) == 1:\n            return board\n        \n          board = saveboard[:] \n          del Solution[-1] \n  return board\n\n\n\n\ndef InitSolve(empty):\n  board = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n  RemovePeg(board,empty_start)\n  Solve(board)\n\n\nempty_start = 1\nInitSolve(empty_start)\n\nboard = [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\nRemovePeg(board,empty_start)\nfor peg,over,land in Solution:\n  RemovePeg(board,peg)\n  RemovePeg(board,over)\n  AddPeg(board,land) \n  DrawBoard(board)\n  print \"Peg %X jumped over %X to land on %X\\n\" % (peg,over,land)\n"}
{"id": 383512, "name": "SHA-256 Merkle tree", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Crypt::Digest::SHA256 'sha256' ;\n\nmy @blocks;\n\nopen my $fh, '<:raw', './title.png';\n\nwhile ( read $fh, my $chunk, 1024 ) { push @blocks, sha256 $chunk }\n\nwhile ( scalar @blocks > 1 ) {\n   my @clone = @blocks and @blocks = ();\n   while ( @_ = splice @clone, 0, 2 ) {\n      push @blocks, scalar @_ == 1 ? $_[0] : sha256 $_[0].$_[1]\n   }\n}\n\nprint unpack ( 'H*', $blocks[0] ) , \"\\n\";\n", "target": "\n\n\nimport argh\nimport hashlib  \nimport sys\n  \n@argh.arg('filename', nargs='?', default=None)\ndef main(filename, block_size=1024*1024):\n    if filename:\n        fin = open(filename, 'rb')\n    else: \n        fin = sys.stdin\n    \n    stack = []\n    block = fin.read(block_size)\n    while block:\n        \n        node = (0, hashlib.sha256(block).digest())\n        stack.append(node)\n\n        \n        while len(stack) >= 2 and stack[-2][0] == stack[-1][0]:\n            a = stack[-2]\n            b = stack[-1]\n            l = a[0]\n            stack[-2:] = [(l+1, hashlib.sha256(a[1] + b[1]).digest())]\n\n        block = fin.read(block_size)\n    \n    while len(stack) > 1:\n        \n        a = stack[-2]\n        b = stack[-1]\n        al = a[0]\n        bl = b[0]\n        stack[-2:] = [(max(al, bl)+1, hashlib.sha256(a[1] + b[1]).digest())]\n\n    print(stack[0][1].hex())\n\n\nargh.dispatch_command(main)\n"}
{"id": 383513, "name": "Partition function P", "source": "Translate Perl to Python: use strict;\nuse warnings;\nno warnings qw(recursion);\nuse Math::AnyNum qw(:overload);\nuse Memoize;\n\nmemoize('partitionsP');\nmemoize('partDiff');\n\nsub partDiffDiff { my($n) = @_; $n%2 != 0 ? ($n+1)/2 : $n+1 }\n\nsub partDiff { my($n) = @_; $n<2 ? 1 : partDiff($n-1) + partDiffDiff($n-1) }\n\nsub partitionsP {\n    my($n) = @_;\n    return 1 if $n < 2;\n\n    my $psum = 0;\n    for my $i (1..$n) {\n        my $pd = partDiff($i);\n        last if $pd > $n;\n        if ( (($i-1)%4) < 2 ) { $psum += partitionsP($n-$pd) }\n        else                  { $psum -= partitionsP($n-$pd) }\n    }\n    return $psum\n}\n\nprint partitionsP($_) . ' ' for 0..25; print \"\\n\";\nprint partitionsP(6666) . \"\\n\";\n", "target": "from itertools import islice\n\ndef posd():\n    \"diff between position numbers. 1, 2, 3... interleaved with  3, 5, 7...\"\n    count, odd = 1, 3\n    while True:\n        yield count\n        yield odd\n        count, odd = count + 1, odd + 2\n\ndef pos_gen():\n    \"position numbers. 1 3 2 5 7 4 9 ...\"\n    val = 1\n    diff = posd()\n    while True:\n        yield val\n        val += next(diff)\n                \ndef plus_minus():\n    \"yield (list_offset, sign) or zero for Partition calc\"\n    n, sign = 0, [1, 1]\n    p_gen = pos_gen()\n    out_on = next(p_gen)\n    while True:\n        n += 1\n        if n == out_on:\n            next_sign = sign.pop(0)\n            if not sign:\n                sign = [-next_sign] * 2\n            yield -n, next_sign\n            out_on = next(p_gen)\n        else:\n            yield 0\n            \ndef part(n):\n    \"Partition numbers\"\n    p = [1]\n    p_m = plus_minus()\n    mods = []\n    for _ in range(n):\n        next_plus_minus = next(p_m)\n        if next_plus_minus:\n            mods.append(next_plus_minus)\n        p.append(sum(p[offset] * sign for offset, sign in mods))\n    return p[-1]\n        \nprint(\"(Intermediaries):\")\nprint(\"    posd:\", list(islice(posd(), 10)))\nprint(\"    pos_gen:\", list(islice(pos_gen(), 10)))\nprint(\"    plus_minus:\", list(islice(plus_minus(), 15)))\nprint(\"\\nPartitions:\", [part(x) for x in range(15)])\n"}
{"id": 383514, "name": "Special divisors", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy @sd;\nfor my $n (1..199) {\n    map { next if $_ != int $_ } map { reverse($n) / reverse $_ } divisors $n;\n    push @sd, $n;\n}\n\nsay @sd . \" matching numbers:\\n\" .\n    (sprintf \"@{['%4d' x @sd]}\", @sd) =~ s/(.{40})/$1\\n/gr;\n", "target": "\n\ndef reverse(n):\n    u = 0\n    while n:\n        u = 10 * u + n % 10\n        n = int(n / 10)\n    return u\n\nc = 0\nfor n in range(1, 200):\n    u = reverse(n)\n    s = True\n    \n    for d in range (1, n):\n        if n % d == 0:\n            b = reverse(d)\n            if u % b != 0:\n                s = False\n    if s:\n        c = c + 1\n        print(n, end='\\t')\n                \nprint(\"\\nEncontrados \", c, \"divisores especiales.\")\n"}
{"id": 383515, "name": "Nimber arithmetic", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Math::AnyNum qw(:overload);\n\nsub msb {\n    my($n, $base) = (shift, 0);\n    $base++ while $n >>= 1;\n    $base;\n}\n\nsub lsb {\n    my $n = shift;\n    msb($n & -$n);\n}\n\nsub nim_sum {\n    my($x,$y) = @_;\n    $x ^ $y\n}\n\nsub nim_prod {\n    no warnings qw(recursion);\n    my($x,$y) = @_;\n    return $x * $y if $x < 2 or $y < 2;\n    my $h = 2 ** lsb($x);\n    return nim_sum( nim_prod($h, $y), nim_prod(nim_sum($x,$h), $y)) if $x > $h;\n    return nim_prod($y,$x) if lsb($y) < msb($y);\n    return $x * $y unless my $comp = lsb($x) & lsb($y);\n    $h = 2 ** lsb($comp);\n    nim_prod(nim_prod(($x >> $h),($y >> $h)), (3 << ($h - 1)));\n}\n\nmy $upto = 15;\nfor (['+', \\&nim_sum], ['*', \\&nim_prod]) {\n    my($op, $f) = @$_;\n    print \" $op |\"; printf '%3d', $_ for 0..$upto;\n    say \"\\n\u2500\u2500\u2500\u253c\" . ('\u2500\u2500\u2500\u2500' x ($upto-3));\n    for my $r (0..$upto) {\n        printf('%2s |', $r);\n        printf '%3s', &$f($r, $_) for 0..$upto;\n        print \"\\n\";\n    }\n    print \"\\n\";\n}\n\nsay nim_sum(21508, 42689);\nsay nim_prod(21508, 42689);\nsay nim_sum(2150821508215082150821508, 4268942689426894268942689);\nsay nim_prod(2150821508215082150821508, 4268942689426894268942689); \n", "target": "\ndef hpo2(n): return n & (-n)\n\n\ndef lhpo2(n):\n    q = 0\n    m = hpo2(n)\n    while m%2 == 0:\n        m = m >> 1\n        q += 1\n    return q\n\ndef nimsum(x,y): return x ^ y\n\ndef nimprod(x,y):\n    if x < 2 or y < 2:\n        return x * y\n    h = hpo2(x)\n    if x > h:\n        return nimprod(h, y) ^ nimprod(x^h, y) \n    if hpo2(y) < y:\n        return nimprod(y, x) \n    xp, yp = lhpo2(x), lhpo2(y)\n    comp = xp & yp\n    if comp == 0:\n        return x * y \n    h = hpo2(comp)\n    \n    return nimprod(nimprod(x>>h, y>>h), 3<<(h-1))\n\nif __name__ == '__main__':\n    for f, op in ((nimsum, '+'), (nimprod, '*')):\n        print(f\" {op} |\", end='')\n        for i in range(16):\n            print(f\"{i:3d}\", end='')\n        print(\"\\n--- \" + \"-\"*48)\n        for i in range(16):\n            print(f\"{i:2d} |\", end='')\n            for j in range(16):\n                print(f\"{f(i,j):3d}\", end='')\n            print()\n        print()\n\n    a, b = 21508, 42689\n    print(f\"{a} + {b} = {nimsum(a,b)}\")\n    print(f\"{a} * {b} = {nimprod(a,b)}\")\n"}
{"id": 383516, "name": "Polynomial synthetic division", "source": "Translate Perl to Python: sub synthetic_division {\n    my($numerator,$denominator) = @_;\n    my @result = @$numerator;\n    my $end    = @$denominator-1;\n\n    for my $i (0 .. @$numerator-($end+1)) {\n        next unless $result[$i];\n        $result[$i]    /= @$denominator[0];\n        $result[$i+$_] -= @$denominator[$_] * $result[$i] for 1 .. $end;\n    }\n\n    return join(' ', @result[0 .. @result-($end+1)]), join(' ', @result[-$end .. -1]);\n}\n\nsub poly_divide {\n    *n = shift; *d = shift;\n    my($quotient,$remainder)= synthetic_division( \\@n, \\@d );\n    \"[@n] / [@d] = [$quotient], remainder [$remainder]\\n\";\n}\n\nprint poly_divide([1, -12, 0, -42], [1, -3]);\nprint poly_divide([1, 0, 0, 0, -2], [1, 1, 1, 1]);\n", "target": "from __future__ import print_function\nfrom __future__ import division\n\n\n\n\ndef extended_synthetic_division(dividend, divisor):\n    \n    \n\n    out = list(dividend) \n    normalizer = divisor[0]\n    for i in xrange(len(dividend)-(len(divisor)-1)):\n        out[i] /= normalizer \n                                 \n        coef = out[i]\n        if coef != 0: \n            for j in xrange(1, len(divisor)): \n                                              \n                out[i + j] += -divisor[j] * coef\n\n    \n    \n    \n    separator = -(len(divisor)-1)\n    return out[:separator], out[separator:] \n\nif __name__ == '__main__':\n    print(\"POLYNOMIAL SYNTHETIC DIVISION\")\n    N = [1, -12, 0, -42]\n    D = [1, -3]\n    print(\"  %s / %s  =\" % (N,D), \" %s remainder %s\" % extended_synthetic_division(N, D))\n"}
{"id": 383517, "name": "Polynomial synthetic division", "source": "Translate Perl to Python: sub synthetic_division {\n    my($numerator,$denominator) = @_;\n    my @result = @$numerator;\n    my $end    = @$denominator-1;\n\n    for my $i (0 .. @$numerator-($end+1)) {\n        next unless $result[$i];\n        $result[$i]    /= @$denominator[0];\n        $result[$i+$_] -= @$denominator[$_] * $result[$i] for 1 .. $end;\n    }\n\n    return join(' ', @result[0 .. @result-($end+1)]), join(' ', @result[-$end .. -1]);\n}\n\nsub poly_divide {\n    *n = shift; *d = shift;\n    my($quotient,$remainder)= synthetic_division( \\@n, \\@d );\n    \"[@n] / [@d] = [$quotient], remainder [$remainder]\\n\";\n}\n\nprint poly_divide([1, -12, 0, -42], [1, -3]);\nprint poly_divide([1, 0, 0, 0, -2], [1, 1, 1, 1]);\n", "target": "from __future__ import print_function\nfrom __future__ import division\n\n\n\n\ndef extended_synthetic_division(dividend, divisor):\n    \n    \n\n    out = list(dividend) \n    normalizer = divisor[0]\n    for i in xrange(len(dividend)-(len(divisor)-1)):\n        out[i] /= normalizer \n                                 \n        coef = out[i]\n        if coef != 0: \n            for j in xrange(1, len(divisor)): \n                                              \n                out[i + j] += -divisor[j] * coef\n\n    \n    \n    \n    separator = -(len(divisor)-1)\n    return out[:separator], out[separator:] \n\nif __name__ == '__main__':\n    print(\"POLYNOMIAL SYNTHETIC DIVISION\")\n    N = [1, -12, 0, -42]\n    D = [1, -3]\n    print(\"  %s / %s  =\" % (N,D), \" %s remainder %s\" % extended_synthetic_division(N, D))\n"}
{"id": 383518, "name": "Color wheel", "source": "Translate Perl to Python: use Imager;\nuse Math::Complex qw(cplx i pi);\n\nmy ($width, $height) = (300, 300);\nmy $center = cplx($width/2, $height/2);\n\nmy $img = Imager->new(xsize => $width,\n                      ysize => $height);\n\nforeach my $y (0 .. $height - 1) {\n    foreach my $x (0 .. $width - 1) {\n\n        my $vec = $center - $x - $y * i;\n        my $mag = 2 * abs($vec) / $width;\n        my $dir = (pi + atan2($vec->Re, $vec->Im)) / (2 * pi);\n\n        $img->setpixel(x => $x, y => $y,\n            color => {hsv => [360 * $dir, $mag, $mag < 1 ? 1 : 0]});\n    }\n}\n\n$img->write(file => 'color_wheel.png');\n", "target": "size(300, 300)\nbackground(0)\nradius = min(width, height) / 2.0\ncx, cy = width / 2, width / 2\nfor x in range(width):\n        for y in range(height):\n            rx = x - cx\n            ry = y - cy\n            s = sqrt(rx ** 2 + ry ** 2) / radius\n            if s <= 1.0:\n                h = ((atan2(ry, rx) / PI) + 1.0) / 2.0\n                colorMode(HSB)\n                c = color(int(h * 255), int(s * 255), 255)\n                set(x, y, c) \n"}
{"id": 383519, "name": "Retrieve and search chat history", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse Time::Piece;\nuse IO::Socket::INET;\nuse HTTP::Tiny;\nuse feature 'say';\n\nmy $needle = shift @ARGV // '';\nmy @haystack = ();\nmy $page = '';\n \n\nmy $begin =  Time::Piece->new - 10 * Time::Piece::ONE_DAY;\nsay \"         Executed at: \", Time::Piece->new;\nsay \"Begin searching from: $begin\";\n\nfor (my $date = $begin ; Time::Piece->new > $date ; $date += Time::Piece::ONE_DAY) { \n   $page .= HTTP::Tiny->new()->get( 'http://tclers.tk/conferences/tcl/'.$date->strftime('%Y-%m-%d').'.tcl')->{content};\n}\n\n\nmy @lines = split /\\n/, $page;\nfor (@lines) { push @haystack, $_ if substr($_, 0, 13) =~ m/^m \\d\\d\\d\\d-\\d\\d-\\d\\dT/ }\n\n\nsay \"First and last lines of the haystack:\";\nsay $haystack[0] and say $haystack[-1];\n\nsay \"Needle: \", $needle;\nsay  '-' x 79;\n\n\nfor (@haystack) { say $_ if (index($_, $needle) != -1) }\n", "target": "\nimport datetime\nimport re\nimport urllib.request\nimport sys\n\ndef get(url):\n    with urllib.request.urlopen(url) as response:\n       html = response.read().decode('utf-8')\n    if re.match(r'<!Doctype HTML[\\s\\S]*<Title>URL Not Found</Title>', html):\n        return None\n    return html\n\ndef main():\n    template = 'http://tclers.tk/conferences/tcl/%Y-%m-%d.tcl'\n    today = datetime.datetime.utcnow()\n    back = 10\n    needle = sys.argv[1]\n    \n    \n    \n    for i in range(-back, 2):\n        day = today + datetime.timedelta(days=i)\n        url = day.strftime(template)\n        haystack = get(url)\n        if haystack:\n            mentions = [x for x in haystack.split('\\n') if needle in x]\n            if mentions:\n                print('{}\\n------\\n{}\\n------\\n'\n                          .format(url, '\\n'.join(mentions)))\n\nmain()\n"}
{"id": 383520, "name": "Find duplicate files", "source": "Translate Perl to Python: use File::Find qw(find);\nuse File::Compare qw(compare);\nuse Sort::Naturally;\nuse Getopt::Std qw(getopts);\n\nmy %opts;\n$opts{s} = 1;\ngetopts(\"s:\", \\%opts);\n\nsub find_dups {\n    my($dir) = @_;\n\n    my @results;\n    my %files;\n    find {\n        no_chdir => 1,\n        wanted => sub { lstat; -f _ && (-s >= $opt{s} ) && push @{$files{-s _}}, $_ }\n    } => $dir;\n\n    foreach my $files (values %files) {\n        next unless @$files;\n\n        my %dups;\n        foreach my $a (0 .. @$files - 1) {\n            for (my $b = $a + 1 ; $b < @$files ; $b++) {\n                next if compare(@$files[$a], @$files[$b]);\n                push @{$dups{ @$files[$a] }}, splice @$files, $b--, 1;\n            }\n        }\n\n        while (my ($original, $clones) = each %dups) {\n            push @results, sprintf \"%8d %s\\n\", (stat($original))[7], join ', ', sort $original, @$clones;\n        }\n    }\n    reverse nsort @results;\n\n}\n\nprint for find_dups(@ARGV);\n", "target": "from __future__ import print_function\nimport os\nimport hashlib\nimport datetime\n\ndef FindDuplicateFiles(pth, minSize = 0, hashName = \"md5\"):\n    knownFiles = {}\n\n    \n    for root, dirs, files in os.walk(pth):\n        for fina in files:\n            fullFina = os.path.join(root, fina)\n            isSymLink = os.path.islink(fullFina)\n            if isSymLink:\n                continue \n            si = os.path.getsize(fullFina)\n            if si < minSize:\n                continue\n            if si not in knownFiles:\n                knownFiles[si] = {}\n            h = hashlib.new(hashName)\n            h.update(open(fullFina, \"rb\").read())\n            hashed = h.digest()\n            if hashed in knownFiles[si]:\n                fileRec = knownFiles[si][hashed]\n                fileRec.append(fullFina)\n            else:\n                knownFiles[si][hashed] = [fullFina]\n\n    \n    sizeList = list(knownFiles.keys())\n    sizeList.sort(reverse=True)\n    for si in sizeList:\n        filesAtThisSize = knownFiles[si]\n        for hashVal in filesAtThisSize:\n            if len(filesAtThisSize[hashVal]) < 2:\n                continue\n            fullFinaLi = filesAtThisSize[hashVal]\n            print (\"=======Duplicate=======\")\n            for fullFina in fullFinaLi:\n                st = os.stat(fullFina)\n                isHardLink = st.st_nlink > 1 \n                infoStr = []\n                if isHardLink:\n                    infoStr.append(\"(Hard linked)\")\n                fmtModTime = datetime.datetime.utcfromtimestamp(st.st_mtime).strftime('%Y-%m-%dT%H:%M:%SZ')\n                print (fmtModTime, si, os.path.relpath(fullFina, pth), \" \".join(infoStr))\n\nif __name__==\"__main__\":\n\n    FindDuplicateFiles('/home/tim/Dropbox', 1024*1024)\n"}
{"id": 383521, "name": "Legendre prime counting function", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nno warnings qw(recursion);\nuse ntheory qw( nth_prime prime_count );\n\nmy (%cachephi, %cachepi);\n\nsub phi\n  {\n  return $cachephi{\"@_\"} //= do {\n    my ($x, $aa) = @_;\n    $aa <= 0 ? $x : phi($x, $aa - 1) - phi(int $x / nth_prime($aa), $aa - 1) };\n  }\n\nsub pi\n  {\n  return $cachepi{$_[0]} //= do {\n    my $n = shift;\n    $n < 2 ? 0 : do{ my $aa = pi(int sqrt $n); phi($n, $aa) + $aa - 1 } };\n  }\n\nprint \"e             n   Legendre    ntheory\\n\",\n      \"-             -   --------    -------\\n\";\nfor (1 .. 9)\n  {\n  printf \"%d  %12d %10d %10d\\n\", $_, 10**$_, pi(10**$_), prime_count(10**$_);\n  }\n", "target": "from primesieve import primes\nfrom math import isqrt\nfrom functools import cache\n\np = primes(isqrt(1_000_000_000))\n\n@cache\ndef phi(x, a):\n    res = 0\n    while True:\n        if not a or not x:\n            return x + res\n    \n        a -= 1\n        res -= phi(x//p[a], a) \n\ndef legpi(n):\n    if n < 2: return 0\n\n    a = legpi(isqrt(n))\n    return phi(n, a) + a - 1\n\nfor e in range(10):\n    print(f'10^{e}', legpi(10**e))\n"}
{"id": 383522, "name": "Rosetta Code_Find bare lang tags", "source": "Translate Perl to Python: my $lang = 'no language';\nmy $total = 0;\nmy %blanks = ();\nwhile (<>) {\n  if (m/<lang>/) {\n    if (exists $blanks{lc $lang}) {\n      $blanks{lc $lang}++\n    } else {\n      $blanks{lc $lang} = 1\n    }\n    $total++\n  } elsif (m/==\\s*\\{\\{\\s*header\\s*\\|\\s*([^\\s\\}]+)\\s*\\}\\}\\s*==/) {\n    $lang = lc $1\n  }\n}\n\nif ($total) {\n\tprint \"$total bare language tag\" . ($total > 1 ? 's' : '') . \".\\n\\n\";\n\twhile ( my ($k, $v) = each(%blanks) ) {\n\t\tprint \"$k in $v\\n\"\n\t}\n}\n", "target": "\n\nfrom __future__ import annotations\n\nimport functools\nimport gzip\nimport json\nimport logging\nimport platform\nimport re\n\nfrom collections import Counter\nfrom collections import defaultdict\n\nfrom typing import Any\nfrom typing import Iterator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\n\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlunparse\nfrom urllib.parse import quote_plus\n\nimport urllib.error\nimport urllib.request\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\n\n\n\n\n\nRE_SPEC = [\n    (\"NOWIKI\", r\"<\\s*nowiki\\s*>.*?</\\s*nowiki\\s*>\"),\n    (\"PRE\", r\"<\\s*pre\\s*>.*?</\\s*pre\\s*>\"),\n    (\"LANG\", r\"<\\s*lang\\s+.+?>.*?</\\s*lang\\s*>\"),\n    (\"HEAD\", r\"==\\{\\{\\s*header\\s*\\|\\s*(?P<header>.+?)\\s*}}==\"),\n    (\"BARE\", r\"<\\s*lang\\s*>.*?</\\s*lang\\s*>\"),\n]\n\nRE_BARE_LANG = re.compile(\n    \"|\".join(rf\"(?P<{name}>{pattern})\" for name, pattern in RE_SPEC),\n    re.DOTALL | re.IGNORECASE,\n)\n\n\n\nRE_MULTI_HEADER = re.compile(r\"(}|(\\{\\{\\s*header\\s*\\|\\s*))\", re.IGNORECASE)\n\n\ndef find_bare_lang_section_headers(wiki_text: str) -> Iterator[str]:\n    \n    current_heading = \"no language\"\n\n    for match in RE_BARE_LANG.finditer(wiki_text):\n        kind = match.lastgroup\n\n        if kind == \"HEAD\":\n            current_heading = RE_MULTI_HEADER.sub(\"\", match.group(\"header\"))\n        elif kind == \"BARE\":\n            yield current_heading\n\n\nclass Error(Exception):\n    \n\n\nclass TagCounter:\n    \n\n    def __init__(self):\n        self.counter = Counter()\n        self.pages = defaultdict(set)\n        self.total = 0\n\n    def __len__(self):\n        return len(self.counter)\n\n    @classmethod\n    def from_section_headers(\n        cls, page_title: str, section_headers: Iterable[str]\n    ) -> TagCounter:\n        \n        counter = cls()\n\n        for heading in section_headers:\n            counter.add(page_title, heading)\n\n        return counter\n\n    @classmethod\n    def from_wiki_text(cls, page_title: str, wiki_text: str) -> TagCounter:\n        \n        return cls.from_section_headers(\n            page_title,\n            find_bare_lang_section_headers(wiki_text),\n        )\n\n    def add(self, page_title: str, section_heading: str):\n        \n        self.counter[section_heading] += 1\n        self.pages[section_heading].add(page_title)\n        self.total += 1\n\n    def update(self, other):\n        \n        assert isinstance(other, TagCounter)\n\n        self.counter.update(other.counter)\n\n        for section_heading, pages in other.pages.items():\n            self.pages[section_heading].update(pages)\n\n        self.total += other.total\n\n    def most_common(self, n=None) -> str:\n        \n        buf = [f\"{sum(self.counter.values())} bare lang tags.\\n\"]\n\n        for section_heading, count in self.counter.most_common(n=n):\n            pages = list(self.pages[section_heading])\n            buf.append(f\"{count} in {section_heading} {pages}\")\n\n        return \"\\n\".join(buf)\n\n\ndef quote_underscore(string, safe=\"\", encoding=None, errors=None):\n    \n    string = quote_plus(string, safe, encoding, errors)\n    return string.replace(\"+\", \"_\")\n\n\nclass URL(NamedTuple):\n    \n\n    scheme: str\n    netloc: str\n    path: str\n    params: str\n    query: str\n    fragment: str\n\n    def __str__(self):\n        return urlunparse(self)\n\n    def with_query(self, query: Mapping[str, Any]) -> URL:\n        query_string = urlencode(query, safe=\":\", quote_via=quote_underscore)\n        return self._replace(query=query_string)\n\n\nAPI_BASE_URL = URL(\n    scheme=\"http\",\n    netloc=\"rosettacode.org\",\n    path=\"/mw/api.php\",\n    params=\"\",\n    query=\"\",\n    fragment=\"\",\n)\n\nUGLY_RAW_URL = URL(\n    scheme=\"http\",\n    netloc=\"rosettacode.org\",\n    path=\"/mw/index.php\",\n    params=\"\",\n    query=\"\",\n    fragment=\"\",\n)\n\n\nDEFAULT_HEADERS = {\n    \"User-agent\": f\"python/{platform.python_version()}\",\n    \"Accept-encoding\": \"gzip, deflate\",\n    \"Accept\": \"*/*\",\n    \"Connection\": \"keep-alive\",\n}\n\n\nclass Response(NamedTuple):\n    headers: Mapping[str, str]\n    body: bytes\n\n\ndef get(url: URL, headers=DEFAULT_HEADERS) -> Response:\n    \n    logger.debug(f\"GET {url}\")\n    request = urllib.request.Request(str(url), headers=headers)\n\n    try:\n        with urllib.request.urlopen(request) as response:\n            return Response(\n                headers=dict(response.getheaders()),\n                body=response.read(),\n            )\n    except urllib.error.HTTPError as e:\n        logging.debug(e.code)\n        logging.debug(gzip.decompress(e.read()))\n        raise\n\n\ndef raise_for_header(headers: Mapping[str, str], header: str, expect: str):\n    got = headers.get(header)\n    if got != expect:\n        raise Error(f\"expected '{expect}', got '{got}'\")\n\n\nraise_for_content_type = functools.partial(raise_for_header, header=\"Content-Type\")\n\n\nclass CMContinue(NamedTuple):\n    continue_: str\n    cmcontinue: str\n\n\nPages = Tuple[List[str], Optional[CMContinue]]\n\n\ndef get_wiki_page_titles(chunk_size: int = 500, continue_: CMContinue = None) -> Pages:\n    \n    query = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtitle\": \"Category:Programming_Tasks\",\n        \"cmlimit\": chunk_size,\n        \"format\": \"json\",\n        \"continue\": \"\",\n    }\n\n    if continue_:\n        query[\"continue\"] = continue_.continue_\n        query[\"cmcontinue\"] = continue_.cmcontinue\n\n    response = get(API_BASE_URL.with_query(query))\n\n    \n    raise_for_content_type(response.headers, expect=\"application/json; charset=utf-8\")\n    raise_for_header(response.headers, \"Content-Encoding\", \"gzip\")\n\n    data = json.loads(gzip.decompress(response.body))\n    page_titles = [p[\"title\"] for p in data[\"query\"][\"categorymembers\"]]\n\n    if data.get(\"continue\", {}).get(\"cmcontinue\"):\n        _continue = CMContinue(\n            data[\"continue\"][\"continue\"],\n            data[\"continue\"][\"cmcontinue\"],\n        )\n    else:\n        _continue = None\n\n    return (page_titles, _continue)\n\n\ndef get_wiki_page_markup(page_title: str) -> str:\n    \n    query = {\"action\": \"raw\", \"title\": page_title}\n    response = get(UGLY_RAW_URL.with_query(query))\n\n    \n    raise_for_content_type(response.headers, expect=\"text/x-wiki; charset=UTF-8\")\n\n    return response.body.decode()\n\n\ndef example(limit=30):\n    \n    page_titles, continue_ = get_wiki_page_titles()\n\n    \n    while continue_ is not None:\n        more_page_titles, continue_ = get_wiki_page_titles(continue_=continue_)\n        page_titles.extend(more_page_titles)\n\n    \n    counter = TagCounter()\n\n    for i, page_title in enumerate(page_titles):\n        if i > limit:\n            break\n\n        \n        wiki_text = get_wiki_page_markup(page_title)\n        counts = TagCounter.from_wiki_text(page_title, wiki_text)\n        counter.update(counts)\n\n    \n    print(counter.most_common())\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(format=\"%(asctime)s %(message)s\", level=logging.DEBUG)\n    example()\n"}
{"id": 383523, "name": "Palindromic gapful numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse constant Inf  => 1e10;\n\nsub is_p_gapful {\n    my($d,$n) = @_;\n    return '' unless 0 == $n % 11;\n    my @digits = split //, $n;\n    $d eq $digits[0] and (0 == $n % ($digits[0].$digits[-1])) and $n eq join '', reverse @digits;\n}\n\nfor ([1, 20], [86, 15]) {\n    my($offset, $count) = @$_;\n    say \"Palindromic gapful numbers starting at $offset:\";\n    for my $d ('1'..'9') {\n        my $n = 0; my $out = \"$d: \";\n        $out .= do { $n+1 < $count+$offset ? (is_p_gapful($d,$_) and ++$n and $n >= $offset and \"$_ \") : last } for 100 .. Inf;\n        say $out\n    }\n    say ''\n}\n", "target": "from itertools import count\nfrom pprint import pformat\nimport re\nimport heapq\n\n\ndef pal_part_gen(odd=True):\n    for i in count(1):\n        fwd = str(i)\n        rev = fwd[::-1][1:] if odd else fwd[::-1]\n        yield int(fwd + rev)\n\ndef pal_ordered_gen():\n    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))\n\ndef is_gapful(x):\n    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)\n\nif __name__ == '__main__':\n    start = 100\n    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:\n        print(f\"\\nLast {last} of the first {mx} binned-by-last digit \" \n              f\"gapful numbers >= {start}\")\n        bin = {i: [] for i in range(1, 10)}\n        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))\n        while any(len(val) < mx for val in bin.values()):\n            g = next(gen)\n            val = bin[g % 10]\n            if len(val) < mx:\n                val.append(g)\n        b = {k:v[-last:] for k, v in bin.items()}\n        txt = pformat(b, width=220)\n        print('', re.sub(r\"[{},\\[\\]]\", '', txt))\n"}
{"id": 383524, "name": "Palindromic gapful numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse constant Inf  => 1e10;\n\nsub is_p_gapful {\n    my($d,$n) = @_;\n    return '' unless 0 == $n % 11;\n    my @digits = split //, $n;\n    $d eq $digits[0] and (0 == $n % ($digits[0].$digits[-1])) and $n eq join '', reverse @digits;\n}\n\nfor ([1, 20], [86, 15]) {\n    my($offset, $count) = @$_;\n    say \"Palindromic gapful numbers starting at $offset:\";\n    for my $d ('1'..'9') {\n        my $n = 0; my $out = \"$d: \";\n        $out .= do { $n+1 < $count+$offset ? (is_p_gapful($d,$_) and ++$n and $n >= $offset and \"$_ \") : last } for 100 .. Inf;\n        say $out\n    }\n    say ''\n}\n", "target": "from itertools import count\nfrom pprint import pformat\nimport re\nimport heapq\n\n\ndef pal_part_gen(odd=True):\n    for i in count(1):\n        fwd = str(i)\n        rev = fwd[::-1][1:] if odd else fwd[::-1]\n        yield int(fwd + rev)\n\ndef pal_ordered_gen():\n    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))\n\ndef is_gapful(x):\n    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)\n\nif __name__ == '__main__':\n    start = 100\n    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:\n        print(f\"\\nLast {last} of the first {mx} binned-by-last digit \" \n              f\"gapful numbers >= {start}\")\n        bin = {i: [] for i in range(1, 10)}\n        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))\n        while any(len(val) < mx for val in bin.values()):\n            g = next(gen)\n            val = bin[g % 10]\n            if len(val) < mx:\n                val.append(g)\n        b = {k:v[-last:] for k, v in bin.items()}\n        txt = pformat(b, width=220)\n        print('', re.sub(r\"[{},\\[\\]]\", '', txt))\n"}
{"id": 383525, "name": "Chernick's Carmichael numbers", "source": "Translate Perl to Python: use 5.020;\nuse warnings;\nuse ntheory qw/:all/;\nuse experimental qw/signatures/;\n\nsub chernick_carmichael_factors ($n, $m) {\n    (6*$m + 1, 12*$m + 1, (map { (1 << $_) * 9*$m + 1 } 1 .. $n-2));\n}\n\nsub chernick_carmichael_number ($n, $callback) {\n\n    my $multiplier = ($n > 4) ? (1 << ($n-4)) : 1;\n\n    for (my $m = 1 ; ; ++$m) {\n        my @f = chernick_carmichael_factors($n, $m * $multiplier);\n        next if not vecall { is_prime($_) } @f;\n        $callback->(@f);\n        last;\n    }\n}\n\nforeach my $n (3..9) {\n    chernick_carmichael_number($n, sub (@f) { say \"a($n) = \", vecprod(@f) });\n}\n", "target": "\n\n\n\nfrom sympy import isprime\n\n\n\ndef primality_pretest(k):\n    if not (k % 3) or not (k % 5) or not (k % 7) or not (k % 11) or not(k % 13) or not (k % 17) or not (k % 19) or not (k % 23):\n        return (k <= 23)\n        \n    return True\n\ndef is_chernick(n, m):\n\n    t = 9 * m\n    \n    if not primality_pretest(6 * m + 1):\n        return False\n        \n    if not primality_pretest(12 * m + 1):\n        return False\n        \n    for i in range(1,n-1):\n        if not primality_pretest((t << i) + 1):\n            return False\n        \n    if not isprime(6 * m + 1):\n        return False\n        \n    if not isprime(12 * m + 1):\n        return False\n        \n    for i in range(1,n - 1):\n        if not isprime((t << i) + 1):\n            return False\n        \n    return True\n    \nfor n in range(3,10):\n\n    if n > 4:\n        multiplier = 1 << (n - 4)\n    else:\n        multiplier = 1\n    \n    if n > 5:\n        multiplier *= 5\n        \n        \n    k = 1\n    \n    while True:\n        m = k * multiplier\n        \n        if is_chernick(n, m): \n            print(\"a(\"+str(n)+\") has m = \"+str(m))\n            break\n            \n        k += 1\n"}
{"id": 383526, "name": "The sieve of Sundaram", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @sieve;\nmy $nth = 1_000_000;\nmy $k = 2.4 * $nth * log($nth) / 2;\n\n$sieve[$k] = 0;\nfor my $i (1 .. $k) {\n    my $j = $i;\n    while ((my $l = $i + $j + 2 * $i * $j) < $k) {\n        $sieve[$l] = 1;\n        $j++\n    }\n}\n\n$sieve[0] = 1;\nmy @S = (grep { $_ } map { ! $sieve[$_] and 1+$_*2 } 0..@sieve)[0..99];\nsay \"First 100 Sundaram primes:\\n\" .\n    (sprintf \"@{['%5d' x 100]}\", @S) =~ s/(.{50})/$1\\n/gr;\n\nmy ($count, $index);\nfor (@sieve) {\n    $count += !$_;\n    (say \"One millionth: \" . (1+2*$index)) and last if $count == $nth;\n    ++$index;\n}\n", "target": "from numpy import log\n\ndef sieve_of_Sundaram(nth, print_all=True):\n    \n    assert nth > 0, \"nth must be a positive integer\"\n    k = int((2.4 * nth * log(nth)) // 2)  \n    integers_list = [True] * k\n    for i in range(1, k):\n        j = i\n        while i + j + 2 * i * j < k:\n            integers_list[i + j + 2 * i * j] = False\n            j += 1\n    pcount = 0\n    for i in range(1, k + 1):\n        if integers_list[i]:\n            pcount += 1\n            if print_all:\n                print(f\"{2 * i + 1:4}\", end=' ')\n                if pcount % 10 == 0:\n                    print()\n\n            if pcount == nth:\n                print(f\"\\nSundaram primes start with 3. The {nth}th Sundaram prime is {2 * i + 1}.\\n\")\n                break\n\n\n\nsieve_of_Sundaram(100, True)\n\nsieve_of_Sundaram(1000000, False)\n"}
{"id": 383527, "name": "Consecutive primes with ascending or descending differences", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'primes';\nuse List::AllUtils <indexes max>;\n\nmy $limit  = 1000000;\nmy @primes = @{primes( $limit )};\n\nsub runs {\n    my($op) = @_;\n    my @diff = my $diff = my $run = 1;\n    push @diff, map {\n        my $next = $primes[$_] - $primes[$_ - 1];\n        if ($op eq '>') { if ($next > $diff) { ++$run } else { $run = 1 } }\n        else            { if ($next < $diff) { ++$run } else { $run = 1 } }\n        $diff = $next;\n        $run\n    } 1 .. $\n\n    my @prime_run;\n    my $max = max @diff;\n    for my $r ( indexes { $_ == $max } @diff ) {\n        push @prime_run, join ' ', map { $primes[$r - $_] } reverse 0..$max\n    }\n    @prime_run\n}\n\nsay   \"Longest run(s) of ascending prime gaps up to $limit:\\n\"  . join \"\\n\", runs('>');\nsay \"\\nLongest run(s) of descending prime gaps up to $limit:\\n\" . join \"\\n\", runs('<');\n", "target": "from sympy import sieve\n\nprimelist = list(sieve.primerange(2,1000000))\n\nlistlen = len(primelist)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff > old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff < old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n"}
{"id": 383528, "name": "Verhoeff algorithm", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @inv = qw(0 4 3 2 1 5 6 7 8 9);\n\nmy @d = map [ split ], split /\\n/, <<END;\n0 \t1 \t2 \t3 \t4 \t5 \t6 \t7 \t8 \t9\n1 \t2 \t3 \t4 \t0 \t6 \t7 \t8 \t9 \t5\n2 \t3 \t4 \t0 \t1 \t7 \t8 \t9 \t5 \t6\n3 \t4 \t0 \t1 \t2 \t8 \t9 \t5 \t6 \t7\n4 \t0 \t1 \t2 \t3 \t9 \t5 \t6 \t7 \t8\n5 \t9 \t8 \t7 \t6 \t0 \t4 \t3 \t2 \t1\n6 \t5 \t9 \t8 \t7 \t1 \t0 \t4 \t3 \t2\n7 \t6 \t5 \t9 \t8 \t2 \t1 \t0 \t4 \t3\n8 \t7 \t6 \t5 \t9 \t3 \t2 \t1 \t0 \t4\n9 \t8 \t7 \t6 \t5 \t4 \t3 \t2 \t1 \t0\nEND\n\nmy @p = map [ split ], split /\\n/, <<END;\n0 \t1 \t2 \t3 \t4 \t5 \t6 \t7 \t8 \t9\n1 \t5 \t7 \t6 \t2 \t8 \t3 \t0 \t9 \t4\n5 \t8 \t0 \t3 \t7 \t9 \t6 \t1 \t4 \t2\n8 \t9 \t1 \t6 \t0 \t4 \t3 \t5 \t2 \t7\n9 \t4 \t5 \t3 \t1 \t2 \t6 \t8 \t7 \t0\n4 \t2 \t8 \t6 \t5 \t7 \t3 \t9 \t0 \t1\n2 \t7 \t9 \t3 \t8 \t0 \t6 \t4 \t1 \t5\n7 \t0 \t4 \t6 \t9 \t1 \t3 \t2 \t5 \t8\nEND\n\nmy $debug;\n\nsub generate\n  {\n  local $_ = shift() . 0;\n  my $c = my $i = 0;\n  my ($n, $p);\n  $debug and print \"i ni d(c,p(i%8,ni)) c\\n\";\n  while( length )\n    {\n    $c = $d[ $c ][ $p = $p[ $i % 8 ][ $n = chop ] ];\n    $debug and printf \"%d%3d%7d%10d\\n\", $i, $n, $p, $c;\n    $i++;\n    }\n  return $inv[ $c ];\n  }\n\nsub validate { shift =~ /(\\d+)(\\d)/ and $2 == generate($1) }\n\nfor ( 236, 12345, 123456789012 )\n  {\n  print \"testing $_\\n\";\n  $debug = length() < 6;\n  my $checkdigit = generate($_);\n  print \"check digit for $_ is $checkdigit\\n\";\n  $debug = 0;\n  for my $cd ( $checkdigit, 9 )\n    {\n    print \"$_$cd is \", validate($_ . $cd) ? '' : 'not ', \"valid\\n\";\n    }\n  print \"\\n\";\n  }\n", "target": "MULTIPLICATION_TABLE = [\n    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9),\n    (1, 2, 3, 4, 0, 6, 7, 8, 9, 5),\n    (2, 3, 4, 0, 1, 7, 8, 9, 5, 6),\n    (3, 4, 0, 1, 2, 8, 9, 5, 6, 7),\n    (4, 0, 1, 2, 3, 9, 5, 6, 7, 8),\n    (5, 9, 8, 7, 6, 0, 4, 3, 2, 1),\n    (6, 5, 9, 8, 7, 1, 0, 4, 3, 2),\n    (7, 6, 5, 9, 8, 2, 1, 0, 4, 3),\n    (8, 7, 6, 5, 9, 3, 2, 1, 0, 4),\n    (9, 8, 7, 6, 5, 4, 3, 2, 1, 0),\n]\n\nINV = (0, 4, 3, 2, 1, 5, 6, 7, 8, 9)\n\nPERMUTATION_TABLE = [\n    (0, 1, 2, 3, 4, 5, 6, 7, 8, 9),\n    (1, 5, 7, 6, 2, 8, 3, 0, 9, 4),\n    (5, 8, 0, 3, 7, 9, 6, 1, 4, 2),\n    (8, 9, 1, 6, 0, 4, 3, 5, 2, 7),\n    (9, 4, 5, 3, 1, 2, 6, 8, 7, 0),\n    (4, 2, 8, 6, 5, 7, 3, 9, 0, 1),\n    (2, 7, 9, 3, 8, 0, 6, 4, 1, 5),\n    (7, 0, 4, 6, 9, 1, 3, 2, 5, 8),\n]\n\ndef verhoeffchecksum(n, validate=True, terse=True, verbose=False):\n    \n    if verbose:\n        print(f\"\\n{'Validation' if validate else 'Check digit'}\",\\\n            f\"calculations for {n}:\\n\\n i  n\u1d62  p[i,n\u1d62]   c\\n------------------\")\n    \n    c, dig = 0, list(str(n if validate else 10 * n))\n    for i, ni in enumerate(dig[::-1]):\n        p = PERMUTATION_TABLE[i % 8][int(ni)]\n        c = MULTIPLICATION_TABLE[c][p]\n        if verbose:\n            print(f\"{i:2}  {ni}      {p}    {c}\")\n\n    if verbose and not validate:\n        print(f\"\\ninv({c}) = {INV[c]}\")\n    if not terse:\n        print(f\"\\nThe validation for '{n}' is {'correct' if c == 0 else 'incorrect'}.\"\\\n              if validate else f\"\\nThe check digit for '{n}' is {INV[c]}.\")\n    return c == 0 if validate else INV[c]\n\nif __name__ == '__main__':\n\n    for n, va, t, ve in [\n        (236, False, False, True), (2363, True, False, True), (2369, True, False, True),\n        (12345, False, False, True), (123451, True, False, True), (123459, True, False, True),\n        (123456789012, False, False, False), (1234567890120, True, False, False),\n        (1234567890129, True, False, False)]:\n        verhoeffchecksum(n, va, t, ve)\n"}
{"id": 383529, "name": "Padovan n-step number sequences", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <state say>;\nuse List::Util 'sum';\nuse List::Lazy 'lazy_list';\n\nsay 'Padovan N-step sequences; first 25 terms:';\nfor our $N (2..8) {\n\n    my $pad_n = lazy_list {\n        state $n  = 2;\n        state @pn = (1, 1, 1);\n        push @pn, sum @pn[ grep { $_ >= 0 } $n-$N .. $n++ - 1 ];\n        $pn[-4]\n    };\n\n    print \"N = $N |\";\n    print ' ' . $pad_n->next() for 1..25;\n    print \"\\n\"\n}\n", "target": "def pad_like(max_n=8, t=15):\n    \n    start = [[], [1, 1, 1]]     \n    for n in range(2, max_n+1):\n        this = start[n-1][:n+1]     \n        while len(this) < t:\n            this.append(sum(this[i] for i in range(-2, -n - 2, -1)))\n        start.append(this)\n    return start[2:]\n\ndef pr(p):\n    print(.strip())\n    for n, seq in enumerate(p, 2):\n        print(f\"| {n:2} || {str(seq)[1:-1].replace(' ', '')+', ...'}\\n|-\")\n    print('|}')\n\nif __name__ == '__main__':\n    p = pad_like()\n    pr(p)\n"}
{"id": 383530, "name": "Prime triangle", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\nuse List::MoreUtils qw(zip slideatatime);\nuse Algorithm::Combinatorics qw(permutations);\n\nsay '1 2';\n\nmy @count = (0, 0, 1);\n\nfor my $n (3..17) {\n    my @even_nums = grep { 0 == $_ % 2 } 2..$n-1;\n    my @odd_nums  = grep { 1 == $_ % 2 } 3..$n-1;\n    for my $e (permutations [@even_nums]) {\n        next if $$e[0] == 8 or $$e[0] == 14;\n        my $nope = 0;\n        for my $o (permutations [@odd_nums]) {\n            my @list = (zip(@$e, @$o), $n);                 \n            splice @list, -2, -1 if not defined $list[-2];  \n            my $it = slideatatime(1, 2, @list);\n            while ( my @rr = $it->() ) {\n                last unless defined $rr[1];\n                $nope++ and last unless is_prime $rr[0]+$rr[1];\n            }\n            unless ($nope) {\n                say '1 ' . join ' ', @list unless $count[$n];\n                $count[$n]++;\n            }\n            $nope = 0;\n        }\n    }\n}\n\nsay \"\\n\" . join ' ', @count[2..$\n", "target": "from numpy import array\n\ndef is_prime(n: int) -> bool:\n    assert n < 64\n    return ((1 << n) & 0x28208a20a08a28ac) != 0\n\ndef prime_triangle_row(a: array, start: int, length: int) -> bool:\n    if length == 2:\n        return is_prime(a[0] + a[1])\n    for i in range(1, length - 1, 1):\n        if is_prime(a[start] + a[start + i]):\n            a[start + i], a[start + 1] = a[start + 1], a[start + i]\n            if prime_triangle_row(a, start + 1, length - 1):\n                return True\n            a[start + i], a[start + 1] = a[start + 1], a[start + i]\n    return False\n\ndef prime_triangle_count(a: array, start: int, length: int) -> int:\n    count: int = 0\n    if length == 2:\n        if is_prime(a[start] + a[start + 1]):\n            count += 1\n    else:\n        for i in range(1, length - 1, 1):\n            if is_prime(a[start] + a[start + i]):\n                a[start + i], a[start + 1] = a[start + 1], a[start + i]\n                count += prime_triangle_count(a, start + 1, length - 1)\n                a[start + i], a[start + 1] = a[start + 1], a[start + i]\n    return count\n\ndef print_row(a: array):\n    if a == []:\n        return\n    print(\"%2d\"% a[0], end=\" \")\n    for x in a[1:]:\n        print(\"%2d\"% x, end=\" \")\n    print()\n\nfor n in range(2, 21):\n    tr: array = [_ for _ in range(1, n + 1)]\n    if prime_triangle_row(tr, 0, n):\n        print_row(tr)\nprint()\nfor n in range(2, 21):\n    tr: array = [_ for _ in range(1, n + 1)]\n    if n > 2:\n        print(\" \", end=\"\")\n    print(prime_triangle_count(tr, 0, n), end=\"\")\nprint()\n"}
{"id": 383531, "name": "XML validation", "source": "Translate Perl to Python: \nuse 5.018_002;\nuse warnings;\nuse Try::Tiny;\nuse XML::LibXML;\n\nour $VERSION = 1.000_000;\n\nmy $parser = XML::LibXML->new();\n\nmy $good_xml         = '<a>5</a>';\nmy $bad_xml          = '<a>5<b>foobar</b></a>';\nmy $xmlschema_markup = <<'END';\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"xsd:integer\"/>\n</xsd:schema>\nEND\n\nmy $xmlschema = XML::LibXML::Schema->new( string => $xmlschema_markup );\n\nfor ( $good_xml, $bad_xml ) {\n    my $doc = $parser->parse_string($_);\n    try {\n        $xmlschema->validate($doc);\n    }\n    finally {\n        if (@_) {\n            say \"Not valid: @_\";\n        }\n        else {\n            say 'Valid';\n        }\n    };\n}\n", "target": "\nfrom __future__ import print_function\nimport lxml\nfrom lxml import etree\n\nif __name__==\"__main__\":\n\n\tparser = etree.XMLParser(dtd_validation=True)\n\tschema_root = etree.XML()\n\tschema = etree.XMLSchema(schema_root)\n\n\t\n\tparser = etree.XMLParser(schema = schema)\n\ttry:\n\t\troot = etree.fromstring(\"<a>5</a>\", parser)\n\t\tprint (\"Finished validating good xml\")\n\texcept lxml.etree.XMLSyntaxError as err:\n\t\tprint (err)\n\n\t\n\tparser = etree.XMLParser(schema = schema)\n\ttry:\n\t\troot = etree.fromstring(\"<a>5<b>foobar</b></a>\", parser)\n\texcept lxml.etree.XMLSyntaxError as err:\n\t\tprint (err)\n"}
{"id": 383532, "name": "Own digits power sum", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\nuse Parallel::ForkManager;\n\nmy %own_dps;\nmy($lo,$hi) = (3,9);\nmy $cores   = 8;     \n\nmy $start = 10**($lo-1);\nmy $stop  = 10**$hi - 1;\nmy $step  = int(1 + ($stop - $start)/ ($cores+1));\n\nmy $pm = Parallel::ForkManager->new($cores);\n\nRUN:\nfor my $i ( 0 .. $cores ) {\n\n    $pm->run_on_finish (\n        sub {\n            my ($pid, $exit_code, $ident, $exit_signal, $core_dump, $data_ref) = @_;\n            $own_dps{$ident} = $data_ref;\n        }\n    );\n\n    $pm->start($i) and next RUN;\n\n    my @values;\n    for my $n ( ($start + $i*$step) .. ($start + ($i+1)*$step) ) {\n        push @values, $n if $n == sum map { $_**length($n) } split '', $n;\n    }\n\n    $pm->finish(0, \\@values)\n}\n\n$pm->wait_all_children;\n\nsay $_ for sort { $a <=> $b } map { @$_ } values %own_dps;\n", "target": "\n\ndef isowndigitspowersum(integer):\n    \n    digits = [int(c) for c in str(integer)]\n    exponent = len(digits)\n    return sum(x ** exponent for x in digits) == integer\n\nprint(\"Own digits power sums for N = 3 to 9 inclusive:\")\nfor i in range(100, 1000000000):\n    if isowndigitspowersum(i):\n        print(i)\n"}
{"id": 383533, "name": "Metallic ratios", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature qw(say state);\nuse Math::AnyNum qw<:overload as_dec>;\n\nsub gen_lucas {\n    my $b = shift;\n    my $i = 0;\n    return sub {\n        state @seq = (state $v1 = 1, state $v2 = 1);\n        ($v2, $v1) = ($v1, $v2 + $b*$v1) and push(@seq, $v1) unless defined $seq[$i+1];\n        return $seq[$i++];\n    }\n}\n\nsub metallic {\n    my $lucas  = shift;\n    my $places = shift || 32;\n    my $n = my $last = 0;\n    my @seq = $lucas->();\n    while (1) {\n        push @seq, $lucas->();\n        my $this = as_dec( $seq[-1]/$seq[-2], $places+1 );\n        last if $this eq $last;\n        $last = $this;\n        $n++;\n    }\n    $last, $n\n}\n\nmy @name = <Platinum Golden Silver Bronze Copper Nickel Aluminum Iron Tin Lead>;\n\nfor my $b (0..$\n    my $lucas = gen_lucas($b);\n    printf \"\\n'Lucas' sequence for $name[$b] ratio, where b = $b:\\nFirst 15 elements: \" . join ', ', map { $lucas->() } 1..15;\n    printf \"Approximated value %s reached after %d iterations\\n\", metallic(gen_lucas($b));\n}\n\nprintf \"\\nGolden ratio to 256 decimal places %s reached after %d iterations\", metallic(gen_lucas(1),256);\n", "target": "from itertools import count, islice\nfrom _pydecimal import getcontext, Decimal\n\ndef metallic_ratio(b):\n    m, n = 1, 1\n    while True:\n        yield m, n\n        m, n = m*b + n, m\n\ndef stable(b, prec):\n    def to_decimal(b):\n        for m,n in metallic_ratio(b):\n            yield Decimal(m)/Decimal(n)\n\n    getcontext().prec = prec\n    last = 0\n    for i,x in zip(count(), to_decimal(b)):\n        if x == last:\n            print(f'after {i} iterations:\\n\\t{x}')\n            break\n        last = x\n\nfor b in range(4):\n    coefs = [n for _,n in islice(metallic_ratio(b), 15)]\n    print(f'\\nb = {b}: {coefs}')\n    stable(b, 32)\n\nprint(f'\\nb = 1 with 256 digits:')\nstable(1, 256)\n"}
{"id": 383534, "name": "Metallic ratios", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature qw(say state);\nuse Math::AnyNum qw<:overload as_dec>;\n\nsub gen_lucas {\n    my $b = shift;\n    my $i = 0;\n    return sub {\n        state @seq = (state $v1 = 1, state $v2 = 1);\n        ($v2, $v1) = ($v1, $v2 + $b*$v1) and push(@seq, $v1) unless defined $seq[$i+1];\n        return $seq[$i++];\n    }\n}\n\nsub metallic {\n    my $lucas  = shift;\n    my $places = shift || 32;\n    my $n = my $last = 0;\n    my @seq = $lucas->();\n    while (1) {\n        push @seq, $lucas->();\n        my $this = as_dec( $seq[-1]/$seq[-2], $places+1 );\n        last if $this eq $last;\n        $last = $this;\n        $n++;\n    }\n    $last, $n\n}\n\nmy @name = <Platinum Golden Silver Bronze Copper Nickel Aluminum Iron Tin Lead>;\n\nfor my $b (0..$\n    my $lucas = gen_lucas($b);\n    printf \"\\n'Lucas' sequence for $name[$b] ratio, where b = $b:\\nFirst 15 elements: \" . join ', ', map { $lucas->() } 1..15;\n    printf \"Approximated value %s reached after %d iterations\\n\", metallic(gen_lucas($b));\n}\n\nprintf \"\\nGolden ratio to 256 decimal places %s reached after %d iterations\", metallic(gen_lucas(1),256);\n", "target": "from itertools import count, islice\nfrom _pydecimal import getcontext, Decimal\n\ndef metallic_ratio(b):\n    m, n = 1, 1\n    while True:\n        yield m, n\n        m, n = m*b + n, m\n\ndef stable(b, prec):\n    def to_decimal(b):\n        for m,n in metallic_ratio(b):\n            yield Decimal(m)/Decimal(n)\n\n    getcontext().prec = prec\n    last = 0\n    for i,x in zip(count(), to_decimal(b)):\n        if x == last:\n            print(f'after {i} iterations:\\n\\t{x}')\n            break\n        last = x\n\nfor b in range(4):\n    coefs = [n for _,n in islice(metallic_ratio(b), 15)]\n    print(f'\\nb = {b}: {coefs}')\n    stable(b, 32)\n\nprint(f'\\nb = 1 with 256 digits:')\nstable(1, 256)\n"}
{"id": 383535, "name": "Data Encryption Standard", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Crypt::DES;\n\nmy $key        = pack(\"H*\", \"0E329232EA6D0D73\");\nmy $cipher     = Crypt::DES->new($key);\nmy $ciphertext = $cipher->encrypt(pack(\"H*\", \"8787878787878787\"));\nprint \"Encoded\u00a0: \", unpack(\"H*\", $ciphertext), \"\\n\";\nprint \"Decoded\u00a0: \", unpack(\"H*\", $cipher->decrypt($ciphertext)), \"\\n\";\n", "target": "\n\n\n\nIP = (\n    58, 50, 42, 34, 26, 18, 10, 2,\n    60, 52, 44, 36, 28, 20, 12, 4,\n    62, 54, 46, 38, 30, 22, 14, 6,\n    64, 56, 48, 40, 32, 24, 16, 8,\n    57, 49, 41, 33, 25, 17, 9,  1,\n    59, 51, 43, 35, 27, 19, 11, 3,\n    61, 53, 45, 37, 29, 21, 13, 5,\n    63, 55, 47, 39, 31, 23, 15, 7\n)\nIP_INV = (\n    40,  8, 48, 16, 56, 24, 64, 32,\n    39,  7, 47, 15, 55, 23, 63, 31,\n    38,  6, 46, 14, 54, 22, 62, 30,\n    37,  5, 45, 13, 53, 21, 61, 29,\n    36,  4, 44, 12, 52, 20, 60, 28,\n    35,  3, 43, 11, 51, 19, 59, 27,\n    34,  2, 42, 10, 50, 18, 58, 26,\n    33,  1, 41,  9, 49, 17, 57, 25\n)\nPC1 = (\n    57, 49, 41, 33, 25, 17, 9,\n    1,  58, 50, 42, 34, 26, 18,\n    10, 2,  59, 51, 43, 35, 27,\n    19, 11, 3,  60, 52, 44, 36,\n    63, 55, 47, 39, 31, 23, 15,\n    7,  62, 54, 46, 38, 30, 22,\n    14, 6,  61, 53, 45, 37, 29,\n    21, 13, 5,  28, 20, 12, 4\n)\nPC2 = (\n    14, 17, 11, 24, 1,  5,\n    3,  28, 15, 6,  21, 10,\n    23, 19, 12, 4,  26, 8,\n    16, 7,  27, 20, 13, 2,\n    41, 52, 31, 37, 47, 55,\n    30, 40, 51, 45, 33, 48,\n    44, 49, 39, 56, 34, 53,\n    46, 42, 50, 36, 29, 32\n)\n\nE  = (\n    32, 1,  2,  3,  4,  5,\n    4,  5,  6,  7,  8,  9,\n    8,  9,  10, 11, 12, 13,\n    12, 13, 14, 15, 16, 17,\n    16, 17, 18, 19, 20, 21,\n    20, 21, 22, 23, 24, 25,\n    24, 25, 26, 27, 28, 29,\n    28, 29, 30, 31, 32, 1\n)\n\nSboxes = {\n    0: (\n        14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7,\n        0, 15,  7,  4, 14,  2, 13,  1, 10,  6, 12, 11,  9,  5,  3,  8,\n        4,  1, 14,  8, 13,  6,  2, 11, 15, 12,  9,  7,  3, 10,  5,  0,\n        15, 12,  8,  2,  4,  9,  1,  7,  5, 11,  3, 14, 10,  0,  6, 13\n    ),\n    1: (\n        15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10,\n        3, 13,  4,  7, 15,  2,  8, 14, 12,  0,  1, 10,  6,  9, 11,  5,\n        0, 14,  7, 11, 10,  4, 13,  1,  5,  8, 12,  6,  9,  3,  2, 15,\n        13,  8, 10,  1,  3, 15,  4,  2, 11,  6,  7, 12,  0,  5, 14,  9 \n    ),\n    2: (\n        10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8,\n        13,  7,  0,  9,  3,  4,  6, 10,  2,  8,  5, 14, 12, 11, 15,  1,\n        13,  6,  4,  9,  8, 15,  3,  0, 11,  1,  2, 12,  5, 10, 14,  7,\n        1, 10, 13,  0,  6,  9,  8,  7,  4, 15, 14,  3, 11,  5,  2, 12 \n    ),\n    3: (\n        7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15,\n        13,  8, 11,  5,  6, 15,  0,  3,  4,  7,  2, 12,  1, 10, 14,  9,\n        10,  6,  9,  0, 12, 11,  7, 13, 15,  1,  3, 14,  5,  2,  8,  4,\n        3, 15,  0,  6, 10,  1, 13,  8,  9,  4,  5, 11, 12,  7,  2, 14\n    ),\n    4: (\n        2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9,\n        14, 11,  2, 12,  4,  7, 13,  1,  5,  0, 15, 10,  3,  9,  8,  6,\n        4,  2,  1, 11, 10, 13,  7,  8, 15,  9, 12,  5,  6,  3,  0, 14,\n        11,  8, 12,  7,  1, 14,  2, 13,  6, 15,  0,  9, 10,  4,  5,  3\n    ),\n    5: (\n        12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11,\n        10, 15,  4,  2,  7, 12,  9,  5,  6,  1, 13, 14,  0, 11,  3,  8,\n        9, 14, 15,  5,  2,  8, 12,  3,  7,  0,  4, 10,  1, 13, 11,  6,\n        4,  3,  2, 12,  9,  5, 15, 10, 11, 14,  1,  7,  6,  0,  8, 13\n    ),\n    6: (\n        4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1,\n        13,  0, 11,  7,  4,  9,  1, 10, 14,  3,  5, 12,  2, 15,  8,  6,\n        1,  4, 11, 13, 12,  3,  7, 14, 10, 15,  6,  8,  0,  5,  9,  2,\n        6, 11, 13,  8,  1,  4, 10,  7,  9,  5,  0, 15, 14,  2,  3, 12\n    ),\n    7: (\n        13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7,\n        1, 15, 13,  8, 10,  3,  7,  4, 12,  5,  6, 11,  0, 14,  9,  2,\n        7, 11,  4,  1,  9, 12, 14,  2,  0,  6, 10, 13, 15,  3,  5,  8,\n        2,  1, 14,  7,  4, 10,  8, 13, 15, 12,  9,  0,  3,  5,  6, 11\n    )\n}\n\nP = (\n    16,  7, 20, 21,\n    29, 12, 28, 17,\n    1, 15, 23, 26,\n    5, 18, 31, 10,\n    2,  8, 24, 14,\n    32, 27,  3,  9,\n    19, 13, 30,  6,\n    22, 11, 4,  25\n)\n    \ndef encrypt(msg, key, decrypt=False):\n    \n    assert isinstance(msg, int) and isinstance(key, int)\n    assert not msg.bit_length() > 64\n    assert not key.bit_length() > 64\n\n    \n    key = permutation_by_table(key, 64, PC1) \n\n    \n    \n    C0 = key >> 28\n    D0 = key & (2**28-1)\n    round_keys = generate_round_keys(C0, D0) \n\n    msg_block = permutation_by_table(msg, 64, IP)\n    L0 = msg_block >> 32\n    R0 = msg_block & (2**32-1)\n\n    \n    L_last = L0\n    R_last = R0\n    for i in range(1,17):\n        if decrypt: \n            i = 17-i\n        L_round = R_last\n        R_round = L_last ^ round_function(R_last, round_keys[i])\n        L_last = L_round\n        R_last = R_round\n\n    \n    cipher_block = (R_round<<32) + L_round\n\n    \n    cipher_block = permutation_by_table(cipher_block, 64, IP_INV)\n\n    return cipher_block\n\ndef round_function(Ri, Ki):\n    \n    Ri = permutation_by_table(Ri, 32, E)\n\n    \n    Ri ^= Ki\n\n    \n    Ri_blocks = [((Ri & (0b111111 << shift_val)) >> shift_val) for shift_val in (42,36,30,24,18,12,6,0)]\n\n    \n    for i, block in enumerate(Ri_blocks):\n        \n        row = ((0b100000 & block) >> 4) + (0b1 & block)\n        col = (0b011110 & block) >> 1\n        \n        Ri_blocks[i] = Sboxes[i][16*row+col]\n\n    \n    Ri_blocks = zip(Ri_blocks, (28,24,20,16,12,8,4,0))\n    Ri = 0\n    for block, lshift_val in Ri_blocks:\n        Ri += (block << lshift_val)\n\n    \n    Ri = permutation_by_table(Ri, 32, P)\n\n    return Ri\n\ndef permutation_by_table(block, block_len, table):\n    \n    block_str = bin(block)[2:].zfill(block_len)\n    perm = []\n    for pos in range(len(table)):\n        perm.append(block_str[table[pos]-1])\n    return int(''.join(perm), 2)\n\ndef generate_round_keys(C0, D0):\n    \n\n    round_keys = dict.fromkeys(range(0,17))\n    lrot_values = (1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1)\n\n    \n    lrot = lambda val, r_bits, max_bits: \\\n    (val << r_bits%max_bits) & (2**max_bits-1) | \\\n    ((val & (2**max_bits-1)) >> (max_bits-(r_bits%max_bits)))\n\n    \n    C0 = lrot(C0, 0, 28)\n    D0 = lrot(D0, 0, 28)\n    round_keys[0] = (C0, D0)\n\n    \n    for i, rot_val in enumerate(lrot_values):\n        i+=1\n        Ci = lrot(round_keys[i-1][0], rot_val, 28)\n        Di = lrot(round_keys[i-1][1], rot_val, 28)\n        round_keys[i] = (Ci, Di)\n\n    \n    \n    \n    del round_keys[0]\n\n    \n    for i, (Ci, Di) in round_keys.items():\n        Ki = (Ci << 28) + Di\n        round_keys[i] = permutation_by_table(Ki, 56, PC2) \n\n    return round_keys\n\nk = 0x0e329232ea6d0d73 \nk2 = 0x133457799BBCDFF1\nm = 0x8787878787878787\nm2 = 0x0123456789ABCDEF\n\ndef prove(key, msg):\n    print('key:       {:x}'.format(key))\n    print('message:   {:x}'.format(msg))\n    cipher_text = encrypt(msg, key)\n    print('encrypted: {:x}'.format(cipher_text))\n    plain_text = encrypt(cipher_text, key, decrypt=True)\n    print('decrypted: {:x}'.format(plain_text))\n\nprove(k, m)\nprint('----------')\nprove(k2, m2)\n"}
{"id": 383536, "name": "Repunit primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory <is_prime fromdigits>;\n\nmy $limit = 1000;\n\nprint \"Repunit prime digits (up to $limit) in:\\n\";\n\nfor my $base (2..16) {\n    printf \"Base %2d: %s\\n\", $base, join ' ', grep { is_prime $_ and is_prime fromdigits(('1'x$_), $base) and \" $_\" } 1..$limit\n}\n", "target": "from sympy import isprime\nfor b in range(2, 17):\n    print(b, [n for n in range(2, 1001) if isprime(n) and isprime(int('1'*n, base=b))])\n"}
{"id": 383537, "name": "Repunit primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory <is_prime fromdigits>;\n\nmy $limit = 1000;\n\nprint \"Repunit prime digits (up to $limit) in:\\n\";\n\nfor my $base (2..16) {\n    printf \"Base %2d: %s\\n\", $base, join ' ', grep { is_prime $_ and is_prime fromdigits(('1'x$_), $base) and \" $_\" } 1..$limit\n}\n", "target": "from sympy import isprime\nfor b in range(2, 17):\n    print(b, [n for n in range(2, 1001) if isprime(n) and isprime(int('1'*n, base=b))])\n"}
{"id": 383538, "name": "Earliest difference between prime gaps", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( primes );\n\nmy @gaps;\nmy $primeref = primes( 1e9 );\nfor my $i ( 2 .. $\n  {\n  my $diff = $primeref->[$i] - $primeref->[$i - 1];\n  $gaps[ $diff >> 1 ] //= $primeref->[$i - 1];\n  }\nmy %first;\nfor my $i ( 1 .. $\n  {\n  defined $gaps[$i] && defined $gaps[$i-1] or next;\n  my $diff = abs $gaps[$i] - $gaps[$i-1];\n  for my $m ( map 10 ** $_, 1 .. 10 )\n    {\n    $diff > $m and !$first{$m}++ and\n      print \"above $m gap @{[$i * 2 - 2 ]} abs( $gaps[$i-1] - $gaps[$i] )\\n\";\n    }\n  }\n", "target": "\n\nfrom primesieve import primes\n\nLIMIT = 10**9\npri = primes(LIMIT * 5)\ngapstarts = {}\nfor i in range(1, len(pri)):\n    if pri[i] - pri[i - 1] not in gapstarts:\n        gapstarts[pri[i] - pri[i - 1]] = pri[i - 1]\n\nPM, GAP1, = 10, 2\nwhile True:\n    while GAP1 not in gapstarts:\n        GAP1 += 2\n    start1 = gapstarts[GAP1]\n    GAP2 = GAP1 + 2\n    if GAP2 not in gapstarts:\n        GAP1 = GAP2 + 2\n        continue\n    start2 = gapstarts[GAP2]\n    diff = abs(start2 - start1)\n    if diff > PM:\n        print(f\"Earliest difference >{PM: ,} between adjacent prime gap starting primes:\")\n        print(f\"Gap {GAP1} starts at{start1: ,}, gap {GAP2} starts at{start2: ,}, difference is{diff: ,}.\\n\")\n        if PM == LIMIT:\n            break\n        PM *= 10\n    else:\n        GAP1 = GAP2\n"}
{"id": 383539, "name": "Monads_Writer monad", "source": "Translate Perl to Python: \n\npackage Writer;\n\nuse strict;\nuse warnings;\n\nsub new {\n   my ($class, $value, $log) = @_;\n   return bless [ $value => $log ], $class;\n}\n\nsub Bind {\n   my ($self, $code) = @_;\n   my ($value, $log) = @$self;\n   my $n = $code->($value);\n   return Writer->new( @$n[0], $log.@$n[1] );\n}\n\nsub Unit { Writer->new($_[0], sprintf(\"%-17s:\u00a0%.12f\\n\",$_[1],$_[0])) }\n\nsub root { Unit sqrt($_[0]), \"Took square root\" }\n\nsub addOne { Unit $_[0]+1, \"Added one\" }\n\nsub half { Unit $_[0]/2, \"Divided by two\" }\n\nprint Unit(5, \"Initial value\")->Bind(\\&root)->Bind(\\&addOne)->Bind(\\&half)->[1];\n", "target": "\nfrom __future__ import annotations\n\nimport functools\nimport math\nimport os\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import List\nfrom typing import TypeVar\nfrom typing import Union\n\n\nT = TypeVar(\"T\")\n\n\nclass Writer(Generic[T]):\n    def __init__(self, value: Union[T, Writer[T]], *msgs: str):\n        if isinstance(value, Writer):\n            self.value: T = value.value\n            self.msgs: List[str] = value.msgs + list(msgs)\n        else:\n            self.value = value\n            self.msgs = list(f\"{msg}: {self.value}\" for msg in msgs)\n\n    def bind(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:\n        writer = func(self.value)\n        return Writer(writer, *self.msgs)\n\n    def __rshift__(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:\n        return self.bind(func)\n\n    def __str__(self):\n        return f\"{self.value}\\n{os.linesep.join(reversed(self.msgs))}\"\n\n    def __repr__(self):\n        return f\"Writer({self.value}, \\\"{', '.join(reversed(self.msgs))}\\\")\"\n\n\ndef lift(func: Callable, msg: str) -> Callable[[Any], Writer[Any]]:\n    \n\n    @functools.wraps(func)\n    def wrapped(value):\n        return Writer(func(value), msg)\n\n    return wrapped\n\n\nif __name__ == \"__main__\":\n    square_root = lift(math.sqrt, \"square root\")\n    add_one = lift(lambda x: x + 1, \"add one\")\n    half = lift(lambda x: x / 2, \"div two\")\n\n    print(Writer(5, \"initial\") >> square_root >> add_one >> half)\n"}
{"id": 383540, "name": "Word ladder", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy %dict;\n\nopen my $handle, '<', 'unixdict.txt';\nwhile (my $word = <$handle>) {\n    chomp($word);\n    my $len = length $word;\n    if (exists $dict{$len}) {\n        push @{ $dict{ $len } }, $word;\n    } else {\n        my @words = ( $word );\n        $dict{$len} = \\@words;\n    }\n}\nclose $handle;\n\nsub distance {\n    my $w1 = shift;\n    my $w2 = shift;\n\n    my $dist = 0;\n    for my $i (0 .. length($w1) - 1) {\n        my $c1 = substr($w1, $i, 1);\n        my $c2 = substr($w2, $i, 1);\n        if (not ($c1 eq $c2)) {\n            $dist++;\n        }\n    }\n    return $dist;\n}\n\nsub contains {\n    my $aref = shift;\n    my $needle = shift;\n\n    for my $v (@$aref) {\n        if ($v eq $needle) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nsub word_ladder {\n    my $fw = shift;\n    my $tw = shift;\n\n    if (exists $dict{length $fw}) {\n        my @poss = @{ $dict{length $fw} };\n        my @queue = ([$fw]);\n        while (scalar @queue > 0) {\n            my $curr_ref = shift @queue;\n            my $last = $curr_ref->[-1];\n\n            my @next;\n            for my $word (@poss) {\n                if (distance($last, $word) == 1) {\n                    push @next, $word;\n                }\n            }\n\n            if (contains(\\@next, $tw)) {\n                push @$curr_ref, $tw;\n                print join (' -> ', @$curr_ref), \"\\n\";\n                return;\n            }\n\n            for my $word (@next) {\n                for my $i (0 .. scalar @poss - 1) {\n                    if ($word eq $poss[$i]) {\n                        splice @poss, $i, 1;\n                        last;\n                    }\n                }\n            }\n\n            for my $word (@next) {\n                my @temp = @$curr_ref;\n                push @temp, $word;\n\n                push @queue, \\@temp;\n            }\n        }\n    }\n\n    print STDERR \"Cannot change $fw into $tw\\n\";\n}\n\nword_ladder('boy', 'man');\nword_ladder('girl', 'lady');\nword_ladder('john', 'jane');\nword_ladder('child', 'adult');\nword_ladder('cat', 'dog');\nword_ladder('lead', 'gold');\nword_ladder('white', 'black');\nword_ladder('bubble', 'tickle');\n", "target": "import os,sys,zlib,urllib.request\n\ndef h ( str,x=9 ):\n    for c in str :\n        x = ( x*33 + ord( c )) & 0xffffffffff\n    return x  \n\ndef cache ( func,*param ):\n    n = 'cache_%x.bin'%abs( h( repr( param )))\n    try    : return eval( zlib.decompress( open( n,'rb' ).read()))\n    except : pass\n    s = func( *param )\n    open( n,'wb' ).write( zlib.compress( bytes( repr( s ),'ascii' )))\n    return s\n\ndico_url  = 'https://raw.githubusercontent.com/quinnj/Rosetta-Julia/master/unixdict.txt'\nread_url  = lambda url   : urllib.request.urlopen( url ).read()\nload_dico = lambda url   : tuple( cache( read_url,url ).split( b'\\n'))\nisnext    = lambda w1,w2 : len( w1 ) == len( w2 ) and len( list( filter( lambda l : l[0]!=l[1] , zip( w1,w2 )))) == 1\n\ndef build_map ( words ):\n    map = [(w.decode('ascii'),[]) for w in words]\n    for i1,(w1,n1) in enumerate( map ):\n        for i2,(w2,n2) in enumerate( map[i1+1:],i1+1 ):\n            if isnext( w1,w2 ):\n                n1.append( i2 )\n                n2.append( i1 )\n    return map\n\ndef find_path ( words,w1,w2 ):\n    i = [w[0] for w in words].index( w1 )\n    front,done,res  = [i],{i:-1},[]\n    while front :\n        i = front.pop(0)\n        word,next = words[i]\n        for n in next :\n            if n in done : continue\n            done[n] = i\n            if words[n][0] == w2 :\n                while n >= 0 :\n                    res = [words[n][0]] + res\n                    n = done[n]\n                return ' '.join( res )\n            front.append( n )\n    return '%s can not be turned into %s'%( w1,w2 )\n\nfor w in ('boy man','girl lady','john jane','alien drool','child adult'):\n    print( find_path( cache( build_map,load_dico( dico_url )),*w.split()))\n"}
{"id": 383541, "name": "Non-transitive dice", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub fourFaceCombs {\n    my %found = ();\n    my @res = ();\n    for (my $i = 1; $i <= 4; $i++) {\n        for (my $j = 1; $j <= 4; $j++) {\n            for (my $k = 1; $k <= 4; $k++) {\n                for (my $l = 1; $l <= 4; $l++) {\n                    my @c = sort ($i, $j, $k, $l);\n                    my $key = 0;\n                    for my $p (@c) {\n                        $key = 10 * $key + $p;\n                    }\n                    if (not exists $found{$key}) {\n                        $found{$key} = 1;\n                        push @res, \\@c;\n                    }\n                }\n            }\n        }\n    }\n    return @res;\n}\n\nsub compare {\n    my $xref = shift;\n    my $yref = shift;\n\n    my @x = @$xref;\n    my $xw = 0;\n\n    my @y = @$yref;\n    my $yw = 0;\n\n    for my $i (@x) {\n        for my $j (@y) {\n            if ($i < $j) {\n                $yw++;\n            }\n            if ($j < $i) {\n                $xw++;\n            }\n        }\n    }\n\n    if ($xw < $yw) {\n        return -1;\n    }\n    if ($yw < $xw) {\n        return 1;\n    }\n    return 0;\n}\n\nsub findIntransitive3 {\n    my $dice_ref = shift;\n    my @dice = @$dice_ref;\n    my $len = scalar @dice;\n\n    my @res = ();\n    for (my $i = 0; $i < $len; $i++) {\n        for (my $j = 0; $j < $len; $j++) {\n            my $first = compare($dice[$i], $dice[$j]);\n            if ($first == 1) {\n                for (my $k = 0; $k < $len; $k++) {\n                    my $second = compare($dice[$j], $dice[$k]);\n                    if ($second == 1) {\n                        my $third = compare($dice[$k], $dice[$i]);\n                        if ($third == 1) {\n                            my $d1r = $dice[$i];\n                            my $d2r = $dice[$j];\n                            my $d3r = $dice[$k];\n                            my @itd = ($d1r, $d2r, $d3r);\n                            push @res, \\@itd;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return @res;\n}\n\nsub findIntransitive4 {\n    my $dice_ref = shift;\n    my @dice = @$dice_ref;\n    my $len = scalar @dice;\n\n    my @res = ();\n    for (my $i = 0; $i < $len; $i++) {\n        for (my $j = 0; $j < $len; $j++) {\n            for (my $k = 0; $k < $len; $k++) {\n                for (my $l = 0; $l < $len; $l++) {\n                    my $first = compare($dice[$i], $dice[$j]);\n                    if ($first == 1) {\n                        my $second = compare($dice[$j], $dice[$k]);\n                        if ($second == 1) {\n                            my $third = compare($dice[$k], $dice[$l]);\n                            if ($third == 1) {\n                                my $fourth = compare($dice[$l], $dice[$i]);\n                                if ($fourth == 1) {\n                                    my $d1r = $dice[$i];\n                                    my $d2r = $dice[$j];\n                                    my $d3r = $dice[$k];\n                                    my $d4r = $dice[$l];\n                                    my @itd = ($d1r, $d2r, $d3r, $d4r);\n                                    push @res, \\@itd;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return @res;\n}\n\nsub main {\n    my @dice = fourFaceCombs();\n    my $len = scalar @dice;\n    print \"Number of eligible 4-faced dice: $len\\n\\n\";\n\n    my @it3 = findIntransitive3(\\@dice);\n    my $count3 = scalar @it3;\n    print \"$count3 ordered lists of 3 non-transitive dice found, namely:\\n\";\n    for my $itref (@it3) {\n        print \"[ \";\n        for my $r (@$itref) {\n            print \"[@$r] \";\n        }\n        print \"]\\n\";\n    }\n    print \"\\n\";\n\n    my @it4 = findIntransitive4(\\@dice);\n    my $count = scalar @it4;\n    print \"$count ordered lists of 4 non-transitive dice found, namely:\\n\";\n    for my $itref (@it4) {\n        print \"[ \";\n        for my $r (@$itref) {\n            print \"[@$r] \";\n        }\n        print \"]\\n\";\n    }\n}\n\nmain();\n", "target": "from itertools import combinations_with_replacement as cmbr\nfrom time import time\n \ndef dice_gen(n, faces, m):\n    dice = list(cmbr(faces, n))\n \n    succ = [set(j for j, b in enumerate(dice)\n                    if sum((x>y) - (x<y) for x in a for y in b) > 0)\n                for a in dice]\n \n    def loops(seq):\n        s = succ[seq[-1]]\n\n        if len(seq) == m:\n            if seq[0] in s: yield seq\n            return\n\n        for d in (x for x in s if x > seq[0] and not x in seq):\n            yield from loops(seq + (d,))\n \n    yield from (tuple(''.join(dice[s]) for s in x)\n                    for i, v in enumerate(succ)\n                    for x in loops((i,)))\n \nt = time()\nfor n, faces, loop_len in [(4, '1234', 3), (4, '1234', 4), (6, '123456', 3), (6, '1234567', 3)]:\n    for i, x in enumerate(dice_gen(n, faces, loop_len)): pass\n \n    print(f'{n}-sided, markings {faces}, loop length {loop_len}:')\n    print(f'\\t{i + 1}*{loop_len} solutions, e.g. {\" > \".join(x)} > [loop]')\n    t, t0 = time(), t\n    print(f'\\ttime: {t - t0:.4f} seconds\\n')\n"}
{"id": 383542, "name": "ADFGVX cipher", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( shuffle );\n\nmy $plaintext = 'ATTACKAT1200AM';\nmy $keysize = 9;\n\nmy $polybius = <<END;\n  | A D F G V X\n--+------------\nA | x x x x x x\nD | x x x x x x\nF | x x x x x x\nG | x x x x x x\nV | x x x x x x\nX | x x x x x x\nEND\n$polybius =~ s/x/$_/ for my @letters = shuffle \"A\" .. 'Z' , 0 .. 9;\nprint \"Polybius square =\\n\\n$polybius\\n\";\nmy %char2pair;\n@char2pair{ @letters } = glob '{A,D,F,G,V,X}' x 2; \nmy %pair2char = reverse %char2pair;                \nmy ($keyword) = shuffle grep !/(.).*\\1/,\n  do { local (@ARGV, $/) = 'unixdict.txt'; <> =~ /^.{$keysize}$/gm };\nmy ($n, @deorder) = 0;\nmy @reorder = map /.(.+)/, sort map $_ . $n++, split //, $keyword;\n@deorder[@reorder] = 0 .. $\nprint \"  keyword = $keyword\\n\\nplaintext = $plaintext\\n\\n\";\n\nmy $encoded = encode( $plaintext, \\%char2pair, \\@reorder );\nprint \"  encoded = $encoded\\n\\n\";\n\nmy $decoded = decode( $encoded, \\%pair2char, \\@deorder );\nprint \"  decoded = $decoded\\n\";\n\nsub encode\n  {\n  my ($plain, $c2p, $order) = @_;\n  my $len = @$order;\n  join ' ', (transpose( $plain =~ s/./$c2p->{$&}/gr =~ /.{1,$len}/g ))[@$order];\n  }\n\nsub decode\n  {\n  my ($encoded, $p2c, $order) = @_;\n  (join '', transpose((split ' ', $encoded)[@$order])) =~ s/../$p2c->{$&}/gr;\n  }\n\nsub transpose { map join('', map {s/.// ? $& : ''} @_), 1 .. length $_[0] }\n", "target": "\n\nfrom random import shuffle, choice\nfrom itertools import product, accumulate\nfrom numpy import floor, sqrt\n\nclass ADFGVX:\n    \n    def __init__(self, spoly, k, alph='ADFGVX'):\n        self.polybius = list(spoly.upper())\n        self.pdim = int(floor(sqrt(len(self.polybius))))\n        self.key = list(k.upper())\n        self.keylen = len(self.key)\n        self.alphabet = list(alph)\n        pairs = [p[0] + p[1] for p in product(self.alphabet, self.alphabet)]\n        self.encode = dict(zip(self.polybius, pairs))\n        self.decode = dict((v, k) for (k, v) in self.encode.items())\n\n    def encrypt(self, msg):\n        \n        chars = list(''.join([self.encode[c] for c in msg.upper() if c in self.polybius]))\n        colvecs = [(lett, chars[i:len(chars):self.keylen]) \\\n            for (i, lett) in enumerate(self.key)]\n        colvecs.sort(key=lambda x: x[0])\n        return ''.join([''.join(a[1]) for a in colvecs])\n\n    def decrypt(self, cod):\n        \n        chars = [c for c in cod if c in self.alphabet]\n        sortedkey = sorted(self.key)\n        order = [self.key.index(ch) for ch in sortedkey]\n        originalorder = [sortedkey.index(ch) for ch in self.key]\n        base, extra = divmod(len(chars), self.keylen)\n        strides = [base + (1 if extra > i else 0) for i in order]    \n        starts = list(accumulate(strides[:-1], lambda x, y: x + y))  \n        starts = [0] + starts                                        \n        ends = [starts[i] + strides[i] for i in range(self.keylen)]  \n        cols = [chars[starts[i]:ends[i]] for i in originalorder]     \n        pairs = []                                                   \n        for i in range((len(chars) - 1) // self.keylen + 1):\n            for j in range(self.keylen):\n                if i * self.keylen + j < len(chars):\n                    pairs.append(cols[j][i])\n\n        return ''.join([self.decode[pairs[i] + pairs[i + 1]] for i in range(0, len(pairs), 2)])\n\n\nif __name__ == '__main__':\n    PCHARS = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')\n    shuffle(PCHARS)\n    POLYBIUS = ''.join(PCHARS)\n    with open('unixdict.txt') as fh:\n        WORDS = [w for w in (fh.read()).split() \\\n            if len(w) == 9 and len(w) == len(set(list(w)))]\n        KEY = choice(WORDS)\n\n    SECRET, MESSAGE = ADFGVX(POLYBIUS, KEY), 'ATTACKAT1200AM'\n    print(f'Polybius: {POLYBIUS}, key: {KEY}')\n    print('Message: ', MESSAGE)\n    ENCODED = SECRET.encrypt(MESSAGE)\n    DECODED = SECRET.decrypt(ENCODED)\n    print('Encoded: ', ENCODED)\n    print('Decoded: ', DECODED)\n"}
{"id": 383543, "name": "ADFGVX cipher", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( shuffle );\n\nmy $plaintext = 'ATTACKAT1200AM';\nmy $keysize = 9;\n\nmy $polybius = <<END;\n  | A D F G V X\n--+------------\nA | x x x x x x\nD | x x x x x x\nF | x x x x x x\nG | x x x x x x\nV | x x x x x x\nX | x x x x x x\nEND\n$polybius =~ s/x/$_/ for my @letters = shuffle \"A\" .. 'Z' , 0 .. 9;\nprint \"Polybius square =\\n\\n$polybius\\n\";\nmy %char2pair;\n@char2pair{ @letters } = glob '{A,D,F,G,V,X}' x 2; \nmy %pair2char = reverse %char2pair;                \nmy ($keyword) = shuffle grep !/(.).*\\1/,\n  do { local (@ARGV, $/) = 'unixdict.txt'; <> =~ /^.{$keysize}$/gm };\nmy ($n, @deorder) = 0;\nmy @reorder = map /.(.+)/, sort map $_ . $n++, split //, $keyword;\n@deorder[@reorder] = 0 .. $\nprint \"  keyword = $keyword\\n\\nplaintext = $plaintext\\n\\n\";\n\nmy $encoded = encode( $plaintext, \\%char2pair, \\@reorder );\nprint \"  encoded = $encoded\\n\\n\";\n\nmy $decoded = decode( $encoded, \\%pair2char, \\@deorder );\nprint \"  decoded = $decoded\\n\";\n\nsub encode\n  {\n  my ($plain, $c2p, $order) = @_;\n  my $len = @$order;\n  join ' ', (transpose( $plain =~ s/./$c2p->{$&}/gr =~ /.{1,$len}/g ))[@$order];\n  }\n\nsub decode\n  {\n  my ($encoded, $p2c, $order) = @_;\n  (join '', transpose((split ' ', $encoded)[@$order])) =~ s/../$p2c->{$&}/gr;\n  }\n\nsub transpose { map join('', map {s/.// ? $& : ''} @_), 1 .. length $_[0] }\n", "target": "\n\nfrom random import shuffle, choice\nfrom itertools import product, accumulate\nfrom numpy import floor, sqrt\n\nclass ADFGVX:\n    \n    def __init__(self, spoly, k, alph='ADFGVX'):\n        self.polybius = list(spoly.upper())\n        self.pdim = int(floor(sqrt(len(self.polybius))))\n        self.key = list(k.upper())\n        self.keylen = len(self.key)\n        self.alphabet = list(alph)\n        pairs = [p[0] + p[1] for p in product(self.alphabet, self.alphabet)]\n        self.encode = dict(zip(self.polybius, pairs))\n        self.decode = dict((v, k) for (k, v) in self.encode.items())\n\n    def encrypt(self, msg):\n        \n        chars = list(''.join([self.encode[c] for c in msg.upper() if c in self.polybius]))\n        colvecs = [(lett, chars[i:len(chars):self.keylen]) \\\n            for (i, lett) in enumerate(self.key)]\n        colvecs.sort(key=lambda x: x[0])\n        return ''.join([''.join(a[1]) for a in colvecs])\n\n    def decrypt(self, cod):\n        \n        chars = [c for c in cod if c in self.alphabet]\n        sortedkey = sorted(self.key)\n        order = [self.key.index(ch) for ch in sortedkey]\n        originalorder = [sortedkey.index(ch) for ch in self.key]\n        base, extra = divmod(len(chars), self.keylen)\n        strides = [base + (1 if extra > i else 0) for i in order]    \n        starts = list(accumulate(strides[:-1], lambda x, y: x + y))  \n        starts = [0] + starts                                        \n        ends = [starts[i] + strides[i] for i in range(self.keylen)]  \n        cols = [chars[starts[i]:ends[i]] for i in originalorder]     \n        pairs = []                                                   \n        for i in range((len(chars) - 1) // self.keylen + 1):\n            for j in range(self.keylen):\n                if i * self.keylen + j < len(chars):\n                    pairs.append(cols[j][i])\n\n        return ''.join([self.decode[pairs[i] + pairs[i + 1]] for i in range(0, len(pairs), 2)])\n\n\nif __name__ == '__main__':\n    PCHARS = list('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')\n    shuffle(PCHARS)\n    POLYBIUS = ''.join(PCHARS)\n    with open('unixdict.txt') as fh:\n        WORDS = [w for w in (fh.read()).split() \\\n            if len(w) == 9 and len(w) == len(set(list(w)))]\n        KEY = choice(WORDS)\n\n    SECRET, MESSAGE = ADFGVX(POLYBIUS, KEY), 'ATTACKAT1200AM'\n    print(f'Polybius: {POLYBIUS}, key: {KEY}')\n    print('Message: ', MESSAGE)\n    ENCODED = SECRET.encrypt(MESSAGE)\n    DECODED = SECRET.decrypt(ENCODED)\n    print('Encoded: ', ENCODED)\n    print('Decoded: ', DECODED)\n"}
{"id": 383544, "name": "Factorial base numbers indexing permutations of a collection", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub fpermute {\n    my($f,@a) = @_;\n    my @f = split /\\./, $f;\n    for (0..$\n        my @b = @a[$_ ..  $_+$f[$_]];\n        unshift @b, splice @b, $\n        @a[$_ .. $_+$f[$_]] = @b;\n    }\n    join '', @a;\n}\n\nsub base {\n    my($n) = @_;\n    my @digits;\n    push(@digits, int $n/$_) and $n = $n % $_ for <6 2 1>; \n    join '.', @digits;\n}\n\nsay 'Generate table';\n\nfor (0..23) {\n    my $x = base($_);\n    say $x . ' -> ' . fpermute($x, <0 1 2 3>)\n}\n\nsay \"\\nGenerate the given task shuffles\";\nmy @omega = qw<A\u2660 K\u2660 Q\u2660 J\u2660 10\u2660 9\u2660 8\u2660 7\u2660 6\u2660 5\u2660 4\u2660 3\u2660 2\u2660 A\u2665 K\u2665 Q\u2665 J\u2665 10\u2665 9\u2665 8\u2665 7\u2665 6\u2665 5\u2665 4\u2665 3\u2665 2\u2665 A\u2666 K\u2666 Q\u2666 J\u2666 10\u2666 9\u2666 8\u2666 7\u2666 6\u2666 5\u2666 4\u2666 3\u2666 2\u2666 A\u2663 K\u2663 Q\u2663 J\u2663 10\u2663 9\u2663 8\u2663 7\u2663 6\u2663 5\u2663 4\u2663 3\u2663 2\u2663>;\n\nmy @books = (\n'39.49.7.47.29.30.2.12.10.3.29.37.33.17.12.31.29.34.17.25.2.4.25.4.1.14.20.6.21.18.1.1.1.4.0.5.15.12.4.3.10.10.9.1.6.5.5.3.0.0.0',\n'51.48.16.22.3.0.19.34.29.1.36.30.12.32.12.29.30.26.14.21.8.12.1.3.10.4.7.17.6.21.8.12.15.15.13.15.7.3.12.11.9.5.5.6.6.3.4.0.3.2.1'\n);\n\nsay \"Original deck:\";\nsay join '', @omega;\n\nsay \"\\n$_\\n\" . fpermute($_,@omega) for @books;\n\nsay \"\\nGenerate a random shuffle\";\nsay my $shoe = join '.', map { int rand($_) } reverse 0..$\nsay fpermute($shoe,@omega);\n", "target": "\n\nimport math\n\ndef apply_perm(omega,fbn):\n    \n    for m in range(len(fbn)):\n        g = fbn[m]\n        if g > 0:\n            \n            \n            new_first = omega[m+g]\n            \n            omega[m+1:m+g+1] = omega[m:m+g]\n            \n            omega[m] = new_first\n            \n    return omega\n    \ndef int_to_fbn(i):\n    \n    current = i\n    divisor = 2\n    new_fbn = []\n    while current > 0:\n        remainder = current % divisor\n        current = current // divisor\n        new_fbn.append(remainder)\n        divisor += 1\n    \n    return list(reversed(new_fbn))\n    \ndef leading_zeros(l,n):\n   \n   if len(l) < n:\n       return(([0] * (n - len(l))) + l)\n   else:\n       return l\n\ndef get_fbn(n):\n    \n    max = math.factorial(n)\n    \n    for i in range(max):\n        \n        current = i\n        divisor = 1\n        new_fbn = int_to_fbn(i)\n        yield leading_zeros(new_fbn,n-1)\n        \ndef print_write(f, line):\n    \n    print(line)\n    f.write(str(line)+'\\n')     \n    \ndef dot_format(l):\n    \n    \n    if len(l) < 1:\n        return \"\"\n    \n    dot_string = str(l[0])\n    \n    for e in l[1:]:\n        dot_string += \".\"+str(e)\n        \n    return dot_string\n    \ndef str_format(l):\n    \n    if len(l) < 1:\n        return \"\"\n        \n    new_string = \"\"\n        \n    for e in l:\n        new_string += str(e)\n    \n    return new_string \n    \nwith open(\"output.html\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"<pre>\\n\")\n    \n    \n        \n    omega=[0,1,2,3]\n    \n    four_list = get_fbn(4)\n    \n    for l in four_list:\n        print_write(f,dot_format(l)+' -> '+str_format(apply_perm(omega[:],l)))\n        \n    print_write(f,\" \")\n    \n    \n    \n    \n    \n    \n        \n    num_permutations = 0\n    \n    for p in get_fbn(11):\n        num_permutations += 1\n        if num_permutations % 1000000 == 0:\n            print_write(f,\"permutations so far = \"+str(num_permutations))\n    \n    print_write(f,\" \")\n    print_write(f,\"Permutations generated = \"+str(num_permutations))\n    print_write(f,\"compared to 11! which  = \"+str(math.factorial(11)))\n    \n    print_write(f,\" \")\n    \n       \n    \n    \n    \n    shoe = []\n    \n    for suit in [u\"\\u2660\",u\"\\u2665\",u\"\\u2666\",u\"\\u2663\"]:\n        for value in ['A','K','Q','J','10','9','8','7','6','5','4','3','2']:\n            shoe.append(value+suit)\n                    \n    print_write(f,str_format(shoe))\n    \n    p1 = [39,49,7,47,29,30,2,12,10,3,29,37,33,17,12,31,29,34,17,25,2,4,25,4,1,14,20,6,21,18,1,1,1,4,0,5,15,12,4,3,10,10,9,1,6,5,5,3,0,0,0]\n    \n    p2 = [51,48,16,22,3,0,19,34,29,1,36,30,12,32,12,29,30,26,14,21,8,12,1,3,10,4,7,17,6,21,8,12,15,15,13,15,7,3,12,11,9,5,5,6,6,3,4,0,3,2,1]\n    \n    print_write(f,\" \")\n    print_write(f,dot_format(p1))\n    print_write(f,\" \")\n    print_write(f,str_format(apply_perm(shoe[:],p1)))\n    \n    print_write(f,\" \")\n    print_write(f,dot_format(p2))\n    print_write(f,\" \")\n    print_write(f,str_format(apply_perm(shoe[:],p2)))\n\n    \n    \n    import random\n    \n    max = math.factorial(52)\n    \n    random_int = random.randint(0, max-1)\n\n    myperm = leading_zeros(int_to_fbn(random_int),51)\n    \n    print(len(myperm))\n    \n    print_write(f,\" \")\n    print_write(f,dot_format(myperm))\n    print_write(f,\" \")\n    print_write(f,str_format(apply_perm(shoe[:],myperm)))\n\n    f.write(\"</pre>\\n\")\n"}
{"id": 383545, "name": "Geohash", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils qw<sum max natatime>;\n\nmy @Geo32 = <0 1 2 3 4 5 6 7 8 9 b c d e f g h j k m n p q r s t u v w x y z>;\n\nsub geo_encode {\n    my( $latitude, $longitude, $precision ) = @_;\n    my @coord = ($latitude, $longitude);\n    my @range = ([-90, 90], [-180, 180]);\n    my($which,$value) = (1, '');\n    while (length($value) < $precision * 5) {\n        my $mid = sum(@{$range[$which]}) / 2;\n        $value .= my $upper = $coord[$which] <= $mid ? 0 : 1;\n        $range[$which][$upper ? 0 : 1] = $mid;\n        $which = $which ? 0 : 1;\n    }\n    my $enc;\n    my $iterator = natatime 5, split '', $value;\n    while (my @n = $iterator->()) {\n        $enc .= $Geo32[ord pack 'B8', '000' . join '', @n]; \n    }\n    $enc\n}\n\nsub geo_decode {\n    my($geo) = @_;\n     my @range = ([-90, 90], [-180, 180]);\n     my(%Geo32,$c); $Geo32{$_} = $c++ for @Geo32;\n     my $which = 1;\n     for ( split '', join '', map { sprintf '%05b', $_ } @Geo32{split '', $geo} ) {\n        $range[$which][$_] = sum(@{$range[$which]}) / 2;\n        $which = $which ? 0 : 1;\n     }\n     @range\n}\n\nfor ([51.433718,   -0.214126,  2, 'Ireland, most of England and Wales, small part of Scotland'],\n     [51.433718,   -0.214126,  9, \"the umpire's chair on Center Court at Wimbledon\"],\n     [51.433718,   -0.214126, 17, 'likely an individual molecule of the chair'],\n     [57.649110,   10.407440, 11, 'Wikipedia test value - R\u00e5bjerg Mile in Denmark'],\n     [59.115800, -151.687312,  7, 'Perl Island, Alaska'],\n     [38.743586, -109.499336,  8, 'Delicate Arch, Utah'],\n    ) {\n    my($lat, $long, $precision, $description) = @$_;\n    my $enc = geo_encode($lat, $long, $precision);\n    say \"\\n$lat, $long, $precision ($description):\" .\n        \"\\ngeo-encoded: $enc\\n\" .\n        'geo-decoded: ' . join ',  ',\n        map {         sprintf(\"%.@{[max(3,$precision-3)]}f\", (  -($$_[0] + $$_[1]) / 2)) .\n              ' \u00b1 ' . sprintf('%.3e',                        (abs($$_[0] - $$_[1]) / 2))\n            } geo_decode($enc);}\n", "target": "ch32 = \"0123456789bcdefghjkmnpqrstuvwxyz\"\nbool2ch = {f\"{i:05b}\": ch for i, ch in enumerate(ch32)}\nch2bool = {v : k for k, v in bool2ch.items()}\n\ndef bisect(val, mn, mx, bits):\n    mid = (mn + mx) / 2\n    if val < mid:\n        bits <<= 1                        \n        mx = mid                          \n    else:\n        bits = bits << 1 | 1              \n        mn = mid                          \n\n    return mn, mx, bits\n\ndef encoder(lat, lng, pre):\n    latmin, latmax = -90, 90\n    lngmin, lngmax = -180, 180\n    bits = 0\n    for i in range(pre * 5):\n        if i % 2:\n            \n            latmin, latmax, bits = bisect(lat, latmin, latmax, bits)\n        else:\n            \n            lngmin, lngmax, bits = bisect(lng, lngmin, lngmax, bits)\n    \n    b = f\"{bits:0{pre * 5}b}\"\n    geo = (bool2ch[b[i*5: (i+1)*5]] for i in range(pre))\n\n    return ''.join(geo)\n\ndef decoder(geo):\n    minmaxes, latlong = [[-90.0, 90.0], [-180.0, 180.0]], True\n    for c in geo:\n        for bit in ch2bool[c]:\n            minmaxes[latlong][bit != '1'] = sum(minmaxes[latlong]) / 2\n            latlong = not latlong\n\n    return minmaxes\n\nif __name__ == '__main__':\n    for (lat, lng), pre in [([51.433718, -0.214126],  2),\n                            ([51.433718, -0.214126],  9),\n                            ([57.64911,  10.40744] , 11),\n                            ([57.64911,  10.40744] , 22)]:\n        print(\"encoder(lat=%f, lng=%f, pre=%i) = %r\"\n              % (lat, lng, pre, encoder(lat, lng, pre)))\n"}
{"id": 383546, "name": "N-queens minimum and knights and bishops", "source": "Translate Perl to Python: use v5.36;\nuse builtin 'true', 'false';\nno warnings 'experimental::for_list', 'experimental::builtin';\n\nmy(@B, @D1, @D2, @D1x, @D2x, $N, $Min, $Layout);\n\nsub X ($a,$b)       { my @c; for my $aa (0..$a-1) { for my $bb (0..$b-1) { push @c, $aa, $bb } } @c }\nsub Xr($a,$b,$c,$d) { my @c; for my $ab ($a..$b)  { for my $cd ($c..$d)  { push @c, $ab, $cd } } @c }\n\nsub is_attacked($piece, $r, $c) {\n    if ($piece eq 'Q') {\n        for (0..$N-1) { return true if $B[$_][$c] or $B[$r][$_] }\n        return true if $D1x[ $D1[$r][$c] ] or\n                       $D2x[ $D2[$r][$c] ]\n    } elsif ($piece eq 'B') {\n        return true if $D1x[ $D1[$r][$c] ] or $D2x[ $D2[$r][$c] ]\n    } else { \n        return true if (\n            $B[$r][$c] or\n            $r+2 < $N and $c-1 >= 0 and $B[$r+2][$c-1] or\n            $r-2 >= 0 and $c-1 >= 0 and $B[$r-2][$c-1] or\n            $r+2 < $N and $c+1 < $N and $B[$r+2][$c+1] or\n            $r-2 >= 0 and $c+1 < $N and $B[$r-2][$c+1] or\n            $r+1 < $N and $c+2 < $N and $B[$r+1][$c+2] or\n            $r-1 >= 0 and $c+2 < $N and $B[$r-1][$c+2] or\n            $r+1 < $N and $c-2 >= 0 and $B[$r+1][$c-2] or\n            $r-1 >= 0 and $c-2 >= 0 and $B[$r-1][$c-2]\n        )\n   }\n   false\n}\n\nsub attacks($piece, $r, $c, $tr, $tc) {\n    if    ($piece eq 'Q') { $r==$tr or $c==$tc or abs($r - $tr)==abs($c - $tc) }\n    elsif ($piece eq 'B') { abs($r - $tr) == abs($c - $tc) }\n    else                  {\n        my ($rd, $cd) = (abs($tr - $r), abs($tc - $c));\n        ($rd == 1 and $cd == 2) or ($rd == 2 and $cd == 1)\n    }\n}\n\nsub store_layout($piece) {\n    $Layout = '';\n    for (@B) {\n        map { $Layout .= $_ ?  $piece.' ' : '. ' } @$_;\n        $Layout .=  \"\\n\";\n    }\n}\n\nsub place_piece($piece, $so_far, $max) {\n    return if $so_far >= $Min;\n    my ($all_attacked,$ti,$tj) = (true,0,0);\n    for my($i,$j) (X $N, $N) {\n        unless (is_attacked($piece, $i, $j)) {\n            ($all_attacked,$ti,$tj) = (false,$i,$j) and last\n        }\n        last unless $all_attacked\n    }\n    if ($all_attacked) {\n        $Min = $so_far;\n        store_layout($piece);\n    } elsif ($so_far <= $max) {\n        my($si,$sj) = ($ti,$tj);\n        if ($piece eq 'K') {\n            $si -= 2; $si = 0 if $si < 0;\n            $sj -= 2; $sj = 0 if $sj < 0;\n        }\n        for my ($i,$j) (Xr $si, $N-1, $sj, $N-1) {\n            unless (is_attacked($piece, $i, $j)) {\n                if (($i == $ti and $j == $tj) or attacks($piece, $i, $j, $ti, $tj)) {\n                    $B[$i][$j] = true;\n                    unless ($piece eq 'K') {\n                        ($D1x[ $D1[$i][$j] ], $D2x[ $D2[$i][$j] ]) = (true,true);\n                    };\n                    place_piece($piece, $so_far+1, $max);\n                    $B[$i][$j] = false;\n                    unless ($piece eq 'K') {\n                        ($D1x[ $D1[$i][$j] ], $D2x[ $D2[$i][$j] ]) = (false,false);\n                    }\n                }\n            }\n         }\n     }\n}\n\nmy @Pieces = <Q B K>;\nmy %Limits = ( 'Q' =>   10,     'B' =>    10,     'K' =>    10   );\nmy %Names  = ( 'Q' => 'Queens', 'B' => 'Bishops', 'K' =>'Knights');\n\nfor my $piece (@Pieces) {\n    say $Names{$piece} . \"\\n=======\\n\";\n    for ($N = 1 ; ; $N++) {\n        @B = map { [ (false) x $N ] } 1..$N;\n        unless ($piece eq 'K') {\n            @D2 = reverse @D1 = map { [$_ .. $N+$_-1] } 0..$N-1;\n            @D2x = @D1x = (false) x ((2*$N)-1);\n        }\n        $Min = 2**31 - 1;\n        my $nSQ   = $N**2;\n        for my $max (1..$nSQ) {\n            place_piece($piece, 0, $max);\n            last if $Min <= $nSQ\n        }\n        printf(\"%2d x\u00a0%-2d\u00a0: %d\\n\", $N, $N, $Min);\n        if ($N == $Limits{$piece}) {\n            printf \"\\n%s on a %d x %d board:\\n\", $Names{$piece}, $N, $N;\n            say $Layout and last\n        }\n    }\n}\n", "target": "\n\nfrom mip import Model, BINARY, xsum, minimize\n\ndef n_queens_min(N):\n    \n    if N < 4:\n        brd = [[0 for i in range(N)] for j in range(N)]\n        brd[0 if N < 2 else 1][0 if N < 2 else 1] = 1\n        return 1, brd\n\n    model = Model()\n    board = [[model.add_var(var_type=BINARY) for j in range(N)] for i in range(N)]\n    for k in range(N):\n        model += xsum(board[k][j] for j in range(N)) <= 1\n        model += xsum(board[i][k] for i in range(N)) <= 1\n\n    for k in range(1, 2 * N - 2):\n        model += xsum(board[k - j][j] for j in range(max(0, k - N + 1), min(k + 1, N))) <= 1\n\n    for k in range(2 - N, N - 1):\n        model += xsum(board[k + j][j] for j in range(max(0, -k), min(N - k, N))) <= 1\n\n    for i in range(N):\n        for j in range(N):\n            model += xsum([xsum(board[i][k] for k in range(N)),\n               xsum(board[k][j] for k in range(N)),\n               xsum(board[i + k][j + k] for k in range(-N, N)\n                  if 0 <= i + k < N and 0 <= j + k < N),\n               xsum(board[i - k][j + k] for k in range(-N, N)\n                  if 0 <= i - k < N and 0 <= j + k < N)]) >= 1\n\n    model.objective = minimize(xsum(board[i][j] for i in range(N) for j in range(N)))\n    model.optimize()\n    return model.objective_value, [[board[i][j].x for i in range(N)] for j in range(N)]\n\n\ndef n_bishops_min(N):\n    \n    model = Model()\n    board = [[model.add_var(var_type=BINARY) for j in range(N)] for i in range(N)]\n\n    for i in range(N):\n        for j in range(N):\n            model += xsum([\n               xsum(board[i + k][j + k] for k in range(-N, N)\n                  if 0 <= i + k < N and 0 <= j + k < N),\n               xsum(board[i - k][j + k] for k in range(-N, N)\n                  if 0 <= i - k < N and 0 <= j + k < N)]) >= 1\n\n    model.objective = minimize(xsum(board[i][j] for i in range(N) for j in range(N)))\n    model.optimize()\n    return model.objective_value, [[board[i][j].x for i in range(N)] for j in range(N)]\n\ndef n_knights_min(N):\n    \n    if N < 2:\n        return 1, \"N\"\n\n    knightdeltas = [(1, 2), (2, 1), (2, -1), (1, -2), (-1, -2), (-2, -1), (-2, 1), (-1, 2)]\n    model = Model()\n    \n    board = [[model.add_var(var_type=BINARY) for j in range(N + 4)] for i in range(N + 4)]\n    for i in range(N + 4):\n        model += xsum(board[i][j] for j in [0, 1, N + 2, N + 3]) == 0\n    for j in range(N + 4):\n        model += xsum(board[i][j] for i in [0, 1, N + 2, N + 3]) == 0\n\n    for i in range(2, N + 2):\n        for j in range(2, N + 2):\n            model += xsum([board[i][j]] + [board[i + d[0]][j + d[1]]\n               for d in knightdeltas]) >= 1\n            model += xsum([board[i + d[0]][j + d[1]]\n               for d in knightdeltas] + [100 * board[i][j]]) <= 100\n\n    model.objective = minimize(xsum(board[i][j] for i in range(2, N + 2) for j in range(2, N + 2)))\n    model.optimize()\n    minresult = model.objective_value\n    return minresult, [[board[i][j].x for i in range(2, N + 2)] for j in range(2, N + 2)]\n\n\nif __name__ == '__main__':\n    examples, pieces, chars = [[], [], []], [\"Queens\", \"Bishops\", \"Knights\"], ['Q', 'B', 'N']\n    print(\"   Squares    Queens   Bishops   Knights\")\n    for nrows in range(1, 11):\n        print(str(nrows * nrows).rjust(10), end='')\n        minval, examples[0] = n_queens_min(nrows)\n        print(str(int(minval)).rjust(10), end='')\n        minval, examples[1] = n_bishops_min(nrows)\n        print(str(int(minval)).rjust(10), end='')\n        minval, examples[2] = n_knights_min(nrows)\n        print(str(int(minval)).rjust(10))\n        if nrows == 10:\n            print(\"\\nExamples for N = 10:\")\n            for idx, piece in enumerate(chars):\n                print(f\"\\n{pieces[idx]}:\")\n                for row in examples[idx]:\n                    for sqr in row:\n                        print(chars[idx] if sqr == 1 else '.', '', end = '')\n                    print()\n                print()\n"}
{"id": 383547, "name": "Smallest numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'first';\nuse Math::AnyNum 'ipow';\n\nsub smallest { first { ipow($_,$_) =~ /$_[0]/ } 1..1e4 }\nsay join ' ', map { smallest($_) } 0..50;\n", "target": "\n\nimport sys\n\nif len(sys.argv)!=2:\n    print(\"Usage\u00a0: python \" + sys.argv[0] + \" <whole number>\")\n    exit()\n\nnumLimit = int(sys.argv[1])\n\nresultSet = {}\n\nbase = 1\n\nwhile len(resultSet)!=numLimit:\n    result = base**base\n\n    for i in range(0,numLimit):\n        if str(i) in str(result) and i not in resultSet:\n            resultSet[i] = base\n\n    base+=1\n\n[print(resultSet[i], end=' ') for i in sorted(resultSet)]\n"}
{"id": 383548, "name": "Gaussian primes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nmy ($plot, @primes) = gaussianprimes(10);\nprint \"Primes within 10\\n\", join(',  ', @primes) =~ s/.{94}\\K  /\\n/gr;\n($plot, @primes) = gaussianprimes(50);\nprint \"\\n\\nPlot within 50\\n$plot\";\n\nsub gaussianprimes\n  {\n  my $size = shift;\n  my $plot = ( ' ' x (2 * $size + 1) . \"\\n\" ) x (2 * $size + 1);\n  my @primes;\n  for my $A ( -$size .. $size )\n    {\n    my $limit = int sqrt $size**2 - $A**2;\n    for my $B ( -$limit .. $limit )\n      {\n      my $norm = $A**2 + $B**2;\n      if ( is_prime( $norm )\n      or ( $A==0 && is_prime(abs $B) && (abs($B)-3)%4 == 0)\n      or ( $B==0 && is_prime(abs $A) && (abs($A)-3)%4 == 0) )\n        {\n          push @primes, sprintf(\"%2d%2di\", $A, $B) =~ s/ (\\di)/+$1/r;\n          substr $plot, ($B + $size + 1) * (2 * $size + 2) + $A + $size + 1, 1, 'X';\n        }\n      }\n    }\n  return $plot, @primes;\n  }\n", "target": "\n\nfrom matplotlib.pyplot import scatter\nfrom sympy import isprime\nfrom math import isqrt\n\ndef norm(c):\n    \n    return c.real * c.real + c.imag * c.imag\n\n\ndef is_gaussian_prime(n):\n    \n    r, c = int(abs(n.real)), int(abs(n.imag))\n    return isprime(r * r + c * c) or c == 0 and isprime(r) and (r - 3) % 4 == 0 or r == 0 and isprime(c) and (c - 3) % 4 == 0\n\nif __name__ == '__main__':\n\n    limitsquared = 100\n    lim = isqrt(limitsquared)\n    testvals = [complex(r, c) for r in range(-lim, lim) for c in range(-lim, lim)]\n    gprimes = sorted(filter(lambda c : is_gaussian_prime(c) and norm(c) < limitsquared, testvals), key=norm)\n    print(f'Gaussian primes within {isqrt(limitsquared)} of the origin on the complex plane:')\n    for i, c in enumerate(gprimes):\n        print(str(c).ljust(9), end='\\n' if (i +1) % 10 == 0 else '')\n    scatter([c.real for c in gprimes], [c.imag for c in gprimes])\n"}
{"id": 383549, "name": "Doomsday rule", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nsub dow ($) {\n   my ($year, $month, $day) = split /-/;\n   my @D = $year%($year%25?4:16) ? (3,7,7,4,2,6,4,1,5,3,7,5) : (4,1,7,2,4,6,4,1,5,3,7,5);\n   my $c = int($year / 100);\n   my $s = ($year % 100) / 12;\n   my $t = ($year % 100) % 12;\n   my $a = ( 5 * ($c % 4) + 2 ) % 7;\n   my $b = ( $s + $t + int($t / 4) + $a ) % 7;\n\n   qw ( Sunday Monday Tuesday Wednesday Thursday Friday Saturday ) [\n      ($b + $day - $D[$month - 1] + 7) % 7 ]\n}\n\nfor (qw( 1800-01-06 1875-03-29 1915-12-07 1970-12-23 2043-05-14 2077-02-12 2101-04-02 )) {\n   print  $_, \" is a\u00a0: \", dow $_, \"\\n\";\n}\n", "target": "from datetime import date\nfrom calendar import isleap\n\ndef weekday(d):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n            \"Friday\", \"Saturday\"]\n    dooms = [\n        [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5],\n        [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n    ]\n    \n    c = d.year // 100\n    r = d.year % 100\n    s = r // 12\n    t = r % 12\n    c_anchor = (5 * (c % 4) + 2) % 7\n    doomsday = (s + t + (t // 4) + c_anchor) % 7\n    anchorday = dooms[isleap(d.year)][d.month - 1]\n    weekday = (doomsday + d.day - anchorday + 7) % 7\n    return days[weekday]\n\ndates = [date(*x) for x in\n    [(1800, 1, 6), (1875, 3, 29), (1915, 12, 7), (1970, 12, 23),\n     (2043, 5, 14), (2077, 2, 12), (2101, 4, 2)]\n]\n\nfor d in dates:\n    tense = \"was\" if d < date.today() else \"is\" if d == date.today() else \"will be\"\n    print(\"{} {} a {}\".format(d.strftime(\"%B %d, %Y\"), tense, weekday(d)))\n"}
{"id": 383550, "name": "Doomsday rule", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nsub dow ($) {\n   my ($year, $month, $day) = split /-/;\n   my @D = $year%($year%25?4:16) ? (3,7,7,4,2,6,4,1,5,3,7,5) : (4,1,7,2,4,6,4,1,5,3,7,5);\n   my $c = int($year / 100);\n   my $s = ($year % 100) / 12;\n   my $t = ($year % 100) % 12;\n   my $a = ( 5 * ($c % 4) + 2 ) % 7;\n   my $b = ( $s + $t + int($t / 4) + $a ) % 7;\n\n   qw ( Sunday Monday Tuesday Wednesday Thursday Friday Saturday ) [\n      ($b + $day - $D[$month - 1] + 7) % 7 ]\n}\n\nfor (qw( 1800-01-06 1875-03-29 1915-12-07 1970-12-23 2043-05-14 2077-02-12 2101-04-02 )) {\n   print  $_, \" is a\u00a0: \", dow $_, \"\\n\";\n}\n", "target": "from datetime import date\nfrom calendar import isleap\n\ndef weekday(d):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n            \"Friday\", \"Saturday\"]\n    dooms = [\n        [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5],\n        [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n    ]\n    \n    c = d.year // 100\n    r = d.year % 100\n    s = r // 12\n    t = r % 12\n    c_anchor = (5 * (c % 4) + 2) % 7\n    doomsday = (s + t + (t // 4) + c_anchor) % 7\n    anchorday = dooms[isleap(d.year)][d.month - 1]\n    weekday = (doomsday + d.day - anchorday + 7) % 7\n    return days[weekday]\n\ndates = [date(*x) for x in\n    [(1800, 1, 6), (1875, 3, 29), (1915, 12, 7), (1970, 12, 23),\n     (2043, 5, 14), (2077, 2, 12), (2101, 4, 2)]\n]\n\nfor d in dates:\n    tense = \"was\" if d < date.today() else \"is\" if d == date.today() else \"will be\"\n    print(\"{} {} a {}\".format(d.strftime(\"%B %d, %Y\"), tense, weekday(d)))\n"}
{"id": 383551, "name": "Gauss-Jordan matrix inversion", "source": "Translate Perl to Python: sub rref {\n  our @m; local *m = shift;\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n\n      ++$lead;}\n}\n\nsub display { join(\"\\n\" => map join(\" \" => map(sprintf(\"%6.2f\", $_), @$_)), @{+shift}).\"\\n\" }\n\nsub gauss_jordan_invert {\n    my(@m) = @_;\n    my $rows = @m;\n    my @i = identity(scalar @m);\n    push @{$m[$_]}, @{$i[$_]} for 0..$rows-1;\n    rref(\\@m);\n    map { splice @$_, 0, $rows } @m;\n    @m;\n}\n\nsub identity {\n    my($n) = @_;\n    map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1\n}\n\nmy @tests = (\n    [\n      [ 2, -1,  0 ],\n      [-1,  2, -1 ],\n      [ 0, -1,  2 ]\n    ],\n    [\n      [ -1, -2, 3, 2 ],\n      [ -4, -1, 6, 2 ],\n      [  7, -8, 9, 1 ],\n      [  1, -2, 1, 3 ]\n    ],\n);\n\nfor my $matrix (@tests) {\n    print \"Original Matrix:\\n\" . display(\\@$matrix) . \"\\n\";\n    my @gj = gauss_jordan_invert( @$matrix );\n    print \"Gauss-Jordan Inverted Matrix:\\n\" . display(\\@gj) . \"\\n\";\n    my @rt = gauss_jordan_invert( @gj );\n    print \"After round-trip:\\n\" . display(\\@rt) . \"\\n\";} . \"\\n\"\n}\n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 383552, "name": "Gauss-Jordan matrix inversion", "source": "Translate Perl to Python: sub rref {\n  our @m; local *m = shift;\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n\n      ++$lead;}\n}\n\nsub display { join(\"\\n\" => map join(\" \" => map(sprintf(\"%6.2f\", $_), @$_)), @{+shift}).\"\\n\" }\n\nsub gauss_jordan_invert {\n    my(@m) = @_;\n    my $rows = @m;\n    my @i = identity(scalar @m);\n    push @{$m[$_]}, @{$i[$_]} for 0..$rows-1;\n    rref(\\@m);\n    map { splice @$_, 0, $rows } @m;\n    @m;\n}\n\nsub identity {\n    my($n) = @_;\n    map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1\n}\n\nmy @tests = (\n    [\n      [ 2, -1,  0 ],\n      [-1,  2, -1 ],\n      [ 0, -1,  2 ]\n    ],\n    [\n      [ -1, -2, 3, 2 ],\n      [ -4, -1, 6, 2 ],\n      [  7, -8, 9, 1 ],\n      [  1, -2, 1, 3 ]\n    ],\n);\n\nfor my $matrix (@tests) {\n    print \"Original Matrix:\\n\" . display(\\@$matrix) . \"\\n\";\n    my @gj = gauss_jordan_invert( @$matrix );\n    print \"Gauss-Jordan Inverted Matrix:\\n\" . display(\\@gj) . \"\\n\";\n    my @rt = gauss_jordan_invert( @gj );\n    print \"After round-trip:\\n\" . display(\\@rt) . \"\\n\";} . \"\\n\"\n}\n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 383553, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub adaptive_Simpson_quadrature {\n    my($f, $left, $right, $eps) = @_;\n    my $lf = eval \"$f($left)\";\n    my $rf = eval \"$f($right)\";\n    my ($mid, $midf, $whole) = Simpson_quadrature_mid($f, $left, $lf, $right, $rf);\n    return recursive_Simpsons_asr($f, $left, $lf, $right, $rf, $eps, $whole, $mid, $midf);\n\n    sub Simpson_quadrature_mid {\n        my($g, $l, $lf, $r, $rf) = @_;\n        my $mid = ($l + $r) / 2;\n        my $midf = eval \"$g($mid)\";\n        ($mid, $midf, abs($r - $l) / 6 * ($lf + 4 * $midf + $rf))\n    }\n\n    sub recursive_Simpsons_asr {\n        my($h, $a, $fa, $b, $fb, $eps, $whole, $m, $fm) = @_;\n        my ($lm, $flm, $left)  = Simpson_quadrature_mid($h, $a, $fa, $m, $fm);\n        my ($rm, $frm, $right) = Simpson_quadrature_mid($h, $m, $fm, $b, $fb);\n        my $delta = $left + $right - $whole;\n        abs($delta) <= 15 * $eps\n            ? $left + $right + $delta / 15\n            : recursive_Simpsons_asr($h, $a, $fa, $m, $fm, $eps/2, $left,  $lm, $flm) +\n              recursive_Simpsons_asr($h, $m, $fm, $b, $fb, $eps/2, $right, $rm, $frm)\n    }\n}\n\nmy ($a, $b) = (0, 1);\nmy $sin = adaptive_Simpson_quadrature('sin', $a, $b, 1e-9);\nprintf \"Simpson's integration of sine from $a to $b =\u00a0%.9f\", $sin\n", "target": "\n\n\n\nimport math\n\nimport collections\ntriple = collections.namedtuple('triple', 'm fm simp')\n\ndef _quad_simpsons_mem(f: callable, a: float , fa: float, b: float, fb: float)->tuple:\n    \n    m = a + (b - a) / 2\n    fm = f(m)\n    simp = abs(b - a) / 6 * (fa + 4*fm + fb)\n    return triple(m, fm, simp,)\n \ndef _quad_asr(f: callable, a: float, fa: float, b: float, fb: float, eps: float, whole: float, m: float, fm: float)->float:\n    \n    lt = _quad_simpsons_mem(f, a, fa, m, fm)\n    rt = _quad_simpsons_mem(f, m, fm, b, fb)\n    delta = lt.simp + rt.simp - whole\n    return (lt.simp + rt.simp + delta/15\n        if (abs(delta) <= eps * 15) else\n            _quad_asr(f, a, fa, m, fm, eps/2, lt.simp, lt.m, lt.fm) +\n            _quad_asr(f, m, fm, b, fb, eps/2, rt.simp, rt.m, rt.fm)\n    )\n\ndef quad_asr(f: callable, a: float, b: float, eps: float)->float:\n    \n    fa = f(a)\n    fb = f(b)\n    t = _quad_simpsons_mem(f, a, fa, b, fb)\n    return _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm)\n\ndef main():\n    (a, b,) = (0.0, 1.0,)\n    sinx = quad_asr(math.sin, a, b, 1e-09);\n    print(\"Simpson's integration of sine from {} to {} = {}\\n\".format(a, b, sinx))\n\nmain()\n"}
{"id": 383554, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub adaptive_Simpson_quadrature {\n    my($f, $left, $right, $eps) = @_;\n    my $lf = eval \"$f($left)\";\n    my $rf = eval \"$f($right)\";\n    my ($mid, $midf, $whole) = Simpson_quadrature_mid($f, $left, $lf, $right, $rf);\n    return recursive_Simpsons_asr($f, $left, $lf, $right, $rf, $eps, $whole, $mid, $midf);\n\n    sub Simpson_quadrature_mid {\n        my($g, $l, $lf, $r, $rf) = @_;\n        my $mid = ($l + $r) / 2;\n        my $midf = eval \"$g($mid)\";\n        ($mid, $midf, abs($r - $l) / 6 * ($lf + 4 * $midf + $rf))\n    }\n\n    sub recursive_Simpsons_asr {\n        my($h, $a, $fa, $b, $fb, $eps, $whole, $m, $fm) = @_;\n        my ($lm, $flm, $left)  = Simpson_quadrature_mid($h, $a, $fa, $m, $fm);\n        my ($rm, $frm, $right) = Simpson_quadrature_mid($h, $m, $fm, $b, $fb);\n        my $delta = $left + $right - $whole;\n        abs($delta) <= 15 * $eps\n            ? $left + $right + $delta / 15\n            : recursive_Simpsons_asr($h, $a, $fa, $m, $fm, $eps/2, $left,  $lm, $flm) +\n              recursive_Simpsons_asr($h, $m, $fm, $b, $fb, $eps/2, $right, $rm, $frm)\n    }\n}\n\nmy ($a, $b) = (0, 1);\nmy $sin = adaptive_Simpson_quadrature('sin', $a, $b, 1e-9);\nprintf \"Simpson's integration of sine from $a to $b =\u00a0%.9f\", $sin\n", "target": "\n\n\n\nimport math\n\nimport collections\ntriple = collections.namedtuple('triple', 'm fm simp')\n\ndef _quad_simpsons_mem(f: callable, a: float , fa: float, b: float, fb: float)->tuple:\n    \n    m = a + (b - a) / 2\n    fm = f(m)\n    simp = abs(b - a) / 6 * (fa + 4*fm + fb)\n    return triple(m, fm, simp,)\n \ndef _quad_asr(f: callable, a: float, fa: float, b: float, fb: float, eps: float, whole: float, m: float, fm: float)->float:\n    \n    lt = _quad_simpsons_mem(f, a, fa, m, fm)\n    rt = _quad_simpsons_mem(f, m, fm, b, fb)\n    delta = lt.simp + rt.simp - whole\n    return (lt.simp + rt.simp + delta/15\n        if (abs(delta) <= eps * 15) else\n            _quad_asr(f, a, fa, m, fm, eps/2, lt.simp, lt.m, lt.fm) +\n            _quad_asr(f, m, fm, b, fb, eps/2, rt.simp, rt.m, rt.fm)\n    )\n\ndef quad_asr(f: callable, a: float, b: float, eps: float)->float:\n    \n    fa = f(a)\n    fb = f(b)\n    t = _quad_simpsons_mem(f, a, fa, b, fb)\n    return _quad_asr(f, a, fa, b, fb, eps, t.simp, t.m, t.fm)\n\ndef main():\n    (a, b,) = (0.0, 1.0,)\n    sinx = quad_asr(math.sin, a, b, 1e-09);\n    print(\"Simpson's integration of sine from {} to {} = {}\\n\".format(a, b, sinx))\n\nmain()\n"}
{"id": 383555, "name": "Colorful numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse enum qw(False True);\nuse List::Util <max uniqint product>;\nuse Algorithm::Combinatorics qw(combinations permutations);\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub is_colorful {\n    my($n) = @_;\n    return True if 0 <= $n and $n <= 9;\n    return False if $n =~ /0|1/ or $n < 0;\n    my @digits = split '', $n;\n    return False unless @digits == uniqint @digits;\n    my @p;\n    for my $w (0 .. @digits) {\n        push @p, map { product @digits[$_ .. $_+$w] } 0 .. @digits-$w-1;\n        return False unless @p == uniqint @p\n    }\n    True\n}\n\nsay \"Colorful numbers less than 100:\\n\" . table 10, grep { is_colorful $_ } 0..100;\n\nmy $largest = 98765432;\n1 while not is_colorful --$largest;\nsay \"Largest magnitude colorful number: $largest\\n\";\n\nmy $total= 10;\nmap { is_colorful(join '', @$_) and $total++ } map { permutations $_ } combinations [2..9], $_ for 2..8;\nsay \"Total colorful numbers: $total\";\n", "target": "from math import prod\n\nlargest = [0]\n\ndef iscolorful(n):\n    if 0 <= n < 10:\n        return True\n    dig = [int(c) for c in str(n)]\n    if 1 in dig or 0 in dig or len(dig) > len(set(dig)):\n        return False\n    products = list(set(dig))\n    for i in range(len(dig)):\n        for j in range(i+2, len(dig)+1):\n            p = prod(dig[i:j])\n            if p in products:\n                return False\n            products.append(p)\n\n    largest[0] = max(n, largest[0])\n    return True\n\nprint('Colorful numbers for 1:25, 26:50, 51:75, and 76:100:')\nfor i in range(1, 101, 25):\n    for j in range(25):\n        if iscolorful(i + j):\n            print(f'{i + j: 5,}', end='')\n    print()\n\ncsum = 0\nfor i in range(8):\n    j = 0 if i == 0 else 10**i\n    k = 10**(i+1) - 1\n    n = sum(iscolorful(x) for x in range(j, k+1))\n    csum += n\n    print(f'The count of colorful numbers between {j} and {k} is {n}.')\n\nprint(f'The largest possible colorful number is {largest[0]}.')\nprint(f'The total number of colorful numbers is {csum}.')\n"}
{"id": 383556, "name": "Colorful numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse enum qw(False True);\nuse List::Util <max uniqint product>;\nuse Algorithm::Combinatorics qw(combinations permutations);\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub is_colorful {\n    my($n) = @_;\n    return True if 0 <= $n and $n <= 9;\n    return False if $n =~ /0|1/ or $n < 0;\n    my @digits = split '', $n;\n    return False unless @digits == uniqint @digits;\n    my @p;\n    for my $w (0 .. @digits) {\n        push @p, map { product @digits[$_ .. $_+$w] } 0 .. @digits-$w-1;\n        return False unless @p == uniqint @p\n    }\n    True\n}\n\nsay \"Colorful numbers less than 100:\\n\" . table 10, grep { is_colorful $_ } 0..100;\n\nmy $largest = 98765432;\n1 while not is_colorful --$largest;\nsay \"Largest magnitude colorful number: $largest\\n\";\n\nmy $total= 10;\nmap { is_colorful(join '', @$_) and $total++ } map { permutations $_ } combinations [2..9], $_ for 2..8;\nsay \"Total colorful numbers: $total\";\n", "target": "from math import prod\n\nlargest = [0]\n\ndef iscolorful(n):\n    if 0 <= n < 10:\n        return True\n    dig = [int(c) for c in str(n)]\n    if 1 in dig or 0 in dig or len(dig) > len(set(dig)):\n        return False\n    products = list(set(dig))\n    for i in range(len(dig)):\n        for j in range(i+2, len(dig)+1):\n            p = prod(dig[i:j])\n            if p in products:\n                return False\n            products.append(p)\n\n    largest[0] = max(n, largest[0])\n    return True\n\nprint('Colorful numbers for 1:25, 26:50, 51:75, and 76:100:')\nfor i in range(1, 101, 25):\n    for j in range(25):\n        if iscolorful(i + j):\n            print(f'{i + j: 5,}', end='')\n    print()\n\ncsum = 0\nfor i in range(8):\n    j = 0 if i == 0 else 10**i\n    k = 10**(i+1) - 1\n    n = sum(iscolorful(x) for x in range(j, k+1))\n    csum += n\n    print(f'The count of colorful numbers between {j} and {k} is {n}.')\n\nprint(f'The largest possible colorful number is {largest[0]}.')\nprint(f'The total number of colorful numbers is {csum}.')\n"}
{"id": 383557, "name": "Generate random chess position", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nuse List::AllUtils <shuffle any natatime>;\n\nsub pick1 { return @_[rand @_] }\n\nsub gen_FEN {\n    my $n = 1 + int rand 31;\n    my @n = (shuffle(0 .. 63))[1 .. $n];\n\n    my @kings;\n\n  KINGS: {\n    for my $a (@n) {\n        for my $b (@n) {\n            next unless $a != $b && abs(int($a/8) - int($b/8)) > 1 || abs($a%8 - $b%8) > 1;\n            @kings = ($a, $b);\n            last KINGS;\n        }\n        die 'No good place for kings!';\n    }\n    }\n\n    my ($row, @pp);\n    my @pieces = <p P n N b B r R q Q>;\n    my @k      = rand() < .5 ? <K k> : <k K>;\n\n    for my $sq (0 .. 63) {\n        if (any { $_ == $sq } @kings) {\n            push @pp, shift @k;\n        }\n        elsif (any { $_ == $sq } @n) {\n            $row = 7 - int $sq / 8;\n            push @pp,\n                $row == 0 ? pick1(grep { $_ ne 'P' } @pieces)\n              : $row == 7 ? pick1(grep { $_ ne 'P' } @pieces)\n              :             pick1(@pieces);\n        }\n        else {\n            push @pp, '\u00f8';\n        }\n    }\n\n    my @qq;\n    my $iter = natatime 8, @pp;\n    while (my $row = join '', $iter->()) {\n        $row =~ s/((\u00f8)\\2*)/length($1)/eg;\n        push @qq, $row;\n    }\n    return join('/', @qq) . ' w - - 0 1';\n}\n\nsay gen_FEN();\n", "target": "import random\n\nboard = [[\" \" for x in range(8)] for y in range(8)]\npiece_list = [\"R\", \"N\", \"B\", \"Q\", \"P\"]\n\n\ndef place_kings(brd):\n\twhile True:\n\t\trank_white, file_white, rank_black, file_black = random.randint(0,7), random.randint(0,7), random.randint(0,7), random.randint(0,7)\n\t\tdiff_list = [abs(rank_white - rank_black),  abs(file_white - file_black)]\n\t\tif sum(diff_list) > 2 or set(diff_list) == set([0, 2]):\n\t\t\tbrd[rank_white][file_white], brd[rank_black][file_black] = \"K\", \"k\"\n\t\t\tbreak\n\ndef populate_board(brd, wp, bp):\n\tfor x in range(2):\n\t\tif x == 0:\n\t\t\tpiece_amount = wp\n\t\t\tpieces = piece_list\n\t\telse:\n\t\t\tpiece_amount = bp\n\t\t\tpieces = [s.lower() for s in piece_list]\n\t\twhile piece_amount != 0:\n\t\t\tpiece_rank, piece_file = random.randint(0, 7), random.randint(0, 7)\n\t\t\tpiece = random.choice(pieces)\n\t\t\tif brd[piece_rank][piece_file] == \" \" and pawn_on_promotion_square(piece, piece_rank) == False:\n\t\t\t\tbrd[piece_rank][piece_file] = piece\n\t\t\t\tpiece_amount -= 1\n\ndef fen_from_board(brd):\n\tfen = \"\"\n\tfor x in brd:\n\t\tn = 0\n\t\tfor y in x:\n\t\t\tif y == \" \":\n\t\t\t\tn += 1\n\t\t\telse:\n\t\t\t\tif n != 0:\n\t\t\t\t\tfen += str(n)\n\t\t\t\tfen += y\n\t\t\t\tn = 0\n\t\tif n != 0:\n\t\t\tfen += str(n)\n\t\tfen += \"/\" if fen.count(\"/\") < 7 else \"\"\n\tfen += \" w - - 0 1\\n\"\n\treturn fen\n\ndef pawn_on_promotion_square(pc, pr):\n\tif pc == \"P\" and pr == 0:\n\t\treturn True\n\telif pc == \"p\" and pr == 7:\n\t\treturn True\n\treturn False\n\n\ndef start():\n\tpiece_amount_white, piece_amount_black = random.randint(0, 15), random.randint(0, 15)\n\tplace_kings(board)\n\tpopulate_board(board, piece_amount_white, piece_amount_black)\n\tprint(fen_from_board(board))\n\tfor x in board:\n\t\tprint(x)\n\n\nstart()\n"}
{"id": 383558, "name": "Arithmetic derivative", "source": "Translate Perl to Python: use v5.36;\nuse bigint;\nno warnings 'uninitialized';\nuse List::Util 'max';\nuse ntheory 'factor';\n\nsub table ($c, @V) { my $t = $c * (my $w = 2 + length max @V); ( sprintf( ('%'.$w.'d')x@V, @V) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub D ($n) {\n    my(%f, $s);\n    $f{$_}++ for factor max 1, my $nabs = abs $n;\n    map { $s += $nabs * $f{$_} / $_ } keys %f;\n    $n > 0 ? $s : -$s;\n}\n\nsay table 10, map { D $_ } -99 .. 100;\nsay join \"\\n\", map { sprintf('D(10**%-2d) / 7 == ', $_) . D(10**$_) / 7 } 1 .. 20;\n", "target": "from sympy.ntheory import factorint\n\ndef D(n):\n    if n < 0:\n        return -D(-n)\n    elif n < 2:\n        return 0\n    else:\n        fdict = factorint(n)\n        if len(fdict) == 1 and 1 in fdict: \n            return 1\n        return sum([n * e // p for p, e in fdict.items()])\n\nfor n in range(-99, 101):\n    print('{:5}'.format(D(n)), end='\\n' if n % 10 == 0 else '')\n\nprint()\nfor m in range(1, 21):\n    print('(D for 10**{}) divided by 7 is {}'.format(m, D(10 ** m) // 7))\n"}
{"id": 383559, "name": "Special factorials", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature qw<signatures say>;\nno warnings qw<experimental::signatures>;\nuse bigint try => 'GMP';\nuse ntheory qw<vecprod vecsum vecreduce vecfirstidx>;\n\nsub  f ($n) { vecreduce     { $a * $b } 1,              1..$n }\nsub sf ($n) { vecprod   map { f($_) }                   1..$n }\nsub  H ($n) { vecprod   map { $_ ** $_ }                1..$n }\nsub af ($n) { vecsum    map { (-1) ** ($n-$_) * f($_) } 1..$n }\nsub ef ($n) { vecreduce     { $b ** $a }                1..$n }\nsub rf ($n) {\n    my $v =  vecfirstidx { f($_) >= $n  } 0..1E6;\n    $n == f($v) ? $v : 'Nope'\n}\n\nsay 'sf\u00a0: ' . join ' ', map { sf $_ } 0..9;\nsay 'H \u00a0: ' . join ' ', map {  H $_ } 0..9;\nsay 'af\u00a0: ' . join ' ', map { af $_ } 0..9;\nsay 'ef\u00a0: ' . join ' ', map { ef $_ } 1..4;\nsay '5$ has ' . length(5**4**3**2) . ' digits';\nsay 'rf\u00a0: ' . join ' ', map { rf $_ } <1 2 6 24 120 720 5040 40320 362880 3628800>;\nsay 'rf(119) = ' . rf(119);\n", "target": "\n\nfrom math import prod\n\ndef superFactorial(n):\n    return prod([prod(range(1,i+1)) for i in range(1,n+1)])\n\ndef hyperFactorial(n):\n    return prod([i**i for i in range(1,n+1)])\n\ndef alternatingFactorial(n):\n    return sum([(-1)**(n-i)*prod(range(1,i+1)) for i in range(1,n+1)])\n\ndef exponentialFactorial(n):\n    if n in [0,1]:\n        return 1\n    else:\n        return n**exponentialFactorial(n-1)\n        \ndef inverseFactorial(n):\n    i = 1\n    while True:\n        if n == prod(range(1,i)):\n            return i-1\n        elif n < prod(range(1,i)):\n            return \"undefined\"\n        i+=1\n\nprint(\"Superfactorials for [0,9]\u00a0:\")\nprint({\"sf(\" + str(i) + \") \" : superFactorial(i) for i in range(0,10)})\n\nprint(\"\\nHyperfactorials for [0,9]\u00a0:\")\nprint({\"H(\" + str(i) + \") \"  : hyperFactorial(i) for i in range(0,10)})\n\nprint(\"\\nAlternating factorials for [0,9]\u00a0:\")\nprint({\"af(\" + str(i) + \") \" : alternatingFactorial(i) for i in range(0,10)})\n\nprint(\"\\nExponential factorials for [0,4]\u00a0:\")\nprint({str(i) + \"$ \" : exponentialFactorial(i) for i in range(0,5)})\n\nprint(\"\\nDigits in 5$\u00a0: \" , len(str(exponentialFactorial(5))))\n\nfactorialSet = [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]\n\nprint(\"\\nInverse factorials for \" , factorialSet)\nprint({\"rf(\" + str(i) + \") \":inverseFactorial(i) for i in factorialSet})\n\nprint(\"\\nrf(119)\u00a0: \" + inverseFactorial(119))\n"}
{"id": 383560, "name": "Sierpinski square curve", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\nuse constant pi => 2 * atan2(1, 0);\n\nmy $rule = 'XF-F+F-XF+F+XF-F+F-X';\nmy $S = 'F+F+XF+F+XF';\n$S =~ s/X/$rule/g for 1..5;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = pi/4;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/2; }\n    elsif (/\\-/) { $theta -= pi/2; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-square-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import matplotlib.pyplot as plt\nimport math\n\n\ndef nextPoint(x, y, angle):\n    a = math.pi * angle / 180\n    x2 = (int)(round(x + (1 * math.cos(a))))\n    y2 = (int)(round(y + (1 * math.sin(a))))\n    return x2, y2\n\n\ndef expand(axiom, rules, level):\n    for l in range(0, level):\n        a2 = \"\"\n        for c in axiom:\n            if c in rules:\n                a2 += rules[c]\n            else:\n                a2 += c\n        axiom = a2\n    return axiom\n\n\ndef draw_lsystem(axiom, rules, angle, iterations):\n    xp = [1]\n    yp = [1]\n    direction = 0\n    for c in expand(axiom, rules, iterations):\n        if c == \"F\":\n            xn, yn = nextPoint(xp[-1], yp[-1], direction)\n            xp.append(xn)\n            yp.append(yn)\n        elif c == \"-\":\n            direction = direction - angle\n            if direction < 0:\n                direction = 360 + direction\n        elif c == \"+\":\n            direction = (direction + angle) % 360\n\n    plt.plot(xp, yp)\n    plt.show()\n\n\nif __name__ == '__main__':\n    \n    s_axiom = \"F+XF+F+XF\"\n    s_rules = {\"X\": \"XF-F+F-XF+F+XF-F+F-X\"}\n    s_angle = 90\n\n    draw_lsystem(s_axiom, s_rules, s_angle, 3)\n"}
{"id": 383561, "name": "Achilles numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say current_sub>;\nuse experimental 'signatures';\nuse List::AllUtils <max head uniqint>;\nuse ntheory <is_square_free is_power euler_phi>;\nuse Math::AnyNum <:overload idiv iroot ipow is_coprime>;\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub powerful_numbers ($n, $k = 2) {\n    my @powerful;\n    sub ($m, $r) {\n        $r < $k and push @powerful, $m and return;\n        for my $v (1 .. iroot(idiv($n, $m), $r)) {\n            if ($r > $k) { next unless is_square_free($v) and is_coprime($m, $v) }\n            __SUB__->($m * ipow($v, $r), $r - 1);\n        }\n    }->(1, 2*$k - 1);\n    sort { $a <=> $b } @powerful;\n}\n\nmy(@P, @achilles, %Ahash, @strong);\n@P = uniqint @P, powerful_numbers(10**9, $_) for 2..9; shift @P;\n!is_power($_) and push @achilles, $_ and $Ahash{$_}++ for @P;\n$Ahash{euler_phi $_} and push @strong, $_ for @achilles;\n\nsay \"First 50 Achilles numbers:\\n\"        . table 10, head 50, @achilles;\nsay \"First 30 strong Achilles numbers:\\n\" . table 10, head 30, @strong;\nsay \"Number of Achilles numbers with:\\n\";\nfor my $l (2..9) {\n    my $c; $l == length and $c++ for @achilles;\n    say \"$l digits: $c\";\n}\n", "target": "from math import gcd\nfrom sympy import factorint\n \ndef is_Achilles(n):\n    p = factorint(n).values()\n    return all(i > 1 for i in p) and gcd(*p) == 1\n\ndef is_strong_Achilles(n):\n    return is_Achilles(n) and is_Achilles(totient(n))\n \ndef test_strong_Achilles(nachilles, nstrongachilles):\n    \n    print('First', nachilles, 'Achilles numbers:')\n    n, found = 0, 0\n    while found < nachilles:\n        if is_Achilles(n):\n            found += 1\n            print(f'{n: 8,}', end='\\n' if found % 10 == 0 else '')\n        n += 1\n\n    \n    print('\\nFirst', nstrongachilles, 'strong Achilles numbers:')\n    n, found = 0, 0\n    while found < nstrongachilles:\n        if is_strong_Achilles(n):\n            found += 1\n            print(f'{n: 9,}', end='\\n' if found % 10 == 0 else '')\n        n += 1\n\n    \n    print('\\nCount of Achilles numbers for various intervals:')\n    intervals = [[10, 99], [100, 999], [1000, 9999], [10000, 99999], [100000, 999999]]\n    for interval in intervals:\n        print(f'{interval}:', sum(is_Achilles(i) for i in range(*interval)))\n\n\ntest_strong_Achilles(50, 100)\n"}
{"id": 383562, "name": "Achilles numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say current_sub>;\nuse experimental 'signatures';\nuse List::AllUtils <max head uniqint>;\nuse ntheory <is_square_free is_power euler_phi>;\nuse Math::AnyNum <:overload idiv iroot ipow is_coprime>;\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub powerful_numbers ($n, $k = 2) {\n    my @powerful;\n    sub ($m, $r) {\n        $r < $k and push @powerful, $m and return;\n        for my $v (1 .. iroot(idiv($n, $m), $r)) {\n            if ($r > $k) { next unless is_square_free($v) and is_coprime($m, $v) }\n            __SUB__->($m * ipow($v, $r), $r - 1);\n        }\n    }->(1, 2*$k - 1);\n    sort { $a <=> $b } @powerful;\n}\n\nmy(@P, @achilles, %Ahash, @strong);\n@P = uniqint @P, powerful_numbers(10**9, $_) for 2..9; shift @P;\n!is_power($_) and push @achilles, $_ and $Ahash{$_}++ for @P;\n$Ahash{euler_phi $_} and push @strong, $_ for @achilles;\n\nsay \"First 50 Achilles numbers:\\n\"        . table 10, head 50, @achilles;\nsay \"First 30 strong Achilles numbers:\\n\" . table 10, head 30, @strong;\nsay \"Number of Achilles numbers with:\\n\";\nfor my $l (2..9) {\n    my $c; $l == length and $c++ for @achilles;\n    say \"$l digits: $c\";\n}\n", "target": "from math import gcd\nfrom sympy import factorint\n \ndef is_Achilles(n):\n    p = factorint(n).values()\n    return all(i > 1 for i in p) and gcd(*p) == 1\n\ndef is_strong_Achilles(n):\n    return is_Achilles(n) and is_Achilles(totient(n))\n \ndef test_strong_Achilles(nachilles, nstrongachilles):\n    \n    print('First', nachilles, 'Achilles numbers:')\n    n, found = 0, 0\n    while found < nachilles:\n        if is_Achilles(n):\n            found += 1\n            print(f'{n: 8,}', end='\\n' if found % 10 == 0 else '')\n        n += 1\n\n    \n    print('\\nFirst', nstrongachilles, 'strong Achilles numbers:')\n    n, found = 0, 0\n    while found < nstrongachilles:\n        if is_strong_Achilles(n):\n            found += 1\n            print(f'{n: 9,}', end='\\n' if found % 10 == 0 else '')\n        n += 1\n\n    \n    print('\\nCount of Achilles numbers for various intervals:')\n    intervals = [[10, 99], [100, 999], [1000, 9999], [10000, 99999], [100000, 999999]]\n    for interval in intervals:\n        print(f'{interval}:', sum(is_Achilles(i) for i in range(*interval)))\n\n\ntest_strong_Achilles(50, 100)\n"}
{"id": 383563, "name": "Permutations with some identical elements", "source": "Translate Perl to Python: use ntheory qw<formultiperm>;\n\nformultiperm { print join('',@_) . ' ' } [<1 1 2>];           print \"\\n\\n\";\nformultiperm { print join('',@_) . ' ' } [<1 1 2 2 2 3>];     print \"\\n\\n\";\nformultiperm { print join('',@_) . ' ' } [split //,'AABBBC']; print \"\\n\";\n", "target": "\n\nfrom itertools import permutations\n\nnumList = [2,3,1]\n\nbaseList = []\n\nfor i in numList:\n    for j in range(0,i):\n        baseList.append(i)\n\nstringDict = {'A':2,'B':3,'C':1}\n\nbaseString=\"\"\n\nfor i in stringDict:\n    for j in range(0,stringDict[i]):\n        baseString+=i\n\nprint(\"Permutations for \" + str(baseList) + \"\u00a0: \")\n[print(i) for i in set(permutations(baseList))]\n\nprint(\"Permutations for \" + baseString + \"\u00a0: \")\n[print(i) for i in set(permutations(baseString))]\n"}
{"id": 383564, "name": "Pisano period", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(primes factor_exp lcm);\n\nsub pisano_period_pp {\n    my($a, $b, $n, $k) = (0, 1, $_[0]**$_[1]);\n    while (++$k) {\n        ($a, $b) = ($b, ($a+$b) % $n);\n        return $k if $a == 0 and $b == 1;\n    }\n}\n\nsub pisano_period {\n    (lcm map { pisano_period_pp($$_[0],$$_[1]) } factor_exp($_[0])) or 1;\n}\n\nsub display { (sprintf \"@{['%5d' x @_]}\", @_) =~ s/(.{75})/$1\\n/gr }\n\nsay \"Pisano periods for squares of primes p <= 50:\\n\", display( map { pisano_period_pp($_, 2) } @{primes(1,  50)} ),\n  \"\\nPisano periods for primes p <= 180:\\n\",           display( map { pisano_period_pp($_, 1) } @{primes(1, 180)} ),\n\"\\n\\nPisano periods for integers n from 1 to 180:\\n\",  display( map { pisano_period   ($_   ) }          1..180   );\n", "target": "from sympy import isprime, lcm, factorint, primerange\nfrom functools import reduce\n\n\ndef pisano1(m):\n    \"Simple definition\"\n    if m < 2:\n        return 1\n    lastn, n = 0, 1\n    for i in range(m ** 2):\n        lastn, n = n, (lastn + n) % m\n        if lastn == 0 and n == 1:\n            return i + 1\n    return 1\n\ndef pisanoprime(p, k):\n    \"Use conjecture \u03c0(p ** k) == p ** (k \u2212 1) * \u03c0(p) for prime p and int k > 1\"\n    assert isprime(p) and k > 0\n    return p ** (k - 1) * pisano1(p)\n\ndef pisano_mult(m, n):\n    \"pisano(m*n) where m and n assumed coprime integers\"\n    return lcm(pisano1(m), pisano1(n))\n\ndef pisano2(m):\n    \"Uses prime factorization of m\"\n    return reduce(lcm, (pisanoprime(prime, mult)\n                        for prime, mult in factorint(m).items()), 1)\n\n\nif __name__ == '__main__':\n    for n in range(1, 181):\n        assert pisano1(n) == pisano2(n), \"Wall-Sun-Sun prime exists??!!\"\n    print(\"\\nPisano period (p, 2) for primes less than 50\\n \",\n          [pisanoprime(prime, 2) for prime in primerange(1, 50)])\n    print(\"\\nPisano period (p, 1) for primes less than 180\\n \",\n          [pisanoprime(prime, 1) for prime in primerange(1, 180)])\n    print(\"\\nPisano period (p) for integers 1 to 180\")\n    for i in range(1, 181):\n        print(\" %3d\" % pisano2(i), end=\"\" if i % 10 else \"\\n\")\n"}
{"id": 383565, "name": "Numerical and alphabetical suffixes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy %suffix = qw( k 1e3 m 1e6 g 1e9 t 1e12 p 1e15 e 1e18 z 1e21 y 1e24 x 1e27\n  w 1e30 v 1e33 u 1e36 ki 2**10 mi 2**20 gi 2**30 ti 2**40 pi 2**50 ei 2**60\n  zi 2**70 yi 2**80 xi 2**90 wi 2**100 vi 2**110 ui 2**120 );\n\nlocal $\" = '  '; \nprint \"numbers = ${_}results = @{[ map suffix($_), split ]}\\n\\n\" while <DATA>;\n\nsub suffix\n  {\n  my ($value, $mods) = shift =~ tr/,//dr =~ /([+-]?[\\d.]+(?:e[+-]\\d+)?)(.*)/i;\n  $value *= $^R while $mods =~ /\n      PAIRs?            (?{       2 })\n    | SCO(re?)?         (?{      20 })\n    | DOZ(e(ns?)?)?     (?{      12 })\n    | GREATGR(o(ss?)?)? (?{    1728 }) \n    | GR(o(ss?)?)?      (?{     144 })\n    | GOOGOLs?          (?{ 10**100 })\n    | [kmgtpezyxwvu]i?  (?{ eval $suffix{ lc $& } })\n    |\u00a0!+ (?{ my $factor = $value; \n        $value *= $factor while ($factor -= length $&) > 1;\n        1 })\n    /gix;\n  return $value =~ s/(\\..*)|\\B(?=(\\d\\d\\d)+(?!\\d))/$1 || ','/ger;\n  }\n\n", "target": "from functools import reduce\nfrom operator import mul\nfrom decimal import *\n\ngetcontext().prec = MAX_PREC\n\ndef expand(num):\n    suffixes = [\n        \n        ('greatgross', 7, 12, 3),\n        ('gross', 2, 12, 2),\n        ('dozens', 3, 12, 1),\n        ('pairs', 4, 2, 1),\n        ('scores', 3, 20, 1),\n        ('googols', 6, 10, 100),\n        ('ki', 2, 2, 10),\n        ('mi', 2, 2, 20),\n        ('gi', 2, 2, 30),\n        ('ti', 2, 2, 40),\n        ('pi', 2, 2, 50),\n        ('ei', 2, 2, 60),\n        ('zi', 2, 2, 70),\n        ('yi', 2, 2, 80),\n        ('xi', 2, 2, 90),\n        ('wi', 2, 2, 100),\n        ('vi', 2, 2, 110),\n        ('ui', 2, 2, 120),\n        ('k', 1, 10, 3),\n        ('m', 1, 10, 6),\n        ('g', 1, 10, 9),\n        ('t', 1, 10, 12),\n        ('p', 1, 10, 15),\n        ('e', 1, 10, 18),\n        ('z', 1, 10, 21),\n        ('y', 1, 10, 24),\n        ('x', 1, 10, 27),\n        ('w', 1, 10, 30)\n    ]\n\n    num = num.replace(',', '').strip().lower()\n\n    if num[-1].isdigit():\n        return float(num)\n\n    for i, char in enumerate(reversed(num)):\n        if char.isdigit():\n            input_suffix = num[-i:]\n            num = Decimal(num[:-i])\n            break\n\n    if input_suffix[0] == '!':\n        return reduce(mul, range(int(num), 0, -len(input_suffix)))\n\n    while len(input_suffix) > 0:\n        for suffix, min_abbrev, base, power in suffixes:\n            if input_suffix[:min_abbrev] == suffix[:min_abbrev]:\n                for i in range(min_abbrev, len(input_suffix) + 1):\n                    if input_suffix[:i+1] != suffix[:i+1]:\n                        num *= base ** power\n                        input_suffix = input_suffix[i:]\n                        break\n                break\n\n    return num\n\n\ntest = \"2greatGRo   24Gros  288Doz  1,728pairs  172.8SCOre\\n\\\n        1,567      +1.567k    0.1567e-2m\\n\\\n        25.123kK    25.123m   2.5123e-00002G\\n\\\n        25.123kiKI  25.123Mi  2.5123e-00002Gi  +.25123E-7Ei\\n\\\n        -.25123e-34Vikki      2e-77gooGols\\n\\\n        9!   9!!   9!!!   9!!!!   9!!!!!   9!!!!!!   9!!!!!!!   9!!!!!!!!   9!!!!!!!!!\"\n\nfor test_line in test.split(\"\\n\"):\n    test_cases = test_line.split()\n    print(\"Input:\", ' '.join(test_cases))\n    print(\"Output:\", ' '.join(format(result, ',f').strip('0').strip('.') for result in map(expand, test_cases)))\n"}
{"id": 383566, "name": "Numerical and alphabetical suffixes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy %suffix = qw( k 1e3 m 1e6 g 1e9 t 1e12 p 1e15 e 1e18 z 1e21 y 1e24 x 1e27\n  w 1e30 v 1e33 u 1e36 ki 2**10 mi 2**20 gi 2**30 ti 2**40 pi 2**50 ei 2**60\n  zi 2**70 yi 2**80 xi 2**90 wi 2**100 vi 2**110 ui 2**120 );\n\nlocal $\" = '  '; \nprint \"numbers = ${_}results = @{[ map suffix($_), split ]}\\n\\n\" while <DATA>;\n\nsub suffix\n  {\n  my ($value, $mods) = shift =~ tr/,//dr =~ /([+-]?[\\d.]+(?:e[+-]\\d+)?)(.*)/i;\n  $value *= $^R while $mods =~ /\n      PAIRs?            (?{       2 })\n    | SCO(re?)?         (?{      20 })\n    | DOZ(e(ns?)?)?     (?{      12 })\n    | GREATGR(o(ss?)?)? (?{    1728 }) \n    | GR(o(ss?)?)?      (?{     144 })\n    | GOOGOLs?          (?{ 10**100 })\n    | [kmgtpezyxwvu]i?  (?{ eval $suffix{ lc $& } })\n    |\u00a0!+ (?{ my $factor = $value; \n        $value *= $factor while ($factor -= length $&) > 1;\n        1 })\n    /gix;\n  return $value =~ s/(\\..*)|\\B(?=(\\d\\d\\d)+(?!\\d))/$1 || ','/ger;\n  }\n\n", "target": "from functools import reduce\nfrom operator import mul\nfrom decimal import *\n\ngetcontext().prec = MAX_PREC\n\ndef expand(num):\n    suffixes = [\n        \n        ('greatgross', 7, 12, 3),\n        ('gross', 2, 12, 2),\n        ('dozens', 3, 12, 1),\n        ('pairs', 4, 2, 1),\n        ('scores', 3, 20, 1),\n        ('googols', 6, 10, 100),\n        ('ki', 2, 2, 10),\n        ('mi', 2, 2, 20),\n        ('gi', 2, 2, 30),\n        ('ti', 2, 2, 40),\n        ('pi', 2, 2, 50),\n        ('ei', 2, 2, 60),\n        ('zi', 2, 2, 70),\n        ('yi', 2, 2, 80),\n        ('xi', 2, 2, 90),\n        ('wi', 2, 2, 100),\n        ('vi', 2, 2, 110),\n        ('ui', 2, 2, 120),\n        ('k', 1, 10, 3),\n        ('m', 1, 10, 6),\n        ('g', 1, 10, 9),\n        ('t', 1, 10, 12),\n        ('p', 1, 10, 15),\n        ('e', 1, 10, 18),\n        ('z', 1, 10, 21),\n        ('y', 1, 10, 24),\n        ('x', 1, 10, 27),\n        ('w', 1, 10, 30)\n    ]\n\n    num = num.replace(',', '').strip().lower()\n\n    if num[-1].isdigit():\n        return float(num)\n\n    for i, char in enumerate(reversed(num)):\n        if char.isdigit():\n            input_suffix = num[-i:]\n            num = Decimal(num[:-i])\n            break\n\n    if input_suffix[0] == '!':\n        return reduce(mul, range(int(num), 0, -len(input_suffix)))\n\n    while len(input_suffix) > 0:\n        for suffix, min_abbrev, base, power in suffixes:\n            if input_suffix[:min_abbrev] == suffix[:min_abbrev]:\n                for i in range(min_abbrev, len(input_suffix) + 1):\n                    if input_suffix[:i+1] != suffix[:i+1]:\n                        num *= base ** power\n                        input_suffix = input_suffix[i:]\n                        break\n                break\n\n    return num\n\n\ntest = \"2greatGRo   24Gros  288Doz  1,728pairs  172.8SCOre\\n\\\n        1,567      +1.567k    0.1567e-2m\\n\\\n        25.123kK    25.123m   2.5123e-00002G\\n\\\n        25.123kiKI  25.123Mi  2.5123e-00002Gi  +.25123E-7Ei\\n\\\n        -.25123e-34Vikki      2e-77gooGols\\n\\\n        9!   9!!   9!!!   9!!!!   9!!!!!   9!!!!!!   9!!!!!!!   9!!!!!!!!   9!!!!!!!!!\"\n\nfor test_line in test.split(\"\\n\"):\n    test_cases = test_line.split()\n    print(\"Input:\", ' '.join(test_cases))\n    print(\"Output:\", ' '.join(format(result, ',f').strip('0').strip('.') for result in map(expand, test_cases)))\n"}
{"id": 383567, "name": "Minkowski question-mark function", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse POSIX qw(floor);\n\nmy $MAXITER = 50;\n\nsub minkowski {\n    my($x) = @_;\n\n    return floor($x) + minkowski( $x - floor($x) ) if $x > 1 || $x < 0 ;\n\n    my $y = my $p = floor($x);\n    my ($q,$s,$d) = (1,1,1);\n    my $r = $p + 1;\n\n    while () {\n        last if ( $y + ($d /= 2)  == $y ) or\n                ( my $m = $p + $r) <  0   or\n                ( my $n = $q + $s) <  0;\n        $x < $m/$n ? ($r,$s) = ($m, $n) : ($y += $d and ($p,$q) = ($m, $n) );\n    }\n    return $y + $d\n}\n\nsub minkowskiInv {\n    my($x) = @_;\n\n    return floor($x) + minkowskiInv($x - floor($x)) if $x > 1 || $x < 0;\n    return $x if $x == 1 || $x == 0 ;\n\n    my @contFrac = 0;\n    my $i = my $curr = 0 ; my $count = 1;\n\n    while () {\n        $x *= 2;\n        if ($curr == 0) {\n            if ($x < 1) {\n                $count++\n            } else {\n                $i++;\n                push @contFrac, 0;\n                $contFrac[$i-1] = $count;\n                ($count,$curr) = (1,1);\n                $x--;\n            }\n        } else {\n            if ($x > 1) {\n                $count++;\n                $x--;\n            } else {\n                $i++;\n                push @contFrac, 0;\n                @contFrac[$i-1] = $count;\n                ($count,$curr) = (1,0);\n            }\n        }\n        if ($x == floor($x)) { @contFrac[$i] = $count; last }\n        last if $i == $MAXITER;\n    }\n    my $ret = 1 / $contFrac[$i];\n    for (my $j = $i - 1; $j >= 0; $j--) { $ret = $contFrac[$j] + 1/$ret }\n    return 1 / $ret\n}\n\nprintf \"%19.16f %19.16f\\n\", minkowski(0.5*(1 + sqrt(5))), 5/3;\nprintf \"%19.16f %19.16f\\n\", minkowskiInv(-5/9), (sqrt(13)-7)/6;\nprintf \"%19.16f %19.16f\\n\", minkowski(minkowskiInv(0.718281828)), minkowskiInv(minkowski(0.1213141516171819));\n", "target": "    print(\n        \"{:19.16f} {:19.16f}\".format(\n            minkowski(minkowski_inv(4.04145188432738056)),\n            minkowski_inv(minkowski(4.04145188432738056)),\n        )\n    )\n"}
{"id": 383568, "name": "Dating agency", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Digest::SHA qw(sha1_hex);\nuse List::Util <max head>;\n\nmy(%laddies,%taylors);\n\nfor my $name ( qw( Adam Bob Conrad Drew Eddie Fred George Harry Ian Jake Ken Larry Mike\n                   Ned Oscar Peter Quincy Richard Sam Tom Uriah Victor Will Yogi Zach ) ) {\n    $laddies{$name}{loves}   = hex substr sha1_hex($name),  0, 4;\n    $laddies{$name}{lovable} = hex substr sha1_hex($name), -4, 4;\n}\n\nfor my $name ( < Elizabeth Swift Rip > ) {\n    $taylors{$name}{loves}   = hex substr sha1_hex($name),  0, 4;\n    $taylors{$name}{lovable} = hex substr sha1_hex($name), -4, 4;\n}\n\nsub rank_by {\n   my($subk,$k,$t,$l) = @_;\n   sort { abs $$t{$k}{$subk} - $$l{$a}{$subk} <=> abs $$t{$k}{$subk} - $$l{$b}{$subk} } keys %$l;\n}\n\nfor my $taylor (sort keys %taylors) {\n    printf \"%9s will like: %s\\n\", $taylor, join ', ', my @likes = head 10, rank_by('loves',  $taylor, \\%taylors, \\%laddies);\n    printf \"        Is liked by: %s\\n\",    join ', ', my @liked = head 10, rank_by('lovable',$taylor, \\%taylors, \\%laddies);\n\n    my($max,%matches) = 0;\n    $matches{$liked[$_]}  = @liked-$_ for reverse 0..$\n    $matches{$likes[$_]} += @likes-$_ for reverse 0..$\n    $matches{$_} < $max or $max = $matches{$_} for keys %matches;\n    print 'Best match(s): ' . join(', ', sort grep { $matches{$_} == $max } keys %matches) . \"\\n\\n\";\n}\n", "target": "\n\nsailors = ['Adrian', 'Caspian', 'Dune', 'Finn', 'Fisher', 'Heron', 'Kai',\n           'Ray', 'Sailor', 'Tao']\n\nladies = ['Ariel', 'Bertha', 'Blue', 'Cali', 'Catalina', 'Gale', 'Hannah',\n           'Isla', 'Marina', 'Shelly']\n\ndef isnicegirl(s):\n    return ord(s[0]) % 2 == 0\n\ndef islovable(slady, ssailor):\n    return ord(slady[-1]) % 2 == ord(ssailor[-1]) % 2\n\nfor lady in ladies:\n    if isnicegirl(lady):\n        print(\"Dating service should offer a date with\", lady)\n        for sailor in sailors:\n            if islovable(lady, sailor):\n                print(\"    Sailor\", sailor, \"should take an offer to date her.\")\n    else:\n        print(\"Dating service should NOT offer a date with\", lady)\n"}
{"id": 383569, "name": "Compiler_AST interpreter", "source": "Translate Perl to Python: \n\nuse strict;   \nuse warnings; \nuse integer;\n\nmy %variables;\n\ntree()->run;\n\nsub tree\n  {\n  my $line = <> // die \"incomplete tree\\n\";\n  (local $_, my $arg) = $line =~ /^(\\w+|;)\\s+(.*)/ or die \"bad input $line\";\n  /String/ ? bless [$arg =~ tr/\"\"//dr =~ s/\\\\(.)/$1 eq 'n'\u00a0? \"\\n\"\u00a0: $1/ger], $_ :\n    /Identifier|Integer/ ? bless [ $arg ], $_ :\n    /;/ ? bless [], 'Null' :\n    bless [ tree(), tree() ], $_;\n  }\n\nsub Add::run { $_[0][0]->run + $_[0][1]->run }\nsub And::run { $_[0][0]->run && $_[0][1]->run }\nsub Assign::run { $variables{$_[0][0][0]} = $_[0][1]->run }\nsub Divide::run { $_[0][0]->run / $_[0][1]->run }\nsub Equal::run { $_[0][0]->run == $_[0][1]->run ? 1 : 0 }\nsub Greater::run { $_[0][0]->run > $_[0][1]->run ? 1 : 0 }\nsub GreaterEqual::run { $_[0][0]->run >= $_[0][1]->run ? 1 : 0 }\nsub Identifier::run { $variables{$_[0][0]} // 0 }\nsub If::run { $_[0][0]->run ? $_[0][1][0]->run : $_[0][1][1]->run }\nsub Integer::run { $_[0][0] }\nsub Less::run { $_[0][0]->run < $_[0][1]->run ? 1 : 0 }\nsub LessEqual::run { $_[0][0]->run <= $_[0][1]->run ? 1 : 0 }\nsub Mod::run { $_[0][0]->run % $_[0][1]->run }\nsub Multiply::run { $_[0][0]->run * $_[0][1]->run }\nsub Negate::run { - $_[0][0]->run }\nsub Not::run { $_[0][0]->run ? 0 : 1 }\nsub NotEqual::run { $_[0][0]->run != $_[0][1]->run ? 1 : 0 }\nsub Null::run {}\nsub Or::run { $_[0][0]->run || $_[0][1]->run }\nsub Prtc::run { print chr $_[0][0]->run }\nsub Prti::run { print $_[0][0]->run }\nsub Prts::run { print $_[0][0][0] }\nsub Sequence::run { $_->run for $_[0]->@* }\nsub Subtract::run { $_[0][0]->run - $_[0][1]->run }\nsub While::run { $_[0][1]->run while $_[0][0]->run }\n", "target": "def load_ast()\n    line = readline()\n    \n    line_list = tokenize the line, respecting double quotes\n\n    text = line_list[0] \n\n    if text == \";\"   \n        return NULL\n\n    node_type = text \n\n    \n    \n    \n    if len(line_list) > 1\n        return make_leaf(node_type, line_list[1])\n\n    left = load_ast()\n    right = load_ast()\n    return make_node(node_type, left, right)\n"}
{"id": 383570, "name": "Compiler_AST interpreter", "source": "Translate Perl to Python: \n\nuse strict;   \nuse warnings; \nuse integer;\n\nmy %variables;\n\ntree()->run;\n\nsub tree\n  {\n  my $line = <> // die \"incomplete tree\\n\";\n  (local $_, my $arg) = $line =~ /^(\\w+|;)\\s+(.*)/ or die \"bad input $line\";\n  /String/ ? bless [$arg =~ tr/\"\"//dr =~ s/\\\\(.)/$1 eq 'n'\u00a0? \"\\n\"\u00a0: $1/ger], $_ :\n    /Identifier|Integer/ ? bless [ $arg ], $_ :\n    /;/ ? bless [], 'Null' :\n    bless [ tree(), tree() ], $_;\n  }\n\nsub Add::run { $_[0][0]->run + $_[0][1]->run }\nsub And::run { $_[0][0]->run && $_[0][1]->run }\nsub Assign::run { $variables{$_[0][0][0]} = $_[0][1]->run }\nsub Divide::run { $_[0][0]->run / $_[0][1]->run }\nsub Equal::run { $_[0][0]->run == $_[0][1]->run ? 1 : 0 }\nsub Greater::run { $_[0][0]->run > $_[0][1]->run ? 1 : 0 }\nsub GreaterEqual::run { $_[0][0]->run >= $_[0][1]->run ? 1 : 0 }\nsub Identifier::run { $variables{$_[0][0]} // 0 }\nsub If::run { $_[0][0]->run ? $_[0][1][0]->run : $_[0][1][1]->run }\nsub Integer::run { $_[0][0] }\nsub Less::run { $_[0][0]->run < $_[0][1]->run ? 1 : 0 }\nsub LessEqual::run { $_[0][0]->run <= $_[0][1]->run ? 1 : 0 }\nsub Mod::run { $_[0][0]->run % $_[0][1]->run }\nsub Multiply::run { $_[0][0]->run * $_[0][1]->run }\nsub Negate::run { - $_[0][0]->run }\nsub Not::run { $_[0][0]->run ? 0 : 1 }\nsub NotEqual::run { $_[0][0]->run != $_[0][1]->run ? 1 : 0 }\nsub Null::run {}\nsub Or::run { $_[0][0]->run || $_[0][1]->run }\nsub Prtc::run { print chr $_[0][0]->run }\nsub Prti::run { print $_[0][0]->run }\nsub Prts::run { print $_[0][0][0] }\nsub Sequence::run { $_->run for $_[0]->@* }\nsub Subtract::run { $_[0][0]->run - $_[0][1]->run }\nsub While::run { $_[0][1]->run while $_[0][0]->run }\n", "target": "def load_ast()\n    line = readline()\n    \n    line_list = tokenize the line, respecting double quotes\n\n    text = line_list[0] \n\n    if text == \";\"   \n        return NULL\n\n    node_type = text \n\n    \n    \n    \n    if len(line_list) > 1\n        return make_leaf(node_type, line_list[1])\n\n    left = load_ast()\n    right = load_ast()\n    return make_node(node_type, left, right)\n"}
{"id": 383571, "name": "Welch's t-test", "source": "Translate Perl to Python: use utf8;\nuse List::Util qw(sum);\nuse Math::AnyNum qw(gamma pi);\n\nsub p_value :prototype($$) {\n    my ($A, $B) = @_;\n\n    (@$A > 1 && @$B > 1) || return 1;\n\n    my $x\u0304_a = sum(@$A) / @$A;\n    my $x\u0304_b = sum(@$B) / @$B;\n\n    my $a_var = sum(map { ($x\u0304_a - $_)**2 } @$A) / (@$A - 1);\n    my $b_var = sum(map { ($x\u0304_b - $_)**2 } @$B) / (@$B - 1);\n\n    ($a_var && $b_var) || return 1;\n\n    my $Welsh_\ud835\udc95_statistic = ($x\u0304_a - $x\u0304_b) / sqrt($a_var/@$A + $b_var/@$B);\n\n    my $DoF = ($a_var/@$A + $b_var/@$B)**2 / (\n               $a_var**2 / (@$A**3 - @$A**2) +\n               $b_var**2 / (@$B**3 - @$B**2));\n\n    my $sa = $DoF / 2 - 1;\n    my $x  = $DoF / ($Welsh_\ud835\udc95_statistic**2 + $DoF);\n    my $N  = 65355;\n    my $h  = $x / $N;\n\n    my ($sum1, $sum2) = (0, 0);\n\n    foreach my $k (0 .. $N - 1) {\n        my $i = $h * $k;\n        $sum1 += ($i + $h/2)**$sa / sqrt(1 - ($i + $h/2));\n        $sum2 += $i**$sa / sqrt(1-$i);\n    }\n\n    ($h/6 * ($x**$sa / sqrt(1-$x) + 4*$sum1 + 2*$sum2) /\n        (gamma($sa + 1) * sqrt(pi) / gamma($sa + 1.5)))->numify;\n}\n\nmy @tests = (\n    [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4],\n    [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4],\n\n    [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8],\n    [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8],\n\n    [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0],\n    [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2],\n\n    [30.02, 29.99, 30.11, 29.97, 30.01, 29.99],\n    [29.89, 29.93, 29.72, 29.98, 30.02, 29.98],\n\n    [3.0,   4.0,   1.0, 2.1],\n    [490.2, 340.0, 433.9],\n);\n\nwhile (@tests) {\n    my ($left, $right) = splice(@tests, 0, 2);\n    print p_value($left, $right), \"\\n\";\n}\n", "target": "import numpy as np\nimport scipy as sp\nimport scipy.stats\n\ndef welch_ttest(x1, x2):\n    n1 = x1.size\n    n2 = x2.size\n    m1 = np.mean(x1)\n    m2 = np.mean(x2)\n    v1 = np.var(x1, ddof=1)\n    v2 = np.var(x2, ddof=1)\n    t = (m1 - m2) / np.sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2 * sp.stats.t.cdf(-abs(t), df)\n    return t, df, p\n\nwelch_ttest(np.array([3.0, 4.0, 1.0, 2.1]), np.array([490.2, 340.0, 433.9]))\n(-9.559497721932658, 2.0008523488562844, 0.01075156114978449)\n"}
{"id": 383572, "name": "Welch's t-test", "source": "Translate Perl to Python: use utf8;\nuse List::Util qw(sum);\nuse Math::AnyNum qw(gamma pi);\n\nsub p_value :prototype($$) {\n    my ($A, $B) = @_;\n\n    (@$A > 1 && @$B > 1) || return 1;\n\n    my $x\u0304_a = sum(@$A) / @$A;\n    my $x\u0304_b = sum(@$B) / @$B;\n\n    my $a_var = sum(map { ($x\u0304_a - $_)**2 } @$A) / (@$A - 1);\n    my $b_var = sum(map { ($x\u0304_b - $_)**2 } @$B) / (@$B - 1);\n\n    ($a_var && $b_var) || return 1;\n\n    my $Welsh_\ud835\udc95_statistic = ($x\u0304_a - $x\u0304_b) / sqrt($a_var/@$A + $b_var/@$B);\n\n    my $DoF = ($a_var/@$A + $b_var/@$B)**2 / (\n               $a_var**2 / (@$A**3 - @$A**2) +\n               $b_var**2 / (@$B**3 - @$B**2));\n\n    my $sa = $DoF / 2 - 1;\n    my $x  = $DoF / ($Welsh_\ud835\udc95_statistic**2 + $DoF);\n    my $N  = 65355;\n    my $h  = $x / $N;\n\n    my ($sum1, $sum2) = (0, 0);\n\n    foreach my $k (0 .. $N - 1) {\n        my $i = $h * $k;\n        $sum1 += ($i + $h/2)**$sa / sqrt(1 - ($i + $h/2));\n        $sum2 += $i**$sa / sqrt(1-$i);\n    }\n\n    ($h/6 * ($x**$sa / sqrt(1-$x) + 4*$sum1 + 2*$sum2) /\n        (gamma($sa + 1) * sqrt(pi) / gamma($sa + 1.5)))->numify;\n}\n\nmy @tests = (\n    [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4],\n    [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4],\n\n    [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8],\n    [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8],\n\n    [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0],\n    [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2],\n\n    [30.02, 29.99, 30.11, 29.97, 30.01, 29.99],\n    [29.89, 29.93, 29.72, 29.98, 30.02, 29.98],\n\n    [3.0,   4.0,   1.0, 2.1],\n    [490.2, 340.0, 433.9],\n);\n\nwhile (@tests) {\n    my ($left, $right) = splice(@tests, 0, 2);\n    print p_value($left, $right), \"\\n\";\n}\n", "target": "import numpy as np\nimport scipy as sp\nimport scipy.stats\n\ndef welch_ttest(x1, x2):\n    n1 = x1.size\n    n2 = x2.size\n    m1 = np.mean(x1)\n    m2 = np.mean(x2)\n    v1 = np.var(x1, ddof=1)\n    v2 = np.var(x2, ddof=1)\n    t = (m1 - m2) / np.sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2 * sp.stats.t.cdf(-abs(t), df)\n    return t, df, p\n\nwelch_ttest(np.array([3.0, 4.0, 1.0, 2.1]), np.array([490.2, 340.0, 433.9]))\n(-9.559497721932658, 2.0008523488562844, 0.01075156114978449)\n"}
{"id": 383573, "name": "Mayan calendar", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse utf8;\nbinmode STDOUT, \":utf8\";\nuse Math::BaseArith;\nuse Date::Calc 'Delta_Days';\n\nmy @sacred = qw<Imix\u2019 Ik\u2019 Ak\u2019bal K\u2019an Chikchan Kimi Manik\u2019 Lamat Muluk Ok\n              Chuwen Eb Ben Hix Men K\u2019ib\u2019 Kaban Etz\u2019nab\u2019 Kawak Ajaw>;\n\nmy @civil = qw<Pop Wo\u2019 Sip Sotz\u2019 Sek Xul Yaxk\u2019in Mol Ch\u2019en Yax Sak\u2019 Keh\n             Mak K\u2019ank\u2019in Muwan\u2019 Pax K\u2019ayab Kumk\u2019u Wayeb\u2019>;\n\nmy %correlation = (\n    'gregorian' => '2012-12-21',\n    'round'     => [3,19,263,8],\n    'long'      => 1872000,\n);\n\nsub mayan_calendar_round {\n    my $date = shift;\n    tzolkin($date), haab($date);\n}\n\nsub offset {\n    my $date = shift;\n    Delta_Days( split('-', $correlation{'gregorian'}), split('-', $date) );\n}\n\nsub haab {\n    my $date  = shift;\n    my $index = ($correlation{'round'}[2] + offset $date) % 365;\n    my ($day, $month);\n    if ($index > 360) {\n        $day = $index - 360;\n        $month = $civil[18];\n        if ($day == 5) {\n            $day = 'Chum';\n            $month = $civil[0];\n        }\n    } else {\n        $day = $index % 20;\n        $month = $civil[int $index / 20];\n        if ($day == 0) {\n            $day = 'Chum';\n            $month = $civil[int (1 + $index) / 20];\n        }\n    }\n    $day, $month\n}\n\nsub tzolkin {\n    my $date   = shift;\n    my $offset = offset $date;\n    1 + ($offset + $correlation{'round'}[0]) % 13,\n    $sacred[($offset + $correlation{'round'}[1]) % 20]\n}\n\nsub lord {\n    my $date = shift;\n    1 + ($correlation{'round'}[3] + offset $date) % 9\n}\n\nsub mayan_long_count {\n    my $date = shift;\n    my $days = $correlation{'long'} + offset $date;\n    encode($days, [20,20,20,18,20]);\n}\n\nprint <<'EOH';\n Gregorian   Tzolk\u2019in         Haab\u2019             Long           Lord of\n   Date       \n-----------------------------------------------------------------------\nEOH\n\nfor my $date (<1961-10-06 2004-06-19 2012-12-18 2012-12-21 2019-01-19 2019-03-27 2020-02-29 2020-03-01 2071-05-16>) {\n    printf \"%10s   %2s\u00a0%-9s %4s\u00a0%-10s    \u00a0%-14s     G%d\\n\",\n      $date, mayan_calendar_round($date), join('.',mayan_long_count($date)), lord($date);\n}\n", "target": "import datetime\n\n\ndef g2m(date, gtm_correlation=True):\n    \n\n    \n\n    correlation = 584283 if gtm_correlation else 584285\n\n    long_count_days = [144000, 7200, 360, 20, 1]\n\n    tzolkin_months = ['Imix\u2019', 'Ik\u2019', 'Ak\u2019bal', 'K\u2019an', 'Chikchan', 'Kimi', 'Manik\u2019', 'Lamat', 'Muluk', 'Ok', 'Chuwen',\n                      'Eb', 'Ben', 'Hix', 'Men', 'K\u2019ib\u2019', 'Kaban', 'Etz\u2019nab\u2019', 'Kawak', 'Ajaw']  \n\n    haad_months = ['Pop', 'Wo\u2019', 'Sip', 'Sotz\u2019', 'Sek', 'Xul', 'Yaxk\u2019in', 'Mol', 'Ch\u2019en', 'Yax', 'Sak\u2019', 'Keh', 'Mak',\n                   'K\u2019ank\u2019in', 'Muwan', 'Pax', 'K\u2019ayab', 'Kumk\u2019u', 'Wayeb\u2019']  \n\n    gregorian_days = datetime.datetime.strptime(date, '%Y-%m-%d').toordinal()\n    julian_days = gregorian_days + 1721425\n\n    \n\n    long_date = list()\n    remainder = julian_days - correlation\n\n    for days in long_count_days:\n\n        result, remainder = divmod(remainder, days)\n        long_date.append(int(result))\n\n    long_date = '.'.join(['{:02d}'.format(d) for d in long_date])\n\n    \n\n    tzolkin_month = (julian_days + 16) % 20\n    tzolkin_day = ((julian_days + 5) % 13) + 1\n\n    haab_month = int(((julian_days + 65) % 365) / 20)\n    haab_day = ((julian_days + 65) % 365) % 20\n    haab_day = haab_day if haab_day else 'Chum'\n\n    lord_number = (julian_days - correlation) % 9\n    lord_number = lord_number if lord_number else 9\n\n    round_date = f'{tzolkin_day} {tzolkin_months[tzolkin_month]} {haab_day} {haad_months[haab_month]} G{lord_number}'\n\n    return long_date, round_date\n\nif __name__ == '__main__':\n\n    dates = ['2004-06-19', '2012-12-18', '2012-12-21', '2019-01-19', '2019-03-27', '2020-02-29', '2020-03-01']\n\n    for date in dates:\n\n        long, round = g2m(date)\n        print(date, long, round)\n"}
{"id": 383574, "name": "Four is the number of letters in the ...", "source": "Translate Perl to Python: use feature 'state';\nuse Lingua::EN::Numbers qw(num2en num2en_ordinal);\n\nmy @sentence = split / /, 'Four is the number of letters in the first word of this sentence, ';\n\nsub extend_to {\n    my($last) = @_;\n    state $index = 1;\n    until ($\n        push @sentence, split ' ', num2en(alpha($sentence[$index])) . ' in the ' . no_c(num2en_ordinal(1+$index)) . ',';\n        $index++;\n    }\n}\n\nsub alpha { my($s) = @_; $s =~ s/\\W//gi; length $s }\nsub no_c  { my($s) = @_; $s =~ s/\\ and|,//g;   return $s }\nsub count { length(join ' ', @sentence[0..-1+$_[0]]) . \" characters in the sentence, up to and including this word.\\n\" }\n\nprint \"First 201 word lengths in the sequence:\\n\";\nextend_to(201);\nfor (0..200) {\n    printf \"%3d\", alpha($sentence[$_]);\n    print \"\\n\" unless ($_+1) % 32;\n}\nprint \"\\n\" . count(201) . \"\\n\";\n\nfor (1e3, 1e4, 1e5, 1e6, 1e7) {\n    extend_to($_);\n    print\n        ucfirst(num2en_ordinal($_)) .  \" word, '$sentence[$_-1]' has \" . alpha($sentence[$_-1]) .  \" characters. \\n\" .\n        count($_) . \"\\n\";\n}\n", "target": "\n\n\n\n\nimport inflect\n\ndef count_letters(word):\n    \n    count = 0\n    for letter in word:\n        if letter != ',' and letter !='-' and letter !=' ':\n            count += 1\n            \n    return count\n    \ndef split_with_spaces(sentence):\n    \n    sentence_list = []\n    curr_word = \"\"\n    for c in sentence:\n        if c == \" \" and curr_word != \"\":\n            \n            \n            sentence_list.append(curr_word+\" \")\n            curr_word = \"\"\n        else:\n            curr_word += c\n    \n    \n    \n    if len(curr_word) > 0:\n        sentence_list.append(curr_word)\n    \n    return sentence_list\n    \ndef my_num_to_words(p, my_number):\n    \n    \n    number_string_list = p.number_to_words(my_number, wantlist=True, andword='')\n    \n    number_string = number_string_list[0]\n    \n    for i in range(1,len(number_string_list)):\n        number_string += \" \" + number_string_list[i]\n    \n    return number_string\n        \ndef build_sentence(p, max_words):\n    \n    \n    \n    \n    sentence_list = split_with_spaces(\"Four is the number of letters in the first word of this sentence,\")\n      \n    num_words = 13\n    \n    \n    \n    \n    word_number = 2\n    \n    \n    \n    while num_words < max_words:\n        \n        \n        \n        \n        \n        ordinal_string = my_num_to_words(p, p.ordinal(word_number))\n        \n        \n        \n        word_number_string = my_num_to_words(p, count_letters(sentence_list[word_number - 1]))\n        \n        \n        \n        new_string = \" \"+word_number_string+\" in the \"+ordinal_string+\",\"\n\n        new_list = split_with_spaces(new_string)\n        \n        sentence_list += new_list\n\n        \n        \n        num_words += len(new_list)\n        \n        \n        \n        word_number += 1\n        \n    return sentence_list, num_words\n    \ndef word_and_counts(word_num):\n    \n        \n    sentence_list, num_words = build_sentence(p, word_num)\n    \n    word_str = sentence_list[word_num - 1].strip(' ,')\n    \n    num_letters = len(word_str)\n    \n    num_characters = 0\n    \n    for word in sentence_list:\n       num_characters += len(word)\n       \n    print('Word {0:8d} is \"{1}\", with {2} letters.  Length of the sentence so far: {3}  '.format(word_num,word_str,num_letters,num_characters))\n   \n    \np = inflect.engine()\n\nsentence_list, num_words = build_sentence(p, 201)\n\nprint(\" \")\nprint(\"The lengths of the first 201 words are:\")\nprint(\" \")\n\nprint('{0:3d}:  '.format(1),end='')\n\ntotal_characters = 0\n\nfor word_index in range(201):\n\n    word_length = count_letters(sentence_list[word_index])\n    \n    total_characters += len(sentence_list[word_index])\n    \n    print('{0:2d}'.format(word_length),end='')\n    if (word_index+1) % 20 == 0:\n        \n        print(\" \")\n        print('{0:3d}:  '.format(word_index + 2),end='')\n    else:\n        print(\" \",end='')\n \nprint(\" \")\nprint(\" \")\nprint(\"Length of the sentence so far: \"+str(total_characters))\nprint(\" \")\n\n\n\nword_and_counts(1000)\nword_and_counts(10000)\nword_and_counts(100000)\nword_and_counts(1000000)\nword_and_counts(10000000)\n"}
{"id": 383575, "name": "Wordle comparison", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nfor my $test ( [\"ALLOW\", \"LOLLY\"], [\"BULLY\", \"LOLLY\"], [\"ROBIN\", \"ALERT\"],\n  [\"ROBIN\", \"SONIC\"], [\"ROBIN\", \"ROBIN\"])\n  {\n  local $_ = join \"\\n\", @$test;\n  1 while s/([ -~])(.*\\n(??{$` =~ tr!!.!cr}))\\1/\\0$2\\0/;\n  1 while s/([ -~])(.*\\n.*?)\\1/\\01$2\\01/;\n  print \"@$test => @{[ qw( green yellow grey )\n    [map ord, split //, s/.*\\n//r =~ tr/\\0\\1/\\2/cr] ]}\\n\";\n  }\n", "target": "\n\nfrom functools import reduce\nfrom operator import add\n\n\n\ndef wordleScore(target, guess):\n    \n    return mapAccumL(amber)(\n        *first(charCounts)(\n            mapAccumL(green)(\n                [], zip(target, guess)\n            )\n        )\n    )[1]\n\n\n\ndef green(residue, tg):\n    \n    t, g = tg\n    return (residue, (g, 2)) if t == g else (\n        [t] + residue, (g, 0)\n    )\n\n\n\ndef amber(tally, cn):\n    \n    c, n = cn\n    return (tally, 2) if 2 == n else (\n        adjust(\n            lambda x: x - 1,\n            c, tally\n        ),\n        1\n    ) if 0 < tally.get(c, 0) else (tally, 0)\n\n\n\n\ndef main():\n    \n    print(' -> '.join(['Target', 'Guess', 'Scores']))\n    print()\n    print(\n        '\\n'.join([\n            wordleReport(*tg) for tg in [\n                (\"ALLOW\", \"LOLLY\"),\n                (\"CHANT\", \"LATTE\"),\n                (\"ROBIN\", \"ALERT\"),\n                (\"ROBIN\", \"SONIC\"),\n                (\"ROBIN\", \"ROBIN\"),\n                (\"BULLY\", \"LOLLY\"),\n                (\"ADAPT\", \"S\u00c5L\u00c5D\"),\n                (\"Ukraine\", \"Ukra\u00edne\"),\n                (\"BBAAB\", \"BBBBBAA\"),\n                (\"BBAABBB\", \"AABBBAA\")\n            ]\n        ])\n    )\n\n\n\ndef wordleReport(target, guess):\n    \n    scoreName = {2: 'green', 1: 'amber', 0: 'gray'}\n\n    if 5 != len(target):\n        return f'{target}: Expected 5 character target.'\n    elif 5 != len(guess):\n        return f'{guess}: Expected 5 character guess.'\n    else:\n        scores = wordleScore(target, guess)\n        return ' -> '.join([\n            target, guess, repr(scores),\n            ' '.join([\n                scoreName[n] for n in scores\n            ])\n        ])\n\n\n\n\n\ndef adjust(f, k, dct):\n    \n    return dict(\n        dct,\n        **{k: f(dct[k]) if k in dct else None}\n    )\n\n\n\ndef charCounts(s):\n    \n    return reduce(\n        lambda a, c: insertWith(add)(c)(1)(a),\n        list(s),\n        {}\n    )\n\n\n\ndef first(f):\n    \n    return lambda xy: (f(xy[0]), xy[1])\n\n\n\n\ndef insertWith(f):\n    \n    return lambda k: lambda x: lambda dct: dict(\n        dct,\n        **{k: f(dct[k], x) if k in dct else x}\n    )\n\n\n\n\ndef mapAccumL(f):\n    \n    def nxt(a, x):\n        return second(lambda v: a[1] + [v])(\n            f(a[0], x)\n        )\n    return lambda acc, xs: reduce(\n        nxt, xs, (acc, [])\n    )\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383576, "name": "Fibonacci matrix-exponentiation", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Math::AnyNum qw(:overload fibmod floor);\nuse Math::MatrixLUP;\n\nsub fibonacci {\n    my $M = Math::MatrixLUP->new([ [1, 1], [1,0] ]);\n    (@{$M->pow(shift)})[0][1]\n}\n\nfor my $n (16, 32) {\n    my $f = fibonacci(2**$n);\n    printf \"F(2^$n) = %s ... %s\\n\",  substr($f,0,20), $f % 10**20;\n}\n\nsub binet_approx {\n    my($n) = @_;\n    use constant PHI =>   sqrt(1.25) + 0.5 ;\n    use constant IHP => -(sqrt(1.25) - 0.5);\n    (log(PHI)*$n - log(PHI-IHP))\n}\n\nsub nth_fib_first_k_digits {\n    my($n,$k) = @_;\n    my $f = binet_approx($n);\n    floor(exp($f - log(10)*(floor($f / log(10) + 1))) * 10**$k)\n}\n\nsub nth_fib_last_k_digits {\n    my($n,$k) = @_;\n    fibmod($n, 10**$k);\n}\n\nprint \"\\n\";\nfor my $n (16, 32, 64) {\n    my $first20 = nth_fib_first_k_digits(2**$n, 20);\n    my $last20  = nth_fib_last_k_digits(2**$n, 20);\n    printf \"F(2^$n) = %s ... %s\\n\", $first20, $last20;\n}\n", "target": "class Head():\n    def __init__(self, lo, hi=None, shift=0):\n        if hi is None: hi = lo\n\n        d = hi - lo\n        ds, ls, hs = str(d), str(lo), str(hi)\n\n        if d and len(ls) > len(ds):\n            assert(len(ls) - len(ds) + 1 > 21)\n            lo = int(str(lo)[:len(ls) - len(ds) + 1])\n            hi = int(str(hi)[:len(hs) - len(ds) + 1]) + 1\n            shift += len(ds) - 1\n        elif len(ls) > 100:\n            lo = int(str(ls)[:100])\n            hi = lo + 1\n            shift = len(ls) - 100\n\n        self.lo, self.hi, self.shift = lo, hi, shift\n\n    def __mul__(self, other):\n        lo = self.lo*other.lo\n        hi = self.hi*other.hi\n        shift = self.shift + other.shift\n\n        return Head(lo, hi, shift)\n\n    def __add__(self, other):\n        if self.shift < other.shift:\n            return other + self\n\n        sh = self.shift - other.shift\n        if sh >= len(str(other.hi)):\n            return Head(self.lo, self.hi, self.shift)\n\n        ls = str(other.lo)\n        hs = str(other.hi)\n\n        lo = self.lo + int(ls[:len(ls)-sh])\n        hi = self.hi + int(hs[:len(hs)-sh])\n\n        return Head(lo, hi, self.shift)\n\n    def __repr__(self):\n        return str(self.hi)[:20]\n\nclass Tail():\n    def __init__(self, v):\n        self.v = int(f'{v:020d}'[-20:])\n\n    def __add__(self, other):\n        return Tail(self.v + other.v)\n\n    def __mul__(self, other):\n        return Tail(self.v*other.v)\n\n    def __repr__(self):\n        return f'{self.v:020d}'[-20:]\n        \ndef mul(a, b):\n    return a[0]*b[0] + a[1]*b[1], a[0]*b[1] + a[1]*b[2], a[1]*b[1] + a[2]*b[2]\n\ndef fibo(n, cls):\n    n -= 1\n    zero, one = cls(0), cls(1)\n    m = (one, one, zero)\n    e = (one, zero, one)\n\n    while n:\n        if n&1: e = mul(m, e)\n        m = mul(m, m)\n        n >>= 1\n\n    return f'{e[0]}'\n\nfor i in range(2, 10):\n    n = 10**i\n    print(f'10^{i}\u00a0:', fibo(n, Head), '...', fibo(n, Tail))\n\nfor i in range(3, 8):\n    n = 2**i\n    s = f'2^{n}'\n    print(f'{s:5s}:', fibo(2**n, Head), '...', fibo(2**n, Tail))\n"}
{"id": 383577, "name": "Fibonacci matrix-exponentiation", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse Math::AnyNum qw(:overload fibmod floor);\nuse Math::MatrixLUP;\n\nsub fibonacci {\n    my $M = Math::MatrixLUP->new([ [1, 1], [1,0] ]);\n    (@{$M->pow(shift)})[0][1]\n}\n\nfor my $n (16, 32) {\n    my $f = fibonacci(2**$n);\n    printf \"F(2^$n) = %s ... %s\\n\",  substr($f,0,20), $f % 10**20;\n}\n\nsub binet_approx {\n    my($n) = @_;\n    use constant PHI =>   sqrt(1.25) + 0.5 ;\n    use constant IHP => -(sqrt(1.25) - 0.5);\n    (log(PHI)*$n - log(PHI-IHP))\n}\n\nsub nth_fib_first_k_digits {\n    my($n,$k) = @_;\n    my $f = binet_approx($n);\n    floor(exp($f - log(10)*(floor($f / log(10) + 1))) * 10**$k)\n}\n\nsub nth_fib_last_k_digits {\n    my($n,$k) = @_;\n    fibmod($n, 10**$k);\n}\n\nprint \"\\n\";\nfor my $n (16, 32, 64) {\n    my $first20 = nth_fib_first_k_digits(2**$n, 20);\n    my $last20  = nth_fib_last_k_digits(2**$n, 20);\n    printf \"F(2^$n) = %s ... %s\\n\", $first20, $last20;\n}\n", "target": "class Head():\n    def __init__(self, lo, hi=None, shift=0):\n        if hi is None: hi = lo\n\n        d = hi - lo\n        ds, ls, hs = str(d), str(lo), str(hi)\n\n        if d and len(ls) > len(ds):\n            assert(len(ls) - len(ds) + 1 > 21)\n            lo = int(str(lo)[:len(ls) - len(ds) + 1])\n            hi = int(str(hi)[:len(hs) - len(ds) + 1]) + 1\n            shift += len(ds) - 1\n        elif len(ls) > 100:\n            lo = int(str(ls)[:100])\n            hi = lo + 1\n            shift = len(ls) - 100\n\n        self.lo, self.hi, self.shift = lo, hi, shift\n\n    def __mul__(self, other):\n        lo = self.lo*other.lo\n        hi = self.hi*other.hi\n        shift = self.shift + other.shift\n\n        return Head(lo, hi, shift)\n\n    def __add__(self, other):\n        if self.shift < other.shift:\n            return other + self\n\n        sh = self.shift - other.shift\n        if sh >= len(str(other.hi)):\n            return Head(self.lo, self.hi, self.shift)\n\n        ls = str(other.lo)\n        hs = str(other.hi)\n\n        lo = self.lo + int(ls[:len(ls)-sh])\n        hi = self.hi + int(hs[:len(hs)-sh])\n\n        return Head(lo, hi, self.shift)\n\n    def __repr__(self):\n        return str(self.hi)[:20]\n\nclass Tail():\n    def __init__(self, v):\n        self.v = int(f'{v:020d}'[-20:])\n\n    def __add__(self, other):\n        return Tail(self.v + other.v)\n\n    def __mul__(self, other):\n        return Tail(self.v*other.v)\n\n    def __repr__(self):\n        return f'{self.v:020d}'[-20:]\n        \ndef mul(a, b):\n    return a[0]*b[0] + a[1]*b[1], a[0]*b[1] + a[1]*b[2], a[1]*b[1] + a[2]*b[2]\n\ndef fibo(n, cls):\n    n -= 1\n    zero, one = cls(0), cls(1)\n    m = (one, one, zero)\n    e = (one, zero, one)\n\n    while n:\n        if n&1: e = mul(m, e)\n        m = mul(m, m)\n        n >>= 1\n\n    return f'{e[0]}'\n\nfor i in range(2, 10):\n    n = 10**i\n    print(f'10^{i}\u00a0:', fibo(n, Head), '...', fibo(n, Tail))\n\nfor i in range(3, 8):\n    n = 2**i\n    s = f'2^{n}'\n    print(f'{s:5s}:', fibo(2**n, Head), '...', fibo(2**n, Tail))\n"}
{"id": 383578, "name": "Cyclotomic polynomial", "source": "Translate Perl to Python: use feature 'say';\nuse List::Util qw(first);\nuse Math::Polynomial::Cyclotomic qw(cyclo_poly_iterate);\n\nsay 'First 30 cyclotomic polynomials:';\nmy $it = cyclo_poly_iterate(1);\nsay \"$_: \" . $it->() for 1 .. 30;\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\";\n$it = cyclo_poly_iterate(1);\n\nfor (my ($n, $k) = (1, 1) ; $n <= 10 ; ++$k) {\n    my $poly = $it->();\n    while (my $c = first { abs($_) == $n } $poly->coeff) {\n        say \"CP $k has coefficient with magnitude = $n\";\n        $n++;\n    }\n}\n", "target": "from itertools import count, chain\nfrom collections import deque\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n):\n    for p in primes():\n        if n%p == 0:\n            return False\n        if p*p > n:\n            return True\n\ndef factors(n):\n    for p in primes():\n    \n    \n    \n        if p*p > n:\n            if n > 1:\n                yield(n, 1, 1)\n            break\n\n        if n%p == 0:\n            cnt = 0\n            while True:\n                n, cnt = n//p, cnt+1\n                if n%p != 0: break\n            yield p, cnt, n\n\n\n\n\n\ndef cyclotomic(n):\n    def poly_div(num, den):\n        return (num[0] + den[1], num[1] + den[0])\n\n    def elevate(poly, n): \n        powerup = lambda p, n: [a*n for a in p]\n        return poly if n == 1 else (powerup(poly[0], n), powerup(poly[1], n))\n\n\n    if n == 0:\n        return ([], [])\n    if n == 1:\n        return ([1], [])\n\n    p, m, r = next(factors(n))\n    poly = cyclotomic(r)\n    return elevate(poly_div(elevate(poly, p), poly), p**(m-1))\n\ndef to_text(poly):\n    def getx(c, e):\n        if e == 0:\n            return '1'\n        elif e == 1:\n            return 'x'\n        return 'x' + (''.join('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079'[i] for i in map(int, str(e))))\n\n    parts = []\n    for (c,e) in (poly):\n        if c < 0:\n            coef = ' - ' if c == -1 else f' - {-c} '\n        else:\n            coef = (parts and ' + ' or '') if c == 1 else f' + {c}'\n        parts.append(coef + getx(c,e))\n    return ''.join(parts)\n\ndef terms(poly):\n    \n\n    def merge(a, b):\n        \n        while a or b:\n            l = a[0] if a else (0, -1) \n            r = b[0] if b else (0, -1)\n            if l[1] > r[1]:\n                a.popleft()\n            elif l[1] < r[1]:\n                b.popleft()\n                l = r\n            else:\n                a.popleft()\n                b.popleft()\n                l = (l[0] + r[0], l[1])\n            yield l\n\n    def mul(poly, p): \n        poly = list(poly)\n        return merge(deque((c, e+p) for c,e in poly),\n                     deque((-c, e) for c,e in poly))\n\n    def div(poly, p): \n        q = deque()\n        for c,e in merge(deque(poly), q):\n            if c:\n                q.append((c, e - p))\n                yield (c, e - p)\n            if e == p: break\n\n    p = [(1, 0)]  \n\n    for x in poly[0]: \n        p = mul(p, x)\n    for x in sorted(poly[1], reverse=True): \n        p = div(p, x)\n    return p\n\nfor n in chain(range(11), [2]):\n    print(f'{n}: {to_text(terms(cyclotomic(n)))}')\n\nwant = 1\nfor n in count():\n    c = [c for c,_ in terms(cyclotomic(n))]\n    while want in c or -want in c:\n        print(f'C[{want}]: {n}')\n        want += 1\n"}
{"id": 383579, "name": "Cyclotomic polynomial", "source": "Translate Perl to Python: use feature 'say';\nuse List::Util qw(first);\nuse Math::Polynomial::Cyclotomic qw(cyclo_poly_iterate);\n\nsay 'First 30 cyclotomic polynomials:';\nmy $it = cyclo_poly_iterate(1);\nsay \"$_: \" . $it->() for 1 .. 30;\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\";\n$it = cyclo_poly_iterate(1);\n\nfor (my ($n, $k) = (1, 1) ; $n <= 10 ; ++$k) {\n    my $poly = $it->();\n    while (my $c = first { abs($_) == $n } $poly->coeff) {\n        say \"CP $k has coefficient with magnitude = $n\";\n        $n++;\n    }\n}\n", "target": "from itertools import count, chain\nfrom collections import deque\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n):\n    for p in primes():\n        if n%p == 0:\n            return False\n        if p*p > n:\n            return True\n\ndef factors(n):\n    for p in primes():\n    \n    \n    \n        if p*p > n:\n            if n > 1:\n                yield(n, 1, 1)\n            break\n\n        if n%p == 0:\n            cnt = 0\n            while True:\n                n, cnt = n//p, cnt+1\n                if n%p != 0: break\n            yield p, cnt, n\n\n\n\n\n\ndef cyclotomic(n):\n    def poly_div(num, den):\n        return (num[0] + den[1], num[1] + den[0])\n\n    def elevate(poly, n): \n        powerup = lambda p, n: [a*n for a in p]\n        return poly if n == 1 else (powerup(poly[0], n), powerup(poly[1], n))\n\n\n    if n == 0:\n        return ([], [])\n    if n == 1:\n        return ([1], [])\n\n    p, m, r = next(factors(n))\n    poly = cyclotomic(r)\n    return elevate(poly_div(elevate(poly, p), poly), p**(m-1))\n\ndef to_text(poly):\n    def getx(c, e):\n        if e == 0:\n            return '1'\n        elif e == 1:\n            return 'x'\n        return 'x' + (''.join('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079'[i] for i in map(int, str(e))))\n\n    parts = []\n    for (c,e) in (poly):\n        if c < 0:\n            coef = ' - ' if c == -1 else f' - {-c} '\n        else:\n            coef = (parts and ' + ' or '') if c == 1 else f' + {c}'\n        parts.append(coef + getx(c,e))\n    return ''.join(parts)\n\ndef terms(poly):\n    \n\n    def merge(a, b):\n        \n        while a or b:\n            l = a[0] if a else (0, -1) \n            r = b[0] if b else (0, -1)\n            if l[1] > r[1]:\n                a.popleft()\n            elif l[1] < r[1]:\n                b.popleft()\n                l = r\n            else:\n                a.popleft()\n                b.popleft()\n                l = (l[0] + r[0], l[1])\n            yield l\n\n    def mul(poly, p): \n        poly = list(poly)\n        return merge(deque((c, e+p) for c,e in poly),\n                     deque((-c, e) for c,e in poly))\n\n    def div(poly, p): \n        q = deque()\n        for c,e in merge(deque(poly), q):\n            if c:\n                q.append((c, e - p))\n                yield (c, e - p)\n            if e == p: break\n\n    p = [(1, 0)]  \n\n    for x in poly[0]: \n        p = mul(p, x)\n    for x in sorted(poly[1], reverse=True): \n        p = div(p, x)\n    return p\n\nfor n in chain(range(11), [2]):\n    print(f'{n}: {to_text(terms(cyclotomic(n)))}')\n\nwant = 1\nfor n in count():\n    c = [c for c,_ in terms(cyclotomic(n))]\n    while want in c or -want in c:\n        print(f'C[{want}]: {n}')\n        want += 1\n"}
{"id": 383580, "name": "Minimal steps down to 1", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nno warnings 'recursion';\nuse List::Util qw( first );\nuse Data::Dump 'dd';\n\nfor ( [ 2000, [2, 3], [1] ], [ 2000, [2, 3], [2] ] )\n  {\n  my ( $n, $div, $sub ) = @$_;\n  print \"\\n\", '-' x 40, \" divisors @$div subtractors @$sub\\n\";\n  my ($solve, $max) = minimal( @$_ );\n  printf \"%4d takes %s step(s): %s\\n\",\n    $_, $solve->[$_] =~ tr/ // - 1, $solve->[$_] for 1 .. 10;\n  print \"\\n\";\n  printf \"%d number(s) below %d that take $\n    $max->[-1] =~ tr/ //, $n, $max->[-1];\n  ($solve, $max) = minimal( 20000, $div, $sub );\n  printf \"%d number(s) below %d that take $\n    $max->[-1] =~ tr/ //, 20000, $max->[-1];\n  }\n\nsub minimal\n  {\n  my ($top, $div, $sub) = @_;\n  my @solve = (0, ' ');\n  my @maximal;\n  for my $n ( 2 .. $top )\n    {\n    my @pick;\n    for my $d ( @$div )\n      {\n      $n % $d and next;\n      my $ans = \"/$d $solve[$n / $d]\";\n      $pick[$ans =~ tr/ //] //= $ans;\n      }\n    for my $s ( @$sub )\n      {\n      $n > $s or next;\n      my $ans = \"-$s $solve[$n - $s]\";\n      $pick[$ans =~ tr/ //] //= $ans;\n      }\n    $solve[$n] = first { defined  } @pick;\n    $maximal[$solve[$n] =~ tr/ // - 1] .= \" $n\";\n    }\n  return \\@solve, \\@maximal;\n  }\n", "target": "from functools import lru_cache\n\n\n\n\nDIVS = {2, 3}\nSUBS = {1}\n\nclass Minrec():\n    \"Recursive, memoised minimised steps to 1\"\n\n    def __init__(self, divs=DIVS, subs=SUBS):\n        self.divs, self.subs = divs, subs\n\n    @lru_cache(maxsize=None)\n    def _minrec(self, n):\n        \"Recursive, memoised\"\n        if n == 1:\n            return 0, ['=1']\n        possibles = {}\n        for d in self.divs:\n            if n % d == 0:\n                possibles[f'/{d}=>{n // d:2}'] = self._minrec(n // d)\n        for s in self.subs:\n            if n > s:\n                possibles[f'-{s}=>{n - s:2}'] = self._minrec(n - s)\n        thiskind, (count, otherkinds) = min(possibles.items(), key=lambda x: x[1])\n        ret = 1 + count, [thiskind] + otherkinds\n        return ret\n\n    def __call__(self, n):\n        \"Recursive, memoised\"\n        ans = self._minrec(n)[1][:-1]\n        return len(ans), ans\n\n\nif __name__ == '__main__':\n    for DIVS, SUBS in [({2, 3}, {1}), ({2, 3}, {2})]:\n        minrec = Minrec(DIVS, SUBS)\n        print('\\nMINIMUM STEPS TO 1: Recursive algorithm')\n        print('  Possible divisors:  ', DIVS)\n        print('  Possible decrements:', SUBS)\n        for n in range(1, 11):\n            steps, how = minrec(n)\n            print(f'    minrec({n:2}) in {steps:2} by: ', ', '.join(how))\n\n        upto = 2000\n        print(f'\\n    Those numbers up to {upto} that take the maximum, \"minimal steps down to 1\":')\n        stepn = sorted((minrec(n)[0], n) for n in range(upto, 0, -1))\n        mx = stepn[-1][0]\n        ans = [x[1] for x in stepn if x[0] == mx]\n        print('      Taking', mx, f'steps is/are the {len(ans)} numbers:',\n              ', '.join(str(n) for n in sorted(ans)))\n        \n        print()\n"}
{"id": 383581, "name": "Ramanujan's constant", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::AnyNum;\n\nsub ramanujan_const {\n    my ($x, $decimals) = @_;\n\n    $x = Math::AnyNum->new($x);\n    my $prec = (Math::AnyNum->pi * $x->sqrt)/log(10) + $decimals + 1;\n    local $Math::AnyNum::PREC = 4*$prec->round->numify;\n\n    exp(Math::AnyNum->pi * $x->sqrt)->round(-$decimals)->stringify;\n}\n\nmy $decimals = 100;\nprintf(\"Ramanujan's constant to $decimals decimals:\\n%s\\n\\n\",\n    ramanujan_const(163, $decimals));\n\nprint \"Heegner numbers yielding 'almost' integers:\\n\";\nmy @tests = (19, 96, 43, 960, 67, 5280, 163, 640320);\n\nwhile (@tests) {\n    my ($h, $x) = splice(@tests, 0, 2);\n    my $c = ramanujan_const($h, 32);\n    my $n = Math::AnyNum::ipow($x, 3) + 744;\n    printf(\"%3s: %51s \u2248 %18s (diff: %s)\\n\", $h, $c, $n, ($n - $c)->round(-32));\n}\n", "target": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))\n"}
{"id": 383582, "name": "Ramanujan's constant", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::AnyNum;\n\nsub ramanujan_const {\n    my ($x, $decimals) = @_;\n\n    $x = Math::AnyNum->new($x);\n    my $prec = (Math::AnyNum->pi * $x->sqrt)/log(10) + $decimals + 1;\n    local $Math::AnyNum::PREC = 4*$prec->round->numify;\n\n    exp(Math::AnyNum->pi * $x->sqrt)->round(-$decimals)->stringify;\n}\n\nmy $decimals = 100;\nprintf(\"Ramanujan's constant to $decimals decimals:\\n%s\\n\\n\",\n    ramanujan_const(163, $decimals));\n\nprint \"Heegner numbers yielding 'almost' integers:\\n\";\nmy @tests = (19, 96, 43, 960, 67, 5280, 163, 640320);\n\nwhile (@tests) {\n    my ($h, $x) = splice(@tests, 0, 2);\n    my $c = ramanujan_const($h, 32);\n    my $n = Math::AnyNum::ipow($x, 3) + 744;\n    printf(\"%3s: %51s \u2248 %18s (diff: %s)\\n\", $h, $c, $n, ($n - $c)->round(-32));\n}\n", "target": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))\n"}
{"id": 383583, "name": "Tree from nesting levels", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse Data::Dump qw(dd pp);\n\nmy @tests =\n  (\n  []\n  ,[1, 2, 4]\n  ,[3, 1, 3, 1]\n  ,[1, 2, 3, 1]\n  ,[3, 2, 1, 3]\n  ,[3, 3, 3, 1, 1, 3, 3, 3]\n  );\n\nfor my $before ( @tests )\n  {\n  dd { before => $before };\n  local $_ = (pp $before) =~ s/\\d+/ '['x($&-1) . $& . ']'x($&-1) /ger;\n  1 while s/\\](,\\s*)\\[/$1/;\n  my $after = eval;\n  dd { after => $after };\n  }\n", "target": "def to_tree(x, index=0, depth=1):\n   so_far = []\n   while index < len(x):\n       this = x[index]\n       if this == depth:\n           so_far.append(this)\n       elif this > depth:\n           index, deeper = to_tree(x, index, depth + 1)\n           so_far.append(deeper)\n       else: \n           index -=1\n           break\n       index += 1\n   return (index, so_far) if depth > 1 else so_far\n\n\nif __name__ ==  \"__main__\":\n    from pprint import pformat\n\n    def pnest(nest:list, width: int=9) -> str:\n        text = pformat(nest, width=width).replace('\\n', '\\n    ')\n        print(f\" OR {text}\\n\")\n\n    exercises = [\n        [],\n        [1, 2, 4],\n        [3, 1, 3, 1],\n        [1, 2, 3, 1],\n        [3, 2, 1, 3],\n        [3, 3, 3, 1, 1, 3, 3, 3],\n        ]\n    for flat in exercises:\n        nest = to_tree(flat)\n        print(f\"{flat} NESTS TO: {nest}\")\n        pnest(nest)\n"}
{"id": 383584, "name": "Tree from nesting levels", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse Data::Dump qw(dd pp);\n\nmy @tests =\n  (\n  []\n  ,[1, 2, 4]\n  ,[3, 1, 3, 1]\n  ,[1, 2, 3, 1]\n  ,[3, 2, 1, 3]\n  ,[3, 3, 3, 1, 1, 3, 3, 3]\n  );\n\nfor my $before ( @tests )\n  {\n  dd { before => $before };\n  local $_ = (pp $before) =~ s/\\d+/ '['x($&-1) . $& . ']'x($&-1) /ger;\n  1 while s/\\](,\\s*)\\[/$1/;\n  my $after = eval;\n  dd { after => $after };\n  }\n", "target": "def to_tree(x, index=0, depth=1):\n   so_far = []\n   while index < len(x):\n       this = x[index]\n       if this == depth:\n           so_far.append(this)\n       elif this > depth:\n           index, deeper = to_tree(x, index, depth + 1)\n           so_far.append(deeper)\n       else: \n           index -=1\n           break\n       index += 1\n   return (index, so_far) if depth > 1 else so_far\n\n\nif __name__ ==  \"__main__\":\n    from pprint import pformat\n\n    def pnest(nest:list, width: int=9) -> str:\n        text = pformat(nest, width=width).replace('\\n', '\\n    ')\n        print(f\" OR {text}\\n\")\n\n    exercises = [\n        [],\n        [1, 2, 4],\n        [3, 1, 3, 1],\n        [1, 2, 3, 1],\n        [3, 2, 1, 3],\n        [3, 3, 3, 1, 1, 3, 3, 3],\n        ]\n    for flat in exercises:\n        nest = to_tree(flat)\n        print(f\"{flat} NESTS TO: {nest}\")\n        pnest(nest)\n"}
{"id": 383585, "name": "Tree datastructures", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse JSON;\nuse Data::Printer;\n\nmy $trees = <<~END;\n    RosettaCode\n      encourages\n        code\n          diversity\n          comparison\n      discourages\n        golfing\n        trolling\n        emphasising execution speed\n    code-golf.io\n      encourages\n        golfing\n      discourages\n        comparison\n    END\n\nmy $level = '  ';\nsub nested_to_indent { shift =~ s\nsub indent_to_nested { shift =~ s\n\nsay my $indent = nested_to_indent $trees;\n    my $nest   = indent_to_nested $indent;\n\nuse Test::More;\nis($trees, $nest, 'Round-trip');\ndone_testing();\n\n\nsub import {\n    my($trees) = @_;\n    my $level = '  ';\n    my $forest;\n    my $last = -999;\n\n    for my $branch (split /\\n/, $trees) {\n        $branch =~ m/(($level*))*/;\n        my $this = $1 ? length($1)/length($level) : 0;\n        $forest .= do {\n            if    ($this gt $last) { '['                   . trim_and_quote($branch) }\n            elsif ($this lt $last) { ']'x($last-$this).',' . trim_and_quote($branch) }\n            else                   {                         trim_and_quote($branch) }\n        };\n        $last = $this;\n    }\n    sub trim_and_quote { shift =~ s/^\\s*(.*\\S)\\s*$/\"$1\",/r }\n\n    eval $forest . ']' x (1+$last);\n}\n\nmy $forest = import $trees;\nsay \"Native data structure:\\n\" . np $forest;\nsay \"\\nJSON:\\n\" . encode_json($forest);\n", "target": "from pprint import pprint as pp\n\ndef to_indent(node, depth=0, flat=None):\n    if flat is None:\n        flat = []\n    if node:\n        flat.append((depth, node[0]))\n    for child in node[1]:\n        to_indent(child, depth + 1, flat)\n    return flat\n\ndef to_nest(lst, depth=0, level=None):\n    if level is None:\n        level = []\n    while lst:\n        d, name = lst[0]\n        if d == depth:\n            children = []\n            level.append((name, children))\n            lst.pop(0)\n        elif d > depth:  \n            to_nest(lst, d, children)\n        elif d < depth:  \n            return\n    return level[0] if level else None\n                    \nif __name__ == '__main__':\n    print('Start Nest format:')\n    nest = ('RosettaCode', [('rocks', [('code', []), ('comparison', []), ('wiki', [])]), \n                            ('mocks', [('trolling', [])])])\n    pp(nest, width=25)\n\n    print('\\n... To Indent format:')\n    as_ind = to_indent(nest)\n    pp(as_ind, width=25)\n\n    print('\\n... To Nest format:')\n    as_nest = to_nest(as_ind)\n    pp(as_nest, width=25)\n\n    if nest != as_nest:\n        print(\"Whoops round-trip issues\")\n"}
{"id": 383586, "name": "Most frequent k chars distance", "source": "Translate Perl to Python: \nuse strict ;\nuse warnings ;\n\nsub mostFreqHashing {\n   my $inputstring = shift ;\n   my $howmany = shift ;\n   my $outputstring ;\n   my %letterfrequencies = findFrequencies ( $inputstring ) ;\n   my @orderedChars = sort { $letterfrequencies{$b} <=> $letterfrequencies{$a} ||\n      index( $inputstring , $a ) <=> index ( $inputstring , $b ) } keys %letterfrequencies ;\n   for my $i ( 0..$howmany - 1 ) {\n      $outputstring .= ( $orderedChars[ $i ] . $letterfrequencies{$orderedChars[ $i ]} ) ;\n   }\n   return $outputstring ;\n}\n\nsub findFrequencies {\n   my $input = shift ;\n   my %letterfrequencies ;\n   for my $i ( 0..length( $input ) - 1 ) {\n      $letterfrequencies{substr( $input , $i , 1 ) }++ ;\n   }\n   return %letterfrequencies ;\n}\n\nsub mostFreqKSimilarity {\n   my $first = shift ;\n   my $second = shift ;\n   my $similarity = 0 ;\n   my %frequencies_first = findFrequencies( $first ) ;\n   my %frequencies_second = findFrequencies( $second ) ;\n   foreach my $letter ( keys %frequencies_first ) {\n      if ( exists ( $frequencies_second{$letter} ) ) {\n\t $similarity += ( $frequencies_second{$letter} + $frequencies_first{$letter} ) ;\n      }\n   }\n   return $similarity ;\n}\n\nsub mostFreqKSDF {\n   (my $input1 , my $input2 , my $k , my $maxdistance ) = @_ ;\n   return $maxdistance - mostFreqKSimilarity( mostFreqHashing( $input1 , $k) ,\n\t mostFreqHashing( $input2 , $k) ) ;\n}\n\nmy $firststring = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\" ;\nmy $secondstring = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\" ;\nprint \"MostFreqKHashing ( \" . '$firststring , 2)' . \" is \" . mostFreqHashing( $firststring , 2 ) . \"\\n\" ;\nprint \"MostFreqKHashing ( \" . '$secondstring , 2)' . \" is \" . mostFreqHashing( $secondstring , 2 ) . \"\\n\" ;\n", "target": "import collections\ndef MostFreqKHashing(inputString, K):\n    occuDict = collections.defaultdict(int)\n    for c in inputString:\n        occuDict[c] += 1\n    occuList = sorted(occuDict.items(), key = lambda x: x[1], reverse = True)\n    outputStr = ''.join(c + str(cnt) for c, cnt in occuList[:K])\n    return outputStr \n\n\ndef MostFreqKSimilarity(inputStr1, inputStr2):\n    similarity = 0\n    for i in range(0, len(inputStr1), 2):\n        c = inputStr1[i]\n        cnt1 = int(inputStr1[i + 1])\n        for j in range(0, len(inputStr2), 2):\n            if inputStr2[j] == c:\n                cnt2 = int(inputStr2[j + 1])\n                similarity += cnt1 + cnt2\n                break\n    return similarity\n\ndef MostFreqKSDF(inputStr1, inputStr2, K, maxDistance):\n    return maxDistance - MostFreqKSimilarity(MostFreqKHashing(inputStr1,K), MostFreqKHashing(inputStr2,K))\n"}
{"id": 383587, "name": "One-time pad", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Crypt::OTP;\nuse Bytes::Random::Secure qw( random_bytes );\n\nprint \"Message    \u00a0: \", my $message = \"show me the monKey\", \"\\n\";\n\nmy $otp = random_bytes(length $message);\nprint \"Ord(OTP)   \u00a0: \", ( map { ord($_).' ' } (split //, $otp)   ) , \"\\n\";\n\nmy $cipher = OTP( $otp, $message, 1 );\nprint \"Ord(Cipher)\u00a0: \", ( map { ord($_).' ' } (split //, $cipher) ) , \"\\n\";\n\nprint \"Decoded    \u00a0: \",  OTP( $otp, $cipher, 1 ), \"\\n\";\n", "target": "\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n\nMAGIC = \"\n\n\ndef make_keys(n, size):\n    \n    \n    \n    \n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \n    pad = [\n        MAGIC,\n        f\"\n        f\"\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    \n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    \n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    \n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n"}
{"id": 383588, "name": "One-time pad", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Crypt::OTP;\nuse Bytes::Random::Secure qw( random_bytes );\n\nprint \"Message    \u00a0: \", my $message = \"show me the monKey\", \"\\n\";\n\nmy $otp = random_bytes(length $message);\nprint \"Ord(OTP)   \u00a0: \", ( map { ord($_).' ' } (split //, $otp)   ) , \"\\n\";\n\nmy $cipher = OTP( $otp, $message, 1 );\nprint \"Ord(Cipher)\u00a0: \", ( map { ord($_).' ' } (split //, $cipher) ) , \"\\n\";\n\nprint \"Decoded    \u00a0: \",  OTP( $otp, $cipher, 1 ), \"\\n\";\n", "target": "\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n\nMAGIC = \"\n\n\ndef make_keys(n, size):\n    \n    \n    \n    \n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \n    pad = [\n        MAGIC,\n        f\"\n        f\"\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    \n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    \n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    \n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n"}
{"id": 383589, "name": "Functional coverage tree", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub walktree {\n    my @parts;\n    while( $_[0] =~ /(?<head> (\\s*)   \\N+\\n  )         \n                     (?<body> (?:\\2 \\s\\N+\\n)*)/gx ) {  \n\n        my($head, $body) = ($+{head}, $+{body});\n        $head =~ /^.*?      \\|      \n                  (\\S*) \\s* \\|      \n                  (\\S*)       /x;   \n        my $weight   = sprintf '%-8s',  $1 || 1;\n        my $coverage = sprintf '%-10s', $2 || 0;\n        my($w, $wsum) = (0, 0);\n\n        $head .= $_->[0],\n        $w    += $_->[1],\n        $wsum += $_->[1] * $_->[2]\n              for walktree( $body );\n\n        $coverage = sprintf '%-10.2g', $wsum/$w unless $w == 0;\n        push @parts, [ $head =~ s/\\|.*/|$weight|$coverage|/r, $weight, $coverage ];\n    }\n    return @parts;\n}\n\nprint $_->[0] for walktree( join '', <DATA> );\n\n", "target": "from itertools import zip_longest\n\n\nfc2 = \n\nNAME, WT, COV = 0, 1, 2\n\ndef right_type(txt):\n    try:\n        return float(txt)\n    except ValueError:\n        return txt\n\ndef commas_to_list(the_list, lines, start_indent=0):\n    \n    for n, line in lines:\n        indent = 0\n        while line.startswith(' ' * (4 * indent)):\n            indent += 1\n        indent -= 1\n        fields = [right_type(f) for f in line.strip().split(',')]\n        if indent == start_indent:\n            the_list.append(fields)\n        elif indent > start_indent:\n            lst = [fields]\n            sub = commas_to_list(lst, lines, indent)\n            the_list[-1] = (the_list[-1], lst)\n            if sub not in (None, ['']) :\n                the_list.append(sub)\n        else:\n            return fields if fields else None\n    return None\n\n\ndef pptreefields(lst, indent=0, widths=['%-32s', '%-8g', '%-10g']):\n    \n    lhs = ' ' * (4 * indent)\n    for item in lst:\n        if type(item) != tuple:\n            name, *rest = item\n            print(widths[0] % (lhs + name), end='|')\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\n                if type(item) == str:\n                    width = width[:-1] + 's'\n                print(width % item, end='|')\n            print()\n        else:\n            item, children = item\n            name, *rest = item\n            print(widths[0] % (lhs + name), end='|')\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\n                if type(item) == str:\n                    width = width[:-1] + 's'\n                print(width % item, end='|')\n            print()\n            pptreefields(children, indent+1)\n\n\ndef default_field(node_list):\n    node_list[WT] = node_list[WT] if node_list[WT] else 1.0\n    node_list[COV] = node_list[COV] if node_list[COV] else 0.0\n\ndef depth_first(tree, visitor=default_field):\n    for item in tree:\n        if type(item) == tuple:\n            item, children = item\n            depth_first(children, visitor)\n        visitor(item)\n            \n\ndef covercalc(tree):\n    \n    sum_covwt, sum_wt = 0, 0\n    for item in tree:\n        if type(item) == tuple:\n            item, children = item\n            item[COV] = covercalc(children)\n        sum_wt  += item[WT]\n        sum_covwt += item[COV] * item[WT]\n    cov = sum_covwt / sum_wt\n    return cov\n\nif __name__ == '__main__':        \n    lstc = []\n    commas_to_list(lstc, ((n, ln) for n, ln in enumerate(fc2.split('\\n'))))\n    \n    \n    \n    depth_first(lstc)\n    \n    \n    print('\\n\\nTOP COVERAGE = %f\\n' % covercalc(lstc))\n    depth_first(lstc)\n    pptreefields(['NAME_HIERARCHY WEIGHT COVERAGE'.split()] + lstc)\n"}
{"id": 383590, "name": "Graph colouring", "source": "Translate Perl to Python: use strict;\nuse warnings;\nno warnings 'uninitialized';\nuse feature 'say';\nuse constant True => 1;\nuse List::Util qw(head uniq);\n\nsub GraphNodeColor {\n    my(%OneMany, %NodeColor, %NodePool, @ColorPool);\n    my(@data) = @_;\n\n    for (@data) {\n        my($a,$b) = @$_;\n        push @{$OneMany{$a}}, $b;\n        push @{$OneMany{$b}}, $a;\n    }\n\n    @ColorPool = 0 .. -1 + scalar %OneMany;\n    $NodePool{$_} = True for keys %OneMany;\n\n    if ($OneMany{''}) { \n        delete $NodePool{$_} for @{$OneMany{''}};\n        delete $NodePool{''};\n    }\n\n    while (%NodePool) {\n        my $color = shift @ColorPool;\n        my %TempPool = %NodePool;\n\n        while (my $n = head 1, sort keys %TempPool) {\n            $NodeColor{$n} = $color;\n            delete $TempPool{$n};\n            delete $TempPool{$_} for @{$OneMany{$n}} ; \n            delete $NodePool{$n};\n        }\n\n        if ($OneMany{''}) { \n            $NodeColor{$_} = head 1, sort values %NodeColor for @{$OneMany{''}};\n        }\n    }\n    %NodeColor\n}\n\nmy @DATA = (\n    [ [1,2],[2,3],[3,1],[4,undef],[5,undef],[6,undef] ],\n    [ [1,6],[1,7],[1,8],[2,5],[2,7],[2,8],[3,5],[3,6],[3,8],[4,5],[4,6],[4,7] ],\n    [ [1,4],[1,6],[1,8],[3,2],[3,6],[3,8],[5,2],[5,4],[5,8],[7,2],[7,4],[7,6] ],\n    [ [1,6],[7,1],[8,1],[5,2],[2,7],[2,8],[3,5],[6,3],[3,8],[4,5],[4,6],[4,7] ]\n);\n\nfor my $d (@DATA) {\n    my %result = GraphNodeColor @$d;\n\n    my($graph,$colors);\n    $graph  .= '(' . join(' ', @$_) . '), ' for @$d;\n    $colors .= ' ' . $result{$$_[0]} . '-' . ($result{$$_[1]} // '') . '   ' for @$d;\n\n    say 'Graph \u00a0: ' . $graph =~ s/,\\s*$//r;\n    say 'Colors\u00a0: ' . $colors;\n    say 'Nodes \u00a0: ' . keys %result;\n    say 'Edges \u00a0: ' . @$d;\n    say 'Unique\u00a0: ' . uniq values %result;\n    say '';\n}\n", "target": "import re\nfrom collections import defaultdict\nfrom itertools import count\n\n\nconnection_re = r\n\nclass Graph:\n\n    def __init__(self, name, connections):\n        self.name = name\n        self.connections = connections\n        g = self.graph = defaultdict(list)  \n\n        matches = re.finditer(connection_re, connections,\n                              re.MULTILINE | re.VERBOSE)\n        for match in matches:\n            n1, n2, n = match.groups()\n            if n:\n                g[n] += []\n            else:\n                g[n1].append(n2)    \n                g[n2].append(n1)\n\n    def greedy_colour(self, order=None):\n        \"Greedy colourisation algo.\"\n        if order is None:\n            order = self.graph      \n        colour = self.colour = {}\n        neighbours = self.graph\n        for node in order:\n            used_neighbour_colours = (colour[nbr] for nbr in neighbours[node]\n                                      if nbr in colour)\n            colour[node] = first_avail_int(used_neighbour_colours)\n        self.pp_colours()\n        return colour\n\n    def pp_colours(self):\n        print(f\"\\n{self.name}\")\n        c = self.colour\n        e = canonical_edges = set()\n        for n1, neighbours in sorted(self.graph.items()):\n            if neighbours:\n                for n2 in neighbours:\n                    edge = tuple(sorted([n1, n2]))\n                    if edge not in canonical_edges:\n                        print(f\"       {n1}-{n2}: Colour: {c[n1]}, {c[n2]}\")\n                        canonical_edges.add(edge)\n            else:\n                print(f\"         {n1}: Colour: {c[n1]}\")\n        lc = len(set(c.values()))\n        print(f\"    \n\n\ndef first_avail_int(data):\n    \"return lowest int 0... not in data\"\n    d = set(data)\n    for i in count():\n        if i not in d:\n            return i\n\n\nif __name__ == '__main__':\n    for name, connections in [\n            ('Ex1', \"0-1 1-2 2-0 3\"),\n            ('Ex2', \"1-6 1-7 1-8 2-5 2-7 2-8 3-5 3-6 3-8 4-5 4-6 4-7\"),\n            ('Ex3', \"1-4 1-6 1-8 3-2 3-6 3-8 5-2 5-4 5-8 7-2 7-4 7-6\"),\n            ('Ex4', \"1-6 7-1 8-1 5-2 2-7 2-8 3-5 6-3 3-8 4-5 4-6 4-7\"),\n            ]:\n        g = Graph(name, connections)\n        g.greedy_colour()\n"}
{"id": 383591, "name": "Faces from a mesh", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Set::Scalar;\nuse Set::Bag;\nuse Storable qw(dclone);\n\nsub show { my($pts) = @_; my $p='( '; $p .= '(' . join(' ',@$_) . ') ' for @$pts; $p.')' }\n\nsub check_equivalence {\n    my($a, $b) = @_;\n    Set::Scalar->new(@$a) == Set::Scalar->new(@$b)\n}\n\nsub edge_to_periphery {\n    my $a = dclone \\@_;\n\n    my $bag_a = Set::Bag->new;\n    for my $p (@$a) {\n        $bag_a->insert( @$p[0] => 1);\n        $bag_a->insert( @$p[1] => 1);\n    }\n    2 != @$bag_a{$_} and return 0 for keys %$bag_a;\n\n    my $b = shift @$a;\n    while ($\n        for my $k (0..$\n            my $v = @$a[$k];\n            if (@$v[0] == @$b[-1]) {\n                push @$b, @$v[1];\n                splice(@$a,$k,1);\n                last\n            } elsif (@$v[1] == @$b[-1]) {\n                push @$b, @$v[0];\n                splice(@$a,$k,1);\n                last\n            }\n        }\n    }\n    @$b;\n}\n\nsay 'Perimeter format equality checks:';\nfor ([[8, 1, 3], [1, 3, 8]],\n     [[18, 8, 14, 10, 12, 17, 19], [8, 14, 10, 12, 17, 19, 18]]) {\n    my($a, $b) = @$_;\n    say '(' . join(', ', @$a) . ')  equivalent to  (' . join(', ', @$b) . ')? ',\n        check_equivalence($a, $b) ? 'True' : 'False';\n}\n\nsay \"\\nEdge to perimeter format translations:\";\nfor ([[1, 11], [7, 11], [1, 7]],\n     [[11, 23], [1, 17], [17, 23], [1, 11]],\n     [[8, 14], [17, 19], [10, 12], [10, 14], [12, 17], [8, 18], [18, 19]],\n     [[1, 3], [9, 11], [3, 11], [1, 11]]) {\n    say show($_) . '  ==>  (' .  (join ' ', edge_to_periphery(@$_) or 'Invalid edge format') . ')'\n}\n", "target": "def perim_equal(p1, p2):\n    \n    if len(p1) != len(p2) or set(p1) != set(p2):\n        return False\n    if any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1))):\n        return True\n    p2 = p2[::-1] \n    return any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1)))\n\ndef edge_to_periphery(e):\n    edges = sorted(e)\n    p = list(edges.pop(0)) if edges else []\n    last = p[-1] if p else None\n    while edges:\n        for n, (i, j) in enumerate(edges):\n            if i == last:\n                p.append(j)\n                last = j\n                edges.pop(n)\n                break\n            elif j == last:\n                p.append(i)\n                last = i\n                edges.pop(n)\n                break\n        else:\n            \n            return \">>>Error! Invalid edge format<<<\"\n    return p[:-1]\n\nif __name__ == '__main__':\n    print('Perimeter format equality checks:')\n    for eq_check in [\n            { 'Q': (8, 1, 3),\n              'R': (1, 3, 8)},\n            { 'U': (18, 8, 14, 10, 12, 17, 19),\n              'V': (8, 14, 10, 12, 17, 19, 18)} ]:\n        (n1, p1), (n2, p2) = eq_check.items()\n        eq = '==' if perim_equal(p1, p2) else '!='\n        print(' ', n1, eq, n2)\n\n    print('\\nEdge to perimeter format translations:')\n    edge_d = {\n     'E': {(1, 11), (7, 11), (1, 7)},\n     'F': {(11, 23), (1, 17), (17, 23), (1, 11)},\n     'G': {(8, 14), (17, 19), (10, 12), (10, 14), (12, 17), (8, 18), (18, 19)},\n     'H': {(1, 3), (9, 11), (3, 11), (1, 11)}\n            }\n    for name, edges in edge_d.items():\n        print(f\"  {name}: {edges}\\n     -> {edge_to_periphery(edges)}\")\n"}
{"id": 383592, "name": "Pragmatic directives", "source": "Translate Perl to Python: use warnings;  \nuse strict;    \n", "target": "Python 3.2 (r32:88445, Feb 20 2011, 21:30:00) [MSC v.1500 64 bit (AMD64)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> import __future__\n>>> __future__.all_feature_names\n['nested_scopes', 'generators', 'division', 'absolute_import', 'with_statement', 'print_function', 'unicode_literals', 'barry_as_FLUFL']\n>>>\n"}
{"id": 383593, "name": "Topological sort_Extracted top item", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse List::Util qw( uniq );\n\nmy $deps = <<END;\ntop1    des1 ip1 ip2\ntop2    des1 ip2 ip3\nip1     extra1 ip1a ipcommon\nip2     ip2a ip2b ip2c ipcommon\ndes1    des1a des1b des1c\ndes1a   des1a1 des1a2\ndes1c   des1c1 extra1\nEND\n\nsub before\n  {\n  map { $deps =~ /^$_\\b(.+)/m ? before( split ' ', $1 ) : (), $_ } @_\n  }\n\n1 while $deps =~ s/^(\\w+)\\b.*?\\K\\h+\\1\\b//gm; \nprint \"TOP LEVELS: @{[grep $deps\u00a0!~ /\\h$_\\b/, $deps =~ /^\\w+/gm]}\\n\";\nprint \"\\nTARGET $_ ORDER: @{[ uniq before split ]}\\n\"\n  for $deps =~ /^\\w+/gm, 'top1 top2';\n", "target": "try:\n    from functools import reduce\nexcept: pass\n\n\ndef topx(data, tops=None):\n    'Extract the set of top-level(s) in topological order'\n    for k, v in data.items():\n        v.discard(k) \n    if tops is None:\n        tops = toplevels(data)\n    return _topx(data, tops, [], set())\n\ndef _topx(data, tops, _sofar, _sofar_set):\n    'Recursive topological extractor'\n    _sofar += [tops] \n    _sofar_set.union(tops)\n    depends = reduce(set.union, (data.get(top, set()) for top in tops))\n    if depends:\n        _topx(data, depends, _sofar, _sofar_set)\n    ordered, accum = [], set()\n    for s in _sofar[::-1]:\n        ordered += [sorted(s - accum)]\n        accum |= s\n    return ordered\n\ndef printorder(order):\n    'Prettyprint topological ordering'\n    if order:\n        print(\"First: \" + ', '.join(str(s) for s in order[0]))\n    for o in order[1:]:\n        print(\" Then: \" + ', '.join(str(s) for s in o))\n\ndef toplevels(data):\n    \n    for k, v in data.items():\n        v.discard(k) \n    dependents = reduce(set.union, data.values())\n    return  set(data.keys()) - dependents\n\nif __name__ == '__main__':\n    data = dict(\n        top1  = set('ip1 des1 ip2'.split()),\n        top2  = set('ip2 des1 ip3'.split()),\n        des1  = set('des1a des1b des1c'.split()),\n        des1a = set('des1a1 des1a2'.split()),\n        des1c = set('des1c1 extra1'.split()),\n        ip2   = set('ip2a ip2b ip2c ipcommon'.split()),\n        ip1   = set('ip1a ipcommon extra1'.split()),\n        )\n\n    tops = toplevels(data)\n    print(\"The top levels of the dependency graph are: \" + ' '.join(tops))\n\n    for t in sorted(tops):\n        print(\"\\nThe compile order for top level: %s is...\" % t)\n        printorder(topx(data, set([t])))\n    if len(tops) > 1:\n        print(\"\\nThe compile order for top levels: %s is...\"\n              % ' and '.join(str(s) for s in sorted(tops)) )\n        printorder(topx(data, tops))\n"}
{"id": 383594, "name": "Topological sort_Extracted top item", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse List::Util qw( uniq );\n\nmy $deps = <<END;\ntop1    des1 ip1 ip2\ntop2    des1 ip2 ip3\nip1     extra1 ip1a ipcommon\nip2     ip2a ip2b ip2c ipcommon\ndes1    des1a des1b des1c\ndes1a   des1a1 des1a2\ndes1c   des1c1 extra1\nEND\n\nsub before\n  {\n  map { $deps =~ /^$_\\b(.+)/m ? before( split ' ', $1 ) : (), $_ } @_\n  }\n\n1 while $deps =~ s/^(\\w+)\\b.*?\\K\\h+\\1\\b//gm; \nprint \"TOP LEVELS: @{[grep $deps\u00a0!~ /\\h$_\\b/, $deps =~ /^\\w+/gm]}\\n\";\nprint \"\\nTARGET $_ ORDER: @{[ uniq before split ]}\\n\"\n  for $deps =~ /^\\w+/gm, 'top1 top2';\n", "target": "try:\n    from functools import reduce\nexcept: pass\n\n\ndef topx(data, tops=None):\n    'Extract the set of top-level(s) in topological order'\n    for k, v in data.items():\n        v.discard(k) \n    if tops is None:\n        tops = toplevels(data)\n    return _topx(data, tops, [], set())\n\ndef _topx(data, tops, _sofar, _sofar_set):\n    'Recursive topological extractor'\n    _sofar += [tops] \n    _sofar_set.union(tops)\n    depends = reduce(set.union, (data.get(top, set()) for top in tops))\n    if depends:\n        _topx(data, depends, _sofar, _sofar_set)\n    ordered, accum = [], set()\n    for s in _sofar[::-1]:\n        ordered += [sorted(s - accum)]\n        accum |= s\n    return ordered\n\ndef printorder(order):\n    'Prettyprint topological ordering'\n    if order:\n        print(\"First: \" + ', '.join(str(s) for s in order[0]))\n    for o in order[1:]:\n        print(\" Then: \" + ', '.join(str(s) for s in o))\n\ndef toplevels(data):\n    \n    for k, v in data.items():\n        v.discard(k) \n    dependents = reduce(set.union, data.values())\n    return  set(data.keys()) - dependents\n\nif __name__ == '__main__':\n    data = dict(\n        top1  = set('ip1 des1 ip2'.split()),\n        top2  = set('ip2 des1 ip3'.split()),\n        des1  = set('des1a des1b des1c'.split()),\n        des1a = set('des1a1 des1a2'.split()),\n        des1c = set('des1c1 extra1'.split()),\n        ip2   = set('ip2a ip2b ip2c ipcommon'.split()),\n        ip1   = set('ip1a ipcommon extra1'.split()),\n        )\n\n    tops = toplevels(data)\n    print(\"The top levels of the dependency graph are: \" + ' '.join(tops))\n\n    for t in sorted(tops):\n        print(\"\\nThe compile order for top level: %s is...\" % t)\n        printorder(topx(data, set([t])))\n    if len(tops) > 1:\n        print(\"\\nThe compile order for top levels: %s is...\"\n              % ' and '.join(str(s) for s in sorted(tops)) )\n        printorder(topx(data, tops))\n"}
{"id": 383595, "name": "Periodic table", "source": "Translate Perl to Python: use strict;\nuse warnings; no warnings 'uninitialized';\nuse feature 'say';\nuse List::Util <sum head>;\n\nsub divmod { int $_[0]/$_[1], $_[0]%$_[1] }\n\nmy $b = 18;\nmy(@offset,@span,$cnt);\npush @span, ($cnt++) x $_ for <1 3 8 44 15 17 15 15>;\n@offset = (16, 10, 10, (2*$b)+1, (-2*$b)-15, (2*$b)+1, (-2*$b)-15);\n\nfor my $n (<1 2 29 42 57 58 72 89 90 103 118>) {\n    printf \"%3d: %2d, %2d\\n\", $n, map { $_+1 } divmod $n-1 + sum(head $span[$n-1], @offset), $b;\n}\n", "target": "def perta(atomic) -> (int, int):\n\n    NOBLES = 2, 10, 18, 36, 54, 86, 118\n    INTERTWINED = 0, 0, 0, 0, 0, 57, 89\n    INTERTWINING_SIZE = 14\n    LINE_WIDTH = 18\n\n    prev_noble = 0\n    for row, noble in enumerate(NOBLES):\n        if atomic <= noble:  \n            nb_elem = noble - prev_noble  \n            rank =  atomic - prev_noble  \n            if INTERTWINED[row] and INTERTWINED[row] <= atomic <= INTERTWINED[row] + INTERTWINING_SIZE:  \n                row += 2\n                col = rank + 1\n            else:  \n                \n                nb_empty = LINE_WIDTH - nb_elem  \n                inside_left_element_rank = 2 if noble > 2 else 1\n                col = rank + (nb_empty if rank > inside_left_element_rank else 0)\n            break\n        prev_noble = noble\n    return row+1, col\n\n\n\n\n\nTESTS = {\n    1: (1, 1),\n    2: (1, 18),\n    29: (4,11),\n    42: (5, 6),\n    58: (8, 5),\n    59: (8, 6),\n    57: (8, 4),\n    71: (8, 18),\n    72: (6, 4),\n    89: (9, 4),\n    90: (9, 5),\n    103: (9, 18),\n}\n\nfor input, out in TESTS.items():\n    found = perta(input)\n    print('TEST:{:3d} -> '.format(input) + str(found) + (f'\u00a0; ERROR: expected {out}' if found != out else ''))\n"}
{"id": 383596, "name": "Banker's algorithm", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @avail =  (3, 1, 1, 2);                              \nmy @maxm  = ([3, 3, 2, 2], [1, 2, 3, 4], [1, 3, 5, 0]); \nmy @allot = ([1, 2, 2, 1], [1, 0, 3, 3], [1, 2, 1, 0]); \n\n\nsub isSafe {\n    my($work, $maxm, $allot) = @_;\n    my $P = @$allot;            \n    my $R = @$work;             \n    my @unfinished = (1) x $P;  \n    my(@safeSeq,@need);\n    for my $i (0..$P-1) {       \n        for my $j (0..$R-1) {   \n           $need[$i][$j] = $$maxm[$i][$j]   - $$allot[$i][$j]\n        }\n    }\n\n    \n    my $count = 0;\n    while ($count < $P) {\n        my $found = 0;\n        for my $p (0..$P-1) {\n            \n            if ($unfinished[$p]) {\n                \n                my $satisfied;\n                LOOP: for my $j (0..$R-1) {\n                    $satisfied = $j;\n                    last LOOP if $need[$p][$j] > $$work[$j]\n                }\n                \n                if ($satisfied == $R-1) {\n                    $$work[$_] += $$allot[$p][$_] for 0..$R-1; \n                    say 'available resources: ' . join ' ', @$work;\n                    push @safeSeq, $p;                         \n                    $unfinished[$p]  = 1;                      \n                    $count += 1;\n                    $found = 1\n                }\n            }\n        }\n        \n        return 0, \"System is not in safe state.\" unless $found;\n    }\n    \n    return 1, \"Safe sequence is: \" . join ' ', @safeSeq\n}\n\n\nmy($safe_state,$status_message) = isSafe(\\@avail, \\@maxm, \\@allot);\nsay \"Safe state? \" . ($safe_state ? 'True' : 'False');\nsay \"Message:    $status_message\";\n", "target": "def main():\n    resources = int(input(\"Cantidad de recursos: \"))\n    processes = int(input(\"Cantidad de procesos: \"))\n    max_resources = [int(i) for i in input(\"Recursos m\u00e1ximos: \").split()]\n\n    print(\"\\n-- recursos asignados para cada proceso  --\")\n    currently_allocated = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    print(\"\\n--- recursos m\u00e1ximos para cada proceso  ---\")\n    max_need = [[int(i) for i in input(f\"proceso {j + 1}: \").split()] for j in range(processes)]\n\n    allocated = [0] * resources\n    for i in range(processes):\n        for j in range(resources):\n            allocated[j] += currently_allocated[i][j]\n    print(f\"\\nRecursos totales asignados \u00a0: {allocated}\")\n\n    available = [max_resources[i] - allocated[i] for i in range(resources)]\n    print(f\"Recursos totales disponibles: {available}\\n\")\n\n    running = [True] * processes\n    count = processes\n    while count != 0:\n        safe = False\n        for i in range(processes):\n            if running[i]:\n                executing = True\n                for j in range(resources):\n                    if max_need[i][j] - currently_allocated[i][j] > available[j]:\n                        executing = False\n                        break\n                if executing:\n                    print(f\"proceso {i + 1} ejecut\u00e1ndose\")\n                    running[i] = False\n                    count -= 1\n                    safe = True\n                    for j in range(resources):\n                        available[j] += currently_allocated[i][j]\n                    break\n        if not safe:\n            print(\"El proceso est\u00e1 en un estado inseguro.\")\n            break\n\n        print(f\"El proceso est\u00e1 en un estado seguro.\\nRecursos disponibles: {available}\\n\")\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 383597, "name": "Sunflower fractal", "source": "Translate Perl to Python: use Game.SDL2;\nuse Game.Framework;\n\nclass Test {\n  @framework : GameFramework;\n  @colors : Color[];\n  \n  function : Main(args : String[]) ~ Nil {\n    Test->New()->Run();\n  }\n  \n  New() {\n    @framework := GameFramework->New(GameConsts->SCREEN_WIDTH, GameConsts->SCREEN_HEIGHT, \"Test\");\n    @framework->SetClearColor(Color->New(0, 0, 0));\n    @colors := Color->New[2];\n    @colors[0] := Color->New(255,128,0); \n    @colors[1] := Color->New(255,255,25); \n  }\n  \n  method : Run() ~ Nil {\n    if(@framework->IsOk()) {\n      e := @framework->GetEvent();\n      \n      quit := false;\n      while(<>quit) {\n        \n        while(e->Poll() <> 0) {\n          if(e->GetType() = EventType->SDL_QUIT) {\n            quit := true;\n          };\n        };\n\n        @framework->FrameStart();\n        Render(525,525,0.50,3000);\n        @framework->FrameEnd();\n      };\n    }\n    else {\n      \"--- Error Initializing Environment ---\"->ErrorLine();\n      return;\n    };\n\n    leaving {\n      @framework->Quit();\n    };\n  }\n\n  method : Render(winWidth : Int, winHeight : Int, diskRatio : Float, iter : Int) ~ Nil {\n    renderer := @framework->GetRenderer();\n\n    @framework->Clear();\n\n    factor := 0.5 + 1.25->SquareRoot();\n    x := winWidth / 2.0;\n    y := winHeight / 2.0;\n    maxRad := Float->Power(iter, factor) / iter;\n\n    for(i:=0;i<=iter;i+=1;) {\n      r := Float->Power(i,factor)/iter;\n      color := r/maxRad < diskRatio ? @colors[0] : @colors[1];\n      theta := 2*Float->Pi()*factor*i;\n      renderer->CircleColor(x + r*theta->Sin(), y + r*theta->Cos(), 10 * i/(1.0*iter), color);\n    };\n        \n    @framework->Show();\n  }\n}\n\nconsts GameConsts {\n  SCREEN_WIDTH := 640,\n  SCREEN_HEIGHT := 480\n}\n", "target": "from turtle import *\nfrom math import *\n\n\n\niter = 3000\ndiskRatio = .5\n\nfactor = .5 + sqrt(1.25)\n\nscreen = getscreen()\n\n(winWidth, winHeight) = screen.screensize()\n\n\n\n\n\nx = 0.0\ny = 0.0\n\nmaxRad = pow(iter,factor)/iter;\n\nbgcolor(\"light blue\")\n\nhideturtle()\n\ntracer(0, 0)\n\nfor i in range(iter+1):\n    r = pow(i,factor)/iter;\n    \n    if r/maxRad < diskRatio:\n        pencolor(\"black\")\n    else:\n        pencolor(\"yellow\")\n \n    theta = 2*pi*factor*i;\n        \n    up()\n    \n    setposition(x + r*sin(theta), y + r*cos(theta))\n    \n    down()\n       \n    circle(10.0 * i/(1.0*iter))\n    \nupdate()\n\ndone()\n"}
{"id": 383598, "name": "Practical numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse enum <False True>;\nuse ntheory <divisors vecextract>;\nuse List::AllUtils <sum uniq firstidx>;\n\nsub proper_divisors {\n  return 1 if 0 == (my $n = shift);\n  my @d = divisors($n);\n  pop @d;\n  @d\n}\n\nsub powerset_sums { uniq map { sum vecextract(\\@_,$_) } 1..2**@_-1 }\n\nsub is_practical {\n    my($n) = @_;\n    return True  if $n == 1;\n    return False if 0 != $n % 2;\n    ($n-2 == firstidx { $_ == $n-1 } powerset_sums(proper_divisors($n)) ) ? True : False;\n}\n\nmy @pn;\nis_practical($_) and push @pn, $_ for 1..333;\nsay @pn . \" matching numbers:\\n\" . (sprintf \"@{['%4d' x @pn]}\", @pn) =~ s/(.{40})/$1\\n/gr;\nsay '';\nprintf \"%6d is practical? %s\\n\", $_, is_practical($_) ? 'True' : 'False' for 666, 6666, 66666;\n", "target": "from itertools import chain, cycle, accumulate, combinations\nfrom typing import List, Tuple\n\n\n\ndef factors5(n: int) -> List[int]:\n    \n    def prime_powers(n):\n        \n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d + (p,)\n            yield(d)\n        if n > 1: yield((n,))\n\n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r[:-1]\n\n\n\ndef powerset(s: List[int]) -> List[Tuple[int, ...]]:\n    \n    return chain.from_iterable(combinations(s, r) for r in range(1, len(s)+1))\n\n\n\ndef is_practical(x: int) -> bool:\n    \n    if x == 1:\n        return True\n    if x %2:\n        return False  \n    f = factors5(x)\n    ps = powerset(f)\n    found = {y for y in {sum(i) for i in ps}\n             if 1 <= y < x}\n    return len(found) == x - 1\n\n\nif __name__ == '__main__':\n    n = 333\n    p = [x for x in range(1, n + 1) if is_practical(x)]\n    print(f\"There are {len(p)} Practical numbers from 1 to {n}:\")\n    print(' ', str(p[:10])[1:-1], '...', str(p[-10:])[1:-1])\n    x = 666\n    print(f\"\\nSTRETCH GOAL: {x} is {'not ' if not is_practical(x) else ''}Practical.\")\n"}
{"id": 383599, "name": "External sort", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $max = 4; \nmy(@chunk,@tempf);\n\nsub mysort ($$) { return $_[0] <=> $_[1] }\n\nsub store {\n    my($a) = @_;\n    my $f = IO::File->new_tmpfile; \n    print $f sort mysort @$a;\n    seek $f, 0, 0 or warn \"Oops: $!\";\n    push(@tempf, { fh => $f, queued => scalar <$f> } );\n}\n\n\nwhile (<DATA>) {\n    push @chunk, $_;\n    store(\\@chunk), @chunk = () if @chunk == $max;\n}\nstore(\\@chunk) if @chunk;\n\n\nwhile (1) {\n    my($lowest) = (sort { mysort($a->{queued}, $b->{queued}); } grep(defined $_->{queued}, @tempf) )[0];\n    last unless $lowest->{queued};\n    print $lowest->{queued};\n    $lowest->{queued} = $lowest->{fh}->getline();\n}\n\n", "target": "\n\n\n\nimport io\n\ndef sort_large_file(n: int, source: open, sink: open, file_opener = open)->None:\n\n    \n\n    \n    mergers = []\n    while True:\n        text = list(source.read(n))\n        if not len(text):\n            break;\n        text.sort()\n        merge_me = file_opener()\n        merge_me.write(''.join(text))\n        mergers.append(merge_me)\n        merge_me.seek(0)\n\n    \n    stack_tops = [f.read(1) for f in mergers]\n    while stack_tops:\n        c = min(stack_tops)\n        sink.write(c)\n        i = stack_tops.index(c)\n        t = mergers[i].read(1)\n        if t:\n            stack_tops[i] = t\n        else:\n            del stack_tops[i]\n            mergers[i].close()\n            del mergers[i]  \n\ndef main():\n    \n\n    \n    input_file_too_large_for_memory = io.StringIO('678925341')\n\n    \n    t = list(input_file_too_large_for_memory.read())\n    t.sort()\n    expect = ''.join(t)\n    print('expect', expect)\n\n    \n    for memory_size in range(1,12):\n        input_file_too_large_for_memory.seek(0)\n        output_file_too_large_for_memory = io.StringIO()\n        sort_large_file(memory_size, input_file_too_large_for_memory, output_file_too_large_for_memory, io.StringIO)\n        output_file_too_large_for_memory.seek(0)\n        assert(output_file_too_large_for_memory.read() == expect)\n        print('memory size {} passed'.format(memory_size))\n\nif __name__ == '__main__':\n   example = main\n   example()\n"}
{"id": 383600, "name": "Penrose tiling", "source": "Translate Perl to Python: use constant pi => 2 * atan2(1, 0);\n\n\n%rules = (\n    A => '',\n    M => 'OA++PA----NA[-OA----MA]++',\n    N => '+OA--PA[---MA--NA]+',\n    O => '-MA++NA[+++OA++PA]-',\n    P => '--OA++++MA[+PA++++NA]--NA'\n);\n$penrose = '[N]++[N]++[N]++[N]++[N]';\n$penrose =~ s/([AMNOP])/$rules{$1}/eg for 1..4;\n\n\n($x, $y) = (160, 160);\n$theta   = pi/5;\n$r       = 20;\n\nfor (split //, $penrose) {\n    if (/A/) {\n        $line  = sprintf \"<line x1='%.1f' y1='%.1f' \", $x, $y;\n        $line .= sprintf \"x2='%.1f' \", $x += $r * cos($theta);\n        $line .= sprintf \"y2='%.1f' \", $y += $r * sin($theta);\n        $line .= \"style='stroke:rgb(255,165,0)'/>\\n\";\n        $SVG{$line} = 1;\n    } elsif (/\\+/) { $theta += pi/5\n    } elsif (/\\-/) { $theta -= pi/5\n    } elsif (/\\[/) { push @stack, [$x, $y, $theta]\n    } elsif (/\\]/) { ($x, $y, $theta) = @{pop @stack} }\n}\n$svg .= $_ for keys %SVG;\nopen  $fh, '>', 'penrose_tiling.svg';\nprint $fh  qq{<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"350\" width=\"350\"> <rect height=\"100%\" width=\"100%\" style=\"fill:black\" />\\n$svg</svg>};\nclose $fh;\n", "target": "def penrose(depth):\n    print(\t<g id=\"A{d+1}\" transform=\"translate(100, 0) scale(0.6180339887498949)\">\n\t\t<use href=\"\n\t\t<use href=\"\n\t</g>\n\t<g id=\"B{d+1}\">\n\t\t<use href=\"\n\t\t<use href=\"\n\t</g>\t<g id=\"G\">\n\t\t<use href=\"\n\t\t<use href=\"\n\t</g>\n  </defs>\n  <g transform=\"scale(2, 2)\">\n\t<use href=\"\n\t<use href=\"\n\t<use href=\"\n\t<use href=\"\n\t<use href=\"\n  </g>\n</svg>''')\n\npenrose(6)\n"}
{"id": 383601, "name": "Railway circuit", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse experimental 'signatures';\nuse List::Util qw(sum);\nuse ntheory 'todigits';\n\n{\n    package Point;\n    use Class::Struct;\n    struct( x => '$', y => '$',);\n}\n\nuse constant pi => 2 * atan2(1, 0);\nuse enum qw(False True);\n\nmy @twelvesteps = map { Point->new( x => sin(pi * $_/6), y => cos(pi * $_/6) ) } 1 .. 12;\nmy @foursteps   = map { Point->new( x => sin(pi * $_/2), y => cos(pi * $_/2) ) } 1 ..  4;\n\nsub add ($p, $q) { Point->new( x => $p->x + $q->x , y => $p->y + $q->y) }\n\nsub approx_eq ($p, $q) { use constant eps => .0001; abs($p->x - $q->x)<eps and abs($p->y - $q->y)<eps }\n\nsub digits($n, $base, $pad=0) {\n    my @output = reverse todigits($n, $base);\n    push @output, (0) x ($pad - +@output) if $pad > +@output;\n    @output\n}\n\nsub rotate { my($i,@a) = @_; @a[$i .. @a-1, 0 .. $i-1] }\n\nsub circularsymmetries(@c) { map { join ' ', rotate($_, @c) } 0 .. $\n\nsub addsymmetries($infound, @turns) {\n    my @allsym;\n    push @allsym, circularsymmetries(@turns);\n    push @allsym, circularsymmetries(map { -1 * $_ } @turns);\n    $$infound{$_} = True for @allsym;\n    (sort @allsym)[-1]\n}\n\nsub isclosedpath($straight, @turns) {\n    my $start = Point->new(x=> 0, y =>0);\n    return False if sum(@turns) % ($straight ? 4 : 12);\n    my ($angl, $point) = (0, $start);\n    for my $turn (@turns) {\n        $angl  += $turn;\n        $point = add($point, $straight ? $foursteps[$angl % 4] : $twelvesteps[$angl % 12]);\n    }\n    approx_eq($point, $start);\n}\n\nsub allvalidcircuits($N, $doPrint = False, $straight = False) {\n    my ( @found, %infound );\n    say \"\\nFor N of \". $N . ' and ' . ($straight ? 'straight' : 'curved') . ' track:';\n    for my $i (0 .. ($straight ? 3 : 2)**$N - 1) {\n        my @turns = $straight ?\n            map { $_ == 0 ?  0 : ($_ == 1 ? -1 : 1) } digits($i,3,$N) :\n            map { $_ == 0 ? -1 :                 1  } digits($i,2,$N);\n        if (isclosedpath($straight, @turns) && ! exists $infound{join ' ', @turns} ) {\n            my $canon = addsymmetries(\\%infound, @turns);\n            push @found, $canon;\n        }\n    }\n    say join \"\\n\", @found if $doPrint;\n    say \"There are \" . +@found . ' unique valid circuits.';\n    @found\n}\n\nallvalidcircuits($_, True)       for 12, 16, 20;\nallvalidcircuits($_, True, True) for 4, 6, 8;\n", "target": "from itertools import count, islice\nimport numpy as np\nfrom numpy import sin, cos, pi\n\n\nANGDIV = 12\nANG = 2*pi/ANGDIV\n\ndef draw_all(sols):\n    import matplotlib.pyplot as plt\n\n    def draw_track(ax, s):\n        turn, xend, yend = 0, [0], [0]\n\n        for d in s:\n            x0, y0 = xend[-1], yend[-1]\n            a = turn*ANG\n            cs, sn = cos(a), sin(a)\n            ang = a + d*pi/2\n            cx, cy = x0 + cos(ang), y0 + sin(ang)\n\n            da = np.linspace(ang, ang + d*ANG, 10)\n            xs = cx - cos(da)\n            ys = cy - sin(da)\n            ax.plot(xs, ys, 'green' if d == -1 else 'orange')\n\n            xend.append(xs[-1])\n            yend.append(ys[-1])\n            turn += d\n\n        ax.plot(xend, yend, 'k.', markersize=1)\n        ax.set_aspect(1)\n\n    ls = len(sols)\n    if ls == 0: return\n\n    w, h = min((abs(w*2 - h*3) + w*h - ls, w, h)\n        for w, h in ((w, (ls + w - 1)//w)\n            for w in range(1, ls + 1)))[1:]\n\n    fig, ax = plt.subplots(h, w, squeeze=False)\n    for a in ax.ravel(): a.set_axis_off()\n\n    for i, s in enumerate(sols):\n        draw_track(ax[i//w, i%w], s)\n\n    plt.show()\n\n\ndef match_up(this, that, equal_lr, seen):\n    if not this or not that: return\n\n    n = len(this[0][-1])\n    n2 = n*2\n\n    l_lo, l_hi, r_lo, r_hi = 0, 0, 0, 0\n\n    def record(m):\n        for _ in range(n2):\n            seen[m] = True\n            m = (m&1) << (n2 - 1) | (m >> 1)\n\n        if equal_lr:\n            m ^= (1<<n2) - 1\n            for _ in range(n2):\n                seen[m] = True\n                m = (m&1) << (n2 - 1) | (m >> 1)\n\n    l_n, r_n = len(this), len(that)\n    tol = 1e-3\n\n    while l_lo < l_n:\n        while l_hi < l_n and this[l_hi][0] - this[l_lo][0] <= tol:\n            l_hi += 1\n\n        while r_lo < r_n and that[r_lo][0] < this[l_lo][0] - tol:\n            r_lo += 1\n\n        r_hi = r_lo\n        while r_hi < r_n and that[r_hi][0] < this[l_lo][0] + tol:\n            r_hi += 1\n\n        for a in this[l_lo:l_hi]:\n            m_left = a[-2]<<n\n            for b in that[r_lo:r_hi]:\n                if (m := m_left | b[-2]) not in seen:\n                    if np.abs(a[1] + b[2]) < tol:\n                        record(m)\n                        record(int(f'{m:b}'[::-1], base=2))\n                        yield(a[-1] + b[-1])\n\n        l_lo, r_lo = l_hi, r_hi\n\ndef track_combo(left, right):\n    n = (left + right)//2\n    n1 = left + right - n\n\n    alphas = np.exp(1j*ANG*np.arange(ANGDIV))\n    def half_track(m, n):\n        turns = tuple(1 - 2*(m>>i & 1) for i in range(n))\n        rcnt = np.cumsum(turns)%ANGDIV\n        asum = np.sum(alphas[rcnt])\n        want = asum/alphas[rcnt[-1]]\n        return np.abs(asum), asum, want, m, turns\n\n    res = [[] for _ in range(right + 1)]\n    for i in range(1<<n):\n        b = i.bit_count()\n        if b <= right:\n            res[b].append(half_track(i, n))\n\n    for v in res: v.sort()\n    if n1 == n:\n        return res, res\n\n    res1 = [[] for _ in range(right + 1)]\n    for i in range(1<<n1):\n        b = i.bit_count()\n        if b <= right:\n            res1[b].append(half_track(i, n1))\n\n    for v in res: v.sort()\n    return res, res1\n\ndef railway(n):\n    seen = {}\n\n    for l in range(n//2, n + 1):\n        r = n - l\n        if not l >= r: continue\n\n        if (l - r)%ANGDIV == 0:\n            res_l, res_r = track_combo(l, r)\n\n            for i, this in enumerate(res_l):\n                if 2*i < r: continue\n                that = res_r[r - i]\n                for s in match_up(this, that, l == r, seen):\n                    yield s\n\nsols = []\nfor i, s in enumerate(railway(30)):\n    \n    print(i + 1, s)\n    sols.append(s)\n\ndraw_all(sols[:40])\n"}
{"id": 383602, "name": "Print itself", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nopen my $in, '<', $0 or die;\nprint while <$in>;\nclose($in)\n\n\n", "target": "import sys\nwith open(sys.argv[0],'r') as input:\n    for row in input:\n        print(row, end='')\n"}
{"id": 383603, "name": "Count the coins_0-1", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\ncountcoins( 6, [1, 2, 3, 4, 5] );\ncountcoins( 6, [1, 1, 2, 3, 3, 4, 5] );\ncountcoins( 40, [1, 2, 3, 4, 5, 5, 5, 5, 15, 15, 10, 10, 10, 10, 25, 100] );\n\nmy $count;\n\nsub countcoins\n  {\n  my ($want, $coins) = @_;\n  print \"\\nsum $want coins @$coins\\n\";\n  $count = 0;\n  count($want, [], 0, $coins);\n  print \"Number of ways: $count\\n\";\n  }\n\nsub count\n  {\n  my ($want, $used, $sum, $have) = @_;\n  if( $sum == $want ) { $count++ }\n  elsif( $sum > $want or @$have == 0 ) {}\n  else\n    {\n    my ($thiscoin, @rest) = @$have;\n    count( $want, [@$used, $thiscoin], $sum + $thiscoin, \\@rest);\n    count( $want, $used, $sum, \\@rest);\n    }\n  }\n", "target": "from itertools import product, compress\n\nfact = lambda n: n and n*fact(n - 1) or 1\ncombo_count = lambda total, coins, perm:\\\n                    sum(perm and fact(len(x)) or 1\n                        for x in (list(compress(coins, c))\n                                  for c in product(*([(0, 1)]*len(coins))))\n                        if sum(x) == total)\n\ncases = [(6,  [1, 2, 3, 4, 5]),\n         (6,  [1, 1, 2, 3, 3, 4, 5]),\n         (40, [1, 2, 3, 4, 5, 5, 5, 5, 15, 15, 10, 10, 10, 10, 25, 100])]\n\nfor perm in [False, True]:\n    print(f'Order matters: {perm}')\n    for s, c in cases:\n        print(f'{combo_count(s, c, perm):7d} ways for {s:2d} total from coins {c}')\n    print()\n"}
{"id": 383604, "name": "Bifid cipher", "source": "Translate Perl to Python: use v5.36;\nuse builtin <indexed floor>;\nuse experimental qw(builtin for_list);\nuse List::Util 'max';\n\nsub table ($c, @V) { my $t = $c * (my $w = 2 + length max map { length } @V); ( sprintf( ('%'.$w.'s')x@V, @V) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub polybius ($text) {\n    my %p;\n    my $n = floor sqrt length $text;\n    for my($k,$v) (indexed split '', $text) {\n        $p{$v} = join ' ', $k%$n, int $k/$n\n    }\n    %p;\n}\n\nsub encrypt ($text, %P) {\n    my(%I, @c, $encrypted);\n    for my($k,$v) (%P) { $I{$v} = $k }\n    for my ($n,$char) (indexed split '', ($text =~ s/\\s//gr)) {\n        for my($m,$i) (indexed split ' ', $P{$char}) { $c[$m][$n] = $i }\n    }\n    for my($i,$j) ($c[1]->@*, $c[0]->@*) { $encrypted .= $I{\"$j $i\"} }\n    $encrypted\n}\n\nsub decrypt ($text, %P) {\n    my($decrypted, $l, %I, @c) = ('', length($text));\n    for my($k,$v) (%P) { $I{$v} = $k }\n    for (split '', $text) {\n        for my($i,$j) (split ' ', $P{$_}) { unshift @c, $i, $j }\n    }\n    substr $decrypted, 0, 0, $I{ \"$c[$_] $c[$_+$l]\" } for 0 .. $l-1;\n    $decrypted;\n}\n\nfor my($polybius,$message) (\n  join('','A'..'Z') =~ s/J//r,                 'ATTACK AT DAWN',\n  'BGWKZQPNDSIOAXEFCLUMTHYVR',                 'FLEE AT ONCE',\n  join('','_.', 'A'..'Z', 'a'..'z', '0'..'9'), 'The_invasion_will_start_on_the_first_of_January_2023.',\n  ) {\n    my %Ptable = polybius $polybius;\n    say \"\\nUsing polybius:\\n\" . table sqrt length $polybius, split '', $polybius;\n    say 'Message  \u00a0: ' .  $message;\n    say 'Encrypted\u00a0: ' .  (my $encrypted = encrypt $message, %Ptable);\n    say 'Decrypted\u00a0: ' .  decrypt $encrypted, %Ptable;\n}\n", "target": "\nimport math\nimport pprint\nimport string\n\nfrom itertools import chain\nfrom itertools import zip_longest\n\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Tuple\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\ndef group(it: Iterable[T], n: int) -> Iterator[Tuple[T, ...]]:\n    \n    return zip_longest(*[iter(it)] * n)\n\n\nSquare = Tuple[Tuple[str, ...], ...]\n\n\ndef polybius_square(alphabet: str) -> Square:\n    \n    return tuple(group(alphabet, math.ceil(math.sqrt(len(alphabet)))))\n\n\ndef polybius_map(square: Square) -> Dict[str, Tuple[int, int]]:\n    \n    return {\n        square[i][j]: (i + 1, j + 1)\n        for i in range(len(square))\n        for j in range(len(square))\n    }\n\n\ndef encrypt(message: str, square: Square) -> str:\n    \n    _map = polybius_map(square)\n    return \"\".join(\n        square[x - 1][y - 1]\n        for x, y in group(\n            chain.from_iterable(zip(*(_map[c] for c in message if c in _map))),\n            2,\n        )\n    )\n\n\ndef decrypt(message: str, square: Square) -> str:\n    \n    _map = polybius_map(square)\n    return \"\".join(\n        square[x - 1][y - 1]\n        for x, y in zip(\n            *group(\n                chain.from_iterable((_map[c] for c in message if c in _map)),\n                len(message),\n            )\n        )\n    )\n\n\ndef normalize(message: str) -> str:\n    \n    return message.upper().replace(\"J\", \"I\")\n\n\nTYPICAL_POLYBIUS_SQUARE = polybius_square(\n    alphabet=\"\".join(c for c in string.ascii_uppercase if c != \"J\")\n)\n\n\nEXAMPLE_POLYBIUS_SQUARE = polybius_square(\n    alphabet=\"BGWKZQPNDSIOAXEFCLUMTHYVR\",\n)\n\n\ndef main() -> None:\n    test_cases = [\n        (\"ATTACKATDAWN\", TYPICAL_POLYBIUS_SQUARE),  \n        (\"FLEEATONCE\", EXAMPLE_POLYBIUS_SQUARE),  \n        (\"FLEEATONCE\", TYPICAL_POLYBIUS_SQUARE),  \n        (\n            normalize(\"The invasion will start on the first of January\"),\n            polybius_square(alphabet=\"PLAYFIREXMBCDGHKNOQSTUVWZ\"),\n        ),\n        (\n            \"The invasion will start on the first of January\".upper(),\n            polybius_square(alphabet=string.ascii_uppercase + string.digits),\n        ),\n    ]\n\n    for message, square in test_cases:\n        pprint.pprint(square)\n        print(\"Message \u00a0:\", message)\n        print(\"Encrypted:\", encrypt(message, square))\n        print(\"Decrypted:\", decrypt(encrypt(message, square), square))\n        print(\"\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 383605, "name": "Bifid cipher", "source": "Translate Perl to Python: use v5.36;\nuse builtin <indexed floor>;\nuse experimental qw(builtin for_list);\nuse List::Util 'max';\n\nsub table ($c, @V) { my $t = $c * (my $w = 2 + length max map { length } @V); ( sprintf( ('%'.$w.'s')x@V, @V) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub polybius ($text) {\n    my %p;\n    my $n = floor sqrt length $text;\n    for my($k,$v) (indexed split '', $text) {\n        $p{$v} = join ' ', $k%$n, int $k/$n\n    }\n    %p;\n}\n\nsub encrypt ($text, %P) {\n    my(%I, @c, $encrypted);\n    for my($k,$v) (%P) { $I{$v} = $k }\n    for my ($n,$char) (indexed split '', ($text =~ s/\\s//gr)) {\n        for my($m,$i) (indexed split ' ', $P{$char}) { $c[$m][$n] = $i }\n    }\n    for my($i,$j) ($c[1]->@*, $c[0]->@*) { $encrypted .= $I{\"$j $i\"} }\n    $encrypted\n}\n\nsub decrypt ($text, %P) {\n    my($decrypted, $l, %I, @c) = ('', length($text));\n    for my($k,$v) (%P) { $I{$v} = $k }\n    for (split '', $text) {\n        for my($i,$j) (split ' ', $P{$_}) { unshift @c, $i, $j }\n    }\n    substr $decrypted, 0, 0, $I{ \"$c[$_] $c[$_+$l]\" } for 0 .. $l-1;\n    $decrypted;\n}\n\nfor my($polybius,$message) (\n  join('','A'..'Z') =~ s/J//r,                 'ATTACK AT DAWN',\n  'BGWKZQPNDSIOAXEFCLUMTHYVR',                 'FLEE AT ONCE',\n  join('','_.', 'A'..'Z', 'a'..'z', '0'..'9'), 'The_invasion_will_start_on_the_first_of_January_2023.',\n  ) {\n    my %Ptable = polybius $polybius;\n    say \"\\nUsing polybius:\\n\" . table sqrt length $polybius, split '', $polybius;\n    say 'Message  \u00a0: ' .  $message;\n    say 'Encrypted\u00a0: ' .  (my $encrypted = encrypt $message, %Ptable);\n    say 'Decrypted\u00a0: ' .  decrypt $encrypted, %Ptable;\n}\n", "target": "\nimport math\nimport pprint\nimport string\n\nfrom itertools import chain\nfrom itertools import zip_longest\n\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import Iterator\nfrom typing import Tuple\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\ndef group(it: Iterable[T], n: int) -> Iterator[Tuple[T, ...]]:\n    \n    return zip_longest(*[iter(it)] * n)\n\n\nSquare = Tuple[Tuple[str, ...], ...]\n\n\ndef polybius_square(alphabet: str) -> Square:\n    \n    return tuple(group(alphabet, math.ceil(math.sqrt(len(alphabet)))))\n\n\ndef polybius_map(square: Square) -> Dict[str, Tuple[int, int]]:\n    \n    return {\n        square[i][j]: (i + 1, j + 1)\n        for i in range(len(square))\n        for j in range(len(square))\n    }\n\n\ndef encrypt(message: str, square: Square) -> str:\n    \n    _map = polybius_map(square)\n    return \"\".join(\n        square[x - 1][y - 1]\n        for x, y in group(\n            chain.from_iterable(zip(*(_map[c] for c in message if c in _map))),\n            2,\n        )\n    )\n\n\ndef decrypt(message: str, square: Square) -> str:\n    \n    _map = polybius_map(square)\n    return \"\".join(\n        square[x - 1][y - 1]\n        for x, y in zip(\n            *group(\n                chain.from_iterable((_map[c] for c in message if c in _map)),\n                len(message),\n            )\n        )\n    )\n\n\ndef normalize(message: str) -> str:\n    \n    return message.upper().replace(\"J\", \"I\")\n\n\nTYPICAL_POLYBIUS_SQUARE = polybius_square(\n    alphabet=\"\".join(c for c in string.ascii_uppercase if c != \"J\")\n)\n\n\nEXAMPLE_POLYBIUS_SQUARE = polybius_square(\n    alphabet=\"BGWKZQPNDSIOAXEFCLUMTHYVR\",\n)\n\n\ndef main() -> None:\n    test_cases = [\n        (\"ATTACKATDAWN\", TYPICAL_POLYBIUS_SQUARE),  \n        (\"FLEEATONCE\", EXAMPLE_POLYBIUS_SQUARE),  \n        (\"FLEEATONCE\", TYPICAL_POLYBIUS_SQUARE),  \n        (\n            normalize(\"The invasion will start on the first of January\"),\n            polybius_square(alphabet=\"PLAYFIREXMBCDGHKNOQSTUVWZ\"),\n        ),\n        (\n            \"The invasion will start on the first of January\".upper(),\n            polybius_square(alphabet=string.ascii_uppercase + string.digits),\n        ),\n    ]\n\n    for message, square in test_cases:\n        pprint.pprint(square)\n        print(\"Message \u00a0:\", message)\n        print(\"Encrypted:\", encrypt(message, square))\n        print(\"Decrypted:\", decrypt(encrypt(message, square), square))\n        print(\"\")\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 383606, "name": "Marching squares", "source": "Translate Perl to Python: use v5.36;\nno warnings 'experimental::for_list';\nuse List::Util 'any';\nuse enum <E N W S>;\n\nsub X ($a,$b) { my @c; for my $aa (0..$a) { for my $bb (0..$b) { push @c, $aa, $bb } } @c }\n\nsub identify_perimeter(@data) {\n    for my ($x,$y) (X $\n        next unless $data[$y][$x] and $data[$y][$x] != 0;\n        my ($path,$cx,$cy,$d,$p) = ('', $x, $y);\n        do {\n            my $mask;\n            for my($dx,$dy,$b) (0,0,1, 1,0,2, 0,1,4, 1,1,8) {\n                my ($mx, $my) = ($cx+$dx, $cy+$dy);\n                $mask += $b if $mx>1 and $my>1 and $data[$my-1][$mx-1] != 0\n            }\n\n            $d = N if any { $mask == $_ } (1, 5,13);\n            $d = E if any { $mask == $_ } (2, 3, 7);\n            $d = W if any { $mask == $_ } (4,12,14);\n            $d = S if any { $mask == $_ } (8,10,11);\n            $d = $p == N ? W : E if $mask == 6;\n            $d = $p == E ? N : S if $mask == 9;\n\n            $path .= $p = (<E N W S>)[$d];\n            $cx += (1, 0,-1,0)[$d];\n            $cy += (0,-1, 0,1)[$d];\n        } until $cx == $x and $cy == $y;\n        return $x, -$y, $path\n    }\n    exit 'That did not work out...';\n}\n\nmy @M = ([0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0],\n         [0, 0, 1, 1, 0],\n         [0, 0, 1, 1, 0],\n         [0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0]);\n\nprintf \"X: %d, Y: %d, Path: %s\\n\", identify_perimeter(@M);\n", "target": "from numpy import array, round\nfrom skimage import measure\n\nexample = array([\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 0],\n    [0, 0, 1, 1, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0]\n])\n\n\ncontours = round(measure.find_contours(example, 0.1))[0]\nprint('[', ', '.join([str((p[1], 5 - p[0])) for p in contours]), ']')\n"}
{"id": 383607, "name": "Marching squares", "source": "Translate Perl to Python: use v5.36;\nno warnings 'experimental::for_list';\nuse List::Util 'any';\nuse enum <E N W S>;\n\nsub X ($a,$b) { my @c; for my $aa (0..$a) { for my $bb (0..$b) { push @c, $aa, $bb } } @c }\n\nsub identify_perimeter(@data) {\n    for my ($x,$y) (X $\n        next unless $data[$y][$x] and $data[$y][$x] != 0;\n        my ($path,$cx,$cy,$d,$p) = ('', $x, $y);\n        do {\n            my $mask;\n            for my($dx,$dy,$b) (0,0,1, 1,0,2, 0,1,4, 1,1,8) {\n                my ($mx, $my) = ($cx+$dx, $cy+$dy);\n                $mask += $b if $mx>1 and $my>1 and $data[$my-1][$mx-1] != 0\n            }\n\n            $d = N if any { $mask == $_ } (1, 5,13);\n            $d = E if any { $mask == $_ } (2, 3, 7);\n            $d = W if any { $mask == $_ } (4,12,14);\n            $d = S if any { $mask == $_ } (8,10,11);\n            $d = $p == N ? W : E if $mask == 6;\n            $d = $p == E ? N : S if $mask == 9;\n\n            $path .= $p = (<E N W S>)[$d];\n            $cx += (1, 0,-1,0)[$d];\n            $cy += (0,-1, 0,1)[$d];\n        } until $cx == $x and $cy == $y;\n        return $x, -$y, $path\n    }\n    exit 'That did not work out...';\n}\n\nmy @M = ([0, 0, 0, 0, 0],\n         [0, 0, 0, 0, 0],\n         [0, 0, 1, 1, 0],\n         [0, 0, 1, 1, 0],\n         [0, 0, 0, 1, 0],\n         [0, 0, 0, 0, 0]);\n\nprintf \"X: %d, Y: %d, Path: %s\\n\", identify_perimeter(@M);\n", "target": "from numpy import array, round\nfrom skimage import measure\n\nexample = array([\n    [0, 0, 0, 0, 0],\n    [0, 0, 0, 0, 0],\n    [0, 0, 1, 1, 0],\n    [0, 0, 1, 1, 0],\n    [0, 0, 0, 1, 0],\n    [0, 0, 0, 0, 0]\n])\n\n\ncontours = round(measure.find_contours(example, 0.1))[0]\nprint('[', ', '.join([str((p[1], 5 - p[0])) for p in contours]), ']')\n"}
{"id": 383608, "name": "Babylonian spiral", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say state>;\nuse constant TAU => 2 * 2 * atan2(1, 0);\n\nsub B_spiral {\n    my($nsteps) = @_;\n    my @squares = map $_**2, 0..$nsteps+1;\n    my @dxys = ([0, 0], [0, 1]);\n    my $dsq  = 1;\n\n    for (1 .. $nsteps-2) {\n        my ($x,$y) = @{$dxys[-1]};\n        our $theta = atan2 $y, $x;\n        my @candidates;\n\n        until (@candidates) {\n            $dsq++;\n            for my $i (0..$\n                my $a = $squares[$i];\n                next if $a > $dsq/2;\n                for my $j ( reverse 0 .. 1 + int sqrt $dsq ) {\n                    my $b = $squares[$j];\n                    next if ($a + $b) < $dsq;\n                    if ($dsq == $a + $b) {\n                        push @candidates, ( [$i, $j], [-$i, $j], [$i, -$j], [-$i, -$j],\n                                            [$j, $i], [-$j, $i], [$j, -$i], [-$j, -$i] );\n                    }\n                }\n            }\n        }\n\n        sub comparer {\n            my $i = ($theta - atan2 $_[1], $_[0]);\n            my $z = $i - int($i / TAU) * TAU;\n            $z < 0 ? TAU + $z : $z;\n        }\n\n        push @dxys, (sort { comparer(@$b) < comparer(@$a) } @candidates)[0];\n    }\n\n    map { state($x,$y); $x += $$_[0]; $y += $$_[1]; [$x,$y] } @dxys;\n}\n\nmy @points = map { sprintf \"(%3d,%4d)\", @$_ } B_spiral(40);\nsay \"The first 40 Babylonian spiral points are:\\n\" .\n    join(' ', @points) =~ s/.{1,88}\\K/\\n/gr;\n", "target": "\n\nfrom itertools import accumulate\nfrom math import isqrt, atan2, tau\nfrom matplotlib.pyplot import axis, plot, show\n\n\nsquare_cache = []\n\ndef babylonian_spiral(nsteps):\n    \n    if len(square_cache) <= nsteps:\n        square_cache.extend([x * x for x in range(len(square_cache), nsteps)])\n    xydeltas = [(0, 0), (0, 1)]\n    \u03b4squared = 1\n    for _ in range(nsteps - 2):\n        x, y = xydeltas[-1]\n        \u03b8 = atan2(y, x)\n        candidates = []\n        while not candidates:\n            \u03b4squared += 1\n            for i, a in enumerate(square_cache):\n                if a > \u03b4squared // 2:\n                    break\n                for j in range(isqrt(\u03b4squared) + 1, 0, -1):\n                    b = square_cache[j]\n                    if a + b < \u03b4squared:\n                        break\n                    if a + b == \u03b4squared:\n                        candidates.extend([(i, j), (-i, j), (i, -j), (-i, -j), (j, i), (-j, i),\n                           (j, -i), (-j, -i)])\n\n        p = min(candidates, key=lambda d: (\u03b8 - atan2(d[1], d[0])) % tau)\n        xydeltas.append(p)\n\n    return list(accumulate(xydeltas, lambda a, b: (a[0] + b[0], a[1] + b[1])))\n\n\npoints10000 = babylonian_spiral(10000)\nprint(\"The first 40 Babylonian spiral points are:\")\nfor i, p in enumerate(points10000[:40]):\n     print(str(p).ljust(10), end = '\\n' if (i + 1) % 10 == 0 else '')\n\n\nplot(*zip(*points10000), color=\"navy\", linewidth=0.2)\naxis('scaled')\nshow()\n"}
{"id": 383609, "name": "Discrete Fourier transform", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse feature 'say';\n\nuse Math::Complex;\nuse constant  PI => 4 * atan2(1, 1);\nuse constant ESP =>  1e10; \nuse constant EPS => 1e-10; \n\nsub dft {\n   my $n = scalar ( my @in = @_ );\n   return map {\n      my $s=0;\n      for my $k (0 .. $n-1) { $s += $in[$k] * exp(-2*i * PI * $k * $_ / $n) }\n      $_ = $s;\n   } (0 .. $n-1);\n}\n\nsub idft {\n   my $n = scalar ( my @in = @_ );\n   return map {\n      my $s=0;\n      for my $k (0 .. $n-1) { $s += $in[$k] * exp(2*i * PI * $k * $_ / $n) }\n      my $t = $s/$n;\n      $_ = abs(Im $t) < EPS ? Re($t) : $t \n   } (0 .. $n-1);\n}\n\nsay 'Original sequence                 \u00a0: ', join ', ', my @series = ( 2, 3, 5, 7, 11 );\nsay 'Discrete Fourier transform        \u00a0: ', join ', ', my @dft = dft @series;\nsay 'Inverse Discrete Fourier Transform\u00a0: ', join ', ', idft @dft;\n", "target": "\nimport cmath\n\n\ndef dft( x ):\n    \n    N                           = len( x )\n    result                      = []\n    for k in range( N ):\n        r                       = 0\n        for n in range( N ):\n            t                   = -2j * cmath.pi * k * n / N\n            r                  += x[n] * cmath.exp( t )\n        result.append( r )\n    return result\n\n\ndef idft( y ):\n    \n    N                           = len( y )\n    result                      = []\n    for n in range( N ):\n        r                       = 0\n        for k in range( N ):\n            t                   = 2j * cmath.pi * k * n / N\n            r                  += y[k] * cmath.exp( t )\n        r                      /= N+0j\n        result.append( r )\n    return result\n\n\nif __name__ == \"__main__\":\n    x                           = [ 2, 3, 5, 7, 11 ]\n    print( \"vals:   \" + ' '.join( f\"{f:11.2f}\" for f in x ))\n    y                           = dft( x )\n    print( \"DFT:    \" + ' '.join( f\"{f:11.2f}\" for f in y ))\n    z                           = idft( y )\n    print( \"inverse:\" + ' '.join( f\"{f:11.2f}\" for f in z ))\n    print( \" - real:\" + ' '.join( f\"{f.real:11.2f}\" for f in z ))\n\n    N                           = 8\n    print( f\"Complex signals, 1-4 cycles in {N} samples; energy into successive DFT bins\" )\n    for rot in (0, 1, 2, 3, -4, -3, -2, -1):    \n        if rot > N/2:\n            print( \"Signal change frequency exceeds sample rate and will result in artifacts\")\n        sig                     = [\n            \n            cmath.rect(\n                1, cmath.pi*2*rot/N*i\n            )\n            for i in range( N )\n        ]\n        print( f\"{rot:2} cycle\" + ' '.join( f\"{f:11.2f}\" for f in sig ))\n        dft_sig                 = dft( sig )\n        print( f\"  DFT:  \" + ' '.join( f\"{f:11.2f}\" for f in dft_sig ))\n        print( f\"   ABS: \" + ' '.join( f\"{abs(f):11.2f}\" for f in dft_sig ))\n"}
{"id": 383610, "name": "Rosetta Code_Rank languages by number of users", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse JSON;\nuse URI::Escape;\nuse LWP::UserAgent;\n\nmy $client = LWP::UserAgent->new;\n$client->agent(\"Rosettacode Perl task solver\");\nmy $url = 'http://rosettacode.org/mw';\nmy $minimum = 100;\n\nsub uri_query_string {\n    my(%fields) = @_;\n    'action=query&format=json&formatversion=2&' .\n    join '&', map { $_ . '=' . uri_escape($fields{$_}) } keys %fields\n}\n\nsub mediawiki_query {\n    my($site, $type, %query) = @_;\n    my $url = \"$site/api.php?\" . uri_query_string(%query);\n    my %languages = ();\n\n    my $req = HTTP::Request->new( GET => $url );\n    my $response = $client->request($req);\n    $response->is_success or die \"Failed to GET '$url': \", $response->status_line;\n    my $data = decode_json($response->content);\n    for my $row ( @{${$data}{query}{pages}} ) {\n        next unless defined $$row{categoryinfo} && $$row{title} =~ /User/;\n        my($title) = $$row{title} =~ /Category:(.*?) User/;\n        my($count) = $$row{categoryinfo}{pages};\n        $languages{$title} = $count;\n    }\n    %languages;\n}\n\nmy %table = mediawiki_query(\n    $url, 'pages',\n    ( generator   => 'categorymembers',\n      gcmtitle    => 'Category:Language users',\n      gcmlimit    => '999',\n      prop        => 'categoryinfo',\n      rawcontinue => '',\n    )\n);\n\nfor my $k (sort { $table{$b} <=> $table{$a} } keys %table) {\n    printf \"%4d %s\\n\", $table{$k}, $k if $table{$k} > $minimum;\n}\n", "target": "\n\nimport requests\n\n\nURL = \"http://rosettacode.org/mw/api.php\"\n\n\nPARAMS = {\n    \"action\": \"query\",\n    \"format\": \"json\",\n    \"formatversion\": 2,\n    \"generator\": \"categorymembers\",\n    \"gcmtitle\": \"Category:Language users\",\n    \"gcmlimit\": 500,\n    \"prop\": \"categoryinfo\",\n}\n\n\ndef fetch_data():\n    counts = {}\n    continue_ = {\"continue\": \"\"}\n\n    \n    \n    while continue_:\n        resp = requests.get(URL, params={**PARAMS, **continue_})\n        resp.raise_for_status()\n\n        data = resp.json()\n\n        \n        counts.update(\n            {\n                p[\"title\"]: p.get(\"categoryinfo\", {}).get(\"size\", 0)\n                for p in data[\"query\"][\"pages\"]\n            }\n        )\n\n        continue_ = data.get(\"continue\", {})\n\n    return counts\n\n\nif __name__ == \"__main__\":\n    \n    counts = fetch_data()\n\n    \n    at_least_100 = [(lang, count) for lang, count in counts.items() if count >= 100]\n\n    \n    top_languages = sorted(at_least_100, key=lambda x: x[1], reverse=True)\n\n    \n    for i, lang in enumerate(top_languages):\n        print(f\"{i+1:<5}{lang[0][9:][:-5]:<20}{lang[1]}\")\n"}
{"id": 383611, "name": "Rosetta Code_Rank languages by number of users", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse JSON;\nuse URI::Escape;\nuse LWP::UserAgent;\n\nmy $client = LWP::UserAgent->new;\n$client->agent(\"Rosettacode Perl task solver\");\nmy $url = 'http://rosettacode.org/mw';\nmy $minimum = 100;\n\nsub uri_query_string {\n    my(%fields) = @_;\n    'action=query&format=json&formatversion=2&' .\n    join '&', map { $_ . '=' . uri_escape($fields{$_}) } keys %fields\n}\n\nsub mediawiki_query {\n    my($site, $type, %query) = @_;\n    my $url = \"$site/api.php?\" . uri_query_string(%query);\n    my %languages = ();\n\n    my $req = HTTP::Request->new( GET => $url );\n    my $response = $client->request($req);\n    $response->is_success or die \"Failed to GET '$url': \", $response->status_line;\n    my $data = decode_json($response->content);\n    for my $row ( @{${$data}{query}{pages}} ) {\n        next unless defined $$row{categoryinfo} && $$row{title} =~ /User/;\n        my($title) = $$row{title} =~ /Category:(.*?) User/;\n        my($count) = $$row{categoryinfo}{pages};\n        $languages{$title} = $count;\n    }\n    %languages;\n}\n\nmy %table = mediawiki_query(\n    $url, 'pages',\n    ( generator   => 'categorymembers',\n      gcmtitle    => 'Category:Language users',\n      gcmlimit    => '999',\n      prop        => 'categoryinfo',\n      rawcontinue => '',\n    )\n);\n\nfor my $k (sort { $table{$b} <=> $table{$a} } keys %table) {\n    printf \"%4d %s\\n\", $table{$k}, $k if $table{$k} > $minimum;\n}\n", "target": "\n\nimport requests\n\n\nURL = \"http://rosettacode.org/mw/api.php\"\n\n\nPARAMS = {\n    \"action\": \"query\",\n    \"format\": \"json\",\n    \"formatversion\": 2,\n    \"generator\": \"categorymembers\",\n    \"gcmtitle\": \"Category:Language users\",\n    \"gcmlimit\": 500,\n    \"prop\": \"categoryinfo\",\n}\n\n\ndef fetch_data():\n    counts = {}\n    continue_ = {\"continue\": \"\"}\n\n    \n    \n    while continue_:\n        resp = requests.get(URL, params={**PARAMS, **continue_})\n        resp.raise_for_status()\n\n        data = resp.json()\n\n        \n        counts.update(\n            {\n                p[\"title\"]: p.get(\"categoryinfo\", {}).get(\"size\", 0)\n                for p in data[\"query\"][\"pages\"]\n            }\n        )\n\n        continue_ = data.get(\"continue\", {})\n\n    return counts\n\n\nif __name__ == \"__main__\":\n    \n    counts = fetch_data()\n\n    \n    at_least_100 = [(lang, count) for lang, count in counts.items() if count >= 100]\n\n    \n    top_languages = sorted(at_least_100, key=lambda x: x[1], reverse=True)\n\n    \n    for i, lang in enumerate(top_languages):\n        print(f\"{i+1:<5}{lang[0][9:][:-5]:<20}{lang[1]}\")\n"}
{"id": 383612, "name": "HTTPS_Client-authenticated", "source": "Translate Perl to Python: \nuse 5.018_002;\nuse warnings;\nuse LWP;\n\nour $VERSION = 1.000_000;\n\nmy $ua = LWP::UserAgent->new(\n    ssl_opts => {\n        SSL_cert_file   => 'certificate.pem',\n        SSL_key_file    => 'key.pem',\n        verify_hostname => 1,\n    }\n);\nmy $req = HTTP::Request->new( GET => 'https://www.example.com' );\nmy $res = $ua->request($req);\nif ( $res->is_success ) {\n    say $res->content;\n}\nelse {\n    say $res->status_line;\n}\n", "target": "import httplib\n\nconnection = httplib.HTTPSConnection('www.example.com',cert_file='myCert.PEM')\nconnection.request('GET','/index.html')\nresponse = connection.getresponse()\ndata = response.read()\n"}
{"id": 383613, "name": "SQL-based authentication", "source": "Translate Perl to Python: use DBI;\n\n \nsub connect_db {\n    my ($dbname, $host, $user, $pass) = @_;\n    my $db = DBI->connect(\"dbi:mysql:$dbname:$host\", $user, $pass)\n        or die $DBI::errstr;\n    $db->{RaiseError} = 1;\n    $db\n}\n\n \n \nsub create_user {\n    my ($db, $user, $pass) = @_;\n    my $salt = pack \"C*\", map {int rand 256} 1..16;\n    $db->do(\"INSERT IGNORE INTO users (username, pass_salt, pass_md5)\n        VALUES (?,\u00a0?, unhex(md5(concat(pass_salt,\u00a0?))))\",\n        undef, $user, $salt, $pass)\n      and $db->{mysql_insertid} or undef\n}\n\n \nsub authenticate_user {\n    my ($db, $user, $pass) = @_;\n    my $userid = $db->selectrow_array(\"SELECT userid FROM users WHERE\n        username=? AND pass_md5=unhex(md5(concat(pass_salt,\u00a0?)))\",\n        undef, $user, $pass);\n    $userid\n}\n", "target": "import mysql.connector \nimport hashlib\n \nimport sys\t \nimport random\t \n \nDB_HOST = \"localhost\"\t \nDB_USER = \"devel\" \nDB_PASS = \"devel\"\t \nDB_NAME = \"test\"\t \n \ndef connect_db():\t \n    \t \n    try:\t \n        return mysql.connector.connect(host=DB_HOST, user=DB_USER, passwd=DB_PASS, db=DB_NAME)\t \n    except:\t \n        return False\t \n \ndef create_user(username, passwd):\t \n    \t \n    db = connect_db()\t \n    if not db:\t \n        print \"Can't connect MySQL!\"\n        return None\n \n    cursor = db.cursor()\t \n \n    salt = randomValue(16)\t \t \n    passwd_md5 = hashlib.md5(salt+passwd).hexdigest()\t \n \n    \n    try:\t \n        cursor.execute(\"INSERT INTO users (`username`, `pass_salt`, `pass_md5`) VALUES (%s, %s, %s)\", (username, salt, passwd_md5)) \n        cursor.execute(\"SELECT userid FROM users WHERE username=%s\", (username,) ) \n        id = cursor.fetchone()\n        db.commit()\n        cursor.close()\n        db.close()\n        return id[0]\t \n    except:\t \n        print 'Username was already taken. Please select another'\t \n        return None\n \ndef authenticate_user(username, passwd):\t \n    db = connect_db()\t \n    if not db:\t \n        print \"Can't connect MySQL!\"\n        return False\n \n    cursor = db.cursor()\t \n \n    cursor.execute(\"SELECT pass_salt, pass_md5 FROM users WHERE username=%s\", (username,))\n\n    row = cursor.fetchone()\n    cursor.close()\n    db.close()\n    if row is None:     \n        return False\n    salt = row[0]\n    correct_md5 = row[1]\n    tried_md5 = hashlib.md5(salt+passwd).hexdigest()\n    return correct_md5 == tried_md5\n \ndef randomValue(length):\t \n    \t \n    salt_chars = 'abcdefghijklmnopqrstuvwxyz0123456789'\n\n    return ''.join(random.choice(salt_chars) for x in range(length))\n \nif __name__ == '__main__':\t \n    user = randomValue(10)\n    passwd = randomValue(16)\t \n \n    new_user_id = create_user(user, passwd)\n    if new_user_id is None:\n        print 'Failed to create user %s' % user\n        sys.exit(1)\n    auth = authenticate_user(user, passwd)\t \n    if auth:\t \n        print 'User %s authenticated successfully' % user\t \n    else:\t \n        print 'User %s failed' % user\n"}
{"id": 383614, "name": "Bitmap_PPM conversion through a pipe", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse Imager;\nuse Imager::Test 'test_image_raw'; \n\nmy $img = test_image_raw();\nmy $IO  = Imager::io_new_bufchain();\nImager::i_writeppm_wiol($img, $IO) or die;\nmy $raw = Imager::io_slurp($IO) or die;\n\nopen my $fh, '|-', '/usr/local/bin/convert - -compress none output.jpg' or die;\nbinmode $fh;\nsyswrite $fh, $raw or die;\nclose $fh;\n", "target": "\n\nfrom PIL import Image\n\nim = Image.open(\"boxes_1.ppm\")\nim.save(\"boxes_1.jpg\")\n"}
{"id": 383615, "name": "Tarjan", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say state current_sub>;\nuse List::Util qw(min);\n\nsub tarjan {\n    my (%k) = @_;\n    my (%onstack, %index, %lowlink, @stack, @connected);\n\n    my sub strong_connect {\n        my ($vertex, $i) = @_;\n        $index{$vertex}   = $i;\n        $lowlink{$vertex} = $i + 1;\n        $onstack{$vertex} = 1;\n        push @stack, $vertex;\n        for my $connection (@{$k{$vertex}}) {\n            if (not defined $index{$connection}) {\n                __SUB__->($connection, $i + 1);\n                $lowlink{$vertex} = min($lowlink{$connection}, $lowlink{$vertex});\n            }\n            elsif ($onstack{$connection}) {\n                $lowlink{$vertex} = min($index{$connection}, $lowlink{$vertex});\n            }\n        }\n        if ($lowlink{$vertex} eq $index{$vertex}) {\n            my @node;\n            do {\n                push @node, pop @stack;\n                $onstack{$node[-1]} = 0;\n            } while $node[-1] ne $vertex;\n            push @connected, [@node];\n        }\n    }\n\n    for (sort keys %k) {\n        strong_connect($_, 0) unless $index{$_};\n    }\n    @connected;\n}\n\nmy %test1 = (\n             0 => [1],\n             1 => [2],\n             2 => [0],\n             3 => [1, 2, 4],\n             4 => [3, 5],\n             5 => [2, 6],\n             6 => [5],\n             7 => [4, 6, 7]\n            );\n\nmy %test2 = (\n             'Andy' => ['Bart'],\n             'Bart' => ['Carl'],\n             'Carl' => ['Andy'],\n             'Dave' => [qw<Bart Carl Earl>],\n             'Earl' => [qw<Dave Fred>],\n             'Fred' => [qw<Carl Gary>],\n             'Gary' => ['Fred'],\n             'Hank' => [qw<Earl Gary Hank>]\n            );\n\nprint \"Strongly connected components:\\n\";\nprint join(', ', sort @$_) . \"\\n\" for tarjan(%test1);\nprint \"\\nStrongly connected components:\\n\";\nprint join(', ', sort @$_) . \"\\n\" for tarjan(%test2);\n", "target": "from collections import defaultdict\n\ndef from_edges(edges):\n    \n\n    class Node:\n        def __init__(self):\n            \n            \n            \n            \n            self.root = None\n            self.succ = []\n\n    nodes = defaultdict(Node)\n    for v,w in edges:\n        nodes[v].succ.append(nodes[w])\n\n    for i,v in nodes.items(): \n        v.id = i\n\n    return nodes.values()\n\ndef trajan(V):\n    def strongconnect(v, S):\n        v.root = pos = len(S)\n        S.append(v)\n\n        for w in v.succ:\n            if w.root is None:  \n                yield from strongconnect(w, S)\n\n            if w.root >= 0:  \n                v.root = min(v.root, w.root)\n\n        if v.root == pos:  \n            res, S[pos:] = S[pos:], []\n            for w in res:\n                w.root = -1\n            yield [r.id for r in res]\n\n    for v in V:\n        if v.root is None:\n            yield from strongconnect(v, [])\n\n\ntables = [  \n            [(1,2), (3,1), (3,6), (6,7), (7,6), (2,3), (4,2),\n             (4,3), (4,5), (5,6), (5,4), (8,5), (8,7), (8,6)],\n\n            \n            [('A', 'B'), ('B', 'C'), ('C', 'A'), ('A', 'Other')]]\n\nfor table in (tables):\n    for g in trajan(from_edges(table)):\n        print(g)\n    print()\n"}
{"id": 383616, "name": "Powerful numbers", "source": "Translate Perl to Python: use 5.020;\nuse ntheory qw(is_square_free);\nuse experimental qw(signatures);\nuse Math::AnyNum qw(:overload idiv iroot ipow is_coprime);\n\nsub powerful_numbers ($n, $k = 2) {\n\n    my @powerful;\n\n    sub ($m, $r) {\n        if ($r < $k) {\n            push @powerful, $m;\n            return;\n        }\n        for my $v (1 .. iroot(idiv($n, $m), $r)) {\n            if ($r > $k) {\n                is_square_free($v) || next;\n                is_coprime($m, $v) || next;\n            }\n            __SUB__->($m * ipow($v, $r), $r - 1);\n        }\n    }->(1, 2*$k - 1);\n\n    sort { $a <=> $b } @powerful;\n}\n\nforeach my $k (2 .. 10) {\n    my @a = powerful_numbers(10**$k, $k);\n    my $h = join(', ', @a[0..4]);\n    my $t = join(', ', @a[$\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", $k, scalar(@a), $h, $t);\n}\n", "target": "from primesieve import primes \nimport math\n\ndef primepowers(k, upper_bound):\n    ub = int(math.pow(upper_bound, 1/k) + .5)\n    res = [(1,)]\n\n    for p in primes(ub):\n        a = [p**k]\n        u = upper_bound // a[-1]\n        while u >= p:\n            a.append(a[-1]*p)\n            u //= p\n        res.append(tuple(a))\n\n    return res\n\ndef kpowerful(k, upper_bound, count_only=True):\n    ps = primepowers(k, upper_bound)\n\n    def accu(i, ub):\n        c = 0 if count_only else [] \n        for p in ps[i]:\n            u = ub//p\n            if not u: break\n\n            c += 1 if count_only else [p]\n\n            for j in range(i + 1, len(ps)):\n                if u < ps[j][0]:\n                    break\n                c += accu(j, u) if count_only else [p*x for x in accu(j, u)]\n        return c\n\n    res = accu(0, upper_bound)\n    return res if count_only else sorted(res)\n\nfor k in range(2, 11):\n    res = kpowerful(k, 10**k, count_only=False)\n    print(f'{len(res)} {k}-powerfuls up to 10^{k}:',\n        ' '.join(str(x) for x in res[:5]),\n        '...',\n        ' '.join(str(x) for x in res[-5:])\n        )\n\nfor k in range(2, 11):\n    res = [kpowerful(k, 10**n) for n in range(k+10)]\n    print(f'{k}-powerful up to 10^{k+10}:',\n        ' '.join(str(x) for x in res))\n"}
{"id": 383617, "name": "Powerful numbers", "source": "Translate Perl to Python: use 5.020;\nuse ntheory qw(is_square_free);\nuse experimental qw(signatures);\nuse Math::AnyNum qw(:overload idiv iroot ipow is_coprime);\n\nsub powerful_numbers ($n, $k = 2) {\n\n    my @powerful;\n\n    sub ($m, $r) {\n        if ($r < $k) {\n            push @powerful, $m;\n            return;\n        }\n        for my $v (1 .. iroot(idiv($n, $m), $r)) {\n            if ($r > $k) {\n                is_square_free($v) || next;\n                is_coprime($m, $v) || next;\n            }\n            __SUB__->($m * ipow($v, $r), $r - 1);\n        }\n    }->(1, 2*$k - 1);\n\n    sort { $a <=> $b } @powerful;\n}\n\nforeach my $k (2 .. 10) {\n    my @a = powerful_numbers(10**$k, $k);\n    my $h = join(', ', @a[0..4]);\n    my $t = join(', ', @a[$\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", $k, scalar(@a), $h, $t);\n}\n", "target": "from primesieve import primes \nimport math\n\ndef primepowers(k, upper_bound):\n    ub = int(math.pow(upper_bound, 1/k) + .5)\n    res = [(1,)]\n\n    for p in primes(ub):\n        a = [p**k]\n        u = upper_bound // a[-1]\n        while u >= p:\n            a.append(a[-1]*p)\n            u //= p\n        res.append(tuple(a))\n\n    return res\n\ndef kpowerful(k, upper_bound, count_only=True):\n    ps = primepowers(k, upper_bound)\n\n    def accu(i, ub):\n        c = 0 if count_only else [] \n        for p in ps[i]:\n            u = ub//p\n            if not u: break\n\n            c += 1 if count_only else [p]\n\n            for j in range(i + 1, len(ps)):\n                if u < ps[j][0]:\n                    break\n                c += accu(j, u) if count_only else [p*x for x in accu(j, u)]\n        return c\n\n    res = accu(0, upper_bound)\n    return res if count_only else sorted(res)\n\nfor k in range(2, 11):\n    res = kpowerful(k, 10**k, count_only=False)\n    print(f'{len(res)} {k}-powerfuls up to 10^{k}:',\n        ' '.join(str(x) for x in res[:5]),\n        '...',\n        ' '.join(str(x) for x in res[-5:])\n        )\n\nfor k in range(2, 11):\n    res = [kpowerful(k, 10**n) for n in range(k+10)]\n    print(f'{k}-powerful up to 10^{k+10}:',\n        ' '.join(str(x) for x in res))\n"}
{"id": 383618, "name": "Distribution of 0 digits in factorial series", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory qw/factorial/;\n\nfor my $n (100, 1000, 10000) {\n    my($sum,$f) = 0;\n    $f = factorial $_ and $sum += ($f =~ tr/0//) / length $f for 1..$n;\n    printf \"%5d:\u00a0%.5f\\n\", $n, $sum/$n;\n}\n", "target": "def facpropzeros(N, verbose = True):\n    proportions = [0.0] * N\n    fac, psum = 1, 0.0\n    for i in range(N):\n        fac *= i + 1\n        d = list(str(fac))\n        psum += sum(map(lambda x: x == '0', d)) / len(d)\n        proportions[i] = psum / (i + 1)\n\n    if verbose:\n        print(\"The mean proportion of 0 in factorials from 1 to {} is {}.\".format(N, psum / N))\n\n    return proportions\n\n\nfor n in [100, 1000, 10000]:\n    facpropzeros(n)\n\nprops = facpropzeros(47500, False)\nn = (next(i for i in reversed(range(len(props))) if props[i] > 0.16))\n\nprint(\"The mean proportion dips permanently below 0.16 at {}.\".format(n + 2))\n"}
{"id": 383619, "name": "Execute CopyPasta Language", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Path::Tiny;\n\nsub CopyPasta {\n    my($code) = @_;\n    my @code = split /\\n/, $code =~ s/\\s*\\n+\\s*/\\n/gr;\n    return \"Program never ends!\" unless grep { $_ eq 'Pasta!' } @code;\n\n    my @cb;\n    my $PC = 0;\n    while (1) {\n        if    ($code[$PC] eq 'Copy')      {        push @cb, $code[++$PC] }\n        elsif ($code[$PC] eq 'CopyFile')  { $PC++; push @cb, join ' ', $code[$PC] eq 'TheF*ckingCode' ? @code : path($code[$PC])->slurp }\n        elsif ($code[$PC] eq 'Duplicate') {             @cb = (@cb) x $code[++$PC] }\n        elsif ($code[$PC] eq 'Pasta!')    { return @cb }\n        else                              { return \"Does not compute: $code[$PC]\" }\n        $PC++;\n    }\n}\n\npath('pasta.txt')->spew( \"I'm the pasta.txt file.\");\n\nfor my $prog (\n    \"Copy \\nRosetta Code\\n\\tDuplicate\\n2\\n\\nPasta!\\nLa Vista\",\n    \"CopyFile\\npasta.txt\\nDuplicate\\n1\\nPasta!\",\n    \"Copy\\nInvalid\\n Duplicate\\n1\\n\\nGoto\\n3\\nPasta!\",\n    \"CopyFile\\nTheF*ckingCode\\nDuplicate\\n2\\nPasta!\",\n    \"Copy\\nRosetta Code\\nDuplicate\\n2\\n\\nPasta\"\n) {\n    say for CopyPasta($prog);\n    say '';\n}\n\nunlink 'pasta.txt';\n", "target": "import sys\n\n\ndef fatal_error(errtext):\n\tprint(\"%\" + errtext)\n\tprint(\"usage: \" + sys.argv[0] + \" [filename.cp]\")\n\tsys.exit(1)\n\n\nfname = None\nsource = None\ntry:\n\tfname = sys.argv[1]\n\tsource = open(fname).read()\nexcept:\n\tfatal_error(\"error while trying to read from specified file\")\n\n\nlines = source.split(\"\\n\")\n\n\nclipboard = \"\"\n\n\nloc = 0\nwhile(loc < len(lines)):\n\t\n\tcommand = lines[loc].strip()\n\n\ttry:\n\t\tif(command == \"Copy\"):\n\t\t\tclipboard += lines[loc + 1]\n\t\telif(command == \"CopyFile\"):\n\t\t\tif(lines[loc + 1] == \"TheF*ckingCode\"):\n\t\t\t\tclipboard += source\n\t\t\telse:\n\t\t\t\tfiletext = open(lines[loc+1]).read()\n\t\t\t\tclipboard += filetext\n\t\telif(command == \"Duplicate\"):\n\t\t\tclipboard += clipboard * ((int(lines[loc + 1])) - 1)\n\t\telif(command == \"Pasta!\"):\n\t\t\tprint(clipboard)\n\t\t\tsys.exit(0)\n\t\telse:\n\t\t\tfatal_error(\"unknown command '\" + command + \"' encountered on line \" + str(loc + 1))\n\texcept Exception as e:\n\t\tfatal_error(\"error while executing command '\" + command + \"' on line \" + str(loc + 1) + \": \" + e)\n\n\t\n\tloc += 2\n"}
{"id": 383620, "name": "Suffixation of decimal numbers", "source": "Translate Perl to Python: use List::Util qw(min max first);\n\nsub sufficate {\n    my($val, $type, $round) = @_;\n    $type //= 'M';\n   if ($type =~ /^\\d$/) { $round = $type; $type = 'M' }\n\n    my $s = '';\n    if (substr($val,0,1) eq '-') { $s = '-'; $val = substr $val, 1 }\n    $val =~ s/,//g;\n    if ($val =~ m/e/i) {\n        my ($m,$e) = split /[eE]/, $val;\n        $val = ($e < 0) ? $m * 10**-$e : $m * 10**$e;\n    }\n\n    my %s;\n    if ($type eq 'M') {\n        my @x = qw<K M G T P E Z Y X W V U>;\n        $s{$x[$_]} = 1000 * 10 ** ($_*3) for 0..$\n    } elsif ($type eq 'B') {\n        my @x = qw<Ki Mi Gi Ti Pi Ei Zi Yi Xi Wi Vi Ui>;\n        $s{$x[$_]} = 2 ** (10*($_+1)) for 0..$\n    } elsif ($type eq 'G') {\n        $s{'googol'} = 10**100\n    } else {\n        return 'What we have here is a failure to communicate...'\n    }\n\n    my $k;\n    if (abs($val) < (my $m = min values %s)) {\n        $k = first { $s{$_} == $m } keys %s;\n    } elsif (abs($val) > (my $x = max values %s)) {\n        $k = first { $s{$_} == $x } keys %s;\n    } else {\n        for my $key (sort { $s{$a} <=> $s{$b} } keys %s) {\n            next unless abs($val)/$s{$key} < min values %s;\n            $k = $key;\n            last;\n        }\n    }\n\n    my $final = abs($val)/$s{$k};\n    $final = round($final,$round) if defined $round;\n    $s . $final . $k\n}\n\nsub round {\n    my($num,$dig) = @_;\n    if    ($dig == 0) { int 0.5 + $num }\n    elsif ($dig  < 0) { 10**-$dig * int(0.5 + $num/10**-$dig) }\n    else              { my $fmt = '%.' . $dig . 'f'; sprintf $fmt, $num }\n}\n\nsub comma {\n    my($i) = @_;\n    my ($whole, $frac) = split /\\./, $i;\n    (my $s = reverse $whole) =~ s/(.{3})/$1,/g;\n    ($s = reverse $s) =~ s/^,//;\n    $frac = $frac.defined ? \".$frac\" : '';\n    return \"$s$frac\";\n}\n\nmy @tests = (\n   '87,654,321',\n   '-998,877,665,544,332,211,000 3',\n   '+112,233 0',\n   '16,777,216 1',\n   '456,789,100,000,000',\n   '456,789,100,000,000 M 2',\n   '456,789,100,000,000 B 5',\n   '456,789,100,000.000e+00 M 0',\n   '+16777216 B',\n   '1.2e101 G',\n   '347,344 M -2', \n   '1122334455 Q', \n);\n\nprintf \"%33s\u00a0: %s\\n\", $_, sufficate(split ' ', $_) for @tests;\n", "target": "import math\nimport os\n\n\ndef suffize(num, digits=None, base=10):\n    suffixes = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y', 'X', 'W', 'V', 'U', 'googol']\n\n    exponent_distance = 10 if base == 2 else 3\n    num = num.strip().replace(',', '')\n    num_sign = num[0] if num[0] in '+-' else ''\n\n    num = abs(float(num))\n\n    if base == 10 and num >= 1e100:\n        suffix_index = 13\n        num /= 1e100\n    elif num > 1:\n        magnitude = math.floor(math.log(num, base))\n        suffix_index = min(math.floor(magnitude / exponent_distance), 12)\n        num /= base ** (exponent_distance * suffix_index)\n    else:\n        suffix_index = 0\n\n    if digits is not None:\n        num_str = f'{num:.{digits}f}'\n    else:\n        num_str = f'{num:.3f}'.strip('0').strip('.')\n\n    return num_sign + num_str + suffixes[suffix_index] + ('i' if base == 2 else '')\n\n\ntests = [('87,654,321',),\n         ('-998,877,665,544,332,211,000', 3),\n         ('+112,233', 0),\n         ('16,777,216', 1),\n         ('456,789,100,000,000', 2),\n         ('456,789,100,000,000', 2, 10),\n         ('456,789,100,000,000', 5, 2),\n         ('456,789,100,000.000e+00', 0, 10),\n         ('+16777216', None, 2),\n         ('1.2e101',)]\n\nfor test in tests:\n    print(' '.join(str(i) for i in test) + '\u00a0: ' + suffize(*test))\n"}
{"id": 383621, "name": "Suffixation of decimal numbers", "source": "Translate Perl to Python: use List::Util qw(min max first);\n\nsub sufficate {\n    my($val, $type, $round) = @_;\n    $type //= 'M';\n   if ($type =~ /^\\d$/) { $round = $type; $type = 'M' }\n\n    my $s = '';\n    if (substr($val,0,1) eq '-') { $s = '-'; $val = substr $val, 1 }\n    $val =~ s/,//g;\n    if ($val =~ m/e/i) {\n        my ($m,$e) = split /[eE]/, $val;\n        $val = ($e < 0) ? $m * 10**-$e : $m * 10**$e;\n    }\n\n    my %s;\n    if ($type eq 'M') {\n        my @x = qw<K M G T P E Z Y X W V U>;\n        $s{$x[$_]} = 1000 * 10 ** ($_*3) for 0..$\n    } elsif ($type eq 'B') {\n        my @x = qw<Ki Mi Gi Ti Pi Ei Zi Yi Xi Wi Vi Ui>;\n        $s{$x[$_]} = 2 ** (10*($_+1)) for 0..$\n    } elsif ($type eq 'G') {\n        $s{'googol'} = 10**100\n    } else {\n        return 'What we have here is a failure to communicate...'\n    }\n\n    my $k;\n    if (abs($val) < (my $m = min values %s)) {\n        $k = first { $s{$_} == $m } keys %s;\n    } elsif (abs($val) > (my $x = max values %s)) {\n        $k = first { $s{$_} == $x } keys %s;\n    } else {\n        for my $key (sort { $s{$a} <=> $s{$b} } keys %s) {\n            next unless abs($val)/$s{$key} < min values %s;\n            $k = $key;\n            last;\n        }\n    }\n\n    my $final = abs($val)/$s{$k};\n    $final = round($final,$round) if defined $round;\n    $s . $final . $k\n}\n\nsub round {\n    my($num,$dig) = @_;\n    if    ($dig == 0) { int 0.5 + $num }\n    elsif ($dig  < 0) { 10**-$dig * int(0.5 + $num/10**-$dig) }\n    else              { my $fmt = '%.' . $dig . 'f'; sprintf $fmt, $num }\n}\n\nsub comma {\n    my($i) = @_;\n    my ($whole, $frac) = split /\\./, $i;\n    (my $s = reverse $whole) =~ s/(.{3})/$1,/g;\n    ($s = reverse $s) =~ s/^,//;\n    $frac = $frac.defined ? \".$frac\" : '';\n    return \"$s$frac\";\n}\n\nmy @tests = (\n   '87,654,321',\n   '-998,877,665,544,332,211,000 3',\n   '+112,233 0',\n   '16,777,216 1',\n   '456,789,100,000,000',\n   '456,789,100,000,000 M 2',\n   '456,789,100,000,000 B 5',\n   '456,789,100,000.000e+00 M 0',\n   '+16777216 B',\n   '1.2e101 G',\n   '347,344 M -2', \n   '1122334455 Q', \n);\n\nprintf \"%33s\u00a0: %s\\n\", $_, sufficate(split ' ', $_) for @tests;\n", "target": "import math\nimport os\n\n\ndef suffize(num, digits=None, base=10):\n    suffixes = ['', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y', 'X', 'W', 'V', 'U', 'googol']\n\n    exponent_distance = 10 if base == 2 else 3\n    num = num.strip().replace(',', '')\n    num_sign = num[0] if num[0] in '+-' else ''\n\n    num = abs(float(num))\n\n    if base == 10 and num >= 1e100:\n        suffix_index = 13\n        num /= 1e100\n    elif num > 1:\n        magnitude = math.floor(math.log(num, base))\n        suffix_index = min(math.floor(magnitude / exponent_distance), 12)\n        num /= base ** (exponent_distance * suffix_index)\n    else:\n        suffix_index = 0\n\n    if digits is not None:\n        num_str = f'{num:.{digits}f}'\n    else:\n        num_str = f'{num:.3f}'.strip('0').strip('.')\n\n    return num_sign + num_str + suffixes[suffix_index] + ('i' if base == 2 else '')\n\n\ntests = [('87,654,321',),\n         ('-998,877,665,544,332,211,000', 3),\n         ('+112,233', 0),\n         ('16,777,216', 1),\n         ('456,789,100,000,000', 2),\n         ('456,789,100,000,000', 2, 10),\n         ('456,789,100,000,000', 5, 2),\n         ('456,789,100,000.000e+00', 0, 10),\n         ('+16777216', None, 2),\n         ('1.2e101',)]\n\nfor test in tests:\n    print(' '.join(str(i) for i in test) + '\u00a0: ' + suffize(*test))\n"}
{"id": 383622, "name": "Pentomino tiling", "source": "Translate Perl to Python: use strict; \nuse warnings;\nuse feature 'bitwise';\n\nmy $size = shift // 8;\n\nsub rotate\n  {\n  local $_ = shift;\n  my $ans = '';\n  $ans .= \"\\n\" while s/.$/$ans .= $&; ''/gem;\n  $ans;\n  }\n\nsub topattern\n  {\n  local $_ = shift;\n  s/.+/ $& . ' ' x ($size - length $&)/ge;\n  s/^\\s+|\\s+\\z//g;\n  [ tr/ \\nA-Z/.. /r, lc tr/ \\n/\\0/r, substr $_, 0, 1 ]; \n  }\n\nmy %all;\n@all{ \" FF\\nFF \\n F \\n\", \"IIIII\\n\", \"LLLL\\nL   \\n\", \"NNN \\n  NN\\n\",\n  \"PPP\\nPP \\n\", \"TTT\\n T \\n T \\n\", \"UUU\\nU U\\n\", \"VVV\\nV  \\nV  \\n\",\n  \"WW \\n WW\\n  W\\n\", \" X \\nXXX\\n X \\n\", \"YYYY\\n Y  \\n\", \"ZZ \\n Z \\n ZZ\\n\",\n  } = ();\n@all{map rotate($_), keys %all} = () for 1 .. 3;  \n@all{map s/.+/reverse $&/ger, keys %all} = ();    \nmy @all = map topattern($_), keys %all;\nmy $grid = ( ' ' x $size . \"\\n\" ) x $size;\nmy %used;\nfind( $grid );\n\n\nsub find\n  {\n  my $grid = shift;\n  %used >= 12 and exit not print $grid;\n  for ( grep ! $used{ $_->[2] }, @all )\n    {\n    my ($pattern, $pentomino, $letter) = @$_;\n    local $used{$letter} = 1;\n    $grid =~ /^[^ ]*\\K$pattern/s and find( $grid ^. \"\\0\" x $-[0] . $pentomino );\n    }\n  }\n", "target": "from itertools import product\n\nminos = (((197123, 7, 6), (1797, 6, 7), (1287, 6, 7), (196867, 7, 6)),\n        ((263937, 6, 6), (197126, 6, 6), (393731, 6, 6), (67332, 6, 6)),\n        ((16843011, 7, 5), (2063, 5, 7), (3841, 5, 7), (271, 5, 7), (3848, 5, 7), (50463234, 7, 5), (50397441, 7, 5), (33686019, 7, 5)),\n        ((131843, 7, 6), (1798, 6, 7), (775, 6, 7), (1795, 6, 7), (1543, 6, 7), (197377, 7, 6), (197378, 7, 6), (66307, 7, 6)),\n        ((132865, 6, 6), (131846, 6, 6), (198146, 6, 6), (132611, 6, 6), (393986, 6, 6), (263938, 6, 6), (67330, 6, 6), (132868, 6, 6)),\n        ((1039, 5, 7), (33751554, 7, 5), (16843521, 7, 5), (16974081, 7, 5), (33686274, 7, 5), (3842, 5, 7), (3844, 5, 7), (527, 5, 7)),\n        ((1804, 5, 7), (33751297, 7, 5), (33686273, 7, 5), (16974338, 7, 5), (16843522, 7, 5), (782, 5, 7), (3079, 5, 7), (3587, 5, 7)),\n        ((263683, 6, 6), (198148, 6, 6), (66310, 6, 6), (393985, 6, 6)),\n        ((67329, 6, 6), (131591, 6, 6), (459266, 6, 6), (263940, 6, 6)),\n        ((459780, 6, 6), (459009, 6, 6), (263175, 6, 6), (65799, 6, 6)),\n        ((4311810305, 8, 4), (31, 4, 8)),\n        ((132866, 6, 6),))\n\nboxchar_double_width = ' \u2576\u257a\u2575\u2514\u2515\u2579\u2516\u2517\u2574\u2500\u257c\u2518\u2534\u2536\u251a\u2538\u253a\u2578\u257e\u2501\u2519\u2535\u2537\u251b\u2539\u253b\u2577\u250c\u250d\u2502\u251c\u251d\u257f\u251e\u2521\u2510\u252c\u252e\u2524\u253c\u253e\u2526\u2540\u2544\u2511\u252d\u252f\u2525\u253d\u253f\u2529\u2543\u2547\u257b\u250e\u250f\u257d\u251f\u2522\u2503\u2520\u2523\u2512\u2530\u2532\u2527\u2541\u2546\u2528\u2542\u254a\u2513\u2531\u2533\u252a\u2545\u2548\u252b\u2549\u254b'\nboxchar_single_width = [c + ' \u2500\u2501'[i%3] for i, c in enumerate(boxchar_double_width)]\n\n\npatterns = boxchar_single_width\n\ntiles = []\nfor row in reversed(minos):\n    tiles.append([])\n    for n, x, y in row:\n        for shift in (b*8 + a for a, b in product(range(x), range(y))):\n            tiles[-1].append(n << shift)\n\ndef img(seq):\n    b = [[0]*10 for _ in range(10)]\n\n    for i, s in enumerate(seq):\n        for j, k in product(range(8), range(8)):\n            if s & (1<<(j*8 + k)):\n                b[j + 1][k + 1] = i + 1\n\n    idices = [[0]*9 for _ in range(9)]\n    for i, j in product(range(9), range(9)):\n        n = (b[i+1][j+1], b[i][j+1], b[i][j], b[i+1][j], b[i+1][j+1])\n        idices[i][j] = sum((a != b)*(1 + (not a or not b))*3**i for i, (a,b) in enumerate(zip(n, n[1:])))\n\n    return '\\n'.join(''.join(patterns[i] for i in row) for row in idices)\n\ndef tile(board=0, seq=tuple(), tiles=tiles):\n    if not tiles:\n        yield img(seq)\n        return\n\n    for c in tiles[0]:\n        b = board | c\n\n        tnext = [] \n        for t in tiles[1:]:\n            tnext.append(tuple(n for n in t if not n&b))\n            if not tnext[-1]: break \n        else:\n            yield from tile(b, seq + (c,), tnext)\n\nfor x in tile():\n    print(x)\n"}
{"id": 383623, "name": "Bioinformatics_Global alignment", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( first uniq );\n\nmy @seq = (\n  [ qw( TA AAG TA GAA TA ) ],\n\n  [ qw( CATTAGGG ATTAG GGG TA) ],\n\n  [ qw( AAGAUGGA GGAGCGCAUC AUCGCAAUAAGGA ) ],\n\n  [ qw(\n  ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT\n  GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT\n  CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\n  TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\n  AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\n  GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC\n  CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT\n  TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\n  CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC\n  GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT\n  TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\n  CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\n  TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA\n  ) ],\n  );\n\nsub removedups \n  {\n  local $_ = join ' ', sort { length $a <=> length $b } split ' ', shift;\n  1 while s/\\b(\\w+) (?=.*\\1)//;\n  return $_;\n  }\n\nfor ( @seq )\n  {\n  local $_ = removedups join ' ', @$_;\n  my @queue = $_;\n  my @best;\n\n  while( @queue )\n    {\n    local $_ = shift @queue;\n    my @seq = split ' ', $_;\n    my @over;\n    for my $left ( @seq )\n      {\n      for my $right ( @seq )\n        {\n        $left eq $right and next;\n        \"$left $right\" =~ /(.+) \\1/ or next;\n        my $len = length $1;\n        $over[$len] .= \"$left $right\\n\";\n        }\n      }\n    if( @over )\n      {\n      for my $join ( split /\\n/, $over[-1] )\n        {\n        my ($left, $right) = split ' ', $join;\n        my @newseq = grep $_ ne $left && $_ ne $right, @seq; \n        push @queue, removedups \"$left $right\" =~ s/(.+) (?=\\1)//r .\n          join ' ', '', @newseq;\n        }\n      }\n    else\n      {\n      tr/ //d;\n      $best[length] .= \"$_\\n\";\n      next;\n      }\n    }\n\n  for ( uniq split /\\n/, first {defined} @best )\n    {\n    printf \"\\nlength %d - %s\\n\", length, $_;\n    my %ch;\n    $ch{$_}++ for /./g;\n    use Data::Dump 'dd'; dd \\%ch;\n    }\n  }\n", "target": "import os\n\nfrom collections import Counter\nfrom functools import reduce\nfrom itertools import permutations\n\nBASES = (\"A\", \"C\", \"G\", \"T\")\n\n\ndef deduplicate(sequences):\n    \n    sequences = set(sequences)\n    duplicates = set()\n\n    for s, t in permutations(sequences, 2):\n        if s != t and s in t:\n            duplicates.add(s)\n\n    return sequences - duplicates\n\n\ndef smash(s, t):\n    \n    for i in range(len(s)):\n        if t.startswith(s[i:]):\n            return s[:i] + t\n    return s + t\n\n\ndef shortest_superstring(sequences):\n    \n    sequences = deduplicate(sequences)\n    shortest = \"\".join(sequences)\n\n    for perm in permutations(sequences):\n        superstring = reduce(smash, perm)\n        if len(superstring) < len(shortest):\n            shortest = superstring\n\n    return shortest\n\n\ndef shortest_superstrings(sequences):\n    \n    sequences = deduplicate(sequences)\n\n    shortest = set([\"\".join(sequences)])\n    shortest_length = sum(len(s) for s in sequences)\n\n    for perm in permutations(sequences):\n        superstring = reduce(smash, perm)\n        superstring_length = len(superstring)\n        if superstring_length < shortest_length:\n            shortest.clear()\n            shortest.add(superstring)\n            shortest_length = superstring_length\n        elif superstring_length == shortest_length:\n            shortest.add(superstring)\n\n    return shortest\n\n\ndef print_report(sequence):\n    \n    buf = [f\"Nucleotide counts for {sequence}:\\n\"]\n\n    counts = Counter(sequence)\n    for base in BASES:\n        buf.append(f\"{base:>10}{counts.get(base, 0):>12}\")\n\n    other = sum(v for k, v in counts.items() if k not in BASES)\n    buf.append(f\"{'Other':>10}{other:>12}\")\n\n    buf.append(\" \" * 5 + \"_\" * 17)\n    buf.append(f\"{'Total length':>17}{sum(counts.values()):>5}\")\n\n    print(os.linesep.join(buf), \"\\n\")\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        (\"TA\", \"AAG\", \"TA\", \"GAA\", \"TA\"),\n        (\"CATTAGGG\", \"ATTAG\", \"GGG\", \"TA\"),\n        (\"AAGAUGGA\", \"GGAGCGCAUC\", \"AUCGCAAUAAGGA\"),\n        (\n            \"ATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTAT\",\n            \"GGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGT\",\n            \"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\",\n            \"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"AACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTT\",\n            \"GCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTC\",\n            \"CGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCT\",\n            \"TGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGC\",\n            \"GATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATT\",\n            \"TTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATC\",\n            \"CTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATA\",\n            \"TCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGA\",\n        ),\n    ]\n\n    for case in test_cases:\n        for superstring in shortest_superstrings(case):\n            print_report(superstring)\n\n    \n    \n    \n    \n    \n    \n"}
{"id": 383624, "name": "Divide a rectangle into a number of unequal triangles", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\n\nsub UnequalDivider {\n    my($L,$H,$N) = @_;\n    die unless $N > 2;\n    return (0,$H), (0,0), ((2/5)*$L,$H), ($L,0), ($L,$H) if $N == 3;\n\n    my ($fail,%unique,%ratios,@base,@roof,$bTotal,$rTotal);\n\n    do { \n        $fail   = 0;\n        %unique =  %ratios = () ;\n        ++$unique{int(rand 2*$N) + 1} while keys %unique < $N;\n        my @segments      = keys %unique;\n        @base             = @segments[   0 ..     $N/2-1];\n        @roof             = @segments[$N/2 .. $\n        ($bTotal,$rTotal) = (  sum(@base),  sum(@roof)  );\n        ++$ratios{$_/$bTotal} for (@base);\n        for (@roof) { if ( exists($ratios{$_/$rTotal}) ) { $fail = 1 && last } }\n   } until ( $fail == 0 );\n\n   my ($bPartial,$rPartial) = ( shift(@base), shift(@roof) ); \n   my @vertices = ([0,$H], [0,0], [($rPartial/$rTotal)*$L,$H]);\n\n    for (0 .. @base) {\n        push @vertices, [$bPartial/$bTotal*$L,0];\n        if (@base == 1) {\n            0 == $N%2 ? return @vertices, ([$L,$H], [$L,0])\n                      : return @vertices, ([$L*(1-$roof[-1]/$rTotal),$H], [$L,0], [$L,$H]);\n        }\n        ($bPartial) += shift @base;\n        ($rPartial) += shift @roof;\n        push @vertices, [$rPartial/$rTotal*$L,$H];\n   }\n}\n\nmy @V = UnequalDivider(1000,500,7);\nsay sprintf( '(%.3f\u00a0%.3f) 'x3, @{$V[$_]}, @{$V[++$_]}, @{$V[++$_]} ) =~ s/\\.000//gr for 0 .. @V-3;\n", "target": "import random\nfrom typing import List, Union, Tuple\n\n\n\nNum = Union[int, float]\nPoint = Tuple[Num, Num]\n\n\n\ndef rect_into_tri(\n        top_right: Tuple[Num, Num] = (2, 1), \n        triangles: int             = 5,      \n        _rand_tol: Num             = 1e6,    \n        ) -> List[Tuple[Point, Point, Point]]:\n    \n\n    width, height = top_right\n    assert triangles > 2 and triangles % 2 == 1, \"Needs Odd number greater than 2\"\n    \n\n    _rand_tol = int(_rand_tol)\n\n    \n    insert_top = triangles // 2\n    p = q = None\n    while not p or not different_distances(p, q, height):\n        p = [0] + rand_points(insert_top,     width, int(_rand_tol)) + [width]  \n        q = [0] + rand_points(insert_top - 1, width, int(_rand_tol)) + [width]  \n\n    \n    top_tri = [((t0, height), (t1, height), (b0, 0))\n               for t0, t1, b0 in zip(p, p[1:], q)]\n    bottom_tri = [((b0, 0), (b1, 0), (t1, height))\n                  for b0, b1, t1 in zip(q, q[1:], p[1:])]\n\n    return top_tri + bottom_tri\n\ndef rect_into_top_tri(\n        top_right: Tuple[Num, Num] = (2, 1),\n        triangles: int             = 4,\n        _rand_tol: Num             = 1e6,\n        ) -> List[Tuple[Point, Point, Point]]:\n    \n\n    width, height = top_right\n    assert int(triangles)==triangles and triangles > 2, \"Needs int > 2\"\n    \n\n    _rand_tol = int(_rand_tol)\n\n    \n    insert_top = triangles - 2\n    top = [0] + rand_points(insert_top, width, int(_rand_tol)) + [width]  \n\n    \n    top_tri = [((0, 0), (t0, height), (t1, height))\n               for t0, t1 in zip(top, top[1:])]\n    bottom_tri = [((0, 0), (width, height), (width, 0))]\n\n    return top_tri + bottom_tri\n\n\ndef rand_points(n: int, width: Num=1, _rand_tol: int=1_000_000) -> List[float]:\n    \"return n sorted, random points where 0 < point < width\"\n    return sorted(p * width / _rand_tol\n                  for p in random.sample(range(1, _rand_tol), n))\n\ndef different_distances(p: List[Num], q: List[Num], height: Num) -> bool:\n    \"Are all point-to-next-point distances in p and q; and height all different?\"\n    diffs =  [p1 - p0 for p0, p1 in zip(p, p[1:])]\n    diffs += [q1 - q0 for q0, q1 in zip(q, q[1:])]\n    diffs += [height]\n    return len(diffs) == len(set(diffs))\n\n\n\nif __name__ == \"__main__\":\n    from pprint import pprint as pp\n\n    print(\"\\nrect_into_tri \n    pp(rect_into_tri((2, 1), 5, 10))\n    print(\"\\nrect_into_tri \n    pp(rect_into_tri((2, 1), 5, 10))\n    print(\"\\nrect_into_top_tri \n    pp(rect_into_top_tri((2, 1), 4, 10))\n    print(\"\\nrect_into_top_tri \n    pp(rect_into_top_tri((2, 1), 4, 10))\n"}
{"id": 383625, "name": "Resistance network calculator", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub gauss {\n  our @m; local *m = shift;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n      ++$lead;}\n}\n\nsub network {\n    my($n,$k0,$k1,$grid) = @_;\n    my @m;\n    push @m, [(0)x($n+1)] for 1..$n;\n\n    for my $resistor (split '\\|', $grid) {\n        my ($a,$b,$r_inv) = split /\\s+/, $resistor;\n        my $r = 1 / $r_inv;\n        $m[$a][$a] += $r;\n        $m[$b][$b] += $r;\n        $m[$a][$b] -= $r if $a > 0;\n        $m[$b][$a] -= $r if $b > 0;\n    }\n    $m[$k0][$k0] = 1;\n    $m[$k1][ -1] = 1;\n    gauss(\\@m);\n    return $m[$k1][-1];\n}\n\nfor (\n    [   7, 0,     1, '0 2 6|2 3 4|3 4 10|4 5 2|5 6 8|6 1 4|3 5 6|3 6 6|3 1 8|2 1 8' ],\n    [ 3*3, 0, 3*3-1, '0 1 1|1 2 1|3 4 1|4 5 1|6 7 1|7 8 1|0 3 1|3 6 1|1 4 1|4 7 1|2 5 1|5 8 1' ],\n    [ 4*4, 0, 4*4-1, '0 1 1|1 2 1|2 3 1|4 5 1|5 6 1|6 7 1|8 9 1|9 10 1|10 11 1|12 13 1|13 14 1|14 15 1|0 4 1|4 8 1|8 12 1|1 5 1|5 9 1|9 13\n1|2 6 1|6 10 1|10 14 1|3 7 1|7 11 1|11 15 1' ],\n    [   4, 0,     3, '0 1 150|0 2 50|1 3 300|2 3 250' ],\n) {\n    printf \"%10.3f\\n\", network(@$_);\n}\n", "target": "from fractions import Fraction\n\ndef gauss(m):\n\tn, p = len(m), len(m[0])\n\tfor i in range(n):\n\t\tk = max(range(i, n), key = lambda x: abs(m[x][i]))\n\t\tm[i], m[k] = m[k], m[i]\n\t\tt = 1 / m[i][i]\n\t\tfor j in range(i + 1, p): m[i][j] *= t\n\t\tfor j in range(i + 1, n):\n\t\t\tt = m[j][i]\n\t\t\tfor k in range(i + 1, p): m[j][k] -= t * m[i][k]\n\tfor i in range(n - 1, -1, -1):\n\t\tfor j in range(i): m[j][-1] -= m[j][i] * m[i][-1]\n\treturn [row[-1] for row in m]\n\ndef network(n,k0,k1,s):\n\tm = [[0] * (n+1) for i in range(n)]\n\tresistors = s.split('|')\n\tfor resistor in resistors:\n\t\ta,b,r = resistor.split(' ')\n\t\ta,b,r = int(a), int(b), Fraction(1,int(r))\n\t\tm[a][a] += r\n\t\tm[b][b] += r\n\t\tif a > 0: m[a][b] -= r\n\t\tif b > 0: m[b][a] -= r\n\tm[k0][k0] = Fraction(1, 1)\n\tm[k1][-1] = Fraction(1, 1)\n\treturn gauss(m)[k1]\n\nassert 10             == network(7,0,1,\"0 2 6|2 3 4|3 4 10|4 5 2|5 6 8|6 1 4|3 5 6|3 6 6|3 1 8|2 1 8\")\nassert 3/2            == network(3*3,0,3*3-1,\"0 1 1|1 2 1|3 4 1|4 5 1|6 7 1|7 8 1|0 3 1|3 6 1|1 4 1|4 7 1|2 5 1|5 8 1\")\nassert Fraction(13,7) == network(4*4,0,4*4-1,\"0 1 1|1 2 1|2 3 1|4 5 1|5 6 1|6 7 1|8 9 1|9 10 1|10 11 1|12 13 1|13 14 1|14 15 1|0 4 1|4 8 1|8 12 1|1 5 1|5 9 1|9 13 1|2 6 1|6 10 1|10 14 1|3 7 1|7 11 1|11 15 1\")\nassert 180            == network(4,0,3,\"0 1 150|0 2 50|1 3 300|2 3 250\")\n"}
{"id": 383626, "name": "Resistance calculator", "source": "Translate Perl to Python: use v5.36;\n\npackage Resistor;\nrequire Exporter;\nour @ISA    = qw(Exporter);\nour @EXPORT = qw(set_voltage report);\n\nuse overload '+' => \\&serial, '*' => \\&parallel;\n\nsub new ($class, $args) {\n    my $self = {\n        symbol     => $args->{symbol},\n        voltage    => $args->{voltage},\n        resistance => $args->{resistance},\n        a          => $args->{a},\n        b          => $args->{b},\n    };\n    return bless $self, $class;\n}\n\nsub res ($self) {\n    if    ($self->{symbol} eq '+') { return res($self->{a}) + res($self->{b}) }\n    elsif ($self->{symbol} eq '*') { return 1 / (1/res($self->{a}) + 1/res($self->{b})) }\n    else                           { return $self->{resistance} }\n}\n\nsub set_voltage ($self,$voltage) {\n    if ($self->{symbol} eq '+') {\n        my $ra = res($self->{a});\n        my $rb = res($self->{b});\n        set_voltage($self->{a}, $ra / ($ra+$rb) * $voltage );\n        set_voltage($self->{b}, $rb / ($ra+$rb) * $voltage );\n    } elsif ($self->{symbol} eq '*') {\n        set_voltage($self->{a}, $voltage );\n        set_voltage($self->{b}, $voltage );\n    }\n    $self->{voltage} = $voltage;\n}\n\nsub current ($self) { return $self->{voltage} / res($self)     }\nsub effect  ($self) { return $self->{voltage} * current($self) }\n\nsub serial   ($a,$b,$) { Resistor->new( {symbol => '+', a => $a, b => $b} ) }\nsub parallel ($a,$b,$) { Resistor->new( {symbol => '*', a => $a, b => $b} ) }\n\nsub report ($self,$level = 0) {\n    state @results;\n    push @results, '      Ohm     Volt   Ampere     Watt   Network tree' and $level = 1 unless $level;\n    my $pad = ('| ') x $level;\n    my $f = sprintf '%9.3f' x 4, res($self), $self->{voltage}, current($self), effect($self);\n    say \"$f $pad\" . $self->{symbol};\n    report($self->{a}, $level+1) if defined $self->{a};\n    report($self->{b}, $level+1) if defined $self->{b};\n    join \"\\n\", @results;\n}\n\n}\n\npackage main;\nResistor->import;\n\nmy ($R1, $R2, $R3, $R4, $R5, $R6, $R7, $R8, $R9, $R10) =\n    map { Resistor->new( {symbol => 'r', resistance => $_} ) } <6 8 4 8 4 6 8 10 6 2>;\n\nmy $node = (((($R8 + $R10) * $R9 + $R7) * $R6 + $R5)\n                           * $R4 + $R3) * $R2 + $R1;\n\nset_voltage($node,18);\nsay report($node);\n", "target": "import strutils, strformat\n\ntype\n  Node = ref object\n    kind: char  \n    resistance: float\n    voltage: float\n    a: Node\n    b: Node\n\nproc res(node: Node): float =\n  if node.kind == '+': return node.a.res + node.b.res\n  if node.kind == '*': return 1 / (1 / node.a.res + 1 / node.b.res)\n  node.resistance\n\nproc current(node: Node): float = node.voltage / node.res\nproc effect (node: Node): float = node.current * node.voltage\n\nproc report(node: Node, level: string = \"\") =\n  echo fmt\"{node.res:8.3f} {node.voltage:8.3f} {node.current:8.3f} {node.effect:8.3f}  {level}{node.kind}\"\n  if node.kind in \"+*\":\n    node.a.report level & \"| \"\n    node.b.report level & \"| \"\n\nproc setVoltage(node: Node, voltage: float) =\n  node.voltage = voltage\n  if node.kind == '+':\n    let ra = node.a.res\n    let rb = node.b.res\n    node.a.setVoltage ra / (ra+rb) * voltage\n    node.b.setVoltage rb / (ra+rb) * voltage\n  if node.kind == '*':\n    node.a.setVoltage voltage\n    node.b.setVoltage voltage\n\nproc build(tokens: seq[string]): Node =\n  var stack: seq[Node]\n  for token in tokens:\n    stack.add if token == \"+\": Node(kind: '+', a: stack.pop, b: stack.pop)\n              elif token == \"*\": Node(kind: '*', a: stack.pop, b: stack.pop)\n              else: Node(kind: 'r', resistance: parseFloat(token))\n  stack.pop\n\nproc calculate(voltage: float, tokens: seq[string]): Node =\n  echo \"\"\n  echo \"     Ohm     Volt   Ampere     Watt  Network tree\"\n  let node = build tokens\n  node.setVoltage voltage\n  node.report\n  node\n"}
{"id": 383627, "name": "Solve equations with substitution method", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub parse {\n    my($e) = @_;\n    $e =~ s/ ([xy])/ 1$1/;\n    $e =~ s/[ =\\+]//g;\n    split /[xy=]/, $e;\n}\n\nsub solve {\n    my($a1, $b1, $c1, $a2, $b2, $c2) = @_;\n    my $X = ( $b2 * $c1  -  $b1 * $c2 )\n          / ( $b2 * $a1  -  $b1 * $a2 );\n    my $Y = ( $a1 * $X  -  $c1 ) / -$b1;\n    return $X, $Y;\n}\n\nsay my $result = join ' ', solve( parse('3x + y = -1'), parse('2x - 3y = -19') );\n", "target": "\n\nfirstEquation  = [ 3, 1, -1]\nsecondEquation = [ 2,-3,-19]\n\ndef getCrossingPoint(firstEquation, secondEquation):\n    x1 = firstEquation[0]\n    y1 = firstEquation[1]\n    r1 = firstEquation[2]\n    x2 = secondEquation[0]\n    y2 = secondEquation[1]\n    r2 = secondEquation[2]\n    temp = []\n    temp.append( x1)\n    temp.append(-y1)\n    temp.append( r1)\n    resultY = ((temp[0]*r2) - (x2*temp[2])) / ((x2*temp[1]) + (temp[0]*y2)) \n    resultX = (r1 - (y1*resultY)) / x1 \n    print(\"x = \", resultX)\n    print(\"y = \", resultY)\n\n\nif __name__ == \"__main__\":\n    getCrossingPoint(firstEquation, secondEquation)\n"}
{"id": 383628, "name": "Price list behind API", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util <min max shuffle>;\n\nsub getPRangeCount {\n    my($min,$max,@prices) = @_;\n    grep { $min <= $_ <= $max } @prices;\n}\n\nsub get5000 {\n   my($min, $max, $n, @prices) = @_;\n   my $count = getPRangeCount($min, $max, @prices);\n   my $delta = ($max - $min) / 2;\n   while ($count != $n and $delta >= 1/2) {\n      $count > $n ? $max -= $delta : ($max += $delta);\n      $count = getPRangeCount($min, $max, @prices);\n      $delta /= 2;\n   }\n   $max, $count\n}\n\nsub getAll5000 {\n   my($min, $max, $n, @prices) = @_;\n   my ( $pmax, $pcount ) = get5000($min, $max, $n, @prices);\n   my @results = [ $min, $pmax, $pcount ];\n   while ($pmax < $max) {\n      my $pmin = $pmax + 1;\n      ( $pmax, $pcount ) = get5000($pmin, $max, $n, @prices);\n      $pcount == 0 and print \"Price list from $pmin has too many duplicates.\\n\";\n      push @results, [ $pmin, $pmax, $pcount ];\n   }\n   @results\n}\n\nmy @prices;\npush @prices, int rand 10_000+1 for 1 .. (my $numPrices = shuffle 99_990..100_050);\n\nmy $actualMax = max @prices;\nprint \"Using $numPrices items with prices from 0 to $actualMax:\\n\";\n\nmy @results = getAll5000(0, $actualMax, 5000, @prices);\nprint \"Split into \" . @results . \" bins of approx 5000 elements:\\n\";\n\nfor my $row (@results) {\n   my ($min,$max,$subtotal) = @$row;\n   $max = $actualMax if $max > $actualMax;\n   printf \"  From %6d to %6d with %4d items\\n\", $min, $max, $subtotal\n}\n", "target": "import random\n\n\nprice_list_size = random.choice(range(99_000, 101_000))\nprice_list = random.choices(range(100_000), k=price_list_size)\n\ndelta_price = 1     \n\n\ndef get_prange_count(startp, endp):\n    return len([r for r in price_list if startp <= r <= endp])\n\ndef get_max_price():\n    return max(price_list)\n\n\ndef get_5k(mn=0, mx=get_max_price(), num=5_000):\n    \"Binary search for num items between mn and mx, adjusting mx\"\n    count = get_prange_count(mn, mx)\n    delta_mx = (mx - mn) / 2\n    while count != num and delta_mx >= delta_price / 2:\n        mx += -delta_mx if count > num else +delta_mx\n        mx = mx // 1    \n        count, delta_mx = get_prange_count(mn, mx), delta_mx / 2\n    return mx, count\n\ndef get_all_5k(mn=0, mx=get_max_price(), num=5_000):\n    \"Get all non-overlapping ranges\"\n    partmax, partcount = get_5k(mn, mx, num)\n    result = [(mn, partmax, partcount)]\n    while partmax < mx:\n        partmin = partmax + delta_price \n        partmax, partcount = get_5k(partmin, mx, num)\n        assert partcount > 0, \\\n            f\"price_list from {partmin} with too many of the same price\"\n        result.append((partmin, partmax, partcount))\n    return result\n\nif __name__ == '__main__':\n    print(f\"Using {price_list_size} random prices from 0 to {get_max_price()}\")\n    result = get_all_5k()\n    print(f\"Splits into {len(result)} bins of approx 5000 elements\")\n    for mn, mx, count in result:\n        print(f\"  From {mn:8.1f} ... {mx:8.1f} with {count} items.\")\n\n    if len(price_list) != sum(count for mn, mx, count in result):\n        print(\"\\nWhoops! Some items missing:\")\n"}
{"id": 383629, "name": "Checksumcolor", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Term::ANSIColor qw<colored :constants256>;\n\nwhile (<>) {\n    my($cs,$fn) = /(^\\S+)\\s+(.*)/;\n    print colored($_, 'ansi' . hex $_) for $cs =~ /(..)/g;\n    print \" $fn\\n\";\n}\n", "target": "\n\n\nfrom __future__ import unicode_literals\n\nimport argparse\nimport fileinput\nimport os\nimport sys\n\nfrom functools import partial\nfrom itertools import count\nfrom itertools import takewhile\n\n\nANSI_RESET = \"\\u001b[0m\"\n\nRED = (255, 0, 0)\nGREEN = (0, 255, 0)\nYELLOW = (255, 255, 0)\nBLUE = (0, 0, 255)\nMAGENTA = (255, 0, 255)\nCYAN = (0, 255, 255)\n\nANSI_PALETTE = {\n    RED: \"\\u001b[31m\",\n    GREEN: \"\\u001b[32m\",\n    YELLOW: \"\\u001b[33m\",\n    BLUE: \"\\u001b[34m\",\n    MAGENTA: \"\\u001b[35m\",\n    CYAN: \"\\u001b[36m\",\n}\n\n\n\n_8BIT_PALETTE = {\n    (0xAF, 0x00, 0x00): \"\\u001b[38;5;124m\",\n    (0xAF, 0x00, 0x5F): \"\\u001b[38;5;125m\",\n    (0xAF, 0x00, 0x87): \"\\u001b[38;5;126m\",\n    (0xAF, 0x00, 0xAF): \"\\u001b[38;5;127m\",\n    (0xAF, 0x00, 0xD7): \"\\u001b[38;5;128m\",\n    (0xAF, 0x00, 0xFF): \"\\u001b[38;5;129m\",\n    (0xAF, 0x5F, 0x00): \"\\u001b[38;5;130m\",\n    (0xAF, 0x5F, 0x5F): \"\\u001b[38;5;131m\",\n    (0xAF, 0x5F, 0x87): \"\\u001b[38;5;132m\",\n    (0xAF, 0x5F, 0xAF): \"\\u001b[38;5;133m\",\n    (0xAF, 0x5F, 0xD7): \"\\u001b[38;5;134m\",\n    (0xAF, 0x5F, 0xFF): \"\\u001b[38;5;135m\",\n    (0xAF, 0x87, 0x00): \"\\u001b[38;5;136m\",\n    (0xAF, 0x87, 0x5F): \"\\u001b[38;5;137m\",\n    (0xAF, 0x87, 0x87): \"\\u001b[38;5;138m\",\n    (0xAF, 0x87, 0xAF): \"\\u001b[38;5;139m\",\n    (0xAF, 0x87, 0xD7): \"\\u001b[38;5;140m\",\n    (0xAF, 0x87, 0xFF): \"\\u001b[38;5;141m\",\n    (0xAF, 0xAF, 0x00): \"\\u001b[38;5;142m\",\n    (0xAF, 0xAF, 0x5F): \"\\u001b[38;5;143m\",\n    (0xAF, 0xAF, 0x87): \"\\u001b[38;5;144m\",\n    (0xAF, 0xAF, 0xAF): \"\\u001b[38;5;145m\",\n    (0xAF, 0xAF, 0xD7): \"\\u001b[38;5;146m\",\n    (0xAF, 0xAF, 0xFF): \"\\u001b[38;5;147m\",\n    (0xAF, 0xD7, 0x00): \"\\u001b[38;5;148m\",\n    (0xAF, 0xD7, 0x5F): \"\\u001b[38;5;149m\",\n    (0xAF, 0xD7, 0x87): \"\\u001b[38;5;150m\",\n    (0xAF, 0xD7, 0xAF): \"\\u001b[38;5;151m\",\n    (0xAF, 0xD7, 0xD7): \"\\u001b[38;5;152m\",\n    (0xAF, 0xD7, 0xFF): \"\\u001b[38;5;153m\",\n    (0xAF, 0xFF, 0x00): \"\\u001b[38;5;154m\",\n    (0xAF, 0xFF, 0x5F): \"\\u001b[38;5;155m\",\n    (0xAF, 0xFF, 0x87): \"\\u001b[38;5;156m\",\n    (0xAF, 0xFF, 0xAF): \"\\u001b[38;5;157m\",\n    (0xAF, 0xFF, 0xD7): \"\\u001b[38;5;158m\",\n    (0xAF, 0xFF, 0xFF): \"\\u001b[38;5;159m\",\n}\n\n\ndef error(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(os.linesep)\n    sys.exit(1)\n\n\ndef rgb(group):\n    \n    nibbles_per_channel = len(group) // 3\n    max_val = 16 ** nibbles_per_channel - 1\n    nibbles = chunked(group, nibbles_per_channel)\n\n    \n    return tuple((int(n, 16) * 255) // max_val for n in nibbles)\n\n\ndef distance(color, other):\n    \n    return sum((o - s) ** 2 for s, o in zip(color, other))\n\n\ndef chunked(seq, n):\n    \n    return takewhile(len, (seq[i : i + n] for i in count(0, n)))\n\n\ndef escape(group, palette):\n    \n    key = partial(distance, other=rgb(group.ljust(3, \"0\")))\n    ansi_color = min(palette, key=key)\n    return \"\".join([palette[ansi_color], group, ANSI_RESET])\n\n\ndef colorize(line, group_size=3, palette=ANSI_PALETTE):\n    \n    checksum, filename = line.split(None, 1)\n    escaped = [escape(group, palette) for group in chunked(checksum, group_size)]\n    sys.stdout.write(\"  \".join([\"\".join(escaped), filename]))\n\n\ndef html_colorize(checksum, group_size=3, palette=ANSI_PALETTE):\n    \n\n    def span(group):\n        key = partial(distance, other=rgb(group.ljust(3, \"0\")))\n        ansi_color = min(palette, key=key)\n        int_val = int.from_bytes(ansi_color, byteorder=\"big\")\n        hex_val = hex(int_val)[2:].rjust(6, \"0\")\n        return '<span style=\"color:\n\n    checksum, filename = line.split(None, 1)\n    escaped = [span(group) for group in chunked(checksum, group_size)]\n    sys.stdout.write(\"  \".join([\"\".join(escaped), filename]))\n\n\nif __name__ == \"__main__\":\n    \n    parser = argparse.ArgumentParser(description=\"Color checksum.\")\n\n    parser.add_argument(\n        \"-n\",\n        type=int,\n        default=3,\n        help=\"Color the checksum in groups of size N. Defaults to 3.\",\n    )\n\n    parser.add_argument(\n        \"-e\",\n        \"--extended-palette\",\n        action=\"store_true\",\n        help=\"Use the extended 8-bit palette. Defaults to False.\",\n    )\n\n    parser.add_argument(\n        \"--html\",\n        action=\"store_true\",\n        help=\"Output checksum groups wrapped with 'span' tags instead of ANSI escape sequences.\",\n    )\n\n    parser.add_argument(\"files\", nargs=\"*\", default=\"-\", metavar=\"FILE\")\n\n    args = parser.parse_args()\n\n    if sys.stdout.isatty():\n\n        palette = ANSI_PALETTE\n        if args.extended_palette:\n            palette = _8BIT_PALETTE\n\n        colorize_func = colorize\n        if args.html:\n            colorize_func = html_colorize\n\n        for line in fileinput.input(files=args.files):\n            colorize_func(line, group_size=args.n, palette=palette)\n    else:\n        \n        for line in fileinput.input(files=args.files):\n            sys.stdout.write(line)\n"}
{"id": 383630, "name": "Run as a daemon or service", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse IO::Handle;\nuse File::Temp qw/ tempfile tempdir /;\n\nmy ($fh, $tempfile) = tempfile();\nmy $count = 0;\n\nopen $fh, '>', $tempfile or die;\n\nprint \"\\n\\nOutput goes to $tempfile\\n\";\n\nwhile (1) {\n   sleep 1;\n   print $fh \"Sheep number \",$count++,\" just leaped over the fence ..\\n\";\n   $fh->flush();\n}\n", "target": "\nimport posix\nimport os\nimport sys\n\npid = posix.fork()\nif pid != 0:\n    print(\"Child process detached with pid %s\" % pid)\n    sys.exit(0)\n\nold_stdin = sys.stdin\nold_stdout = sys.stdout\nold_stderr = sys.stderr\n\nsys.stdin = open('/dev/null', 'rt')\nsys.stdout = open('/tmp/dmn.log', 'wt')\nsys.stderr = sys.stdout\n\nold_stdin.close()\nold_stdout.close()\nold_stderr.close()\n\nposix.setsid()\n\nimport time\nt = time.time()\nwhile time.time() < t + 10:\n    print(\"timer running, %s seconds\" % str(time.time() - t))\n    time.sleep(1)\n"}
{"id": 383631, "name": "Run as a daemon or service", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse IO::Handle;\nuse File::Temp qw/ tempfile tempdir /;\n\nmy ($fh, $tempfile) = tempfile();\nmy $count = 0;\n\nopen $fh, '>', $tempfile or die;\n\nprint \"\\n\\nOutput goes to $tempfile\\n\";\n\nwhile (1) {\n   sleep 1;\n   print $fh \"Sheep number \",$count++,\" just leaped over the fence ..\\n\";\n   $fh->flush();\n}\n", "target": "\nimport posix\nimport os\nimport sys\n\npid = posix.fork()\nif pid != 0:\n    print(\"Child process detached with pid %s\" % pid)\n    sys.exit(0)\n\nold_stdin = sys.stdin\nold_stdout = sys.stdout\nold_stderr = sys.stderr\n\nsys.stdin = open('/dev/null', 'rt')\nsys.stdout = open('/tmp/dmn.log', 'wt')\nsys.stderr = sys.stdout\n\nold_stdin.close()\nold_stdout.close()\nold_stderr.close()\n\nposix.setsid()\n\nimport time\nt = time.time()\nwhile time.time() < t + 10:\n    print(\"timer running, %s seconds\" % str(time.time() - t))\n    time.sleep(1)\n"}
{"id": 383632, "name": "Hexapawn", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( max each_array reduce shuffle );\nuse Tk;\n\nmy @argv = @ARGV;\nmy $size = max 3, shift // 3;\nmy $train = shift // 1e3;\nmy $forward = qr/.{$size}/s;\nmy $take = qr/.{@{[$size - 1]}}(?:..)?/s;\nmy $message = 'Click on Pawn';\nmy (@played, %scores, $from, $active);\nmy $board = my $start = \"b\\n-\\nw\\n\" =~\n  s/-\\n/$& x ($size - 2)/er =~ s/./$& x $size/ger;\n\nmy $mw = MainWindow->new;\n$mw->geometry( '+600+300' );\n$mw->title( 'RosettaCode Hexapawn' );\nmy $grid = $mw->Frame->pack;\nmy @squares = map {\n  my $row = $_;\n  map {\n    my $col = $_;\n    my $g = $grid->Canvas( -width => 100, -height => 100,\n      -bd => 0, -relief => 'flat', -highlightthickness => 0,\n      -bg => ($row+$col) % 2 ? 'gray80' : 'gray60',\n      )->grid( -row => $row, -column => $col, -sticky => 'nsew' );\n    $g->Tk::bind('<1>' => sub{ click( $col, $row ) } );\n    $g->Tk::bind(\"<ButtonRelease-$_>\" => sub{$g->yviewMoveto(0)} ) for 4, 5;\n    $g } 0 .. $size - 1\n  } 0 .. $size - 1;\nmy $label = $mw->Label( -textvariable => \\$message,\n  )->pack( -side => 'bottom', -expand => 1, -fill => 'both' );\n$mw->Button(-text => 'Exit', -command => sub {$mw->destroy},\n  )->pack( -side => 'right', -fill => 'x', -expand => 0 );\n$mw->Button(-text => 'New Game', -command => \\&newgame,\n  )->pack( -side => 'right', -fill => 'x', -expand => 1 );\n$mw->Button(-text => 'Train', -command => \\&train,\n  )->pack( -side => 'right', -fill => 'x', -expand => 0 );\nnewgame();\nMainLoop;\n-M $0 < 0 and exec \"$0 @argv\";\n\nsub findwhite\n  {\n  my @moves;\n  $board =~ /(?:-($forward)w|b($take)w)(?{ push @moves, \"$`w$+-$'\"; })(*FAIL)/;\n  @moves;\n  }\n\nsub findblack\n  {\n  my @moves;\n  $board =~ /(?:b($forward)-|b($take)w)(?{ push @moves, \"$`-$+b$'\"; })(*FAIL)/;\n  @moves;\n  }\n\nsub newgame\n  {\n  $board = $start;\n  @played = ();\n  $from = undef;\n  $active = 1;\n  $message = 'Click on Pawn';\n  $label->configure( -bg => 'gray85' );\n  show();\n  }\n\nsub train\n  {\n  $message = 'Training';\n  $label->configure( -bg => 'yellow' );\n  $mw->update;\n  for ( 1 .. $train )\n    {\n    $board = $start;\n    my @whitemoves = findwhite;\n    my @blackmoves;\n    @played = ();\n    while( 1 )\n      {\n      $board = $whitemoves[rand @whitemoves];;\n      if( $board =~ /^.*w/ or not (@blackmoves = findblack) )\n        {\n        $scores{$_}++ for map {$_, s/.+/ reverse $& /ger } @played;\n        last;\n        }\n      push @played, $board = $blackmoves[rand @blackmoves];\n      if( $board =~ /b.*$/ or not (@whitemoves = findwhite) )\n        {\n        $scores{$_}-- for map {$_, s/.+/ reverse $& /ger } @played;\n        last;\n        }\n      }\n    }\n  print \"score count: @{[ scalar keys %scores ]}\\n\";\n  newgame();\n  }\n\nsub scale { map 100 * $_ >> 3, @_ };\n\nsub show\n  {\n  my $ea = each_array(@{[ $board =~ /./g ]}, @squares );\n  while( my ($piece, $canvas) = $ea->() )\n    {\n    $canvas->delete('all');\n    $piece eq '-' and next;\n    $canvas->createOval(scale(3, 3, 5, 5));\n    $canvas->createArc(scale(2, 4.8, 6, 9), -start => 0, -extent => 180);\n    $canvas->itemconfigure('all', -outline => undef,\n      -fill => $piece eq 'w' ? 'white' : 'black');\n    }\n  }\n\nsub click\n  {\n  my ($col, $row) = @_;\n  $active or return;\n  my $pos = $row * ($size + 1) + $col;\n  if( 'w' eq substr $board, $pos, 1 )\n    {\n    $from = $pos;\n    $message = 'Click on Destination';\n    }\n  elsif( defined $from )\n    {\n    my $new = $board;\n    substr $new, $from, 1, '-';\n    substr $new, $pos, 1, 'w';\n    if( grep $_ eq $new, findwhite )\n      {\n      $board = $new;\n      my @blackmoves = findblack;\n      if( $board =~ /^.*w/ or @blackmoves == 0 )\n        {\n        $active = 0;\n        $message = 'White Wins';\n        $label->configure( -bg => 'green' );\n        $scores{$_}++ for map {$_, s/.+/ reverse $& /ger } @played;\n        }\n      else\n        {\n        $from = undef;\n        $message = 'Blacks Move';\n        push @played, $board = reduce\n          { ($scores{$a} // 0) < ($scores{$b} // 0) ? $a : $b }\n          shuffle @blackmoves;\n        if( $board =~ /b.*$/ or not findwhite )\n          {\n          $active = 0;\n          $message = 'Black Wins';\n          $label->configure( -bg => 'red' );\n          $scores{$_}-- for map {$_, s/.+/ reverse $& /ger } @played;\n          }\n        else\n          {\n          $message = 'Click on Pawn';\n          }\n        }\n      show;\n      }\n    else\n      {\n      $mw->bell;\n      $message = 'Invalid move';\n      $mw->after( 500 => sub { $message = 'Click on Destination' } );\n      }\n    }\n  }\n", "target": "\nimport sys\n\nblack_pawn = \" \\u265f  \"\nwhite_pawn = \" \\u2659  \"\nempty_square = \"    \"\n\n\ndef draw_board(board_data):\n    \n    bg_black = \"\\u001b[48;5;237m\"\n    \n    bg_white = \"\\u001b[48;5;245m\"\n\n    clear_to_eol = \"\\u001b[0m\\u001b[K\\n\"\n\n    board = [\"1 \", bg_black, board_data[0][0], bg_white, board_data[0][1], bg_black, board_data[0][2], clear_to_eol,\n             \"2 \", bg_white, board_data[1][0], bg_black, board_data[1][1], bg_white, board_data[1][2], clear_to_eol,\n             \"3 \", bg_black, board_data[2][0], bg_white, board_data[2][1], bg_black, board_data[2][2], clear_to_eol,\n             \"   A   B   C\\n\"];\n\n    sys.stdout.write(\"\".join(board))\n\ndef get_movement_direction(colour):\n    direction = -1\n    if colour == black_pawn:\n        direction = 1\n    elif colour == white_pawn:\n        direction = -1\n    else:\n        raise ValueError(\"Invalid piece colour\")\n\n    return direction\n\ndef get_other_colour(colour):\n    if colour == black_pawn:\n        return white_pawn\n    elif colour == white_pawn:\n        return black_pawn\n    else:\n        raise ValueError(\"Invalid piece colour\")\n\ndef get_allowed_moves(board_data, row, col):\n    if board_data[row][col] == empty_square:\n        return set()\n\n    colour = board_data[row][col]\n    other_colour = get_other_colour(colour)\n    direction = get_movement_direction(colour)\n\n    if (row + direction < 0 or row + direction > 2):\n        return set()\n\n    allowed_moves = set()\n    if board_data[row + direction][col] == empty_square:\n        allowed_moves.add('f')\n    if col > 0 and board_data[row + direction][col - 1] == other_colour:\n        allowed_moves.add('dl')\n    if col < 2 and board_data[row + direction][col + 1] == other_colour:\n        allowed_moves.add('dr')\n\n    return allowed_moves\n\ndef get_human_move(board_data, colour):\n    \n    direction = get_movement_direction(colour)\n\n    while True:\n        piece_posn = input(f'What {colour} do you want to move? ')\n        valid_inputs = {'a1': (0,0), 'b1': (0,1), 'c1': (0,2),\n                        'a2': (1,0), 'b2': (1,1), 'c2': (1,2),\n                        'a3': (2,0), 'b3': (2,1), 'c3': (2,2)}\n        if piece_posn not in valid_inputs:\n            print(\"LOL that's not a valid position! Try again.\")\n            continue\n\n        (row, col) = valid_inputs[piece_posn]\n        piece = board_data[row][col]\n        if piece == empty_square:\n            print(\"What are you trying to pull, there's no piece in that space!\")\n            continue\n\n        if piece != colour:\n            print(\"LOL that's not your piece, try again!\")\n            continue\n\n        allowed_moves = get_allowed_moves(board_data, row, col)\n\n        if len(allowed_moves) == 0:\n            print('LOL nice try. That piece has no valid moves.')\n            continue\n\n        move = list(allowed_moves)[0]\n        if len(allowed_moves) > 1:\n            move = input(f'What move do you want to make ({\",\".join(list(allowed_moves))})? ')\n            if move not in allowed_moves:\n                print('LOL that move is not allowed. Try again.')\n                continue\n\n        if move == 'f':\n            board_data[row + direction][col] = board_data[row][col]\n        elif move == 'dl':\n            board_data[row + direction][col - 1] = board_data[row][col]\n        elif move == 'dr':\n            board_data[row + direction][col + 1] = board_data[row][col]\n\n        board_data[row][col] = empty_square\n        return board_data\n\n\ndef is_game_over(board_data):\n    if board_data[0][0] == white_pawn or board_data[0][1] == white_pawn or board_data[0][2] == white_pawn:\n        return white_pawn\n\n    if board_data[2][0] == black_pawn or board_data[2][1] == black_pawn or board_data[2][2] == black_pawn:\n        return black_pawn\n\n    white_count = 0\n    black_count = 0\n    black_allowed_moves = []\n    white_allowed_moves = []\n    for i in range(3):\n        for j in range(3):\n            moves = get_allowed_moves(board_data, i, j)\n\n            if board_data[i][j] == white_pawn:\n                white_count += 1\n                if len(moves) > 0:\n                    white_allowed_moves.append((i,j,moves))\n            if board_data[i][j] == black_pawn:\n                black_count += 1\n                if len(moves) > 0:\n                    black_allowed_moves.append((i,j,moves))\n\n    if white_count == 0 or len(white_allowed_moves) == 0:\n        return black_pawn\n    if black_count == 0 or len(black_allowed_moves) == 0:\n        return white_pawn\n\n    return \"LOL NOPE\"\n\ndef play_game(black_move, white_move):\n\n    board_data = [[black_pawn, black_pawn, black_pawn],\n                  [empty_square, empty_square, empty_square],\n                  [white_pawn, white_pawn, white_pawn]]\n\n    last_player = black_pawn\n    next_player = white_pawn\n    while is_game_over(board_data) == \"LOL NOPE\":\n        draw_board(board_data)\n\n        if (next_player == black_pawn):\n            board_data = black_move(board_data, next_player)\n        else:\n            board_data = white_move(board_data, next_player)\n\n        temp = last_player\n        last_player = next_player\n        next_player = temp\n\n    winner = is_game_over(board_data)\n    print(f'Congratulations {winner}!')\n\nplay_game(get_human_move, get_human_move)\n"}
{"id": 400267, "name": "Nonoblock", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"\\n$_\", tr/\\n/=/cr;\n  my ($cells, @blocks) = split;\n  my $letter = 'A';\n  $_ = join '.', map { $letter++ x $_ } @blocks;\n  $cells < length and print(\"no solution\\n\"), next;\n  $_ .= '.' x ($cells - length) . \"\\n\";\n  1 while print, s/^(\\.*)\\b(.*?)\\b(\\w+)\\.\\B/$2$1.$3/;\n  }\n\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\npublic static class Nonoblock\n{\n    public static void Main() {\n        Positions(5, 2,1);\n        Positions(5);\n        Positions(10, 8);\n        Positions(15, 2,3,2,3);\n        Positions(5, 2,3);\n    }\n\n    public static void Positions(int cells, params int[] blocks) {\n        if (cells < 0 || blocks == null || blocks.Any(b => b < 1)) throw new ArgumentOutOfRangeException();\n        Console.WriteLine($\"{cells} cells with [{string.Join(\", \", blocks)}]\");\n        if (blocks.Sum() + blocks.Length - 1 > cells) {\n            Console.WriteLine(\"No solution\");\n            return;\n        }\n        var spaces = new int[blocks.Length + 1];\n        int total = -1;\n        for (int i = 0; i < blocks.Length; i++) {\n            total += blocks[i] + 1;\n            spaces[i+1] = total;\n        }\n        spaces[spaces.Length - 1] = cells - 1;\n        var sb = new StringBuilder(string.Join(\".\", blocks.Select(b => new string('#', b))).PadRight(cells, '.'));\n        Iterate(sb, spaces, spaces.Length - 1, 0);\n        Console.WriteLine();\n    }\n\n    private static void Iterate(StringBuilder output, int[] spaces, int index, int offset) {\n        Console.WriteLine(output.ToString());\n        if (index <= 0) return;\n        int count = 0;\n        while (output[spaces[index] - offset] != '#') {\n            count++;\n            output.Remove(spaces[index], 1);\n            output.Insert(spaces[index-1], '.');\n            spaces[index-1]++;\n            Iterate(output, spaces, index - 1, 1);\n        }\n        if (offset == 0) return;\n        spaces[index-1] -= count;\n        output.Remove(spaces[index-1], count);\n        output.Insert(spaces[index] - count, \".\", count);\n    }\n\n}\n"}
{"id": 400268, "name": "Nonoblock", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"\\n$_\", tr/\\n/=/cr;\n  my ($cells, @blocks) = split;\n  my $letter = 'A';\n  $_ = join '.', map { $letter++ x $_ } @blocks;\n  $cells < length and print(\"no solution\\n\"), next;\n  $_ .= '.' x ($cells - length) . \"\\n\";\n  1 while print, s/^(\\.*)\\b(.*?)\\b(\\w+)\\.\\B/$2$1.$3/;\n  }\n\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\npublic static class Nonoblock\n{\n    public static void Main() {\n        Positions(5, 2,1);\n        Positions(5);\n        Positions(10, 8);\n        Positions(15, 2,3,2,3);\n        Positions(5, 2,3);\n    }\n\n    public static void Positions(int cells, params int[] blocks) {\n        if (cells < 0 || blocks == null || blocks.Any(b => b < 1)) throw new ArgumentOutOfRangeException();\n        Console.WriteLine($\"{cells} cells with [{string.Join(\", \", blocks)}]\");\n        if (blocks.Sum() + blocks.Length - 1 > cells) {\n            Console.WriteLine(\"No solution\");\n            return;\n        }\n        var spaces = new int[blocks.Length + 1];\n        int total = -1;\n        for (int i = 0; i < blocks.Length; i++) {\n            total += blocks[i] + 1;\n            spaces[i+1] = total;\n        }\n        spaces[spaces.Length - 1] = cells - 1;\n        var sb = new StringBuilder(string.Join(\".\", blocks.Select(b => new string('#', b))).PadRight(cells, '.'));\n        Iterate(sb, spaces, spaces.Length - 1, 0);\n        Console.WriteLine();\n    }\n\n    private static void Iterate(StringBuilder output, int[] spaces, int index, int offset) {\n        Console.WriteLine(output.ToString());\n        if (index <= 0) return;\n        int count = 0;\n        while (output[spaces[index] - offset] != '#') {\n            count++;\n            output.Remove(spaces[index], 1);\n            output.Insert(spaces[index-1], '.');\n            spaces[index-1]++;\n            Iterate(output, spaces, index - 1, 1);\n        }\n        if (offset == 0) return;\n        spaces[index-1] -= count;\n        output.Remove(spaces[index-1], count);\n        output.Insert(spaces[index] - count, \".\", count);\n    }\n\n}\n"}
{"id": 400269, "name": "Eban numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse Lingua::EN::Numbers qw(num2en);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub e_ban {\n    my($power) = @_;\n    my @n;\n    for (1..10**$power) {\n        next unless 0 == $_%2;\n        next if $_ =~ /[789]/ or /[12].$/ or /[135]..$/ or /[135]...$/ or /[135].....$/;\n        push @n, $_ unless num2en($_) =~ /e/;\n    }\n    @n;\n}\n\nmy @OK = e_ban(my $max = 7);\n\nmy @a = grep { $_ <= 1000 } @OK;\nsay \"Number of eban numbers up to and including 1000: @{[1+$\nsay join(', ',@a);\nsay '';\n\nmy @b = grep { $_ >= 1000 && $_ <= 4000 } @OK;\nsay \"Number of eban numbers between 1000 and 4000 (inclusive): @{[1+$\nsay join(', ',@b);\nsay '';\n\nfor my $exp (4..$max) {\n    my $n = + grep { $_ <= 10**$exp } @OK;\n    printf \"Number of eban numbers and %10s: %d\\n\", comma(10**$exp), $n;\n}\n", "target": "using System;\n\nnamespace EbanNumbers {\n    struct Interval {\n        public int start, end;\n        public bool print;\n\n        public Interval(int start, int end, bool print) {\n            this.start = start;\n            this.end = end;\n            this.print = print;\n        }\n    }\n\n    class Program {\n        static void Main() {\n            Interval[] intervals = {\n                new Interval(2, 1_000, true),\n                new Interval(1_000, 4_000, true),\n                new Interval(2, 10_000, false),\n                new Interval(2, 100_000, false),\n                new Interval(2, 1_000_000, false),\n                new Interval(2, 10_000_000, false),\n                new Interval(2, 100_000_000, false),\n                new Interval(2, 1_000_000_000, false),\n            };\n            foreach (var intv in intervals) {\n                if (intv.start == 2) {\n                    Console.WriteLine(\"eban numbers up to and including {0}:\", intv.end);\n                } else {\n                    Console.WriteLine(\"eban numbers between {0} and {1} (inclusive):\", intv.start, intv.end);\n                }\n\n                int count = 0;\n                for (int i = intv.start; i <= intv.end; i += 2) {\n                    int b = i / 1_000_000_000;\n                    int r = i % 1_000_000_000;\n                    int m = r / 1_000_000;\n                    r = i % 1_000_000;\n                    int t = r / 1_000;\n                    r %= 1_000;\n                    if (m >= 30 && m <= 66) m %= 10;\n                    if (t >= 30 && t <= 66) t %= 10;\n                    if (r >= 30 && r <= 66) r %= 10;\n                    if (b == 0 || b == 2 || b == 4 || b == 6) {\n                        if (m == 0 || m == 2 || m == 4 || m == 6) {\n                            if (t == 0 || t == 2 || t == 4 || t == 6) {\n                                if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                    if (intv.print) Console.Write(\"{0} \", i);\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (intv.print) {\n                    Console.WriteLine();\n                }\n                Console.WriteLine(\"count = {0}\\n\", count);\n            }\n        }\n    }\n}\n"}
{"id": 400270, "name": "Eban numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse Lingua::EN::Numbers qw(num2en);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub e_ban {\n    my($power) = @_;\n    my @n;\n    for (1..10**$power) {\n        next unless 0 == $_%2;\n        next if $_ =~ /[789]/ or /[12].$/ or /[135]..$/ or /[135]...$/ or /[135].....$/;\n        push @n, $_ unless num2en($_) =~ /e/;\n    }\n    @n;\n}\n\nmy @OK = e_ban(my $max = 7);\n\nmy @a = grep { $_ <= 1000 } @OK;\nsay \"Number of eban numbers up to and including 1000: @{[1+$\nsay join(', ',@a);\nsay '';\n\nmy @b = grep { $_ >= 1000 && $_ <= 4000 } @OK;\nsay \"Number of eban numbers between 1000 and 4000 (inclusive): @{[1+$\nsay join(', ',@b);\nsay '';\n\nfor my $exp (4..$max) {\n    my $n = + grep { $_ <= 10**$exp } @OK;\n    printf \"Number of eban numbers and %10s: %d\\n\", comma(10**$exp), $n;\n}\n", "target": "using System;\n\nnamespace EbanNumbers {\n    struct Interval {\n        public int start, end;\n        public bool print;\n\n        public Interval(int start, int end, bool print) {\n            this.start = start;\n            this.end = end;\n            this.print = print;\n        }\n    }\n\n    class Program {\n        static void Main() {\n            Interval[] intervals = {\n                new Interval(2, 1_000, true),\n                new Interval(1_000, 4_000, true),\n                new Interval(2, 10_000, false),\n                new Interval(2, 100_000, false),\n                new Interval(2, 1_000_000, false),\n                new Interval(2, 10_000_000, false),\n                new Interval(2, 100_000_000, false),\n                new Interval(2, 1_000_000_000, false),\n            };\n            foreach (var intv in intervals) {\n                if (intv.start == 2) {\n                    Console.WriteLine(\"eban numbers up to and including {0}:\", intv.end);\n                } else {\n                    Console.WriteLine(\"eban numbers between {0} and {1} (inclusive):\", intv.start, intv.end);\n                }\n\n                int count = 0;\n                for (int i = intv.start; i <= intv.end; i += 2) {\n                    int b = i / 1_000_000_000;\n                    int r = i % 1_000_000_000;\n                    int m = r / 1_000_000;\n                    r = i % 1_000_000;\n                    int t = r / 1_000;\n                    r %= 1_000;\n                    if (m >= 30 && m <= 66) m %= 10;\n                    if (t >= 30 && t <= 66) t %= 10;\n                    if (r >= 30 && r <= 66) r %= 10;\n                    if (b == 0 || b == 2 || b == 4 || b == 6) {\n                        if (m == 0 || m == 2 || m == 4 || m == 6) {\n                            if (t == 0 || t == 2 || t == 4 || t == 6) {\n                                if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                    if (intv.print) Console.Write(\"{0} \", i);\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (intv.print) {\n                    Console.WriteLine();\n                }\n                Console.WriteLine(\"count = {0}\\n\", count);\n            }\n        }\n    }\n}\n"}
{"id": 400271, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Perl to C#: use bigint;\n\nfor $sailors (1..15) { check( $sailors, coconuts( 0+$sailors ) ) }\n\nsub is_valid {\n    my($sailors, $nuts) = @_;\n    return 0, 0 if $sailors == 1 and $nuts == 1;\n    my @shares;\n    for (1..$sailors) {\n        return () unless ($nuts % $sailors) == 1;\n        push @shares, int ($nuts-1)/$sailors;\n        $nuts -= (1 + int $nuts/$sailors);\n    }\n    push @shares, int $nuts/$sailors;\n    return @shares if !($nuts % $sailors);\n}\n\nsub check {\n    my($sailors, $coconuts) = @_;\n    my @suffix = ('th', 'st', 'nd', 'rd', ('th') x 6, ('th') x 10);\n    my @piles = is_valid($sailors, $coconuts);\n    if (@piles) {\n        print \"\\nSailors $sailors: Coconuts $coconuts:\\n\";\n        for my $k (0..-1 + $\n             print $k+1 . $suffix[$k+1] . \" takes \" . $piles[$k] . \", gives 1 to the monkey.\\n\"\n        }\n        print \"The next morning, each sailor takes \" . $piles[-1] . \"\\nwith none left over for the monkey.\\n\";\n        return 1\n    }\n    return 0\n}\n\nsub coconuts {\n    my($sailors) = @_;\n    if ($sailors % 2 == 0 ) { ($sailors ** $sailors - 1) * ($sailors - 1) }\n    else                    {  $sailors ** $sailors      -  $sailors + 1  }\n}\n", "target": "class Test\n{\n    static bool valid(int n, int nuts)\n    {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n        {\n            if (nuts % n != 1)\n            {\n                return false;\n            }                \n        }\n            \n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    static void Main(string[] args)\n    {\n        int x = 0;\n        for (int n = 2; n < 10; n++)\n        {\n            while (!valid(n, x))\n                x++;\n            System.Console.WriteLine(n + \": \" + x);\n        }\n    }\n}\n"}
{"id": 400272, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Perl to C#: use bigint;\n\nfor $sailors (1..15) { check( $sailors, coconuts( 0+$sailors ) ) }\n\nsub is_valid {\n    my($sailors, $nuts) = @_;\n    return 0, 0 if $sailors == 1 and $nuts == 1;\n    my @shares;\n    for (1..$sailors) {\n        return () unless ($nuts % $sailors) == 1;\n        push @shares, int ($nuts-1)/$sailors;\n        $nuts -= (1 + int $nuts/$sailors);\n    }\n    push @shares, int $nuts/$sailors;\n    return @shares if !($nuts % $sailors);\n}\n\nsub check {\n    my($sailors, $coconuts) = @_;\n    my @suffix = ('th', 'st', 'nd', 'rd', ('th') x 6, ('th') x 10);\n    my @piles = is_valid($sailors, $coconuts);\n    if (@piles) {\n        print \"\\nSailors $sailors: Coconuts $coconuts:\\n\";\n        for my $k (0..-1 + $\n             print $k+1 . $suffix[$k+1] . \" takes \" . $piles[$k] . \", gives 1 to the monkey.\\n\"\n        }\n        print \"The next morning, each sailor takes \" . $piles[-1] . \"\\nwith none left over for the monkey.\\n\";\n        return 1\n    }\n    return 0\n}\n\nsub coconuts {\n    my($sailors) = @_;\n    if ($sailors % 2 == 0 ) { ($sailors ** $sailors - 1) * ($sailors - 1) }\n    else                    {  $sailors ** $sailors      -  $sailors + 1  }\n}\n", "target": "class Test\n{\n    static bool valid(int n, int nuts)\n    {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n        {\n            if (nuts % n != 1)\n            {\n                return false;\n            }                \n        }\n            \n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    static void Main(string[] args)\n    {\n        int x = 0;\n        for (int n = 2; n < 10; n++)\n        {\n            while (!valid(n, x))\n                x++;\n            System.Console.WriteLine(n + \": \" + x);\n        }\n    }\n}\n"}
{"id": 400273, "name": "Polyspiral", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse Tk;\nuse List::Util qw( min );\n\nmy $size = 500;\nmy ($width, $height, $x, $y, $dist);\nmy $angleinc = 0;\nmy $active = 0;\nmy $wait = 1000 / 30;\nmy $radian = 90 / atan2 1, 0;\n\nmy $mw = MainWindow->new;\n$mw->title( 'Polyspiral' );\nmy $c = $mw->Canvas( -width => $size, -height => $size,\n  -relief => 'raised', -borderwidth => 2,\n  )->pack(-fill => 'both', -expand => 1);\n$mw->bind('<Configure>' => sub { $width = $c->width; $height = $c->height;\n  $dist = min($width, $height) ** 2 / 4 } );\n$mw->Button(-text => $_->[0], -command => $_->[1],\n  )->pack(-side => 'right') for\n  [ Exit => sub {$mw->destroy} ],\n  [ 'Start / Pause' => sub { $active ^= 1; step() } ];\n\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub step\n  {\n  $active or return;\n  my @pts = ($x = $width >> 1, $y = $height >> 1);\n  my $length = 5;\n  my $angle = $angleinc;\n  $angleinc += 0.05 / $radian;\n  while( ($x - $width / 2)**2 + ($y - $height / 2)**2 < $dist && @pts < 300 )\n    {\n    push @pts, $x, $y;\n    $x += $length * cos($angle);\n    $y += $length * sin($angle);\n    $length += 3;\n    $angle += $angleinc;\n    }\n  $c->delete('all');\n  $c->createLine( @pts );\n  $mw->after($wait => \\&step);\n  }\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\nusing System.Windows.Threading;\n\nnamespace Polyspiral\n{\n    public partial class Form1 : Form\n    {\n        private double inc;\n\n        public Form1()\n        {\n            Width = Height = 640;\n            StartPosition = FormStartPosition.CenterScreen;\n            SetStyle(\n                ControlStyles.AllPaintingInWmPaint |\n                ControlStyles.UserPaint |\n                ControlStyles.DoubleBuffer,\n                true);\n\n            var timer = new DispatcherTimer();\n            timer.Tick += (s, e) => { inc = (inc + 0.05) % 360; Refresh(); };\n            timer.Interval = new TimeSpan(0, 0, 0, 0, 40);\n            timer.Start();\n        }\n\n        private void DrawSpiral(Graphics g, int len, double angleIncrement)\n        {\n            double x1 = Width / 2;\n            double y1 = Height / 2;\n            double angle = angleIncrement;\n\n            for (int i = 0; i < 150; i++)\n            {\n                double x2 = x1 + Math.Cos(angle) * len;\n                double y2 = y1 - Math.Sin(angle) * len;\n                g.DrawLine(Pens.Blue, (int)x1, (int)y1, (int)x2, (int)y2);\n                x1 = x2;\n                y1 = y2;\n\n                len += 3;\n\n                angle = (angle + angleIncrement) % (Math.PI * 2);\n            }\n        }\n\n        protected override void OnPaint(PaintEventArgs args)\n        {\n            var g = args.Graphics;\n            g.SmoothingMode = SmoothingMode.AntiAlias;\n            g.Clear(Color.White);\n\n            DrawSpiral(g, 5, ToRadians(inc));\n        }\n\n        private double ToRadians(double angle)\n        {\n            return Math.PI * angle / 180.0;\n        }\n    }\n}\n"}
{"id": 400274, "name": "Polyspiral", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse Tk;\nuse List::Util qw( min );\n\nmy $size = 500;\nmy ($width, $height, $x, $y, $dist);\nmy $angleinc = 0;\nmy $active = 0;\nmy $wait = 1000 / 30;\nmy $radian = 90 / atan2 1, 0;\n\nmy $mw = MainWindow->new;\n$mw->title( 'Polyspiral' );\nmy $c = $mw->Canvas( -width => $size, -height => $size,\n  -relief => 'raised', -borderwidth => 2,\n  )->pack(-fill => 'both', -expand => 1);\n$mw->bind('<Configure>' => sub { $width = $c->width; $height = $c->height;\n  $dist = min($width, $height) ** 2 / 4 } );\n$mw->Button(-text => $_->[0], -command => $_->[1],\n  )->pack(-side => 'right') for\n  [ Exit => sub {$mw->destroy} ],\n  [ 'Start / Pause' => sub { $active ^= 1; step() } ];\n\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub step\n  {\n  $active or return;\n  my @pts = ($x = $width >> 1, $y = $height >> 1);\n  my $length = 5;\n  my $angle = $angleinc;\n  $angleinc += 0.05 / $radian;\n  while( ($x - $width / 2)**2 + ($y - $height / 2)**2 < $dist && @pts < 300 )\n    {\n    push @pts, $x, $y;\n    $x += $length * cos($angle);\n    $y += $length * sin($angle);\n    $length += 3;\n    $angle += $angleinc;\n    }\n  $c->delete('all');\n  $c->createLine( @pts );\n  $mw->after($wait => \\&step);\n  }\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\nusing System.Windows.Threading;\n\nnamespace Polyspiral\n{\n    public partial class Form1 : Form\n    {\n        private double inc;\n\n        public Form1()\n        {\n            Width = Height = 640;\n            StartPosition = FormStartPosition.CenterScreen;\n            SetStyle(\n                ControlStyles.AllPaintingInWmPaint |\n                ControlStyles.UserPaint |\n                ControlStyles.DoubleBuffer,\n                true);\n\n            var timer = new DispatcherTimer();\n            timer.Tick += (s, e) => { inc = (inc + 0.05) % 360; Refresh(); };\n            timer.Interval = new TimeSpan(0, 0, 0, 0, 40);\n            timer.Start();\n        }\n\n        private void DrawSpiral(Graphics g, int len, double angleIncrement)\n        {\n            double x1 = Width / 2;\n            double y1 = Height / 2;\n            double angle = angleIncrement;\n\n            for (int i = 0; i < 150; i++)\n            {\n                double x2 = x1 + Math.Cos(angle) * len;\n                double y2 = y1 - Math.Sin(angle) * len;\n                g.DrawLine(Pens.Blue, (int)x1, (int)y1, (int)x2, (int)y2);\n                x1 = x2;\n                y1 = y2;\n\n                len += 3;\n\n                angle = (angle + angleIncrement) % (Math.PI * 2);\n            }\n        }\n\n        protected override void OnPaint(PaintEventArgs args)\n        {\n            var g = args.Graphics;\n            g.SmoothingMode = SmoothingMode.AntiAlias;\n            g.Clear(Color.White);\n\n            DrawSpiral(g, 5, ToRadians(inc));\n        }\n\n        private double ToRadians(double angle)\n        {\n            return Math.PI * angle / 180.0;\n        }\n    }\n}\n"}
{"id": 400275, "name": "Merge and aggregate datasets", "source": "Translate Perl to C#: \nmy $fmt = '|\u00a0%-11s' x 5 . \"|\\n\";\nprintf $fmt, qw( PATIENT_ID LASTNAME LAST_VISIT SCORE_SUM SCORE_AVG);\nmy ($names, $visits) = do { local $/; split /^\\n/m, <DATA> };\nmy %score;\nfor ( $visits =~ /^\\d.*/gm )\n  {\n  my ($id, undef, $score) = split /,/;\n  $score{$id} //= ['', ''];\n  $score and $score{$id}[0]++, $score{$id}[1] += $score;\n  }\nfor ( sort $names =~ /^\\d.*/gm )\n  {\n  my ($id, $name) = split /,/;\n  printf $fmt, $id, $name, ( sort $visits =~ /^$id,(.*?),/gm, '' )[-1],\n    $score{$id}[0]\n      ? ( $score{$id}[1], $score{$id}[1] / $score{$id}[0])\n      : ('', '');\n  }\n\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Runtime.Serialization;\n\npublic static class MergeAndAggregateDatasets\n{\n    public static void Main()\n    {\n        string patientsCsv = @\"\nPATIENT_ID,LASTNAME\n1001,Hopper\n4004,Wirth\n3003,Kemeny\n2002,Gosling\n5005,Kurtz\";\n\n        string visitsCsv = @\"\nPATIENT_ID,VISIT_DATE,SCORE\n2002,2020-09-10,6.8\n1001,2020-09-17,5.5\n4004,2020-09-24,8.4\n2002,2020-10-08,\n1001,,6.6\n3003,2020-11-12,\n4004,2020-11-05,7.0\n1001,2020-11-19,5.3\";\n\n        string format = \"yyyy-MM-dd\";\n        var formatProvider = new DateTimeFormat(format).FormatProvider;\n\n        var patients = ParseCsv(\n            patientsCsv.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries),\n            line => (PatientId: int.Parse(line[0]), LastName: line[1]));\n\n        var visits = ParseCsv(\n            visitsCsv.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries),\n            line => (\n                PatientId: int.Parse(line[0]),\n                VisitDate: DateTime.TryParse(line[1], formatProvider, DateTimeStyles.None, out var date) ? date : default(DateTime?),\n                Score: double.TryParse(line[2], out double score) ? score : default(double?)\n            )\n        );\n\n        var results =\n            patients.GroupJoin(visits,\n                p => p.PatientId,\n                v => v.PatientId,\n                (p, vs) => (\n                    p.PatientId,\n                    p.LastName,\n                    LastVisit: vs.Max(v => v.VisitDate),\n                    ScoreSum: vs.Sum(v => v.Score),\n                    ScoreAvg: vs.Average(v => v.Score)\n                )\n            ).OrderBy(r => r.PatientId);\n\n        Console.WriteLine(\"| PATIENT_ID | LASTNAME | LAST_VISIT | SCORE_SUM | SCORE_AVG |\");\n        foreach (var r in results) {\n            Console.WriteLine($\"| {r.PatientId,-10} | {r.LastName,-8} | {r.LastVisit?.ToString(format)\u00a0?? \"\",-10} | {r.ScoreSum,9} | {r.ScoreAvg,9} |\");\n        }\n    }\n\n    private static IEnumerable<T> ParseCsv<T>(string[] contents, Func<string[], T> constructor)\n    {\n        for (int i = 1; i < contents.Length; i++) {\n            var line = contents[i].Split(',');\n            yield return constructor(line);\n        }\n    }\n\n}\n"}
{"id": 400276, "name": "Active Directory_Connect", "source": "Translate Perl to C#: use Net::LDAP;\n\nmy $ldap = Net::LDAP->new('ldap://ldap.example.com') or die $@;\nmy $mesg = $ldap->bind( $bind_dn, password => $bind_pass );\n", "target": "\nvar objDE = new System.DirectoryServices.DirectoryEntry(\"LDAP:\n"}
{"id": 400277, "name": "Knapsack problem_Bounded", "source": "Translate Perl to C#: \n\nuse strict;\n\nmy $raw = <<'TABLE';\nmap     \t9       150     1\ncompass \t13      35      1\nwater   \t153     200     2\nsandwich        50      60      2\nglucose \t15      60      2\ntin     \t68      45      3\nbanana  \t27      60      3\napple  \t\t39      40      3\ncheese  \t23      30      1\nbeer    \t52      10      1\nsuntancream     11      70      1\ncamera  \t32      30      1\nT-shirt \t24      15      2\ntrousers        48      10      2\numbrella        73      40      1\nw_trousers     \t42      70      1\nw_overcoat  \t43      75      1\nnote-case       22      80      1\nsunglasses      7       20      1\ntowel   \t18      12      2\nsocks   \t4       50      1\nbook    \t30      10      2\nTABLE\n \nmy @items;\nfor (split \"\\n\", $raw) {\n        my @x = split /\\s+/;\n\tpush @items, {\n\t\tname\t=> $x[0],\n\t\tweight\t=> $x[1],\n\t\tvalue\t=> $x[2],\n\t\tquant\t=> $x[3],\n\t}\n}\n\nmy $max_weight = 400;\n\nmy %cache;\nsub pick {\n\tmy ($weight, $pos) = @_;\n\tif ($pos < 0 or $weight <= 0) {\n\t\treturn 0, 0, []\n\t}\n\n\t@{ $cache{$weight, $pos} //= [do{\t\n\t\tmy $item = $items[$pos];\n\t\tmy ($bv, $bi, $bw, $bp) = (0, 0, 0, []);\n\n\t\tfor my $i (0 .. $item->{quant}) {\n\t\t\tlast if $i * $item->{weight} > $weight;\n\t\t\tmy ($v, $w, $p) = pick($weight - $i * $item->{weight}, $pos - 1);\n\t\t\tnext if ($v += $i * $item->{value}) <= $bv;\n\n\t\t\t($bv, $bi, $bw, $bp) = ($v, $i, $w, $p);\n\t\t}\n\n\t\tmy @picked = ( @$bp, $bi );\n\t\t$bv, $bw + $bi * $item->{weight}, \\@picked\n\t}]}\n}\n\nmy ($v, $w, $p) = pick($max_weight, $\nfor (0 .. $\n\tif ($p->[$_] > 0) {\n\t\tprint \"$p->[$_] of $items[$_]{name}\\n\";\n\t}\n}\nprint \"Value: $v; Weight: $w\\n\";\n", "target": "using System;  \nclass program\n{\n    static void Main()\n    {\n        knapSack(40);\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        Console.Write(knapSack(400) + \"\\n\" + sw.Elapsed);  \n        Console.Read();\n    }\n\n    static string knapSack(uint w1)\n    {\n        init(); change();\n        uint n = (uint)w.Length; var K = new uint[n + 1, w1 + 1];\n        for (uint vi, wi, w0, x, i = 0; i < n; i++)\n            for (vi = v[i], wi = w[i], w0 = 1; w0 <= w1; w0++)\n            {\n                x = K[i, w0];\n                if (wi <= w0) x = max(vi + K[i, w0 - wi], x);\n                K[i + 1, w0] = x;\n            }\n        string str = \"\";\n        for (uint v1 = K[n, w1]; v1 > 0; n--)\n            if (v1 != K[n - 1, w1])\n            {\n                v1 -= v[n - 1]; w1 -= w[n - 1]; str += items[n - 1] + \"\\n\";\n            }\n        return str;\n    }\n\n    static uint max(uint a, uint b) { return a > b ? a : b; }\n\n    static byte[] w, v; static string[] items;\n\n    static byte[] p = { 1, 1, 2, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2 };\n\n    static void init()\n    {\n        w = new byte[] { 9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11,\n                          32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30 };\n\n        v = new byte[] { 150, 35, 200, 60, 60, 45, 60, 40, 30, 10, 70,\n                          30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10 };\n\n        items = new string[] {\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"tin\",\n                              \"banana\",\"apple\",\"cheese\",\"beer\",\"suntan cream\",\n                              \"camera\",\"T-shirt\",\"trousers\",\"umbrella\",\n                              \"waterproof trousers\",\"waterproof overclothes\",\n                              \"note-case\",\"sunglasses\",\"towel\",\"socks\",\"book\"};\n    }\n\n    static void change()\n    {\n        int n = w.Length, s = 0, i, j, k; byte xi;\n        for (i = 0; i < n; i++) s += p[i];\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = w[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            w = x;\n        }\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = v[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            v = x;\n        }\n        string[] pItems = new string[s]; string itemI;\n        for (k = i = 0; i < n; i++)\n            for (itemI = items[i], j = p[i]; j > 0; j--) pItems[k++] = itemI;\n        items = pItems;\n    }\n}\n"}
{"id": 400278, "name": "Solve a Hidato puzzle", "source": "Translate Perl to C#: use strict;\nuse List::Util 'max';\n\nour (@grid, @known, $n);\n\nsub show_board {\n\tfor my $r (@grid) {\n\t\tprint map(!defined($_)\t? '   ' : $_\n\t\t\t\t\t? sprintf(\"%3d\", $_)\n\t\t\t\t\t: ' __'\n\t\t\t, @$r), \"\\n\"\n\t}\n}\n\nsub parse_board {\n\t@grid = map{[map(/^_/ ? 0 : /^\\./ ? undef: $_, split ' ')]}\n\t\t\tsplit \"\\n\", shift();\n\tfor my $y (0 .. $\n\t\tfor my $x (0 .. $\n\t\t\t$grid[$y][$x] > 0\n\t\t\t\tand $known[$grid[$y][$x]] = \"$y,$x\";\n\t\t}\n\t}\n\t$n = max(map { max @$_ } @grid);\n}\n\nsub neighbors {\n\tmy ($y, $x) = @_;\n\tmy @out;\n\tfor (\t[-1, -1], [-1, 0], [-1, 1],\n\t\t[ 0, -1],\t   [ 0, 1],\n\t\t[ 1, -1], [ 1, 0], [ 1, 1])\n\t{\n\t\tmy $y1 = $y + $_->[0];\n\t\tmy $x1 = $x + $_->[1];\n\t\tnext if $x1 < 0 || $y1 < 0;\n\t\tnext unless defined $grid[$y1][$x1];\n\t\tpush @out, \"$y1,$x1\";\n\t}\n\t@out\n}\n\nsub try_fill {\n\tmy ($v, $coord) = @_;\n\treturn 1\tif $v > $n;\n\n\tmy ($y, $x) = split ',', $coord;\n\tmy $old = $grid[$y][$x];\n\n\treturn\tif $old && $old != $v;\n\treturn\tif exists $known[$v] and $known[$v] ne $coord;\n\n\t$grid[$y][$x] = $v;\n\tprint \"\\033[0H\";\n\tshow_board();\n\n\ttry_fill($v + 1, $_) && return 1\n\t\t\tfor neighbors($y, $x);\n\n\t$grid[$y][$x] = $old;\n\treturn\n}\n\nparse_board \n\n\n\n\n\n\n\n\n\n\t\"__ 33 35 __ __ .. .. .. .\n\t __ __ 24 22 __ .. .. .. .\n\t __ __ __ 21 __ __ .. .. .\n\t __ 26 __ 13 40 11 .. .. .\n\t 27 __ __ __  9 __  1 .. .\n\t .   . __ __ 18 __ __ .. .\n\t .  ..  .  . __  7 __ __ .\n\t .  .. .. ..  .  .  5 __ .\";\n\nprint \"\\033[2J\";\ntry_fill(1, $known[1]);\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hidatoMoves).Solve(false, new [,] {\n            {  0, 33, 35,  0,  0, -1, -1, -1 },\n            {  0,  0, 24, 22,  0, -1, -1, -1 },\n            {  0,  0,  0, 21,  0,  0, -1, -1 },\n            {  0, 26,  0, 13, 40, 11, -1, -1 },\n            { 27,  0,  0,  0,  9,  0,  1, -1 },\n            { -1, -1,  0,  0, 18,  0,  0, -1 },\n            { -1, -1, -1, -1,  0,  7,  0,  0 },\n            { -1, -1, -1, -1, -1, -1,  5,  0 }\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 400279, "name": "Solve a Hidato puzzle", "source": "Translate Perl to C#: use strict;\nuse List::Util 'max';\n\nour (@grid, @known, $n);\n\nsub show_board {\n\tfor my $r (@grid) {\n\t\tprint map(!defined($_)\t? '   ' : $_\n\t\t\t\t\t? sprintf(\"%3d\", $_)\n\t\t\t\t\t: ' __'\n\t\t\t, @$r), \"\\n\"\n\t}\n}\n\nsub parse_board {\n\t@grid = map{[map(/^_/ ? 0 : /^\\./ ? undef: $_, split ' ')]}\n\t\t\tsplit \"\\n\", shift();\n\tfor my $y (0 .. $\n\t\tfor my $x (0 .. $\n\t\t\t$grid[$y][$x] > 0\n\t\t\t\tand $known[$grid[$y][$x]] = \"$y,$x\";\n\t\t}\n\t}\n\t$n = max(map { max @$_ } @grid);\n}\n\nsub neighbors {\n\tmy ($y, $x) = @_;\n\tmy @out;\n\tfor (\t[-1, -1], [-1, 0], [-1, 1],\n\t\t[ 0, -1],\t   [ 0, 1],\n\t\t[ 1, -1], [ 1, 0], [ 1, 1])\n\t{\n\t\tmy $y1 = $y + $_->[0];\n\t\tmy $x1 = $x + $_->[1];\n\t\tnext if $x1 < 0 || $y1 < 0;\n\t\tnext unless defined $grid[$y1][$x1];\n\t\tpush @out, \"$y1,$x1\";\n\t}\n\t@out\n}\n\nsub try_fill {\n\tmy ($v, $coord) = @_;\n\treturn 1\tif $v > $n;\n\n\tmy ($y, $x) = split ',', $coord;\n\tmy $old = $grid[$y][$x];\n\n\treturn\tif $old && $old != $v;\n\treturn\tif exists $known[$v] and $known[$v] ne $coord;\n\n\t$grid[$y][$x] = $v;\n\tprint \"\\033[0H\";\n\tshow_board();\n\n\ttry_fill($v + 1, $_) && return 1\n\t\t\tfor neighbors($y, $x);\n\n\t$grid[$y][$x] = $old;\n\treturn\n}\n\nparse_board \n\n\n\n\n\n\n\n\n\n\t\"__ 33 35 __ __ .. .. .. .\n\t __ __ 24 22 __ .. .. .. .\n\t __ __ __ 21 __ __ .. .. .\n\t __ 26 __ 13 40 11 .. .. .\n\t 27 __ __ __  9 __  1 .. .\n\t .   . __ __ 18 __ __ .. .\n\t .  ..  .  . __  7 __ __ .\n\t .  .. .. ..  .  .  5 __ .\";\n\nprint \"\\033[2J\";\ntry_fill(1, $known[1]);\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hidatoMoves).Solve(false, new [,] {\n            {  0, 33, 35,  0,  0, -1, -1, -1 },\n            {  0,  0, 24, 22,  0, -1, -1, -1 },\n            {  0,  0,  0, 21,  0,  0, -1, -1 },\n            {  0, 26,  0, 13, 40, 11, -1, -1 },\n            { 27,  0,  0,  0,  9,  0,  1, -1 },\n            { -1, -1,  0,  0, 18,  0,  0, -1 },\n            { -1, -1, -1, -1,  0,  7,  0,  0 },\n            { -1, -1, -1, -1, -1, -1,  5,  0 }\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 400280, "name": "Angles (geometric), normalization and conversion", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse POSIX 'fmod';\n\nmy $tau = 2 * 4*atan2(1, 1);\nmy @units = (\n    { code => 'd', name => 'degrees' , number =>  360 },\n    { code => 'g', name => 'gradians', number =>  400 },\n    { code => 'm', name => 'mills'   , number => 6400 },\n    { code => 'r', name => 'radians' , number => $tau },\n);\n\nmy %cvt;\nfor my $a (@units) {\n  for my $b (@units) {\n    $cvt{ \"${$a}{code}2${$b}{code}\" } = sub {\n        my($angle) = shift;\n        my $norm = fmod($angle,${$a}{number}); \n        $norm -= ${$a}{number} if $angle < 0;\n        $norm * ${$b}{number} / ${$a}{number}\n        }\n  }\n}\n\nprintf '%s'. '%12s'x4 . \"\\n\", '     Angle Unit    ', <Degrees Gradians Mills Radians>;\nfor my $angle (-2, -1, 0, 1, 2, $tau, 16, 360/$tau, 360-1, 400-1, 6400-1, 1_000_000) {\n    print \"\\n\";\n    for my $from (@units) {\n        my @sub_keys = map { \"${$from}{code}2${$_}{code}\" } @units;\n        my @results  = map { &{$cvt{$_}}($angle) } @sub_keys;\n        printf '%10g\u00a0%-8s' . '%12g'x4 . \"\\n\", $angle, ${$from}{name}, @results;\n    }\n}\n", "target": "using System;\n\npublic static class Angles\n{\n    public static void Main() => Print(-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000);\n\n    public static void Print(params double[] angles) {\n        string[] names = { \"Degrees\", \"Gradians\", \"Mils\", \"Radians\" };\n        Func<double, double> rnd = a => Math.Round(a, 4);\n        Func<double, double>[] normal = { NormalizeDeg, NormalizeGrad, NormalizeMil, NormalizeRad };\n\n        Func<double, double>[,] convert = {\n            { a => a, DegToGrad, DegToMil, DegToRad },\n            { GradToDeg, a => a, GradToMil, GradToRad },\n            { MilToDeg, MilToGrad, a => a, MilToRad },\n            { RadToDeg, RadToGrad, RadToMil, a => a }\n        };\n\n        Console.WriteLine($@\"{\"Angle\",-12}{\"Normalized\",-12}{\"Unit\",-12}{\n            \"Degrees\",-12}{\"Gradians\",-12}{\"Mils\",-12}{\"Radians\",-12}\");\n\n        foreach (double angle in angles) {\n            for (int i = 0; i < 4; i++) {\n                double nAngle = normal[i](angle);\n\n                Console.WriteLine($@\"{\n                    rnd(angle),-12}{\n                    rnd(nAngle),-12}{\n                    names[i],-12}{\n                    rnd(convert[i, 0](nAngle)),-12}{\n                    rnd(convert[i, 1](nAngle)),-12}{\n                    rnd(convert[i, 2](nAngle)),-12}{\n                    rnd(convert[i, 3](nAngle)),-12}\");\n            }\n        }\n    }\n\n    public static double NormalizeDeg(double angle) => Normalize(angle, 360);\n    public static double NormalizeGrad(double angle) => Normalize(angle, 400);\n    public static double NormalizeMil(double angle) => Normalize(angle, 6400);\n    public static double NormalizeRad(double angle) => Normalize(angle, 2 * Math.PI);\n\n    private static double Normalize(double angle, double N) {\n        while (angle <= -N) angle += N;\n        while (angle >= N) angle -= N;\n        return angle;\n    }\n\n    public static double DegToGrad(double angle) => angle * 10 / 9;\n    public static double DegToMil(double angle) => angle * 160 / 9;\n    public static double DegToRad(double angle) => angle * Math.PI / 180;\n    \n    public static double GradToDeg(double angle) => angle * 9 / 10;\n    public static double GradToMil(double angle) => angle * 16;\n    public static double GradToRad(double angle) => angle * Math.PI / 200;\n    \n    public static double MilToDeg(double angle) => angle * 9 / 160;\n    public static double MilToGrad(double angle) => angle / 16;\n    public static double MilToRad(double angle) => angle * Math.PI / 3200;\n    \n    public static double RadToDeg(double angle) => angle * 180 / Math.PI;\n    public static double RadToGrad(double angle) => angle * 200 / Math.PI;\n    public static double RadToMil(double angle) => angle * 3200 / Math.PI;\n}\n"}
{"id": 400281, "name": "XML_XPath", "source": "Translate Perl to C#: use XML::XPath qw();\n\nmy $x = XML::XPath->new('<inventory ... </inventory>');\n\n[$x->findnodes('//item[1]')->get_nodelist]->[0];\nprint $x->findnodes_as_string('//price');\n$x->findnodes('//name')->get_nodelist;\n", "target": "XmlReader XReader;\n \n\nXReader = XmlReader.Create(new StringReader(\"<inventory title=... </inventory>\"));\n \n\nXReader = XmlReader.Create(\"xmlfile.xml\");\n \n\n\nIXPathNavigable XDocument = new XPathDocument(XReader);\n \n\nXPathNavigator Nav = XDocument.CreateNavigator();\nNav = Nav.SelectSingleNode(\"\n \n\nif(Nav.MoveToFirst())\n{\n  Console.WriteLine(Nav.OuterXml); \n}\n \n\nXPathNodeIterator Iterator = XDocument.CreateNavigator().Select(\"\n \nwhile (Iterator.MoveNext())\n{\n  Console.WriteLine(Iterator.Current.Value);\n}\n \nIterator = XDocument.CreateNavigator().Select(\"\n \n\nList<string> NodesValues = new List<string>();\n \nwhile (Iterator.MoveNext())\n{\n  NodesValues.Add(Iterator.Current.Value);\n}\n \n\nConsole.WriteLine(NodesValues.ToArray().Length);\n"}
{"id": 400282, "name": "HTTPS_Authenticated", "source": "Translate Perl to C#: use LWP::UserAgent qw();\nmy $ua = LWP::UserAgent->new;\nmy $netloc = 'http://www.buddhism-dict.net/cgi-bin/xpr-dealt.pl:80';\n$ua->credentials(\n   $netloc,\n   'CJK-E and Buddhist Dictionaries', \n   'guest',  \n   '',       \n);\nmy $response = $ua->get($netloc);\n\nuse WWW::Mechanize qw();\nmy $mech = WWW::Mechanize->new;\n$mech->get('https://login.yahoo.com/');\n$mech->submit_form(with_fields => {\n    login         => 'XXXXXX',\n    passwd        => 'YYYYYY',\n    '.persistent' => 'y',  \n});\n", "target": "using System;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var client = new WebClient();\n\n        \n        client.Credentials = CredentialCache.DefaultCredentials;\n        \n        client.Credentials = new NetworkCredential(\"User\", \"Password\");\n\n        var data = client.DownloadString(\"https:\n\n        Console.WriteLine(data);\n    }\n}\n"}
{"id": 400283, "name": "Ranking methods", "source": "Translate Perl to C#: my %scores = (\n    'Solomon' => 44,\n    'Jason'   => 42,\n    'Errol'   => 42,\n    'Garry'   => 41,\n    'Bernard' => 41,\n    'Barry'   => 41,\n    'Stephen' => 39\n);\n\nsub tiers {\n    my(%s) = @_; my(%h);\n    push @{$h{$s{$_}}}, $_ for keys %s;\n    @{\\%h}{reverse sort keys %h};\n}\n\nsub standard {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n        $rank += @$players;\n    }\n    return $result;\n}\n\nsub modified {\n    my(%s) = @_; my($result);\n    my $rank = 0;\n    for my $players (tiers %s) {\n        $rank += @$players;\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n    }\n    return $result;\n}\n\nsub dense {\n    my(%s) = @_; my($n,$result);\n    $result .= sprintf \"%d %s\\n\", ++$n, join(', ', sort @$_) for tiers %s;\n    return $result;\n}\n\nsub ordinal {\n    my(%s) = @_; my($n,$result);\n    for my $players (tiers %s) {\n        $result .= sprintf \"%d %s\\n\", ++$n, $_ for sort @$players;\n    }\n    return $result;\n}\n\nsub fractional {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        my $beg = $rank;\n        my $end = $rank += @$players;\n        my $avg = 0;\n        $avg += $_/@$players for $beg .. $end-1;\n        $result .= sprintf \"%3.1f %s\\n\", $avg, join ', ', sort @$players;\n    }\n    return $result;\n}\n\nprint \"Standard:\\n\"    .   standard(%scores) . \"\\n\";\nprint \"Modified:\\n\"    .   modified(%scores) . \"\\n\";\nprint \"Dense:\\n\"       .      dense(%scores) . \"\\n\";\nprint \"Ordinal:\\n\"     .    ordinal(%scores) . \"\\n\";\nprint \"Fractional:\\n\"  . fractional(%scores) . \"\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RankingMethods {\n    class Program {\n        static void Main(string[] args) {\n            Dictionary<string, int> scores = new Dictionary<string, int> {\n                [\"Solomon\"] = 44,\n                [\"Jason\"] = 42,\n                [\"Errol\"] = 42,\n                [\"Gary\"] = 41,\n                [\"Bernard\"] = 41,\n                [\"Barry\"] = 41,\n                [\"Stephen\"] = 39,\n            };\n\n            StandardRank(scores);\n            ModifiedRank(scores);\n            DenseRank(scores);\n            OrdinalRank(scores);\n            FractionalRank(scores);\n        }\n\n        static void StandardRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Standard Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                int temp = rank;\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", temp, value, k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void ModifiedRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Modified Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                    }\n                }\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void DenseRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Dense Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n                rank++;\n            }\n\n            Console.WriteLine();\n        }\n\n        static void OrdinalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Ordinal Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void FractionalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Fractional Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                double avg = 0;\n                int cnt = 0;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                        cnt++;\n                        avg += rank;\n                    }\n                }\n                avg /= cnt;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0:F1} {1} {2}\", avg, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400284, "name": "Straddling checkerboard", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util <min max>;\n\nmy(%encode,%decode,@table);\n\nsub build {\n    my($u,$v,$alphabet) = @_;\n    my(@flat_board,%p2c,%c2p);\n    my $numeric_escape = '/';\n\n    @flat_board = split '', uc $alphabet;\n    splice @flat_board, min($u,$v), 0, undef;\n    splice @flat_board, max($u,$v), 0, undef;\n\n    push @table, [' ', 0..9];\n    push @table, [' ', map { defined $_ ? $_ : ' '} @flat_board[ 0 ..  9] ];\n    push @table, [$u,  @flat_board[10 .. 19]];\n    push @table, [$v,  @flat_board[20 .. 29]];\n\n    my @nums = my @order = 0..9;\n    push @nums, (map { +\"$u$_\" } @order), map { +\"$v$_\" } @order;\n\n    @c2p{@nums} = @flat_board;\n    for (keys %c2p) { delete $c2p{$_} unless defined $c2p{$_} }\n    @p2c{values %c2p} = keys %c2p;\n    $p2c{$_} = $p2c{$numeric_escape} . $_ for 0..9;\n    while (my ($k, $v) = each %p2c) {\n        $encode{$k} = $v;\n        $decode{$v} = $k unless $k eq $numeric_escape;\n    }\n}\n\nsub decode {\n    my($string) = @_;\n    my $keys = join '|', keys %decode;\n    $string =~ s/($keys)/$decode{$1}/gr;\n}\n\nsub encode {\n    my($string) = uc shift;\n    $string =~ s\n}\n\nmy $sc = build(3, 7, 'HOLMESRTABCDFGIJKNPQUVWXYZ./');\nsay join  ' ', @$_ for @table;\nsay '';\nsay 'Original: ', my $original = 'One night-it was on the twentieth of March, 1888-I was returning';\nsay 'Encoded:  ', my $en = encode($original);\nsay 'Decoded:  ', decode($en);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace StraddlingCheckerboard\n{\n    class Program\n    {\n        public readonly static IReadOnlyDictionary<char, string> val2Key;\n        public readonly static IReadOnlyDictionary<string, char> key2Val;\n\n        static Program()\n        {\n            val2Key = new Dictionary<char, string> {\n                {'A',\"30\"},  {'B',\"31\"}, {'C',\"32\"},  {'D',\"33\"},  {'E',\"5\"},   {'F',\"34\"},  {'G',\"35\"},\n                {'H',\"0\"},   {'I',\"36\"}, {'J',\"37\"},  {'K',\"38\"},  {'L',\"2\"},   {'M',\"4\"},   {'.',\"78\"},\n                {'N',\"39\"},  {'/',\"79\"}, {'O',\"1\"},   {'0',\"790\"}, {'P',\"70\"},  {'1',\"791\"}, {'Q',\"71\"},\n                {'2',\"792\"}, {'R',\"8\"},  {'3',\"793\"}, {'S',\"6\"},   {'4',\"794\"}, {'T',\"9\"},   {'5',\"795\"},\n                {'U',\"72\"},  {'6',\"796\"},{'V',\"73\"},  {'7',\"797\"}, {'W',\"74\"},  {'8',\"798\"}, {'X',\"75\"},\n                {'9',\"799\"}, {'Y',\"76\"}, {'Z',\"77\"}};\n\n            key2Val = val2Key.ToDictionary(kv => kv.Value, kv => kv.Key);\n        }\n\n        public static string Encode(string s)\n        {\n            return string.Concat(s.ToUpper().ToCharArray()\n                .Where(c => val2Key.ContainsKey(c)).Select(c => val2Key[c]));\n        }\n\n        public static string Decode(string s)\n        {\n            return string.Concat(Regex.Matches(s, \"79.|7.|3.|.\").Cast<Match>()\n                .Where(m => key2Val.ContainsKey(m.Value)).Select(m => key2Val[m.Value]));\n        }\n\n        static void Main(string[] args)\n        {\n            var enc = Encode(\"One night-it was on the twentieth of March, 1888-I was returning\");\n            Console.WriteLine(enc);\n            Console.WriteLine(Decode(enc));\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 400285, "name": "I before E except after C", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\n\nsub result {\n    my ($support, $against) = @_;\n    my $ratio  = sprintf '%.2f', $support / $against;\n    my $result = $ratio >= 2;\n    print \"$support / $against = $ratio. \", 'NOT ' x !$result, \"PLAUSIBLE\\n\";\n    return $result;\n}\n\nmy @keys  = qw(ei cei ie cie);\nmy %count;\n\nwhile (<>) {\n    for my $k (@keys) {\n        $count{$k}++ if -1 != index $_, $k;\n    }\n}\n\nmy ($support, $against, $result);\n\nprint 'I before E when not preceded by C: ';\n$support = $count{ie} - $count{cie};\n$against = $count{ei} - $count{cei};\n$result += result($support, $against);\n\nprint 'E before I when preceded by C: ';\n$support = $count{cei};\n$against = $count{cie};\n$result += result($support, $against);\n\nprint 'Overall: ', 'NOT ' x ($result < 2), \"PLAUSIBLE.\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 400286, "name": "I before E except after C", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\n\nsub result {\n    my ($support, $against) = @_;\n    my $ratio  = sprintf '%.2f', $support / $against;\n    my $result = $ratio >= 2;\n    print \"$support / $against = $ratio. \", 'NOT ' x !$result, \"PLAUSIBLE\\n\";\n    return $result;\n}\n\nmy @keys  = qw(ei cei ie cie);\nmy %count;\n\nwhile (<>) {\n    for my $k (@keys) {\n        $count{$k}++ if -1 != index $_, $k;\n    }\n}\n\nmy ($support, $against, $result);\n\nprint 'I before E when not preceded by C: ';\n$support = $count{ie} - $count{cie};\n$against = $count{ei} - $count{cei};\n$result += result($support, $against);\n\nprint 'E before I when preceded by C: ';\n$support = $count{cei};\n$against = $count{cie};\n$result += result($support, $against);\n\nprint 'Overall: ', 'NOT ' x ($result < 2), \"PLAUSIBLE.\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 400287, "name": "Write to Windows event log", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse Win32::EventLog;\nmy $handle = Win32::EventLog->new(\"Application\");\n\nmy $event = {\n\tComputer \t=>\t$ENV{COMPUTERNAME},\n\tSource\t\t=> \t'Rosettacode',\n\tEventType \t=> \tEVENTLOG_INFORMATION_TYPE,\n\tCategory  \t=> \t'test',\n\tEventID \t=> \t0,\n\tData \t\t=> \t'a test for rosettacode',\n\tStrings \t=> \t'a string test for rosettacode',\n};\n$handle->Report($event);\n", "target": "using System.Diagnostics;\n\nnamespace RC\n{\n  internal class Program\n  {\n    public static void Main()\n    {\n      string sSource  = \"Sample App\";\n      string sLog     = \"Application\";\n      string sEvent   = \"Hello from RC!\";\n\n      if (!EventLog.SourceExists(sSource))\n        EventLog.CreateEventSource(sSource, sLog);\n\n      EventLog.WriteEntry(sSource, sEvent);\n      EventLog.WriteEntry(sSource, sEvent, EventLogEntryType.Information);\n    }\n  }\n}\n"}
{"id": 400288, "name": "Line circle intersection", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\n\nsub find_intersection {\n   my($P1, $P2, $center, $radius) = @_;\n   my @d = ($$P2[0] -     $$P1[0], $$P2[1] -     $$P1[1]);\n   my @f = ($$P1[0] - $$center[0], $$P1[1] - $$center[1]);\n   my $a = sum map { $_**2 } @d;\n   my $b = 2 * ($f[0]*$d[0] + $f[1]*$d[1]);\n   my $c = sum(map { $_**2 } @f) - $radius**2;\n   my $D =  $b**2 - 4*$a*$c;\n\n   return unless $D >= 0;\n   my ($t1, $t2) = ( (-$b - sqrt $D) / (2*$a), (-$b + sqrt $D) / (2*$a) );\n   return unless $t1 >= 0 and $t1 <= 1 or $t2 >= 0 and $t2  <= 1;\n\n   my ($dx, $dy) = ($$P2[0] - $$P1[0], $$P2[1] - $$P1[1]);\n   return ([$dx*$t1 + $$P1[0], $dy*$t1 + $$P1[1]],\n           [$dx*$t2 + $$P1[0], $dy*$t2 + $$P1[1]])\n}\n\nmy @data = (\n   [ [-10, 11], [ 10, -9], [3, -5], 3 ],\n   [ [-10, 11], [-11, 12], [3, -5], 3 ],\n   [ [  3, -2], [  7, -2], [3, -5], 3 ],\n   [ [  3, -2], [  7, -2], [0,  0], 4 ],\n   [ [  0, -3], [  0,  6], [0,  0], 4 ],\n   [ [  6,  3], [ 10,  7], [4,  2], 5 ],\n   [ [  7,  4], [ 11, 18], [4,  2], 5 ],\n);\n\nsub rnd { map { sprintf('%.2f', $_) =~ s/\\.00//r } @_ }\n\nfor my $d (@data) {\n   my @solution = find_intersection @$d[0] , @$d[1] , @$d[2], @$d[3];\n   say 'For input: ' . join ', ', (map { '('. join(',', @$_) .')' } @$d[0,1,2]), @$d[3];\n   say 'Solutions: ' . (@solution > 1 ? join ', ', map { '('. join(',', rnd @$_) .')' } @solution : 'None');\n   say '';\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main()\n    {\n        Circle circle = ((3, -5), 3);\n        Line[] lines = {\n            ((-10, 11), (10, -9)),\n            ((-10, 11), (-11, 12), true),\n            ((3, -2), (7, -2))\n        };\n        Print(circle, lines);\n        \n        circle = ((0, 0), 4);\n        lines = new Line[] {\n            ((0, -3), (0, 6)),\n            ((0, -3), (0, 6), true)\n        };\n        Print(circle, lines);\n        \n        circle = ((4, 2), 5);\n        lines = new Line[] {\n            ((6, 3), (10, 7)),\n            ((7, 4), (11, 8), true)\n        };\n        Print(circle, lines);\n    }\n    \n    static void Print(Circle circle, Line[] lines)\n    {\n        Console.WriteLine($\"Circle: {circle}\");\n        foreach (var line in lines) {\n            Console.WriteLine($\"\\t{(line.IsSegment\u00a0? \"Segment:\"\u00a0: \"Line:\")} {line}\");\n            var points = Intersection(circle, line).ToList();\n            Console.WriteLine(points.Count == 0 ? \"\\t\\tdo not intersect\" : \"\\t\\tintersect at \" + string.Join(\" and \", points));\n        }\n        Console.WriteLine();\n    }\n    \n    static IEnumerable<Point> Intersection(Circle circle, Line line)\n    {\n        var intersection = LineIntersection(circle, line);\n        return line.IsSegment\n            ? intersection.Where(p => p.CompareTo(line.P1) >= 0 && p.CompareTo(line.P2) <= 0)\n            : intersection;\n\n        static IEnumerable<Point> LineIntersection(Circle circle, Line line)\n        {\n            double x, y, A, B, C, D;\n            var (m, c) = (line.Slope, line.YIntercept);\n            var (p, q, r) = (circle.X, circle.Y, circle.Radius);\n\n            if (line.IsVertical) {\n                x = line.P1.X;\n                B = -2 * q;\n                C = p * p + q * q - r * r + x * x - 2 * p * x;\n                D = B * B - 4 * C;\n                if (D == 0) yield return (x, -q);\n                else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    yield return (x, (-B - D) / 2);\n                    yield return (x, (-B + D) / 2);\n                }\n            } else {\n                A = m * m + 1;\n                B = 2 * (m * c - m * q - p);\n                C = p * p + q * q - r * r + c * c - 2 * c * q;\n                D = B * B - 4 * A * C;\n                if (D == 0) {\n                    x = -B / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                } else if (D > 0) {\n                    D = Math.Sqrt(D);\n                    x = (-B - D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                    x = (-B + D) / (2 * A);\n                    y = m * x + c;\n                    yield return (x, y);\n                }\n            }\n        }\n\n    }\n    \n    readonly struct Point : IComparable<Point>\n    {\n        public Point(double x, double y) => (X, Y) = (x, y);\n        \n        public static implicit operator Point((double x, double y) p) => new Point(p.x, p.y);\n        \n        public double X { get; }\n        public double Y { get; }\n        \n        public int CompareTo(Point other)\n        {\n            int c = X.CompareTo(other.X);\n            if (c != 0) return c;\n            return Y.CompareTo(other.Y);\n        }\n        \n        public override string ToString() => $\"({X}, {Y})\";\n    }\n    \n    readonly struct Line\n    {\n        public Line(Point p1, Point p2, bool isSegment = false)\n        {\n            (P1, P2) = p2.CompareTo(p1) < 0 ? (p2, p1) : (p1, p2);\n            IsSegment = isSegment;\n            if (p1.X == p2.X) (Slope, YIntercept) = (double.PositiveInfinity, double.NaN);\n            else {\n                Slope = (P2.Y - P1.Y) / (P2.X - P1.X);\n                YIntercept = P2.Y - Slope * P2.X;\n            }\n        }\n        \n        public static implicit operator Line((Point p1, Point p2) l) => new Line(l.p1, l.p2);\n        public static implicit operator Line((Point p1, Point p2, bool isSegment) l) => new Line(l.p1, l.p2, l.isSegment);\n        \n        public Point P1 { get; }\n        public Point P2 { get; }\n        public double Slope { get; }\n        public double YIntercept { get; }\n        public bool IsSegment { get; }\n        public bool IsVertical => P1.X == P2.X;\n        \n        public override string ToString() => $\"[{P1}, {P2}]\";\n    }\n    \n    readonly struct Circle\n    {\n        public Circle(Point center, double radius) => (Center, Radius) = (center, radius);\n        \n        public static implicit operator Circle((Point center, double radius) c) => new Circle(c.center, c.radius);\n        \n        public Point Center { get; }\n        public double Radius { get; }\n        public double X => Center.X;\n        public double Y => Center.Y;\n        \n        public override string ToString() => $\"{{ C:{Center}, R:{Radius} }}\";\n    }   \n}\n"}
{"id": 400289, "name": "Solve a Hopido puzzle", "source": "Translate Perl to C#: \n\nuse strict;             \nuse warnings;\n\n$_ = do { local $/; <DATA> };\ns/./$&$&/g;             \nmy $w = /\\n/ && $-[0];\nmy $wd = 3 * $w + 1;    \nmy $wr = 2 * $w + 8;    \nmy $wl = 2 * $w - 8;    \nplace($_, '00');\ndie \"No solution\\n\";\n\nsub place\n  {\n  (local $_, my $last) = @_;\n  (my $new = $last)++;\n  /$last.{10}(?=00)/g   and place( s/\\G00/$new/r, $new ); \n  /(?=00.{10}$last)/g   and place( s/\\G00/$new/r, $new ); \n  /$last.{$wd}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wd}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wr}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wr}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wl}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wl}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /00/ and return;\n  print \"Solution\\n\\n\", s/  / /gr =~ s/0\\B/ /gr;\n  exit;\n  }\n\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hopidoMoves = {(-3,0),(0,-3),(0,3),(3,0),(-2,-2),(-2,2),(2,-2),(2,2)},\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hopidoMoves).Solve(false,\n            \".00.00.\",\n            \"0000000\",\n            \"0000000\",\n            \".00000.\",\n            \"..000..\",\n            \"...0...\"\n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 400290, "name": "Solve a Hopido puzzle", "source": "Translate Perl to C#: \n\nuse strict;             \nuse warnings;\n\n$_ = do { local $/; <DATA> };\ns/./$&$&/g;             \nmy $w = /\\n/ && $-[0];\nmy $wd = 3 * $w + 1;    \nmy $wr = 2 * $w + 8;    \nmy $wl = 2 * $w - 8;    \nplace($_, '00');\ndie \"No solution\\n\";\n\nsub place\n  {\n  (local $_, my $last) = @_;\n  (my $new = $last)++;\n  /$last.{10}(?=00)/g   and place( s/\\G00/$new/r, $new ); \n  /(?=00.{10}$last)/g   and place( s/\\G00/$new/r, $new ); \n  /$last.{$wd}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wd}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wr}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wr}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wl}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wl}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /00/ and return;\n  print \"Solution\\n\\n\", s/  / /gr =~ s/0\\B/ /gr;\n  exit;\n  }\n\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hopidoMoves = {(-3,0),(0,-3),(0,3),(3,0),(-2,-2),(-2,2),(2,-2),(2,2)},\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hopidoMoves).Solve(false,\n            \".00.00.\",\n            \"0000000\",\n            \"0000000\",\n            \".00000.\",\n            \"..000..\",\n            \"...0...\"\n        ));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 400291, "name": "Solve a Numbrix puzzle", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEND\n\nmy $gap = /.\\n/ * $-[0];\nprint;\ns/ (?=\\d\\b)/0/g;\nmy $max = sprintf \"%02d\", tr/0-9// / 2;\n\nsolve( '01', $_ );\n\nsub solve\n  {\n  my ($have, $in) = @_;\n  $have eq $max and exit !print \"solution\\n\", $in =~ s/\\b0/ /gr;\n  if( $in =~ ++(my $want = $have) )\n    {\n    $in =~ /($have|$want)( |.{$gap})($have|$want)/s and solve($want, $in);\n    }\n  else\n    {\n    ($_ = $in) =~ s/$have \\K00/$want/          and solve( $want, $_ ); \n    ($_ = $in) =~ s/$have.{$gap}\\K00/$want/s   and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?= $have)/$want/        and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?=.{$gap}$have)/$want/s and solve( $want, $_ ); \n    }\n  }\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        numbrixMoves = {(1,0),(0,1),(-1,0),(0,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        var numbrixSolver = new Solver(numbrixMoves);\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0,  0, 46, 45,  0, 55, 74,  0,  0 },\n            {  0, 38,  0,  0, 43,  0,  0, 78,  0 },\n            {  0, 35,  0,  0,  0,  0,  0, 71,  0 },\n            {  0,  0, 33,  0,  0,  0, 59,  0,  0 },\n            {  0, 17,  0,  0,  0,  0,  0, 67,  0 },\n            {  0, 18,  0,  0, 11,  0,  0, 64,  0 },\n            {  0,  0, 24, 21,  0,  1,  2,  0,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0, 11, 12, 15, 18, 21, 62, 61,  0 },\n            {  0,  6,  0,  0,  0,  0,  0, 60,  0 },\n            {  0, 33,  0,  0,  0,  0,  0, 57,  0 },\n            {  0, 32,  0,  0,  0,  0,  0, 56,  0 },\n            {  0, 37,  0,  1,  0,  0,  0, 73,  0 },\n            {  0, 38,  0,  0,  0,  0,  0, 72,  0 },\n            {  0, 43, 44, 47, 48, 51, 76, 77,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 400292, "name": "Solve a Numbrix puzzle", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEND\n\nmy $gap = /.\\n/ * $-[0];\nprint;\ns/ (?=\\d\\b)/0/g;\nmy $max = sprintf \"%02d\", tr/0-9// / 2;\n\nsolve( '01', $_ );\n\nsub solve\n  {\n  my ($have, $in) = @_;\n  $have eq $max and exit !print \"solution\\n\", $in =~ s/\\b0/ /gr;\n  if( $in =~ ++(my $want = $have) )\n    {\n    $in =~ /($have|$want)( |.{$gap})($have|$want)/s and solve($want, $in);\n    }\n  else\n    {\n    ($_ = $in) =~ s/$have \\K00/$want/          and solve( $want, $_ ); \n    ($_ = $in) =~ s/$have.{$gap}\\K00/$want/s   and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?= $have)/$want/        and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?=.{$gap}$have)/$want/s and solve( $want, $_ ); \n    }\n  }\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        numbrixMoves = {(1,0),(0,1),(-1,0),(0,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        var numbrixSolver = new Solver(numbrixMoves);\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0,  0, 46, 45,  0, 55, 74,  0,  0 },\n            {  0, 38,  0,  0, 43,  0,  0, 78,  0 },\n            {  0, 35,  0,  0,  0,  0,  0, 71,  0 },\n            {  0,  0, 33,  0,  0,  0, 59,  0,  0 },\n            {  0, 17,  0,  0,  0,  0,  0, 67,  0 },\n            {  0, 18,  0,  0, 11,  0,  0, 64,  0 },\n            {  0,  0, 24, 21,  0,  1,  2,  0,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n\n        Print(numbrixSolver.Solve(false, new [,] {\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n            {  0, 11, 12, 15, 18, 21, 62, 61,  0 },\n            {  0,  6,  0,  0,  0,  0,  0, 60,  0 },\n            {  0, 33,  0,  0,  0,  0,  0, 57,  0 },\n            {  0, 32,  0,  0,  0,  0,  0, 56,  0 },\n            {  0, 37,  0,  1,  0,  0,  0, 73,  0 },\n            {  0, 38,  0,  0,  0,  0,  0, 72,  0 },\n            {  0, 43, 44, 47, 48, 51, 76, 77,  0 },\n            {  0,  0,  0,  0,  0,  0,  0,  0,  0 },\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 400293, "name": "Respond to an unknown method call", "source": "Translate Perl to C#: package Example;\nsub new {\n    bless {}\n}\nsub foo {\n    print \"this is foo\\n\";\n}\nsub bar {\n    print \"this is bar\\n\";\n}\nsub AUTOLOAD {\n    my $name = $Example::AUTOLOAD;\n    my ($self, @args) = @_;\n    print \"tried to handle unknown method $name\\n\";\n    if (@args) {\n        print \"it had arguments: @args\\n\";\n    }\n}\nsub DESTROY {}          \n                        \n                        \n \npackage main;\nmy $example = Example->new;\n \n$example->foo;          \n$example->bar;          \n$example->grill;        \n$example->ding(\"dong\"); \n                        \n", "target": "using System;\nusing System.Dynamic;\n\nclass Example : DynamicObject\n{\n    public override bool TryInvokeMember(InvokeMemberBinder binder, object[] args, out object result)\n    {\n        result = null;\n\n        Console.WriteLine(\"This is {0}.\", binder.Name);\n        return true;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        dynamic ex = new Example();\n\n        ex.Foo();\n        ex.Bar();\n    }\n}\n"}
{"id": 400294, "name": "Chemical calculator", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse List::Util;\nuse Parse::RecDescent;\n\nmy $g = Parse::RecDescent->new(<<'EOG');\n  {\n     my %atomic_weight = <H 1.008 C 12.011 O 15.999 Na 22.99 S 32.06>\n  }\n\n  weight   : compound         { $item[1] }\n  compound : group(s)         { List::Util::sum( @{$item[1]} ) }\n  group    : element /\\d+/    { $item[1] * $item[2] }\n           | element          { $item[1] }\n  element  : /[A-Z][a-z]*/    { $atomic_weight{ $item[1] } }\n           | \"(\" compound \")\" { $item[2] }\nEOG\n\nfor (<H H2 H2O Na2SO4 C6H12 COOH(C(CH3)2)3CH3>) {\n    printf \"%7.3f %s\\n\", $g->weight($_), $_\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChemicalCalculator {\n    class Program {\n        static Dictionary<string, double> atomicMass = new Dictionary<string, double>() {\n            {\"H\",     1.008 },\n            {\"He\",    4.002602},\n            {\"Li\",    6.94},\n            {\"Be\",    9.0121831},\n            {\"B\",    10.81},\n            {\"C\",    12.011},\n            {\"N\",    14.007},\n            {\"O\",    15.999},\n            {\"F\",    18.998403163},\n            {\"Ne\",   20.1797},\n            {\"Na\",   22.98976928},\n            {\"Mg\",   24.305},\n            {\"Al\",   26.9815385},\n            {\"Si\",   28.085},\n            {\"P\",    30.973761998},\n            {\"S\",    32.06},\n            {\"Cl\",   35.45},\n            {\"Ar\",   39.948},\n            {\"K\",    39.0983},\n            {\"Ca\",   40.078},\n            {\"Sc\",   44.955908},\n            {\"Ti\",   47.867},\n            {\"V\",    50.9415},\n            {\"Cr\",   51.9961},\n            {\"Mn\",   54.938044},\n            {\"Fe\",   55.845},\n            {\"Co\",   58.933194},\n            {\"Ni\",   58.6934},\n            {\"Cu\",   63.546},\n            {\"Zn\",   65.38},\n            {\"Ga\",   69.723},\n            {\"Ge\",   72.630},\n            {\"As\",   74.921595},\n            {\"Se\",   78.971},\n            {\"Br\",   79.904},\n            {\"Kr\",   83.798},\n            {\"Rb\",   85.4678},\n            {\"Sr\",   87.62},\n            {\"Y\",    88.90584},\n            {\"Zr\",   91.224},\n            {\"Nb\",   92.90637},\n            {\"Mo\",   95.95},\n            {\"Ru\",  101.07},\n            {\"Rh\",  102.90550},\n            {\"Pd\",  106.42},\n            {\"Ag\",  107.8682},\n            {\"Cd\",  112.414},\n            {\"In\",  114.818},\n            {\"Sn\",  118.710},\n            {\"Sb\",  121.760},\n            {\"Te\",  127.60},\n            {\"I\",   126.90447},\n            {\"Xe\",  131.293},\n            {\"Cs\",  132.90545196},\n            {\"Ba\",  137.327},\n            {\"La\",  138.90547},\n            {\"Ce\",  140.116},\n            {\"Pr\",  140.90766},\n            {\"Nd\",  144.242},\n            {\"Pm\",  145},\n            {\"Sm\",  150.36},\n            {\"Eu\",  151.964},\n            {\"Gd\",  157.25},\n            {\"Tb\",  158.92535},\n            {\"Dy\",  162.500},\n            {\"Ho\",  164.93033},\n            {\"Er\",  167.259},\n            {\"Tm\",  168.93422},\n            {\"Yb\",  173.054},\n            {\"Lu\",  174.9668},\n            {\"Hf\",  178.49},\n            {\"Ta\",  180.94788},\n            {\"W\",   183.84},\n            {\"Re\",  186.207},\n            {\"Os\",  190.23},\n            {\"Ir\",  192.217},\n            {\"Pt\",  195.084},\n            {\"Au\",  196.966569},\n            {\"Hg\",  200.592},\n            {\"Tl\",  204.38},\n            {\"Pb\",  207.2},\n            {\"Bi\",  208.98040},\n            {\"Po\",  209},\n            {\"At\",  210},\n            {\"Rn\",  222},\n            {\"Fr\",  223},\n            {\"Ra\",  226},\n            {\"Ac\",  227},\n            {\"Th\",  232.0377},\n            {\"Pa\",  231.03588},\n            {\"U\",   238.02891},\n            {\"Np\",  237},\n            {\"Pu\",  244},\n            {\"Am\",  243},\n            {\"Cm\",  247},\n            {\"Bk\",  247},\n            {\"Cf\",  251},\n            {\"Es\",  252},\n            {\"Fm\",  257},\n            {\"Uue\", 315},\n            {\"Ubn\", 299},\n        };\n\n        static double Evaluate(string s) {\n            s += \"[\";\n            double sum = 0.0;\n            string symbol = \"\";\n            string number = \"\";\n            for (int i = 0; i < s.Length; ++i) {\n                var c = s[i];\n                if ('@' <= c && c <= '[') {\n                    \n                    int n = 1;\n                    if (number != \"\") {\n                        n = int.Parse(number);\n                    }\n                    if (symbol != \"\") {\n                        sum += atomicMass[symbol] * n;\n                    }\n                    if (c == '[') {\n                        break;\n                    }\n                    symbol = c.ToString();\n                    number = \"\";\n                } else if ('a' <= c && c <= 'z') {\n                    symbol += c;\n                } else if ('0' <= c && c <= '9') {\n                    number += c;\n                } else {\n                    throw new Exception(string.Format(\"Unexpected symbol {0} in molecule\", c));\n                }\n            }\n            return sum;\n        }\n\n        \n        static string ReplaceFirst(string text, string search, string replace) {\n            int pos = text.IndexOf(search);\n            if (pos < 0) {\n                return text;\n            }\n            return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);\n        }\n\n        static string ReplaceParens(string s) {\n            char letter = 's';\n            while (true) {\n                var start = s.IndexOf('(');\n                if (start == -1) {\n                    break;\n                }\n\n                for (int i = start + 1; i < s.Length; ++i) {\n                    if (s[i] == ')') {\n                        var expr = s.Substring(start + 1, i - start - 1);\n                        var symbol = string.Format(\"@{0}\", letter);\n                        s = ReplaceFirst(s, s.Substring(start, i + 1 - start), symbol);\n                        atomicMass[symbol] = Evaluate(expr);\n                        letter++;\n                        break;\n                    }\n                    if (s[i] == '(') {\n                        start = i;\n                        continue;\n                    }\n                }\n            }\n            return s;\n        }\n\n        static void Main() {\n            var molecules = new string[]{\n                \"H\", \"H2\", \"H2O\", \"H2O2\", \"(HO)2\", \"Na2SO4\", \"C6H12\",\n                \"COOH(C(CH3)2)3CH3\", \"C6H4O2(OH)4\", \"C27H46O\", \"Uue\"\n            };\n            foreach (var molecule in molecules) {\n                var mass = Evaluate(ReplaceParens(molecule));\n                Console.WriteLine(\"{0,17} -> {1,7:0.000}\", molecule, mass);\n            }\n        }\n    }\n}\n"}
{"id": 400295, "name": "Snake and ladder", "source": "Translate Perl to C#: \nmy %snl =( 4, 14,  9, 31, 17,  7, 20, 38, 28, 84, 40, 59, 51, 67, 54, 34,\n          62, 19, 63, 81, 64, 60, 71, 91, 87, 24, 93, 73, 95, 75, 99, 78);\n\n@players = (1, 1, 1, 1); \n\nwhile () {\n    for $player (0..$\n       $turn_count++;\n       turn(\\$players[$player], $player + 1, $turn_count);\n    }\n}\n\nsub turn {\n    my($square, $player) = @_;\n    if ($player == @players) { print \"You are on square $$square. Hit enter to roll the die:\"; <> }\n    my $roll = 1 + int rand 6;\n    my $turn = $$square + $roll;\n    print \"Player $player on square %2d rolls a $roll\", $$square;\n    if ($turn > 100) {\n       print \" but cannot move. Next players turn.\\n\";\n       return\n    }\n    if ($snl{$turn}) {\n        $$square = $snl{$turn};\n        if ($turn > $$square) {\n           print \". Oops! Landed on a snake. Slither down to $$square.\\n\"\n        } else {\n           print \". Yay! Landed on a ladder. Climb up to $$square.\\n\"\n        }\n    } else {\n        $$square = $turn;\n        print \" and moves to square $$square\\n\";\n    }\n    if ($$square == 100) {print \"Player $player wins after $turn_count turns.\\n\"; exit }\n    return\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SnakeAndLadder {\n    class Program {\n        private static Dictionary<int, int> snl = new Dictionary<int, int>() {\n            {4, 14},\n            {9, 31},\n            {17, 7},\n            {20, 38},\n            {28, 84},\n            {40, 59},\n            {51, 67},\n            {54, 34},\n            {62, 19},\n            {63, 81},\n            {64, 60},\n            {71, 91},\n            {87, 24},\n            {93, 73},\n            {95, 75},\n            {99, 78},\n        };\n        private static Random rand = new Random();\n        private const bool sixesThrowAgain = true;\n\n        static int Turn(int player, int square) {\n            while (true) {\n                int roll = rand.Next(1, 6);\n                Console.Write(\"Player {0}, on square {1}, rolls a {2}\", player, square, roll);\n                if (square + roll > 100) {\n                    Console.WriteLine(\" but cannot move.\");\n                } else {\n                    square += roll;\n                    Console.WriteLine(\" and moves to square {0}\", square);\n                    if (square == 100) return 100;\n                    int next = square;\n                    if (snl.ContainsKey(square)) {\n                        next = snl[square];\n                    }\n                    if (square < next) {\n                        Console.WriteLine(\"Yay! Landed on a ladder. Climb up to {0}.\", next);\n                        if (next == 100) return 100;\n                        square = next;\n                    } else if (square > next) {\n                        Console.WriteLine(\"Oops! Landed on a snake. Slither down to {0}.\", next);\n                    }\n                }\n                if (roll < 6 || !sixesThrowAgain) return square;\n                Console.WriteLine(\"Rolled a 6 so roll again.\");\n            }\n        }\n\n        static void Main(string[] args) {\n            \n            int[] players = { 1, 1, 1 };\n            while (true) {\n                for (int i = 0; i < players.Length; i++) {\n                    int ns = Turn(i + 1, players[i]);\n                    if (ns == 100) {\n                        Console.WriteLine(\"Player {0} wins!\", i + 1);\n                        return;\n                    }\n                    players[i] = ns;\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 400296, "name": "Snake and ladder", "source": "Translate Perl to C#: \nmy %snl =( 4, 14,  9, 31, 17,  7, 20, 38, 28, 84, 40, 59, 51, 67, 54, 34,\n          62, 19, 63, 81, 64, 60, 71, 91, 87, 24, 93, 73, 95, 75, 99, 78);\n\n@players = (1, 1, 1, 1); \n\nwhile () {\n    for $player (0..$\n       $turn_count++;\n       turn(\\$players[$player], $player + 1, $turn_count);\n    }\n}\n\nsub turn {\n    my($square, $player) = @_;\n    if ($player == @players) { print \"You are on square $$square. Hit enter to roll the die:\"; <> }\n    my $roll = 1 + int rand 6;\n    my $turn = $$square + $roll;\n    print \"Player $player on square %2d rolls a $roll\", $$square;\n    if ($turn > 100) {\n       print \" but cannot move. Next players turn.\\n\";\n       return\n    }\n    if ($snl{$turn}) {\n        $$square = $snl{$turn};\n        if ($turn > $$square) {\n           print \". Oops! Landed on a snake. Slither down to $$square.\\n\"\n        } else {\n           print \". Yay! Landed on a ladder. Climb up to $$square.\\n\"\n        }\n    } else {\n        $$square = $turn;\n        print \" and moves to square $$square\\n\";\n    }\n    if ($$square == 100) {print \"Player $player wins after $turn_count turns.\\n\"; exit }\n    return\n}\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SnakeAndLadder {\n    class Program {\n        private static Dictionary<int, int> snl = new Dictionary<int, int>() {\n            {4, 14},\n            {9, 31},\n            {17, 7},\n            {20, 38},\n            {28, 84},\n            {40, 59},\n            {51, 67},\n            {54, 34},\n            {62, 19},\n            {63, 81},\n            {64, 60},\n            {71, 91},\n            {87, 24},\n            {93, 73},\n            {95, 75},\n            {99, 78},\n        };\n        private static Random rand = new Random();\n        private const bool sixesThrowAgain = true;\n\n        static int Turn(int player, int square) {\n            while (true) {\n                int roll = rand.Next(1, 6);\n                Console.Write(\"Player {0}, on square {1}, rolls a {2}\", player, square, roll);\n                if (square + roll > 100) {\n                    Console.WriteLine(\" but cannot move.\");\n                } else {\n                    square += roll;\n                    Console.WriteLine(\" and moves to square {0}\", square);\n                    if (square == 100) return 100;\n                    int next = square;\n                    if (snl.ContainsKey(square)) {\n                        next = snl[square];\n                    }\n                    if (square < next) {\n                        Console.WriteLine(\"Yay! Landed on a ladder. Climb up to {0}.\", next);\n                        if (next == 100) return 100;\n                        square = next;\n                    } else if (square > next) {\n                        Console.WriteLine(\"Oops! Landed on a snake. Slither down to {0}.\", next);\n                    }\n                }\n                if (roll < 6 || !sixesThrowAgain) return square;\n                Console.WriteLine(\"Rolled a 6 so roll again.\");\n            }\n        }\n\n        static void Main(string[] args) {\n            \n            int[] players = { 1, 1, 1 };\n            while (true) {\n                for (int i = 0; i < players.Length; i++) {\n                    int ns = Turn(i + 1, players[i]);\n                    if (ns == 100) {\n                        Console.WriteLine(\"Player {0} wins!\", i + 1);\n                        return;\n                    }\n                    players[i] = ns;\n                    Console.WriteLine();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 400297, "name": "Farey sequence", "source": "Translate Perl to C#: use warnings;\nuse strict;\nuse Math::BigRat;\nuse ntheory qw/euler_phi vecsum/;\n\nsub farey {\n  my $N = shift;\n  my @f;\n  my($m0,$n0, $m1,$n1) = (0, 1, 1, $N);\n  push @f, Math::BigRat->new(\"$m0/$n0\");\n  push @f, Math::BigRat->new(\"$m1/$n1\");\n  while ($f[-1] < 1) {\n    my $m = int( ($n0 + $N) / $n1) * $m1 - $m0;\n    my $n = int( ($n0 + $N) / $n1) * $n1 - $n0;\n    ($m0,$n0, $m1,$n1) = ($m1,$n1, $m,$n);\n    push @f, Math::BigRat->new(\"$m/$n\");\n  }\n  @f;\n}\nsub farey_count { 1 + vecsum(euler_phi(1, shift)); }\n\nfor (1 .. 11) {\n  my @f = map { join \"/\", $_->parts }   \n          farey($_);\n  print \"F$_: [@f]\\n\";\n}\nfor (1 .. 10, 100000) {\n  print \"F${_}00: \", farey_count(100*$_), \" members\\n\";\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 400298, "name": "Farey sequence", "source": "Translate Perl to C#: use warnings;\nuse strict;\nuse Math::BigRat;\nuse ntheory qw/euler_phi vecsum/;\n\nsub farey {\n  my $N = shift;\n  my @f;\n  my($m0,$n0, $m1,$n1) = (0, 1, 1, $N);\n  push @f, Math::BigRat->new(\"$m0/$n0\");\n  push @f, Math::BigRat->new(\"$m1/$n1\");\n  while ($f[-1] < 1) {\n    my $m = int( ($n0 + $N) / $n1) * $m1 - $m0;\n    my $n = int( ($n0 + $N) / $n1) * $n1 - $n0;\n    ($m0,$n0, $m1,$n1) = ($m1,$n1, $m,$n);\n    push @f, Math::BigRat->new(\"$m/$n\");\n  }\n  @f;\n}\nsub farey_count { 1 + vecsum(euler_phi(1, shift)); }\n\nfor (1 .. 11) {\n  my @f = map { join \"/\", $_->parts }   \n          farey($_);\n  print \"F$_: [@f]\\n\";\n}\nfor (1 .. 10, 100000) {\n  print \"F${_}00: \", farey_count(100*$_), \" members\\n\";\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 400299, "name": "Implicit type conversion", "source": "Translate Perl to C#: print  1  + '2';  \nprint '1' + '2';  \nprint  1  .  1;   \n\n$a = 1;\n$b = 2;\nsay \"$a+$b\";  \n\n\nsay hex int( (2 . 0 x '2') ** substr 98.5, '2', '2' ) . 'beef'; \n", "target": "byte aByte = 2;\nshort aShort = aByte;\nint anInt = aShort;\nlong aLong = anInt;\n\nfloat aFloat = 1.2f;\ndouble aDouble = aFloat;\n\nBigInteger b = 5;\nComplex c = 2.5; \n"}
{"id": 400300, "name": "Magnanimous numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\n\nsub magnanimous {\n    my($n) = @_;\n    my $last;\n    for my $c (1 .. length($n) - 1) {\n        ++$last and last unless is_prime substr($n,0,$c) + substr($n,$c)\n    }\n    not $last;\n}\n\nmy @M;\nfor ( my $i = 0, my $count = 0; $count < 400; $i++ ) {\n    ++$count and push @M, $i if magnanimous($i);\n}\n\nsay \"First 45 magnanimous numbers\\n\".\n    (sprintf \"@{['%4d' x 45]}\", @M[0..45-1]) =~ s/(.{60})/$1\\n/gr;\n\nsay \"241st through 250th magnanimous numbers\\n\" .\n    join ' ', @M[240..249];\n\nsay \"\\n391st through 400th magnanimous numbers\\n\".\n    join ' ', @M[390..399];\n", "target": "using System; using static System.Console;\n\nclass Program {\n\n  static bool[] np; \n\n  static void ms(long lmt) { \n    np = new bool[lmt]; np[0] = np[1] = true;\n    for (long n = 2, j = 1; n < lmt; n += j, j = 2) if (!np[n])\n        for (long k = n * n; k < lmt; k += n) np[k] = true; }\n\n  static bool is_Mag(long n) { long res, rem;\n    for (long p = 10; n >= p; p *= 10) {\n      res = Math.DivRem (n, p, out rem);\n      if (np[res + rem]) return false; } return true; }\n\n  static void Main(string[] args) { ms(100_009); string mn;\n    WriteLine(\"First 45{0}\", mn = \" magnanimous numbers:\");\n    for (long l = 0, c = 0; c < 400; l++) if (is_Mag(l)) {\n      if (c++ < 45 || (c > 240 && c <= 250) || c > 390)\n        Write(c <= 45 ? \"{0,4} \" : \"{0,8:n0} \", l);\n      if (c < 45 && c % 15 == 0) WriteLine();\n      if (c == 240) WriteLine (\"\\n\\n241st through 250th{0}\", mn);\n      if (c == 390) WriteLine (\"\\n\\n391st through 400th{0}\", mn); } }\n}\n"}
{"id": 400301, "name": "Mersenne primes", "source": "Translate Perl to C#: use ntheory qw/forprimes is_mersenne_prime/;\nforprimes { is_mersenne_prime($_) && say } 1e9;\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 400302, "name": "Mersenne primes", "source": "Translate Perl to C#: use ntheory qw/forprimes is_mersenne_prime/;\nforprimes { is_mersenne_prime($_) && say } 1e9;\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 400303, "name": "Taxicab numbers", "source": "Translate Perl to C#: my($beg, $end) = (@ARGV==0) ? (1,25) : (@ARGV==1) ? (1,shift) : (shift,shift);\n\nmy $lim = 1e14;  \nmy @basis = map { $_*$_*$_ } (1 .. int($lim ** (1.0/3.0) + 1));\nmy $paira = 2;  \n\nmy ($segsize, $low, $high, $i) = (500_000_000, 0, 0, 0);\n\nwhile ($i < $end) {\n  $low = $high+1;\n  die \"lim too low\" if $low > $lim;\n  $high = $low + $segsize - 1;\n  $high = $lim if $high > $lim;\n  foreach my $p (_find_pairs_segment(\\@basis, $paira, $low, $high,\n                 sub { sprintf(\"%4d^3 + %4d^3\", $_[0], $_[1]) })    ) {\n    $i++;\n    next if $i < $beg;\n    last if $i > $end;\n    my $n = shift @$p;\n    printf \"%4d: %10d  = %s\\n\", $i, $n, join(\"  = \", @$p);\n  }\n}\n\nsub _find_pairs_segment {\n  my($p, $len, $start, $end, $formatsub) = @_;\n  my $plen = $\n\n  my %allpairs;\n  foreach my $i (0 .. $plen) {\n    my $pi = $p->[$i];\n    next if ($pi+$p->[$plen]) < $start;\n    last if (2*$pi) > $end;\n    foreach my $j ($i .. $plen) {\n      my $sum = $pi + $p->[$j];\n      next if $sum < $start;\n      last if $sum > $end;\n      push @{ $allpairs{$sum} }, $i, $j;\n    }\n    \n    \n  }\n\n  my @retlist;\n  foreach my $list (grep { scalar @$_ >= $len*2 } values %allpairs) {\n    my $n = $p->[$list->[0]] + $p->[$list->[1]];\n    my @pairlist;\n    while (@$list) {\n      push @pairlist, $formatsub->(1 + shift @$list, 1 + shift @$list);\n    }\n    push @retlist, [$n, @pairlist];\n  }\n  @retlist = sort { $a->[0] <=> $b->[0] } @retlist;\n  return @retlist;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace TaxicabNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IDictionary<long, IList<Tuple<int, int>>> taxicabNumbers = GetTaxicabNumbers(2006);\n            PrintTaxicabNumbers(taxicabNumbers);\n            Console.ReadKey();\n        }\n\n        private static IDictionary<long, IList<Tuple<int, int>>> GetTaxicabNumbers(int length)\n        {\n            SortedList<long, IList<Tuple<int, int>>> sumsOfTwoCubes = new SortedList<long, IList<Tuple<int, int>>>();\n\n            for (int i = 1; i < int.MaxValue; i++)\n            {\n                for (int j = 1; j < int.MaxValue; j++)\n                {\n                    long sum = (long)(Math.Pow((double)i, 3) + Math.Pow((double)j, 3));\n\n                    if (!sumsOfTwoCubes.ContainsKey(sum))\n                    {\n                        sumsOfTwoCubes.Add(sum, new List<Tuple<int, int>>());\n                    }\n\n                    sumsOfTwoCubes[sum].Add(new Tuple<int, int>(i, j));\n\n                    if (j >= i)\n                    {\n                        break;\n                    }\n                }\n\n                \n                if (sumsOfTwoCubes.Count(t => t.Value.Count >= 2) >= length * 1.1)\n                {\n                    break;\n                }\n            }\n\n            IDictionary<long, IList<Tuple<int, int>>> values = (from t in sumsOfTwoCubes where t.Value.Count >= 2 select t)\n                .Take(2006)\n                .ToDictionary(u => u.Key, u => u.Value);\n\n            return values;\n        }\n\n        private static void PrintTaxicabNumbers(IDictionary<long, IList<Tuple<int, int>>> values)\n        {\n            int i = 1;\n\n            foreach (long taxicabNumber in values.Keys)\n            {\n                StringBuilder output = new StringBuilder().AppendFormat(\"{0,10}\\t{1,4}\", i, taxicabNumber);\n\n                foreach (Tuple<int, int> numbers in values[taxicabNumber])\n                {\n                    output.AppendFormat(\"\\t= {0}^3 + {1}^3\", numbers.Item1, numbers.Item2);\n                }\n\n                if (i <= 25 || (i >= 2000 && i <= 2006))\n                {\n                    Console.WriteLine(output.ToString());\n                }\n\n                i++;\n            }\n        }\n    }\n}\n"}
{"id": 400304, "name": "Strong and weak primes", "source": "Translate Perl to C#: use ntheory qw(primes vecfirst);\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    $s =~ s/,(-?)$/$1/;\n    $s = reverse $s;\n}\n\nsub below { my ($m, @a) = @_; vecfirst { $a[$_] > $m } 0..$\n\nmy (@strong, @weak, @balanced);\nmy @primes = @{ primes(10_000_019) };\n\nfor my $k (1 .. $\n    my $x = ($primes[$k - 1] + $primes[$k + 1]) / 2;\n    if    ($x > $primes[$k]) { push @weak,     $primes[$k] }\n    elsif ($x < $primes[$k]) { push @strong,   $primes[$k] }\n    else                     { push @balanced, $primes[$k] }\n}\n\nfor ([\\@strong,   'strong',   36, 1e6, 1e7],\n     [\\@weak,     'weak',     37, 1e6, 1e7],\n     [\\@balanced, 'balanced', 28, 1e6, 1e7]) {\n    my($pr, $type, $d, $c1, $c2) = @$_;\n    print \"\\nFirst $d $type primes:\\n\", join ' ', map { comma $_ } @$pr[0..$d-1], \"\\n\";\n    print \"Count of $type primes <=  @{[comma $c1]}:  \" . comma below($c1,@$pr) . \"\\n\";\n    print \"Count of $type primes <= @{[comma $c2]}: \"   . comma scalar @$pr . \"\\n\";\n}\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\nusing System;\n\npublic static class StrongAndWeakPrimes\n{\n    public static void Main() {\n        var primes = PrimeGenerator(10_000_100).ToList();\n        var strongPrimes = from i in Range(1, primes.Count - 2) where primes[i] > (primes[i-1] + primes[i+1]) / 2 select primes[i];\n        var weakPrimes = from i in Range(1, primes.Count - 2) where primes[i] < (primes[i-1] + primes[i+1]) / 2.0 select primes[i];\n        WriteLine($\"First 36 strong primes: {string.Join(\", \", strongPrimes.Take(36))}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 1_000_000).Count():N0} strong primes below {1_000_000:N0}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 10_000_000).Count():N0} strong primes below {10_000_000:N0}\");\n        WriteLine($\"First 37 weak primes: {string.Join(\", \", weakPrimes.Take(37))}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 1_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 10_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n    }\n   \n}\n"}
{"id": 400305, "name": "Left factorials", "source": "Translate Perl to C#: \nuse 5.010;\nuse strict;\nuse warnings;\nuse bigint;\n\nsub leftfact {\n\tmy ($n) = @_;\n\tstate $cached = 0;\n\tstate $factorial = 1;\n\tstate $leftfact = 0;\n\tif( $n < $cached ) {\n\t\t($cached, $factorial, $leftfact) = (0, 1, 0);\n\t}\n\twhile( $n > $cached ) {\n\t\t$leftfact += $factorial;\n\t\t$factorial *= ++$cached;\n\t}\n\treturn $leftfact;\n}\n\nprintf \"!%d = %s\\n\", $_, leftfact($_) for 0 .. 10, map $_*10, 2..11;\nprintf \"!%d has %d digits.\\n\", $_, length leftfact($_) for map $_*1000, 1..10;\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 400306, "name": "Left factorials", "source": "Translate Perl to C#: \nuse 5.010;\nuse strict;\nuse warnings;\nuse bigint;\n\nsub leftfact {\n\tmy ($n) = @_;\n\tstate $cached = 0;\n\tstate $factorial = 1;\n\tstate $leftfact = 0;\n\tif( $n < $cached ) {\n\t\t($cached, $factorial, $leftfact) = (0, 1, 0);\n\t}\n\twhile( $n > $cached ) {\n\t\t$leftfact += $factorial;\n\t\t$factorial *= ++$cached;\n\t}\n\treturn $leftfact;\n}\n\nprintf \"!%d = %s\\n\", $_, leftfact($_) for 0 .. 10, map $_*10, 2..11;\nprintf \"!%d has %d digits.\\n\", $_, length leftfact($_) for map $_*1000, 1..10;\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 400307, "name": "Strange unique prime triplets", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse List::Util 'sum';\nuse ntheory <primes is_prime>;\nuse Algorithm::Combinatorics 'combinations';\n\nfor my $n (30, 1000) {\n    printf \"Found %d strange unique prime triplets up to $n.\\n\",\n        scalar grep { is_prime(sum @$_) } combinations(primes($n), 3);\n}\n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 400308, "name": "Strange unique prime triplets", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse List::Util 'sum';\nuse ntheory <primes is_prime>;\nuse Algorithm::Combinatorics 'combinations';\n\nfor my $n (30, 1000) {\n    printf \"Found %d strange unique prime triplets up to $n.\\n\",\n        scalar grep { is_prime(sum @$_) } combinations(primes($n), 3);\n}\n", "target": "using System; using System.Collections.Generic; using static System.Console; using System.Linq; using DT = System.DateTime;\n\nclass Program { static void Main(string[] args) { string s;\n  foreach (int lmt in new int[]{ 90, 300, 3000, 30000, 111000 }) {\n    var pr = PG.Primes(lmt).Skip(1).ToList(); DT st = DT.Now;\n    int d, f = 0; var r = new List<string>();\n    int i = -1, m, h = (m = lmt / 3), j, k, pra, prab;\n    while (i < 0) i = pr.IndexOf(h--); k = (j = i - 1) - 1;\n    for (int a = 0; a <= k; a++) { pra = pr[a];\n    for (int b = a + 1; b <= j; b++) { prab = pra + pr[b]; \n    for (int c = b + 1; c <= i; c++) {\n      if (PG.flags[d = prab + pr[c]]) continue; f++;\n      if (lmt < 100) r.Add(string.Format(\"{3,5} = {0,2} + {1,2} + {2,2}\", pra, pr[b], pr[c], d)); } } }\n    s = \"s.u.p.t.s under \"; r.Sort(); if (r.Count > 0) WriteLine(\"{0}{1}:\\n{2}\", s, m, string.Join(\"\\n\", r));\n    if (lmt > 100) WriteLine(\"Count of {0}{1,6:n0}: {2,13:n0}  {3} sec\", s, m, f, (DT.Now - st).ToString().Substring(6)); } } }\n\nclass PG { public static bool[] flags;\n  public static IEnumerable<int> Primes(int lim) {\n  flags = new bool[lim + 1]; int j = 2;\n  for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n    if (!flags[j]) { yield return j;\n      for (int k = sq; k <= lim; k += j) flags[k] = true; }\n  for (; j <= lim; j++) if (!flags[j]) yield return j; } }\n"}
{"id": 400309, "name": "Motzkin numbers", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nsub motzkin\n  {\n  my $N = shift;\n  my @m = ( 0, 1, 1 );\n  for my $i ( 3 .. $N )\n    {\n    $m[$i] = ($m[$i - 1] * (2 * $i - 1) + $m[$i - 2] * (3 * $i - 6)) / ($i + 1);\n    }\n  return splice @m, 1;\n  }\n\nprint \"  n          M[n]\\n\";\nmy $count = 0;\nfor ( motzkin(42) )\n  {\n  printf \"%3d%25s  %s\\n\", $count++, s/\\B(?=(\\d\\d\\d)+$)/,/gr,\n    is_prime($_) ? 'prime' : '';\n  }\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n  \n  static bool hmf(BI x) {\n    if (x < 4) return x == 1;\n    if ((x & 1) == 0 || x % 3 == 0) return true;\n    int l = (int)Math.Sqrt((double)x); \n    for (int j = 5, d = 4; j <= l; j += d = 6 - d)\n      if (x % j == 0) return x > j;\n    return false;\n  }\n \n  static void Main(string[] args) {\n    BI a = 0, b = 1, t;\n    int n = 1, s = 0, d = 1, c = 0, f = 1;\n    while (n <= 80)\n      Console.WriteLine(\"{0,46:n0} {1}\",\n        t = b / n++,\n        hmf(t) ? \"\" : \"is prime.\",\n        t = b,\n        b = ((c += d * 3 + 3) * a +\n             (f += d * 2 + 3) * b) /\n             (s += d += 2),\n        a = t);\n  }\n}\n"}
{"id": 400310, "name": "Self numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util qw(max sum);\n\nmy ($i, $pow, $digits, $offset, $lastSelf, @selfs)\n = ( 1,   10,       1,       9,         0,       );\n\nmy $final = 50;\n\nwhile () {\n   my $isSelf = 1;\n   my $sum = my $start = sum split //, max(($i-$offset), 0);\n   for ( my $j = $start; $j < $i; $j++ ) {\n      if ($j+$sum == $i) { $isSelf = 0 ; last }\n      ($j+1)%10 != 0 ? $sum++ : ( $sum = sum split '', ($j+1) );\n   }\n\n   if ($isSelf) {\n      push @selfs, $lastSelf = $i;\n      last if @selfs == $final;\n   }\n\n   next unless ++$i % $pow == 0;\n   $pow *= 10;\n   $offset = 9 * $digits++\n}\n\nsay \"The first 50 self numbers are:\\n\" . join ' ', @selfs;\n", "target": "using System;\nusing static System.Console;\n\nclass Program {\n\n  const int mc = 103 * 1000 * 10000 + 11 * 9 + 1;\n\n  static bool[] sv = new bool[mc + 1];\n\n  static void sieve() { int[] dS = new int[10000];\n    for (int a = 9, i = 9999; a >= 0; a--)\n      for (int b = 9; b >= 0; b--)\n        for (int c = 9, s = a + b; c >= 0; c--)\n          for (int d = 9, t = s + c; d >= 0; d--)\n            dS[i--] = t + d;\n    for (int a = 0, n = 0; a < 103; a++)\n      for (int b = 0, d = dS[a]; b < 1000; b++, n += 10000)\n        for (int c = 0, s = d + dS[b] + n; c < 10000; c++)\n          sv[dS[c] + s++] = true; }\n\n  static void Main() { DateTime st = DateTime.Now; sieve();\n    WriteLine(\"Sieving took {0}s\", (DateTime.Now - st).TotalSeconds); \n    WriteLine(\"\\nThe first 50 self numbers are:\");\n    for (int i = 0, count = 0; count <= 50; i++) if (!sv[i]) {\n        count++; if (count <= 50) Write(\"{0} \", i);\n        else WriteLine(\"\\n\\n       Index     Self number\"); }\n    for (int i = 0, limit = 1, count = 0; i < mc; i++)\n      if (!sv[i]) if (++count == limit) {\n          WriteLine(\"{0,12:n0} \u00a0 {1,13:n0}\", count, i);\n          if (limit == 1e9) break; limit *= 10; }\n    WriteLine(\"\\nOverall took {0}s\", (DateTime.Now - st). TotalSeconds);\n  }\n}\n"}
{"id": 400311, "name": "Pythagorean quadruples", "source": "Translate Perl to C#: my $N = 2200;\npush @sq, $_**2 for 0 .. $N;\nmy @not = (0) x $N;\n@not[0] = 1;\n\n\nfor my $d (1 .. $N) {\n    my $last = 0;\n    for my $a (reverse ceiling($d/3) .. $d) {\n        for my $b (1 .. ceiling($a/2)) {\n            my $ab = $sq[$a] + $sq[$b];\n            last if $ab > $sq[$d];\n            my $x = sqrt($sq[$d] - $ab);\n            if ($x == int $x) {\n                $not[$d] = 1;\n                $last = 1;\n                last\n            }\n        }\n        last if $last;\n    }\n}\n\nsub ceiling { int $_[0] + 1 - 1e-15 }\n\nfor (0 .. $\n    $result .= \"$_ \" unless $not[$_]\n}\nprint \"$result\\n\"\n", "target": "using System;\n\nnamespace PythagoreanQuadruples {\n    class Program {\n        const int MAX = 2200;\n        const int MAX2 = MAX * MAX * 2;\n\n        static void Main(string[] args) {\n            bool[] found = new bool[MAX + 1]; \n            bool[] a2b2 = new bool[MAX2 + 1]; \n            int s = 3;\n\n            for(int a = 1; a <= MAX; a++) {\n                int a2 = a * a;\n                for (int b=a; b<=MAX; b++) {\n                    a2b2[a2 + b * b] = true;\n                }\n            }\n\n            for (int c = 1; c <= MAX; c++) {\n                int s1 = s;\n                s += 2;\n                int s2 = s;\n                for (int d = c + 1; d <= MAX; d++) {\n                    if (a2b2[s1]) found[d] = true;\n                    s1 += s2;\n                    s2 += 2;\n                }\n            }\n\n            Console.WriteLine(\"The values of d <= {0} which can't be represented:\", MAX);\n            for (int d = 1; d < MAX; d++) {\n                if (!found[d]) Console.Write(\"{0}  \", d);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400312, "name": "Sum and product puzzle", "source": "Translate Perl to C#: use List::Util qw(none);\n\nsub grep_unique {\n    my($by, @list) = @_;\n    my @seen;\n    for (@list) {\n        my $x = &$by(@$_);\n        $seen[$x]= defined $seen[$x] ? 0 : join ' ', @$_;\n    }\n    grep { $_ } @seen;\n}\n\nsub sums {\n    my($n) = @_;\n    my @sums;\n    push @sums, [$_, $n - $_] for 2 .. int $n/2;\n    @sums;\n}\n\nsub sum     { $_[0] + $_[1] }\nsub product { $_[0] * $_[1] }\n\nfor $i (2..97) {\n    push @all_pairs, map { [$i, $_] } $i + 1..98\n}\n\n\n%p_unique = map { $_ => 1 } grep_unique(\\&product, @all_pairs);\nfor my $p (@all_pairs) {\n    push @s_pairs, [@$p] if none { $p_unique{join ' ', @$_} } sums sum @$p;\n}\n\n\n@p_pairs = map { [split ' ', $_] } grep_unique(\\&product, @s_pairs);\n\n\n@final_pair = grep_unique(\\&sum, @p_pairs);\n\nprintf \"X = %d, Y = %d\\n\", split ' ', $final_pair[0];\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        const int maxSum = 100;\n        var pairs = (\n            from X in 2.To(maxSum / 2 - 1)\n            from Y in (X + 1).To(maxSum - 2).TakeWhile(y => X + y <= maxSum)\n            select new { X, Y, S = X + Y, P = X * Y }\n            ).ToHashSet();\n\n        Console.WriteLine(pairs.Count);\n        \n        var uniqueP = pairs.GroupBy(pair => pair.P).Where(g => g.Count() == 1).Select(g => g.Key).ToHashSet();\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Any(pair => uniqueP.Contains(pair.P))).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.P).Where(g => g.Count() > 1).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Count() > 1).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        foreach (var pair in pairs) Console.WriteLine(pair);\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i <= end; i++) yield return i;\n    }\n    \n    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);\n}\n"}
{"id": 400313, "name": "Minimum primes", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse ntheory qw( next_prime );\nuse List::Util qw( max );\n\nmy @Numbers1 = (5,45,23,21,67);\nmy @Numbers2 = (43,22,78,46,38);\nmy @Numbers3 = (9,98,12,54,53);\n\nmy @Primes = map {\n  next_prime( max( $Numbers1[$_], $Numbers2[$_], $Numbers3[$_] ) - 1 )\n  } 0 .. 4;\n\nprint \"@Primes\\n\";\n", "target": "using System;\nusing System.Linq;\nusing static System.Console;\n\nclass Program {\n\n  static int nxtPrime(int x) {\n    int j = 2; do {\n        if (x % j == 0) { j = 2; x++; }\n        else j += j < 3 ? 1 : 2;\n    } while (j * j <= x); return x; }\n\n  static void Main(string[] args) {\n    WriteLine(\"working...\");\n    int[] Num1 = new int[]{  5, 45, 23, 21, 67 },\n          Num2 = new int[]{ 43, 22, 78, 46, 38 },\n          Num3 = new int[]{  9, 98, 12, 54, 53 };\n    int n = Num1.Length; int[] Nums = new int[n];\n    for (int i = 0; i < n; i++)\n      Nums[i] = nxtPrime(new int[]{ Num1[i], Num2[i], Num3[i] }.Max());\n    WriteLine(\"The minimum prime numbers of three lists = [{0}]\", string.Join(\",\", Nums));\n    Write(\"done...\"); } }\n"}
{"id": 400314, "name": "Linux CPU utilization", "source": "Translate Perl to C#: $last_total = 0;\n$last_idle  = 0;\n\nwhile () {\n    @cpu = split /\\s+/, `head -1 /proc/stat`;\n    shift @cpu;\n    $this_total  = 0;\n    $this_total += $_ for @cpu;\n    $delta_total = $this_total - $last_total;\n    $this_idle   = $cpu[3]     - $last_idle;\n    $delta_idle  = $this_idle  - $last_idle;\n    $last_total  = $this_total;\n    $last_idle   = $this_idle;\n    printf \"Utilization: %0.1f%%\\n\", 100 * (1 - $delta_idle / $delta_total);\n    sleep 1;\n}\n", "target": "var prevIdle = 0f;\nvar prevTotal = 0f;\n\nwhile (true)\n{\n    var cpuLine = File\n        .ReadAllLines(\"/proc/stat\")\n        .First()\n        .Split(' ', StringSplitOptions.RemoveEmptyEntries)\n        .Skip(1)\n        .Select(float.Parse)\n        .ToArray();\n\n    var idle = cpuLine[3];\n    var total = cpuLine.Sum();\n\n    var percent = 100.0 * (1.0 - (idle - prevIdle) / (total - prevTotal));\n    Console.WriteLine($\"{percent:0.00}%\");\n\n    prevIdle = idle;\n    prevTotal = total;\n\n    Thread.Sleep(1000);\n}\n"}
{"id": 400315, "name": "Type detection", "source": "Translate Perl to C#: $scalar    = 1;\n@array     = (1, 2);\n%hash      = ('a' => 1);\n$regex     = qr/foo.*bar/;\n$reference = \\%hash;\nsub greet { print \"Hello world!\" };\n$subref    = \\&greet;\n\n$fmt = \"%-11s is type:  %s\\n\";\nprintf $fmt, '$scalar',    ref(\\$scalar);\nprintf $fmt, '@array',     ref(\\@array);\nprintf $fmt, '%hash',      ref(\\%hash);\nprintf $fmt, '$regex',     ref( $regex);\nprintf $fmt, '$reference', ref(\\$reference);\nprintf $fmt, '$subref',    ref( $subref);\n", "target": "using System;\n\nnamespace TypeDetection {\n    class C { }\n    struct S { }\n    enum E {\n        NONE,\n    }\n\n    class Program {\n        static void ShowType<T>(T t) {\n            Console.WriteLine(\"The type of '{0}' is {1}\", t, t.GetType());\n        }\n\n        static void Main() {\n            ShowType(5);\n            ShowType(7.5);\n            ShowType('d');\n            ShowType(true);\n            ShowType(\"Rosetta\");\n            ShowType(new C());\n            ShowType(new S());\n            ShowType(E.NONE);\n            ShowType(new int[] { 1, 2, 3 });\n        }\n    }\n}\n"}
{"id": 400316, "name": "Primes which contain only one odd digit", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @singleodd = grep tr/13579// == 1, @{ primes(1e3) };\nmy $million = grep tr/13579// == 1, @{ primes(1e6) };\nprint \"found \" . @singleodd .\n  \"\\n\\n@singleodd\\n\\nfound $million in 1000000\\n\" =~ s/.{60}\\K /\\n/gr;\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    \n    \n    static List<uint> sieve(uint max, bool ordinary = false)\n    {\n        uint k = ((max - 3) >> 1) + 1,\n           lmt = ((uint)(Math.Sqrt(max++) - 3) >> 1) + 1;\n        var pl = new List<uint> { };\n        var ic = new bool[k];\n        for (uint i = 0, p = 3; i < lmt; i++, p += 2) if (!ic[i])\n                for (uint j = (p * p - 3) >> 1; j < k; j += p) ic[j] = true;\n        if (ordinary)\n        {\n            pl.Add(2);\n            for (uint i = 0, j = 3; i < k; i++, j += 2)\n                if (!ic[i]) pl.Add(j);\n        }\n        else\n            for (uint i = 0, j = 3, t = j; i < k; i++, t = j += 2)\n                if (!ic[i])\n                {\n                    while ((t /= 10) > 0)\n                        if (((t % 10) & 1) == 1) goto skip;\n                    pl.Add(j);\n                skip:;\n                }\n        return pl;\n    }\n\n    static void Main(string[] args)\n    {\n        var pl = sieve((uint)1e9);\n        uint c = 0, l = 10, p = 1;\n        Console.WriteLine(\"List of one-odd-digit primes < 1,000:\");\n        for (int i = 0; pl[i] < 1000; i++)\n            Console.Write(\"{0,3}{1}\", pl[i], i % 9 == 8 ? \"\\n\" : \"  \");\n        string fmt = \"\\nFound {0:n0} one-odd-digit primes < 10^{1} ({2:n0})\";\n        foreach (var itm in pl)\n            if (itm < l) c++;\n            else Console.Write(fmt, c++, p++, l, l *= 10);\n        Console.Write(fmt, c++, p++, l);\n    }\n}\n"}
{"id": 400317, "name": "Primes which contain only one odd digit", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @singleodd = grep tr/13579// == 1, @{ primes(1e3) };\nmy $million = grep tr/13579// == 1, @{ primes(1e6) };\nprint \"found \" . @singleodd .\n  \"\\n\\n@singleodd\\n\\nfound $million in 1000000\\n\" =~ s/.{60}\\K /\\n/gr;\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    \n    \n    static List<uint> sieve(uint max, bool ordinary = false)\n    {\n        uint k = ((max - 3) >> 1) + 1,\n           lmt = ((uint)(Math.Sqrt(max++) - 3) >> 1) + 1;\n        var pl = new List<uint> { };\n        var ic = new bool[k];\n        for (uint i = 0, p = 3; i < lmt; i++, p += 2) if (!ic[i])\n                for (uint j = (p * p - 3) >> 1; j < k; j += p) ic[j] = true;\n        if (ordinary)\n        {\n            pl.Add(2);\n            for (uint i = 0, j = 3; i < k; i++, j += 2)\n                if (!ic[i]) pl.Add(j);\n        }\n        else\n            for (uint i = 0, j = 3, t = j; i < k; i++, t = j += 2)\n                if (!ic[i])\n                {\n                    while ((t /= 10) > 0)\n                        if (((t % 10) & 1) == 1) goto skip;\n                    pl.Add(j);\n                skip:;\n                }\n        return pl;\n    }\n\n    static void Main(string[] args)\n    {\n        var pl = sieve((uint)1e9);\n        uint c = 0, l = 10, p = 1;\n        Console.WriteLine(\"List of one-odd-digit primes < 1,000:\");\n        for (int i = 0; pl[i] < 1000; i++)\n            Console.Write(\"{0,3}{1}\", pl[i], i % 9 == 8 ? \"\\n\" : \"  \");\n        string fmt = \"\\nFound {0:n0} one-odd-digit primes < 10^{1} ({2:n0})\";\n        foreach (var itm in pl)\n            if (itm < l) c++;\n            else Console.Write(fmt, c++, p++, l, l *= 10);\n        Console.Write(fmt, c++, p++, l);\n    }\n}\n"}
{"id": 400318, "name": "Safe primes and unsafe primes", "source": "Translate Perl to C#: use ntheory qw(forprimes is_prime);\n\nmy $upto = 1e7;\nmy %class = ( safe => [], unsafe => [2] );\n\nforprimes {\n    push @{$class{ is_prime(($_-1)>>1) ? 'safe' : 'unsafe' }}, $_;\n} 3, $upto;\n\nfor (['safe', 35], ['unsafe', 40]) {\n    my($type, $quantity) = @$_;\n    print  \"The first $quantity $type primes are:\\n\";\n    print join(\" \", map { comma($class{$type}->[$_-1]) } 1..$quantity), \"\\n\";\n    for my $q ($upto/10, $upto) {\n        my $n = scalar(grep { $_ <= $q } @{$class{$type}});\n        printf \"The number of $type primes up to %s: %s\\n\", comma($q), comma($n);\n    }\n}\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    $s =~ s/,(-?)$/$1/;\n    $s = reverse $s;\n}\n", "target": "using static System.Console;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class SafePrimes\n{\n    public static void Main() {\n        HashSet<int> primes = Primes(10_000_000).ToHashSet();\n        WriteLine(\"First 35 safe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsSafe).Take(35)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsSafe):n0} safe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsSafe):n0} safe primes below {10_000_000:n0}\");\n        WriteLine(\"First 40 unsafe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsUnsafe).Take(40)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsUnsafe):n0} unsafe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsUnsafe):n0} unsafe primes below {10_000_000:n0}\");\n\n        bool IsSafe(int prime) => primes.Contains(prime / 2);\n        bool IsUnsafe(int prime) => !primes.Contains(prime / 2);\n    }\n\n    \n    static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n}\n"}
{"id": 400319, "name": "Hash join", "source": "Translate Perl to C#: use Data::Dumper qw(Dumper);\n\nsub hashJoin {\n    my ($table1, $index1, $table2, $index2) = @_;\n    my %h;\n    \n    foreach my $s (@$table1) {\n\tpush @{ $h{$s->[$index1]} }, $s;\n    }\n    \n    map { my $r = $_;\n\t  map [$_, $r], @{ $h{$r->[$index2]} }\n    } @$table2;\n}\n\n@table1 = ([27, \"Jonah\"],\n           [18, \"Alan\"],\n           [28, \"Glory\"],\n           [18, \"Popeye\"],\n           [28, \"Alan\"]);\n@table2 = ([\"Jonah\", \"Whales\"],\n           [\"Jonah\", \"Spiders\"],\n           [\"Alan\", \"Ghosts\"],\n           [\"Alan\", \"Zombies\"],\n           [\"Glory\", \"Buffy\"]);\n\n$Data::Dumper::Indent = 0;\nforeach my $row (hashJoin(\\@table1, 1, \\@table2, 0)) {\n    print Dumper($row), \"\\n\";\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HashJoin\n{\n    public class AgeName\n    {\n        public AgeName(byte age, string name)\n        {\n            Age = age;\n            Name = name;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n    }\n\n    public class NameNemesis\n    {\n        public NameNemesis(string name, string nemesis)\n        {\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    public class DataContext\n    {\n        public DataContext()\n        {\n            AgeName = new List<AgeName>();\n            NameNemesis = new List<NameNemesis>();\n        }\n        public List<AgeName> AgeName { get; set; }\n        public List<NameNemesis> NameNemesis { get; set; }\n    }\n\n    public class AgeNameNemesis\n    {\n        public AgeNameNemesis(byte age, string name, string nemesis)\n        {\n            Age = age;\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    class Program\n    {\n        public static void Main()\n        {\n            var data = GetData();\n            var result = ExecuteHashJoin(data);\n            WriteResultToConsole(result);\n        }\n\n        private static void WriteResultToConsole(List<AgeNameNemesis> result)\n        {\n            result.ForEach(ageNameNemesis => Console.WriteLine(\"Age: {0}, Name: {1}, Nemesis: {2}\",\n                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));\n        }\n\n        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)\n        {\n            return (data.AgeName.Join(data.NameNemesis, \n                ageName => ageName.Name, nameNemesis => nameNemesis.Name,\n                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))\n                .ToList();\n        }\n\n        private static DataContext GetData()\n        {\n            var context = new DataContext();\n\n            context.AgeName.AddRange(new [] {\n                    new AgeName(27, \"Jonah\"), \n                    new AgeName(18, \"Alan\"), \n                    new AgeName(28, \"Glory\"), \n                    new AgeName(18, \"Popeye\"), \n                    new AgeName(28, \"Alan\")\n                });\n\n            context.NameNemesis.AddRange(new[]\n            {\n                new NameNemesis(\"Jonah\", \"Whales\"),\n                new NameNemesis(\"Jonah\", \"Spiders\"),\n                new NameNemesis(\"Alan\", \"Ghosts\"),\n                new NameNemesis(\"Alan\", \"Zombies\"),\n                new NameNemesis(\"Glory\", \"Buffy\")\n            });\n\n            return context;\n        }\n    }\n}\n"}
{"id": 400320, "name": "Largest palindrome product", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nfor my $l (2..7) {\n    LOOP:\n    for my $p (reverse map { $_ . reverse $_ } 10**($l-1) .. 10**$l - 1)  {\n        my @f = reverse grep { length == $l } divisors $p;\n        next unless @f >= 2 and $p == $f[0] * $f[1];\n        say \"Largest palindromic product of two @{[$l]}-digit integers: $f[1] \u00d7 $f[0] = $p\" and last LOOP;\n    }\n}\n", "target": "using System;\nclass Program {\n\n  static bool isPal(int n) {\n    int rev = 0, lr = -1, rem;\n    while (n > rev) {\n      n = Math.DivRem(n, 10, out rem);\n      if (lr < 0 && rem == 0) return false;\n      lr = rev; rev = 10 * rev + rem;\n      if (n == rev || n == lr) return true;\n    } return false; }\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    int x = 900009, y = (int)Math.Sqrt(x), y10, max = 999, max9 = max - 9, z, p, bp = x, ld, c;\n    var a = new int[]{ 0,9,0,3,0,0,0,7,0,1 }; string bs = \"\";\n    y /= 11;\n    if ((y & 1) == 0) y--;\n    if (y % 5 == 0) y -= 2;\n    y *= 11;\n    while (y <= max) {\n      c = 0;\n      y10 = y * 10;\n      z = max9 + a[ld = y % 10];\n      p = y * z;\n      while (p >= bp) {\n        if (isPal(p)) {\n          if (p > bp) bp = p;\n          bs = string.Format(\"{0} x {1} = {2}\", y, z - c, bp);\n        }\n        p -= y10; c += 10;\n      }\n      y += ld == 3 ? 44 : 22;\n    }\n    sw.Stop();\n    Console.Write(\"{0} {1} \u03bcs\", bs, sw.Elapsed.TotalMilliseconds * 1000.0);\n  }\n}\n"}
{"id": 400321, "name": "Find largest left truncatable prime in a given base", "source": "Translate Perl to C#: use ntheory qw/:all/;\nuse Math::GMPz;\n\nsub lltp {\n  my($n, $b, $best) = (shift, Math::GMPz->new(1));\n  my @v = map { Math::GMPz->new($_) } @{primes($n-1)};\n  while (@v) {\n    $best = vecmax(@v);\n    $b *= $n;\n    my @u;\n    foreach my $vi (@v) {\n      push @u, grep { is_prob_prime($_) } map { $vi + $_*$b } 1 .. $n-1;\n    }\n    @v = @u;\n  }\n  die unless is_provable_prime($best);\n  $best;\n}\n\nprintf \"%2d %s\\n\", $_, lltp($_)  for 3 .. 17;\n", "target": "using Mpir.NET;  \nusing System;   \nusing System.Collections.Generic;\nclass MaxLftTrP_B   \n{\n    static void Main()\n    {\n        mpz_t p; var sw = System.Diagnostics.Stopwatch.StartNew(); L(3);\n        for (uint b = 3; b < 13; b++)\n        {\n            sw.Restart(); p = L(b);\n            Console.WriteLine(\"{0} {1,2} {2}\", sw.Elapsed, b, p);\n        }\n        Console.Read();\n    }\n\n    static mpz_t L(uint b)\n    {\n        var p = new List<mpz_t>(); mpz_t np = 0;\n        while ((np = nxtP(np)) < b) p.Add(np);\n        int i0 = 0, i = 0, i1 = p.Count - 1; mpz_t n0 = b, n, n1 = b * (b - 1);\n        for (; i < p.Count; n0 *= b, n1 *= b, i0 = i1 + 1, i1 = p.Count - 1)\n            for (n = n0; n <= n1; n += n0)\n                for (i = i0; i <= i1; i++)\n                    if (mpir.mpz_probab_prime_p(np = n + p[i], 15) > 0) p.Add(np);\n        return p[p.Count - 1];\n    }\n\n    static mpz_t nxtP(mpz_t n) { mpz_t p = 0; mpir.mpz_nextprime(p, n); return p; }\n}\n"}
{"id": 400322, "name": "Tonelli-Shanks algorithm", "source": "Translate Perl to C#: use bigint;\nuse ntheory qw(is_prime powmod kronecker);\n\nsub tonelli_shanks {\n    my($n,$p) = @_;\n    return if kronecker($n,$p) <= 0;\n    my $Q = $p - 1;\n    my $S = 0;\n    $Q >>= 1 and $S++ while 0 == $Q%2;\n    return powmod($n,int(($p+1)/4), $p) if $S == 1;\n\n    my $c;\n    for $n (2..$p) {\n        next if kronecker($n,$p) >= 0;\n        $c = powmod($n, $Q, $p);\n        last;\n    }\n\n    my $R = powmod($n, ($Q+1) >> 1, $p ); \n    my $t = powmod($n, $Q, $p );\n    while (($t-1) % $p) {\n        my $b;\n        my $t2 = $t**2 % $p;\n        for (1 .. $S) {\n            if (0 == ($t2-1)%$p) {\n                $b = powmod($c, 1 << ($S-1-$_), $p);\n                $S = $_;\n                last;\n            }\n            $t2 = $t2**2 % $p;\n        }\n        $R = ($R * $b) % $p;\n        $c = $b**2 % $p;\n        $t = ($t * $c) % $p;\n    }\n    $R;\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (1030, 10009),\n    (1032, 10009),\n    (44402, 100049),\n    (665820697, 1000000009),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n    $n = shift @tests;\n    $p = shift @tests;\n    my $t = tonelli_shanks($n, $p);\n    if (!$t or ($t**2 - $n) % $p) {\n        printf \"No solution for (%d, %d)\\n\", $n, $p;\n    } else {\n        printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $t, $p-$t, $p;\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace TonelliShanks {\n    class Solution {\n        private readonly BigInteger root1, root2;\n        private readonly bool exists;\n\n        public Solution(BigInteger root1, BigInteger root2, bool exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n\n        public BigInteger Root1() {\n            return root1;\n        }\n\n        public BigInteger Root2() {\n            return root2;\n        }\n\n        public bool Exists() {\n            return exists;\n        }\n    }\n\n    class Program {\n        static Solution Ts(BigInteger n, BigInteger p) {\n            if (BigInteger.ModPow(n, (p - 1) / 2, p) != 1) {\n                return new Solution(0, 0, false);\n            }\n\n            BigInteger q = p - 1;\n            BigInteger ss = 0;\n            while ((q & 1) == 0) {\n                ss = ss + 1;\n                q = q >> 1;\n            }\n\n            if (ss == 1) {\n                BigInteger r1 = BigInteger.ModPow(n, (p + 1) / 4, p);\n                return new Solution(r1, p - r1, true);\n            }\n\n            BigInteger z = 2;\n            while (BigInteger.ModPow(z, (p - 1) / 2, p) != p - 1) {\n                z = z + 1;\n            }\n            BigInteger c = BigInteger.ModPow(z, q, p);\n            BigInteger r = BigInteger.ModPow(n, (q + 1) / 2, p);\n            BigInteger t = BigInteger.ModPow(n, q, p);\n            BigInteger m = ss;\n\n            while (true) {\n                if (t == 1) {\n                    return new Solution(r, p - r, true);\n                }\n                BigInteger i = 0;\n                BigInteger zz = t;\n                while (zz != 1 && i < (m - 1)) {\n                    zz = zz * zz % p;\n                    i = i + 1;\n                }\n                BigInteger b = c;\n                BigInteger e = m - i - 1;\n                while (e > 0) {\n                    b = b * b % p;\n                    e = e - 1;\n                }\n                r = r * b % p;\n                c = b * b % p;\n                t = t * c % p;\n                m = i;\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Tuple<long, long>> pairs = new List<Tuple<long, long>>() {\n                new Tuple<long, long>(10, 13),\n                new Tuple<long, long>(56, 101),\n                new Tuple<long, long>(1030, 10009),\n                new Tuple<long, long>(1032, 10009),\n                new Tuple<long, long>(44402, 100049),\n                new Tuple<long, long>(665820697, 1000000009),\n                new Tuple<long, long>(881398088036, 1000000000039),\n            };\n\n            foreach (var pair in pairs) {\n                Solution sol = Ts(pair.Item1, pair.Item2);\n                Console.WriteLine(\"n = {0}\", pair.Item1);\n                Console.WriteLine(\"p = {0}\", pair.Item2);\n                if (sol.Exists()) {\n                    Console.WriteLine(\"root1 = {0}\", sol.Root1());\n                    Console.WriteLine(\"root2 = {0}\", sol.Root2());\n                } else {\n                    Console.WriteLine(\"No solution exists\");\n                }\n                Console.WriteLine();\n            }\n\n            BigInteger bn = BigInteger.Parse(\"41660815127637347468140745042827704103445750172002\");\n            BigInteger bp = BigInteger.Pow(10, 50) + 577;\n            Solution bsol = Ts(bn, bp);\n            Console.WriteLine(\"n = {0}\", bn);\n            Console.WriteLine(\"p = {0}\", bp);\n            if (bsol.Exists()) {\n                Console.WriteLine(\"root1 = {0}\", bsol.Root1());\n                Console.WriteLine(\"root2 = {0}\", bsol.Root2());\n            } else {\n                Console.WriteLine(\"No solution exists\");\n            }\n        }\n    }\n}\n"}
{"id": 400323, "name": "Tonelli-Shanks algorithm", "source": "Translate Perl to C#: use bigint;\nuse ntheory qw(is_prime powmod kronecker);\n\nsub tonelli_shanks {\n    my($n,$p) = @_;\n    return if kronecker($n,$p) <= 0;\n    my $Q = $p - 1;\n    my $S = 0;\n    $Q >>= 1 and $S++ while 0 == $Q%2;\n    return powmod($n,int(($p+1)/4), $p) if $S == 1;\n\n    my $c;\n    for $n (2..$p) {\n        next if kronecker($n,$p) >= 0;\n        $c = powmod($n, $Q, $p);\n        last;\n    }\n\n    my $R = powmod($n, ($Q+1) >> 1, $p ); \n    my $t = powmod($n, $Q, $p );\n    while (($t-1) % $p) {\n        my $b;\n        my $t2 = $t**2 % $p;\n        for (1 .. $S) {\n            if (0 == ($t2-1)%$p) {\n                $b = powmod($c, 1 << ($S-1-$_), $p);\n                $S = $_;\n                last;\n            }\n            $t2 = $t2**2 % $p;\n        }\n        $R = ($R * $b) % $p;\n        $c = $b**2 % $p;\n        $t = ($t * $c) % $p;\n    }\n    $R;\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (1030, 10009),\n    (1032, 10009),\n    (44402, 100049),\n    (665820697, 1000000009),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n    $n = shift @tests;\n    $p = shift @tests;\n    my $t = tonelli_shanks($n, $p);\n    if (!$t or ($t**2 - $n) % $p) {\n        printf \"No solution for (%d, %d)\\n\", $n, $p;\n    } else {\n        printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $t, $p-$t, $p;\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace TonelliShanks {\n    class Solution {\n        private readonly BigInteger root1, root2;\n        private readonly bool exists;\n\n        public Solution(BigInteger root1, BigInteger root2, bool exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n\n        public BigInteger Root1() {\n            return root1;\n        }\n\n        public BigInteger Root2() {\n            return root2;\n        }\n\n        public bool Exists() {\n            return exists;\n        }\n    }\n\n    class Program {\n        static Solution Ts(BigInteger n, BigInteger p) {\n            if (BigInteger.ModPow(n, (p - 1) / 2, p) != 1) {\n                return new Solution(0, 0, false);\n            }\n\n            BigInteger q = p - 1;\n            BigInteger ss = 0;\n            while ((q & 1) == 0) {\n                ss = ss + 1;\n                q = q >> 1;\n            }\n\n            if (ss == 1) {\n                BigInteger r1 = BigInteger.ModPow(n, (p + 1) / 4, p);\n                return new Solution(r1, p - r1, true);\n            }\n\n            BigInteger z = 2;\n            while (BigInteger.ModPow(z, (p - 1) / 2, p) != p - 1) {\n                z = z + 1;\n            }\n            BigInteger c = BigInteger.ModPow(z, q, p);\n            BigInteger r = BigInteger.ModPow(n, (q + 1) / 2, p);\n            BigInteger t = BigInteger.ModPow(n, q, p);\n            BigInteger m = ss;\n\n            while (true) {\n                if (t == 1) {\n                    return new Solution(r, p - r, true);\n                }\n                BigInteger i = 0;\n                BigInteger zz = t;\n                while (zz != 1 && i < (m - 1)) {\n                    zz = zz * zz % p;\n                    i = i + 1;\n                }\n                BigInteger b = c;\n                BigInteger e = m - i - 1;\n                while (e > 0) {\n                    b = b * b % p;\n                    e = e - 1;\n                }\n                r = r * b % p;\n                c = b * b % p;\n                t = t * c % p;\n                m = i;\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Tuple<long, long>> pairs = new List<Tuple<long, long>>() {\n                new Tuple<long, long>(10, 13),\n                new Tuple<long, long>(56, 101),\n                new Tuple<long, long>(1030, 10009),\n                new Tuple<long, long>(1032, 10009),\n                new Tuple<long, long>(44402, 100049),\n                new Tuple<long, long>(665820697, 1000000009),\n                new Tuple<long, long>(881398088036, 1000000000039),\n            };\n\n            foreach (var pair in pairs) {\n                Solution sol = Ts(pair.Item1, pair.Item2);\n                Console.WriteLine(\"n = {0}\", pair.Item1);\n                Console.WriteLine(\"p = {0}\", pair.Item2);\n                if (sol.Exists()) {\n                    Console.WriteLine(\"root1 = {0}\", sol.Root1());\n                    Console.WriteLine(\"root2 = {0}\", sol.Root2());\n                } else {\n                    Console.WriteLine(\"No solution exists\");\n                }\n                Console.WriteLine();\n            }\n\n            BigInteger bn = BigInteger.Parse(\"41660815127637347468140745042827704103445750172002\");\n            BigInteger bp = BigInteger.Pow(10, 50) + 577;\n            Solution bsol = Ts(bn, bp);\n            Console.WriteLine(\"n = {0}\", bn);\n            Console.WriteLine(\"p = {0}\", bp);\n            if (bsol.Exists()) {\n                Console.WriteLine(\"root1 = {0}\", bsol.Root1());\n                Console.WriteLine(\"root2 = {0}\", bsol.Root2());\n            } else {\n                Console.WriteLine(\"No solution exists\");\n            }\n        }\n    }\n}\n"}
{"id": 400324, "name": "Truth table", "source": "Translate Perl to C#: \n\nsub truth_table {\n    my $s = shift;\n    my (%seen, @vars);\n    for ($s =~ /([a-zA-Z_]\\w*)/g) {\n        $seen{$_} //= do { push @vars, $_; 1 };\n    }\n\n    print \"\\n\", join(\"\\t\", @vars, $s), \"\\n\", '-' x 40, \"\\n\";\n    @vars = map(\"\\$$_\", @vars);\n\n    $s =~ s/([a-zA-Z_]\\w*)/\\$$1/g;\n    $s = \"print(\".join(',\"\\t\", ', map(\"($_?'T':'F')\", @vars, $s)).\",\\\"\\\\n\\\")\";\n    $s = \"for my $_ (0, 1) { $s }\" for (reverse @vars);\n    eval $s;\n}\n\ntruth_table 'A ^ A_1';\ntruth_table 'foo & bar | baz';\ntruth_table 'Jim & (Spock ^ Bones) | Scotty';\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class TruthTable\n{\n    enum TokenType { Unknown, WhiteSpace, Constant, Operand, Operator, LeftParenthesis, RightParenthesis }\n\n    readonly char trueConstant, falseConstant;\n    readonly IDictionary<char, Operator> operators = new Dictionary<char, Operator>();\n\n    public TruthTable(char falseConstant, char trueConstant)\n    {\n        this.trueConstant = trueConstant;\n        this.falseConstant = falseConstant;\n        Operators = new OperatorCollection(operators);\n    }\n\n    public OperatorCollection Operators { get; }\n\n    public void PrintTruthTable(string expression, bool isPostfix = false)\n    {\n        try {\n            foreach (string line in GetTruthTable(expression, isPostfix)) {\n                Console.WriteLine(line);\n            }\n        } catch (ArgumentException ex) {\n            Console.WriteLine(expression + \"   \" + ex.Message);\n        }\n    }\n\n    public IEnumerable<string> GetTruthTable(string expression, bool isPostfix = false)\n    {\n        if (string.IsNullOrWhiteSpace(expression)) throw new ArgumentException(\"Invalid expression.\");\n        \n        \n        var parameters = expression\n            .Where(c => TypeOf(c) == TokenType.Operand)\n            .Distinct()\n            .Reverse()\n            .Select((c, i) => (symbol: c, index: i))\n            .ToDictionary(p => p.symbol, p => p.index);\n\n        int count = parameters.Count;\n        if (count > 32) throw new ArgumentException(\"Cannot have more than 32 parameters.\");\n        string header = count == 0 ? expression : string.Join(\" \",\n            parameters.OrderByDescending(p => p.Value).Select(p => p.Key)) + \" \" + expression;\n\n        if (!isPostfix) expression = ConvertToPostfix(expression);\n\n        var values = default(BitSet);\n        var stack = new Stack<char>(expression.Length);\n        for (int loop = 1 << count; loop > 0; loop--) {\n            foreach (char token in expression) stack.Push(token);\n            bool result = Evaluate(stack, values, parameters);\n            if (header != null) {\n                if (stack.Count > 0) throw new ArgumentException(\"Invalid expression.\");\n                yield return header;\n                header = null;\n            }\n            string line = (count == 0 ? \"\" : \" \") + (result ? trueConstant : falseConstant);\n            line = string.Join(\" \", Enumerable.Range(0, count)\n                .Select(i => values[count - i - 1] ? trueConstant : falseConstant)) + line;\n            yield return line;\n            values++;\n        }\n    }\n\n    public string ConvertToPostfix(string infix)\n    {\n        var stack = new Stack<char>();\n        var postfix = new StringBuilder();\n        foreach (char c in infix) {\n            switch (TypeOf(c)) {\n            case TokenType.WhiteSpace:\n                continue;\n            case TokenType.Constant:\n            case TokenType.Operand:\n                postfix.Append(c);\n                break;\n            case TokenType.Operator:\n                int precedence = Precedence(c);\n                while (stack.Count > 0 && Precedence(stack.Peek()) > precedence) {\n                    postfix.Append(stack.Pop());\n                }\n                stack.Push(c);\n                break;\n            case TokenType.LeftParenthesis:\n                stack.Push(c);\n                break;\n            case TokenType.RightParenthesis:\n                char top = default(char);\n                while (stack.Count > 0) {\n                    top = stack.Pop();\n                    if (top == '(') break;\n                    else postfix.Append(top);\n                }\n                if (top != '(') throw new ArgumentException(\"No matching left parenthesis.\");\n                break;\n            default:\n                throw new ArgumentException(\"Invalid character: \" + c);\n            }\n        }\n        while (stack.Count > 0) {\n            char top = stack.Pop();\n            if (top == '(') throw new ArgumentException(\"No matching right parenthesis.\");\n            postfix.Append(top);\n        }\n        return postfix.ToString();\n    }\n\n    private bool Evaluate(Stack<char> expression, BitSet values, IDictionary<char, int> parameters)\n    {\n        if (expression.Count == 0) throw new ArgumentException(\"Invalid expression.\");\n        char c = expression.Pop();\n        TokenType type = TypeOf(c);\n        while (type == TokenType.WhiteSpace) type = TypeOf(c = expression.Pop());\n        switch (type) {\n        case TokenType.Constant:\n            return c == trueConstant;\n        case TokenType.Operand:\n            return values[parameters[c]];\n        case TokenType.Operator:\n            bool right = Evaluate(expression, values, parameters);\n            Operator op = operators[c];\n            if (op.Arity == 1) return op.Function(right, right);\n            bool left = Evaluate(expression, values, parameters);\n            return op.Function(left, right);\n        default:\n            throw new ArgumentException(\"Invalid character: \" + c);\n        }\n    }\n\n    private TokenType TypeOf(char c)\n    {\n        if (char.IsWhiteSpace(c)) return TokenType.WhiteSpace;\n        if (c == '(') return TokenType.LeftParenthesis;\n        if (c == ')') return TokenType.RightParenthesis;\n        if (c == trueConstant || c == falseConstant) return TokenType.Constant;\n        if (operators.ContainsKey(c)) return TokenType.Operator;\n        if (char.IsLetter(c)) return TokenType.Operand;\n        return TokenType.Unknown;\n    }\n\n    private int Precedence(char op) => operators.TryGetValue(op, out var o) ? o.Precedence : int.MinValue;\n}\n\nstruct Operator\n{\n    public Operator(char symbol, int precedence, Func<bool, bool> function) : this(symbol, precedence, 1, (l, r) => function(r)) { }\n\n    public Operator(char symbol, int precedence, Func<bool, bool, bool> function) : this(symbol, precedence, 2, function) { }\n\n    private Operator(char symbol, int precedence, int arity, Func<bool, bool, bool> function) : this()\n    {\n        Symbol = symbol;\n        Precedence = precedence;\n        Arity = arity;\n        Function = function;\n    }\n\n    public char Symbol { get; }\n    public int Precedence { get; }\n    public int Arity { get; }\n    public Func<bool, bool, bool> Function { get; }\n}\n\npublic class OperatorCollection : IEnumerable\n{\n    readonly IDictionary<char, Operator> operators;\n\n    internal OperatorCollection(IDictionary<char, Operator> operators) {\n        this.operators = operators;\n    }\n\n    public void Add(char symbol, int precedence, Func<bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n    public void Add(char symbol, int precedence, Func<bool, bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n\n    public void Remove(char symbol) => operators.Remove(symbol);\n\n    IEnumerator IEnumerable.GetEnumerator() => operators.Values.GetEnumerator();\n}\n\nstruct BitSet\n{\n    private int bits;\n\n    private BitSet(int bits) { this.bits = bits; }\n\n    public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet.bits + 1);\n\n    public bool this[int index] => (bits & (1 << index)) != 0;\n}\n\nclass Program\n{\n    public static void Main() {\n        TruthTable tt = new TruthTable('F', 'T') {\n            Operators = {\n                { '!', 6, r => !r },\n                { '&', 5, (l, r) => l && r },\n                { '^', 4, (l, r) => l ^ r },\n                { '|', 3, (l, r) => l || r }\n            }\n        };\n        \n        var rng = new Random();\n        tt.Operators.Add('?', 6, r => rng.NextDouble() < 0.5);\n        string[] expressions = {\n            \"!!!T\",\n            \"?T\",\n            \"F & x | T\",\n            \"F & (x | T\",\n            \"F & x | T)\",\n            \"a\u00a0! (a & a)\",\n            \"a | (a * a)\",\n            \"a ^ T & (b & !c)\",\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n\n        \n        tt = new TruthTable('0', '1') {\n            Operators = {\n                { '-', 6, r => !r },\n                { '^', 5, (l, r) => l && r },\n                { 'v', 3, (l, r) => l || r },\n                { '>', 2, (l, r) => !l || r },\n                { '=', 1, (l, r) => l == r },\n            }\n        };\n        expressions = new[] {\n            \"-X v 0 = X ^ 1\",\n            \"(H > M) ^ (S > H) > (S > M)\"\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400325, "name": "Truth table", "source": "Translate Perl to C#: \n\nsub truth_table {\n    my $s = shift;\n    my (%seen, @vars);\n    for ($s =~ /([a-zA-Z_]\\w*)/g) {\n        $seen{$_} //= do { push @vars, $_; 1 };\n    }\n\n    print \"\\n\", join(\"\\t\", @vars, $s), \"\\n\", '-' x 40, \"\\n\";\n    @vars = map(\"\\$$_\", @vars);\n\n    $s =~ s/([a-zA-Z_]\\w*)/\\$$1/g;\n    $s = \"print(\".join(',\"\\t\", ', map(\"($_?'T':'F')\", @vars, $s)).\",\\\"\\\\n\\\")\";\n    $s = \"for my $_ (0, 1) { $s }\" for (reverse @vars);\n    eval $s;\n}\n\ntruth_table 'A ^ A_1';\ntruth_table 'foo & bar | baz';\ntruth_table 'Jim & (Spock ^ Bones) | Scotty';\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class TruthTable\n{\n    enum TokenType { Unknown, WhiteSpace, Constant, Operand, Operator, LeftParenthesis, RightParenthesis }\n\n    readonly char trueConstant, falseConstant;\n    readonly IDictionary<char, Operator> operators = new Dictionary<char, Operator>();\n\n    public TruthTable(char falseConstant, char trueConstant)\n    {\n        this.trueConstant = trueConstant;\n        this.falseConstant = falseConstant;\n        Operators = new OperatorCollection(operators);\n    }\n\n    public OperatorCollection Operators { get; }\n\n    public void PrintTruthTable(string expression, bool isPostfix = false)\n    {\n        try {\n            foreach (string line in GetTruthTable(expression, isPostfix)) {\n                Console.WriteLine(line);\n            }\n        } catch (ArgumentException ex) {\n            Console.WriteLine(expression + \"   \" + ex.Message);\n        }\n    }\n\n    public IEnumerable<string> GetTruthTable(string expression, bool isPostfix = false)\n    {\n        if (string.IsNullOrWhiteSpace(expression)) throw new ArgumentException(\"Invalid expression.\");\n        \n        \n        var parameters = expression\n            .Where(c => TypeOf(c) == TokenType.Operand)\n            .Distinct()\n            .Reverse()\n            .Select((c, i) => (symbol: c, index: i))\n            .ToDictionary(p => p.symbol, p => p.index);\n\n        int count = parameters.Count;\n        if (count > 32) throw new ArgumentException(\"Cannot have more than 32 parameters.\");\n        string header = count == 0 ? expression : string.Join(\" \",\n            parameters.OrderByDescending(p => p.Value).Select(p => p.Key)) + \" \" + expression;\n\n        if (!isPostfix) expression = ConvertToPostfix(expression);\n\n        var values = default(BitSet);\n        var stack = new Stack<char>(expression.Length);\n        for (int loop = 1 << count; loop > 0; loop--) {\n            foreach (char token in expression) stack.Push(token);\n            bool result = Evaluate(stack, values, parameters);\n            if (header != null) {\n                if (stack.Count > 0) throw new ArgumentException(\"Invalid expression.\");\n                yield return header;\n                header = null;\n            }\n            string line = (count == 0 ? \"\" : \" \") + (result ? trueConstant : falseConstant);\n            line = string.Join(\" \", Enumerable.Range(0, count)\n                .Select(i => values[count - i - 1] ? trueConstant : falseConstant)) + line;\n            yield return line;\n            values++;\n        }\n    }\n\n    public string ConvertToPostfix(string infix)\n    {\n        var stack = new Stack<char>();\n        var postfix = new StringBuilder();\n        foreach (char c in infix) {\n            switch (TypeOf(c)) {\n            case TokenType.WhiteSpace:\n                continue;\n            case TokenType.Constant:\n            case TokenType.Operand:\n                postfix.Append(c);\n                break;\n            case TokenType.Operator:\n                int precedence = Precedence(c);\n                while (stack.Count > 0 && Precedence(stack.Peek()) > precedence) {\n                    postfix.Append(stack.Pop());\n                }\n                stack.Push(c);\n                break;\n            case TokenType.LeftParenthesis:\n                stack.Push(c);\n                break;\n            case TokenType.RightParenthesis:\n                char top = default(char);\n                while (stack.Count > 0) {\n                    top = stack.Pop();\n                    if (top == '(') break;\n                    else postfix.Append(top);\n                }\n                if (top != '(') throw new ArgumentException(\"No matching left parenthesis.\");\n                break;\n            default:\n                throw new ArgumentException(\"Invalid character: \" + c);\n            }\n        }\n        while (stack.Count > 0) {\n            char top = stack.Pop();\n            if (top == '(') throw new ArgumentException(\"No matching right parenthesis.\");\n            postfix.Append(top);\n        }\n        return postfix.ToString();\n    }\n\n    private bool Evaluate(Stack<char> expression, BitSet values, IDictionary<char, int> parameters)\n    {\n        if (expression.Count == 0) throw new ArgumentException(\"Invalid expression.\");\n        char c = expression.Pop();\n        TokenType type = TypeOf(c);\n        while (type == TokenType.WhiteSpace) type = TypeOf(c = expression.Pop());\n        switch (type) {\n        case TokenType.Constant:\n            return c == trueConstant;\n        case TokenType.Operand:\n            return values[parameters[c]];\n        case TokenType.Operator:\n            bool right = Evaluate(expression, values, parameters);\n            Operator op = operators[c];\n            if (op.Arity == 1) return op.Function(right, right);\n            bool left = Evaluate(expression, values, parameters);\n            return op.Function(left, right);\n        default:\n            throw new ArgumentException(\"Invalid character: \" + c);\n        }\n    }\n\n    private TokenType TypeOf(char c)\n    {\n        if (char.IsWhiteSpace(c)) return TokenType.WhiteSpace;\n        if (c == '(') return TokenType.LeftParenthesis;\n        if (c == ')') return TokenType.RightParenthesis;\n        if (c == trueConstant || c == falseConstant) return TokenType.Constant;\n        if (operators.ContainsKey(c)) return TokenType.Operator;\n        if (char.IsLetter(c)) return TokenType.Operand;\n        return TokenType.Unknown;\n    }\n\n    private int Precedence(char op) => operators.TryGetValue(op, out var o) ? o.Precedence : int.MinValue;\n}\n\nstruct Operator\n{\n    public Operator(char symbol, int precedence, Func<bool, bool> function) : this(symbol, precedence, 1, (l, r) => function(r)) { }\n\n    public Operator(char symbol, int precedence, Func<bool, bool, bool> function) : this(symbol, precedence, 2, function) { }\n\n    private Operator(char symbol, int precedence, int arity, Func<bool, bool, bool> function) : this()\n    {\n        Symbol = symbol;\n        Precedence = precedence;\n        Arity = arity;\n        Function = function;\n    }\n\n    public char Symbol { get; }\n    public int Precedence { get; }\n    public int Arity { get; }\n    public Func<bool, bool, bool> Function { get; }\n}\n\npublic class OperatorCollection : IEnumerable\n{\n    readonly IDictionary<char, Operator> operators;\n\n    internal OperatorCollection(IDictionary<char, Operator> operators) {\n        this.operators = operators;\n    }\n\n    public void Add(char symbol, int precedence, Func<bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n    public void Add(char symbol, int precedence, Func<bool, bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n\n    public void Remove(char symbol) => operators.Remove(symbol);\n\n    IEnumerator IEnumerable.GetEnumerator() => operators.Values.GetEnumerator();\n}\n\nstruct BitSet\n{\n    private int bits;\n\n    private BitSet(int bits) { this.bits = bits; }\n\n    public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet.bits + 1);\n\n    public bool this[int index] => (bits & (1 << index)) != 0;\n}\n\nclass Program\n{\n    public static void Main() {\n        TruthTable tt = new TruthTable('F', 'T') {\n            Operators = {\n                { '!', 6, r => !r },\n                { '&', 5, (l, r) => l && r },\n                { '^', 4, (l, r) => l ^ r },\n                { '|', 3, (l, r) => l || r }\n            }\n        };\n        \n        var rng = new Random();\n        tt.Operators.Add('?', 6, r => rng.NextDouble() < 0.5);\n        string[] expressions = {\n            \"!!!T\",\n            \"?T\",\n            \"F & x | T\",\n            \"F & (x | T\",\n            \"F & x | T)\",\n            \"a\u00a0! (a & a)\",\n            \"a | (a * a)\",\n            \"a ^ T & (b & !c)\",\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n\n        \n        tt = new TruthTable('0', '1') {\n            Operators = {\n                { '-', 6, r => !r },\n                { '^', 5, (l, r) => l && r },\n                { 'v', 3, (l, r) => l || r },\n                { '>', 2, (l, r) => !l || r },\n                { '=', 1, (l, r) => l == r },\n            }\n        };\n        expressions = new[] {\n            \"-X v 0 = X ^ 1\",\n            \"(H > M) ^ (S > H) > (S > M)\"\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400326, "name": "Set of real numbers", "source": "Translate Perl to C#: use utf8;\n\n\n\n\n\n\npackage BNum;\n\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'<=>'\t=> \\&_cmp,\n);\n\nsub new {\n\tmy $self = shift;\n\tbless [@_], ref $self || $self\n}\n\nsub flip {\n\tmy @a = @{+shift};\n\t$a[2] = !$a[2];\n\tbless \\@a\n}\n\nmy $brackets = qw/ [ ( ) ] /;\nsub _str {\n\tmy $v = sprintf \"%.2f\", $_[0][0];\n\t$_[0][2]\n\t\t? $v . ($_[0][1] == 1 ? \"]\" : \")\")\n\t\t: ($_[0][1] == 1 ? \"(\" : \"[\" ) . $v;\n}\n\nsub _cmp {\n\tmy ($a, $b, $swap) = @_;\n\n\t\n\tif ($swap) { return -_ncmp($a, $b) }\n\tif (!ref $b || !$b->isa(__PACKAGE__)) { return _ncmp($a, $b) }\n\n\t$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]\n}\n\nsub _ncmp {\n\t\n\tmy ($a, $b) = @_;\n\t$a->[0] <=> $b || $a->[1] <=> 0\n}\n\npackage RealSet;\nuse Carp;\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'|'\t=> \\&_or,\n\t'&'\t=> \\&_and,\n\t'~'\t=> \\&_neg,\n\t'-'\t=> \\&_diff,\n\t'bool'\t=> \\&not_empty, \n);\n\nmy %pm = qw/ [ -1 ( 1 ) -1 ] 1 /;\nsub range {\n\tmy ($cls, $a, $b, $spec) = @_;\n\t$spec =~ /^( \\[ | \\( )( \\) | \\] )$/x\tor croak \"bad spec $spec\";\n\n\t$a = BNum->new($a, $pm{$1}, 0);\n\t$b = BNum->new($b, $pm{$2}, 1);\n\tnormalize($a < $b ? [$a, $b] : [])\n}\n\nsub normalize {\n\tmy @a = @{+shift};\n\t\n\t\n\t\n\tfor (my $i = $\n\t\tsplice @a, $i - 1, 2\n\t\t\tif $a[$i] <= $a[$i - 1]\n\t}\n\tbless \\@a\n}\n\nsub not_empty { scalar @{ normalize shift } }\n\nsub _str {\n\tmy (@a, @s) = @{+shift}\t\tor return '()';\n\tjoin \" \u222a \", map { shift(@a).\", \".shift(@a) } 0 .. $\n}\n\nsub _or {\n\t\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? () : ($_)\n\t\t\t\t: $d++ ? () : ($_) }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _neg {\n\tnormalize [\n\t\tBNum->new('-inf', 1, 0),\n\t\tmap($_->flip, @{+shift}),\n\t\tBNum->new('inf', -1, 1),\n\t]\n}\n\nsub _and {\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? ($_) : ()\n\t\t\t\t: $d++ ? ($_) : () }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _diff { shift() & ~shift() }\n\nsub has {\n\tmy ($a, $b) = @_;\n\tfor (my $i = 0; $i < $\n\t\treturn 1 if $a->[$i] <= $b && $b <= $a->[$i + 1]\n\t}\n\treturn 0\n}\n\nsub len {\n\tmy ($a, $l) = shift;\n\tfor (my $i = 0; $i < $\n\t\t$l += $a->[$i+1][0] - $a->[$i][0]\n\t}\n\treturn $l\n}\n\npackage main;\nuse List::Util 'reduce';\n\nsub rng { RealSet->range(@_) }\nmy @sets = (\n\trng(0, 1, '(]') | rng(0, 2, '[)'),\n\trng(0, 2, '[)') & rng(0, 2, '(]'),\n\trng(0, 3, '[)') - rng(0, 1, '()'),\n\trng(0, 3, '[)') - rng(0, 1, '[]'),\n);\n\nfor my $i (0 .. $\n\tprint \"Set $i = \", $sets[$i], \": \";\n\tfor (0 .. 2) {\n\t\tprint \"has $_; \" if $sets[$i]->has($_);\n\t}\n\tprint \"\\n\";\n}\n\n\nprint \"\\n\nsub brev { \n\tmy $x = shift;\n\treturn $x if length $x < 60;\n\tsubstr($x, 0, 30).\" ... \".substr($x, -30, 30)\n}\n\n\nmy $x = reduce { $a | $b }\n\tmap(rng(sqrt($_ + 1./6), sqrt($_ + 5./6), '()'), 0 .. 101);\n$x &= rng(0, 10, '()');\n\nprint \"A\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x\u00b2)| > 1/2 }',\n\t\"\\n\\t= \", brev($x), \"\\n\";\n\nmy $y = reduce { $a | $b }\n\tmap { rng($_ + 1./6, $_ + 5./6, '()') } 0 .. 11;\n$y &= rng(0, 10, '()');\n\nprint \"B\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x)| > 1/2 }',\n\t\"\\n\\t= \", brev($y), \"\\n\";\n\nmy $z = $x - $y;\nprint \"A - B\\t= \", brev($z), \"\\n\\tlength = \", $z->len, \"\\n\";\nprint $z ? \"not empty\\n\" : \"empty\\n\";\n", "target": "using System;\n\nnamespace RosettaCode.SetOfRealNumbers\n{\n    public class Set<TValue>\n    {\n        public Set(Predicate<TValue> contains)\n        {\n            Contains = contains;\n        }\n\n        public Predicate<TValue> Contains\n        {\n            get;\n            private set;\n        }\n\n        public Set<TValue> Union(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) || set.Contains(value));\n        }\n\n        public Set<TValue> Intersection(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && set.Contains(value));\n        }\n\n        public Set<TValue> Difference(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && !set.Contains(value));\n        }\n    }\n}\n"}
{"id": 400327, "name": "Set of real numbers", "source": "Translate Perl to C#: use utf8;\n\n\n\n\n\n\npackage BNum;\n\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'<=>'\t=> \\&_cmp,\n);\n\nsub new {\n\tmy $self = shift;\n\tbless [@_], ref $self || $self\n}\n\nsub flip {\n\tmy @a = @{+shift};\n\t$a[2] = !$a[2];\n\tbless \\@a\n}\n\nmy $brackets = qw/ [ ( ) ] /;\nsub _str {\n\tmy $v = sprintf \"%.2f\", $_[0][0];\n\t$_[0][2]\n\t\t? $v . ($_[0][1] == 1 ? \"]\" : \")\")\n\t\t: ($_[0][1] == 1 ? \"(\" : \"[\" ) . $v;\n}\n\nsub _cmp {\n\tmy ($a, $b, $swap) = @_;\n\n\t\n\tif ($swap) { return -_ncmp($a, $b) }\n\tif (!ref $b || !$b->isa(__PACKAGE__)) { return _ncmp($a, $b) }\n\n\t$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]\n}\n\nsub _ncmp {\n\t\n\tmy ($a, $b) = @_;\n\t$a->[0] <=> $b || $a->[1] <=> 0\n}\n\npackage RealSet;\nuse Carp;\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'|'\t=> \\&_or,\n\t'&'\t=> \\&_and,\n\t'~'\t=> \\&_neg,\n\t'-'\t=> \\&_diff,\n\t'bool'\t=> \\&not_empty, \n);\n\nmy %pm = qw/ [ -1 ( 1 ) -1 ] 1 /;\nsub range {\n\tmy ($cls, $a, $b, $spec) = @_;\n\t$spec =~ /^( \\[ | \\( )( \\) | \\] )$/x\tor croak \"bad spec $spec\";\n\n\t$a = BNum->new($a, $pm{$1}, 0);\n\t$b = BNum->new($b, $pm{$2}, 1);\n\tnormalize($a < $b ? [$a, $b] : [])\n}\n\nsub normalize {\n\tmy @a = @{+shift};\n\t\n\t\n\t\n\tfor (my $i = $\n\t\tsplice @a, $i - 1, 2\n\t\t\tif $a[$i] <= $a[$i - 1]\n\t}\n\tbless \\@a\n}\n\nsub not_empty { scalar @{ normalize shift } }\n\nsub _str {\n\tmy (@a, @s) = @{+shift}\t\tor return '()';\n\tjoin \" \u222a \", map { shift(@a).\", \".shift(@a) } 0 .. $\n}\n\nsub _or {\n\t\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? () : ($_)\n\t\t\t\t: $d++ ? () : ($_) }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _neg {\n\tnormalize [\n\t\tBNum->new('-inf', 1, 0),\n\t\tmap($_->flip, @{+shift}),\n\t\tBNum->new('inf', -1, 1),\n\t]\n}\n\nsub _and {\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? ($_) : ()\n\t\t\t\t: $d++ ? ($_) : () }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _diff { shift() & ~shift() }\n\nsub has {\n\tmy ($a, $b) = @_;\n\tfor (my $i = 0; $i < $\n\t\treturn 1 if $a->[$i] <= $b && $b <= $a->[$i + 1]\n\t}\n\treturn 0\n}\n\nsub len {\n\tmy ($a, $l) = shift;\n\tfor (my $i = 0; $i < $\n\t\t$l += $a->[$i+1][0] - $a->[$i][0]\n\t}\n\treturn $l\n}\n\npackage main;\nuse List::Util 'reduce';\n\nsub rng { RealSet->range(@_) }\nmy @sets = (\n\trng(0, 1, '(]') | rng(0, 2, '[)'),\n\trng(0, 2, '[)') & rng(0, 2, '(]'),\n\trng(0, 3, '[)') - rng(0, 1, '()'),\n\trng(0, 3, '[)') - rng(0, 1, '[]'),\n);\n\nfor my $i (0 .. $\n\tprint \"Set $i = \", $sets[$i], \": \";\n\tfor (0 .. 2) {\n\t\tprint \"has $_; \" if $sets[$i]->has($_);\n\t}\n\tprint \"\\n\";\n}\n\n\nprint \"\\n\nsub brev { \n\tmy $x = shift;\n\treturn $x if length $x < 60;\n\tsubstr($x, 0, 30).\" ... \".substr($x, -30, 30)\n}\n\n\nmy $x = reduce { $a | $b }\n\tmap(rng(sqrt($_ + 1./6), sqrt($_ + 5./6), '()'), 0 .. 101);\n$x &= rng(0, 10, '()');\n\nprint \"A\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x\u00b2)| > 1/2 }',\n\t\"\\n\\t= \", brev($x), \"\\n\";\n\nmy $y = reduce { $a | $b }\n\tmap { rng($_ + 1./6, $_ + 5./6, '()') } 0 .. 11;\n$y &= rng(0, 10, '()');\n\nprint \"B\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x)| > 1/2 }',\n\t\"\\n\\t= \", brev($y), \"\\n\";\n\nmy $z = $x - $y;\nprint \"A - B\\t= \", brev($z), \"\\n\\tlength = \", $z->len, \"\\n\";\nprint $z ? \"not empty\\n\" : \"empty\\n\";\n", "target": "using System;\n\nnamespace RosettaCode.SetOfRealNumbers\n{\n    public class Set<TValue>\n    {\n        public Set(Predicate<TValue> contains)\n        {\n            Contains = contains;\n        }\n\n        public Predicate<TValue> Contains\n        {\n            get;\n            private set;\n        }\n\n        public Set<TValue> Union(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) || set.Contains(value));\n        }\n\n        public Set<TValue> Intersection(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && set.Contains(value));\n        }\n\n        public Set<TValue> Difference(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && !set.Contains(value));\n        }\n    }\n}\n"}
{"id": 400328, "name": "Super-d numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\n\nsub super {\n    my $d = shift;\n    my $run = $d x $d;\n    my @super;\n    my $i = 0;\n    my $n = 0;\n    while ( $i < 10 ) {\n        if (index($n ** $d * $d, $run) > -1) {\n            push @super, $n;\n            ++$i;\n        }\n        ++$n;\n    }\n    @super;\n}\n \nsay \"\\nFirst 10 super-$_ numbers:\\n\", join ' ', super($_) for 2..6;\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 400329, "name": "Super-d numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\n\nsub super {\n    my $d = shift;\n    my $run = $d x $d;\n    my @super;\n    my $i = 0;\n    my $n = 0;\n    while ( $i < 10 ) {\n        if (index($n ** $d * $d, $run) > -1) {\n            push @super, $n;\n            ++$i;\n        }\n        ++$n;\n    }\n    @super;\n}\n \nsay \"\\nFirst 10 super-$_ numbers:\\n\", join ' ', super($_) for 2..6;\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 400330, "name": "Monads_Maybe monad", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\n\nuse Data::Monad::Maybe;\n\nsub safeReciprocal { ( $_[0] == 0 ) ? nothing : just(  1 /  $_[0] )   }\n\nsub safeRoot       { ( $_[0] <  0 ) ? nothing : just( sqrt( $_[0] ) ) }\n\nsub safeLog        { ( $_[0] <= 0 ) ? nothing : just( log ( $_[0] ) ) }\n\nprint join(' ', map {\n   my $safeLogRootReciprocal = just($_)->flat_map( \\&safeReciprocal )\n                                       ->flat_map( \\&safeRoot       )\n                                       ->flat_map( \\&safeLog        );\n   $safeLogRootReciprocal->is_nothing ? \"NaN\" : $safeLogRootReciprocal->value;\n} (-2, -1, -0.5, 0, exp (-1), 1, 2, exp(1), 3, 4, 5) ), \"\\n\";\n", "target": "using System;\n\nnamespace RosettaMaybe\n{\n    \n    public abstract class Maybe<T>\n    {\n        public sealed class Some : Maybe<T>\n        {\n            public Some(T value) => Value = value;\n            public T Value { get; }\n        }\n        public sealed class None : Maybe<T> { }\n    }\n\n    class Program\n    {\n        static Maybe<double> MonadicSquareRoot(double x)\n        {\n            if (x >= 0)\n            {\n                return new Maybe<double>.Some(Math.Sqrt(x));\n            }\n            else\n            {\n                return new Maybe<double>.None();\n            }\n        }\n        static void Main(string[] args)\n        {\n            foreach (double x in new double[] { 4.0D, 8.0D, -15.0D, 16.23D, -42 })\n            {\n                Maybe<double> maybe = MonadicSquareRoot(x);\n                if (maybe is Maybe<double>.Some some)\n                {\n                    Console.WriteLine($\"The square root of {x} is \" + some.Value);\n                }\n                else\n                {\n                    Console.WriteLine($\"Square root of {x} is undefined.\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 400331, "name": "Minesweeper game", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\n\n{   package Local::Field;\n\n    use constant {\n        REAL  => 0,\n        SHOW  => 1,\n        COUNT => 2,\n    };\n\n    sub new {\n        my ($class, $width, $height, $percent) = @_;\n        my $field;\n        for my $x (1 .. $width) {\n            for my $y (1 .. $height) {\n                $field->[$x - 1][$y - 1][REAL] = ' ';\n                $field->[$x - 1][$y - 1][SHOW] = '.';\n            }\n        }\n        for (1 .. $percent / 100 * $width * $height) {\n            my ($x, $y) = map int rand $_, $width, $height;\n            redo if 'm' eq $field->[$x][$y][REAL];\n            $field->[$x][$y][REAL] = 'm';\n            for my $i ($x - 1 .. $x + 1) {\n                for my $j ($y - 1 .. $y + 1) {\n                    $field->[$i][$j][COUNT]++\n                        if $i >= 0 and $j >= 0\n                        and $i <= $\n                }\n            }\n        }\n        bless $field, $class;\n    }\n\n\n    sub show {\n        my ($self) = @_;\n        print \"\\n  \";\n        printf '%2d ', $_ + 1 for 0 .. $\n        print \"\\n\";\n\n        for my $row (0 .. $\n            printf '%2d ', 1 + $row;\n            for my $column (0 .. $\n                print $self->[$column][$row][SHOW], '  ';\n            }\n            print \"\\n\";\n        }\n    }\n\n\n    sub mark {\n        my ($self, $x, $y) = @_;\n        $_-- for $x, $y;\n\n        if ('.' eq $self->[$x][$y][SHOW]) {\n            $self->[$x][$y][SHOW] = '?';\n\n        } elsif ('?' eq $self->[$x][$y][SHOW]) {\n            $self->[$x][$y][SHOW] = '.';\n        }\n    }\n\n\n    sub end {\n        my $self = shift;\n        for my $y (0 .. $\n            for my $x (0 .. $\n                $self->[$x][$y][SHOW] = '!' if '.' eq $self->[$x][$y][SHOW]\n                    and 'm' eq $self->[$x][$y][REAL];\n                $self->[$x][$y][SHOW] = 'x' if '?' eq $self->[$x][$y][SHOW]\n                    and 'm' ne $self->[$x][$y][REAL];\n            }\n        }\n        $self->show;\n        exit;\n    }\n\n    sub _declassify {\n        my ($self, $x, $y) = @_;\n        return if '.' ne $self->[$x][$y][SHOW];\n        if (' ' eq $self->[$x][$y][REAL] and '.' eq $self->[$x][$y][SHOW]) {\n            $self->[$x][$y][SHOW] = $self->[$x][$y][COUNT] || ' ';\n        }\n        return if ' ' ne $self->[$x][$y][SHOW];\n\n        for my $i ($x - 1 .. $x + 1) {\n            next if $i < 0 or $i > $\n            for my $j ($y - 1 .. $y + 1) {\n                next if $j < 0 or $j > $\n                no warnings 'recursion';\n                $self->_declassify($i, $j);\n            }\n        }\n    }\n\n\n    sub clear {\n        my ($self, $x, $y) = @_;\n        $_-- for $x, $y;\n        return unless '.' eq $self->[$x][$y][SHOW];\n\n        print \"You lost.\\n\" and $self->end if 'm' eq $self->[$x][$y][REAL];\n\n        $self->_declassify($x, $y);\n    }\n\n\n    sub remain {\n        my $self = shift;\n        my $unclear = 0;\n        for my $column (@$self) {\n            for my $cell (@$column) {\n                $unclear++ if '.' eq $cell->[SHOW];\n            }\n        }\n        return $unclear;\n    }\n\n}\n\nsub help {\n    print << '__HELP__';\nCommands:\nh     ... help\nq     ... quit\nm X Y ... mark/unmark X Y\nc X Y ... clear X Y\n__HELP__\n}\n\n\nmy ($width, $height, $percent) = @ARGV;\n$width   ||= 6;\n$height  ||= 4;\n$percent ||= 15;\n\nmy $field = 'Local::Field'->new($width, $height, $percent);\n\nmy $help = 1;\nwhile (1) {\n    $field->show;\n    help() if $help;\n    $help = 0;\n    my $remain = $field->remain;\n    last if 0 == $remain;\n    print \"Cells remaining: $remain.\\n\";\n    my $command = <STDIN>;\n    exit if $command =~ /^q/i;\n\n    if ($command =~ /^m.*?([0-9]+).*?([0-9]+)/i) {\n        $field->mark($1, $2);\n\n    } elsif ($command =~ /^c.*?([0-9]+).*?([0-9]+)/i) {\n        $field->clear($1, $2);\n\n    } elsif ($command =~ /^h/i) {\n        $help = 1;\n\n    } else {\n        print \"Huh?\\n\";\n    }\n}\nprint \"You won!\\n\";\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass MineFieldModel\n{\n    public int RemainingMinesCount{\n        get{\n            var count = 0;\n            ForEachCell((i,j)=>{\n                if (Mines[i,j] && !Marked[i,j])\n                    count++;\n            });\n            return count;\n        }\n    }\n\n    public bool[,] Mines{get; private set;}\n    public bool[,] Opened{get;private set;}\n    public bool[,] Marked{get; private set;}\n    public int[,] Values{get;private set; }\n    public int Width{ get{return Mines.GetLength(1);} } \n    public int Height{ get{return Mines.GetLength(0);} }\n\n    public MineFieldModel(bool[,] mines)\n    {\n        this.Mines = mines;\n        this.Opened = new bool[Height, Width]; \n        this.Marked = new bool[Height, Width];\n        this.Values = CalculateValues();\n    }\n    \n    private int[,] CalculateValues()\n    {\n        int[,] values = new int[Height, Width];\n        ForEachCell((i,j) =>{\n            var value = 0;\n            ForEachNeighbor(i,j, (i1,j1)=>{\n                if (Mines[i1,j1])\n                    value++;\n            });\n            values[i,j] = value;\n        });\n        return values;\n    }\n\n    \n    public void ForEachCell(Action<int,int> action)\n    {\n        for (var i = 0; i < Height; i++)\n        for (var j = 0; j < Width; j++)\n            action(i,j);\n    }\n\n    \n    public void ForEachNeighbor(int i, int j, Action<int,int> action)\n    {\n        for (var i1 = i-1; i1 <= i+1; i1++)\n        for (var j1 = j-1; j1 <= j+1; j1++)               \n            if (InBounds(j1, i1) && !(i1==i && j1 ==j))\n                action(i1, j1);\n    }\n\n    private bool InBounds(int x, int y)\n    {\n        return y >= 0 && y < Height && x >=0 && x < Width;\n    }\n\n    public event Action Exploded = delegate{};\n    public event Action Win = delegate{};\n    public event Action Updated = delegate{};\n\n    public void OpenCell(int i, int j){\n        if(!Opened[i,j]){\n            if (Mines[i,j])\n                Exploded();\n            else{\n                OpenCellsStartingFrom(i,j);\n                Updated();\n                CheckForVictory();\n            }\n        }\n    }\n\n    void OpenCellsStartingFrom(int i, int j)\n    {\n            Opened[i,j] = true;\n            ForEachNeighbor(i,j, (i1,j1)=>{\n                if (!Mines[i1,j1] && !Opened[i1,j1] && !Marked[i1,j1])\n                    OpenCellsStartingFrom(i1, j1);\n            });\n    }\n    \n    void CheckForVictory(){\n        int notMarked = 0;\n        int wrongMarked = 0;\n        ForEachCell((i,j)=>{\n            if (Mines[i,j] && !Marked[i,j])\n                notMarked++;\n            if (!Mines[i,j] && Marked[i,j])\n                wrongMarked++;\n        }); \n        if (notMarked == 0 && wrongMarked == 0)\n            Win();\n    }\n\n    public void Mark(int i, int j){\n        if (!Opened[i,j])\n            Marked[i,j] = true;\n            Updated();\n            CheckForVictory();\n    }\n}\n\nclass MineFieldView: UserControl{\n    public const int CellSize = 40;\n\n    MineFieldModel _model;\n    public MineFieldModel Model{\n        get{ return _model; }\n        set\n        { \n            _model = value; \n            this.Size = new Size(_model.Width * CellSize+1, _model.Height * CellSize+2);\n        }\n    }\n    \n    public MineFieldView(){\n        \n        this.SetStyle(ControlStyles.AllPaintingInWmPaint | ControlStyles.UserPaint | ControlStyles.DoubleBuffer,true);\n        this.Font = new Font(FontFamily.GenericSansSerif, 14, FontStyle.Bold);\n\n        this.MouseUp += (o,e)=>{\n            Point cellCoords = GetCell(e.Location);\n            if (Model != null)\n            {\n                if (e.Button == MouseButtons.Left)\n                    Model.OpenCell(cellCoords.Y, cellCoords.X);\n                else if (e.Button == MouseButtons.Right)\n                    Model.Mark(cellCoords.Y, cellCoords.X);\n            }\n        };\n    }\n\n    Point GetCell(Point coords)\n    {\n        var rgn = ClientRectangle;\n        var x = (coords.X - rgn.X)/CellSize;\n        var y = (coords.Y - rgn.Y)/CellSize;\n        return new Point(x,y);\n    }\n         \n    static readonly Brush MarkBrush = new SolidBrush(Color.Blue);\n    static readonly Brush ValueBrush = new SolidBrush(Color.Black);\n    static readonly Brush UnexploredBrush = new SolidBrush(SystemColors.Control);\n    static readonly Brush OpenBrush = new SolidBrush(SystemColors.ControlDark);\n\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        var g = e.Graphics;\n        if (Model != null)\n        {\n            Model.ForEachCell((i,j)=>\n            {\n                var bounds = new Rectangle(j * CellSize, i * CellSize, CellSize, CellSize);\n                if (Model.Opened[i,j])\n                {\n                    g.FillRectangle(OpenBrush, bounds);\n                    if (Model.Values[i,j] > 0)\n                    {\n                        DrawStringInCenter(g, Model.Values[i,j].ToString(), ValueBrush, bounds);\n                    }\n                } \n                else \n                {\n                    g.FillRectangle(UnexploredBrush, bounds);\n                    if (Model.Marked[i,j])\n                    {\n                        DrawStringInCenter(g, \"?\", MarkBrush, bounds);\n                    }\n                    var outlineOffset = 1;\n                    var outline = new Rectangle(bounds.X+outlineOffset, bounds.Y+outlineOffset, bounds.Width-2*outlineOffset, bounds.Height-2*outlineOffset);\n                    g.DrawRectangle(Pens.Gray, outline);\n                }\n                g.DrawRectangle(Pens.Black, bounds);\n            });\n        }\n\n    }\n\n    static readonly StringFormat FormatCenter = new StringFormat\n                            {\n                                LineAlignment = StringAlignment.Center,\n                                Alignment=StringAlignment.Center\n                            };\n\n    void DrawStringInCenter(Graphics g, string s, Brush brush, Rectangle bounds)\n    {\n        PointF center = new PointF(bounds.X + bounds.Width/2, bounds.Y + bounds.Height/2);\n        g.DrawString(s, this.Font, brush, center, FormatCenter);\n    }\n\n}\n\nclass MineSweepForm: Form\n{\n\n    MineFieldModel CreateField(int width, int height)\n{\n        var field = new bool[height, width];\n        int mineCount = (int)(0.2 * height * width);\n        var rnd = new Random();\n        while(mineCount > 0)\n        {\n            var x = rnd.Next(width);\n            var y = rnd.Next(height);\n            if (!field[y,x])\n            {\n                field[y,x] = true;\n                mineCount--;\n            }\n        }\n        return new MineFieldModel(field);\n    }\n\n    public MineSweepForm()\n    {\n        var model = CreateField(6, 4);\n        var counter = new Label{ };\n        counter.Text = model.RemainingMinesCount.ToString();\n        var view = new MineFieldView\n                        { \n                            Model = model, BorderStyle = BorderStyle.FixedSingle,\n                        };\n        var stackPanel = new FlowLayoutPanel\n                        {\n                            Dock = DockStyle.Fill,\n                            FlowDirection = FlowDirection.TopDown,\n                            Controls = {counter, view}\n                        };\n        this.Controls.Add(stackPanel);\n        model.Updated += delegate{\n            view.Invalidate();\n            counter.Text = model.RemainingMinesCount.ToString();\n        };\n        model.Exploded += delegate {\n            MessageBox.Show(\"FAIL!\");\n            Close();\n        };\n        model.Win += delegate {\n            MessageBox.Show(\"WIN!\");\n            view.Enabled = false;\n        };\n\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        Application.Run(new MineSweepForm());\n    }\n}\n"}
{"id": 400332, "name": "Church numerals", "source": "Translate Perl to C#: use 5.020;\nuse feature qw<signatures>;\nno warnings qw<experimental::signatures>;\n\nuse constant zero  => sub ($f) {\n                      sub ($x) { $x }};\n\nuse constant succ  => sub ($n) {\n                      sub ($f) {\n                      sub ($x) { $f->($n->($f)($x)) }}};\n\nuse constant add   => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($f)($n->($f)($x)) }}}};\n\nuse constant mult  => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($n->($f))($x) }}}};\n\nuse constant power => sub ($b) {\n                      sub ($e) { $e->($b) }};\n\nuse constant countup   => sub ($i) { $i + 1 };\nuse constant countdown => sub ($i) { $i == 0 ? zero : succ->( __SUB__->($i - 1) ) };\nuse constant to_int    => sub ($f) { $f->(countup)->(0) };\nuse constant from_int  => sub ($x) { countdown->($x) };\n\nuse constant three => succ->(succ->(succ->(zero)));\nuse constant four  => from_int->(4);\n\nsay join ' ', map { to_int->($_) } (\n    add  ->( three )->( four  ),\n    mult ->( three )->( four  ),\n    power->( four  )->( three ),\n    power->( three )->( four  ),\n);\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 400333, "name": "Church numerals", "source": "Translate Perl to C#: use 5.020;\nuse feature qw<signatures>;\nno warnings qw<experimental::signatures>;\n\nuse constant zero  => sub ($f) {\n                      sub ($x) { $x }};\n\nuse constant succ  => sub ($n) {\n                      sub ($f) {\n                      sub ($x) { $f->($n->($f)($x)) }}};\n\nuse constant add   => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($f)($n->($f)($x)) }}}};\n\nuse constant mult  => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($n->($f))($x) }}}};\n\nuse constant power => sub ($b) {\n                      sub ($e) { $e->($b) }};\n\nuse constant countup   => sub ($i) { $i + 1 };\nuse constant countdown => sub ($i) { $i == 0 ? zero : succ->( __SUB__->($i - 1) ) };\nuse constant to_int    => sub ($f) { $f->(countup)->(0) };\nuse constant from_int  => sub ($x) { countdown->($x) };\n\nuse constant three => succ->(succ->(succ->(zero)));\nuse constant four  => from_int->(4);\n\nsay join ' ', map { to_int->($_) } (\n    add  ->( three )->( four  ),\n    mult ->( three )->( four  ),\n    power->( four  )->( three ),\n    power->( three )->( four  ),\n);\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 400334, "name": "Reflection_List methods", "source": "Translate Perl to C#: package Nums;\n\nuse overload ('<=>' => \\&compare);\nsub new     { my $self = shift; bless [@_] }\nsub flip    { my @a = @_; 1/$a }\nsub double  { my @a = @_; 2*$a }\nsub compare { my ($a, $b) = @_; abs($a) <=> abs($b) }\n\nmy $a = Nums->new(42);\nprint \"$_\\n\" for %{ref ($a).\"::\" });\n", "target": "using System;\nusing System.Reflection;\n\npublic class Rosetta\n{\n    public static void Main()\n    {\n        \n        BindingFlags flags = BindingFlags.Instance | BindingFlags.Static\n            | BindingFlags.Public | BindingFlags.NonPublic\n            | BindingFlags.DeclaredOnly;\n\n        foreach (var method in typeof(TestForMethodReflection).GetMethods(flags))\n            Console.WriteLine(method);\n    }\n    \n    class TestForMethodReflection\n    {\n        public void MyPublicMethod() {}\n        private void MyPrivateMethod() {}\n        \n        public static void MyPublicStaticMethod() {}\n        private static void MyPrivateStaticMethod() {}\n    }\n    \n}\n"}
{"id": 400335, "name": "Send an unknown method call", "source": "Translate Perl to C#: package Example;\nsub new {\n    bless {}\n}\nsub foo {\n    my ($self, $x) = @_;\n    return 42 + $x;\n}\n\npackage main;\nmy $name = \"foo\";\nprint Example->new->$name(5), \"\\n\"; \n", "target": "using System;\n\nclass Example\n{\n    public int foo(int x)\n    {\n        return 42 + x;\n    }\n}\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var example = new Example();\n        var method = \"foo\";\n        \n        var result = (int)example.GetType().GetMethod(method).Invoke(example, new object[]{ 5 });\n        Console.WriteLine(\"{0}(5) = {1}\", method, result);\n    }\n}\n"}
{"id": 400336, "name": "Canonicalize CIDR", "source": "Translate Perl to C#: \nuse v5.16;\nuse Socket qw(inet_aton inet_ntoa);\n\n\nif (!@ARGV) {\n   chomp(@ARGV = <>);\n}\n\nfor (@ARGV) {\n\n  \n  my ($dotted, $size) = split m\n\n  \n  my $binary = sprintf \"%032b\", unpack('N', inet_aton $dotted);\n\n  \n  substr($binary, $size) = 0 x (32 - $size);\n\n  \n  $dotted = inet_ntoa(pack 'B32', $binary);\n\n  \n  say \"$dotted/$size\";\n}\n", "target": "using System;\nusing System.Net;\nusing System.Linq;\n                    \npublic class Program\n{\n    public static void Main()\n    {\n        string[] tests = {\n            \"87.70.141.1/22\",\n            \"36.18.154.103/12\",\n            \"62.62.197.11/29\",\n            \"67.137.119.181/4\",\n            \"161.214.74.21/24\",\n            \"184.232.176.184/18\"\n        };\n        \n        foreach (string t in tests) Console.WriteLine($\"{t}   =>   {Canonicalize(t)}\");\n    }\n    \n    static string Canonicalize(string cidr) => CIDR.Parse(cidr).Canonicalize().ToString();\n}\n\nreadonly struct CIDR\n{\n    public readonly IPAddress ip;\n    public readonly int length;\n    \n    public static CIDR Parse(string cidr)\n    {\n        string[] parts = cidr.Split('/');\n        return new CIDR(IPAddress.Parse(parts[0]), int.Parse(parts[1]));\n    }\n    \n    public CIDR(IPAddress ip, int length) => (this.ip, this.length) = (ip, length);\n    \n    public CIDR Canonicalize() =>\n        new CIDR(\n            new IPAddress(\n                ToBytes(\n                    ToInt(\n                        ip.GetAddressBytes()\n                    )\n                    & ~((1 << (32 - length)) - 1)\n                )\n            ),\n            length\n        );\n    \n    private int ToInt(byte[] bytes) => bytes.Aggregate(0, (n, b) => (n << 8) | b);\n    \n    private byte[] ToBytes(int n)\n    {\n        byte[] bytes = new byte[4];\n        for (int i = 3; i >= 0; i--) {\n            bytes[i] = (byte)(n & 0xFF);\n            n >>= 8;\n        }\n        return bytes;\n    }\n    \n    public override string ToString() => $\"{ip}/{length}\";\n}\n"}
{"id": 400337, "name": "Canonicalize CIDR", "source": "Translate Perl to C#: \nuse v5.16;\nuse Socket qw(inet_aton inet_ntoa);\n\n\nif (!@ARGV) {\n   chomp(@ARGV = <>);\n}\n\nfor (@ARGV) {\n\n  \n  my ($dotted, $size) = split m\n\n  \n  my $binary = sprintf \"%032b\", unpack('N', inet_aton $dotted);\n\n  \n  substr($binary, $size) = 0 x (32 - $size);\n\n  \n  $dotted = inet_ntoa(pack 'B32', $binary);\n\n  \n  say \"$dotted/$size\";\n}\n", "target": "using System;\nusing System.Net;\nusing System.Linq;\n                    \npublic class Program\n{\n    public static void Main()\n    {\n        string[] tests = {\n            \"87.70.141.1/22\",\n            \"36.18.154.103/12\",\n            \"62.62.197.11/29\",\n            \"67.137.119.181/4\",\n            \"161.214.74.21/24\",\n            \"184.232.176.184/18\"\n        };\n        \n        foreach (string t in tests) Console.WriteLine($\"{t}   =>   {Canonicalize(t)}\");\n    }\n    \n    static string Canonicalize(string cidr) => CIDR.Parse(cidr).Canonicalize().ToString();\n}\n\nreadonly struct CIDR\n{\n    public readonly IPAddress ip;\n    public readonly int length;\n    \n    public static CIDR Parse(string cidr)\n    {\n        string[] parts = cidr.Split('/');\n        return new CIDR(IPAddress.Parse(parts[0]), int.Parse(parts[1]));\n    }\n    \n    public CIDR(IPAddress ip, int length) => (this.ip, this.length) = (ip, length);\n    \n    public CIDR Canonicalize() =>\n        new CIDR(\n            new IPAddress(\n                ToBytes(\n                    ToInt(\n                        ip.GetAddressBytes()\n                    )\n                    & ~((1 << (32 - length)) - 1)\n                )\n            ),\n            length\n        );\n    \n    private int ToInt(byte[] bytes) => bytes.Aggregate(0, (n, b) => (n << 8) | b);\n    \n    private byte[] ToBytes(int n)\n    {\n        byte[] bytes = new byte[4];\n        for (int i = 3; i >= 0; i--) {\n            bytes[i] = (byte)(n & 0xFF);\n            n >>= 8;\n        }\n        return bytes;\n    }\n    \n    public override string ToString() => $\"{ip}/{length}\";\n}\n"}
{"id": 400338, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Perl to C#: use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   \nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 400339, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Perl to C#: use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   \nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 400340, "name": "Long primes", "source": "Translate Perl to C#: use ntheory qw/divisors powmod is_prime/;\n\nsub is_long_prime {\n    my($p) = @_;\n    return 0 unless is_prime($p);\n    for my $d (divisors($p-1)) {\n        return $d+1 == $p if powmod(10, $d, $p) == 1;\n    }\n    0;\n}\n\nprint \"Long primes \u2264 500:\\n\";\nprint join(' ', grep {is_long_prime($_) } 1 .. 500), \"\\n\\n\";\n\nfor my $n (500, 1000, 2000, 4000, 8000, 16000, 32000, 64000) {\n    printf \"Number of long primes \u2264 $n: %d\\n\",  scalar grep { is_long_prime($_) } 1 .. $n;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LongPrimes\n{\n    public static void Main() {\n        var primes = SomePrimeGenerator.Primes(64000).Skip(1).Where(p => Period(p) == p - 1).Append(99999);\n        Console.WriteLine(string.Join(\" \", primes.TakeWhile(p => p <= 500)));\n        int count = 0, limit = 500;\n        foreach (int prime in primes) {\n            if (prime > limit) {\n                Console.WriteLine($\"There are {count} long primes below {limit}\");\n                limit *= 2;\n            }\n            count++;\n        }\n\n        int Period(int n) {\n            int r = 1, rr;\n            for (int i = 0; i <= n; i++) r = 10 * r % n;\n            rr = r;\n            for (int period = 1;; period++) {\n                r = (10 * r) % n;\n                if (r == rr) return period;\n            }\n        }\n    }\n\n}\n\nstatic class SomePrimeGenerator {\n\n    public static IEnumerable<int> Primes(int lim) {\n        bool [] flags = new bool[lim + 1]; int j = 2;\n        for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n            if (!flags[j]) {\n                yield return j; for (int k = sq; k <= lim; k += j)\n                    flags[k] = true;\n            }\n        for (; j<= lim; j++) if (!flags[j]) yield return j;\n    }\n}\n"}
{"id": 400341, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse bigint;\nsub isEgyption{\n    my $nr = int($_[0]);\n    my $de = int($_[1]);\n    if($nr == 0 or $de == 0){\n\t\n\treturn;\n    }\n    if($de % $nr == 0){\n\t\n\tprintf \"1/\" . int($de/$nr);\n\treturn;\n    }\n    if($nr % $de == 0){\n\t\n\tprintf $nr/$de;\n\treturn;\n    }\n    if($nr > $de){\n        printf int($nr/$de) . \" + \";\n\tisEgyption($nr%$de, $de);\n\treturn;\n    }\n    \n    my $tmp = int($de/$nr) + 1;\n    printf \"1/\" . $tmp . \" + \";\n    isEgyption($nr*$tmp-$de, $de*$tmp);\n}\n\nmy $nrI = 2014;\nmy $deI = 59;\nprintf \"\\nEgyptian Fraction Representation of \" . $nrI . \"/\" . $deI . \" is: \\n\\n\";\nisEgyption($nrI,$deI);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EgyptianFractions {\n    class Program {\n        class Rational : IComparable<Rational>, IComparable<int> {\n            public BigInteger Num { get; }\n            public BigInteger Den { get; }\n\n            public Rational(BigInteger n, BigInteger d) {\n                var c = Gcd(n, d);\n                Num = n / c;\n                Den = d / c;\n                if (Den < 0) {\n                    Num = -Num;\n                    Den = -Den;\n                }\n            }\n\n            public Rational(BigInteger n) {\n                Num = n;\n                Den = 1;\n            }\n\n            public override string ToString() {\n                if (Den == 1) {\n                    return Num.ToString();\n                } else {\n                    return string.Format(\"{0}/{1}\", Num, Den);\n                }\n            }\n\n            public Rational Add(Rational rhs) {\n                return new Rational(Num * rhs.Den + rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public Rational Sub(Rational rhs) {\n                return new Rational(Num * rhs.Den - rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public int CompareTo(Rational rhs) {\n                var ad = Num * rhs.Den;\n                var bc = Den * rhs.Num;\n                return ad.CompareTo(bc);\n            }\n\n            public int CompareTo(int rhs) {\n                var ad = Num * rhs;\n                var bc = Den * rhs;\n                return ad.CompareTo(bc);\n            }\n        }\n\n        static BigInteger Gcd(BigInteger a, BigInteger b) {\n            if (b == 0) {\n                if (a < 0) {\n                    return -a;\n                } else {\n                    return a;\n                }\n            } else {\n                return Gcd(b, a % b);\n            }\n        }\n\n        static List<Rational> Egyptian(Rational r) {\n            List<Rational> result = new List<Rational>();\n\n            if (r.CompareTo(1) >= 0) {\n                if (r.Den == 1) {\n                    result.Add(r);\n                    result.Add(new Rational(0));\n                    return result;\n                }\n                result.Add(new Rational(r.Num / r.Den));\n                r = r.Sub(result[0]);\n            }\n\n            BigInteger modFunc(BigInteger m, BigInteger n) {\n                return ((m % n) + n) % n;\n            }\n\n            while (r.Num != 1) {\n                var q = (r.Den + r.Num - 1) / r.Num;\n                result.Add(new Rational(1, q));\n                r = new Rational(modFunc(-r.Den, r.Num), r.Den * q);\n            }\n\n            result.Add(r);\n            return result;\n        }\n\n        static string FormatList<T>(IEnumerable<T> col) {\n            StringBuilder sb = new StringBuilder();\n            var iter = col.GetEnumerator();\n\n            sb.Append('[');\n            if (iter.MoveNext()) {\n                sb.Append(iter.Current);\n            }\n            while (iter.MoveNext()) {\n                sb.AppendFormat(\", {0}\", iter.Current);\n            }\n            sb.Append(']');\n\n            return sb.ToString();\n        }\n\n        static void Main() {\n            List<Rational> rs = new List<Rational> {\n                new Rational(43, 48),\n                new Rational(5, 121),\n                new Rational(2014, 59)\n            };\n            foreach (var r in rs) {\n                Console.WriteLine(\"{0} => {1}\", r, FormatList(Egyptian(r)));\n            }\n\n            var lenMax = Tuple.Create(0UL, new Rational(0));\n            var denomMax = Tuple.Create(BigInteger.Zero, new Rational(0));\n\n            var query = (from i in Enumerable.Range(1, 100)\n                         from j in Enumerable.Range(1, 100)\n                         select new Rational(i, j))\n                         .Distinct()\n                         .ToList();\n            foreach (var r in query) {\n                var e = Egyptian(r);\n                ulong eLen = (ulong) e.Count;\n                var eDenom = e.Last().Den;\n                if (eLen > lenMax.Item1) {\n                    lenMax = Tuple.Create(eLen, r);\n                }\n                if (eDenom > denomMax.Item1) {\n                    denomMax = Tuple.Create(eDenom, r);\n                }\n            }\n\n            Console.WriteLine(\"Term max is {0} with {1} terms\", lenMax.Item2, lenMax.Item1);\n            var dStr = denomMax.Item1.ToString();\n            Console.WriteLine(\"Denominator max is {0} with {1} digits {2}...{3}\", denomMax.Item2, dStr.Length, dStr.Substring(0, 5), dStr.Substring(dStr.Length - 5, 5));\n        }\n    }\n}\n"}
{"id": 400342, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse bigint;\nsub isEgyption{\n    my $nr = int($_[0]);\n    my $de = int($_[1]);\n    if($nr == 0 or $de == 0){\n\t\n\treturn;\n    }\n    if($de % $nr == 0){\n\t\n\tprintf \"1/\" . int($de/$nr);\n\treturn;\n    }\n    if($nr % $de == 0){\n\t\n\tprintf $nr/$de;\n\treturn;\n    }\n    if($nr > $de){\n        printf int($nr/$de) . \" + \";\n\tisEgyption($nr%$de, $de);\n\treturn;\n    }\n    \n    my $tmp = int($de/$nr) + 1;\n    printf \"1/\" . $tmp . \" + \";\n    isEgyption($nr*$tmp-$de, $de*$tmp);\n}\n\nmy $nrI = 2014;\nmy $deI = 59;\nprintf \"\\nEgyptian Fraction Representation of \" . $nrI . \"/\" . $deI . \" is: \\n\\n\";\nisEgyption($nrI,$deI);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EgyptianFractions {\n    class Program {\n        class Rational : IComparable<Rational>, IComparable<int> {\n            public BigInteger Num { get; }\n            public BigInteger Den { get; }\n\n            public Rational(BigInteger n, BigInteger d) {\n                var c = Gcd(n, d);\n                Num = n / c;\n                Den = d / c;\n                if (Den < 0) {\n                    Num = -Num;\n                    Den = -Den;\n                }\n            }\n\n            public Rational(BigInteger n) {\n                Num = n;\n                Den = 1;\n            }\n\n            public override string ToString() {\n                if (Den == 1) {\n                    return Num.ToString();\n                } else {\n                    return string.Format(\"{0}/{1}\", Num, Den);\n                }\n            }\n\n            public Rational Add(Rational rhs) {\n                return new Rational(Num * rhs.Den + rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public Rational Sub(Rational rhs) {\n                return new Rational(Num * rhs.Den - rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public int CompareTo(Rational rhs) {\n                var ad = Num * rhs.Den;\n                var bc = Den * rhs.Num;\n                return ad.CompareTo(bc);\n            }\n\n            public int CompareTo(int rhs) {\n                var ad = Num * rhs;\n                var bc = Den * rhs;\n                return ad.CompareTo(bc);\n            }\n        }\n\n        static BigInteger Gcd(BigInteger a, BigInteger b) {\n            if (b == 0) {\n                if (a < 0) {\n                    return -a;\n                } else {\n                    return a;\n                }\n            } else {\n                return Gcd(b, a % b);\n            }\n        }\n\n        static List<Rational> Egyptian(Rational r) {\n            List<Rational> result = new List<Rational>();\n\n            if (r.CompareTo(1) >= 0) {\n                if (r.Den == 1) {\n                    result.Add(r);\n                    result.Add(new Rational(0));\n                    return result;\n                }\n                result.Add(new Rational(r.Num / r.Den));\n                r = r.Sub(result[0]);\n            }\n\n            BigInteger modFunc(BigInteger m, BigInteger n) {\n                return ((m % n) + n) % n;\n            }\n\n            while (r.Num != 1) {\n                var q = (r.Den + r.Num - 1) / r.Num;\n                result.Add(new Rational(1, q));\n                r = new Rational(modFunc(-r.Den, r.Num), r.Den * q);\n            }\n\n            result.Add(r);\n            return result;\n        }\n\n        static string FormatList<T>(IEnumerable<T> col) {\n            StringBuilder sb = new StringBuilder();\n            var iter = col.GetEnumerator();\n\n            sb.Append('[');\n            if (iter.MoveNext()) {\n                sb.Append(iter.Current);\n            }\n            while (iter.MoveNext()) {\n                sb.AppendFormat(\", {0}\", iter.Current);\n            }\n            sb.Append(']');\n\n            return sb.ToString();\n        }\n\n        static void Main() {\n            List<Rational> rs = new List<Rational> {\n                new Rational(43, 48),\n                new Rational(5, 121),\n                new Rational(2014, 59)\n            };\n            foreach (var r in rs) {\n                Console.WriteLine(\"{0} => {1}\", r, FormatList(Egyptian(r)));\n            }\n\n            var lenMax = Tuple.Create(0UL, new Rational(0));\n            var denomMax = Tuple.Create(BigInteger.Zero, new Rational(0));\n\n            var query = (from i in Enumerable.Range(1, 100)\n                         from j in Enumerable.Range(1, 100)\n                         select new Rational(i, j))\n                         .Distinct()\n                         .ToList();\n            foreach (var r in query) {\n                var e = Egyptian(r);\n                ulong eLen = (ulong) e.Count;\n                var eDenom = e.Last().Den;\n                if (eLen > lenMax.Item1) {\n                    lenMax = Tuple.Create(eLen, r);\n                }\n                if (eDenom > denomMax.Item1) {\n                    denomMax = Tuple.Create(eDenom, r);\n                }\n            }\n\n            Console.WriteLine(\"Term max is {0} with {1} terms\", lenMax.Item2, lenMax.Item1);\n            var dStr = denomMax.Item1.ToString();\n            Console.WriteLine(\"Denominator max is {0} with {1} digits {2}...{3}\", denomMax.Item2, dStr.Length, dStr.Substring(0, 5), dStr.Substring(dStr.Length - 5, 5));\n        }\n    }\n}\n"}
{"id": 400343, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Perl to C#: use List::Util qw(sum);\nuse constant pi => 3.14159265;\n\nsub legendre_pair {\n    my($n, $x) = @_;\n    if ($n == 1) { return $x, 1 }\n    my ($m1, $m2) = legendre_pair($n - 1, $x);\n    my $u = 1 - 1 / $n;\n    (1 + $u) * $x * $m1 - $u * $m2, $m1;\n}\n\nsub legendre {\n    my($n, $x) = @_;\n    (legendre_pair($n, $x))[0]\n}\n\nsub legendre_prime {\n    my($n, $x) = @_;\n    if ($n == 0) { return 0 }\n    if ($n == 1) { return 1 }\n    my ($m0, $m1) = legendre_pair($n, $x);\n    ($m1 - $x * $m0) * $n / (1 - $x**2);\n}\n\nsub approximate_legendre_root {\n    my($n, $k) = @_;\n    my $t = (4*$k - 1) / (4*$n + 2);\n    (1 - ($n - 1) / (8 * $n**3)) * cos(pi * $t);\n}\n\nsub newton_raphson {\n    my($n, $r) = @_;\n    while (abs(my $dr = - legendre($n,$r) / legendre_prime($n,$r)) >= 2e-16) {\n        $r += $dr;\n    }\n    $r;\n}\n\nsub legendre_root {\n    my($n, $k) = @_;\n    newton_raphson($n, approximate_legendre_root($n, $k));\n}\n\nsub weight {\n    my($n, $r) = @_;\n    2 / ((1 - $r**2) * legendre_prime($n, $r)**2)\n}\n\nsub nodes {\n    my($n) = @_;\n    my %node;\n    $node{'0'} = weight($n, 0) if 0 != $n%2;\n    for (1 .. int $n/2) {\n        my $r = legendre_root($n, $_);\n        my $w = weight($n, $r);\n        $node{$r} = $w; $node{-$r} = $w;\n    }\n    return %node\n}\n\nsub quadrature {\n    our($n, $a, $b) = @_;\n    sub scale { ($_[0] * ($b - $a) + $a + $b) / 2 }\n    %nodes = nodes($n);\n    ($b - $a) / 2 * sum map { $nodes{$_} * exp(scale($_)) } keys %nodes;\n}\n\nprintf(\"Gauss-Legendre %2d-point quadrature \u222b\u208b\u2083\u207a\u00b3 exp(x) dx \u2248\u00a0%.13f\\n\", $_, quadrature($_, -3, +3) )\n        for 5 .. 10, 20;\n", "target": "using System;\n\n\n                    \npublic class Program {\n\n    public static double[][] legeCoef(int N) {\n        \n        double[][] lcoef = new double[N+1][];\n        for (int i=0; i < lcoef.Length; ++i) \n            lcoef[i] = new double[N+1];\n\n\n        lcoef[0][0] = lcoef[1][1] = 1;\n        for (int n = 2; n <= N; n++) {\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n            for (int i = 1; i <= n; i++) \n                lcoef[n][i] = ((2*n - 1) * lcoef[n-1][i-1] \n                               - (n-1) * lcoef[n-2][i] ) / n;\n        }\n        return lcoef;\n    }\n\n\n    static double legeEval(double[][] lcoef, int N, double x) {\n        double s = lcoef[N][N];\n        for (int i = N; i > 0; --i)\n            s = s * x + lcoef[N][i-1];\n        return s;\n    }\n\n    static double legeDiff(double[][] lcoef, int N, double x) {\n        return N * (x * legeEval(lcoef, N, x) - legeEval(lcoef, N-1, x)) / (x*x - 1);\n    }\n\n    static void legeRoots(double[][] lcoef, int N, out double[] lroots,  out double[] weight) {\n        lroots = new double[N];\n        weight = new double[N];\n\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = Math.Cos(Math.PI * (i - 0.25) / (N + 0.5));\n            do { \n                x1 = x;\n                x -= legeEval(lcoef, N, x) / legeDiff(lcoef, N, x);\n            } \n            while (x != x1);\n            lroots[i-1] = x;\n\n            x1 = legeDiff(lcoef, N, x);\n            weight[i-1] = 2 / ((1 - x*x) * x1*x1);\n        }\n    }\n    \n    \n\n    static double legeInte(Func<Double, Double> f, int N, double[] weights, double[] lroots, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weights[i] * f.Invoke(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n    \n    \n    public static string Combine(double[] arrayD) {\n        return string.Join(\", \", arrayD);\t\n    }\n\n    public static void Main() {\n        int N = 5;\n        \n        var lcoeff = legeCoef(N);\n        \n        double[] roots;\n        double[] weights;\n        legeRoots(lcoeff, N, out roots, out weights);\n        \n        var integrateResult = legeInte(x=>Math.Exp(x), N, weights, roots, -3, 3);\n        \n        Console.WriteLine(\"Roots:   \" + Combine(roots));\n        Console.WriteLine(\"Weights: \" + Combine(weights)+ \"\\n\" );\n        Console.WriteLine(\"integral: \" + integrateResult );\n        Console.WriteLine(\"actual:   \" + (Math.Exp(3)-Math.Exp(-3)) );\n    }\n\n\n}\n"}
{"id": 400344, "name": "Cuban primes", "source": "Translate Perl to C#: use feature 'say';\nuse ntheory 'is_prime';\n\nsub cuban_primes {\n    my ($n) = @_;\n\n    my @primes;\n    for (my $k = 1 ; ; ++$k) {\n        my $p = 3 * $k * ($k + 1) + 1;\n        if (is_prime($p)) {\n            push @primes, $p;\n            last if @primes >= $n;\n        }\n    }\n\n    return @primes;\n}\n\nsub commify {\n    scalar reverse join ',', unpack '(A3)*', reverse shift;\n}\n\nmy @c = cuban_primes(200);\n\nwhile (@c) {\n    say join ' ', map { sprintf \"%9s\", commify $_ } splice(@c, 0, 10);\n}\n\nsay '';\nfor my $n (1 .. 6) {\n    say \"10^$n-th cuban prime is: \", commify((cuban_primes(10**$n))[-1]);\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program\n{\n    static List<long> primes = new List<long>() { 3, 5 };\n\n     static void Main(string[] args)\n    {\n        const int cutOff = 200;\n        const int bigUn = 100000;\n        const int chunks = 50;\n        const int little = bigUn / chunks;\n        const string tn = \" cuban prime\";\n        Console.WriteLine(\"The first {0:n0}{1}s:\", cutOff, tn);\n        int c = 0;\n        bool showEach = true;\n        long u = 0, v = 1;\n        DateTime st = DateTime.Now;\n        for (long i = 1; i <= long.MaxValue; i++)\n        {\n            bool found = false;\n            int mx = System.Convert.ToInt32(Math.Ceiling(Math.Sqrt(v += (u += 6))));\n            foreach (long item in primes)\n            {\n                if (item > mx) break;\n                if (v % item == 0) { found = true; break; }\n            }\n            if (!found)\n            {\n                c += 1; if (showEach)\n                {\n                    for (var z = primes.Last() + 2; z <= v - 2; z += 2)\n                    {\n                        bool fnd = false;\n                        foreach (long item in primes)\n                        {\n                            if (item > mx) break;\n                            if (z % item == 0) { fnd = true; break; }\n                        }\n                        if (!fnd) primes.Add(z);\n                    }\n                    primes.Add(v); Console.Write(\"{0,11:n0}\", v);\n                    if (c % 10 == 0) Console.WriteLine();\n                    if (c == cutOff)\n                    {\n                        showEach = false;\n                        Console.Write(\"\\nProgress to the {0:n0}th{1}: \", bigUn, tn);\n                    }\n                }\n                if (c % little == 0) { Console.Write(\".\"); if (c == bigUn) break; }\n            }\n        }\n        Console.WriteLine(\"\\nThe {1:n0}th{2} is {0,17:n0}\", v, c, tn);\n        Console.WriteLine(\"Computation time was {0} seconds\", (DateTime.Now - st).TotalSeconds);\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 400345, "name": "Chaos game", "source": "Translate Perl to C#: use Imager;\n\nmy $width  = 1000;\nmy $height = 1000;\n\nmy @points = (\n    [ $width/2,         0],\n    [        0, $height-1],\n    [$height-1, $height-1],\n);\n\nmy $img = Imager->new(\n                      xsize    => $width,\n                      ysize    => $height,\n                      channels => 3,\n                     );\n\nmy $color = Imager::Color->new('\nmy $r = [int(rand($width)), int(rand($height))];\n\nforeach my $i (1 .. 100000) {\n    my $p = $points[rand @points];\n\n    my $h = [\n        int(($p->[0] + $r->[0]) / 2),\n        int(($p->[1] + $r->[1]) / 2),\n    ];\n\n    $img->setpixel(\n        x     => $h->[0],\n        y     => $h->[1],\n        color => $color,\n    );\n\n    $r = $h;\n}\n\n$img->write(file => 'chaos_game_triangle.png');\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 400346, "name": "Chaos game", "source": "Translate Perl to C#: use Imager;\n\nmy $width  = 1000;\nmy $height = 1000;\n\nmy @points = (\n    [ $width/2,         0],\n    [        0, $height-1],\n    [$height-1, $height-1],\n);\n\nmy $img = Imager->new(\n                      xsize    => $width,\n                      ysize    => $height,\n                      channels => 3,\n                     );\n\nmy $color = Imager::Color->new('\nmy $r = [int(rand($width)), int(rand($height))];\n\nforeach my $i (1 .. 100000) {\n    my $p = $points[rand @points];\n\n    my $h = [\n        int(($p->[0] + $r->[0]) / 2),\n        int(($p->[1] + $r->[1]) / 2),\n    ];\n\n    $img->setpixel(\n        x     => $h->[0],\n        y     => $h->[1],\n        color => $color,\n    );\n\n    $r = $h;\n}\n\n$img->write(file => 'chaos_game_triangle.png');\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 400347, "name": "World Cup group stage", "source": "Translate Perl to C#: use Math::Cartesian::Product;\n\n@scoring = (0, 1, 3);\npush @histo, [(0) x 10] for 1..4;\npush @aoa,    [(0,1,2)] for 1..6;\n\nfor $results (cartesian {@_} @aoa) {\n    my @s;\n    my @g = ([0,1],[0,2],[0,3],[1,2],[1,3],[2,3]);\n    for (0..$\n        $r = $results->[$_];\n        $s[$g[$_][0]] += $scoring[$r];\n        $s[$g[$_][1]] += $scoring[2 - $r];\n    }\n\n    my @ss = sort @s;\n    $histo[$_][$ss[$_]]++ for 0..$\n}\n\n$fmt = ('%3d ') x 10 . \"\\n\";\nprintf $fmt, @$_ for reverse @histo;\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\nnamespace WorldCupGroupStage\n{\n    public static class WorldCupGroupStage\n    {\n        static int[][] _histogram;\n\n        static WorldCupGroupStage()\n        {\n            int[] scoring = new[] { 0, 1, 3 };\n\n            _histogram = Repeat<Func<int[]>>(()=>new int[10], 4).Select(f=>f()).ToArray();\n\n            var teamCombos = Range(0, 4).Combinations(2).Select(t2=>t2.ToArray()).ToList();\n\n            foreach (var results in Range(0, 3).CartesianProduct(6))\n            {\n                var points = new int[4]; \n\n                foreach (var (result, teams) in results.Zip(teamCombos, (r, t) => (r, t)))\n                {\n                    points[teams[0]] += scoring[result];\n                    points[teams[1]] += scoring[2 - result];\n                }\n\n                foreach(var (p,i) in points.OrderByDescending(a => a).Select((p,i)=>(p,i)))\n                    _histogram[i][p]++;\n            }\n        }\n      \n       \n       \n       static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> seqs) => \n            seqs.Aggregate(Empty<T>().ToSingleton(), (acc, sq) => acc.SelectMany(a => sq.Select(s => a.Append(s))));\n        \n       static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<T> seq, int repeat = 1) => \n            Repeat(seq, repeat).CartesianProduct();\n\n       static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) => \n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n       static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) => \n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        private static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n\n        static new string ToString()\n        {\n            var sb = new StringBuilder();\n\n            var range = String.Concat(Range(0, 10).Select(i => $\"{i,-3} \"));\n            sb.AppendLine($\"Points     \u00a0: {range}\");\n\n            var u = String.Concat(Repeat(\"\u2500\", 40+13));\n            sb.AppendLine($\"{u}\");\n\n            var places = new[] { \"First\", \"Second\", \"Third\", \"Fourth\" };\n            foreach (var row in _histogram.Select((r, i) => (r, i)))\n            {\n                sb.Append($\"{places[row.i],-6} place: \");\n                foreach (var standing in row.r)\n                    sb.Append($\"{standing,-3} \");\n                sb.Append(\"\\n\");\n            }\n\n            return sb.ToString();\n        }\n\n        static void Main(string[] args)\n        {\n            Write(ToString());\n            Read();\n        }\n    }\n}\n"}
{"id": 400348, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Perl to C#: my %prec = (\n    '^' => 4,\n    '*' => 3,\n    '/' => 3,\n    '+' => 2,\n    '-' => 2,\n    '(' => 1\n);\n\nmy %assoc = (\n    '^' => 'right',\n    '*' => 'left',\n    '/' => 'left',\n    '+' => 'left',\n    '-' => 'left'\n);\n\nsub shunting_yard {\n    my @inp = split ' ', $_[0];\n    my @ops;\n    my @res;\n\n    my $report = sub { printf \"%25s   \u00a0%-7s %10s %s\\n\", \"@res\", \"@ops\", $_[0], \"@inp\" };\n    my $shift  = sub { $report->(\"shift @_\");  push @ops, @_ };\n    my $reduce = sub { $report->(\"reduce @_\"); push @res, @_ };\n\n    while (@inp) {\n        my $token = shift @inp;\n        if    ( $token =~ /\\d/ ) { $reduce->($token) }\n        elsif ( $token eq '(' )  { $shift->($token) }\n        elsif ( $token eq ')' ) {\n            while ( @ops and \"(\" ne ( my $x = pop @ops ) ) { $reduce->($x) }\n        } else {\n            my $newprec = $prec{$token};\n            while (@ops) {\n                my $oldprec = $prec{ $ops[-1] };\n                last if $newprec > $oldprec;\n                last if $newprec == $oldprec and $assoc{$token} eq 'right';\n                $reduce->( pop @ops );\n            }\n            $shift->($token);\n        }\n    }\n    $reduce->( pop @ops ) while @ops;\n    @res;\n}\n\nlocal $, = \" \";\nprint shunting_yard '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3';\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        string infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        Console.WriteLine(infix.ToPostfix());\n    }\n}\n\npublic static class ShuntingYard\n{\n    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators\n        = new (string symbol, int precedence, bool rightAssociative) [] {\n            (\"^\", 4, true),\n            (\"*\", 3, false),\n            (\"/\", 3, false),\n            (\"+\", 2, false),\n            (\"-\", 2, false)\n    }.ToDictionary(op => op.symbol);\n\n    public static string ToPostfix(this string infix) {\n        string[] tokens = infix.Split(' ');\n        var stack = new Stack<string>();\n        var output = new List<string>();\n        foreach (string token in tokens) {\n            if (int.TryParse(token, out _)) {\n                output.Add(token);\n                Print(token);\n            } else if (operators.TryGetValue(token, out var op1)) {\n                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {\n                    int c = op1.precedence.CompareTo(op2.precedence);\n                    if (c < 0 || !op1.rightAssociative && c <= 0) {\n                        output.Add(stack.Pop());\n                    } else {\n                        break;\n                    }\n                }\n                stack.Push(token);\n                Print(token);\n            } else if (token == \"(\") {\n                stack.Push(token);\n                Print(token);\n            } else if (token == \")\") {\n                string top = \"\";\n                while (stack.Count > 0 && (top = stack.Pop()) != \"(\") {\n                    output.Add(top);\n                }\n                if (top != \"(\") throw new ArgumentException(\"No matching left parenthesis.\");\n                Print(token);\n            }\n        }\n        while (stack.Count > 0) {\n            var top = stack.Pop();\n            if (!operators.ContainsKey(top)) throw new ArgumentException(\"No matching right parenthesis.\");\n            output.Add(top);\n        }\n        Print(\"pop\");\n        return string.Join(\" \", output);\n        \n        \n        void Print(string action) => Console.WriteLine($\"{action + \":\",-4} {$\"stack[ {string.Join(\" \", stack.Reverse())} ]\",-18} {$\"out[ {string.Join(\" \", output)} ]\"}\");\n        \n        void Print(string action) => Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {string.Join(\" \", stack.Reverse())} ]\", $\"out[ {string.Join(\" \", output)} ]\");\n    }\n}\n"}
{"id": 400349, "name": "A_ search algorithm", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( nsort_by );\n\nsub distance\n  {\n  my ($r1, $c1, $r2, $c2) = split /[, ]/, \"@_\";\n  sqrt( ($r1-$r2)**2 + ($c1-$c2)**2 );\n  }\n\nmy $start = '0,0';\nmy $finish = '7,7';\nmy %barrier = map {$_, 100}\n  split ' ', '2,4 2,5 2,6 3,6 4,6 5,6 5,5 5,4 5,3 5,2 4,2 3,2';\nmy %values = ( $start, 0 );\nmy @new = [ $start, 0 ];\nmy %from;\nmy $mid;\nwhile( ! exists $values{$finish} and @new )\n  {\n  my $pick = (shift @new)->[0];\n  for my $n ( nsort_by { distance($_, $finish) } \n    grep !/-|8/ && ! exists $values{$_},\n    glob $pick =~ s/\\d+/{@{[$&-1]},$&,@{[$&+1]}}/gr\n    )\n    {\n    $from{$n} = $pick;\n    $values{$n} = $values{$pick} + ( $barrier{$n} // 1 );\n    my $new = [ $n, my $dist = $values{$n} ];\n    my $low = 0; \n    my $high = @new;\n    $new[$mid = $low + $high >> 1][1] <= $dist\n      ? ($low = $mid + 1) : ($high = $mid) while $low < $high;\n    splice @new, $low, 0, $new; \n    }\n  }\n\nmy $grid = \"s.......\\n\" . ('.' x 8 . \"\\n\") x 7;\nsubstr $grid, /,/ * $` * 9 + $', 1, 'b' for keys %barrier;\nmy @path = my $pos = $finish; \nwhile( $pos ne $start )\n  {\n  substr $grid, $pos =~ /,/ ? $` * 9 + $' : die, 1, 'x';\n  unshift @path, $pos = $from{$pos};\n  }\nprint \"$grid\\nvalue $values{$finish}  path @path\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace A_star\n{\n    class A_star\n    {\n        \n        public class Coordinates : IEquatable<Coordinates>\n        {\n            public int row;\n            public int col;\n\n            public Coordinates() { this.row = -1; this.col = -1; }\n            public Coordinates(int row, int col) { this.row = row; this.col = col; }\n\n            public Boolean Equals(Coordinates c)\n            {\n                if (this.row == c.row && this.col == c.col)\n                    return true;\n                else\n                    return false;\n            }\n        }\n\n        \n        \n        public class Cell\n        {\n            public int cost;\n            public int g;\n            public int f;\n            public Coordinates parent;\n        }\n\n        \n        public class Astar\n        {\n            \n            public Cell[,] cells = new Cell[8, 8];\n            \n            public List<Coordinates> path = new List<Coordinates>();\n            \n            public List<Coordinates> opened = new List<Coordinates>();\n            \n            public List<Coordinates> closed = new List<Coordinates>();\n            \n            public Coordinates startCell = new Coordinates(0, 0);\n            \n            public Coordinates finishCell = new Coordinates(7, 7);\n\n            \n            public Astar()\n            {\n                \n                for (int i = 0; i < 8; i++)\n                    for (int j = 0; j < 8; j++)\n                    {\n                        cells[i, j] = new Cell();\n                        cells[i, j].parent = new Coordinates();\n                        if (IsAWall(i, j))\n                            cells[i, j].cost = 100;\n                        else\n                            cells[i, j].cost = 1;\n                    }\n\n                \n                opened.Add(startCell);\n\n                \n                Boolean pathFound = false;\n\n                \n                do\n                {\n                    List<Coordinates> neighbors = new List<Coordinates>();\n                    \n                    Coordinates currentCell = ShorterExpectedPath();\n                    \n                    neighbors = neighborsCells(currentCell);\n                    foreach (Coordinates newCell in neighbors)\n                    {\n                        \n                        if (newCell.row == finishCell.row && newCell.col == finishCell.col)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            pathFound = true;\n                            break;\n                        }\n\n                        \n                        else if (!opened.Contains(newCell) && !closed.Contains(newCell))\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                        }\n\n                        \n                        \n                        else if (cells[newCell.row, newCell.col].g > cells[currentCell.row,\n                            currentCell.col].g + cells[newCell.row, newCell.col].cost)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                            ResetCell(newCell, closed);\n                        }\n                    }\n                    SetCell(currentCell, closed);\n                    ResetCell(currentCell, opened);\n                } while (opened.Count > 0 && pathFound == false);\n\n                if (pathFound)\n                {\n                    path.Add(finishCell);\n                    Coordinates currentCell = new Coordinates(finishCell.row, finishCell.col);\n                    \n                    while (cells[currentCell.row, currentCell.col].parent.row >= 0)\n                    {\n                        path.Add(cells[currentCell.row, currentCell.col].parent);\n                        int tmp_row = cells[currentCell.row, currentCell.col].parent.row;\n                        currentCell.col = cells[currentCell.row, currentCell.col].parent.col;\n                        currentCell.row = tmp_row;\n                    }\n\n                    \n                    for (int i = 0; i < 8; i++)\n                    {\n                        for (int j = 0; j < 8; j++)\n                        {\n                            \n                            \n                            char gr = '.';\n                            \n                            if (path.Contains(new Coordinates(i, j))) { gr = 'X'; }\n                            \n                            else if (cells[i, j].cost > 1) { gr = '\\u2588'; }\n                            System.Console.Write(gr);\n                        }\n                        System.Console.WriteLine();\n                    }\n\n                    \n                    System.Console.Write(\"\\nPath: \");\n                    for (int i = path.Count - 1; i >= 0; i--)\n                    {\n                        System.Console.Write(\"({0},{1})\", path[i].row, path[i].col);\n                    }\n\n                    \n                    System.Console.WriteLine(\"\\nPath cost: {0}\", path.Count - 1);\n\n                    \n                    String wt = System.Console.ReadLine();\n                }\n            }\n\n            \n            \n            public Coordinates ShorterExpectedPath()\n            {\n                int sep = 0;\n                if (opened.Count > 1)\n                {\n                    for (int i = 1; i < opened.Count; i++)\n                    {\n                        if (cells[opened[i].row, opened[i].col].f < cells[opened[sep].row,\n                            opened[sep].col].f)\n                        {\n                            sep = i;\n                        }\n                    }\n                }\n                return opened[sep];\n            }\n\n            \n            public List<Coordinates> neighborsCells(Coordinates c)\n            {\n                List<Coordinates> lc = new List<Coordinates>();\n                for (int i = -1; i <= 1; i++)\n                    for (int j = -1; j <= 1; j++)\n                        if (c.row+i >= 0 && c.row+i < 8 && c.col+j >= 0 && c.col+j < 8 &&\n                            (i != 0 || j != 0))\n                        {\n                            lc.Add(new Coordinates(c.row + i, c.col + j));\n                        }\n                return lc;\n            }\n\n            \n            public bool IsAWall(int row, int col)\n            {\n                int[,] walls = new int[,] { { 2, 4 }, { 2, 5 }, { 2, 6 }, { 3, 6 }, { 4, 6 },\n                    { 5, 6 }, { 5, 5 }, { 5, 4 }, { 5, 3 }, { 5, 2 }, { 4, 2 }, { 3, 2 } };\n                bool found = false;\n                for (int i = 0; i < walls.GetLength(0); i++)\n                    if (walls[i,0] == row && walls[i,1] == col)\n                        found = true;\n                return found;\n            }\n\n            \n            \n            public int Heuristic(Coordinates cell)\n            {\n                int dRow = Math.Abs(finishCell.row - cell.row);\n                int dCol = Math.Abs(finishCell.col - cell.col);\n                return Math.Max(dRow, dCol);\n            }\n\n            \n            public void SetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell) == false)\n                {\n                    coordinatesList.Add(cell);\n                }\n            }\n\n            \n            public void ResetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell))\n                {\n                    coordinatesList.Remove(cell);\n                }\n            }\n        }\n\n        \n        static void Main(string[] args)\n        {\n            Astar astar = new Astar();\n        }\n    }\n}\n"}
{"id": 400350, "name": "A_ search algorithm", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( nsort_by );\n\nsub distance\n  {\n  my ($r1, $c1, $r2, $c2) = split /[, ]/, \"@_\";\n  sqrt( ($r1-$r2)**2 + ($c1-$c2)**2 );\n  }\n\nmy $start = '0,0';\nmy $finish = '7,7';\nmy %barrier = map {$_, 100}\n  split ' ', '2,4 2,5 2,6 3,6 4,6 5,6 5,5 5,4 5,3 5,2 4,2 3,2';\nmy %values = ( $start, 0 );\nmy @new = [ $start, 0 ];\nmy %from;\nmy $mid;\nwhile( ! exists $values{$finish} and @new )\n  {\n  my $pick = (shift @new)->[0];\n  for my $n ( nsort_by { distance($_, $finish) } \n    grep !/-|8/ && ! exists $values{$_},\n    glob $pick =~ s/\\d+/{@{[$&-1]},$&,@{[$&+1]}}/gr\n    )\n    {\n    $from{$n} = $pick;\n    $values{$n} = $values{$pick} + ( $barrier{$n} // 1 );\n    my $new = [ $n, my $dist = $values{$n} ];\n    my $low = 0; \n    my $high = @new;\n    $new[$mid = $low + $high >> 1][1] <= $dist\n      ? ($low = $mid + 1) : ($high = $mid) while $low < $high;\n    splice @new, $low, 0, $new; \n    }\n  }\n\nmy $grid = \"s.......\\n\" . ('.' x 8 . \"\\n\") x 7;\nsubstr $grid, /,/ * $` * 9 + $', 1, 'b' for keys %barrier;\nmy @path = my $pos = $finish; \nwhile( $pos ne $start )\n  {\n  substr $grid, $pos =~ /,/ ? $` * 9 + $' : die, 1, 'x';\n  unshift @path, $pos = $from{$pos};\n  }\nprint \"$grid\\nvalue $values{$finish}  path @path\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace A_star\n{\n    class A_star\n    {\n        \n        public class Coordinates : IEquatable<Coordinates>\n        {\n            public int row;\n            public int col;\n\n            public Coordinates() { this.row = -1; this.col = -1; }\n            public Coordinates(int row, int col) { this.row = row; this.col = col; }\n\n            public Boolean Equals(Coordinates c)\n            {\n                if (this.row == c.row && this.col == c.col)\n                    return true;\n                else\n                    return false;\n            }\n        }\n\n        \n        \n        public class Cell\n        {\n            public int cost;\n            public int g;\n            public int f;\n            public Coordinates parent;\n        }\n\n        \n        public class Astar\n        {\n            \n            public Cell[,] cells = new Cell[8, 8];\n            \n            public List<Coordinates> path = new List<Coordinates>();\n            \n            public List<Coordinates> opened = new List<Coordinates>();\n            \n            public List<Coordinates> closed = new List<Coordinates>();\n            \n            public Coordinates startCell = new Coordinates(0, 0);\n            \n            public Coordinates finishCell = new Coordinates(7, 7);\n\n            \n            public Astar()\n            {\n                \n                for (int i = 0; i < 8; i++)\n                    for (int j = 0; j < 8; j++)\n                    {\n                        cells[i, j] = new Cell();\n                        cells[i, j].parent = new Coordinates();\n                        if (IsAWall(i, j))\n                            cells[i, j].cost = 100;\n                        else\n                            cells[i, j].cost = 1;\n                    }\n\n                \n                opened.Add(startCell);\n\n                \n                Boolean pathFound = false;\n\n                \n                do\n                {\n                    List<Coordinates> neighbors = new List<Coordinates>();\n                    \n                    Coordinates currentCell = ShorterExpectedPath();\n                    \n                    neighbors = neighborsCells(currentCell);\n                    foreach (Coordinates newCell in neighbors)\n                    {\n                        \n                        if (newCell.row == finishCell.row && newCell.col == finishCell.col)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            pathFound = true;\n                            break;\n                        }\n\n                        \n                        else if (!opened.Contains(newCell) && !closed.Contains(newCell))\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                        }\n\n                        \n                        \n                        else if (cells[newCell.row, newCell.col].g > cells[currentCell.row,\n                            currentCell.col].g + cells[newCell.row, newCell.col].cost)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                            ResetCell(newCell, closed);\n                        }\n                    }\n                    SetCell(currentCell, closed);\n                    ResetCell(currentCell, opened);\n                } while (opened.Count > 0 && pathFound == false);\n\n                if (pathFound)\n                {\n                    path.Add(finishCell);\n                    Coordinates currentCell = new Coordinates(finishCell.row, finishCell.col);\n                    \n                    while (cells[currentCell.row, currentCell.col].parent.row >= 0)\n                    {\n                        path.Add(cells[currentCell.row, currentCell.col].parent);\n                        int tmp_row = cells[currentCell.row, currentCell.col].parent.row;\n                        currentCell.col = cells[currentCell.row, currentCell.col].parent.col;\n                        currentCell.row = tmp_row;\n                    }\n\n                    \n                    for (int i = 0; i < 8; i++)\n                    {\n                        for (int j = 0; j < 8; j++)\n                        {\n                            \n                            \n                            char gr = '.';\n                            \n                            if (path.Contains(new Coordinates(i, j))) { gr = 'X'; }\n                            \n                            else if (cells[i, j].cost > 1) { gr = '\\u2588'; }\n                            System.Console.Write(gr);\n                        }\n                        System.Console.WriteLine();\n                    }\n\n                    \n                    System.Console.Write(\"\\nPath: \");\n                    for (int i = path.Count - 1; i >= 0; i--)\n                    {\n                        System.Console.Write(\"({0},{1})\", path[i].row, path[i].col);\n                    }\n\n                    \n                    System.Console.WriteLine(\"\\nPath cost: {0}\", path.Count - 1);\n\n                    \n                    String wt = System.Console.ReadLine();\n                }\n            }\n\n            \n            \n            public Coordinates ShorterExpectedPath()\n            {\n                int sep = 0;\n                if (opened.Count > 1)\n                {\n                    for (int i = 1; i < opened.Count; i++)\n                    {\n                        if (cells[opened[i].row, opened[i].col].f < cells[opened[sep].row,\n                            opened[sep].col].f)\n                        {\n                            sep = i;\n                        }\n                    }\n                }\n                return opened[sep];\n            }\n\n            \n            public List<Coordinates> neighborsCells(Coordinates c)\n            {\n                List<Coordinates> lc = new List<Coordinates>();\n                for (int i = -1; i <= 1; i++)\n                    for (int j = -1; j <= 1; j++)\n                        if (c.row+i >= 0 && c.row+i < 8 && c.col+j >= 0 && c.col+j < 8 &&\n                            (i != 0 || j != 0))\n                        {\n                            lc.Add(new Coordinates(c.row + i, c.col + j));\n                        }\n                return lc;\n            }\n\n            \n            public bool IsAWall(int row, int col)\n            {\n                int[,] walls = new int[,] { { 2, 4 }, { 2, 5 }, { 2, 6 }, { 3, 6 }, { 4, 6 },\n                    { 5, 6 }, { 5, 5 }, { 5, 4 }, { 5, 3 }, { 5, 2 }, { 4, 2 }, { 3, 2 } };\n                bool found = false;\n                for (int i = 0; i < walls.GetLength(0); i++)\n                    if (walls[i,0] == row && walls[i,1] == col)\n                        found = true;\n                return found;\n            }\n\n            \n            \n            public int Heuristic(Coordinates cell)\n            {\n                int dRow = Math.Abs(finishCell.row - cell.row);\n                int dCol = Math.Abs(finishCell.col - cell.col);\n                return Math.Max(dRow, dCol);\n            }\n\n            \n            public void SetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell) == false)\n                {\n                    coordinatesList.Add(cell);\n                }\n            }\n\n            \n            public void ResetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell))\n                {\n                    coordinatesList.Remove(cell);\n                }\n            }\n        }\n\n        \n        static void Main(string[] args)\n        {\n            Astar astar = new Astar();\n        }\n    }\n}\n"}
{"id": 400351, "name": "Nonogram solver", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nmy $file = 'nonogram_problems.txt';\nopen my $fd, '<', $file or die \"$! opening $file\";\n\nwhile(my $row = <$fd> )\n  {\n  $row =~ /\\S/ or next;\n  my $column = <$fd>;\n  my @rpats = makepatterns($row);\n  my @cpats = makepatterns($column);\n  my @rows = ( '.' x @cpats ) x @rpats;\n  for( my $prev = ''; $prev ne \"@rows\"; )\n    {\n    $prev = \"@rows\";\n    try(\\@rows, \\@rpats);\n    my @cols = map { join '', map { s/.//; $& } @rows } 0..$\n    try(\\@cols, \\@cpats);\n    @rows = map { join '', map { s/.//; $& } @cols } 0..$\n    }\n  print \"\\n\", \"@rows\" =~ /\\./ ? \"Failed\\n\" : map { tr/01/.\n  }\n\nsub try\n  {\n  my ($lines, $patterns) = @_;\n  for my $i ( 0 .. $\n    {\n    while( $lines->[$i] =~ /\\./g )\n      {\n      for my $try ( 0, 1 )\n        {\n        $lines->[$i] =~ s/.\\G/$try/r =~ $patterns->[$i] or\n          $lines->[$i] =~ s// 1 - $try /e;\n        }\n      }\n    }\n  }\n\nsub makepatterns {                         \n    map { qr/^$_$/                          \n        } map {  '[0.]*'                    \n               . join('[0.]+',              \n                       map { \"[1.]{$_}\"     \n                           } map { -64+ord  \n                                 } split // \n                     )\n               . '[0.]*'                    \n              } split ' ', shift;           \n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class NonogramSolver\n{\n    public static void Main2() {\n        foreach (var (x, y) in new [] {\n            (\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"),\n            (\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\",\n                \"D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"),\n            (\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n                \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC\"),\n            (\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G\",\n                \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\")\n            })\n        {\n            Solve(x, y);\n            Console.WriteLine();\n        }\n    }\n\n    static void Solve(string rowLetters, string columnLetters) {\n        var r = rowLetters.Split(\" \").Select(row => row.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        var c = columnLetters.Split(\" \").Select(column => column.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        Solve(r, c);\n    }\n\n    static void Solve(int[][] rowRuns, int[][] columnRuns) {\n        int len = columnRuns.Length;\n        var rows = rowRuns.Select(row => Generate(len, row)).ToList();\n        var columns = columnRuns.Select(column => Generate(rowRuns.Length, column)).ToList();\n        Reduce(rows, columns);\n        foreach (var list in rows) {\n            if (list.Count != 1) Console.WriteLine(Repeat('?', len).Spaced());\n            else Console.WriteLine(list[0].ToString().PadLeft(len, '0').Replace('1', '#').Replace('0', '.').Reverse().Spaced());\n        }\n    }\n\n    static List<BitSet> Generate(int length, params int[] runs) {\n        var list = new List<BitSet>();\n        BitSet initial = BitSet.Empty;\n        int[] sums = new int[runs.Length];\n        sums[0] = 0;\n        for (int i = 1; i < runs.Length; i++) sums[i] = sums[i - 1] + runs[i - 1] + 1;\n        for (int r = 0; r < runs.Length; r++) initial = initial.AddRange(sums[r], runs[r]);\n        Generate(list, BitSet.Empty.Add(length), runs, sums, initial, 0, 0);\n        return list;\n    }\n\n    static void Generate(List<BitSet> result, BitSet max, int[] runs, int[] sums, BitSet current, int index, int shift) {\n        if (index == runs.Length) {\n            result.Add(current);\n            return;\n        }\n        while (current.Value < max.Value) {\n            Generate(result, max, runs, sums, current, index + 1, shift);\n            current = current.ShiftLeftAt(sums[index] + shift);\n            shift++;\n        }\n    }\n\n    static void Reduce(List<List<BitSet>> rows, List<List<BitSet>> columns) {\n        for (int count = 1; count > 0; ) {\n            foreach (var (rowIndex, row) in rows.WithIndex()) {\n                var allOn  = row.Aggregate((a, b) => a & b);\n                var allOff = row.Aggregate((a, b) => a | b);\n                foreach (var (columnIndex, column) in columns.WithIndex()) {\n                    count  = column.RemoveAll(c => allOn.Contains(columnIndex) && !c.Contains(rowIndex));\n                    count += column.RemoveAll(c => !allOff.Contains(columnIndex) && c.Contains(rowIndex));\n                }\n            }\n            foreach (var (columnIndex, column) in columns.WithIndex()) {\n                var allOn  = column.Aggregate((a, b) => a & b);\n                var allOff = column.Aggregate((a, b) => a | b);\n                foreach (var (rowIndex, row) in rows.WithIndex()) {\n                    count += row.RemoveAll(r => allOn.Contains(rowIndex) && !r.Contains(columnIndex));\n                    count += row.RemoveAll(r => !allOff.Contains(rowIndex) && r.Contains(columnIndex));\n                }\n            }\n        }\n    }\n\n    static IEnumerable<(int index, T element)> WithIndex<T>(this IEnumerable<T> source) {\n        int i = 0;\n        foreach (T element in source) {\n            yield return (i++, element);\n        }\n    }\n\n    static string Reverse(this string s) {\n        char[] array = s.ToCharArray();\n        Array.Reverse(array);\n        return new string(array);\n    }\n\n    static string Spaced(this IEnumerable<char> s) => string.Join(\" \", s);\n\n    struct BitSet \n    {\n        public static BitSet Empty => default;\n        private readonly int bits;\n        public int Value => bits;\n\n        private BitSet(int bits) => this.bits = bits;\n\n        public BitSet Add(int item) => new BitSet(bits | (1 << item));\n        public BitSet AddRange(int start, int count) => new BitSet(bits | (((1 << (start + count)) - 1) - ((1 << start) - 1)));\n        public bool Contains(int item) => (bits & (1 << item)) != 0;\n        public BitSet ShiftLeftAt(int index)  => new BitSet((bits >> index << (index + 1)) | (bits & ((1 << index) - 1)));\n        public override string ToString() => Convert.ToString(bits, 2);\n\n        public static BitSet operator &(BitSet a, BitSet b) => new BitSet(a.bits & b.bits);\n        public static BitSet operator |(BitSet a, BitSet b) => new BitSet(a.bits | b.bits);\n    }\n\n}\n"}
{"id": 400352, "name": "Nonogram solver", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nmy $file = 'nonogram_problems.txt';\nopen my $fd, '<', $file or die \"$! opening $file\";\n\nwhile(my $row = <$fd> )\n  {\n  $row =~ /\\S/ or next;\n  my $column = <$fd>;\n  my @rpats = makepatterns($row);\n  my @cpats = makepatterns($column);\n  my @rows = ( '.' x @cpats ) x @rpats;\n  for( my $prev = ''; $prev ne \"@rows\"; )\n    {\n    $prev = \"@rows\";\n    try(\\@rows, \\@rpats);\n    my @cols = map { join '', map { s/.//; $& } @rows } 0..$\n    try(\\@cols, \\@cpats);\n    @rows = map { join '', map { s/.//; $& } @cols } 0..$\n    }\n  print \"\\n\", \"@rows\" =~ /\\./ ? \"Failed\\n\" : map { tr/01/.\n  }\n\nsub try\n  {\n  my ($lines, $patterns) = @_;\n  for my $i ( 0 .. $\n    {\n    while( $lines->[$i] =~ /\\./g )\n      {\n      for my $try ( 0, 1 )\n        {\n        $lines->[$i] =~ s/.\\G/$try/r =~ $patterns->[$i] or\n          $lines->[$i] =~ s// 1 - $try /e;\n        }\n      }\n    }\n  }\n\nsub makepatterns {                         \n    map { qr/^$_$/                          \n        } map {  '[0.]*'                    \n               . join('[0.]+',              \n                       map { \"[1.]{$_}\"     \n                           } map { -64+ord  \n                                 } split // \n                     )\n               . '[0.]*'                    \n              } split ' ', shift;           \n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class NonogramSolver\n{\n    public static void Main2() {\n        foreach (var (x, y) in new [] {\n            (\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"),\n            (\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\",\n                \"D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"),\n            (\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n                \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC\"),\n            (\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G\",\n                \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\")\n            })\n        {\n            Solve(x, y);\n            Console.WriteLine();\n        }\n    }\n\n    static void Solve(string rowLetters, string columnLetters) {\n        var r = rowLetters.Split(\" \").Select(row => row.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        var c = columnLetters.Split(\" \").Select(column => column.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        Solve(r, c);\n    }\n\n    static void Solve(int[][] rowRuns, int[][] columnRuns) {\n        int len = columnRuns.Length;\n        var rows = rowRuns.Select(row => Generate(len, row)).ToList();\n        var columns = columnRuns.Select(column => Generate(rowRuns.Length, column)).ToList();\n        Reduce(rows, columns);\n        foreach (var list in rows) {\n            if (list.Count != 1) Console.WriteLine(Repeat('?', len).Spaced());\n            else Console.WriteLine(list[0].ToString().PadLeft(len, '0').Replace('1', '#').Replace('0', '.').Reverse().Spaced());\n        }\n    }\n\n    static List<BitSet> Generate(int length, params int[] runs) {\n        var list = new List<BitSet>();\n        BitSet initial = BitSet.Empty;\n        int[] sums = new int[runs.Length];\n        sums[0] = 0;\n        for (int i = 1; i < runs.Length; i++) sums[i] = sums[i - 1] + runs[i - 1] + 1;\n        for (int r = 0; r < runs.Length; r++) initial = initial.AddRange(sums[r], runs[r]);\n        Generate(list, BitSet.Empty.Add(length), runs, sums, initial, 0, 0);\n        return list;\n    }\n\n    static void Generate(List<BitSet> result, BitSet max, int[] runs, int[] sums, BitSet current, int index, int shift) {\n        if (index == runs.Length) {\n            result.Add(current);\n            return;\n        }\n        while (current.Value < max.Value) {\n            Generate(result, max, runs, sums, current, index + 1, shift);\n            current = current.ShiftLeftAt(sums[index] + shift);\n            shift++;\n        }\n    }\n\n    static void Reduce(List<List<BitSet>> rows, List<List<BitSet>> columns) {\n        for (int count = 1; count > 0; ) {\n            foreach (var (rowIndex, row) in rows.WithIndex()) {\n                var allOn  = row.Aggregate((a, b) => a & b);\n                var allOff = row.Aggregate((a, b) => a | b);\n                foreach (var (columnIndex, column) in columns.WithIndex()) {\n                    count  = column.RemoveAll(c => allOn.Contains(columnIndex) && !c.Contains(rowIndex));\n                    count += column.RemoveAll(c => !allOff.Contains(columnIndex) && c.Contains(rowIndex));\n                }\n            }\n            foreach (var (columnIndex, column) in columns.WithIndex()) {\n                var allOn  = column.Aggregate((a, b) => a & b);\n                var allOff = column.Aggregate((a, b) => a | b);\n                foreach (var (rowIndex, row) in rows.WithIndex()) {\n                    count += row.RemoveAll(r => allOn.Contains(rowIndex) && !r.Contains(columnIndex));\n                    count += row.RemoveAll(r => !allOff.Contains(rowIndex) && r.Contains(columnIndex));\n                }\n            }\n        }\n    }\n\n    static IEnumerable<(int index, T element)> WithIndex<T>(this IEnumerable<T> source) {\n        int i = 0;\n        foreach (T element in source) {\n            yield return (i++, element);\n        }\n    }\n\n    static string Reverse(this string s) {\n        char[] array = s.ToCharArray();\n        Array.Reverse(array);\n        return new string(array);\n    }\n\n    static string Spaced(this IEnumerable<char> s) => string.Join(\" \", s);\n\n    struct BitSet \n    {\n        public static BitSet Empty => default;\n        private readonly int bits;\n        public int Value => bits;\n\n        private BitSet(int bits) => this.bits = bits;\n\n        public BitSet Add(int item) => new BitSet(bits | (1 << item));\n        public BitSet AddRange(int start, int count) => new BitSet(bits | (((1 << (start + count)) - 1) - ((1 << start) - 1)));\n        public bool Contains(int item) => (bits & (1 << item)) != 0;\n        public BitSet ShiftLeftAt(int index)  => new BitSet((bits >> index << (index + 1)) | (bits & ((1 << index) - 1)));\n        public override string ToString() => Convert.ToString(bits, 2);\n\n        public static BitSet operator &(BitSet a, BitSet b) => new BitSet(a.bits & b.bits);\n        public static BitSet operator |(BitSet a, BitSet b) => new BitSet(a.bits | b.bits);\n    }\n\n}\n"}
{"id": 400353, "name": "Almkvist-Giullera formula for pi", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature qw(say);\nuse Math::AnyNum qw(:overload factorial);\n\nsub almkvist_giullera_integral {\n    my($n) = @_;\n    (32 * (14*$n * (38*$n + 9) + 9) * factorial(6*$n)) / (3*factorial($n)**6);\n}\n\nsub almkvist_giullera {\n    my($n) = @_;\n    almkvist_giullera_integral($n) / (10**(6*$n + 3));\n}\n\nsub almkvist_giullera_pi {\n    my ($prec) = @_;\n\n    local $Math::AnyNum::PREC = 4*($prec+1);\n\n    my $sum = 0;\n    my $target = '';\n\n    for (my $n = 0; ; ++$n) {\n        $sum += almkvist_giullera($n);\n        my $curr = ($sum**-.5)->as_dec;\n        return $target if ($curr eq $target);\n        $target = $curr;\n    }\n}\n\nsay 'First 10 integer portions: ';\nsay \"$_  \" . almkvist_giullera_integral($_) for 0..9;\n\nmy $precision = 70;\n\nprintf(\"\u03c0 to %s decimal places is:\\n%s\\n\",\n    $precision, almkvist_giullera_pi($precision));\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\nusing static System.Console;\n\nclass Program {\n\n  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\n\u00a0 static string dump(int digs, bool show = false) {\n    int gb = 1, dg = ++digs + gb, z;\n    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,\n       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;\n    for (BI n = 0; n < dg; n++) {\n      if (n > 0) t3 *= BI.Pow(n, 6);\n      te = t1 * t2 / t3;\n      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);\n      else te /= BI.Pow (10, -z);\n      if (show && n < 10)\n        WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t);\n      su += te; if (te < 10) {\n        if (show) WriteLine(\"\\n{0} iterations required for {1} digits \" +\n        \"after the decimal point.\\n\", n, --digs); break; }\n      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;\n      t2 += 126 + 532 * (d += 2);\n    }\n    string s = string.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) /\n      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));\n    return s[0] + \".\" + s.Substring(1, digs); }\n\n  static void Main(string[] args) {\n    WriteLine(dump(70, true)); }\n}\n"}
{"id": 400354, "name": "Almkvist-Giullera formula for pi", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature qw(say);\nuse Math::AnyNum qw(:overload factorial);\n\nsub almkvist_giullera_integral {\n    my($n) = @_;\n    (32 * (14*$n * (38*$n + 9) + 9) * factorial(6*$n)) / (3*factorial($n)**6);\n}\n\nsub almkvist_giullera {\n    my($n) = @_;\n    almkvist_giullera_integral($n) / (10**(6*$n + 3));\n}\n\nsub almkvist_giullera_pi {\n    my ($prec) = @_;\n\n    local $Math::AnyNum::PREC = 4*($prec+1);\n\n    my $sum = 0;\n    my $target = '';\n\n    for (my $n = 0; ; ++$n) {\n        $sum += almkvist_giullera($n);\n        my $curr = ($sum**-.5)->as_dec;\n        return $target if ($curr eq $target);\n        $target = $curr;\n    }\n}\n\nsay 'First 10 integer portions: ';\nsay \"$_  \" . almkvist_giullera_integral($_) for 0..9;\n\nmy $precision = 70;\n\nprintf(\"\u03c0 to %s decimal places is:\\n%s\\n\",\n    $precision, almkvist_giullera_pi($precision));\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\nusing static System.Console;\n\nclass Program {\n\n  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\n\u00a0 static string dump(int digs, bool show = false) {\n    int gb = 1, dg = ++digs + gb, z;\n    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,\n       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;\n    for (BI n = 0; n < dg; n++) {\n      if (n > 0) t3 *= BI.Pow(n, 6);\n      te = t1 * t2 / t3;\n      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);\n      else te /= BI.Pow (10, -z);\n      if (show && n < 10)\n        WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t);\n      su += te; if (te < 10) {\n        if (show) WriteLine(\"\\n{0} iterations required for {1} digits \" +\n        \"after the decimal point.\\n\", n, --digs); break; }\n      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;\n      t2 += 126 + 532 * (d += 2);\n    }\n    string s = string.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) /\n      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));\n    return s[0] + \".\" + s.Substring(1, digs); }\n\n  static void Main(string[] args) {\n    WriteLine(dump(70, true)); }\n}\n"}
{"id": 400355, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse POSIX qw(fmod);\nuse Perl6::GatherTake;\n\nuse constant ln2ln10 => log(2) / log(10);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub ordinal_digit {\n    my($d) = $_[0] =~ /(.)$/;\n    $d eq '1' ? 'st' : $d eq '2' ? 'nd' : $d eq '3' ? 'rd' : 'th'\n}\n\nsub startswith12 {\n    my($nth) = @_;\n    state $i = 0;\n    state $n = 0;\n    while (1) {\n      next unless '1.2' eq substr(( 10 ** fmod(++$i * ln2ln10, 1) ), 0, 3);\n      return $i if ++$n eq $nth;\n    }\n}\n\nsub startswith123 {\n    my $pre = '1.23';\n    my ($this, $count) = (0, 0);\n\n    gather {\n      while (1) {\n        if ($this == 196) {\n            $this = 289;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 485) {\n            $this = 196;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 289) {\n            $this = 196\n        } elsif ($this ==  90) {\n            $this = 289\n        } elsif ($this ==   0) {\n            $this = 90;\n        }\n        take $count += $this;\n      }\n    }\n}\n\nmy $start_123 = startswith123(); \n\nsub p {\n    my($prefix,$nth) = @_;\n    $prefix eq '12' ? startswith12($nth) : $start_123->[$nth-1];\n}\n\nfor ([12, 1], [12, 2], [123, 45], [123, 12345], [123, 678910]) {\n    my($prefix,$nth) = @$_;\n    printf \"%-15s %9s power of two (2^n) that starts with %5s is at n = %s\\n\", \"p($prefix, $nth):\",\n        comma($nth) . ordinal_digit($nth), \"'$prefix'\", comma p($prefix, $nth);\n}\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 400356, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse POSIX qw(fmod);\nuse Perl6::GatherTake;\n\nuse constant ln2ln10 => log(2) / log(10);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub ordinal_digit {\n    my($d) = $_[0] =~ /(.)$/;\n    $d eq '1' ? 'st' : $d eq '2' ? 'nd' : $d eq '3' ? 'rd' : 'th'\n}\n\nsub startswith12 {\n    my($nth) = @_;\n    state $i = 0;\n    state $n = 0;\n    while (1) {\n      next unless '1.2' eq substr(( 10 ** fmod(++$i * ln2ln10, 1) ), 0, 3);\n      return $i if ++$n eq $nth;\n    }\n}\n\nsub startswith123 {\n    my $pre = '1.23';\n    my ($this, $count) = (0, 0);\n\n    gather {\n      while (1) {\n        if ($this == 196) {\n            $this = 289;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 485) {\n            $this = 196;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 289) {\n            $this = 196\n        } elsif ($this ==  90) {\n            $this = 289\n        } elsif ($this ==   0) {\n            $this = 90;\n        }\n        take $count += $this;\n      }\n    }\n}\n\nmy $start_123 = startswith123(); \n\nsub p {\n    my($prefix,$nth) = @_;\n    $prefix eq '12' ? startswith12($nth) : $start_123->[$nth-1];\n}\n\nfor ([12, 1], [12, 2], [123, 45], [123, 12345], [123, 678910]) {\n    my($prefix,$nth) = @$_;\n    printf \"%-15s %9s power of two (2^n) that starts with %5s is at n = %s\\n\", \"p($prefix, $nth):\",\n        comma($nth) . ordinal_digit($nth), \"'$prefix'\", comma p($prefix, $nth);\n}\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 400357, "name": "Cipolla's algorithm", "source": "Translate Perl to C#: use bigint;\nuse ntheory qw(is_prime);\n\nsub Legendre {\n    my($n,$p) = @_;\n    return -1 unless $p != 2 && is_prime($p);\n    my $x = ($n->as_int())->bmodpow(int(($p-1)/2), $p); \n    if    ($x==0) { return  0 }\n    elsif ($x==1) { return  1 }\n    else          { return -1 }\n}\n\nsub Cipolla {\n    my($n, $p) = @_;\n    return undef if Legendre($n,$p) != 1;\n\n    my $w2;\n    my $a = 0;\n    $a++ until Legendre(($w2 = ($a**2 - $n) % $p), $p) < 0;\n\n    my %r = ( x=> 1,  y=> 0 );\n    my %s = ( x=> $a, y=> 1 );\n    my $i = $p + 1;\n    while (1 <= ($i >>= 1)) {\n        %r = ( x => (($r{x} * $s{x} + $r{y} * $s{y} * $w2) % $p),\n               y => (($r{x} * $s{y} + $s{x} * $r{y})       % $p)\n             ) if $i % 2;\n        %s = ( x => (($s{x} * $s{x} + $s{y} * $s{y} * $w2) % $p),\n               y => (($s{x} * $s{y} + $s{x} * $s{y})       % $p)\n             )\n    }\n    $r{y} ? undef : $r{x}\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (8218, 10007),\n    (8219, 10007),\n    (331575, 1000003),\n    (665165880, 1000000007),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n   $n = shift @tests;\n   $p = shift @tests;\n   my $r = Cipolla($n, $p);\n   $r ? printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $r, $p-$r, $p\n      : print  \"No solution for ($n, $p)\\n\"\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace CipollaAlgorithm {\n    class Program {\n        static readonly BigInteger BIG = BigInteger.Pow(10, 50) + 151;\n\n        private static Tuple<BigInteger, BigInteger, bool> C(string ns, string ps) {\n            BigInteger n = BigInteger.Parse(ns);\n            BigInteger p = ps.Length > 0 ? BigInteger.Parse(ps) : BIG;\n\n            \n            BigInteger ls(BigInteger a0) => BigInteger.ModPow(a0, (p - 1) / 2, p);\n\n            \n            if (ls(n) != 1) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            BigInteger a = 0;\n            BigInteger omega2;\n            while (true) {\n                omega2 = (a * a + p - n) % p;\n                if (ls(omega2) == p - 1) {\n                    break;\n                }\n                a += 1;\n            }\n\n            \n            BigInteger finalOmega = omega2;\n            Tuple<BigInteger, BigInteger> mul(Tuple<BigInteger, BigInteger> aa, Tuple<BigInteger, BigInteger> bb) {\n                return new Tuple<BigInteger, BigInteger>(\n                    (aa.Item1 * bb.Item1 + aa.Item2 * bb.Item2 * finalOmega) % p,\n                    (aa.Item1 * bb.Item2 + bb.Item1 * aa.Item2) % p\n                );\n            }\n\n            \n            Tuple<BigInteger, BigInteger> r = new Tuple<BigInteger, BigInteger>(1, 0);\n            Tuple<BigInteger, BigInteger> s = new Tuple<BigInteger, BigInteger>(a, 1);\n            BigInteger nn = ((p + 1) >> 1) % p;\n            while (nn > 0) {\n                if ((nn & 1) == 1) {\n                    r = mul(r, s);\n                }\n                s = mul(s, s);\n                nn >>= 1;\n            }\n\n            \n            if (r.Item2 != 0) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            if (r.Item1 * r.Item1 % p != n) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            return new Tuple<BigInteger, BigInteger, bool>(r.Item1, p - r.Item1, true);\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(C(\"10\", \"13\"));\n            Console.WriteLine(C(\"56\", \"101\"));\n            Console.WriteLine(C(\"8218\", \"10007\"));\n            Console.WriteLine(C(\"8219\", \"10007\"));\n            Console.WriteLine(C(\"331575\", \"1000003\"));\n            Console.WriteLine(C(\"665165880\", \"1000000007\"));\n            Console.WriteLine(C(\"881398088036\", \"1000000000039\"));\n            Console.WriteLine(C(\"34035243914635549601583369544560650254325084643201\", \"\"));\n        }\n    }\n}\n"}
{"id": 400358, "name": "Cipolla's algorithm", "source": "Translate Perl to C#: use bigint;\nuse ntheory qw(is_prime);\n\nsub Legendre {\n    my($n,$p) = @_;\n    return -1 unless $p != 2 && is_prime($p);\n    my $x = ($n->as_int())->bmodpow(int(($p-1)/2), $p); \n    if    ($x==0) { return  0 }\n    elsif ($x==1) { return  1 }\n    else          { return -1 }\n}\n\nsub Cipolla {\n    my($n, $p) = @_;\n    return undef if Legendre($n,$p) != 1;\n\n    my $w2;\n    my $a = 0;\n    $a++ until Legendre(($w2 = ($a**2 - $n) % $p), $p) < 0;\n\n    my %r = ( x=> 1,  y=> 0 );\n    my %s = ( x=> $a, y=> 1 );\n    my $i = $p + 1;\n    while (1 <= ($i >>= 1)) {\n        %r = ( x => (($r{x} * $s{x} + $r{y} * $s{y} * $w2) % $p),\n               y => (($r{x} * $s{y} + $s{x} * $r{y})       % $p)\n             ) if $i % 2;\n        %s = ( x => (($s{x} * $s{x} + $s{y} * $s{y} * $w2) % $p),\n               y => (($s{x} * $s{y} + $s{x} * $s{y})       % $p)\n             )\n    }\n    $r{y} ? undef : $r{x}\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (8218, 10007),\n    (8219, 10007),\n    (331575, 1000003),\n    (665165880, 1000000007),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n   $n = shift @tests;\n   $p = shift @tests;\n   my $r = Cipolla($n, $p);\n   $r ? printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $r, $p-$r, $p\n      : print  \"No solution for ($n, $p)\\n\"\n}\n", "target": "using System;\nusing System.Numerics;\n\nnamespace CipollaAlgorithm {\n    class Program {\n        static readonly BigInteger BIG = BigInteger.Pow(10, 50) + 151;\n\n        private static Tuple<BigInteger, BigInteger, bool> C(string ns, string ps) {\n            BigInteger n = BigInteger.Parse(ns);\n            BigInteger p = ps.Length > 0 ? BigInteger.Parse(ps) : BIG;\n\n            \n            BigInteger ls(BigInteger a0) => BigInteger.ModPow(a0, (p - 1) / 2, p);\n\n            \n            if (ls(n) != 1) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            BigInteger a = 0;\n            BigInteger omega2;\n            while (true) {\n                omega2 = (a * a + p - n) % p;\n                if (ls(omega2) == p - 1) {\n                    break;\n                }\n                a += 1;\n            }\n\n            \n            BigInteger finalOmega = omega2;\n            Tuple<BigInteger, BigInteger> mul(Tuple<BigInteger, BigInteger> aa, Tuple<BigInteger, BigInteger> bb) {\n                return new Tuple<BigInteger, BigInteger>(\n                    (aa.Item1 * bb.Item1 + aa.Item2 * bb.Item2 * finalOmega) % p,\n                    (aa.Item1 * bb.Item2 + bb.Item1 * aa.Item2) % p\n                );\n            }\n\n            \n            Tuple<BigInteger, BigInteger> r = new Tuple<BigInteger, BigInteger>(1, 0);\n            Tuple<BigInteger, BigInteger> s = new Tuple<BigInteger, BigInteger>(a, 1);\n            BigInteger nn = ((p + 1) >> 1) % p;\n            while (nn > 0) {\n                if ((nn & 1) == 1) {\n                    r = mul(r, s);\n                }\n                s = mul(s, s);\n                nn >>= 1;\n            }\n\n            \n            if (r.Item2 != 0) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            if (r.Item1 * r.Item1 % p != n) {\n                return new Tuple<BigInteger, BigInteger, bool>(0, 0, false);\n            }\n\n            \n            return new Tuple<BigInteger, BigInteger, bool>(r.Item1, p - r.Item1, true);\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(C(\"10\", \"13\"));\n            Console.WriteLine(C(\"56\", \"101\"));\n            Console.WriteLine(C(\"8218\", \"10007\"));\n            Console.WriteLine(C(\"8219\", \"10007\"));\n            Console.WriteLine(C(\"331575\", \"1000003\"));\n            Console.WriteLine(C(\"665165880\", \"1000000007\"));\n            Console.WriteLine(C(\"881398088036\", \"1000000000039\"));\n            Console.WriteLine(C(\"34035243914635549601583369544560650254325084643201\", \"\"));\n        }\n    }\n}\n"}
{"id": 400359, "name": "Pierpont primes", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint try=>\"GMP\";\nuse ntheory qw<is_prime>;\n\n\nsub min_index { my $b = $_[my $i = 0]; $_[$_] < $b && ($b = $_[$i = $_]) for 0..$\n\nsub iter1 { my $m = shift; my $e = 0; return sub { $m ** $e++;    } }\nsub iter2 { my $m = shift; my $e = 1; return sub { $m * ($e *= 2) } }\n\nsub pierpont {\n    my($max ) = shift || die 'Must specify count of primes to generate.';\n    my($kind) = @_ ? shift : 1;\n    die \"Unknown type: $kind. Must be one of 1 (default) or 2\" unless $kind == 1 || $kind == 2;\n    $kind = -1 if $kind == 2;\n\n    my $po3     = 3;\n    my $add_one = 3;\n    my @iterators;\n    push @iterators, iter1(2);\n    push @iterators, iter1(3); $iterators[1]->();\n    my @head = ($iterators[0]->(), $iterators[1]->());\n\n    my @pierpont;\n    do {\n        my $key = min_index(@head);\n        my $min = $head[$key];\n        push @pierpont, $min + $kind if is_prime($min + $kind);\n\n        $head[$key] = $iterators[$key]->();\n\n        if ($min >= $add_one) {\n            push @iterators, iter2($po3);\n            $add_one = $head[$\n            $po3 *= 3;\n        }\n    } until @pierpont == $max;\n    @pierpont;\n}\n\nmy @pierpont_1st = pierpont(250,1);\nmy @pierpont_2nd = pierpont(250,2);\n\nsay \"First 50 Pierpont primes of the first kind:\";\nmy $fmt = \"%9d\"x10 . \"\\n\";\nfor my $row (0..4) { printf $fmt, map { $pierpont_1st[10*$row + $_] } 0..9 }\nsay \"\\nFirst 50 Pierpont primes of the second kind:\";\nfor my $row (0..4) { printf $fmt, map { $pierpont_2nd[10*$row + $_] } 0..9 }\n\nsay \"\\n250th Pierpont prime of the first kind:    \" . $pierpont_1st[249];\nsay \"\\n250th Pierpont prime of the second kind: \"   . $pierpont_2nd[249];\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace PierpontPrimes {\n    public static class Helper {\n        private static readonly Random rand = new Random();\n        private static readonly List<int> primeList = new List<int>() {\n              2,   3,   5,   7,  11,  13,  17,  19,  23,  29,  31,  37,  41,  43, 47,\n             53,  59,  61,  67,  71,  73,  79,  83,  89,  97, 101, 103, 107, 109, 113,\n            127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197,\n            199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281,\n            283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,\n            383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463,\n            467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571,\n            577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659,\n            661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761,\n            769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863,\n            877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977,\n        };\n\n        public static BigInteger GetRandom(BigInteger min, BigInteger max) {\n            var bytes = max.ToByteArray();\n            BigInteger r;\n\n            do {\n                rand.NextBytes(bytes);\n                bytes[bytes.Length - 1] &= (byte)0x7F; \n                r = new BigInteger(bytes);\n            } while (r < min || r >= max);\n\n            return r;\n        }\n\n        \n        public static bool IsProbablePrime(this BigInteger n) {\n            if (n == 0 || n == 1) {\n                return false;\n            }\n\n            bool Check(BigInteger num) {\n                foreach (var prime in primeList) {\n                    if (num == prime) {\n                        return true;\n                    }\n                    if (num % prime == 0) {\n                        return false;\n                    }\n                    if (prime * prime > num) {\n                        return true;\n                    }\n                }\n\n                return true;\n            }\n\n            if (Check(n)) {\n                var large = primeList[primeList.Count - 1];\n                if (n <= large) {\n                    return true;\n                }\n            }\n\n            var s = 0;\n            var d = n - 1;\n            while (d.IsEven) {\n                d >>= 1;\n                s++;\n            }\n\n            bool TrialComposite(BigInteger a) {\n                if (BigInteger.ModPow(a, d, n) == 1) {\n                    return false;\n                }\n                for (int i = 0; i < s; i++) {\n                    var t = BigInteger.Pow(2, i);\n                    if (BigInteger.ModPow(a, t * d, n) == n - 1) {\n                        return false;\n                    }\n                }\n                return true;\n            }\n\n            for (int i = 0; i < 8; i++) {\n                var a = GetRandom(2, n);\n                if (TrialComposite(a)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n\n    class Program {\n        static List<List<BigInteger>> Pierpont(int n) {\n            var p = new List<List<BigInteger>> {\n                new List<BigInteger>(),\n                new List<BigInteger>()\n            };\n            for (int i = 0; i < n; i++) {\n                p[0].Add(0);\n                p[1].Add(0);\n            }\n            p[0][0] = 2;\n\n            var count = 0;\n            var count1 = 1;\n            var count2 = 0;\n            List<BigInteger> s = new List<BigInteger> { 1 };\n            var i2 = 0;\n            var i3 = 0;\n            var k = 1;\n            BigInteger n2;\n            BigInteger n3;\n            BigInteger t;\n\n            while (count < n) {\n                n2 = s[i2] * 2;\n                n3 = s[i3] * 3;\n                if (n2 < n3) {\n                    t = n2;\n                    i2++;\n                } else {\n                    t = n3;\n                    i3++;\n                }\n                if (t > s[k - 1]) {\n                    s.Add(t);\n                    k++;\n                    t += 1;\n                    if (count1 < n && t.IsProbablePrime()) {\n                        p[0][count1] = t;\n                        count1++;\n                    }\n                    t -= 2;\n                    if (count2 < n && t.IsProbablePrime()) {\n                        p[1][count2] = t;\n                        count2++;\n                    }\n                    count = Math.Min(count1, count2);\n                }\n            }\n\n            return p;\n        }\n\n        static void Main() {\n            var p = Pierpont(250);\n\n            Console.WriteLine(\"First 50 Pierpont primes of the first kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[0][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"First 50 Pierpont primes of the second kind:\");\n            for (int i = 0; i < 50; i++) {\n                Console.Write(\"{0,8} \", p[1][i]);\n                if ((i - 9) % 10 == 0) {\n                    Console.WriteLine();\n                }\n            }\n            Console.WriteLine();\n\n            Console.WriteLine(\"250th Pierpont prime of the first kind: {0}\", p[0][249]);\n            Console.WriteLine(\"250th Pierpont prime of the second kind: {0}\", p[1][249]);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400360, "name": "N-smooth numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw<primes>;\nuse List::Util qw<min>;\n\n\nuse Math::GMPz; \n\nsub smooth_numbers {\n\n    my @m = map { Math::GMPz->new($_) } @_;     \n    my @s;\n    push @s, [1] for 0..$\n\n    return sub {\n    my $n = $s[0][0];\n    $n = min $n, $s[$_][0] for 1..$\n    for (0..$\n            shift @{$s[$_]} if $s[$_][0] == $n;\n            push @{$s[$_]}, $n * $m[$_]\n        }\n        return $n\n    }\n}\n\nsub abbrev {\n    my($n) = @_;\n    return $n if length($n) <= 50;\n    substr($n,0,10) . \"...(@{[length($n) - 2*10]} digits omitted)...\" . substr($n, -10, 10)\n}\n\nmy @primes = @{primes(10_000)};\n\nmy $start = 3000; my $cnt = 3;\nfor my $n_smooth (0..9) {\n    say \"\\nFirst 25, and ${start}th through @{[$start+2]}nd $primes[$n_smooth]-smooth numbers:\";\n    my $s = smooth_numbers(@primes[0..$n_smooth]);\n    my @S25;\n    push @S25, $s->() for 1..25;\n    say join ' ', @S25;\n\n    my @Sm; my $c = 25;\n    do {\n        my $sn = $s->();\n        push @Sm, abbrev($sn) if ++$c >= $start;\n    } until @Sm == $cnt;\n    say join ' ', @Sm;\n}\n\n$start = 30000; $cnt = 20;\nfor my $n_smooth (95..97) { \n    say \"\\n${start}th through @{[$start+$cnt-1]}th $primes[$n_smooth]-smooth numbers:\";\n    my $s = smooth_numbers(@primes[0..$n_smooth]);\n    my(@Sm,$c);\n    do {\n        my $sn = $s->();\n        push @Sm, $sn if ++$c >= $start;\n    } until @Sm == $cnt;\n    say join ' ', @Sm;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NSmooth {\n    class Program {\n        static readonly List<BigInteger> primes = new List<BigInteger>();\n        static readonly List<int> smallPrimes = new List<int>();\n\n        static Program() {\n            primes.Add(2);\n            smallPrimes.Add(2);\n\n            BigInteger i = 3;\n            while (i <= 521) {\n                if (IsPrime(i)) {\n                    primes.Add(i);\n                    if (i <= 29) {\n                        smallPrimes.Add((int)i);\n                    }\n                }\n                i += 2;\n            }\n        }\n\n        static bool IsPrime(BigInteger value) {\n            if (value < 2) return false;\n\n            if (value % 2 == 0) return value == 2;\n            if (value % 3 == 0) return value == 3;\n\n            if (value % 5 == 0) return value == 5;\n            if (value % 7 == 0) return value == 7;\n\n            if (value % 11 == 0) return value == 11;\n            if (value % 13 == 0) return value == 13;\n\n            if (value % 17 == 0) return value == 17;\n            if (value % 19 == 0) return value == 19;\n\n            if (value % 23 == 0) return value == 23;\n\n            BigInteger t = 29;\n            while (t * t < value) {\n                if (value % t == 0) return false;\n                value += 2;\n\n                if (value % t == 0) return false;\n                value += 4;\n            }\n\n            return true;\n        }\n\n        static List<BigInteger> NSmooth(int n, int size) {\n            if (n < 2 || n > 521) {\n                throw new ArgumentOutOfRangeException(\"n\");\n            }\n            if (size < 1) {\n                throw new ArgumentOutOfRangeException(\"size\");\n            }\n\n            BigInteger bn = n;\n            bool ok = false;\n            foreach (var prime in primes) {\n                if (bn == prime) {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                throw new ArgumentException(\"must be a prime number\", \"n\");\n            }\n\n            BigInteger[] ns = new BigInteger[size];\n            ns[0] = 1;\n            for (int i = 1; i < size; i++) {\n                ns[i] = 0;\n            }\n\n            List<BigInteger> next = new List<BigInteger>();\n            foreach (var prime in primes) {\n                if (prime > bn) {\n                    break;\n                }\n                next.Add(prime);\n            }\n\n            int[] indices = new int[next.Count];\n            for (int i = 0; i < indices.Length; i++) {\n                indices[i] = 0;\n            }\n            for (int m = 1; m < size; m++) {\n                ns[m] = next.Min();\n                for (int i = 0; i < indices.Length; i++) {\n                    if (ns[m] == next[i]) {\n                        indices[i]++;\n                        next[i] = primes[i] * ns[indices[i]];\n                    }\n                }\n            }\n\n            return ns.ToList();\n        }\n\n        static void Println<T>(IEnumerable<T> nums) {\n            Console.Write('[');\n\n            var it = nums.GetEnumerator();\n            if (it.MoveNext()) {\n                Console.Write(it.Current);\n            }\n            while (it.MoveNext()) {\n                Console.Write(\", \");\n                Console.Write(it.Current);\n            }\n\n            Console.WriteLine(']');\n        }\n\n        static void Main() {\n            foreach (var i in smallPrimes) {\n                Console.WriteLine(\"The first {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 25));\n                Console.WriteLine();\n            }\n            foreach (var i in smallPrimes.Skip(1)) {\n                Console.WriteLine(\"The 3,000 to 3,202 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 3_002).Skip(2_999));\n                Console.WriteLine();\n            }\n            foreach (var i in new int[] { 503, 509, 521 }) {\n                Console.WriteLine(\"The 30,000 to 3,019 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 30_019).Skip(29_999));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 400361, "name": "Partition an integer x into n primes", "source": "Translate Perl to C#: use ntheory \":all\";\n\nsub prime_partition {\n  my($num, $parts) = @_;\n  return is_prime($num) ? [$num] : undef if $parts == 1;\n  my @p = @{primes($num)};\n  my $r;\n  forcomb { lastfor, $r = [@p[@_]] if vecsum(@p[@_]) == $num; } @p, $parts;\n  $r;\n}\n\nforeach my $test ([18,2], [19,3], [20,4], [99807,1], [99809,1], [2017,24], [22699,1], [22699,2], [22699,3], [22699,4], [40355,3]) {\n  my $partar = prime_partition(@$test);\n  printf \"Partition %5d into %2d prime piece%s %s\\n\", $test->[0], $test->[1], ($test->[1] == 1) ? \": \" : \"s:\", defined($partar) ? join(\"+\",@$partar) : \"not possible\";\n}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class Rosetta\n{\n    static void Main()\n    {\n        foreach ((int x, int n) in new [] {\n            (99809, 1),\n            (18, 2),\n            (19, 3),\n            (20, 4),\n            (2017, 24),\n            (22699, 1),\n            (22699, 2),\n            (22699, 3),\n            (22699, 4),\n            (40355, 3)\n        }) {\n            Console.WriteLine(Partition(x, n));\n        }\n    }\n\n    public static string Partition(int x, int n) {\n        if (x < 1 || n < 1) throw new ArgumentOutOfRangeException(\"Parameters must be positive.\");\n        string header = $\"{x} with {n} {(n == 1\u00a0? \"prime\"\u00a0: \"primes\")}: \";\n        int[] primes = SievePrimes(x).ToArray();\n        if (primes.Length < n) return header + \"not enough primes\";\n        int[] solution = CombinationsOf(n, primes).FirstOrDefault(c => c.Sum() == x);\n        return header + (solution == null ? \"not possible\" : string.Join(\"+\", solution);\n    }\n\n    static IEnumerable<int> SievePrimes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n    static IEnumerable<int[]> CombinationsOf(int count, int[] input) {\n        T[] result = new T[count];\n        foreach (int[] indices in Combinations(input.Length, count)) {\n            for (int i = 0; i < count; i++) result[i] = input[indices[i]];\n            yield return result;\n        }\n    }\n\n    static IEnumerable<int[]> Combinations(int n, int k) {\n        var result = new int[k];\n        var stack = new Stack<int>();\n        stack.Push(0);\n        while (stack.Count > 0) {\n            int index = stack.Count - 1;\n            int value = stack.Pop();\n            while (value < n) {\n                result[index++] = value++;\n                stack.Push(value);\n                if (index == k) {\n                    yield return result;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 400362, "name": "Zeckendorf arithmetic", "source": "Translate Perl to C#: use v5.36;\n\npackage Zeckendorf;\nuse overload qw(\"\" zstring + zadd - zsub ++ zinc -- zdec * zmul / zdiv ge zge);\n\nsub new ($class, $value) {\n    bless \\$value, ref $class || $class;\n}\n\nsub zinc ($self, $, $) {\n    local $_ = $$self;\n    s/0$/1/ or s/(?:^|0)1$/10/;\n    1 while s/(?:^|0)11/100/;\n    $$self = $self->new( s/^0+\\B//r )\n}\n\nsub zdec ($self, $, $) {\n    local $_ = $$self;\n    1 while s/100(?=0*$)/011/;\n    s/1$/0/ || s/10$/01/;\n    $$self = $self->new( s/^0+\\B//r )\n}\n\nsub zadd ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    $x++, $y-- while $$y;\n    $x\n}\n\nsub zsub ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    $x--, $y-- while $$y;\n    $x\n}\n\nsub zmul ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    my $product = Zeckendorf->new(0);\n    $product = $product + $x, $y-- while $y;\n    $product\n}\n\nsub zdiv ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    my $quotient = Zeckendorf->new(0);\n    $quotient++, $x = $x - $y while $x ge $y;\n    $quotient\n}\n\nsub zge ($self, $other, $) {\n    my $l; $l = length $$other if length $other > ($l = length $$self);\n    0 x ($l - length $$self) . $$self ge 0 x ($l - length $$other) . $$other;\n}\n\nsub asdecimal ($self) {\n    my($aa, $bb, $n) = (1, 1, 0);\n    for ( reverse split '', $$self ) {\n        $n += $bb * $_;\n        ($aa, $bb) = ($bb, $aa + $bb);\n    }\n    $n\n}\n\nsub fromdecimal ($self, $value) {\n    my $z = $self->new(0);\n    $z++ for 1 .. $value;\n    $z\n}\n\nsub zstring { ${ shift() } }\n\npackage main;\n\nfor ( split /\\n/, <<END ) \n  1 + 1\n  10 + 10\n  10100 + 1010\n  10100 - 1010\n  10100 * 1010\n  100010 * 100101\n  10100 / 1010\n  101000 / 1000\n  100001000001 / 100010\n  100001000001 / 100101\nEND\n  {\n  my ($left, $op, $right) = split;\n  my ($x, $y) = map Zeckendorf->new($_), $left, $right;\n  my $answer =\n    $op eq '+' ? $x + $y :\n    $op eq '-' ? $x - $y :\n    $op eq '*' ? $x * $y :\n    $op eq '/' ? $x / $y :\n    die \"bad op <$op>\";\n    printf \"%12s %s\u00a0%-9s => %12s  in Zeckendorf\\n\", $x, $op, $y, $answer;\n    printf \"%12d %s\u00a0%-9d => %12d  in decimal\\n\\n\",\n    $x->asdecimal, $op, $y->asdecimal, $answer->asdecimal;\n  }\n", "target": "using System;\nusing System.Text;\n\nnamespace ZeckendorfArithmetic {\n    class Zeckendorf : IComparable<Zeckendorf> {\n        private static readonly string[] dig = { \"00\", \"01\", \"10\" };\n        private static readonly string[] dig1 = { \"\", \"1\", \"10\" };\n\n        private int dVal = 0;\n        private int dLen = 0;\n\n        public Zeckendorf() : this(\"0\") {\n            \n        }\n\n        public Zeckendorf(string x) {\n            int q = 1;\n            int i = x.Length - 1;\n            dLen = i / 2;\n            while (i >= 0) {\n                dVal += (x[i] - '0') * q;\n                q *= 2;\n                i--;\n            }\n        }\n\n        private void A(int n) {\n            int i = n;\n            while (true) {\n                if (dLen < i) dLen = i;\n                int j = (dVal >> (i * 2)) & 3;\n                switch (j) {\n                    case 0:\n                    case 1:\n                        return;\n                    case 2:\n                        if (((dVal >> ((i + 1) * 2)) & 1) != 1) return;\n                        dVal += 1 << (i * 2 + 1);\n                        return;\n                    case 3:\n                        int temp = 3 << (i * 2);\n                        temp ^= -1;\n                        dVal = dVal & temp;\n                        B((i + 1) * 2);\n                        break;\n                }\n                i++;\n            }\n        }\n\n        private void B(int pos) {\n            if (pos == 0) {\n                Inc();\n                return;\n            }\n            if (((dVal >> pos) & 1) == 0) {\n                dVal += 1 << pos;\n                A(pos / 2);\n                if (pos > 1) A(pos / 2 - 1);\n            }\n            else {\n                int temp = 1 << pos;\n                temp ^= -1;\n                dVal = dVal & temp;\n                B(pos + 1);\n                B(pos - (pos > 1 ? 2 : 1));\n            }\n        }\n\n        private void C(int pos) {\n            if (((dVal >> pos) & 1) == 1) {\n                int temp = 1 << pos;\n                temp ^= -1;\n                dVal = dVal & temp;\n                return;\n            }\n            C(pos + 1);\n            if (pos > 0) {\n                B(pos - 1);\n            }\n            else {\n                Inc();\n            }\n        }\n\n        public Zeckendorf Inc() {\n            dVal++;\n            A(0);\n            return this;\n        }\n\n        public Zeckendorf Copy() {\n            Zeckendorf z = new Zeckendorf {\n                dVal = dVal,\n                dLen = dLen\n            };\n            return z;\n        }\n\n        public void PlusAssign(Zeckendorf other) {\n            for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n                if (((other.dVal >> gn) & 1) == 1) {\n                    B(gn);\n                }\n            }\n        }\n\n        public void MinusAssign(Zeckendorf other) {\n            for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n                if (((other.dVal >> gn) & 1) == 1) {\n                    C(gn);\n                }\n            }\n            while ((((dVal >> dLen * 2) & 3) == 0) || (dLen == 0)) {\n                dLen--;\n            }\n        }\n\n        public void TimesAssign(Zeckendorf other) {\n            Zeckendorf na = other.Copy();\n            Zeckendorf nb = other.Copy();\n            Zeckendorf nt;\n            Zeckendorf nr = new Zeckendorf();\n            for (int i = 0; i < (dLen + 1) * 2; i++) {\n                if (((dVal >> i) & 1) > 0) {\n                    nr.PlusAssign(nb);\n                }\n                nt = nb.Copy();\n                nb.PlusAssign(na);\n                na = nt.Copy();\n            }\n            dVal = nr.dVal;\n            dLen = nr.dLen;\n        }\n\n        public int CompareTo(Zeckendorf other) {\n            return dVal.CompareTo(other.dVal);\n        }\n\n        public override string ToString() {\n            if (dVal == 0) {\n                return \"0\";\n            }\n\n            int idx = (dVal >> (dLen * 2)) & 3;\n            StringBuilder sb = new StringBuilder(dig1[idx]);\n            for (int i = dLen - 1; i >= 0; i--) {\n                idx = (dVal >> (i * 2)) & 3;\n                sb.Append(dig[idx]);\n            }\n            return sb.ToString();\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Addition:\");\n            Zeckendorf g = new Zeckendorf(\"10\");\n            g.PlusAssign(new Zeckendorf(\"10\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"10\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"1001\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"1000\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"10101\"));\n            Console.WriteLine(g);\n            Console.WriteLine();\n\n            Console.WriteLine(\"Subtraction:\");\n            g = new Zeckendorf(\"1000\");\n            g.MinusAssign(new Zeckendorf(\"101\"));\n            Console.WriteLine(g);\n            g = new Zeckendorf(\"10101010\");\n            g.MinusAssign(new Zeckendorf(\"1010101\"));\n            Console.WriteLine(g);\n            Console.WriteLine();\n\n            Console.WriteLine(\"Multiplication:\");\n            g = new Zeckendorf(\"1001\");\n            g.TimesAssign(new Zeckendorf(\"101\"));\n            Console.WriteLine(g);\n            g = new Zeckendorf(\"101010\");\n            g.PlusAssign(new Zeckendorf(\"101\"));\n            Console.WriteLine(g);\n        }\n    }\n}\n"}
{"id": 400363, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse List::MoreUtils qw(firstidx minmax);\n\nmy $epsilon = 1;\n\nsub norm {\n    my(@list) = @_;\n    my $sum;\n    $sum += $_**2 for @list;\n    sqrt($sum)\n}\n\nsub perpendicular_distance {\n    our(@start,@end,@point);\n    local(*start,*end,*point) = (shift, shift, shift);\n    return 0 if $start[0]==$point[0] && $start[1]==$point[1]\n             or   $end[0]==$point[0] &&   $end[1]==$point[1];\n    my ( $dx,  $dy)  = (  $end[0]-$start[0],  $end[1]-$start[1]);\n    my ($dpx, $dpy)  = ($point[0]-$start[0],$point[1]-$start[1]);\n    my $t = norm($dx, $dy);\n    $dx /= $t;\n    $dy /= $t;\n    norm($dpx - $dx*($dx*$dpx + $dy*$dpy), $dpy - $dy*($dx*$dpx + $dy*$dpy));\n}\n\nsub Ramer_Douglas_Peucker {\n    my(@points) = @_;\n    return @points if @points == 2;\n    my @d;\n    push @d, perpendicular_distance(@points[0, -1, $_]) for 0..@points-1;\n    my(undef,$dmax) = minmax @d;\n    my $index = firstidx { $_ == $dmax } @d;\n    if ($dmax > $epsilon) {\n        my @lo = Ramer_Douglas_Peucker( @points[0..$index]);\n        my @hi = Ramer_Douglas_Peucker( @points[$index..$\n        return  @lo[0..@lo-2], @hi;\n    }\n    @points[0, -1];\n}\n\nsay '(' . join(' ', @$_) . ') '\n    for Ramer_Douglas_Peucker( [0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9] )\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LineSimplification {\n    using Point = Tuple<double, double>;\n\n    class Program {\n        static double PerpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n            double dx = lineEnd.Item1 - lineStart.Item1;\n            double dy = lineEnd.Item2 - lineStart.Item2;\n\n            \n            double mag = Math.Sqrt(dx * dx + dy * dy);\n            if (mag > 0.0) {\n                dx /= mag;\n                dy /= mag;\n            }\n            double pvx = pt.Item1 - lineStart.Item1;\n            double pvy = pt.Item2 - lineStart.Item2;\n\n            \n            double pvdot = dx * pvx + dy * pvy;\n\n            \n            double ax = pvx - pvdot * dx;\n            double ay = pvy - pvdot * dy;\n\n            return Math.Sqrt(ax * ax + ay * ay);\n        }\n\n        static void RamerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> output) {\n            if (pointList.Count < 2) {\n                throw new ArgumentOutOfRangeException(\"Not enough points to simplify\");\n            }\n\n            \n            double dmax = 0.0;\n            int index = 0;\n            int end = pointList.Count - 1;\n            for (int i = 1; i < end; ++i) {\n                double d = PerpendicularDistance(pointList[i], pointList[0], pointList[end]);\n                if (d > dmax) {\n                    index = i;\n                    dmax = d;\n                }\n            }\n\n            \n            if (dmax > epsilon) {\n                List<Point> recResults1 = new List<Point>();\n                List<Point> recResults2 = new List<Point>();\n                List<Point> firstLine = pointList.Take(index + 1).ToList();\n                List<Point> lastLine = pointList.Skip(index).ToList();\n                RamerDouglasPeucker(firstLine, epsilon, recResults1);\n                RamerDouglasPeucker(lastLine, epsilon, recResults2);\n\n                \n                output.AddRange(recResults1.Take(recResults1.Count - 1));\n                output.AddRange(recResults2);\n                if (output.Count < 2) throw new Exception(\"Problem assembling output\");\n            }\n            else {\n                \n                output.Clear();\n                output.Add(pointList[0]);\n                output.Add(pointList[pointList.Count - 1]);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Point> pointList = new List<Point>() {\n                new Point(0.0,0.0),\n                new Point(1.0,0.1),\n                new Point(2.0,-0.1),\n                new Point(3.0,5.0),\n                new Point(4.0,6.0),\n                new Point(5.0,7.0),\n                new Point(6.0,8.1),\n                new Point(7.0,9.0),\n                new Point(8.0,9.0),\n                new Point(9.0,9.0),\n            };\n            List<Point> pointListOut = new List<Point>();\n            RamerDouglasPeucker(pointList, 1.0, pointListOut);\n            Console.WriteLine(\"Points remaining after simplification:\");\n            pointListOut.ForEach(p => Console.WriteLine(p));\n        }\n    }\n}\n"}
{"id": 400364, "name": "Bilinear interpolation", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse GD;\n\nmy $image = GD::Image->newFromPng('color_wheel.png');\n$image->interpolationMethod( ['GD_BILINEAR_FIXED'] );\nmy($width,$height) = $image->getBounds();\nmy $image2 = $image->copyScaleInterpolated( 1.6*$width, 1.6*$height );\n\n$image2->_file('color_wheel_interpolated.png');\n", "target": "using System;\nusing System.Drawing;\n\nnamespace BilinearInterpolation {\n    class Program {\n        private static float Lerp(float s, float e, float t) {\n            return s + (e - s) * t;\n        }\n\n        private static float Blerp(float c00, float c10, float c01, float c11, float tx, float ty) {\n            return Lerp(Lerp(c00, c10, tx), Lerp(c01, c11, tx), ty);\n        }\n\n        private static Image Scale(Bitmap self, float scaleX, float scaleY) {\n            int newWidth = (int)(self.Width * scaleX);\n            int newHeight = (int)(self.Height * scaleY);\n            Bitmap newImage = new Bitmap(newWidth, newHeight, self.PixelFormat);\n\n            for (int x = 0; x < newWidth; x++) {\n                for (int y = 0; y < newHeight; y++) {\n                    float gx = ((float)x) / newWidth * (self.Width - 1);\n                    float gy = ((float)y) / newHeight * (self.Height - 1);\n                    int gxi = (int)gx;\n                    int gyi = (int)gy;\n                    Color c00 = self.GetPixel(gxi, gyi);\n                    Color c10 = self.GetPixel(gxi + 1, gyi);\n                    Color c01 = self.GetPixel(gxi, gyi + 1);\n                    Color c11 = self.GetPixel(gxi + 1, gyi + 1);\n\n                    int red = (int)Blerp(c00.R, c10.R, c01.R, c11.R, gx - gxi, gy - gyi);\n                    int green = (int)Blerp(c00.G, c10.G, c01.G, c11.G, gx - gxi, gy - gyi);\n                    int blue = (int)Blerp(c00.B, c10.B, c01.B, c11.B, gx - gxi, gy - gyi);\n                    Color rgb = Color.FromArgb(red, green, blue);\n                    newImage.SetPixel(x, y, rgb);\n                }\n            }\n\n            return newImage;\n        }\n\n        static void Main(string[] args) {\n            Image newImage = Image.FromFile(\"Lenna100.jpg\");\n            if (newImage is Bitmap oi) {\n                Image result = Scale(oi, 1.6f, 1.6f);\n                result.Save(\"Lenna100_larger.jpg\");\n            } else {\n                Console.WriteLine(\"Could not open the source file.\");\n            }\n        }\n    }\n}\n"}
{"id": 400365, "name": "Bilinear interpolation", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse GD;\n\nmy $image = GD::Image->newFromPng('color_wheel.png');\n$image->interpolationMethod( ['GD_BILINEAR_FIXED'] );\nmy($width,$height) = $image->getBounds();\nmy $image2 = $image->copyScaleInterpolated( 1.6*$width, 1.6*$height );\n\n$image2->_file('color_wheel_interpolated.png');\n", "target": "using System;\nusing System.Drawing;\n\nnamespace BilinearInterpolation {\n    class Program {\n        private static float Lerp(float s, float e, float t) {\n            return s + (e - s) * t;\n        }\n\n        private static float Blerp(float c00, float c10, float c01, float c11, float tx, float ty) {\n            return Lerp(Lerp(c00, c10, tx), Lerp(c01, c11, tx), ty);\n        }\n\n        private static Image Scale(Bitmap self, float scaleX, float scaleY) {\n            int newWidth = (int)(self.Width * scaleX);\n            int newHeight = (int)(self.Height * scaleY);\n            Bitmap newImage = new Bitmap(newWidth, newHeight, self.PixelFormat);\n\n            for (int x = 0; x < newWidth; x++) {\n                for (int y = 0; y < newHeight; y++) {\n                    float gx = ((float)x) / newWidth * (self.Width - 1);\n                    float gy = ((float)y) / newHeight * (self.Height - 1);\n                    int gxi = (int)gx;\n                    int gyi = (int)gy;\n                    Color c00 = self.GetPixel(gxi, gyi);\n                    Color c10 = self.GetPixel(gxi + 1, gyi);\n                    Color c01 = self.GetPixel(gxi, gyi + 1);\n                    Color c11 = self.GetPixel(gxi + 1, gyi + 1);\n\n                    int red = (int)Blerp(c00.R, c10.R, c01.R, c11.R, gx - gxi, gy - gyi);\n                    int green = (int)Blerp(c00.G, c10.G, c01.G, c11.G, gx - gxi, gy - gyi);\n                    int blue = (int)Blerp(c00.B, c10.B, c01.B, c11.B, gx - gxi, gy - gyi);\n                    Color rgb = Color.FromArgb(red, green, blue);\n                    newImage.SetPixel(x, y, rgb);\n                }\n            }\n\n            return newImage;\n        }\n\n        static void Main(string[] args) {\n            Image newImage = Image.FromFile(\"Lenna100.jpg\");\n            if (newImage is Bitmap oi) {\n                Image result = Scale(oi, 1.6f, 1.6f);\n                result.Save(\"Lenna100_larger.jpg\");\n            } else {\n                Console.WriteLine(\"Could not open the source file.\");\n            }\n        }\n    }\n}\n"}
{"id": 400366, "name": "Vector", "source": "Translate Perl to C#: use v5.36;\n\npackage Vector;\nuse Moose;\nuse overload '+'  => \\&add,\n             '-'  => \\&sub,\n             '*'  => \\&mul,\n             '/'  => \\&div,\n             '\"\"' => \\&stringify;\n\nhas 'x' => (is =>'rw', isa => 'Num', required => 1);\nhas 'y' => (is =>'rw', isa => 'Num', required => 1);\n\nsub add ($a, $b, $) { Vector->new( x => $a->x + $b->x, y => $a->y + $b->y) }\nsub sub ($a, $b, $) { Vector->new( x => $a->x - $b->x, y => $a->y - $b->y) }\nsub mul ($a, $b, $) { Vector->new( x => $a->x * $b,    y => $a->y * $b)    }\nsub div ($a, $b, $) { Vector->new( x => $a->x / $b,    y => $a->y / $b)    }\nsub stringify ($self, $, $) { '(' . $self->x . ',' . $self->y . ')' }\n\npackage main;\n\nmy $a = Vector->new(x => 5, y => 7);\nmy $b = Vector->new(x => 2, y => 3);\nsay \"a:    $a\";\nsay \"b:    $b\";\nsay \"a+b:  \",$a+$b;\nsay \"a-b:  \",$a-$b;\nsay \"a*11: \",$a*11;\nsay \"a/2:  \",$a/2;\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaVectors\n{\n    public class Vector\n    {\n        public double[] store;\n        public Vector(IEnumerable<double> init)\n        {\n            store = init.ToArray();\n        }\n        public Vector(double x, double y)\n        {\n            store = new double[] { x, y };\n        }\n        static public Vector operator+(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a + b));\n        }\n        static public Vector operator -(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a - b));\n        }\n        static public Vector operator *(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x * scalar));\n        }\n        static public Vector operator /(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x / scalar));\n        }\n        public override string ToString()\n        {\n            return string.Format(\"[{0}]\", string.Join(\",\", store));\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var v1 = new Vector(5, 7);\n            var v2 = new Vector(2, 3);\n            Console.WriteLine(v1 + v2);\n            Console.WriteLine(v1 - v2);\n            Console.WriteLine(v1 * 11);\n            Console.WriteLine(v1 / 2);\n            \n            var lostVector = new Vector(new double[] { 4, 8, 15, 16, 23, 42 });\n            Console.WriteLine(lostVector * 7);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 400367, "name": "Chebyshev coefficients", "source": "Translate Perl to C#: use constant PI => 2 * atan2(1, 0);\n\nsub chebft {\n  my($func, $a, $b, $n) = @_;\n  my($bma, $bpa) = ( 0.5*($b-$a), 0.5*($b+$a) );\n\n  my @pin = map { ($_ + 0.5) * (PI/$n) } 0..$n-1;\n  my @f   = map { $func->( cos($_) * $bma + $bpa ) } @pin;\n  my @c   = (0) x $n;\n  for my $j (0 .. $n-1) {\n      $c[$j] += $f[$_] * cos($j * $pin[$_]) for 0..$n-1;\n      $c[$j] *= (2.0/$n);\n  }\n  @c\n}\n\nprintf \"%+13.7e\\n\", $_ for chebft(sub{cos($_[0])}, 0, 1, 10);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace Chebyshev {\n    class Program {\n        struct ChebyshevApprox {\n            public readonly List<double> coeffs;\n            public readonly Tuple<double, double> domain;\n\n            public ChebyshevApprox(Func<double, double> func, int n, Tuple<double, double> domain) {\n                coeffs = ChebCoef(func, n, domain);\n                this.domain = domain;\n            }\n\n            public double Call(double x) {\n                return ChebEval(coeffs, domain, x);\n            }\n        }\n\n        static double AffineRemap(Tuple<double, double> from, double x, Tuple<double, double> to) {\n            return to.Item1 + (x - from.Item1) * (to.Item2 - to.Item1) / (from.Item2 - from.Item1);\n        }\n\n        static List<double> ChebCoef(List<double> fVals) {\n            int n = fVals.Count;\n            double theta = Math.PI / n;\n            List<double> retval = new List<double>();\n            for (int i = 0; i < n; i++) {\n                retval.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                double f = fVals[ii] * 2.0 / n;\n                double phi = (ii + 0.5) * theta;\n                double c1 = Math.Cos(phi);\n                double s1 = Math.Sin(phi);\n                double c = 1.0;\n                double s = 0.0;\n                for (int j = 0; j < n; j++) {\n                    retval[j] += f * c;\n                    \n                    double cNext = c * c1 - s * s1;\n                    s = c * s1 + s * c1;\n                    c = cNext;\n                }\n            }\n            return retval;\n        }\n\n        static List<double> ChebCoef(Func<double, double> func, int n, Tuple<double, double> domain) {\n            double remap(double x) {\n                return AffineRemap(new Tuple<double, double>(-1.0, 1.0), x, domain);\n            }\n            double theta = Math.PI / n;\n            List<double> fVals = new List<double>();\n            for (int i = 0; i < n; i++) {\n                fVals.Add(0.0);\n            }\n            for (int ii = 0; ii < n; ii++) {\n                fVals[ii] = func(remap(Math.Cos((ii + 0.5) * theta)));\n            }\n            return ChebCoef(fVals);\n        }\n\n        static double ChebEval(List<double> coef, double x) {\n            double a = 1.0;\n            double b = x;\n            double c;\n            double retval = 0.5 * coef[0] + b * coef[1];\n            var it = coef.GetEnumerator();\n            it.MoveNext();\n            it.MoveNext();\n            while (it.MoveNext()) {\n                double pc = it.Current;\n                c = 2.0 * b * x - a;\n                retval += pc * c;\n                a = b;\n                b = c;\n            }\n            return retval;\n        }\n\n        static double ChebEval(List<double> coef, Tuple<double, double> domain, double x) {\n            return ChebEval(coef, AffineRemap(domain, x, new Tuple<double, double>(-1.0, 1.0)));\n        }\n\n        static void Main() {\n            const int N = 10;\n            ChebyshevApprox fApprox = new ChebyshevApprox(Math.Cos, N, new Tuple<double, double>(0.0, 1.0));\n            Console.WriteLine(\"Coefficients: \");\n            foreach (var c in fApprox.coeffs) {\n                Console.WriteLine(\"\\t{0: 0.00000000000000;-0.00000000000000;zero}\", c);\n            }\n\n            Console.WriteLine(\"\\nApproximation:\\n    x       func(x)        approx      diff\");\n            const int nX = 20;\n            const int min = 0;\n            const int max = 1;\n            for (int i = 0; i < nX; i++) {\n                double x = AffineRemap(new Tuple<double, double>(0, nX), i, new Tuple<double, double>(min, max));\n                double f = Math.Cos(x);\n                double approx = fApprox.Call(x);\n                Console.WriteLine(\"{0:0.000} {1:0.00000000000000} {2:0.00000000000000} {3:E}\", x, f, approx, approx - f);\n            }\n        }\n    }\n}\n"}
{"id": 400368, "name": "Burrows\u2013Wheeler transform", "source": "Translate Perl to C#: use utf8;\nbinmode STDOUT, \":utf8\";\n\nuse constant STX => '\ud83d\udc4d ';\n\nsub transform {\n    my($s) = @_;\n    my($t);\n    warn \"String can't contain STX character.\" and exit if $s =~ /STX/;\n    $s = STX . $s;\n    $t .= substr($_,-1,1) for sort map { rotate($s,$_) } 1..length($s);\n    return $t;\n}\n\nsub rotate { my($s,$n) = @_; join '', (split '', $s)[$n..length($s)-1, 0..$n-1] }\n\nsub \u026f\u0279o\u025fsu\u0250\u0279\u0287 {\n    my($s) = @_;\n    my @s = split '', $s;\n    my @t = sort @s;\n    map { @t = sort map { $s[$_] . $t[$_] } 0..length($s)-1 } 1..length($s)-1;\n    for (@t) {\n        next unless /${\\(STX)}$/;  \n        chop $_ and return $_\n    }\n}\n\nfor $phrase (qw<BANANA dogwood SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES>,\n    'TO BE OR NOT TO BE OR WANT TO BE OR NOT?') {\n    push @res, 'Original:            '. $phrase;\n    push @res, 'Transformed:         '. transform $phrase;\n    push @res, 'Inverse transformed: '. \u026f\u0279o\u025fsu\u0250\u0279\u0287 transform $phrase;\n    push @res, '';\n}\n\nprint join \"\\n\", @res;\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 400369, "name": "Burrows\u2013Wheeler transform", "source": "Translate Perl to C#: use utf8;\nbinmode STDOUT, \":utf8\";\n\nuse constant STX => '\ud83d\udc4d ';\n\nsub transform {\n    my($s) = @_;\n    my($t);\n    warn \"String can't contain STX character.\" and exit if $s =~ /STX/;\n    $s = STX . $s;\n    $t .= substr($_,-1,1) for sort map { rotate($s,$_) } 1..length($s);\n    return $t;\n}\n\nsub rotate { my($s,$n) = @_; join '', (split '', $s)[$n..length($s)-1, 0..$n-1] }\n\nsub \u026f\u0279o\u025fsu\u0250\u0279\u0287 {\n    my($s) = @_;\n    my @s = split '', $s;\n    my @t = sort @s;\n    map { @t = sort map { $s[$_] . $t[$_] } 0..length($s)-1 } 1..length($s)-1;\n    for (@t) {\n        next unless /${\\(STX)}$/;  \n        chop $_ and return $_\n    }\n}\n\nfor $phrase (qw<BANANA dogwood SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES>,\n    'TO BE OR NOT TO BE OR WANT TO BE OR NOT?') {\n    push @res, 'Original:            '. $phrase;\n    push @res, 'Transformed:         '. transform $phrase;\n    push @res, 'Inverse transformed: '. \u026f\u0279o\u025fsu\u0250\u0279\u0287 transform $phrase;\n    push @res, '';\n}\n\nprint join \"\\n\", @res;\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 400370, "name": "Card shuffles", "source": "Translate Perl to C#: sub overhand {\n    our @cards; local *cards = shift;\n    my(@splits,@shuffle);\n    my $x = int +@cards / 5;\n    push @splits, (1..$x)[int rand $x] for 1..+@cards;\n    while (@cards) {\n        push @shuffle, [splice @cards, 0, shift @splits];\n    }\n    @cards = flatten(reverse @shuffle);\n}\n\nsub flatten { map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_ }\n\nsub riffle {\n    our @cards; local *cards = shift;\n    splice @cards, @cards/2 - $_, 0, pop @cards for 0 .. (@cards/2)-1;\n}\n\n@cards = 1..20;\noverhand(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n\n@cards = 1..20;\nriffle(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CardShuffles {\n    public static class Helper {\n        public static string AsString<T>(this ICollection<T> c) {\n            StringBuilder sb = new StringBuilder(\"[\");\n            sb.Append(string.Join(\", \", c));\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        private static Random rand = new Random();\n\n        public static List<T> riffleShuffle<T>(ICollection<T> list, int flips) {\n            List<T> newList = new List<T>(list);\n\n            for (int n = 0; n < flips; n++) {\n                \n                int cutPoint = newList.Count / 2\n                    + (rand.Next(0, 2) == 0 ? -1 : 1) * rand.Next((int)(newList.Count * 0.1));\n\n                \n                List<T> left = new List<T>(newList.Take(cutPoint));\n                List<T> right = new List<T>(newList.Skip(cutPoint));\n\n                newList.Clear();\n\n                while (left.Count > 0 && right.Count > 0) {\n                    \n                    \n                    \n                    if (rand.NextDouble() >= ((double)left.Count / right.Count) / 2) {\n                        newList.Add(right.First());\n                        right.RemoveAt(0);\n                    }\n                    else {\n                        newList.Add(left.First());\n                        left.RemoveAt(0);\n                    }\n                }\n\n                \n                if (left.Count > 0) newList.AddRange(left);\n                if (right.Count > 0) newList.AddRange(right);\n            }\n\n            return newList;\n        }\n\n        public static List<T> overhandShuffle<T>(List<T> list, int passes) {\n            List<T> mainHand = new List<T>(list);\n\n            for (int n = 0; n < passes; n++) {\n                List<T> otherHand = new List<T>();\n\n                while (mainHand.Count>0) {\n                    \n                    int cutSize = rand.Next((int)(list.Count * 0.2)) + 1;\n\n                    List<T> temp = new List<T>();\n\n                    \n                    for (int i = 0; i < cutSize && mainHand.Count > 0; i++) {\n                        temp.Add(mainHand.First());\n                        mainHand.RemoveAt(0);\n                    }\n\n                    \n                    if (rand.NextDouble()>=0.1) {\n                        \n                        temp.AddRange(otherHand);\n                        otherHand = temp;\n                    }\n                    else {\n                        \n                        otherHand.AddRange(temp);\n                    }\n                }\n\n                \n                mainHand = otherHand;\n            }\n\n            return mainHand;\n        }\n\n        static void Main(string[] args) {\n            List<int> list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400371, "name": "Card shuffles", "source": "Translate Perl to C#: sub overhand {\n    our @cards; local *cards = shift;\n    my(@splits,@shuffle);\n    my $x = int +@cards / 5;\n    push @splits, (1..$x)[int rand $x] for 1..+@cards;\n    while (@cards) {\n        push @shuffle, [splice @cards, 0, shift @splits];\n    }\n    @cards = flatten(reverse @shuffle);\n}\n\nsub flatten { map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_ }\n\nsub riffle {\n    our @cards; local *cards = shift;\n    splice @cards, @cards/2 - $_, 0, pop @cards for 0 .. (@cards/2)-1;\n}\n\n@cards = 1..20;\noverhand(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n\n@cards = 1..20;\nriffle(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CardShuffles {\n    public static class Helper {\n        public static string AsString<T>(this ICollection<T> c) {\n            StringBuilder sb = new StringBuilder(\"[\");\n            sb.Append(string.Join(\", \", c));\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        private static Random rand = new Random();\n\n        public static List<T> riffleShuffle<T>(ICollection<T> list, int flips) {\n            List<T> newList = new List<T>(list);\n\n            for (int n = 0; n < flips; n++) {\n                \n                int cutPoint = newList.Count / 2\n                    + (rand.Next(0, 2) == 0 ? -1 : 1) * rand.Next((int)(newList.Count * 0.1));\n\n                \n                List<T> left = new List<T>(newList.Take(cutPoint));\n                List<T> right = new List<T>(newList.Skip(cutPoint));\n\n                newList.Clear();\n\n                while (left.Count > 0 && right.Count > 0) {\n                    \n                    \n                    \n                    if (rand.NextDouble() >= ((double)left.Count / right.Count) / 2) {\n                        newList.Add(right.First());\n                        right.RemoveAt(0);\n                    }\n                    else {\n                        newList.Add(left.First());\n                        left.RemoveAt(0);\n                    }\n                }\n\n                \n                if (left.Count > 0) newList.AddRange(left);\n                if (right.Count > 0) newList.AddRange(right);\n            }\n\n            return newList;\n        }\n\n        public static List<T> overhandShuffle<T>(List<T> list, int passes) {\n            List<T> mainHand = new List<T>(list);\n\n            for (int n = 0; n < passes; n++) {\n                List<T> otherHand = new List<T>();\n\n                while (mainHand.Count>0) {\n                    \n                    int cutSize = rand.Next((int)(list.Count * 0.2)) + 1;\n\n                    List<T> temp = new List<T>();\n\n                    \n                    for (int i = 0; i < cutSize && mainHand.Count > 0; i++) {\n                        temp.Add(mainHand.First());\n                        mainHand.RemoveAt(0);\n                    }\n\n                    \n                    if (rand.NextDouble()>=0.1) {\n                        \n                        temp.AddRange(otherHand);\n                        otherHand = temp;\n                    }\n                    else {\n                        \n                        otherHand.AddRange(temp);\n                    }\n                }\n\n                \n                mainHand = otherHand;\n            }\n\n            return mainHand;\n        }\n\n        static void Main(string[] args) {\n            List<int> list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = riffleShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 10);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n\n            list = new List<int>() { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20 };\n            Console.WriteLine(list.AsString());\n            list = overhandShuffle(list, 1);\n            Console.WriteLine(list.AsString());\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400372, "name": "Faulhaber's triangle", "source": "Translate Perl to C#: use 5.010;\nuse List::Util qw(sum);\nuse Math::BigRat try => 'GMP';\nuse ntheory qw(binomial bernfrac);\n\nsub faulhaber_triangle {\n    my ($p) = @_;\n    map {\n        Math::BigRat->new(bernfrac($_))\n          * binomial($p, $_)\n          / $p\n    } reverse(0 .. $p-1);\n}\n\n\nforeach my $p (1 .. 10) {\n    say map { sprintf(\"%6s\", $_) } faulhaber_triangle($p);\n}\n\n\nmy $p = 17;\nmy $n = Math::BigInt->new(1000);\nmy @r = faulhaber_triangle($p+1);\nsay \"\\n\", sum(map { $r[$_] * $n**($_ + 1) } 0 .. $\n", "target": "using System;\n\nnamespace FaulhabersTriangle {\n    internal class Frac {\n        private long num;\n        private long denom;\n\n        public static readonly Frac ZERO = new Frac(0, 1);\n        public static readonly Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) {\n                throw new ArgumentException(\"d must not be zero\");\n            }\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            }\n            else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.Abs(Gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        private static long Gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            return Gcd(b, a % b);\n        }\n\n        public static Frac operator -(Frac self) {\n            return new Frac(-self.num, self.denom);\n        }\n\n        public static Frac operator +(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);\n        }\n\n        public static Frac operator -(Frac lhs, Frac rhs) {\n            return lhs + -rhs;\n        }\n\n        public static Frac operator *(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);\n        }\n\n        public static bool operator <(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x < y;\n        }\n\n        public static bool operator >(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x > y;\n        }\n\n        public static bool operator ==(Frac lhs, Frac rhs) {\n            return lhs.num == rhs.num && lhs.denom == rhs.denom;\n        }\n\n        public static bool operator !=(Frac lhs, Frac rhs) {\n            return lhs.num != rhs.num || lhs.denom != rhs.denom;\n        }\n\n        public override string ToString() {\n            if (denom == 1) {\n                return num.ToString();\n            }\n            return string.Format(\"{0}/{1}\", num, denom);\n        }\n\n        public override bool Equals(object obj) {\n            var frac = obj as Frac;\n            return frac != null &&\n                   num == frac.num &&\n                   denom == frac.denom;\n        }\n\n        public override int GetHashCode() {\n            var hashCode = 1317992671;\n            hashCode = hashCode * -1521134295 + num.GetHashCode();\n            hashCode = hashCode * -1521134295 + denom.GetHashCode();\n            return hashCode;\n        }\n    }\n\n    class Program {\n        static Frac Bernoulli(int n) {\n            if (n < 0) {\n                throw new ArgumentException(\"n may not be negative or zero\");\n            }\n            Frac[] a = new Frac[n + 1];\n            for (int m = 0; m <= n; m++) {\n                a[m] = new Frac(1, m + 1);\n                for (int j = m; j >= 1; j--) {\n                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);\n                }\n            }\n            \n            if (n != 1) return a[0];\n            return -a[0];\n        }\n\n        static int Binomial(int n, int k) {\n            if (n < 0 || k < 0 || n < k) {\n                throw new ArgumentException();\n            }\n            if (n == 0 || k == 0) return 1;\n            int num = 1;\n            for (int i = k + 1; i <= n; i++) {\n                num = num * i;\n            }\n            int denom = 1;\n            for (int i = 2; i <= n - k; i++) {\n                denom = denom * i;\n            }\n            return num / denom;\n        }\n\n        static Frac[] FaulhaberTriangle(int p) {\n            Frac[] coeffs = new Frac[p + 1];\n            for (int i = 0; i < p + 1; i++) {\n                coeffs[i] = Frac.ZERO;\n            }\n            Frac q = new Frac(1, p + 1);\n            int sign = -1;\n            for (int j = 0; j <= p; j++) {\n                sign *= -1;\n                coeffs[p - j] = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);\n            }\n            return coeffs;\n        }\n\n        static void Main(string[] args) {\n            for (int i = 0; i < 10; i++) {\n                Frac[] coeffs = FaulhaberTriangle(i);\n                foreach (Frac coeff in coeffs) {\n                    Console.Write(\"{0,5}  \", coeff);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 400373, "name": "Faulhaber's formula", "source": "Translate Perl to C#: use 5.014;\nuse Math::Algebra::Symbols;\n\nsub bernoulli_number {\n    my ($n) = @_;\n\n    return 0 if $n > 1 && $n % 2;\n\n    my @A;\n    for my $m (0 .. $n) {\n        $A[$m] = symbols(1) / ($m + 1);\n\n        for (my $j = $m ; $j > 0 ; $j--) {\n            $A[$j - 1] = $j * ($A[$j - 1] - $A[$j]);\n        }\n    }\n\n    return $A[0];\n}\n\nsub binomial {\n    my ($n, $k) = @_;\n    return 1 if $k == 0 || $n == $k;\n    binomial($n - 1, $k - 1) + binomial($n - 1, $k);\n}\n\nsub faulhaber_s_formula {\n    my ($p) = @_;\n\n    my $formula = 0;\n    for my $j (0 .. $p) {\n        $formula += binomial($p + 1, $j)\n                 *  bernoulli_number($j)\n                 *  symbols('n')**($p + 1 - $j);\n    }\n\n    (symbols(1) / ($p + 1) * $formula)\n        =~ s/\\$n/n/gr =~ s/\\*\\*/^/gr =~ s/\\*/ /gr;\n}\n\nforeach my $i (0 .. 9) {\n    say \"$i: \", faulhaber_s_formula($i);\n}\n", "target": "using System;\n\nnamespace FaulhabersFormula {\n    internal class Frac {\n        private long num;\n        private long denom;\n\n        public static readonly Frac ZERO = new Frac(0, 1);\n        public static readonly Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) {\n                throw new ArgumentException(\"d must not be zero\");\n            }\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            }\n            else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.Abs(Gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        private static long Gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            return Gcd(b, a % b);\n        }\n\n        public static Frac operator -(Frac self) {\n            return new Frac(-self.num, self.denom);\n        }\n\n        public static Frac operator +(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);\n        }\n\n        public static Frac operator -(Frac lhs, Frac rhs) {\n            return lhs + -rhs;\n        }\n\n        public static Frac operator *(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);\n        }\n\n        public static bool operator <(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x < y;\n        }\n\n        public static bool operator >(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x > y;\n        }\n\n        public static bool operator ==(Frac lhs, Frac rhs) {\n            return lhs.num == rhs.num && lhs.denom == rhs.denom;\n        }\n\n        public static bool operator !=(Frac lhs, Frac rhs) {\n            return lhs.num != rhs.num || lhs.denom != rhs.denom;\n        }\n\n        public override string ToString() {\n            if (denom == 1) {\n                return num.ToString();\n            }\n            return string.Format(\"{0}/{1}\", num, denom);\n        }\n\n        public override bool Equals(object obj) {\n            var frac = obj as Frac;\n            return frac != null &&\n                   num == frac.num &&\n                   denom == frac.denom;\n        }\n\n        public override int GetHashCode() {\n            var hashCode = 1317992671;\n            hashCode = hashCode * -1521134295 + num.GetHashCode();\n            hashCode = hashCode * -1521134295 + denom.GetHashCode();\n            return hashCode;\n        }\n    }\n\n    class Program {\n        static Frac Bernoulli(int n) {\n            if (n < 0) {\n                throw new ArgumentException(\"n may not be negative or zero\");\n            }\n            Frac[] a = new Frac[n + 1];\n            for (int m = 0; m <= n; m++) {\n                a[m] = new Frac(1, m + 1);\n                for (int j = m; j >= 1; j--) {\n                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);\n                }\n            }\n            \n            if (n != 1) return a[0];\n            return -a[0];\n        }\n\n        static int Binomial(int n, int k) {\n            if (n < 0 || k < 0 || n < k) {\n                throw new ArgumentException();\n            }\n            if (n == 0 || k == 0) return 1;\n            int num = 1;\n            for (int i = k + 1; i <= n; i++) {\n                num = num * i;\n            }\n            int denom = 1;\n            for (int i = 2; i <= n - k; i++) {\n                denom = denom * i;\n            }\n            return num / denom;\n        }\n\n        static void Faulhaber(int p) {\n            Console.Write(\"{0}\u00a0: \", p);\n            Frac q = new Frac(1, p + 1);\n            int sign = -1;\n            for (int j = 0; j <= p; j++) {\n                sign *= -1;\n                Frac coeff = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);\n                if (Frac.ZERO == coeff) continue;\n                if (j == 0) {\n                    if (Frac.ONE != coeff) {\n                        if (-Frac.ONE == coeff) {\n                            Console.Write(\"-\");\n                        }\n                        else {\n                            Console.Write(coeff);\n                        }\n                    }\n                }\n                else {\n                    if (Frac.ONE == coeff) {\n                        Console.Write(\" + \");\n                    }\n                    else if (-Frac.ONE == coeff) {\n                        Console.Write(\" - \");\n                    }\n                    else if (Frac.ZERO < coeff) {\n                        Console.Write(\" + {0}\", coeff);\n                    }\n                    else {\n                        Console.Write(\" - {0}\", -coeff);\n                    }\n                }\n                int pwr = p + 1 - j;\n                if (pwr > 1) {\n                    Console.Write(\"n^{0}\", pwr);\n                }\n                else {\n                    Console.Write(\"n\");\n                }\n            }\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            for (int i = 0; i < 10; i++) {\n                Faulhaber(i);\n            }\n        }\n    }\n}\n"}
{"id": 400374, "name": "Prime conspiracy", "source": "Translate Perl to C#: use ntheory qw/forprimes nth_prime/;\n\nmy $upto = 1_000_000;\nmy %freq;\nmy($this_digit,$last_digit)=(2,0);\n\nforprimes {\n  ($last_digit,$this_digit) = ($this_digit, $_ % 10);\n  $freq{$last_digit . $this_digit}++;\n} 3,nth_prime($upto);\n\nprint \"$upto first primes.  Transitions prime\u00a0% 10 \u2192 next-prime\u00a0% 10.\\n\";\nprintf \"%s \u2192 %s count:\\t%7d\\tfrequency: %4.2f\u00a0%%\\n\",\n  substr($_,0,1), substr($_,1,1), $freq{$_}, 100*$freq{$_}/$upto\n    for sort keys %freq;\n", "target": "using System;\n\nnamespace PrimeConspiracy {\n    class Program {\n        static void Main(string[] args) {\n            const int limit = 1_000_000;\n            const int sieveLimit = 15_500_000;\n\n            int[,] buckets = new int[10, 10];\n            int prevDigit = 2;\n            bool[] notPrime = Sieve(sieveLimit);\n\n            for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n                if (notPrime[n]) continue;\n\n                int digit = n % 10;\n                buckets[prevDigit, digit]++;\n                prevDigit = digit;\n                primeCount++;\n            }\n\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (buckets[i, j] != 0) {\n                        Console.WriteLine(\"{0} -> {1}  count: {2,5:d}  frequency\u00a0: {3,6:0.00%}\", i, j, buckets[i, j], 1.0 * buckets[i, j] / limit);\n                    }\n                }\n            }\n        }\n\n        public static bool[] Sieve(int limit) {\n            bool[] composite = new bool[limit];\n            composite[0] = composite[1] = true;\n\n            int max = (int)Math.Sqrt(limit);\n            for (int n = 2; n <= max; n++) {\n                if (!composite[n]) {\n                    for (int k = n * n; k < limit; k += n) {\n                        composite[k] = true;\n                    }\n                }\n            }\n\n            return composite;\n        }\n    }\n}\n"}
{"id": 400375, "name": "Imaginary base numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nuse Math::Complex;\nuse List::AllUtils qw(sum mesh);\nuse ntheory qw<todigitstring fromdigits>;\n\nsub zip {\n    my($a,$b) = @_;\n    my($la, $lb) = (length $a, length $b);\n    my $l = '0' x abs $la - $lb;\n    $a .= $l if $la < $lb;\n    $b .= $l if $lb < $la;\n    (join('', mesh(@{[split('',$a),]}, @{[split('',$b),]})) =~ s/0+$//r) or 0;\n}\n\nsub base_i {\n    my($num,$radix,$precision) = @_;\n    die unless $radix > -37 and $radix < -1;\n    return '0' unless $num;\n    my $value  = $num;\n    my $result = '';\n    my $place  = 0;\n    my $upper_bound = 1 / (-$radix + 1);\n    my $lower_bound = $radix * $upper_bound;\n\n    $value = $num / $radix ** ++$place until $lower_bound <= $value and $value < $upper_bound;\n\n    while (($value or $place > 0) and $place > $precision) {\n        my $digit = int $radix * $value - $lower_bound;\n        $value    =  $radix * $value - $digit;\n        $result  .= '.' unless $place or not index($result, '.');\n        $result  .= $digit == -$radix ? todigitstring($digit-1, -$radix) . '0' : (todigitstring($digit, -$radix) or '0');\n        $place--;\n    }\n    $result\n}\n\nsub base_c {\n    my($num, $radix, $precision) = @_;\n    die \"Base $radix out of range\" unless\n        (-6 <= $radix->Im or $radix->Im <= -2) or (2 <= $radix->Im or $radix->Im <= 6);\n    my ($re,$im);\n    defined $num->Im ? ($re, $im) = ($num->Re, $num->Im) : $re = $num;\n    my ($re_wh, $re_fr) = split /\\./, base_i(  $re,               -1 * int($radix->Im**2), $precision);\n    my ($im_wh, $im_fr) = split /\\./, base_i( ($im/($radix->Im)), -1 * int($radix->Im**2), $precision);\n    $_ //= '' for $re_fr, $im_fr;\n\n    my $whole = reverse zip scalar reverse($re_wh), scalar reverse($im_wh);\n    my $fraction = zip $im_fr, $re_fr;\n    $fraction eq 0 ? \"$whole\" : \"$whole.$fraction\"\n}\n\nsub parse_base {\n    my($str, $radix) = @_;\n    return -1 * parse_base( substr($str,1), $radix) if substr($str,0,1) eq '-';\n    my($whole, $frac) = split /\\./, $str;\n    my $fraction = 0;\n    my $k = 0;\n    $fraction = sum map { (fromdigits($_, int $radix->Im**2) || 0) * $radix ** -($k++ +1) } split '', $frac\n        if $frac;\n    $k = 0;\n    $fraction + sum map { (fromdigits($_, int $radix->Im**2) || 0) * $radix ** $k++  } reverse split '', $whole;\n}\n\nfor (\n    [  0*i,  2*i], [1+0*i,  2*i], [5+0*i,      2*i], [ -13+0*i, 2*i],\n    [  9*i,  2*i], [ -3*i,  2*i], [7.75-7.5*i, 2*i], [0.25+0*i, 2*i],\n    [5+5*i,  2*i], [5+5*i,  3*i], [5+5*i,  4*i], [5+5*i,  5*i], [5+5*i,  6*i],\n    [5+5*i, -2*i], [5+5*i, -3*i], [5+5*i, -4*i], [5+5*i, -5*i], [5+5*i, -6*i]\n) {\n    my($v,$r) = @$_;\n    my $ibase = base_c($v, $r, -6);\n    my $rt = cplx parse_base($ibase, $r);\n    $rt->display_format('format' => '%.2f');\n    printf \"base(%3s): %10s  => %9s  => %13s\\n\", $r, $v, $ibase, $rt;\n}\n\nsay '';\nsay 'base( 6i): 31432.6219135802-2898.5266203704*i => ' .\n         base_c(31432.6219135802-2898.5266203704*i, 0+6*i, -3);\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace ImaginaryBaseNumbers {\n    class Complex {\n        private double real, imag;\n\n        public Complex(int r, int i) {\n            real = r;\n            imag = i;\n        }\n\n        public Complex(double r, double i) {\n            real = r;\n            imag = i;\n        }\n\n        public static Complex operator -(Complex self) =>\n            new Complex(-self.real, -self.imag);\n\n        public static Complex operator +(Complex rhs, Complex lhs) =>\n            new Complex(rhs.real + lhs.real, rhs.imag + lhs.imag);\n\n        public static Complex operator -(Complex rhs, Complex lhs) =>\n            new Complex(rhs.real - lhs.real, rhs.imag - lhs.imag);\n\n        public static Complex operator *(Complex rhs, Complex lhs) =>\n            new Complex(\n                rhs.real * lhs.real - rhs.imag * lhs.imag,\n                rhs.real * lhs.imag + rhs.imag * lhs.real\n                );\n\n        public static Complex operator *(Complex rhs, double lhs) =>\n             new Complex(rhs.real * lhs, rhs.imag * lhs);\n\n        public static Complex operator /(Complex rhs, Complex lhs) =>\n            rhs * lhs.Inv();\n\n        public Complex Inv() {\n            double denom = real * real + imag * imag;\n            return new Complex(real / denom, -imag / denom);\n        }\n\n        public QuaterImaginary ToQuaterImaginary() {\n            if (real == 0.0 && imag == 0.0) return new QuaterImaginary(\"0\");\n            int re = (int)real;\n            int im = (int)imag;\n            int fi = -1;\n            StringBuilder sb = new StringBuilder();\n            while (re != 0) {\n                int rem = re % -4;\n                re /= -4;\n                if (rem < 0) {\n                    rem = 4 + rem;\n                    re++;\n                }\n                sb.Append(rem);\n                sb.Append(0);\n            }\n            if (im != 0) {\n                double f = (new Complex(0.0, imag) / new Complex(0.0, 2.0)).real;\n                im = (int)Math.Ceiling(f);\n                f = -4.0 * (f - im);\n                int index = 1;\n                while (im != 0) {\n                    int rem = im % -4;\n                    im /= -4;\n                    if (rem < 0) {\n                        rem = 4 + rem;\n                        im++;\n                    }\n                    if (index < sb.Length) {\n                        sb[index] = (char)(rem + 48);\n                    } else {\n                        sb.Append(0);\n                        sb.Append(rem);\n                    }\n                    index += 2;\n                }\n                fi = (int)f;\n            }\n            string reverse = new string(sb.ToString().Reverse().ToArray());\n            sb.Length = 0;\n            sb.Append(reverse);\n            if (fi != -1) sb.AppendFormat(\".{0}\", fi);\n            string s = sb.ToString().TrimStart('0');\n            if (s[0] == '.') s = \"0\" + s;\n            return new QuaterImaginary(s);\n        }\n\n        public override string ToString() {\n            double real2 = (real == -0.0) ? 0.0 : real;  \n            double imag2 = (imag == -0.0) ? 0.0 : imag;  \n            if (imag2 == 0.0) {\n                return string.Format(\"{0}\", real2);\n            }\n            if (real2 == 0.0) {\n                return string.Format(\"{0}i\", imag2);\n            }\n            if (imag2 > 0.0) {\n                return string.Format(\"{0} + {1}i\", real2, imag2);\n            }\n            return string.Format(\"{0} - {1}i\", real2, -imag2);\n        }\n    }\n\n    class QuaterImaginary {\n        internal static Complex twoI = new Complex(0.0, 2.0);\n        internal static Complex invTwoI = twoI.Inv();\n\n        private string b2i;\n\n        public QuaterImaginary(string b2i) {\n            if (b2i == \"\" || !b2i.All(c => \"0123.\".IndexOf(c) > -1) || b2i.Count(c => c == '.') > 1) {\n                throw new Exception(\"Invalid Base 2i number\");\n            }\n            this.b2i = b2i;\n        }\n\n        public Complex ToComplex() {\n            int pointPos = b2i.IndexOf(\".\");\n            int posLen = (pointPos != -1) ? pointPos : b2i.Length;\n            Complex sum = new Complex(0.0, 0.0);\n            Complex prod = new Complex(1.0, 0.0);\n            for (int j = 0; j < posLen; j++) {\n                double k = (b2i[posLen - 1 - j] - '0');\n                if (k > 0.0) {\n                    sum += prod * k;\n                }\n                prod *= twoI;\n            }\n            if (pointPos != -1) {\n                prod = invTwoI;\n                for (int j = posLen + 1; j < b2i.Length; j++) {\n                    double k = (b2i[j] - '0');\n                    if (k > 0.0) {\n                        sum += prod * k;\n                    }\n                    prod *= invTwoI;\n                }\n            }\n\n            return sum;\n        }\n\n        public override string ToString() {\n            return b2i;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 1; i <= 16; i++) {\n                Complex c1 = new Complex(i, 0);\n                QuaterImaginary qi = c1.ToQuaterImaginary();\n                Complex c2 = qi.ToComplex();\n                Console.Write(\"{0,4} -> {1,8} -> {2,4}     \", c1, qi, c2);\n                c1 = -c1;\n                qi = c1.ToQuaterImaginary();\n                c2 = qi.ToComplex();\n                Console.WriteLine(\"{0,4} -> {1,8} -> {2,4}\", c1, qi, c2);\n            }\n            Console.WriteLine();\n            for (int i = 1; i <= 16; i++) {\n                Complex c1 = new Complex(0, i);\n                QuaterImaginary qi = c1.ToQuaterImaginary();\n                Complex c2 = qi.ToComplex();\n                Console.Write(\"{0,4} -> {1,8} -> {2,4}     \", c1, qi, c2);\n                c1 = -c1;\n                qi = c1.ToQuaterImaginary();\n                c2 = qi.ToComplex();\n                Console.WriteLine(\"{0,4} -> {1,8} -> {2,4}\", c1, qi, c2);\n            }\n        }\n    }\n}\n"}
{"id": 400376, "name": "Statistics_Normal distribution", "source": "Translate Perl to C#: use constant pi => 3.14159265;\nuse List::Util qw(sum reduce min max);\n\nsub normdist {\n    my($m, $sigma) = @_;\n    my $r = sqrt -2 * log rand;\n    my $theta = 2 * pi * rand;\n    $r * cos($theta) * $sigma + $m;\n}\n\n$size = 100000; $mean = 50; $stddev = 4;\n\npush @dataset, normdist($mean,$stddev) for 1..$size;\n\nmy $m = sum(@dataset) / $size;\nprint \"m = $m\\n\";\n\nmy $sigma = sqrt( (reduce { $a + $b **2 } 0,@dataset) / $size - $m**2 );\nprint \"sigma = $sigma\\n\";\n\n    $hash{int $_}++ for @dataset;\n    my $scale = 180 * $stddev / $size;\n    my @subbar = < \u23b8 \u258f \u258e \u258d \u258c \u258b \u258a \u2589 \u2588 >;\n    for $i (min(@dataset)..max(@dataset)) {\n        my $x = ($hash{$i} // 0) * $scale;\n        my $full = int $x;\n        my $part = 8 * ($x - $full);\n        my $t1 = '\u2588' x $full;\n        my $t2 = $subbar[$part];\n        print \"$i\\t$t1$t2\\n\";\n    }\n", "target": "using System;\nusing MathNet.Numerics.Distributions;\nusing MathNet.Numerics.Statistics;\n\nclass Program\n{\n    static void RunNormal(int sampleSize)\n    {\n        double[] X = new double[sampleSize];\n        var norm = new Normal(new Random());\n        norm.Samples(X);\n\n        const int numBuckets = 10;\n        var histogram = new Histogram(X, numBuckets);\n        Console.WriteLine(\"Sample size: {0:N0}\", sampleSize);\n        for (int i = 0; i < numBuckets; i++)\n        {\n            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));\n            Console.WriteLine(\" {0:0.00}\u00a0: {1}\", histogram[i].LowerBound, bar);\n        }\n        var statistics = new DescriptiveStatistics(X);\n        Console.WriteLine(\"  Mean: \" + statistics.Mean);\n        Console.WriteLine(\"StdDev: \" + statistics.StandardDeviation);\n        Console.WriteLine();\n    }\n    static void Main(string[] args)\n    {\n        RunNormal(100);\n        RunNormal(1000);\n        RunNormal(10000);\n    }\n}\n"}
{"id": 400377, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse Math::AnyNum qw(:overload as_bin digits2num);\n\nfor my $x (1..10, 95..105, 297, 576, 594, 891, 909, 999) {\n    my $y;\n    if ($x =~ /^9+$/) { $y = digits2num([(1) x (9 * length $x)],2)  } \n    else              { while (1) { last unless as_bin(++$y) % $x } }\n    printf \"%4d: %28s  %s\\n\", $x, as_bin($y), as_bin($y)/$x;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Console;\n \nclass Program {\n \n  static string B10(int n) {\n    int[] pow = new int[n + 1], val = new int[29];\n    for (int count = 0, ten = 1, x = 1; x <= n; x++) {\n      val[x] = ten;\n      for (int j = 0, t; j <= n; j++)\n        if (pow[j] != 0 && pow[j] != x && pow[t = (j + ten) % n] == 0)\n          pow[t] = x;\n      if (pow[ten] == 0) pow[ten] = x;\n      ten = (10 * ten) % n;\n      if (pow[0] != 0) {\n        x = n;\n        string s = \"\"; \n        while (x != 0) {\n          int p = pow[x % n];\n          if (count > p) s += new string('0', count - p);\n          count = p - 1;\n          s += \"1\";\n          x = (n + x - val[p]) % n;\n        }\n        if (count > 0) s += new string('0', count);\n        return s;\n      }\n    } \n    return \"1\";\n  }\n \n  static void Main(string[] args) {\n    string fmt = \"{0,4} * {1,24} = {2,-28}\\n\";\n    int[] m = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n      95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,\n      297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878 };\n    string[] r = new string[m.Length]; \n    WriteLine(fmt + new string('-', 62), \"n\", \"multiplier\", \"B10\");\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    for (int i = 0; i < m.Length; i++) r[i] = B10(m[i]);\n    sw.Stop();\n    for (int i = 0; i < m.Length; i++) Write(fmt, m[i], decimal.Parse(r[i]) / m[i], r[i]);\n    Write(\"\\nTook {0}ms\", sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 400378, "name": "Weird numbers", "source": "Translate Perl to C#: use strict;\nuse feature 'say';\n\nuse List::Util 'sum';\nuse POSIX 'floor';\nuse Algorithm::Combinatorics 'subsets';\nuse ntheory <is_prime divisors>;\n\nsub abundant {\n    my($x) = @_;\n    my $s = sum( my @l = is_prime($x) ? 1 : grep { $x != $_ } divisors($x) );\n    $s > $x ? ($s, sort { $b <=> $a } @l) : ();\n}\n\nmy(@weird,$n);\nwhile () {\n    $n++;\n    my ($sum, @div) = abundant($n);\n    next unless $sum;        \n    next if $sum / $n > 1.1; \n\n    if ($n >= 10430 and (! int $n%70) and is_prime(int $n/70)) {\n        \n    } else {\n        my $next;\n        my $l = shift @div;\n        my $iter = subsets(\\@div);\n        while (my $s = $iter->next) {\n            ++$next and last if sum(@$s) == $n - $l;\n        }\n        next if $next;\n    }\n    push @weird, $n;\n    last if @weird == 25;\n}\n\nsay \"The first 25 weird numbers:\\n\" . join ' ', @weird;\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WeirdNumbers {\n    class Program {\n        static List<int> Divisors(int n) {\n            List<int> divs = new List<int> { 1 };\n            List<int> divs2 = new List<int>();\n\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs2.Add(j);\n                    }\n                }\n            }\n\n            divs.Reverse();\n            divs2.AddRange(divs);\n            return divs2;\n        }\n\n        static bool Abundant(int n, List<int> divs) {\n            return divs.Sum() > n;\n        }\n\n        static bool Semiperfect(int n, List<int> divs) {\n            if (divs.Count > 0) {\n                var h = divs[0];\n                var t = divs.Skip(1).ToList();\n                if (n < h) {\n                    return Semiperfect(n, t);\n                } else {\n                    return n == h\n                        || Semiperfect(n - h, t)\n                        || Semiperfect(n, t);\n                }\n            } else {\n                return false;\n            }\n        }\n\n        static List<bool> Sieve(int limit) {\n            \n            \n            bool[] w = new bool[limit];\n            for (int i = 2; i < limit; i += 2) {\n                if (w[i]) continue;\n                var divs = Divisors(i);\n                if (!Abundant(i, divs)) {\n                    w[i] = true;\n                } else if (Semiperfect(i, divs)) {\n                    for (int j = i; j < limit; j += i) {\n                        w[j] = true;\n                    }\n                }\n            }\n            return w.ToList();\n        }\n\n        static void Main() {\n            var w = Sieve(17_000);\n            int count = 0;\n            int max = 25;\n            Console.WriteLine(\"The first 25 weird numbers:\");\n            for (int n = 2; count < max; n += 2) {\n                if (!w[n]) {\n                    Console.Write(\"{0} \", n);\n                    count++;\n                }\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 400379, "name": "Peaceful chess queen armies", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nmy $m = shift // 4;\nmy $n = shift // 5;\nmy %seen;\nmy $gaps = join '|', qr/-*/, map qr/.{$_}(?:-.{$_})*/s, $n-1, $n, $n+1;\nmy $attack = qr/(\\w)(?:$gaps)(?!\\1)\\w/;\n\nplace( scalar ('-' x $n . \"\\n\") x $n );\nprint \"No solution to $m $n\\n\";\n\nsub place\n  {\n  local $_ = shift;\n  $seen{$_}++ || /$attack/ and return; \n  (my $have = tr/WB//) < $m * 2 or exit !print \"Solution to $m $n\\n\\n$_\";\n  place( s/-\\G/ qw(W B)[$have\u00a0% 2] /er ) while /-/g; \n  }\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace PeacefulChessQueenArmies {\n    using Position = Tuple<int, int>;\n\n    enum Piece {\n        Empty,\n        Black,\n        White\n    }\n\n    class Program {\n        static bool IsAttacking(Position queen, Position pos) {\n            return queen.Item1 == pos.Item1\n                || queen.Item2 == pos.Item2\n                || Math.Abs(queen.Item1 - pos.Item1) == Math.Abs(queen.Item2 - pos.Item2);\n        }\n\n        static bool Place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n            if (m == 0) {\n                return true;\n            }\n            bool placingBlack = true;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    var pos = new Position(i, j);\n                    foreach (var queen in pBlackQueens) {\n                        if (queen.Equals(pos) || !placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    foreach (var queen in pWhiteQueens) {\n                        if (queen.Equals(pos) || placingBlack && IsAttacking(queen, pos)) {\n                            goto inner;\n                        }\n                    }\n                    if (placingBlack) {\n                        pBlackQueens.Add(pos);\n                        placingBlack = false;\n                    } else {\n                        pWhiteQueens.Add(pos);\n                        if (Place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                            return true;\n                        }\n                        pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n                        pWhiteQueens.RemoveAt(pWhiteQueens.Count - 1);\n                        placingBlack = true;\n                    }\n                inner: { }\n                }\n            }\n            if (!placingBlack) {\n                pBlackQueens.RemoveAt(pBlackQueens.Count - 1);\n            }\n            return false;\n        }\n\n        static void PrintBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n            var board = new Piece[n * n];\n\n            foreach (var queen in blackQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.Black;\n            }\n            foreach (var queen in whiteQueens) {\n                board[queen.Item1 * n + queen.Item2] = Piece.White;\n            }\n\n            for (int i = 0; i < board.Length; i++) {\n                if (i != 0 && i % n == 0) {\n                    Console.WriteLine();\n                }\n                switch (board[i]) {\n                    case Piece.Black:\n                        Console.Write(\"B \");\n                        break;\n                    case Piece.White:\n                        Console.Write(\"W \");\n                        break;\n                    case Piece.Empty:\n                        int j = i / n;\n                        int k = i - j * n;\n                        if (j % 2 == k % 2) {\n                            Console.Write(\"  \");\n                        } else {\n                            Console.Write(\"# \");\n                        }\n                        break;\n                }\n            }\n\n            Console.WriteLine(\"\\n\");\n        }\n\n        static void Main() {\n            var nms = new int[,] {\n                {2, 1}, {3, 1}, {3, 2}, {4, 1}, {4, 2}, {4, 3},\n                {5, 1}, {5, 2}, {5, 3}, {5, 4}, {5, 5},\n                {6, 1}, {6, 2}, {6, 3}, {6, 4}, {6, 5}, {6, 6},\n                {7, 1}, {7, 2}, {7, 3}, {7, 4}, {7, 5}, {7, 6}, {7, 7},\n            };\n            for (int i = 0; i < nms.GetLength(0); i++) {\n                Console.WriteLine(\"{0} black and {0} white queens on a {1} x {1} board:\", nms[i, 1], nms[i, 0]);\n                List<Position> blackQueens = new List<Position>();\n                List<Position> whiteQueens = new List<Position>();\n                if (Place(nms[i, 1], nms[i, 0], blackQueens, whiteQueens)) {\n                    PrintBoard(nms[i, 0], blackQueens, whiteQueens);\n                } else {\n                    Console.WriteLine(\"No solution exists.\\n\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 400380, "name": "N-body problem", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse constant PI         => 3.141592653589793;\nuse constant SOLAR_MASS => (4 * PI * PI);\nuse constant YEAR       => 365.24;\n\nsub solar_offset {\n    my($vxs, $vys, $vzs, $mass) = @_;\n    my($px, $py, $pz);\n    for (0..@$mass-1) {\n        $px += @$vxs[$_] * @$mass[$_];\n        $py += @$vys[$_] * @$mass[$_];\n        $pz += @$vzs[$_] * @$mass[$_];\n    }\n    (@$vxs[0], @$vys[0], @$vzs[0]) = ((-$px/SOLAR_MASS), (-$py/SOLAR_MASS), (-$pz/SOLAR_MASS));\n}\n\nsub orbit {\n    my ($dt, $xs, $ys, $zs, $vxs, $vys, $vzs, $mass) = @_;\n    for (0..@$mass-1) {\n        for (my $j = $_ + 1; $j < @$mass; $j++) {\n            my($dx, $dy, $dz) = ((@$xs[$_] - @$xs[$j]), (@$ys[$_] - @$ys[$j]), (@$zs[$_] - @$zs[$j]));\n            my $mag = $dt / ($dx**2 + $dy**2 + $dz**2)**(3/2);\n            my($mm, $mm2) = ((@$mass[$_] * $mag), (@$mass[$j] * $mag));\n            @$vxs[$_] -= $dx * $mm2;\n            @$vxs[$j] += $dx * $mm;\n            @$vys[$_] -= $dy * $mm2;\n            @$vys[$j] += $dy * $mm;\n            @$vzs[$_] -= $dz * $mm2;\n            @$vzs[$j] += $dz * $mm;\n        }\n        @$xs[$_] += $dt * @$vxs[$_];\n        @$ys[$_] += $dt * @$vys[$_];\n        @$zs[$_] += $dt * @$vzs[$_];\n    }\n}\n\nsub display {\n    my($t,$xs,$ys) = @_;\n    printf '%6d', $t;\n    printf '%7.2f' x 2, @$xs[$_],@$ys[$_] for 1..4;\n    print \"\\n\";\n}\n\nmy @ns =                         <Sun   Jupiter          Saturn           Uranus           Neptune       >;\nmy @xs =                         <0     4.84143144e+00   8.34336671e+00   1.28943695e+01   1.53796971e+01>;\nmy @ys =                         <0    -1.16032004e+00   4.12479856e+00  -1.51111514e+01  -2.59193146e+01>;\nmy @zs =                         <0    -1.03622044e-01  -4.03523417e-01  -2.23307578e-01   1.79258772e-01>;\nmy @vxs = map {$_ * YEAR}        <0     1.66007664e-03  -2.76742510e-03   2.96460137e-03   2.68067772e-03>;\nmy @vys = map {$_ * YEAR}        <0     7.69901118e-03   4.99852801e-03   2.37847173e-03   1.62824170e-03>;\nmy @vzs = map {$_ * YEAR}        <0    -6.90460016e-05   2.30417297e-05  -2.96589568e-05  -9.51592254e-05>;\nmy @mass = map {$_ * SOLAR_MASS} <1     9.54791938e-04   2.85885980e-04   4.36624404e-05   5.15138902e-05>;\nsolar_offset(\\@vxs, \\@vys, \\@vzs, \\@mass);\n\nprintf '     t' . '%14s'x4 . \"\\n\", @ns[1..4];\ndisplay(0, \\@xs, \\@ys);\nmy $steps = 16567;\nfor my $t (1 .. $steps) {\n    orbit(0.01, \\@xs, \\@ys, \\@zs, \\@vxs, \\@vys, \\@vzs, \\@mass);\n    display($t,\\@xs, \\@ys) unless $t % 1000;\n}\ndisplay($steps, \\@xs, \\@ys);\n", "target": "using System;\nusing System.IO;\n\nnamespace NBodyProblem {\n    class Vector3D {\n        public Vector3D(double x, double y, double z) {\n            X = x;\n            Y = y;\n            Z = z;\n        }\n\n        public double X { get; }\n        public double Y { get; }\n        public double Z { get; }\n\n        public double Mod() {\n            return Math.Sqrt(X * X + Y * Y + Z * Z);\n        }\n\n        public static Vector3D operator +(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);\n        }\n\n        public static Vector3D operator -(Vector3D lhs, Vector3D rhs) {\n            return new Vector3D(lhs.X - rhs.X, lhs.Y - rhs.Y, lhs.Z - rhs.Z);\n        }\n\n        public static Vector3D operator *(Vector3D lhs, double rhs) {\n            return new Vector3D(lhs.X * rhs, lhs.Y * rhs, lhs.Z * rhs);\n        }\n    }\n\n    class NBody {\n        private readonly double gc;\n        private readonly int bodies;\n        private readonly int timeSteps;\n        private readonly double[] masses;\n        private readonly Vector3D[] positions;\n        private readonly Vector3D[] velocities;\n        private readonly Vector3D[] accelerations;\n\n        public NBody(string fileName) {\n            string[] lines = File.ReadAllLines(fileName);\n\n            string[] gbt = lines[0].Split();\n            gc = double.Parse(gbt[0]);\n            bodies = int.Parse(gbt[1]);\n            timeSteps = int.Parse(gbt[2]);\n\n            masses = new double[bodies];\n            positions = new Vector3D[bodies];\n            velocities = new Vector3D[bodies];\n            accelerations = new Vector3D[bodies];\n            for (int i = 0; i < bodies; ++i) {\n                masses[i] = double.Parse(lines[i * 3 + 1]);\n                positions[i] = Decompose(lines[i * 3 + 2]);\n                velocities[i] = Decompose(lines[i * 3 + 3]);\n            }\n\n            Console.WriteLine(\"Contents of {0}\", fileName);\n            foreach (string line in lines) {\n                Console.WriteLine(line);\n            }\n            Console.WriteLine();\n            Console.Write(\"Body  \u00a0:      x          y          z    |\");\n            Console.WriteLine(\"     vx         vy         vz\");\n        }\n\n        public int GetTimeSteps() {\n            return timeSteps;\n        }\n\n        private Vector3D Decompose(string line) {\n            string[] xyz = line.Split();\n            double x = double.Parse(xyz[0]);\n            double y = double.Parse(xyz[1]);\n            double z = double.Parse(xyz[2]);\n            return new Vector3D(x, y, z);\n        }\n\n        private void ComputeAccelerations() {\n            for (int i = 0; i < bodies; ++i) {\n                accelerations[i] = new Vector3D(0, 0, 0);\n                for (int j = 0; j < bodies; ++j) {\n                    if (i != j) {\n                        double temp = gc * masses[j] / Math.Pow((positions[i] - positions[j]).Mod(), 3);\n                        accelerations[i] = accelerations[i] + (positions[j] - positions[i]) * temp;\n                    }\n                }\n            }\n        }\n\n        private void ComputeVelocities() {\n            for (int i = 0; i < bodies; ++i) {\n                velocities[i] = velocities[i] + accelerations[i];\n            }\n        }\n\n        private void ComputePositions() {\n            for (int i = 0; i < bodies; ++i) {\n                positions[i] = positions[i] + velocities[i] + accelerations[i] * 0.5;\n            }\n        }\n\n        private void ResolveCollisions() {\n            for (int i = 0; i < bodies; ++i) {\n                for (int j = i + 1; j < bodies; ++j) {\n                    if (positions[i].X == positions[j].X\n                     && positions[i].Y == positions[j].Y\n                     && positions[i].Z == positions[j].Z) {\n                        Vector3D temp = velocities[i];\n                        velocities[i] = velocities[j];\n                        velocities[j] = temp;\n                    }\n                }\n            }\n        }\n\n        public void Simulate() {\n            ComputeAccelerations();\n            ComputePositions();\n            ComputeVelocities();\n            ResolveCollisions();\n        }\n\n        public void PrintResults() {\n            for (int i = 0; i < bodies; ++i) {\n                Console.WriteLine(\n                    \"Body {0}\u00a0: {1,9:F6}  {2,9:F6}  {3,9:F6} | {4,9:F6}  {5,9:F6}  {6,9:F6}\",\n                    i + 1,\n                    positions[i].X, positions[i].Y, positions[i].Z,\n                    velocities[i].X, velocities[i].Y, velocities[i].Z\n                );\n            }\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            NBody nb = new NBody(\"nbody.txt\");\n\n            for (int i = 0; i < nb.GetTimeSteps(); ++i) {\n                Console.WriteLine();\n                Console.WriteLine(\"Cycle {0}\", i + 1);\n                nb.Simulate();\n                nb.PrintResults();\n            }\n        }\n    }\n}\n"}
{"id": 400381, "name": "Readline interface", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse Term::ReadLine;\nuse POSIX;\n\nmy $term = Term::ReadLine->new( 'simple Perl shell' );\nmy $attribs = $term->Attribs;\n$attribs->{completion_append_character}     = ' ';\n$attribs->{attempted_completion_function}   = \\&attempt_perl_completion;\n$attribs->{completion_display_matches_hook} = \\&perl_symbol_display_match_list;\n\nwhile (defined(my $command = &reader)) {\n    my @result = eval (\"package main; $command\");\n    print \"$_\\n\" for @result;\n}\n\nsub reader {\n    my $command = $term->readline('> ');\n    $term->addhistory($command) if $command;\n    $command;\n}\n\nsub perl_symbol_display_match_list {\n    my($matches, $num_matches, $max_length) = @_;\n    map { $_ =~ s/^((\\$\n    $term->display_match_list($matches);\n    $term->forced_update_display;\n}\n\nsub attempt_perl_completion {\n    my ($text, $line, $start, $end) = @_;\n    $term->completion_matches($text, \\&perl_symbol_completion_function);\n}\n\nuse vars qw($i @matches $prefix);\nsub perl_symbol_completion_function {\n    my($text, $state) = @_;\n    my %type = ('$' => 'SCALAR', '*' => 'SCALAR', '@' => 'ARRAY', '$\n\n    if ($state) {\n        $i++;\n    } else {\n        my ($pre, $pkg, $sym);\n        $i = 0;\n\n        no strict qw(refs);\n        ($prefix, $pre, $pkg) = ($text =~ m/^((\\$\n        @matches = grep /::$/, $pkg ? keys %$pkg : keys %::;\n        $pkg = '::' unless $pkg;\n        @matches = (@matches, grep (/^\\w+$/ && ($sym = $pkg . $_, defined *$sym{$type{$pre}}), keys %$pkg));\n    }\n    my $entry;\n    for (; $i <= $\n        $entry = $prefix . $matches[$i];\n        return $entry if ($entry =~ /^\\Q$text/);\n    }\n    undef;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n\nnamespace ReadlineInterface {\n    class Program {\n        static LinkedList<string> histArr = new LinkedList<string>();\n\n        static void AppendHistory([CallerMemberName] string name = \"unknown\") {\n            histArr.AddLast(name);\n        }\n\n        static void Hist() {\n            if (histArr.Count == 0) {\n                Console.WriteLine(\"No history\");\n            }\n            else {\n                foreach (string cmd in histArr) {\n                    Console.WriteLine(\" - {0}\", cmd);\n                }\n            }\n            AppendHistory();\n        }\n\n        static void Hello() {\n            Console.WriteLine(\"Hello World!\");\n            AppendHistory();\n        }\n\n        static void Help() {\n            Console.WriteLine(\"Available commands:\");\n            Console.WriteLine(\"  hello\");\n            Console.WriteLine(\"  hist\");\n            Console.WriteLine(\"  exit\");\n            Console.WriteLine(\"  help\");\n            AppendHistory();\n        }\n\n        static void Main(string[] args) {\n            Dictionary<string, Action> cmdDict = new Dictionary<string, Action>();\n            cmdDict.Add(\"help\", Help);\n            cmdDict.Add(\"hist\", Hist);\n            cmdDict.Add(\"hello\", Hello);\n\n            Console.WriteLine(\"Enter a command, type help for a listing.\");\n            while (true) {\n                Console.Write(\">\");\n                string line = Console.ReadLine();\n                if (line==\"exit\") {\n                    break;\n                }\n\n                Action action;\n                if (cmdDict.TryGetValue(line, out action)) {\n                    action.Invoke();\n                } else {\n                    Help();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 400382, "name": "Addition chains", "source": "Translate Perl to C#: use strict;\nuse feature 'say';\n\nmy @Example = ();\n\nsub checkSeq {\n   my($pos, $n, $minLen, @seq) = @_;\n   if ($pos > $minLen || $seq[0] > $n) {\n      return $minLen, 0;\n   } elsif ($seq[0] == $n) {\n      @Example = @seq;\n      return $pos, 1;\n   } elsif ($pos < $minLen) {\n      return tryPerm(0, $pos, $n, $minLen, @seq);\n   } else {\n      return $minLen, 0;\n   }\n}\n\nsub tryPerm {\n   my($i, $pos, $n, $minLen, @seq) = @_;\n   return $minLen, 0 if $i > $pos;\n   my @res1 = checkSeq($pos+1, $n, $minLen, ($seq[0]+$seq[$i],@seq));\n   my @res2 = tryPerm($i+1, $pos, $n, $res1[0], @seq);\n   if ($res2[0] < $res1[0]) {\n      return $res2[0], $res2[1];\n   } elsif ($res2[0] == $res1[0]) {\n      return $res2[0], $res1[1]+$res2[1];\n   } else {\n      say \"Error in tryPerm\";\n      return 0, 0;\n   }\n}\n\nsub initTryPerm {\n   my($x, $minLen) = @_;\n   return tryPerm(0, 0, $x, $minLen, (1));\n}\n\nsub findBrauer {\n   my($num, $minLen, $nbLimit) = @_;\n   my ($actualMin, $brauer) = initTryPerm($num, $minLen);\n   say \"\\nN = \". $num;\n   say \"Minimum length of chains\u00a0: L($num) = $actualMin\";\n   say \"Number of minimum length Brauer chains\u00a0: \". $brauer;\n   say \"Brauer example\u00a0: \". join ' ', reverse @Example if $brauer > 0;\n   @Example = ();\n   if ($num <= $nbLimit) {\n      my $nonBrauer = findNonBrauer($num, $actualMin+1, $brauer);\n      say \"Number of minimum length non-Brauer chains\u00a0: \". $nonBrauer;\n      say \"Non-Brauer example\u00a0: \". join ' ', @Example if $nonBrauer > 0;\n      @Example = ();\n   } else {\n      say \"Non-Brauer analysis suppressed\";\n   }\n}\n\nsub isAdditionChain {\n   my(@a) = @_;\n   for my $i (2 .. $\n      return 0 if $a[$i] > $a[$i-1]*2;\n      my $ok = 0;\n      for my $j (reverse 0 .. $i-1) {\n          for my $k (reverse 0 .. $j) {\n            $ok = 1, last if $a[$j]+$a[$k] == $a[$i];\n         }\n      }\n      return 0 unless $ok;\n   }\n   @Example = @a if !isBrauer(@a) and !@Example;\n   return 1;\n}\n\nsub isBrauer {\n   my(@a) = @_;\n   for my $i (2 .. $\n      my $ok = 0;\n      for my $j (reverse 0 .. $i-1) {\n         $ok = 1, last if $a[$i-1]+$a[$j] == $a[$i];\n      }\n      return 0 unless $ok;\n   }\n   return 1;\n}\n\nsub findNonBrauer {\n   our($num, $len, $brauer) = @_;\n   our @seq = 1 .. $len-1; push @seq, $num;\n   our $count = isAdditionChain(@seq) ? 1 : 0;\n\n   sub nextChains {\n      my($index) = @_;\n      while () {\n         nextChains($index+1) if $index < $len-1;\n         return if ($seq[$index]+$len-1-$index >= $seq[$len-1]);\n         $seq[$index]++;\n         for ($index+1 .. $len-2) { $seq[$_] = $seq[$_-1] + 1;}\n         $count++ if isAdditionChain(@seq);\n      }\n   }\n\n   nextChains(2);\n   return $count - $brauer;\n}\n\nmy @nums = (7, 14, 21, 29, 32, 42, 64);  \n                                         \nsay \"Searching for Brauer chains up to a minimum length of 12:\";\nfor (@nums) { findBrauer $_, 12, 79 }\n", "target": "using System;\n\nnamespace AdditionChains {\n    class Program {\n        static int[] Prepend(int n, int[] seq) {\n            int[] result = new int[seq.Length + 1];\n            Array.Copy(seq, 0, result, 1, seq.Length);\n            result[0] = n;\n            return result;\n        }\n\n        static Tuple<int, int> CheckSeq(int pos, int[] seq, int n, int min_len) {\n            if (pos > min_len || seq[0] > n) return new Tuple<int, int>(min_len, 0);\n            if (seq[0] == n) return new Tuple<int, int>(pos, 1);\n            if (pos < min_len) return TryPerm(0, pos, seq, n, min_len);\n            return new Tuple<int, int>(min_len, 0);\n        }\n\n        static Tuple<int, int> TryPerm(int i, int pos, int[] seq, int n, int min_len) {\n            if (i > pos) return new Tuple<int, int>(min_len, 0);\n\n            Tuple<int, int> res1 = CheckSeq(pos + 1, Prepend(seq[0] + seq[i], seq), n, min_len);\n            Tuple<int, int> res2 = TryPerm(i + 1, pos, seq, n, res1.Item1);\n\n            if (res2.Item1 < res1.Item1) return res2;\n            if (res2.Item1 == res1.Item1) return new Tuple<int, int>(res2.Item1, res1.Item2 + res2.Item2);\n\n            throw new Exception(\"TryPerm exception\");\n        }\n\n        static Tuple<int, int> InitTryPerm(int x) {\n            return TryPerm(0, 0, new int[] { 1 }, x, 12);\n        }\n\n        static void FindBrauer(int num) {\n            Tuple<int, int> res = InitTryPerm(num);\n            Console.WriteLine();\n            Console.WriteLine(\"N = {0}\", num);\n            Console.WriteLine(\"Minimum length of chains: L(n)= {0}\", res.Item1);\n            Console.WriteLine(\"Number of minimum length Brauer chains: {0}\", res.Item2);\n        }\n\n        static void Main(string[] args) {\n            int[] nums = new int[] { 7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379 };\n            Array.ForEach(nums, n => FindBrauer(n));\n        }\n    }\n}\n"}
{"id": 400383, "name": "Just in time processing on a character stream", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse ntheory qw/fromdigits todigitstring/;\n\nmy $key = 'perl5';\nsrand fromdigits($key,36) % 2**63;\n\nmy @stream;\n\nsub stream {\n    my($i) = shift;\n    state @chars;\n    push @chars, chr($_) for 14..127;\n    $stream[$i] = $chars[rand 1+127-14] unless $stream[$i];\n}\n\nsub jit_encode {\n    my($str) = shift;\n    my $i = 0;\n    my $last = 0;\n    my $enc = '';\n    for my $c (split '', $str) {\n        my $h;\n        my $l = '';\n        ++$i until $c eq stream($i);\n        my $o = $i - $last;\n        $l    = $o % 26;\n        $h    = $o - $l if $o > 26;\n        $l   += 10;\n        $enc .= ($h ? uc todigitstring($h,36) : '') . lc todigitstring($l,36);\n        $last = $i;\n    }\n    $enc\n}\n\nsub jit_decode {\n    my($str) = shift;\n    my @matches = $str =~ /((.*?) ([a-z]))/gx;\n    my $dec = '';\n    my $i = 0;\n    for my $j (0 .. @matches/3 - 1) {\n        my $o = ( fromdigits($matches[3*$j+1],36) - 10 // 0) +\n                ( fromdigits($matches[3*$j+2],36)      // 0);\n        $i   += $o;\n        $dec .= $stream[$i];\n    }\n    $dec\n}\n\nmy $enc = jit_encode('The slithey toves did gyre and gimble in the wabe');\nsay my $result = \"Encoded\\n$enc\\n\\nDecoded\\n\" . jit_decode($enc);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace JustInTimeProcessing {\n    struct UserInput {\n        public UserInput(string ff, string lf, string tb, string sp) {\n            FormFeed = (char)int.Parse(ff);\n            LineFeed = (char)int.Parse(lf);\n            Tab = (char)int.Parse(tb);\n            Space = (char)int.Parse(sp);\n        }\n\n        public char FormFeed { get; }\n        public char LineFeed { get; }\n        public char Tab { get; }\n        public char Space { get; }\n    }\n\n    class Program {\n        static List<UserInput> GetUserInput() {\n            string h = \"0 18 0 0 0 68 0 1 0 100 0 32 0 114 0 45 0 38 0 26 0 16 0 21 0 17 0 59 0 11 \"\n                + \"0 29 0 102 0 0 0 10 0 50 0 39 0 42 0 33 0 50 0 46 0 54 0 76 0 47 0 84 2 28\";\n            return h.Split(' ')\n                .Select((x, idx) => new { x, idx })\n                .GroupBy(x => x.idx / 4)\n                \n                .Select(g => {\n                    var ge = g.Select(a => a.x).ToArray();\n                    return new UserInput(ge[0], ge[1], ge[2], ge[3]);\n                })\n                .ToList();\n        }\n\n        static void Decode(string filename, List<UserInput> uiList) {\n            string text = System.IO.File.ReadAllText(filename);\n\n            bool Decode2(UserInput ui) {\n                char f = (char)0;\n                char l = (char)0;\n                char t = (char)0;\n                char s = (char)0;\n\n                foreach (char c in text) {\n                    if (f == ui.FormFeed && l == ui.LineFeed && t == ui.Tab && s == ui.Space) {\n                        if (c == '!') return false;\n                        Console.Write(c);\n                        return true;\n                    }\n                    if (c == '\\u000c') {\n                        f++; l = (char)0; t = (char)0; s = (char)0;\n                    } else if (c == '\\n') {\n                        l++; t = (char)0; s = (char)0;\n                    } else if (c == '\\t') {\n                        t++; s = (char)0;\n                    } else {\n                        s++;\n                    }\n                }\n\n                return false;\n            }\n\n            foreach (UserInput ui in uiList) {\n                if (!Decode2(ui)) {\n                    break;\n                }\n            }\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            var uiList = GetUserInput();\n            Decode(\"theraven.txt\", uiList);\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 400384, "name": "Montgomery reduction", "source": "Translate Perl to C#: use bigint;\nuse ntheory qw(powmod);\n\nsub msb {\n  my ($n, $base) = (shift, 0);\n  $base++ while $n >>= 1;\n  $base;\n}\n\nsub montgomery_reduce {\n    my($m, $a) = @_;\n    for (0 .. msb($m)) {\n        $a += $m if $a & 1;\n        $a >>= 1\n    }\n    $a % $m\n}\n\nmy $m  = 750791094644726559640638407699;\nmy $t1 = 323165824550862327179367294465482435542970161392400401329100;\n\nmy $r1 = 440160025148131680164261562101;\nmy $r2 = 435362628198191204145287283255;\n\nmy $x1 = 540019781128412936473322405310;\nmy $x2 = 515692107665463680305819378593;\n\nprintf \"Original x1:       %s\\n\", $x1;\nprintf \"Recovered from r1: %s\\n\", montgomery_reduce($m, $r1);\nprintf \"Original x2:       %s\\n\", $x2;\nprintf \"Recovered from r2: %s\\n\", montgomery_reduce($m, $r2);\n\nprint \"\\nMontgomery  computation x1**x2 mod m: \";\nmy $prod = montgomery_reduce($m, $t1/$x1);\nmy $base = montgomery_reduce($m, $t1);\n\nfor (my $exponent = $x2; $exponent >= 0; $exponent >>= 1) {\n    $prod = montgomery_reduce($m, $prod * $base) if $exponent & 1;\n    $base = montgomery_reduce($m, $base * $base);\n    last if $exponent == 0;\n}\n\nprint montgomery_reduce($m, $prod) . \"\\n\";\nprintf \"Built-in op computation x1**x2 mod m: %s\\n\", powmod($x1, $x2, $m);\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MontgomeryReduction {\n    public static class Helper {\n        public static int BitLength(this BigInteger v) {\n            if (v < 0) {\n                v *= -1;\n            }\n\n            int result = 0;\n            while (v > 0) {\n                v >>= 1;\n                result++;\n            }\n\n            return result;\n        }\n    }\n\n    struct Montgomery {\n        public static readonly int BASE = 2;\n\n        public BigInteger m;\n        public BigInteger rrm;\n        public int n;\n\n        public Montgomery(BigInteger m) {\n            if (m < 0 || m.IsEven) throw new ArgumentException();\n\n            this.m = m;\n            n = m.BitLength();\n            rrm = (BigInteger.One << (n * 2)) % m;\n        }\n\n        public BigInteger Reduce(BigInteger t) {\n            var a = t;\n\n            for (int i = 0; i < n; i++) {\n                if (!a.IsEven) a += m;\n                a = a >> 1;\n            }\n            if (a >= m) a -= m;\n            return a;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            var m = BigInteger.Parse(\"750791094644726559640638407699\");\n            var x1 = BigInteger.Parse(\"540019781128412936473322405310\");\n            var x2 = BigInteger.Parse(\"515692107665463680305819378593\");\n\n            var mont = new Montgomery(m);\n            var t1 = x1 * mont.rrm;\n            var t2 = x2 * mont.rrm;\n\n            var r1 = mont.Reduce(t1);\n            var r2 = mont.Reduce(t2);\n            var r = BigInteger.One << mont.n;\n\n            Console.WriteLine(\"b\u00a0:  {0}\", Montgomery.BASE);\n            Console.WriteLine(\"n\u00a0:  {0}\", mont.n);\n            Console.WriteLine(\"r\u00a0:  {0}\", r);\n            Console.WriteLine(\"m\u00a0:  {0}\", mont.m);\n            Console.WriteLine(\"t1:  {0}\", t1);\n            Console.WriteLine(\"t2:  {0}\", t2);\n            Console.WriteLine(\"r1:  {0}\", r1);\n            Console.WriteLine(\"r2:  {0}\", r2);\n            Console.WriteLine();\n            Console.WriteLine(\"Original x1      \u00a0: {0}\", x1);\n            Console.WriteLine(\"Recovered from r1\u00a0: {0}\", mont.Reduce(r1));\n            Console.WriteLine(\"Original x2      \u00a0: {0}\", x2);\n            Console.WriteLine(\"Recovered from r2\u00a0: {0}\", mont.Reduce(r2));\n\n            Console.WriteLine();\n            Console.WriteLine(\"Montgomery computation of x1 ^ x2 mod m\u00a0:\");\n            var prod = mont.Reduce(mont.rrm);\n            var @base = mont.Reduce(x1 * mont.rrm);\n            var exp = x2;\n            while (exp.BitLength() > 0) {\n                if (!exp.IsEven) prod = mont.Reduce(prod * @base);\n                exp >>= 1;\n                @base = mont.Reduce(@base * @base);\n            }\n            Console.WriteLine(mont.Reduce(prod));\n            Console.WriteLine();\n            Console.WriteLine(\"Alternate computation of x1 ^ x2 mod m\u00a0:\");\n            Console.WriteLine(BigInteger.ModPow(x1, x2, m));\n        }\n    }\n}\n"}
{"id": 400385, "name": "Sokoban", "source": "Translate Perl to C#: \nuse strict;\nuse warnings qw(FATAL all);\nmy @initial = split /\\n/, <<'';\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=for\nspace is an empty square\n\n@ is the player\n$ is a box\n. is a goal\n+ is the player on a goal\n* is a box on a goal\n=cut\n\n\nmy $cols = length($initial[0]);\nmy $initial = join '', @initial;\nmy $size = length($initial);\ndie unless $size == $cols * @initial;\n\nsub WALL() { 1 }\nsub PLAYER() { 2 }\nsub BOX() { 4 }\nsub GOAL() { 8 }\n\nmy %input = (\n\t' ' => 0, '\n\t'.' => GOAL, '+' => PLAYER|GOAL, '*' => BOX|GOAL,\n);\nmy %output = reverse(%input);\n\nsub packed_initial {\n\tmy $ret = '';\n\tvec( $ret, $_, 4 ) = $input{substr $initial, $_, 1}\n\t\tfor( 0 .. $size-1 );\n\t$ret;\n}\n\nsub printable_board {\n\tmy $board = shift;\n\tmy @c = @output{map vec($board, $_, 4), 0 .. $size-1};\n\tmy $ret = '';\n\twhile( my @row = splice @c, 0, $cols ) {\n\t\t$ret .= join '', @row, \"\\n\";\n\t}\n\t$ret;\n}\n\nmy $packed = packed_initial();\n\nmy @udlr = qw(u d l r);\nmy @UDLR = qw(U D L R);\nmy @deltas = (-$cols, +$cols, -1, +1);\n\nmy %fseen;\nINIT_FORWARD: {\n\t$initial =~ /(\\@|\\+)/ or die;\n\tuse vars qw(@ftodo @fnext);\n\t@ftodo = ([\"\", $packed,  $-[0]]);\n\t$fseen{$packed} = '';\n}\n\nmy %rseen;\nINIT_REVERSE: {\n\tmy $goal = $packed;\n\tvec($goal, $ftodo[0][2], 4) -= PLAYER;\n\tmy @u = grep { my $t = vec($goal, $_, 4); $t & GOAL and not $t & BOX } 0 .. $size-1;\n\tmy @b = grep { my $t = vec($goal, $_, 4); $t & BOX and not $t & GOAL } 0 .. $size-1;\n\tdie unless @u == @b;\n\tvec($goal, $_, 4) += BOX for @u;\n\tvec($goal, $_, 4) -= BOX for @b;\n\tuse vars qw(@rtodo @rnext);\n\tFINAL_PLACE: for my $player (0 .. $size-1) {\n\t\tnext if vec($goal, $player, 4);\n\t\tFIND_GOAL: {\n\t\t\tvec($goal, $player + $_, 4) & GOAL and last FIND_GOAL for @deltas;\n\t\t\tnext FINAL_PLACE;\n\t\t}\n\t\tmy $a_goal = $goal;\n\t\tvec($a_goal, $player, 4) += PLAYER;\n\t\tpush @rtodo, [\"\", $a_goal, $player ];\n\t\t$rseen{$a_goal} = '';\n\t\t\n\t}\n}\n\nmy $movelen = -1;\nmy ($solution);\nMAIN: while( @ftodo and @rtodo ) {\n\n\tFORWARD: {\n\t\tmy ($moves, $level, $player) = @{pop @ftodo};\n\t\tdie unless vec($level, $player, 4) & PLAYER;\n\n\t\tfor my $dir_num (0 .. 3) {\n\t\t\tmy $delta = $deltas[$dir_num];\n\t\t\tmy @loc = map $player + $delta * $_, 0 .. 2;\n\t\t\tmy @val = map vec($level, $_, 4), @loc;\n\n\t\t\tnext if $val[1] & WALL or ($val[1] & BOX and $val[2] & (BOX|WALL));\n\t\t\t\n\t\t\tmy $new = $level;\n\t\t\tvec($new, $loc[0], 4) -= PLAYER;\n\t\t\tvec($new, $loc[1], 4) += PLAYER;\n\t\t\tmy $nmoves;\n\t\t\tif( $val[1] & BOX ) {\n\t\t\t\tvec($new, $loc[1], 4) -= BOX;\n\t\t\t\tvec($new, $loc[2], 4) += BOX;\n\t\t\t\t$nmoves = $moves . $UDLR[$dir_num];\n\t\t\t} else {\n\t\t\t\t$nmoves = $moves . $udlr[$dir_num];\n\t\t\t}\n\t\t\t\n\t\t\tnext if exists $fseen{$new};\n\t\t\t$fseen{$new} = $nmoves;\n\n\t\t\tpush @fnext, [ $nmoves, $new, $loc[1] ];\n\n\t\t\texists $rseen{$new} or next;\n\t\t\t\n\t\t\t$solution = $new;\n\t\t\tlast MAIN;\n\t\t}\n\n\t\tlast FORWARD if @ftodo;\n\t\tuse vars qw(*ftodo *fnext);\n\t\t(*ftodo, *fnext) = (\\@fnext, \\@ftodo);\n\t} \n\t\n\tBACKWARD: {\n\t\tmy ($moves, $level, $player) = @{pop @rtodo};\n\t\tdie \"<$level>\" unless vec($level, $player, 4) & PLAYER;\n\n\t\tfor my $dir_num (0 .. 3) {\n\t\t\tmy $delta = $deltas[$dir_num];\n\t\t\t\n\t\t\tmy @loc = map $player + $delta * $_, -1 .. 1;\n\t\t\tmy @val = map vec($level, $_, 4), @loc;\n\n\t\t\t\n\t\t\tnext if $val[0] & (WALL|BOX);\n\t\t\tmy $new = $level;\n\t\t\tvec($new, $loc[0], 4) += PLAYER;\n\t\t\tvec($new, $loc[1], 4) -= PLAYER;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif( $val[2] & BOX ) {\n\t\t\t\tmy $pull = $new;\n\t\t\t\tvec($pull, $loc[2], 4) -= BOX;\n\t\t\t\tvec($pull, $loc[1], 4) += BOX;\n\t\t\t\tgoto RWALK if exists $rseen{$pull};\n\t\t\t\tmy $pmoves = $UDLR[$dir_num] . $moves;\n\t\t\t\t$rseen{$pull} = $pmoves;\n\t\t\t\tpush @rnext, [$pmoves, $pull, $loc[0]];\n\t\t\t\tgoto RWALK unless exists $fseen{$pull};\n\t\t\t\tprint \"Doing pull\\n\";\n\t\t\t\t$solution = $pull;\n\t\t\t\tlast MAIN;\n\t\t\t}\n\t\t\tRWALK:\n\t\t\tnext if exists $rseen{$new}; \n\t\t\tmy $wmoves = $udlr[$dir_num] . $moves;\n\t\t\t$rseen{$new} = $wmoves;\n\t\t\tpush @rnext, [$wmoves, $new, $loc[0]];\n\t\t\tnext unless exists $fseen{$new};\n\t\t\tprint \"Rwalk\\n\";\n\t\t\t$solution = $new;\n\t\t\tlast MAIN;\n\t\t}\n\n\t\tlast BACKWARD if @rtodo;\n\t\tuse vars qw(*rtodo *rnext);\n\t\t(*rtodo, *rnext) = (\\@rnext, \\@rtodo);\n\t} \n}\n\nif( $solution ) {\n\tmy $fmoves = $fseen{$solution};\n\tmy $rmoves = $rseen{$solution};\n\tprint \"Solution found!\\n\";\n\tprint \"Time: \", (time() - $^T), \" seconds\\n\";\n\tprint \"Moves: $fmoves $rmoves\\n\";\n\tprint \"Move Length: \", length($fmoves . $rmoves), \"\\n\";\n\tprint \"Middle Board: \\n\", printable_board($solution);\n} else {\n\tprint \"No solution found!\\n\";\n}\n", "target": "using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace SokobanSolver\n{\n    public class SokobanSolver\n    {\n        private class Board\n        {\n            public string Cur { get; internal set; }\n            public string Sol { get; internal set; }\n            public int X { get; internal set; }\n            public int Y { get; internal set; }\n\n            public Board(string cur, string sol, int x, int y)\n            {\n                Cur = cur;\n                Sol = sol;\n                X = x;\n                Y = y;\n            }\n        }\n\n        private string destBoard, currBoard;\n        private int playerX, playerY, nCols;\n\n        SokobanSolver(string[] board)\n        {\n            nCols = board[0].Length;\n            StringBuilder destBuf = new StringBuilder();\n            StringBuilder currBuf = new StringBuilder();\n\n            for (int r = 0; r < board.Length; r++)\n            {\n                for (int c = 0; c < nCols; c++)\n                {\n\n                    char ch = board[r][c];\n\n                    destBuf.Append(ch != '$' && ch != '@' ? ch : ' ');\n                    currBuf.Append(ch != '.' ? ch : ' ');\n\n                    if (ch == '@')\n                    {\n                        this.playerX = c;\n                        this.playerY = r;\n                    }\n                }\n            }\n            destBoard = destBuf.ToString();\n            currBoard = currBuf.ToString();\n        }\n\n        private string Move(int x, int y, int dx, int dy, string trialBoard)\n        {\n\n            int newPlayerPos = (y + dy) * nCols + x + dx;\n\n            if (trialBoard[newPlayerPos] != ' ')\n                return null;\n\n            char[] trial = trialBoard.ToCharArray();\n            trial[y * nCols + x] = ' ';\n            trial[newPlayerPos] = '@';\n\n            return new string(trial);\n        }\n\n        private string Push(int x, int y, int dx, int dy, string trialBoard)\n        {\n\n            int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;\n\n            if (trialBoard[newBoxPos] != ' ')\n                return null;\n\n            char[] trial = trialBoard.ToCharArray();\n            trial[y * nCols + x] = ' ';\n            trial[(y + dy) * nCols + x + dx] = '@';\n            trial[newBoxPos] = '$';\n\n            return new string(trial);\n        }\n\n        private bool IsSolved(string trialBoard)\n        {\n            for (int i = 0; i < trialBoard.Length; i++)\n                if ((destBoard[i] == '.')\n                        != (trialBoard[i] == '$'))\n                    return false;\n            return true;\n        }\n\n        private string Solve()\n        {\n            char[,] dirLabels = { { 'u', 'U' }, { 'r', 'R' }, { 'd', 'D' }, { 'l', 'L' } };\n            int[,] dirs = { { 0, -1 }, { 1, 0 }, { 0, 1 }, { -1, 0 } };\n            ISet<string> history = new HashSet<string>();\n            LinkedList<Board> open = new LinkedList<Board>();\n\n            history.Add(currBoard);\n            open.AddLast(new Board(currBoard, string.Empty, playerX, playerY));\n\n            while (!open.Count.Equals(0))\n            {\n                Board item = open.First();\n                open.RemoveFirst();\n                string cur = item.Cur;\n                string sol = item.Sol;\n                int x = item.X;\n                int y = item.Y;\n\n                for (int i = 0; i < dirs.GetLength(0); i++)\n                {\n                    string trial = cur;\n                    int dx = dirs[i, 0];\n                    int dy = dirs[i, 1];\n\n                    \n                    if (trial[(y + dy) * nCols + x + dx] == '$')\n                    {\n                        \n                        if ((trial = Push(x, y, dx, dy, trial)) != null)\n                        {\n                            \n                            if (!history.Contains(trial))\n                            {\n\n                                string newSol = sol + dirLabels[i, 1];\n\n                                if (IsSolved(trial))\n                                    return newSol;\n\n                                open.AddLast(new Board(trial, newSol, x + dx, y + dy));\n                                history.Add(trial);\n                            }\n                        }\n                        \n                    }\n                    else if ((trial = Move(x, y, dx, dy, trial)) != null)\n                    {\n                        if (!history.Contains(trial))\n                        {\n                            string newSol = sol + dirLabels[i, 0];\n                            open.AddLast(new Board(trial, newSol, x + dx, y + dy));\n                            history.Add(trial);\n                        }\n                    }\n                }\n            }\n            return \"No solution\";\n        }\n\n        public static void Main(string[] a)\n        {\n            string level = \"#######,\" +\n                           \"#     #,\" +\n                           \"#     #,\" +\n                           \"#. #  #,\" +\n                           \"#. $$ #,\" +\n                           \"#.$$  #,\" +\n                           \"#.#  @#,\" +\n                           \"#######\";\n            System.Console.WriteLine(\"Level:\\n\");\n            foreach (string line in level.Split(','))\n            {\n                System.Console.WriteLine(line);\n            }\n            System.Console.WriteLine(\"\\nSolution:\\n\");\n            System.Console.WriteLine(new SokobanSolver(level.Split(',')).Solve());\n        }\n    }\n}\n"}
{"id": 400386, "name": "Zumkeller numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <is_prime divisor_sum divisors vecsum forcomb lastfor>;\n\nsub in_columns {\n    my($columns, $values) = @_;\n    my @v = split ' ', $values;\n    my $width = int(80/$columns);\n    printf \"%${width}d\"x$columns.\"\\n\", @v[$_*$columns .. -1+(1+$_)*$columns] for 0..-1+@v/$columns;\n    print \"\\n\";\n}\n\nsub is_Zumkeller {\n    my($n) = @_;\n    return 0 if is_prime($n);\n    my @divisors = divisors($n);\n    return 0 unless @divisors > 2 && 0 == @divisors % 2;\n    my $sigma = divisor_sum($n);\n    return 0 unless 0 == $sigma%2 && ($sigma/2) >= $n;\n    if (1 == $n%2) {\n        return 1\n    } else {\n        my $Z = 0;\n        forcomb { $Z++, lastfor if vecsum(@divisors[@_]) == $sigma/2 } @divisors;\n        return $Z;\n    }\n}\n\nuse constant Inf  => 1e10;\n\nsay 'First 220 Zumkeller numbers:';\nmy $n = 0; my $z;\n$z .= do { $n < 220 ? (is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(20, $z);\n\nsay 'First 40 odd Zumkeller numbers:';\n$n = 0; $z = '';\n$z .= do { $n < 40 ? (!!($_%2) and is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(10, $z);\n\nsay 'First 40 odd Zumkeller numbers not divisible by 5:';\n$n = 0; $z = '';\n$z .= do { $n < 40 ? (!!($_%2 and $_%5) and is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(10, $z);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ZumkellerNumbers {\n    class Program {\n        static List<int> GetDivisors(int n) {\n            List<int> divs = new List<int> {\n                1, n\n            };\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs.Add(j);\n                    }\n                }\n            }\n            return divs;\n        }\n\n        static bool IsPartSum(List<int> divs, int sum) {\n            if (sum == 0) {\n                return true;\n            }\n            var le = divs.Count;\n            if (le == 0) {\n                return false;\n            }\n            var last = divs[le - 1];\n            List<int> newDivs = new List<int>();\n            for (int i = 0; i < le - 1; i++) {\n                newDivs.Add(divs[i]);\n            }\n            if (last > sum) {\n                return IsPartSum(newDivs, sum);\n            }\n            return IsPartSum(newDivs, sum) || IsPartSum(newDivs, sum - last);\n        }\n\n        static bool IsZumkeller(int n) {\n            var divs = GetDivisors(n);\n            var sum = divs.Sum();\n            \n            if (sum % 2 == 1) {\n                return false;\n            }\n            \n            if (n % 2 == 1) {\n                var abundance = sum - 2 * n;\n                return abundance > 0 && abundance % 2 == 0;\n            }\n            \n            return IsPartSum(divs, sum / 2);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The first 220 Zumkeller numbers are:\");\n            int i = 2;\n            for (int count = 0; count < 220; i++) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,3} \", i);\n                    count++;\n                    if (count % 20 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,5} \", i);\n                    count++;\n                    if (count % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers which don't end in 5 are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (i % 10 != 5 && IsZumkeller(i)) {\n                    Console.Write(\"{0,7} \", i);\n                    count++;\n                    if (count % 8 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 400387, "name": "Commatizing numbers", "source": "Translate Perl to C#: @input = (\n    ['pi=3.14159265358979323846264338327950288419716939937510582097494459231', ' ', 5],\n    ['The author has two Z$100000000000000 Zimbabwe notes (100 trillion).', '.'],\n    ['-in Aus$+1411.8millions'],\n    ['===US$0017440 millions=== (in 2000 dollars)'],\n    ['123.e8000 is pretty big.'],\n    ['The land area of the earth is  57268900(29% of the surface)  square miles.'],\n    ['Ain\\'t no numbers in this here words, nohow, no way, Jose.'],\n    ['James was never known as  0000000007'],\n    ['Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.'],\n    ['   $-140000\u00b1100  millions.'],\n    ['5/9/1946 was a good year for some.']\n);\n\nfor $i (@input) {\n    $old = @$i[0];\n    $new = commatize(@$i);\n    printf(\"%s\\n%s\\n\\n\", $old, $new) if $old ne $new;\n}\n\nsub commatize {\n    my($str,$sep,$by) = @_;\n    $sep = ',' unless $sep;\n    $by  = 3   unless $by;\n\n    $str =~ s/                      \n            (?<![eE\\/])             \n            ([1-9]\\d{$by,})         \n            /c_ins($1,$by,$sep)/ex; \n    return $str;\n}\n\nsub c_ins {\n    my($s,$by,$sep) = @_;\n    ($c = reverse $s) =~ s/(.{$by})/$1$sep/g;\n    $c =~ s/$sep$//;\n    return reverse $c;\n}\n", "target": "static string[] inputs = {\n\t\"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n\t\"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n\t\"\\\"-in Aus$+1411.8millions\\\"\",\n\t\"===US$0017440 millions=== (in 2000 dollars)\"\n};\n\nvoid Main()\n{\n\tinputs.Select(s => Commatize(s, 0, 3, \",\"))\n              .ToList()\n              .ForEach(Console.WriteLine);\n}\n\nstring Commatize(string text, int startPosition, int interval, string separator)\n{\n\tvar matches = Regex.Matches(text.Substring(startPosition), \"[0-9]*\");\n\tvar x = matches.Cast<Match>().Select(match => Commatize(match, interval, separator, text)).ToList();\n\treturn string.Join(\"\", x);\n}\n\n\nstring Commatize(Match match, int interval, string separator, string original)\n{\n\tif (match.Length <= interval)\n\t\treturn original.Substring(match.Index, \n                match.Index == original.Length ? 0 : Math.Max(match.Length, 1));\n\t\n\treturn string.Join(separator, match.Value.Split(interval));\n}\n\npublic static class Extension\n{\n\tpublic static string[] Split(this string source, int interval)\n\t{\n\t\treturn SplitImpl(source, interval).ToArray();\n\t}\n\t\n\tstatic IEnumerable<string>SplitImpl(string source, int interval)\n\t{\n\t\tfor\t(int i = 1; i < source.Length; i++)\n\t\t{\n\t\t\tif (i % interval != 0) continue;\n\t\t\t\n\t\t\tyield return source.Substring(i - interval, interval);\n\t\t}\n\t}\n}\n"}
{"id": 400388, "name": "Rare numbers", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse integer;\n\nmy $count = 0;\nmy @squares;\nfor my $large ( 0 .. 1e5 )\n  {\n  my $largesquared = $squares[$large] = $large * $large; \n  for my $small ( 0 .. $large - 1 )\n    {\n    my $n = $largesquared + $squares[$small];\n    2 * $large * $small == reverse $n or next;\n    printf \"%12s %s\\n\", $n, scalar reverse $n;\n    $n == reverse $n and die \"oops!\"; \n    ++$count >= 5 and exit;\n    }\n  }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing UI = System.UInt64;\nusing LST = System.Collections.Generic.List<System.Collections.Generic.List<sbyte>>;\nusing Lst = System.Collections.Generic.List<sbyte>;\nusing DT = System.DateTime;\n\nclass Program {\n\n    const sbyte MxD = 19;\n\n    public struct term { public UI coeff; public sbyte a, b;\n        public term(UI c, int a_, int b_) { coeff = c; a = (sbyte)a_; b = (sbyte)b_; } }\n\n    static int[] digs;   static List<UI> res;   static sbyte count = 0;\n    static DT st; static List<List<term>> tLst; static List<LST> lists;\n    static Dictionary<int, LST> fml, dmd; static Lst dl, zl, el, ol, il;\n    static bool odd; static int nd, nd2; static LST ixs;\n    static int[] cnd, di; static LST dis; static UI Dif;\n\n    \n    static UI ToDif() { UI r = 0; for (int i = 0; i < digs.Length; i++)\n            r = r * 10 + (uint)digs[i]; return r; }\n    \n    \n    static UI ToSum() { UI r = 0; for (int i = digs.Length - 1; i >= 0; i--)\n            r = r * 10 + (uint)digs[i]; return Dif + (r << 1); }\n\n    \n    static bool IsSquare(UI nmbr) { if ((0x202021202030213 & (1 << (int)(nmbr & 63))) != 0)\n        { UI r = (UI)Math.Sqrt((double)nmbr); return r * r == nmbr; } return false; }\n\n    \n    static Lst Seq(sbyte from, int to, sbyte stp = 1) { Lst res = new Lst();\n        for (sbyte item = from; item <= to; item += stp) res.Add(item); return res; }\n\n    \n    static void Fnpr(int lev) { if (lev == dis.Count) { digs[ixs[0][0]] = fml[cnd[0]][di[0]][0];\n            digs[ixs[0][1]] = fml[cnd[0]][di[0]][1]; int le = di.Length, i = 1;\n            if (odd) digs[nd >> 1] = di[--le]; foreach (sbyte d in di.Skip(1).Take(le - 1)) {\n                digs[ixs[i][0]] = dmd[cnd[i]][d][0]; digs[ixs[i][1]] = dmd[cnd[i++]][d][1]; }\n            if (!IsSquare(ToSum())) return; res.Add(ToDif()); WriteLine(\"{0,16:n0}{1,4}   ({2:n0})\",\n                (DT.Now - st).TotalMilliseconds, ++count, res.Last()); }\n        else foreach (var n in dis[lev]) { di[lev] = n; Fnpr(lev + 1); } }\n\n    \n    static void Fnmr (LST list, int lev) { if (lev == list.Count) { Dif = 0; sbyte i = 0;\n            foreach (var t in tLst[nd2]) { if (cnd[i] < 0) Dif -= t.coeff * (UI)(-cnd[i++]);\n                else Dif += t.coeff * (UI)cnd[i++]; } if (Dif <= 0 || !IsSquare(Dif)) return;\n            dis = new LST { Seq(0, fml[cnd[0]].Count - 1) };\n            foreach (int ii in cnd.Skip(1)) dis.Add(Seq(0, dmd[ii].Count - 1));\n            if (odd) dis.Add(il); di = new int[dis.Count]; Fnpr(0);\n        } else foreach(sbyte n in list[lev]) { cnd[lev] = n; Fnmr(list, lev + 1); } }\n\n    static void init() { UI pow = 1;\n        \n        tLst = new List<List<term>>(); foreach (int r in Seq(2, MxD)) {\n            List<term> terms = new List<term>(); pow *= 10; UI p1 = pow, p2 = 1;\n            for (int i1 = 0, i2 = r - 1; i1 < i2; i1++, i2--) {\n                terms.Add(new term(p1 - p2, i1, i2)); p1 /= 10; p2 *= 10; }\n            tLst.Add(terms); }\n        \n        fml = new Dictionary<int, LST> {\n            [0] = new LST { new Lst { 2, 2 }, new Lst { 8, 8 } },\n            [1] = new LST { new Lst { 6, 5 }, new Lst { 8, 7 } },\n            [4] = new LST { new Lst { 4, 0 } },\n            [6] = new LST { new Lst { 6, 0 }, new Lst { 8, 2 } } };\n        \n        dmd = new Dictionary<int, LST>();\n        for (sbyte i = 0; i < 10; i++) for (sbyte j = 0, d = i; j < 10; j++, d--) {\n                if (dmd.ContainsKey(d)) dmd[d].Add(new Lst { i, j });\n                else dmd[d] = new LST { new Lst { i, j } }; }\n        dl = Seq(-9, 9);    \n        zl = Seq( 0, 0);    \n        el = Seq(-8, 8, 2); \n        ol = Seq(-9, 9, 2); \n        il = Seq( 0, 9); lists = new List<LST>();\n        foreach (sbyte f in fml.Keys) lists.Add(new LST { new Lst { f } }); }\n\n    static void Main(string[] args) { init(); res = new List<UI>(); st = DT.Now; count = 0;\n        WriteLine(\"{0,5}{1,12}{2,4}{3,14}\", \"digs\", \"elapsed(ms)\", \"R/N\", \"Unordered Rare Numbers\");\n        for (nd = 2, nd2 = 0, odd = false; nd <= MxD; nd++, nd2++, odd = !odd) { digs = new int[nd];\n            if (nd == 4) { lists[0].Add(zl); lists[1].Add(ol); lists[2].Add(el); lists[3].Add(ol); }\n            else if (tLst[nd2].Count > lists[0].Count) foreach (LST list in lists) list.Add(dl);\n            ixs = new LST(); \n            foreach (term t in tLst[nd2]) ixs.Add(new Lst { t.a, t.b });\n            foreach (LST list in lists) { cnd = new int[list.Count]; Fnmr(list, 0); }\n            WriteLine(\"  {0,2}  {1,10:n0}\", nd, (DT.Now - st).TotalMilliseconds); }\n        res.Sort();\n        WriteLine(\"\\nThe {0} rare numbers with up to {1} digits are:\", res.Count, MxD);\n        count = 0; foreach (var rare in res) WriteLine(\"{0,2}:{1,27:n0}\", ++count, rare);\n        if (System.Diagnostics.Debugger.IsAttached) ReadKey(); }\n}\n"}
{"id": 400389, "name": "Suffix tree", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse Data::Dumper;\n \nsub classify {\n    my $h = {};\n    for (@_) { push @{$h->{substr($_,0,1)}}, $_ }\n    return $h;\n}\nsub suffixes {\n    my $str = shift;\n    map { substr $str, $_ } 0 .. length($str) - 1;\n}\nsub suffix_tree {\n    return +{} if @_ == 0;\n    return +{ $_[0] => +{} } if @_ == 1;\n    my $h = {};\n    my $classif = classify @_;\n    for my $key (keys %$classif) {\n        my $subtree = suffix_tree(\n            map { substr $_, 1 } @{$classif->{$key}}\n        );\n        my @subkeys = keys %$subtree;\n        if (@subkeys == 1) {\n            my ($subkey) = @subkeys;\n            $h->{\"$key$subkey\"} = $subtree->{$subkey};\n        } else { $h->{$key} = $subtree }\n    }\n    return $h;\n}\nprint +Dumper suffix_tree suffixes 'banana$';\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SuffixTree {\n    class Node {\n        public string sub;                     \n        public List<int> ch = new List<int>(); \n\n        public Node() {\n            sub = \"\";\n        }\n\n        public Node(string sub, params int[] children) {\n            this.sub = sub;\n            ch.AddRange(children);\n        }\n    }\n\n    class SuffixTree {\n        readonly List<Node> nodes = new List<Node>();\n\n        public SuffixTree(string str) {\n            nodes.Add(new Node());\n            for (int i = 0; i < str.Length; i++) {\n                AddSuffix(str.Substring(i));\n            }\n        }\n\n        public void Visualize() {\n            if (nodes.Count == 0) {\n                Console.WriteLine(\"<empty>\");\n                return;\n            }\n\n            void f(int n, string pre) {\n                var children = nodes[n].ch;\n                if (children.Count == 0) {\n                    Console.WriteLine(\"- {0}\", nodes[n].sub);\n                    return;\n                }\n                Console.WriteLine(\"+ {0}\", nodes[n].sub);\n\n                var it = children.GetEnumerator();\n                if (it.MoveNext()) {\n                    do {\n                        var cit = it;\n                        if (!cit.MoveNext()) break;\n\n                        Console.Write(\"{0}+-\", pre);\n                        f(it.Current, pre + \"| \");\n                    } while (it.MoveNext());\n                }\n\n                Console.Write(\"{0}+-\", pre);\n                f(children[children.Count-1], pre+\"  \");\n            }\n\n            f(0, \"\");\n        }\n\n        private void AddSuffix(string suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.Length) {\n                char b = suf[i];\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    var children = nodes[n].ch;\n                    if (x2 == children.Count) {\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(suf.Substring(i)));\n                        nodes[n].ch.Add(n2);\n                        return;\n                    }\n                    n2 = children[x2];\n                    if (nodes[n2].sub[0] == b) {\n                        break;\n                    }\n                    x2++;\n                }\n                \n                var sub2 = nodes[n2].sub;\n                int j = 0;\n                while (j < sub2.Length) {\n                    if (suf[i + j] != sub2[j]) {\n                        \n                        var n3 = n2;\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(sub2.Substring(0, j), n3));\n                        nodes[n3].sub = sub2.Substring(j); \n                        nodes[n].ch[x2] = n2;\n                        break; \n                    }\n                    j++;\n                }\n                i += j; \n                n = n2; \n            }\n        }\n    }\n\n    class Program {\n        static void Main() {\n            new SuffixTree(\"banana$\").Visualize();\n        }\n    }\n}\n"}
{"id": 400390, "name": "Suffix tree", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse Data::Dumper;\n \nsub classify {\n    my $h = {};\n    for (@_) { push @{$h->{substr($_,0,1)}}, $_ }\n    return $h;\n}\nsub suffixes {\n    my $str = shift;\n    map { substr $str, $_ } 0 .. length($str) - 1;\n}\nsub suffix_tree {\n    return +{} if @_ == 0;\n    return +{ $_[0] => +{} } if @_ == 1;\n    my $h = {};\n    my $classif = classify @_;\n    for my $key (keys %$classif) {\n        my $subtree = suffix_tree(\n            map { substr $_, 1 } @{$classif->{$key}}\n        );\n        my @subkeys = keys %$subtree;\n        if (@subkeys == 1) {\n            my ($subkey) = @subkeys;\n            $h->{\"$key$subkey\"} = $subtree->{$subkey};\n        } else { $h->{$key} = $subtree }\n    }\n    return $h;\n}\nprint +Dumper suffix_tree suffixes 'banana$';\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace SuffixTree {\n    class Node {\n        public string sub;                     \n        public List<int> ch = new List<int>(); \n\n        public Node() {\n            sub = \"\";\n        }\n\n        public Node(string sub, params int[] children) {\n            this.sub = sub;\n            ch.AddRange(children);\n        }\n    }\n\n    class SuffixTree {\n        readonly List<Node> nodes = new List<Node>();\n\n        public SuffixTree(string str) {\n            nodes.Add(new Node());\n            for (int i = 0; i < str.Length; i++) {\n                AddSuffix(str.Substring(i));\n            }\n        }\n\n        public void Visualize() {\n            if (nodes.Count == 0) {\n                Console.WriteLine(\"<empty>\");\n                return;\n            }\n\n            void f(int n, string pre) {\n                var children = nodes[n].ch;\n                if (children.Count == 0) {\n                    Console.WriteLine(\"- {0}\", nodes[n].sub);\n                    return;\n                }\n                Console.WriteLine(\"+ {0}\", nodes[n].sub);\n\n                var it = children.GetEnumerator();\n                if (it.MoveNext()) {\n                    do {\n                        var cit = it;\n                        if (!cit.MoveNext()) break;\n\n                        Console.Write(\"{0}+-\", pre);\n                        f(it.Current, pre + \"| \");\n                    } while (it.MoveNext());\n                }\n\n                Console.Write(\"{0}+-\", pre);\n                f(children[children.Count-1], pre+\"  \");\n            }\n\n            f(0, \"\");\n        }\n\n        private void AddSuffix(string suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.Length) {\n                char b = suf[i];\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    var children = nodes[n].ch;\n                    if (x2 == children.Count) {\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(suf.Substring(i)));\n                        nodes[n].ch.Add(n2);\n                        return;\n                    }\n                    n2 = children[x2];\n                    if (nodes[n2].sub[0] == b) {\n                        break;\n                    }\n                    x2++;\n                }\n                \n                var sub2 = nodes[n2].sub;\n                int j = 0;\n                while (j < sub2.Length) {\n                    if (suf[i + j] != sub2[j]) {\n                        \n                        var n3 = n2;\n                        \n                        n2 = nodes.Count;\n                        nodes.Add(new Node(sub2.Substring(0, j), n3));\n                        nodes[n3].sub = sub2.Substring(j); \n                        nodes[n].ch[x2] = n2;\n                        break; \n                    }\n                    j++;\n                }\n                i += j; \n                n = n2; \n            }\n        }\n    }\n\n    class Program {\n        static void Main() {\n            new SuffixTree(\"banana$\").Visualize();\n        }\n    }\n}\n"}
{"id": 400391, "name": "Reflection_List properties", "source": "Translate Perl to C#: {\n     package Point;\n     use Class::Spiffy -base;\n\n     field 'x';\n     field 'y';\n}\n\n{\n     package Circle;\n     use base qw(Point);\n     field 'r';\n}\n\nmy $p1 = Point->new(x => 8, y => -5);\nmy $c1 = Circle->new(r => 4);\nmy $c2 = Circle->new(x => 1, y => 2, r => 3);\n\nuse Data::Dumper;\nsay Dumper $p1;\nsay Dumper $c1;\nsay Dumper $c2;\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Reflection;\n\npublic static class Reflection\n{\n    public static void Main() {\n        var t = new TestClass();\n        var flags = BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance;\n        foreach (var prop in GetPropertyValues(t, flags)) {\n            Console.WriteLine(prop);\n        }\n        foreach (var field in GetFieldValues(t, flags)) {\n            Console.WriteLine(field);\n        }\n    }\n\n    public static IEnumerable<(string name, object value)> GetPropertyValues<T>(T obj, BindingFlags flags) =>\n        from p in typeof(T).GetProperties(flags)\n        where p.GetIndexParameters().Length == 0 \n        select (p.Name, p.GetValue(obj, null));\n    \n    public static IEnumerable<(string name, object value)> GetFieldValues<T>(T obj, BindingFlags flags) =>\n        typeof(T).GetFields(flags).Select(f => (f.Name, f.GetValue(obj)));\n    \n    class TestClass\n    {\n        private int privateField = 7;\n        public int PublicNumber { get; } = 4;\n        private int PrivateNumber { get; } = 2;\n    }\n\n}\n"}
{"id": 400392, "name": "Eertree", "source": "Translate Perl to C#: $str = \"eertree\";\n\nfor $n (1 .. length($str)) {\n   for $m (1 .. length($str)) {\n      $strrev = \"\";\n      $strpal = substr($str, $n-1, $m);\n      if ($strpal ne \"\") {\n         for $p (reverse 1 .. length($strpal)) {\n            $strrev .= substr($strpal, $p-1, 1);\n         }\n         ($strpal eq $strrev) and push @pal, $strpal;\n      }\n   }\n}\n\nprint join ' ', grep {not $seen{$_}++} @pal, \"\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Eertree {\n    class Node {\n        public Node(int length) {\n            this.Length = length;\n            \n            this.Edges = new Dictionary<char, int>();\n        }\n\n        public Node(int length, Dictionary<char, int> edges, int suffix) {\n            this.Length = length;\n            this.Edges = edges;\n            this.Suffix = suffix;\n        }\n\n        public int Length { get; set; }\n        public Dictionary<char, int> Edges { get; set; }\n        public int Suffix { get; set; }\n    }\n\n    class Program {\n        const int EVEN_ROOT = 0;\n        const int ODD_ROOT = 1;\n\n        static List<Node> Eertree(string s) {\n            List<Node> tree = new List<Node> {\n                \n                new Node(0, new Dictionary<char, int>(), ODD_ROOT),\n                \n                new Node(-1, new Dictionary<char, int>(), ODD_ROOT)\n            };\n            int suffix = ODD_ROOT;\n            int n, k;\n            for (int i = 0; i < s.Length; i++) {\n                char c = s[i];\n                for (n = suffix; ; n = tree[n].Suffix) {\n                    k = tree[n].Length;\n                    int b = i - k - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                if (tree[n].Edges.ContainsKey(c)) {\n                    suffix = tree[n].Edges[c];\n                    continue;\n                }\n                suffix = tree.Count;\n                tree.Add(new Node(k + 2));\n                tree[n].Edges[c] = suffix;\n                if (tree[suffix].Length == 1) {\n                    tree[suffix].Suffix = 0;\n                    continue;\n                }\n                while (true) {\n                    n = tree[n].Suffix;\n                    int b = i - tree[n].Length - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                tree[suffix].Suffix = tree[n].Edges[c];\n            }\n            return tree;\n        }\n\n        static List<string> SubPalindromes(List<Node> tree) {\n            List<string> s = new List<string>();\n            SubPalindromes_children(0, \"\", tree, s);\n            foreach (var c in tree[1].Edges.Keys) {\n                int m = tree[1].Edges[c];\n                string ct = c.ToString();\n                s.Add(ct);\n                SubPalindromes_children(m, ct, tree, s);\n            }\n            return s;\n        }\n\n        static void SubPalindromes_children(int n, string p, List<Node> tree, List<string> s) {\n            foreach (var c in tree[n].Edges.Keys) {\n                int m = tree[n].Edges[c];\n                string p1 = c + p + c;\n                s.Add(p1);\n                SubPalindromes_children(m, p1, tree, s);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Node> tree = Eertree(\"eertree\");\n            List<string> result = SubPalindromes(tree);\n            string listStr = string.Join(\", \", result);\n            Console.WriteLine(\"[{0}]\", listStr);\n        }\n    }\n}\n"}
{"id": 400393, "name": "Eertree", "source": "Translate Perl to C#: $str = \"eertree\";\n\nfor $n (1 .. length($str)) {\n   for $m (1 .. length($str)) {\n      $strrev = \"\";\n      $strpal = substr($str, $n-1, $m);\n      if ($strpal ne \"\") {\n         for $p (reverse 1 .. length($strpal)) {\n            $strrev .= substr($strpal, $p-1, 1);\n         }\n         ($strpal eq $strrev) and push @pal, $strpal;\n      }\n   }\n}\n\nprint join ' ', grep {not $seen{$_}++} @pal, \"\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace Eertree {\n    class Node {\n        public Node(int length) {\n            this.Length = length;\n            \n            this.Edges = new Dictionary<char, int>();\n        }\n\n        public Node(int length, Dictionary<char, int> edges, int suffix) {\n            this.Length = length;\n            this.Edges = edges;\n            this.Suffix = suffix;\n        }\n\n        public int Length { get; set; }\n        public Dictionary<char, int> Edges { get; set; }\n        public int Suffix { get; set; }\n    }\n\n    class Program {\n        const int EVEN_ROOT = 0;\n        const int ODD_ROOT = 1;\n\n        static List<Node> Eertree(string s) {\n            List<Node> tree = new List<Node> {\n                \n                new Node(0, new Dictionary<char, int>(), ODD_ROOT),\n                \n                new Node(-1, new Dictionary<char, int>(), ODD_ROOT)\n            };\n            int suffix = ODD_ROOT;\n            int n, k;\n            for (int i = 0; i < s.Length; i++) {\n                char c = s[i];\n                for (n = suffix; ; n = tree[n].Suffix) {\n                    k = tree[n].Length;\n                    int b = i - k - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                if (tree[n].Edges.ContainsKey(c)) {\n                    suffix = tree[n].Edges[c];\n                    continue;\n                }\n                suffix = tree.Count;\n                tree.Add(new Node(k + 2));\n                tree[n].Edges[c] = suffix;\n                if (tree[suffix].Length == 1) {\n                    tree[suffix].Suffix = 0;\n                    continue;\n                }\n                while (true) {\n                    n = tree[n].Suffix;\n                    int b = i - tree[n].Length - 1;\n                    if (b >= 0 && s[b] == c) {\n                        break;\n                    }\n                }\n                tree[suffix].Suffix = tree[n].Edges[c];\n            }\n            return tree;\n        }\n\n        static List<string> SubPalindromes(List<Node> tree) {\n            List<string> s = new List<string>();\n            SubPalindromes_children(0, \"\", tree, s);\n            foreach (var c in tree[1].Edges.Keys) {\n                int m = tree[1].Edges[c];\n                string ct = c.ToString();\n                s.Add(ct);\n                SubPalindromes_children(m, ct, tree, s);\n            }\n            return s;\n        }\n\n        static void SubPalindromes_children(int n, string p, List<Node> tree, List<string> s) {\n            foreach (var c in tree[n].Edges.Keys) {\n                int m = tree[n].Edges[c];\n                string p1 = c + p + c;\n                s.Add(p1);\n                SubPalindromes_children(m, p1, tree, s);\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Node> tree = Eertree(\"eertree\");\n            List<string> result = SubPalindromes(tree);\n            string listStr = string.Join(\", \", result);\n            Console.WriteLine(\"[{0}]\", listStr);\n        }\n    }\n}\n"}
{"id": 400394, "name": "Base58Check encoding", "source": "Translate Perl to C#: use Math::BigInt;\n\nsub encode_base58 {\n    my ($num) = @_;\n    $num = Math::BigInt->new($num);\n\n    my $chars = [qw(\n    1 2 3 4 5 6 7 8 9\n    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z\n    a b c d e f g h i j k   m n o p q r s t u v w x y z\n    )];\n\n    my $base58;\n    while ($num->is_pos) {\n        my ($quotient, $remainder) = $num->bdiv(58);\n        $base58 = $chars->[$remainder] . $base58;\n    }\n    $base58\n}\n\nprintf \"%56s -> %s\\n\", $_, encode_base58(+$_)\n    for qw(\n     25420294593250030202636073700053352635053786165627414518\n     0x61\n     0x626262\n     0x636363\n     0x73696d706c792061206c6f6e6720737472696e67\n     0x516b6fcd0f\n     0xbf4f89001e670274dd\n     0x572e4794\n     0xecac89cad93923c02321\n     0x10c8511e\n    );\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Text;\n\nnamespace Base58CheckEncoding {\n    class Program {\n        const string ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        static BigInteger ToBigInteger(string value, int @base) {\n            const string HEX = \"0123456789ABCDEF\";\n            if (@base < 1 || @base > HEX.Length) {\n                throw new ArgumentException(\"Base is out of range.\");\n            }\n\n            BigInteger bi = BigInteger.Zero;\n            foreach (char c in value) {\n                char c2 = Char.ToUpper(c);\n                int idx = HEX.IndexOf(c2);\n                if (idx == -1 || idx >= @base) {\n                    throw new ArgumentOutOfRangeException(\"Illegal character encountered.\");\n                }\n                bi = bi * @base + idx;\n            }\n\n            return bi;\n        }\n\n        static string ConvertToBase58(string hash, int @base = 16) {\n            BigInteger x;\n            if (@base == 16 && hash.Substring(0, 2) == \"0x\") {\n                x = ToBigInteger(hash.Substring(2), @base);\n            } else {\n                x = ToBigInteger(hash, @base);\n            }\n\n            StringBuilder sb = new StringBuilder();\n            while (x > 0) {\n                BigInteger r = x % 58;\n                sb.Append(ALPHABET[(int)r]);\n                x = x / 58;\n            }\n\n            char[] ca = sb.ToString().ToCharArray();\n            Array.Reverse(ca);\n            return new string(ca);\n        }\n\n        static void Main(string[] args) {\n            string s = \"25420294593250030202636073700053352635053786165627414518\";\n            string b = ConvertToBase58(s, 10);\n            Console.WriteLine(\"{0} -> {1}\", s, b);\n\n            List<string> hashes = new List<string>() {\n                \"0x61\",\n                \"0x626262\",\n                \"0x636363\",\n                \"0x73696d706c792061206c6f6e6720737472696e67\",\n                \"0x516b6fcd0f\",\n                \"0xbf4f89001e670274dd\",\n                \"0x572e4794\",\n                \"0xecac89cad93923c02321\",\n                \"0x10c8511e\",\n            };\n            foreach (string hash in hashes) {\n                string b58 = ConvertToBase58(hash);\n                Console.WriteLine(\"{0,-56} -> {1}\", hash, b58);\n            }\n        }\n    }\n}\n"}
{"id": 400395, "name": "Base58Check encoding", "source": "Translate Perl to C#: use Math::BigInt;\n\nsub encode_base58 {\n    my ($num) = @_;\n    $num = Math::BigInt->new($num);\n\n    my $chars = [qw(\n    1 2 3 4 5 6 7 8 9\n    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z\n    a b c d e f g h i j k   m n o p q r s t u v w x y z\n    )];\n\n    my $base58;\n    while ($num->is_pos) {\n        my ($quotient, $remainder) = $num->bdiv(58);\n        $base58 = $chars->[$remainder] . $base58;\n    }\n    $base58\n}\n\nprintf \"%56s -> %s\\n\", $_, encode_base58(+$_)\n    for qw(\n     25420294593250030202636073700053352635053786165627414518\n     0x61\n     0x626262\n     0x636363\n     0x73696d706c792061206c6f6e6720737472696e67\n     0x516b6fcd0f\n     0xbf4f89001e670274dd\n     0x572e4794\n     0xecac89cad93923c02321\n     0x10c8511e\n    );\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Text;\n\nnamespace Base58CheckEncoding {\n    class Program {\n        const string ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        static BigInteger ToBigInteger(string value, int @base) {\n            const string HEX = \"0123456789ABCDEF\";\n            if (@base < 1 || @base > HEX.Length) {\n                throw new ArgumentException(\"Base is out of range.\");\n            }\n\n            BigInteger bi = BigInteger.Zero;\n            foreach (char c in value) {\n                char c2 = Char.ToUpper(c);\n                int idx = HEX.IndexOf(c2);\n                if (idx == -1 || idx >= @base) {\n                    throw new ArgumentOutOfRangeException(\"Illegal character encountered.\");\n                }\n                bi = bi * @base + idx;\n            }\n\n            return bi;\n        }\n\n        static string ConvertToBase58(string hash, int @base = 16) {\n            BigInteger x;\n            if (@base == 16 && hash.Substring(0, 2) == \"0x\") {\n                x = ToBigInteger(hash.Substring(2), @base);\n            } else {\n                x = ToBigInteger(hash, @base);\n            }\n\n            StringBuilder sb = new StringBuilder();\n            while (x > 0) {\n                BigInteger r = x % 58;\n                sb.Append(ALPHABET[(int)r]);\n                x = x / 58;\n            }\n\n            char[] ca = sb.ToString().ToCharArray();\n            Array.Reverse(ca);\n            return new string(ca);\n        }\n\n        static void Main(string[] args) {\n            string s = \"25420294593250030202636073700053352635053786165627414518\";\n            string b = ConvertToBase58(s, 10);\n            Console.WriteLine(\"{0} -> {1}\", s, b);\n\n            List<string> hashes = new List<string>() {\n                \"0x61\",\n                \"0x626262\",\n                \"0x636363\",\n                \"0x73696d706c792061206c6f6e6720737472696e67\",\n                \"0x516b6fcd0f\",\n                \"0xbf4f89001e670274dd\",\n                \"0x572e4794\",\n                \"0xecac89cad93923c02321\",\n                \"0x10c8511e\",\n            };\n            foreach (string hash in hashes) {\n                string b58 = ConvertToBase58(hash);\n                Console.WriteLine(\"{0,-56} -> {1}\", hash, b58);\n            }\n        }\n    }\n}\n"}
{"id": 400396, "name": "Latin Squares in reduced form", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\n\nmy $n = 0;\nmy $count;\nour @perms;\n\nwhile( ++$n <= 7 )\n  {\n  $count = 0;\n  @perms = perm( my $start = join '', 1 .. $n );\n  find( $start );\n  print \"order $n size $count total @{[$count * fact($n) * fact($n-1)]}\\n\\n\";\n  }\n\nsub find\n  {\n  @_ >= $n and return $count += ($n != 4) || print join \"\\n\", @_, \"\\n\";\n  local @perms = grep 0 == ($_[-1] ^ $_) =~ tr/\\0//, @perms;\n  my $row = @_ + 1;\n  find( @_, $_ ) for grep /^$row/, @perms;\n  }\n\nsub fact { $_[0] > 1 ? $_[0] * fact($_[0] - 1) : 1 }\n\nsub perm\n  {\n  my $s = shift;\n  length $s <= 1 ? $s :\n    map { my $f = $_; map \"$f$_\", perm( $s =~ s/$_//r ) } split //, $s;\n  }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LatinSquares {\n    using matrix = List<List<int>>;\n\n    class Program {\n        static void Swap<T>(ref T a, ref T b) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        static matrix DList(int n, int start) {\n            start--; \n            var a = Enumerable.Range(0, n).ToArray();\n            a[start] = a[0];\n            a[0] = start;\n            Array.Sort(a, 1, a.Length - 1);\n            var first = a[1];\n            \n            matrix r = new matrix();\n            void recurse(int last) {\n                if (last == first) {\n                    \n                    \n                    for (int j = 1; j < a.Length; j++) {\n                        var v = a[j];\n                        if (j == v) {\n                            return; \n                        }\n                    }\n                    \n                    var b = a.Select(v => v + 1).ToArray();\n                    r.Add(b.ToList());\n                    return;\n                }\n                for (int i = last; i >= 1; i--) {\n                    Swap(ref a[i], ref a[last]);\n                    recurse(last - 1);\n                    Swap(ref a[i], ref a[last]);\n                }\n            }\n            recurse(n - 1);\n            return r;\n        }\n\n        static ulong ReducedLatinSquares(int n, bool echo) {\n            if (n <= 0) {\n                if (echo) {\n                    Console.WriteLine(\"[]\\n\");\n                }\n                return 0;\n            } else if (n == 1) {\n                if (echo) {\n                    Console.WriteLine(\"[1]\\n\");\n                }\n                return 1;\n            }\n\n            matrix rlatin = new matrix();\n            for (int i = 0; i < n; i++) {\n                rlatin.Add(new List<int>());\n                for (int j = 0; j < n; j++) {\n                    rlatin[i].Add(0);\n                }\n            }\n            \n            for (int j = 0; j < n; j++) {\n                rlatin[0][j] = j + 1;\n            }\n\n            ulong count = 0;\n            void recurse(int i) {\n                var rows = DList(n, i);\n\n                for (int r = 0; r < rows.Count; r++) {\n                    rlatin[i - 1] = rows[r];\n                    for (int k = 0; k < i - 1; k++) {\n                        for (int j = 1; j < n; j++) {\n                            if (rlatin[k][j] == rlatin[i - 1][j]) {\n                                if (r < rows.Count - 1) {\n                                    goto outer;\n                                }\n                                if (i > 2) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    if (i < n) {\n                        recurse(i + 1);\n                    } else {\n                        count++;\n                        if (echo) {\n                            PrintSquare(rlatin, n);\n                        }\n                    }\n                outer: { }\n                }\n            }\n\n            \n            recurse(2);\n            return count;\n        }\n\n        static void PrintSquare(matrix latin, int n) {\n            foreach (var row in latin) {\n                var it = row.GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", {0}\", it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n            Console.WriteLine();\n        }\n\n        static ulong Factorial(ulong n) {\n            if (n <= 0) {\n                return 1;\n            }\n            ulong prod = 1;\n            for (ulong i = 2; i < n + 1; i++) {\n                prod *= i;\n            }\n            return prod;\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The four reduced latin squares of order 4 are:\\n\");\n            ReducedLatinSquares(4, true);\n\n            Console.WriteLine(\"The size of the set of reduced latin squares for the following orders\");\n            Console.WriteLine(\"and hence the total number of latin squares of these orders are:\\n\");\n            for (int n = 1; n < 7; n++) {\n                ulong nu = (ulong)n;\n\n                var size = ReducedLatinSquares(n, false);\n                var f = Factorial(nu - 1);\n                f *= f * nu * size;\n                Console.WriteLine(\"Order {0}: Size {1} x {2}! x {3}! => Total {4}\", n, size, n, n - 1, f);\n            }\n        }\n    }\n}\n"}
{"id": 400397, "name": "Kosaraju", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub kosaraju {\n    our(%k) = @_;\n    our %g = ();\n    our %h;\n    my $i = 0;\n    $g{$_}     = $i++ for sort keys %k;\n    $h{$g{$_}} = $_   for      keys %g; \n\n    our(%visited, @stack, @transpose, @connected);\n    sub visit {\n        my($u) = @_;\n        unless ($visited{$u}) {\n            $visited{$u} = 1;\n            for my $v (@{$k{$u}}) {\n                visit($v);\n                push @{$transpose[$g{$v}]}, $u;\n            }\n            push @stack, $u;\n        }\n    }\n\n    sub assign {\n        my($u, $root) = @_;\n        if ($visited{$u}) {\n            $visited{$u} = 0;\n            $connected[$g{$u}] = $root;\n            assign($_, $root) for @{$transpose[$g{$u}]};\n        }\n    }\n\n    visit($_) for sort keys %g;\n    assign($_, $_) for reverse @stack;\n\n    my %groups;\n    for my $i (0..$\n        my $id = $g{$connected[$i]};\n        push @{$groups{$id}}, $h{$i};\n    }\n    say join ' ', @{$groups{$_}} for sort keys %groups;\n}\n\nmy %test1 = (\n    0 => [1],\n    1 => [2],\n    2 => [0],\n    3 => [1, 2, 4],\n    4 => [3, 5],\n    5 => [2, 6],\n    6 => [5],\n    7 => [4, 6, 7]\n);\n\nmy %test2 = (\n   'Andy' => ['Bart'],\n   'Bart' => ['Carl'],\n   'Carl' => ['Andy'],\n   'Dave' => [<Bart Carl Earl>],\n   'Earl' => [<Dave Fred>],\n   'Fred' => [<Carl Gary>],\n   'Gary' => ['Fred'],\n   'Hank' => [<Earl Gary Hank>]\n);\n\nkosaraju(%test1);\nsay '';\nkosaraju(%test2);\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Node\n{\n\tpublic enum Colors\n\t{\n\t\tBlack, White, Gray\n\t}\n\n\tpublic Colors color { get; set; }\n\tpublic int N { get; }\n\t\n\tpublic Node(int n)\n\t{\n\t\tN = n;\n\t\tcolor = Colors.White;\n\t}\n}\n\nclass Graph\n{\n\tpublic HashSet<Node> V { get; }\n\tpublic Dictionary<Node, HashSet<Node>> Adj { get; }\n\n\t\n\t\n\t\n\tpublic void Kosaraju()\n\t{\n\t\tvar L = new HashSet<Node>();\n\n\t\tAction<Node> Visit = null;\n\t\tVisit = (u) =>\n\t\t{\n\t\t\tif (u.color == Node.Colors.White)\n\t\t\t{\n\t\t\t\tu.color = Node.Colors.Gray;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tVisit(v);\n\n\t\t\t\tL.Add(u);\n\t\t\t}\n\t\t};\n\n\t\tAction<Node, Node> Assign = null;\n\t\tAssign = (u, root) =>\n\t\t{\n\t\t\tif (u.color != Node.Colors.Black)\n\t\t\t{\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.Write(\"SCC: \");\n\n\t\t\t\tConsole.Write(u.N + \" \");\n\t\t\t\tu.color = Node.Colors.Black;\n\n\t\t\t\tforeach (var v in Adj[u])\n\t\t\t\t\tAssign(v, root);\n\n\t\t\t\tif (u == root)\n\t\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t};\n\n\t\tforeach (var u in V)\n\t\t\tVisit(u);\n\n\t\tforeach (var u in L)\n\t\t\tAssign(u, u);\n\t}\n}\n"}
{"id": 400398, "name": "Word search", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature <bitwise>;\nuse Path::Tiny;\nuse List::Util qw( shuffle );\n\nmy $size = 10;\nmy $s1 = $size + 1;\n$_ = <<END;\n.....R....\n......O...\n.......S..\n........E.\nT........T\n.A........\n..C.......\n...O......\n....D.....\n.....E....\nEND\n\nmy @words = shuffle path('/usr/share/dict/words')->slurp =~ /^[a-z]{3,7}$/gm;\nmy @played;\nmy %used;\n\nfor my $word ( (@words) x 5 )\n  {\n  my ($pat, $start, $end, $mask, $nulls) = find( $word );\n  defined $pat or next;\n  $used{$word}++ and next; \n  $nulls //= '';\n  my $expand = $word =~ s/\\B/$nulls/gr;\n  my $pos = $start;\n  if( $start > $end )\n    {\n    $pos = $end;\n    $expand = reverse $expand;\n    }\n  substr $_, $pos, length $mask,\n    (substr( $_, $pos, length $mask ) &. ~. \"$mask\") |. \"$expand\";\n  push @played, join ' ', $word, $start, $end;\n  tr/.// > 0 or last;\n  }\n\nprint \"   0 1 2 3 4 5 6 7 8 9\\n\\n\";\nmy $row = 0;\nprint s/(?<=.)(?=.)/ /gr =~ s/^/ $row++ . '  ' /gemr;\nprint \"\\nNumber of words: \", @played . \"\\n\\n\";\nmy @where = map\n  {\n  my ($word, $start, $end) = split;\n  sprintf \"%11s %s\", $word, $start < $end\n    ? \"(@{[$start\u00a0% $s1]},@{[int $start / $s1]})->\" .\n      \"(@{[$end\u00a0% $s1 - 1]},@{[int $end / $s1]})\"\n    : \"(@{[$start\u00a0% $s1 - 1]},@{[int $start / $s1]})->\" .\n      \"(@{[$end\u00a0% $s1]},@{[int $end / $s1]})\";\n  } sort @played;\nprint splice(@where, 0, 3), \"\\n\" while @where;\ntr/.// and die \"incomplete\";\n\nsub find\n  {\n  my ($word) = @_;\n  my $n = length $word;\n  my $nm1 = $n - 1;\n  my %pats;\n\n  for my $space ( 0, $size - 1 .. $size + 1 )\n    {\n    my $nulls = \"\\0\" x $space;\n    my $mask = \"\\xff\" . ($nulls . \"\\xff\") x $nm1; \n    my $gap = qr/.{$space}/s;\n    while( /(?=(.(?:$gap.){$nm1}))/g )\n      {\n      my $pat = ($1 &. $mask) =~ tr/\\0//dr;\n      $pat =~ tr/.// or next;\n      my $pos = \"$-[1] $+[1]\";\n      $word =~ /$pat/ or reverse($word) =~ /$pat/ or next;\n      push @{ $pats{$pat} }, \"$pos $mask $nulls\";\n      }\n    }\n\n  for my $key ( sort keys %pats )\n    {\n    if( $word =~ /^$key$/ )\n      {\n      my @all = @{ $pats{$key} };\n      return $key, split ' ', $all[ rand @all ];\n      }\n    elsif( (reverse $word) =~ /^$key$/ )\n      {\n      my @all = @{ $pats{$key} };\n      my @parts = split ' ', $all[ rand @all ];\n      return $key, @parts[ 1, 0, 2, 3]\n      }\n    }\n\n  return undef;\n  }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace Wordseach\n{\n    static class Program\n    {\n        readonly static int[,] dirs = {{1, 0}, {0, 1}, {1, 1}, {1, -1}, {-1, 0},\n            {0, -1}, {-1, -1}, {-1, 1}};\n\n        class Grid\n        {\n            public char[,] Cells = new char[nRows, nCols];\n            public List<string> Solutions = new List<string>();\n            public int NumAttempts;\n        }\n\n        readonly static int nRows = 10;\n        readonly static int nCols = 10;\n        readonly static int gridSize = nRows * nCols;\n        readonly static int minWords = 25;\n\n        readonly static Random rand = new Random();\n\n        static void Main(string[] args)\n        {\n            PrintResult(CreateWordSearch(ReadWords(\"unixdict.txt\")));\n        }\n\n        private static List<string> ReadWords(string filename)\n        {\n            int maxLen = Math.Max(nRows, nCols);\n\n            return System.IO.File.ReadAllLines(filename)\n                .Select(s => s.Trim().ToLower())\n                .Where(s => Regex.IsMatch(s, \"^[a-z]{3,\" + maxLen + \"}$\"))\n                .ToList();\n        }\n\n        private static Grid CreateWordSearch(List<string> words)\n        {\n            int numAttempts = 0;\n\n            while (++numAttempts < 100)\n            {\n                words.Shuffle();\n\n                var grid = new Grid();\n                int messageLen = PlaceMessage(grid, \"Rosetta Code\");\n                int target = gridSize - messageLen;\n\n                int cellsFilled = 0;\n                foreach (var word in words)\n                {\n                    cellsFilled += TryPlaceWord(grid, word);\n                    if (cellsFilled == target)\n                    {\n                        if (grid.Solutions.Count >= minWords)\n                        {\n                            grid.NumAttempts = numAttempts;\n                            return grid;\n                        }\n                        else break; \n                    }\n                }\n            }\n            return null;\n        }\n\n        private static int TryPlaceWord(Grid grid, string word)\n        {\n            int randDir = rand.Next(dirs.GetLength(0));\n            int randPos = rand.Next(gridSize);\n\n            for (int dir = 0; dir < dirs.GetLength(0); dir++)\n            {\n                dir = (dir + randDir) % dirs.GetLength(0);\n\n                for (int pos = 0; pos < gridSize; pos++)\n                {\n                    pos = (pos + randPos) % gridSize;\n\n                    int lettersPlaced = TryLocation(grid, word, dir, pos);\n                    if (lettersPlaced > 0)\n                        return lettersPlaced;\n                }\n            }\n            return 0;\n        }\n\n        private static int TryLocation(Grid grid, string word, int dir, int pos)\n        {\n            int r = pos / nCols;\n            int c = pos % nCols;\n            int len = word.Length;\n\n            \n            if ((dirs[dir, 0] == 1 && (len + c) > nCols)\n                    || (dirs[dir, 0] == -1 && (len - 1) > c)\n                    || (dirs[dir, 1] == 1 && (len + r) > nRows)\n                    || (dirs[dir, 1] == -1 && (len - 1) > r))\n                return 0;\n\n            int rr, cc, i, overlaps = 0;\n\n            \n            for (i = 0, rr = r, cc = c; i < len; i++)\n            {\n                if (grid.Cells[rr, cc] != 0 && grid.Cells[rr, cc] != word[i])\n                {\n                    return 0;\n                }\n\n                cc += dirs[dir, 0];\n                rr += dirs[dir, 1];\n            }\n\n            \n            for (i = 0, rr = r, cc = c; i < len; i++)\n            {\n                if (grid.Cells[rr, cc] == word[i])\n                    overlaps++;\n                else\n                    grid.Cells[rr, cc] = word[i];\n\n                if (i < len - 1)\n                {\n                    cc += dirs[dir, 0];\n                    rr += dirs[dir, 1];\n                }\n            }\n\n            int lettersPlaced = len - overlaps;\n            if (lettersPlaced > 0)\n            {\n                grid.Solutions.Add($\"{word,-10} ({c},{r})({cc},{rr})\");\n            }\n\n            return lettersPlaced;\n        }\n\n        private static int PlaceMessage(Grid grid, string msg)\n        {\n            msg = Regex.Replace(msg.ToUpper(), \"[^A-Z]\", \"\");\n\n            int messageLen = msg.Length;\n            if (messageLen > 0 && messageLen < gridSize)\n            {\n                int gapSize = gridSize / messageLen;\n\n                for (int i = 0; i < messageLen; i++)\n                {\n                    int pos = i * gapSize + rand.Next(gapSize);\n                    grid.Cells[pos / nCols, pos % nCols] = msg[i];\n                }\n                return messageLen;\n            }\n            return 0;\n        }\n\n        public static void Shuffle<T>(this IList<T> list)\n        {\n            int n = list.Count;\n            while (n > 1)\n            {\n                n--;\n                int k = rand.Next(n + 1);\n                T value = list[k];\n                list[k] = list[n];\n                list[n] = value;\n            }\n        }\n\n        private static void PrintResult(Grid grid)\n        {\n            if (grid == null || grid.NumAttempts == 0)\n            {\n                Console.WriteLine(\"No grid to display\");\n                return;\n            }\n            int size = grid.Solutions.Count;\n\n            Console.WriteLine(\"Attempts: \" + grid.NumAttempts);\n            Console.WriteLine(\"Number of words: \" + size);\n\n            Console.WriteLine(\"\\n     0  1  2  3  4  5  6  7  8  9\");\n            for (int r = 0; r < nRows; r++)\n            {\n                Console.Write(\"\\n{0}   \", r);\n                for (int c = 0; c < nCols; c++)\n                    Console.Write(\" {0} \", grid.Cells[r, c]);\n            }\n\n            Console.WriteLine(\"\\n\");\n\n            for (int i = 0; i < size - 1; i += 2)\n            {\n                Console.WriteLine(\"{0}   {1}\", grid.Solutions[i],\n                        grid.Solutions[i + 1]);\n            }\n            if (size % 2 == 1)\n                Console.WriteLine(grid.Solutions[size - 1]);\n\n            Console.ReadLine();\n        }        \n    }\n}\n"}
{"id": 400399, "name": "Markov chain text generator", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nmy $file = shift || 'alice_oz.txt';\nmy $n    = shift || 3;\nmy $max  = shift || 200;\n\nsub build_dict {\n    my ($n, @words) = @_;\n    my %dict;\n    for my $i (0 .. $\n        my @prefix = @words[$i .. $i+$n-1];\n        push @{$dict{join ' ', @prefix}}, $words[$i+$n];\n    }\n    return %dict;\n}\n\nsub pick1 { $_[rand @_] }\n\nmy $text = do {\n    open my $fh, '<', $file;\n    local $/;\n    <$fh>;\n};\n\nmy @words = split ' ', $text;\npush @words, @words[0..$n-1];\nmy %dict  = build_dict($n, @words);\nmy @rotor = @words[0..$n-1];\nmy @chain = @rotor;\n\nfor (1 .. $max) {\n    my $new = pick1(@{$dict{join ' ', @rotor}});\n    shift @rotor;\n    push @rotor, $new;\n    push @chain, $new;\n}\n\nprint join(' ', @chain) . \"\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace MarkovChainTextGenerator {\n    class Program {\n        static string Join(string a, string b) {\n            return a + \" \" + b;\n        }\n\n        static string Markov(string filePath, int keySize, int outputSize) {\n            if (keySize < 1) throw new ArgumentException(\"Key size can't be less than 1\");\n\n            string body;\n            using (StreamReader sr = new StreamReader(filePath)) {\n                body = sr.ReadToEnd();\n            }\n            var words = body.Split();\n            if (outputSize < keySize || words.Length < outputSize) {\n                throw new ArgumentException(\"Output size is out of range\");\n            }\n\n            Dictionary<string, List<string>> dict = new Dictionary<string, List<string>>();\n            for (int i = 0; i < words.Length - keySize; i++) {\n                var key = words.Skip(i).Take(keySize).Aggregate(Join);\n                string value;\n                if (i + keySize < words.Length) {\n                    value = words[i + keySize];\n                } else {\n                    value = \"\";\n                }\n\n                if (dict.ContainsKey(key)) {\n                    dict[key].Add(value);\n                } else {\n                    dict.Add(key, new List<string>() { value });\n                }\n            }\n\n            Random rand = new Random();\n            List<string> output = new List<string>();\n            int n = 0;\n            int rn = rand.Next(dict.Count);\n            string prefix = dict.Keys.Skip(rn).Take(1).Single();\n            output.AddRange(prefix.Split());\n\n            while (true) {\n                var suffix = dict[prefix];\n                if (suffix.Count == 1) {\n                    if (suffix[0] == \"\") {\n                        return output.Aggregate(Join);\n                    }\n                    output.Add(suffix[0]);\n                } else {\n                    rn = rand.Next(suffix.Count);\n                    output.Add(suffix[rn]);\n                }\n                if (output.Count >= outputSize) {\n                    return output.Take(outputSize).Aggregate(Join);\n                }\n                n++;\n                prefix = output.Skip(n).Take(keySize).Aggregate(Join);\n            }\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(Markov(\"alice_oz.txt\", 3, 200));\n        }\n    }\n}\n"}
{"id": 400400, "name": "Arithmetic coding_As a generalized change of radix", "source": "Translate Perl to C#: use Math::BigInt (try => 'GMP');\n\nsub cumulative_freq {\n    my ($freq) = @_;\n\n    my %cf;\n    my $total = Math::BigInt->new(0);\n    foreach my $c (sort keys %$freq) {\n        $cf{$c} = $total;\n        $total += $freq->{$c};\n    }\n\n    return %cf;\n}\n\nsub arithmethic_coding {\n    my ($str, $radix) = @_;\n    my @chars = split(//, $str);\n\n    \n    my %freq;\n    $freq{$_}++ for @chars;\n\n    \n    my %cf = cumulative_freq(\\%freq);\n\n    \n    my $base = Math::BigInt->new(scalar @chars);\n\n    \n    my $L = Math::BigInt->new(0);\n\n    \n    my $pf = Math::BigInt->new(1);\n\n    \n    \n    foreach my $c (@chars) {\n        $L->bmuladd($base, $cf{$c} * $pf);\n        $pf->bmul($freq{$c});\n    }\n\n    \n    my $U = $L + $pf;\n\n    my $pow = Math::BigInt->new($pf)->blog($radix);\n    my $enc = ($U - 1)->bdiv(Math::BigInt->new($radix)->bpow($pow));\n\n    return ($enc, $pow, \\%freq);\n}\n\nsub arithmethic_decoding {\n    my ($enc, $radix, $pow, $freq) = @_;\n\n    \n    $enc *= $radix**$pow;\n\n    \n    my $base = Math::BigInt->new(0);\n    $base += $_ for values %{$freq};\n\n    \n    my %cf = cumulative_freq($freq);\n\n    \n    my %dict;\n    while (my ($k, $v) = each %cf) {\n        $dict{$v} = $k;\n    }\n\n    \n    my $lchar;\n    foreach my $i (0 .. $base - 1) {\n        if (exists $dict{$i}) {\n            $lchar = $dict{$i};\n        }\n        elsif (defined $lchar) {\n            $dict{$i} = $lchar;\n        }\n    }\n\n    \n    my $decoded = '';\n    for (my $pow = $base**($base - 1) ; $pow > 0 ; $pow /= $base) {\n        my $div = $enc / $pow;\n\n        my $c  = $dict{$div};\n        my $fv = $freq->{$c};\n        my $cv = $cf{$c};\n\n        $enc = ($enc - $pow * $cv) / $fv;\n        $decoded .= $c;\n    }\n\n    \n    return $decoded;\n}\n\nmy $radix = 10;    \n\nforeach my $str (qw(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT)) {\n    my ($enc, $pow, $freq) = arithmethic_coding($str, $radix);\n    my $dec = arithmethic_decoding($enc, $radix, $pow, $freq);\n\n    printf(\"%-25s=> %19s * %d^%s\\n\", $str, $enc, $radix, $pow);\n\n    if ($str ne $dec) {\n        die \"\\tHowever that is incorrect!\";\n    }\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\n\nnamespace AruthmeticCoding {\n    using Freq = Dictionary<char, long>;\n    using Triple = Tuple<BigInteger, int, Dictionary<char, long>>;\n\n    class Program {\n        static Freq CumulativeFreq(Freq freq) {\n            long total = 0;\n            Freq cf = new Freq();\n            for (int i = 0; i < 256; i++) {\n                char c = (char)i;\n                if (freq.ContainsKey(c)) {\n                    long v = freq[c];\n                    cf[c] = total;\n                    total += v;\n                }\n            }\n            return cf;\n        }\n\n        static Triple ArithmeticCoding(string str, long radix) {\n            \n            Freq freq = new Freq();\n            foreach (char c in str) {\n                if (freq.ContainsKey(c)) {\n                    freq[c] += 1;\n                } else {\n                    freq[c] = 1;\n                }\n            }\n\n            \n            Freq cf = CumulativeFreq(freq);\n\n            \n            BigInteger @base = str.Length;\n\n            \n            BigInteger lower = 0;\n\n            \n            BigInteger pf = 1;\n\n            \n            \n            foreach (char c in str) {\n                BigInteger x = cf[c];\n                lower = lower * @base + x * pf;\n                pf = pf * freq[c];\n            }\n\n            \n            BigInteger upper = lower + pf;\n\n            int powr = 0;\n            BigInteger bigRadix = radix;\n\n            while (true) {\n                pf = pf / bigRadix;\n                if (pf == 0) break;\n                powr++;\n            }\n\n            BigInteger diff = (upper - 1) / (BigInteger.Pow(bigRadix, powr));\n            return new Triple(diff, powr, freq);\n        }\n\n        static string ArithmeticDecoding(BigInteger num, long radix, int pwr, Freq freq) {\n            BigInteger powr = radix;\n            BigInteger enc = num * BigInteger.Pow(powr, pwr);\n            long @base = freq.Values.Sum();\n\n            \n            Freq cf = CumulativeFreq(freq);\n\n            \n            Dictionary<long, char> dict = new Dictionary<long, char>();\n            foreach (char key in cf.Keys) {\n                long value = cf[key];\n                dict[value] = key;\n            }\n\n            \n            long lchar = -1;\n            for (long i = 0; i < @base; i++) {\n                if (dict.ContainsKey(i)) {\n                    lchar = dict[i];\n                } else if (lchar != -1) {\n                    dict[i] = (char)lchar;\n                }\n            }\n\n            \n            StringBuilder decoded = new StringBuilder((int)@base);\n            BigInteger bigBase = @base;\n            for (long i = @base - 1; i >= 0; --i) {\n                BigInteger pow = BigInteger.Pow(bigBase, (int)i);\n                BigInteger div = enc / pow;\n                char c = dict[(long)div];\n                BigInteger fv = freq[c];\n                BigInteger cv = cf[c];\n                BigInteger diff = enc - pow * cv;\n                enc = diff / fv;\n                decoded.Append(c);\n            }\n\n            \n            return decoded.ToString();\n        }\n\n        static void Main(string[] args) {\n            long radix = 10;\n            string[] strings = { \"DABDDB\", \"DABDDBBDDBA\", \"ABRACADABRA\", \"TOBEORNOTTOBEORTOBEORNOT\" };\n            foreach (string str in strings) {\n                Triple encoded = ArithmeticCoding(str, radix);\n                string dec = ArithmeticDecoding(encoded.Item1, radix, encoded.Item2, encoded.Item3);\n                Console.WriteLine(\"{0,-25}=> {1,19} * {2}^{3}\", str, encoded.Item1, radix, encoded.Item2);\n                if (str != dec) {\n                    throw new Exception(\"\\tHowever that is incorrect!\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 400401, "name": "Free polyominoes enumeration", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\n\nmy @new = \"\n\nfor my $N ( 2 .. 10 )\n  {\n  @new = find( @new );\n  my %allbest;\n  $allbest{best($_)}++ for @new;\n  my @show = @new = sort keys %allbest;\n  printf \"rank: %2d  count: %d\\n\\n\", $N, scalar @show;\n  if( @show <= 12 )\n    {\n    my $fmt = join '', map({ /\\n/; '%' . ($+[0] + 1) . 's' } @show), \"\\n\";\n    grep $_, @show and printf $fmt, map s/(.*)\\n// && $1, @show for 0 .. $N;\n    print \"\\n\";\n    }\n  }\n\nsub bare\n  {\n  local $_ = shift;\n  s/^ *\\n//gm;\n  s/^ //gm until /^\n  s/ $//gm until /\n  $_;\n  }\n\nsub transpose\n  {\n  local $_ = shift;\n  my $t = '';\n  $t .= \"\\n\" while s/^./ $t .= $&; '' /gem;\n  $t;\n  }\n\nsub rotate\n  {\n  local $_ = shift;\n  my $t = '';\n  $t .= \"\\n\" while s/.$/ $t .= $&; '' /gem;\n  $t;\n  }\n\nsub best\n  {\n  my %all = (shift, 1);\n  for my $p (keys %all)\n    {\n    $all{ my $tmp = rotate $p }++;\n    $all{ rotate $tmp }++;\n    }\n  $all{ transpose $_ }++ for keys %all;\n  $all{ s/(.+)/reverse $1/ger }++ for keys %all;        \n  (sort keys %all)[-1];\n  }\n\nsub find\n  {\n  my @before = @_;\n  my %new;\n  for my $p ( @before )\n    {\n    local $_ = $p;\n    s/^/ /gm;\n    s/\\n/ \\n/g;\n    my $line = s/\\n.*/\\n/sr =~ tr/\\n/ /cr;\n    $_ = $line . $_ . $line;\n    my $n = -1 + length $line;\n    my $gap = qr/.{$n}/s;\n    $new{ bare \"$`\n    $new{ bare \"$`\n    $new{ bare \"$`\n    $new{ bare \"$`\n    }\n  keys %new;\n  }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace cppfpe\n{\n    class Program\n    {\n        static int n, ns;               \n        static long[] AnyR;             \n        static long[] nFlip;            \n        static long[] Frees;            \n        static int[] fChk, fCkR;        \n        static int fSiz, fWid;          \n        static int[] dirs;              \n        static int[] rotO, rotX, rotY;  \n        static List<string> polys;      \n        static int target;              \n        static int clipAt;              \n\n        static int Main(string[] args)\n        {\n            polys = new List<string>();\n            n = 11; if (!(args.Length == 0)) int.TryParse(args[0], out n);\n            if (n < 1 || n > 24) return 1;\n            target = 5;\n            Console.WriteLine(\"Counting polyominoes to rank {0}...\", n);\n            clipAt = 120;\n            DateTime start = DateTime.Now;\n            CountEm();\n            TimeSpan ti = DateTime.Now - start;\n            if (polys.Count > 0)\n            {\n                Console.WriteLine(\"Displaying rank {0}:\", target);\n                Console.WriteLine(Assemble(polys));\n            }\n            Console.WriteLine(\"Displaying results:\");\n            Console.WriteLine(\" n      All Rotations     Non-Flipped      Free Polys\");\n            for (int i = 1; i <= n; i++)\n                Console.WriteLine(\"{0,2}\u00a0:{1,17}{2,16}{3,16}\", i, AnyR[i], nFlip[i], Frees[i]);\n            Console.WriteLine(string.Format(\"Elasped: {0,2}d {1,2}h {2,2}m {3:00}s {4:000}ms\",\n                              ti.Days, ti.Hours, ti.Minutes, ti.Seconds, ti.Milliseconds).Replace(\"  0d \", \"\")\n                              .Replace(\" 0h\", \"\").Replace(\" 0m\", \"\").Replace(\" 00s\", \"\"));\n            long ms = (long)ti.TotalMilliseconds, lim = int.MaxValue >> 2;\n            if (ms > 250)\n            {\n                Console.WriteLine(\"Estimated completion times:\");\n                for (int i = n + 1; i <= n + 10; i++)\n                {\n                    if (ms >= lim) break; ms += 44; ms <<= 2; ti = TimeSpan.FromMilliseconds(ms);\n                    Console.WriteLine(\"{0,2}\u00a0: {1,2}d {2,2}h {3,2}m {4:00}.{5:000}s\", i, \n                        ti.Days, ti.Hours, ti.Minutes, ti.Seconds, ti.Milliseconds);\n                }\n            }\n            if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n            return 0;\n        }\n\n        static void CountEm()\n        {\n            ns = n * n;\n            AnyR = new long[n + 1];\n            nFlip = new long[n + 1];\n            Frees = new long[n + 1];\n            fWid = n * 2 - 2;\n            fSiz = (n - 1) * (n - 1) * 2 + 1;\n            int[] pnField = new int[fSiz];\n            int[] pnPutList = new int[fSiz];\n            fChk = new int[ns];\n            fCkR = new int[ns];\n            dirs = new int[] { 1, fWid, -1, -fWid };\n            rotO = new int[] { 0, n - 1, ns - 1, ns - n, n - 1, 0, ns - n, ns - 1 };\n            rotX = new int[] { 1, n, -1, -n, -1, n, 1, -n };\n            rotY = new int[] { n, -1, -n, 1, n, 1, -n, -1 };\n            Recurse(0, pnField, pnPutList, 0, 1);\n        }\n\n        static void Recurse(int lv, int[] field, int[] putlist, int putno, int putlast)\n        {\n            CheckIt(field, lv);\n            if (n == lv) return;\n            int pos;\n            for (int i = putno; i < putlast; i++)\n            {\n                field[pos = putlist[i]] |= 1;\n                int k = 0;\n                foreach (int dir in dirs)\n                {\n                    int pos2 = pos + dir;\n                    if (0 <= pos2 && pos2 < fSiz && (field[pos2] == 0))\n                    {\n                        field[pos2] = 2;\n                        putlist[putlast + k++] = pos2;\n                    }\n                }\n                Recurse(lv + 1, field, putlist, i + 1, putlast + k);\n                for (int j = 0; j < k; j++) field[putlist[putlast + j]] = 0;\n                field[pos] = 2;\n            }\n            for (int i = putno; i < putlast; i++) field[putlist[i]] &= -2;\n        }\n\n        static void CheckIt(int[] field, int lv)\n        {\n            AnyR[lv]++;\n            for (int i = 0; i < ns; i++) fChk[i] = 0;\n            int x, y;\n            for (x = n; x < fWid; x++)\n                for (y = 0; y + x < fSiz; y += fWid)\n                    if ((field[x + y] & 1) == 1) goto bail;\n            bail:\n            int x2 = n - x, t;\n            for (int i = 0; i < fSiz; i++)\n                if ((field[i] & 1) == 1) fChk[((t = (i + n - 2)) % fWid) + x2 + (t / fWid * n)] = 1;\n            int of1; for (of1 = 0; of1 < fChk.Length && (fChk[of1] == 0); of1++) ;\n            bool c = true; int r;\n            for (r = 1; r < 8 && c; r++)\n            {\n                for (x = 0; x < n; x++) for (y = 0; y < n; y++)\n                        fCkR[rotO[r] + rotX[r] * x + rotY[r] * y] = fChk[x + y * n];\n                int of2; for (of2 = 0; of2 < fCkR.Length && (fCkR[of2] == 0); of2++) ;\n                of2 -= of1;\n                for (int i = of1; i < ns - ((of2 > 0) ? of2 : 0); i++)\n                {\n                    if (fChk[i] > fCkR[i + of2]) break;\n                    if (fChk[i] < fCkR[i + of2]) { c = false; break; }\n                }\n            }\n            if (r > 4) nFlip[lv]++;\n            if (c)\n            {\n                if (lv == target) polys.Add(toStr(field.ToArray()));\n                Frees[lv]++;\n            }\n        }\n\n        static string toStr(int[] field) \n        {\n            char [] res = new string(' ', n * (fWid + 1) - 1).ToCharArray();\n            for (int i = fWid; i < res.Length; i += fWid+1) res[i] = '\\n';\n            for (int i = 0, j = n - 2; i < field.Length; i++, j++)\n            {\n                if ((field[i] & 1) == 1) res[j] = '#';\n                if (j % (fWid + 1) == fWid) i--;\n            }\n            List<string> t = new string(res).Split('\\n').ToList();\n            int nn = 100, m = 0, v, k = 0; \n            foreach (string s in t)\n            {\n                if ((v = s.IndexOf('#')) < nn) if (v >= 0) nn = v;\n                if ((v = s.LastIndexOf('#')) > m) if (v < fWid +1) m = v;\n                if (v < 0) break; k++;\n            }\n            m = m - nn + 1; \n            for (int i = t.Count - 1; i >= 0; i--)\n            {\n                if (i >= k) t.RemoveAt(i);\n                else t[i] = t[i].Substring(nn, m);\n            }\n            return String.Join(\"\\n\", t.ToArray());\n        }\n\n        \n        static string Assemble(List<string> p)\n        {\n            List<string> lines = new List<string>();\n            for (int i = 0; i < target; i++) lines.Add(string.Empty);\n            foreach (string poly in p)\n            {\n                List<string> t = poly.Split('\\n').ToList();\n                if (t.Count < t[0].Length) t = flipXY(t);\n                for (int i = 0; i < lines.Count; i++)\n                    lines[i] += (i < t.Count) ? ' ' + t[i] + ' ': new string(' ', t[0].Length + 2);\n            }\n            for (int i = lines.Count - 1; i > 0; i--)\n                if (lines[i].IndexOf('#') < 0) lines.RemoveAt(i);\n            if (lines[0].Length >= clipAt / 2-2) Wrap(lines, clipAt / 2-2);\n            lines = Cornered(string.Join(\"\\n\", lines.ToArray())).Split('\\n').ToList();\n            return String.Join(\"\\n\", lines.ToArray());\n        }\n\n        static List<string> flipXY(List<string> p)  \n        {\n            List<string> res = new List<string>();\n            for (int i = 0; i < p[0].Length; i++) res.Add(string.Empty);\n            for (int i = 0; i < res.Count; i++)\n                for(int j = 0; j < p.Count; j++) res[i] += p[j][i];\n            return res;\n        }\n\n        static string DW(string s)  \n        {\n            string t = string.Empty;\n            foreach (char c in s) t += string.Format(\"{0}{0}\",c);\n            return t;\n        }\n\n        static void Wrap(List<string> s, int w) \n        {\n            int last = 0;\n            while (s.Last().Length >= w)\n            {\n                int x = w, lim = s.Count; bool ok;\n                do\n                {\n                    ok = true;\n                    for (int i = last; i < lim; i++)\n                        if (s[i][x] != ' ')\n                        { ok = false; x--; break; }\n                } while (!ok);\n                for (int i = last; i < lim; i++)\n                    if (s[i].Length > x) { s.Add(s[i].Substring(x)); s[i] = s[i].Substring(0, x + 1); }\n                last = lim;\n            }\n            last = 0;\n            for (int i = s.Count - 1; i > 0; i--)\n                if ((last = (s[i].IndexOf('#') < 0) ? last + 1 : 0) > 1) s.RemoveAt(i + 1);\n        }\n\n        static string Cornered(string s)    \n        {\n            string[] lines = s.Split('\\n');\n            string res = string.Empty;\n            string line = DW(new string(' ', lines[0].Length)), last;\n            for (int i = 0; i < lines.Length; i++)\n            {\n                last = line; line = DW(lines[i]);\n                res += Puzzle(last, line) + '\\n';\n            }\n            res += Puzzle(line, DW(new string(' ', lines.Last().Length))) + '\\n';\n            return res;\n        }\n\n        static string Puzzle(string a, string b)    \n        {\n            string res = string.Empty;\n            if (a.Length > b.Length) b += new string(' ', a.Length - b.Length);\n            if (a.Length < b.Length) a += new string(' ', b.Length - a.Length);\n            for (int i = 0; i < a.Length - 1; i++)\n                res += \" 12\u25144\u2518\u2500\u25348\u2502\u250c\u251c\u2510\u2524\u252c\u253c\"[(a[i] == a[i + 1] ? 0 : 1) + \n                                          (b[i + 1] == a[i + 1] ? 0 : 2) +\n                                          (a[i] == b[i] ? 0 : 4) + \n                                          (b[i] == b[i + 1] ? 0 : 8)];\n            return res;\n        }\n    }\n}\n"}
{"id": 400402, "name": "Particle swarm optimization", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nuse constant PI  => 2 * atan2(1, 0);\nuse constant Inf => 1e10;\n\nsub pso_init {\n    my(%y) = @_;\n    my $d = @{$y{'min'}};\n    my $n = $y{'n'};\n\n    $y{'gbval'} = Inf;\n    $y{'gbpos'} = [(Inf) x $d];\n    $y{'bval'}  = [(Inf) x $n];\n    $y{'bpos'}  = [($y{'min'}) x $n];\n    $y{'pos'}   = [($y{'min'}) x $n];\n    $y{'vel'}   = [([(0) x $d]) x $n];\n\n    %y\n}\n\nsub pso {\n    my($fn, %y) = @_;\n    my $p      = $y{'p'};\n    my $n      = $y{'n'};\n    my $d      = @{$y{'min'}};\n    my @bpos   = ($y{'min'}) x $n;\n    my $gbval  = Inf;\n    my $rand_g = rand;\n    my (@pos, @vel, @v, @gbpos, @bval);\n\n    for my $j (0 .. $n-1) {\n        $v[$j] = &$fn(@{$y{'pos'}[$j]}); \n\n        \n        if ($v[$j] < $y{'bval'}[$j]) {\n            $bpos[$j] = $y{'pos'}[$j];\n            $bval[$j] = $v[$j];\n        } else {\n            $bpos[$j] = $y{'bpos'}[$j];\n            $bval[$j] = $y{'bval'}[$j];\n        }\n        if ($bval[$j] < $gbval) {\n            @gbpos = @{$bpos[$j]};\n            $gbval = $bval[$j];\n        }\n    }\n\n    \n    for my $j (0 .. $n-1) {\n        my $rand_p = rand;\n        my $ok = 1;\n        for my $k (0 .. $d-1) {\n            $vel[$j][$k] = $$p{'omega'} * $y{'vel'}[$j][$k]\n                       + $$p{'phi_p'} * $rand_p * ($bpos[$j][$k] - $y{'pos'}[$j][$k])\n                       + $$p{'phi_g'} * $rand_g * ($gbpos[$k]    - $y{'pos'}[$j][$k]);\n            $pos[$j][$k] = $y{'pos'}[$j][$k] + $vel[$j][$k];\n            $ok = ($y{'min'}[$k] < $pos[$j][$k]) && ($pos[$j][$k] < $y{'max'}[$k]) && $ok;\n        }\n        next if $ok;\n        $pos[$j][$_] = $y{'min'}[$_] + ($y{'max'}[$_] - $y{'min'}[$_]) * rand for 0 .. $d-1;\n    }\n    return {gbpos => \\@gbpos, gbval => $gbval, bpos => \\@bpos, bval => \\@bval, pos => \\@pos, vel => \\@vel,\n               min => $y{'min'}, max => $y{'max'}, p=> $y{'p'}, n => $n};\n}\n\nsub report {\n    my($function_name, %state) = @_;\n    say $function_name;\n    say 'Global best position: ' . sprintf \"%.5f\u00a0%.5f\", @{$state{'gbpos'}};\n    say 'Global best value:    ' . sprintf \"%.5f\",      $state{'gbval'};\n    say '';\n}\n\n\nsub mccormick {\n    my($a,$b) = @_;\n    sin($a+$b) + ($a-$b)**2 + (1 + 2.5*$b - 1.5*$a)\n}\n\nmy %state = pso_init( (\n    min => [-1.5, -3],\n    max => [4, 4],\n    n   => 100,\n    p   => {omega => 0, phi_p => 0.6, phi_g => 0.3},\n) );\n%state = %{pso(\\&mccormick, %state)} for 1 .. 40;\nreport('McCormick', %state);\n\n\nsub michalewicz {\n    my(@x) = @_;\n    my $sum;\n    my $m = 10;\n    for my $i (1..@x) {\n        my $j = $x[$i - 1];\n        my $k = sin($i * $j**2/PI);\n        $sum += sin($j) * $k**(2*$m)\n    }\n    -$sum\n}\n\n%state = pso_init( (\n    min => [0, 0],\n    max => [PI, PI],\n    n   => 1000,\n    p   => {omega => 0.3, phi_p => 0.3, phi_g => 0.3},\n) );\n%state = %{pso(\\&michalewicz, %state)} for 1 .. 30;\nreport('Michalewicz', %state);\n", "target": "using System;\n\nnamespace ParticleSwarmOptimization {\n    public struct Parameters {\n        public double omega, phip, phig;\n\n        public Parameters(double omega, double phip, double phig) : this() {\n            this.omega = omega;\n            this.phip = phip;\n            this.phig = phig;\n        }\n    }\n\n    public struct State {\n        public int iter;\n        public double[] gbpos;\n        public double gbval;\n        public double[] min;\n        public double[] max;\n        public Parameters parameters;\n        public double[][] pos;\n        public double[][] vel;\n        public double[][] bpos;\n        public double[] bval;\n        public int nParticles;\n        public int nDims;\n\n        public State(int iter, double[] gbpos, double gbval, double[] min, double[] max, Parameters parameters, double[][] pos, double[][] vel, double[][] bpos, double[] bval, int nParticles, int nDims) : this() {\n            this.iter = iter;\n            this.gbpos = gbpos;\n            this.gbval = gbval;\n            this.min = min;\n            this.max = max;\n            this.parameters = parameters;\n            this.pos = pos;\n            this.vel = vel;\n            this.bpos = bpos;\n            this.bval = bval;\n            this.nParticles = nParticles;\n            this.nDims = nDims;\n        }\n\n        public void Report(string testfunc) {\n            Console.WriteLine(\"Test Function       \u00a0: {0}\", testfunc);\n            Console.WriteLine(\"Iterations          \u00a0: {0}\", iter);\n            Console.WriteLine(\"Global Best Position\u00a0: {0}\", string.Join(\", \", gbpos));\n            Console.WriteLine(\"Global Best Value   \u00a0: {0}\", gbval);\n        }\n    }\n\n    class Program {\n        public static State PsoInit(double[] min, double[] max, Parameters parameters, int nParticles) {\n            var nDims = min.Length;\n            double[][] pos = new double[nParticles][];\n            for (int i = 0; i < nParticles; i++) {\n                pos[i] = new double[min.Length];\n                min.CopyTo(pos[i], 0);\n            }\n            double[][] vel = new double[nParticles][];\n            for (int i = 0; i < nParticles; i++) {\n                vel[i] = new double[nDims];\n            }\n            double[][] bpos = new double[nParticles][];\n            for (int i = 0; i < nParticles; i++) {\n                bpos[i] = new double[min.Length];\n                min.CopyTo(bpos[i], 0);\n            }\n            double[] bval = new double[nParticles];\n            for (int i = 0; i < nParticles; i++) {\n                bval[i] = double.PositiveInfinity;\n            }\n            int iter = 0;\n            double[] gbpos = new double[nDims];\n            for (int i = 0; i < nDims; i++) {\n                gbpos[i] = double.PositiveInfinity;\n            }\n            double gbval = double.PositiveInfinity;\n\n            return new State(iter, gbpos, gbval, min, max, parameters, pos, vel, bpos, bval, nParticles, nDims);\n        }\n\n        static Random r = new Random();\n\n        public static State Pso(Func<double[], double> fn, State y) {\n            var p = y.parameters;\n            double[] v = new double[y.nParticles];\n            double[][] bpos = new double[y.nParticles][];\n            for (int i = 0; i < y.nParticles; i++) {\n                bpos[i] = new double[y.min.Length];\n                y.min.CopyTo(bpos[i], 0);\n            }\n            double[] bval = new double[y.nParticles];\n            double[] gbpos = new double[y.nDims];\n            double gbval = double.PositiveInfinity;\n            for (int j = 0; j < y.nParticles; j++) {\n                \n                v[j] = fn.Invoke(y.pos[j]);\n                \n                if (v[j] < y.bval[j]) {\n                    y.pos[j].CopyTo(bpos[j], 0);\n                    bval[j] = v[j];\n                }\n                else {\n                    y.bpos[j].CopyTo(bpos[j], 0);\n                    bval[j] = y.bval[j];\n                }\n                if (bval[j] < gbval) {\n                    gbval = bval[j];\n                    bpos[j].CopyTo(gbpos, 0);\n                }\n            }\n            double rg = r.NextDouble();\n            double[][] pos = new double[y.nParticles][];\n            double[][] vel = new double[y.nParticles][];\n            for (int i = 0; i < y.nParticles; i++) {\n                pos[i] = new double[y.nDims];\n                vel[i] = new double[y.nDims];\n            }\n            for (int j = 0; j < y.nParticles; j++) {\n                \n                double rp = r.NextDouble();\n                bool ok = true;\n                for (int k = 0; k < y.nDims; k++) {\n                    vel[j][k] = 0.0;\n                    pos[j][k] = 0.0;\n                }\n                for (int k = 0; k < y.nDims; k++) {\n                    vel[j][k] = p.omega * y.vel[j][k] +\n                                p.phip * rp * (bpos[j][k] - y.pos[j][k]) +\n                                p.phig * rg * (gbpos[k] - y.pos[j][k]);\n                    pos[j][k] = y.pos[j][k] + vel[j][k];\n                    ok = ok && y.min[k] < pos[j][k] && y.max[k] > pos[j][k];\n                }\n                if (!ok) {\n                    for (int k = 0; k < y.nDims; k++) {\n                        pos[j][k] = y.min[k] + (y.max[k] - y.min[k]) * r.NextDouble();\n                    }\n                }\n            }\n            var iter = 1 + y.iter;\n            return new State(iter, gbpos, gbval, y.min, y.max, y.parameters, pos, vel, bpos, bval, y.nParticles, y.nDims);\n        }\n\n        public static State Iterate(Func<double[], double> fn, int n, State y) {\n            State r = y;\n            if (n == int.MaxValue) {\n                State old = y;\n                while (true) {\n                    r = Pso(fn, r);\n                    if (r.Equals(old)) break;\n                    old = r;\n                }\n            }\n            else {\n                for (int i = 0; i < n; i++) {\n                    r = Pso(fn, r);\n                }\n            }\n            return r;\n        }\n\n        public static double Mccormick(double[] x) {\n            var a = x[0];\n            var b = x[1];\n            return Math.Sin(a + b) + (a - b) * (a - b) + 1.0 + 2.5 * b - 1.5 * a;\n        }\n\n        public static double Michalewicz(double[] x) {\n            int m = 10;\n            int d = x.Length;\n            double sum = 0.0;\n            for (int i = 1; i < d; i++) {\n                var j = x[i - 1];\n                var k = Math.Sin(i * j * j / Math.PI);\n                sum += Math.Sin(j) * Math.Pow(k, 2.0 * m);\n            }\n            return -sum;\n        }\n\n        static void Main(string[] args) {\n            var state = PsoInit(\n                new double[] { -1.5, -3.0 },\n                new double[] { 4.0, 4.0 },\n                new Parameters(0.0, 0.6, 0.3),\n                100\n                );\n            state = Iterate(Mccormick, 40, state);\n            state.Report(\"McCormick\");\n            Console.WriteLine(\"f(-.54719, -1.54719)\u00a0: {0}\", Mccormick(new double[] { -.54719, -1.54719 }));\n            Console.WriteLine();\n\n            state = PsoInit(\n                new double[] { -0.0, -0.0 },\n                new double[] { Math.PI, Math.PI },\n                new Parameters(0.3, 0.3, 0.3),\n                1000\n                );\n            state = Iterate(Michalewicz, 30, state);\n            state.Report(\"Michalewicz (2D)\");\n            Console.WriteLine(\"f(2.20, 1.57)       \u00a0: {0}\", Michalewicz(new double[] { 2.20, 1.57 }));\n        }\n    }\n}\n"}
{"id": 400403, "name": "Partition function P", "source": "Translate Perl to C#: use strict;\nuse warnings;\nno warnings qw(recursion);\nuse Math::AnyNum qw(:overload);\nuse Memoize;\n\nmemoize('partitionsP');\nmemoize('partDiff');\n\nsub partDiffDiff { my($n) = @_; $n%2 != 0 ? ($n+1)/2 : $n+1 }\n\nsub partDiff { my($n) = @_; $n<2 ? 1 : partDiff($n-1) + partDiffDiff($n-1) }\n\nsub partitionsP {\n    my($n) = @_;\n    return 1 if $n < 2;\n\n    my $psum = 0;\n    for my $i (1..$n) {\n        my $pd = partDiff($i);\n        last if $pd > $n;\n        if ( (($i-1)%4) < 2 ) { $psum += partitionsP($n-$pd) }\n        else                  { $psum -= partitionsP($n-$pd) }\n    }\n    return $psum\n}\n\nprint partitionsP($_) . ' ' for 0..25; print \"\\n\";\nprint partitionsP(6666) . \"\\n\";\n", "target": "using System;\n\nclass Program {\n\n    const long Lm = (long)1e18;\n    const string Fm = \"D18\";\n\n    \n    struct LI { public long lo, ml, mh, hi, tp; }\n\n    static void inc(ref LI d, LI s) { \n        if ((d.lo += s.lo) >= Lm) { d.ml++; d.lo -= Lm; }\n        if ((d.ml += s.ml) >= Lm) { d.mh++; d.ml -= Lm; }\n        if ((d.mh += s.mh) >= Lm) { d.hi++; d.mh -= Lm; }\n        if ((d.hi += s.hi) >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n \n    static void dec(ref LI d, LI s) { \n        if ((d.lo -= s.lo) < 0) { d.ml--; d.lo += Lm; }\n        if ((d.ml -= s.ml) < 0) { d.mh--; d.ml += Lm; }\n        if ((d.mh -= s.mh) < 0) { d.hi--; d.mh += Lm; }\n        if ((d.hi -= s.hi) < 0) { d.tp--; d.hi += Lm; }\n        d.tp -= s.tp;\n    }\n\n    static LI set(long s) { LI d;\n      d.lo = s; d.ml = d.mh = d.hi = d.tp = 0; return d; }\n\n  static string fmt(LI x) { \n    if (x.tp > 0) return x.tp.ToString() + x.hi.ToString(Fm) + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.hi > 0) return x.hi.ToString() + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.mh > 0) return x.mh.ToString() + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.ml > 0) return x.ml.ToString() + x.lo.ToString(Fm);\n    return x.lo.ToString();\n  }\n\n  static LI partcount(int n) {\n    var P = new LI[n + 1]; P[0] = set(1);\n    for (int i = 1; i <= n; i++) {\n      int k = 0, d = -2, j = i;\n      LI x = set(0);\n      while (true) {\n        if ((j -= (d += 3) -k) >= 0) inc(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) inc(ref x, P[j]); else break;\n        if ((j -= (d += 3) -k) >= 0) dec(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) dec(ref x, P[j]); else break;\n      }\n      P[i] = x;\n    }\n    return P[n];\n  }\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew ();\n    var res = partcount(6666); sw.Stop();\n    Console.Write(\"{0}  {1} ms\", fmt(res), sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 400404, "name": "Special divisors", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy @sd;\nfor my $n (1..199) {\n    map { next if $_ != int $_ } map { reverse($n) / reverse $_ } divisors $n;\n    push @sd, $n;\n}\n\nsay @sd . \" matching numbers:\\n\" .\n    (sprintf \"@{['%4d' x @sd]}\", @sd) =~ s/(.{40})/$1\\n/gr;\n", "target": "using System;\n\nnamespace SpecialDivisors {\n    class Program {\n        static int Reverse(int n) {\n            int result = 0;\n            while (n > 0) {\n                result = 10 * result + n % 10;\n                n /= 10;\n            }\n            return result;\n        }\n\n        static void Main() {\n            const int LIMIT = 200;\n\n            int row = 0;\n            int num = 0;\n\n            for (int n = 1; n < LIMIT; n++) {\n                bool flag = true;\n                int revNum = Reverse(n);\n\n                for (int m = 1; m < n / 2; m++) {\n                    int revDiv = Reverse(m);\n                    if (n % m == 0) {\n                        if (revNum % revDiv == 0) {\n                            flag = true;\n                        } else {\n                            flag = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (flag) {\n                    num++;\n                    row++;\n                    Console.Write(\"{0,4}\", n);\n                    if (row % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine();\n            Console.WriteLine();\n            Console.WriteLine(\"Found {0} special divisors N that reverse(D) divides reverse(N) for all divisors D of N, where N < 200\", num);\n        }\n    }\n}\n"}
{"id": 400405, "name": "Polynomial synthetic division", "source": "Translate Perl to C#: sub synthetic_division {\n    my($numerator,$denominator) = @_;\n    my @result = @$numerator;\n    my $end    = @$denominator-1;\n\n    for my $i (0 .. @$numerator-($end+1)) {\n        next unless $result[$i];\n        $result[$i]    /= @$denominator[0];\n        $result[$i+$_] -= @$denominator[$_] * $result[$i] for 1 .. $end;\n    }\n\n    return join(' ', @result[0 .. @result-($end+1)]), join(' ', @result[-$end .. -1]);\n}\n\nsub poly_divide {\n    *n = shift; *d = shift;\n    my($quotient,$remainder)= synthetic_division( \\@n, \\@d );\n    \"[@n] / [@d] = [$quotient], remainder [$remainder]\\n\";\n}\n\nprint poly_divide([1, -12, 0, -42], [1, -3]);\nprint poly_divide([1, 0, 0, 0, -2], [1, 1, 1, 1]);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SyntheticDivision\n{\n    class Program\n    {\n        static (List<int>,List<int>) extendedSyntheticDivision(List<int> dividend, List<int> divisor)\n        {\n            List<int> output = dividend.ToList();\n            int normalizer = divisor[0];\n\n            for (int i = 0; i < dividend.Count() - (divisor.Count() - 1); i++)\n            {\n                output[i] /= normalizer;\n\n                int coef = output[i];\n                if (coef != 0)\n                {\n                    for (int j = 1; j < divisor.Count(); j++)\n                        output[i + j] += -divisor[j] * coef;\n                }\n            }\n\n            int separator = output.Count() - (divisor.Count() - 1);\n\n            return (\n                output.GetRange(0, separator),\n                output.GetRange(separator, output.Count() - separator)\n            );\n        }\n\n        static void Main(string[] args)\n        {\n            List<int> N = new List<int>{ 1, -12, 0, -42 };\n            List<int> D = new List<int> { 1, -3 };\n\n            var (quotient, remainder) = extendedSyntheticDivision(N, D);\n            Console.WriteLine(\"[ {0} ] / [ {1} ] = [ {2} ], remainder [ {3} ]\" ,\n                string.Join(\",\", N),\n                string.Join(\",\", D),\n                string.Join(\",\", quotient),\n                string.Join(\",\", remainder)\n            );\n        }\n    }\n}\n"}
{"id": 400406, "name": "Polynomial synthetic division", "source": "Translate Perl to C#: sub synthetic_division {\n    my($numerator,$denominator) = @_;\n    my @result = @$numerator;\n    my $end    = @$denominator-1;\n\n    for my $i (0 .. @$numerator-($end+1)) {\n        next unless $result[$i];\n        $result[$i]    /= @$denominator[0];\n        $result[$i+$_] -= @$denominator[$_] * $result[$i] for 1 .. $end;\n    }\n\n    return join(' ', @result[0 .. @result-($end+1)]), join(' ', @result[-$end .. -1]);\n}\n\nsub poly_divide {\n    *n = shift; *d = shift;\n    my($quotient,$remainder)= synthetic_division( \\@n, \\@d );\n    \"[@n] / [@d] = [$quotient], remainder [$remainder]\\n\";\n}\n\nprint poly_divide([1, -12, 0, -42], [1, -3]);\nprint poly_divide([1, 0, 0, 0, -2], [1, 1, 1, 1]);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SyntheticDivision\n{\n    class Program\n    {\n        static (List<int>,List<int>) extendedSyntheticDivision(List<int> dividend, List<int> divisor)\n        {\n            List<int> output = dividend.ToList();\n            int normalizer = divisor[0];\n\n            for (int i = 0; i < dividend.Count() - (divisor.Count() - 1); i++)\n            {\n                output[i] /= normalizer;\n\n                int coef = output[i];\n                if (coef != 0)\n                {\n                    for (int j = 1; j < divisor.Count(); j++)\n                        output[i + j] += -divisor[j] * coef;\n                }\n            }\n\n            int separator = output.Count() - (divisor.Count() - 1);\n\n            return (\n                output.GetRange(0, separator),\n                output.GetRange(separator, output.Count() - separator)\n            );\n        }\n\n        static void Main(string[] args)\n        {\n            List<int> N = new List<int>{ 1, -12, 0, -42 };\n            List<int> D = new List<int> { 1, -3 };\n\n            var (quotient, remainder) = extendedSyntheticDivision(N, D);\n            Console.WriteLine(\"[ {0} ] / [ {1} ] = [ {2} ], remainder [ {3} ]\" ,\n                string.Join(\",\", N),\n                string.Join(\",\", D),\n                string.Join(\",\", quotient),\n                string.Join(\",\", remainder)\n            );\n        }\n    }\n}\n"}
{"id": 400407, "name": "Color wheel", "source": "Translate Perl to C#: use Imager;\nuse Math::Complex qw(cplx i pi);\n\nmy ($width, $height) = (300, 300);\nmy $center = cplx($width/2, $height/2);\n\nmy $img = Imager->new(xsize => $width,\n                      ysize => $height);\n\nforeach my $y (0 .. $height - 1) {\n    foreach my $x (0 .. $width - 1) {\n\n        my $vec = $center - $x - $y * i;\n        my $mag = 2 * abs($vec) / $width;\n        my $dir = (pi + atan2($vec->Re, $vec->Im)) / (2 * pi);\n\n        $img->setpixel(x => $x, y => $y,\n            color => {hsv => [360 * $dir, $mag, $mag < 1 ? 1 : 0]});\n    }\n}\n\n$img->write(file => 'color_wheel.png');\n", "target": "\n\npublic MainWindow()\n{\n    InitializeComponent();\n    RenderOptions.SetBitmapScalingMode(imgMain, BitmapScalingMode.HighQuality);\n    imgMain.Source = new WriteableBitmap(480, 480, 96, 96, PixelFormats.Bgr32, null);\n    \n    DrawHue(100);\n}\n\nvoid DrawHue(int saturation)\n{\n    var bmp = (WriteableBitmap)imgMain.Source;\n\n    int centerX = (int)bmp.Width / 2;\n    int centerY = (int)bmp.Height / 2;\n    int radius = Math.Min(centerX, centerY);\n    int radius2 = radius - 40;\n\n    bmp.Lock();\n    unsafe{\n        var buf = bmp.BackBuffer;\n        IntPtr pixLineStart;\n        for(int y=0; y < bmp.Height; y++){\n            pixLineStart = buf + bmp.BackBufferStride * y;\n            double dy = (y - centerY);\n            for(int x=0; x < bmp.Width; x++){\n                double dx = (x - centerX);\n                double dist = Math.Sqrt(dx * dx + dy * dy);\n                if (radius2 <= dist && dist <= radius) {\n                    double theta = Math.Atan2(dy, dx);\n                    double hue = (theta + Math.PI) / (2.0 * Math.PI);\n                    *((int*)(pixLineStart + x * 4)) = HSB_to_RGB((int)(hue * 360), saturation, 100);\n                }\n            }\n        }\n    }\n    bmp.AddDirtyRect(new Int32Rect(0, 0, 480, 480));\n    bmp.Unlock();\n}\n\nstatic int HSB_to_RGB(int h, int s, int v)\n{\n    var rgb = new int[3];\n\n    var baseColor = (h + 60) % 360 / 120;\n    var shift = (h + 60) % 360 - (120 * baseColor + 60 );\n    var secondaryColor = (baseColor + (shift >= 0 ? 1 : -1) + 3) % 3;\n\n    \n    rgb[baseColor] = 255;\n    rgb[secondaryColor] = (int) ((Math.Abs(shift) / 60.0f) * 255.0f);\n\n    \n    for (var i = 0; i < 3; i++)\n        rgb[i] += (int) ((255 - rgb[i]) * ((100 - s) / 100.0f));\n\n    \n    for (var i = 0; i < 3; i++)\n        rgb[i] -= (int) (rgb[i] * (100-v) / 100.0f);\n\n    return RGB2int(rgb[0], rgb[1], rgb[2]);\n}\n\npublic static int RGB2int(int r, int g, int b) => r << 16 | g << 8 | b;\n"}
{"id": 400408, "name": "The sieve of Sundaram", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @sieve;\nmy $nth = 1_000_000;\nmy $k = 2.4 * $nth * log($nth) / 2;\n\n$sieve[$k] = 0;\nfor my $i (1 .. $k) {\n    my $j = $i;\n    while ((my $l = $i + $j + 2 * $i * $j) < $k) {\n        $sieve[$l] = 1;\n        $j++\n    }\n}\n\n$sieve[0] = 1;\nmy @S = (grep { $_ } map { ! $sieve[$_] and 1+$_*2 } 0..@sieve)[0..99];\nsay \"First 100 Sundaram primes:\\n\" .\n    (sprintf \"@{['%5d' x 100]}\", @S) =~ s/(.{50})/$1\\n/gr;\n\nmy ($count, $index);\nfor (@sieve) {\n    $count += !$_;\n    (say \"One millionth: \" . (1+2*$index)) and last if $count == $nth;\n    ++$index;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nclass Program\n{\n    static string fmt(int[] a)\n    {\n        var sb = new System.Text.StringBuilder();\n        for (int i = 0; i < a.Length; i++)\n            sb.Append(string.Format(\"{0,5}{1}\",\n              a[i], i % 10 == 9 ? \"\\n\" : \" \"));\n        return sb.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        var pr = PG.Sundaram(15_500_000).Take(1_000_000).ToArray();\n        sw.Stop();\n        Write(\"The first 100 odd prime numbers:\\n{0}\\n\",\n          fmt(pr.Take(100).ToArray()));\n        Write(\"The millionth odd prime number: {0}\", pr.Last());\n        Write(\"\\n{0} ms\", sw.Elapsed.TotalMilliseconds);\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<int> Sundaram(int n)\n    {\n        \n        int i = 1, k = (n + 1) >> 1, t = 1, v = 1, d = 1, s = 1;\n        var comps = new bool[k + 1];\n        for (; t < k; t = ((++i + (s += d += 2)) << 1) - d - 2)\n            while ((t += d + 2) < k)\n                comps[t] = true;\n        for (; v < k; v++)\n            if (!comps[v])\n                yield return (v << 1) + 1;\n    }\n}\n"}
{"id": 400409, "name": "Consecutive primes with ascending or descending differences", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'primes';\nuse List::AllUtils <indexes max>;\n\nmy $limit  = 1000000;\nmy @primes = @{primes( $limit )};\n\nsub runs {\n    my($op) = @_;\n    my @diff = my $diff = my $run = 1;\n    push @diff, map {\n        my $next = $primes[$_] - $primes[$_ - 1];\n        if ($op eq '>') { if ($next > $diff) { ++$run } else { $run = 1 } }\n        else            { if ($next < $diff) { ++$run } else { $run = 1 } }\n        $diff = $next;\n        $run\n    } 1 .. $\n\n    my @prime_run;\n    my $max = max @diff;\n    for my $r ( indexes { $_ == $max } @diff ) {\n        push @prime_run, join ' ', map { $primes[$r - $_] } reverse 0..$max\n    }\n    @prime_run\n}\n\nsay   \"Longest run(s) of ascending prime gaps up to $limit:\\n\"  . join \"\\n\", runs('>');\nsay \"\\nLongest run(s) of descending prime gaps up to $limit:\\n\" . join \"\\n\", runs('<');\n", "target": "using System.Linq;\nusing System.Collections.Generic;\nusing TG = System.Tuple<int, int>;\nusing static System.Console;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int mil = (int)1e6;\n        foreach (var amt in new int[] { 1, 2, 6, 12, 18 })\n        {\n            int lmt = mil * amt, lg = 0, ng, d, ld = 0;\n            var desc = new string[] { \"A\", \"\", \"De\" };\n            int[] mx = new int[] { 0, 0, 0 },\n                  bi = new int[] { 0, 0, 0 },\n                   c = new int[] { 2, 2, 2 };\n            WriteLine(\"For primes up to {0:n0}:\", lmt);\n            var pr = PG.Primes(lmt).ToArray();\n            for (int i = 0; i < pr.Length; i++)\n            {\n                ng = pr[i].Item2; d = ng.CompareTo(lg) + 1;\n                if (ld == d)\n                    c[2 - d]++;\n                else\n                {\n                    if (c[d] > mx[d]) { mx[d] = c[d]; bi[d] = i - mx[d] - 1; }\n                    c[d] = 2;\n                }\n                ld = d; lg = ng;\n            }\n            for (int r = 0; r <= 2; r += 2)\n            {\n                Write(\"{0}scending, found run of {1} consecutive primes:\\n  {2} \",\n                    desc[r], mx[r] + 1, pr[bi[r]++].Item1);\n                foreach (var itm in pr.Skip(bi[r]).Take(mx[r]))\n                    Write(\"({0}) {1} \", itm.Item2, itm.Item1); WriteLine(r == 0 ? \"\" : \"\\n\");\n            }\n        }\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<TG> Primes(int lim)\n    {\n        bool[] flags = new bool[lim + 1];\n        int j = 3, lj = 2;\n        for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n                for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true;\n            }\n        for (; j <= lim; j += 2)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n            }\n    }\n}\n"}
{"id": 400410, "name": "XML validation", "source": "Translate Perl to C#: \nuse 5.018_002;\nuse warnings;\nuse Try::Tiny;\nuse XML::LibXML;\n\nour $VERSION = 1.000_000;\n\nmy $parser = XML::LibXML->new();\n\nmy $good_xml         = '<a>5</a>';\nmy $bad_xml          = '<a>5<b>foobar</b></a>';\nmy $xmlschema_markup = <<'END';\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"xsd:integer\"/>\n</xsd:schema>\nEND\n\nmy $xmlschema = XML::LibXML::Schema->new( string => $xmlschema_markup );\n\nfor ( $good_xml, $bad_xml ) {\n    my $doc = $parser->parse_string($_);\n    try {\n        $xmlschema->validate($doc);\n    }\n    finally {\n        if (@_) {\n            say \"Not valid: @_\";\n        }\n        else {\n            say 'Valid';\n        }\n    };\n}\n", "target": "using System;\nusing System.Xml;\nusing System.Xml.Schema;\nusing System.IO;\n\npublic class Test\n{\n\tpublic static void Main()\n\t{\n\t\t\n\t\tXmlSchemaSet sc = new XmlSchemaSet();\n\t\tsc.Add(null, \"http:\n\t\tXmlReaderSettings settings = new XmlReaderSettings();\n\t\tsettings.ValidationType = ValidationType.Schema;\n\t\tsettings.Schemas = sc;\n\t\tsettings.ValidationEventHandler += new ValidationEventHandler(ValidationCallBack);\n\t\t\n\t\tXmlReader reader = XmlReader.Create(\"http:\n\t\t\n\t\twhile (reader.Read()); \n\t\t\n\t\tConsole.WriteLine(\"The XML file is valid for the given xsd file\");\n\t}\n\t\n\t\n\tprivate static void ValidationCallBack(object sender, ValidationEventArgs e) {\n\t\tConsole.WriteLine(\"Validation Error: {0}\", e.Message);\n\t}\n}\n"}
{"id": 400411, "name": "Metallic ratios", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature qw(say state);\nuse Math::AnyNum qw<:overload as_dec>;\n\nsub gen_lucas {\n    my $b = shift;\n    my $i = 0;\n    return sub {\n        state @seq = (state $v1 = 1, state $v2 = 1);\n        ($v2, $v1) = ($v1, $v2 + $b*$v1) and push(@seq, $v1) unless defined $seq[$i+1];\n        return $seq[$i++];\n    }\n}\n\nsub metallic {\n    my $lucas  = shift;\n    my $places = shift || 32;\n    my $n = my $last = 0;\n    my @seq = $lucas->();\n    while (1) {\n        push @seq, $lucas->();\n        my $this = as_dec( $seq[-1]/$seq[-2], $places+1 );\n        last if $this eq $last;\n        $last = $this;\n        $n++;\n    }\n    $last, $n\n}\n\nmy @name = <Platinum Golden Silver Bronze Copper Nickel Aluminum Iron Tin Lead>;\n\nfor my $b (0..$\n    my $lucas = gen_lucas($b);\n    printf \"\\n'Lucas' sequence for $name[$b] ratio, where b = $b:\\nFirst 15 elements: \" . join ', ', map { $lucas->() } 1..15;\n    printf \"Approximated value %s reached after %d iterations\\n\", metallic(gen_lucas($b));\n}\n\nprintf \"\\nGolden ratio to 256 decimal places %s reached after %d iterations\", metallic(gen_lucas(1),256);\n", "target": "using static System.Math;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n    static BI IntSqRoot(BI v, BI res) { \n        BI term = 0, d = 0, dl = 1; while (dl != d) { term = v / res; res = (res + term) >> 1;\n            dl = d; d = term - res; } return term; }\n \n    static string doOne(int b, int digs) { \n        int s = b * b + 4; BI g = (BI)(Sqrt((double)s) * Pow(10, ++digs)),\n            bs = IntSqRoot(s * BI.Parse('1' + new string('0', digs << 1)), g);\n        bs += b * BI.Parse('1' + new string('0', digs));\n        bs >>= 1; bs += 4; string st = bs.ToString();\n        return string.Format(\"{0}.{1}\", st[0], st.Substring(1, --digs)); }\n \n    static string divIt(BI a, BI b, int digs) { \n        int al = a.ToString().Length, bl = b.ToString().Length;\n        a *= BI.Pow(10, ++digs << 1); b *= BI.Pow(10, digs);\n        string s = (a / b + 5).ToString(); return s[0] + \".\" + s.Substring(1, --digs); }\n \n    \n    static string joined(BI[] x) { int[] wids = {1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};\n        string res = \"\"; for (int i = 0; i < x.Length; i++) res += \n            string.Format(\"{0,\" + (-wids[i]).ToString() + \"} \", x[i]); return res; }\n \n    static void Main(string[] args) { \n        WriteLine(\"Metal B Sq.Rt Iters /---- 32 decimal place value ----\\\\  Matches Sq.Rt Calc\");\n        int k; string lt, t = \"\"; BI n, nm1, on; for (int b = 0; b < 10; b++) {\n            BI[] lst = new BI[15]; lst[0] = lst[1] = 1;\n            for (int i = 2; i < 15; i++) lst[i] = b * lst[i - 1] + lst[i - 2];\n            \n            n = lst[14]; nm1 = lst[13]; k = 0; for (int j = 13; k == 0; j++) {\n                lt = t; if (lt == (t = divIt(n, nm1, 32))) k = b == 0 ? 1 : j;\n                on = n; n = b * n + nm1; nm1 = on; }\n            WriteLine(\"{0,4}  {1}   {2,2}    {3, 2}  {4}  {5}\\n{6,19} {7}\", \"Pt Au Ag CuSn Cu Ni Al Fe Sn Pb\"\n                .Split(' ')[b], b, b * b + 4, k, t, t == doOne(b, 32), \"\", joined(lst)); }\n        \n        n = nm1 =1; k = 0; for (int j = 1; k == 0; j++) {\n            lt = t; if (lt == (t = divIt(n, nm1, 256))) k = j;\n                on = n; n += nm1; nm1 = on; }\n        WriteLine(\"\\nAu to 256 digits:\"); WriteLine(t);\n        WriteLine(\"Iteration count: {0}  Matched Sq.Rt Calc: {1}\", k, t == doOne(1, 256)); }\n}\n"}
{"id": 400412, "name": "Metallic ratios", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature qw(say state);\nuse Math::AnyNum qw<:overload as_dec>;\n\nsub gen_lucas {\n    my $b = shift;\n    my $i = 0;\n    return sub {\n        state @seq = (state $v1 = 1, state $v2 = 1);\n        ($v2, $v1) = ($v1, $v2 + $b*$v1) and push(@seq, $v1) unless defined $seq[$i+1];\n        return $seq[$i++];\n    }\n}\n\nsub metallic {\n    my $lucas  = shift;\n    my $places = shift || 32;\n    my $n = my $last = 0;\n    my @seq = $lucas->();\n    while (1) {\n        push @seq, $lucas->();\n        my $this = as_dec( $seq[-1]/$seq[-2], $places+1 );\n        last if $this eq $last;\n        $last = $this;\n        $n++;\n    }\n    $last, $n\n}\n\nmy @name = <Platinum Golden Silver Bronze Copper Nickel Aluminum Iron Tin Lead>;\n\nfor my $b (0..$\n    my $lucas = gen_lucas($b);\n    printf \"\\n'Lucas' sequence for $name[$b] ratio, where b = $b:\\nFirst 15 elements: \" . join ', ', map { $lucas->() } 1..15;\n    printf \"Approximated value %s reached after %d iterations\\n\", metallic(gen_lucas($b));\n}\n\nprintf \"\\nGolden ratio to 256 decimal places %s reached after %d iterations\", metallic(gen_lucas(1),256);\n", "target": "using static System.Math;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n    static BI IntSqRoot(BI v, BI res) { \n        BI term = 0, d = 0, dl = 1; while (dl != d) { term = v / res; res = (res + term) >> 1;\n            dl = d; d = term - res; } return term; }\n \n    static string doOne(int b, int digs) { \n        int s = b * b + 4; BI g = (BI)(Sqrt((double)s) * Pow(10, ++digs)),\n            bs = IntSqRoot(s * BI.Parse('1' + new string('0', digs << 1)), g);\n        bs += b * BI.Parse('1' + new string('0', digs));\n        bs >>= 1; bs += 4; string st = bs.ToString();\n        return string.Format(\"{0}.{1}\", st[0], st.Substring(1, --digs)); }\n \n    static string divIt(BI a, BI b, int digs) { \n        int al = a.ToString().Length, bl = b.ToString().Length;\n        a *= BI.Pow(10, ++digs << 1); b *= BI.Pow(10, digs);\n        string s = (a / b + 5).ToString(); return s[0] + \".\" + s.Substring(1, --digs); }\n \n    \n    static string joined(BI[] x) { int[] wids = {1, 1, 2, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13};\n        string res = \"\"; for (int i = 0; i < x.Length; i++) res += \n            string.Format(\"{0,\" + (-wids[i]).ToString() + \"} \", x[i]); return res; }\n \n    static void Main(string[] args) { \n        WriteLine(\"Metal B Sq.Rt Iters /---- 32 decimal place value ----\\\\  Matches Sq.Rt Calc\");\n        int k; string lt, t = \"\"; BI n, nm1, on; for (int b = 0; b < 10; b++) {\n            BI[] lst = new BI[15]; lst[0] = lst[1] = 1;\n            for (int i = 2; i < 15; i++) lst[i] = b * lst[i - 1] + lst[i - 2];\n            \n            n = lst[14]; nm1 = lst[13]; k = 0; for (int j = 13; k == 0; j++) {\n                lt = t; if (lt == (t = divIt(n, nm1, 32))) k = b == 0 ? 1 : j;\n                on = n; n = b * n + nm1; nm1 = on; }\n            WriteLine(\"{0,4}  {1}   {2,2}    {3, 2}  {4}  {5}\\n{6,19} {7}\", \"Pt Au Ag CuSn Cu Ni Al Fe Sn Pb\"\n                .Split(' ')[b], b, b * b + 4, k, t, t == doOne(b, 32), \"\", joined(lst)); }\n        \n        n = nm1 =1; k = 0; for (int j = 1; k == 0; j++) {\n            lt = t; if (lt == (t = divIt(n, nm1, 256))) k = j;\n                on = n; n += nm1; nm1 = on; }\n        WriteLine(\"\\nAu to 256 digits:\"); WriteLine(t);\n        WriteLine(\"Iteration count: {0}  Matched Sq.Rt Calc: {1}\", k, t == doOne(1, 256)); }\n}\n"}
{"id": 400413, "name": "Data Encryption Standard", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse Crypt::DES;\n\nmy $key        = pack(\"H*\", \"0E329232EA6D0D73\");\nmy $cipher     = Crypt::DES->new($key);\nmy $ciphertext = $cipher->encrypt(pack(\"H*\", \"8787878787878787\"));\nprint \"Encoded\u00a0: \", unpack(\"H*\", $ciphertext), \"\\n\";\nprint \"Decoded\u00a0: \", unpack(\"H*\", $cipher->decrypt($ciphertext)), \"\\n\";\n", "target": "using System;\nusing System.IO;\nusing System.Security.Cryptography;\n\nnamespace DES {\n    class Program {\n        \n        static string ByteArrayToString(byte[] ba) {\n            return BitConverter.ToString(ba).Replace(\"-\", \"\");\n        }\n\n        \n        \n        static byte[] Encrypt(byte[] messageBytes, byte[] passwordBytes) {\n            byte[] iv = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n            \n            DESCryptoServiceProvider provider = new DESCryptoServiceProvider();\n            ICryptoTransform transform = provider.CreateEncryptor(passwordBytes, iv);\n            CryptoStreamMode mode = CryptoStreamMode.Write;\n\n            \n            MemoryStream memStream = new MemoryStream();\n            CryptoStream cryptoStream = new CryptoStream(memStream, transform, mode);\n            cryptoStream.Write(messageBytes, 0, messageBytes.Length);\n            cryptoStream.FlushFinalBlock();\n\n            \n            byte[] encryptedMessageBytes = new byte[memStream.Length];\n            memStream.Position = 0;\n            memStream.Read(encryptedMessageBytes, 0, encryptedMessageBytes.Length);\n\n            return encryptedMessageBytes;\n        }\n\n        \n        \n        static byte[] Decrypt(byte[] encryptedMessageBytes, byte[] passwordBytes) {\n            byte[] iv = new byte[] { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };\n\n            \n            DESCryptoServiceProvider provider = new DESCryptoServiceProvider();\n            ICryptoTransform transform = provider.CreateDecryptor(passwordBytes, iv);\n            CryptoStreamMode mode = CryptoStreamMode.Write;\n\n            \n            MemoryStream memStream = new MemoryStream();\n            CryptoStream cryptoStream = new CryptoStream(memStream, transform, mode);\n            cryptoStream.Write(encryptedMessageBytes, 0, encryptedMessageBytes.Length);\n            cryptoStream.FlushFinalBlock();\n\n            \n            byte[] decryptedMessageBytes = new byte[memStream.Length];\n            memStream.Position = 0;\n            memStream.Read(decryptedMessageBytes, 0, decryptedMessageBytes.Length);\n\n            return decryptedMessageBytes;\n        }\n\n        static void Main(string[] args) {\n            byte[] keyBytes = new byte[] { 0x0e, 0x32, 0x92, 0x32, 0xea, 0x6d, 0x0d, 0x73 };\n            byte[] plainBytes = new byte[] { 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87 };\n\n            byte[] encStr = Encrypt(plainBytes, keyBytes);\n            Console.WriteLine(\"Encoded: {0}\", ByteArrayToString(encStr));\n\n            byte[] decBytes = Decrypt(encStr, keyBytes);\n            Console.WriteLine(\"Decoded: {0}\", ByteArrayToString(decBytes));\n        }\n    }\n}\n"}
{"id": 400414, "name": "Gauss-Jordan matrix inversion", "source": "Translate Perl to C#: sub rref {\n  our @m; local *m = shift;\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n\n      ++$lead;}\n}\n\nsub display { join(\"\\n\" => map join(\" \" => map(sprintf(\"%6.2f\", $_), @$_)), @{+shift}).\"\\n\" }\n\nsub gauss_jordan_invert {\n    my(@m) = @_;\n    my $rows = @m;\n    my @i = identity(scalar @m);\n    push @{$m[$_]}, @{$i[$_]} for 0..$rows-1;\n    rref(\\@m);\n    map { splice @$_, 0, $rows } @m;\n    @m;\n}\n\nsub identity {\n    my($n) = @_;\n    map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1\n}\n\nmy @tests = (\n    [\n      [ 2, -1,  0 ],\n      [-1,  2, -1 ],\n      [ 0, -1,  2 ]\n    ],\n    [\n      [ -1, -2, 3, 2 ],\n      [ -4, -1, 6, 2 ],\n      [  7, -8, 9, 1 ],\n      [  1, -2, 1, 3 ]\n    ],\n);\n\nfor my $matrix (@tests) {\n    print \"Original Matrix:\\n\" . display(\\@$matrix) . \"\\n\";\n    my @gj = gauss_jordan_invert( @$matrix );\n    print \"Gauss-Jordan Inverted Matrix:\\n\" . display(\\@gj) . \"\\n\";\n    my @rt = gauss_jordan_invert( @gj );\n    print \"After round-trip:\\n\" . display(\\@rt) . \"\\n\";} . \"\\n\"\n}\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 400415, "name": "Gauss-Jordan matrix inversion", "source": "Translate Perl to C#: sub rref {\n  our @m; local *m = shift;\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n\n      ++$lead;}\n}\n\nsub display { join(\"\\n\" => map join(\" \" => map(sprintf(\"%6.2f\", $_), @$_)), @{+shift}).\"\\n\" }\n\nsub gauss_jordan_invert {\n    my(@m) = @_;\n    my $rows = @m;\n    my @i = identity(scalar @m);\n    push @{$m[$_]}, @{$i[$_]} for 0..$rows-1;\n    rref(\\@m);\n    map { splice @$_, 0, $rows } @m;\n    @m;\n}\n\nsub identity {\n    my($n) = @_;\n    map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1\n}\n\nmy @tests = (\n    [\n      [ 2, -1,  0 ],\n      [-1,  2, -1 ],\n      [ 0, -1,  2 ]\n    ],\n    [\n      [ -1, -2, 3, 2 ],\n      [ -4, -1, 6, 2 ],\n      [  7, -8, 9, 1 ],\n      [  1, -2, 1, 3 ]\n    ],\n);\n\nfor my $matrix (@tests) {\n    print \"Original Matrix:\\n\" . display(\\@$matrix) . \"\\n\";\n    my @gj = gauss_jordan_invert( @$matrix );\n    print \"Gauss-Jordan Inverted Matrix:\\n\" . display(\\@gj) . \"\\n\";\n    my @rt = gauss_jordan_invert( @gj );\n    print \"After round-trip:\\n\" . display(\\@rt) . \"\\n\";} . \"\\n\"\n}\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 400416, "name": "Pandigital prime", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse ntheory qw( forperm is_prime );\n\nfor my $digits ( reverse 1 .. 9 )\n  {\n  forperm\n    {\n    my $n = join '', map $digits - $_, @_;\n    is_prime($n) and exit ! print \"$n\\n\";\n    } $digits;\n  }\n", "target": "using System;\n \nclass Program {\n  \n \n  \n  \n \n  static void fun(char sp) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    \n    \n    \n \n    for (int x = sp == '1' ? 7654321 : 76543201; ; x -= 18) {\n \n      \n      \n      \n      var s = x.ToString();\n      for (var ch = sp; ch < '8'; ch++) if (s.IndexOf(ch) < 0) goto nxt;\n \n      \n      \n      if (x % 3 == 0) continue;\n      for (int i = 1; i * i < x; ) {\n        if (x % (i += 4) == 0) goto nxt;\n        if (x % (i += 2) == 0) goto nxt;\n      }\n      sw.Stop(); Console.WriteLine(\"{0}..7: {1,10:n0} {2} \u03bcs\", sp, x, sw.Elapsed.TotalMilliseconds * 1000); break;\n      nxt: ;\n    }\n  }\n\nstatic void Main(string[] args) {\n    fun('1');\n    fun('0');\n  }\n}\n"}
{"id": 400417, "name": "Pandigital prime", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse ntheory qw( forperm is_prime );\n\nfor my $digits ( reverse 1 .. 9 )\n  {\n  forperm\n    {\n    my $n = join '', map $digits - $_, @_;\n    is_prime($n) and exit ! print \"$n\\n\";\n    } $digits;\n  }\n", "target": "using System;\n \nclass Program {\n  \n \n  \n  \n \n  static void fun(char sp) {\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    \n    \n    \n \n    for (int x = sp == '1' ? 7654321 : 76543201; ; x -= 18) {\n \n      \n      \n      \n      var s = x.ToString();\n      for (var ch = sp; ch < '8'; ch++) if (s.IndexOf(ch) < 0) goto nxt;\n \n      \n      \n      if (x % 3 == 0) continue;\n      for (int i = 1; i * i < x; ) {\n        if (x % (i += 4) == 0) goto nxt;\n        if (x % (i += 2) == 0) goto nxt;\n      }\n      sw.Stop(); Console.WriteLine(\"{0}..7: {1,10:n0} {2} \u03bcs\", sp, x, sw.Elapsed.TotalMilliseconds * 1000); break;\n      nxt: ;\n    }\n  }\n\nstatic void Main(string[] args) {\n    fun('1');\n    fun('0');\n  }\n}\n"}
{"id": 400418, "name": "Fibonacci matrix-exponentiation", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse Math::AnyNum qw(:overload fibmod floor);\nuse Math::MatrixLUP;\n\nsub fibonacci {\n    my $M = Math::MatrixLUP->new([ [1, 1], [1,0] ]);\n    (@{$M->pow(shift)})[0][1]\n}\n\nfor my $n (16, 32) {\n    my $f = fibonacci(2**$n);\n    printf \"F(2^$n) = %s ... %s\\n\",  substr($f,0,20), $f % 10**20;\n}\n\nsub binet_approx {\n    my($n) = @_;\n    use constant PHI =>   sqrt(1.25) + 0.5 ;\n    use constant IHP => -(sqrt(1.25) - 0.5);\n    (log(PHI)*$n - log(PHI-IHP))\n}\n\nsub nth_fib_first_k_digits {\n    my($n,$k) = @_;\n    my $f = binet_approx($n);\n    floor(exp($f - log(10)*(floor($f / log(10) + 1))) * 10**$k)\n}\n\nsub nth_fib_last_k_digits {\n    my($n,$k) = @_;\n    fibmod($n, 10**$k);\n}\n\nprint \"\\n\";\nfor my $n (16, 32, 64) {\n    my $first20 = nth_fib_first_k_digits(2**$n, 20);\n    my $last20  = nth_fib_last_k_digits(2**$n, 20);\n    printf \"F(2^$n) = %s ... %s\\n\", $first20, $last20;\n}\n", "target": "using System;\nusing System.IO;\nusing System.Numerics;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Globalization;\n\nnamespace Fibonacci {\n    class Program\n    {\n        private static readonly BigInteger[,] F = { { BigInteger.One, BigInteger.One }, { BigInteger.One, BigInteger.Zero } };\n        private static NumberFormatInfo nfi  = new NumberFormatInfo { NumberGroupSeparator = \"_\" };\n        private static BigInteger[,] Multiply(in BigInteger[,] A, in BigInteger[,] B)\n        {\n            if (A.GetLength(1) != B.GetLength(0))\n            {\n                throw new ArgumentException(\"Illegal matrix dimensions for multiplication.\");\n            }\n            var C = new BigInteger[A.GetLength(0), B.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < B.GetLength(1); ++j)\n                {\n                    for (int k = 0; k < A.GetLength(1); ++k)\n                    {\n                        C[i, j] +=  A[i, k] * B[k, j];\n                    }\n                }\n            }\n            return C;\n        }\n        private static BigInteger[,] Power(in BigInteger[,] A, ulong n)\n        {\n            if (A.GetLength(1) != A.GetLength(0))\n            {\n                throw new ArgumentException(\"Not a square matrix.\");\n            }\n            var C = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                C[i, i] = BigInteger.One;\n            }\n            if (0 == n) return C;\n            var S = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < A.GetLength(1); ++j)\n                {\n                    S[i, j] = A[i, j];\n                }\n            }\n            while (0 < n)\n            {\n                if (1 == n % 2) C = Multiply(C, S);\n                S = Multiply(S,S);\n                n /= 2;\n            }\n            return C;\n        }\n        public static BigInteger Fib(in ulong n)\n        {\n            var C = Power(F, n);\n            return C[0, 1];\n        }\n        public static void Task(in ulong p)\n        {\n            var ans = Fib(p).ToString();\n            var sp = p.ToString(\"N0\", nfi);\n            if (ans.Length <= 40)\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1}\", sp, ans);\n            }\n            else\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1} ... {2}\", sp, ans[0..19], ans[^20..]);\n            }\n        }\n        public static void Main()\n        {\n            Stopwatch stopWatch = new Stopwatch();\n            stopWatch.Start();\n            for (ulong p = 10; p <= 10_000_000; p *= 10) {\n                Task(p);\n            }\n            stopWatch.Stop();\n            TimeSpan ts = stopWatch.Elapsed;\n            string elapsedTime = String.Format(\"{0:00}:{1:00}:{2:00}.{3:00}\",\n                ts.Hours, ts.Minutes, ts.Seconds,\n                ts.Milliseconds / 10);\n            Console.WriteLine(\"Took \" + elapsedTime);\n        }\n    }\n}\n"}
{"id": 400419, "name": "Fibonacci matrix-exponentiation", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse Math::AnyNum qw(:overload fibmod floor);\nuse Math::MatrixLUP;\n\nsub fibonacci {\n    my $M = Math::MatrixLUP->new([ [1, 1], [1,0] ]);\n    (@{$M->pow(shift)})[0][1]\n}\n\nfor my $n (16, 32) {\n    my $f = fibonacci(2**$n);\n    printf \"F(2^$n) = %s ... %s\\n\",  substr($f,0,20), $f % 10**20;\n}\n\nsub binet_approx {\n    my($n) = @_;\n    use constant PHI =>   sqrt(1.25) + 0.5 ;\n    use constant IHP => -(sqrt(1.25) - 0.5);\n    (log(PHI)*$n - log(PHI-IHP))\n}\n\nsub nth_fib_first_k_digits {\n    my($n,$k) = @_;\n    my $f = binet_approx($n);\n    floor(exp($f - log(10)*(floor($f / log(10) + 1))) * 10**$k)\n}\n\nsub nth_fib_last_k_digits {\n    my($n,$k) = @_;\n    fibmod($n, 10**$k);\n}\n\nprint \"\\n\";\nfor my $n (16, 32, 64) {\n    my $first20 = nth_fib_first_k_digits(2**$n, 20);\n    my $last20  = nth_fib_last_k_digits(2**$n, 20);\n    printf \"F(2^$n) = %s ... %s\\n\", $first20, $last20;\n}\n", "target": "using System;\nusing System.IO;\nusing System.Numerics;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Globalization;\n\nnamespace Fibonacci {\n    class Program\n    {\n        private static readonly BigInteger[,] F = { { BigInteger.One, BigInteger.One }, { BigInteger.One, BigInteger.Zero } };\n        private static NumberFormatInfo nfi  = new NumberFormatInfo { NumberGroupSeparator = \"_\" };\n        private static BigInteger[,] Multiply(in BigInteger[,] A, in BigInteger[,] B)\n        {\n            if (A.GetLength(1) != B.GetLength(0))\n            {\n                throw new ArgumentException(\"Illegal matrix dimensions for multiplication.\");\n            }\n            var C = new BigInteger[A.GetLength(0), B.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < B.GetLength(1); ++j)\n                {\n                    for (int k = 0; k < A.GetLength(1); ++k)\n                    {\n                        C[i, j] +=  A[i, k] * B[k, j];\n                    }\n                }\n            }\n            return C;\n        }\n        private static BigInteger[,] Power(in BigInteger[,] A, ulong n)\n        {\n            if (A.GetLength(1) != A.GetLength(0))\n            {\n                throw new ArgumentException(\"Not a square matrix.\");\n            }\n            var C = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                C[i, i] = BigInteger.One;\n            }\n            if (0 == n) return C;\n            var S = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < A.GetLength(1); ++j)\n                {\n                    S[i, j] = A[i, j];\n                }\n            }\n            while (0 < n)\n            {\n                if (1 == n % 2) C = Multiply(C, S);\n                S = Multiply(S,S);\n                n /= 2;\n            }\n            return C;\n        }\n        public static BigInteger Fib(in ulong n)\n        {\n            var C = Power(F, n);\n            return C[0, 1];\n        }\n        public static void Task(in ulong p)\n        {\n            var ans = Fib(p).ToString();\n            var sp = p.ToString(\"N0\", nfi);\n            if (ans.Length <= 40)\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1}\", sp, ans);\n            }\n            else\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1} ... {2}\", sp, ans[0..19], ans[^20..]);\n            }\n        }\n        public static void Main()\n        {\n            Stopwatch stopWatch = new Stopwatch();\n            stopWatch.Start();\n            for (ulong p = 10; p <= 10_000_000; p *= 10) {\n                Task(p);\n            }\n            stopWatch.Stop();\n            TimeSpan ts = stopWatch.Elapsed;\n            string elapsedTime = String.Format(\"{0:00}:{1:00}:{2:00}.{3:00}\",\n                ts.Hours, ts.Minutes, ts.Seconds,\n                ts.Milliseconds / 10);\n            Console.WriteLine(\"Took \" + elapsedTime);\n        }\n    }\n}\n"}
{"id": 400420, "name": "Cyclotomic polynomial", "source": "Translate Perl to C#: use feature 'say';\nuse List::Util qw(first);\nuse Math::Polynomial::Cyclotomic qw(cyclo_poly_iterate);\n\nsay 'First 30 cyclotomic polynomials:';\nmy $it = cyclo_poly_iterate(1);\nsay \"$_: \" . $it->() for 1 .. 30;\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\";\n$it = cyclo_poly_iterate(1);\n\nfor (my ($n, $k) = (1, 1) ; $n <= 10 ; ++$k) {\n    my $poly = $it->();\n    while (my $c = first { abs($_) == $n } $poly->coeff) {\n        say \"CP $k has coefficient with magnitude = $n\";\n        $n++;\n    }\n}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing IntMap = System.Collections.Generic.Dictionary<int, int>;\n\npublic static class CyclotomicPolynomial\n{\n    public static void Main2() {\n        Console.WriteLine(\"Task 1: Cyclotomic polynomials for n <= 30:\");\n        for (int i = 1; i <= 30; i++) {\n            var p = GetCyclotomicPolynomial(i);\n            Console.WriteLine($\"CP[{i}] = {p.ToString()}\");\n        }\n        Console.WriteLine();\n\n        Console.WriteLine(\"Task 2: Smallest cyclotomic polynomial with n or -n as a coefficient:\");\n        for (int i = 1, n = 0; i <= 10; i++) {\n            while (true) {\n                n++;\n                var p = GetCyclotomicPolynomial(n);\n                if (p.Any(t => Math.Abs(t.Coefficient) == i)) {\n                    Console.WriteLine($\"CP[{n}] has coefficient with magnitude = {i}\");\n                    n--;\n                    break;\n                }\n            }\n        }\n    }\n\n    private const int MaxFactors = 100_000;\n    private const int Algorithm = 2;\n    private static readonly Term x = new Term(1, 1);\n    private static readonly Dictionary<int, Polynomial> polyCache =\n        new Dictionary<int, Polynomial> { [1] = x - 1 };\n    private static readonly Dictionary<int, IntMap> factorCache =\n        new Dictionary<int, IntMap> { [2] = new IntMap { [2] = 1 } };\n\n    private static Polynomial GetCyclotomicPolynomial(in int n) {\n        if (polyCache.TryGetValue(n, out var result)) return result;\n\n        var factors = GetFactors(n);\n        if (factors.ContainsKey(n)) { \n            result = new Polynomial(from exp in ..n select x[exp]);\n        } else if (factors.Count == 2 && factors.Contains(2, 1) && factors.Contains(n/2, 1)) { \n            result = new Polynomial(from i in ..(n/2) select (IsOdd(i) ? -x : x)[i]);\n        } else if (factors.Count == 1 && factors.TryGetValue(2, out int h)) { \n            result = x[1<<(h-1)] + 1;\n        } else if (factors.Count == 1 && !factors.ContainsKey(n)) { \n            (int p, int k) = factors.First();\n            result = new Polynomial(from i in ..p select x[i * (int)Math.Pow(p, k-1)]);\n        } else if (factors.Count == 2 && factors.ContainsKey(2)) { \n            (int p, int k) = factors.First(entry => entry.Key != 2);\n            int twoExp = 1 << (factors[2] - 1);\n            result = new Polynomial(from i in ..p select (IsOdd(i) ? -x : x)[i * twoExp * (int)Math.Pow(p, k-1)]);\n        } else if (factors.ContainsKey(2) && IsOdd(n/2) && n/2 > 1) { \n            Polynomial cycloDiv2 = GetCyclotomicPolynomial(n/2);\n            result = new Polynomial(from term in cycloDiv2 select IsOdd(term.Exponent) ? -term : term);\n            #pragma warning disable CS0162\n        } else if (Algorithm == 0) {\n            var divisors = GetDivisors(n);\n            result = x[n] - 1;\n            foreach (int d in divisors) result /= GetCyclotomicPolynomial(d);\n        } else if (Algorithm == 1) {\n            var divisors = GetDivisors(n).ToList();\n            int maxDivisor = divisors.Max();\n            result = (x[n] - 1) / (x[maxDivisor] - 1);\n            foreach (int d in divisors.Where(div => maxDivisor % div == 0)) {\n                result /= GetCyclotomicPolynomial(d);\n            }\n        } else if (Algorithm == 2) {\n            int m = 1;\n            result = GetCyclotomicPolynomial(m);\n            var primes = factors.Keys.ToList();\n            primes.Sort();\n            foreach (int prime in primes) {\n                var cycloM = result;\n                result = new Polynomial(from term in cycloM select term.Coefficient * x[term.Exponent * prime]);\n                result /= cycloM;\n                m *= prime;\n            }\n            int s = n / m;\n            result = new Polynomial(from term in result select term.Coefficient * x[term.Exponent * s]);\n            #pragma warning restore CS0162\n        } else {\n            throw new InvalidOperationException(\"Invalid algorithm\");\n        }\n        polyCache[n] = result;\n        return result;\n    }\n\n    private static bool IsOdd(int i) => (i & 1) != 0;\n    private static bool Contains(this IntMap map, int key, int value) => map.TryGetValue(key, out int v) && v == value;\n    private static int GetOrZero(this IntMap map, int key) => map.TryGetValue(key, out int v) ? v : 0;\n    private static IEnumerable<T> Select<T>(this Range r, Func<int, T> f) => Enumerable.Range(r.Start.Value, r.End.Value - r.Start.Value).Select(f);\n\n    private static IntMap GetFactors(in int n) {\n        if (factorCache.TryGetValue(n, out var factors)) return factors;\n\n        factors = new IntMap();\n        if (!IsOdd(n)) {\n            foreach (var entry in GetFactors(n/2)) factors.Add(entry.Key, entry.Value);\n            factors[2] = factors.GetOrZero(2) + 1;\n            return Cache(n, factors);\n        }\n        for (int i = 3; i * i <= n; i+=2) {\n            if (n % i == 0) {\n                foreach (var entry in GetFactors(n/i)) factors.Add(entry.Key, entry.Value);\n                factors[i] = factors.GetOrZero(i) + 1;\n                return Cache(n, factors);\n            }\n        }\n        factors[n] = 1;\n        return Cache(n, factors);\n    }\n\n    private static IntMap Cache(int n, IntMap factors) {\n        if (n < MaxFactors) factorCache[n] = factors;\n        return factors;\n    }\n\n    private static IEnumerable<int> GetDivisors(int n) {\n        for (int i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                yield return i;\n                int div = n / i;\n                if (div != i && div != n) yield return div;\n            }\n        }\n    }\n\n    public sealed class Polynomial : IEnumerable<Term>\n    {\n        public Polynomial() { }\n        public Polynomial(params Term[] terms) : this(terms.AsEnumerable()) { }\n\n        public Polynomial(IEnumerable<Term> terms) {\n            Terms.AddRange(terms);\n            Simplify();\n        }\n\n        private List<Term>? terms;\n        private List<Term> Terms => terms ??= new List<Term>();\n\n        public int Count => terms?.Count ?? 0;\n        public int Degree => Count == 0 ? -1 : Terms[0].Exponent;\n        public int LeadingCoefficient => Count == 0 ? 0 : Terms[0].Coefficient;\n\n        public IEnumerator<Term> GetEnumerator() => Terms.GetEnumerator();\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public override string ToString() => Count == 0 ? \"0\" : string.Join(\" + \", Terms).Replace(\"+ -\", \"- \");\n\n        public static Polynomial operator *(Polynomial p, Term t) => new Polynomial(from s in p select s * t);\n        public static Polynomial operator +(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms));\n        public static Polynomial operator -(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms.Select(t => -t)));\n        public static Polynomial operator *(Polynomial p, Polynomial q) => new Polynomial(from s in p from t in q select s * t);\n        public static Polynomial operator /(Polynomial p, Polynomial q) => p.Divide(q).quotient;\n\n        public (Polynomial quotient, Polynomial remainder) Divide(Polynomial divisor) {\n            if (Degree < 0) return (new Polynomial(), this);\n            Polynomial quotient = new Polynomial();\n            Polynomial remainder = this;\n            int lcv = divisor.LeadingCoefficient;\n            int dv = divisor.Degree;\n            while (remainder.Degree >= divisor.Degree) {\n                int lcr = remainder.LeadingCoefficient;\n                Term div = new Term(lcr / lcv, remainder.Degree - dv);\n                quotient.Terms.Add(div);\n                remainder += divisor * -div;\n            }\n            quotient.Simplify();\n            remainder.Simplify();\n            return (quotient, remainder);\n        }\n\n        private void Simplify() {\n            if (Count < 2) return;\n            Terms.Sort((a, b) => -a.CompareTo(b));\n            for (int i = Terms.Count - 1; i > 0; i--) {\n                Term s = Terms[i-1];\n                Term t = Terms[i];\n                if (t.Exponent == s.Exponent) {\n                    Terms[i-1] = new Term(s.Coefficient + t.Coefficient, s.Exponent);\n                    Terms.RemoveAt(i);\n                }\n            }\n            Terms.RemoveAll(t => t.IsZero);\n        }\n\n    }\n    \n    public readonly struct Term : IEquatable<Term>, IComparable<Term>\n    {\n        public Term(int coefficient, int exponent = 0) => (Coefficient, Exponent) = (coefficient, exponent);\n\n        public Term this[int exponent] => new Term(Coefficient, exponent); \n        public int Coefficient { get; }\n        public int Exponent { get; }\n        public bool IsZero => Coefficient == 0;\n\n        public static Polynomial operator +(Term left, Term right) => new Polynomial(left, right);\n        public static Polynomial operator -(Term left, Term right) => new Polynomial(left, -right);\n        public static implicit operator Term(int coefficient) => new Term(coefficient);\n        public static Term operator -(Term t) => new Term(-t.Coefficient, t.Exponent);\n        public static Term operator *(Term left, Term right) => new Term(left.Coefficient * right.Coefficient, left.Exponent + right.Exponent);\n\n        public static bool operator ==(Term left, Term right) => left.Equals(right);\n        public static bool operator !=(Term left, Term right) => !left.Equals(right);\n        public static bool operator  <(Term left, Term right) => left.CompareTo(right)  < 0;\n        public static bool operator  >(Term left, Term right) => left.CompareTo(right)  > 0;\n        public static bool operator <=(Term left, Term right) => left.CompareTo(right) <= 0;\n        public static bool operator >=(Term left, Term right) => left.CompareTo(right) >= 0;\n\n        public bool Equals(Term other) => Exponent == other.Exponent && Coefficient == other.Coefficient;\n        public override bool Equals(object? obj) => obj is Term t && Equals(t);\n        public override int GetHashCode() => Coefficient.GetHashCode() * 31 + Exponent.GetHashCode();\n\n        public int CompareTo(Term other) {\n            int c = Exponent.CompareTo(other.Exponent);\n            if (c != 0) return c;\n            return Coefficient.CompareTo(other.Coefficient);\n        }\n\n        public override string ToString() => (Coefficient, Exponent) switch {\n            (0,  _) => \"0\",\n            (_,  0) => $\"{Coefficient}\",\n            (1,  1) => \"x\",\n            (-1, 1) => \"-x\",\n            (_,  1) => $\"{Coefficient}x\",\n            (1,  _) => $\"x^{Exponent}\",\n            (-1, _) => $\"-x^{Exponent}\",\n                    _ => $\"{Coefficient}x^{Exponent}\"\n        };\n    }\n}\n"}
{"id": 400421, "name": "Cyclotomic polynomial", "source": "Translate Perl to C#: use feature 'say';\nuse List::Util qw(first);\nuse Math::Polynomial::Cyclotomic qw(cyclo_poly_iterate);\n\nsay 'First 30 cyclotomic polynomials:';\nmy $it = cyclo_poly_iterate(1);\nsay \"$_: \" . $it->() for 1 .. 30;\n\nsay \"\\nSmallest cyclotomic polynomial with n or -n as a coefficient:\";\n$it = cyclo_poly_iterate(1);\n\nfor (my ($n, $k) = (1, 1) ; $n <= 10 ; ++$k) {\n    my $poly = $it->();\n    while (my $c = first { abs($_) == $n } $poly->coeff) {\n        say \"CP $k has coefficient with magnitude = $n\";\n        $n++;\n    }\n}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing IntMap = System.Collections.Generic.Dictionary<int, int>;\n\npublic static class CyclotomicPolynomial\n{\n    public static void Main2() {\n        Console.WriteLine(\"Task 1: Cyclotomic polynomials for n <= 30:\");\n        for (int i = 1; i <= 30; i++) {\n            var p = GetCyclotomicPolynomial(i);\n            Console.WriteLine($\"CP[{i}] = {p.ToString()}\");\n        }\n        Console.WriteLine();\n\n        Console.WriteLine(\"Task 2: Smallest cyclotomic polynomial with n or -n as a coefficient:\");\n        for (int i = 1, n = 0; i <= 10; i++) {\n            while (true) {\n                n++;\n                var p = GetCyclotomicPolynomial(n);\n                if (p.Any(t => Math.Abs(t.Coefficient) == i)) {\n                    Console.WriteLine($\"CP[{n}] has coefficient with magnitude = {i}\");\n                    n--;\n                    break;\n                }\n            }\n        }\n    }\n\n    private const int MaxFactors = 100_000;\n    private const int Algorithm = 2;\n    private static readonly Term x = new Term(1, 1);\n    private static readonly Dictionary<int, Polynomial> polyCache =\n        new Dictionary<int, Polynomial> { [1] = x - 1 };\n    private static readonly Dictionary<int, IntMap> factorCache =\n        new Dictionary<int, IntMap> { [2] = new IntMap { [2] = 1 } };\n\n    private static Polynomial GetCyclotomicPolynomial(in int n) {\n        if (polyCache.TryGetValue(n, out var result)) return result;\n\n        var factors = GetFactors(n);\n        if (factors.ContainsKey(n)) { \n            result = new Polynomial(from exp in ..n select x[exp]);\n        } else if (factors.Count == 2 && factors.Contains(2, 1) && factors.Contains(n/2, 1)) { \n            result = new Polynomial(from i in ..(n/2) select (IsOdd(i) ? -x : x)[i]);\n        } else if (factors.Count == 1 && factors.TryGetValue(2, out int h)) { \n            result = x[1<<(h-1)] + 1;\n        } else if (factors.Count == 1 && !factors.ContainsKey(n)) { \n            (int p, int k) = factors.First();\n            result = new Polynomial(from i in ..p select x[i * (int)Math.Pow(p, k-1)]);\n        } else if (factors.Count == 2 && factors.ContainsKey(2)) { \n            (int p, int k) = factors.First(entry => entry.Key != 2);\n            int twoExp = 1 << (factors[2] - 1);\n            result = new Polynomial(from i in ..p select (IsOdd(i) ? -x : x)[i * twoExp * (int)Math.Pow(p, k-1)]);\n        } else if (factors.ContainsKey(2) && IsOdd(n/2) && n/2 > 1) { \n            Polynomial cycloDiv2 = GetCyclotomicPolynomial(n/2);\n            result = new Polynomial(from term in cycloDiv2 select IsOdd(term.Exponent) ? -term : term);\n            #pragma warning disable CS0162\n        } else if (Algorithm == 0) {\n            var divisors = GetDivisors(n);\n            result = x[n] - 1;\n            foreach (int d in divisors) result /= GetCyclotomicPolynomial(d);\n        } else if (Algorithm == 1) {\n            var divisors = GetDivisors(n).ToList();\n            int maxDivisor = divisors.Max();\n            result = (x[n] - 1) / (x[maxDivisor] - 1);\n            foreach (int d in divisors.Where(div => maxDivisor % div == 0)) {\n                result /= GetCyclotomicPolynomial(d);\n            }\n        } else if (Algorithm == 2) {\n            int m = 1;\n            result = GetCyclotomicPolynomial(m);\n            var primes = factors.Keys.ToList();\n            primes.Sort();\n            foreach (int prime in primes) {\n                var cycloM = result;\n                result = new Polynomial(from term in cycloM select term.Coefficient * x[term.Exponent * prime]);\n                result /= cycloM;\n                m *= prime;\n            }\n            int s = n / m;\n            result = new Polynomial(from term in result select term.Coefficient * x[term.Exponent * s]);\n            #pragma warning restore CS0162\n        } else {\n            throw new InvalidOperationException(\"Invalid algorithm\");\n        }\n        polyCache[n] = result;\n        return result;\n    }\n\n    private static bool IsOdd(int i) => (i & 1) != 0;\n    private static bool Contains(this IntMap map, int key, int value) => map.TryGetValue(key, out int v) && v == value;\n    private static int GetOrZero(this IntMap map, int key) => map.TryGetValue(key, out int v) ? v : 0;\n    private static IEnumerable<T> Select<T>(this Range r, Func<int, T> f) => Enumerable.Range(r.Start.Value, r.End.Value - r.Start.Value).Select(f);\n\n    private static IntMap GetFactors(in int n) {\n        if (factorCache.TryGetValue(n, out var factors)) return factors;\n\n        factors = new IntMap();\n        if (!IsOdd(n)) {\n            foreach (var entry in GetFactors(n/2)) factors.Add(entry.Key, entry.Value);\n            factors[2] = factors.GetOrZero(2) + 1;\n            return Cache(n, factors);\n        }\n        for (int i = 3; i * i <= n; i+=2) {\n            if (n % i == 0) {\n                foreach (var entry in GetFactors(n/i)) factors.Add(entry.Key, entry.Value);\n                factors[i] = factors.GetOrZero(i) + 1;\n                return Cache(n, factors);\n            }\n        }\n        factors[n] = 1;\n        return Cache(n, factors);\n    }\n\n    private static IntMap Cache(int n, IntMap factors) {\n        if (n < MaxFactors) factorCache[n] = factors;\n        return factors;\n    }\n\n    private static IEnumerable<int> GetDivisors(int n) {\n        for (int i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                yield return i;\n                int div = n / i;\n                if (div != i && div != n) yield return div;\n            }\n        }\n    }\n\n    public sealed class Polynomial : IEnumerable<Term>\n    {\n        public Polynomial() { }\n        public Polynomial(params Term[] terms) : this(terms.AsEnumerable()) { }\n\n        public Polynomial(IEnumerable<Term> terms) {\n            Terms.AddRange(terms);\n            Simplify();\n        }\n\n        private List<Term>? terms;\n        private List<Term> Terms => terms ??= new List<Term>();\n\n        public int Count => terms?.Count ?? 0;\n        public int Degree => Count == 0 ? -1 : Terms[0].Exponent;\n        public int LeadingCoefficient => Count == 0 ? 0 : Terms[0].Coefficient;\n\n        public IEnumerator<Term> GetEnumerator() => Terms.GetEnumerator();\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public override string ToString() => Count == 0 ? \"0\" : string.Join(\" + \", Terms).Replace(\"+ -\", \"- \");\n\n        public static Polynomial operator *(Polynomial p, Term t) => new Polynomial(from s in p select s * t);\n        public static Polynomial operator +(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms));\n        public static Polynomial operator -(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms.Select(t => -t)));\n        public static Polynomial operator *(Polynomial p, Polynomial q) => new Polynomial(from s in p from t in q select s * t);\n        public static Polynomial operator /(Polynomial p, Polynomial q) => p.Divide(q).quotient;\n\n        public (Polynomial quotient, Polynomial remainder) Divide(Polynomial divisor) {\n            if (Degree < 0) return (new Polynomial(), this);\n            Polynomial quotient = new Polynomial();\n            Polynomial remainder = this;\n            int lcv = divisor.LeadingCoefficient;\n            int dv = divisor.Degree;\n            while (remainder.Degree >= divisor.Degree) {\n                int lcr = remainder.LeadingCoefficient;\n                Term div = new Term(lcr / lcv, remainder.Degree - dv);\n                quotient.Terms.Add(div);\n                remainder += divisor * -div;\n            }\n            quotient.Simplify();\n            remainder.Simplify();\n            return (quotient, remainder);\n        }\n\n        private void Simplify() {\n            if (Count < 2) return;\n            Terms.Sort((a, b) => -a.CompareTo(b));\n            for (int i = Terms.Count - 1; i > 0; i--) {\n                Term s = Terms[i-1];\n                Term t = Terms[i];\n                if (t.Exponent == s.Exponent) {\n                    Terms[i-1] = new Term(s.Coefficient + t.Coefficient, s.Exponent);\n                    Terms.RemoveAt(i);\n                }\n            }\n            Terms.RemoveAll(t => t.IsZero);\n        }\n\n    }\n    \n    public readonly struct Term : IEquatable<Term>, IComparable<Term>\n    {\n        public Term(int coefficient, int exponent = 0) => (Coefficient, Exponent) = (coefficient, exponent);\n\n        public Term this[int exponent] => new Term(Coefficient, exponent); \n        public int Coefficient { get; }\n        public int Exponent { get; }\n        public bool IsZero => Coefficient == 0;\n\n        public static Polynomial operator +(Term left, Term right) => new Polynomial(left, right);\n        public static Polynomial operator -(Term left, Term right) => new Polynomial(left, -right);\n        public static implicit operator Term(int coefficient) => new Term(coefficient);\n        public static Term operator -(Term t) => new Term(-t.Coefficient, t.Exponent);\n        public static Term operator *(Term left, Term right) => new Term(left.Coefficient * right.Coefficient, left.Exponent + right.Exponent);\n\n        public static bool operator ==(Term left, Term right) => left.Equals(right);\n        public static bool operator !=(Term left, Term right) => !left.Equals(right);\n        public static bool operator  <(Term left, Term right) => left.CompareTo(right)  < 0;\n        public static bool operator  >(Term left, Term right) => left.CompareTo(right)  > 0;\n        public static bool operator <=(Term left, Term right) => left.CompareTo(right) <= 0;\n        public static bool operator >=(Term left, Term right) => left.CompareTo(right) >= 0;\n\n        public bool Equals(Term other) => Exponent == other.Exponent && Coefficient == other.Coefficient;\n        public override bool Equals(object? obj) => obj is Term t && Equals(t);\n        public override int GetHashCode() => Coefficient.GetHashCode() * 31 + Exponent.GetHashCode();\n\n        public int CompareTo(Term other) {\n            int c = Exponent.CompareTo(other.Exponent);\n            if (c != 0) return c;\n            return Coefficient.CompareTo(other.Coefficient);\n        }\n\n        public override string ToString() => (Coefficient, Exponent) switch {\n            (0,  _) => \"0\",\n            (_,  0) => $\"{Coefficient}\",\n            (1,  1) => \"x\",\n            (-1, 1) => \"-x\",\n            (_,  1) => $\"{Coefficient}x\",\n            (1,  _) => $\"x^{Exponent}\",\n            (-1, _) => $\"-x^{Exponent}\",\n                    _ => $\"{Coefficient}x^{Exponent}\"\n        };\n    }\n}\n"}
{"id": 400422, "name": "Minimal steps down to 1", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nno warnings 'recursion';\nuse List::Util qw( first );\nuse Data::Dump 'dd';\n\nfor ( [ 2000, [2, 3], [1] ], [ 2000, [2, 3], [2] ] )\n  {\n  my ( $n, $div, $sub ) = @$_;\n  print \"\\n\", '-' x 40, \" divisors @$div subtractors @$sub\\n\";\n  my ($solve, $max) = minimal( @$_ );\n  printf \"%4d takes %s step(s): %s\\n\",\n    $_, $solve->[$_] =~ tr/ // - 1, $solve->[$_] for 1 .. 10;\n  print \"\\n\";\n  printf \"%d number(s) below %d that take $\n    $max->[-1] =~ tr/ //, $n, $max->[-1];\n  ($solve, $max) = minimal( 20000, $div, $sub );\n  printf \"%d number(s) below %d that take $\n    $max->[-1] =~ tr/ //, 20000, $max->[-1];\n  }\n\nsub minimal\n  {\n  my ($top, $div, $sub) = @_;\n  my @solve = (0, ' ');\n  my @maximal;\n  for my $n ( 2 .. $top )\n    {\n    my @pick;\n    for my $d ( @$div )\n      {\n      $n % $d and next;\n      my $ans = \"/$d $solve[$n / $d]\";\n      $pick[$ans =~ tr/ //] //= $ans;\n      }\n    for my $s ( @$sub )\n      {\n      $n > $s or next;\n      my $ans = \"-$s $solve[$n - $s]\";\n      $pick[$ans =~ tr/ //] //= $ans;\n      }\n    $solve[$n] = first { defined  } @pick;\n    $maximal[$solve[$n] =~ tr/ // - 1] .= \" $n\";\n    }\n  return \\@solve, \\@maximal;\n  }\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MinimalSteps\n{\n    public static void Main() {\n        var (divisors, subtractors) = (new int[] { 2, 3 }, new [] { 1 });\n        var lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n        Console.WriteLine();\n\n        subtractors = new [] { 2 };\n        lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n    }\n\n    private static void PrintRange((char op, int param, int steps)[] lookup, int limit) {\n        for (int goal = 1; goal <= limit; goal++) {\n            var x = lookup[goal];\n            if (x.param == 0) {\n                Console.WriteLine($\"{goal} cannot be reached with these numbers.\");\n                continue;\n            }\n            Console.Write($\"{goal} takes {x.steps} {(x.steps == 1\u00a0? \"step\"\u00a0: \"steps\")}: \");\n            for (int n = goal; n > 1; ) {\n                Console.Write($\"{n},{x.op}{x.param}=> \");\n                n = x.op == '/' ? n / x.param : n - x.param;\n                x = lookup[n];\n            }\n            Console.WriteLine(\"1\");\n        }\n    }\n\n    private static void PrintMaxMins((char op, int param, int steps)[] lookup) {\n        var maxSteps = lookup.Max(x => x.steps);\n        var items = lookup.Select((x, i) => (i, x)).Where(t => t.x.steps == maxSteps).ToList();\n        Console.WriteLine(items.Count == 1\n            ? $\"There is one number below {lookup.Length-1} that requires {maxSteps} steps: {items[0].i}\"\n            : $\"There are {items.Count} numbers below {lookup.Length-1} that require {maxSteps} steps: {items.Select(t => t.i).Delimit()}\"\n        );\n    }\n\n    private static (char op, int param, int steps)[] CreateLookup(int goal, int[] divisors, int[] subtractors)\n    {\n        var lookup = new (char op, int param, int steps)[goal+1];\n        lookup[1] = ('/', 1, 0);\n        for (int n = 1; n < lookup.Length; n++) {\n            var ln = lookup[n];\n            if (ln.param == 0) continue;\n            for (int d = 0; d < divisors.Length; d++) {\n                int target = n * divisors[d];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('/', divisors[d], ln.steps + 1);\n            }\n            for (int s = 0; s < subtractors.Length; s++) {\n                int target = n + subtractors[s];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('-', subtractors[s], ln.steps + 1);\n            }\n        }\n        return lookup;\n    }\n\n    private static string Delimit<T>(this IEnumerable<T> source) => string.Join(\", \", source);\n}\n"}
{"id": 400423, "name": "Transportation problem", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils qw( max_by nsort_by min );\n\nmy $data = <<END;\nA=20 B=30 C=10\nS=25 T=35\nAS=3 BS=5 CS=7\nCT=3 BT=2 CT=5\nEND\n\nmy $table = sprintf +('%4s' x 4 . \"\\n\") x 3,\n  map {my $t = $_; map \"$_$t\", '', 'A' .. 'C' } '' , 'S' .. 'T';\n\nmy ($cost, %assign) = (0);\nwhile( $data =~ /\\b\\w=\\d/ ) {\n  my @penalty;\n  for ( $data =~ /\\b(\\w)=\\d/g ) {\n    my @all = map /(\\d+)/, nsort_by { /\\d+/ && $& }\n      grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n      $data =~ /$_\\w=\\d+|\\w$_=\\d+/g;\n    push @penalty, [ $_, ($all[1] // 0) - $all[0] ];\n  }\n  my $rc = (max_by { $_->[1] } nsort_by\n    { my $x = $_->[0]; $data =~ /(?:$x\\w|\\w$x)=(\\d+)/ && $1 } @penalty)->[0];\n  my @lowest = nsort_by { /\\d+/ && $& }\n    grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n    $data =~ /$rc\\w=\\d+|\\w$rc=\\d+/g;\n  my ($t, $c) = $lowest[0] =~ /(.)(.)/;\n  my $allocate = min $data =~ /\\b[$t$c]=(\\d+)/g;\n  $table =~ s/$t$c/ sprintf \"%2d\", $allocate/e;\n  $cost += $data =~ /$t$c=(\\d+)/ && $1 * $allocate;\n  $data =~ s/\\b$_=\\K\\d+/ $& - $allocate || '' /e for $t, $c;\n}\n\nsay my $result = \"cost $cost\\n\\n\" . $table =~ s/[A-Z]{2}/--/gr;\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nnamespace TransportationProblem {\n    class Shipment {\n        public Shipment(double q, double cpu, int r, int c) {\n            Quantity = q;\n            CostPerUnit = cpu;\n            R = r;\n            C = c;\n        }\n\n        public double CostPerUnit { get; }\n\n        public double Quantity { get; set; }\n\n        public int R { get; }\n\n        public int C { get; }\n    }\n\n    class Program {\n        private static int[] demand;\n        private static int[] supply;\n        private static double[,] costs;\n        private static Shipment[,] matrix;\n\n        static void Init(string filename) {\n            string line;\n            using (StreamReader file = new StreamReader(filename)) {\n                line = file.ReadLine();\n                var numArr = line.Split();\n                int numSources = int.Parse(numArr[0]);\n                int numDestinations = int.Parse(numArr[1]);\n\n                List<int> src = new List<int>();\n                List<int> dst = new List<int>();\n\n                line = file.ReadLine();\n                numArr = line.Split();\n                for (int i = 0; i < numSources; i++) {\n                    src.Add(int.Parse(numArr[i]));\n                }\n\n                line = file.ReadLine();\n                numArr = line.Split();\n                for (int i = 0; i < numDestinations; i++) {\n                    dst.Add(int.Parse(numArr[i]));\n                }\n\n                \n                int totalSrc = src.Sum();\n                int totalDst = dst.Sum();\n                if (totalSrc > totalDst) {\n                    dst.Add(totalSrc - totalDst);\n                } else if (totalDst > totalSrc) {\n                    src.Add(totalDst - totalSrc);\n                }\n\n                supply = src.ToArray();\n                demand = dst.ToArray();\n\n                costs = new double[supply.Length, demand.Length];\n                matrix = new Shipment[supply.Length, demand.Length];\n\n                for (int i = 0; i < numSources; i++) {\n                    line = file.ReadLine();\n                    numArr = line.Split();\n                    for (int j = 0; j < numDestinations; j++) {\n                        costs[i, j] = int.Parse(numArr[j]);\n                    }\n                }\n            }\n        }\n\n        static void NorthWestCornerRule() {\n            for (int r = 0, northwest = 0; r < supply.Length; r++) {\n                for (int c = northwest; c < demand.Length; c++) {\n                    int quantity = Math.Min(supply[r], demand[c]);\n                    if (quantity > 0) {\n                        matrix[r, c] = new Shipment(quantity, costs[r, c], r, c);\n\n                        supply[r] -= quantity;\n                        demand[c] -= quantity;\n\n                        if (supply[r] == 0) {\n                            northwest = c;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        static void SteppingStone() {\n            double maxReduction = 0;\n            Shipment[] move = null;\n            Shipment leaving = null;\n\n            FixDegenerateCase();\n\n            for (int r = 0; r < supply.Length; r++) {\n                for (int c = 0; c < demand.Length; c++) {\n                    if (matrix[r, c] != null) {\n                        continue;\n                    }\n\n                    Shipment trial = new Shipment(0, costs[r, c], r, c);\n                    Shipment[] path = GetClosedPath(trial);\n\n                    double reduction = 0;\n                    double lowestQuantity = int.MaxValue;\n                    Shipment leavingCandidate = null;\n\n                    bool plus = true;\n                    foreach (var s in path) {\n                        if (plus) {\n                            reduction += s.CostPerUnit;\n                        } else {\n                            reduction -= s.CostPerUnit;\n                            if (s.Quantity < lowestQuantity) {\n                                leavingCandidate = s;\n                                lowestQuantity = s.Quantity;\n                            }\n                        }\n                        plus = !plus;\n                    }\n                    if (reduction < maxReduction) {\n                        move = path;\n                        leaving = leavingCandidate;\n                        maxReduction = reduction;\n                    }\n                }\n            }\n\n            if (move != null) {\n                double q = leaving.Quantity;\n                bool plus = true;\n                foreach (var s in move) {\n                    s.Quantity += plus ? q : -q;\n                    matrix[s.R, s.C] = s.Quantity == 0 ? null : s;\n                    plus = !plus;\n                }\n                SteppingStone();\n            }\n        }\n\n        static List<Shipment> MatrixToList() {\n            List<Shipment> newList = new List<Shipment>();\n            foreach (var item in matrix) {\n                if (null != item) {\n                    newList.Add(item);\n                }\n            }\n            return newList;\n        }\n\n        static Shipment[] GetClosedPath(Shipment s) {\n            List<Shipment> path = MatrixToList();\n            path.Add(s);\n\n            \n            \n            int before;\n            do {\n                before = path.Count;\n                path.RemoveAll(ship => {\n                    var nbrs = GetNeighbors(ship, path);\n                    return nbrs[0] == null || nbrs[1] == null;\n                });\n            } while (before != path.Count);\n\n            \n            Shipment[] stones = path.ToArray();\n            Shipment prev = s;\n            for (int i = 0; i < stones.Length; i++) {\n                stones[i] = prev;\n                prev = GetNeighbors(prev, path)[i % 2];\n            }\n            return stones;\n        }\n\n        static Shipment[] GetNeighbors(Shipment s, List<Shipment> lst) {\n            Shipment[] nbrs = new Shipment[2];\n            foreach (var o in lst) {\n                if (o != s) {\n                    if (o.R == s.R && nbrs[0] == null) {\n                        nbrs[0] = o;\n                    } else if (o.C == s.C && nbrs[1] == null) {\n                        nbrs[1] = o;\n                    }\n                    if (nbrs[0] != null && nbrs[1] != null) {\n                        break;\n                    }\n                }\n            }\n            return nbrs;\n        }\n\n        static void FixDegenerateCase() {\n            const double eps = double.Epsilon;\n            if (supply.Length + demand.Length - 1 != MatrixToList().Count) {\n                for (int r = 0; r < supply.Length; r++) {\n                    for (int c = 0; c < demand.Length; c++) {\n                        if (matrix[r, c] == null) {\n                            Shipment dummy = new Shipment(eps, costs[r, c], r, c);\n                            if (GetClosedPath(dummy).Length == 0) {\n                                matrix[r, c] = dummy;\n                                return;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        static void PrintResult(string filename) {\n            Console.WriteLine(\"Optimal solution {0}\\n\", filename);\n            double totalCosts = 0;\n\n            for (int r = 0; r < supply.Length; r++) {\n                for (int c = 0; c < demand.Length; c++) {\n                    Shipment s = matrix[r, c];\n                    if (s != null && s.R == r && s.C == c) {\n                        Console.Write(\" {0,3} \", s.Quantity);\n                        totalCosts += (s.Quantity * s.CostPerUnit);\n                    } else {\n                        Console.Write(\"  -  \");\n                    }\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nTotal costs: {0}\\n\", totalCosts);\n        }\n\n        static void Main() {\n            foreach (var filename in new string[] { \"input1.txt\", \"input2.txt\", \"input3.txt\" }) {\n                Init(filename);\n                NorthWestCornerRule();\n                SteppingStone();\n                PrintResult(filename);\n            }\n        }\n    }\n}\n"}
{"id": 400424, "name": "HTTPS_Client-authenticated", "source": "Translate Perl to C#: \nuse 5.018_002;\nuse warnings;\nuse LWP;\n\nour $VERSION = 1.000_000;\n\nmy $ua = LWP::UserAgent->new(\n    ssl_opts => {\n        SSL_cert_file   => 'certificate.pem',\n        SSL_key_file    => 'key.pem',\n        verify_hostname => 1,\n    }\n);\nmy $req = HTTP::Request->new( GET => 'https://www.example.com' );\nmy $res = $ua->request($req);\nif ( $res->is_success ) {\n    say $res->content;\n}\nelse {\n    say $res->status_line;\n}\n", "target": "using System;\nusing System.Net;\n\nclass Program\n{\n    class MyWebClient : WebClient\n    {\n        protected override WebRequest GetWebRequest(Uri address)\n        {\n            HttpWebRequest request = (HttpWebRequest)base.GetWebRequest(address);\n            request.ClientCertificates.Add(new X509Certificate());\n            return request;\n        }\n    }\n    static void Main(string[] args)\n    {\n        var client = new MyWebClient();\n\n        var data = client.DownloadString(\"https:\n\n        Console.WriteLine(data);\n    }\n}\n"}
{"id": 400425, "name": "SQL-based authentication", "source": "Translate Perl to C#: use DBI;\n\n \nsub connect_db {\n    my ($dbname, $host, $user, $pass) = @_;\n    my $db = DBI->connect(\"dbi:mysql:$dbname:$host\", $user, $pass)\n        or die $DBI::errstr;\n    $db->{RaiseError} = 1;\n    $db\n}\n\n \n \nsub create_user {\n    my ($db, $user, $pass) = @_;\n    my $salt = pack \"C*\", map {int rand 256} 1..16;\n    $db->do(\"INSERT IGNORE INTO users (username, pass_salt, pass_md5)\n        VALUES (?,\u00a0?, unhex(md5(concat(pass_salt,\u00a0?))))\",\n        undef, $user, $salt, $pass)\n      and $db->{mysql_insertid} or undef\n}\n\n \nsub authenticate_user {\n    my ($db, $user, $pass) = @_;\n    my $userid = $db->selectrow_array(\"SELECT userid FROM users WHERE\n        username=? AND pass_md5=unhex(md5(concat(pass_salt,\u00a0?)))\",\n        undef, $user, $pass);\n    $userid\n}\n", "target": "using System.Security.Cryptography;\nusing System.Text;\n\nnamespace rosettaMySQL\n{\n    class Hasher\n    {\n        private static string _BytesToHex(byte[] input)\n        {\n            var strBuilder = new StringBuilder();\n            foreach (byte _byte in input)\n            {\n                strBuilder.Append(_byte.ToString(\"x2\"));\n            }\n            return strBuilder.ToString();\n        }\n\n        public static string Hash(string salt, string input)\n        {\n            using (MD5 md5 = new MD5CryptoServiceProvider())\n            {\n                var bytes = Encoding.Default.GetBytes(salt + input);\n                var data = md5.ComputeHash(bytes);\n                return _BytesToHex(data);\n            }\n        }\n\n        public static string GenSalt()\n        {\n            using (RandomNumberGenerator rng = new RNGCryptoServiceProvider())\n            {\n                var salt = new byte[16];\n                rng.GetBytes(salt);\n                return _BytesToHex(salt);\n            }\n        }\n    }\n}\n"}
{"id": 400426, "name": "Tarjan", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature <say state current_sub>;\nuse List::Util qw(min);\n\nsub tarjan {\n    my (%k) = @_;\n    my (%onstack, %index, %lowlink, @stack, @connected);\n\n    my sub strong_connect {\n        my ($vertex, $i) = @_;\n        $index{$vertex}   = $i;\n        $lowlink{$vertex} = $i + 1;\n        $onstack{$vertex} = 1;\n        push @stack, $vertex;\n        for my $connection (@{$k{$vertex}}) {\n            if (not defined $index{$connection}) {\n                __SUB__->($connection, $i + 1);\n                $lowlink{$vertex} = min($lowlink{$connection}, $lowlink{$vertex});\n            }\n            elsif ($onstack{$connection}) {\n                $lowlink{$vertex} = min($index{$connection}, $lowlink{$vertex});\n            }\n        }\n        if ($lowlink{$vertex} eq $index{$vertex}) {\n            my @node;\n            do {\n                push @node, pop @stack;\n                $onstack{$node[-1]} = 0;\n            } while $node[-1] ne $vertex;\n            push @connected, [@node];\n        }\n    }\n\n    for (sort keys %k) {\n        strong_connect($_, 0) unless $index{$_};\n    }\n    @connected;\n}\n\nmy %test1 = (\n             0 => [1],\n             1 => [2],\n             2 => [0],\n             3 => [1, 2, 4],\n             4 => [3, 5],\n             5 => [2, 6],\n             6 => [5],\n             7 => [4, 6, 7]\n            );\n\nmy %test2 = (\n             'Andy' => ['Bart'],\n             'Bart' => ['Carl'],\n             'Carl' => ['Andy'],\n             'Dave' => [qw<Bart Carl Earl>],\n             'Earl' => [qw<Dave Fred>],\n             'Fred' => [qw<Carl Gary>],\n             'Gary' => ['Fred'],\n             'Hank' => [qw<Earl Gary Hank>]\n            );\n\nprint \"Strongly connected components:\\n\";\nprint join(', ', sort @$_) . \"\\n\" for tarjan(%test1);\nprint \"\\nStrongly connected components:\\n\";\nprint join(', ', sort @$_) . \"\\n\" for tarjan(%test2);\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Node\n{\n    public int LowLink { get; set; }\n    public int Index { get; set; }\n    public int N { get; }\n\n    public Node(int n)\n    {\n        N = n;\n        Index = -1;\n        LowLink = 0;\n    }\n}\n\nclass Graph\n{\n    public HashSet<Node> V { get; }\n    public Dictionary<Node, HashSet<Node>> Adj { get; }\n\n    \n    \n    \n    public void Tarjan()\n    {\n        var index = 0; \n        var S = new Stack<Node>();\n\n        Action<Node> StrongConnect = null;\n        StrongConnect = (v) =>\n        {\n            \n            v.Index = index;\n            v.LowLink = index;\n\n            index++;\n            S.Push(v);\n\n            \n            foreach (var w in Adj[v])\n                if (w.Index < 0)\n                {\n                    \n                    StrongConnect(w);\n                    v.LowLink = Math.Min(v.LowLink, w.LowLink);\n                }\n                else if (S.Contains(w))\n                    \n                    v.LowLink = Math.Min(v.LowLink, w.Index);\n\n            \n            if (v.LowLink == v.Index)\n            {\n                Console.Write(\"SCC: \");\n\n                Node w;\n                do\n                {\n                    w = S.Pop();\n                    Console.Write(w.N + \" \");\n                } while (w != v);\n\n                Console.WriteLine();\n            }\n        };\n\n        foreach (var v in V)\n            if (v.Index < 0)\n                StrongConnect(v);\n    }\n}\n"}
{"id": 400427, "name": "Time-based one-time password algorithm", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\n\nuse Authen::OATH;\n\nmy $message = \"show me the monKey\"; \n\nmy $oath = Authen::OATH->new(); \n\nfor ( my $t = 2177452800 ; $t < 2177452919 ; $t += 13 ) {\n   print \"At \", scalar gmtime $t, \"\u00a0: \", $oath->totp( $message, $t ), \"\\n\" ;\n}\n", "target": "using System;\nusing System.Security.Cryptography;\n\nnamespace RosettaTOTP\n{\n    public class TOTP_SHA1\n    {\n        private byte[] K;\n        public TOTP_SHA1()\n        {\n            GenerateKey();\n        }\n        public void GenerateKey()\n        {\n            using (RandomNumberGenerator rng = new RNGCryptoServiceProvider())\n            {\n                \n                K = new byte[HMACSHA1.Create().HashSize / 8];\n                rng.GetBytes(K);\n            }\n        }\n        public int HOTP(UInt64 C, int digits = 6)\n        {\n            var hmac = HMACSHA1.Create();\n            hmac.Key = K;\n            hmac.ComputeHash(BitConverter.GetBytes(C));\n            return Truncate(hmac.Hash, digits);\n        }\n        public UInt64 CounterNow(int T1 = 30)\n        {\n            var secondsSinceEpoch = (DateTime.UtcNow - new DateTime(1970, 1, 1, 0, 0, 0, DateTimeKind.Utc)).TotalSeconds;\n            return (UInt64)Math.Floor(secondsSinceEpoch / T1);\n        }\n        private int DT(byte[] hmac_result)\n        {\n            int offset = hmac_result[19] & 0xf;\n            int bin_code = (hmac_result[offset] & 0x7f) << 24\n               | (hmac_result[offset + 1] & 0xff) << 16\n               | (hmac_result[offset + 2] & 0xff) << 8\n               | (hmac_result[offset + 3] & 0xff);\n            return bin_code;\n        }\n\n        private int Truncate(byte[] hmac_result, int digits)\n        {\n            var Snum = DT(hmac_result);\n            return Snum % (int)Math.Pow(10, digits);\n        }\n    }\n\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var totp = new TOTP_SHA1();\n            Console.WriteLine(totp.HOTP(totp.CounterNow()));\n        }\n    }\n}\n"}
{"id": 400428, "name": "Pentomino tiling", "source": "Translate Perl to C#: use strict; \nuse warnings;\nuse feature 'bitwise';\n\nmy $size = shift // 8;\n\nsub rotate\n  {\n  local $_ = shift;\n  my $ans = '';\n  $ans .= \"\\n\" while s/.$/$ans .= $&; ''/gem;\n  $ans;\n  }\n\nsub topattern\n  {\n  local $_ = shift;\n  s/.+/ $& . ' ' x ($size - length $&)/ge;\n  s/^\\s+|\\s+\\z//g;\n  [ tr/ \\nA-Z/.. /r, lc tr/ \\n/\\0/r, substr $_, 0, 1 ]; \n  }\n\nmy %all;\n@all{ \" FF\\nFF \\n F \\n\", \"IIIII\\n\", \"LLLL\\nL   \\n\", \"NNN \\n  NN\\n\",\n  \"PPP\\nPP \\n\", \"TTT\\n T \\n T \\n\", \"UUU\\nU U\\n\", \"VVV\\nV  \\nV  \\n\",\n  \"WW \\n WW\\n  W\\n\", \" X \\nXXX\\n X \\n\", \"YYYY\\n Y  \\n\", \"ZZ \\n Z \\n ZZ\\n\",\n  } = ();\n@all{map rotate($_), keys %all} = () for 1 .. 3;  \n@all{map s/.+/reverse $&/ger, keys %all} = ();    \nmy @all = map topattern($_), keys %all;\nmy $grid = ( ' ' x $size . \"\\n\" ) x $size;\nmy %used;\nfind( $grid );\n\n\nsub find\n  {\n  my $grid = shift;\n  %used >= 12 and exit not print $grid;\n  for ( grep ! $used{ $_->[2] }, @all )\n    {\n    my ($pattern, $pentomino, $letter) = @$_;\n    local $used{$letter} = 1;\n    $grid =~ /^[^ ]*\\K$pattern/s and find( $grid ^. \"\\0\" x $-[0] . $pentomino );\n    }\n  }\n", "target": "using System;\nusing System.Linq;\n\nnamespace PentominoTiling\n{\n    class Program\n    {\n        static readonly char[] symbols = \"FILNPTUVWXYZ-\".ToCharArray();\n\n        static readonly int nRows = 8;\n        static readonly int nCols = 8;\n        static readonly int target = 12;\n        static readonly int blank = 12;\n\n        static int[][] grid = new int[nRows][];\n        static bool[] placed = new bool[target];\n\n        static void Main(string[] args)\n        {\n            var rand = new Random();\n\n            for (int r = 0; r < nRows; r++)\n                grid[r] = Enumerable.Repeat(-1, nCols).ToArray();\n\n            for (int i = 0; i < 4; i++)\n            {\n                int randRow, randCol;\n                do\n                {\n                    randRow = rand.Next(nRows);\n                    randCol = rand.Next(nCols);\n                } \n                while (grid[randRow][randCol] == blank);\n\n                grid[randRow][randCol] = blank;\n            }\n\n            if (Solve(0, 0))\n            {\n                PrintResult();\n            }\n            else\n            {\n                Console.WriteLine(\"no solution\");\n            }\n\n            Console.ReadKey();\n        }\n\n        private static void PrintResult()\n        {\n            foreach (int[] r in grid)\n            {\n                foreach (int i in r)\n                    Console.Write(\"{0} \", symbols[i]);\n                Console.WriteLine();\n            }\n        }\n\n        private static bool Solve(int pos, int numPlaced)\n        {\n            if (numPlaced == target)\n                return true;\n\n            int row = pos / nCols;\n            int col = pos % nCols;\n\n            if (grid[row][col] != -1)\n                return Solve(pos + 1, numPlaced);\n\n            for (int i = 0; i < shapes.Length; i++)\n            {\n                if (!placed[i])\n                {\n                    foreach (int[] orientation in shapes[i])\n                    {\n                        if (!TryPlaceOrientation(orientation, row, col, i))\n                            continue;\n\n                        placed[i] = true;\n\n                        if (Solve(pos + 1, numPlaced + 1))\n                            return true;\n\n                        RemoveOrientation(orientation, row, col);\n                        placed[i] = false;\n                    }\n                }\n            }\n            return false;\n        }\n\n        private static void RemoveOrientation(int[] orientation, int row, int col)\n        {\n            grid[row][col] = -1;\n            for (int i = 0; i < orientation.Length; i += 2)\n                grid[row + orientation[i]][col + orientation[i + 1]] = -1;\n        }\n\n        private static bool TryPlaceOrientation(int[] orientation, int row, int col, int shapeIndex)\n        {\n            for (int i = 0; i < orientation.Length; i += 2)\n            {\n                int x = col + orientation[i + 1];\n                int y = row + orientation[i];\n                if (x < 0 || x >= nCols || y < 0 || y >= nRows || grid[y][x] != -1)\n                    return false;\n            }\n\n            grid[row][col] = shapeIndex;\n            for (int i = 0; i < orientation.Length; i += 2)\n                grid[row + orientation[i]][col + orientation[i + 1]] = shapeIndex;\n\n            return true;\n        }\n\n        \n        static readonly int[][] F = {\n            new int[] {1, -1, 1, 0, 1, 1, 2, 1}, new int[] {0, 1, 1, -1, 1, 0, 2, 0},\n            new int[] {1, 0, 1, 1, 1, 2, 2, 1}, new int[] {1, 0, 1, 1, 2, -1, 2, 0},\n            new int[] {1, -2, 1, -1, 1, 0, 2, -1}, new int[] {0, 1, 1, 1, 1, 2, 2, 1},\n            new int[] {1, -1, 1, 0, 1, 1, 2, -1}, new int[] {1, -1, 1, 0, 2, 0, 2, 1}};\n\n        static readonly int[][] I = {\n            new int[] { 0, 1, 0, 2, 0, 3, 0, 4 }, new int[] { 1, 0, 2, 0, 3, 0, 4, 0 } };\n\n        static readonly int[][] L = {\n            new int[] {1, 0, 1, 1, 1, 2, 1, 3}, new int[] {1, 0, 2, 0, 3, -1, 3, 0},\n            new int[] {0, 1, 0, 2, 0, 3, 1, 3}, new int[] {0, 1, 1, 0, 2, 0, 3, 0},\n            new int[] {0, 1, 1, 1, 2, 1, 3, 1}, new int[] {0, 1, 0, 2, 0, 3, 1, 0},\n            new int[] {1, 0, 2, 0, 3, 0, 3, 1}, new int[] {1, -3, 1, -2, 1, -1, 1, 0}};\n\n        static readonly int[][] N = {\n            new int[] {0, 1, 1, -2, 1, -1, 1, 0}, new int[] {1, 0, 1, 1, 2, 1, 3, 1},\n            new int[]  {0, 1, 0, 2, 1, -1, 1, 0}, new int[] {1, 0, 2, 0, 2, 1, 3, 1},\n            new int[] {0, 1, 1, 1, 1, 2, 1, 3}, new int[] {1, 0, 2, -1, 2, 0, 3, -1},\n            new int[] {0, 1, 0, 2, 1, 2, 1, 3}, new int[] {1, -1, 1, 0, 2, -1, 3, -1}};\n\n        static readonly int[][] P = {\n            new int[] {0, 1, 1, 0, 1, 1, 2, 1}, new int[] {0, 1, 0, 2, 1, 0, 1, 1},\n            new int[] {1, 0, 1, 1, 2, 0, 2, 1}, new int[] {0, 1, 1, -1, 1, 0, 1, 1},\n            new int[] {0, 1, 1, 0, 1, 1, 1, 2}, new int[] {1, -1, 1, 0, 2, -1, 2, 0},\n            new int[] {0, 1, 0, 2, 1, 1, 1, 2}, new int[] {0, 1, 1, 0, 1, 1, 2, 0}};\n\n        static readonly int[][] T = {\n            new int[] {0, 1, 0, 2, 1, 1, 2, 1}, new int[] {1, -2, 1, -1, 1, 0, 2, 0},\n            new int[] {1, 0, 2, -1, 2, 0, 2, 1}, new int[] {1, 0, 1, 1, 1, 2, 2, 0}};\n\n        static readonly int[][] U = {\n            new int[] {0, 1, 0, 2, 1, 0, 1, 2}, new int[] {0, 1, 1, 1, 2, 0, 2, 1},\n            new int[]  {0, 2, 1, 0, 1, 1, 1, 2}, new int[] {0, 1, 1, 0, 2, 0, 2, 1}};\n\n        static readonly int[][] V = {\n            new int[] {1, 0, 2, 0, 2, 1, 2, 2}, new int[] {0, 1, 0, 2, 1, 0, 2, 0},\n            new int[] {1, 0, 2, -2, 2, -1, 2, 0}, new int[] {0, 1, 0, 2, 1, 2, 2, 2}};\n\n        static readonly int[][] W = {\n            new int[] {1, 0, 1, 1, 2, 1, 2, 2}, new int[] {1, -1, 1, 0, 2, -2, 2, -1},\n            new int[] {0, 1, 1, 1, 1, 2, 2, 2}, new int[] {0, 1, 1, -1, 1, 0, 2, -1}};\n\n        static readonly int[][] X = { new int[] { 1, -1, 1, 0, 1, 1, 2, 0 } };\n\n        static readonly int[][] Y = {\n            new int[] {1, -2, 1, -1, 1, 0, 1, 1}, new int[] {1, -1, 1, 0, 2, 0, 3, 0},\n            new int[] {0, 1, 0, 2, 0, 3, 1, 1}, new int[] {1, 0, 2, 0, 2, 1, 3, 0},\n            new int[] {0, 1, 0, 2, 0, 3, 1, 2}, new int[] {1, 0, 1, 1, 2, 0, 3, 0},\n            new int[] {1, -1, 1, 0, 1, 1, 1, 2}, new int[] {1, 0, 2, -1, 2, 0, 3, 0}};\n\n        static readonly int[][] Z = {\n            new int[] {0, 1, 1, 0, 2, -1, 2, 0}, new int[] {1, 0, 1, 1, 1, 2, 2, 2},\n            new int[] {0, 1, 1, 1, 2, 1, 2, 2}, new int[] {1, -2, 1, -1, 1, 0, 2, -2}};\n\n        static readonly int[][][] shapes = { F, I, L, N, P, T, U, V, W, X, Y, Z };\n    }\n}\n"}
{"id": 415396, "name": "Next special primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature <state say>;\nuse ntheory 'primes';\n\nmy $limit = 1050;\n\nsub is_special {\n    state $previous = 2;\n    state $gap      = 0;\n    state @primes = @{primes( 2*$limit )};\n\n    shift @primes while $primes[0] <= $previous + $gap;\n    $gap = $primes[0] - $previous;\n    $previous = $primes[0];\n    [$previous, $gap];\n}\n\nmy @specials = [2, 0];\ndo { push @specials, is_special() } until $specials[-1][0] >= $limit;\n\npop @specials;\nprintf \"%4d %4d\\n\", @$_ for @specials;\n", "target": "class SpecialPrimes {\n    private static boolean isPrime(int n) {\n        if (n < 2)  return false;\n        if (n%2 == 0) return n == 2;\n        if (n%3 == 0) return n == 3;\n        int d = 5;\n        while (d*d <= n) {\n            if (n%d == 0) return false;\n            d += 2;\n            if (n%d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Special primes under 1,050:\");\n        System.out.println(\"Prime1 Prime2 Gap\");\n        int lastSpecial = 3;\n        int lastGap = 1;\n        System.out.printf(\"%6d %6d %3d\\n\", 2, 3, lastGap);\n        for (int i = 5; i < 1050; i += 2) {\n            if (isPrime(i) && (i-lastSpecial) > lastGap) {\n                lastGap = i - lastSpecial;\n                System.out.printf(\"%6d %6d %3d\\n\", lastSpecial, i, lastGap);\n                lastSpecial = i;\n            }\n        }\n    }\n}\n"}
{"id": 415397, "name": "Largest number divisible by its digits", "source": "Translate Perl to Java: my $step = 9 * 8 * 7;                               \n\nmy $initial = int(9876432 / $step) * $step;         \n\nfor($test = $initial; $test > 0 ; $test -= $step) { \n    next if $test =~ /[05]/;                        \n    next if $test =~ /(.).*\\1/;                     \n\n    for (split '', $test) {                         \n        next unless ($test / $_) % 1;\n    }\n\n    printf \"Found $test after %d steps\\n\", ($initial-$test)/$step;\n    for (split '', $test) {\n       printf \"%s / %s = %s\\n\", $test, $_, $test / $_;\n    }\n    last\n}\n", "target": "public class LynchBell {\n    \n    static String s = \"\";\n    \n    public static void main(String args[]) {\n        \n        int i = 98764321;\n        boolean isUnique = true;\n        boolean canBeDivided = true;\n        while (i>0) {\n            s = String.valueOf(i);\n            isUnique = uniqueDigits(i);\n            if (isUnique) {\n                \n                canBeDivided = testNumber(i);\n                if(canBeDivided) {\n                    System.out.println(\"Number found: \" + i);\n                    i=0;\n                }\n            }\n            i--;\n        }\n    }\n    \n    public static boolean uniqueDigits(int i) {\n        \n        for (int k = 0; k<s.length();k++) {\n            for(int l=k+1; l<s.length();l++) {\n                if(s.charAt(l)=='0' || s.charAt(l)=='5') {\n                    \n                    return false;\n                }\n                if(s.charAt(k) == s.charAt(l)) {\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    public static boolean testNumber(int i) {\n        \n        int j = 0;\n        boolean divisible = true;\n        \n        for (char ch: s.toCharArray()) {\n            j = Character.getNumericValue(ch);\n            divisible = ((i%j)==0);\n            if (!divisible) {\n                return false;\n            }\n        }       \n        return true;\n    }\n}\n"}
{"id": 415398, "name": "Largest number divisible by its digits", "source": "Translate Perl to Java: my $step = 9 * 8 * 7;                               \n\nmy $initial = int(9876432 / $step) * $step;         \n\nfor($test = $initial; $test > 0 ; $test -= $step) { \n    next if $test =~ /[05]/;                        \n    next if $test =~ /(.).*\\1/;                     \n\n    for (split '', $test) {                         \n        next unless ($test / $_) % 1;\n    }\n\n    printf \"Found $test after %d steps\\n\", ($initial-$test)/$step;\n    for (split '', $test) {\n       printf \"%s / %s = %s\\n\", $test, $_, $test / $_;\n    }\n    last\n}\n", "target": "public class LynchBell {\n    \n    static String s = \"\";\n    \n    public static void main(String args[]) {\n        \n        int i = 98764321;\n        boolean isUnique = true;\n        boolean canBeDivided = true;\n        while (i>0) {\n            s = String.valueOf(i);\n            isUnique = uniqueDigits(i);\n            if (isUnique) {\n                \n                canBeDivided = testNumber(i);\n                if(canBeDivided) {\n                    System.out.println(\"Number found: \" + i);\n                    i=0;\n                }\n            }\n            i--;\n        }\n    }\n    \n    public static boolean uniqueDigits(int i) {\n        \n        for (int k = 0; k<s.length();k++) {\n            for(int l=k+1; l<s.length();l++) {\n                if(s.charAt(l)=='0' || s.charAt(l)=='5') {\n                    \n                    return false;\n                }\n                if(s.charAt(k) == s.charAt(l)) {\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    public static boolean testNumber(int i) {\n        \n        int j = 0;\n        boolean divisible = true;\n        \n        for (char ch: s.toCharArray()) {\n            j = Character.getNumericValue(ch);\n            divisible = ((i%j)==0);\n            if (!divisible) {\n                return false;\n            }\n        }       \n        return true;\n    }\n}\n"}
{"id": 415399, "name": "Jacobi symbol", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub J {\n    my($k,$n) = @_;\n\n    $k %= $n;\n    my $jacobi = 1;\n    while ($k) {\n        while (0 == $k % 2) {\n            $k = int $k / 2;\n            $jacobi *= -1 if $n%8 == 3 or $n%8 == 5;\n        }\n        ($k, $n) = ($n, $k);\n        $jacobi *= -1 if $n%4 == 3 and $k%4 == 3;\n        $k %= $n;\n    }\n    $n == 1 ? $jacobi : 0\n}\n\nmy $maxa = 1 + (my $maxn = 29);\n\nprint 'n\\k';\nprintf '%4d', $_ for 1..$maxa;\nprint \"\\n\";\nprint '   ' . '-' x (4 * $maxa) . \"\\n\";\n\nfor my $n (1..$maxn) {\n    next if 0 == $n % 2;\n    printf '%3d', $n;\n    printf '%4d', J($_, $n) for 1..$maxa;\n    print \"\\n\"\n}\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 415400, "name": "Jacobi symbol", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub J {\n    my($k,$n) = @_;\n\n    $k %= $n;\n    my $jacobi = 1;\n    while ($k) {\n        while (0 == $k % 2) {\n            $k = int $k / 2;\n            $jacobi *= -1 if $n%8 == 3 or $n%8 == 5;\n        }\n        ($k, $n) = ($n, $k);\n        $jacobi *= -1 if $n%4 == 3 and $k%4 == 3;\n        $k %= $n;\n    }\n    $n == 1 ? $jacobi : 0\n}\n\nmy $maxa = 1 + (my $maxn = 29);\n\nprint 'n\\k';\nprintf '%4d', $_ for 1..$maxa;\nprint \"\\n\";\nprint '   ' . '-' x (4 * $maxa) . \"\\n\";\n\nfor my $n (1..$maxn) {\n    next if 0 == $n % 2;\n    printf '%3d', $n;\n    printf '%4d', J($_, $n) for 1..$maxa;\n    print \"\\n\"\n}\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 415401, "name": "Determinant and permanent", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\nuse PDL;\nuse PDL::NiceSlice;\n\nsub permanent{\n\tmy $mat = shift;\n\tmy $n = shift // $mat->dim(0);\n\treturn undef if $mat->dim(0) != $mat->dim(1);\n\treturn $mat(0,0) if $n == 1;\n\tmy $sum = 0;\n\t--$n;\n\tmy $m = $mat(1:,1:)->copy;\n\tfor(my $i = 0; $i <= $n; ++$i){\n\t\t$sum += $mat($i,0) * permanent($m, $n);\n\t\tlast if $i == $n;\n\t\t$m($i,:) .= $mat($i,1:);\n\t}\n\treturn sclr($sum);\n}\n\nmy $M = pdl([[2,9,4], [7,5,3], [6,1,8]]);\nprint \"M = $M\\n\";\nprint \"det(M) = \" . $M->determinant . \".\\n\";\nprint \"det(M) = \" . $M->det . \".\\n\";\nprint \"perm(M) = \" . permanent($M) . \".\\n\";\n", "target": "import java.util.Scanner;\n\npublic class MatrixArithmetic {\n\tpublic static double[][] minor(double[][] a, int x, int y){\n\t\tint length = a.length-1;\n\t\tdouble[][] result = new double[length][length];\n\t\tfor(int i=0;i<length;i++) for(int j=0;j<length;j++){\n\t\t\tif(i<x && j<y){\n\t\t\t\tresult[i][j] = a[i][j];\n\t\t\t}else if(i>=x && j<y){\n\t\t\t\tresult[i][j] = a[i+1][j];\n\t\t\t}else if(i<x && j>=y){\n\t\t\t\tresult[i][j] = a[i][j+1];\n\t\t\t}else{ \n\t\t\t\tresult[i][j] = a[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static double det(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tint sign = 1;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += sign * a[0][i] * det(minor(a,0,i));\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static double perm(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += a[0][i] * perm(minor(a,0,i));\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint size = sc.nextInt();\n\t\tdouble[][] a = new double[size][size];\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<size;j++){\n\t\t\ta[i][j] = sc.nextDouble();\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(\"Determinant: \"+det(a));\n\t\tSystem.out.println(\"Permanent: \"+perm(a));\n\t}\n}\n"}
{"id": 415402, "name": "Determinant and permanent", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\nuse PDL;\nuse PDL::NiceSlice;\n\nsub permanent{\n\tmy $mat = shift;\n\tmy $n = shift // $mat->dim(0);\n\treturn undef if $mat->dim(0) != $mat->dim(1);\n\treturn $mat(0,0) if $n == 1;\n\tmy $sum = 0;\n\t--$n;\n\tmy $m = $mat(1:,1:)->copy;\n\tfor(my $i = 0; $i <= $n; ++$i){\n\t\t$sum += $mat($i,0) * permanent($m, $n);\n\t\tlast if $i == $n;\n\t\t$m($i,:) .= $mat($i,1:);\n\t}\n\treturn sclr($sum);\n}\n\nmy $M = pdl([[2,9,4], [7,5,3], [6,1,8]]);\nprint \"M = $M\\n\";\nprint \"det(M) = \" . $M->determinant . \".\\n\";\nprint \"det(M) = \" . $M->det . \".\\n\";\nprint \"perm(M) = \" . permanent($M) . \".\\n\";\n", "target": "import java.util.Scanner;\n\npublic class MatrixArithmetic {\n\tpublic static double[][] minor(double[][] a, int x, int y){\n\t\tint length = a.length-1;\n\t\tdouble[][] result = new double[length][length];\n\t\tfor(int i=0;i<length;i++) for(int j=0;j<length;j++){\n\t\t\tif(i<x && j<y){\n\t\t\t\tresult[i][j] = a[i][j];\n\t\t\t}else if(i>=x && j<y){\n\t\t\t\tresult[i][j] = a[i+1][j];\n\t\t\t}else if(i<x && j>=y){\n\t\t\t\tresult[i][j] = a[i][j+1];\n\t\t\t}else{ \n\t\t\t\tresult[i][j] = a[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static double det(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tint sign = 1;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += sign * a[0][i] * det(minor(a,0,i));\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static double perm(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += a[0][i] * perm(minor(a,0,i));\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint size = sc.nextInt();\n\t\tdouble[][] a = new double[size][size];\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<size;j++){\n\t\t\ta[i][j] = sc.nextDouble();\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(\"Determinant: \"+det(a));\n\t\tSystem.out.println(\"Permanent: \"+perm(a));\n\t}\n}\n"}
{"id": 415403, "name": "Sattolo cycle", "source": "Translate Perl to Java: @a = 0..30;\n\nprintf \"%2d \", $_ for @a; print \"\\n\";\nsattolo_cycle(\\@a);\nprintf \"%2d \", $_ for @a; print \"\\n\";\n\nsub sattolo_cycle {\n    my($array) = @_;\n    for $i (reverse 0 .. -1+@$array) {\n        my $j = int rand $i;\n        @$array[$j, $i] = @$array[$i, $j];\n    }\n}\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 415404, "name": "FTP", "source": "Translate Perl to Java: use Net::FTP;\n\n\nmy $host     = 'speedtest.tele2.net';\nmy $user     = 'anonymous';\nmy $password = '';\n\n\nmy $f = Net::FTP->new($host) or die \"Can't open $host\\n\";\n$f->login($user, $password)  or die \"Can't login as $user\\n\";\n$f->passive();\n\n\n$f->cwd('upload');\n@files = $f->ls();\nprintf \"Currently %d files in the 'upload' directory.\\n\", @files;\n\n\n$f->cwd('/');\n$f->type('binary');\n$local = $f->get('512KB.zip');\nprint \"Your file was stored as $local in the current directory\\n\";\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPFile;\nimport org.apache.commons.net.ftp.FTPReply;\n\npublic class FTPconn {\n\n    public static void main(String[] args) throws IOException {\n        String server = \"ftp.hq.nasa.gov\";\n        int port = 21;\n        String user = \"anonymous\";\n        String pass = \"ftptest@example.com\";\n\n        OutputStream output = null;\n\n        FTPClient ftpClient = new FTPClient();\n        try {\n            ftpClient.connect(server, port);\n\n            serverReply(ftpClient);\n\n            int replyCode = ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                System.out.println(\"Failure. Server reply code: \" + replyCode);\n                return;\n            }\n\n            serverReply(ftpClient);\n\n            if (!ftpClient.login(user, pass)) {\n                System.out.println(\"Could not login to the server.\");\n                return;\n            }\n\n            String dir = \"pub/issoutreach/Living in Space Stories (MP3 Files)/\";\n            if (!ftpClient.changeWorkingDirectory(dir)) {\n                System.out.println(\"Change directory failed.\");\n                return;\n            }\n\n            ftpClient.enterLocalPassiveMode();\n\n            for (FTPFile file : ftpClient.listFiles())\n                System.out.println(file);\n\n            String filename = \"Can People go to Mars.mp3\";\n            output = new FileOutputStream(filename);\n\n            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);\n            if (!ftpClient.retrieveFile(filename, output)) {\n                System.out.println(\"Retrieving file failed\");\n                return;\n            }\n\n            serverReply(ftpClient);\n\n            ftpClient.logout();\n\n        } finally {\n            if (output != null)\n                output.close();\n        }\n    }\n\n    private static void serverReply(FTPClient ftpClient) {\n        for (String reply : ftpClient.getReplyStrings()) {\n            System.out.println(reply);\n        }\n    }\n}\n"}
{"id": 415405, "name": "Sorting algorithms_Cycle sort", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub cycleSort :prototype(@) {\n\tmy ($array) = @_;\n\tmy $writes = 0;\n\t\n\tmy @alreadysorted;\n\t\n\t\n\tfor my $start ( 0 .. $\n\t\tnext if $alreadysorted[$start];\n\t\tmy $item = $array->[$start];\n\t\t\n\t\t\n\t\tmy $pos = $start + grep $array->[$_] lt $item, $start + 1 .. $\n\t\t\n\t\tnext if $pos == $start;\n\t\t\n\t\t\n\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\n\t\t\n\t\t($array->[ $pos ], $item) = ($item, $array->[ $pos ]);\n\t\t++$writes;\n\n\t\t\n\t\tdo {\n\t\t\t\n\t\t\t$pos = $start + grep $array->[$_] lt $item, $start+1 .. $\n\t\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\t\n\t\t\t($array->[ $pos ] , $item ) = ($item, $array->[ $pos ]);\n\t\t\t\n\t\t\t$alreadysorted[ $pos ] = 1;\n\t\t\t++$writes;\n\t\t\t\n\t\t} while $pos != $start;\n\t}\n\t$writes;\n}\n\nuse List::Util 'shuffle';\nmy @test = shuffle( ('a'..'z') x 2 );\nprint \"Before sorting: @test\\n\";\nprint \"There were \", cycleSort( \\@test ), \" writes\\n\";\nprint \"After  sorting: @test\\n\";\n", "target": "import java.util.Arrays;\n\npublic class CycleSort {\n\n    public static void main(String[] args) {\n        int[] arr = {5, 0, 1, 2, 2, 3, 5, 1, 1, 0, 5, 6, 9, 8, 0, 1};\n\n        System.out.println(Arrays.toString(arr));\n\n        int writes = cycleSort(arr);\n        System.out.println(Arrays.toString(arr));\n        System.out.println(\"writes: \" + writes);\n    }\n\n    static int cycleSort(int[] a) {\n        int writes = 0;\n\n        for (int cycleStart = 0; cycleStart < a.length - 1; cycleStart++) {\n            int val = a[cycleStart];\n\n            \n            \n            int pos = cycleStart;\n            for (int i = cycleStart + 1; i < a.length; i++)\n                if (a[i] < val)\n                    pos++;\n\n            \n            if (pos == cycleStart)\n                continue;\n\n            \n            while (val == a[pos])\n                pos++;\n\n            \n            int tmp = a[pos];\n            a[pos] = val;\n            val = tmp;\n            writes++;\n\n            \n            \n            while (pos != cycleStart) {\n                pos = cycleStart;\n                for (int i = cycleStart + 1; i < a.length; i++)\n                    if (a[i] < val)\n                        pos++;\n\n                while (val == a[pos])\n                    pos++;\n\n                tmp = a[pos];\n                a[pos] = val;\n                val = tmp;\n                writes++;\n            }\n        }\n        return writes;\n    }\n}\n"}
{"id": 415406, "name": "Sorting algorithms_Cycle sort", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub cycleSort :prototype(@) {\n\tmy ($array) = @_;\n\tmy $writes = 0;\n\t\n\tmy @alreadysorted;\n\t\n\t\n\tfor my $start ( 0 .. $\n\t\tnext if $alreadysorted[$start];\n\t\tmy $item = $array->[$start];\n\t\t\n\t\t\n\t\tmy $pos = $start + grep $array->[$_] lt $item, $start + 1 .. $\n\t\t\n\t\tnext if $pos == $start;\n\t\t\n\t\t\n\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\n\t\t\n\t\t($array->[ $pos ], $item) = ($item, $array->[ $pos ]);\n\t\t++$writes;\n\n\t\t\n\t\tdo {\n\t\t\t\n\t\t\t$pos = $start + grep $array->[$_] lt $item, $start+1 .. $\n\t\t\t++$pos while $item eq $array->[ $pos ];\n\t\t\t\n\t\t\t($array->[ $pos ] , $item ) = ($item, $array->[ $pos ]);\n\t\t\t\n\t\t\t$alreadysorted[ $pos ] = 1;\n\t\t\t++$writes;\n\t\t\t\n\t\t} while $pos != $start;\n\t}\n\t$writes;\n}\n\nuse List::Util 'shuffle';\nmy @test = shuffle( ('a'..'z') x 2 );\nprint \"Before sorting: @test\\n\";\nprint \"There were \", cycleSort( \\@test ), \" writes\\n\";\nprint \"After  sorting: @test\\n\";\n", "target": "import java.util.Arrays;\n\npublic class CycleSort {\n\n    public static void main(String[] args) {\n        int[] arr = {5, 0, 1, 2, 2, 3, 5, 1, 1, 0, 5, 6, 9, 8, 0, 1};\n\n        System.out.println(Arrays.toString(arr));\n\n        int writes = cycleSort(arr);\n        System.out.println(Arrays.toString(arr));\n        System.out.println(\"writes: \" + writes);\n    }\n\n    static int cycleSort(int[] a) {\n        int writes = 0;\n\n        for (int cycleStart = 0; cycleStart < a.length - 1; cycleStart++) {\n            int val = a[cycleStart];\n\n            \n            \n            int pos = cycleStart;\n            for (int i = cycleStart + 1; i < a.length; i++)\n                if (a[i] < val)\n                    pos++;\n\n            \n            if (pos == cycleStart)\n                continue;\n\n            \n            while (val == a[pos])\n                pos++;\n\n            \n            int tmp = a[pos];\n            a[pos] = val;\n            val = tmp;\n            writes++;\n\n            \n            \n            while (pos != cycleStart) {\n                pos = cycleStart;\n                for (int i = cycleStart + 1; i < a.length; i++)\n                    if (a[i] < val)\n                        pos++;\n\n                while (val == a[pos])\n                    pos++;\n\n                tmp = a[pos];\n                a[pos] = val;\n                val = tmp;\n                writes++;\n            }\n        }\n        return writes;\n    }\n}\n"}
{"id": 415407, "name": "Twin primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse Primesieve;\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nprintf \"Twin prime pairs less than %14s: %s\\n\", comma(10**$_), comma count_twins(1, 10**$_) for 1..10;\n", "target": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class twinPrimes {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Search Size: \");\n        BigInteger max = input.nextBigInteger();\n        int counter = 0;\n        for(BigInteger x = new BigInteger(\"3\"); x.compareTo(max) <= 0; x = x.add(BigInteger.ONE)){\n            BigInteger sqrtNum = x.sqrt().add(BigInteger.ONE);\n            if(x.add(BigInteger.TWO).compareTo(max) <= 0) {\n                counter += findPrime(x.add(BigInteger.TWO), x.add(BigInteger.TWO).sqrt().add(BigInteger.ONE)) && findPrime(x, sqrtNum) ? 1 : 0;\n            }\n        }\n        System.out.println(counter + \" twin prime pairs.\");\n    }\n    public static boolean findPrime(BigInteger x, BigInteger sqrtNum){\n        for(BigInteger divisor = BigInteger.TWO; divisor.compareTo(sqrtNum) <= 0; divisor = divisor.add(BigInteger.ONE)){\n            if(x.remainder(divisor).compareTo(BigInteger.ZERO) == 0){\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"}
{"id": 415408, "name": "Brazilian numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory qw<is_prime>;\nuse constant Inf  => 1e10;\n\nsub is_Brazilian {\n    my($n) = @_;\n    return 1 if $n > 6 && 0 == $n%2;\n    LOOP: for (my $base = 2; $base < $n - 1; ++$base) {\n        my $digit;\n        my $nn = $n;\n        while (1) {\n            my $x = $nn % $base;\n            $digit //= $x;\n            next LOOP if $digit != $x;\n            $nn = int $nn / $base;\n            if ($nn < $base) {\n                return 1 if $digit == $nn;\n                next LOOP;\n            }\n        }\n    }\n}\n\nmy $upto = 20;\n\nprint \"First $upto Brazilian numbers:\\n\";\nmy $n = 0;\nprint do { $n < $upto ? (is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto odd Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!($_%2) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto prime Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!is_prime($_) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 415409, "name": "Brazilian numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory qw<is_prime>;\nuse constant Inf  => 1e10;\n\nsub is_Brazilian {\n    my($n) = @_;\n    return 1 if $n > 6 && 0 == $n%2;\n    LOOP: for (my $base = 2; $base < $n - 1; ++$base) {\n        my $digit;\n        my $nn = $n;\n        while (1) {\n            my $x = $nn % $base;\n            $digit //= $x;\n            next LOOP if $digit != $x;\n            $nn = int $nn / $base;\n            if ($nn < $base) {\n                return 1 if $digit == $nn;\n                next LOOP;\n            }\n        }\n    }\n}\n\nmy $upto = 20;\n\nprint \"First $upto Brazilian numbers:\\n\";\nmy $n = 0;\nprint do { $n < $upto ? (is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto odd Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!($_%2) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto prime Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!is_prime($_) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 415410, "name": "Recaman's sequence", "source": "Translate Perl to Java: use bignum;\n\n$max = 1000;\n$remaining += $_ for 1..$max;\n\nmy @recamans = 0;\nmy $previous = 0;\n\nwhile ($remaining > 0) {\n   $term++;\n   my $this = $previous - $term;\n   $this = $previous + $term unless $this > 0 and !$seen{$this};\n   push @recamans, $this;\n   $dup = $term if !$dup and defined $seen{$this};\n   $remaining -= $this if $this <= $max and ! defined $seen{$this};\n   $seen{$this}++;\n   $previous = $this;\n}\n\nprint \"First fifteen terms of Recaman's sequence: \" . join(' ', @recamans[0..14]) . \"\\n\";\nprint \"First duplicate at term: a[$dup]\\n\";\nprint \"Range 0..1000 covered by terms up to a[$term]\\n\";\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 415411, "name": "Recaman's sequence", "source": "Translate Perl to Java: use bignum;\n\n$max = 1000;\n$remaining += $_ for 1..$max;\n\nmy @recamans = 0;\nmy $previous = 0;\n\nwhile ($remaining > 0) {\n   $term++;\n   my $this = $previous - $term;\n   $this = $previous + $term unless $this > 0 and !$seen{$this};\n   push @recamans, $this;\n   $dup = $term if !$dup and defined $seen{$this};\n   $remaining -= $this if $this <= $max and ! defined $seen{$this};\n   $seen{$this}++;\n   $previous = $this;\n}\n\nprint \"First fifteen terms of Recaman's sequence: \" . join(' ', @recamans[0..14]) . \"\\n\";\nprint \"First duplicate at term: a[$dup]\\n\";\nprint \"Range 0..1000 covered by terms up to a[$term]\\n\";\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 415412, "name": "Y combinator", "source": "Translate Perl to Java: sub Y { my $f = shift;                                \n    sub { my $x = shift; $x->($x) }->(                \n\tsub {my $y = shift; $f->(sub {$y->($y)(@_)})} \n    )\n}\nmy $fac = sub {my $f = shift;\n    sub {my $n = shift; $n < 2 ? 1 : $n * $f->($n-1)}\n};\nmy $fib = sub {my $f = shift;\n    sub {my $n = shift; $n == 0 ? 0 : $n == 1 ? 1 : $f->($n-1) + $f->($n-2)}\n};\nfor my $f ($fac, $fib) {\n    print join(' ', map Y($f)->($_), 0..9), \"\\n\";\n}\n", "target": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}\n"}
{"id": 415413, "name": "Total circles area", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::AllUtils <min max>;\n\nmy @circles = (\n    [ 1.6417233788,  1.6121789534, 0.0848270516],\n    [-1.4944608174,  1.2077959613, 1.1039549836],\n    [ 0.6110294452, -0.6907087527, 0.9089162485],\n    [ 0.3844862411,  0.2923344616, 0.2375743054],\n    [-0.2495892950, -0.3832854473, 1.0845181219],\n    [ 1.7813504266,  1.6178237031, 0.8162655711],\n    [-0.1985249206, -0.8343333301, 0.0538864941],\n    [-1.7011985145, -0.1263820964, 0.4776976918],\n    [-0.4319462812,  1.4104420482, 0.7886291537],\n    [ 0.2178372997, -0.9499557344, 0.0357871187],\n    [-0.6294854565, -1.3078893852, 0.7653357688],\n    [ 1.7952608455,  0.6281269104, 0.2727652452],\n    [ 1.4168575317,  1.0683357171, 1.1016025378],\n    [ 1.4637371396,  0.9463877418, 1.1846214562],\n    [-0.5263668798,  1.7315156631, 1.4428514068],\n    [-1.2197352481,  0.9144146579, 1.0727263474],\n    [-0.1389358881,  0.1092805780, 0.7350208828],\n    [ 1.5293954595,  0.0030278255, 1.2472867347],\n    [-0.5258728625,  1.3782633069, 1.3495508831],\n    [-0.1403562064,  0.2437382535, 1.3804956588],\n    [ 0.8055826339, -0.0482092025, 0.3327165165],\n    [-0.6311979224,  0.7184578971, 0.2491045282],\n    [ 1.4685857879, -0.8347049536, 1.3670667538],\n    [-0.6855727502,  1.6465021616, 1.0593087096],\n    [ 0.0152957411,  0.0638919221, 0.9771215985],\n);\n\nmy $x_min = min map { $_->[0] - $_->[2] } @circles;\nmy $x_max = max map { $_->[0] + $_->[2] } @circles;\nmy $y_min = min map { $_->[1] - $_->[2] } @circles;\nmy $y_max = max map { $_->[1] + $_->[2] } @circles;\n\nmy $box_side = 500;\nmy $dx = ($x_max - $x_min) / $box_side;\nmy $dy = ($y_max - $y_min) / $box_side;\nmy $count = 0;\n\nfor my $r (0..$box_side) {\n    my $y = $y_min + $r * $dy;\n    for my $c (0..$box_side) {\n        my $x = $x_min + $c * $dx;\n        for my $c (@circles) {\n            $count++ and last if ($x - $$c[0])**2 + ($y - $$c[1])**2 <= $$c[2]**2\n        }\n    }\n}\n\nprintf \"Approximated area:\u00a0%.9f\\n\", $count * $dx * $dy;\n", "target": "public class CirclesTotalArea {\n\n    \n    \n    private static double distSq(double x1, double y1, double x2, double y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n    \n    private static boolean rectangleFullyInsideCircle(double[] rect, double[] circ) {\n        double r2 = circ[2] * circ[2];\n        \n        return distSq(rect[0], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) <= r2;\n    }\n    \n    private static boolean rectangleSurelyOutsideCircle(double[] rect, double[] circ) {\n        \n        if(rect[0] <= circ[0] && circ[0] <= rect[0] + rect[2] &&\n          rect[1] - rect[3] <= circ[1] && circ[1] <= rect[1]) { return false; }\n        \n        double r2 = circ[2] + Math.max(rect[2], rect[3]);\n        r2 = r2 * r2;\n        return distSq(rect[0], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) >= r2;\n    }\n    \n    private static boolean[] surelyOutside;\n    \n    private static double totalArea(double[] rect, double[][] circs, int d) {    \n        \n        int surelyOutsideCount = 0;\n        for(int i = 0; i < circs.length; i++) {\n            if(rectangleFullyInsideCircle(rect, circs[i])) { return rect[2] * rect[3]; }\n            if(rectangleSurelyOutsideCircle(rect, circs[i])) {\n                surelyOutside[i] = true;\n                surelyOutsideCount++;\n            }\n            else { surelyOutside[i] = false; }\n        }\n        \n        if(surelyOutsideCount == circs.length) { return 0; }\n        \n        if(d < 1) { \n            return rect[2] * rect[3] / 3;  \n        }\n        \n        if(surelyOutsideCount > 0) {\n            double[][] newCircs = new double[circs.length - surelyOutsideCount][3];\n            int loc = 0;\n            for(int i = 0; i < circs.length; i++) {\n                if(!surelyOutside[i]) { newCircs[loc++] = circs[i]; }\n            }\n            circs = newCircs;\n        }\n        \n        double w = rect[2] / 2; \n        double h = rect[3] / 2; \n        double[][] pieces = {\n            { rect[0], rect[1], w, h }, \n            { rect[0] + w, rect[1], w, h }, \n            { rect[0], rect[1] - h, w, h }, \n            { rect[0] + w, rect[1] - h, w, h } \n        };\n        double total = 0;\n        for(double[] piece: pieces) { total += totalArea(piece, circs, d - 1); }\n        return total;\n    }\n    \n    public static double totalArea(double[][] circs, int d) {\n        double maxx = Double.NEGATIVE_INFINITY;\n        double minx = Double.POSITIVE_INFINITY;\n        double maxy = Double.NEGATIVE_INFINITY;\n        double miny = Double.POSITIVE_INFINITY;\n        \n        for(double[] circ: circs) {\n            if(circ[0] + circ[2] > maxx) { maxx = circ[0] + circ[2]; }\n            if(circ[0] - circ[2] < minx) { minx = circ[0] - circ[2]; }\n            if(circ[1] + circ[2] > maxy) { maxy = circ[1] + circ[2]; }\n            if(circ[1] - circ[2] < miny) { miny = circ[1] - circ[2]; }\n        }\n        double[] rect = { minx, maxy, maxx - minx, maxy - miny };\n        surelyOutside = new boolean[circs.length];\n        return totalArea(rect, circs, d);\n    }\n    \n    public static void main(String[] args) {\n        double[][] circs = {\n            { 1.6417233788, 1.6121789534, 0.0848270516 },\n            {-1.4944608174, 1.2077959613, 1.1039549836 },\n            { 0.6110294452, -0.6907087527, 0.9089162485 },\n            { 0.3844862411, 0.2923344616, 0.2375743054 },\n            {-0.2495892950, -0.3832854473, 1.0845181219 },\n            {1.7813504266, 1.6178237031, 0.8162655711 },\n            {-0.1985249206, -0.8343333301, 0.0538864941 },\n            {-1.7011985145, -0.1263820964, 0.4776976918 },\n            {-0.4319462812, 1.4104420482, 0.7886291537 },\n            {0.2178372997, -0.9499557344, 0.0357871187 },\n            {-0.6294854565, -1.3078893852, 0.7653357688 },\n            {1.7952608455, 0.6281269104, 0.2727652452 },\n            {1.4168575317, 1.0683357171, 1.1016025378 },\n            {1.4637371396, 0.9463877418, 1.1846214562 },\n            {-0.5263668798, 1.7315156631, 1.4428514068 },\n            {-1.2197352481, 0.9144146579, 1.0727263474 },\n            {-0.1389358881, 0.1092805780, 0.7350208828 },\n            {1.5293954595, 0.0030278255, 1.2472867347 },\n            {-0.5258728625, 1.3782633069, 1.3495508831 },\n            {-0.1403562064, 0.2437382535, 1.3804956588 },\n            {0.8055826339, -0.0482092025, 0.3327165165 },\n            {-0.6311979224, 0.7184578971, 0.2491045282 },\n            {1.4685857879, -0.8347049536, 1.3670667538 },\n            {-0.6855727502, 1.6465021616, 1.0593087096 },\n            {0.0152957411, 0.0638919221, 0.9771215985 }\n        };\n        double ans = totalArea(circs, 24);\n        System.out.println(\"Approx. area is \" + ans);\n        System.out.println(\"Error is \" + Math.abs(21.56503660 - ans));\n    }\n}\n"}
{"id": 415414, "name": "Total circles area", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::AllUtils <min max>;\n\nmy @circles = (\n    [ 1.6417233788,  1.6121789534, 0.0848270516],\n    [-1.4944608174,  1.2077959613, 1.1039549836],\n    [ 0.6110294452, -0.6907087527, 0.9089162485],\n    [ 0.3844862411,  0.2923344616, 0.2375743054],\n    [-0.2495892950, -0.3832854473, 1.0845181219],\n    [ 1.7813504266,  1.6178237031, 0.8162655711],\n    [-0.1985249206, -0.8343333301, 0.0538864941],\n    [-1.7011985145, -0.1263820964, 0.4776976918],\n    [-0.4319462812,  1.4104420482, 0.7886291537],\n    [ 0.2178372997, -0.9499557344, 0.0357871187],\n    [-0.6294854565, -1.3078893852, 0.7653357688],\n    [ 1.7952608455,  0.6281269104, 0.2727652452],\n    [ 1.4168575317,  1.0683357171, 1.1016025378],\n    [ 1.4637371396,  0.9463877418, 1.1846214562],\n    [-0.5263668798,  1.7315156631, 1.4428514068],\n    [-1.2197352481,  0.9144146579, 1.0727263474],\n    [-0.1389358881,  0.1092805780, 0.7350208828],\n    [ 1.5293954595,  0.0030278255, 1.2472867347],\n    [-0.5258728625,  1.3782633069, 1.3495508831],\n    [-0.1403562064,  0.2437382535, 1.3804956588],\n    [ 0.8055826339, -0.0482092025, 0.3327165165],\n    [-0.6311979224,  0.7184578971, 0.2491045282],\n    [ 1.4685857879, -0.8347049536, 1.3670667538],\n    [-0.6855727502,  1.6465021616, 1.0593087096],\n    [ 0.0152957411,  0.0638919221, 0.9771215985],\n);\n\nmy $x_min = min map { $_->[0] - $_->[2] } @circles;\nmy $x_max = max map { $_->[0] + $_->[2] } @circles;\nmy $y_min = min map { $_->[1] - $_->[2] } @circles;\nmy $y_max = max map { $_->[1] + $_->[2] } @circles;\n\nmy $box_side = 500;\nmy $dx = ($x_max - $x_min) / $box_side;\nmy $dy = ($y_max - $y_min) / $box_side;\nmy $count = 0;\n\nfor my $r (0..$box_side) {\n    my $y = $y_min + $r * $dy;\n    for my $c (0..$box_side) {\n        my $x = $x_min + $c * $dx;\n        for my $c (@circles) {\n            $count++ and last if ($x - $$c[0])**2 + ($y - $$c[1])**2 <= $$c[2]**2\n        }\n    }\n}\n\nprintf \"Approximated area:\u00a0%.9f\\n\", $count * $dx * $dy;\n", "target": "public class CirclesTotalArea {\n\n    \n    \n    private static double distSq(double x1, double y1, double x2, double y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n    \n    private static boolean rectangleFullyInsideCircle(double[] rect, double[] circ) {\n        double r2 = circ[2] * circ[2];\n        \n        return distSq(rect[0], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) <= r2;\n    }\n    \n    private static boolean rectangleSurelyOutsideCircle(double[] rect, double[] circ) {\n        \n        if(rect[0] <= circ[0] && circ[0] <= rect[0] + rect[2] &&\n          rect[1] - rect[3] <= circ[1] && circ[1] <= rect[1]) { return false; }\n        \n        double r2 = circ[2] + Math.max(rect[2], rect[3]);\n        r2 = r2 * r2;\n        return distSq(rect[0], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) >= r2;\n    }\n    \n    private static boolean[] surelyOutside;\n    \n    private static double totalArea(double[] rect, double[][] circs, int d) {    \n        \n        int surelyOutsideCount = 0;\n        for(int i = 0; i < circs.length; i++) {\n            if(rectangleFullyInsideCircle(rect, circs[i])) { return rect[2] * rect[3]; }\n            if(rectangleSurelyOutsideCircle(rect, circs[i])) {\n                surelyOutside[i] = true;\n                surelyOutsideCount++;\n            }\n            else { surelyOutside[i] = false; }\n        }\n        \n        if(surelyOutsideCount == circs.length) { return 0; }\n        \n        if(d < 1) { \n            return rect[2] * rect[3] / 3;  \n        }\n        \n        if(surelyOutsideCount > 0) {\n            double[][] newCircs = new double[circs.length - surelyOutsideCount][3];\n            int loc = 0;\n            for(int i = 0; i < circs.length; i++) {\n                if(!surelyOutside[i]) { newCircs[loc++] = circs[i]; }\n            }\n            circs = newCircs;\n        }\n        \n        double w = rect[2] / 2; \n        double h = rect[3] / 2; \n        double[][] pieces = {\n            { rect[0], rect[1], w, h }, \n            { rect[0] + w, rect[1], w, h }, \n            { rect[0], rect[1] - h, w, h }, \n            { rect[0] + w, rect[1] - h, w, h } \n        };\n        double total = 0;\n        for(double[] piece: pieces) { total += totalArea(piece, circs, d - 1); }\n        return total;\n    }\n    \n    public static double totalArea(double[][] circs, int d) {\n        double maxx = Double.NEGATIVE_INFINITY;\n        double minx = Double.POSITIVE_INFINITY;\n        double maxy = Double.NEGATIVE_INFINITY;\n        double miny = Double.POSITIVE_INFINITY;\n        \n        for(double[] circ: circs) {\n            if(circ[0] + circ[2] > maxx) { maxx = circ[0] + circ[2]; }\n            if(circ[0] - circ[2] < minx) { minx = circ[0] - circ[2]; }\n            if(circ[1] + circ[2] > maxy) { maxy = circ[1] + circ[2]; }\n            if(circ[1] - circ[2] < miny) { miny = circ[1] - circ[2]; }\n        }\n        double[] rect = { minx, maxy, maxx - minx, maxy - miny };\n        surelyOutside = new boolean[circs.length];\n        return totalArea(rect, circs, d);\n    }\n    \n    public static void main(String[] args) {\n        double[][] circs = {\n            { 1.6417233788, 1.6121789534, 0.0848270516 },\n            {-1.4944608174, 1.2077959613, 1.1039549836 },\n            { 0.6110294452, -0.6907087527, 0.9089162485 },\n            { 0.3844862411, 0.2923344616, 0.2375743054 },\n            {-0.2495892950, -0.3832854473, 1.0845181219 },\n            {1.7813504266, 1.6178237031, 0.8162655711 },\n            {-0.1985249206, -0.8343333301, 0.0538864941 },\n            {-1.7011985145, -0.1263820964, 0.4776976918 },\n            {-0.4319462812, 1.4104420482, 0.7886291537 },\n            {0.2178372997, -0.9499557344, 0.0357871187 },\n            {-0.6294854565, -1.3078893852, 0.7653357688 },\n            {1.7952608455, 0.6281269104, 0.2727652452 },\n            {1.4168575317, 1.0683357171, 1.1016025378 },\n            {1.4637371396, 0.9463877418, 1.1846214562 },\n            {-0.5263668798, 1.7315156631, 1.4428514068 },\n            {-1.2197352481, 0.9144146579, 1.0727263474 },\n            {-0.1389358881, 0.1092805780, 0.7350208828 },\n            {1.5293954595, 0.0030278255, 1.2472867347 },\n            {-0.5258728625, 1.3782633069, 1.3495508831 },\n            {-0.1403562064, 0.2437382535, 1.3804956588 },\n            {0.8055826339, -0.0482092025, 0.3327165165 },\n            {-0.6311979224, 0.7184578971, 0.2491045282 },\n            {1.4685857879, -0.8347049536, 1.3670667538 },\n            {-0.6855727502, 1.6465021616, 1.0593087096 },\n            {0.0152957411, 0.0638919221, 0.9771215985 }\n        };\n        double ans = totalArea(circs, 24);\n        System.out.println(\"Approx. area is \" + ans);\n        System.out.println(\"Error is \" + Math.abs(21.56503660 - ans));\n    }\n}\n"}
{"id": 415415, "name": "Factorions", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory qw/factorial todigits/;\n\nmy $limit = 1500000;\n\nfor my $b (9 .. 12) {\n    print \"Factorions in base $b:\\n\";\n    $_ == factorial($_) and print \"$_ \" for 0..$b-1;\n\n    for my $i (1 .. int $limit/$b) {\n        my $sum;\n        my $prod = $i * $b;\n\n        for (reverse todigits($i, $b)) {\n            $sum += factorial($_);\n            $sum = 0 && last if $sum > $prod;\n        }\n\n        next if $sum == 0;\n        ($sum + factorial($_) == $prod + $_) and print $prod+$_ . ' ' for 0..$b-1;\n    }\n    print \"\\n\\n\";\n}\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 415416, "name": "Factorions", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory qw/factorial todigits/;\n\nmy $limit = 1500000;\n\nfor my $b (9 .. 12) {\n    print \"Factorions in base $b:\\n\";\n    $_ == factorial($_) and print \"$_ \" for 0..$b-1;\n\n    for my $i (1 .. int $limit/$b) {\n        my $sum;\n        my $prod = $i * $b;\n\n        for (reverse todigits($i, $b)) {\n            $sum += factorial($_);\n            $sum = 0 && last if $sum > $prod;\n        }\n\n        next if $sum == 0;\n        ($sum + factorial($_) == $prod + $_) and print $prod+$_ . ' ' for 0..$b-1;\n    }\n    print \"\\n\\n\";\n}\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 415417, "name": "Sum of divisors", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisor_sum';\n\nmy @x;\npush @x, scalar divisor_sum($_) for 1..100;\n\nsay \"Divisor sums - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415418, "name": "Sum of divisors", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisor_sum';\n\nmy @x;\npush @x, scalar divisor_sum($_) for 1..100;\n\nsay \"Divisor sums - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415419, "name": "Order by pair comparisons", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nsub ask\n  {\n  while( 1 )\n    {\n    print \"Compare $a to $b [<,=,>]: \";\n    <STDIN> =~ /[<=>]/ and return +{qw( < -1 = 0 > 1 )}->{$&};\n    }\n  }\n\nmy @sorted = sort ask qw( violet red green indigo blue yellow orange );\nprint \"sorted: @sorted\\n\";\n", "target": "import java.util.*;\n\npublic class SortComp1 {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"violet\", \"red\", \"green\", \"indigo\", \"blue\", \"yellow\", \"orange\");\n        List<String> sortedItems = new ArrayList<>();\n        Comparator<String> interactiveCompare = new Comparator<String>() {\n                int count = 0;\n                Scanner s = new Scanner(System.in);\n                public int compare(String s1, String s2) {\n                    System.out.printf(\"(%d) Is %s <, =, or > %s. Answer -1, 0, or 1: \", ++count, s1, s2);\n                    return s.nextInt();\n                }\n            };\n        for (String item : items) {\n            System.out.printf(\"Inserting '%s' into %s\\n\", item, sortedItems);\n            int spotToInsert = Collections.binarySearch(sortedItems, item, interactiveCompare);\n            \n            \n            if (spotToInsert < 0) spotToInsert = ~spotToInsert;\n            sortedItems.add(spotToInsert, item);\n        }\n        System.out.println(sortedItems);\n    }\n}\n"}
{"id": 415420, "name": "Fermat numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint try=>\"GMP\";\nuse ntheory qw<factor>;\n\nmy @Fermats = map { 2**(2**$_) + 1 } 0..9;\n\nmy $sub = 0;\nsay 'First 10 Fermat numbers:';\nprintf \"F%s = %s\\n\", $sub++, $_ for @Fermats;\n\n$sub = 0;\nsay \"\\nFactors of first few Fermat numbers:\";\nfor my $f (map { [factor($_)] } @Fermats[0..8]) {\n   printf \"Factors of F%s: %s\\n\", $sub++, @$f == 1 ? 'prime' : join ' ', @$f\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class FermatNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 Fermat numbers:\");\n        for ( int i = 0 ; i < 10 ; i++ ) {\n            System.out.printf(\"F[%d] = %s\\n\", i, fermat(i));\n        }\n        System.out.printf(\"%nFirst 12 Fermat numbers factored:%n\");\n        for ( int i = 0 ; i < 13 ; i++ ) {\n            System.out.printf(\"F[%d] = %s\\n\", i, getString(getFactors(i, fermat(i))));\n        }\n    }\n    \n    private static String getString(List<BigInteger> factors) {\n        if ( factors.size() == 1 ) {\n            return factors.get(0) + \" (PRIME)\";\n        }\n        return factors.stream().map(v -> v.toString()).map(v -> v.startsWith(\"-\") ? \"(C\" + v.replace(\"-\", \"\") + \")\" : v).collect(Collectors.joining(\" * \"));\n    }\n\n    private static Map<Integer, String> COMPOSITE = new HashMap<>();\n    static {\n        COMPOSITE.put(9, \"5529\");\n        COMPOSITE.put(10, \"6078\");\n        COMPOSITE.put(11, \"1037\");\n        COMPOSITE.put(12, \"5488\");\n        COMPOSITE.put(13, \"2884\");\n    }\n\n    private static List<BigInteger> getFactors(int fermatIndex, BigInteger n) {\n        List<BigInteger> factors = new ArrayList<>();\n        BigInteger factor = BigInteger.ONE;\n        while ( true ) {\n            if ( n.isProbablePrime(100) ) {\n                factors.add(n);\n                break;\n            }\n            else {\n                if ( COMPOSITE.containsKey(fermatIndex) ) {\n                    String stop = COMPOSITE.get(fermatIndex);\n                    if ( n.toString().startsWith(stop) ) {\n                        factors.add(new BigInteger(\"-\" + n.toString().length()));\n                        break;\n                    }\n                }\n                factor = pollardRhoFast(n);\n                if ( factor.compareTo(BigInteger.ZERO) == 0 ) {\n                    factors.add(n);\n                    break;\n                }\n                else {\n                    factors.add(factor);\n                    n = n.divide(factor);\n                }\n            }\n        }\n        return factors;\n    }\n    \n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    \n    private static BigInteger fermat(int n) {\n        return TWO.pow((int)Math.pow(2, n)).add(BigInteger.ONE);\n    }\n        \n    \n    @SuppressWarnings(\"unused\")\n    private static BigInteger pollardRho(BigInteger n) {\n        BigInteger x = BigInteger.valueOf(2);\n        BigInteger y = BigInteger.valueOf(2);\n        BigInteger d = BigInteger.ONE;\n        while ( d.compareTo(BigInteger.ONE) == 0 ) {\n            x = pollardRhoG(x, n);\n            y = pollardRhoG(pollardRhoG(y, n), n);\n            d = x.subtract(y).abs().gcd(n);\n        }\n        if ( d.compareTo(n) == 0 ) {\n            return BigInteger.ZERO;\n        }\n        return d;\n    }\n    \n    \n    \n    \n    \n    \n    private static BigInteger pollardRhoFast(BigInteger n) {\n        long start = System.currentTimeMillis();\n        BigInteger x = BigInteger.valueOf(2);\n        BigInteger y = BigInteger.valueOf(2);\n        BigInteger d = BigInteger.ONE;\n        int count = 0;\n        BigInteger z = BigInteger.ONE;\n        while ( true ) {\n            x = pollardRhoG(x, n);\n            y = pollardRhoG(pollardRhoG(y, n), n);\n            d = x.subtract(y).abs();\n            z = z.multiply(d).mod(n);\n            count++;\n            if ( count == 100 ) {\n                d = z.gcd(n);\n                if ( d.compareTo(BigInteger.ONE) != 0 ) {\n                    break;\n                }\n                z = BigInteger.ONE;\n                count = 0;\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"    Pollard rho try factor %s elapsed time = %d ms (factor = %s).%n\", n, (end-start), d);\n        if ( d.compareTo(n) == 0 ) {\n            return BigInteger.ZERO;\n        }\n        return d;\n    }\n\n    private static BigInteger pollardRhoG(BigInteger x, BigInteger n) {\n        return x.multiply(x).add(BigInteger.ONE).mod(n);\n    }\n\n}\n"}
{"id": 415421, "name": "Sorting algorithms_Bead sort", "source": "Translate Perl to Java: sub beadsort {\n    my @data = @_;\n\n    my @columns;\n    my @rows;\n\n    for my $datum (@data) {\n        for my $column ( 0 .. $datum-1 ) {\n            ++ $rows[ $columns[$column]++ ];\n        }\n    }\n\n    return reverse @rows;\n}\n\nbeadsort 5, 7, 1, 3, 1, 1, 20;\n", "target": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}\n"}
{"id": 415422, "name": "Casting out nines", "source": "Translate Perl to Java: sub co9 {  \n  my $n = shift;\n  return $n if $n < 10;\n  my $sum = 0; $sum += $_ for split(//,$n);\n  co9($sum);\n}\n\nsub showadd {\n  my($n,$m) = @_;\n  print \"( $n [\",co9($n),\"] + $m [\",co9($m),\"] ) [\",co9(co9($n)+co9($m)),\"]\", \n        \"   =   \", $n+$m,\" [\",co9($n+$m),\"]\\n\";\n}\n\nsub co9filter {\n  my $base = shift;\n  die unless $base >= 2;\n  my($beg, $end, $basem1) = (1, $base*$base-1, $base-1);\n  my @list = grep { $_ % $basem1 == $_*$_ % $basem1 } $beg .. $end;\n  ($end, scalar(@list), @list);\n}\n\nprint \"Part 1: Create a simple filter and demonstrate using simple example.\\n\";\nshowadd(6395, 1259);\n\nprint \"\\nPart 2: Use this to filter a range with co9(k) == co9(k^2).\\n\";\nprint join(\" \", grep { co9($_) == co9($_*$_) } 1..99), \"\\n\";\n\nprint \"\\nPart 3: Use efficient method on range.\\n\";\nfor my $base (10, 17) {\n  my($N, $n, @l) = co9filter($base);\n  printf \"[@l]\\nIn base %d, trying %d numbers instead of %d saves\u00a0%.4f%%\\n\\n\",\n         $base, $n, $N, 100-($n/$N)*100;\n}\n", "target": "import java.util.*;\nimport java.util.stream.IntStream;\n\npublic class CastingOutNines {\n\n    public static void main(String[] args) {\n        System.out.println(castOut(16, 1, 255));\n        System.out.println(castOut(10, 1, 99));\n        System.out.println(castOut(17, 1, 288));\n    }\n\n    static List<Integer> castOut(int base, int start, int end) {\n        int[] ran = IntStream\n                .range(0, base - 1)\n                .filter(x -> x % (base - 1) == (x * x) % (base - 1))\n                .toArray();\n\n        int x = start / (base - 1);\n\n        List<Integer> result = new ArrayList<>();\n        while (true) {\n            for (int n : ran) {\n                int k = (base - 1) * x + n;\n                if (k < start)\n                    continue;\n                if (k > end)\n                    return result;\n                result.add(k);\n            }\n            x++;\n        }\n    }\n}\n"}
{"id": 415423, "name": "Casting out nines", "source": "Translate Perl to Java: sub co9 {  \n  my $n = shift;\n  return $n if $n < 10;\n  my $sum = 0; $sum += $_ for split(//,$n);\n  co9($sum);\n}\n\nsub showadd {\n  my($n,$m) = @_;\n  print \"( $n [\",co9($n),\"] + $m [\",co9($m),\"] ) [\",co9(co9($n)+co9($m)),\"]\", \n        \"   =   \", $n+$m,\" [\",co9($n+$m),\"]\\n\";\n}\n\nsub co9filter {\n  my $base = shift;\n  die unless $base >= 2;\n  my($beg, $end, $basem1) = (1, $base*$base-1, $base-1);\n  my @list = grep { $_ % $basem1 == $_*$_ % $basem1 } $beg .. $end;\n  ($end, scalar(@list), @list);\n}\n\nprint \"Part 1: Create a simple filter and demonstrate using simple example.\\n\";\nshowadd(6395, 1259);\n\nprint \"\\nPart 2: Use this to filter a range with co9(k) == co9(k^2).\\n\";\nprint join(\" \", grep { co9($_) == co9($_*$_) } 1..99), \"\\n\";\n\nprint \"\\nPart 3: Use efficient method on range.\\n\";\nfor my $base (10, 17) {\n  my($N, $n, @l) = co9filter($base);\n  printf \"[@l]\\nIn base %d, trying %d numbers instead of %d saves\u00a0%.4f%%\\n\\n\",\n         $base, $n, $N, 100-($n/$N)*100;\n}\n", "target": "import java.util.*;\nimport java.util.stream.IntStream;\n\npublic class CastingOutNines {\n\n    public static void main(String[] args) {\n        System.out.println(castOut(16, 1, 255));\n        System.out.println(castOut(10, 1, 99));\n        System.out.println(castOut(17, 1, 288));\n    }\n\n    static List<Integer> castOut(int base, int start, int end) {\n        int[] ran = IntStream\n                .range(0, base - 1)\n                .filter(x -> x % (base - 1) == (x * x) % (base - 1))\n                .toArray();\n\n        int x = start / (base - 1);\n\n        List<Integer> result = new ArrayList<>();\n        while (true) {\n            for (int n : ran) {\n                int k = (base - 1) * x + n;\n                if (k < start)\n                    continue;\n                if (k > end)\n                    return result;\n                result.add(k);\n            }\n            x++;\n        }\n    }\n}\n"}
{"id": 415424, "name": "Simple database", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\nuse feature qw{ say };\n\nuse JSON::PP;\nuse Time::Piece;\n\nuse constant {\n    NAME     => 0,\n    CATEGORY => 1,\n    DATE     => 2,\n    DB       => 'simple-db',\n};\n\nmy $operation = shift // \"\";\n\nmy %dispatch = (\n    n => \\&add_new,\n    l => \\&print_latest,\n    L => \\&print_latest_for_categories,\n    a => \\&print_all,\n);\n\nif ($dispatch{$operation}) {\n    $dispatch{$operation}->(@ARGV);\n} else {\n    die \"Invalid option. Use one of n, l, L, a.\\n\"\n}\n\nsub add_new {\n    my ($name, $category, $date) = @_;\n    my $db = eval { load() } || {};\n    if (defined $date) {\n        eval { 'Time::Piece'->strptime($date, '%Y-%m-%d'); 1 }\n            or die \"Invalid date format: YYYY-MM-DD.\\n\";\n\n    } else {\n        $date //= localtime->ymd;\n    }\n\n    my @ids = keys %{ $db->{by_id} };\n    my $max_id = max(num => @ids) || 0;\n    $db->{by_id}{ ++$max_id } = [ $name, $category, $date ];\n    save($db);\n}\n\nsub print_latest {\n    build_indexes( my $db = load(), 0, 1 );\n    _print_latest($db);\n}\n\nsub _print_latest {\n    my ($db, $category) = @_;\n    my @dates = keys %{ $db->{by_date} };\n    @dates = grep {\n        grep $db->{by_id}{$_}[CATEGORY] eq $category,\n            @{ $db->{by_date}{$_} };\n    } @dates if defined $category;\n\n    my $last_date = max(str => @dates);\n    say for map $db->{by_id}{$_}[NAME],\n            grep ! defined $category\n                 || $db->{by_id}{$_}[CATEGORY] eq $category,\n            @{ $db->{by_date}{$last_date} };\n}\n\nsub max {\n    my $type = shift;\n    my $max = $_[0];\n    { num => sub { $_ >  $max },\n      str => sub { $_ gt $max},\n    }->{$type}->() and $max = $_\n        for @_[ 1 .. $\n    return $max\n}\n\nsub print_latest_for_categories {\n    build_indexes( my $db = load(), 1, 1 );\n\n    for my $category (sort keys %{ $db->{by_category} }){\n        say \"* $category\";\n        _print_latest($db, $category);\n    }\n}\n\nsub print_all {\n    build_indexes( my $db = load(), 0, 1 );\n\n    for my $date (sort keys %{ $db->{by_date} }) {\n        for my $id (@{ $db->{by_date}{$date} }) {\n            say $db->{by_id}{$id}[NAME];\n        }\n    }\n}\n\nsub load {\n    open my $in, '<', DB or die \"Can't open database: $!\\n\";\n    local $/;\n    return { by_id => decode_json(<$in>) };\n}\n\nsub save {\n    my ($db) = @_;\n    open my $out, '>', DB or die \"Can't save database: $!\\n\";\n    print {$out} encode_json($db->{by_id});\n    close $out;\n}\n\nsub build_indexes {\n    my ($db, $by_category, $by_date) = @_;\n    for my $id (keys %{ $db->{by_id} }) {\n        push @{ $db->{by_category}{ $db->{by_id}{$id}[CATEGORY] } }, $id\n            if $by_category;\n        push @{ $db->{by_date}{ $db->{by_id}{$id}[DATE] } }, $id\n            if $by_date;\n    }\n}\n", "target": "import java.io.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class SimpleDatabase {\n\n    final static String filename = \"simdb.csv\";\n\n    public static void main(String[] args) {\n        if (args.length < 1 || args.length > 3) {\n            printUsage();\n            return;\n        }\n\n        switch (args[0].toLowerCase()) {\n            case \"add\":\n                addItem(args);\n                break;\n            case \"latest\":\n                printLatest(args);\n                break;\n            case \"all\":\n                printAll();\n                break;\n            default:\n                printUsage();\n                break;\n        }\n    }\n\n    private static class Item implements Comparable<Item>{\n        final String name;\n        final String date;\n        final String category;\n\n        Item(String n, String d, String c) {\n            name = n;\n            date = d;\n            category = c;\n        }\n\n        @Override\n        public int compareTo(Item item){\n            return date.compareTo(item.date);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s,%s,%s%n\", name, date, category);\n        }\n    }\n\n    private static void addItem(String[] input) {\n        if (input.length < 2) {\n            printUsage();\n            return;\n        }\n        List<Item> db = load();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String date = sdf.format(new Date());\n        String cat = (input.length == 3) ? input[2] : \"none\";\n        db.add(new Item(input[1], date, cat));\n        store(db);\n    }\n\n    private static void printLatest(String[] a) {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        if (a.length == 2) {\n            for (Item item : db)\n                if (item.category.equals(a[1]))\n                    System.out.println(item);\n        } else {\n            System.out.println(db.get(0));\n        }\n    }\n\n    private static void printAll() {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        for (Item item : db)\n            System.out.println(item);\n    }\n\n    private static List<Item> load() {\n        List<Item> db = new ArrayList<>();\n        try (Scanner sc = new Scanner(new File(filename))) {\n            while (sc.hasNext()) {\n                String[] item = sc.nextLine().split(\",\");\n                db.add(new Item(item[0], item[1], item[2]));\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return db;\n    }\n\n    private static void store(List<Item> db) {\n        try (FileWriter fw = new FileWriter(filename)) {\n            for (Item item : db)\n                fw.write(item.toString());\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    private static void printUsage() {\n         System.out.println(\"Usage:\");\n         System.out.println(\"  simdb cmd [categoryName]\");\n         System.out.println(\"  add     add item, followed by optional category\");\n         System.out.println(\"  latest  print last added item(s), followed by \"\n                 + \"optional category\");\n         System.out.println(\"  all     print all\");\n         System.out.println(\"  For instance: add \\\"some item name\\\" \"\n                 + \"\\\"some category name\\\"\");\n    }\n}\n"}
{"id": 415425, "name": "Keyboard macros", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Term::ReadKey;\n\nReadMode 4; \n\nsub logger { my($message) = @_; print \"$message\\n\" }\n\nwhile (1) {\n    if (my $c = ReadKey 0) { \n        if ($c eq 'q') { logger \"QUIT\"; last }\n        elsif ($c =~ /\\n|\\r/) { logger \"CR\" }\n        elsif ($c eq \"j\") { logger \"down\" }\n        elsif ($c eq \"k\") { logger \"up\" }\n        elsif ($c eq \"h\") { logger \"left\" }\n        elsif ($c eq \"l\") { logger \"right\" }\n\n        elsif ($c eq \"J\") { logger \"DOWN\" }\n        elsif ($c eq \"K\") { logger \"UP\" }\n        elsif ($c eq \"H\") { logger \"LEFT\" }\n        elsif ($c eq \"L\") { logger \"RIGHT\" }\n\n        elsif ($c eq \"\\e\") { \n            my $esc  = ReadKey 0;\n               $esc .= ReadKey 0;\n            if    ($esc eq \"[A\") { logger \"up\" }\n            elsif ($esc eq \"[B\") { logger \"down\" }\n            elsif ($esc eq \"[C\") { logger \"right\" }\n            elsif ($esc eq \"[D\") { logger \"left\" }\n            elsif ($esc eq \"[5\") { logger \"page up\" }\n            elsif ($esc eq \"[6\") { logger \"page down\" }\n            else { logger \"Unrecognized escape: $esc\"; }\n        }\n\n        else { logger \"you typed: $c\"; }\n    }\n}\n\nReadMode 0; \n", "target": "package keybord.macro.demo;\n\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\n\nclass KeyboardMacroDemo {\n    public static void main( String [] args ) {\n        final JFrame frame = new JFrame();\n        \n        String directions = \"<html><b>Ctrl-S</b> to show frame title<br>\"\n                                 +\"<b>Ctrl-H</b> to hide it</html>\";\n                                 \n        frame.add( new JLabel(directions));\n        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        \n        frame.addKeyListener( new KeyAdapter(){\n            public void keyReleased( KeyEvent e ) {\n                if( e.isControlDown() && e.getKeyCode() == KeyEvent.VK_S){\n                    frame.setTitle(\"Hello there\");\n                }else if( e.isControlDown() && e.getKeyCode() == KeyEvent.VK_H){\n                    frame.setTitle(\"\");\n                }\n            }\n        });\n        frame.pack();\n        frame.setVisible(true);\n    }\n}\n"}
{"id": 415426, "name": "Tau function", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy @x;\npush @x, scalar divisors($_) for 1..100;\n\nsay \"Tau function - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415427, "name": "Tau function", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy @x;\npush @x, scalar divisors($_) for 1..100;\n\nsay \"Tau function - first 100:\\n\" .\n    ((sprintf \"@{['%4d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415428, "name": "M\u00f6bius function", "source": "Translate Perl to Java: use utf8;\nuse strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'uniq';\n\nsub prime_factors {\n    my ($n, $d, @factors) = (shift, 1);\n    while ($n > 1 and $d++) {\n        $n /= $d, push @factors, $d until $n % $d;\n    }\n    @factors\n}\n\nsub \u03bc {\n    my @p = prime_factors(shift);\n    @p == uniq(@p) ? 0 == @p%2 ? 1 : -1 : 0;\n}\n\nmy @m\u00f6ebius;\npush @m\u00f6ebius, \u03bc($_) for 1 .. (my $upto = 199);\n\nsay \"M\u00f6bius sequence - First $upto terms:\\n\" .\n    (' 'x4 . sprintf \"@{['%4d' x $upto]}\", @m\u00f6ebius) =~ s/((.){80})/$1\\n/gr;\n", "target": "public class M\u00f6biusFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the m\u00f6bius function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", m\u00f6biusFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n    }\n    \n    private static int MU_MAX = 1_000_000;\n    private static int[] MU = null;\n    \n    \n    private static int m\u00f6biusFunction(int n) {\n        if ( MU != null ) {\n            return MU[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n        }\n        return MU[n];\n    }\n\n}\n"}
{"id": 415429, "name": "Execute Brain____", "source": "Translate Perl to Java: \n\nmy %code = split ' ', <<'END';\n  >  $ptr++\n  <  $ptr--\n  +  $memory[$ptr]++\n  -  $memory[$ptr]--\n  ,  $memory[$ptr]=ord(getc)\n  .  print(chr($memory[$ptr]))\n  [  while($memory[$ptr]){\n  ]  }\nEND\n\nmy ($ptr, @memory) = 0;\neval join ';', map @code{ /./g }, <>;\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 415430, "name": "Execute Brain____", "source": "Translate Perl to Java: \n\nmy %code = split ' ', <<'END';\n  >  $ptr++\n  <  $ptr--\n  +  $memory[$ptr]++\n  -  $memory[$ptr]--\n  ,  $memory[$ptr]=ord(getc)\n  .  print(chr($memory[$ptr]))\n  [  while($memory[$ptr]){\n  ]  }\nEND\n\nmy ($ptr, @memory) = 0;\neval join ';', map @code{ /./g }, <>;\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 415431, "name": "Mertens function", "source": "Translate Perl to Java: use utf8;\nuse strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'uniq';\n\nsub prime_factors {\n    my ($n, $d, @factors) = (shift, 1);\n    while ($n > 1 and $d++) {\n        $n /= $d, push @factors, $d until $n % $d;\n    }\n    @factors\n}\n\nsub \u03bc {\n    my @p = prime_factors(shift);\n    @p == uniq(@p) ? 0 == @p%2 ? 1 : -1 : 0\n}\n\nsub progressive_sum {\n    my @sum = shift @_;\n    push @sum, $sum[-1] + $_ for @_;\n    @sum\n}\n\nmy($upto, $show, @m\u00f6ebius) = (1000, 199, ());\npush @m\u00f6ebius, \u03bc($_) for 1..$upto;\nmy @mertens = progressive_sum @m\u00f6ebius;\n\nsay \"Mertens sequence - First $show terms:\\n\" .\n    (' 'x4 . sprintf \"@{['%4d' x $show]}\", @mertens[0..$show-1]) =~ s/((.){80})/$1\\n/gr .\n    sprintf(\"\\nEquals zero %3d times between 1 and $upto\", scalar grep { ! $_ } @mertens) .\n    sprintf \"\\nCrosses zero%3d times between 1 and $upto\", scalar grep { ! $mertens[$_-1] and $mertens[$_] } 1 .. @mertens;\n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 415432, "name": "Product of divisors", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy @products = ( 1 ) x 51;\nfor my $n ( 1 .. 50 )\n  {\n  $n % $_ or $products[$n] *= $_ for 1 .. $n;\n  }\nprintf '' . (('%11d' x 5) . \"\\n\") x 10, @products[1 .. 50];\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415433, "name": "Product of divisors", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy @products = ( 1 ) x 51;\nfor my $n ( 1 .. 50 )\n  {\n  $n % $_ or $products[$n] *= $_ for 1 .. $n;\n  }\nprintf '' . (('%11d' x 5) . \"\\n\") x 10, @products[1 .. 50];\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415434, "name": "Erd\u0151s-primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nbinmode(STDOUT, ':utf8');\nuse List::AllUtils 'before';\nuse ntheory qw<is_prime factorial>;\n\nsub is_erdos {\n    my($n) = @_; my $k;\n    return unless is_prime($n);\n    while ($n > factorial($k++)) { return if is_prime $n-factorial($k) }\n    'True'\n}\n\nmy(@Erd\u0151s,$n);\ndo { push @Erd\u0151s, $n if is_erdos(++$n) } until $n >= 1e6;\n\nsay 'Erd\u0151s primes < ' . (my $max = 2500) . ':';\nsay join ' ', before { $_ > 2500 } @Erd\u0151s;\nsay \"\\nErd\u0151s prime \n", "target": "import java.util.*;\n\npublic class ErdosPrimes {\n    public static void main(String[] args) {\n        boolean[] sieve = primeSieve(1000000);\n        int maxPrint = 2500;\n        int maxCount = 7875;\n        System.out.printf(\"Erd\\u0151s primes less than %d:\\n\", maxPrint);\n        for (int count = 0, prime = 1; count < maxCount; ++prime) {\n            if (erdos(sieve, prime)) {\n                ++count;\n                if (prime < maxPrint) {\n                    System.out.printf(\"%6d\", prime);\n                    if (count % 10 == 0)\n                        System.out.println();\n                }\n                if (count == maxCount)\n                    System.out.printf(\"\\n\\nThe %dth Erd\\u0151s prime is %d.\\n\", maxCount, prime);\n            }\n        }\n    }\n\n    private static boolean erdos(boolean[] sieve, int p) {\n        if (!sieve[p])\n            return false;\n        for (int k = 1, f = 1; f < p; ++k, f *= k) {\n            if (sieve[p - f])\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 415435, "name": "Erd\u0151s-primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nbinmode(STDOUT, ':utf8');\nuse List::AllUtils 'before';\nuse ntheory qw<is_prime factorial>;\n\nsub is_erdos {\n    my($n) = @_; my $k;\n    return unless is_prime($n);\n    while ($n > factorial($k++)) { return if is_prime $n-factorial($k) }\n    'True'\n}\n\nmy(@Erd\u0151s,$n);\ndo { push @Erd\u0151s, $n if is_erdos(++$n) } until $n >= 1e6;\n\nsay 'Erd\u0151s primes < ' . (my $max = 2500) . ':';\nsay join ' ', before { $_ > 2500 } @Erd\u0151s;\nsay \"\\nErd\u0151s prime \n", "target": "import java.util.*;\n\npublic class ErdosPrimes {\n    public static void main(String[] args) {\n        boolean[] sieve = primeSieve(1000000);\n        int maxPrint = 2500;\n        int maxCount = 7875;\n        System.out.printf(\"Erd\\u0151s primes less than %d:\\n\", maxPrint);\n        for (int count = 0, prime = 1; count < maxCount; ++prime) {\n            if (erdos(sieve, prime)) {\n                ++count;\n                if (prime < maxPrint) {\n                    System.out.printf(\"%6d\", prime);\n                    if (count % 10 == 0)\n                        System.out.println();\n                }\n                if (count == maxCount)\n                    System.out.printf(\"\\n\\nThe %dth Erd\\u0151s prime is %d.\\n\", maxCount, prime);\n            }\n        }\n    }\n\n    private static boolean erdos(boolean[] sieve, int p) {\n        if (!sieve[p])\n            return false;\n        for (int k = 1, f = 1; f < p; ++k, f *= k) {\n            if (sieve[p - f])\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 415436, "name": "Playing cards", "source": "Translate Perl to Java: package Playing_Card_Deck;\n\nuse strict;\nuse warnings;\n\n@Playing_Card_Deck::suits = qw\n   [Diamonds Clubs Hearts Spades];\n@Playing_Card_Deck::pips = qw\n   [Two Three Four Five Six Seven Eight Nine Ten\n    Jack King Queen Ace];\n\n\n\n\n\nsub new\n\n {my $invocant = shift;\n  my $class = ref($invocant) || $invocant;\n  my @cards;\n  foreach my $suit (@Playing_Card_Deck::suits)\n     {foreach my $pip (@Playing_Card_Deck::pips)\n         {push(@cards, {suit => $suit, pip => $pip});}}\n  return bless([@cards], $class);}\n\nsub deal\n\n\n {return %{ shift( @{shift()} ) };}\n\nsub shuffle\n\n\n\n {our @deck; local *deck = shift;\n    \n  for (my $n = $\n     {my $k = int rand($n + 1);\n      @deck[$k, $n] = @deck[$n, $k] if $k != $n;}}\n\nsub print_cards\n\n {print \"$_->{pip} of $_->{suit}\\n\" foreach @{shift()};}\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 415437, "name": "Perfect totient numbers", "source": "Translate Perl to Java: use ntheory qw(euler_phi);\n\nsub phi_iter {\n    my($p) = @_;\n    euler_phi($p) + ($p == 2 ? 0 : phi_iter(euler_phi($p)));\n}\n\nmy @perfect;\nfor (my $p = 2; @perfect < 20 ; ++$p) {\n    push @perfect, $p if $p == phi_iter($p);\n}\n\nprintf \"The first twenty perfect totient numbers:\\n%s\\n\", join ' ', @perfect;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 415438, "name": "Perfect totient numbers", "source": "Translate Perl to Java: use ntheory qw(euler_phi);\n\nsub phi_iter {\n    my($p) = @_;\n    euler_phi($p) + ($p == 2 ? 0 : phi_iter(euler_phi($p)));\n}\n\nmy @perfect;\nfor (my $p = 2; @perfect < 20 ; ++$p) {\n    push @perfect, $p if $p == phi_iter($p);\n}\n\nprintf \"The first twenty perfect totient numbers:\\n%s\\n\", join ' ', @perfect;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 415439, "name": "Lah numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(factorial);\nuse List::Util qw(max);\n\nsub Lah {\n    my($n, $k) = @_;\n    return factorial($n) if $k == 1;\n    return 1 if $k == $n;\n    return 0 if $k > $n;\n    return 0 if $k < 1 or $n < 1;\n    (factorial($n) * factorial($n - 1)) / (factorial($k) * factorial($k - 1)) / factorial($n - $k)\n}\n\nmy $upto = 12;\nmy $mx   = 1 + length max map { Lah(12,$_) } 0..$upto;\n\nsay 'Unsigned Lah numbers:  L(n, k):';\nprint 'n\\k' . sprintf \"%${mx}s\"x(1+$upto).\"\\n\", 0..1+$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    map { printf \"%${mx}d\", Lah($row, $_) } 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the L(100, *) row:\";\nsay max map { Lah(100,$_) } 0..100;\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 415440, "name": "Lah numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(factorial);\nuse List::Util qw(max);\n\nsub Lah {\n    my($n, $k) = @_;\n    return factorial($n) if $k == 1;\n    return 1 if $k == $n;\n    return 0 if $k > $n;\n    return 0 if $k < 1 or $n < 1;\n    (factorial($n) * factorial($n - 1)) / (factorial($k) * factorial($k - 1)) / factorial($n - $k)\n}\n\nmy $upto = 12;\nmy $mx   = 1 + length max map { Lah(12,$_) } 0..$upto;\n\nsay 'Unsigned Lah numbers:  L(n, k):';\nprint 'n\\k' . sprintf \"%${mx}s\"x(1+$upto).\"\\n\", 0..1+$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    map { printf \"%${mx}d\", Lah($row, $_) } 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the L(100, *) row:\";\nsay max map { Lah(100,$_) } 0..100;\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 415441, "name": "Two sum", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub two_sum{\n  my($sum,@numbers) = @_;\n  my $i = 0;\n  my $j = $\n  my @indices;\n  while ($i < $j) {\n    if    ($numbers[$i] + $numbers[$j] == $sum) { push @indices, ($i, $j); $i++; }\n    elsif ($numbers[$i] + $numbers[$j]  < $sum) { $i++ }\n    else                                        { $j-- }\n  }\n  return @indices\n}\n\nmy @numbers = <0 2 11 19 90>;\nmy @indices = two_sum(21, @numbers);\nsay join(', ', @indices) || 'No match';\n\n@indices = two_sum(25, @numbers);\nsay join(', ', @indices) || 'No match';\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 415442, "name": "Two sum", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub two_sum{\n  my($sum,@numbers) = @_;\n  my $i = 0;\n  my $j = $\n  my @indices;\n  while ($i < $j) {\n    if    ($numbers[$i] + $numbers[$j] == $sum) { push @indices, ($i, $j); $i++; }\n    elsif ($numbers[$i] + $numbers[$j]  < $sum) { $i++ }\n    else                                        { $j-- }\n  }\n  return @indices\n}\n\nmy @numbers = <0 2 11 19 90>;\nmy @indices = two_sum(21, @numbers);\nsay join(', ', @indices) || 'No match';\n\n@indices = two_sum(25, @numbers);\nsay join(', ', @indices) || 'No match';\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 415443, "name": "Sorting algorithms_Cocktail sort with shifting bounds", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub cocktail_sort {\n    my @a = @_;\n    my ($min, $max) = (0, $\n    while (1) {\n        my $swapped_forward = 0;\n        for my $i ($min .. $max) {\n            if ($a[$i] gt $a[$i+1]) {\n                @a[$i, $i+1] = @a[$i+1, $i];\n                $swapped_forward = 1\n            }\n        }\n        last if not $swapped_forward;\n        $max -= 1;\n\n        my $swapped_backward = 0;\n        for my $i (reverse $min .. $max) {\n            if ($a[$i] gt $a[$i+1]) {\n                @a[$i, $i+1] = @a[$i+1, $i];\n                $swapped_backward = 1;\n            }\n        }\n        last if not $swapped_backward;\n        $min += 1;\n    }\n    @a\n}\n\nsay join ' ', cocktail_sort( <t h e q u i c k b r o w n f o x j u m p s o v e r t h e l a z y d o g> );\n", "target": "import java.util.*;\n\npublic class CocktailSort {\n    public static void main(String[] args) {\n        Integer[] array = new Integer[]{ 5, 1, -6, 12, 3, 13, 2, 4, 0, 15 };\n        System.out.println(\"before: \" + Arrays.toString(array));\n        cocktailSort(array);\n        System.out.println(\"after: \" + Arrays.toString(array));\n    }\n\n    \n    public static void cocktailSort(Object[] array) {\n        int begin = 0;\n        int end = array.length;\n        if (end == 0)\n            return;\n        for (--end; begin < end; ) {\n            int new_begin = end;\n            int new_end = begin;\n            for (int i = begin; i < end; ++i) {\n                Comparable c1 = (Comparable)array[i];\n                Comparable c2 = (Comparable)array[i + 1];\n                if (c1.compareTo(c2) > 0) {\n                    swap(array, i, i + 1);\n                    new_end = i;\n                }\n            }\n            end = new_end;\n            for (int i = end; i > begin; --i) {\n                Comparable c1 = (Comparable)array[i - 1];\n                Comparable c2 = (Comparable)array[i];\n                if (c1.compareTo(c2) > 0) {\n                    swap(array, i, i - 1);\n                    new_begin = i;\n                }\n            }\n            begin = new_begin;\n        }\n    }\n\n    private static void swap(Object[] array, int i, int j) {\n        Object tmp = array[i];\n        array[i] = array[j];\n        array[j] = tmp;\n    }\n}\n"}
{"id": 415444, "name": "Unprimeable numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\nuse enum qw(False True);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub is_unprimeable {\n    my($n) = @_;\n    return False if is_prime($n);\n    my $chrs = length $n;\n    for my $place (0..$chrs-1) {\n        my $pow = 10**($chrs - $place - 1);\n        my $this = substr($n, $place, 1) * $pow;\n        map { return False if $this != $_ and is_prime($n - $this + $_ * $pow) } 0..9;\n     }\n     True\n}\n\nmy($n, @ups);\ndo { push @ups, $n if is_unprimeable(++$n); } until @ups == 600;\nsay \"First 35 unprimeables:\\n\" . join ' ', @ups[0..34];\nprintf \"\\n600th unprimeable: %s\\n\", comma $ups[599];\n\nmap {\n    my $x = $_;\n    while ($x += 10) { last if is_unprimeable($x) }\n    say \"First unprimeable that ends with $_: \" . sprintf \"%9s\", comma $x;\n} 0..9;\n", "target": "public class UnprimeableNumbers {\n\n    private static int MAX = 10_000_000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 35 unprimeable numbers:\");\n        displayUnprimeableNumbers(35);\n        int n = 600;\n        System.out.printf(\"%nThe %dth unprimeable number =\u00a0%,d%n%n\", n, nthUnprimeableNumber(n));\n        int[] lowest = genLowest();\n        System.out.println(\"Least unprimeable number that ends in:\");\n        for ( int i = 0 ; i <= 9 ; i++ ) {\n            System.out.printf(\" %d is\u00a0%,d%n\", i, lowest[i]);\n        }\n    }\n    \n    private static int[] genLowest() {\n        int[] lowest = new int[10];\n        int count = 0;\n        int test = 1;\n        while ( count < 10 ) {\n            test++;\n            if ( unPrimable(test) && lowest[test % 10] == 0 ) {\n                lowest[test % 10] = test;\n                count++;\n            }\n        }\n        return lowest;\n    }\n\n    private static int nthUnprimeableNumber(int maxCount) {\n        int test = 1;\n        int count = 0;\n        int result = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                result = test;\n            }\n        }\n        return result;\n    }\n\n    private static void displayUnprimeableNumbers(int maxCount) {\n        int test = 1;\n        int count = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                System.out.printf(\"%d \", test);\n            }\n        }\n        System.out.println();\n    }\n    \n    private static boolean unPrimable(int test) {\n        if ( primes[test] ) {\n            return false;\n        }\n        String s = test + \"\";\n        for ( int i = 0 ; i < s.length() ; i++ ) {\n            for ( int j = 0 ; j <= 9 ; j++ ) {\n                if ( primes[Integer.parseInt(replace(s, i, j))] ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private static String replace(String str, int position, int value) {\n        char[] sChar = str.toCharArray();\n        sChar[position] = (char) value;\n        return str.substring(0, position) + value + str.substring(position + 1);\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 415445, "name": "Tau number", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'divisors';\n\nmy(@x,$n);\n\ndo { push(@x,$n) unless $n % scalar(divisors(++$n)) } until 100 == @x;\n\nsay \"Tau numbers - first 100:\\n\" .\n    ((sprintf \"@{['%5d' x 100]}\", @x[0..100-1]) =~ s/(.{80})/$1\\n/gr);\n", "target": "public class Tau {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"The first %d tau numbers are:%n\", limit);\n        long count = 0;\n        for (long n = 1; count < limit; ++n) {\n            if (n % divisorCount(n) == 0) {\n                System.out.printf(\"%6d\", n);\n                ++count;\n                if (count % 10 == 0) {\n                    System.out.println();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415446, "name": "Primes whose sum of digits is 25", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\nuse ntheory 'is_prime';\n\nmy($limit, @p25) = 5000;\nis_prime($_) and 25 == sum(split '', $_) and push @p25, $_ for 1..$limit;\nsay @p25 . \" primes < $limit with digital sum 25:\\n\" . join ' ', @p25;\n", "target": "import java.math.BigInteger;\n\npublic class PrimeSum {\n    private static int digitSum(BigInteger bi) {\n        int sum = 0;\n        while (bi.compareTo(BigInteger.ZERO) > 0) {\n            BigInteger[] dr = bi.divideAndRemainder(BigInteger.TEN);\n            sum += dr[1].intValue();\n            bi = dr[0];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        BigInteger fiveK = BigInteger.valueOf(5_000);\n        BigInteger bi = BigInteger.valueOf(2);\n        while (bi.compareTo(fiveK) < 0) {\n            if (digitSum(bi) == 25) {\n                System.out.print(bi);\n                System.out.print(\"  \");\n            }\n            bi = bi.nextProbablePrime();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 415447, "name": "Primes whose sum of digits is 25", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\nuse ntheory 'is_prime';\n\nmy($limit, @p25) = 5000;\nis_prime($_) and 25 == sum(split '', $_) and push @p25, $_ for 1..$limit;\nsay @p25 . \" primes < $limit with digital sum 25:\\n\" . join ' ', @p25;\n", "target": "import java.math.BigInteger;\n\npublic class PrimeSum {\n    private static int digitSum(BigInteger bi) {\n        int sum = 0;\n        while (bi.compareTo(BigInteger.ZERO) > 0) {\n            BigInteger[] dr = bi.divideAndRemainder(BigInteger.TEN);\n            sum += dr[1].intValue();\n            bi = dr[0];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        BigInteger fiveK = BigInteger.valueOf(5_000);\n        BigInteger bi = BigInteger.valueOf(2);\n        while (bi.compareTo(fiveK) < 0) {\n            if (digitSum(bi) == 25) {\n                System.out.print(bi);\n                System.out.print(\"  \");\n            }\n            bi = bi.nextProbablePrime();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 415448, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nmy @queue = my @primedigits = ( 2, 3, 5, 7 );\nmy $numbers;\n\nwhile( my $n = shift @queue )\n  {\n  if( eval $n == 13 )\n    {\n    $numbers .= $n =~ tr/+//dr . \" \";\n    }\n  elsif( eval $n < 13 )\n    {\n    push @queue, map \"$n+$_\", @primedigits;\n    }\n  }\nprint $numbers =~ s/.{1,80}\\K /\\n/gr;\n", "target": "public class PrimeDigits {\n    private static boolean primeDigitsSum13(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int r = n % 10;\n            if (r != 2 && r != 3 && r != 5 && r != 7) {\n                return false;\n            }\n            n /= 10;\n            sum += r;\n        }\n        return sum == 13;\n    }\n\n    public static void main(String[] args) {\n        \n        int c = 0;\n        for (int i = 1; i < 1_000_000; i++) {\n            if (primeDigitsSum13(i)) {\n                System.out.printf(\"%6d \", i);\n                if (c++ == 10) {\n                    c = 0;\n                    System.out.println();\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 415449, "name": "Deepcopy", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\nuse Storable;\nuse Data::Dumper;\n\nmy $src = { foo => 0, bar => [0, 1] };\n$src->{baz} = $src;\nmy $dst = Storable::dclone($src);\nprint Dumper($src);\nprint Dumper($dst);\n", "target": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class DeepCopy {\n\n    public static void main(String[] args) {\n        Person p1 = new Person(\"Clark\", \"Kent\", new Address(\"1 World Center\", \"Metropolis\", \"NY\", \"010101\"));\n        Person p2 = p1;\n        \n        System.out.printf(\"Demonstrate shallow copy.  Both are the same object.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on both objects is changed.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        \n        p1 = new Person(\"Clark\", \"Kent\", new Address(\"1 World Center\", \"Metropolis\", \"NY\", \"010101\"));\n        p2 = new Person(p1);\n        System.out.printf(\"%nDemonstrate copy constructor.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n\n        p2 = (Person) deepCopy(p1);\n        System.out.printf(\"%nDemonstrate serialization.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        \n        p2 = (Person) p1.clone();\n        System.out.printf(\"%nDemonstrate cloning.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n    }\n\n    \n    private static Object deepCopy(Object object) {\n        try {\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            ObjectOutputStream outputStrm = new ObjectOutputStream(outputStream);\n            outputStrm.writeObject(object);\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());\n            ObjectInputStream objInputStream = new ObjectInputStream(inputStream);\n            return objInputStream.readObject();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    \n    public static class Address implements Serializable, Cloneable {\n\n        private static final long serialVersionUID = -7073778041809445593L;\n\n        private String street;\n        private String city;\n        private String state;\n        private String postalCode;\n        public String getStreet() {\n            return street;\n        }\n        public String getCity() {\n            return city;\n        }\n        public void setCity(String city) {\n            this.city = city;\n        }\n        public String getState() {\n            return state;\n        }\n        public String getPostalCode() {\n            return postalCode;\n        }\n        \n        @Override\n        public String toString() {\n            return \"[street=\" + street + \", city=\" + city + \", state=\" + state + \", code=\" + postalCode + \"]\";\n        }\n        \n        public Address(String s, String c, String st, String p) {\n            street = s;\n            city = c;\n            state = st;\n            postalCode = p;\n        }\n        \n        \n        public Address(Address add) {\n            street    = add.street;\n            city       = add.city;\n            state      = add.state;\n            postalCode = add.postalCode;\n        }\n        \n        \n        @Override\n        public Object clone() {\n            return new Address(this);\n        }\n        \n    }\n    \n    public static class Person implements Serializable, Cloneable {\n        private static final long serialVersionUID = -521810583786595050L;\n        private String firstName;\n        private String lastName;\n        private Address address;\n        public String getFirstName() {\n            return firstName;\n        }\n        public String getLastName() {\n            return lastName;\n        }\n        public Address getAddress() {\n            return address;\n        }\n\n        @Override\n        public String toString() {\n            return \"[first name=\" + firstName + \", last name=\" + lastName + \", address=\" + address + \"]\";\n        }\n\n        public Person(String fn, String ln, Address add) {\n            firstName = fn;\n            lastName = ln;\n            address = add;\n        }\n        \n        \n        public Person(Person person) {\n            firstName = person.firstName;\n            lastName = person.lastName;\n            address = new Address(person.address);  \n        }\n        \n        \n        @Override\n        public Object clone() {\n            return new Person(this);\n        }\n    }\n}\n"}
{"id": 415450, "name": "Deepcopy", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\nuse Storable;\nuse Data::Dumper;\n\nmy $src = { foo => 0, bar => [0, 1] };\n$src->{baz} = $src;\nmy $dst = Storable::dclone($src);\nprint Dumper($src);\nprint Dumper($dst);\n", "target": "import java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.Serializable;\n\npublic class DeepCopy {\n\n    public static void main(String[] args) {\n        Person p1 = new Person(\"Clark\", \"Kent\", new Address(\"1 World Center\", \"Metropolis\", \"NY\", \"010101\"));\n        Person p2 = p1;\n        \n        System.out.printf(\"Demonstrate shallow copy.  Both are the same object.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on both objects is changed.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        \n        p1 = new Person(\"Clark\", \"Kent\", new Address(\"1 World Center\", \"Metropolis\", \"NY\", \"010101\"));\n        p2 = new Person(p1);\n        System.out.printf(\"%nDemonstrate copy constructor.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n\n        p2 = (Person) deepCopy(p1);\n        System.out.printf(\"%nDemonstrate serialization.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        \n        p2 = (Person) p1.clone();\n        System.out.printf(\"%nDemonstrate cloning.  Object p2 is a deep copy of p1.%n\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n        System.out.printf(\"Set city on person 2.  City on objects is different.%n\");\n        p2.getAddress().setCity(\"New York\");\n        System.out.printf(\"Person p1 = %s%n\", p1);\n        System.out.printf(\"Person p2 = %s%n\", p2);\n    }\n\n    \n    private static Object deepCopy(Object object) {\n        try {\n            ByteArrayOutputStream outputStream = new ByteArrayOutputStream();\n            ObjectOutputStream outputStrm = new ObjectOutputStream(outputStream);\n            outputStrm.writeObject(object);\n            ByteArrayInputStream inputStream = new ByteArrayInputStream(outputStream.toByteArray());\n            ObjectInputStream objInputStream = new ObjectInputStream(inputStream);\n            return objInputStream.readObject();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            return null;\n        }\n    }\n    \n    public static class Address implements Serializable, Cloneable {\n\n        private static final long serialVersionUID = -7073778041809445593L;\n\n        private String street;\n        private String city;\n        private String state;\n        private String postalCode;\n        public String getStreet() {\n            return street;\n        }\n        public String getCity() {\n            return city;\n        }\n        public void setCity(String city) {\n            this.city = city;\n        }\n        public String getState() {\n            return state;\n        }\n        public String getPostalCode() {\n            return postalCode;\n        }\n        \n        @Override\n        public String toString() {\n            return \"[street=\" + street + \", city=\" + city + \", state=\" + state + \", code=\" + postalCode + \"]\";\n        }\n        \n        public Address(String s, String c, String st, String p) {\n            street = s;\n            city = c;\n            state = st;\n            postalCode = p;\n        }\n        \n        \n        public Address(Address add) {\n            street    = add.street;\n            city       = add.city;\n            state      = add.state;\n            postalCode = add.postalCode;\n        }\n        \n        \n        @Override\n        public Object clone() {\n            return new Address(this);\n        }\n        \n    }\n    \n    public static class Person implements Serializable, Cloneable {\n        private static final long serialVersionUID = -521810583786595050L;\n        private String firstName;\n        private String lastName;\n        private Address address;\n        public String getFirstName() {\n            return firstName;\n        }\n        public String getLastName() {\n            return lastName;\n        }\n        public Address getAddress() {\n            return address;\n        }\n\n        @Override\n        public String toString() {\n            return \"[first name=\" + firstName + \", last name=\" + lastName + \", address=\" + address + \"]\";\n        }\n\n        public Person(String fn, String ln, Address add) {\n            firstName = fn;\n            lastName = ln;\n            address = add;\n        }\n        \n        \n        public Person(Person person) {\n            firstName = person.firstName;\n            lastName = person.lastName;\n            address = new Address(person.address);  \n        }\n        \n        \n        @Override\n        public Object clone() {\n            return new Person(this);\n        }\n    }\n}\n"}
{"id": 415451, "name": "Circular primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'min';\nuse ntheory 'is_prime';\n\nsub rotate { my($i,@a) = @_; join '', @a[$i .. @a-1, 0 .. $i-1] }\n\nsub isCircular {\n    my ($n) = @_;\n    return 0 unless is_prime($n);\n    my @circular = split //, $n;\n    return 0 if min(@circular) < $circular[0];\n    for (1 .. scalar @circular) {\n        my $r = join '', rotate($_,@circular);\n        return 0 unless is_prime($r) and $r >= $n;\n    }\n    1\n}\n\nsay \"The first 19 circular primes are:\";\nfor ( my $i = 1, my $count = 0; $count < 19; $i++ ) {\n    ++$count and print \"$i \" if isCircular($i);\n}\n\nsay \"\\n\\nThe next 4 circular primes, in repunit format, are:\";\nfor ( my $i = 7, my $count = 0; $count < 4; $i++ ) {\n    ++$count and say \"R($i)\" if is_prime 1 x $i\n}\n\nsay \"\\nRepunit testing:\";\n\nfor (5003, 9887, 15073, 25031, 35317, 49081) {\n    say \"R($_): Prime? \" . (is_prime 1 x $_ ? 'True' : 'False');\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class CircularPrimes {\n    public static void main(String[] args) {\n        System.out.println(\"First 19 circular primes:\");\n        int p = 2;\n        for (int count = 0; count < 19; ++p) {\n            if (isCircularPrime(p)) {\n                if (count > 0)\n                    System.out.print(\", \");\n                System.out.print(p);\n                ++count;\n            }\n        }\n        System.out.println();\n        System.out.println(\"Next 4 circular primes:\");\n        int repunit = 1, digits = 1;\n        for (; repunit < p; ++digits)\n            repunit = 10 * repunit + 1;\n        BigInteger bignum = BigInteger.valueOf(repunit);\n        for (int count = 0; count < 4; ) {\n            if (bignum.isProbablePrime(15)) {\n                if (count > 0)\n                    System.out.print(\", \");\n                System.out.printf(\"R(%d)\", digits);\n                ++count;\n            }\n            ++digits;\n            bignum = bignum.multiply(BigInteger.TEN);\n            bignum = bignum.add(BigInteger.ONE);\n        }\n        System.out.println();\n        testRepunit(5003);\n        testRepunit(9887);\n        testRepunit(15073);\n        testRepunit(25031);\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n\n    private static int cycle(int n) {\n        int m = n, p = 1;\n        while (m >= 10) {\n            p *= 10;\n            m /= 10;\n        }\n        return m + 10 * (n % p);\n    }\n\n    private static boolean isCircularPrime(int p) {\n        if (!isPrime(p))\n            return false;\n        int p2 = cycle(p);\n        while (p2 != p) {\n            if (p2 < p || !isPrime(p2))\n                return false;\n            p2 = cycle(p2);\n        }\n        return true;\n    }\n\n    private static void testRepunit(int digits) {\n        BigInteger repunit = repunit(digits);\n        if (repunit.isProbablePrime(15))\n            System.out.printf(\"R(%d) is probably prime.\\n\", digits);\n        else\n            System.out.printf(\"R(%d) is not prime.\\n\", digits);\n    }\n\n    private static BigInteger repunit(int digits) {\n        char[] ch = new char[digits];\n        Arrays.fill(ch, '1');\n        return new BigInteger(new String(ch));\n    }\n}\n"}
{"id": 415452, "name": "Frobenius numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <nth_prime primes>;\nuse List::MoreUtils qw(slide);\n\n\nmy(@F,$n);\ndo { ++$n and push @F, nth_prime($n) * nth_prime($n+1) - (nth_prime($n) + nth_prime($n+1)) } until $F[-1] >= 10000;\nsay \"$\n\n\nmy $limit = 10_000;\nsay \"\\n\" . join ' ', grep { $_ < $limit } slide { $a * $b - $a - $b } @{primes($limit)};\n", "target": "public class Frobenius {\n    public static void main(String[] args) {\n        final int limit = 1000000;\n        System.out.printf(\"Frobenius numbers less than %d (asterisk marks primes):\\n\", limit);\n        PrimeGenerator primeGen = new PrimeGenerator(1000, 100000);\n        int prime1 = primeGen.nextPrime();\n        for (int count = 1; ; ++count) {\n            int prime2 = primeGen.nextPrime();\n            int frobenius = prime1 * prime2 - prime1 - prime2;\n            if (frobenius >= limit)\n                break;\n            System.out.printf(\"%6d%c%c\", frobenius,\n                    isPrime(frobenius) ? '*' : ' ',\n                    count % 10 == 0 ? '\\n' : ' ');\n            prime1 = prime2;\n        }\n        System.out.println();\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 415453, "name": "Sorting algorithms_Permutation sort", "source": "Translate Perl to Java: sub psort {\n        my ($x, $d) = @_;\n\n        unless ($d //= $\n                $x->[$_] < $x->[$_ - 1] and return for 1 .. $\n                return 1\n        }\n        \n        for (0 .. $d) {\n                unshift @$x, splice @$x, $d, 1;\n                next if $x->[$d] < $x->[$d - 1];\n                return 1 if psort($x, $d - 1);\n        }\n}\n\nmy @a = map+(int rand 100), 0 .. 10;\nprint \"Before:\\t@a\\n\";\npsort(\\@a);\nprint \"After:\\t@a\\n\"\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class PermutationSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tint[] a={3,2,1,8,9,4,6};\n\t\tSystem.out.println(\"Unsorted: \" + Arrays.toString(a));\n\t\ta=pSort(a);\n\t\tSystem.out.println(\"Sorted: \" + Arrays.toString(a));\n\t}\n\tpublic static int[] pSort(int[] a)\n\t{\n\t\tList<int[]> list=new ArrayList<int[]>();\n\t\tpermute(a,a.length,list);\n\t\tfor(int[] x : list)\n\t\t\tif(isSorted(x))\n\t\t\t\treturn x;\n\t\treturn a;\n\t}\n\tprivate static void permute(int[] a, int n, List<int[]> list) \n\t{\n\t\tif (n == 1) \n\t\t{\n\t\t\tint[] b=new int[a.length];\n\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\tlist.add(b);\n\t\t    return;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) \n\t\t{\n\t\t        swap(a, i, n-1);\n\t\t        permute(a, n-1, list);\n\t\t        swap(a, i, n-1);\n\t\t }\n\t}\n\tprivate static boolean isSorted(int[] a)\n\t{\n\t\tfor(int i=1;i<a.length;i++)\n\t\t\tif(a[i-1]>a[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tprivate static void swap(int[] arr,int i, int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n}\n"}
{"id": 415454, "name": "Integer roots", "source": "Translate Perl to Java: use bigint;\n\nsub integer_root {\n    our($a,$b) = @_;\n    our $a1 = $a - 1;\n    my $c = 1;\n    my $d = f($c);\n    my $e = f($d);\n    ($c, $d, $e) = ($d, $e, f($e)) until $c==$d || $c==$e;\n    return $d < $e ? $d : $e;\n\n    sub f { ($a1*$_[0]+$b/$_[0]**$a1)/$a }\n}\n\nprint integer_root( 3, 8), \"\\n\";\nprint integer_root( 3, 9), \"\\n\";\nprint integer_root( 2, 2 * 100 ** 2000), \"\\n\";\n", "target": "import java.math.BigInteger;\n\npublic class IntegerRoots {\n    private static BigInteger iRoot(BigInteger base, int n) {\n        if (base.compareTo(BigInteger.ZERO) < 0 || n <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        int n1 = n - 1;\n        BigInteger n2 = BigInteger.valueOf(n);\n        BigInteger n3 = BigInteger.valueOf(n1);\n        BigInteger c = BigInteger.ONE;\n        BigInteger d = n3.add(base).divide(n2);\n        BigInteger e = n3.multiply(d).add(base.divide(d.pow(n1))).divide(n2);\n        while (!c.equals(d) && !c.equals(e)) {\n            c = d;\n            d = e;\n            e = n3.multiply(e).add(base.divide(e.pow(n1))).divide(n2);\n        }\n        if (d.compareTo(e) < 0) {\n            return d;\n        }\n        return e;\n    }\n\n    public static void main(String[] args) {\n        BigInteger b = BigInteger.valueOf(8);\n        System.out.print(\"3rd integer root of 8 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(9);\n        System.out.print(\"3rd integer root of 9 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(100).pow(2000).multiply(BigInteger.valueOf(2));\n        System.out.print(\"First 2001 digits of the square root of 2: \");\n        System.out.println(iRoot(b, 2));\n    }\n}\n"}
{"id": 415455, "name": "Integer roots", "source": "Translate Perl to Java: use bigint;\n\nsub integer_root {\n    our($a,$b) = @_;\n    our $a1 = $a - 1;\n    my $c = 1;\n    my $d = f($c);\n    my $e = f($d);\n    ($c, $d, $e) = ($d, $e, f($e)) until $c==$d || $c==$e;\n    return $d < $e ? $d : $e;\n\n    sub f { ($a1*$_[0]+$b/$_[0]**$a1)/$a }\n}\n\nprint integer_root( 3, 8), \"\\n\";\nprint integer_root( 3, 9), \"\\n\";\nprint integer_root( 2, 2 * 100 ** 2000), \"\\n\";\n", "target": "import java.math.BigInteger;\n\npublic class IntegerRoots {\n    private static BigInteger iRoot(BigInteger base, int n) {\n        if (base.compareTo(BigInteger.ZERO) < 0 || n <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        int n1 = n - 1;\n        BigInteger n2 = BigInteger.valueOf(n);\n        BigInteger n3 = BigInteger.valueOf(n1);\n        BigInteger c = BigInteger.ONE;\n        BigInteger d = n3.add(base).divide(n2);\n        BigInteger e = n3.multiply(d).add(base.divide(d.pow(n1))).divide(n2);\n        while (!c.equals(d) && !c.equals(e)) {\n            c = d;\n            d = e;\n            e = n3.multiply(e).add(base.divide(e.pow(n1))).divide(n2);\n        }\n        if (d.compareTo(e) < 0) {\n            return d;\n        }\n        return e;\n    }\n\n    public static void main(String[] args) {\n        BigInteger b = BigInteger.valueOf(8);\n        System.out.print(\"3rd integer root of 8 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(9);\n        System.out.print(\"3rd integer root of 9 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(100).pow(2000).multiply(BigInteger.valueOf(2));\n        System.out.print(\"First 2001 digits of the square root of 2: \");\n        System.out.println(iRoot(b, 2));\n    }\n}\n"}
{"id": 415456, "name": "Modulinos", "source": "Translate Perl to Java: \n\n\npackage Life;\n\nuse strict;\nuse warnings;\n\nsub meaning_of_life {\n\treturn 42;\n}\n\nunless(caller) {\n\tprint \"Main: The meaning of life is \" . meaning_of_life() . \"\\n\";\n}\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 415457, "name": "Modulinos", "source": "Translate Perl to Java: \n\n\npackage Life;\n\nuse strict;\nuse warnings;\n\nsub meaning_of_life {\n\treturn 42;\n}\n\nunless(caller) {\n\tprint \"Main: The meaning of life is \" . meaning_of_life() . \"\\n\";\n}\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 415458, "name": "Nice primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse ntheory 'is_prime';\nuse List::Util qw(sum);\n\nsub digital_root {\n    my ($n) = @_;\n    do { $n = sum split '', $n } until 1 == length $n;\n    $n\n}\n\nmy($low, $high, $cnt, @nice_primes) = (500,1000);\nis_prime($_) and is_prime(digital_root($_)) and push @nice_primes, $_ for $low+1 .. $high-1;\n\n$cnt = @nice_primes;\nprint \"Nice primes between $low and $high (total of $cnt):\\n\" .\n(sprintf \"@{['%5d' x $cnt]}\", @nice_primes[0..$cnt-1]) =~ s/(.{55})/$1\\n/gr;\n", "target": "public class NicePrimes {\n    private static boolean isPrime(long n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n % 2 == 0L) {\n            return n == 2L;\n        }\n        if (n % 3 == 0L) {\n            return n == 3L;\n        }\n\n        var p = 5L;\n        while (p * p <= n) {\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 2;\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 4;\n        }\n        return true;\n    }\n\n    private static long digitalRoot(long n) {\n        if (n == 0) {\n            return 0;\n        }\n        return 1 + (n - 1) % 9;\n    }\n\n    public static void main(String[] args) {\n        final long from = 500;\n        final long to = 1000;\n        int count = 0;\n\n        System.out.printf(\"Nice primes between %d and %d%n\", from, to);\n        long n = from;\n        while (n < to) {\n            if (isPrime(digitalRoot(n)) && isPrime(n)) {\n                count++;\n                System.out.print(n);\n                if (count % 10 == 0) {\n                    System.out.println();\n                } else {\n                    System.out.print(' ');\n                }\n            }\n\n            n++;\n        }\n        System.out.println();\n        System.out.printf(\"%d nice primes found.%n\", count);\n    }\n}\n"}
{"id": 415459, "name": "Nice primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse ntheory 'is_prime';\nuse List::Util qw(sum);\n\nsub digital_root {\n    my ($n) = @_;\n    do { $n = sum split '', $n } until 1 == length $n;\n    $n\n}\n\nmy($low, $high, $cnt, @nice_primes) = (500,1000);\nis_prime($_) and is_prime(digital_root($_)) and push @nice_primes, $_ for $low+1 .. $high-1;\n\n$cnt = @nice_primes;\nprint \"Nice primes between $low and $high (total of $cnt):\\n\" .\n(sprintf \"@{['%5d' x $cnt]}\", @nice_primes[0..$cnt-1]) =~ s/(.{55})/$1\\n/gr;\n", "target": "public class NicePrimes {\n    private static boolean isPrime(long n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n % 2 == 0L) {\n            return n == 2L;\n        }\n        if (n % 3 == 0L) {\n            return n == 3L;\n        }\n\n        var p = 5L;\n        while (p * p <= n) {\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 2;\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 4;\n        }\n        return true;\n    }\n\n    private static long digitalRoot(long n) {\n        if (n == 0) {\n            return 0;\n        }\n        return 1 + (n - 1) % 9;\n    }\n\n    public static void main(String[] args) {\n        final long from = 500;\n        final long to = 1000;\n        int count = 0;\n\n        System.out.printf(\"Nice primes between %d and %d%n\", from, to);\n        long n = from;\n        while (n < to) {\n            if (isPrime(digitalRoot(n)) && isPrime(n)) {\n                count++;\n                System.out.print(n);\n                if (count % 10 == 0) {\n                    System.out.println();\n                } else {\n                    System.out.print(' ');\n                }\n            }\n\n            n++;\n        }\n        System.out.println();\n        System.out.printf(\"%d nice primes found.%n\", count);\n    }\n}\n"}
{"id": 415460, "name": "Find the last Sunday of each month", "source": "Translate Perl to Java: \nuse strict ;\nuse warnings ;\nuse DateTime ;\n\nfor my $i( 1..12 ) {\n   my $date = DateTime->last_day_of_month( year => $ARGV[ 0 ] , \n\t month => $i ) ;\n   while ( $date->dow != 7 ) {\n      $date = $date->subtract( days => 1 ) ;\n   }\n   my $ymd = $date->ymd ;\n   print \"$ymd\\n\" ;\n}\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 415461, "name": "Find the last Sunday of each month", "source": "Translate Perl to Java: \nuse strict ;\nuse warnings ;\nuse DateTime ;\n\nfor my $i( 1..12 ) {\n   my $date = DateTime->last_day_of_month( year => $ARGV[ 0 ] , \n\t month => $i ) ;\n   while ( $date->dow != 7 ) {\n      $date = $date->subtract( days => 1 ) ;\n   }\n   my $ymd = $date->ymd ;\n   print \"$ymd\\n\" ;\n}\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 415462, "name": "Random Latin squares", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'shuffle';\n\nsub random_ls {\n    my($n) = @_;\n    my(@cols,@symbols,@ls_sym);\n\n    \n    my @ls = [0,];\n    for my $i (1..$n-1) {\n        @{$ls[$i]} = @{$ls[0]};\n        splice(@{$ls[$_]}, $_, 0, $i) for 0..$i;\n    }\n\n    \n    @cols = shuffle 0..$n-1;\n    @ls = map [ @{$_}[@cols] ], @ls[shuffle 0..$n-1];\n\n    \n    @symbols = shuffle( ('A'..'Z')[0..$n-1] );\n    push @ls_sym, [@symbols[@$_]] for @ls;\n    @ls_sym\n}\n\nsub display {\n    my $str;\n    $str .= join(' ', @$_) . \"\\n\" for @_;\n    $str\n}\n\nsay display random_ls($_) for 2..5, 5;\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class RandomLatinSquares {\n    private static void printSquare(List<List<Integer>> latin) {\n        for (List<Integer> row : latin) {\n            Iterator<Integer> it = row.iterator();\n\n            System.out.print(\"[\");\n            if (it.hasNext()) {\n                Integer col = it.next();\n                System.out.print(col);\n            }\n            while (it.hasNext()) {\n                Integer col = it.next();\n                System.out.print(\", \");\n                System.out.print(col);\n            }\n            System.out.println(\"]\");\n        }\n        System.out.println();\n    }\n\n    private static void latinSquare(int n) {\n        if (n <= 0) {\n            System.out.println(\"[]\");\n            return;\n        }\n\n        List<List<Integer>> latin = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i) {\n            List<Integer> inner = new ArrayList<>(n);\n            for (int j = 0; j < n; ++j) {\n                inner.add(j);\n            }\n            latin.add(inner);\n        }\n        \n        Collections.shuffle(latin.get(0));\n\n        \n        for (int i = 1; i < n - 1; ++i) {\n            boolean shuffled = false;\n            shuffling:\n            while (!shuffled) {\n                Collections.shuffle(latin.get(i));\n                for (int k = 0; k < i; ++k) {\n                    for (int j = 0; j < n; ++j) {\n                        if (Objects.equals(latin.get(k).get(j), latin.get(i).get(j))) {\n                            continue shuffling;\n                        }\n                    }\n                }\n                shuffled = true;\n            }\n        }\n\n        \n        for (int j = 0; j < n; ++j) {\n            List<Boolean> used = new ArrayList<>(n);\n            for (int i = 0; i < n; ++i) {\n                used.add(false);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                used.set(latin.get(i).get(j), true);\n            }\n            for (int k = 0; k < n; ++k) {\n                if (!used.get(k)) {\n                    latin.get(n - 1).set(j, k);\n                    break;\n                }\n            }\n        }\n\n        printSquare(latin);\n    }\n\n    public static void main(String[] args) {\n        latinSquare(5);\n        latinSquare(5);\n        latinSquare(10);\n    }\n}\n"}
{"id": 415463, "name": "Teacup rim text", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util qw(uniqstr any);\n\nmy(%words,@teacups,%seen);\n\nopen my $fh, '<', 'ref/wordlist.10000';\nwhile (<$fh>) {\n    chomp(my $w = uc $_);\n    next if length $w < 3;\n    push @{$words{join '', sort split //, $w}}, $w;}\n\nfor my $these (values %words) {\n    next if @$these < 3;\n    MAYBE: for (@$these) {\n        my $maybe = $_;\n        next if $seen{$_};\n        my @print;\n        for my $i (0 .. length $maybe) {\n            if (any { $maybe eq $_ } @$these) {\n                push @print, $maybe;\n                $maybe = substr($maybe,1) . substr($maybe,0,1)\n            } else {\n                @print = () and next MAYBE\n            }\n        }\n        if (@print) {\n            push @teacups, [@print];\n            $seen{$_}++ for @print;\n        }\n    }\n}\n\nsay join ', ', uniqstr @$_ for sort @teacups;\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Teacup {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"usage: java Teacup dictionary\");\n            System.exit(1);\n        }\n        try {\n            findTeacupWords(loadDictionary(args[0]));\n        } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n        }\n    }\n\n    \n    private static Set<String> loadDictionary(String fileName) throws IOException {\n        Set<String> words = new TreeSet<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String word;\n            while ((word = reader.readLine()) != null)\n                words.add(word);\n            return words;\n        }\n    }\n\n    private static void findTeacupWords(Set<String> words) {\n        List<String> teacupWords = new ArrayList<>();\n        Set<String> found = new HashSet<>();\n        for (String word : words) {\n            int len = word.length();\n            if (len < 3 || found.contains(word))\n                continue;\n            teacupWords.clear();\n            teacupWords.add(word);\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < len - 1; ++i) {\n                String rotated = new String(rotate(chars));\n                if (rotated.equals(word) || !words.contains(rotated))\n                    break;\n                teacupWords.add(rotated);\n            }\n            if (teacupWords.size() == len) {\n                found.addAll(teacupWords);\n                System.out.print(word);\n                for (int i = 1; i < len; ++i)\n                    System.out.print(\" \" + teacupWords.get(i));\n                System.out.println();\n            }\n        }\n    }\n\n    private static char[] rotate(char[] ch) {\n        char c = ch[0];\n        System.arraycopy(ch, 1, ch, 0, ch.length - 1);\n        ch[ch.length - 1] = c;\n        return ch;\n    }\n}\n"}
{"id": 415464, "name": "Fairshare between two and more", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::AnyNum qw(sum polymod);\n\nsub fairshare {\n    my($b, $n) = @_;\n    sprintf '%3d'x$n, map { sum ( polymod($_, $b, $b )) % $b } 0 .. $n-1;\n}\n\nfor (<2 3 5 11>) {\n    printf \"%3s:%s\\n\", $_, fairshare($_, 25);\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class FairshareBetweenTwoAndMore {\n\n    public static void main(String[] args) {\n        for ( int base : Arrays.asList(2, 3, 5, 11) ) {\n            System.out.printf(\"Base %d = %s%n\", base, thueMorseSequence(25, base));\n        }\n    }\n    \n    private static List<Integer> thueMorseSequence(int terms, int base) {\n        List<Integer> sequence = new ArrayList<Integer>();\n        for ( int i = 0 ; i < terms ; i++ ) {\n            int sum = 0;\n            int n = i;\n            while ( n > 0 ) {\n                \n                sum += n % base;\n                n /= base;\n            }\n            \n            sequence.add(sum % base);\n        }\n        return sequence;\n    }\n\n}\n"}
{"id": 415465, "name": "Esthetic numbers", "source": "Translate Perl to Java: use 5.020;\nuse warnings;\nuse experimental qw(signatures);\n\nuse ntheory qw(fromdigits todigitstring);\n\nsub generate_esthetic ($root, $upto, $callback, $base = 10) {\n\n    my $v = fromdigits($root, $base);\n\n    return if ($v > $upto);\n    $callback->($v);\n\n    my $t = $root->[-1];\n\n    __SUB__->([@$root, $t + 1], $upto, $callback, $base) if ($t + 1 < $base);\n    __SUB__->([@$root, $t - 1], $upto, $callback, $base) if ($t - 1 >= 0);\n}\n\nsub between_esthetic ($from, $upto, $base = 10) {\n    my @list;\n    foreach my $k (1 .. $base - 1) {\n        generate_esthetic([$k], $upto,\n            sub($n) { push(@list, $n) if ($n >= $from) }, $base);\n    }\n    sort { $a <=> $b } @list;\n}\n\nsub first_n_esthetic ($n, $base = 10) {\n    for (my $m = $n * $n ; 1 ; $m *= $base) {\n        my @list = between_esthetic(1, $m, $base);\n        return @list[0 .. $n - 1] if @list >= $n;\n    }\n}\n\nforeach my $base (2 .. 16) {\n    say \"\\n$base-esthetic numbers at indices ${\\(4*$base)}..${\\(6*$base)}:\";\n    my @list = first_n_esthetic(6 * $base, $base);\n    say join(' ', map { todigitstring($_, $base) } @list[4*$base-1 .. $\n}\n\nsay \"\\nBase 10 esthetic numbers between 1,000 and 9,999:\";\nfor (my @list = between_esthetic(1e3, 1e4) ; @list ;) {\n    say join(' ', splice(@list, 0, 20));\n}\n\nsay \"\\nBase 10 esthetic numbers between 100,000,000 and 130,000,000:\";\nfor (my @list = between_esthetic(1e8, 1.3e8) ; @list ;) {\n    say join(' ', splice(@list, 0, 9));\n}\n", "target": "import java.util.ArrayList;\nimport java.util.stream.IntStream;\nimport java.util.stream.LongStream;\n\npublic class EstheticNumbers {\n    interface RecTriConsumer<A, B, C> {\n        void accept(RecTriConsumer<A, B, C> f, A a, B b, C c);\n    }\n\n    private static boolean isEsthetic(long n, long b) {\n        if (n == 0) {\n            return false;\n        }\n        var i = n % b;\n        var n2 = n / b;\n        while (n2 > 0) {\n            var j = n2 % b;\n            if (Math.abs(i - j) != 1) {\n                return false;\n            }\n            n2 /= b;\n            i = j;\n        }\n        return true;\n    }\n\n    private static void listEsths(long n, long n2, long m, long m2, int perLine, boolean all) {\n        var esths = new ArrayList<Long>();\n        var dfs = new RecTriConsumer<Long, Long, Long>() {\n            public void accept(Long n, Long m, Long i) {\n                accept(this, n, m, i);\n            }\n\n            @Override\n            public void accept(RecTriConsumer<Long, Long, Long> f, Long n, Long m, Long i) {\n                if (n <= i && i <= m) {\n                    esths.add(i);\n                }\n                if (i == 0 || i > m) {\n                    return;\n                }\n                var d = i % 10;\n                var i1 = i * 10 + d - 1;\n                var i2 = i1 + 2;\n                if (d == 0) {\n                    f.accept(f, n, m, i2);\n                } else if (d == 9) {\n                    f.accept(f, n, m, i1);\n                } else {\n                    f.accept(f, n, m, i1);\n                    f.accept(f, n, m, i2);\n                }\n            }\n        };\n\n        LongStream.range(0, 10).forEach(i -> dfs.accept(n2, m2, i));\n\n        var le = esths.size();\n        System.out.printf(\"Base 10: %d esthetic numbers between %d and %d:%n\", le, n, m);\n        if (all) {\n            for (int i = 0; i < esths.size(); i++) {\n                System.out.printf(\"%d \", esths.get(i));\n                if ((i + 1) % perLine == 0) {\n                    System.out.println();\n                }\n            }\n        } else {\n            for (int i = 0; i < perLine; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n            System.out.println();\n            System.out.println(\"............\");\n            for (int i = le - perLine; i < le; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n        }\n        System.out.println();\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        IntStream.rangeClosed(2, 16).forEach(b -> {\n            System.out.printf(\"Base %d: %dth to %dth esthetic numbers:%n\", b, 4 * b, 6 * b);\n            var n = 1L;\n            var c = 0L;\n            while (c < 6 * b) {\n                if (isEsthetic(n, b)) {\n                    c++;\n                    if (c >= 4 * b) {\n                        System.out.printf(\"%s \", Long.toString(n, b));\n                    }\n                }\n                n++;\n            }\n            System.out.println();\n        });\n        System.out.println();\n\n        \n        listEsths(1000, 1010, 9999, 9898, 16, true);\n        listEsths((long) 1e8, 101_010_101, 13 * (long) 1e7, 123_456_789, 9, true);\n        listEsths((long) 1e11, 101_010_101_010L, 13 * (long) 1e10, 123_456_789_898L, 7, false);\n        listEsths((long) 1e14, 101_010_101_010_101L, 13 * (long) 1e13, 123_456_789_898_989L, 5, false);\n        listEsths((long) 1e17, 101_010_101_010_101_010L, 13 * (long) 1e16, 123_456_789_898_989_898L, 4, false);\n    }\n}\n"}
{"id": 415466, "name": "Permutations by swapping", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\n\n\n\n\n\n\n\n\n\n\n\nsub perms :prototype(&@) {\n   my $callback = shift;\n   my @perm = map [$_, -1], @_;\n   $perm[0][1] = 0;\n\n   my $sign = 1;\n   while( ) {\n      $callback->($sign, map $_->[0], @perm);\n      $sign *= -1;\n\n      my ($chosen, $index) = (-1, -1);\n      for my $i ( 0 .. $\n         ($chosen, $index) = ($perm[$i][0], $i)\n           if $perm[$i][1] and $perm[$i][0] > $chosen;\n      }\n      return if $index == -1;\n\n      my $direction = $perm[$index][1];\n      my $next = $index + $direction;\n\n      @perm[ $index, $next ] = @perm[ $next, $index ];\n\n      if( $next <= 0 or $next >= $\n         $perm[$next][1] = 0;\n      } elsif( $perm[$next + $direction][0] > $chosen ) {\n         $perm[$next][1] = 0;\n      }\n\n      for my $i ( 0 .. $next - 1 ) {\n         $perm[$i][1] = +1 if $perm[$i][0] > $chosen;\n      }\n      for my $i ( $next + 1 .. $\n         $perm[$i][1] = -1 if $perm[$i][0] > $chosen;\n      }\n   }\n}\n\nmy $n = shift(@ARGV) || 4;\n\nperms {\n   my ($sign, @perm) = @_;\n   print \"[\", join(\", \", @perm), \"]\";\n   print $sign < 0 ? \" => -1\\n\" : \" => +1\\n\";   \n} 1 .. $n;\n", "target": "package org.rosettacode.java;\n\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class HeapsAlgorithm {\n\n\tpublic static void main(String[] args) {\n\t\tObject[] array = IntStream.range(0, 4)\n\t\t\t\t.boxed()\n\t\t\t\t.toArray();\n\t\tHeapsAlgorithm algorithm = new HeapsAlgorithm();\n\t\talgorithm.recursive(array);\n\t\tSystem.out.println();\n\t\talgorithm.loop(array);\n\t}\n\n\tvoid recursive(Object[] array) {\n\t\trecursive(array, array.length, true);\n\t}\n\n\tvoid recursive(Object[] array, int n, boolean plus) {\n\t\tif (n == 1) {\n\t\t\toutput(array, plus);\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trecursive(array, n - 1, i == 0);\n\t\t\t\tswap(array, n % 2 == 0 ? i : 0, n - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid output(Object[] array, boolean plus) {\n\t\tSystem.out.println(Arrays.toString(array) + (plus ? \" +1\" : \" -1\"));\n\t}\n\n\tvoid swap(Object[] array, int a, int b) {\n\t\tObject o = array[a];\n\t\tarray[a] = array[b];\n\t\tarray[b] = o;\n\t}\n\n\tvoid loop(Object[] array) {\n\t\tloop(array, array.length);\n\t}\n\n\tvoid loop(Object[] array, int n) {\n\t\tint[] c = new int[n];\n\t\toutput(array, true);\n\t\tboolean plus = false;\n\t\tfor (int i = 0; i < n; ) {\n\t\t\tif (c[i] < i) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tswap(array, 0, i);\n\t\t\t\t} else {\n\t\t\t\t\tswap(array, c[i], i);\n\t\t\t\t}\n\t\t\t\toutput(array, plus);\n\t\t\t\tplus = !plus;\n\t\t\t\tc[i]++;\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\tc[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 415467, "name": "RPG attributes generator", "source": "Translate Perl to Java: use strict;\nuse List::Util 'sum';\n\nmy ($min_sum, $hero_attr_min, $hero_count_min) = <75 15 3>;\nmy @attr_names = <Str Int Wis Dex Con Cha>;\n\nsub heroic { scalar grep { $_ >= $hero_attr_min } @_ }\n\nsub roll_skip_lowest {\n    my($dice, $sides) = @_;\n    sum( (sort map { 1 + int rand($sides) } 1..$dice)[1..$dice-1] );\n}\n\nmy @attr;\ndo {\n    @attr = map { roll_skip_lowest(6,4) } @attr_names;\n} until sum(@attr) >= $min_sum and heroic(@attr) >= $hero_count_min;\n\nprintf \"%s = %2d\\n\", $attr_names[$_], $attr[$_] for 0..$\nprintf \"Sum = %d, with %d attributes >= $hero_attr_min\\n\", sum(@attr), heroic(@attr);\n", "target": "import java.util.List;\nimport java.util.Random;\nimport java.util.stream.Stream;\n\nimport static java.util.stream.Collectors.toList;\n\npublic class Rpg {\n\n    private static final Random random = new Random();\n \n    public static int genAttribute() {\n        return random.ints(1, 6 + 1) \n            .limit(4) \n            .sorted() \n            .limit(3) \n            .sum();   \n    }\n \n    public static void main(String[] args) {\n        while (true) {\n            List<Integer> stats =\n                Stream.generate(Rpg::genAttribute) \n                    .limit(6) \n                    .collect(toList()); \n            int sum = stats.stream().mapToInt(Integer::intValue).sum();\n            long count = stats.stream().filter(v -> v >= 15).count();\n            if (count >= 2 && sum >= 75) {\n                System.out.printf(\"The 6 random numbers generated are: %s\\n\", stats);\n                System.out.printf(\"Their sum is %s and %s of them are >= 15\\n\", sum, count);\n                return;\n            }      \n        }\n    }\n}\n"}
{"id": 415468, "name": "Kolakoski sequence", "source": "Translate Perl to Java: sub kolakoski {\n    my($terms,@seed) = @_;\n    my @k;\n    my $k = $seed[0] == 1 ? 1 : 0;\n    if ($k == 1) { @k = (1, split //, (($seed[1]) x $seed[1])) }\n    else         { @k = ($seed[0]) x $seed[0] }\n    do {\n        $k++;\n        push @k, ($seed[$k % @seed]) x $k[$k];\n    } until $terms <= @k;\n    @k[0..$terms-1]\n}\n\nsub rle {\n    (my $string = join '', @_) =~ s/((.)\\2*)/length $1/eg;\n    split '', $string\n}\n\nfor ([20,1,2], [20,2,1], [30,1,3,1,2], [30,1,3,2,1]) {\n    $terms = shift @$_;\n    print \"\\n$terms members of the series generated from [@$_] is:\\n\";\n    print join(' ', @kolakoski = kolakoski($terms, @$_)) . \"\\n\";\n    $status = join('', @rle = rle(@kolakoski)) eq join('', @kolakoski[0..$\n    print \"Looks like a Kolakoski sequence?: $status\\n\";\n}\n", "target": "import java.util.Arrays;\n\npublic class Kolakoski {\n    private static class Crutch {\n        final int len;\n        int[] s;\n        int i;\n\n        Crutch(int len) {\n            this.len = len;\n            s = new int[len];\n            i = 0;\n        }\n\n        void repeat(int count) {\n            for (int j = 0; j < count; j++) {\n                if (++i == len) return;\n                s[i] = s[i - 1];\n            }\n        }\n    }\n\n    private static int nextInCycle(final int[] self, int index) {\n        return self[index % self.length];\n    }\n\n    private static int[] kolakoski(final int[] self, int len) {\n        Crutch c = new Crutch(len);\n\n        int k = 0;\n        while (c.i < len) {\n            c.s[c.i] = nextInCycle(self, k);\n            if (c.s[k] > 1) {\n                c.repeat(c.s[k] - 1);\n            }\n            if (++c.i == len) return c.s;\n            k++;\n        }\n        return c.s;\n    }\n\n    private static boolean possibleKolakoski(final int[] self) {\n        int[] rle = new int[self.length];\n        int prev = self[0];\n        int count = 1;\n        int pos = 0;\n        for (int i = 1; i < self.length; i++) {\n            if (self[i] == prev) {\n                count++;\n            } else {\n                rle[pos++] = count;\n                count = 1;\n                prev = self[i];\n            }\n        }\n        \n        for (int i = 0; i < pos; i++) {\n            if (rle[i] != self[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[][] ias = new int[][]{\n            new int[]{1, 2},\n            new int[]{2, 1},\n            new int[]{1, 3, 1, 2},\n            new int[]{1, 3, 2, 1}\n        };\n        int[] lens = new int[]{20, 20, 30, 30};\n\n        for (int i=0; i<ias.length; i++) {\n            int len = lens[i];\n            int[] kol = kolakoski(ias[i], len);\n\n            System.out.printf(\"First %d members of the sequence generated by %s: \\n\", len, Arrays.toString(ias[i]));\n            System.out.printf(\"%s\\n\", Arrays.toString(kol));\n            System.out.printf(\"Possible Kolakoski sequence? %s\\n\\n\", possibleKolakoski(kol));\n        }\n    }\n}\n"}
{"id": 415469, "name": "Variable declaration reset", "source": "Translate Perl to Java: @s = <1 2 2 3 4 4 5>;\nfor ($i = 0; $i < 7; $i++) {\n    $curr = $s[$i];\n    if ($i > 1 and $curr == $prev) { print \"$i\\n\" }\n    $prev = $curr;\n}\n", "target": "public class VariableDeclarationReset {\n    public static void main(String[] args) {\n        int[] s = {1, 2, 2, 3, 4, 4, 5};\n\n        \n        \n        for (int i = 0; i < s.length; ++i) {\n            int curr = s[i];\n            int prev = 0;\n\n            if (i > 0 && curr == prev) System.out.println(i);\n            prev = curr;\n        }\n\n        int gprev = 0;\n\n        \n        \n        for (int i = 0; i < s.length; ++i) {\n            int curr = s[i];\n            if (i > 0 && curr == gprev) System.out.println(i);\n            gprev = curr;\n        }\n    }\n}\n"}
{"id": 415470, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory 'divisors';\n\nprint \"First 15 terms of OEIS: A005179\\n\";\nfor my $n (1..15) {\n    my $l = 0;\n    while (++$l) {\n        print \"$l \" and last if $n == divisors($l);\n    }\n}\n", "target": "import java.util.Arrays;\n\npublic class OEIS_A005179 {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        int[] seq = new int[max];\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, n = 0; n < max; ++i) {\n            int k = count_divisors(i);\n            if (k <= max && seq[k - 1] == 0) {        \n                seq[k- 1] = i;\n                n++;\n            }\n        }\n        System.out.println(Arrays.toString(seq));\n    }\n}\n"}
{"id": 415471, "name": "Sparkline in unicode", "source": "Translate Perl to Java: binmode(STDOUT, \":utf8\");\nour @sparks=map {chr} 0x2581 .. 0x2588;\nsub sparkline :prototype(@) {\n    my @n=map {0+$_} grep {length} @_ or return \"\";\n    my($min,$max)=($n[0])x2;\n    if (@n>1) {\n        for (@n[1..$\n            if    ($_<$min) { $min=$_ }\n            elsif ($_>$max) { $max=$_ }\n        }\n    }\n    my $sparkline=\"\";\n    for(@n) {\n        my $height=int( $max==$min ? @sparks/2\u00a0: ($_-$min)/($max-$min)*@sparks );\n        $height=$\n        $sparkline.=$sparks[$height];\n    }\n    my $summary=sprintf \"%d values; range %s..%s\", scalar(@n), $min, $max;\n    return wantarray ? ($summary, \"\\n\", $sparkline, \"\\n\") : $sparkline;\n}\n\n\n\n\n\n\n\n\nprint sparkline( split /[\\s,]+/ ) while <>;\n", "target": "public class Sparkline \n{\n\tString bars=\"\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588\";\n\tpublic static void main(String[] args)\n\t{\n\t\tSparkline now=new Sparkline();\n\t\tfloat[] arr={1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1};\n\t\tnow.display1D(arr);\n\t\tSystem.out.println(now.getSparkline(arr));\n\t\tfloat[] arr1={1.5f, 0.5f, 3.5f, 2.5f, 5.5f, 4.5f, 7.5f, 6.5f};\n\t\tnow.display1D(arr1);\n\t\tSystem.out.println(now.getSparkline(arr1));\n\t}\n\tpublic void display1D(float[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tpublic String getSparkline(float[] arr)\n\t{\n\t\tfloat min=Integer.MAX_VALUE;\n\t\tfloat max=Integer.MIN_VALUE;\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tif(arr[i]<min)\n\t\t\t\tmin=arr[i];\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t}\n\t\tfloat range=max-min;\n\t\tint num=bars.length()-1;\n\t\tString line=\"\";\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\t\n\t\t\tline+=bars.charAt((int)Math.ceil(((arr[i]-min)/range*num)));\n\t\t}\n\t\treturn line;\n\t}\n}\n"}
{"id": 415472, "name": "Levenshtein distance_Alignment", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse List::Util qw(min);\n \nsub levenshtein_distance_alignment {\n    my @s = ('^', split //, shift);\n    my @t = ('^', split //, shift);\n \n    my @A;\n    @{$A[$_][0]}{qw(d s t)} = ($_, join('', @s[1 .. $_]), ('~' x $_)) for 0 .. $\n    @{$A[0][$_]}{qw(d s t)} = ($_, ('-' x $_), join '', @t[1 .. $_])  for 0 .. $\n    for my $i (1 .. $\n        for my $j (1 .. $\n\t    if ($s[$i] ne $t[$j]) {\n\t\t$A[$i][$j]{d} = 1 + (\n\t\t    my $min = min $A[$i-1][$j]{d}, $A[$i][$j-1]{d}, $A[$i-1][$j-1]{d}\n\t\t);\n\t\t@{$A[$i][$j]}{qw(s t)} =\n\t\t$A[$i-1][$j]{d} == $min ? ($A[$i-1][$j]{s}.$s[$i], $A[$i-1][$j]{t}.'-') :\n\t\t$A[$i][$j-1]{d} == $min ? ($A[$i][$j-1]{s}.'-', $A[$i][$j-1]{t}.$t[$j]) :\n\t\t($A[$i-1][$j-1]{s}.$s[$i], $A[$i-1][$j-1]{t}.$t[$j]);\n\t    }\n            else {\n\t\t@{$A[$i][$j]}{qw(d s t)} = (\n\t\t    $A[$i-1][$j-1]{d},\n\t\t    $A[$i-1][$j-1]{s}.$s[$i],\n\t\t    $A[$i-1][$j-1]{t}.$t[$j]\n\t\t);\n            }\n        }\n    }\n    return @{$A[-1][-1]}{'s', 't'};\n}\n \nprint  join \"\\n\", levenshtein_distance_alignment \"rosettacode\", \"raisethysword\";\n", "target": "public class LevenshteinAlignment {\n\n    public static String[] alignment(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int[][] costs = new int[a.length()+1][b.length()+1];\n        for (int j = 0; j <= b.length(); j++)\n            costs[0][j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            costs[i][0] = i;\n            for (int j = 1; j <= b.length(); j++) {\n                costs[i][j] = Math.min(1 + Math.min(costs[i-1][j], costs[i][j-1]), a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1);\n            }\n        }\n\n\t\n\tStringBuilder aPathRev = new StringBuilder();\n\tStringBuilder bPathRev = new StringBuilder();\n\tfor (int i = a.length(), j = b.length(); i != 0 && j != 0; ) {\n\t    if (costs[i][j] == (a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1)) {\n\t\taPathRev.append(a.charAt(--i));\n\t\tbPathRev.append(b.charAt(--j));\n\t    } else if (costs[i][j] == 1 + costs[i-1][j]) {\n\t\taPathRev.append(a.charAt(--i));\n\t\tbPathRev.append('-');\n\t    } else if (costs[i][j] == 1 + costs[i][j-1]) {\n\t\taPathRev.append('-');\n\t\tbPathRev.append(b.charAt(--j));\n\t    }\n\t}\n        return new String[]{aPathRev.reverse().toString(), bPathRev.reverse().toString()};\n    }\n\n    public static void main(String[] args) {\n\tString[] result = alignment(\"rosettacode\", \"raisethysword\");\n\tSystem.out.println(result[0]);\n\tSystem.out.println(result[1]);\n    }\n}\n"}
{"id": 415473, "name": "Longest increasing subsequence", "source": "Translate Perl to Java: use strict;\n\nsub lis {\n    my @l = map [], 1 .. @_;\n    push @{$l[0]}, +$_[0];\n    for my $i (1 .. @_-1) {\n        for my $j (0 .. $i - 1) {\n            if ($_[$j] < $_[$i] and @{$l[$i]} < @{$l[$j]} + 1) {\n                $l[$i] = [ @{$l[$j]} ];\n            }\n        }\n        push @{$l[$i]}, $_[$i];\n    }\n    my ($max, $l) = (0, []);\n    for (@l) {\n        ($max, $l) = (scalar(@$_), $_) if @$_ > $max;\n    }\n    return @$l;\n}\n\nprint join ' ', lis 3, 2, 6, 4, 5, 1;\nprint join ' ', lis 0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15;\n", "target": "import java.util.*;\n\npublic class LIS {\n    public static <E extends Comparable<? super E>> List<E> lis(List<E> n) {\n        List<Node<E>> pileTops = new ArrayList<Node<E>>();\n        \n        for (E x : n) {\n\t    Node<E> node = new Node<E>();\n\t    node.value = x;\n            int i = Collections.binarySearch(pileTops, node);\n            if (i < 0) i = ~i;\n\t    if (i != 0)\n\t\tnode.pointer = pileTops.get(i-1);\n            if (i != pileTops.size())\n                pileTops.set(i, node);\n            else\n                pileTops.add(node);\n        }\n\t\n\tList<E> result = new ArrayList<E>();\n\tfor (Node<E> node = pileTops.size() == 0 ? null : pileTops.get(pileTops.size()-1);\n                node != null; node = node.pointer)\n\t    result.add(node.value);\n\tCollections.reverse(result);\n\treturn result;\n    }\n\n    private static class Node<E extends Comparable<? super E>> implements Comparable<Node<E>> {\n\tpublic E value;\n\tpublic Node<E> pointer;\n        public int compareTo(Node<E> y) { return value.compareTo(y.value); }\n    }\n\n    public static void main(String[] args) {\n\tList<Integer> d = Arrays.asList(3,2,6,4,5,1);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n        d = Arrays.asList(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n    }\n}\n"}
{"id": 415474, "name": "Words from neighbour ones", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\n@ARGV = 'unixdict.txt';\nmy $skew = join '', map { s/^.{9}\\K.+//r } my @words = grep length() > 9, <>;\nmy %dict = map { $_ => 1 } grep length == 10, @words;\nmy %seen;\nmy $nextch = '.{10}(\\\\w)' x 8;\nwhile( $skew =~ /^(\\w)(?=$nextch)/gms )\n  {\n  my $new = join '', @{^CAPTURE}, \"\\n\";\n  $dict{$new} and !$seen{$new}++ and print $new;\n  }\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class NeighbourWords {\n    public static void main(String[] args) {\n        try {\n            int minLength = 9;\n            List<String> words = new ArrayList<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.length() >= minLength)\n                        words.add(line);\n                }\n            }\n            Collections.sort(words);\n            String previousWord = null;\n            int count = 0;\n            for (int i = 0, n = words.size(); i + minLength <= n; ++i) {\n                StringBuilder sb = new StringBuilder(minLength);\n                for (int j = 0; j < minLength; ++j)\n                    sb.append(words.get(i + j).charAt(j));\n                String word = sb.toString();\n                if (word.equals(previousWord))\n                    continue;\n                if (Collections.binarySearch(words, word) >= 0)\n                    System.out.printf(\"%2d. %s\\n\", ++count, word);\n                previousWord = word;\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 415475, "name": "Dynamic variable names", "source": "Translate Perl to Java: print \"Enter a variable name: \";\n$varname = <STDIN>; \nchomp($varname);\n$$varname = 42; \n                \n                \nprint \"$foo\\n\"; \n", "target": "public static void main(String... args){\n        HashMap<String, Integer> vars = new HashMap<String, Integer>();\n        \n        \n        \n        vars.put(\"Variable name\", 3); \n        vars.put(\"Next variable name\", 5);\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        vars.put(str, sc.nextInt()); \n        \n        System.out.println(vars.get(\"Variable name\")); \n        System.out.println(vars.get(str));\n}\n"}
{"id": 415476, "name": "Square root by hand", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub integral   { my($n) = @_; (length($n) % 2 != 0 ? '0' . $n  : $n) =~ /../g }\nsub fractional { my($n) = @_; (length($n) % 2 == 0 ? $n  . '0' : $n) =~ /../g }\n\nsub SpigotSqrt {\n    my($in) = @_;\n\n    my(@dividends, @fractional, $dividend, $quotient, $remainder, $accum);\n    my $d   = 9;\n    my $D   = '';\n    my $dot = 0;\n\n    if ($in == int $in) {\n        @dividends =    integral($in);\n    } else {\n        @dividends  =   integral($in =~ /(.*)\\./);\n        @fractional = fractional($in =~ /\\.(.*)/);\n    }\n    $dividend = shift @dividends;\n\n    while () {\n        until ( ( $remainder = $dividend - ($D.$d) * $d ) >= 0) { $d-- }\n\n        $accum    .= $d;\n        $quotient .= $d;\n        unless (@dividends) {\n            last if $remainder == 0 and $quotient != 0 and !@fractional;\n            unless ($dot) { $accum .= '.' and $dot = 1 }\n            if (@fractional) {\n                push @dividends, @fractional;\n                @fractional = ();\n            } else {\n                push @dividends, '00';\n            }\n        }\n        $dividend = $remainder . shift @dividends;\n        $D = 2 * $quotient;\n        $d = 9\n    }\n    return $accum;\n}\n\nsay \"The square root of $_ is \" . SpigotSqrt $_ for < 25 0.0625 152.2756 >;\n", "target": "import java.math.BigInteger;\n\npublic class SquareRoot {\n    public static final BigInteger ONE_HUNDRED = BigInteger.valueOf(100);\n    public static final BigInteger TWENTY = BigInteger.valueOf(20);\n\n    public static void main(String[] args) {\n        var i = BigInteger.TWO;\n        var j = BigInteger.valueOf((long) Math.floor(Math.sqrt(2.0)));\n        var k = j;\n        var d = j;\n        int n = 500;\n        int n0 = n;\n        do {\n            System.out.print(d);\n            i = i.subtract(k.multiply(d)).multiply(ONE_HUNDRED);\n            k = TWENTY.multiply(j);\n            for (d = BigInteger.ONE; d.compareTo(BigInteger.TEN) <= 0; d = d.add(BigInteger.ONE)) {\n                if (k.add(d).multiply(d).compareTo(i) > 0) {\n                    d = d.subtract(BigInteger.ONE);\n                    break;\n                }\n            }\n            j = j.multiply(BigInteger.TEN).add(d);\n            k = k.add(d);\n            if (n0 > 0) {\n                n--;\n            }\n        } while (n > 0);\n        System.out.println();\n    }\n}\n"}
{"id": 415477, "name": "Square root by hand", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub integral   { my($n) = @_; (length($n) % 2 != 0 ? '0' . $n  : $n) =~ /../g }\nsub fractional { my($n) = @_; (length($n) % 2 == 0 ? $n  . '0' : $n) =~ /../g }\n\nsub SpigotSqrt {\n    my($in) = @_;\n\n    my(@dividends, @fractional, $dividend, $quotient, $remainder, $accum);\n    my $d   = 9;\n    my $D   = '';\n    my $dot = 0;\n\n    if ($in == int $in) {\n        @dividends =    integral($in);\n    } else {\n        @dividends  =   integral($in =~ /(.*)\\./);\n        @fractional = fractional($in =~ /\\.(.*)/);\n    }\n    $dividend = shift @dividends;\n\n    while () {\n        until ( ( $remainder = $dividend - ($D.$d) * $d ) >= 0) { $d-- }\n\n        $accum    .= $d;\n        $quotient .= $d;\n        unless (@dividends) {\n            last if $remainder == 0 and $quotient != 0 and !@fractional;\n            unless ($dot) { $accum .= '.' and $dot = 1 }\n            if (@fractional) {\n                push @dividends, @fractional;\n                @fractional = ();\n            } else {\n                push @dividends, '00';\n            }\n        }\n        $dividend = $remainder . shift @dividends;\n        $D = 2 * $quotient;\n        $d = 9\n    }\n    return $accum;\n}\n\nsay \"The square root of $_ is \" . SpigotSqrt $_ for < 25 0.0625 152.2756 >;\n", "target": "import java.math.BigInteger;\n\npublic class SquareRoot {\n    public static final BigInteger ONE_HUNDRED = BigInteger.valueOf(100);\n    public static final BigInteger TWENTY = BigInteger.valueOf(20);\n\n    public static void main(String[] args) {\n        var i = BigInteger.TWO;\n        var j = BigInteger.valueOf((long) Math.floor(Math.sqrt(2.0)));\n        var k = j;\n        var d = j;\n        int n = 500;\n        int n0 = n;\n        do {\n            System.out.print(d);\n            i = i.subtract(k.multiply(d)).multiply(ONE_HUNDRED);\n            k = TWENTY.multiply(j);\n            for (d = BigInteger.ONE; d.compareTo(BigInteger.TEN) <= 0; d = d.add(BigInteger.ONE)) {\n                if (k.add(d).multiply(d).compareTo(i) > 0) {\n                    d = d.subtract(BigInteger.ONE);\n                    break;\n                }\n            }\n            j = j.multiply(BigInteger.TEN).add(d);\n            k = k.add(d);\n            if (n0 > 0) {\n                n--;\n            }\n        } while (n > 0);\n        System.out.println();\n    }\n}\n"}
{"id": 415478, "name": "Brilliant numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils <max head firstidx uniqint>;\nuse ntheory <primes is_semiprime forsetproduct>;\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nmy(@B,@Br);\nfor my $oom (1..5) {\n    my @P = grep { $oom == length } @{primes(10**$oom)};\n    forsetproduct { is_semiprime($_[0] * $_[1]) and push @B, $_[0] * $_[1] } \\@P, \\@P;\n    @Br = uniqint sort { $a <=> $b } @Br, @B;\n}\n\nsay \"First 100 brilliant numbers:\\n\" . table 10, head 100, @Br;\n\nfor my $oom (1..9) {\n    my $key = firstidx { $_ > 10**$oom } @Br;\n    printf \"First >= %13s is position %9s in the series: %13s\\n\", comma(10**$oom), comma($key), comma $Br[$key];\n}\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 415479, "name": "Brilliant numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils <max head firstidx uniqint>;\nuse ntheory <primes is_semiprime forsetproduct>;\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nmy(@B,@Br);\nfor my $oom (1..5) {\n    my @P = grep { $oom == length } @{primes(10**$oom)};\n    forsetproduct { is_semiprime($_[0] * $_[1]) and push @B, $_[0] * $_[1] } \\@P, \\@P;\n    @Br = uniqint sort { $a <=> $b } @Br, @B;\n}\n\nsay \"First 100 brilliant numbers:\\n\" . table 10, head 100, @Br;\n\nfor my $oom (1..9) {\n    my $key = firstidx { $_ > 10**$oom } @Br;\n    printf \"First >= %13s is position %9s in the series: %13s\\n\", comma(10**$oom), comma($key), comma $Br[$key];\n}\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 415480, "name": "Order disjoint list items", "source": "Translate Perl to Java: sub dsort {\n        my ($m, $n) = @_;\n        my %h;\n        $h{$_}++ for @$n;\n        map $h{$_}-- > 0 ? shift @$n : $_, @$m;\n}\n\nfor (split \"\\n\", <<\"IN\")\n        the cat sat on the mat  | mat cat\n        the cat sat on the mat  | cat mat\n        A B C A B C A B C       | C A C A\n        A B C A B D A B E       | E A D A\n        A B                     | B\n        A B                     | B A\n        A B B A                 | B A\nIN\n{\n\n        my ($a, $b) = map([split], split '\\|');\n        print \"@$a | @$b -> @{[dsort($a, $b)]}\\n\";\n}\n", "target": "import java.util.Arrays;\nimport java.util.BitSet;\nimport org.apache.commons.lang3.ArrayUtils;\n\npublic class OrderDisjointItems {\n\n    public static void main(String[] args) {\n        final String[][] MNs = {{\"the cat sat on the mat\", \"mat cat\"},\n        {\"the cat sat on the mat\", \"cat mat\"},\n        {\"A B C A B C A B C\", \"C A C A\"}, {\"A B C A B D A B E\", \"E A D A\"},\n        {\"A B\", \"B\"}, {\"A B\", \"B A\"}, {\"A B B A\", \"B A\"}, {\"X X Y\", \"X\"}};\n\n        for (String[] a : MNs) {\n            String[] r = orderDisjointItems(a[0].split(\" \"), a[1].split(\" \"));\n            System.out.printf(\"%s | %s -> %s%n\", a[0], a[1], Arrays.toString(r));\n        }\n    }\n\n    \n    static String[] orderDisjointItems(String[] m, String[] n) {\n        for (String e : n) {\n            int idx = ArrayUtils.indexOf(m, e);\n            if (idx != -1)\n                m[idx] = null;\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (m[i] == null)\n                m[i] = n[j++];\n        }\n        return m;\n    }\n\n    \n    static String[] orderDisjointItems2(String[] m, String[] n) {\n        BitSet bitSet = new BitSet(m.length);\n        for (String e : n) {\n            int idx = -1;\n            do {\n                idx = ArrayUtils.indexOf(m, e, idx + 1);\n            } while (idx != -1 && bitSet.get(idx));\n            if (idx != -1)\n                bitSet.set(idx);\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (bitSet.get(i))\n                m[i] = n[j++];\n        }\n        return m;\n    }\n}\n"}
{"id": 415481, "name": "Sort stability", "source": "Translate Perl to Java: use sort 'stable';\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class RJSortStability {\n\n  public static void main(String[] args) {\n    String[] cityList = { \"UK  London\", \"US  New York\", \"US  Birmingham\", \"UK  Birmingham\", };\n\n    String[] cn = cityList.clone();\n    System.out.println(\"\\nBefore sort:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    \n    Arrays.sort(cn, new Comparator<String>() {\n      public int compare(String lft, String rgt) {\n        return lft.substring(4).compareTo(rgt.substring(4));\n      }\n    });\n\n    System.out.println(\"\\nAfter sort on city:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    cn = cityList.clone();\n    System.out.println(\"\\nBefore sort:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    \n    Arrays.sort(cn, new Comparator<String>() {\n      public int compare(String lft, String rgt) {\n        return lft.substring(0, 2).compareTo(rgt.substring(0, 2));\n      }\n    });\n\n    System.out.println(\"\\nAfter sort on country:\");\n    for (String city : cn) {\n      System.out.println(city);\n    }\n\n    System.out.println();\n  }\n}\n"}
{"id": 415482, "name": "Interactive programming (repl)", "source": "Translate Perl to Java: $ perl -de1\n\nLoading DB routines from perl5db.pl version 1.3\nEditor support available.\n\nEnter h or `h h' for help, or `man perldebug' for more help.\n\nmain::(-e:1):   1\n  DB<1> sub f {my ($s1, $s2, $sep) = @_; $s1 . $sep . $sep . $s2}\n\n  DB<2> p f('Rosetta', 'Code', ':')\nRosetta::Code\n  DB<3> q\n", "target": "public static void main(String[] args) {\n    System.out.println(concat(\"Rosetta\", \"Code\", \":\"));\n}\n\npublic static String concat(String a, String b, String c) {\n   return a + c + c + b;\n}\n\nRosetta::Code\n"}
{"id": 415483, "name": "Runtime evaluation_In an environment", "source": "Translate Perl to Java: sub eval_with_x\n   {my $code = shift;\n    my $x = shift;\n    my $first = eval $code;\n    $x = shift;\n    return eval($code) - $first;}\n \nprint eval_with_x('3 * $x', 5, 10), \"\\n\"; \n", "target": "import java.io.File;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.Arrays;\nimport javax.tools.JavaCompiler;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.ToolProvider;\n\npublic class Eval {\n    private static final String CLASS_NAME = \"TempPleaseDeleteMe\";\n\n    private static class StringCompiler\n            extends SimpleJavaFileObject {\n        final String m_sourceCode;\n\n        private StringCompiler( final String sourceCode ) {\n            super( URI.create( \"string:\n            m_sourceCode = sourceCode;\n        }\n\n        @Override\n        public CharSequence getCharContent( final boolean ignoreEncodingErrors ) {\n            return m_sourceCode;\n        }\n\n        private boolean compile() {\n            final JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n\n            return javac.getTask( null, javac.getStandardFileManager( null, null, null ),\n                null, null, null, Arrays.asList( this )\n            ).call();\n        }\n\n        private double callEval( final double x )\n                throws Exception {\n            final Class<?> clarse = Class.forName( CLASS_NAME );\n            final Method   eval   = clarse.getMethod( \"eval\", double.class );\n\n            return ( Double ) eval.invoke( null, x );\n        }\n    }\n\n    public static double evalWithX( final String code, final double x )\n            throws Exception {\n        final StringCompiler sc = new StringCompiler(\n            \"class \"\n                + CLASS_NAME\n                + \"{public static double eval(double x){return (\"\n                + code\n                + \");}}\"\n            );\n\n        if ( ! sc.compile() ) throw new RuntimeException( \"Compiler error\" );\n        return sc.callEval( x );\n    }\n\n    public static void main( final String [] args ) \n            throws Exception  {\n        final String expression = args [ 0 ];\n        final double x1         = Double.parseDouble( args [ 1 ] );\n        final double x2         = Double.parseDouble( args [ 2 ] );\n\n        System.out.println(\n            evalWithX( expression, x1 )\n            - evalWithX( expression, x2 )\n        );\n    }\n}\n"}
{"id": 415484, "name": "Runtime evaluation_In an environment", "source": "Translate Perl to Java: sub eval_with_x\n   {my $code = shift;\n    my $x = shift;\n    my $first = eval $code;\n    $x = shift;\n    return eval($code) - $first;}\n \nprint eval_with_x('3 * $x', 5, 10), \"\\n\"; \n", "target": "import java.io.File;\nimport java.lang.reflect.Method;\nimport java.net.URI;\nimport java.util.Arrays;\nimport javax.tools.JavaCompiler;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.ToolProvider;\n\npublic class Eval {\n    private static final String CLASS_NAME = \"TempPleaseDeleteMe\";\n\n    private static class StringCompiler\n            extends SimpleJavaFileObject {\n        final String m_sourceCode;\n\n        private StringCompiler( final String sourceCode ) {\n            super( URI.create( \"string:\n            m_sourceCode = sourceCode;\n        }\n\n        @Override\n        public CharSequence getCharContent( final boolean ignoreEncodingErrors ) {\n            return m_sourceCode;\n        }\n\n        private boolean compile() {\n            final JavaCompiler javac = ToolProvider.getSystemJavaCompiler();\n\n            return javac.getTask( null, javac.getStandardFileManager( null, null, null ),\n                null, null, null, Arrays.asList( this )\n            ).call();\n        }\n\n        private double callEval( final double x )\n                throws Exception {\n            final Class<?> clarse = Class.forName( CLASS_NAME );\n            final Method   eval   = clarse.getMethod( \"eval\", double.class );\n\n            return ( Double ) eval.invoke( null, x );\n        }\n    }\n\n    public static double evalWithX( final String code, final double x )\n            throws Exception {\n        final StringCompiler sc = new StringCompiler(\n            \"class \"\n                + CLASS_NAME\n                + \"{public static double eval(double x){return (\"\n                + code\n                + \");}}\"\n            );\n\n        if ( ! sc.compile() ) throw new RuntimeException( \"Compiler error\" );\n        return sc.callEval( x );\n    }\n\n    public static void main( final String [] args ) \n            throws Exception  {\n        final String expression = args [ 0 ];\n        final double x1         = Double.parseDouble( args [ 1 ] );\n        final double x2         = Double.parseDouble( args [ 2 ] );\n\n        System.out.println(\n            evalWithX( expression, x1 )\n            - evalWithX( expression, x2 )\n        );\n    }\n}\n"}
{"id": 415485, "name": "Reverse the gender of a string", "source": "Translate Perl to Java: my %swaps = (\n    'she'  => 'he',\n    'his'  => 'her',\n);\n\n$swaps{         $swaps{$_} } =         $_ for keys %swaps; \n$swaps{ ucfirst $swaps{$_} } = ucfirst $_ for keys %swaps; \n\nsub gender_swap {\n    my($s) = @_;\n    $s =~ s/\\b$_\\b/_$swaps{$_}/g for keys %swaps; \n    $s =~ s/_//g;                                 \n    $s;\n}\n\n$original = qq{She was this soul sherpa. She took his heart! They say she's going to put me on a shelf.\\n};\nprint $swapped  = gender_swap($original);\nprint $reverted = gender_swap($swapped);\n", "target": "public class ReallyLameTranslationOfJ {\n\n    public static void main(String[] args) {\n        String s = \"She was a soul stripper. She took my heart!\";\n        System.out.println(cheapTrick(s));\n        System.out.println(cheapTrick(cheapTrick(s)));\n    }\n\n    static String cheapTrick(String s) {\n        if (s.contains(\"She\"))\n            return s.replaceAll(\"She\", \"He\");\n        else if(s.contains(\"He\"))\n            return s.replaceAll(\"He\", \"She\");\n        return s;\n    }\n}\n"}
{"id": 415486, "name": "Reverse the gender of a string", "source": "Translate Perl to Java: my %swaps = (\n    'she'  => 'he',\n    'his'  => 'her',\n);\n\n$swaps{         $swaps{$_} } =         $_ for keys %swaps; \n$swaps{ ucfirst $swaps{$_} } = ucfirst $_ for keys %swaps; \n\nsub gender_swap {\n    my($s) = @_;\n    $s =~ s/\\b$_\\b/_$swaps{$_}/g for keys %swaps; \n    $s =~ s/_//g;                                 \n    $s;\n}\n\n$original = qq{She was this soul sherpa. She took his heart! They say she's going to put me on a shelf.\\n};\nprint $swapped  = gender_swap($original);\nprint $reverted = gender_swap($swapped);\n", "target": "public class ReallyLameTranslationOfJ {\n\n    public static void main(String[] args) {\n        String s = \"She was a soul stripper. She took my heart!\";\n        System.out.println(cheapTrick(s));\n        System.out.println(cheapTrick(cheapTrick(s)));\n    }\n\n    static String cheapTrick(String s) {\n        if (s.contains(\"She\"))\n            return s.replaceAll(\"She\", \"He\");\n        else if(s.contains(\"He\"))\n            return s.replaceAll(\"He\", \"She\");\n        return s;\n    }\n}\n"}
{"id": 415487, "name": "Runtime evaluation", "source": "Translate Perl to Java: my ($a, $b) = (-5, 7);\n$ans = eval 'abs($a * $b)';  \n", "target": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URI;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport javax.tools.FileObject;\nimport javax.tools.ForwardingJavaFileManager;\nimport javax.tools.JavaCompiler;\nimport javax.tools.JavaFileObject;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.StandardJavaFileManager;\nimport javax.tools.StandardLocation;\nimport javax.tools.ToolProvider;\n\npublic class Evaluator{\n    public static void main(String[] args){\n        new Evaluator().eval(\n            \"SayHello\",\n            \"public class SayHello{public void speak(){System.out.println(\\\"Hello world\\\");}}\",\n            \"speak\"\n        );\n    }\n\n    void eval(String className, String classCode, String methodName){\n        Map<String, ByteArrayOutputStream> classCache = new HashMap<>();\n        JavaCompiler                       compiler   = ToolProvider.getSystemJavaCompiler();\n\n        if ( null == compiler )\n            throw new RuntimeException(\"Could not get a compiler.\");\n\n        StandardJavaFileManager                            sfm  = compiler.getStandardFileManager(null, null, null);\n        ForwardingJavaFileManager<StandardJavaFileManager> fjfm = new ForwardingJavaFileManager<StandardJavaFileManager>(sfm){\n            @Override\n            public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling)\n                    throws IOException{\n                if (StandardLocation.CLASS_OUTPUT == location && JavaFileObject.Kind.CLASS == kind)\n                    return new SimpleJavaFileObject(URI.create(\"mem:\n                        @Override\n                        public OutputStream openOutputStream()\n                                throws IOException{\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            classCache.put(className, baos);\n                            return baos;\n                        }\n                    };\n                else\n                    throw new IllegalArgumentException(\"Unexpected output file requested: \" + location + \", \" + className + \", \" + kind);\n            }\n        };\n        List<JavaFileObject> files = new LinkedList<JavaFileObject>(){{\n            add(\n                new SimpleJavaFileObject(URI.create(\"string:\n                    @Override\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors){\n                        return classCode;\n                    }\n                }\n            );\n        }};\n\n        \n        compiler.getTask(null, fjfm, null, null, null, files).call();\n\n        try{\n            Class<?> clarse = new ClassLoader(){\n                @Override\n                public Class<?> findClass(String name){\n                    if (! name.startsWith(className))\n                        throw new IllegalArgumentException(\"This class loader is for \" + className + \" - could not handle \\\"\" + name + '\"');\n                    byte[] bytes = classCache.get(name).toByteArray();\n                    return defineClass(name, bytes, 0, bytes.length);\n                }\n            }.loadClass(className);\n\n            \n            clarse.getMethod(methodName).invoke(clarse.newInstance());\n\n        }catch(ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException x){\n            throw new RuntimeException(\"Run failed: \" + x, x);\n        }\n    }\n}\n"}
{"id": 415488, "name": "Runtime evaluation", "source": "Translate Perl to Java: my ($a, $b) = (-5, 7);\n$ans = eval 'abs($a * $b)';  \n", "target": "import java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.lang.reflect.InvocationTargetException;\nimport java.net.URI;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport javax.tools.FileObject;\nimport javax.tools.ForwardingJavaFileManager;\nimport javax.tools.JavaCompiler;\nimport javax.tools.JavaFileObject;\nimport javax.tools.SimpleJavaFileObject;\nimport javax.tools.StandardJavaFileManager;\nimport javax.tools.StandardLocation;\nimport javax.tools.ToolProvider;\n\npublic class Evaluator{\n    public static void main(String[] args){\n        new Evaluator().eval(\n            \"SayHello\",\n            \"public class SayHello{public void speak(){System.out.println(\\\"Hello world\\\");}}\",\n            \"speak\"\n        );\n    }\n\n    void eval(String className, String classCode, String methodName){\n        Map<String, ByteArrayOutputStream> classCache = new HashMap<>();\n        JavaCompiler                       compiler   = ToolProvider.getSystemJavaCompiler();\n\n        if ( null == compiler )\n            throw new RuntimeException(\"Could not get a compiler.\");\n\n        StandardJavaFileManager                            sfm  = compiler.getStandardFileManager(null, null, null);\n        ForwardingJavaFileManager<StandardJavaFileManager> fjfm = new ForwardingJavaFileManager<StandardJavaFileManager>(sfm){\n            @Override\n            public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind, FileObject sibling)\n                    throws IOException{\n                if (StandardLocation.CLASS_OUTPUT == location && JavaFileObject.Kind.CLASS == kind)\n                    return new SimpleJavaFileObject(URI.create(\"mem:\n                        @Override\n                        public OutputStream openOutputStream()\n                                throws IOException{\n                            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n                            classCache.put(className, baos);\n                            return baos;\n                        }\n                    };\n                else\n                    throw new IllegalArgumentException(\"Unexpected output file requested: \" + location + \", \" + className + \", \" + kind);\n            }\n        };\n        List<JavaFileObject> files = new LinkedList<JavaFileObject>(){{\n            add(\n                new SimpleJavaFileObject(URI.create(\"string:\n                    @Override\n                    public CharSequence getCharContent(boolean ignoreEncodingErrors){\n                        return classCode;\n                    }\n                }\n            );\n        }};\n\n        \n        compiler.getTask(null, fjfm, null, null, null, files).call();\n\n        try{\n            Class<?> clarse = new ClassLoader(){\n                @Override\n                public Class<?> findClass(String name){\n                    if (! name.startsWith(className))\n                        throw new IllegalArgumentException(\"This class loader is for \" + className + \" - could not handle \\\"\" + name + '\"');\n                    byte[] bytes = classCache.get(name).toByteArray();\n                    return defineClass(name, bytes, 0, bytes.length);\n                }\n            }.loadClass(className);\n\n            \n            clarse.getMethod(methodName).invoke(clarse.newInstance());\n\n        }catch(ClassNotFoundException | InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException x){\n            throw new RuntimeException(\"Run failed: \" + x, x);\n        }\n    }\n}\n"}
{"id": 415489, "name": "Index finite lists of positive integers", "source": "Translate Perl to Java: use bigint;\nuse ntheory qw(fromdigits todigitstring);\nuse feature 'say';\n\nsub rank   { join   '', fromdigits(join('a',@_), 11) }\nsub unrank { split 'a', todigitstring(@_[0],     11) }\n\nsay join ' ', @n = qw<12 11 0 7 9 15 15 5 7 13 5 5>;\nsay $n = rank(@n);\nsay join ' ', unrank $n;\n", "target": "import java.math.BigInteger;\nimport static java.util.Arrays.stream;\nimport java.util.*;\nimport static java.util.stream.Collectors.*;\n\npublic class Test3 {\n    static BigInteger rank(int[] x) {\n        String s = stream(x).mapToObj(String::valueOf).collect(joining(\"F\"));\n        return new BigInteger(s, 16);\n    }\n\n    static List<BigInteger> unrank(BigInteger n) {\n        BigInteger sixteen = BigInteger.valueOf(16);\n        String s = \"\";\n        while (!n.equals(BigInteger.ZERO)) {\n            s = \"0123456789ABCDEF\".charAt(n.mod(sixteen).intValue()) + s;\n            n = n.divide(sixteen);\n        }\n        return stream(s.split(\"F\")).map(x -> new BigInteger(x)).collect(toList());\n    }\n\n    public static void main(String[] args) {\n        int[] s = {1, 2, 3, 10, 100, 987654321};\n        System.out.println(Arrays.toString(s));\n        System.out.println(rank(s));\n        System.out.println(unrank(rank(s)));\n    }\n}\n"}
{"id": 415490, "name": "Generate random numbers without repeating a value", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse List::Util qw( shuffle );\n\nprint \"@{[ shuffle 1 .. 20 ]}\\n\" for 1 .. 5;\n", "target": "import java.util.*;\n\npublic class RandomShuffle {\n    public static void main(String[] args) {\n        Random rand = new Random();\n        List<Integer> list = new ArrayList<>();\n        for (int j = 1; j <= 20; ++j)\n            list.add(j);\n        Collections.shuffle(list, rand);\n        System.out.println(list);\n    }\n}\n"}
{"id": 415491, "name": "Read a file character by character_UTF8", "source": "Translate Perl to Java: binmode STDOUT, ':utf8';  \n\nopen my $fh, \"<:encoding(UTF-8)\", \"input.txt\" or die \"$!\\n\";\n\nwhile (read $fh, my $char, 1) {\n    printf \"got character $char [U+%04x]\\n\", ord $char;\n}\n\nclose $fh;\n", "target": "import java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n    \tfinal int endOfFile = -1;\n    \t\n        try ( FileReader reader = new FileReader(\"input.txt\", StandardCharsets.UTF_8) ) {\n\t\t\twhile ( true ) {\n\t\t\t    int ch = reader.read();\n\t\t\t    if ( ch == endOfFile ) {\n\t\t\t    \tbreak;\n\t\t\t    }\n\t\t\t    \n\t\t\t    System.out.print(Character.toChars(ch));\n\t\t\t}\n\t\t}\n    }\n}\n"}
{"id": 415492, "name": "Window management", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\nuse Tk;\n\nmy $mw;\nmy $win;\nmy $lab;\n\n\nsub openWin {\n\tif( $win ) {\n\t\t$win->deiconify;\n\t\t$win->wm('state', 'normal');\n\t} else {\n\t\teval { $win->destroy } if $win;\n\t\t$win = $mw->Toplevel;\n\t\t$win->Label(-text => \"This is the window being manipulated\")\n\t\t\t->pack(-fill => 'both', -expand => 1);\n\t\t$lab->configure(-text => \"The window object is:\\n$win\");\n\t}\n}\n\n\nsub closeWin {\n\treturn unless $win;\n\t$win->destroy;\n\t$lab->configure(-text => '');\n\tundef $win;\n}\n\n\nsub minimizeWin {\n\treturn unless $win;\n\t$win->iconify;\n}\n\n\nsub maximizeWin {\n\treturn unless $win;\n\t$win->wm('state', 'zoomed');\n\teval { $win->wmAttribute(-zoomed => 1) }; \n}\n\n\nsub moveWin {\n\treturn unless $win;\n\tmy ($x, $y) = $win->geometry() =~ /\\+(\\d+)\\+(\\d+)\\z/ or die;\n\t$_ += 10 for $x, $y;\n\t$win->geometry(\"+$x+$y\");\n}\n\n\nsub resizeWin {\n\treturn unless $win;\n\tmy ($w, $h) = $win->geometry() =~ /^(\\d+)x(\\d+)/ or die;\n\t$_ += 10 for $w, $h;\n\t$win->geometry($w . \"x\" . $h);\n}\n\n$mw = MainWindow->new;\nfor my $label0 ($mw->Label(-text => 'Window handle:')) {\n\t$lab = $mw->Label(-text => '');\n\t$label0->grid($lab);\n}\n\nmy @binit = ('Open/Restore' => \\&openWin, Close => \\&closeWin,\n\tMinimize => \\&minimizeWin, Maximize => \\&maximizeWin,\n\tMove => \\&moveWin, Resize => \\&resizeWin);\n\nwhile( my ($text, $callback) = splice @binit, 0, 2 ) {\n\t$mw->Button(-text => $text, -command => $callback)->grid('-');\n}\n\nMainLoop();\n\n", "target": "import java.awt.BorderLayout;\nimport java.awt.EventQueue;\nimport java.awt.Frame;\nimport java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.lang.reflect.InvocationTargetException;\nimport javax.swing.AbstractAction;\nimport javax.swing.JButton;\nimport javax.swing.JComboBox;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.border.EmptyBorder;\n\npublic class WindowController extends JFrame {\n   \n   public static void main( final String[] args ) {\n      EventQueue.invokeLater( () -> new WindowController() );\n   }\n\n   private JComboBox<ControlledWindow> list;\n\n   \n   private class ControlButton extends JButton {\n      private ControlButton( final String name ) {\n         super(\n            new AbstractAction( name ) {\n               public void actionPerformed( final ActionEvent e ) {\n                  try {\n                     WindowController.class.getMethod( \"do\" + name )\n                        .invoke ( WindowController.this );\n                  } catch ( final Exception x ) { \n                     x.printStackTrace();        \n                  }\n               }\n            }\n         );\n      }\n   }\n\n   \n   public WindowController() {\n      super( \"Controller\" );\n\n      final JPanel main = new JPanel();\n      final JPanel controls = new JPanel();\n\n      setLocationByPlatform( true );\n      setResizable( false );\n      setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );\n      setLayout( new BorderLayout( 3, 3 ) );\n      getRootPane().setBorder( new EmptyBorder( 3, 3, 3, 3 ) );\n      add( new JLabel( \"Add windows and control them.\" ), BorderLayout.NORTH );\n      main.add( list = new JComboBox<>() );\n      add( main, BorderLayout.CENTER );\n      controls.setLayout( new GridLayout( 0, 1, 3, 3 ) );\n      controls.add( new ControlButton( \"Add\"      ) );\n      controls.add( new ControlButton( \"Hide\"     ) );\n      controls.add( new ControlButton( \"Show\"     ) );\n      controls.add( new ControlButton( \"Close\"    ) );\n      controls.add( new ControlButton( \"Maximise\" ) );\n      controls.add( new ControlButton( \"Minimise\" ) );\n      controls.add( new ControlButton( \"Move\"     ) );\n      controls.add( new ControlButton( \"Resize\"   ) );\n      add( controls, BorderLayout.EAST );\n      pack();\n      setVisible( true );\n   }\n\n   \n   private static class ControlledWindow extends JFrame {\n      private int num;\n\n      public ControlledWindow( final int num ) {\n         super( Integer.toString( num ) );\n         this.num = num;\n         setLocationByPlatform( true );\n         getRootPane().setBorder( new EmptyBorder( 3, 3, 3, 3 ) );\n         setDefaultCloseOperation( JFrame.DISPOSE_ON_CLOSE );\n         add( new JLabel( \"I am window \" + num + \". Use the controller to control me.\" ) );\n         pack();\n         setVisible( true );\n      }\n\n      public String toString() {\n         return \"Window \" + num;\n      }\n   }\n\n   \n   \n\n   public void doAdd() {\n      list.addItem( new ControlledWindow( list.getItemCount () + 1 ) );\n      pack();\n   }\n\n   public void doHide() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setVisible( false );\n   }\n\n   public void doShow() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setVisible( true );\n   }\n\n   public void doClose() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.dispose();\n   }\n\n   public void doMinimise() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setState( Frame.ICONIFIED );\n   }\n\n   public void doMaximise() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      window.setExtendedState( Frame.MAXIMIZED_BOTH );\n   }\n\n   public void doMove() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      final int hPos = getInt( \"Horizontal position?\" );\n      if ( -1 == hPos ) {\n         return;\n      }\n      final int vPos = getInt( \"Vertical position?\" );\n      if ( -1 == vPos ) {\n         return;\n      }\n      window.setLocation ( hPos, vPos );\n   }\n\n   public void doResize() {\n      final JFrame window = getWindow();\n      if ( null == window ) {\n         return;\n      }\n      final int width = getInt( \"Width?\" );\n      if ( -1 == width ) {\n         return;\n      }\n      final int height = getInt( \"Height?\" );\n      if ( -1 == height ) {\n         return;\n      }\n      window.setBounds ( window.getX(), window.getY(), width, height );\n   }\n\n   private JFrame getWindow() {\n      final JFrame window = ( JFrame ) list.getSelectedItem();\n      if ( null == window ) {\n         JOptionPane.showMessageDialog( this, \"Add a window first\" );\n      }\n      return window;\n   }\n\n   private int getInt(final String prompt) {\n      final String s = JOptionPane.showInputDialog( prompt );\n      if ( null == s ) {\n         return -1;\n      }\n      try {\n         return Integer.parseInt( s );\n      } catch ( final NumberFormatException x ) {\n         JOptionPane.showMessageDialog( this, \"Not a number\" );\n         return -1;\n      }\n   }\n}\n"}
{"id": 415493, "name": "Galton box animation", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse List::Util 'any';\nuse Time::HiRes qw(sleep);\nuse List::AllUtils <pairwise pairs>;\n\nuse utf8;\nbinmode STDOUT, ':utf8';\n\nmy $coins      = shift || 100;\nmy $peg_lines  = shift || 13;\nmy $row_count  = $peg_lines;\nmy $peg        = '^';\nmy @coin_icons = (\"\\N{UPPER HALF BLOCK}\", \"\\N{LOWER HALF BLOCK}\");\n\nmy @coins = (undef) x (3 + $row_count + 4);\nmy @stats = (0) x ($row_count * 2);\n$coins[0] = 0; \n\nwhile (1) {\n    my $active = 0;\n    \n    $stats[$coins[-1] + $row_count]++ if defined $coins[-1];\n\n    \n    for my $line (reverse 1..(3+$row_count+3) ) {\n        my $coinpos = $coins[$line - 1];\n\n        \n        if (! defined $coinpos) {\n            $coins[$line] = undef\n        } elsif (hits_peg($coinpos, $line)) {\n            \n            $active = 1;\n            $coinpos += rand() < .5 ? -1 : 1;\n            $coins[$line] = $coinpos\n        } else {\n            \n            $active = 1;\n            $coins[$line] = $coinpos;\n        }\n    }\n    \n    if (defined $coins[0]) {\n        $coins[0] = undef;\n    } elsif (--$coins > 0) {\n        $coins[0] = 0\n    }\n\n    for (<0 1>) {\n        display_board(\\@coins, \\@stats, $_);\n        sleep .1;\n    }\n    exit unless $active;\n}\n\nsub display_board {\n    my($p_ref, $s_ref, $halfstep) = @_;\n    my @positions = @$p_ref;\n    my @stats     = @$s_ref;\n    my $coin      = $coin_icons[$halfstep];\n\n    my @board = do {\n        my @tmpl;\n\n        sub out {\n            my(@stuff) = split '', shift;\n            my @line;\n            push @line, ord($_) for @stuff;\n            [@line];\n        }\n\n        push @tmpl, out(\"  \" . \" \"x(2 * $row_count)) for 1..3;\n        my @a = reverse 1..$row_count;\n        my @b = 1..$row_count;\n        my @pairs = pairwise { ($a, $b) } @a, @b;\n        for ( pairs @pairs ) {\n            my ( $spaces, $pegs ) = @$_;\n            push @tmpl, out(\"  \" . \" \"x$spaces . join(' ',($peg) x $pegs) . \" \"x$spaces);\n        }\n        push @tmpl, out(\"  \" . \" \"x(2 * $row_count)) for 1..4;\n        @tmpl;\n    };\n\n    my $midpos = $row_count + 2;\n\n    our @output;\n    {\n        \n        sub printnl { my($foo) = @_; push @output, $foo . \"\\n\" }\n        sub printl  { my($foo) = @_; push @output, $foo        }\n\n        \n        printnl(\"\") for 0..9;\n\n        \n        for my $line (0..$\n            my $pos = $positions[$line];\n            next unless defined $pos;\n            $board[$line][$pos + $midpos] = ord($coin);\n        }\n        \n        for my $line (@board) {\n            printnl join '', map { chr($_) } @$line;\n        }\n\n        \n        my $padding = 0;\n        while (any {$_> 0} @stats) {\n            $padding++;\n            printl \"  \";\n            for my $i (0..$\n                if ($stats[$i] == 1) {\n                        printl \"\\N{UPPER HALF BLOCK}\";\n                        $stats[$i]--;\n                } elsif ($stats[$i] <= 0) {\n                        printl \" \";\n                        $stats[$i] = 0\n                } else {\n                        printl \"\\N{FULL BLOCK}\";\n                        $stats[$i]--; $stats[$i]--;\n                }\n            }\n            printnl(\"\");\n        }\n        printnl(\"\") for $padding..(10-1);\n    }\n\n    print join('', @output) . \"\\n\";\n}\n\nsub hits_peg {\n    my($x, $y) = @_;\n    3 <= $y && $y < (3 + $row_count) and -($y - 2) <= $x && $x <= $y - 2\n        ? not 0 == ($x - $y) % 2\n        : 0\n}\n", "target": "import java.util.Random;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class GaltonBox {\n    public static void main( final String[] args ) {\n        new GaltonBox( 8, 200 ).run();\n    }\n\n    private final int        m_pinRows;\n    private final int        m_startRow;\n    private final Position[] m_balls;\n    private final Random     m_random = new Random();\n\n    public GaltonBox( final int pinRows, final int ballCount ) {\n        m_pinRows  = pinRows;\n        m_startRow = pinRows + 1;\n        m_balls    = new Position[ ballCount ];\n\n        for ( int ball = 0; ball < ballCount; ball++ )\n            m_balls[ ball ] = new Position( m_startRow, 0, 'o' );\n    }\n\n    private static class Position {\n        int  m_row;\n        int  m_col;\n        char m_char;\n\n        Position( final int row, final int col, final char ch ) {\n            m_row  = row;\n            m_col  = col;\n            m_char = ch;\n        }\n    }\n\n    public void run() {\n        for ( int ballsInPlay = m_balls.length; ballsInPlay > 0;  ) {\n            ballsInPlay = dropBalls();\n            print();\n        }\n    }\n\n    private int dropBalls() {\n        int ballsInPlay = 0;\n        int ballToStart = -1;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( m_balls[ ball ].m_row == m_startRow )\n                ballToStart = ball;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( ball == ballToStart ) {\n                m_balls[ ball ].m_row = m_pinRows;\n                ballsInPlay++;\n            }\n            else if ( m_balls[ ball ].m_row > 0 && m_balls[ ball ].m_row != m_startRow ) {\n                m_balls[ ball ].m_row -= 1;\n                m_balls[ ball ].m_col += m_random.nextInt( 2 );\n                if ( 0 != m_balls[ ball ].m_row )\n                    ballsInPlay++;\n            }\n\n        return ballsInPlay;\n    }\n\n    private void print() {\n        for ( int row = m_startRow; row --> 1;  ) {\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == row )\n                    printBall( m_balls[ ball ] );\n            System.out.println();\n            printPins( row );\n        }\n        printCollectors();\n        System.out.println();\n    }\n\n    private static void printBall( final Position pos ) {\n        for ( int col = pos.m_row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = 0; col < pos.m_col; col++ )\n            System.out.print( \"  \" );\n        System.out.print( pos.m_char );\n    }\n\n    private void printPins( final int row ) {\n        for ( int col = row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = m_startRow - row; col --> 0;  )\n            System.out.print( \". \" );\n        System.out.println();\n    }\n\n    private void printCollectors() {\n        final List<List<Position>> collectors = new ArrayList<List<Position>>();\n\n        for ( int col = 0; col < m_startRow; col++ ) {\n            final List<Position> collector = new ArrayList<Position>();\n\n            collectors.add( collector );\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == 0 && m_balls[ ball ].m_col == col )\n                    collector.add( m_balls[ ball ] );\n        }\n\n        for ( int row = 0, rows = longest( collectors ); row < rows; row++ ) {\n            for ( int col = 0; col < m_startRow; col++ ) {\n                final List<Position> collector = collectors.get( col );\n                final int            pos       = row + collector.size() - rows;\n\n                System.out.print( '|' );\n                if ( pos >= 0 )\n                    System.out.print( collector.get( pos ).m_char );\n                else\n                    System.out.print( ' ' );\n            }\n            System.out.println( '|' );\n        }\n    }\n\n    private static final int longest( final List<List<Position>> collectors ) {\n        int result = 0;\n\n        for ( final List<Position> collector : collectors )\n            result = Math.max( collector.size(), result );\n\n        return result;\n    }\n}\n"}
{"id": 415494, "name": "Primes - allocate descendants to their ancestors", "source": "Translate Perl to Java: use List::Util qw(sum uniq);\nuse ntheory qw(nth_prime);\n\nmy $max = 99;\nmy %tree;\n\nsub allocate {\n    my($n, $i, $sum,, $prod) = @_;\n    $i //= 0; $sum //= 0; $prod //= 1;\n\n    for my $k (0..$max) {\n        next if $k < $i;\n        my $p = nth_prime($k+1);\n        if (($sum + $p) <= $max) {\n            allocate($n, $k, $sum + $p, $prod * $p);\n        } else {\n            last if $sum == $prod;\n            $tree{$sum}{descendants}{$prod} = 1;\n            $tree{$prod}{ancestor} = [uniq $sum, @{$tree{$sum}{ancestor}}] unless $prod > $max || $sum == 0;\n            last;\n        }\n    }\n}\n\nsub abbrev { \n    my(@d) = @_;\n    return @d if @d < 11;\n    @d[0 .. 4], '...', @d[-5 .. -1];\n}\n\nallocate($_) for 1 .. $max;\n\nfor (1 .. 15, 46, $max) {\n    printf \"%2d, %2d Ancestors:\u00a0%-15s\", $_, (scalar uniq @{$tree{$_}{ancestor}}),\n        '[' . join(' ',uniq @{$tree{$_}{ancestor}}) . ']';\n    my $dn = 0; my $dl = '';\n    if ($tree{$_}{descendants}) {\n        $dn = keys %{$tree{$_}{descendants}};\n        $dl = join ' ', abbrev(sort { $a <=> $b } keys %{$tree{$_}{descendants}});\n    }\n    printf \"%5d Descendants: %s\", $dn, \"[$dl]\\n\";\n}\n\nmap { for my $k (keys %{$tree{$_}{descendants}}) { $total += $tree{$_}{descendants}{$k} } } 1..$max;\nprint \"\\nTotal descendants: $total\\n\";\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class PrimeDescendants {\n    public static void main(String[] args) {\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(System.out))) {\n            printPrimeDesc(writer, 100);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private static void printPrimeDesc(Writer writer, int limit) throws IOException {\n        List<Long> primes = findPrimes(limit);\n\n        List<Long> ancestor = new ArrayList<>(limit);\n        List<List<Long>> descendants = new ArrayList<>(limit);\n        for (int i = 0; i < limit; ++i) {\n            ancestor.add(Long.valueOf(0));\n            descendants.add(new ArrayList<Long>());\n        }\n\n        for (Long prime : primes) {\n            int p = prime.intValue();\n            descendants.get(p).add(prime);\n            for (int i = 0; i + p < limit; ++i) {\n                int s = i + p;\n                for (Long n : descendants.get(i)) {\n                    Long prod = n * p;\n                    descendants.get(s).add(prod);\n                    if (prod < limit)\n                        ancestor.set(prod.intValue(), Long.valueOf(s));\n                }\n            }\n        }\n\n        \n        int totalDescendants = 0;\n        for (int i = 1; i < limit; ++i) {\n            List<Long> ancestors = getAncestors(ancestor, i);\n            writer.write(\"[\" + i + \"] Level: \" + ancestors.size() + \"\\n\");\n            writer.write(\"Ancestors: \");\n            Collections.sort(ancestors);\n            print(writer, ancestors);\n\n            writer.write(\"Descendants: \");\n            List<Long> desc = descendants.get(i);\n            if (!desc.isEmpty()) {\n                Collections.sort(desc);\n                if (desc.get(0) == i)\n                    desc.remove(0);\n            }\n            writer.write(desc.size() + \"\\n\");\n            totalDescendants += desc.size();\n            if (!desc.isEmpty())\n                print(writer, desc);\n            writer.write(\"\\n\");\n        }\n        writer.write(\"Total descendants: \" + totalDescendants + \"\\n\");\n    }\n\n    \n    private static List<Long> findPrimes(int limit) {\n        boolean[] isprime = new boolean[limit];\n        Arrays.fill(isprime, true);\n        isprime[0] = isprime[1] = false;\n        for (int p = 2; p * p < limit; ++p) {\n            if (isprime[p]) {\n                for (int i = p * p; i < limit; i += p)\n                    isprime[i] = false;\n            }\n        }\n        List<Long> primes = new ArrayList<>();\n        for (int p = 2; p < limit; ++p) {\n            if (isprime[p])\n                primes.add(Long.valueOf(p));\n        }\n        return primes;\n    }\n\n    \n    private static List<Long> getAncestors(List<Long> ancestor, int n) {\n        List<Long> result = new ArrayList<>();\n        for (Long a = ancestor.get(n); a != 0 && a != n; ) {\n            n = a.intValue();\n            a = ancestor.get(n);\n            result.add(Long.valueOf(n));\n        }\n        return result;\n    }\n\n    private static void print(Writer writer, List<Long> list) throws IOException {\n        if (list.isEmpty()) {\n            writer.write(\"none\\n\");\n            return;\n        }\n        int i = 0;\n        writer.write(String.valueOf(list.get(i++)));\n        for (; i != list.size(); ++i)\n            writer.write(\", \" + list.get(i));\n        writer.write(\"\\n\");\n    }\n}\n"}
{"id": 415495, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Perl to Java: sub circlesort {\n    our @x; local *x = shift;\n    my($beg,$end) = @_;\n\n    my $swaps = 0;\n    if ($beg < $end) {\n        my $lo = $beg;\n        my $hi = $end;\n        while ($lo < $hi) {\n            if ($x[$lo] > $x[$hi]) { \n                @x[$lo,$hi] = @x[$hi,$lo];\n                ++$swaps;\n            }\n            ++$hi if --$hi == ++$lo\n        }\n        $swaps += circlesort(\\@x, $beg, $hi);\n        $swaps += circlesort(\\@x, $lo, $end);\n    }\n    $swaps;\n}\n\nmy @a = <16 35 -64 -29 46 36 -1 -99 20 100 59 26 76 -78 39 85 -7 -81 25 88>;\nwhile (circlesort(\\@a, 0, $\n", "target": "import java.util.Arrays;\n\npublic class CircleSort {\n\n    public static void main(String[] args) {\n        circleSort(new int[]{2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1});\n    }\n\n    public static void circleSort(int[] arr) {\n        if (arr.length > 0)\n            do {\n                System.out.println(Arrays.toString(arr));\n            } while (circleSortR(arr, 0, arr.length - 1, 0) != 0);\n    }\n\n    private static int circleSortR(int[] arr, int lo, int hi, int numSwaps) {\n        if (lo == hi)\n            return numSwaps;\n\n        int high = hi;\n        int low = lo;\n        int mid = (hi - lo) / 2;\n\n        while (lo < hi) {\n            if (arr[lo] > arr[hi]) {\n                swap(arr, lo, hi);\n                numSwaps++;\n            }\n            lo++;\n            hi--;\n        }\n\n        if (lo == hi && arr[lo] > arr[hi + 1]) {\n            swap(arr, lo, hi + 1);\n            numSwaps++;\n        }\n\n        numSwaps = circleSortR(arr, low, low + mid, numSwaps);\n        numSwaps = circleSortR(arr, low + mid + 1, high, numSwaps);\n\n        return numSwaps;\n    }\n\n    private static void swap(int[] arr, int idx1, int idx2) {\n        int tmp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = tmp;\n    }\n}\n"}
{"id": 415496, "name": "Brace expansion", "source": "Translate Perl to Java: sub brace_expand {\n    my $input = shift;\n    my @stack = ([my $current = ['']]);\n    \n    while ($input =~ /\\G ((?:[^\\\\{,}]++ | \\\\(?:.|\\z))++ | . )/gx) {\n        if ($1 eq '{') {\n            push @stack, [$current = ['']];\n        }\n        elsif ($1 eq ',' && @stack > 1) {\n            push @{$stack[-1]}, ($current = ['']);\n        }\n        elsif ($1 eq '}' && @stack > 1) {\n            my $group = pop @stack;\n            $current = $stack[-1][-1];\n            \n            \n            @{$group->[0]} = map { \"{$_}\" } @{$group->[0]} if @$group == 1;\n            \n            @$current = map {\n                my $c = $_;\n                map { map { $c . $_ } @$_ } @$group;\n            } @$current;\n        }\n        else { $_ .= $1 for @$current; }\n    }\n    \n    \n    while (@stack > 1) {\n        my $right = pop @{$stack[-1]};\n        my $sep;\n        if (@{$stack[-1]}) { $sep = ',' }\n        else               { $sep = '{'; pop @stack }\n        $current = $stack[-1][-1];\n        @$current = map {\n            my $c = $_;\n            map { $c . $sep . $_ } @$right;\n        } @$current;\n    }\n    \n    return @$current;\n}\n", "target": "public class BraceExpansion {\n\n    public static void main(String[] args) {\n        for (String s : new String[]{\"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            \"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\",\n            \"{}} some }{,{\\\\\\\\{ edge, edge} \\\\,}{ cases, {here} \\\\\\\\\\\\\\\\\\\\}\"}) {\n            System.out.println();\n            expand(s);\n        }\n    }\n\n    public static void expand(String s) {\n        expandR(\"\", s, \"\");\n    }\n\n    private static void expandR(String pre, String s, String suf) {\n        int i1 = -1, i2 = 0;\n        String noEscape = s.replaceAll(\"([\\\\\\\\]{2}|[\\\\\\\\][,}{])\", \"  \");\n        StringBuilder sb = null;\n\n        outer:\n        while ((i1 = noEscape.indexOf('{', i1 + 1)) != -1) {\n            i2 = i1 + 1;\n            sb = new StringBuilder(s);\n            for (int depth = 1; i2 < s.length() && depth > 0; i2++) {\n                char c = noEscape.charAt(i2);\n                depth = (c == '{') ? ++depth : depth;\n                depth = (c == '}') ? --depth : depth;\n                if (c == ',' && depth == 1) {\n                    sb.setCharAt(i2, '\\u0000');\n                } else if (c == '}' && depth == 0 && sb.indexOf(\"\\u0000\") != -1)\n                    break outer;\n            }\n        }\n        if (i1 == -1) {\n            if (suf.length() > 0)\n                expandR(pre + s, suf, \"\");\n            else\n                System.out.printf(\"%s%s%s%n\", pre, s, suf);\n        } else {\n            for (String m : sb.substring(i1 + 1, i2).split(\"\\u0000\", -1))\n                expandR(pre + s.substring(0, i1), m, s.substring(i2 + 1) + suf);\n        }\n    }\n}\n"}
{"id": 415497, "name": "Intersecting number wheels", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub get_next {\n    my($w,%wheels) = @_;\n    my $wh = \\@{$wheels{$w}}; \n    my $value = $$wh[0][$$wh[1]];\n    $$wh[1] = ($$wh[1]+1) % @{$$wh[0]};\n    defined $wheels{$value} ? get_next($value,%wheels) : $value;\n}\n\nsub spin_wheels {\n    my(%wheels) = @_;\n    say \"$_: \" . join ', ', @{${$wheels{$_}}[0]} for sort keys %wheels;\n    print get_next('A', %wheels) . ' ' for 1..20; print \"\\n\\n\";\n}\n\nspin_wheels(%$_) for\n(\n {'A' => [['1', '2', '3'], 0]},\n {'A' => [['1', 'B', '2'], 0], 'B' => [['3', '4'], 0]},\n {'A' => [['1', 'D', 'D'], 0], 'D' => [['6', '7', '8'], 0]},\n {'A' => [['1', 'B', 'C'], 0], 'B' => [['3', '4'], 0], 'C' => [['5', 'B'], 0]},\n);\n", "target": "package intersectingNumberWheels;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\npublic class WheelController {\n\tprivate static final String IS_NUMBER = \"[0-9]\";\n\tprivate static final int TWENTY = 20;\n\tprivate static Map<String, WheelModel> wheelMap;\n\n\tpublic static void advance(String wheel) {\n\t\tWheelModel w = wheelMap.get(wheel);\n\t\tif (w.list.get(w.position).matches(IS_NUMBER)) {\n\t\t\tw.printThePosition();\n\t\t\tw.advanceThePosition();\n\t\t} else {\n\t\t\tString wheelName = w.list.get(w.position);\n\t\t\tadvance(wheelName);\n\t\t\tw.advanceThePosition();\n\t\t}\n\t}\n\n\tpublic static void run() {\n\t\tSystem.out.println(wheelMap);\n\t\tIntStream.rangeClosed(1, TWENTY).forEach(i -> advance(\"A\"));\n\t\tSystem.out.println();\n\t\twheelMap.clear();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twheelMap = new HashMap<>();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"2\", \"3\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"2\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"D\", \"D\"));\n\t\twheelMap.put(\"D\", new WheelModel(\"D\", \"6\", \"7\", \"8\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"C\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\twheelMap.put(\"C\", new WheelModel(\"C\", \"5\", \"B\"));\n\t\trun();\n\t}\n\n}\n\nclass WheelModel {\n\tString name;\n\tList<String> list;\n\tint position;\n\tint endPosition;\n\tprivate static final int INITIAL = 0;\n\n\tpublic WheelModel(String name, String... values) {\n\t\tsuper();\n\n\t\tthis.name = name.toUpperCase();\n\t\tthis.list = new ArrayList<>();\n\t\tfor (String value : values) {\n\t\t\tlist.add(value);\n\t\t}\n\t\tthis.position = INITIAL;\n\t\tthis.endPosition = this.list.size() - 1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn list.toString();\n\t}\n\n\tpublic void advanceThePosition() {\n\t\tif (this.position == this.endPosition) {\n\t\t\tthis.position = INITIAL;\n\t\t} else {\n\t\t\tthis.position++;\n\t\t}\n\t}\n\n\tpublic void printThePosition() {\n\t\tSystem.out.print(\" \" + this.list.get(position));\n\t}\n}\n"}
{"id": 415498, "name": "Intersecting number wheels", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub get_next {\n    my($w,%wheels) = @_;\n    my $wh = \\@{$wheels{$w}}; \n    my $value = $$wh[0][$$wh[1]];\n    $$wh[1] = ($$wh[1]+1) % @{$$wh[0]};\n    defined $wheels{$value} ? get_next($value,%wheels) : $value;\n}\n\nsub spin_wheels {\n    my(%wheels) = @_;\n    say \"$_: \" . join ', ', @{${$wheels{$_}}[0]} for sort keys %wheels;\n    print get_next('A', %wheels) . ' ' for 1..20; print \"\\n\\n\";\n}\n\nspin_wheels(%$_) for\n(\n {'A' => [['1', '2', '3'], 0]},\n {'A' => [['1', 'B', '2'], 0], 'B' => [['3', '4'], 0]},\n {'A' => [['1', 'D', 'D'], 0], 'D' => [['6', '7', '8'], 0]},\n {'A' => [['1', 'B', 'C'], 0], 'B' => [['3', '4'], 0], 'C' => [['5', 'B'], 0]},\n);\n", "target": "package intersectingNumberWheels;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\npublic class WheelController {\n\tprivate static final String IS_NUMBER = \"[0-9]\";\n\tprivate static final int TWENTY = 20;\n\tprivate static Map<String, WheelModel> wheelMap;\n\n\tpublic static void advance(String wheel) {\n\t\tWheelModel w = wheelMap.get(wheel);\n\t\tif (w.list.get(w.position).matches(IS_NUMBER)) {\n\t\t\tw.printThePosition();\n\t\t\tw.advanceThePosition();\n\t\t} else {\n\t\t\tString wheelName = w.list.get(w.position);\n\t\t\tadvance(wheelName);\n\t\t\tw.advanceThePosition();\n\t\t}\n\t}\n\n\tpublic static void run() {\n\t\tSystem.out.println(wheelMap);\n\t\tIntStream.rangeClosed(1, TWENTY).forEach(i -> advance(\"A\"));\n\t\tSystem.out.println();\n\t\twheelMap.clear();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twheelMap = new HashMap<>();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"2\", \"3\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"2\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"D\", \"D\"));\n\t\twheelMap.put(\"D\", new WheelModel(\"D\", \"6\", \"7\", \"8\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"C\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\twheelMap.put(\"C\", new WheelModel(\"C\", \"5\", \"B\"));\n\t\trun();\n\t}\n\n}\n\nclass WheelModel {\n\tString name;\n\tList<String> list;\n\tint position;\n\tint endPosition;\n\tprivate static final int INITIAL = 0;\n\n\tpublic WheelModel(String name, String... values) {\n\t\tsuper();\n\n\t\tthis.name = name.toUpperCase();\n\t\tthis.list = new ArrayList<>();\n\t\tfor (String value : values) {\n\t\t\tlist.add(value);\n\t\t}\n\t\tthis.position = INITIAL;\n\t\tthis.endPosition = this.list.size() - 1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn list.toString();\n\t}\n\n\tpublic void advanceThePosition() {\n\t\tif (this.position == this.endPosition) {\n\t\t\tthis.position = INITIAL;\n\t\t} else {\n\t\t\tthis.position++;\n\t\t}\n\t}\n\n\tpublic void printThePosition() {\n\t\tSystem.out.print(\" \" + this.list.get(position));\n\t}\n}\n"}
{"id": 415499, "name": "Color of a screen pixel", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse GD;\n\nmy $file = '/tmp/one-pixel-screen-capture.png';\n\nsystem \"screencapture -R 123,456,1,1 $file\";\n\nmy $image = GD::Image->newFromPng($file);\nmy $index = $image->getPixel(0,0);\nmy($red,$green,$blue) = $image->rgb($index);\nprint \"RGB: $red, $green, $blue\\n\";\n\nunlink $file;\n", "target": "public static Color getColorAt(int x, int y){\n   return new Robot().getPixelColor(x, y);\n}\n"}
{"id": 415500, "name": "Yahoo! search interface", "source": "Translate Perl to Java: package YahooSearch;\n\nuse Encode;\nuse HTTP::Cookies;  \nuse WWW::Mechanize;\n\n\n\nsub apply (&$)\n {my $f = shift; local $_ = shift; $f->(); return $_;}\n\n\n\nmy $search_prefs = 'v=1&n=100&sm=' .\n    apply {s/([^a-zA-Z0-9])/sprintf '%%%02X', ord $1/ge}\n    join '|',\n    map {'!' . $_}\n    qw(hsb Zq0 XbM sss dDO VFM RQh uZ0 Fxe yCl GP4 FZK yNC mEG niH);\nmy $cookies = HTTP::Cookies->new;\n$cookies->set_cookie(0, 'sB', $search_prefs, '/', 'search.yahoo.com');\n\nmy $mech = new WWW::Mechanize\n   (cookie_jar => $cookies,\n    stack_depth => 0);\n\nsub read_page\n {my ($next, $page, @results) =\n     ($mech->find_link(text => 'Next >')->url,\n      decode 'iso-8859-1', $mech->content);\n  while ($page =~ m\n         {<h3> <a \\s class=\"yschttl \\s spt\" \\s\n          href=\" ([^\"]+) \" \\s* >                \n          (.+?) </a>\n          .+?\n          <div \\s class=\"abstr\">\n          (.+?) </div>}xg)\n     {push @results, {url => $1, title => $2, content => $3};\n      foreach ( @{$results[-1]}{qw(title content)} )\n         {s/<.+?>//g;\n          $_ = encode 'utf8', $_;}}\n  return $next, \\@results;}\n\n\n\nsub new\n {my $invocant = shift;\n  my $class = ref($invocant) || $invocant;\n  $mech->get('http://search.yahoo.com/search?p=' . apply\n     {s/([^a-zA-Z0-9 ])/sprintf '%%%02X', ord $1/ge;\n      s/ /+/g;}\n    shift);\n  my ($next, $results) = read_page();\n  return bless {link_to_next => $next, results => $results}, $class;}\n\nsub results\n {@{shift()->{results}};}\n\nsub next_page\n {my $invocant = shift;\n  my $next = $invocant->{link_to_next};\n  unless ($next)\n     {$invocant->{results} = [];\n      return undef;}\n  $mech->get($next);\n  ($next, my $results) = read_page();\n  $invocant->{link_to_next} = $next;\n  $invocant->{results} = $results;\n  return 1;}\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass YahooSearch {\n    private String query;\n    \n    private int page = 1;\n    \n    private static final Pattern pattern = Pattern.compile(\n        \"<a class=\\\"yschttl spt\\\" href=\\\"[^*]+?\\\\*\\\\*([^\\\"]+?)\\\">(.+?)</a></h3>.*?<div class=\\\"(?:sm-abs|abstr)\\\">(.+?)</div>\");\n\n    public YahooSearch(String query) {\n        this.query = query;\n    }\n\n    public List<YahooResult> search() throws MalformedURLException, URISyntaxException, IOException {\n        \n        \n        StringBuilder searchUrl = new StringBuilder(\"http:\n        searchUrl.append(\"p=\").append(URLEncoder.encode(query, \"UTF-8\"));\n        if (page > 1) {searchUrl.append(\"&b=\").append((page - 1) * 10 + 1);}\n        \n        URL url = new URL(searchUrl.toString());\n        List<YahooResult> result = new ArrayList<YahooResult>();\n        StringBuilder sb = new StringBuilder();\n        \n        BufferedReader in = null;\n        try {\n            in = new BufferedReader(new InputStreamReader(url.openStream()));\n            \n            String line = in.readLine();\n            while (line != null) {\n                sb.append(line);\n                line = in.readLine();\n            }\n        }\n        catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        finally {\n            try {in.close();} catch (Exception ignoreMe) {}\n        }\n        String searchResult = sb.toString();\n        \n        Matcher matcher = pattern.matcher(searchResult);\n        while (matcher.find()) {\n            \n            String resultUrl = URLDecoder.decode(matcher.group(1), \"UTF-8\");\n            String resultTitle = matcher.group(2).replaceAll(\"</?b>\", \"\").replaceAll(\"<wbr\u00a0?/?>\", \"\");\n            String resultContent = matcher.group(3).replaceAll(\"</?b>\", \"\").replaceAll(\"<wbr\u00a0?/?>\", \"\");\n            \n            result.add(new YahooResult(resultUrl, resultTitle, resultContent));\n        }\n        return result;\n    }\n\n    public List<YahooResult> search(int page) throws MalformedURLException, URISyntaxException, IOException {\n        \n        this.page = page;\n        return search();\n    }\n\n    public List<YahooResult> nextPage() throws MalformedURLException, URISyntaxException, IOException {\n        \n        page++;\n        return search();\n    }\n\n    public List<YahooResult> previousPage() throws MalformedURLException, URISyntaxException, IOException {\n        \n        if (page > 1) {\n            page--;\n            return search();\n        } else return new ArrayList<YahooResult>();\n    }\n}\n\nclass YahooResult {\n    private URL url;\n    private String title;\n    private String content;\n\n    public URL getUrl() {\n        return url;\n    }\n\n    public void setUrl(URL url) {\n        this.url = url;\n    }\n\n    public void setUrl(String url) throws MalformedURLException {\n        this.url = new URL(url);\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public YahooResult(URL url, String title, String content) {\n        setUrl(url);\n        setTitle(title);\n        setContent(content);\n    }\n\n    public YahooResult(String url, String title, String content) throws MalformedURLException {\n        setUrl(url);\n        setTitle(title);\n        setContent(content);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (title != null) {\n            sb.append(\",title=\").append(title);\n        }\n        if (url != null) {\n            sb.append(\",url=\").append(url);\n        }\n        return sb.charAt(0) == ',' ? sb.substring(1) : sb.toString();\n    }\n}\n\npublic class TestYahooSearch {\n    public static void main(String[] args) throws MalformedURLException, URISyntaxException, IOException {\n        \n        YahooSearch search = new YahooSearch(\"Rosetta code\");\n        \n        List<YahooResult> results = search.search();\n        \n        for (YahooResult result : results) {\n            System.out.println(result.toString());\n        }\n    }\n}\n"}
{"id": 415501, "name": "Circles of given radius through two points", "source": "Translate Perl to Java: use strict;\n\nsub circles {\n    my ($x1, $y1, $x2, $y2, $r) = @_;\n\n    return \"Radius is zero\" if $r == 0;\n    return \"Coincident points gives infinite number of circles\" if $x1 == $x2 and $y1 == $y2;\n\n    \n    my ($dx, $dy) = ($x2 - $x1, $y2 - $y1);\n    my $q = sqrt($dx**2 + $dy**2);\n    return \"Separation of points greater than diameter\" if $q > 2*$r;\n\n    \n    my ($x3, $y3) = (($x1 + $x2) / 2, ($y1 + $y2) / 2);\n    \n    my $d = sqrt($r**2-($q/2)**2);\n\n    \n    sprintf '(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f)',\n        $x3 - $d*$dy/$q, $y3 + $d*$dx/$q,\n        $x3 + $d*$dy/$q, $y3 - $d*$dx/$q;\n}\n\nmy @arr = (\n    [0.1234, 0.9876, 0.8765, 0.2345, 2.0],\n    [0.0000, 2.0000, 0.0000, 0.0000, 1.0],\n    [0.1234, 0.9876, 0.1234, 0.9876, 2.0],\n    [0.1234, 0.9876, 0.8765, 0.2345, 0.5],\n    [0.1234, 0.9876, 0.1234, 0.9876, 0.0]\n);\n\nprintf \"(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f) with radius\u00a0%.1f: %s\\n\", @$_[0..4], circles @$_ for @arr;\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415502, "name": "Circles of given radius through two points", "source": "Translate Perl to Java: use strict;\n\nsub circles {\n    my ($x1, $y1, $x2, $y2, $r) = @_;\n\n    return \"Radius is zero\" if $r == 0;\n    return \"Coincident points gives infinite number of circles\" if $x1 == $x2 and $y1 == $y2;\n\n    \n    my ($dx, $dy) = ($x2 - $x1, $y2 - $y1);\n    my $q = sqrt($dx**2 + $dy**2);\n    return \"Separation of points greater than diameter\" if $q > 2*$r;\n\n    \n    my ($x3, $y3) = (($x1 + $x2) / 2, ($y1 + $y2) / 2);\n    \n    my $d = sqrt($r**2-($q/2)**2);\n\n    \n    sprintf '(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f)',\n        $x3 - $d*$dy/$q, $y3 + $d*$dx/$q,\n        $x3 + $d*$dy/$q, $y3 - $d*$dx/$q;\n}\n\nmy @arr = (\n    [0.1234, 0.9876, 0.8765, 0.2345, 2.0],\n    [0.0000, 2.0000, 0.0000, 0.0000, 1.0],\n    [0.1234, 0.9876, 0.1234, 0.9876, 2.0],\n    [0.1234, 0.9876, 0.8765, 0.2345, 0.5],\n    [0.1234, 0.9876, 0.1234, 0.9876, 0.0]\n);\n\nprintf \"(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f) with radius\u00a0%.1f: %s\\n\", @$_[0..4], circles @$_ for @arr;\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415503, "name": "Vampire number", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\nuse feature qw(say);\n\nsub fangs {\n    my $vampire = shift;\n    my $length  = length 0 + $vampire;\n    return if $length % 2;\n    my $fang_length = $length / 2;\n    my $from        = '1' . '0' x ($fang_length - 1);\n    my $to          = '9' x $fang_length;\n    my $sorted      = join q(), sort split //, $vampire;\n    my @fangs;\n    for my $f1 ($from .. 1 + sqrt $vampire) {\n        next if $vampire % $f1;\n        my $f2 = $vampire / $f1;\n        next if $sorted ne join q(), sort split //, $f1 . $f2;\n        next if 2 == grep '0' eq substr($_, -1 , 1), $f1, $f2; \n        push @fangs, [$f1, $f2];\n    }\n    return @fangs;\n}\n\nmy $count = 0;\nmy $i     = 9;\nwhile ($count < 25) {\n    $i++;\n    my @f = fangs($i);\n    $count++, say join ' ', \"$count. $i:\", map \"[@$_]\", @f if @f;\n}\n\nsay join ' ', $_, map \"[@$_]\", fangs($_) for 16758243290880, 24959017348650, 14593825548650;\n", "target": "import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class VampireNumbers{\n    private static int numDigits(long num){\n        return Long.toString(Math.abs(num)).length();\n    }\n\n    private static boolean fangCheck(long orig, long fang1, long fang2){\n        if(Long.toString(fang1).endsWith(\"0\") && Long.toString(fang2).endsWith(\"0\")) return false;\n\n        int origLen = numDigits(orig);\n        if(numDigits(fang1) != origLen / 2 || numDigits(fang2) != origLen / 2) return false;\n\n        byte[] origBytes = Long.toString(orig).getBytes();\n        byte[] fangBytes = (Long.toString(fang1) + Long.toString(fang2)).getBytes();\n        Arrays.sort(origBytes);\n        Arrays.sort(fangBytes);\n        return Arrays.equals(origBytes, fangBytes);\n    }\n\n    public static void main(String[] args){\n        HashSet<Long> vamps = new HashSet<Long>();\n        for(long i = 10; vamps.size() <= 25; i++ ){\n            if((numDigits(i) % 2) != 0) {i = i * 10 - 1; continue;}\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        vamps.add(i);\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n        Long[] nums = {16758243290880L, 24959017348650L, 14593825548650L};\n        for(Long i : nums){\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415504, "name": "Cistercian numerals", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy @pts = ('', qw( 01 23 03 12 012 13 013 132 0132) );\nmy @dots = qw( 4-0 8-0 4-4 8-4 );\n\nmy @images = map { sprintf(\"%-9s\\n\", \"$_:\") . draw($_) }\n  0, 1, 20, 300, 4000, 5555, 6789, 1133;\nfor ( 1 .. 13 )\n  {\n  s/(.+)\\n/ print \" $1\"; '' /e for @images;\n  print \"\\n\";\n  }\n\nsub draw\n  {\n  my $n = shift;\n  local $_ = \"    \n  my $quadrant = 0;\n  for my $digit ( reverse split //, sprintf \"%04d\", $n )\n    {\n    my ($oldx, $oldy);\n    for my $cell ( split //, $pts[$digit] )\n      {\n      my ($x, $y) = split /-/, $dots[$cell];\n      if( defined $oldx )\n        {\n        my $dirx = $x <=> $oldx;\n        my $diry = $y <=> $oldy;\n        for my $place ( 0 .. 3 )\n          {\n          substr $_, $oldx + $oldy * 10, 1, '\n          $oldx += $dirx;\n          $oldy += $diry;\n          }\n        }\n      ($oldx, $oldy) = ($x, $y);\n      }\n    s/.+/ reverse $& /ge;\n    ++$quadrant & 1 or $_ = join '', reverse /.+\\n/g;\n    }\n  return $_;\n  }\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class Cistercian {\n    private static final int SIZE = 15;\n    private final char[][] canvas = new char[SIZE][SIZE];\n\n    public Cistercian(int n) {\n        initN();\n        draw(n);\n    }\n\n    public void initN() {\n        for (var row : canvas) {\n            Arrays.fill(row, ' ');\n            row[5] = 'x';\n        }\n    }\n\n    private void horizontal(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void vertical(int r1, int r2, int c) {\n        for (int r = r1; r <= r2; r++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void diagd(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r + c - c1][c] = 'x';\n        }\n    }\n\n    private void diagu(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r - c + c1][c] = 'x';\n        }\n    }\n\n    private void draw(int v) {\n        var thousands = v / 1000;\n        v %= 1000;\n\n        var hundreds = v / 100;\n        v %= 100;\n\n        var tens = v / 10;\n        var ones = v % 10;\n\n        drawPart(1000 * thousands);\n        drawPart(100 * hundreds);\n        drawPart(10 * tens);\n        drawPart(ones);\n    }\n\n    private void drawPart(int v) {\n        switch (v) {\n            case 1:\n                horizontal(6, 10, 0);\n                break;\n            case 2:\n                horizontal(6, 10, 4);\n                break;\n            case 3:\n                diagd(6, 10, 0);\n                break;\n            case 4:\n                diagu(6, 10, 4);\n                break;\n            case 5:\n                drawPart(1);\n                drawPart(4);\n                break;\n            case 6:\n                vertical(0, 4, 10);\n                break;\n            case 7:\n                drawPart(1);\n                drawPart(6);\n                break;\n            case 8:\n                drawPart(2);\n                drawPart(6);\n                break;\n            case 9:\n                drawPart(1);\n                drawPart(8);\n                break;\n\n            case 10:\n                horizontal(0, 4, 0);\n                break;\n            case 20:\n                horizontal(0, 4, 4);\n                break;\n            case 30:\n                diagu(0, 4, 4);\n                break;\n            case 40:\n                diagd(0, 4, 0);\n                break;\n            case 50:\n                drawPart(10);\n                drawPart(40);\n                break;\n            case 60:\n                vertical(0, 4, 0);\n                break;\n            case 70:\n                drawPart(10);\n                drawPart(60);\n                break;\n            case 80:\n                drawPart(20);\n                drawPart(60);\n                break;\n            case 90:\n                drawPart(10);\n                drawPart(80);\n                break;\n\n            case 100:\n                horizontal(6, 10, 14);\n                break;\n            case 200:\n                horizontal(6, 10, 10);\n                break;\n            case 300:\n                diagu(6, 10, 14);\n                break;\n            case 400:\n                diagd(6, 10, 10);\n                break;\n            case 500:\n                drawPart(100);\n                drawPart(400);\n                break;\n            case 600:\n                vertical(10, 14, 10);\n                break;\n            case 700:\n                drawPart(100);\n                drawPart(600);\n                break;\n            case 800:\n                drawPart(200);\n                drawPart(600);\n                break;\n            case 900:\n                drawPart(100);\n                drawPart(800);\n                break;\n\n            case 1000:\n                horizontal(0, 4, 14);\n                break;\n            case 2000:\n                horizontal(0, 4, 10);\n                break;\n            case 3000:\n                diagd(0, 4, 10);\n                break;\n            case 4000:\n                diagu(0, 4, 14);\n                break;\n            case 5000:\n                drawPart(1000);\n                drawPart(4000);\n                break;\n            case 6000:\n                vertical(10, 14, 0);\n                break;\n            case 7000:\n                drawPart(1000);\n                drawPart(6000);\n                break;\n            case 8000:\n                drawPart(2000);\n                drawPart(6000);\n                break;\n            case 9000:\n                drawPart(1000);\n                drawPart(8000);\n                break;\n\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        for (var row : canvas) {\n            builder.append(row);\n            builder.append('\\n');\n        }\n        return builder.toString();\n    }\n\n    public static void main(String[] args) {\n        for (int number : List.of(0, 1, 20, 300, 4000, 5555, 6789, 9999)) {\n            System.out.printf(\"%d:\\n\", number);\n            var c = new Cistercian(number);\n            System.out.println(c);\n        }\n    }\n}\n"}
{"id": 415505, "name": "Cistercian numerals", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy @pts = ('', qw( 01 23 03 12 012 13 013 132 0132) );\nmy @dots = qw( 4-0 8-0 4-4 8-4 );\n\nmy @images = map { sprintf(\"%-9s\\n\", \"$_:\") . draw($_) }\n  0, 1, 20, 300, 4000, 5555, 6789, 1133;\nfor ( 1 .. 13 )\n  {\n  s/(.+)\\n/ print \" $1\"; '' /e for @images;\n  print \"\\n\";\n  }\n\nsub draw\n  {\n  my $n = shift;\n  local $_ = \"    \n  my $quadrant = 0;\n  for my $digit ( reverse split //, sprintf \"%04d\", $n )\n    {\n    my ($oldx, $oldy);\n    for my $cell ( split //, $pts[$digit] )\n      {\n      my ($x, $y) = split /-/, $dots[$cell];\n      if( defined $oldx )\n        {\n        my $dirx = $x <=> $oldx;\n        my $diry = $y <=> $oldy;\n        for my $place ( 0 .. 3 )\n          {\n          substr $_, $oldx + $oldy * 10, 1, '\n          $oldx += $dirx;\n          $oldy += $diry;\n          }\n        }\n      ($oldx, $oldy) = ($x, $y);\n      }\n    s/.+/ reverse $& /ge;\n    ++$quadrant & 1 or $_ = join '', reverse /.+\\n/g;\n    }\n  return $_;\n  }\n", "target": "import java.util.Arrays;\nimport java.util.List;\n\npublic class Cistercian {\n    private static final int SIZE = 15;\n    private final char[][] canvas = new char[SIZE][SIZE];\n\n    public Cistercian(int n) {\n        initN();\n        draw(n);\n    }\n\n    public void initN() {\n        for (var row : canvas) {\n            Arrays.fill(row, ' ');\n            row[5] = 'x';\n        }\n    }\n\n    private void horizontal(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void vertical(int r1, int r2, int c) {\n        for (int r = r1; r <= r2; r++) {\n            canvas[r][c] = 'x';\n        }\n    }\n\n    private void diagd(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r + c - c1][c] = 'x';\n        }\n    }\n\n    private void diagu(int c1, int c2, int r) {\n        for (int c = c1; c <= c2; c++) {\n            canvas[r - c + c1][c] = 'x';\n        }\n    }\n\n    private void draw(int v) {\n        var thousands = v / 1000;\n        v %= 1000;\n\n        var hundreds = v / 100;\n        v %= 100;\n\n        var tens = v / 10;\n        var ones = v % 10;\n\n        drawPart(1000 * thousands);\n        drawPart(100 * hundreds);\n        drawPart(10 * tens);\n        drawPart(ones);\n    }\n\n    private void drawPart(int v) {\n        switch (v) {\n            case 1:\n                horizontal(6, 10, 0);\n                break;\n            case 2:\n                horizontal(6, 10, 4);\n                break;\n            case 3:\n                diagd(6, 10, 0);\n                break;\n            case 4:\n                diagu(6, 10, 4);\n                break;\n            case 5:\n                drawPart(1);\n                drawPart(4);\n                break;\n            case 6:\n                vertical(0, 4, 10);\n                break;\n            case 7:\n                drawPart(1);\n                drawPart(6);\n                break;\n            case 8:\n                drawPart(2);\n                drawPart(6);\n                break;\n            case 9:\n                drawPart(1);\n                drawPart(8);\n                break;\n\n            case 10:\n                horizontal(0, 4, 0);\n                break;\n            case 20:\n                horizontal(0, 4, 4);\n                break;\n            case 30:\n                diagu(0, 4, 4);\n                break;\n            case 40:\n                diagd(0, 4, 0);\n                break;\n            case 50:\n                drawPart(10);\n                drawPart(40);\n                break;\n            case 60:\n                vertical(0, 4, 0);\n                break;\n            case 70:\n                drawPart(10);\n                drawPart(60);\n                break;\n            case 80:\n                drawPart(20);\n                drawPart(60);\n                break;\n            case 90:\n                drawPart(10);\n                drawPart(80);\n                break;\n\n            case 100:\n                horizontal(6, 10, 14);\n                break;\n            case 200:\n                horizontal(6, 10, 10);\n                break;\n            case 300:\n                diagu(6, 10, 14);\n                break;\n            case 400:\n                diagd(6, 10, 10);\n                break;\n            case 500:\n                drawPart(100);\n                drawPart(400);\n                break;\n            case 600:\n                vertical(10, 14, 10);\n                break;\n            case 700:\n                drawPart(100);\n                drawPart(600);\n                break;\n            case 800:\n                drawPart(200);\n                drawPart(600);\n                break;\n            case 900:\n                drawPart(100);\n                drawPart(800);\n                break;\n\n            case 1000:\n                horizontal(0, 4, 14);\n                break;\n            case 2000:\n                horizontal(0, 4, 10);\n                break;\n            case 3000:\n                diagd(0, 4, 10);\n                break;\n            case 4000:\n                diagu(0, 4, 14);\n                break;\n            case 5000:\n                drawPart(1000);\n                drawPart(4000);\n                break;\n            case 6000:\n                vertical(10, 14, 0);\n                break;\n            case 7000:\n                drawPart(1000);\n                drawPart(6000);\n                break;\n            case 8000:\n                drawPart(2000);\n                drawPart(6000);\n                break;\n            case 9000:\n                drawPart(1000);\n                drawPart(8000);\n                break;\n\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder builder = new StringBuilder();\n        for (var row : canvas) {\n            builder.append(row);\n            builder.append('\\n');\n        }\n        return builder.toString();\n    }\n\n    public static void main(String[] args) {\n        for (int number : List.of(0, 1, 20, 300, 4000, 5555, 6789, 9999)) {\n            System.out.printf(\"%d:\\n\", number);\n            var c = new Cistercian(number);\n            System.out.println(c);\n        }\n    }\n}\n"}
{"id": 415506, "name": "Poker hand analyser", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse utf8;\nuse feature 'say';\nuse open qw<:encoding(utf-8) :std>;\n \npackage Hand {\n    sub describe {\n        my $str = pop;\n        my $hand = init($str);\n        return \"$str: INVALID\" if !$hand;\n        return analyze($hand);\n    }\n \n    sub init {\n        (my $str = lc shift) =~ tr/234567891jqka\u2665\u2666\u2663\u2660//cd;\n        return if $str !~ m/\\A (?: [234567891jqka] [\u2665\u2666\u2663\u2660] ){5} \\z/x;\n        for (my ($i, $cnt) = (0, 0); $i < 10; $i += 2, $cnt = 0) {\n            my $try = substr $str, $i, 2;\n            ++$cnt while $str =~ m/$try/g;\n            return if $cnt > 1;\n        }\n        my $suits = $str =~ tr/234567891jqka//dr;\n        my $ranks = $str =~ tr/\u2665\u2666\u2663\u2660//dr;\n        return {\n            hand  => $str,\n            suits => $suits,\n            ranks => $ranks,\n        };\n    }\n \n    sub analyze {\n        my $hand = shift;\n        my @ranks = split //, $hand->{ranks};\n        my %cards;\n        for (@ranks) {\n            $_ = 10, next if $_ eq '1';\n            $_ = 11, next if $_ eq 'j';\n            $_ = 12, next if $_ eq 'q';\n            $_ = 13, next if $_ eq 'k';\n            $_ = 14, next if $_ eq 'a';\n        } continue {\n            ++$cards{ $_ };\n        }\n        my $kicker = 0;\n        my (@pairs, $set, $quads, $straight, $flush);\n \n        while (my ($card, $count) = each %cards) {\n            if ($count == 1) {\n                $kicker = $card if $kicker < $card;\n            }\n            elsif ($count == 2) {\n                push @pairs, $card;\n            }\n            elsif ($count == 3) {\n                $set = $card;\n            }\n            elsif ($count == 4) {\n                $quads = $card;\n            }\n            else {\n                die \"Five of a kind? Cheater!\\n\";\n            }\n        }\n        $flush    = 1 if $hand->{suits} =~ m/\\A (.) \\1 {4}/x;\n        $straight = check_straight(@ranks);\n        return get_high($kicker, \\@pairs, $set, $quads, $straight, $flush,);\n    }\n \n    sub check_straight {\n        my $sequence = join ' ', sort { $a <=> $b } @_;\n        return 1       if index('2 3 4 5 6 7 8 9 10 11 12 13 14', $sequence) != -1;\n        return 'wheel' if index('2 3 4 5 14 6 7 8 9 10 11 12 13', $sequence) ==  0;\n        return undef;\n    }\n \n    sub get_high {\n        my ($kicker, $pairs, $set, $quads, $straight, $flush) = @_;\n        $kicker = to_s($kicker, 's');\n        return 'straight-flush: Royal Flush!'\n            if $straight && $flush && $kicker eq 'Ace' && $straight ne 'wheel';\n        return \"straight-flush: Steel Wheel!\"\n            if $straight && $flush && $straight eq 'wheel';\n        return \"straight-flush: $kicker high\"\n            if $straight && $flush;\n        return 'four-of-a-kind: '. to_s($quads, 'p')\n            if $quads;\n        return 'full-house: '. to_s($set, 'p') .' full of '. to_s($pairs->[0], 'p')\n            if $set && @$pairs;\n        return \"flush: $kicker high\"\n            if $flush;\n        return 'straight: Wheel!'\n            if $straight && $straight eq 'wheel';\n        return \"straight: $kicker high\"\n            if $straight;\n        return 'three-of-a-kind: '. to_s($set, 'p')\n            if $set;\n        return 'two-pairs: '. to_s($pairs->[0], 'p') .' and '. to_s($pairs->[1], 'p')\n            if @$pairs == 2;\n        return 'one-pair: '. to_s($pairs->[0], 'p')\n            if @$pairs == 1;\n        return \"high-card: $kicker\";\n    }\n \n    my %to_str = (\n         2 => 'Two',    3 => 'Three', 4 => 'Four',  5 => 'Five', 6 => 'Six',\n         7 => 'Seven',  8 => 'Eight', 9 => 'Nine', 10 => 'Ten', 11 => 'Jack',\n        12 => 'Queen', 13 => 'King', 14 => 'Ace',\n    );\n    my %to_str_diffs = (2 => 'Deuces', 6 => 'Sixes',);\n \n    sub to_s {\n        my ($num, $verb) = @_;\n        \n        if ($verb =~ m/\\A p/xi) {\n            return $to_str_diffs{ $num } if $to_str_diffs{ $num };\n            return $to_str{ $num } .'s';\n        }\n        return $to_str{ $num };\n    }\n}\n \nmy @cards = (\n    '10\u2665 j\u2665  q\u2665 k\u2665 a\u2665',\n    '2\u2665  3\u2665  4\u2665 5\u2665 a\u2665',\n    '2\u2665  2\u2663  2\u2666 3\u2663 2\u2660',\n    '10\u2665 K\u2665  K\u2666 K\u2663 10\u2666',\n    'q\u2663  10\u2663 7\u2663 6\u2663 3\u2663',\n    '5\u2663  10\u2663 7\u2663 6\u2663 4\u2663',\n    '9\u2665  10\u2665 q\u2665 k\u2665 j\u2663',\n    'a\u2665  a\u2663  3\u2663 4\u2663 5\u2666',\n    '2\u2665  2\u2666  2\u2663 k\u2663 q\u2666',\n    '6\u2665  7\u2665  6\u2666 j\u2663 j\u2666',\n    '2\u2665  6\u2665  2\u2666 3\u2663 3\u2666',\n    '7\u2665  7\u2660  k\u2660 3\u2666 10\u2660',\n    '4\u2665  4\u2660  k\u2660 2\u2666 10\u2660',\n    '2\u2665  5\u2665  j\u2666 8\u2663 9\u2660',\n    '2\u2665  5\u2665  7\u2666 8\u2663 9\u2660',\n    'a\u2665  a\u2665  3\u2663 4\u2663 5\u2666', \n);\n \nsay Hand::describe($_) for @cards;\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\n\npublic class PokerHandAnalyzer {\n\n    final static String faces = \"AKQJT98765432\";\n    final static String suits = \"HDSC\";\n    final static String[] deck = buildDeck();\n\n    public static void main(String[] args) {\n        System.out.println(\"Regular hands:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS QD\",\n            \"2H 5H 7D 8S 9D\",\n            \"AH 2D 3S 4S 5S\",\n            \"2H 3H 2D 3S 3D\",\n            \"2H 7H 2D 3S 3D\",\n            \"2H 7H 7D 7S 7C\",\n            \"TH JH QH KH AH\",\n            \"4H 4C KC 5D TC\",\n            \"QC TC 7C 6C 4C\",\n            \"QC TC 7C 7C TD\"}) {\n            System.out.println(analyzeHand(input.split(\" \")));\n        }\n\n        System.out.println(\"\\nHands with wildcards:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS WW\",\n            \"2H 5H 7D 8S WW\",\n            \"AH 2D 3S 4S WW\",\n            \"2H 3H 2D 3S WW\",\n            \"2H 7H 2D 3S WW\",\n            \"2H 7H 7D WW WW\",\n            \"TH JH QH WW WW\",\n            \"4H 4C KC WW WW\",\n            \"QC TC 7C WW WW\",\n            \"QC TC 7H WW WW\"}) {\n            System.out.println(analyzeHandWithWildcards(input.split(\" \")));\n        }\n    }\n\n    private static Score analyzeHand(final String[] hand) {\n        if (hand.length != 5)\n            return new Score(\"invalid hand: wrong number of cards\", -1, hand);\n\n        if (new HashSet<>(Arrays.asList(hand)).size() != hand.length)\n            return new Score(\"invalid hand: duplicates\", -1, hand);\n\n        int[] faceCount = new int[faces.length()];\n        long straight = 0, flush = 0;\n        for (String card : hand) {\n\n            int face = faces.indexOf(card.charAt(0));\n            if (face == -1)\n                return new Score(\"invalid hand: non existing face\", -1, hand);\n            straight |= (1 << face);\n\n            faceCount[face]++;\n\n            if (suits.indexOf(card.charAt(1)) == -1)\n                return new Score(\"invalid hand: non-existing suit\", -1, hand);\n            flush |= (1 << card.charAt(1));\n        }\n\n        \n        while (straight % 2 == 0)\n            straight >>= 1;\n\n        \n        boolean hasStraight = straight == 0b11111 || straight == 0b1111000000001;\n\n        \n        boolean hasFlush = (flush & (flush - 1)) == 0;\n\n        if (hasStraight && hasFlush)\n            return new Score(\"straight-flush\", 9, hand);\n\n        int total = 0;\n        for (int count : faceCount) {\n            if (count == 4)\n                return new Score(\"four-of-a-kind\", 8, hand);\n            if (count == 3)\n                total += 3;\n            else if (count == 2)\n                total += 2;\n        }\n\n        if (total == 5)\n            return new Score(\"full-house\", 7, hand);\n\n        if (hasFlush)\n            return new Score(\"flush\", 6, hand);\n\n        if (hasStraight)\n            return new Score(\"straight\", 5, hand);\n\n        if (total == 3)\n            return new Score(\"three-of-a-kind\", 4, hand);\n\n        if (total == 4)\n            return new Score(\"two-pair\", 3, hand);\n\n        if (total == 2)\n            return new Score(\"one-pair\", 2, hand);\n\n        return new Score(\"high-card\", 1, hand);\n    }\n\n    private static WildScore analyzeHandWithWildcards(String[] hand) {\n        if (Collections.frequency(Arrays.asList(hand), \"WW\") > 2)\n            throw new IllegalArgumentException(\"too many wildcards\");\n\n        return new WildScore(analyzeHandWithWildcardsR(hand, null), hand.clone());\n    }\n\n    private static Score analyzeHandWithWildcardsR(String[] hand,\n            Score best) {\n\n        for (int i = 0; i < hand.length; i++) {\n            if (hand[i].equals(\"WW\")) {\n                for (String card : deck) {\n                    if (!Arrays.asList(hand).contains(card)) {\n                        hand[i] = card;\n                        best = analyzeHandWithWildcardsR(hand, best);\n                    }\n                }\n                hand[i] = \"WW\";\n                break;\n            }\n        }\n        Score result = analyzeHand(hand);\n        if (best == null || result.weight > best.weight)\n            best = result;\n        return best;\n    }\n\n    private static String[] buildDeck() {\n        String[] dck = new String[suits.length() * faces.length()];\n        int i = 0;\n        for (char s : suits.toCharArray()) {\n            for (char f : faces.toCharArray()) {\n                dck[i] = \"\" + f + s;\n                i++;\n            }\n        }\n        return dck;\n    }\n\n    private static class Score {\n        final int weight;\n        final String name;\n        final String[] hand;\n\n        Score(String n, int w, String[] h) {\n            weight = w;\n            name = n;\n            hand = h != null ? h.clone() : h;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(hand) + \" \" + name;\n        }\n    }\n\n    private static class WildScore {\n        final String[] wild;\n        final Score score;\n\n        WildScore(Score s, String[] w) {\n            score = s;\n            wild = w;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s%n%s%n\", Arrays.toString(wild),\n                    score.toString());\n        }\n    }\n}\n"}
{"id": 415507, "name": "Poker hand analyser", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse utf8;\nuse feature 'say';\nuse open qw<:encoding(utf-8) :std>;\n \npackage Hand {\n    sub describe {\n        my $str = pop;\n        my $hand = init($str);\n        return \"$str: INVALID\" if !$hand;\n        return analyze($hand);\n    }\n \n    sub init {\n        (my $str = lc shift) =~ tr/234567891jqka\u2665\u2666\u2663\u2660//cd;\n        return if $str !~ m/\\A (?: [234567891jqka] [\u2665\u2666\u2663\u2660] ){5} \\z/x;\n        for (my ($i, $cnt) = (0, 0); $i < 10; $i += 2, $cnt = 0) {\n            my $try = substr $str, $i, 2;\n            ++$cnt while $str =~ m/$try/g;\n            return if $cnt > 1;\n        }\n        my $suits = $str =~ tr/234567891jqka//dr;\n        my $ranks = $str =~ tr/\u2665\u2666\u2663\u2660//dr;\n        return {\n            hand  => $str,\n            suits => $suits,\n            ranks => $ranks,\n        };\n    }\n \n    sub analyze {\n        my $hand = shift;\n        my @ranks = split //, $hand->{ranks};\n        my %cards;\n        for (@ranks) {\n            $_ = 10, next if $_ eq '1';\n            $_ = 11, next if $_ eq 'j';\n            $_ = 12, next if $_ eq 'q';\n            $_ = 13, next if $_ eq 'k';\n            $_ = 14, next if $_ eq 'a';\n        } continue {\n            ++$cards{ $_ };\n        }\n        my $kicker = 0;\n        my (@pairs, $set, $quads, $straight, $flush);\n \n        while (my ($card, $count) = each %cards) {\n            if ($count == 1) {\n                $kicker = $card if $kicker < $card;\n            }\n            elsif ($count == 2) {\n                push @pairs, $card;\n            }\n            elsif ($count == 3) {\n                $set = $card;\n            }\n            elsif ($count == 4) {\n                $quads = $card;\n            }\n            else {\n                die \"Five of a kind? Cheater!\\n\";\n            }\n        }\n        $flush    = 1 if $hand->{suits} =~ m/\\A (.) \\1 {4}/x;\n        $straight = check_straight(@ranks);\n        return get_high($kicker, \\@pairs, $set, $quads, $straight, $flush,);\n    }\n \n    sub check_straight {\n        my $sequence = join ' ', sort { $a <=> $b } @_;\n        return 1       if index('2 3 4 5 6 7 8 9 10 11 12 13 14', $sequence) != -1;\n        return 'wheel' if index('2 3 4 5 14 6 7 8 9 10 11 12 13', $sequence) ==  0;\n        return undef;\n    }\n \n    sub get_high {\n        my ($kicker, $pairs, $set, $quads, $straight, $flush) = @_;\n        $kicker = to_s($kicker, 's');\n        return 'straight-flush: Royal Flush!'\n            if $straight && $flush && $kicker eq 'Ace' && $straight ne 'wheel';\n        return \"straight-flush: Steel Wheel!\"\n            if $straight && $flush && $straight eq 'wheel';\n        return \"straight-flush: $kicker high\"\n            if $straight && $flush;\n        return 'four-of-a-kind: '. to_s($quads, 'p')\n            if $quads;\n        return 'full-house: '. to_s($set, 'p') .' full of '. to_s($pairs->[0], 'p')\n            if $set && @$pairs;\n        return \"flush: $kicker high\"\n            if $flush;\n        return 'straight: Wheel!'\n            if $straight && $straight eq 'wheel';\n        return \"straight: $kicker high\"\n            if $straight;\n        return 'three-of-a-kind: '. to_s($set, 'p')\n            if $set;\n        return 'two-pairs: '. to_s($pairs->[0], 'p') .' and '. to_s($pairs->[1], 'p')\n            if @$pairs == 2;\n        return 'one-pair: '. to_s($pairs->[0], 'p')\n            if @$pairs == 1;\n        return \"high-card: $kicker\";\n    }\n \n    my %to_str = (\n         2 => 'Two',    3 => 'Three', 4 => 'Four',  5 => 'Five', 6 => 'Six',\n         7 => 'Seven',  8 => 'Eight', 9 => 'Nine', 10 => 'Ten', 11 => 'Jack',\n        12 => 'Queen', 13 => 'King', 14 => 'Ace',\n    );\n    my %to_str_diffs = (2 => 'Deuces', 6 => 'Sixes',);\n \n    sub to_s {\n        my ($num, $verb) = @_;\n        \n        if ($verb =~ m/\\A p/xi) {\n            return $to_str_diffs{ $num } if $to_str_diffs{ $num };\n            return $to_str{ $num } .'s';\n        }\n        return $to_str{ $num };\n    }\n}\n \nmy @cards = (\n    '10\u2665 j\u2665  q\u2665 k\u2665 a\u2665',\n    '2\u2665  3\u2665  4\u2665 5\u2665 a\u2665',\n    '2\u2665  2\u2663  2\u2666 3\u2663 2\u2660',\n    '10\u2665 K\u2665  K\u2666 K\u2663 10\u2666',\n    'q\u2663  10\u2663 7\u2663 6\u2663 3\u2663',\n    '5\u2663  10\u2663 7\u2663 6\u2663 4\u2663',\n    '9\u2665  10\u2665 q\u2665 k\u2665 j\u2663',\n    'a\u2665  a\u2663  3\u2663 4\u2663 5\u2666',\n    '2\u2665  2\u2666  2\u2663 k\u2663 q\u2666',\n    '6\u2665  7\u2665  6\u2666 j\u2663 j\u2666',\n    '2\u2665  6\u2665  2\u2666 3\u2663 3\u2666',\n    '7\u2665  7\u2660  k\u2660 3\u2666 10\u2660',\n    '4\u2665  4\u2660  k\u2660 2\u2666 10\u2660',\n    '2\u2665  5\u2665  j\u2666 8\u2663 9\u2660',\n    '2\u2665  5\u2665  7\u2666 8\u2663 9\u2660',\n    'a\u2665  a\u2665  3\u2663 4\u2663 5\u2666', \n);\n \nsay Hand::describe($_) for @cards;\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\n\npublic class PokerHandAnalyzer {\n\n    final static String faces = \"AKQJT98765432\";\n    final static String suits = \"HDSC\";\n    final static String[] deck = buildDeck();\n\n    public static void main(String[] args) {\n        System.out.println(\"Regular hands:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS QD\",\n            \"2H 5H 7D 8S 9D\",\n            \"AH 2D 3S 4S 5S\",\n            \"2H 3H 2D 3S 3D\",\n            \"2H 7H 2D 3S 3D\",\n            \"2H 7H 7D 7S 7C\",\n            \"TH JH QH KH AH\",\n            \"4H 4C KC 5D TC\",\n            \"QC TC 7C 6C 4C\",\n            \"QC TC 7C 7C TD\"}) {\n            System.out.println(analyzeHand(input.split(\" \")));\n        }\n\n        System.out.println(\"\\nHands with wildcards:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS WW\",\n            \"2H 5H 7D 8S WW\",\n            \"AH 2D 3S 4S WW\",\n            \"2H 3H 2D 3S WW\",\n            \"2H 7H 2D 3S WW\",\n            \"2H 7H 7D WW WW\",\n            \"TH JH QH WW WW\",\n            \"4H 4C KC WW WW\",\n            \"QC TC 7C WW WW\",\n            \"QC TC 7H WW WW\"}) {\n            System.out.println(analyzeHandWithWildcards(input.split(\" \")));\n        }\n    }\n\n    private static Score analyzeHand(final String[] hand) {\n        if (hand.length != 5)\n            return new Score(\"invalid hand: wrong number of cards\", -1, hand);\n\n        if (new HashSet<>(Arrays.asList(hand)).size() != hand.length)\n            return new Score(\"invalid hand: duplicates\", -1, hand);\n\n        int[] faceCount = new int[faces.length()];\n        long straight = 0, flush = 0;\n        for (String card : hand) {\n\n            int face = faces.indexOf(card.charAt(0));\n            if (face == -1)\n                return new Score(\"invalid hand: non existing face\", -1, hand);\n            straight |= (1 << face);\n\n            faceCount[face]++;\n\n            if (suits.indexOf(card.charAt(1)) == -1)\n                return new Score(\"invalid hand: non-existing suit\", -1, hand);\n            flush |= (1 << card.charAt(1));\n        }\n\n        \n        while (straight % 2 == 0)\n            straight >>= 1;\n\n        \n        boolean hasStraight = straight == 0b11111 || straight == 0b1111000000001;\n\n        \n        boolean hasFlush = (flush & (flush - 1)) == 0;\n\n        if (hasStraight && hasFlush)\n            return new Score(\"straight-flush\", 9, hand);\n\n        int total = 0;\n        for (int count : faceCount) {\n            if (count == 4)\n                return new Score(\"four-of-a-kind\", 8, hand);\n            if (count == 3)\n                total += 3;\n            else if (count == 2)\n                total += 2;\n        }\n\n        if (total == 5)\n            return new Score(\"full-house\", 7, hand);\n\n        if (hasFlush)\n            return new Score(\"flush\", 6, hand);\n\n        if (hasStraight)\n            return new Score(\"straight\", 5, hand);\n\n        if (total == 3)\n            return new Score(\"three-of-a-kind\", 4, hand);\n\n        if (total == 4)\n            return new Score(\"two-pair\", 3, hand);\n\n        if (total == 2)\n            return new Score(\"one-pair\", 2, hand);\n\n        return new Score(\"high-card\", 1, hand);\n    }\n\n    private static WildScore analyzeHandWithWildcards(String[] hand) {\n        if (Collections.frequency(Arrays.asList(hand), \"WW\") > 2)\n            throw new IllegalArgumentException(\"too many wildcards\");\n\n        return new WildScore(analyzeHandWithWildcardsR(hand, null), hand.clone());\n    }\n\n    private static Score analyzeHandWithWildcardsR(String[] hand,\n            Score best) {\n\n        for (int i = 0; i < hand.length; i++) {\n            if (hand[i].equals(\"WW\")) {\n                for (String card : deck) {\n                    if (!Arrays.asList(hand).contains(card)) {\n                        hand[i] = card;\n                        best = analyzeHandWithWildcardsR(hand, best);\n                    }\n                }\n                hand[i] = \"WW\";\n                break;\n            }\n        }\n        Score result = analyzeHand(hand);\n        if (best == null || result.weight > best.weight)\n            best = result;\n        return best;\n    }\n\n    private static String[] buildDeck() {\n        String[] dck = new String[suits.length() * faces.length()];\n        int i = 0;\n        for (char s : suits.toCharArray()) {\n            for (char f : faces.toCharArray()) {\n                dck[i] = \"\" + f + s;\n                i++;\n            }\n        }\n        return dck;\n    }\n\n    private static class Score {\n        final int weight;\n        final String name;\n        final String[] hand;\n\n        Score(String n, int w, String[] h) {\n            weight = w;\n            name = n;\n            hand = h != null ? h.clone() : h;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(hand) + \" \" + name;\n        }\n    }\n\n    private static class WildScore {\n        final String[] wild;\n        final Score score;\n\n        WildScore(Score s, String[] w) {\n            score = s;\n            wild = w;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s%n%s%n\", Arrays.toString(wild),\n                    score.toString());\n        }\n    }\n}\n"}
{"id": 415508, "name": "Fibonacci word_fractal", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse GD;\n\nmy @fword = ( undef, 1, 0 );\n\nsub fword {\n\tmy $n = shift;\n\treturn $fword[$n] if $n<3;\n\treturn $fword[$n] //= fword($n-1).fword($n-2);\n}\n\nmy $size = 3000;\nmy $im = GD::Image->new($size,$size);\nmy $white = $im->colorAllocate(255,255,255);\nmy $black = $im->colorAllocate(0,0,0);       \n$im->transparent($white);\n$im->interlaced('true');\n\nmy @pos   = (0,0);\nmy @dir   = (0,5);\nmy @steps = split //, fword 23;\nmy $i     = 1;\nfor( @steps ) {\n\tmy @next = ( $pos[0]+$dir[0], $pos[1]+$dir[1] );\n\t$im->line( @pos, @next, $black );\n\t@dir = (  $dir[1], -$dir[0] ) if 0==$_ && 1==$i%2; \n\t@dir = ( -$dir[1],  $dir[0] ) if 0==$_ && 0==$i%2; \n\t$i++;\n\t@pos = @next;\n}\n\nopen my $out, \">\", \"fword.png\" or die \"Cannot open output file.\\n\";\nbinmode $out;\nprint $out $im->png;\nclose $out;\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class FibonacciWordFractal extends JPanel {\n    String wordFractal;\n\n    FibonacciWordFractal(int n) {\n        setPreferredSize(new Dimension(450, 620));\n        setBackground(Color.white);\n        wordFractal = wordFractal(n);\n    }\n\n    public String wordFractal(int n) {\n        if (n < 2)\n            return n == 1 ? \"1\" : \"\";\n\n        \n        StringBuilder f1 = new StringBuilder(\"1\");\n        StringBuilder f2 = new StringBuilder(\"0\");\n\n        for (n = n - 2; n > 0; n--) {\n            String tmp = f2.toString();\n            f2.append(f1);\n\n            f1.setLength(0);\n            f1.append(tmp);\n        }\n\n        return f2.toString();\n    }\n\n    void drawWordFractal(Graphics2D g, int x, int y, int dx, int dy) {\n        for (int n = 0; n < wordFractal.length(); n++) {\n            g.drawLine(x, y, x + dx, y + dy);\n            x += dx;\n            y += dy;\n            if (wordFractal.charAt(n) == '0') {\n                int tx = dx;\n                dx = (n % 2 == 0) ? -dy : dy;\n                dy = (n % 2 == 0) ? tx : -tx;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawWordFractal(g, 20, 20, 1, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fibonacci Word Fractal\");\n            f.setResizable(false);\n            f.add(new FibonacciWordFractal(23), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415509, "name": "Penney's game", "source": "Translate Perl to Java: \nuse 5.020;\nuse strict;\nuse warnings;\n\n\nbinaryRand() == 0 ? flipCoin(userFirst()) : flipCoin(compFirst());\n\n\nsub binaryRand\n{\n    return int(rand(2));\n}\n\nsub convert\n{\n    my $randNum = binaryRand();\n    if($randNum == 0)\n    {\n        return \"T\"\n    }\n    else\n    {\n        return \"H\";\n    }\n}\n\n\nsub uSeq\n{\n    print(\"Please enter a sequence of 3 of \\\"H\\\" and \\\"T\\\". EG: HHT\\n>\");\n    my $uString = <STDIN>;\n\n    while(1)\n    {\n        \n        chomp($uString);\n        $uString = uc $uString;\n        \n        if(length $uString == 3 && (substr($uString, 0, 1) =~ /[HT]/ &&\n                                    substr($uString, 1, 1) =~ /[HT]/ &&\n                                    substr($uString, 2, 1) =~ /[HT]/))\n        {\n            last;\n        }\n        else\n        {\n            print(\"Error, try again. \\n\");\n            print(\"Please enter a sequence of 3 of \\\"H\\\" and \\\"T\\\". EG: HHT\\n\");\n            $uString = <STDIN>;\n        }\n    }\n    return $uString;\n}\n\n\nsub compFirst\n{\n    my $cSeq;\n    \n    for(my $i = 0; $i < 3; $i++)\n    {\n        $cSeq = $cSeq . convert();\n    }\n\n    print(\"The computer guesses first:\\ncomp- $cSeq\\n\");\n    my $uSeq = uSeq();\n    print(\"user- $uSeq\\n\");\n    my @seqArr = ($uSeq, $cSeq);\n    return @seqArr;\n}\n\n\nsub userFirst\n{\n    print(\"The user quesses first:\\n\");\n    my $uSeq = uSeq();\n    my $cSeq;\n    \n    my $middle = substr($uSeq, 1, 1);\n    $middle eq \"H\" ? $cSeq = \"T\" : $cSeq = \"H\";\n    $cSeq = $cSeq . substr($uSeq, 0, 2); \n\n    print(\"user- $uSeq\\ncomp- $cSeq\\n\");\n    my @seqArr = ($uSeq, $cSeq);\n    return @seqArr; \n}\n\n\nsub flipCoin\n{\n    my ($uSeq, $cSeq) = @_;\n    my $coin;\n    while(1)\n    {\n        $coin = $coin . convert();\n        if($coin =~ m/$uSeq/)\n        {\n            print(\"The sequence of tosses was: $coin\\n\");\n            say(\"The player wins! \");\n            last;\n        }\n        elsif($coin =~ m/$cSeq/)\n        {\n            print(\"The sequence of tosses was: $coin\\n\");\n            say(\"The computer wins! \");\n            last;\n        }\n    }\n}\n", "target": "import java.util.*;\n\npublic class PenneysGame {\n\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        String compChoice = \"\", playerChoice;\n        if (rand.nextBoolean()) {\n\n            for (int i = 0; i < 3; i++)\n                compChoice += \"HT\".charAt(rand.nextInt(2));\n            System.out.printf(\"Computer chooses %s%n\", compChoice);\n\n            playerChoice = prompt(compChoice);\n\n        } else {\n\n            playerChoice = prompt(compChoice);\n\n            compChoice = \"T\";\n            if (playerChoice.charAt(1) == 'T')\n                compChoice = \"H\";\n            compChoice += playerChoice.substring(0, 2);\n            System.out.printf(\"Computer chooses %s%n\", compChoice);\n        }\n\n        String tossed = \"\";\n        while (true) {\n            tossed += \"HT\".charAt(rand.nextInt(2));\n            System.out.printf(\"Tossed %s%n\" , tossed);\n            if (tossed.endsWith(playerChoice)) {\n                System.out.println(\"You win!\");\n                break;\n            }\n            if (tossed.endsWith(compChoice)) {\n                System.out.println(\"Computer wins!\");\n                break;\n            }\n        }\n    }\n\n    private static String prompt(String otherChoice) {\n        Scanner sc = new Scanner(System.in);\n        String s;\n        do {\n            System.out.print(\"Choose a sequence: \");\n            s = sc.nextLine().trim().toUpperCase();\n        } while (!s.matches(\"[HT]{3}\") || s.equals(otherChoice));\n        return s;\n    }\n}\n"}
{"id": 415510, "name": "Sierpinski triangle_Graphical", "source": "Translate Perl to Java: my $levels = 6;\nmy $side   = 512;\nmy $height = get_height($side);\n\nsub get_height { my($side) = @_; $side * sqrt(3) / 2 }\n\nsub triangle {\n    my($x1, $y1, $x2, $y2, $x3, $y3, $fill, $animate) = @_;\n    my $svg;\n    $svg .= qq{<polygon points=\"$x1,$y1 $x2,$y2 $x3,$y3\"};\n    $svg .= qq{ style=\"fill: $fill; stroke-width: 0;\"} if $fill;\n    $svg .= $animate\n        ? qq{>\\n  <animate attributeType=\"CSS\" attributeName=\"opacity\"\\n  values=\"1;0;1\" keyTimes=\"0;.5;1\" dur=\"20s\" repeatCount=\"indefinite\" />\\n</polygon>\\n}\n        : ' />';\n    return $svg;\n}\n\nsub fractal {\n    my( $x1, $y1, $x2, $y2, $x3, $y3, $r ) = @_;\n    my $svg;\n    $svg .= triangle( $x1, $y1, $x2, $y2, $x3, $y3 );\n    return $svg unless --$r;\n    my $side = abs($x3 - $x2) / 2;\n    my $height = get_height($side);\n    $svg .= fractal( $x1, $y1-$height*2, $x1-$side/2, $y1-3*$height, $x1+$side/2, $y1-3*$height, $r);\n    $svg .= fractal( $x2, $y1, $x2-$side/2, $y1-$height, $x2+$side/2, $y1-$height, $r);\n    $svg .= fractal( $x3, $y1, $x3-$side/2, $y1-$height, $x3+$side/2, $y1-$height, $r);\n}\n\nopen my $fh, '>', 'run/sierpinski_triangle.svg';\nprint $fh <<'EOD',\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<defs>\n  <radialGradient id=\"basegradient\" cx=\"50%\" cy=\"65%\" r=\"50%\" fx=\"50%\" fy=\"65%\">\n    <stop offset=\"10%\" stop-color=\"\n    <stop offset=\"60%\" stop-color=\"\n    <stop offset=\"99%\" stop-color=\"\n  </radialGradient>\n</defs>\nEOD\n\ntriangle( $side/2, 0, 0, $height, $side, $height, 'url(\ntriangle( $side/2, 0, 0, $height, $side, $height, '\n'<g style=\"fill: \nfractal( $side/2, $height, $side*3/4, $height/2, $side/4, $height/2, $levels ),\n'</g></svg>';\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}\n"}
{"id": 415511, "name": "Sierpinski triangle_Graphical", "source": "Translate Perl to Java: my $levels = 6;\nmy $side   = 512;\nmy $height = get_height($side);\n\nsub get_height { my($side) = @_; $side * sqrt(3) / 2 }\n\nsub triangle {\n    my($x1, $y1, $x2, $y2, $x3, $y3, $fill, $animate) = @_;\n    my $svg;\n    $svg .= qq{<polygon points=\"$x1,$y1 $x2,$y2 $x3,$y3\"};\n    $svg .= qq{ style=\"fill: $fill; stroke-width: 0;\"} if $fill;\n    $svg .= $animate\n        ? qq{>\\n  <animate attributeType=\"CSS\" attributeName=\"opacity\"\\n  values=\"1;0;1\" keyTimes=\"0;.5;1\" dur=\"20s\" repeatCount=\"indefinite\" />\\n</polygon>\\n}\n        : ' />';\n    return $svg;\n}\n\nsub fractal {\n    my( $x1, $y1, $x2, $y2, $x3, $y3, $r ) = @_;\n    my $svg;\n    $svg .= triangle( $x1, $y1, $x2, $y2, $x3, $y3 );\n    return $svg unless --$r;\n    my $side = abs($x3 - $x2) / 2;\n    my $height = get_height($side);\n    $svg .= fractal( $x1, $y1-$height*2, $x1-$side/2, $y1-3*$height, $x1+$side/2, $y1-3*$height, $r);\n    $svg .= fractal( $x2, $y1, $x2-$side/2, $y1-$height, $x2+$side/2, $y1-$height, $r);\n    $svg .= fractal( $x3, $y1, $x3-$side/2, $y1-$height, $x3+$side/2, $y1-$height, $r);\n}\n\nopen my $fh, '>', 'run/sierpinski_triangle.svg';\nprint $fh <<'EOD',\n<?xml version=\"1.0\" standalone=\"no\"?>\n<!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\">\n<svg width=\"100%\" height=\"100%\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\n<defs>\n  <radialGradient id=\"basegradient\" cx=\"50%\" cy=\"65%\" r=\"50%\" fx=\"50%\" fy=\"65%\">\n    <stop offset=\"10%\" stop-color=\"\n    <stop offset=\"60%\" stop-color=\"\n    <stop offset=\"99%\" stop-color=\"\n  </radialGradient>\n</defs>\nEOD\n\ntriangle( $side/2, 0, 0, $height, $side, $height, 'url(\ntriangle( $side/2, 0, 0, $height, $side, $height, '\n'<g style=\"fill: \nfractal( $side/2, $height, $side*3/4, $height/2, $side/4, $height/2, $levels ),\n'</g></svg>';\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}\n"}
{"id": 415512, "name": "Nonoblock", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"\\n$_\", tr/\\n/=/cr;\n  my ($cells, @blocks) = split;\n  my $letter = 'A';\n  $_ = join '.', map { $letter++ x $_ } @blocks;\n  $cells < length and print(\"no solution\\n\"), next;\n  $_ .= '.' x ($cells - length) . \"\\n\";\n  1 while print, s/^(\\.*)\\b(.*?)\\b(\\w+)\\.\\B/$2$1.$3/;\n  }\n\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 415513, "name": "Nonoblock", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"\\n$_\", tr/\\n/=/cr;\n  my ($cells, @blocks) = split;\n  my $letter = 'A';\n  $_ = join '.', map { $letter++ x $_ } @blocks;\n  $cells < length and print(\"no solution\\n\"), next;\n  $_ .= '.' x ($cells - length) . \"\\n\";\n  1 while print, s/^(\\.*)\\b(.*?)\\b(\\w+)\\.\\B/$2$1.$3/;\n  }\n\n", "target": "import java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toList;\n\npublic class Nonoblock {\n\n    public static void main(String[] args) {\n        printBlock(\"21\", 5);\n        printBlock(\"\", 5);\n        printBlock(\"8\", 10);\n        printBlock(\"2323\", 15);\n        printBlock(\"23\", 5);\n    }\n\n    static void printBlock(String data, int len) {\n        int sumChars = data.chars().map(c -> Character.digit(c, 10)).sum();\n        String[] a = data.split(\"\");\n\n        System.out.printf(\"%nblocks %s, cells %s%n\", Arrays.toString(a), len);\n        if (len - sumChars <= 0) {\n            System.out.println(\"No solution\");\n            return;\n        }\n\n        List<String> prep = stream(a).filter(x -> !\"\".equals(x))\n                .map(x -> repeat(Character.digit(x.charAt(0), 10), \"1\"))\n                .collect(toList());\n\n        for (String r : genSequence(prep, len - sumChars + 1))\n            System.out.println(r.substring(1));\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return Arrays.asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n}\n"}
{"id": 415514, "name": "Eban numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Lingua::EN::Numbers qw(num2en);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub e_ban {\n    my($power) = @_;\n    my @n;\n    for (1..10**$power) {\n        next unless 0 == $_%2;\n        next if $_ =~ /[789]/ or /[12].$/ or /[135]..$/ or /[135]...$/ or /[135].....$/;\n        push @n, $_ unless num2en($_) =~ /e/;\n    }\n    @n;\n}\n\nmy @OK = e_ban(my $max = 7);\n\nmy @a = grep { $_ <= 1000 } @OK;\nsay \"Number of eban numbers up to and including 1000: @{[1+$\nsay join(', ',@a);\nsay '';\n\nmy @b = grep { $_ >= 1000 && $_ <= 4000 } @OK;\nsay \"Number of eban numbers between 1000 and 4000 (inclusive): @{[1+$\nsay join(', ',@b);\nsay '';\n\nfor my $exp (4..$max) {\n    my $n = + grep { $_ <= 10**$exp } @OK;\n    printf \"Number of eban numbers and %10s: %d\\n\", comma(10**$exp), $n;\n}\n", "target": "import java.util.List;\n\npublic class Main {\n    private static class Range {\n        int start;\n        int end;\n        boolean print;\n\n        public Range(int s, int e, boolean p) {\n            start = s;\n            end = e;\n            print = p;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Range> rgs = List.of(\n            new Range(2, 1000, true),\n            new Range(1000, 4000, true),\n            new Range(2, 10_000, false),\n            new Range(2, 100_000, false),\n            new Range(2, 1_000_000, false),\n            new Range(2, 10_000_000, false),\n            new Range(2, 100_000_000, false),\n            new Range(2, 1_000_000_000, false)\n        );\n        for (Range rg : rgs) {\n            if (rg.start == 2) {\n                System.out.printf(\"eban numbers up to and including %d\\n\", rg.end);\n            } else {\n                System.out.printf(\"eban numbers between %d and %d\\n\", rg.start, rg.end);\n            }\n            int count = 0;\n            for (int i = rg.start; i <= rg.end; ++i) {\n                int b = i / 1_000_000_000;\n                int r = i % 1_000_000_000;\n                int m = r / 1_000_000;\n                r = i % 1_000_000;\n                int t = r / 1_000;\n                r %= 1_000;\n                if (m >= 30 && m <= 66) m %= 10;\n                if (t >= 30 && t <= 66) t %= 10;\n                if (r >= 30 && r <= 66) r %= 10;\n                if (b == 0 || b == 2 || b == 4 || b == 6) {\n                    if (m == 0 || m == 2 || m == 4 || m == 6) {\n                        if (t == 0 || t == 2 || t == 4 || t == 6) {\n                            if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                if (rg.print) System.out.printf(\"%d \", i);\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n            if (rg.print) {\n                System.out.println();\n            }\n            System.out.printf(\"count = %d\\n\\n\", count);\n        }\n    }\n}\n"}
{"id": 415515, "name": "Eban numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Lingua::EN::Numbers qw(num2en);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub e_ban {\n    my($power) = @_;\n    my @n;\n    for (1..10**$power) {\n        next unless 0 == $_%2;\n        next if $_ =~ /[789]/ or /[12].$/ or /[135]..$/ or /[135]...$/ or /[135].....$/;\n        push @n, $_ unless num2en($_) =~ /e/;\n    }\n    @n;\n}\n\nmy @OK = e_ban(my $max = 7);\n\nmy @a = grep { $_ <= 1000 } @OK;\nsay \"Number of eban numbers up to and including 1000: @{[1+$\nsay join(', ',@a);\nsay '';\n\nmy @b = grep { $_ >= 1000 && $_ <= 4000 } @OK;\nsay \"Number of eban numbers between 1000 and 4000 (inclusive): @{[1+$\nsay join(', ',@b);\nsay '';\n\nfor my $exp (4..$max) {\n    my $n = + grep { $_ <= 10**$exp } @OK;\n    printf \"Number of eban numbers and %10s: %d\\n\", comma(10**$exp), $n;\n}\n", "target": "import java.util.List;\n\npublic class Main {\n    private static class Range {\n        int start;\n        int end;\n        boolean print;\n\n        public Range(int s, int e, boolean p) {\n            start = s;\n            end = e;\n            print = p;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Range> rgs = List.of(\n            new Range(2, 1000, true),\n            new Range(1000, 4000, true),\n            new Range(2, 10_000, false),\n            new Range(2, 100_000, false),\n            new Range(2, 1_000_000, false),\n            new Range(2, 10_000_000, false),\n            new Range(2, 100_000_000, false),\n            new Range(2, 1_000_000_000, false)\n        );\n        for (Range rg : rgs) {\n            if (rg.start == 2) {\n                System.out.printf(\"eban numbers up to and including %d\\n\", rg.end);\n            } else {\n                System.out.printf(\"eban numbers between %d and %d\\n\", rg.start, rg.end);\n            }\n            int count = 0;\n            for (int i = rg.start; i <= rg.end; ++i) {\n                int b = i / 1_000_000_000;\n                int r = i % 1_000_000_000;\n                int m = r / 1_000_000;\n                r = i % 1_000_000;\n                int t = r / 1_000;\n                r %= 1_000;\n                if (m >= 30 && m <= 66) m %= 10;\n                if (t >= 30 && t <= 66) t %= 10;\n                if (r >= 30 && r <= 66) r %= 10;\n                if (b == 0 || b == 2 || b == 4 || b == 6) {\n                    if (m == 0 || m == 2 || m == 4 || m == 6) {\n                        if (t == 0 || t == 2 || t == 4 || t == 6) {\n                            if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                if (rg.print) System.out.printf(\"%d \", i);\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n            if (rg.print) {\n                System.out.println();\n            }\n            System.out.printf(\"count = %d\\n\\n\", count);\n        }\n    }\n}\n"}
{"id": 415516, "name": "Mayan numerals", "source": "Translate Perl to Java: use ntheory qw/fromdigits todigitstring/;\n\nmy $t_style = '\"border-collapse: separate; text-align: center; border-spacing: 3px 0px;\"';\nmy $c_style = '\"border: solid black 2px;background-color: \n  'border-radius: 1em;-moz-border-radius: 1em;-webkit-border-radius: 1em;'.\n  'vertical-align: bottom;width: 3.25em;\"';\n\nsub cartouches {\n    my($num, @digits) = @_;\n    my $render;\n    for my $d (@digits) {\n        $render .= \"| style=$c_style | $_\\n\" for glyphs(@$d);\n    }\n    chomp $render;\n    join \"\\n\", \"\\{| style=$t_style\", \"|+ $num\", '|-', $render, '|}'\n}\n\nsub glyphs {\n    return '\u0398' unless $_[0] || $_[1];\n    join '<br>', '\u25cf' x $_[0], ('\u2500\u2500\u2500') x $_[1];\n}\n\nsub mmod {\n    my($n,$b) = @_;\n    my @nb;\n    return 0 unless $n;\n    push @nb, fromdigits($_, $b) for split '', todigitstring($n, $b);\n    return @nb;\n}\n\nfor $n (qw<4005 8017 326205 886205 26960840421>) {\n    push @output, cartouches($n, map { [reverse mmod($_,5)] } mmod($n,20) );\n}\n\nprint join \"\\n<br>\\n\", @output;\n", "target": "import java.math.BigInteger;\n\npublic class MayanNumerals {\n\n    public static void main(String[] args) {\n        for ( long base10 : new long[] {4005, 8017, 326205, 886205, 1000000000, 1081439556L, 26960840421L, 503491211079L }) {\n            displayMyan(BigInteger.valueOf(base10));\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    private static char[] digits = \"0123456789ABCDEFGHJK\".toCharArray();\n    private static BigInteger TWENTY = BigInteger.valueOf(20);\n    \n    private static void displayMyan(BigInteger numBase10) {\n        System.out.printf(\"As base 10:  %s%n\", numBase10);\n        String numBase20 = \"\";\n        while ( numBase10.compareTo(BigInteger.ZERO) > 0 ) {\n            numBase20 = digits[numBase10.mod(TWENTY).intValue()] + numBase20;\n            numBase10 = numBase10.divide(TWENTY);\n        }\n        System.out.printf(\"As base 20:  %s%nAs Mayan:%n\", numBase20);\n        displayMyanLine1(numBase20);\n        displayMyanLine2(numBase20);\n        displayMyanLine3(numBase20);\n        displayMyanLine4(numBase20);\n        displayMyanLine5(numBase20);\n        displayMyanLine6(numBase20);\n    }\n \n    private static char boxUL = Character.toChars(9556)[0];\n    private static char boxTeeUp = Character.toChars(9574)[0];\n    private static char boxUR = Character.toChars(9559)[0];\n    private static char boxHorz = Character.toChars(9552)[0];\n    private static char boxVert = Character.toChars(9553)[0];\n    private static char theta = Character.toChars(952)[0];\n    private static char boxLL = Character.toChars(9562)[0];\n    private static char boxLR = Character.toChars(9565)[0];\n    private static char boxTeeLow = Character.toChars(9577)[0];\n    private static char bullet = Character.toChars(8729)[0];\n    private static char dash = Character.toChars(9472)[0];\n    \n    private static void displayMyanLine1(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxUL);\n            }\n            for ( int j = 0 ; j < 4 ; j++ ) {\n                sb.append(boxHorz);\n            }\n            sb.append(i < chars.length-1 ? boxTeeUp : boxUR);\n        }\n        System.out.println(sb.toString());\n    }\n    \n    private static String getBullet(int count) {\n        StringBuilder sb = new StringBuilder();\n        switch ( count ) {\n        case 1:  sb.append(\" \" + bullet + \"  \"); break;\n        case 2:  sb.append(\" \" + bullet + bullet + \" \"); break;\n        case 3:  sb.append(\"\" + bullet + bullet + bullet + \" \"); break;\n        case 4:  sb.append(\"\" + bullet + bullet + bullet + bullet); break;\n        default:  throw new IllegalArgumentException(\"Must be 1-4:  \" + count);\n        }\n        return sb.toString();\n    }\n\n    private static void displayMyanLine2(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case 'G':  sb.append(getBullet(1)); break;\n            case 'H':  sb.append(getBullet(2)); break;\n            case 'J':  sb.append(getBullet(3)); break;\n            case 'K':  sb.append(getBullet(4)); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n    \n    private static String DASH = getDash();\n    \n    private static String getDash() {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < 4 ; i++ ) {\n            sb.append(dash);\n        }\n        return sb.toString();\n    }\n\n    private static void displayMyanLine3(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case 'B':  sb.append(getBullet(1)); break;\n            case 'C':  sb.append(getBullet(2)); break;\n            case 'D':  sb.append(getBullet(3)); break;\n            case 'E':  sb.append(getBullet(4)); break;\n            case 'F': case 'G': case 'H': case 'J': case 'K':\n                sb.append(DASH); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n\n    private static void displayMyanLine4(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case '6':  sb.append(getBullet(1)); break;\n            case '7':  sb.append(getBullet(2)); break;\n            case '8':  sb.append(getBullet(3)); break;\n            case '9':  sb.append(getBullet(4)); break;\n            case 'A': case 'B': case 'C': case 'D': case 'E':\n            case 'F': case 'G': case 'H': case 'J': case 'K':\n                sb.append(DASH); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n\n    private static void displayMyanLine5(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case '0':  sb.append(\" \" + theta + \"  \"); break;\n            case '1':  sb.append(getBullet(1)); break;\n            case '2':  sb.append(getBullet(2)); break;\n            case '3':  sb.append(getBullet(3)); break;\n            case '4':  sb.append(getBullet(4)); break;\n            case '5': case '6': case '7': case '8': case '9': \n            case 'A': case 'B': case 'C': case 'D': case 'E':\n            case 'F': case 'G': case 'H': case 'J': case 'K':\n                sb.append(DASH); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n\n    private static void displayMyanLine6(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxLL);\n            }\n            for ( int j = 0 ; j < 4 ; j++ ) {\n                sb.append(boxHorz);\n            }\n            sb.append(i < chars.length-1 ? boxTeeLow : boxLR);\n        }\n        System.out.println(sb.toString());\n    }\n\n}\n"}
{"id": 415517, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Perl to Java: use bigint;\n\nfor $sailors (1..15) { check( $sailors, coconuts( 0+$sailors ) ) }\n\nsub is_valid {\n    my($sailors, $nuts) = @_;\n    return 0, 0 if $sailors == 1 and $nuts == 1;\n    my @shares;\n    for (1..$sailors) {\n        return () unless ($nuts % $sailors) == 1;\n        push @shares, int ($nuts-1)/$sailors;\n        $nuts -= (1 + int $nuts/$sailors);\n    }\n    push @shares, int $nuts/$sailors;\n    return @shares if !($nuts % $sailors);\n}\n\nsub check {\n    my($sailors, $coconuts) = @_;\n    my @suffix = ('th', 'st', 'nd', 'rd', ('th') x 6, ('th') x 10);\n    my @piles = is_valid($sailors, $coconuts);\n    if (@piles) {\n        print \"\\nSailors $sailors: Coconuts $coconuts:\\n\";\n        for my $k (0..-1 + $\n             print $k+1 . $suffix[$k+1] . \" takes \" . $piles[$k] . \", gives 1 to the monkey.\\n\"\n        }\n        print \"The next morning, each sailor takes \" . $piles[-1] . \"\\nwith none left over for the monkey.\\n\";\n        return 1\n    }\n    return 0\n}\n\nsub coconuts {\n    my($sailors) = @_;\n    if ($sailors % 2 == 0 ) { ($sailors ** $sailors - 1) * ($sailors - 1) }\n    else                    {  $sailors ** $sailors      -  $sailors + 1  }\n}\n", "target": "public class Test {\n\n    static boolean valid(int n, int nuts) {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n            if (nuts % n != 1)\n                return false;\n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    public static void main(String[] args) {\n        int x = 0;\n        for (int n = 2; n < 10; n++) {\n            while (!valid(n, x))\n                x++;\n            System.out.printf(\"%d: %d%n\", n, x);\n        }\n    }\n}\n"}
{"id": 415518, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Perl to Java: use bigint;\n\nfor $sailors (1..15) { check( $sailors, coconuts( 0+$sailors ) ) }\n\nsub is_valid {\n    my($sailors, $nuts) = @_;\n    return 0, 0 if $sailors == 1 and $nuts == 1;\n    my @shares;\n    for (1..$sailors) {\n        return () unless ($nuts % $sailors) == 1;\n        push @shares, int ($nuts-1)/$sailors;\n        $nuts -= (1 + int $nuts/$sailors);\n    }\n    push @shares, int $nuts/$sailors;\n    return @shares if !($nuts % $sailors);\n}\n\nsub check {\n    my($sailors, $coconuts) = @_;\n    my @suffix = ('th', 'st', 'nd', 'rd', ('th') x 6, ('th') x 10);\n    my @piles = is_valid($sailors, $coconuts);\n    if (@piles) {\n        print \"\\nSailors $sailors: Coconuts $coconuts:\\n\";\n        for my $k (0..-1 + $\n             print $k+1 . $suffix[$k+1] . \" takes \" . $piles[$k] . \", gives 1 to the monkey.\\n\"\n        }\n        print \"The next morning, each sailor takes \" . $piles[-1] . \"\\nwith none left over for the monkey.\\n\";\n        return 1\n    }\n    return 0\n}\n\nsub coconuts {\n    my($sailors) = @_;\n    if ($sailors % 2 == 0 ) { ($sailors ** $sailors - 1) * ($sailors - 1) }\n    else                    {  $sailors ** $sailors      -  $sailors + 1  }\n}\n", "target": "public class Test {\n\n    static boolean valid(int n, int nuts) {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n            if (nuts % n != 1)\n                return false;\n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    public static void main(String[] args) {\n        int x = 0;\n        for (int n = 2; n < 10; n++) {\n            while (!valid(n, x))\n                x++;\n            System.out.printf(\"%d: %d%n\", n, x);\n        }\n    }\n}\n"}
{"id": 415519, "name": "Nautical bell", "source": "Translate Perl to Java: use utf8;\nbinmode STDOUT, \":utf8\";\nuse DateTime;\n\n$| = 1; \n\nmy @watch = <Middle Morning Forenoon Afternoon Dog First>;\nmy @ordinal = <One Two Three Four Five Six Seven Eight>;\n\nmy $thishour;\nmy $thisminute = '';\n\nwhile () {\n    my $utc = DateTime->now( time_zone => 'UTC' );\n    if ($utc->minute =~ /^(00|30)$/ and $utc->minute != $thisminute) {\n        $thishour   = $utc->hour;\n        $thisminute = $utc->minute;\n        bell($thishour, $thisminute);\n    }\n    printf \"%s%02d:%02d:%02d\", \"\\r\", $utc->hour, $utc->minute, $utc->second;\n    sleep(1);\n}\n\nsub bell {\n    my($hour, $minute) = @_;\n\n    my $bells = (($hour % 4) * 2 + int $minute/30) || 8;\n    printf \"%s%02d:%02d%9s watch,%6s Bell%s Gone: \\t\", \"\\b\" x 9, $hour, $minute,\n       $watch[(int($hour/4) - (0==($minute + $hour % 4)) + 6) % 6],\n       $ordinal[$bells - 1], $bells == 1 ? '' : 's';\n    chime($bells);\n}\n\nsub chime {\n    my($count) = shift;\n    for (1..int($count/2)) {\n        print \"\\a\u266b \"; sleep .25;\n        print \"\\a\";   sleep .75;\n    }\n    if ($count % 2) {\n        print \"\\a\u266a\";  sleep 1;\n    }\n    print \"\\n\";\n}\n", "target": "import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.TimeZone;\n\npublic class NauticalBell extends Thread {\n\n    public static void main(String[] args) {\n        NauticalBell bells = new NauticalBell();\n        bells.setDaemon(true);\n        bells.start();\n        try {\n            bells.join();\n        } catch (InterruptedException e) {\n            System.out.println(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        DateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        int numBells = 0;\n        long time = System.currentTimeMillis();\n        long next = time - (time % (24 * 60 * 60 * 1000)); \n\n        while (next < time) {\n            next += 30 * 60 * 1000; \n            numBells = 1 + (numBells % 8);\n        }\n\n        while (true) {\n            long wait = 100L;\n            time = System.currentTimeMillis();\n            if (time - next >= 0) {\n                String bells = numBells == 1 ? \"bell\" : \"bells\";\n                String timeString = sdf.format(time);\n                System.out.printf(\"%s\u00a0: %d %s\\n\", timeString, numBells, bells);\n                next += 30 * 60 * 1000;\n                wait = next - time;\n                numBells = 1 + (numBells % 8);\n            }\n            try {\n                Thread.sleep(wait);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n}\n"}
{"id": 415520, "name": "Nautical bell", "source": "Translate Perl to Java: use utf8;\nbinmode STDOUT, \":utf8\";\nuse DateTime;\n\n$| = 1; \n\nmy @watch = <Middle Morning Forenoon Afternoon Dog First>;\nmy @ordinal = <One Two Three Four Five Six Seven Eight>;\n\nmy $thishour;\nmy $thisminute = '';\n\nwhile () {\n    my $utc = DateTime->now( time_zone => 'UTC' );\n    if ($utc->minute =~ /^(00|30)$/ and $utc->minute != $thisminute) {\n        $thishour   = $utc->hour;\n        $thisminute = $utc->minute;\n        bell($thishour, $thisminute);\n    }\n    printf \"%s%02d:%02d:%02d\", \"\\r\", $utc->hour, $utc->minute, $utc->second;\n    sleep(1);\n}\n\nsub bell {\n    my($hour, $minute) = @_;\n\n    my $bells = (($hour % 4) * 2 + int $minute/30) || 8;\n    printf \"%s%02d:%02d%9s watch,%6s Bell%s Gone: \\t\", \"\\b\" x 9, $hour, $minute,\n       $watch[(int($hour/4) - (0==($minute + $hour % 4)) + 6) % 6],\n       $ordinal[$bells - 1], $bells == 1 ? '' : 's';\n    chime($bells);\n}\n\nsub chime {\n    my($count) = shift;\n    for (1..int($count/2)) {\n        print \"\\a\u266b \"; sleep .25;\n        print \"\\a\";   sleep .75;\n    }\n    if ($count % 2) {\n        print \"\\a\u266a\";  sleep 1;\n    }\n    print \"\\n\";\n}\n", "target": "import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.TimeZone;\n\npublic class NauticalBell extends Thread {\n\n    public static void main(String[] args) {\n        NauticalBell bells = new NauticalBell();\n        bells.setDaemon(true);\n        bells.start();\n        try {\n            bells.join();\n        } catch (InterruptedException e) {\n            System.out.println(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        DateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        int numBells = 0;\n        long time = System.currentTimeMillis();\n        long next = time - (time % (24 * 60 * 60 * 1000)); \n\n        while (next < time) {\n            next += 30 * 60 * 1000; \n            numBells = 1 + (numBells % 8);\n        }\n\n        while (true) {\n            long wait = 100L;\n            time = System.currentTimeMillis();\n            if (time - next >= 0) {\n                String bells = numBells == 1 ? \"bell\" : \"bells\";\n                String timeString = sdf.format(time);\n                System.out.printf(\"%s\u00a0: %d %s\\n\", timeString, numBells, bells);\n                next += 30 * 60 * 1000;\n                wait = next - time;\n                numBells = 1 + (numBells % 8);\n            }\n            try {\n                Thread.sleep(wait);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n}\n"}
{"id": 415521, "name": "Musical scale", "source": "Translate Perl to Java: use MIDI::Simple;\n\n\nset_tempo 500_000;\n\n\nn 60; n 62; n 64; n 65; n 67; n 69; n 71; n 72;\n\nwrite_score 'scale.mid';\n", "target": "\n\nimport processing.sound.*;\n\nfloat[] frequencies = {261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25};\n\nSinOsc sine;\n\nsize(500,500);\n\nsine = new SinOsc(this);\n\nfor(int i=0;i<frequencies.length;i++){\n   sine.freq(frequencies[i]);\n   sine.play();\n\n   delay(500);\n}\n"}
{"id": 415522, "name": "Musical scale", "source": "Translate Perl to Java: use MIDI::Simple;\n\n\nset_tempo 500_000;\n\n\nn 60; n 62; n 64; n 65; n 67; n 69; n 71; n 72;\n\nwrite_score 'scale.mid';\n", "target": "\n\nimport processing.sound.*;\n\nfloat[] frequencies = {261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25};\n\nSinOsc sine;\n\nsize(500,500);\n\nsine = new SinOsc(this);\n\nfor(int i=0;i<frequencies.length;i++){\n   sine.freq(frequencies[i]);\n   sine.play();\n\n   delay(500);\n}\n"}
{"id": 415523, "name": "Polyspiral", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse Tk;\nuse List::Util qw( min );\n\nmy $size = 500;\nmy ($width, $height, $x, $y, $dist);\nmy $angleinc = 0;\nmy $active = 0;\nmy $wait = 1000 / 30;\nmy $radian = 90 / atan2 1, 0;\n\nmy $mw = MainWindow->new;\n$mw->title( 'Polyspiral' );\nmy $c = $mw->Canvas( -width => $size, -height => $size,\n  -relief => 'raised', -borderwidth => 2,\n  )->pack(-fill => 'both', -expand => 1);\n$mw->bind('<Configure>' => sub { $width = $c->width; $height = $c->height;\n  $dist = min($width, $height) ** 2 / 4 } );\n$mw->Button(-text => $_->[0], -command => $_->[1],\n  )->pack(-side => 'right') for\n  [ Exit => sub {$mw->destroy} ],\n  [ 'Start / Pause' => sub { $active ^= 1; step() } ];\n\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub step\n  {\n  $active or return;\n  my @pts = ($x = $width >> 1, $y = $height >> 1);\n  my $length = 5;\n  my $angle = $angleinc;\n  $angleinc += 0.05 / $radian;\n  while( ($x - $width / 2)**2 + ($y - $height / 2)**2 < $dist && @pts < 300 )\n    {\n    push @pts, $x, $y;\n    $x += $length * cos($angle);\n    $y += $length * sin($angle);\n    $length += 3;\n    $angle += $angleinc;\n    }\n  $c->delete('all');\n  $c->createLine( @pts );\n  $mw->after($wait => \\&step);\n  }\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport javax.swing.*;\n\npublic class PolySpiral extends JPanel {\n    double inc = 0;\n\n    public PolySpiral() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        new Timer(40, (ActionEvent e) -> {\n            inc = (inc + 0.05) % 360;\n            repaint();\n        }).start();\n    }\n\n    void drawSpiral(Graphics2D g, int len, double angleIncrement) {\n\n        double x1 = getWidth() / 2;\n        double y1 = getHeight() / 2;\n        double angle = angleIncrement;\n\n        for (int i = 0; i < 150; i++) {\n\n            g.setColor(Color.getHSBColor(i / 150f, 1.0f, 1.0f));\n\n            double x2 = x1 + Math.cos(angle) * len;\n            double y2 = y1 - Math.sin(angle) * len;\n            g.drawLine((int) x1, (int) y1, (int) x2, (int) y2);\n            x1 = x2;\n            y1 = y2;\n\n            len += 3;\n\n            angle = (angle + angleIncrement) % (Math.PI * 2);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawSpiral(g, 5, Math.toRadians(inc));\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"PolySpiral\");\n            f.setResizable(true);\n            f.add(new PolySpiral(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415524, "name": "Polyspiral", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse Tk;\nuse List::Util qw( min );\n\nmy $size = 500;\nmy ($width, $height, $x, $y, $dist);\nmy $angleinc = 0;\nmy $active = 0;\nmy $wait = 1000 / 30;\nmy $radian = 90 / atan2 1, 0;\n\nmy $mw = MainWindow->new;\n$mw->title( 'Polyspiral' );\nmy $c = $mw->Canvas( -width => $size, -height => $size,\n  -relief => 'raised', -borderwidth => 2,\n  )->pack(-fill => 'both', -expand => 1);\n$mw->bind('<Configure>' => sub { $width = $c->width; $height = $c->height;\n  $dist = min($width, $height) ** 2 / 4 } );\n$mw->Button(-text => $_->[0], -command => $_->[1],\n  )->pack(-side => 'right') for\n  [ Exit => sub {$mw->destroy} ],\n  [ 'Start / Pause' => sub { $active ^= 1; step() } ];\n\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub step\n  {\n  $active or return;\n  my @pts = ($x = $width >> 1, $y = $height >> 1);\n  my $length = 5;\n  my $angle = $angleinc;\n  $angleinc += 0.05 / $radian;\n  while( ($x - $width / 2)**2 + ($y - $height / 2)**2 < $dist && @pts < 300 )\n    {\n    push @pts, $x, $y;\n    $x += $length * cos($angle);\n    $y += $length * sin($angle);\n    $length += 3;\n    $angle += $angleinc;\n    }\n  $c->delete('all');\n  $c->createLine( @pts );\n  $mw->after($wait => \\&step);\n  }\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport javax.swing.*;\n\npublic class PolySpiral extends JPanel {\n    double inc = 0;\n\n    public PolySpiral() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        new Timer(40, (ActionEvent e) -> {\n            inc = (inc + 0.05) % 360;\n            repaint();\n        }).start();\n    }\n\n    void drawSpiral(Graphics2D g, int len, double angleIncrement) {\n\n        double x1 = getWidth() / 2;\n        double y1 = getHeight() / 2;\n        double angle = angleIncrement;\n\n        for (int i = 0; i < 150; i++) {\n\n            g.setColor(Color.getHSBColor(i / 150f, 1.0f, 1.0f));\n\n            double x2 = x1 + Math.cos(angle) * len;\n            double y2 = y1 - Math.sin(angle) * len;\n            g.drawLine((int) x1, (int) y1, (int) x2, (int) y2);\n            x1 = x2;\n            y1 = y2;\n\n            len += 3;\n\n            angle = (angle + angleIncrement) % (Math.PI * 2);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawSpiral(g, 5, Math.toRadians(inc));\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"PolySpiral\");\n            f.setResizable(true);\n            f.add(new PolySpiral(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415525, "name": "Voronoi diagram", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Imager;\n\nmy %type = (\n     Taxicab   => sub { my($px, $py, $x, $y) = @_; abs($px - $x)    + abs($py - $y)    },\n     Euclidean => sub { my($px, $py, $x, $y) = @_;    ($px - $x)**2 +    ($py - $y)**2 },\n     Minkowski => sub { my($px, $py, $x, $y) = @_; abs($px - $x)**3 + abs($py - $y)**3 },\n);\n\nmy($xmax, $ymax) = (400, 400);\nmy @domains;\nfor (1..30) {\n    push @domains, {\n        x   => int 5 + rand $xmax-10,\n        y   => int 5 + rand $ymax-10,\n        rgb => [int rand 255, int rand 255, int rand 255]\n    }\n}\n\nfor my $type (keys %type) {\n    our $img = Imager->new(xsize => $xmax, ysize => $ymax, channels => 3);\n    voronoi($type, $xmax, $ymax, @domains);\n    dot(1,@domains);\n    $img->write(file => \"voronoi-$type.png\");\n\n    sub voronoi {\n        my($type, $xmax, $ymax, @d) = @_;\n        for my $x (0..$xmax) {\n            for my $y (0..$ymax) {\n                my $i = 0;\n                my $d = 10e6;\n                for (0..$\n                    my $dd = &{$type{$type}}($d[$_]{'x'}, $d[$_]{'y'}, $x, $y);\n                    if ($dd < $d) { $d = $dd; $i = $_ }\n                }\n                $img->setpixel(x => $x, y => $y, color => $d[$i]{rgb} );\n            }\n        }\n    }\n\n    sub dot {\n        my($radius, @d) = @_;\n        for (0..$\n            my $dx = $d[$_]{'x'};\n            my $dy = $d[$_]{'y'};\n            for my $x ($dx-$radius .. $dx+$radius) {\n                for my $y ($dy-$radius .. $dy+$radius) {\n                    $img->setpixel(x => $x, y => $y, color => [0,0,0]);\n                }\n            }\n        }\n    }\n}\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Voronoi extends JFrame {\n\tstatic double p = 3;\n\tstatic BufferedImage I;\n\tstatic int px[], py[], color[], cells = 100, size = 1000;\n\n\tpublic Voronoi() {\n\t\tsuper(\"Voronoi Diagram\");\n\t\tsetBounds(0, 0, size, size);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tint n = 0;\n\t\tRandom rand = new Random();\n\t\tI = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n\t\tpx = new int[cells];\n\t\tpy = new int[cells];\n\t\tcolor = new int[cells];\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tpx[i] = rand.nextInt(size);\n\t\t\tpy[i] = rand.nextInt(size);\n\t\t\tcolor[i] = rand.nextInt(16777215);\n\n\t\t}\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tfor (int y = 0; y < size; y++) {\n\t\t\t\tn = 0;\n\t\t\t\tfor (byte i = 0; i < cells; i++) {\n\t\t\t\t\tif (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {\n\t\t\t\t\t\tn = i;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tI.setRGB(x, y, color[n]);\n\n\t\t\t}\n\t\t}\n\n\t\tGraphics2D g = I.createGraphics();\n\t\tg.setColor(Color.BLACK);\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tg.fill(new Ellipse2D .Double(px[i] - 2.5, py[i] - 2.5, 5, 5));\n\t\t}\n\n\t\ttry {\n\t\t\tImageIO.write(I, \"png\", new File(\"voronoi.png\"));\n\t\t} catch (IOException e) {\n\n\t\t}\n\n\t}\n\n\tpublic void paint(Graphics g) {\n\t\tg.drawImage(I, 0, 0, this);\n\t}\n\n\tstatic double distance(int x1, int x2, int y1, int y2) {\n\t\tdouble d;\n\t    d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); \n\t\n\t\n\t  \treturn d;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Voronoi().setVisible(true);\n\t}\n}\n"}
{"id": 415526, "name": "Voronoi diagram", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Imager;\n\nmy %type = (\n     Taxicab   => sub { my($px, $py, $x, $y) = @_; abs($px - $x)    + abs($py - $y)    },\n     Euclidean => sub { my($px, $py, $x, $y) = @_;    ($px - $x)**2 +    ($py - $y)**2 },\n     Minkowski => sub { my($px, $py, $x, $y) = @_; abs($px - $x)**3 + abs($py - $y)**3 },\n);\n\nmy($xmax, $ymax) = (400, 400);\nmy @domains;\nfor (1..30) {\n    push @domains, {\n        x   => int 5 + rand $xmax-10,\n        y   => int 5 + rand $ymax-10,\n        rgb => [int rand 255, int rand 255, int rand 255]\n    }\n}\n\nfor my $type (keys %type) {\n    our $img = Imager->new(xsize => $xmax, ysize => $ymax, channels => 3);\n    voronoi($type, $xmax, $ymax, @domains);\n    dot(1,@domains);\n    $img->write(file => \"voronoi-$type.png\");\n\n    sub voronoi {\n        my($type, $xmax, $ymax, @d) = @_;\n        for my $x (0..$xmax) {\n            for my $y (0..$ymax) {\n                my $i = 0;\n                my $d = 10e6;\n                for (0..$\n                    my $dd = &{$type{$type}}($d[$_]{'x'}, $d[$_]{'y'}, $x, $y);\n                    if ($dd < $d) { $d = $dd; $i = $_ }\n                }\n                $img->setpixel(x => $x, y => $y, color => $d[$i]{rgb} );\n            }\n        }\n    }\n\n    sub dot {\n        my($radius, @d) = @_;\n        for (0..$\n            my $dx = $d[$_]{'x'};\n            my $dy = $d[$_]{'y'};\n            for my $x ($dx-$radius .. $dx+$radius) {\n                for my $y ($dy-$radius .. $dy+$radius) {\n                    $img->setpixel(x => $x, y => $y, color => [0,0,0]);\n                }\n            }\n        }\n    }\n}\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Voronoi extends JFrame {\n\tstatic double p = 3;\n\tstatic BufferedImage I;\n\tstatic int px[], py[], color[], cells = 100, size = 1000;\n\n\tpublic Voronoi() {\n\t\tsuper(\"Voronoi Diagram\");\n\t\tsetBounds(0, 0, size, size);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tint n = 0;\n\t\tRandom rand = new Random();\n\t\tI = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n\t\tpx = new int[cells];\n\t\tpy = new int[cells];\n\t\tcolor = new int[cells];\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tpx[i] = rand.nextInt(size);\n\t\t\tpy[i] = rand.nextInt(size);\n\t\t\tcolor[i] = rand.nextInt(16777215);\n\n\t\t}\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tfor (int y = 0; y < size; y++) {\n\t\t\t\tn = 0;\n\t\t\t\tfor (byte i = 0; i < cells; i++) {\n\t\t\t\t\tif (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {\n\t\t\t\t\t\tn = i;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tI.setRGB(x, y, color[n]);\n\n\t\t\t}\n\t\t}\n\n\t\tGraphics2D g = I.createGraphics();\n\t\tg.setColor(Color.BLACK);\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tg.fill(new Ellipse2D .Double(px[i] - 2.5, py[i] - 2.5, 5, 5));\n\t\t}\n\n\t\ttry {\n\t\t\tImageIO.write(I, \"png\", new File(\"voronoi.png\"));\n\t\t} catch (IOException e) {\n\n\t\t}\n\n\t}\n\n\tpublic void paint(Graphics g) {\n\t\tg.drawImage(I, 0, 0, this);\n\t}\n\n\tstatic double distance(int x1, int x2, int y1, int y2) {\n\t\tdouble d;\n\t    d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); \n\t\n\t\n\t  \treturn d;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Voronoi().setVisible(true);\n\t}\n}\n"}
{"id": 415527, "name": "Active Directory_Connect", "source": "Translate Perl to Java: use Net::LDAP;\n\nmy $ldap = Net::LDAP->new('ldap://ldap.example.com') or die $@;\nmy $mesg = $ldap->bind( $bind_dn, password => $bind_pass );\n", "target": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapConnectionDemo {\n\n    public static void main(String[] args) throws LdapException, IOException {\n        try (LdapConnection connection = new LdapNetworkConnection(\"localhost\", 10389)) {\n            connection.bind();\n            connection.unBind();\n        }\n    }\n}\n"}
{"id": 415528, "name": "Knapsack problem_Bounded", "source": "Translate Perl to Java: \n\nuse strict;\n\nmy $raw = <<'TABLE';\nmap     \t9       150     1\ncompass \t13      35      1\nwater   \t153     200     2\nsandwich        50      60      2\nglucose \t15      60      2\ntin     \t68      45      3\nbanana  \t27      60      3\napple  \t\t39      40      3\ncheese  \t23      30      1\nbeer    \t52      10      1\nsuntancream     11      70      1\ncamera  \t32      30      1\nT-shirt \t24      15      2\ntrousers        48      10      2\numbrella        73      40      1\nw_trousers     \t42      70      1\nw_overcoat  \t43      75      1\nnote-case       22      80      1\nsunglasses      7       20      1\ntowel   \t18      12      2\nsocks   \t4       50      1\nbook    \t30      10      2\nTABLE\n \nmy @items;\nfor (split \"\\n\", $raw) {\n        my @x = split /\\s+/;\n\tpush @items, {\n\t\tname\t=> $x[0],\n\t\tweight\t=> $x[1],\n\t\tvalue\t=> $x[2],\n\t\tquant\t=> $x[3],\n\t}\n}\n\nmy $max_weight = 400;\n\nmy %cache;\nsub pick {\n\tmy ($weight, $pos) = @_;\n\tif ($pos < 0 or $weight <= 0) {\n\t\treturn 0, 0, []\n\t}\n\n\t@{ $cache{$weight, $pos} //= [do{\t\n\t\tmy $item = $items[$pos];\n\t\tmy ($bv, $bi, $bw, $bp) = (0, 0, 0, []);\n\n\t\tfor my $i (0 .. $item->{quant}) {\n\t\t\tlast if $i * $item->{weight} > $weight;\n\t\t\tmy ($v, $w, $p) = pick($weight - $i * $item->{weight}, $pos - 1);\n\t\t\tnext if ($v += $i * $item->{value}) <= $bv;\n\n\t\t\t($bv, $bi, $bw, $bp) = ($v, $i, $w, $p);\n\t\t}\n\n\t\tmy @picked = ( @$bp, $bi );\n\t\t$bv, $bw + $bi * $item->{weight}, \\@picked\n\t}]}\n}\n\nmy ($v, $w, $p) = pick($max_weight, $\nfor (0 .. $\n\tif ($p->[$_] > 0) {\n\t\tprint \"$p->[$_] of $items[$_]{name}\\n\";\n\t}\n}\nprint \"Value: $v; Weight: $w\\n\";\n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.BoundedKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class BoundedKnapsackForTourists {\n    public BoundedKnapsackForTourists() {\n        BoundedKnapsack bok = new BoundedKnapsack(400); \n\n        \n        bok.add(\"map\", 9, 150, 1);\n        bok.add(\"compass\", 13, 35, 1);\n        bok.add(\"water\", 153, 200, 3);\n        bok.add(\"sandwich\", 50, 60, 2);\n        bok.add(\"glucose\", 15, 60, 2);\n        bok.add(\"tin\", 68, 45, 3);\n        bok.add(\"banana\", 27, 60, 3);\n        bok.add(\"apple\", 39, 40, 3);\n        bok.add(\"cheese\", 23, 30, 1);\n        bok.add(\"beer\", 52, 10, 3);\n        bok.add(\"suntan cream\", 11, 70, 1);\n        bok.add(\"camera\", 32, 30, 1);\n        bok.add(\"t-shirt\", 24, 15, 2);\n        bok.add(\"trousers\", 48, 10, 2);\n        bok.add(\"umbrella\", 73, 40, 1);\n        bok.add(\"waterproof trousers\", 42, 70, 1);\n        bok.add(\"waterproof overclothes\", 43, 75, 1);\n        bok.add(\"note-case\", 22, 80, 1);\n        bok.add(\"sunglasses\", 7, 20, 1);\n        bok.add(\"towel\", 18, 12, 2);\n        bok.add(\"socks\", 4, 50, 1);\n        bok.add(\"book\", 30, 10, 2);\n\n        \n        List<Item> itemList = bok.calcSolution();\n\n        \n        if (bok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(bok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(bok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                bok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry te following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > 0) {\n                    System.out.format(\n                        \"%1$-10s %2$-23s %3$-3s %4$-5s %5$-15s \\n\",\n                        item.getInKnapsack() + \" unit(s) \",\n                        item.getName(),\n                        item.getInKnapsack() * item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getInKnapsack() * item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new BoundedKnapsackForTourists();\n    }\n} \n"}
{"id": 415529, "name": "Solve a Hidato puzzle", "source": "Translate Perl to Java: use strict;\nuse List::Util 'max';\n\nour (@grid, @known, $n);\n\nsub show_board {\n\tfor my $r (@grid) {\n\t\tprint map(!defined($_)\t? '   ' : $_\n\t\t\t\t\t? sprintf(\"%3d\", $_)\n\t\t\t\t\t: ' __'\n\t\t\t, @$r), \"\\n\"\n\t}\n}\n\nsub parse_board {\n\t@grid = map{[map(/^_/ ? 0 : /^\\./ ? undef: $_, split ' ')]}\n\t\t\tsplit \"\\n\", shift();\n\tfor my $y (0 .. $\n\t\tfor my $x (0 .. $\n\t\t\t$grid[$y][$x] > 0\n\t\t\t\tand $known[$grid[$y][$x]] = \"$y,$x\";\n\t\t}\n\t}\n\t$n = max(map { max @$_ } @grid);\n}\n\nsub neighbors {\n\tmy ($y, $x) = @_;\n\tmy @out;\n\tfor (\t[-1, -1], [-1, 0], [-1, 1],\n\t\t[ 0, -1],\t   [ 0, 1],\n\t\t[ 1, -1], [ 1, 0], [ 1, 1])\n\t{\n\t\tmy $y1 = $y + $_->[0];\n\t\tmy $x1 = $x + $_->[1];\n\t\tnext if $x1 < 0 || $y1 < 0;\n\t\tnext unless defined $grid[$y1][$x1];\n\t\tpush @out, \"$y1,$x1\";\n\t}\n\t@out\n}\n\nsub try_fill {\n\tmy ($v, $coord) = @_;\n\treturn 1\tif $v > $n;\n\n\tmy ($y, $x) = split ',', $coord;\n\tmy $old = $grid[$y][$x];\n\n\treturn\tif $old && $old != $v;\n\treturn\tif exists $known[$v] and $known[$v] ne $coord;\n\n\t$grid[$y][$x] = $v;\n\tprint \"\\033[0H\";\n\tshow_board();\n\n\ttry_fill($v + 1, $_) && return 1\n\t\t\tfor neighbors($y, $x);\n\n\t$grid[$y][$x] = $old;\n\treturn\n}\n\nparse_board \n\n\n\n\n\n\n\n\n\n\t\"__ 33 35 __ __ .. .. .. .\n\t __ __ 24 22 __ .. .. .. .\n\t __ __ __ 21 __ __ .. .. .\n\t __ 26 __ 13 40 11 .. .. .\n\t 27 __ __ __  9 __  1 .. .\n\t .   . __ __ 18 __ __ .. .\n\t .  ..  .  . __  7 __ __ .\n\t .  .. .. ..  .  .  5 __ .\";\n\nprint \"\\033[2J\";\ntry_fill(1, $known[1]);\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Hidato {\n\n    private static int[][] board;\n    private static int[] given, start;\n\n    public static void main(String[] args) {\n        String[] input = {\"_ 33 35 _ _ . . .\",\n            \"_ _ 24 22 _ . . .\",\n            \"_ _ _ 21 _ _ . .\",\n            \"_ 26 _ 13 40 11 . .\",\n            \"27 _ _ _ 9 _ 1 .\",\n            \". . _ _ 18 _ _ .\",\n            \". . . . _ 7 _ _\",\n            \". . . . . . 5 _\"};\n\n        setup(input);\n        printBoard();\n        System.out.println(\"\\nFound:\");\n        solve(start[0], start[1], 1, 0);\n        printBoard();\n    }\n\n    private static void setup(String[] input) {\n        \n\n        String[][] puzzle = new String[input.length][];\n        for (int i = 0; i < input.length; i++)\n            puzzle[i] = input[i].split(\" \");\n\n        int nCols = puzzle[0].length;\n        int nRows = puzzle.length;\n\n        List<Integer> list = new ArrayList<>(nRows * nCols);\n\n        board = new int[nRows + 2][nCols + 2];\n        for (int[] row : board)\n            for (int c = 0; c < nCols + 2; c++)\n                row[c] = -1;\n\n        for (int r = 0; r < nRows; r++) {\n            String[] row = puzzle[r];\n            for (int c = 0; c < nCols; c++) {\n                String cell = row[c];\n                switch (cell) {\n                    case \"_\":\n                        board[r + 1][c + 1] = 0;\n                        break;\n                    case \".\":\n                        break;\n                    default:\n                        int val = Integer.parseInt(cell);\n                        board[r + 1][c + 1] = val;\n                        list.add(val);\n                        if (val == 1)\n                            start = new int[]{r + 1, c + 1};\n                }\n            }\n        }\n        Collections.sort(list);\n        given = new int[list.size()];\n        for (int i = 0; i < given.length; i++)\n            given[i] = list.get(i);\n    }\n\n    private static boolean solve(int r, int c, int n, int next) {\n        if (n > given[given.length - 1])\n            return true;\n\n        if (board[r][c] != 0 && board[r][c] != n)\n            return false;\n\n        if (board[r][c] == 0 && given[next] == n)\n            return false;\n\n        int back = board[r][c];\n        if (back == n)\n            next++;\n\n        board[r][c] = n;\n        for (int i = -1; i < 2; i++)\n            for (int j = -1; j < 2; j++)\n                if (solve(r + i, c + j, n + 1, next))\n                    return true;\n\n        board[r][c] = back;\n        return false;\n    }\n\n    private static void printBoard() {\n        for (int[] row : board) {\n            for (int c : row) {\n                if (c == -1)\n                    System.out.print(\" . \");\n                else\n                    System.out.printf(c > 0 ? \"%2d \" : \"__ \", c);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415530, "name": "Solve a Hidato puzzle", "source": "Translate Perl to Java: use strict;\nuse List::Util 'max';\n\nour (@grid, @known, $n);\n\nsub show_board {\n\tfor my $r (@grid) {\n\t\tprint map(!defined($_)\t? '   ' : $_\n\t\t\t\t\t? sprintf(\"%3d\", $_)\n\t\t\t\t\t: ' __'\n\t\t\t, @$r), \"\\n\"\n\t}\n}\n\nsub parse_board {\n\t@grid = map{[map(/^_/ ? 0 : /^\\./ ? undef: $_, split ' ')]}\n\t\t\tsplit \"\\n\", shift();\n\tfor my $y (0 .. $\n\t\tfor my $x (0 .. $\n\t\t\t$grid[$y][$x] > 0\n\t\t\t\tand $known[$grid[$y][$x]] = \"$y,$x\";\n\t\t}\n\t}\n\t$n = max(map { max @$_ } @grid);\n}\n\nsub neighbors {\n\tmy ($y, $x) = @_;\n\tmy @out;\n\tfor (\t[-1, -1], [-1, 0], [-1, 1],\n\t\t[ 0, -1],\t   [ 0, 1],\n\t\t[ 1, -1], [ 1, 0], [ 1, 1])\n\t{\n\t\tmy $y1 = $y + $_->[0];\n\t\tmy $x1 = $x + $_->[1];\n\t\tnext if $x1 < 0 || $y1 < 0;\n\t\tnext unless defined $grid[$y1][$x1];\n\t\tpush @out, \"$y1,$x1\";\n\t}\n\t@out\n}\n\nsub try_fill {\n\tmy ($v, $coord) = @_;\n\treturn 1\tif $v > $n;\n\n\tmy ($y, $x) = split ',', $coord;\n\tmy $old = $grid[$y][$x];\n\n\treturn\tif $old && $old != $v;\n\treturn\tif exists $known[$v] and $known[$v] ne $coord;\n\n\t$grid[$y][$x] = $v;\n\tprint \"\\033[0H\";\n\tshow_board();\n\n\ttry_fill($v + 1, $_) && return 1\n\t\t\tfor neighbors($y, $x);\n\n\t$grid[$y][$x] = $old;\n\treturn\n}\n\nparse_board \n\n\n\n\n\n\n\n\n\n\t\"__ 33 35 __ __ .. .. .. .\n\t __ __ 24 22 __ .. .. .. .\n\t __ __ __ 21 __ __ .. .. .\n\t __ 26 __ 13 40 11 .. .. .\n\t 27 __ __ __  9 __  1 .. .\n\t .   . __ __ 18 __ __ .. .\n\t .  ..  .  . __  7 __ __ .\n\t .  .. .. ..  .  .  5 __ .\";\n\nprint \"\\033[2J\";\ntry_fill(1, $known[1]);\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Hidato {\n\n    private static int[][] board;\n    private static int[] given, start;\n\n    public static void main(String[] args) {\n        String[] input = {\"_ 33 35 _ _ . . .\",\n            \"_ _ 24 22 _ . . .\",\n            \"_ _ _ 21 _ _ . .\",\n            \"_ 26 _ 13 40 11 . .\",\n            \"27 _ _ _ 9 _ 1 .\",\n            \". . _ _ 18 _ _ .\",\n            \". . . . _ 7 _ _\",\n            \". . . . . . 5 _\"};\n\n        setup(input);\n        printBoard();\n        System.out.println(\"\\nFound:\");\n        solve(start[0], start[1], 1, 0);\n        printBoard();\n    }\n\n    private static void setup(String[] input) {\n        \n\n        String[][] puzzle = new String[input.length][];\n        for (int i = 0; i < input.length; i++)\n            puzzle[i] = input[i].split(\" \");\n\n        int nCols = puzzle[0].length;\n        int nRows = puzzle.length;\n\n        List<Integer> list = new ArrayList<>(nRows * nCols);\n\n        board = new int[nRows + 2][nCols + 2];\n        for (int[] row : board)\n            for (int c = 0; c < nCols + 2; c++)\n                row[c] = -1;\n\n        for (int r = 0; r < nRows; r++) {\n            String[] row = puzzle[r];\n            for (int c = 0; c < nCols; c++) {\n                String cell = row[c];\n                switch (cell) {\n                    case \"_\":\n                        board[r + 1][c + 1] = 0;\n                        break;\n                    case \".\":\n                        break;\n                    default:\n                        int val = Integer.parseInt(cell);\n                        board[r + 1][c + 1] = val;\n                        list.add(val);\n                        if (val == 1)\n                            start = new int[]{r + 1, c + 1};\n                }\n            }\n        }\n        Collections.sort(list);\n        given = new int[list.size()];\n        for (int i = 0; i < given.length; i++)\n            given[i] = list.get(i);\n    }\n\n    private static boolean solve(int r, int c, int n, int next) {\n        if (n > given[given.length - 1])\n            return true;\n\n        if (board[r][c] != 0 && board[r][c] != n)\n            return false;\n\n        if (board[r][c] == 0 && given[next] == n)\n            return false;\n\n        int back = board[r][c];\n        if (back == n)\n            next++;\n\n        board[r][c] = n;\n        for (int i = -1; i < 2; i++)\n            for (int j = -1; j < 2; j++)\n                if (solve(r + i, c + j, n + 1, next))\n                    return true;\n\n        board[r][c] = back;\n        return false;\n    }\n\n    private static void printBoard() {\n        for (int[] row : board) {\n            for (int c : row) {\n                if (c == -1)\n                    System.out.print(\" . \");\n                else\n                    System.out.printf(c > 0 ? \"%2d \" : \"__ \", c);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415531, "name": "Sorting algorithms_Strand sort", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub merge {\n    my ($x, $y) = @_;\n    my @out;\n    while (@$x and @$y) {\n        my $t = $x->[-1] <=> $y->[-1];\n        if    ($t == 1)  { unshift @out, pop @$x }\n        elsif ($t == -1) { unshift @out, pop @$y }\n        else             { splice @out, 0, 0, pop(@$x), pop(@$y) }\n    }\n    @$x, @$y, @out\n}\n\nsub strand {\n    my $x = shift;\n    my @out = shift @$x // return;\n    for (-@$x .. -1) {\n        push @out, splice @$x, $_, 1 if $x->[$_] >= $out[-1];\n    }\n    @out\n}\n\nsub strand_sort {\n    my @x = @_;\n    my(@out, @strand);\n    @out = merge \\@out, \\@strand while @strand = strand(\\@x);\n    @out\n}\n\nmy @a = map (int rand(100), 1 .. 10);\nsay \"Before @a\";\n@a = strand_sort(@a);\nsay \"After  @a\";\n", "target": "import java.util.Arrays;\nimport java.util.LinkedList;\n\npublic class Strand{\n\t\n\tpublic static <E extends Comparable<? super E>> \n\tLinkedList<E> strandSort(LinkedList<E> list){\n\t\tif(list.size() <= 1) return list;\n\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(list.size() > 0){\n\t\t\tLinkedList<E> sorted = new LinkedList<E>();\n\t\t\tsorted.add(list.removeFirst()); \n\t\t\tfor(Iterator<E> it = list.iterator(); it.hasNext(); ){\n\t\t\t\tE elem = it.next();\n\t\t\t\tif(sorted.peekLast().compareTo(elem) <= 0){\n\t\t\t\t\tsorted.addLast(elem); \n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = merge(sorted, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static <E extends Comparable<? super E>>\n\tLinkedList<E> merge(LinkedList<E> left, LinkedList<E> right){\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(!left.isEmpty() && !right.isEmpty()){\n\t\t\t\n\t\t\tif(left.peek().compareTo(right.peek()) <= 0)\n\t\t\t\tresult.add(left.remove());\n\t\t\telse\n\t\t\t\tresult.add(right.remove());\n\t\t}\n\t\tresult.addAll(left);\n\t\tresult.addAll(right);\n\t\treturn result;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,1,2,4,5))));\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,3,1,2,4,5))));\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,3,1,2,4,3,5,6))));\n\t}\n}\n"}
{"id": 415532, "name": "Angles (geometric), normalization and conversion", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse POSIX 'fmod';\n\nmy $tau = 2 * 4*atan2(1, 1);\nmy @units = (\n    { code => 'd', name => 'degrees' , number =>  360 },\n    { code => 'g', name => 'gradians', number =>  400 },\n    { code => 'm', name => 'mills'   , number => 6400 },\n    { code => 'r', name => 'radians' , number => $tau },\n);\n\nmy %cvt;\nfor my $a (@units) {\n  for my $b (@units) {\n    $cvt{ \"${$a}{code}2${$b}{code}\" } = sub {\n        my($angle) = shift;\n        my $norm = fmod($angle,${$a}{number}); \n        $norm -= ${$a}{number} if $angle < 0;\n        $norm * ${$b}{number} / ${$a}{number}\n        }\n  }\n}\n\nprintf '%s'. '%12s'x4 . \"\\n\", '     Angle Unit    ', <Degrees Gradians Mills Radians>;\nfor my $angle (-2, -1, 0, 1, 2, $tau, 16, 360/$tau, 360-1, 400-1, 6400-1, 1_000_000) {\n    print \"\\n\";\n    for my $from (@units) {\n        my @sub_keys = map { \"${$from}{code}2${$_}{code}\" } @units;\n        my @results  = map { &{$cvt{$_}}($angle) } @sub_keys;\n        printf '%10g\u00a0%-8s' . '%12g'x4 . \"\\n\", $angle, ${$from}{name}, @results;\n    }\n}\n", "target": "import java.text.DecimalFormat;\n\n\n\npublic class AnglesNormalizationAndConversion {\n\n    public static void main(String[] args) {\n        DecimalFormat formatAngle = new DecimalFormat(\"######0.000000\");\n        DecimalFormat formatConv = new DecimalFormat(\"###0.0000\");\n        System.out.printf(\"                               degrees    gradiens        mils     radians%n\");\n        for ( double angle : new double[] {-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000} ) {\n            for ( String units : new String[] {\"degrees\", \"gradiens\", \"mils\", \"radians\"}) {\n                double d = 0, g = 0, m = 0, r = 0;\n                switch (units) {\n                case \"degrees\":\n                    d = d2d(angle);\n                    g = d2g(d);\n                    m = d2m(d);\n                    r = d2r(d);\n                    break;\n                case \"gradiens\":\n                    g = g2g(angle);\n                    d = g2d(g);\n                    m = g2m(g);\n                    r = g2r(g);\n                    break;\n                case \"mils\":\n                    m = m2m(angle);\n                    d = m2d(m);\n                    g = m2g(m);\n                    r = m2r(m);\n                    break;\n                case \"radians\":\n                    r = r2r(angle);\n                    d = r2d(r);\n                    g = r2g(r);\n                    m = r2m(r);\n                    break;\n                }\n                System.out.printf(\"%15s  %8s = %10s  %10s  %10s  %10s%n\", formatAngle.format(angle), units, formatConv.format(d), formatConv.format(g), formatConv.format(m), formatConv.format(r));\n            }\n        }\n    }\n\n    private static final double DEGREE = 360D;\n    private static final double GRADIAN = 400D;\n    private static final double MIL = 6400D;\n    private static final double RADIAN = (2 * Math.PI);\n    \n    private static double d2d(double a) {\n        return a % DEGREE;\n    }\n    private static double d2g(double a) {\n        return a * (GRADIAN / DEGREE);\n    }\n    private static double d2m(double a) {\n        return a * (MIL / DEGREE);\n    }\n    private static double d2r(double a) {\n        return a * (RADIAN / 360);\n    }\n\n    private static double g2d(double a) {\n        return a * (DEGREE / GRADIAN);\n    }\n    private static double g2g(double a) {\n        return a % GRADIAN;\n    }\n    private static double g2m(double a) {\n        return a * (MIL / GRADIAN);\n    }\n    private static double g2r(double a) {\n        return a * (RADIAN / GRADIAN);\n    }\n    \n    private static double m2d(double a) {\n        return a * (DEGREE / MIL);\n    }\n    private static double m2g(double a) {\n        return a * (GRADIAN / MIL);\n    }\n    private static double m2m(double a) {\n        return a % MIL;\n    }\n    private static double m2r(double a) {\n        return a * (RADIAN / MIL);\n    }\n    \n    private static double r2d(double a) {\n        return a * (DEGREE / RADIAN);\n    }\n    private static double r2g(double a) {\n        return a * (GRADIAN / RADIAN);\n    }\n    private static double r2m(double a) {\n        return a * (MIL / RADIAN);\n    }\n    private static double r2r(double a) {\n        return a % RADIAN;\n    }\n    \n}\n"}
{"id": 415533, "name": "XML_XPath", "source": "Translate Perl to Java: use XML::XPath qw();\n\nmy $x = XML::XPath->new('<inventory ... </inventory>');\n\n[$x->findnodes('//item[1]')->get_nodelist]->[0];\nprint $x->findnodes_as_string('//price');\n$x->findnodes('//name')->get_nodelist;\n", "target": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\npublic class XMLParser {\n\tfinal static String xmlStr = \n\t\t\t  \"<inventory title=\\\"OmniCorp Store #45x10^3\\\">\"\n\t\t\t+ \"  <section name=\\\"health\\\">\"\n\t\t\t+ \"    <item upc=\\\"123456789\\\" stock=\\\"12\\\">\"\n\t\t\t+ \"      <name>Invisibility Cream</name>\"\n\t\t\t+ \"      <price>14.50</price>\"\n\t\t\t+ \"      <description>Makes you invisible</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"445322344\\\" stock=\\\"18\\\">\"\n\t\t\t+ \"      <name>Levitation Salve</name>\"\n\t\t\t+ \"      <price>23.99</price>\"\n\t\t\t+ \"      <description>Levitate yourself for up to 3 hours per application</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\"\n\t\t\t+ \"  <section name=\\\"food\\\">\"\n\t\t\t+ \"    <item upc=\\\"485672034\\\" stock=\\\"653\\\">\"\n\t\t\t+ \"      <name>Blork and Freen Instameal</name>\"\n\t\t\t+ \"      <price>4.95</price>\"\n\t\t\t+ \"      <description>A tasty meal in a tablet; just add water</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"132957764\\\" stock=\\\"44\\\">\"\n\t\t\t+ \"      <name>Grob winglets</name>\"\n\t\t\t+ \"      <price>3.56</price>\"\n\t\t\t+ \"      <description>Tender winglets of Grob. Just add priwater</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\" \n\t\t\t+ \"</inventory>\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tDocument doc = DocumentBuilderFactory.newInstance()\n\t\t\t\t\t.newDocumentBuilder()\n\t\t\t\t\t.parse(new InputSource(new StringReader(xmlStr)));\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\t\n\t\t\tSystem.out.println(((Node) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item[1]\", doc, XPathConstants.NODE))\n\t\t\t\t\t.getAttributes().getNamedItem(\"upc\"));\n\t\t\t\n\t\t\tNodeList nodes = (NodeList) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item/price\", doc,\n\t\t\t\t\tXPathConstants.NODESET);\n\t\t\tfor (int i = 0; i < nodes.getLength(); i++)\n\t\t\t\tSystem.out.println(nodes.item(i).getTextContent());\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"Error ocurred while parsing XML.\");\n\t\t}\n\t}\n}\n"}
{"id": 415534, "name": "Ranking methods", "source": "Translate Perl to Java: my %scores = (\n    'Solomon' => 44,\n    'Jason'   => 42,\n    'Errol'   => 42,\n    'Garry'   => 41,\n    'Bernard' => 41,\n    'Barry'   => 41,\n    'Stephen' => 39\n);\n\nsub tiers {\n    my(%s) = @_; my(%h);\n    push @{$h{$s{$_}}}, $_ for keys %s;\n    @{\\%h}{reverse sort keys %h};\n}\n\nsub standard {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n        $rank += @$players;\n    }\n    return $result;\n}\n\nsub modified {\n    my(%s) = @_; my($result);\n    my $rank = 0;\n    for my $players (tiers %s) {\n        $rank += @$players;\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n    }\n    return $result;\n}\n\nsub dense {\n    my(%s) = @_; my($n,$result);\n    $result .= sprintf \"%d %s\\n\", ++$n, join(', ', sort @$_) for tiers %s;\n    return $result;\n}\n\nsub ordinal {\n    my(%s) = @_; my($n,$result);\n    for my $players (tiers %s) {\n        $result .= sprintf \"%d %s\\n\", ++$n, $_ for sort @$players;\n    }\n    return $result;\n}\n\nsub fractional {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        my $beg = $rank;\n        my $end = $rank += @$players;\n        my $avg = 0;\n        $avg += $_/@$players for $beg .. $end-1;\n        $result .= sprintf \"%3.1f %s\\n\", $avg, join ', ', sort @$players;\n    }\n    return $result;\n}\n\nprint \"Standard:\\n\"    .   standard(%scores) . \"\\n\";\nprint \"Modified:\\n\"    .   modified(%scores) . \"\\n\";\nprint \"Dense:\\n\"       .      dense(%scores) . \"\\n\";\nprint \"Ordinal:\\n\"     .    ordinal(%scores) . \"\\n\";\nprint \"Fractional:\\n\"  . fractional(%scores) . \"\\n\";\n", "target": "import java.util.*;\n\npublic class RankingMethods {\n\n    final static String[] input = {\"44 Solomon\", \"42 Jason\", \"42 Errol\",\n        \"41 Garry\", \"41 Bernard\", \"41 Barry\", \"39 Stephen\"};\n\n    public static void main(String[] args) {\n        int len = input.length;\n\n        Map<String, int[]> map = new TreeMap<>((a, b) -> b.compareTo(a));\n        for (int i = 0; i < len; i++) {\n            String key = input[i].split(\"\\\\s+\")[0];\n            int[] arr;\n            if ((arr = map.get(key)) == null)\n                arr = new int[]{i, 0};\n            arr[1]++;\n            map.put(key, arr);\n        }\n        int[][] groups = map.values().toArray(new int[map.size()][]);\n\n        standardRanking(len, groups);\n        modifiedRanking(len, groups);\n        denseRanking(len, groups);\n        ordinalRanking(len);\n        fractionalRanking(len, groups);\n    }\n\n    private static void standardRanking(int len, int[][] groups) {\n        System.out.println(\"\\nStandard ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                rank = i + 1;\n                group++;\n            }\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void modifiedRanking(int len, int[][] groups) {\n        System.out.println(\"\\nModified ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0])\n                rank += groups[group++][1];\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void denseRanking(int len, int[][] groups) {\n        System.out.println(\"\\nDense ranking\");\n        for (int i = 0, rank = 0; i < len; i++) {\n            if (rank < groups.length && i == groups[rank][0])\n                rank++;\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void ordinalRanking(int len) {\n        System.out.println(\"\\nOrdinal ranking\");\n        for (int i = 0; i < len; i++)\n            System.out.printf(\"%d %s%n\", i + 1, input[i]);\n    }\n\n    private static void fractionalRanking(int len, int[][] groups) {\n        System.out.println(\"\\nFractional ranking\");\n        float rank = 0;\n        for (int i = 0, tmp = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                tmp += groups[group++][1];\n                rank = (i + 1 + tmp) / 2.0F;\n            }\n            System.out.printf(\"%2.1f %s%n\", rank, input[i]);\n        }\n    }\n}\n"}
{"id": 415535, "name": "Update a configuration file", "source": "Translate Perl to Java: use warnings;\nuse strict;\n\nmy $needspeeling         = 0;\nmy $seedsremoved         = 1;\nmy $numberofstrawberries = 62000;\nmy $numberofbananas      = 1024;\nmy $favouritefruit       = 'bananas';\n\nmy @out;\n\nsub config {\n    my (@config) = <DATA>;\n    push @config, \"NUMBEROFSTRAWBERRIES $numberofstrawberries\\n\"\n        unless grep { /^;*[ \\t]*NUMBEROFSTRAWBERRIES\\b/; } @config;\n\n    foreach my $line (@config) {\n\n        if (substr($line, 0, 1) eq '\n            push @out, $line;\n            next;\n        }\n\n        next if $line =~ /^[;\\t ]+$/;\n\n        my ($option, $option_name);\n\n        if ($line =~ /^([A-Z]+[0-9]*)/) {\n            $option_name = lc $1;\n            $option      = eval \"\\\\\\$$option_name\";\n            my $value = eval \"\\${$option_name}\";\n\n            if ($value) {\n                $$option = $value;\n            }\n            else {\n                $line    = '; ' . $line;\n                $$option = undef;\n            }\n        }\n        elsif ($line =~ /^;+\\s*([A-Z]+[0-9]*)/) {\n            $option_name = lc $1;\n            $option      = eval \"\\\\\\$$option_name\";\n            my $value = eval \"\\${$option_name}\";\n\n            if ($value) {\n                $line =~ s/^;+\\s*//;\n                $$option = $value == 1 ? '' : $value;\n            }\n            else {\n                $$option = undef;\n            }\n        }\n\n        if (defined $$option) {\n            push @out, \"\\U$option_name\\E $$option\\n\"\n                unless grep { /^\\U$option_name\\E\\b/; } @out;\n        }\n        else {\n            $line =~ s/\\s*[^[:ascii:]]+\\s*$//;\n            $line =~ s/[[:cntrl:]\\s]+$//;\n            push(@out, \"$line\\n\");\n        }\n    }\n}\n\nconfig();\n\nmy $file = join('', @out);\n$file =~ s/\\n{3,}/\\n\\n/g;\n\nprint $file;\n\n", "target": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class UpdateConfig {\n\n    public static void main(String[] args) {\n        if (args[0] == null) {\n            System.out.println(\"filename required\");\n\n        } else if (readConfig(args[0])) {\n            enableOption(\"seedsremoved\");\n            disableOption(\"needspeeling\");\n            setOption(\"numberofbananas\", \"1024\");\n            addOption(\"numberofstrawberries\", \"62000\");\n            store();\n        }\n    }\n\n    private enum EntryType {\n        EMPTY, ENABLED, DISABLED, COMMENT\n    }\n\n    private static class Entry {\n        EntryType type;\n        String name, value;\n\n        Entry(EntryType t, String n, String v) {\n            type = t;\n            name = n;\n            value = v;\n        }\n    }\n\n    private static Map<String, Entry> entries = new LinkedHashMap<>();\n    private static String path;\n\n    private static boolean readConfig(String p) {\n        path = p;\n\n        File f = new File(path);\n        if (!f.exists() || f.isDirectory())\n            return false;\n\n        String regexString = \"^(;*)\\\\s*([A-Za-z0-9]+)\\\\s*([A-Za-z0-9]*)\";\n        Pattern regex = Pattern.compile(regexString);\n\n        try (Scanner sc = new Scanner(new FileReader(f))){\n            int emptyLines = 0;\n            String line;\n            while (sc.hasNext()) {\n                line = sc.nextLine().trim();\n\n                if (line.isEmpty()) {\n                    addOption(\"\" + emptyLines++, null, EntryType.EMPTY);\n\n                } else if (line.charAt(0) == '#') {\n                    entries.put(line, new Entry(EntryType.COMMENT, line, null));\n\n                } else {\n                    line = line.replaceAll(\"[^a-zA-Z0-9\\\\x20;]\", \"\");\n                    Matcher m = regex.matcher(line);\n\n                    if (m.find() && !m.group(2).isEmpty()) {\n\n                        EntryType t = EntryType.ENABLED;\n                        if (!m.group(1).isEmpty())\n                            t = EntryType.DISABLED;\n\n                        addOption(m.group(2), m.group(3), t);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return true;\n    }\n\n    private static void addOption(String name, String value) {\n        addOption(name, value, EntryType.ENABLED);\n    }\n\n    private static void addOption(String name, String value, EntryType t) {\n        name = name.toUpperCase();\n        entries.put(name, new Entry(t, name, value));\n    }\n\n    private static void enableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.ENABLED;\n    }\n\n    private static void disableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.DISABLED;\n    }\n\n    private static void setOption(String name, String value) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.value = value;\n    }\n\n    private static void store() {\n        try (PrintWriter pw = new PrintWriter(path)) {\n            for (Entry e : entries.values()) {\n                switch (e.type) {\n                    case EMPTY:\n                        pw.println();\n                        break;\n                    case ENABLED:\n                        pw.format(\"%s %s%n\", e.name, e.value);\n                        break;\n                    case DISABLED:\n                        pw.format(\"; %s %s%n\", e.name, e.value);\n                        break;\n                    case COMMENT:\n                        pw.println(e.name);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (pw.checkError()) {\n                throw new IOException(\"writing to file failed\");\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n}\n"}
{"id": 415536, "name": "Straddling checkerboard", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util <min max>;\n\nmy(%encode,%decode,@table);\n\nsub build {\n    my($u,$v,$alphabet) = @_;\n    my(@flat_board,%p2c,%c2p);\n    my $numeric_escape = '/';\n\n    @flat_board = split '', uc $alphabet;\n    splice @flat_board, min($u,$v), 0, undef;\n    splice @flat_board, max($u,$v), 0, undef;\n\n    push @table, [' ', 0..9];\n    push @table, [' ', map { defined $_ ? $_ : ' '} @flat_board[ 0 ..  9] ];\n    push @table, [$u,  @flat_board[10 .. 19]];\n    push @table, [$v,  @flat_board[20 .. 29]];\n\n    my @nums = my @order = 0..9;\n    push @nums, (map { +\"$u$_\" } @order), map { +\"$v$_\" } @order;\n\n    @c2p{@nums} = @flat_board;\n    for (keys %c2p) { delete $c2p{$_} unless defined $c2p{$_} }\n    @p2c{values %c2p} = keys %c2p;\n    $p2c{$_} = $p2c{$numeric_escape} . $_ for 0..9;\n    while (my ($k, $v) = each %p2c) {\n        $encode{$k} = $v;\n        $decode{$v} = $k unless $k eq $numeric_escape;\n    }\n}\n\nsub decode {\n    my($string) = @_;\n    my $keys = join '|', keys %decode;\n    $string =~ s/($keys)/$decode{$1}/gr;\n}\n\nsub encode {\n    my($string) = uc shift;\n    $string =~ s\n}\n\nmy $sc = build(3, 7, 'HOLMESRTABCDFGIJKNPQUVWXYZ./');\nsay join  ' ', @$_ for @table;\nsay '';\nsay 'Original: ', my $original = 'One night-it was on the twentieth of March, 1888-I was returning';\nsay 'Encoded:  ', my $en = encode($original);\nsay 'Decoded:  ', decode($en);\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.*;\n\npublic class StraddlingCheckerboard {\n\n    final static String[] keyvals = {\"H:0\", \"O:1\", \"L:2\", \"M:4\", \"E:5\", \"S:6\",\n        \"R:8\", \"T:9\", \"A:30\", \"B:31\", \"C:32\", \"D:33\", \"F:34\", \"G:35\", \"I:36\",\n        \"J:37\", \"K:38\", \"N:39\", \"P:70\", \"Q:71\", \"U:72\", \"V:73\", \"W:74\", \"X:75\",\n        \"Y:76\", \"Z:77\", \".:78\", \"/:79\", \"0:790\", \"1:791\", \"2:792\", \"3:793\",\n        \"4:794\", \"5:795\", \"6:796\", \"7:797\", \"8:798\", \"9:799\"};\n\n    final static Map<String, String> val2key = new HashMap<>();\n    final static Map<String, String> key2val = new HashMap<>();\n\n    public static void main(String[] args) {\n        for (String keyval : keyvals) {\n            String[] kv = keyval.split(\":\");\n            val2key.put(kv[0], kv[1]);\n            key2val.put(kv[1], kv[0]);\n        }\n        String enc = encode(\"One night-it was on the twentieth of March, \"\n                + \"1888-I was returning\");\n        System.out.println(enc);\n        System.out.println(decode(enc));\n    }\n\n    static String encode(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (String c : s.toUpperCase().split(\"\")) {\n            c = val2key.get(c);\n            if (c != null)\n                sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    static String decode(String s) {\n        Matcher m = Pattern.compile(\"(79.|3.|7.|.)\").matcher(s);\n        StringBuilder sb = new StringBuilder();\n        while (m.find()) {\n            String v = key2val.get(m.group(1));\n            if (v != null)\n                sb.append(v);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 415537, "name": "I before E except after C", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\n\nsub result {\n    my ($support, $against) = @_;\n    my $ratio  = sprintf '%.2f', $support / $against;\n    my $result = $ratio >= 2;\n    print \"$support / $against = $ratio. \", 'NOT ' x !$result, \"PLAUSIBLE\\n\";\n    return $result;\n}\n\nmy @keys  = qw(ei cei ie cie);\nmy %count;\n\nwhile (<>) {\n    for my $k (@keys) {\n        $count{$k}++ if -1 != index $_, $k;\n    }\n}\n\nmy ($support, $against, $result);\n\nprint 'I before E when not preceded by C: ';\n$support = $count{ie} - $count{cie};\n$against = $count{ei} - $count{cei};\n$result += result($support, $against);\n\nprint 'E before I when preceded by C: ';\n$support = $count{cei};\n$against = $count{cie};\n$result += result($support, $against);\n\nprint 'Overall: ', 'NOT ' x ($result < 2), \"PLAUSIBLE.\\n\";\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 415538, "name": "I before E except after C", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\n\nsub result {\n    my ($support, $against) = @_;\n    my $ratio  = sprintf '%.2f', $support / $against;\n    my $result = $ratio >= 2;\n    print \"$support / $against = $ratio. \", 'NOT ' x !$result, \"PLAUSIBLE\\n\";\n    return $result;\n}\n\nmy @keys  = qw(ei cei ie cie);\nmy %count;\n\nwhile (<>) {\n    for my $k (@keys) {\n        $count{$k}++ if -1 != index $_, $k;\n    }\n}\n\nmy ($support, $against, $result);\n\nprint 'I before E when not preceded by C: ';\n$support = $count{ie} - $count{cie};\n$against = $count{ei} - $count{cei};\n$result += result($support, $against);\n\nprint 'E before I when preceded by C: ';\n$support = $count{cei};\n$against = $count{cie};\n$result += result($support, $against);\n\nprint 'Overall: ', 'NOT ' x ($result < 2), \"PLAUSIBLE.\\n\";\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 415539, "name": "Abelian sandpile model", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'bitwise';\n\nmy ($high, $wide) = split ' ', qx(stty size);\nmy $mask = \"\\0\" x $wide . (\"\\0\" . \"\\177\" x ($wide - 2) . \"\\0\") x ($high - 5) .\n  \"\\0\" x $wide;\nmy $pile = $mask =~ s/\\177/ rand() < 0.02\u00a0? chr 64 + rand 20\u00a0: \"\\0\" /ger;\n\nfor (1 .. 1e6)\n  {\n  print \"\\e[H\", $pile =~ tr/\\0-\\177/ 1-~/r, \"\\n$_\";\n  my $add = $pile =~ tr/\\1-\\177/\\0\\0\\0\\200/r; \n  $add =~ /\\200/ or last;\n  $pile =~ tr/\\4-\\177/\\0-\\173/; \n  for (\"\\0$add\", \"\\0\" x $wide . $add, substr($add, 1), substr $add, $wide)\n    {\n    $pile |.= $_;\n    $pile =~ tr/\\200-\\377/\\1-\\176/; \n    $pile &.= $mask;\n    }\n  select undef, undef, undef, 0.1; \n  }\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AbelianSandpile {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                Frame frame = new Frame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class Frame extends JFrame {\n        private Frame() {\n            super(\"Abelian Sandpile Model\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            Container contentPane = getContentPane();\n            JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n            JButton start = new JButton(\"Restart Simulation\");\n            start.addActionListener(e -> restartSimulation());\n            JButton stop = new JButton(\"Stop Simulation\");\n            stop.addActionListener(e -> stopSimulation());\n            controlPanel.add(start);\n            controlPanel.add(stop);\n            contentPane.add(controlPanel, BorderLayout.NORTH);\n            contentPane.add(canvas = new Canvas(), BorderLayout.CENTER);\n            timer = new Timer(100, e -> canvas.runAndDraw());\n            timer.start();\n            pack();\n        }\n\n        private void restartSimulation() {\n            timer.stop();\n            canvas.initGrid();\n            timer.start();\n        }\n\n        private void stopSimulation() {\n            timer.stop();\n        }\n\n        private Timer timer;\n        private Canvas canvas;\n    }\n\n    private static class Canvas extends JComponent {\n        private Canvas() {\n            setBorder(BorderFactory.createEtchedBorder());\n            setPreferredSize(new Dimension(600, 600));\n        }\n\n        public void paintComponent(Graphics g) {\n            int width = getWidth();\n            int height = getHeight();\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, width, height);\n            int cellWidth = width/GRID_LENGTH;\n            int cellHeight = height/GRID_LENGTH;\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    if (grid[i][j] > 0) {\n                        g.setColor(COLORS[grid[i][j]]);\n                        g.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);\n                    }\n                }\n            }\n        }\n\n        private void initGrid() {\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    grid[i][j] = 0;\n                }\n            }\n        }\n\n        private void runAndDraw() {\n            for (int i = 0; i < 100; ++i)\n                addSand(GRID_LENGTH/2, GRID_LENGTH/2);\n            repaint();\n        }\n\n        private void addSand(int i, int j) {\n            int grains = grid[i][j];\n            if (grains < 3) {\n                grid[i][j]++;\n            }\n            else {\n                grid[i][j] = grains - 3;\n                if (i > 0)\n                    addSand(i - 1, j);\n                if (i < GRID_LENGTH - 1)\n                    addSand(i + 1, j);\n                if (j > 0)\n                    addSand(i, j - 1);\n                if (j < GRID_LENGTH - 1)\n                    addSand(i, j + 1);\n            }\n        }\n\n        private int[][] grid = new int[GRID_LENGTH][GRID_LENGTH];\n    }\n\n    private static final Color[] COLORS = {\n        Color.WHITE,\n        new Color(0x00, 0xbf, 0xff),\n        new Color(0xff, 0xd7, 0x00),\n        new Color(0xb0, 0x30, 0x60)\n    };\n    private static final int GRID_LENGTH = 300;\n}\n"}
{"id": 415540, "name": "Abelian sandpile model", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'bitwise';\n\nmy ($high, $wide) = split ' ', qx(stty size);\nmy $mask = \"\\0\" x $wide . (\"\\0\" . \"\\177\" x ($wide - 2) . \"\\0\") x ($high - 5) .\n  \"\\0\" x $wide;\nmy $pile = $mask =~ s/\\177/ rand() < 0.02\u00a0? chr 64 + rand 20\u00a0: \"\\0\" /ger;\n\nfor (1 .. 1e6)\n  {\n  print \"\\e[H\", $pile =~ tr/\\0-\\177/ 1-~/r, \"\\n$_\";\n  my $add = $pile =~ tr/\\1-\\177/\\0\\0\\0\\200/r; \n  $add =~ /\\200/ or last;\n  $pile =~ tr/\\4-\\177/\\0-\\173/; \n  for (\"\\0$add\", \"\\0\" x $wide . $add, substr($add, 1), substr $add, $wide)\n    {\n    $pile |.= $_;\n    $pile =~ tr/\\200-\\377/\\1-\\176/; \n    $pile &.= $mask;\n    }\n  select undef, undef, undef, 0.1; \n  }\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AbelianSandpile {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                Frame frame = new Frame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class Frame extends JFrame {\n        private Frame() {\n            super(\"Abelian Sandpile Model\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            Container contentPane = getContentPane();\n            JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n            JButton start = new JButton(\"Restart Simulation\");\n            start.addActionListener(e -> restartSimulation());\n            JButton stop = new JButton(\"Stop Simulation\");\n            stop.addActionListener(e -> stopSimulation());\n            controlPanel.add(start);\n            controlPanel.add(stop);\n            contentPane.add(controlPanel, BorderLayout.NORTH);\n            contentPane.add(canvas = new Canvas(), BorderLayout.CENTER);\n            timer = new Timer(100, e -> canvas.runAndDraw());\n            timer.start();\n            pack();\n        }\n\n        private void restartSimulation() {\n            timer.stop();\n            canvas.initGrid();\n            timer.start();\n        }\n\n        private void stopSimulation() {\n            timer.stop();\n        }\n\n        private Timer timer;\n        private Canvas canvas;\n    }\n\n    private static class Canvas extends JComponent {\n        private Canvas() {\n            setBorder(BorderFactory.createEtchedBorder());\n            setPreferredSize(new Dimension(600, 600));\n        }\n\n        public void paintComponent(Graphics g) {\n            int width = getWidth();\n            int height = getHeight();\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, width, height);\n            int cellWidth = width/GRID_LENGTH;\n            int cellHeight = height/GRID_LENGTH;\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    if (grid[i][j] > 0) {\n                        g.setColor(COLORS[grid[i][j]]);\n                        g.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);\n                    }\n                }\n            }\n        }\n\n        private void initGrid() {\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    grid[i][j] = 0;\n                }\n            }\n        }\n\n        private void runAndDraw() {\n            for (int i = 0; i < 100; ++i)\n                addSand(GRID_LENGTH/2, GRID_LENGTH/2);\n            repaint();\n        }\n\n        private void addSand(int i, int j) {\n            int grains = grid[i][j];\n            if (grains < 3) {\n                grid[i][j]++;\n            }\n            else {\n                grid[i][j] = grains - 3;\n                if (i > 0)\n                    addSand(i - 1, j);\n                if (i < GRID_LENGTH - 1)\n                    addSand(i + 1, j);\n                if (j > 0)\n                    addSand(i, j - 1);\n                if (j < GRID_LENGTH - 1)\n                    addSand(i, j + 1);\n            }\n        }\n\n        private int[][] grid = new int[GRID_LENGTH][GRID_LENGTH];\n    }\n\n    private static final Color[] COLORS = {\n        Color.WHITE,\n        new Color(0x00, 0xbf, 0xff),\n        new Color(0xff, 0xd7, 0x00),\n        new Color(0xb0, 0x30, 0x60)\n    };\n    private static final int GRID_LENGTH = 300;\n}\n"}
{"id": 415541, "name": "Xiaolin Wu's line algorithm", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\n\nsub plot {\n\tmy ($x, $y, $c) = @_;\n\tprintf \"plot %d %d\u00a0%.1f\\n\", $x, $y, $c if $c;\n}\n\nsub ipart {\n\tint shift;\n}\n\nsub round {\n\tint( 0.5 + shift );\n}\n\nsub fpart {\n\tmy $x = shift;\n\t$x - int $x;\n}\n\nsub rfpart {\n\t1 - fpart(shift);\n}\n \nsub drawLine {\n\tmy ($x0, $y0, $x1, $y1) = @_;\n\n\tmy $plot = \\&plot;\n\n\tif( abs($y1 - $y0) > abs($x1 - $x0) ) {\n\t\t$plot = sub { plot( @_[1, 0, 2] ) };\n\t\t($x0, $y0, $x1, $y1) = ($y0, $x0, $y1, $x1);\n\t}\n\n\tif( $x0 > $x1 ) {\n\t\t($x0, $x1, $y0, $y1) = ($x1, $x0, $y1, $y0);\n\t}\n\n\tmy $dx = $x1 - $x0;\n\tmy $dy = $y1 - $y0;\n\tmy $gradient = $dy / $dx;\n\n\tmy @xends;\n\tmy $intery;\n\n\t\n\tfor my $xy ([$x0, $y0], [$x1, $y1]) {\n\t\tmy ($x, $y) = @$xy;\n\t\tmy $xend = round($x);\n\t\tmy $yend = $y + $gradient * ($xend - $x);\n\t\tmy $xgap = rfpart($x + 0.5);\n\n\t\tmy $x_pixel = $xend;\n\t\tmy $y_pixel = ipart($yend);\n\t\tpush @xends, $x_pixel;\n\n\t\t$plot->($x_pixel, $y_pixel  , rfpart($yend) * $xgap);\n\t\t$plot->($x_pixel, $y_pixel+1,  fpart($yend) * $xgap);\n\t\tnext if defined $intery;\n\t\t\n\t\t$intery = $yend + $gradient;\n\t}\n\n\t\n\n\tfor my $x ( $xends[0] + 1 .. $xends[1] - 1 ) {\n\t\t$plot->($x, ipart ($intery),  rfpart($intery));\n\t\t$plot->($x, ipart ($intery)+1, fpart($intery));\n\t\t$intery += $gradient;\n\t}\n}\n\nif( $0 eq __FILE__ ) {\n\tdrawLine( 0, 1, 10, 2 );\n}\n", "target": "import java.awt.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class XiaolinWu extends JPanel {\n\n    public XiaolinWu() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n    }\n\n    void plot(Graphics2D g, double x, double y, double c) {\n        g.setColor(new Color(0f, 0f, 0f, (float)c));\n        g.fillOval((int) x, (int) y, 2, 2);\n    }\n\n    int ipart(double x) {\n        return (int) x;\n    }\n\n    double fpart(double x) {\n        return x - floor(x);\n    }\n\n    double rfpart(double x) {\n        return 1.0 - fpart(x);\n    }\n\n    void drawLine(Graphics2D g, double x0, double y0, double x1, double y1) {\n\n        boolean steep = abs(y1 - y0) > abs(x1 - x0);\n        if (steep)\n            drawLine(g, y0, x0, y1, x1);\n\n        if (x0 > x1)\n            drawLine(g, x1, y1, x0, y0);\n\n        double dx = x1 - x0;\n        double dy = y1 - y0;\n        double gradient = dy / dx;\n\n        \n        double xend = round(x0);\n        double yend = y0 + gradient * (xend - x0);\n        double xgap = rfpart(x0 + 0.5);\n        double xpxl1 = xend; \n        double ypxl1 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl1, xpxl1, rfpart(yend) * xgap);\n            plot(g, ypxl1 + 1, xpxl1, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl1, ypxl1, rfpart(yend) * xgap);\n            plot(g, xpxl1, ypxl1 + 1, fpart(yend) * xgap);\n        }\n\n        \n        double intery = yend + gradient;\n\n        \n        xend = round(x1);\n        yend = y1 + gradient * (xend - x1);\n        xgap = fpart(x1 + 0.5);\n        double xpxl2 = xend; \n        double ypxl2 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl2, xpxl2, rfpart(yend) * xgap);\n            plot(g, ypxl2 + 1, xpxl2, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl2, ypxl2, rfpart(yend) * xgap);\n            plot(g, xpxl2, ypxl2 + 1, fpart(yend) * xgap);\n        }\n\n        \n        for (double x = xpxl1 + 1; x <= xpxl2 - 1; x++) {\n            if (steep) {\n                plot(g, ipart(intery), x, rfpart(intery));\n                plot(g, ipart(intery) + 1, x, fpart(intery));\n            } else {\n                plot(g, x, ipart(intery), rfpart(intery));\n                plot(g, x, ipart(intery) + 1, fpart(intery));\n            }\n            intery = intery + gradient;\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        drawLine(g, 550, 170, 50, 435);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Xiaolin Wu's line algorithm\");\n            f.setResizable(false);\n            f.add(new XiaolinWu(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415542, "name": "Next highest int from digits", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint;\nuse List::Util 'first';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub next_greatest_index {\n    my($str) = @_;\n    my @i = reverse split //, $str;\n    @i-1 - (1 + first { $i[$_] > $i[$_+1] } 0 .. @i-1);\n}\n\nsub next_greatest_integer {\n    my($num) = @_;\n    my $numr;\n    return 0 if length $num < 2;\n    return ($numr = 0 + reverse $num) > $num ? $numr : 0 if length $num == 2;\n    return 0 unless my $i = next_greatest_index( $num ) // 0;\n    my $digit = substr($num, $i, 1);\n    my @rest  = sort split '', substr($num, $i);\n    my $next  = first { $rest[$_] > $digit } 1..@rest;\n    join '', substr($num, 0, $i), (splice(@rest, $next, 1)), @rest;\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:';\n\nfor (0, 9, 12, 21, 12453, 738440, 45072010, 95322020, 9589776899767587796600, 3345333) {\n    printf \"%30s  ->  %s\\n\", comma($_), comma next_greatest_integer $_;\n}\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NextHighestIntFromDigits {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"0\", \"9\", \"12\", \"21\", \"12453\", \"738440\", \"45072010\", \"95322020\", \"9589776899767587796600\", \"3345333\"} ) {\n            System.out.printf(\"%s -> %s%n\", format(s), format(next(s)));\n        }\n        testAll(\"12345\");\n        testAll(\"11122\");\n    }\n\n    private static NumberFormat FORMAT = NumberFormat.getNumberInstance();\n    \n    private static String format(String s) {\n        return FORMAT.format(new BigInteger(s));\n    }\n\n    private static void testAll(String s) {\n        System.out.printf(\"Test all permutations of:  %s%n\", s);\n        String sOrig = s;\n        String sPrev = s;\n        int count = 1;\n        \n        \n        boolean orderOk = true;\n        Map <String,Integer> uniqueMap = new HashMap<>();\n        uniqueMap.put(s, 1);\n        while ( (s = next(s)).compareTo(\"0\") != 0 ) {\n            count++;\n            if ( Long.parseLong(s) < Long.parseLong(sPrev) ) {\n                orderOk = false;\n            }\n            uniqueMap.merge(s, 1, (v1, v2) -> v1 + v2);\n            sPrev = s;\n        }\n        System.out.printf(\"    Order:  OK =  %b%n\", orderOk);\n\n        \n        String reverse = new StringBuilder(sOrig).reverse().toString();\n        System.out.printf(\"    Last permutation:  Actual = %s, Expected = %s, OK = %b%n\", sPrev, reverse, sPrev.compareTo(reverse) == 0);\n\n        \n        boolean unique = true;\n        for ( String key : uniqueMap.keySet() ) {\n            if ( uniqueMap.get(key) > 1 ) {\n                unique = false;\n            }\n        }\n        System.out.printf(\"    Permutations unique:  OK =  %b%n\", unique);\n        \n        \n        Map<Character,Integer> charMap = new HashMap<>();\n        for ( char c : sOrig.toCharArray() ) {\n            charMap.merge(c, 1, (v1, v2) -> v1 + v2);\n        }\n        long permCount = factorial(sOrig.length());\n        for ( char c : charMap.keySet() ) {\n            permCount /= factorial(charMap.get(c));\n        }\n        System.out.printf(\"    Permutation count:  Actual = %d, Expected = %d, OK = %b%n\", count, permCount, count == permCount);\n        \n\n    }\n    \n    private static long factorial(long n) {\n        long fact = 1;\n        for (long num = 2 ; num <= n ; num++ ) {\n            fact *= num;\n        }\n        return fact;\n    }\n    \n    private static String next(String s) {\n        StringBuilder sb = new StringBuilder();\n        int index = s.length()-1;\n        \n        while ( index > 0 && s.charAt(index-1) >= s.charAt(index)) {\n            index--;\n        }\n        \n        if ( index == 0 ) {\n            return \"0\";\n        }\n\n        \n        int index2 = index;\n        for ( int i = index + 1 ; i < s.length() ; i++ ) {\n            if ( s.charAt(i) < s.charAt(index2) && s.charAt(i) > s.charAt(index-1) ) {\n                index2 = i;\n            }\n        }\n        \n        \n        \n        if ( index > 1 ) {\n            sb.append(s.subSequence(0, index-1));\n        }\n\n        \n        sb.append(s.charAt(index2));\n        \n        \n        List<Character> chars = new ArrayList<>();\n        chars.add(s.charAt(index-1));\n        for ( int i = index ; i < s.length() ; i++ ) {\n            if ( i != index2 ) {\n                chars.add(s.charAt(i));\n            }\n        }\n        \n        \n        Collections.sort(chars);\n        for ( char c : chars ) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 415543, "name": "Next highest int from digits", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint;\nuse List::Util 'first';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub next_greatest_index {\n    my($str) = @_;\n    my @i = reverse split //, $str;\n    @i-1 - (1 + first { $i[$_] > $i[$_+1] } 0 .. @i-1);\n}\n\nsub next_greatest_integer {\n    my($num) = @_;\n    my $numr;\n    return 0 if length $num < 2;\n    return ($numr = 0 + reverse $num) > $num ? $numr : 0 if length $num == 2;\n    return 0 unless my $i = next_greatest_index( $num ) // 0;\n    my $digit = substr($num, $i, 1);\n    my @rest  = sort split '', substr($num, $i);\n    my $next  = first { $rest[$_] > $digit } 1..@rest;\n    join '', substr($num, 0, $i), (splice(@rest, $next, 1)), @rest;\n}\n\nsay 'Next largest integer able to be made from these digits, or zero if no larger exists:';\n\nfor (0, 9, 12, 21, 12453, 738440, 45072010, 95322020, 9589776899767587796600, 3345333) {\n    printf \"%30s  ->  %s\\n\", comma($_), comma next_greatest_integer $_;\n}\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NextHighestIntFromDigits {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"0\", \"9\", \"12\", \"21\", \"12453\", \"738440\", \"45072010\", \"95322020\", \"9589776899767587796600\", \"3345333\"} ) {\n            System.out.printf(\"%s -> %s%n\", format(s), format(next(s)));\n        }\n        testAll(\"12345\");\n        testAll(\"11122\");\n    }\n\n    private static NumberFormat FORMAT = NumberFormat.getNumberInstance();\n    \n    private static String format(String s) {\n        return FORMAT.format(new BigInteger(s));\n    }\n\n    private static void testAll(String s) {\n        System.out.printf(\"Test all permutations of:  %s%n\", s);\n        String sOrig = s;\n        String sPrev = s;\n        int count = 1;\n        \n        \n        boolean orderOk = true;\n        Map <String,Integer> uniqueMap = new HashMap<>();\n        uniqueMap.put(s, 1);\n        while ( (s = next(s)).compareTo(\"0\") != 0 ) {\n            count++;\n            if ( Long.parseLong(s) < Long.parseLong(sPrev) ) {\n                orderOk = false;\n            }\n            uniqueMap.merge(s, 1, (v1, v2) -> v1 + v2);\n            sPrev = s;\n        }\n        System.out.printf(\"    Order:  OK =  %b%n\", orderOk);\n\n        \n        String reverse = new StringBuilder(sOrig).reverse().toString();\n        System.out.printf(\"    Last permutation:  Actual = %s, Expected = %s, OK = %b%n\", sPrev, reverse, sPrev.compareTo(reverse) == 0);\n\n        \n        boolean unique = true;\n        for ( String key : uniqueMap.keySet() ) {\n            if ( uniqueMap.get(key) > 1 ) {\n                unique = false;\n            }\n        }\n        System.out.printf(\"    Permutations unique:  OK =  %b%n\", unique);\n        \n        \n        Map<Character,Integer> charMap = new HashMap<>();\n        for ( char c : sOrig.toCharArray() ) {\n            charMap.merge(c, 1, (v1, v2) -> v1 + v2);\n        }\n        long permCount = factorial(sOrig.length());\n        for ( char c : charMap.keySet() ) {\n            permCount /= factorial(charMap.get(c));\n        }\n        System.out.printf(\"    Permutation count:  Actual = %d, Expected = %d, OK = %b%n\", count, permCount, count == permCount);\n        \n\n    }\n    \n    private static long factorial(long n) {\n        long fact = 1;\n        for (long num = 2 ; num <= n ; num++ ) {\n            fact *= num;\n        }\n        return fact;\n    }\n    \n    private static String next(String s) {\n        StringBuilder sb = new StringBuilder();\n        int index = s.length()-1;\n        \n        while ( index > 0 && s.charAt(index-1) >= s.charAt(index)) {\n            index--;\n        }\n        \n        if ( index == 0 ) {\n            return \"0\";\n        }\n\n        \n        int index2 = index;\n        for ( int i = index + 1 ; i < s.length() ; i++ ) {\n            if ( s.charAt(i) < s.charAt(index2) && s.charAt(i) > s.charAt(index-1) ) {\n                index2 = i;\n            }\n        }\n        \n        \n        \n        if ( index > 1 ) {\n            sb.append(s.subSequence(0, index-1));\n        }\n\n        \n        sb.append(s.charAt(index2));\n        \n        \n        List<Character> chars = new ArrayList<>();\n        chars.add(s.charAt(index-1));\n        for ( int i = index ; i < s.length() ; i++ ) {\n            if ( i != index2 ) {\n                chars.add(s.charAt(i));\n            }\n        }\n        \n        \n        Collections.sort(chars);\n        for ( char c : chars ) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 415544, "name": "Simulate input_Keyboard", "source": "Translate Perl to Java: $target = \"/dev/pts/51\"; \n\n$TIOCSTI = 0x5412 ; \nopen(TTY,\">$target\") or die \"cannot open $target\" ; \n$b=\"sleep 99334 &\\015\"; \n@c=split(\"\",$b); \nsleep(2); \nforeach $a ( @c ) { ioctl(TTY,$TIOCSTI,$a); select(undef,undef,undef,0.1);} ; \nprint \"DONE\\n\";\n", "target": "import java.awt.Robot\npublic static void type(String str){\n   Robot robot = new Robot();\n   for(char ch:str.toCharArray()){\n      if(Character.isUpperCase(ch)){\n         robot.keyPress(KeyEvent.VK_SHIFT);\n         robot.keyPress((int)ch);\n         robot.keyRelease((int)ch);\n         robot.keyRelease(KeyEvent.VK_SHIFT);\n      }else{\n         char upCh = Character.toUpperCase(ch);\n         robot.keyPress((int)upCh);\n         robot.keyRelease((int)upCh);\n      }\n   }\n}\n"}
{"id": 415545, "name": "Four is magic", "source": "Translate Perl to Java: use Lingua::EN::Numbers qw(num2en);\n\nsub cardinal {\n    my($n) = @_;\n    (my $en = num2en($n)) =~ s/\\ and|,//g;\n    $en;\n}\n\nsub magic {\n    my($int) = @_;\n    my $str;\n    while () {\n       $str .= cardinal($int) . \" is \";\n       if ($int == 4) {\n           $str .= \"magic.\\n\";\n           last\n       } else {\n           $int = length cardinal($int);\n           $str .= cardinal($int) . \", \";\n       }\n   }\n   ucfirst $str;\n}\n\nprint magic($_) for 0, 4, 6, 11, 13, 75, 337, -164, 9_876_543_209;\n", "target": "public class FourIsMagic {\n\n    public static void main(String[] args) {\n        for ( long n : new long[] {6, 60, 89, 300, 670, 2000, 2467, 20000, 24500,200000, 230000, 246571, 2300000, 2465712, 20000000, 24657123, 230000000, 245000000, -246570000, 123456789712345l, 8777777777777777777L, Long.MAX_VALUE}) {\n            String magic = fourIsMagic(n);\n            System.out.printf(\"%d = %s%n\", n, toSentence(magic));\n        }\n    }\n    \n    private static final String toSentence(String s) {\n        return s.substring(0,1).toUpperCase() + s.substring(1) + \".\";\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String fourIsMagic(long n) {\n        if ( n == 4 ) {\n            return numToString(n) + \" is magic\";\n        }\n        String result = numToString(n);\n        return result + \" is \" + numToString(result.length()) + \", \" + fourIsMagic(result.length());\n    }\n    \n    private static final String numToString(long n) {\n        if ( n < 0 ) { \n            return \"negative \" + numToString(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \" \" + numToString(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToString(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToString(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 415546, "name": "Sierpinski pentagon", "source": "Translate Perl to Java: use ntheory qw(todigits);\nuse Math::Complex;\n\n$sides = 5;\n$order = 5;\n$dim   = 250;\n$scale = ( 3 - 5**.5 ) / 2;\npush @orders, ((1 - $scale) * $dim) * $scale ** $_ for 0..$order-1;\n\nopen $fh, '>', 'sierpinski_pentagon.svg';\nprint $fh qq|<svg height=\"@{[$dim*2]}\" width=\"@{[$dim*2]}\" style=\"fill:blue\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\">\\n|;\n\n$tau = 2 * 4*atan2(1, 1);\npush @vertices, cis( $_ * $tau / $sides ) for 0..$sides-1;\n\nfor $i (0 .. -1+$sides**$order)  {\n    @base5 = todigits($i,5);\n    @i = ( ((0)x(-1+$sides-$\n    @v = @vertices[@i];\n    $vector = 0;\n    $vector += $v[$_] * $orders[$_] for 0..$\n\n    my @points;\n    for (@vertices) {\n        $v = $vector + $orders[-1] * (1 - $scale) * $_;\n        push @points, sprintf '%.3f\u00a0%.3f', $v->Re, $v->Im;\n    }\n    print $fh pgon(@points);\n}\n\nsub cis  { Math::Complex->make(cos($_[0]), sin($_[0])) }\nsub pgon { my(@q)=@_; qq|<polygon points=\"@q\" transform=\"translate($dim,$dim) rotate(-18)\"/>\\n| }\n\nprint $fh '</svg>';\nclose $fh;\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.geom.Path2D;\nimport static java.lang.Math.*;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class SierpinskiPentagon extends JPanel {\n    \n    final double degrees072 = toRadians(72);\n\n    \n    final double scaleFactor = 1 / (2 + cos(degrees072) * 2);\n\n    final int margin = 20;\n    int limit = 0;\n    Random r = new Random();\n\n    public SierpinskiPentagon() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        new Timer(3000, (ActionEvent e) -> {\n            limit++;\n            if (limit >= 5)\n                limit = 0;\n            repaint();\n        }).start();\n    }\n\n    void drawPentagon(Graphics2D g, double x, double y, double side, int depth) {\n        double angle = 3 * degrees072; \n\n        if (depth == 0) {\n\n            Path2D p = new Path2D.Double();\n            p.moveTo(x, y);\n\n            \n            for (int i = 0; i < 5; i++) {\n                x = x + cos(angle) * side;\n                y = y - sin(angle) * side;\n                p.lineTo(x, y);\n                angle += degrees072;\n            }\n\n            g.setColor(RandomHue.next());\n            g.fill(p);\n\n        } else {\n\n            side *= scaleFactor;\n\n            \n            double distance = side + side * cos(degrees072) * 2;\n\n            \n            for (int i = 0; i < 5; i++) {\n                x = x + cos(angle) * distance;\n                y = y - sin(angle) * distance;\n                drawPentagon(g, x, y, side, depth - 1);\n                angle += degrees072;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        int w = getWidth();\n        double radius = w / 2 - 2 * margin;\n        double side = radius * sin(PI / 5) * 2;\n\n        drawPentagon(g, w / 2, 3 * margin, side, limit);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Sierpinski Pentagon\");\n            f.setResizable(true);\n            f.add(new SierpinskiPentagon(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n\nclass RandomHue {\n    \n    final static double goldenRatioConjugate = (sqrt(5) - 1) / 2;\n    private static double hue = Math.random();\n\n    static Color next() {\n        hue = (hue + goldenRatioConjugate) % 1;\n        return Color.getHSBColor((float) hue, 1, 1);\n    }\n}\n"}
{"id": 415547, "name": "Zhang-Suen thinning algorithm", "source": "Translate Perl to Java: use v5.36.0;\nno warnings 'uninitialized';\nuse List::Util qw(sum min);\n\n$source = <<'END';\n............................................................\n..\n..\n..\n..\n....\n....\n....\n....\n....\n....\n....\n....\n..\n..\n..\n..\n............................................................\nEND\n\nfor $line (split \"\\n\", $source) {\n    push @lines, [map { 1 & ord $_ } split '', $line]\n}\n\n$v = @lines;\n$h = @{$lines[0]};\npush @black, @$_ for @lines;\n@p8 = ((-$h-1), (-$h+0), (-$h+1),                    \n          0-1,              0+1,\n         $h-1,    $h+0,    $h+1)[1,2,4,7,6,5,3,0];   \n\n\n@cand = grep { $black[$_] } map { my $x = $_; map $_*$h + $x, 1..$v-2 } 1..$h-2;\n\ndo {\n    sub seewhite ($w1,$w2) {\n        my @results;\n        sub cycles (@neighbors) { my $c; $c += $neighbors[$_] < $neighbors[($_+1)%8] for 0..$\n        sub blacks (@neighbors) { sum @neighbors }\n        @prior = @cand; @cand = ();\n        for $p (@prior) {\n            @n = @black[map { $_+$p } @p8];\n            if (cycles(@n) == 1 and 2 <= sum(blacks(@n)) and sum(blacks(@n)) <= 6 and min(@n[@$w1]) == 0 and min(@n[@$w2]) == 0) {\n                push @results, $p;\n            } else {\n                push @cand, $p\n            }\n        }\n        @results\n    }\n\n    @goners1 = seewhite [0,2,4], [2,4,6]; @black[@goners1] = 0 x @goners1;\n    @goners2 = seewhite [0,2,6], [0,4,6]; @black[@goners2] = 0 x @goners2;\n} while @goners1 or @goners2;\n\nwhile (@black) { push @thinned, join '', qw<. \n\nsay join \"\\n\", @thinned;\n", "target": "import java.awt.Point;\nimport java.util.*;\n\npublic class ZhangSuen {\n\n    final static String[] image = {\n        \"                                                          \",\n        \" #################                   #############        \",\n        \" ##################               ################        \",\n        \" ###################            ##################        \",\n        \" ########     #######          ###################        \",\n        \"   ######     #######         #######       ######        \",\n        \"   ######     #######        #######                      \",\n        \"   #################         #######                      \",\n        \"   ################          #######                      \",\n        \"   #################         #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######         #######       ######        \",\n        \" ########     #######          ###################        \",\n        \" ########     ####### ######    ################## ###### \",\n        \" ########     ####### ######      ################ ###### \",\n        \" ########     ####### ######         ############# ###### \",\n        \"                                                          \"};\n\n    final static int[][] nbrs = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1},\n        {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\n    final static int[][][] nbrGroups = {{{0, 2, 4}, {2, 4, 6}}, {{0, 2, 6},\n        {0, 4, 6}}};\n\n    static List<Point> toWhite = new ArrayList<>();\n    static char[][] grid;\n\n    public static void main(String[] args) {\n        grid = new char[image.length][];\n        for (int r = 0; r < image.length; r++)\n            grid[r] = image[r].toCharArray();\n\n        thinImage();\n    }\n\n    static void thinImage() {\n        boolean firstStep = false;\n        boolean hasChanged;\n\n        do {\n            hasChanged = false;\n            firstStep = !firstStep;\n\n            for (int r = 1; r < grid.length - 1; r++) {\n                for (int c = 1; c < grid[0].length - 1; c++) {\n\n                    if (grid[r][c] != '#')\n                        continue;\n\n                    int nn = numNeighbors(r, c);\n                    if (nn < 2 || nn > 6)\n                        continue;\n\n                    if (numTransitions(r, c) != 1)\n                        continue;\n\n                    if (!atLeastOneIsWhite(r, c, firstStep ? 0 : 1))\n                        continue;\n\n                    toWhite.add(new Point(c, r));\n                    hasChanged = true;\n                }\n            }\n\n            for (Point p : toWhite)\n                grid[p.y][p.x] = ' ';\n            toWhite.clear();\n\n        } while (firstStep || hasChanged);\n\n        printResult();\n    }\n\n    static int numNeighbors(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == '#')\n                count++;\n        return count;\n    }\n\n    static int numTransitions(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == ' ') {\n                if (grid[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == '#')\n                    count++;\n            }\n        return count;\n    }\n\n    static boolean atLeastOneIsWhite(int r, int c, int step) {\n        int count = 0;\n        int[][] group = nbrGroups[step];\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < group[i].length; j++) {\n                int[] nbr = nbrs[group[i][j]];\n                if (grid[r + nbr[1]][c + nbr[0]] == ' ') {\n                    count++;\n                    break;\n                }\n            }\n        return count > 1;\n    }\n\n    static void printResult() {\n        for (char[] row : grid)\n            System.out.println(row);\n    }\n}\n"}
{"id": 415548, "name": "Generate Chess960 starting position", "source": "Translate Perl to Java: sub rnd($) { int(rand(shift)) }\n\nsub empties { grep !$_[0][$_], 0 .. 7 }\n\nsub chess960 {\n\tmy @s = (undef) x 8;\n\t@s[2*rnd(4), 1 + 2*rnd(4)] = qw/B B/;\n\n\tfor (qw/Q N N/) {\n\t\tmy @idx = empties \\@s;\n\t\t$s[$idx[rnd(@idx)]] = $_;\n\t}\n\n\t@s[empties \\@s] = qw/R K R/;\n\t@s\n}\nprint \"@{[chess960]}\\n\" for 0 .. 10;\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Chess960{\n\tprivate static List<Character> pieces = Arrays.asList('R','B','N','Q','K','N','B','R');\n\n\tpublic static List<Character> generateFirstRank(){\n\t\tdo{\n\t\t\tCollections.shuffle(pieces);\n\t\t}while(!check(pieces.toString().replaceAll(\"[^\\\\p{Upper}]\", \"\"))); \n\t\t\n\t\treturn pieces;\n\t}\n\n\tprivate static boolean check(String rank){\n\t\tif(!rank.matches(\".*R.*K.*R.*\")) return false;\t\t\t\n\t\tif(!rank.matches(\".*B(..|....|......|)B.*\")) return false;\t\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(generateFirstRank());\n\t\t}\n\t}\n}\n"}
{"id": 415549, "name": "UPC", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub decode_UPC {\n    my($line) = @_;\n    my(%pattern_to_digit_1,%pattern_to_digit_2,@patterns1,@patterns2,@digits,$sum);\n\n    for my $p ('   \n        push @patterns1, $p;\n        push @patterns2, $p =~ tr/\n    }\n\n    $pattern_to_digit_1{$patterns1[$_]} = $_ for 0..$\n    $pattern_to_digit_2{$patterns2[$_]} = $_ for 0..$\n\n     my $re = '\\s*\n              \"(?<match1>(?:@{[join '|', @patterns1]}){6})\" .\n              '\\s*\n              \"(?<match2>(?:@{[join '|', @patterns2]}){6})\" .\n              '\\s*\n     $line =~ /^$re$/g || return;\n\n    my($match1,$match2) = ($+{match1}, $+{match2});\n    push @digits, $pattern_to_digit_1{$_} for $match1 =~ /(.{7})/g;\n    push @digits, $pattern_to_digit_2{$_} for $match2 =~ /(.{7})/g;\n    $sum += (3,1)[$_%2] * $digits[$_] for 0..11;\n    $sum % 10 ? '' : join '', @digits;\n}\n\nmy @lines = (\n    '         \n     '        \n    '         \n      '       \n    '         \n   '          \n    '         \n     '        \n    '         \n     '        \n);\n\nfor my $line (@lines) {\n    say decode_UPC($line)\n     // decode_UPC(join '', reverse split '', $line)\n     // 'Invalid';\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\npublic class UPC {\n    private static final int SEVEN = 7;\n\n    private static final Map<String, Integer> LEFT_DIGITS = Map.of(\n        \"   ## #\", 0,\n        \"  ##  #\", 1,\n        \"  #  ##\", 2,\n        \" #### #\", 3,\n        \" #   ##\", 4,\n        \" ##   #\", 5,\n        \" # ####\", 6,\n        \" ### ##\", 7,\n        \" ## ###\", 8,\n        \"   # ##\", 9\n    );\n\n    private static final Map<String, Integer> RIGHT_DIGITS = LEFT_DIGITS.entrySet()\n        .stream()\n        .collect(Collectors.toMap(\n            entry -> entry.getKey()\n                .replace(' ', 's')\n                .replace('#', ' ')\n                .replace('s', '#'),\n            Map.Entry::getValue\n        ));\n\n    private static final String END_SENTINEL = \"# #\";\n    private static final String MID_SENTINEL = \" # # \";\n\n    private static void decodeUPC(String input) {\n        Function<String, Map.Entry<Boolean, List<Integer>>> decode = (String candidate) -> {\n            int pos = 0;\n            var part = candidate.substring(pos, pos + END_SENTINEL.length());\n\n            List<Integer> output = new ArrayList<>();\n            if (END_SENTINEL.equals(part)) {\n                pos += END_SENTINEL.length();\n            } else {\n                return Map.entry(false, output);\n            }\n\n            for (int i = 1; i < SEVEN; i++) {\n                part = candidate.substring(pos, pos + SEVEN);\n                pos += SEVEN;\n\n                if (LEFT_DIGITS.containsKey(part)) {\n                    output.add(LEFT_DIGITS.get(part));\n                } else {\n                    return Map.entry(false, output);\n                }\n            }\n\n            part = candidate.substring(pos, pos + MID_SENTINEL.length());\n            if (MID_SENTINEL.equals(part)) {\n                pos += MID_SENTINEL.length();\n            } else {\n                return Map.entry(false, output);\n            }\n\n            for (int i = 1; i < SEVEN; i++) {\n                part = candidate.substring(pos, pos + SEVEN);\n                pos += SEVEN;\n\n                if (RIGHT_DIGITS.containsKey(part)) {\n                    output.add(RIGHT_DIGITS.get(part));\n                } else {\n                    return Map.entry(false, output);\n                }\n            }\n\n            part = candidate.substring(pos, pos + END_SENTINEL.length());\n            if (!END_SENTINEL.equals(part)) {\n                return Map.entry(false, output);\n            }\n\n            int sum = 0;\n            for (int i = 0; i < output.size(); i++) {\n                if (i % 2 == 0) {\n                    sum += 3 * output.get(i);\n                } else {\n                    sum += output.get(i);\n                }\n            }\n            return Map.entry(sum % 10 == 0, output);\n        };\n\n        Consumer<List<Integer>> printList = list -> {\n            var it = list.iterator();\n            System.out.print('[');\n            if (it.hasNext()) {\n                System.out.print(it.next());\n            }\n            while (it.hasNext()) {\n                System.out.print(\", \");\n                System.out.print(it.next());\n            }\n            System.out.print(']');\n        };\n\n        var candidate = input.trim();\n        var out = decode.apply(candidate);\n        if (out.getKey()) {\n            printList.accept(out.getValue());\n            System.out.println();\n        } else {\n            StringBuilder builder = new StringBuilder(candidate);\n            builder.reverse();\n            out = decode.apply(builder.toString());\n            if (out.getKey()) {\n                printList.accept(out.getValue());\n                System.out.println(\" Upside down\");\n            } else if (out.getValue().size() == 12) {\n                System.out.println(\"Invalid checksum\");\n            } else {\n                System.out.println(\"Invalid digit(s)\");\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        var barcodes = List.of(\n            \"         # #   # ##  #  ## #   ## ### ## ### ## #### # # # ## ##  #   #  ##  ## ###  # ##  ## ### #  # #       \",\n            \"        # # #   ##   ## # #### #   # ## #   ## #   ## # # # ###  # ###  ##  ## ###  # #  ### ###  # # #         \",\n            \"         # #    # # #  ###  #   #    # #  #   #    # # # # ## #   ## #   ## #   ##   # # #### ### ## # #         \",\n            \"       # # ##  ## ##  ##   #  #   #  # ###  # ##  ## # # #   ## ##  #  ### ## ## #   # #### ## #   # #        \",\n            \"         # # ### ## #   ## ## ###  ##  # ##   #   # ## # # ### #  ## ##  #    # ### #  ## ##  #      # #          \",\n            \"          # #  #   # ##  ##  #   #   #  # ##  ##  #   # # # # #### #  ##  # #### #### # #  ##  # #### # #         \",\n            \"         # #  #  ##  ##  # #   ## ##   # ### ## ##   # # # #  #   #   #  #  ### # #    ###  # #  #   # #        \",\n            \"        # # #    # ##  ##   #  # ##  ##  ### #   #  # # # ### ## ## ### ## ### ### ## #  ##  ### ## # #         \",\n            \"         # # ### ##   ## # # #### #   ## # #### # #### # # #   #  # ###  #    # ###  # #    # ###  # # #       \",\n            \"        # # # #### ##   # #### # #   ## ## ### #### # # # #  ### # ###  ###  # # ###  #    # #  ### # #         \"\n        );\n        barcodes.forEach(UPC::decodeUPC);\n    }\n}\n"}
{"id": 415550, "name": "Write to Windows event log", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse Win32::EventLog;\nmy $handle = Win32::EventLog->new(\"Application\");\n\nmy $event = {\n\tComputer \t=>\t$ENV{COMPUTERNAME},\n\tSource\t\t=> \t'Rosettacode',\n\tEventType \t=> \tEVENTLOG_INFORMATION_TYPE,\n\tCategory  \t=> \t'test',\n\tEventID \t=> \t0,\n\tData \t\t=> \t'a test for rosettacode',\n\tStrings \t=> \t'a string test for rosettacode',\n};\n$handle->Report($event);\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.Locale;\nimport java.util.concurrent.TimeUnit;\nimport java.util.stream.Collectors;\n\npublic class WriteToWindowsEventLog {\n    public static void main(String[] args) throws IOException, InterruptedException {\n        String osName = System.getProperty(\"os.name\").toUpperCase(Locale.ENGLISH);\n        if (!osName.startsWith(\"WINDOWS\")) {\n            System.err.println(\"Not windows\");\n            return;\n        }\n\n        Process process = Runtime.getRuntime().exec(\"EventCreate /t INFORMATION /id 123 /l APPLICATION /so Java /d \\\"Rosetta Code Example\\\"\");\n        process.waitFor(10, TimeUnit.SECONDS);\n        int exitValue = process.exitValue();\n        System.out.printf(\"Process exited with value %d\\n\", exitValue);\n        if (exitValue != 0) {\n            InputStream errorStream = process.getErrorStream();\n            String result = new BufferedReader(new InputStreamReader(errorStream))\n                .lines()\n                .collect(Collectors.joining(\"\\n\"));\n            System.err.println(result);\n        }\n    }\n}\n"}
{"id": 415551, "name": "Spelling of ordinal numbers", "source": "Translate Perl to Java: use Lingua::EN::Numbers 'num2en_ordinal';\n\nprintf \"%16s\u00a0: %s\\n\", $_, num2en_ordinal(0+$_) for\n    <1 2 3 4 5 11 65 100 101 272 23456 8007006005004003 123 00123.0 '00123.0' 1.23e2 '1.23e2'>;\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SpellingOfOrdinalNumbers {\n\n    public static void main(String[] args) {\n        for ( long test : new long[] {1,  2,  3,  4,  5,  11,  65,  100,  101,  272,  23456,  8007006005004003L} ) {\n            System.out.printf(\"%d = %s%n\", test, toOrdinal(test));\n        }\n    }\n\n    private static Map<String,String> ordinalMap = new HashMap<>();\n    static {\n        ordinalMap.put(\"one\", \"first\");\n        ordinalMap.put(\"two\", \"second\");\n        ordinalMap.put(\"three\", \"third\");\n        ordinalMap.put(\"five\", \"fifth\");\n        ordinalMap.put(\"eight\", \"eighth\");\n        ordinalMap.put(\"nine\", \"ninth\");\n        ordinalMap.put(\"twelve\", \"twelfth\");\n    }\n    \n    private static String toOrdinal(long n) {\n        String spelling = numToString(n);\n        String[] split = spelling.split(\" \");\n        String last = split[split.length - 1];\n        String replace = \"\";\n        if ( last.contains(\"-\") ) {\n            String[] lastSplit = last.split(\"-\");\n            String lastWithDash = lastSplit[1];\n            String lastReplace = \"\";\n            if ( ordinalMap.containsKey(lastWithDash) ) {\n                lastReplace = ordinalMap.get(lastWithDash);\n            }\n            else if ( lastWithDash.endsWith(\"y\") ) {\n                lastReplace = lastWithDash.substring(0, lastWithDash.length() - 1) + \"ieth\";\n            }\n            else {\n                lastReplace = lastWithDash + \"th\";\n            }\n            replace = lastSplit[0] + \"-\" + lastReplace;\n        }\n        else {\n            if ( ordinalMap.containsKey(last) ) {\n                replace = ordinalMap.get(last);\n            }\n            else if ( last.endsWith(\"y\") ) {\n                replace = last.substring(0, last.length() - 1) + \"ieth\";\n            }\n            else {\n                replace = last + \"th\";\n            }\n        }\n        split[split.length - 1] = replace;\n        return String.join(\" \", split);\n    }\n\n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String numToString(long n) {\n        return numToStringHelper(n);\n    }\n    \n    private static final String numToStringHelper(long n) {\n        if ( n < 0 ) {\n            return \"negative \" + numToStringHelper(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \"-\" + numToStringHelper(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToStringHelper(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToStringHelper(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 415552, "name": "Parse an IP Address", "source": "Translate Perl to Java: sub parse_v4 {\n    my ($ip, $port) = @_;\n    my @quad = split(/\\./, $ip);\n\n    return unless @quad == 4;\n    for (@quad) { return if ($_ > 255) }\n\n    if (!length $port) { $port = -1 }\n    elsif ($port =~ /^(\\d+)$/) { $port = $1 }\n    else { return }\n\n    my $h = join '' => map(sprintf(\"%02x\", $_), @quad);\n    return $h, $port\n}\n\nsub parse_v6 {\n    my $ip = shift;\n    my $omits;\n\n    return unless $ip =~ /^[\\da-f:.]+$/i; \n\n    $ip =~ s/^:/0:/;\n    $omits = 1 if $ip =~ s/::/:z:/g;\n    return if $ip =~ /z.*z/;    \n\n    my $v4 = '';\n    my $len = 8;\n\n    if ($ip =~ s/:((?:\\d+\\.){3}\\d+)$//) {\n        \n        ($v4) = parse_v4($1)    or return;\n        $len -= 2;\n\n    }\n    \n    return unless $ip =~ /^[:a-fz\\d]+$/i;\n\n    my @h = split(/:/, $ip);\n    return if @h + $omits > $len;   \n\n    @h = map( $_ eq 'z' ? (0) x ($len - @h + 1) : ($_), @h);\n    return join('' => map(sprintf(\"%04x\", hex($_)), @h)).$v4;\n}\n\nsub parse_ip {\n    my $str = shift;\n    $str =~ s/^\\s*//;\n    $str =~ s/\\s*$//;\n\n    if ($str =~ s/^((?:\\d+\\.)+\\d+)(?::(\\d+))?$//) {\n        return 'v4', parse_v4($1, $2);\n    }\n\n    my ($ip, $port);\n    if ($str =~ /^\\[(.*?)\\]:(\\d+)$/) {\n        $port = $2;\n        $ip = parse_v6($1);\n    } else {\n        $port = -1;\n        $ip = parse_v6($str);\n    }\n\n    return unless $ip;\n    return 'v6', $ip, $port;\n}\n\nfor (qw/127.0.0.1 127.0.0.1:80\n   \u00a0::1\n    [::1]:80\n    2605:2700:0:3::4713:93e3\n    [2605:2700:0:3::4713:93e3]:80\n   \u00a0::ffff:192.168.0.1\n    [::ffff:192.168.0.1]:22\n   \u00a0::ffff:127.0.0.0.1\n    a::b::1/)\n{\n    print \"$_\\n\\t\";\n    my ($ver, $ip, $port) = parse_ip($_)\n        or print \"parse error\\n\" and next;\n\n    print \"$ver $ip\\tport $port\\n\\n\";\n}\n", "target": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ParseIPAddress {\n\n    public static void main(String[] args) {\n        String [] tests = new String[] {\"192.168.0.1\", \"127.0.0.1\", \"256.0.0.1\", \"127.0.0.1:80\", \"::1\", \"[::1]:80\", \"[32e::12f]:80\", \"2605:2700:0:3::4713:93e3\", \"[2605:2700:0:3::4713:93e3]:80\", \"2001:db8:85a3:0:0:8a2e:370:7334\"};\n        System.out.printf(\"%-40s\u00a0%-32s   %s%n\", \"Test Case\", \"Hex Address\", \"Port\");\n        for ( String ip : tests ) {\n            try {\n                String [] parsed = parseIP(ip);\n                System.out.printf(\"%-40s\u00a0%-32s   %s%n\", ip, parsed[0], parsed[1]);\n            }\n            catch (IllegalArgumentException e) {\n                System.out.printf(\"%-40s Invalid address:  %s%n\", ip, e.getMessage());\n            }\n        }\n    }\n    \n    private static final Pattern IPV4_PAT = Pattern.compile(\"^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)(?::(\\\\d+)){0,1}$\");\n    private static final Pattern IPV6_DOUBL_COL_PAT = Pattern.compile(\"^\\\\[{0,1}([0-9a-f:]*)::([0-9a-f:]*)(?:\\\\]:(\\\\d+)){0,1}$\");\n    private static String ipv6Pattern;\n    static {\n        ipv6Pattern = \"^\\\\[{0,1}\";\n        for ( int i = 1 ; i <= 7 ; i ++ ) {\n            ipv6Pattern += \"([0-9a-f]+):\";\n        }\n        ipv6Pattern += \"([0-9a-f]+)(?:\\\\]:(\\\\d+)){0,1}$\";\n    }\n    private static final Pattern IPV6_PAT = Pattern.compile(ipv6Pattern);\n    \n    private static String[] parseIP(String ip) {\n        String hex = \"\";\n        String port = \"\";\n        \n        \n        Matcher ipv4Matcher = IPV4_PAT.matcher(ip);\n        if ( ipv4Matcher.matches() ) {\n            for ( int i = 1 ; i <= 4 ; i++ ) {\n                hex += toHex4(ipv4Matcher.group(i));\n            }\n            if ( ipv4Matcher.group(5) != null ) {\n                port = ipv4Matcher.group(5);\n            }\n            return new String[] {hex, port};\n        }\n        \n        \n        Matcher ipv6DoubleColonMatcher = IPV6_DOUBL_COL_PAT.matcher(ip);\n        if ( ipv6DoubleColonMatcher.matches() ) {\n            String p1 = ipv6DoubleColonMatcher.group(1);\n            if ( p1.isEmpty() ) {\n                p1 = \"0\";\n            }\n            String p2 = ipv6DoubleColonMatcher.group(2);\n            if ( p2.isEmpty() ) {\n                p2 = \"0\";\n            }\n            ip =  p1 + getZero(8 - numCount(p1) - numCount(p2)) + p2;\n            if ( ipv6DoubleColonMatcher.group(3) != null ) {\n                ip = \"[\" + ip + \"]:\" + ipv6DoubleColonMatcher.group(3);\n            }\n        }\n        \n        \n        Matcher ipv6Matcher = IPV6_PAT.matcher(ip);\n        if ( ipv6Matcher.matches() ) {\n            for ( int i = 1 ; i <= 8 ; i++ ) {\n                hex += String.format(\"%4s\", toHex6(ipv6Matcher.group(i))).replace(\" \", \"0\");\n            }\n            if ( ipv6Matcher.group(9) != null ) {\n                port = ipv6Matcher.group(9);\n            }\n            return new String[] {hex, port};\n        }\n        \n        throw new IllegalArgumentException(\"ERROR 103: Unknown address: \" + ip);\n    }\n    \n    private static int numCount(String s) {\n        return s.split(\":\").length;\n    }\n    \n    private static String getZero(int count) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\":\");\n        while ( count > 0 ) {\n            sb.append(\"0:\");\n            count--;\n        }\n        return sb.toString();\n    }\n\n    private static String toHex4(String s) {\n        int val = Integer.parseInt(s);\n        if ( val < 0 || val > 255 ) {\n            throw new IllegalArgumentException(\"ERROR 101:  Invalid value\u00a0: \" + s);\n        }\n        return String.format(\"%2s\", Integer.toHexString(val)).replace(\" \", \"0\");\n    }\n\n    private static String toHex6(String s) {\n        int val = Integer.parseInt(s, 16);\n        if ( val < 0 || val > 65536 ) {\n            throw new IllegalArgumentException(\"ERROR 102:  Invalid hex value\u00a0: \" + s);\n        }\n        return s;\n    }\n\n}\n"}
{"id": 415553, "name": "Line circle intersection", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\n\nsub find_intersection {\n   my($P1, $P2, $center, $radius) = @_;\n   my @d = ($$P2[0] -     $$P1[0], $$P2[1] -     $$P1[1]);\n   my @f = ($$P1[0] - $$center[0], $$P1[1] - $$center[1]);\n   my $a = sum map { $_**2 } @d;\n   my $b = 2 * ($f[0]*$d[0] + $f[1]*$d[1]);\n   my $c = sum(map { $_**2 } @f) - $radius**2;\n   my $D =  $b**2 - 4*$a*$c;\n\n   return unless $D >= 0;\n   my ($t1, $t2) = ( (-$b - sqrt $D) / (2*$a), (-$b + sqrt $D) / (2*$a) );\n   return unless $t1 >= 0 and $t1 <= 1 or $t2 >= 0 and $t2  <= 1;\n\n   my ($dx, $dy) = ($$P2[0] - $$P1[0], $$P2[1] - $$P1[1]);\n   return ([$dx*$t1 + $$P1[0], $dy*$t1 + $$P1[1]],\n           [$dx*$t2 + $$P1[0], $dy*$t2 + $$P1[1]])\n}\n\nmy @data = (\n   [ [-10, 11], [ 10, -9], [3, -5], 3 ],\n   [ [-10, 11], [-11, 12], [3, -5], 3 ],\n   [ [  3, -2], [  7, -2], [3, -5], 3 ],\n   [ [  3, -2], [  7, -2], [0,  0], 4 ],\n   [ [  0, -3], [  0,  6], [0,  0], 4 ],\n   [ [  6,  3], [ 10,  7], [4,  2], 5 ],\n   [ [  7,  4], [ 11, 18], [4,  2], 5 ],\n);\n\nsub rnd { map { sprintf('%.2f', $_) =~ s/\\.00//r } @_ }\n\nfor my $d (@data) {\n   my @solution = find_intersection @$d[0] , @$d[1] , @$d[2], @$d[3];\n   say 'For input: ' . join ', ', (map { '('. join(',', @$_) .')' } @$d[0,1,2]), @$d[3];\n   say 'Solutions: ' . (@solution > 1 ? join ', ', map { '('. join(',', rnd @$_) .')' } @solution : 'None');\n   say '';\n}\n", "target": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class LineCircleIntersection {\n    public static void main(String[] args) {\n        try {\n            demo();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void demo() throws NoninvertibleTransformException {\n        Point2D center = makePoint(3, -5);\n        double radius = 3.0;\n        System.out.println(\"The intersection points (if any) between:\");\n        System.out.println(\"\\n  A circle, center (3, -5) with radius 3, and:\");\n        System.out.println(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(10, -9),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(-11, 12),\n                            center, radius, true)));\n        System.out.println(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(3, -2), makePoint(7, -2), center, radius, false)));\n        center.setLocation(0, 0);\n        radius = 4.0;\n        System.out.println(\"\\n  A circle, center (0, 0) with radius 4, and:\");\n        System.out.println(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, false)));\n        System.out.println(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, true)));\n        center.setLocation(4, 2);\n        radius = 5.0;\n        System.out.println(\"\\n  A circle, center (4, 2) with radius 5, and:\");\n        System.out.println(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(6, 3), makePoint(10, 7),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(7, 4), makePoint(11, 8),\n                            center, radius, true)));\n    }\n\n    private static Point2D makePoint(double x, double y) {\n        return new Point2D.Double(x, y);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static List<Point2D> intersection(Point2D p1, Point2D p2, Point2D center,\n            double radius, boolean isSegment) throws NoninvertibleTransformException {\n        List<Point2D> result = new ArrayList<>();\n        double dx = p2.getX() - p1.getX();\n        double dy = p2.getY() - p1.getY();\n        AffineTransform trans = AffineTransform.getRotateInstance(dx, dy);\n        trans.invert();\n        trans.translate(-center.getX(), -center.getY());\n        Point2D p1a = trans.transform(p1, null);\n        Point2D p2a = trans.transform(p2, null);\n        double y = p1a.getY();\n        double minX = Math.min(p1a.getX(), p2a.getX());\n        double maxX = Math.max(p1a.getX(), p2a.getX());\n        if (y == radius || y == -radius) {\n            if (!isSegment || (0 <= maxX && 0 >= minX)) {\n                p1a.setLocation(0, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n        } else if (y < radius && y > -radius) {\n            double x = Math.sqrt(radius * radius - y * y);\n            if (!isSegment || (-x <= maxX && -x >= minX)) {\n                p1a.setLocation(-x, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n            if (!isSegment || (x <= maxX && x >= minX)) {\n                p2a.setLocation(x, y);\n                trans.inverseTransform(p2a, p2a);\n                result.add(p2a);\n            }\n        }\n        return result;\n    }\n\n    public static String toString(Point2D point) {\n        return String.format(\"(%g, %g)\", point.getX(), point.getY());\n    }\n\n    public static String toString(List<Point2D> points) {\n        StringBuilder str = new StringBuilder(\"[\");\n        for (int i = 0, n = points.size(); i < n; ++i) {\n            if (i > 0)\n                str.append(\", \");\n            str.append(toString(points.get(i)));\n        }\n        str.append(\"]\");\n        return str.toString();\n    }\n}\n"}
{"id": 415554, "name": "Vibrating rectangles", "source": "Translate Perl to Java: use utf8;\nbinmode STDOUT, \":utf8\";\nuse Time::HiRes qw(sleep);\n\n%r = ('tl' => qw<\u250c>, 'tr' => qw<\u2510>, 'h' => qw<\u2500>, 'v' => qw<\u2502>, 'bl' => qw<\u2514>, 'br' => qw<\u2518>);\n@colors = (\"\\e[1;31m\", \"\\e[1;32m\", \"\\e[1;33m\", \"\\e[1;34m\", \"\\e[1;35m\", \"\\e[1;36m\");\n\nprint \"\\e[?25l\"; \n\n$SIG{INT} = sub { print \"\\e[0H\\e[0J\\e[?25h\"; exit; }; \n\nwhile (1) {\n    @c = palette() unless $n % 16;\n    rect($_, 31-$_) for 0..15;\n    display(@vibe);\n    sleep .20;\n    push @c, $c[0]; shift @c;\n    $n++;\n}\n\nsub palette {\n    my @c = sort { -1 + 2*int(rand 2) } @colors;\n    ($c[0], $c[1], $c[2]) x 12;\n}\n\nsub rect {\n    my ($b, $e) = @_;\n    my $c = $c[$b % @c];\n    my @bb = ($c.$r{tl}, (($r{h})x($e-$b-1)), $r{tr}.\"\\e[0m\");\n    my @ee = ($c.$r{bl}, (($r{h})x($e-$b-1)), $r{br}.\"\\e[0m\");\n    $vibe[$b][$_] = shift @bb for $b .. $e;\n    $vibe[$e][$_] = shift @ee for $b .. $e;\n    $vibe[$_][$b] = $vibe[$_][$e] = $c.$r{v}.\"\\e[0m\" for $b+1 .. $e-1;\n}\n\nsub display {\n    my(@rect) = @_;\n    print \"\\e[0H\\e[0J\\n\\n\";\n    for my $row (@rect) {\n        print \"\\t\\t\\t\";\n        print $_ // ' ' for @$row;\n        print \"\\n\";\n    }\n}\n", "target": "\n\nint counter = 100;\n\nvoid setup(){\n  size(1000,1000);\n}\n\nvoid draw(){\n  \n  for(int i=0;i<20;i++){\n    fill(counter - 5*i);\n    rect(10 + 20*i,10 + 20*i,980 - 40*i,980 - 40*i);\n  }\n  counter++;\n  \n  if(counter > 255)\n    counter = 100;\n  \n  delay(100);\n}\n"}
{"id": 415555, "name": "Solve a Hopido puzzle", "source": "Translate Perl to Java: \n\nuse strict;             \nuse warnings;\n\n$_ = do { local $/; <DATA> };\ns/./$&$&/g;             \nmy $w = /\\n/ && $-[0];\nmy $wd = 3 * $w + 1;    \nmy $wr = 2 * $w + 8;    \nmy $wl = 2 * $w - 8;    \nplace($_, '00');\ndie \"No solution\\n\";\n\nsub place\n  {\n  (local $_, my $last) = @_;\n  (my $new = $last)++;\n  /$last.{10}(?=00)/g   and place( s/\\G00/$new/r, $new ); \n  /(?=00.{10}$last)/g   and place( s/\\G00/$new/r, $new ); \n  /$last.{$wd}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wd}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wr}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wr}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wl}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wl}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /00/ and return;\n  print \"Solution\\n\\n\", s/  / /gr =~ s/0\\B/ /gr;\n  exit;\n  }\n\n", "target": "import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415556, "name": "Solve a Hopido puzzle", "source": "Translate Perl to Java: \n\nuse strict;             \nuse warnings;\n\n$_ = do { local $/; <DATA> };\ns/./$&$&/g;             \nmy $w = /\\n/ && $-[0];\nmy $wd = 3 * $w + 1;    \nmy $wr = 2 * $w + 8;    \nmy $wl = 2 * $w - 8;    \nplace($_, '00');\ndie \"No solution\\n\";\n\nsub place\n  {\n  (local $_, my $last) = @_;\n  (my $new = $last)++;\n  /$last.{10}(?=00)/g   and place( s/\\G00/$new/r, $new ); \n  /(?=00.{10}$last)/g   and place( s/\\G00/$new/r, $new ); \n  /$last.{$wd}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wd}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wr}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wr}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /$last.{$wl}(?=00)/gs and place( s/\\G00/$new/r, $new ); \n  /(?=00.{$wl}$last)/gs and place( s/\\G00/$new/r, $new ); \n  /00/ and return;\n  print \"Solution\\n\\n\", s/  / /gr =~ s/0\\B/ /gr;\n  exit;\n  }\n\n", "target": "import java.util.*;\n\npublic class Hopido {\n\n    final static String[] board = {\n        \".00.00.\",\n        \"0000000\",\n        \"0000000\",\n        \".00000.\",\n        \"..000..\",\n        \"...0...\"};\n\n    final static int[][] moves = {{-3, 0}, {0, 3}, {3, 0}, {0, -3},\n    {2, 2}, {2, -2}, {-2, 2}, {-2, -2}};\n    static int[][] grid;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 6;\n        int nCols = board[0].length() + 6;\n\n        grid = new int[nRows][nCols];\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n            for (int c = 3; c < nCols - 3; c++)\n                if (r >= 3 && r < nRows - 3) {\n                    if (board[r - 3].charAt(c - 3) == '0') {\n                        grid[r][c] = 0;\n                        totalToFill++;\n                    }\n                }\n        }\n\n        int pos = -1, r, c;\n        do {\n            do {\n                pos++;\n                r = pos / nCols;\n                c = pos % nCols;\n            } while (grid[r][c] == -1);\n\n            grid[r][c] = 1;\n            if (solve(r, c, 2))\n                break;\n            grid[r][c] = 0;\n\n        } while (pos < nRows * nCols);\n\n        printResult();\n    }\n\n    static boolean solve(int r, int c, int count) {\n        if (count > totalToFill)\n            return true;\n\n        List<int[]> nbrs = neighbors(r, c);\n\n        if (nbrs.isEmpty() && count != totalToFill)\n            return false;\n\n        Collections.sort(nbrs, (a, b) -> a[2] - b[2]);\n\n        for (int[] nb : nbrs) {\n            r = nb[0];\n            c = nb[1];\n            grid[r][c] = count;\n            if (solve(r, c, count + 1))\n                return true;\n            grid[r][c] = 0;\n        }\n\n        return false;\n    }\n\n    static List<int[]> neighbors(int r, int c) {\n        List<int[]> nbrs = new ArrayList<>();\n\n        for (int[] m : moves) {\n            int x = m[0];\n            int y = m[1];\n            if (grid[r + y][c + x] == 0) {\n                int num = countNeighbors(r + y, c + x) - 1;\n                nbrs.add(new int[]{r + y, c + x, num});\n            }\n        }\n        return nbrs;\n    }\n\n    static int countNeighbors(int r, int c) {\n        int num = 0;\n        for (int[] m : moves)\n            if (grid[r + m[1]][c + m[0]] == 0)\n                num++;\n        return num;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    System.out.printf(\"%2s \", ' ');\n                else\n                    System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415557, "name": "Solve a Numbrix puzzle", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEND\n\nmy $gap = /.\\n/ * $-[0];\nprint;\ns/ (?=\\d\\b)/0/g;\nmy $max = sprintf \"%02d\", tr/0-9// / 2;\n\nsolve( '01', $_ );\n\nsub solve\n  {\n  my ($have, $in) = @_;\n  $have eq $max and exit !print \"solution\\n\", $in =~ s/\\b0/ /gr;\n  if( $in =~ ++(my $want = $have) )\n    {\n    $in =~ /($have|$want)( |.{$gap})($have|$want)/s and solve($want, $in);\n    }\n  else\n    {\n    ($_ = $in) =~ s/$have \\K00/$want/          and solve( $want, $_ ); \n    ($_ = $in) =~ s/$have.{$gap}\\K00/$want/s   and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?= $have)/$want/        and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?=.{$gap}$have)/$want/s and solve( $want, $_ ); \n    }\n  }\n", "target": "import java.util.*;\n\npublic class Numbrix {\n\n    final static String[] board = {\n        \"00,00,00,00,00,00,00,00,00\",\n        \"00,00,46,45,00,55,74,00,00\",\n        \"00,38,00,00,43,00,00,78,00\",\n        \"00,35,00,00,00,00,00,71,00\",\n        \"00,00,33,00,00,00,59,00,00\",\n        \"00,17,00,00,00,00,00,67,00\",\n        \"00,18,00,00,11,00,00,64,00\",\n        \"00,00,24,21,00,01,02,00,00\",\n        \"00,00,00,00,00,00,00,00,00\"};\n\n    final static int[][] moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    static int[][] grid;\n    static int[] clues;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 2;\n        int nCols = board[0].split(\",\").length + 2;\n        int startRow = 0, startCol = 0;\n\n        grid = new int[nRows][nCols];\n        totalToFill = (nRows - 2) * (nCols - 2);\n        List<Integer> lst = new ArrayList<>();\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n\n            if (r >= 1 && r < nRows - 1) {\n\n                String[] row = board[r - 1].split(\",\");\n\n                for (int c = 1; c < nCols - 1; c++) {\n                    int val = Integer.parseInt(row[c - 1]);\n                    if (val > 0)\n                        lst.add(val);\n                    if (val == 1) {\n                        startRow = r;\n                        startCol = c;\n                    }\n                    grid[r][c] = val;\n                }\n            }\n        }\n\n        clues = lst.stream().sorted().mapToInt(i -> i).toArray();\n\n        if (solve(startRow, startCol, 1, 0))\n            printResult();\n    }\n\n    static boolean solve(int r, int c, int count, int nextClue) {\n        if (count > totalToFill)\n            return true;\n\n        if (grid[r][c] != 0 && grid[r][c] != count)\n            return false;\n\n        if (grid[r][c] == 0 && nextClue < clues.length)\n            if (clues[nextClue] == count)\n                return false;\n\n        int back = grid[r][c];\n        if (back == count)\n            nextClue++;\n\n        grid[r][c] = count;\n        for (int[] move : moves)\n            if (solve(r + move[1], c + move[0], count + 1, nextClue))\n                return true;\n\n        grid[r][c] = back;\n        return false;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415558, "name": "Solve a Numbrix puzzle", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n 0  0  0  0  0  0  0  0  0\n 0  0 46 45  0 55 74  0  0\n 0 38  0  0 43  0  0 78  0\n 0 35  0  0  0  0  0 71  0\n 0  0 33  0  0  0 59  0  0\n 0 17  0  0  0  0  0 67  0\n 0 18  0  0 11  0  0 64  0\n 0  0 24 21  0  1  2  0  0\n 0  0  0  0  0  0  0  0  0\nEND\n\nmy $gap = /.\\n/ * $-[0];\nprint;\ns/ (?=\\d\\b)/0/g;\nmy $max = sprintf \"%02d\", tr/0-9// / 2;\n\nsolve( '01', $_ );\n\nsub solve\n  {\n  my ($have, $in) = @_;\n  $have eq $max and exit !print \"solution\\n\", $in =~ s/\\b0/ /gr;\n  if( $in =~ ++(my $want = $have) )\n    {\n    $in =~ /($have|$want)( |.{$gap})($have|$want)/s and solve($want, $in);\n    }\n  else\n    {\n    ($_ = $in) =~ s/$have \\K00/$want/          and solve( $want, $_ ); \n    ($_ = $in) =~ s/$have.{$gap}\\K00/$want/s   and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?= $have)/$want/        and solve( $want, $_ ); \n    ($_ = $in) =~ s/00(?=.{$gap}$have)/$want/s and solve( $want, $_ ); \n    }\n  }\n", "target": "import java.util.*;\n\npublic class Numbrix {\n\n    final static String[] board = {\n        \"00,00,00,00,00,00,00,00,00\",\n        \"00,00,46,45,00,55,74,00,00\",\n        \"00,38,00,00,43,00,00,78,00\",\n        \"00,35,00,00,00,00,00,71,00\",\n        \"00,00,33,00,00,00,59,00,00\",\n        \"00,17,00,00,00,00,00,67,00\",\n        \"00,18,00,00,11,00,00,64,00\",\n        \"00,00,24,21,00,01,02,00,00\",\n        \"00,00,00,00,00,00,00,00,00\"};\n\n    final static int[][] moves = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};\n\n    static int[][] grid;\n    static int[] clues;\n    static int totalToFill;\n\n    public static void main(String[] args) {\n        int nRows = board.length + 2;\n        int nCols = board[0].split(\",\").length + 2;\n        int startRow = 0, startCol = 0;\n\n        grid = new int[nRows][nCols];\n        totalToFill = (nRows - 2) * (nCols - 2);\n        List<Integer> lst = new ArrayList<>();\n\n        for (int r = 0; r < nRows; r++) {\n            Arrays.fill(grid[r], -1);\n\n            if (r >= 1 && r < nRows - 1) {\n\n                String[] row = board[r - 1].split(\",\");\n\n                for (int c = 1; c < nCols - 1; c++) {\n                    int val = Integer.parseInt(row[c - 1]);\n                    if (val > 0)\n                        lst.add(val);\n                    if (val == 1) {\n                        startRow = r;\n                        startCol = c;\n                    }\n                    grid[r][c] = val;\n                }\n            }\n        }\n\n        clues = lst.stream().sorted().mapToInt(i -> i).toArray();\n\n        if (solve(startRow, startCol, 1, 0))\n            printResult();\n    }\n\n    static boolean solve(int r, int c, int count, int nextClue) {\n        if (count > totalToFill)\n            return true;\n\n        if (grid[r][c] != 0 && grid[r][c] != count)\n            return false;\n\n        if (grid[r][c] == 0 && nextClue < clues.length)\n            if (clues[nextClue] == count)\n                return false;\n\n        int back = grid[r][c];\n        if (back == count)\n            nextClue++;\n\n        grid[r][c] = count;\n        for (int[] move : moves)\n            if (solve(r + move[1], c + move[0], count + 1, nextClue))\n                return true;\n\n        grid[r][c] = back;\n        return false;\n    }\n\n    static void printResult() {\n        for (int[] row : grid) {\n            for (int i : row) {\n                if (i == -1)\n                    continue;\n                System.out.printf(\"%2d \", i);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415559, "name": "Chemical calculator", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse List::Util;\nuse Parse::RecDescent;\n\nmy $g = Parse::RecDescent->new(<<'EOG');\n  {\n     my %atomic_weight = <H 1.008 C 12.011 O 15.999 Na 22.99 S 32.06>\n  }\n\n  weight   : compound         { $item[1] }\n  compound : group(s)         { List::Util::sum( @{$item[1]} ) }\n  group    : element /\\d+/    { $item[1] * $item[2] }\n           | element          { $item[1] }\n  element  : /[A-Z][a-z]*/    { $atomic_weight{ $item[1] } }\n           | \"(\" compound \")\" { $item[2] }\nEOG\n\nfor (<H H2 H2O Na2SO4 C6H12 COOH(C(CH3)2)3CH3>) {\n    printf \"%7.3f %s\\n\", $g->weight($_), $_\n}\n", "target": "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\npublic class ChemicalCalculator {\n    private static final Map<String, Double> atomicMass = new HashMap<>();\n\n    static {\n        atomicMass.put(\"H\", 1.008);\n        atomicMass.put(\"He\", 4.002602);\n        atomicMass.put(\"Li\", 6.94);\n        atomicMass.put(\"Be\", 9.0121831);\n        atomicMass.put(\"B\", 10.81);\n        atomicMass.put(\"C\", 12.011);\n        atomicMass.put(\"N\", 14.007);\n        atomicMass.put(\"O\", 15.999);\n        atomicMass.put(\"F\", 18.998403163);\n        atomicMass.put(\"Ne\", 20.1797);\n        atomicMass.put(\"Na\", 22.98976928);\n        atomicMass.put(\"Mg\", 24.305);\n        atomicMass.put(\"Al\", 26.9815385);\n        atomicMass.put(\"Si\", 28.085);\n        atomicMass.put(\"P\", 30.973761998);\n        atomicMass.put(\"S\", 32.06);\n        atomicMass.put(\"Cl\", 35.45);\n        atomicMass.put(\"Ar\", 39.948);\n        atomicMass.put(\"K\", 39.0983);\n        atomicMass.put(\"Ca\", 40.078);\n        atomicMass.put(\"Sc\", 44.955908);\n        atomicMass.put(\"Ti\", 47.867);\n        atomicMass.put(\"V\", 50.9415);\n        atomicMass.put(\"Cr\", 51.9961);\n        atomicMass.put(\"Mn\", 54.938044);\n        atomicMass.put(\"Fe\", 55.845);\n        atomicMass.put(\"Co\", 58.933194);\n        atomicMass.put(\"Ni\", 58.6934);\n        atomicMass.put(\"Cu\", 63.546);\n        atomicMass.put(\"Zn\", 65.38);\n        atomicMass.put(\"Ga\", 69.723);\n        atomicMass.put(\"Ge\", 72.630);\n        atomicMass.put(\"As\", 74.921595);\n        atomicMass.put(\"Se\", 78.971);\n        atomicMass.put(\"Br\", 79.904);\n        atomicMass.put(\"Kr\", 83.798);\n        atomicMass.put(\"Rb\", 85.4678);\n        atomicMass.put(\"Sr\", 87.62);\n        atomicMass.put(\"Y\", 88.90584);\n        atomicMass.put(\"Zr\", 91.224);\n        atomicMass.put(\"Nb\", 92.90637);\n        atomicMass.put(\"Mo\", 95.95);\n        atomicMass.put(\"Ru\", 101.07);\n        atomicMass.put(\"Rh\", 102.90550);\n        atomicMass.put(\"Pd\", 106.42);\n        atomicMass.put(\"Ag\", 107.8682);\n        atomicMass.put(\"Cd\", 112.414);\n        atomicMass.put(\"In\", 114.818);\n        atomicMass.put(\"Sn\", 118.710);\n        atomicMass.put(\"Sb\", 121.760);\n        atomicMass.put(\"Te\", 127.60);\n        atomicMass.put(\"I\", 126.90447);\n        atomicMass.put(\"Xe\", 131.293);\n        atomicMass.put(\"Cs\", 132.90545196);\n        atomicMass.put(\"Ba\", 137.327);\n        atomicMass.put(\"La\", 138.90547);\n        atomicMass.put(\"Ce\", 140.116);\n        atomicMass.put(\"Pr\", 140.90766);\n        atomicMass.put(\"Nd\", 144.242);\n        atomicMass.put(\"Pm\", 145.0);\n        atomicMass.put(\"Sm\", 150.36);\n        atomicMass.put(\"Eu\", 151.964);\n        atomicMass.put(\"Gd\", 157.25);\n        atomicMass.put(\"Tb\", 158.92535);\n        atomicMass.put(\"Dy\", 162.500);\n        atomicMass.put(\"Ho\", 164.93033);\n        atomicMass.put(\"Er\", 167.259);\n        atomicMass.put(\"Tm\", 168.93422);\n        atomicMass.put(\"Yb\", 173.054);\n        atomicMass.put(\"Lu\", 174.9668);\n        atomicMass.put(\"Hf\", 178.49);\n        atomicMass.put(\"Ta\", 180.94788);\n        atomicMass.put(\"W\", 183.84);\n        atomicMass.put(\"Re\", 186.207);\n        atomicMass.put(\"Os\", 190.23);\n        atomicMass.put(\"Ir\", 192.217);\n        atomicMass.put(\"Pt\", 195.084);\n        atomicMass.put(\"Au\", 196.966569);\n        atomicMass.put(\"Hg\", 200.592);\n        atomicMass.put(\"Tl\", 204.38);\n        atomicMass.put(\"Pb\", 207.2);\n        atomicMass.put(\"Bi\", 208.98040);\n        atomicMass.put(\"Po\", 209.0);\n        atomicMass.put(\"At\", 210.0);\n        atomicMass.put(\"Rn\", 222.0);\n        atomicMass.put(\"Fr\", 223.0);\n        atomicMass.put(\"Ra\", 226.0);\n        atomicMass.put(\"Ac\", 227.0);\n        atomicMass.put(\"Th\", 232.0377);\n        atomicMass.put(\"Pa\", 231.03588);\n        atomicMass.put(\"U\", 238.02891);\n        atomicMass.put(\"Np\", 237.0);\n        atomicMass.put(\"Pu\", 244.0);\n        atomicMass.put(\"Am\", 243.0);\n        atomicMass.put(\"Cm\", 247.0);\n        atomicMass.put(\"Bk\", 247.0);\n        atomicMass.put(\"Cf\", 251.0);\n        atomicMass.put(\"Es\", 252.0);\n        atomicMass.put(\"Fm\", 257.0);\n        atomicMass.put(\"Uue\", 315.0);\n        atomicMass.put(\"Ubn\", 299.0);\n    }\n\n    private static double evaluate(String s) {\n        String sym = s + \"[\";\n        double sum = 0.0;\n        StringBuilder symbol = new StringBuilder();\n        String number = \"\";\n        for (int i = 0; i < sym.length(); ++i) {\n            char c = sym.charAt(i);\n            if ('@' <= c && c <= '[') {\n                \n                int n = 1;\n                if (!number.isEmpty()) {\n                    n = Integer.parseInt(number);\n                }\n                if (symbol.length() > 0) {\n                    sum += atomicMass.getOrDefault(symbol.toString(), 0.0) * n;\n                }\n                if (c == '[') {\n                    break;\n                }\n                symbol = new StringBuilder(String.valueOf(c));\n                number = \"\";\n            } else if ('a' <= c && c <= 'z') {\n                symbol.append(c);\n            } else if ('0' <= c && c <= '9') {\n                number += c;\n            } else {\n                throw new RuntimeException(\"Unexpected symbol \" + c + \" in molecule\");\n            }\n        }\n        return sum;\n    }\n\n    private static String replaceParens(String s) {\n        char letter = 'a';\n        String si = s;\n        while (true) {\n            int start = si.indexOf('(');\n            if (start == -1) {\n                break;\n            }\n\n            for (int i = start + 1; i < si.length(); ++i) {\n                if (si.charAt(i) == ')') {\n                    String expr = si.substring(start + 1, i);\n                    String symbol = \"@\" + letter;\n                    String pattern = Pattern.quote(si.substring(start, i + 1));\n                    si = si.replaceFirst(pattern, symbol);\n                    atomicMass.put(symbol, evaluate(expr));\n                    letter++;\n                    break;\n                }\n                if (si.charAt(i) == '(') {\n                    start = i;\n                }\n            }\n        }\n        return si;\n    }\n\n    public static void main(String[] args) {\n        List<String> molecules = List.of(\n            \"H\", \"H2\", \"H2O\", \"H2O2\", \"(HO)2\", \"Na2SO4\", \"C6H12\",\n            \"COOH(C(CH3)2)3CH3\", \"C6H4O2(OH)4\", \"C27H46O\", \"Uue\"\n        );\n        for (String molecule : molecules) {\n            double mass = evaluate(replaceParens(molecule));\n            System.out.printf(\"%17s -> %7.3f\\n\", molecule, mass);\n        }\n    }\n}\n"}
{"id": 415560, "name": "Arithmetic evaluation", "source": "Translate Perl to Java: sub ev\n\n\n {my $exp = shift;\n  \n  \n  $exp =~ tr {0-9.+-/*()} {}cd;\n  return ev_ast(astize($exp));}\n\n {my $balanced_paren_regex;\n  $balanced_paren_regex = qr\n     {\\( ( [^()]+ | (??{$balanced_paren_regex}) )+ \\)}x;\n  \n  \n  \n  sub astize\n  \n  \n  \n   {my $exp = shift;\n    \n    $exp =~ /[^0-9.]/ or return $exp;\n    \n    \n    $exp = substr($exp, 1, -1)\n        while $exp =~ /\\A($balanced_paren_regex)\\z/;\n    \n    my @paren_contents;\n    $exp =~ s {($balanced_paren_regex)}\n              {push(@paren_contents, $1);\n               \"[p$\n    \n    \n    $exp =~ m{(.+) ([+-]) (.+)}x or\n        $exp =~ m{(.+) ([*/]) (.+)}x or\n        \n        \n        die \"Eh?: [$exp]\\n\";\n    my ($op, $lo, $ro) = ($2, $1, $3);\n    \n    s {\\[p(\\d+)\\]} {($paren_contents[$1])}eg\n        foreach $lo, $ro;\n    \n    return [$op, astize($lo), astize($ro)];}}\n\n {my %ops =\n     ('+' => sub {$_[0] + $_[1]},\n      '-' => sub {$_[0] - $_[1]},\n      '*' => sub {$_[0] * $_[1]},\n      '/' => sub {$_[0] / $_[1]});\n  \n  sub ev_ast\n  \n  \n   {my $ast = shift;\n    \n    ref $ast or return $ast;\n    \n    my ($op, @operands) = @$ast;\n    $_ = ev_ast($_) foreach @operands;\n    return $ops{$op}->(@operands);}}\n", "target": "import java.util.Stack;\n\npublic class ArithmeticEvaluation {\n\n    public interface Expression {\n        BigRational eval();\n    }\n\n    public enum Parentheses {LEFT}\n\n    public enum BinaryOperator {\n        ADD('+', 1),\n        SUB('-', 1),\n        MUL('*', 2),\n        DIV('/', 2);\n\n        public final char symbol;\n        public final int precedence;\n\n        BinaryOperator(char symbol, int precedence) {\n            this.symbol = symbol;\n            this.precedence = precedence;\n        }\n\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\n            switch (this) {\n                case ADD:\n                    return leftValue.add(rightValue);\n                case SUB:\n                    return leftValue.subtract(rightValue);\n                case MUL:\n                    return leftValue.multiply(rightValue);\n                case DIV:\n                    return leftValue.divide(rightValue);\n            }\n            throw new IllegalStateException();\n        }\n\n        public static BinaryOperator forSymbol(char symbol) {\n            for (BinaryOperator operator : values()) {\n                if (operator.symbol == symbol) {\n                    return operator;\n                }\n            }\n            throw new IllegalArgumentException(String.valueOf(symbol));\n        }\n    }\n\n    public static class Number implements Expression {\n        private final BigRational number;\n\n        public Number(BigRational number) {\n            this.number = number;\n        }\n\n        @Override\n        public BigRational eval() {\n            return number;\n        }\n\n        @Override\n        public String toString() {\n            return number.toString();\n        }\n    }\n\n    public static class BinaryExpression implements Expression {\n        public final Expression leftOperand;\n        public final BinaryOperator operator;\n        public final Expression rightOperand;\n\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\n            this.leftOperand = leftOperand;\n            this.operator = operator;\n            this.rightOperand = rightOperand;\n        }\n\n        @Override\n        public BigRational eval() {\n            BigRational leftValue = leftOperand.eval();\n            BigRational rightValue = rightOperand.eval();\n            return operator.eval(leftValue, rightValue);\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";\n        }\n    }\n\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\n        Expression rightOperand = operands.pop();\n        Expression leftOperand = operands.pop();\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\n    }\n\n    public static Expression parse(String input) {\n        int curIndex = 0;\n        boolean afterOperand = false;\n        Stack<Expression> operands = new Stack<>();\n        Stack<Object> operators = new Stack<>();\n        while (curIndex < input.length()) {\n            int startIndex = curIndex;\n            char c = input.charAt(curIndex++);\n\n            if (Character.isWhitespace(c))\n                continue;\n\n            if (afterOperand) {\n                if (c == ')') {\n                    Object operator;\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n                        createNewOperand((BinaryOperator) operator, operands);\n                    continue;\n                }\n                afterOperand = false;\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\n                operators.push(operator);\n                continue;\n            }\n\n            if (c == '(') {\n                operators.push(Parentheses.LEFT);\n                continue;\n            }\n\n            afterOperand = true;\n            while (curIndex < input.length()) {\n                c = input.charAt(curIndex);\n                if (((c < '0') || (c > '9')) && (c != '.'))\n                    break;\n                curIndex++;\n            }\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\n        }\n\n        while (!operators.isEmpty()) {\n            Object operator = operators.pop();\n            if (operator == Parentheses.LEFT)\n                throw new IllegalArgumentException();\n            createNewOperand((BinaryOperator) operator, operands);\n        }\n\n        Expression expression = operands.pop();\n        if (!operands.isEmpty())\n            throw new IllegalArgumentException();\n        return expression;\n    }\n\n    public static void main(String[] args) {\n        String[] testExpressions = {\n                \"2+3\",\n                \"2+3/4\",\n                \"2*3-4\",\n                \"2*(3+4)+5/6\",\n                \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n                \"2*-3--4+-.25\"};\n        for (String testExpression : testExpressions) {\n            Expression expression = parse(testExpression);\n            System.out.printf(\"Input: \\\"%s\\\", AST: \\\"%s\\\", value=%s%n\", testExpression, expression, expression.eval());\n        }\n    }\n}\n"}
{"id": 415561, "name": "Arithmetic evaluation", "source": "Translate Perl to Java: sub ev\n\n\n {my $exp = shift;\n  \n  \n  $exp =~ tr {0-9.+-/*()} {}cd;\n  return ev_ast(astize($exp));}\n\n {my $balanced_paren_regex;\n  $balanced_paren_regex = qr\n     {\\( ( [^()]+ | (??{$balanced_paren_regex}) )+ \\)}x;\n  \n  \n  \n  sub astize\n  \n  \n  \n   {my $exp = shift;\n    \n    $exp =~ /[^0-9.]/ or return $exp;\n    \n    \n    $exp = substr($exp, 1, -1)\n        while $exp =~ /\\A($balanced_paren_regex)\\z/;\n    \n    my @paren_contents;\n    $exp =~ s {($balanced_paren_regex)}\n              {push(@paren_contents, $1);\n               \"[p$\n    \n    \n    $exp =~ m{(.+) ([+-]) (.+)}x or\n        $exp =~ m{(.+) ([*/]) (.+)}x or\n        \n        \n        die \"Eh?: [$exp]\\n\";\n    my ($op, $lo, $ro) = ($2, $1, $3);\n    \n    s {\\[p(\\d+)\\]} {($paren_contents[$1])}eg\n        foreach $lo, $ro;\n    \n    return [$op, astize($lo), astize($ro)];}}\n\n {my %ops =\n     ('+' => sub {$_[0] + $_[1]},\n      '-' => sub {$_[0] - $_[1]},\n      '*' => sub {$_[0] * $_[1]},\n      '/' => sub {$_[0] / $_[1]});\n  \n  sub ev_ast\n  \n  \n   {my $ast = shift;\n    \n    ref $ast or return $ast;\n    \n    my ($op, @operands) = @$ast;\n    $_ = ev_ast($_) foreach @operands;\n    return $ops{$op}->(@operands);}}\n", "target": "import java.util.Stack;\n\npublic class ArithmeticEvaluation {\n\n    public interface Expression {\n        BigRational eval();\n    }\n\n    public enum Parentheses {LEFT}\n\n    public enum BinaryOperator {\n        ADD('+', 1),\n        SUB('-', 1),\n        MUL('*', 2),\n        DIV('/', 2);\n\n        public final char symbol;\n        public final int precedence;\n\n        BinaryOperator(char symbol, int precedence) {\n            this.symbol = symbol;\n            this.precedence = precedence;\n        }\n\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\n            switch (this) {\n                case ADD:\n                    return leftValue.add(rightValue);\n                case SUB:\n                    return leftValue.subtract(rightValue);\n                case MUL:\n                    return leftValue.multiply(rightValue);\n                case DIV:\n                    return leftValue.divide(rightValue);\n            }\n            throw new IllegalStateException();\n        }\n\n        public static BinaryOperator forSymbol(char symbol) {\n            for (BinaryOperator operator : values()) {\n                if (operator.symbol == symbol) {\n                    return operator;\n                }\n            }\n            throw new IllegalArgumentException(String.valueOf(symbol));\n        }\n    }\n\n    public static class Number implements Expression {\n        private final BigRational number;\n\n        public Number(BigRational number) {\n            this.number = number;\n        }\n\n        @Override\n        public BigRational eval() {\n            return number;\n        }\n\n        @Override\n        public String toString() {\n            return number.toString();\n        }\n    }\n\n    public static class BinaryExpression implements Expression {\n        public final Expression leftOperand;\n        public final BinaryOperator operator;\n        public final Expression rightOperand;\n\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\n            this.leftOperand = leftOperand;\n            this.operator = operator;\n            this.rightOperand = rightOperand;\n        }\n\n        @Override\n        public BigRational eval() {\n            BigRational leftValue = leftOperand.eval();\n            BigRational rightValue = rightOperand.eval();\n            return operator.eval(leftValue, rightValue);\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";\n        }\n    }\n\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\n        Expression rightOperand = operands.pop();\n        Expression leftOperand = operands.pop();\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\n    }\n\n    public static Expression parse(String input) {\n        int curIndex = 0;\n        boolean afterOperand = false;\n        Stack<Expression> operands = new Stack<>();\n        Stack<Object> operators = new Stack<>();\n        while (curIndex < input.length()) {\n            int startIndex = curIndex;\n            char c = input.charAt(curIndex++);\n\n            if (Character.isWhitespace(c))\n                continue;\n\n            if (afterOperand) {\n                if (c == ')') {\n                    Object operator;\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n                        createNewOperand((BinaryOperator) operator, operands);\n                    continue;\n                }\n                afterOperand = false;\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\n                operators.push(operator);\n                continue;\n            }\n\n            if (c == '(') {\n                operators.push(Parentheses.LEFT);\n                continue;\n            }\n\n            afterOperand = true;\n            while (curIndex < input.length()) {\n                c = input.charAt(curIndex);\n                if (((c < '0') || (c > '9')) && (c != '.'))\n                    break;\n                curIndex++;\n            }\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\n        }\n\n        while (!operators.isEmpty()) {\n            Object operator = operators.pop();\n            if (operator == Parentheses.LEFT)\n                throw new IllegalArgumentException();\n            createNewOperand((BinaryOperator) operator, operands);\n        }\n\n        Expression expression = operands.pop();\n        if (!operands.isEmpty())\n            throw new IllegalArgumentException();\n        return expression;\n    }\n\n    public static void main(String[] args) {\n        String[] testExpressions = {\n                \"2+3\",\n                \"2+3/4\",\n                \"2*3-4\",\n                \"2*(3+4)+5/6\",\n                \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n                \"2*-3--4+-.25\"};\n        for (String testExpression : testExpressions) {\n            Expression expression = parse(testExpression);\n            System.out.printf(\"Input: \\\"%s\\\", AST: \\\"%s\\\", value=%s%n\", testExpression, expression, expression.eval());\n        }\n    }\n}\n"}
{"id": 415562, "name": "Sierpinski curve", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\nmy $rule = 'XF+F+XF--F--XF+F+X';\nmy $S = 'F--F--XF--F--XF';\n$S =~ s/X/$rule/g for 1..5;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = pi/4;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/4; }\n    elsif (/\\-/) { $theta -= pi/4; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import java.io.*;\n\npublic class SierpinskiCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"sierpinski_curve.svg\"))) {\n            SierpinskiCurve s = new SierpinskiCurve(writer);\n            s.currentAngle = 45;\n            s.currentX = 5;\n            s.currentY = 10;\n            s.lineLength = 7;\n            s.begin(545);\n            s.execute(rewrite(5));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private SierpinskiCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                case 'G':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY -= length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = AXIOM;\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'X')\n                    sb.append(PRODUCTION);\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n\n    private static final String AXIOM = \"F--XF--F--XF\";\n    private static final String PRODUCTION = \"XF+G+XF--F--XF+G+X\";\n    private static final int ANGLE = 45;\n}\n"}
{"id": 415563, "name": "Sierpinski curve", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\nmy $rule = 'XF+F+XF--F--XF+F+X';\nmy $S = 'F--F--XF--F--XF';\n$S =~ s/X/$rule/g for 1..5;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = pi/4;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/4; }\n    elsif (/\\-/) { $theta -= pi/4; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import java.io.*;\n\npublic class SierpinskiCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"sierpinski_curve.svg\"))) {\n            SierpinskiCurve s = new SierpinskiCurve(writer);\n            s.currentAngle = 45;\n            s.currentX = 5;\n            s.currentY = 10;\n            s.lineLength = 7;\n            s.begin(545);\n            s.execute(rewrite(5));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private SierpinskiCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                case 'G':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY -= length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = AXIOM;\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'X')\n                    sb.append(PRODUCTION);\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n\n    private static final String AXIOM = \"F--XF--F--XF\";\n    private static final String PRODUCTION = \"XF+G+XF--F--XF+G+X\";\n    private static final int ANGLE = 45;\n}\n"}
{"id": 415564, "name": "Make a backup file", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub backup {\n    my($filepath,$limit,$ext) = @_;\n    my $abs = readlink $filepath // $filepath; \n    for my $bnum (reverse 1 .. $limit-1) {\n        rename \"$abs$ext$bnum\", \"$abs$ext\" . ++$bnum if -e \"$abs$ext$bnum\";\n    }\n\n    if (-e $abs) {\n        if ($limit > 0) {\n            my $orig = $abs . $ext . '1';\n            rename $abs, $orig;\n            open(IN,  '<', $orig) or die \"can't open $orig: $!\";\n            open(OUT, '>', $abs)  or die \"can't open $abs: $!\";\n\n            my $blksize = (stat IN)[11] || 2**14;          \n            my $buf;\n            while (my $len = sysread IN, $buf, $blksize) {\n                die \"System read error: $!\\n\" if !defined $len;\n                my $offset = 0;\n                while ($len) {          \n                    defined(my $written = syswrite OUT, $buf, $len, $offset)\n                        or die \"System write error: $!\\n\";\n                    $len    -= $written;\n                    $offset += $written;\n                };\n            }\n            close(IN);\n            close(OUT);\n        }\n    } else {\n        warn \"File not found: $abs\" and return 0;\n    }\n    $abs\n}\n\n\nbackup($0,3,'.bk');\n", "target": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.file.*;\n \npublic class Backup {\n\tpublic static void saveWithBackup(String filename, String... data) \n        throws IOException {\n\t\t\n\t\tPath file = Paths.get(filename).toRealPath();\n\t\tFile backFile = new File(filename + \".backup\");\n\t\tif(!backFile.exists()) {\n\t\t\t\n\t\t\tbackFile.createNewFile();\n\t\t}\n\t\tPath back = Paths.get(filename + \".backup\").toRealPath();\n\t\tFiles.move(file, back, StandardCopyOption.REPLACE_EXISTING);\n\t\ttry(PrintWriter out = new PrintWriter(file.toFile())){\n\t\t\tfor(int i = 0; i < data.length; i++) {\n\t\t\t\tout.print(data[i]);\n\t\t\t\tif(i < data.length - 1) {\n\t\t\t\t\tout.println();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n        public static void main(String[] args) {\n\t\ttry {\n\t\t\tsaveWithBackup(\"original.txt\", \"fourth\", \"fifth\", \"sixth\");\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(e);\n\t\t}\n\t} \n}\n"}
{"id": 415565, "name": "Rosetta Code_Fix code tags", "source": "Translate Perl to Java: my @langs = qw(ada cpp-qt pascal lscript z80 visualprolog\nhtml4strict cil objc asm progress teraterm hq9plus genero tsql\nemail pic16 tcl apt_sources io apache vhdl avisynth winbatch\nvbnet ini scilab ocaml-brief sas actionscript3 qbasic perl bnf\ncobol powershell php kixtart visualfoxpro mirc make javascript\ncpp sdlbasic cadlisp php-brief rails verilog xml csharp\nactionscript nsis bash typoscript freebasic dot applescript\nhaskell dos oracle8 cfdg glsl lotusscript mpasm latex sql klonec\nruby ocaml smarty python oracle11 caddcl robots groovy smalltalk\ndiff fortran cfm lua modula3 vb autoit java text scala\nlotusformulas pixelbender reg _div whitespace providex asp css\nlolcode lisp inno mysql plsql matlab oobas vim delphi xorg_conf\ngml prolog bf per scheme mxml d basic4gl m68k gnuplot idl abap\nintercal c_mac thinbasic java5 xpp boo klonecpp blitzbasic eiffel\npovray c gettext);\n\nmy $text = join \"\", <STDIN>;\nmy $slang=\"/lang\";\nfor (@langs) {\n    $text =~ s|<$_>|<lang $_>|g;\n    $text =~ s|</$_>|<$slang>|g;\n}\n\n$text =~ s|<code (.+?)>(.*?)</code>|<lang $1>$2<$slang>|sg;\n\nprint $text;\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.FileWriter;\n\npublic class FixCodeTags \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tString sourcefile=args[0];\n\t\tString convertedfile=args[1];\n\t\tconvert(sourcefile,convertedfile);\n\t}\n\t\tstatic String[] languages = {\"abap\", \"actionscript\", \"actionscript3\",\n\t\t\t\"ada\", \"apache\", \"applescript\", \"apt_sources\", \"asm\", \"asp\",\n\t\t\t\"autoit\", \"avisynth\", \"bar\", \"bash\", \"basic4gl\", \"bf\",\n\t\t\t\"blitzbasic\", \"bnf\", \"boo\", \"c\", \"caddcl\", \"cadlisp\", \"cfdg\",\n\t\t\t\"cfm\", \"cil\", \"c_mac\", \"cobol\", \"cpp\", \"cpp-qt\", \"csharp\", \"css\",\n\t\t\t\"d\", \"delphi\", \"diff\", \"_div\", \"dos\", \"dot\", \"eiffel\", \"email\",\n\t\t\t\"foo\", \"fortran\", \"freebasic\", \"genero\", \"gettext\", \"glsl\", \"gml\",\n\t\t\t\"gnuplot\", \"go\", \"groovy\", \"haskell\", \"hq9plus\", \"html4strict\",\n\t\t\t\"idl\", \"ini\", \"inno\", \"intercal\", \"io\", \"java\", \"java5\",\n\t\t\t\"javascript\", \"kixtart\", \"klonec\", \"klonecpp\", \"latex\", \"lisp\",\n\t\t\t\"lolcode\", \"lotusformulas\", \"lotusscript\", \"lscript\", \"lua\",\n\t\t\t\"m68k\", \"make\", \"matlab\", \"mirc\", \"modula3\", \"mpasm\", \"mxml\",\n\t\t\t\"mysql\", \"nsis\", \"objc\", \"ocaml\", \"ocaml-brief\", \"oobas\",\n\t\t\t\"oracle11\", \"oracle8\", \"pascal\", \"per\", \"perl\", \"php\", \"php-brief\",\n\t\t\t\"pic16\", \"pixelbender\", \"plsql\", \"povray\", \"powershell\",\n\t\t\t\"progress\", \"prolog\", \"providex\", \"python\", \"qbasic\", \"rails\",\n\t\t\t\"reg\", \"robots\", \"ruby\", \"sas\", \"scala\", \"scheme\", \"scilab\",\n\t\t\t\"sdlbasic\", \"smalltalk\", \"smarty\", \"sql\", \"tcl\", \"teraterm\",\n\t\t\t\"text\", \"thinbasic\", \"tsql\", \"typoscript\", \"vb\", \"vbnet\",\n\t\t\t\"verilog\", \"vhdl\", \"vim\", \"visualfoxpro\", \"visualprolog\",\n\t\t\t\"whitespace\", \"winbatch\", \"xml\", \"xorg_conf\", \"xpp\", \"z80\"};\n\tstatic void convert(String sourcefile,String convertedfile)\n\t{\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(sourcefile));\n\t\t\t\n\t\t\tStringBuffer sb=new StringBuffer(\"\");\n\t\t\tString line;\n\t\t\twhile((line=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tfor(int i=0;i<languages.length;i++)\n\t\t\t\t{\n\t\t\t\t\tString lang=languages[i];\n\t\t\t\t\tline=line.replaceAll(\"<\"+lang+\">\", \"<lang \"+lang+\">\");\n\t\t\t\t\tline=line.replaceAll(\"</\"+lang+\">\", \"</\"+\"lang>\");\n\t\t\t\t\tline=line.replaceAll(\"<code \"+lang+\">\", \"<lang \"+lang+\">\");\n\t\t\t\t\tline=line.replaceAll(\"</code>\", \"</\"+\"lang>\");\n\t\t\t\t}\n\t\t\t\tsb.append(line);\n\t\t\t}\n\t\t\tbr.close();\n\t\t\t\n\t\t\tFileWriter fw=new FileWriter(new File(convertedfile));\n\t\t\t\n\t\t\tfw.write(sb.toString());\n\t\t\tfw.close();\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t}\n}\n"}
{"id": 415566, "name": "Snake and ladder", "source": "Translate Perl to Java: \nmy %snl =( 4, 14,  9, 31, 17,  7, 20, 38, 28, 84, 40, 59, 51, 67, 54, 34,\n          62, 19, 63, 81, 64, 60, 71, 91, 87, 24, 93, 73, 95, 75, 99, 78);\n\n@players = (1, 1, 1, 1); \n\nwhile () {\n    for $player (0..$\n       $turn_count++;\n       turn(\\$players[$player], $player + 1, $turn_count);\n    }\n}\n\nsub turn {\n    my($square, $player) = @_;\n    if ($player == @players) { print \"You are on square $$square. Hit enter to roll the die:\"; <> }\n    my $roll = 1 + int rand 6;\n    my $turn = $$square + $roll;\n    print \"Player $player on square %2d rolls a $roll\", $$square;\n    if ($turn > 100) {\n       print \" but cannot move. Next players turn.\\n\";\n       return\n    }\n    if ($snl{$turn}) {\n        $$square = $snl{$turn};\n        if ($turn > $$square) {\n           print \". Oops! Landed on a snake. Slither down to $$square.\\n\"\n        } else {\n           print \". Yay! Landed on a ladder. Climb up to $$square.\\n\"\n        }\n    } else {\n        $$square = $turn;\n        print \" and moves to square $$square\\n\";\n    }\n    if ($$square == 100) {print \"Player $player wins after $turn_count turns.\\n\"; exit }\n    return\n}\n", "target": "import java.util.Map;\nimport java.util.Random;\n\npublic class Game {\n    private static final Map<Integer, Integer> snl = Map.ofEntries(\n        Map.entry(4, 14),\n        Map.entry(9, 31),\n        Map.entry(17, 7),\n        Map.entry(20, 38),\n        Map.entry(28, 84),\n        Map.entry(40, 59),\n        Map.entry(51, 67),\n        Map.entry(54, 34),\n        Map.entry(62, 19),\n        Map.entry(63, 81),\n        Map.entry(64, 60),\n        Map.entry(71, 91),\n        Map.entry(87, 24),\n        Map.entry(93, 73),\n        Map.entry(95, 75),\n        Map.entry(99, 78)\n    );\n    private static final boolean sixesThrowAgain = true;\n    private static Random rand = new Random();\n\n    private static int turn(int player, int square) {\n        int square2 = square;\n        while (true) {\n            int roll = rand.nextInt(6) + 1;\n            System.out.printf(\"Player %d, on square %d, rolls a %d\", player, square2, roll);\n            if (square2 + roll > 100) {\n                System.out.println(\" but cannot move.\");\n            } else {\n                square2 += roll;\n                System.out.printf(\" and moves to square %d\\n\", square2);\n                if (square2 == 100) return 100;\n                Integer next = snl.getOrDefault(square2, square2);\n                if (square2 < next) {\n                    System.out.printf(\"Yay! Landed on a ladder. Climb up to %d.\\n\", next);\n                    if (next == 100) return 100;\n                    square2 = next;\n                } else if (square2 > next) {\n                    System.out.printf(\"Oops! Landed on a snake. Slither down to %d.\\n\", next);\n                    square2 = next;\n                }\n            }\n            if (roll < 6 || !sixesThrowAgain) return square2;\n            System.out.println(\"Rolled a 6 so roll again.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        \n        int[] players = {1, 1, 1};\n        while (true) {\n            for (int i = 0; i < players.length; ++i) {\n                int ns = turn(i + 1, players[i]);\n                if (ns == 100) {\n                    System.out.printf(\"Player %d wins!\\n\", i + 1);\n                    return;\n                }\n                players[i] = ns;\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415567, "name": "Snake and ladder", "source": "Translate Perl to Java: \nmy %snl =( 4, 14,  9, 31, 17,  7, 20, 38, 28, 84, 40, 59, 51, 67, 54, 34,\n          62, 19, 63, 81, 64, 60, 71, 91, 87, 24, 93, 73, 95, 75, 99, 78);\n\n@players = (1, 1, 1, 1); \n\nwhile () {\n    for $player (0..$\n       $turn_count++;\n       turn(\\$players[$player], $player + 1, $turn_count);\n    }\n}\n\nsub turn {\n    my($square, $player) = @_;\n    if ($player == @players) { print \"You are on square $$square. Hit enter to roll the die:\"; <> }\n    my $roll = 1 + int rand 6;\n    my $turn = $$square + $roll;\n    print \"Player $player on square %2d rolls a $roll\", $$square;\n    if ($turn > 100) {\n       print \" but cannot move. Next players turn.\\n\";\n       return\n    }\n    if ($snl{$turn}) {\n        $$square = $snl{$turn};\n        if ($turn > $$square) {\n           print \". Oops! Landed on a snake. Slither down to $$square.\\n\"\n        } else {\n           print \". Yay! Landed on a ladder. Climb up to $$square.\\n\"\n        }\n    } else {\n        $$square = $turn;\n        print \" and moves to square $$square\\n\";\n    }\n    if ($$square == 100) {print \"Player $player wins after $turn_count turns.\\n\"; exit }\n    return\n}\n", "target": "import java.util.Map;\nimport java.util.Random;\n\npublic class Game {\n    private static final Map<Integer, Integer> snl = Map.ofEntries(\n        Map.entry(4, 14),\n        Map.entry(9, 31),\n        Map.entry(17, 7),\n        Map.entry(20, 38),\n        Map.entry(28, 84),\n        Map.entry(40, 59),\n        Map.entry(51, 67),\n        Map.entry(54, 34),\n        Map.entry(62, 19),\n        Map.entry(63, 81),\n        Map.entry(64, 60),\n        Map.entry(71, 91),\n        Map.entry(87, 24),\n        Map.entry(93, 73),\n        Map.entry(95, 75),\n        Map.entry(99, 78)\n    );\n    private static final boolean sixesThrowAgain = true;\n    private static Random rand = new Random();\n\n    private static int turn(int player, int square) {\n        int square2 = square;\n        while (true) {\n            int roll = rand.nextInt(6) + 1;\n            System.out.printf(\"Player %d, on square %d, rolls a %d\", player, square2, roll);\n            if (square2 + roll > 100) {\n                System.out.println(\" but cannot move.\");\n            } else {\n                square2 += roll;\n                System.out.printf(\" and moves to square %d\\n\", square2);\n                if (square2 == 100) return 100;\n                Integer next = snl.getOrDefault(square2, square2);\n                if (square2 < next) {\n                    System.out.printf(\"Yay! Landed on a ladder. Climb up to %d.\\n\", next);\n                    if (next == 100) return 100;\n                    square2 = next;\n                } else if (square2 > next) {\n                    System.out.printf(\"Oops! Landed on a snake. Slither down to %d.\\n\", next);\n                    square2 = next;\n                }\n            }\n            if (roll < 6 || !sixesThrowAgain) return square2;\n            System.out.println(\"Rolled a 6 so roll again.\");\n        }\n    }\n\n    public static void main(String[] args) {\n        \n        int[] players = {1, 1, 1};\n        while (true) {\n            for (int i = 0; i < players.length; ++i) {\n                int ns = turn(i + 1, players[i]);\n                if (ns == 100) {\n                    System.out.printf(\"Player %d wins!\\n\", i + 1);\n                    return;\n                }\n                players[i] = ns;\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415568, "name": "Farey sequence", "source": "Translate Perl to Java: use warnings;\nuse strict;\nuse Math::BigRat;\nuse ntheory qw/euler_phi vecsum/;\n\nsub farey {\n  my $N = shift;\n  my @f;\n  my($m0,$n0, $m1,$n1) = (0, 1, 1, $N);\n  push @f, Math::BigRat->new(\"$m0/$n0\");\n  push @f, Math::BigRat->new(\"$m1/$n1\");\n  while ($f[-1] < 1) {\n    my $m = int( ($n0 + $N) / $n1) * $m1 - $m0;\n    my $n = int( ($n0 + $N) / $n1) * $n1 - $n0;\n    ($m0,$n0, $m1,$n1) = ($m1,$n1, $m,$n);\n    push @f, Math::BigRat->new(\"$m/$n\");\n  }\n  @f;\n}\nsub farey_count { 1 + vecsum(euler_phi(1, shift)); }\n\nfor (1 .. 11) {\n  my @f = map { join \"/\", $_->parts }   \n          farey($_);\n  print \"F$_: [@f]\\n\";\n}\nfor (1 .. 10, 100000) {\n  print \"F${_}00: \", farey_count(100*$_), \" members\\n\";\n}\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 415569, "name": "Farey sequence", "source": "Translate Perl to Java: use warnings;\nuse strict;\nuse Math::BigRat;\nuse ntheory qw/euler_phi vecsum/;\n\nsub farey {\n  my $N = shift;\n  my @f;\n  my($m0,$n0, $m1,$n1) = (0, 1, 1, $N);\n  push @f, Math::BigRat->new(\"$m0/$n0\");\n  push @f, Math::BigRat->new(\"$m1/$n1\");\n  while ($f[-1] < 1) {\n    my $m = int( ($n0 + $N) / $n1) * $m1 - $m0;\n    my $n = int( ($n0 + $N) / $n1) * $n1 - $n0;\n    ($m0,$n0, $m1,$n1) = ($m1,$n1, $m,$n);\n    push @f, Math::BigRat->new(\"$m/$n\");\n  }\n  @f;\n}\nsub farey_count { 1 + vecsum(euler_phi(1, shift)); }\n\nfor (1 .. 11) {\n  my @f = map { join \"/\", $_->parts }   \n          farey($_);\n  print \"F$_: [@f]\\n\";\n}\nfor (1 .. 10, 100000) {\n  print \"F${_}00: \", farey_count(100*$_), \" members\\n\";\n}\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 415570, "name": "Aliquot sequence classifications", "source": "Translate Perl to Java: use ntheory qw/divisor_sum/;\n\nsub aliquot {\n  my($n, $maxterms, $maxn) = @_;\n  $maxterms = 16 unless defined $maxterms;\n  $maxn = 2**47 unless defined $maxn;\n\n  my %terms = ($n => 1);\n  my @allterms = ($n);\n  for my $term (2 .. $maxterms) {\n    $n = divisor_sum($n)-$n;\n    \n    last if $n > $maxn;\n    return (\"terminates\",@allterms, 0) if $n == 0;\n    if (defined $terms{$n}) {\n      return (\"perfect\",@allterms)  if $term == 2 && $terms{$n} == 1;\n      return (\"amicible\",@allterms) if $term == 3 && $terms{$n} == 1;\n      return (\"sociable-\".($term-1),@allterms) if $term >  3 && $terms{$n} == 1;\n      return (\"aspiring\",@allterms) if $terms{$n} == $term-1;\n      return (\"cyclic-\".($term-$terms{$n}),@allterms)   if $terms{$n} < $term-1;\n    }\n    $terms{$n} = $term;\n    push @allterms, $n;\n  }\n  (\"non-term\",@allterms);\n}\n\nfor my $n (1..10) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\nprint \"\\n\";\nfor my $n (qw/11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080/) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 415571, "name": "Aliquot sequence classifications", "source": "Translate Perl to Java: use ntheory qw/divisor_sum/;\n\nsub aliquot {\n  my($n, $maxterms, $maxn) = @_;\n  $maxterms = 16 unless defined $maxterms;\n  $maxn = 2**47 unless defined $maxn;\n\n  my %terms = ($n => 1);\n  my @allterms = ($n);\n  for my $term (2 .. $maxterms) {\n    $n = divisor_sum($n)-$n;\n    \n    last if $n > $maxn;\n    return (\"terminates\",@allterms, 0) if $n == 0;\n    if (defined $terms{$n}) {\n      return (\"perfect\",@allterms)  if $term == 2 && $terms{$n} == 1;\n      return (\"amicible\",@allterms) if $term == 3 && $terms{$n} == 1;\n      return (\"sociable-\".($term-1),@allterms) if $term >  3 && $terms{$n} == 1;\n      return (\"aspiring\",@allterms) if $terms{$n} == $term-1;\n      return (\"cyclic-\".($term-$terms{$n}),@allterms)   if $terms{$n} < $term-1;\n    }\n    $terms{$n} = $term;\n    push @allterms, $n;\n  }\n  (\"non-term\",@allterms);\n}\n\nfor my $n (1..10) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\nprint \"\\n\";\nfor my $n (qw/11 12 28 496 220 1184 12496 1264460 790 909 562 1064 1488 15355717786080/) {\n  my($class, @seq) = aliquot($n);\n  printf \"%14d %10s [@seq]\\n\", $n, $class;\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 415572, "name": "Implicit type conversion", "source": "Translate Perl to Java: print  1  + '2';  \nprint '1' + '2';  \nprint  1  .  1;   \n\n$a = 1;\n$b = 2;\nsay \"$a+$b\";  \n\n\nsay hex int( (2 . 0 x '2') ** substr 98.5, '2', '2' ) . 'beef'; \n", "target": "public class ImplicitTypeConversion{\n   public static void main(String...args){\n      System.out.println( \"Primitive conversions\" );\n      byte  by = -1;\n      short sh = by;\n      int   in = sh;\n      long  lo = in;\n      System.out.println( \"byte value    -1         to 3 integral types:  \" + lo );\n\n      float  fl = 0.1f;\n      double db = fl;\n      System.out.println( \"float value   0.1        to double:            \" + db );\n\n      int    in2 = -1;\n      float  fl2 = in2;\n      double db2 = fl2;\n      System.out.println( \"int value     -1         to float and double:  \" + db2 );\n\n      int    in3 = Integer.MAX_VALUE;\n      float  fl3 = in3;\n      double db3 = fl3;\n      System.out.println( \"int value     \" + Integer.MAX_VALUE + \" to float and double:  \" + db3 );\n\n      char   ch  = 'a';\n      int    in4 = ch;\n      double db4 = in4;\n      System.out.println( \"char value    '\" + ch + \"'        to int and double:    \" + db4 );\n\n      System.out.println();\n      System.out.println( \"Boxing and unboxing\" );\n      Integer in5 = -1;\n      int     in6 = in5;\n      System.out.println( \"int  value    -1         to Integer and int:   \" + in6 );\n\n      Double db5 = 0.1;\n      double db6 = db5;\n      System.out.println( \"double value  0.1        to Double and double: \" + db6 );\n   }\n}\n"}
{"id": 415573, "name": "Implicit type conversion", "source": "Translate Perl to Java: print  1  + '2';  \nprint '1' + '2';  \nprint  1  .  1;   \n\n$a = 1;\n$b = 2;\nsay \"$a+$b\";  \n\n\nsay hex int( (2 . 0 x '2') ** substr 98.5, '2', '2' ) . 'beef'; \n", "target": "public class ImplicitTypeConversion{\n   public static void main(String...args){\n      System.out.println( \"Primitive conversions\" );\n      byte  by = -1;\n      short sh = by;\n      int   in = sh;\n      long  lo = in;\n      System.out.println( \"byte value    -1         to 3 integral types:  \" + lo );\n\n      float  fl = 0.1f;\n      double db = fl;\n      System.out.println( \"float value   0.1        to double:            \" + db );\n\n      int    in2 = -1;\n      float  fl2 = in2;\n      double db2 = fl2;\n      System.out.println( \"int value     -1         to float and double:  \" + db2 );\n\n      int    in3 = Integer.MAX_VALUE;\n      float  fl3 = in3;\n      double db3 = fl3;\n      System.out.println( \"int value     \" + Integer.MAX_VALUE + \" to float and double:  \" + db3 );\n\n      char   ch  = 'a';\n      int    in4 = ch;\n      double db4 = in4;\n      System.out.println( \"char value    '\" + ch + \"'        to int and double:    \" + db4 );\n\n      System.out.println();\n      System.out.println( \"Boxing and unboxing\" );\n      Integer in5 = -1;\n      int     in6 = in5;\n      System.out.println( \"int  value    -1         to Integer and int:   \" + in6 );\n\n      Double db5 = 0.1;\n      double db6 = db5;\n      System.out.println( \"double value  0.1        to Double and double: \" + db6 );\n   }\n}\n"}
{"id": 415574, "name": "Magnanimous numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\n\nsub magnanimous {\n    my($n) = @_;\n    my $last;\n    for my $c (1 .. length($n) - 1) {\n        ++$last and last unless is_prime substr($n,0,$c) + substr($n,$c)\n    }\n    not $last;\n}\n\nmy @M;\nfor ( my $i = 0, my $count = 0; $count < 400; $i++ ) {\n    ++$count and push @M, $i if magnanimous($i);\n}\n\nsay \"First 45 magnanimous numbers\\n\".\n    (sprintf \"@{['%4d' x 45]}\", @M[0..45-1]) =~ s/(.{60})/$1\\n/gr;\n\nsay \"241st through 250th magnanimous numbers\\n\" .\n    join ' ', @M[240..249];\n\nsay \"\\n391st through 400th magnanimous numbers\\n\".\n    join ' ', @M[390..399];\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MagnanimousNumbers {\n\n    public static void main(String[] args) {\n        runTask(\"Find and display the first 45 magnanimous numbers.\", 1, 45);\n        runTask(\"241st through 250th magnanimous numbers.\", 241, 250);\n        runTask(\"391st through 400th magnanimous numbers.\", 391, 400);\n    }\n    \n    private static void runTask(String message, int startN, int endN) {\n        int count = 0;\n        List<Integer> nums = new ArrayList<>();\n        for ( int n = 0 ; count < endN ; n++ ) {\n            if ( isMagnanimous(n) ) {\n                nums.add(n);\n                count++;\n            }\n        }\n        System.out.printf(\"%s%n\", message);\n        System.out.printf(\"%s%n%n\", nums.subList(startN-1, endN));\n    }\n    \n    private static boolean isMagnanimous(long n) {\n        if ( n >= 0 && n <= 9 ) {\n            return true;\n        }\n        long q = 11;\n        for ( long div = 10 ; q >= 10 ; div *= 10 ) {\n            q = n / div;\n            long r = n % div;\n            if ( ! isPrime(q+r) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static final int MAX = 100_000;\n    private static final boolean[] primes = new boolean[MAX];\n    private static boolean SIEVE_COMPLETE = false;\n    \n    private static final boolean isPrimeTrivial(long test) {\n        if ( ! SIEVE_COMPLETE ) {\n            sieve();\n            SIEVE_COMPLETE = true;\n        }\n        return primes[(int) test];\n    }\n    \n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n    \n    public static final boolean isPrime(long testValue) {\n        if ( testValue == 2 ) return true;\n        if ( testValue % 2 == 0 ) return false;\n        if ( testValue <= MAX ) return isPrimeTrivial(testValue);\n        long d = testValue-1;\n        int s = 0;\n        while ( d % 2 == 0 ) {\n            s += 1;\n            d /= 2;\n        }\n        if ( testValue < 1373565L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 4759123141L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(7, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(61, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 10000000000000000L ) {\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(24251, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        \n        if ( ! aSrp(37, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(47, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(61, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(73, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(83, s, d, testValue) ) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private static final boolean aSrp(int a, int s, long d, long n) {\n        long modPow = modPow(a, d, n);\n        \n        if ( modPow == 1 ) {\n            return true;\n        }\n        int twoExpR = 1;\n        for ( int r = 0 ; r < s ; r++ ) {\n            if ( modPow(modPow, twoExpR, n) == n-1 ) {\n                return true;\n            }\n            twoExpR *= 2;\n        }\n        return false;\n    }\n    \n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n    \n    public static final long modPow(long base, long exponent, long modulus) {\n        long result = 1;\n        while ( exponent > 0 ) {\n            if ( exponent % 2 == 1 ) {\n                if ( result > SQRT || base > SQRT ) {\n                    result = multiply(result, base, modulus);\n                }\n                else {\n                    result = (result * base) % modulus;\n                }\n            }\n            exponent >>= 1;\n            if ( base > SQRT ) {\n                base = multiply(base, base, modulus);\n            }\n            else {\n                base = (base * base) % modulus;\n            }\n        }\n        return result;\n    }\n\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        return x % modulus;\n    }\n\n}\n"}
{"id": 415575, "name": "Mersenne primes", "source": "Translate Perl to Java: use ntheory qw/forprimes is_mersenne_prime/;\nforprimes { is_mersenne_prime($_) && say } 1e9;\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 415576, "name": "Mersenne primes", "source": "Translate Perl to Java: use ntheory qw/forprimes is_mersenne_prime/;\nforprimes { is_mersenne_prime($_) && say } 1e9;\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 415577, "name": "Sexy primes", "source": "Translate Perl to Java: use ntheory qw/prime_iterator is_prime/;\n\nsub tuple_tail {\n    my($n,$cnt,@array) = @_;\n    $n = @array if $n > @array;\n    my @tail;\n    for (1..$n) {\n        my $p = $array[-$n+$_-1];\n        push @tail, \"(\" . join(\" \", map { $p+6*$_ } 0..$cnt-1) . \")\";\n    }\n    return @tail;\n}\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    ($s = reverse $s) =~ s/^,//;\n    return $s;\n}\n\nsub sexy_string { my $p = shift; is_prime($p+6) || is_prime($p-6) ? 'sexy' : 'unsexy' }\n\nmy $max = 1_000_035;\nmy $cmax = comma $max;\n\nmy $iter = prime_iterator;\nmy $p = $iter->();\nmy %primes;\npush @{$primes{sexy_string($p)}}, $p;\nwhile ( ($p = $iter->()) < $max) {\n    push @{$primes{sexy_string($p)}}, $p;\n    $p+ 6 < $max && is_prime($p+ 6) ? push @{$primes{'pair'}},       $p : next;\n    $p+12 < $max && is_prime($p+12) ? push @{$primes{'triplet'}},    $p : next;\n    $p+18 < $max && is_prime($p+18) ? push @{$primes{'quadruplet'}}, $p : next;\n    $p+24 < $max && is_prime($p+24) ? push @{$primes{'quintuplet'}}, $p : next;\n}\n\nprint \"Total primes less than $cmax: \" . comma(@{$primes{'sexy'}} + @{$primes{'unsexy'}}) . \"\\n\\n\";\n\nfor (['pair', 2], ['triplet', 3], ['quadruplet', 4], ['quintuplet', 5]) {\n    my($sexy,$cnt) = @$_;\n    print \"Number of sexy prime ${sexy}s less than $cmax: \" . comma(scalar @{$primes{$sexy}}) . \"\\n\";\n    print \"   Last 5 sexy prime ${sexy}s less than $cmax: \" . join(' ', tuple_tail(5,$cnt,@{$primes{$sexy}})) . \"\\n\";\n    print \"\\n\";\n}\n\nprint \"Number of unsexy primes less than $cmax: \". comma(scalar @{$primes{unsexy}}) . \"\\n\";\nprint \"  Last 10 unsexy primes less than $cmax: \". join(' ', @{$primes{unsexy}}[-10..-1]) . \"\\n\";\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SexyPrimes {\n\n    public static void main(String[] args) {\n        sieve();\n        int pairs = 0;\n        List<String> pairList = new ArrayList<>();\n        int triples = 0;\n        List<String> tripleList = new ArrayList<>();\n        int quadruplets = 0;\n        List<String> quadrupletList = new ArrayList<>();\n        int unsexyCount = 1;  \n        List<String> unsexyList = new ArrayList<>();\n        for ( int i = 3 ; i < MAX ; i++ ) {\n            if ( i-6 >= 3 && primes[i-6] && primes[i] ) {\n                pairs++;\n                pairList.add((i-6) + \" \" + i);\n                if ( pairList.size() > 5 ) {\n                    pairList.remove(0);\n                }\n            }\n            else if ( i < MAX-2 && primes[i] && ! (i+6<MAX && primes[i] && primes[i+6])) {\n                unsexyCount++;\n                unsexyList.add(\"\" + i);\n                if ( unsexyList.size() > 10 ) {\n                    unsexyList.remove(0);\n                }\n            }\n            if ( i-12 >= 3 && primes[i-12] && primes[i-6] && primes[i] ) {\n                triples++;\n                tripleList.add((i-12) + \" \" + (i-6) + \" \" + i);\n                if ( tripleList.size() > 5 ) {\n                    tripleList.remove(0);\n                }\n            }\n            if ( i-16 >= 3 && primes[i-18] && primes[i-12] && primes[i-6] && primes[i] ) {\n                quadruplets++;\n                quadrupletList.add((i-18) + \" \" + (i-12) + \" \" + (i-6) + \" \" + i);\n                if ( quadrupletList.size() > 5 ) {\n                    quadrupletList.remove(0);\n                }\n            }\n        }\n        System.out.printf(\"Count of sexy triples less than\u00a0%,d =\u00a0%,d%n\", MAX, pairs);\n        System.out.printf(\"The last 5 sexy pairs:%n  %s%n%n\", pairList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of sexy triples less than\u00a0%,d =\u00a0%,d%n\", MAX, triples);\n        System.out.printf(\"The last 5 sexy triples:%n  %s%n%n\", tripleList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of sexy quadruplets less than\u00a0%,d =\u00a0%,d%n\", MAX, quadruplets);\n        System.out.printf(\"The last 5 sexy quadruplets:%n  %s%n%n\", quadrupletList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of unsexy primes less than\u00a0%,d =\u00a0%,d%n\", MAX, unsexyCount);\n        System.out.printf(\"The last 10 unsexy primes:%n  %s%n%n\", unsexyList.toString().replaceAll(\", \", \"], [\"));\n    }\n\n    private static int MAX = 1_000_035;\n    private static boolean[] primes = new boolean[MAX];\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 415578, "name": "Taxicab numbers", "source": "Translate Perl to Java: my($beg, $end) = (@ARGV==0) ? (1,25) : (@ARGV==1) ? (1,shift) : (shift,shift);\n\nmy $lim = 1e14;  \nmy @basis = map { $_*$_*$_ } (1 .. int($lim ** (1.0/3.0) + 1));\nmy $paira = 2;  \n\nmy ($segsize, $low, $high, $i) = (500_000_000, 0, 0, 0);\n\nwhile ($i < $end) {\n  $low = $high+1;\n  die \"lim too low\" if $low > $lim;\n  $high = $low + $segsize - 1;\n  $high = $lim if $high > $lim;\n  foreach my $p (_find_pairs_segment(\\@basis, $paira, $low, $high,\n                 sub { sprintf(\"%4d^3 + %4d^3\", $_[0], $_[1]) })    ) {\n    $i++;\n    next if $i < $beg;\n    last if $i > $end;\n    my $n = shift @$p;\n    printf \"%4d: %10d  = %s\\n\", $i, $n, join(\"  = \", @$p);\n  }\n}\n\nsub _find_pairs_segment {\n  my($p, $len, $start, $end, $formatsub) = @_;\n  my $plen = $\n\n  my %allpairs;\n  foreach my $i (0 .. $plen) {\n    my $pi = $p->[$i];\n    next if ($pi+$p->[$plen]) < $start;\n    last if (2*$pi) > $end;\n    foreach my $j ($i .. $plen) {\n      my $sum = $pi + $p->[$j];\n      next if $sum < $start;\n      last if $sum > $end;\n      push @{ $allpairs{$sum} }, $i, $j;\n    }\n    \n    \n  }\n\n  my @retlist;\n  foreach my $list (grep { scalar @$_ >= $len*2 } values %allpairs) {\n    my $n = $p->[$list->[0]] + $p->[$list->[1]];\n    my @pairlist;\n    while (@$list) {\n      push @pairlist, $formatsub->(1 + shift @$list, 1 + shift @$list);\n    }\n    push @retlist, [$n, @pairlist];\n  }\n  @retlist = sort { $a->[0] <=> $b->[0] } @retlist;\n  return @retlist;\n}\n", "target": "import java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Iterator;\n\nclass CubeSum implements Comparable<CubeSum> {\n\tpublic long x, y, value;\n\n\tpublic CubeSum(long x, long y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.value = x*x*x + y*y*y;\n\t}\n\n\tpublic String toString() {\n\t\treturn String.format(\"%4d^3 + %4d^3\", x, y);\n\t}\n\n\tpublic int compareTo(CubeSum that) {\n\t\treturn value < that.value ? -1 : value > that.value ? 1 : 0;\n\t}\n}\n\nclass SumIterator implements Iterator<CubeSum> {\n\tPriorityQueue<CubeSum> pq = new PriorityQueue<CubeSum>();\n\tlong n = 0;\n\n\tpublic boolean hasNext() { return true; }\n\tpublic CubeSum next() {\n\t\twhile (pq.size() == 0 || pq.peek().value >= n*n*n)\n\t\t\tpq.add(new CubeSum(++n, 1));\n\n\t\tCubeSum s = pq.remove();\n\t\tif (s.x > s.y + 1) pq.add(new CubeSum(s.x, s.y+1));\n\n\t\treturn s;\n\t}\n}\n\nclass TaxiIterator implements Iterator<List<CubeSum>> {\n\tIterator<CubeSum> sumIterator = new SumIterator();\n\tCubeSum last = sumIterator.next();\n\n\tpublic boolean hasNext() { return true; }\n\tpublic List<CubeSum> next() {\n\t\tCubeSum s;\n\t\tList<CubeSum> train = new ArrayList<CubeSum>();\n\n\t\twhile ((s = sumIterator.next()).value != last.value)\n\t\t\tlast = s;\n\n\t\ttrain.add(last);\n\n\t\tdo { train.add(s); } while ((s = sumIterator.next()).value == last.value);\n\t\tlast = s;\n\n\t\treturn train;\n\t}\n}\n\t\npublic class Taxi {\n\tpublic static final void main(String[] args) {\n\t\tIterator<List<CubeSum>> taxi = new TaxiIterator();\n\n\t\tfor (int i = 1; i <= 2006; i++) {\n\t\t\tList<CubeSum> t = taxi.next();\n\t\t\tif (i > 25 && i < 2000) continue;\n\n\t\t\tSystem.out.printf(\"%4d: %10d\", i, t.get(0).value);\n\t\t\tfor (CubeSum s: t)\n\t\t\t\tSystem.out.print(\" = \" + s);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 415579, "name": "Strong and weak primes", "source": "Translate Perl to Java: use ntheory qw(primes vecfirst);\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    $s =~ s/,(-?)$/$1/;\n    $s = reverse $s;\n}\n\nsub below { my ($m, @a) = @_; vecfirst { $a[$_] > $m } 0..$\n\nmy (@strong, @weak, @balanced);\nmy @primes = @{ primes(10_000_019) };\n\nfor my $k (1 .. $\n    my $x = ($primes[$k - 1] + $primes[$k + 1]) / 2;\n    if    ($x > $primes[$k]) { push @weak,     $primes[$k] }\n    elsif ($x < $primes[$k]) { push @strong,   $primes[$k] }\n    else                     { push @balanced, $primes[$k] }\n}\n\nfor ([\\@strong,   'strong',   36, 1e6, 1e7],\n     [\\@weak,     'weak',     37, 1e6, 1e7],\n     [\\@balanced, 'balanced', 28, 1e6, 1e7]) {\n    my($pr, $type, $d, $c1, $c2) = @$_;\n    print \"\\nFirst $d $type primes:\\n\", join ' ', map { comma $_ } @$pr[0..$d-1], \"\\n\";\n    print \"Count of $type primes <=  @{[comma $c1]}:  \" . comma below($c1,@$pr) . \"\\n\";\n    print \"Count of $type primes <= @{[comma $c2]}: \"   . comma scalar @$pr . \"\\n\";\n}\n", "target": "public class StrongAndWeakPrimes {\n\n    private static int MAX = 10_000_000 + 1000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 36 strong primes:\");        \n        displayStrongPrimes(36);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of strong primes below\u00a0%,d =\u00a0%,d%n\", n, strongPrimesBelow(n));\n        }\n        System.out.println(\"First 37 weak primes:\");        \n        displayWeakPrimes(37);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of weak primes below\u00a0%,d =\u00a0%,d%n\", n, weakPrimesBelow(n));\n        }\n    }\n\n    private static int weakPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n\n    private static void displayWeakPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static int getNextPrime(int currentPrime) {\n        int nextPrime = currentPrime + 2;\n        while ( ! primes[nextPrime] ) {\n            nextPrime += 2;\n        }\n        return nextPrime;\n    }\n    \n    private static int strongPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n    \n    private static void displayStrongPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 415580, "name": "Left factorials", "source": "Translate Perl to Java: \nuse 5.010;\nuse strict;\nuse warnings;\nuse bigint;\n\nsub leftfact {\n\tmy ($n) = @_;\n\tstate $cached = 0;\n\tstate $factorial = 1;\n\tstate $leftfact = 0;\n\tif( $n < $cached ) {\n\t\t($cached, $factorial, $leftfact) = (0, 1, 0);\n\t}\n\twhile( $n > $cached ) {\n\t\t$leftfact += $factorial;\n\t\t$factorial *= ++$cached;\n\t}\n\treturn $leftfact;\n}\n\nprintf \"!%d = %s\\n\", $_, leftfact($_) for 0 .. 10, map $_*10, 2..11;\nprintf \"!%d has %d digits.\\n\", $_, length leftfact($_) for map $_*1000, 1..10;\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 415581, "name": "Left factorials", "source": "Translate Perl to Java: \nuse 5.010;\nuse strict;\nuse warnings;\nuse bigint;\n\nsub leftfact {\n\tmy ($n) = @_;\n\tstate $cached = 0;\n\tstate $factorial = 1;\n\tstate $leftfact = 0;\n\tif( $n < $cached ) {\n\t\t($cached, $factorial, $leftfact) = (0, 1, 0);\n\t}\n\twhile( $n > $cached ) {\n\t\t$leftfact += $factorial;\n\t\t$factorial *= ++$cached;\n\t}\n\treturn $leftfact;\n}\n\nprintf \"!%d = %s\\n\", $_, leftfact($_) for 0 .. 10, map $_*10, 2..11;\nprintf \"!%d has %d digits.\\n\", $_, length leftfact($_) for map $_*1000, 1..10;\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 415582, "name": "Strange unique prime triplets", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse List::Util 'sum';\nuse ntheory <primes is_prime>;\nuse Algorithm::Combinatorics 'combinations';\n\nfor my $n (30, 1000) {\n    printf \"Found %d strange unique prime triplets up to $n.\\n\",\n        scalar grep { is_prime(sum @$_) } combinations(primes($n), 3);\n}\n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 415583, "name": "Strange unique prime triplets", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse List::Util 'sum';\nuse ntheory <primes is_prime>;\nuse Algorithm::Combinatorics 'combinations';\n\nfor my $n (30, 1000) {\n    printf \"Found %d strange unique prime triplets up to $n.\\n\",\n        scalar grep { is_prime(sum @$_) } combinations(primes($n), 3);\n}\n", "target": "import java.util.*;\n\npublic class StrangeUniquePrimeTriplets {\n    public static void main(String[] args) {\n        strangeUniquePrimeTriplets(30, true);\n        strangeUniquePrimeTriplets(1000, false);\n    }\n\n    private static void strangeUniquePrimeTriplets(int limit, boolean verbose) {\n        boolean[] sieve = primeSieve(limit * 3);\n        List<Integer> primeList = new ArrayList<>();\n        for (int p = 3; p < limit; p += 2) {\n            if (sieve[p])\n                primeList.add(p);\n        }\n        int n = primeList.size();\n        \n        int[] primes = new int[n];\n        for (int i = 0; i < n; ++i)\n            primes[i] = primeList.get(i);\n        int count = 0;\n        if (verbose)\n            System.out.printf(\"Strange unique prime triplets < %d:\\n\", limit);\n        for (int i = 0; i + 2 < n; ++i) {\n            for (int j = i + 1; j + 1 < n; ++j) {\n                int s = primes[i] + primes[j];\n                for (int k = j + 1; k < n; ++k) {\n                    int sum = s + primes[k];\n                    if (sieve[sum]) {\n                        ++count;\n                        if (verbose)\n                            System.out.printf(\"%2d + %2d + %2d = %2d\\n\", primes[i], primes[j], primes[k], sum);\n                    }\n                }\n            }\n        }\n        System.out.printf(\"\\nCount of strange unique prime triplets < %d is %d.\\n\", limit, count);\n    }\n\n    private static boolean[] primeSieve(int limit) {\n        boolean[] sieve = new boolean[limit];\n        Arrays.fill(sieve, true);\n        if (limit > 0)\n            sieve[0] = false;\n        if (limit > 1)\n            sieve[1] = false;\n        for (int i = 4; i < limit; i += 2)\n            sieve[i] = false;\n        for (int p = 3; ; p += 2) {\n            int q = p * p;\n            if (q >= limit)\n                break;\n            if (sieve[p]) {\n                int inc = 2 * p;\n                for (; q < limit; q += inc)\n                    sieve[q] = false;\n            }\n        }\n        return sieve;\n    }\n}\n"}
{"id": 415584, "name": "Strange plus numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\n\nmy($low, $high) = (100, 500);\nmy $n = my @SP = grep { my @d = split ''; is_prime $d[0]+$d[1] and is_prime $d[1]+$d[2] } $low+1 .. $high-1;\nsay \"Between $low and $high there are $n strange-plus numbers:\\n\" .\n    (sprintf \"@{['%4d' x $n]}\", @SP[0..$n-1]) =~ s/(.{80})/$1\\n/gr;\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 415585, "name": "Smarandache prime-digital sequence", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\nuse ntheory qw<is_prime>;\nuse Lingua::EN::Numbers qw(num2en_ordinal);\n\nmy @prime_digits = <2 3 5 7>;\nmy @spds = grep { is_prime($_) && /^[@{[join '',@prime_digits]}]+$/ } 1..100;\nmy @p    = map { $_+3, $_+7 } map { 10*$_ } @prime_digits;\n\nwhile ($\n    state $o++;\n    my $oom = 10**(1+$o);\n    my @q;\n    for my $l (@prime_digits) {\n        push @q, map { $l*$oom + $_ } @p;\n    }\n    push @spds, grep { is_prime($_) } @p = @q;\n}\n\nsay 'Smarandache prime-digitals:';\nprintf \"%22s: %s\\n\", ucfirst(num2en_ordinal($_)), $spds[$_-1] for 1..25, 100, 1000, 10_000, 100_000;\n", "target": "public class SmarandachePrimeDigitalSequence {\n\n    public static void main(String[] args) {\n        long s = getNextSmarandache(7);\n        System.out.printf(\"First 25 Smarandache prime-digital sequence numbers:%n2 3 5 7 \");\n        for ( int count = 1 ; count <= 21 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                System.out.printf(\"%d \", s);\n                count++;\n            }\n        }\n        System.out.printf(\"%n%n\");\n        for (int i = 2 ; i <=5 ; i++ ) {\n            long n = (long) Math.pow(10, i);\n            System.out.printf(\"%,dth Smarandache prime-digital sequence number = %d%n\", n, getSmarandachePrime(n));\n        }\n    }\n    \n    private static final long getSmarandachePrime(long n) {\n        if ( n < 10 ) {\n            switch ((int) n) {\n            case 1:  return 2;\n            case 2:  return 3;\n            case 3:  return 5;\n            case 4:  return 7;\n            }\n        }\n        long s = getNextSmarandache(7);\n        long result = 0;\n        for ( int count = 1 ; count <= n-4 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                count++;\n                result = s;\n            }\n        }\n        return result;\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static long getNextSmarandache(long n) {\n        \n        if ( n % 10 == 3 ) {\n            return n+4;\n        }\n        long retVal = n-4;\n        \n        \n        int k = 0;\n        while ( n % 10 == 7 ) {\n            k++;\n            n /= 10;\n        }\n        \n        \n        long digit = n % 10;\n\n        \n        long coeff = (digit == 2 ? 1 : 2);\n        \n        \n        retVal += coeff * Math.pow(10, k);\n        \n        \n        while ( k > 1 ) {\n            retVal -= 5 * Math.pow(10, k-1);\n            k--;\n        }\n        \n        \n        return retVal;\n    }\n\n}\n"}
{"id": 415586, "name": "Plasma effect", "source": "Translate Perl to Java: use Imager;\n\nsub plasma {\n    my ($w, $h) = @_;\n\n    my $img = Imager->new(xsize => $w, ysize => $h);\n\n    for my $x (0 .. $w-1) {\n        for my $y (0 .. $h-1) {\n            my $hue = 4 + sin($x/19) + sin($y/9) + sin(($x+$y)/25) + sin(sqrt($x**2 + $y**2)/8);\n            $img->setpixel(x => $x, y => $y, color => {hsv => [360 * $hue / 8, 1, 1]});\n        }\n    }\n\n    return $img;\n}\n\nmy $img = plasma(400, 400);\n$img->write(file => 'plasma-perl.png');\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.awt.image.*;\nimport static java.awt.image.BufferedImage.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class PlasmaEffect extends JPanel {\n    float[][] plasma;\n    float hueShift = 0;\n    BufferedImage img;\n\n    public PlasmaEffect() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        img = new BufferedImage(dim.width, dim.height, TYPE_INT_RGB);\n        plasma = createPlasma(dim.height, dim.width);\n\n        \n        new Timer(42, (ActionEvent e) -> {\n            hueShift = (hueShift + 0.02f) % 1;\n            repaint();\n        }).start();\n    }\n\n    float[][] createPlasma(int w, int h) {\n        float[][] buffer = new float[h][w];\n\n        for (int y = 0; y < h; y++)\n            for (int x = 0; x < w; x++) {\n\n                double value = sin(x / 16.0);\n                value += sin(y / 8.0);\n                value += sin((x + y) / 16.0);\n                value += sin(sqrt(x * x + y * y) / 8.0);\n                value += 4; \n                value /= 8; \n\n                \n                assert (value >= 0.0 && value <= 1.0) : \"Hue value out of bounds\";\n\n                buffer[y][x] = (float) value;\n            }\n        return buffer;\n    }\n\n    void drawPlasma(Graphics2D g) {\n        int h = plasma.length;\n        int w = plasma[0].length;\n        for (int y = 0; y < h; y++)\n            for (int x = 0; x < w; x++) {\n                float hue = hueShift + plasma[y][x] % 1;\n                img.setRGB(x, y, Color.HSBtoRGB(hue, 1, 1));\n            }\n        g.drawImage(img, 0, 0, null);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPlasma(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Plasma Effect\");\n            f.setResizable(false);\n            f.add(new PlasmaEffect(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415587, "name": "Square-free integers", "source": "Translate Perl to Java: use ntheory qw/is_square_free moebius/;\n\nsub square_free_count {\n    my ($n) = @_;\n    my $count = 0;\n    foreach my $k (1 .. sqrt($n)) {\n        $count += moebius($k) * int($n / $k**2);\n    }\n    return $count;\n}\n\nprint \"Square\u2500free numbers between 1 and 145:\\n\";\nprint join(' ', grep { is_square_free($_) } 1 .. 145), \"\\n\";\n\nprint \"\\nSquare-free numbers between 10^12 and 10^12 + 145:\\n\";\nprint join(' ', grep { is_square_free($_) } 1e12 .. 1e12 + 145), \"\\n\";\n\nprint \"\\n\";\nforeach my $n (2 .. 6) {\n    my $c = square_free_count(10**$n);\n    print \"The number of square-free numbers between 1 and 10^$n (inclusive) is: $c\\n\";\n}\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SquareFree\n{\n    private static List<Long> sieve(long limit) {\n        List<Long> primes = new ArrayList<Long>();\n        primes.add(2L);\n        boolean[] c = new boolean[(int)limit + 1]; \n        \n        long p = 3;\n        for (;;) {\n            long p2 = p * p;\n            if (p2 > limit) break;\n            for (long i = p2; i <= limit; i += 2 * p) c[(int)i] = true;\n            for (;;) {\n                p += 2;\n                if (!c[(int)p]) break;\n            }\n        }\n        for (long i = 3; i <= limit; i += 2) {\n            if (!c[(int)i]) primes.add(i);\n        }\n        return primes;\n    }\n\n    private static List<Long> squareFree(long from, long to) {\n        long limit = (long)Math.sqrt((double)to);\n        List<Long> primes = sieve(limit);\n        List<Long> results = new ArrayList<Long>();\n\n        outer: for (long i = from; i <= to; i++) {\n            for (long p : primes) {\n                long p2 = p * p;\n                if (p2 > i) break;\n                if (i % p2 == 0) continue outer;\n            }\n            results.add(i);\n        }\n        return results;\n    }\n\n    private final static long TRILLION = 1000000000000L;\n\n    public static void main(String[] args) {\n        System.out.println(\"Square-free integers from 1 to 145:\");\n        List<Long> sf = squareFree(1, 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 20 == 0) {\n                System.out.println();\n            }\n            System.out.printf(\"%4d\", sf.get(i));\n        }\n\n        System.out.print(\"\\n\\nSquare-free integers\");\n        System.out.printf(\" from %d to %d:\\n\", TRILLION, TRILLION + 145);\n        sf = squareFree(TRILLION, TRILLION + 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 5 == 0) System.out.println();\n            System.out.printf(\"%14d\", sf.get(i));\n        }\n\n        System.out.println(\"\\n\\nNumber of square-free integers:\\n\");\n        long[] tos = {100, 1000, 10000, 100000, 1000000};\n        for (long to : tos) {\n            System.out.printf(\"  from %d to %d = %d\\n\", 1, to, squareFree(1, to).size());\n        }\n    }\n}\n"}
{"id": 415588, "name": "Self numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util qw(max sum);\n\nmy ($i, $pow, $digits, $offset, $lastSelf, @selfs)\n = ( 1,   10,       1,       9,         0,       );\n\nmy $final = 50;\n\nwhile () {\n   my $isSelf = 1;\n   my $sum = my $start = sum split //, max(($i-$offset), 0);\n   for ( my $j = $start; $j < $i; $j++ ) {\n      if ($j+$sum == $i) { $isSelf = 0 ; last }\n      ($j+1)%10 != 0 ? $sum++ : ( $sum = sum split '', ($j+1) );\n   }\n\n   if ($isSelf) {\n      push @selfs, $lastSelf = $i;\n      last if @selfs == $final;\n   }\n\n   next unless ++$i % $pow == 0;\n   $pow *= 10;\n   $offset = 9 * $digits++\n}\n\nsay \"The first 50 self numbers are:\\n\" . join ' ', @selfs;\n", "target": "public class SelfNumbers {\n    private static final int MC = 103 * 1000 * 10000 + 11 * 9 + 1;\n    private static final boolean[] SV = new boolean[MC + 1];\n\n    private static void sieve() {\n        int[] dS = new int[10_000];\n        for (int a = 9, i = 9999; a >= 0; a--) {\n            for (int b = 9; b >= 0; b--) {\n                for (int c = 9, s = a + b; c >= 0; c--) {\n                    for (int d = 9, t = s + c; d >= 0; d--) {\n                        dS[i--] = t + d;\n                    }\n                }\n            }\n        }\n        for (int a = 0, n = 0; a < 103; a++) {\n            for (int b = 0, d = dS[a]; b < 1000; b++, n += 10000) {\n                for (int c = 0, s = d + dS[b] + n; c < 10000; c++) {\n                    SV[dS[c] + s++] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"The first 50 self numbers are:\");\n        for (int i = 0, count = 0; count <= 50; i++) {\n            if (!SV[i]) {\n                count++;\n                if (count <= 50) {\n                    System.out.printf(\"%d \", i);\n                } else {\n                    System.out.printf(\"%n%n       Index     Self number%n\");\n                }\n            }\n        }\n        for (int i = 0, limit = 1, count = 0; i < MC; i++) {\n            if (!SV[i]) {\n                if (++count == limit) {\n                    System.out.printf(\"%,12d  \u00a0%,13d%n\", count, i);\n                    limit *= 10;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415589, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse List::Util 'sum';\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nmy ($index, $last, $gap, $count) = (0, 0, 0, 0);\nmy $threshold = 10_000_000;\n\nprint \"Gap    Index of gap  Starting Niven\\n\";\nwhile (1) {\n    $count++;\n    next unless 0 == $count % sum split //, $count;\n    if ((my $diff = $count - $last) > $gap) {\n        $gap = $diff;\n        printf \"%3d %15s %15s\\n\", $gap, $index > 1 ? comma $index : 1, $last > 1 ? comma $last : 1;\n    }\n    $last = $count;\n    last if ++$index >= $threshold;\n}\n", "target": "public class NivenNumberGaps {\n\n    \n    \n    public static void main(String[] args) {\n        long prevGap = 0;\n        long prevN = 1;\n        long index = 0;\n        System.out.println(\"Gap      Gap Index   Starting Niven\");\n        for ( long n = 2 ; n < 20_000_000_000l ; n++ ) {\n            if ( isNiven(n) ) {\n                index++;\n                long curGap = n - prevN;\n                if ( curGap > prevGap ) {\n                    System.out.printf(\"%3d \u00a0%,13d \u00a0%,15d%n\", curGap, index, prevN);\n                    prevGap = curGap;\n                }\n                prevN = n;\n            }\n        }\n    }\n    \n    public static boolean isNiven(long n) {\n        long sum = 0;\n        long nSave = n;\n        while ( n > 0 ) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return nSave % sum == 0;\n    }\n\n}\n"}
{"id": 415590, "name": "Old Russian measure of length", "source": "Translate Perl to Java: sub convert {\n    my($magnitude, $unit) = @_;\n     my %factor = (\n        tochka     => 0.000254,\n        liniya     => 0.00254,\n        diuym      => 0.0254,\n        vershok    => 0.04445,\n        piad       => 0.1778,\n        fut        => 0.3048,\n        arshin     => 0.7112,\n        sazhen     => 2.1336,\n        versta     => 1066.8,\n        milia      => 7467.6,\n        centimeter => 0.01,\n        meter      => 1.0,\n        kilometer  => 1000.0,\n    );\n\n    my $base= $magnitude * $factor{$unit};\n    my $result .= \"$magnitude $unit to:\\n\";\n    for (sort { $factor{$a} <=> $factor{$b} } keys %factor) {\n        $result .= sprintf \"%10s: %s\\n\", $_, sigdig($base / $factor{$_}, 5) unless $_ eq $unit\n    }\n    return $result;\n}\n\nsub sigdig {\n    my($num,$sig) = @_;\n    return $num unless $num =~ /\\./;\n\n    $num =~ /([1-9]\\d*\\.?\\d*)/;\n    my $prefix = $`;\n    my $match  = $&;\n    $sig++ if $match =~ /\\./;\n    my $digits = substr $match, 0, $sig;\n    my $nextd  = substr $match, $sig, 1;\n    $digits =~ s/(.)$/{1+$1}/e if $nextd > 5;\n    return $prefix . $digits;\n}\n\nprint convert(1,'meter'), \"\\n\\n\";\nprint convert(1,'milia'), \"\\n\";\n", "target": "public class OldRussianMeasures {\n\n    final static String[] keys = {\"tochka\", \"liniya\", \"centimeter\", \"diuym\",\n        \"vershok\", \"piad\", \"fut\", \"arshin\", \"meter\", \"sazhen\", \"kilometer\",\n        \"versta\", \"milia\"};\n\n    final static double[] values = {0.000254, 0.00254, 0.01,0.0254,\n        0.04445, 0.1778, 0.3048, 0.7112, 1.0, 2.1336, 1000.0,\n        1066.8, 7467.6};\n\n    public static void main(String[] a) {\n        if (a.length == 2 && a[0].matches(\"[+-]?\\\\d*(\\\\.\\\\d+)?\")) {\n            double inputVal = lookup(a[1]);\n            if (!Double.isNaN(inputVal)) {\n                double magnitude = Double.parseDouble(a[0]);\n                double meters = magnitude * inputVal;\n                System.out.printf(\"%s %s to: %n%n\", a[0], a[1]);\n                for (String k: keys)\n                    System.out.printf(\"%10s: %g%n\", k, meters / lookup(k));\n                return;\n            }\n        }\n        System.out.println(\"Please provide a number and unit\");\n\n    }\n\n    public static double lookup(String key) {\n        for (int i = 0; i < keys.length; i++)\n            if (keys[i].equals(key))\n                return values[i];\n        return Double.NaN;\n    }\n}\n"}
{"id": 415591, "name": "Pancake numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub pancake {\n    my($n) = @_;\n    my ($gap, $sum, $adj) = (2, 2, -1);\n    while ($sum < $n) { $sum += $gap = $gap * 2 - 1 and $adj++ }\n    $n + $adj;\n}\n\nmy $out;\n$out .= sprintf \"p(%2d) = %2d \", $_, pancake $_ for 1..20;\nsay $out =~ s/.{1,55}\\K /\\n/gr;\n\n\nsub pancake2 {\n    my ($n) = @_;\n    my $numStacks = 1;\n    my @goalStack = 1 .. $n;\n    my %newStacks = my %stacks = (join(' ',@goalStack), 0);\n    for my $k (1..1000) {\n        my %nextStacks;\n        for my $pos (2..$n) {\n            for my $key (keys %newStacks) {\n                my @arr = split ' ', $key;\n                my $cakes = join ' ', (reverse @arr[0..$pos-1]), @arr[$pos..$\n                $nextStacks{$cakes} = $k unless $stacks{$cakes};\n            }\n        }\n        %stacks = (%stacks, (%newStacks = %nextStacks));\n        my $perms    = scalar %stacks;\n        my %inverted = reverse %stacks;\n        return $k-1, $inverted{(sort keys %inverted)[-1]} if $perms == $numStacks;\n        $numStacks = $perms;\n   }\n}\n\nsay \"\\nThe maximum number of flips to sort a given number of elements is:\";\nfor my $n (1..9) {\n    my ($a,$b) = pancake2($n);\n    say \"pancake($n) = $a example: $b\";\n}\n", "target": "public class Pancake {\n    private static int pancake(int n) {\n        int gap = 2;\n        int sum = 2;\n        int adj = -1;\n        while (sum < n) {\n            adj++;\n            gap = 2 * gap - 1;\n            sum += gap;\n        }\n        return n + adj;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 4; i++) {\n            for (int j = 1; j < 6; j++) {\n                int n = 5 * i + j;\n                System.out.printf(\"p(%2d) = %2d  \", n, pancake(n));\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415592, "name": "Pythagorean quadruples", "source": "Translate Perl to Java: my $N = 2200;\npush @sq, $_**2 for 0 .. $N;\nmy @not = (0) x $N;\n@not[0] = 1;\n\n\nfor my $d (1 .. $N) {\n    my $last = 0;\n    for my $a (reverse ceiling($d/3) .. $d) {\n        for my $b (1 .. ceiling($a/2)) {\n            my $ab = $sq[$a] + $sq[$b];\n            last if $ab > $sq[$d];\n            my $x = sqrt($sq[$d] - $ab);\n            if ($x == int $x) {\n                $not[$d] = 1;\n                $last = 1;\n                last\n            }\n        }\n        last if $last;\n    }\n}\n\nsub ceiling { int $_[0] + 1 - 1e-15 }\n\nfor (0 .. $\n    $result .= \"$_ \" unless $not[$_]\n}\nprint \"$result\\n\"\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PythagoreanQuadruples {\n\n    public static void main(String[] args) {\n        long d = 2200;\n        System.out.printf(\"Values of d < %d where a, b, and c are non-zero and a^2 + b^2 + c^2 = d^2 has no solutions:%n%s%n\", d, getPythagoreanQuadruples(d));\n    }\n\n    \n    private static List<Long> getPythagoreanQuadruples(long max) {\n        List<Long> list = new ArrayList<>();\n        long n = -1;\n        long m = -1;\n        while ( true ) {\n            long nTest = (long) Math.pow(2, n+1);\n            long mTest = (long) (5L * Math.pow(2, m+1));\n            long test = 0;\n            if ( nTest > mTest ) {\n                test = mTest;\n                m++;\n            }\n            else {\n                test = nTest;\n                n++;\n            }\n            if ( test < max ) {\n                list.add(test);\n            }\n            else {\n                break;\n            }\n        }\n        return list;\n    }\n\n}\n"}
{"id": 415593, "name": "Sum and product puzzle", "source": "Translate Perl to Java: use List::Util qw(none);\n\nsub grep_unique {\n    my($by, @list) = @_;\n    my @seen;\n    for (@list) {\n        my $x = &$by(@$_);\n        $seen[$x]= defined $seen[$x] ? 0 : join ' ', @$_;\n    }\n    grep { $_ } @seen;\n}\n\nsub sums {\n    my($n) = @_;\n    my @sums;\n    push @sums, [$_, $n - $_] for 2 .. int $n/2;\n    @sums;\n}\n\nsub sum     { $_[0] + $_[1] }\nsub product { $_[0] * $_[1] }\n\nfor $i (2..97) {\n    push @all_pairs, map { [$i, $_] } $i + 1..98\n}\n\n\n%p_unique = map { $_ => 1 } grep_unique(\\&product, @all_pairs);\nfor my $p (@all_pairs) {\n    push @s_pairs, [@$p] if none { $p_unique{join ' ', @$_} } sums sum @$p;\n}\n\n\n@p_pairs = map { [split ' ', $_] } grep_unique(\\&product, @s_pairs);\n\n\n@final_pair = grep_unique(\\&sum, @p_pairs);\n\nprintf \"X = %d, Y = %d\\n\", split ' ', $final_pair[0];\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SumAndProductPuzzle {\n    private final long beginning;\n    private final int maxSum;\n    private static final int MIN_VALUE = 2;\n    private List<int[]> firstConditionExcludes = new ArrayList<>();\n    private List<int[]> secondConditionExcludes = new ArrayList<>();\n    \n    public static void main(String... args){\n        \n        if (args.length == 0){\n            new SumAndProductPuzzle(100).run();\n            new SumAndProductPuzzle(1684).run();\n            new SumAndProductPuzzle(1685).run();\n        } else {\n            for (String arg : args){\n                try{\n                    new SumAndProductPuzzle(Integer.valueOf(arg)).run();\n                } catch (NumberFormatException e){\n                    System.out.println(\"Please provide only integer arguments. \" +\n                            \"Provided argument \" + arg + \" was not an integer. \" +\n                            \"Alternatively, calling the program with no arguments \" +\n                            \"will run the puzzle where maximum sum equals 100, 1684, and 1865.\");\n                }\n            }\n        }\n    }\n    \n    public SumAndProductPuzzle(int maxSum){\n        this.beginning = System.currentTimeMillis();\n        this.maxSum = maxSum;\n        System.out.println(\"Run with maximum sum of \" + String.valueOf(maxSum) + \n                \" started at \" + String.valueOf(beginning) + \".\");\n    }\n    \n    public void run(){\n        for (int x = MIN_VALUE; x < maxSum - MIN_VALUE; x++){\n            for (int y = x + 1; y < maxSum - MIN_VALUE; y++){\n                \n                if (isSumNoGreaterThanMax(x,y) &&\n                    isSKnowsPCannotKnow(x,y) &&\n                    isPKnowsNow(x,y) &&\n                    isSKnowsNow(x,y)\n                    ){\n                    System.out.println(\"Found solution x is \" + String.valueOf(x) + \" y is \" + String.valueOf(y) + \n                            \" in \" + String.valueOf(System.currentTimeMillis() - beginning) + \"ms.\");\n                }\n            }\n        }\n        System.out.println(\"Run with maximum sum of \" + String.valueOf(maxSum) + \n                \" ended in \" + String.valueOf(System.currentTimeMillis() - beginning) + \"ms.\");\n    }\n    \n    public boolean isSumNoGreaterThanMax(int x, int y){\n        return x + y <= maxSum;\n    }\n    \n    public boolean isSKnowsPCannotKnow(int x, int y){\n        \n        if (firstConditionExcludes.contains(new int[] {x, y})){\n            return false;\n        }\n        \n        for (int[] addends : sumAddends(x, y)){\n            if ( !(productFactors(addends[0], addends[1]).size() > 1) ) {\n                firstConditionExcludes.add(new int[] {x, y});\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public boolean isPKnowsNow(int x, int y){\n        \n        if (secondConditionExcludes.contains(new int[] {x, y})){\n            return false;\n        }\n        \n        int countSolutions = 0;\n        for (int[] factors : productFactors(x, y)){\n            if (isSKnowsPCannotKnow(factors[0], factors[1])){\n                countSolutions++;\n            }\n        }\n        \n        if (countSolutions == 1){\n            return true;\n        } else {\n            secondConditionExcludes.add(new int[] {x, y});\n            return false;\n        }\n    }\n    \n    public boolean isSKnowsNow(int x, int y){\n        \n        int countSolutions = 0;\n        for (int[] addends : sumAddends(x, y)){\n            if (isPKnowsNow(addends[0], addends[1])){\n                countSolutions++;\n            }\n        }\n        return countSolutions == 1;\n    }\n    \n    public List<int[]> sumAddends(int x, int y){\n        \n        List<int[]> list = new ArrayList<>();\n        int sum = x + y;\n        \n        for (int addend = MIN_VALUE; addend < sum - addend; addend++){\n            if (isSumNoGreaterThanMax(addend, sum - addend)){\n                list.add(new int[]{addend, sum - addend});\n            }\n        }\n        return list;\n    }\n    \n    public List<int[]> productFactors(int x, int y){\n        \n        List<int[]> list = new ArrayList<>();\n        int product = x * y;\n        \n        for (int factor = MIN_VALUE; factor < product / factor; factor++){\n            if (product % factor == 0){\n                if (isSumNoGreaterThanMax(factor, product / factor)){\n                    list.add(new int[]{factor, product / factor});\n                }\n            }\n        }\n        return list;\n    }\n}\n"}
{"id": 415594, "name": "Superpermutation minimisation", "source": "Translate Perl to Java: use ntheory qw/forperm/;\nfor my $len (1..8) {\n  my($pre, $post, $t) = (\"\",\"\");\n  forperm {\n    $t = join \"\",@_;\n    $post .= $t      unless index($post ,$t) >= 0;\n    $pre = $t . $pre unless index($pre, $t) >= 0;\n  } $len;\n  printf \"%2d: %8d %8d\\n\", $len, length($pre), length($post);\n}\n", "target": "import static java.util.stream.IntStream.rangeClosed;\n\npublic class Test {\n    final static int nMax = 12;\n\n    static char[] superperm;\n    static int pos;\n    static int[] count = new int[nMax];\n\n    static int factSum(int n) {\n        return rangeClosed(1, n)\n                .map(m -> rangeClosed(1, m).reduce(1, (a, b) -> a * b)).sum();\n    }\n\n    static boolean r(int n) {\n        if (n == 0)\n            return false;\n\n        char c = superperm[pos - n];\n        if (--count[n] == 0) {\n            count[n] = n;\n            if (!r(n - 1))\n                return false;\n        }\n        superperm[pos++] = c;\n        return true;\n    }\n\n    static void superPerm(int n) {\n        String chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n        pos = n;\n        superperm = new char[factSum(n)];\n\n        for (int i = 0; i < n + 1; i++)\n            count[i] = i;\n        for (int i = 1; i < n + 1; i++)\n            superperm[i - 1] = chars.charAt(i);\n\n        while (r(n)) {\n        }\n    }\n\n    public static void main(String[] args) {\n        for (int n = 0; n < nMax; n++) {\n            superPerm(n);\n            System.out.printf(\"superPerm(%2d) len = %d\", n, superperm.length);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415595, "name": "Test integerness", "source": "Translate Perl to Java: use Math::Complex;\n\nsub is_int {\n    my $number = shift;\n    \n    if (ref $number eq 'Math::Complex') {\n        return 0 if $number->Im != 0;\n        $number = $number->Re;\n    }\n    \n    return int($number) == $number;\n}\n\nfor (5, 4.1, sqrt(2), sqrt(4), 1.1e10, 3.0-0.0*i, 4-3*i, 5.6+0*i) {\n    printf \"%20s is%s an integer\\n\", $_, (is_int($_) ? \"\" : \" NOT\");\n}\n", "target": "import java.math.BigDecimal;\nimport java.util.List;\n\npublic class TestIntegerness {\n    private static boolean isLong(double d) {\n        return isLong(d, 0.0);\n    }\n\n    private static boolean isLong(double d, double tolerance) {\n        return (d - Math.floor(d)) <= tolerance || (Math.ceil(d) - d) <= tolerance;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static boolean isBigInteger(BigDecimal bd) {\n        try {\n            bd.toBigIntegerExact();\n            return true;\n        } catch (ArithmeticException ex) {\n            return false;\n        }\n    }\n\n    private static class Rational {\n        long num;\n        long denom;\n\n        Rational(int num, int denom) {\n            this.num = num;\n            this.denom = denom;\n        }\n\n        boolean isLong() {\n            return num % denom == 0;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s/%s\", num, denom);\n        }\n    }\n\n    private static class Complex {\n        double real;\n        double imag;\n\n        Complex(double real, double imag) {\n            this.real = real;\n            this.imag = imag;\n        }\n\n        boolean isLong() {\n            return TestIntegerness.isLong(real) && imag == 0.0;\n        }\n\n        @Override\n        public String toString() {\n            if (imag >= 0.0) {\n                return String.format(\"%s + %si\", real, imag);\n            }\n            return String.format(\"%s - %si\", real, imag);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Double> da = List.of(25.000000, 24.999999, 25.000100);\n        for (Double d : da) {\n            boolean exact = isLong(d);\n            System.out.printf(\"%.6f is %s integer%n\", d, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        double tolerance = 0.00001;\n        System.out.printf(\"With a tolerance of\u00a0%.5f:%n\", tolerance);\n        for (Double d : da) {\n            boolean fuzzy = isLong(d, tolerance);\n            System.out.printf(\"%.6f is %s integer%n\", d, fuzzy ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Double> fa = List.of(-2.1e120, -5e-2, Double.NaN, Double.POSITIVE_INFINITY);\n        for (Double f : fa) {\n            boolean exact = !f.isNaN() && !f.isInfinite() && isBigInteger(new BigDecimal(f.toString()));\n            System.out.printf(\"%s is %s integer%n\", f, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Complex> ca = List.of(new Complex(5.0, 0.0), new Complex(5.0, -5.0));\n        for (Complex c : ca) {\n            boolean exact = c.isLong();\n            System.out.printf(\"%s is %s integer%n\", c, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Rational> ra = List.of(new Rational(24, 8), new Rational(-5, 1), new Rational(17, 2));\n        for (Rational r : ra) {\n            boolean exact = r.isLong();\n            System.out.printf(\"%s is %s integer%n\", r, exact ? \"an\" : \"not an\");\n        }\n    }\n}\n"}
{"id": 415596, "name": "Linux CPU utilization", "source": "Translate Perl to Java: $last_total = 0;\n$last_idle  = 0;\n\nwhile () {\n    @cpu = split /\\s+/, `head -1 /proc/stat`;\n    shift @cpu;\n    $this_total  = 0;\n    $this_total += $_ for @cpu;\n    $delta_total = $this_total - $last_total;\n    $this_idle   = $cpu[3]     - $last_idle;\n    $delta_idle  = $this_idle  - $last_idle;\n    $last_total  = $this_total;\n    $last_idle   = $this_idle;\n    printf \"Utilization: %0.1f%%\\n\", 100 * (1 - $delta_idle / $delta_total);\n    sleep 1;\n}\n", "target": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.text.NumberFormat;\nimport java.time.Duration;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws FileNotFoundException {\n        \n        final var period = Duration.ofSeconds(1);\n        new Timer().schedule(new CpuUtilizationTask(), 0, period.toMillis());\n    }\n\n    \n    static class CpuUtilizationTask extends TimerTask {\n\n        private final String STAT_FILE_HEADER = \"cpu  \";\n        private final NumberFormat percentFormatter;\n        private final RandomAccessFile statPointer;\n        long previousIdleTime = 0, previousTotalTime = 0;\n\n        public CpuUtilizationTask() throws FileNotFoundException {\n            this.percentFormatter = NumberFormat.getPercentInstance();\n            percentFormatter.setMaximumFractionDigits(2);\n            var statFile = new File(\"/proc/stat\");\n            \n            this.statPointer = new RandomAccessFile(statFile, \"r\");\n        }\n\n        @Override\n        public void run() {\n\n            try {\n                var values = statPointer.readLine()\n                        .substring(STAT_FILE_HEADER.length())\n                        .split(\" \");\n\n                \n                var idleTime = Long.parseUnsignedLong(values[3]);\n                var totalTime = 0L;\n                for (String value : values) {\n                    totalTime += Long.parseUnsignedLong(value);\n                }\n\n                var idleTimeDelta = idleTime - previousIdleTime;\n                var totalTimeDelta = totalTime - previousTotalTime;\n                var utilization = 1 - ((double) idleTimeDelta) / totalTimeDelta;\n\n                \n                System.out.println(percentFormatter.format(utilization));\n\n                previousIdleTime = idleTime;\n                previousTotalTime = totalTime;\n\n                \n                statPointer.seek(0);\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n        }\n\n    }\n}\n"}
{"id": 415597, "name": "Ulam numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature <say state>;\n\nsub ulam {\n    my($n) = @_;\n    state %u     = (1 => 1, 2 => 1);\n    state @ulams = <0 1 2>; \n\n    return $ulams[$n] if $ulams[$n];\n\n    $n++;\n    my $i = 3;\n\n    while () {\n        my $count = 0;\n \n            $u{ $i - $ulams[$_] }\n        and $ulams[$_] != $i - $ulams[$_]\n        and $count++ > 2\n        and last\n            for 0..$\n\n            $count == 2\n        and push(@ulams,$i)\n        and $u{$i} = 1\n        and @ulams == $n\n        and last;\n\n        $i++;\n    }\n    $ulams[$n-1];\n}\n\nprintf \"The %dth Ulam number is: %d\\n\", 10**$_, ulam(10**$_) for 1..4;\n", "target": "public class UlamNumbers {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int n = 1; n <= 100000; n *= 10) {\n            System.out.printf(\"Ulam(%d) = %d\\n\", n, ulam(n));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"Elapsed time:\u00a0%.3f seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private static int ulam(int n) {\n        int[] ulams = new int[Math.max(n, 2)];\n        ulams[0] = 1;\n        ulams[1] = 2;\n        int sieveLength = 2;\n        int[] sieve = new int[sieveLength];\n        sieve[0] = sieve[1] = 1;\n        for (int u = 2, ulen = 2; ulen < n; ) {\n            sieveLength = u + ulams[ulen - 2];\n            sieve = extend(sieve, sieveLength);\n            for (int i = 0; i < ulen - 1; ++i)\n                ++sieve[u + ulams[i] - 1];\n            for (int i = u; i < sieveLength; ++i) {\n                if (sieve[i] == 1) {\n                    u = i + 1;\n                    ulams[ulen++] = u;\n                    break;\n                }\n            }\n        }\n        return ulams[n - 1];\n    }\n\n    private static int[] extend(int[] array, int minLength) {\n        if (minLength <= array.length)\n            return array;\n        int newLength = 2 * array.length;\n        while (newLength < minLength)\n            newLength *= 2;\n        int[] newArray = new int[newLength];\n        System.arraycopy(array, 0, newArray, 0, array.length);\n        return newArray;\n    }\n}\n"}
{"id": 415598, "name": "Ramsey's theorem", "source": "Translate Perl to Java: use ntheory qw(forcomb);\nuse Math::Cartesian::Product;\n\n$n = 17;\npush @a, [(0) x $n] for 0..$n-1;\n$a[$_][$_] = '-' for 0..$n-1;\n\nfor $x (cartesian {@_} [(0..$n-1)], [(1,2,4,8)]) {\n    $i = @$x[0];\n    $k = @$x[1];\n    $j = ($i + $k) % $n;\n    $a[$i][$j] = $a[$j][$i] = 1;\n}\n\nforcomb {\n    my $l = 0;\n    @i = @_;\n    forcomb { $l += $a[ $i[$_[0]] ][ $i[$_[1]] ]; } (4,2);\n    die \"Bogus!\" unless 0 < $l and $l < 6;\n} ($n,4);\n\nprint join(' ' ,@$_) . \"\\n\" for @a;\nprint 'OK'\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class RamseysTheorem {\n\n    static char[][] createMatrix() {\n        String r = \"-\" + Integer.toBinaryString(53643);\n        int len = r.length();\n        return IntStream.range(0, len)\n                .mapToObj(i -> r.substring(len - i) + r.substring(0, len - i))\n                .map(String::toCharArray)\n                .toArray(char[][]::new);\n    }\n\n    \n    static String ramseyCheck(char[][] mat) {\n        int len = mat.length;\n        char[] connectivity = \"------\".toCharArray();\n\n        for (int a = 0; a < len; a++) {\n            for (int b = 0; b < len; b++) {\n                if (a == b)\n                    continue;\n                connectivity[0] = mat[a][b];\n                for (int c = 0; c < len; c++) {\n                    if (a == c || b == c)\n                        continue;\n                    connectivity[1] = mat[a][c];\n                    connectivity[2] = mat[b][c];\n                    for (int d = 0; d < len; d++) {\n                        if (a == d || b == d || c == d)\n                            continue;\n                        connectivity[3] = mat[a][d];\n                        connectivity[4] = mat[b][d];\n                        connectivity[5] = mat[c][d];\n\n                        \n                        \n                        String conn = new String(connectivity);\n                        if (conn.indexOf('0') == -1)\n                            return String.format(\"Fail, found wholly connected: \"\n                                    + \"%d %d %d %d\", a, b, c, d);\n                        else if (conn.indexOf('1') == -1)\n                            return String.format(\"Fail, found wholly unconnected: \"\n                                    + \"%d %d %d %d\", a, b, c, d);\n                    }\n                }\n            }\n        }\n        return \"Satisfies Ramsey condition.\";\n    }\n\n    public static void main(String[] a) {\n        char[][] mat = createMatrix();\n        for (char[] s : mat)\n            System.out.println(Arrays.toString(s));\n        System.out.println(ramseyCheck(mat));\n    }\n}\n"}
{"id": 415599, "name": "Type detection", "source": "Translate Perl to Java: $scalar    = 1;\n@array     = (1, 2);\n%hash      = ('a' => 1);\n$regex     = qr/foo.*bar/;\n$reference = \\%hash;\nsub greet { print \"Hello world!\" };\n$subref    = \\&greet;\n\n$fmt = \"%-11s is type:  %s\\n\";\nprintf $fmt, '$scalar',    ref(\\$scalar);\nprintf $fmt, '@array',     ref(\\@array);\nprintf $fmt, '%hash',      ref(\\%hash);\nprintf $fmt, '$regex',     ref( $regex);\nprintf $fmt, '$reference', ref(\\$reference);\nprintf $fmt, '$subref',    ref( $subref);\n", "target": "public class TypeDetection {\n    private static void showType(Object a) {\n        if (a instanceof Integer) {\n            System.out.printf(\"'%s' is an integer\\n\", a);\n        } else if (a instanceof Double) {\n            System.out.printf(\"'%s' is a double\\n\", a);\n        } else if (a instanceof Character) {\n            System.out.printf(\"'%s' is a character\\n\", a);\n        } else {\n            System.out.printf(\"'%s' is some other type\\n\", a);\n        }\n    }\n\n    public static void main(String[] args) {\n        showType(5);\n        showType(7.5);\n        showType('d');\n        showType(true);\n    }\n}\n"}
{"id": 415600, "name": "Safe primes and unsafe primes", "source": "Translate Perl to Java: use ntheory qw(forprimes is_prime);\n\nmy $upto = 1e7;\nmy %class = ( safe => [], unsafe => [2] );\n\nforprimes {\n    push @{$class{ is_prime(($_-1)>>1) ? 'safe' : 'unsafe' }}, $_;\n} 3, $upto;\n\nfor (['safe', 35], ['unsafe', 40]) {\n    my($type, $quantity) = @$_;\n    print  \"The first $quantity $type primes are:\\n\";\n    print join(\" \", map { comma($class{$type}->[$_-1]) } 1..$quantity), \"\\n\";\n    for my $q ($upto/10, $upto) {\n        my $n = scalar(grep { $_ <= $q } @{$class{$type}});\n        printf \"The number of $type primes up to %s: %s\\n\", comma($q), comma($n);\n    }\n}\n\nsub comma {\n    (my $s = reverse shift) =~ s/(.{3})/$1,/g;\n    $s =~ s/,(-?)$/$1/;\n    $s = reverse $s;\n}\n", "target": "public class SafePrimes {\n    public static void main(String... args) {\n        \n        int SIEVE_SIZE = 10_000_000;\n        boolean[] isComposite = new boolean[SIEVE_SIZE];\n        \n        isComposite[0] = true;\n        isComposite[1] = true;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (isComposite[n]) {\n                continue;\n            }\n            for (int i = n * 2; i < SIEVE_SIZE; i += n) {\n                isComposite[i] = true;\n            }\n        }\n        \n        int oldSafePrimeCount = 0;\n        int oldUnsafePrimeCount = 0;\n        int safePrimeCount = 0;\n        int unsafePrimeCount = 0;\n        StringBuilder safePrimes = new StringBuilder();\n        StringBuilder unsafePrimes = new StringBuilder();\n        int safePrimesStrCount = 0;\n        int unsafePrimesStrCount = 0;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (n == 1_000_000) {\n                oldSafePrimeCount = safePrimeCount;\n                oldUnsafePrimeCount = unsafePrimeCount;\n            }\n            if (isComposite[n]) {\n                continue;\n            }\n            boolean isUnsafe = isComposite[(n - 1) >>> 1];\n            if (isUnsafe) {\n                if (unsafePrimeCount < 40) {\n                    if (unsafePrimeCount > 0) {\n                        unsafePrimes.append(\", \");\n                    }\n                    unsafePrimes.append(n);\n                    unsafePrimesStrCount++;\n                }\n                unsafePrimeCount++;\n            }\n            else {\n                if (safePrimeCount < 35) {\n                    if (safePrimeCount > 0) {\n                        safePrimes.append(\", \");\n                    }\n                    safePrimes.append(n);\n                    safePrimesStrCount++;\n                }\n                safePrimeCount++;\n            }\n        }\n        \n        System.out.println(\"First \" + safePrimesStrCount + \" safe primes: \" + safePrimes.toString());\n        System.out.println(\"Number of safe primes below 1,000,000: \" + oldSafePrimeCount);\n        System.out.println(\"Number of safe primes below 10,000,000: \" + safePrimeCount);\n        System.out.println(\"First \" + unsafePrimesStrCount + \" unsafe primes: \" + unsafePrimes.toString());\n        System.out.println(\"Number of unsafe primes below 1,000,000: \" + oldUnsafePrimeCount);\n        System.out.println(\"Number of unsafe primes below 10,000,000: \" + unsafePrimeCount);\n        \n        return;\n    }\n}\n"}
{"id": 415601, "name": "Hash join", "source": "Translate Perl to Java: use Data::Dumper qw(Dumper);\n\nsub hashJoin {\n    my ($table1, $index1, $table2, $index2) = @_;\n    my %h;\n    \n    foreach my $s (@$table1) {\n\tpush @{ $h{$s->[$index1]} }, $s;\n    }\n    \n    map { my $r = $_;\n\t  map [$_, $r], @{ $h{$r->[$index2]} }\n    } @$table2;\n}\n\n@table1 = ([27, \"Jonah\"],\n           [18, \"Alan\"],\n           [28, \"Glory\"],\n           [18, \"Popeye\"],\n           [28, \"Alan\"]);\n@table2 = ([\"Jonah\", \"Whales\"],\n           [\"Jonah\", \"Spiders\"],\n           [\"Alan\", \"Ghosts\"],\n           [\"Alan\", \"Zombies\"],\n           [\"Glory\", \"Buffy\"]);\n\n$Data::Dumper::Indent = 0;\nforeach my $row (hashJoin(\\@table1, 1, \\@table2, 0)) {\n    print Dumper($row), \"\\n\";\n}\n", "target": "import java.util.*;\n\npublic class HashJoin {\n\n    public static void main(String[] args) {\n        String[][] table1 = {{\"27\", \"Jonah\"}, {\"18\", \"Alan\"}, {\"28\", \"Glory\"},\n        {\"18\", \"Popeye\"}, {\"28\", \"Alan\"}};\n\n        String[][] table2 = {{\"Jonah\", \"Whales\"}, {\"Jonah\", \"Spiders\"},\n        {\"Alan\", \"Ghosts\"}, {\"Alan\", \"Zombies\"}, {\"Glory\", \"Buffy\"},\n        {\"Bob\", \"foo\"}};\n\n        hashJoin(table1, 1, table2, 0).stream()\n                .forEach(r -> System.out.println(Arrays.deepToString(r)));\n    }\n\n    static List<String[][]> hashJoin(String[][] records1, int idx1,\n            String[][] records2, int idx2) {\n\n        List<String[][]> result = new ArrayList<>();\n        Map<String, List<String[]>> map = new HashMap<>();\n\n        for (String[] record : records1) {\n            List<String[]> v = map.getOrDefault(record[idx1], new ArrayList<>());\n            v.add(record);\n            map.put(record[idx1], v);\n        }\n\n        for (String[] record : records2) {\n            List<String[]> lst = map.get(record[idx2]);\n            if (lst != null) {\n                lst.stream().forEach(r -> {\n                    result.add(new String[][]{r, record});\n                });\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"id": 415602, "name": "Permutations with repetitions", "source": "Translate Perl to Java: use Algorithm::Combinatorics qw/tuples_with_repetition/;\nprint join(\" \", map { \"[@$_]\" } tuples_with_repetition([qw/A B C/],2)), \"\\n\";\n", "target": "import java.util.function.Predicate;\n\npublic class PermutationsWithRepetitions {\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'b', 'c', 'd'};\n        \n        permute(chars, 3, i -> i[0] == 1 && i[1] == 1 && i[2] == 0);\n    }\n\n    static void permute(char[] a, int k, Predicate<int[]> decider) {\n        int n = a.length;\n        if (k < 1 || k > n)\n            throw new IllegalArgumentException(\"Illegal number of positions.\");\n\n        int[] indexes = new int[n];\n        int total = (int) Math.pow(n, k);\n\n        while (total-- > 0) {\n            for (int i = 0; i < n - (n - k); i++)\n                System.out.print(a[indexes[i]]);\n            System.out.println();\n\n            if (decider.test(indexes))\n                break;\n\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] >= n - 1) {\n                    indexes[i] = 0;\n                } else {\n                    indexes[i]++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415603, "name": "Permutations with repetitions", "source": "Translate Perl to Java: use Algorithm::Combinatorics qw/tuples_with_repetition/;\nprint join(\" \", map { \"[@$_]\" } tuples_with_repetition([qw/A B C/],2)), \"\\n\";\n", "target": "import java.util.function.Predicate;\n\npublic class PermutationsWithRepetitions {\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'b', 'c', 'd'};\n        \n        permute(chars, 3, i -> i[0] == 1 && i[1] == 1 && i[2] == 0);\n    }\n\n    static void permute(char[] a, int k, Predicate<int[]> decider) {\n        int n = a.length;\n        if (k < 1 || k > n)\n            throw new IllegalArgumentException(\"Illegal number of positions.\");\n\n        int[] indexes = new int[n];\n        int total = (int) Math.pow(n, k);\n\n        while (total-- > 0) {\n            for (int i = 0; i < n - (n - k); i++)\n                System.out.print(a[indexes[i]]);\n            System.out.println();\n\n            if (decider.test(indexes))\n                break;\n\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] >= n - 1) {\n                    indexes[i] = 0;\n                } else {\n                    indexes[i]++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415604, "name": "Idiomatically determine all the characters that can be used for symbols", "source": "Translate Perl to Java: \n\nfor $i (0..0x7f) {\n    $c = chr($i);\n    print $c if $c =~ /\\w/;\n}\n\n\n\nuse utf8;\nbinmode STDOUT, \":utf8\";\nfor (0..0x1ffff) {\n    $c = chr($_);\n    print $c if $c =~ /\\p{Word}/;\n}\n", "target": "import java.util.function.IntPredicate;\nimport java.util.stream.IntStream;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        print(\"Java Identifier start:     \", 0, 0x10FFFF, 72,\n                Character::isJavaIdentifierStart, \"%c\");\n\n        print(\"Java Identifier part:      \", 0, 0x10FFFF, 25,\n                Character::isJavaIdentifierPart, \"[%d]\");\n\n        print(\"Identifier ignorable:      \", 0, 0x10FFFF, 25,\n                Character::isIdentifierIgnorable, \"[%d]\");\n\n        print(\"Unicode Identifier start:  \", 0, 0x10FFFF, 72,\n                Character::isUnicodeIdentifierStart, \"%c\");\n\n        print(\"Unicode Identifier part\u00a0:  \", 0, 0x10FFFF, 25,\n                Character::isUnicodeIdentifierPart, \"[%d]\");\n    }\n\n    static void print(String msg, int start, int end, int limit, \n        IntPredicate p, String fmt) {\n\n        System.out.print(msg);\n        IntStream.rangeClosed(start, end)\n                .filter(p)\n                .limit(limit)\n                .forEach(cp -> System.out.printf(fmt, cp));\n        System.out.println(\"...\");\n    }\n}\n"}
{"id": 415605, "name": "Selective file copy", "source": "Translate Perl to Java: my %F = ( \n    'field a' => { offset => 0,  length => 5, type => 'Str' },\n    'field b' => { offset => 5,  length => 5, type => 'Str' },\n    'field c' => { offset => 10, length => 4, type => 'Bit' },\n    'field d' => { offset => 14, length => 1, type => 'Str' },\n    'field e' => { offset => 15, length => 5, type => 'Str' }\n);\n\n$record_length += $F{$_}{'length'} for keys %F;\n\nopen $fh, '<', 'sfc.dat' || die;\nwhile ($n=sysread($fh, $record, $record_length)) {\n    last if $n < $record_length;\n    for $k (sort keys %F) {\n        if ($F{$k}{type} eq 'Str') {\n            printf \"$k\u00a0: %s \", $v = substr $record, $F{$k}{offset}, $F{$k}{length};\n            $h{$k} = $v;\n        } elsif ($F{$k}{type} eq 'Bit') {\n            printf \"$k\u00a0: %d \", $v = substr $record, $F{$k}{offset}, $F{$k}{length};\n            $h{$k} = pack(\"B8\",'0011'.$v);;\n        }\n    }\n    print \"\\n\";\n    push @result, sprintf( \"%-5s%s%01d%5s\", $h{'field a'}, $h{'field d'}, $h{'field c'}, 'xxxxx' );\n}\nprint \"\\n\" . join \"\\n\", @result;\n", "target": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\nclass CopysJ {\n\n  public static void main(String[] args) {\n    String ddname_IN  = \"copys.in.txt\";\n    String ddname_OUT = \"copys.out.txt\";\n    if (args.length >= 1) { ddname_IN  = args[0].length() > 0 ? args[0] : ddname_IN; }\n    if (args.length >= 2) { ddname_OUT = args[1].length() > 0 ? args[1] : ddname_OUT; }\n\n    File dd_IN = new File(ddname_IN);\n    File dd_OUT = new File(ddname_OUT);\n\n    try (\n      Scanner scanner_IN = new Scanner(dd_IN);\n      BufferedWriter writer_OUT = new BufferedWriter(new FileWriter(dd_OUT))\n      ) {\n      String a;\n      String b;\n      String c;\n      String d;\n      String c1;\n      String x = \"XXXXX\";\n      String data_IN;\n      String data_OUT;\n      int ib;\n\n      while (scanner_IN.hasNextLine()) {\n        data_IN = scanner_IN.nextLine();\n        ib = 0;\n        a = data_IN.substring(ib, ib += 5);\n        b = data_IN.substring(ib, ib += 5);\n        c = data_IN.substring(ib, ib += 4);\n        c1=Integer.toHexString(new Byte((c.getBytes())[0]).intValue());\n        if (c1.length()<2) { c1=\"0\" + c1; }\n        data_OUT = a + c1 + x;\n        writer_OUT.write(data_OUT);\n        writer_OUT.newLine();\n        System.out.println(data_IN);\n        System.out.println(data_OUT);\n        System.out.println();\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n    return;\n  }\n}\n"}
{"id": 415606, "name": "Terminal control_Preserve screen", "source": "Translate Perl to Java: print \"\\033[?1049h\\033[H\";\nprint \"Alternate screen buffer\\n\";\n\nfor (my $i = 5; $i > 0; --$i) {\n    print \"going back in $i...\\n\";\n    sleep(1);\n}\n\nprint \"\\033[?1049l\";\n", "target": "public class PreserveScreen\n{\n    public static void main(String[] args) throws InterruptedException {\n        System.out.print(\"\\033[?1049h\\033[H\");\n        System.out.println(\"Alternate screen buffer\\n\");\n        for (int i = 5; i > 0; i--) {\n            String s = (i > 1) ? \"s\" : \"\";\n            System.out.printf(\"\\rgoing back in %d second%s...\", i, s);\n            Thread.sleep(1000);\n        }\n        System.out.print(\"\\033[?1049l\");\n    }\n}\n"}
{"id": 415607, "name": "Find largest left truncatable prime in a given base", "source": "Translate Perl to Java: use ntheory qw/:all/;\nuse Math::GMPz;\n\nsub lltp {\n  my($n, $b, $best) = (shift, Math::GMPz->new(1));\n  my @v = map { Math::GMPz->new($_) } @{primes($n-1)};\n  while (@v) {\n    $best = vecmax(@v);\n    $b *= $n;\n    my @u;\n    foreach my $vi (@v) {\n      push @u, grep { is_prob_prime($_) } map { $vi + $_*$b } 1 .. $n-1;\n    }\n    @v = @u;\n  }\n  die unless is_provable_prime($best);\n  $best;\n}\n\nprintf \"%2d %s\\n\", $_, lltp($_)  for 3 .. 17;\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass LeftTruncatablePrime\n{\n  private static List<BigInteger> getNextLeftTruncatablePrimes(BigInteger n, int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> probablePrimes = new ArrayList<BigInteger>();\n    String baseString = n.equals(BigInteger.ZERO) ? \"\" : n.toString(radix);\n    for (int i = 1; i < radix; i++)\n    {\n      BigInteger p = new BigInteger(Integer.toString(i, radix) + baseString, radix);\n      if (p.isProbablePrime(millerRabinCertainty))\n        probablePrimes.add(p);\n    }\n    return probablePrimes;\n  }\n  \n  public static BigInteger getLargestLeftTruncatablePrime(int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> lastList = null;\n    List<BigInteger> list = getNextLeftTruncatablePrimes(BigInteger.ZERO, radix, millerRabinCertainty);\n    while (!list.isEmpty())\n    {\n      lastList = list;\n      list = new ArrayList<BigInteger>();\n      for (BigInteger n : lastList)\n        list.addAll(getNextLeftTruncatablePrimes(n, radix, millerRabinCertainty));\n    }\n    if (lastList == null)\n      return null;\n    Collections.sort(lastList);\n    return lastList.get(lastList.size() - 1);\n  }\n  \n  public static void main(String[] args)\n  {\n    if (args.length != 2) {\n      System.err.println(\"There must be exactly two command line arguments.\");\n      return;\n    }\n    int maxRadix;\n    try {\n      maxRadix = Integer.parseInt(args[0]);\n      if (maxRadix < 3) throw new NumberFormatException(); \n    } catch (NumberFormatException e) {\n      System.err.println(\"Radix must be an integer greater than 2.\");\n      return;\n    }\n    int millerRabinCertainty;\n    try {\n      millerRabinCertainty = Integer.parseInt(args[1]);\n    } catch (NumberFormatException e) {\n      System.err.println(\"Miiller-Rabin Certainty must be an integer.\");\n      return;\n    }  \n    for (int radix = 3; radix <= maxRadix; radix++)\n    {\n      BigInteger largest = getLargestLeftTruncatablePrime(radix, millerRabinCertainty);\n      System.out.print(\"n=\" + radix + \": \");\n      if (largest == null)\n        System.out.println(\"No left-truncatable prime\");\n      else\n        System.out.println(largest + \" (in base \" + radix + \"): \" + largest.toString(radix));\n    }\n  }\n  \n}\n"}
{"id": 415608, "name": "24 game_Solve", "source": "Translate Perl to Java: \n\nsub permute :prototype(&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 415609, "name": "24 game_Solve", "source": "Translate Perl to Java: \n\nsub permute :prototype(&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 415610, "name": "Hough transform", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse Imager;\n\nuse constant pi => 3.14159265;\n\nsub hough {\n    my($im)     = shift;\n    my($width)  = shift || 460;\n    my($height) = shift || 360;\n    $height = 2 * int $height/2;\n \n    $height = 2 * int $height/2;\n    my($xsize, $ysize) = ($im->getwidth, $im->getheight);\n    my $ht = Imager->new(xsize => $width, ysize => $height);\n    my @canvas;\n    for my $i (0..$height-1) { for my $j (0..$width-1) { $canvas[$i][$j] = 255 } }\n    $ht->box(filled => 1, color => 'white');\n\n    my $rmax = sqrt($xsize**2 + $ysize**2);\n    my $dr   = 2 * $rmax / $height;\n    my $dth  = pi / $width;\n\n    for my $x (0..$xsize-1) {\n      for my $y (0..$ysize-1) {\n        my $col = $im->getpixel(x => $x, y => $y);\n        my($r,$g,$b) = $col->rgba;\n        next if $r==255; \n        for my $k (0..$width) {\n            my $th = $dth*$k;\n            my $r2 = ($x*cos($th) + $y*sin($th));\n            my $iry = ($height/2 + int($r2/$dr + 0.5));\n            $ht->setpixel(x => $k, y => $iry, color => [ ($canvas[$iry][$k]--) x 3] );\n        }\n      }\n    }\n    return $ht;\n}\n\nmy $img = Imager->new;\n$img->read(file => 'ref/pentagon.png') or die \"Cannot read: \", $img->errstr;\nmy $ht = hough($img);\n$ht->write(file => 'hough_transform.png');\n", "target": "import java.awt.image.*;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.*;\n\npublic class HoughTransform\n{\n  public static ArrayData houghTransform(ArrayData inputData, int thetaAxisSize, int rAxisSize, int minContrast)\n  {\n    int width = inputData.width;\n    int height = inputData.height;\n    int maxRadius = (int)Math.ceil(Math.hypot(width, height));\n    int halfRAxisSize = rAxisSize >>> 1;\n    ArrayData outputData = new ArrayData(thetaAxisSize, rAxisSize);\n    \n    \n    double[] sinTable = new double[thetaAxisSize];\n    double[] cosTable = new double[thetaAxisSize];\n    for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n    {\n      double thetaRadians = theta * Math.PI / thetaAxisSize;\n      sinTable[theta] = Math.sin(thetaRadians);\n      cosTable[theta] = Math.cos(thetaRadians);\n    }\n    \n    for (int y = height - 1; y >= 0; y--)\n    {\n      for (int x = width - 1; x >= 0; x--)\n      {\n        if (inputData.contrast(x, y, minContrast))\n        {\n          for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n          {\n            double r = cosTable[theta] * x + sinTable[theta] * y;\n            int rScaled = (int)Math.round(r * halfRAxisSize / maxRadius) + halfRAxisSize;\n            outputData.accumulate(theta, rScaled, 1);\n          }\n        }\n      }\n    }\n    return outputData;\n  }\n  \n  public static class ArrayData\n  {\n    public final int[] dataArray;\n    public final int width;\n    public final int height;\n    \n    public ArrayData(int width, int height)\n    {\n      this(new int[width * height], width, height);\n    }\n    \n    public ArrayData(int[] dataArray, int width, int height)\n    {\n      this.dataArray = dataArray;\n      this.width = width;\n      this.height = height;\n    }\n    \n    public int get(int x, int y)\n    {  return dataArray[y * width + x];  }\n    \n    public void set(int x, int y, int value)\n    {  dataArray[y * width + x] = value;  }\n    \n    public void accumulate(int x, int y, int delta)\n    {  set(x, y, get(x, y) + delta);  }\n    \n    public boolean contrast(int x, int y, int minContrast)\n    {\n      int centerValue = get(x, y);\n      for (int i = 8; i >= 0; i--)\n      {\n        if (i == 4)\n          continue;\n        int newx = x + (i % 3) - 1;\n        int newy = y + (i / 3) - 1;\n        if ((newx < 0) || (newx >= width) || (newy < 0) || (newy >= height))\n          continue;\n        if (Math.abs(get(newx, newy) - centerValue) >= minContrast)\n          return true;\n      }\n      return false;\n    }\n    \n    public int getMax()\n    {\n      int max = dataArray[0];\n      for (int i = width * height - 1; i > 0; i--)\n        if (dataArray[i] > max)\n          max = dataArray[i];\n      return max;\n    }\n  }\n  \n  public static ArrayData getArrayDataFromImage(String filename) throws IOException\n  {\n    BufferedImage inputImage = ImageIO.read(new File(filename));\n    int width = inputImage.getWidth();\n    int height = inputImage.getHeight();\n    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);\n    ArrayData arrayData = new ArrayData(width, height);\n    \n    for (int y = 0; y < height; y++)\n    {\n      for (int x = 0; x < width; x++)\n      {\n        int rgbValue = rgbData[y * width + x];\n        rgbValue = (int)(((rgbValue & 0xFF0000) >>> 16) * 0.30 + ((rgbValue & 0xFF00) >>> 8) * 0.59 + (rgbValue & 0xFF) * 0.11);\n        arrayData.set(x, height - 1 - y, rgbValue);\n      }\n    }\n    return arrayData;\n  }\n  \n  public static void writeOutputImage(String filename, ArrayData arrayData) throws IOException\n  {\n    int max = arrayData.getMax();\n    BufferedImage outputImage = new BufferedImage(arrayData.width, arrayData.height, BufferedImage.TYPE_INT_ARGB);\n    for (int y = 0; y < arrayData.height; y++)\n    {\n      for (int x = 0; x < arrayData.width; x++)\n      {\n        int n = Math.min((int)Math.round(arrayData.get(x, y) * 255.0 / max), 255);\n        outputImage.setRGB(x, arrayData.height - 1 - y, (n << 16) | (n << 8) | 0x90 | -0x01000000);\n      }\n    }\n    ImageIO.write(outputImage, \"PNG\", new File(filename));\n    return;\n  }\n  \n  public static void main(String[] args) throws IOException\n  {\n    ArrayData inputData = getArrayDataFromImage(args[0]);\n    int minContrast = (args.length >= 4) ? 64 : Integer.parseInt(args[4]);\n    ArrayData outputData = houghTransform(inputData, Integer.parseInt(args[2]), Integer.parseInt(args[3]), minContrast);\n    writeOutputImage(args[1], outputData);\n    return;\n  }\n}\n"}
{"id": 415611, "name": "Tonelli-Shanks algorithm", "source": "Translate Perl to Java: use bigint;\nuse ntheory qw(is_prime powmod kronecker);\n\nsub tonelli_shanks {\n    my($n,$p) = @_;\n    return if kronecker($n,$p) <= 0;\n    my $Q = $p - 1;\n    my $S = 0;\n    $Q >>= 1 and $S++ while 0 == $Q%2;\n    return powmod($n,int(($p+1)/4), $p) if $S == 1;\n\n    my $c;\n    for $n (2..$p) {\n        next if kronecker($n,$p) >= 0;\n        $c = powmod($n, $Q, $p);\n        last;\n    }\n\n    my $R = powmod($n, ($Q+1) >> 1, $p ); \n    my $t = powmod($n, $Q, $p );\n    while (($t-1) % $p) {\n        my $b;\n        my $t2 = $t**2 % $p;\n        for (1 .. $S) {\n            if (0 == ($t2-1)%$p) {\n                $b = powmod($c, 1 << ($S-1-$_), $p);\n                $S = $_;\n                last;\n            }\n            $t2 = $t2**2 % $p;\n        }\n        $R = ($R * $b) % $p;\n        $c = $b**2 % $p;\n        $t = ($t * $c) % $p;\n    }\n    $R;\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (1030, 10009),\n    (1032, 10009),\n    (44402, 100049),\n    (665820697, 1000000009),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n    $n = shift @tests;\n    $p = shift @tests;\n    my $t = tonelli_shanks($n, $p);\n    if (!$t or ($t**2 - $n) % $p) {\n        printf \"No solution for (%d, %d)\\n\", $n, $p;\n    } else {\n        printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $t, $p-$t, $p;\n    }\n}\n", "target": "import java.math.BigInteger;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class TonelliShanks {\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TEN = BigInteger.TEN;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\n\n    private static class Solution {\n        private BigInteger root1;\n        private BigInteger root2;\n        private boolean exists;\n\n        Solution(BigInteger root1, BigInteger root2, boolean exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n    }\n\n    private static Solution ts(Long n, Long p) {\n        return ts(BigInteger.valueOf(n), BigInteger.valueOf(p));\n    }\n\n    private static Solution ts(BigInteger n, BigInteger p) {\n        BiFunction<BigInteger, BigInteger, BigInteger> powModP = (BigInteger a, BigInteger e) -> a.modPow(e, p);\n        Function<BigInteger, BigInteger> ls = (BigInteger a) -> powModP.apply(a, p.subtract(ONE).divide(TWO));\n\n        if (!ls.apply(n).equals(ONE)) return new Solution(ZERO, ZERO, false);\n\n        BigInteger q = p.subtract(ONE);\n        BigInteger ss = ZERO;\n        while (q.and(ONE).equals(ZERO)) {\n            ss = ss.add(ONE);\n            q = q.shiftRight(1);\n        }\n\n        if (ss.equals(ONE)) {\n            BigInteger r1 = powModP.apply(n, p.add(ONE).divide(FOUR));\n            return new Solution(r1, p.subtract(r1), true);\n        }\n\n        BigInteger z = TWO;\n        while (!ls.apply(z).equals(p.subtract(ONE))) z = z.add(ONE);\n        BigInteger c = powModP.apply(z, q);\n        BigInteger r = powModP.apply(n, q.add(ONE).divide(TWO));\n        BigInteger t = powModP.apply(n, q);\n        BigInteger m = ss;\n\n        while (true) {\n            if (t.equals(ONE)) return new Solution(r, p.subtract(r), true);\n            BigInteger i = ZERO;\n            BigInteger zz = t;\n            while (!zz.equals(BigInteger.ONE) && i.compareTo(m.subtract(ONE)) < 0) {\n                zz = zz.multiply(zz).mod(p);\n                i = i.add(ONE);\n            }\n            BigInteger b = c;\n            BigInteger e = m.subtract(i).subtract(ONE);\n            while (e.compareTo(ZERO) > 0) {\n                b = b.multiply(b).mod(p);\n                e = e.subtract(ONE);\n            }\n            r = r.multiply(b).mod(p);\n            c = b.multiply(b).mod(p);\n            t = t.multiply(c).mod(p);\n            m = i;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Long, Long>> pairs = List.of(\n            Map.entry(10L, 13L),\n            Map.entry(56L, 101L),\n            Map.entry(1030L, 10009L),\n            Map.entry(1032L, 10009L),\n            Map.entry(44402L, 100049L),\n            Map.entry(665820697L, 1000000009L),\n            Map.entry(881398088036L, 1000000000039L)\n        );\n\n        for (Map.Entry<Long, Long> pair : pairs) {\n            Solution sol = ts(pair.getKey(), pair.getValue());\n            System.out.printf(\"n = %s\\n\", pair.getKey());\n            System.out.printf(\"p = %s\\n\", pair.getValue());\n            if (sol.exists) {\n                System.out.printf(\"root1 = %s\\n\", sol.root1);\n                System.out.printf(\"root2 = %s\\n\", sol.root2);\n            } else {\n                System.out.println(\"No solution exists\");\n            }\n            System.out.println();\n        }\n\n        BigInteger bn = new BigInteger(\"41660815127637347468140745042827704103445750172002\");\n        BigInteger bp = TEN.pow(50).add(BigInteger.valueOf(577));\n        Solution sol = ts(bn, bp);\n        System.out.printf(\"n = %s\\n\", bn);\n        System.out.printf(\"p = %s\\n\", bp);\n        if (sol.exists) {\n            System.out.printf(\"root1 = %s\\n\", sol.root1);\n            System.out.printf(\"root2 = %s\\n\", sol.root2);\n        } else {\n            System.out.println(\"No solution exists\");\n        }\n    }\n}\n"}
{"id": 415612, "name": "Tonelli-Shanks algorithm", "source": "Translate Perl to Java: use bigint;\nuse ntheory qw(is_prime powmod kronecker);\n\nsub tonelli_shanks {\n    my($n,$p) = @_;\n    return if kronecker($n,$p) <= 0;\n    my $Q = $p - 1;\n    my $S = 0;\n    $Q >>= 1 and $S++ while 0 == $Q%2;\n    return powmod($n,int(($p+1)/4), $p) if $S == 1;\n\n    my $c;\n    for $n (2..$p) {\n        next if kronecker($n,$p) >= 0;\n        $c = powmod($n, $Q, $p);\n        last;\n    }\n\n    my $R = powmod($n, ($Q+1) >> 1, $p ); \n    my $t = powmod($n, $Q, $p );\n    while (($t-1) % $p) {\n        my $b;\n        my $t2 = $t**2 % $p;\n        for (1 .. $S) {\n            if (0 == ($t2-1)%$p) {\n                $b = powmod($c, 1 << ($S-1-$_), $p);\n                $S = $_;\n                last;\n            }\n            $t2 = $t2**2 % $p;\n        }\n        $R = ($R * $b) % $p;\n        $c = $b**2 % $p;\n        $t = ($t * $c) % $p;\n    }\n    $R;\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (1030, 10009),\n    (1032, 10009),\n    (44402, 100049),\n    (665820697, 1000000009),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n    $n = shift @tests;\n    $p = shift @tests;\n    my $t = tonelli_shanks($n, $p);\n    if (!$t or ($t**2 - $n) % $p) {\n        printf \"No solution for (%d, %d)\\n\", $n, $p;\n    } else {\n        printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $t, $p-$t, $p;\n    }\n}\n", "target": "import java.math.BigInteger;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class TonelliShanks {\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TEN = BigInteger.TEN;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\n\n    private static class Solution {\n        private BigInteger root1;\n        private BigInteger root2;\n        private boolean exists;\n\n        Solution(BigInteger root1, BigInteger root2, boolean exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n    }\n\n    private static Solution ts(Long n, Long p) {\n        return ts(BigInteger.valueOf(n), BigInteger.valueOf(p));\n    }\n\n    private static Solution ts(BigInteger n, BigInteger p) {\n        BiFunction<BigInteger, BigInteger, BigInteger> powModP = (BigInteger a, BigInteger e) -> a.modPow(e, p);\n        Function<BigInteger, BigInteger> ls = (BigInteger a) -> powModP.apply(a, p.subtract(ONE).divide(TWO));\n\n        if (!ls.apply(n).equals(ONE)) return new Solution(ZERO, ZERO, false);\n\n        BigInteger q = p.subtract(ONE);\n        BigInteger ss = ZERO;\n        while (q.and(ONE).equals(ZERO)) {\n            ss = ss.add(ONE);\n            q = q.shiftRight(1);\n        }\n\n        if (ss.equals(ONE)) {\n            BigInteger r1 = powModP.apply(n, p.add(ONE).divide(FOUR));\n            return new Solution(r1, p.subtract(r1), true);\n        }\n\n        BigInteger z = TWO;\n        while (!ls.apply(z).equals(p.subtract(ONE))) z = z.add(ONE);\n        BigInteger c = powModP.apply(z, q);\n        BigInteger r = powModP.apply(n, q.add(ONE).divide(TWO));\n        BigInteger t = powModP.apply(n, q);\n        BigInteger m = ss;\n\n        while (true) {\n            if (t.equals(ONE)) return new Solution(r, p.subtract(r), true);\n            BigInteger i = ZERO;\n            BigInteger zz = t;\n            while (!zz.equals(BigInteger.ONE) && i.compareTo(m.subtract(ONE)) < 0) {\n                zz = zz.multiply(zz).mod(p);\n                i = i.add(ONE);\n            }\n            BigInteger b = c;\n            BigInteger e = m.subtract(i).subtract(ONE);\n            while (e.compareTo(ZERO) > 0) {\n                b = b.multiply(b).mod(p);\n                e = e.subtract(ONE);\n            }\n            r = r.multiply(b).mod(p);\n            c = b.multiply(b).mod(p);\n            t = t.multiply(c).mod(p);\n            m = i;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Long, Long>> pairs = List.of(\n            Map.entry(10L, 13L),\n            Map.entry(56L, 101L),\n            Map.entry(1030L, 10009L),\n            Map.entry(1032L, 10009L),\n            Map.entry(44402L, 100049L),\n            Map.entry(665820697L, 1000000009L),\n            Map.entry(881398088036L, 1000000000039L)\n        );\n\n        for (Map.Entry<Long, Long> pair : pairs) {\n            Solution sol = ts(pair.getKey(), pair.getValue());\n            System.out.printf(\"n = %s\\n\", pair.getKey());\n            System.out.printf(\"p = %s\\n\", pair.getValue());\n            if (sol.exists) {\n                System.out.printf(\"root1 = %s\\n\", sol.root1);\n                System.out.printf(\"root2 = %s\\n\", sol.root2);\n            } else {\n                System.out.println(\"No solution exists\");\n            }\n            System.out.println();\n        }\n\n        BigInteger bn = new BigInteger(\"41660815127637347468140745042827704103445750172002\");\n        BigInteger bp = TEN.pow(50).add(BigInteger.valueOf(577));\n        Solution sol = ts(bn, bp);\n        System.out.printf(\"n = %s\\n\", bn);\n        System.out.printf(\"p = %s\\n\", bp);\n        if (sol.exists) {\n            System.out.printf(\"root1 = %s\\n\", sol.root1);\n            System.out.printf(\"root2 = %s\\n\", sol.root2);\n        } else {\n            System.out.println(\"No solution exists\");\n        }\n    }\n}\n"}
{"id": 415613, "name": "Truth table", "source": "Translate Perl to Java: \n\nsub truth_table {\n    my $s = shift;\n    my (%seen, @vars);\n    for ($s =~ /([a-zA-Z_]\\w*)/g) {\n        $seen{$_} //= do { push @vars, $_; 1 };\n    }\n\n    print \"\\n\", join(\"\\t\", @vars, $s), \"\\n\", '-' x 40, \"\\n\";\n    @vars = map(\"\\$$_\", @vars);\n\n    $s =~ s/([a-zA-Z_]\\w*)/\\$$1/g;\n    $s = \"print(\".join(',\"\\t\", ', map(\"($_?'T':'F')\", @vars, $s)).\",\\\"\\\\n\\\")\";\n    $s = \"for my $_ (0, 1) { $s }\" for (reverse @vars);\n    eval $s;\n}\n\ntruth_table 'A ^ A_1';\ntruth_table 'foo & bar | baz';\ntruth_table 'Jim & (Spock ^ Bones) | Scotty';\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Stack;\n\npublic class TruthTable {\n    public static void main( final String... args ) {\n        System.out.println( new TruthTable( args ) );\n    }\n\n    private interface Operator {\n        boolean evaluate( Stack<Boolean> s );\n    }\n\n    \n    private static final Map<String,Operator> operators = new HashMap<String,Operator>() {{\n        \n        put( \"&\", stack -> Boolean.logicalAnd( stack.pop(), stack.pop() ) );\n        put( \"|\", stack -> Boolean.logicalOr( stack.pop(), stack.pop() ) );\n        put( \"!\", stack -> ! stack.pop() );\n        put( \"^\", stack -> ! stack.pop().equals ( stack.pop() ) );\n    }};\n\n    private final List<String> variables;\n    private final String[]     symbols;\n\n    \n    public TruthTable( final String... symbols ) {\n        final Set<String> variables = new LinkedHashSet<>();\n\n        for ( final String symbol : symbols ) {\n            if ( ! operators.containsKey( symbol ) ) {\n                variables.add( symbol );\n            }\n        }\n        this.variables = new ArrayList<>( variables );\n        this.symbols = symbols;\n    }\n\n    @Override\n    public String toString () {\n        final StringBuilder result = new StringBuilder();\n\n        for ( final String variable : variables ) {\n            result.append( variable ).append( ' ' );\n        }\n        result.append( ' ' );\n        for ( final String symbol : symbols ) {\n            result.append( symbol ).append ( ' ' );\n        }\n        result.append( '\\n' );\n        for ( final List<Boolean> values : enumerate( variables.size () ) ) {\n            final Iterator<String> i = variables.iterator();\n\n            for ( final Boolean value : values ) {\n                result.append(\n                    String.format(\n                        \"%-\" + i.next().length() + \"c \",\n                        value ? 'T' : 'F'\n                    )\n                );\n            }\n            result.append( ' ' )\n                .append( evaluate( values ) ? 'T' : 'F' )\n                .append( '\\n' );\n        }\n\n        return result.toString ();\n    }\n\n    \n    private static List<List<Boolean>> enumerate( final int size ) {\n        if ( 1 == size )\n            return new ArrayList<List<Boolean>>() {{\n                add( new ArrayList<Boolean>() {{ add(false); }} );\n                add( new ArrayList<Boolean>() {{ add(true);  }} );\n            }};\n\n        return new ArrayList<List<Boolean>>() {{\n            for ( final List<Boolean> head : enumerate( size - 1 ) ) {\n                add( new ArrayList<Boolean>( head ) {{ add(false); }} );\n                add( new ArrayList<Boolean>( head ) {{ add(true);  }} );\n            }\n        }};\n    }\n\n    \n    private boolean evaluate( final List<Boolean> enumeration ) {\n        final Iterator<Boolean>   i      = enumeration.iterator();\n        final Map<String,Boolean> values = new HashMap<>();\n        final Stack<Boolean>      stack  = new Stack<>();\n\n        variables.forEach ( v -> values.put( v, i.next() ) );\n        for ( final String symbol : symbols ) {\n            final Operator op = operators.get ( symbol );\n\n            \n            stack.push(\n                null == op\n                    ? values.get ( symbol )\n                    : op.evaluate ( stack )\n            );\n        }\n        return stack.pop();\n    }\n}\n"}
{"id": 415614, "name": "Truth table", "source": "Translate Perl to Java: \n\nsub truth_table {\n    my $s = shift;\n    my (%seen, @vars);\n    for ($s =~ /([a-zA-Z_]\\w*)/g) {\n        $seen{$_} //= do { push @vars, $_; 1 };\n    }\n\n    print \"\\n\", join(\"\\t\", @vars, $s), \"\\n\", '-' x 40, \"\\n\";\n    @vars = map(\"\\$$_\", @vars);\n\n    $s =~ s/([a-zA-Z_]\\w*)/\\$$1/g;\n    $s = \"print(\".join(',\"\\t\", ', map(\"($_?'T':'F')\", @vars, $s)).\",\\\"\\\\n\\\")\";\n    $s = \"for my $_ (0, 1) { $s }\" for (reverse @vars);\n    eval $s;\n}\n\ntruth_table 'A ^ A_1';\ntruth_table 'foo & bar | baz';\ntruth_table 'Jim & (Spock ^ Bones) | Scotty';\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Stack;\n\npublic class TruthTable {\n    public static void main( final String... args ) {\n        System.out.println( new TruthTable( args ) );\n    }\n\n    private interface Operator {\n        boolean evaluate( Stack<Boolean> s );\n    }\n\n    \n    private static final Map<String,Operator> operators = new HashMap<String,Operator>() {{\n        \n        put( \"&\", stack -> Boolean.logicalAnd( stack.pop(), stack.pop() ) );\n        put( \"|\", stack -> Boolean.logicalOr( stack.pop(), stack.pop() ) );\n        put( \"!\", stack -> ! stack.pop() );\n        put( \"^\", stack -> ! stack.pop().equals ( stack.pop() ) );\n    }};\n\n    private final List<String> variables;\n    private final String[]     symbols;\n\n    \n    public TruthTable( final String... symbols ) {\n        final Set<String> variables = new LinkedHashSet<>();\n\n        for ( final String symbol : symbols ) {\n            if ( ! operators.containsKey( symbol ) ) {\n                variables.add( symbol );\n            }\n        }\n        this.variables = new ArrayList<>( variables );\n        this.symbols = symbols;\n    }\n\n    @Override\n    public String toString () {\n        final StringBuilder result = new StringBuilder();\n\n        for ( final String variable : variables ) {\n            result.append( variable ).append( ' ' );\n        }\n        result.append( ' ' );\n        for ( final String symbol : symbols ) {\n            result.append( symbol ).append ( ' ' );\n        }\n        result.append( '\\n' );\n        for ( final List<Boolean> values : enumerate( variables.size () ) ) {\n            final Iterator<String> i = variables.iterator();\n\n            for ( final Boolean value : values ) {\n                result.append(\n                    String.format(\n                        \"%-\" + i.next().length() + \"c \",\n                        value ? 'T' : 'F'\n                    )\n                );\n            }\n            result.append( ' ' )\n                .append( evaluate( values ) ? 'T' : 'F' )\n                .append( '\\n' );\n        }\n\n        return result.toString ();\n    }\n\n    \n    private static List<List<Boolean>> enumerate( final int size ) {\n        if ( 1 == size )\n            return new ArrayList<List<Boolean>>() {{\n                add( new ArrayList<Boolean>() {{ add(false); }} );\n                add( new ArrayList<Boolean>() {{ add(true);  }} );\n            }};\n\n        return new ArrayList<List<Boolean>>() {{\n            for ( final List<Boolean> head : enumerate( size - 1 ) ) {\n                add( new ArrayList<Boolean>( head ) {{ add(false); }} );\n                add( new ArrayList<Boolean>( head ) {{ add(true);  }} );\n            }\n        }};\n    }\n\n    \n    private boolean evaluate( final List<Boolean> enumeration ) {\n        final Iterator<Boolean>   i      = enumeration.iterator();\n        final Map<String,Boolean> values = new HashMap<>();\n        final Stack<Boolean>      stack  = new Stack<>();\n\n        variables.forEach ( v -> values.put( v, i.next() ) );\n        for ( final String symbol : symbols ) {\n            final Operator op = operators.get ( symbol );\n\n            \n            stack.push(\n                null == op\n                    ? values.get ( symbol )\n                    : op.evaluate ( stack )\n            );\n        }\n        return stack.pop();\n    }\n}\n"}
{"id": 415615, "name": "Set of real numbers", "source": "Translate Perl to Java: use utf8;\n\n\n\n\n\n\npackage BNum;\n\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'<=>'\t=> \\&_cmp,\n);\n\nsub new {\n\tmy $self = shift;\n\tbless [@_], ref $self || $self\n}\n\nsub flip {\n\tmy @a = @{+shift};\n\t$a[2] = !$a[2];\n\tbless \\@a\n}\n\nmy $brackets = qw/ [ ( ) ] /;\nsub _str {\n\tmy $v = sprintf \"%.2f\", $_[0][0];\n\t$_[0][2]\n\t\t? $v . ($_[0][1] == 1 ? \"]\" : \")\")\n\t\t: ($_[0][1] == 1 ? \"(\" : \"[\" ) . $v;\n}\n\nsub _cmp {\n\tmy ($a, $b, $swap) = @_;\n\n\t\n\tif ($swap) { return -_ncmp($a, $b) }\n\tif (!ref $b || !$b->isa(__PACKAGE__)) { return _ncmp($a, $b) }\n\n\t$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]\n}\n\nsub _ncmp {\n\t\n\tmy ($a, $b) = @_;\n\t$a->[0] <=> $b || $a->[1] <=> 0\n}\n\npackage RealSet;\nuse Carp;\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'|'\t=> \\&_or,\n\t'&'\t=> \\&_and,\n\t'~'\t=> \\&_neg,\n\t'-'\t=> \\&_diff,\n\t'bool'\t=> \\&not_empty, \n);\n\nmy %pm = qw/ [ -1 ( 1 ) -1 ] 1 /;\nsub range {\n\tmy ($cls, $a, $b, $spec) = @_;\n\t$spec =~ /^( \\[ | \\( )( \\) | \\] )$/x\tor croak \"bad spec $spec\";\n\n\t$a = BNum->new($a, $pm{$1}, 0);\n\t$b = BNum->new($b, $pm{$2}, 1);\n\tnormalize($a < $b ? [$a, $b] : [])\n}\n\nsub normalize {\n\tmy @a = @{+shift};\n\t\n\t\n\t\n\tfor (my $i = $\n\t\tsplice @a, $i - 1, 2\n\t\t\tif $a[$i] <= $a[$i - 1]\n\t}\n\tbless \\@a\n}\n\nsub not_empty { scalar @{ normalize shift } }\n\nsub _str {\n\tmy (@a, @s) = @{+shift}\t\tor return '()';\n\tjoin \" \u222a \", map { shift(@a).\", \".shift(@a) } 0 .. $\n}\n\nsub _or {\n\t\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? () : ($_)\n\t\t\t\t: $d++ ? () : ($_) }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _neg {\n\tnormalize [\n\t\tBNum->new('-inf', 1, 0),\n\t\tmap($_->flip, @{+shift}),\n\t\tBNum->new('inf', -1, 1),\n\t]\n}\n\nsub _and {\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? ($_) : ()\n\t\t\t\t: $d++ ? ($_) : () }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _diff { shift() & ~shift() }\n\nsub has {\n\tmy ($a, $b) = @_;\n\tfor (my $i = 0; $i < $\n\t\treturn 1 if $a->[$i] <= $b && $b <= $a->[$i + 1]\n\t}\n\treturn 0\n}\n\nsub len {\n\tmy ($a, $l) = shift;\n\tfor (my $i = 0; $i < $\n\t\t$l += $a->[$i+1][0] - $a->[$i][0]\n\t}\n\treturn $l\n}\n\npackage main;\nuse List::Util 'reduce';\n\nsub rng { RealSet->range(@_) }\nmy @sets = (\n\trng(0, 1, '(]') | rng(0, 2, '[)'),\n\trng(0, 2, '[)') & rng(0, 2, '(]'),\n\trng(0, 3, '[)') - rng(0, 1, '()'),\n\trng(0, 3, '[)') - rng(0, 1, '[]'),\n);\n\nfor my $i (0 .. $\n\tprint \"Set $i = \", $sets[$i], \": \";\n\tfor (0 .. 2) {\n\t\tprint \"has $_; \" if $sets[$i]->has($_);\n\t}\n\tprint \"\\n\";\n}\n\n\nprint \"\\n\nsub brev { \n\tmy $x = shift;\n\treturn $x if length $x < 60;\n\tsubstr($x, 0, 30).\" ... \".substr($x, -30, 30)\n}\n\n\nmy $x = reduce { $a | $b }\n\tmap(rng(sqrt($_ + 1./6), sqrt($_ + 5./6), '()'), 0 .. 101);\n$x &= rng(0, 10, '()');\n\nprint \"A\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x\u00b2)| > 1/2 }',\n\t\"\\n\\t= \", brev($x), \"\\n\";\n\nmy $y = reduce { $a | $b }\n\tmap { rng($_ + 1./6, $_ + 5./6, '()') } 0 .. 11;\n$y &= rng(0, 10, '()');\n\nprint \"B\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x)| > 1/2 }',\n\t\"\\n\\t= \", brev($y), \"\\n\";\n\nmy $z = $x - $y;\nprint \"A - B\\t= \", brev($z), \"\\n\\tlength = \", $z->len, \"\\n\";\nprint $z ? \"not empty\\n\" : \"empty\\n\";\n", "target": "import java.util.Objects;\nimport java.util.function.Predicate;\n\npublic class RealNumberSet {\n    public enum RangeType {\n        CLOSED,\n        BOTH_OPEN,\n        LEFT_OPEN,\n        RIGHT_OPEN,\n    }\n\n    public static class RealSet {\n        private Double low;\n        private Double high;\n        private Predicate<Double> predicate;\n        private double interval = 0.00001;\n\n        public RealSet(Double low, Double high, Predicate<Double> predicate) {\n            this.low = low;\n            this.high = high;\n            this.predicate = predicate;\n        }\n\n        public RealSet(Double start, Double end, RangeType rangeType) {\n            this(start, end, d -> {\n                switch (rangeType) {\n                    case CLOSED:\n                        return start <= d && d <= end;\n                    case BOTH_OPEN:\n                        return start < d && d < end;\n                    case LEFT_OPEN:\n                        return start < d && d <= end;\n                    case RIGHT_OPEN:\n                        return start <= d && d < end;\n                    default:\n                        throw new IllegalStateException(\"Unhandled range type encountered.\");\n                }\n            });\n        }\n\n        public boolean contains(Double d) {\n            return predicate.test(d);\n        }\n\n        public RealSet union(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.or(other.predicate).test(d));\n        }\n\n        public RealSet intersect(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.and(other.predicate).test(d));\n        }\n\n        public RealSet subtract(RealSet other) {\n            return new RealSet(low, high, d -> predicate.and(other.predicate.negate()).test(d));\n        }\n\n        public double length() {\n            if (low.isInfinite() || high.isInfinite()) return -1.0; \n            if (high <= low) return 0.0;\n            Double p = low;\n            int count = 0;\n            do {\n                if (predicate.test(p)) count++;\n                p += interval;\n            } while (p < high);\n            return count * interval;\n        }\n\n        public boolean isEmpty() {\n            if (Objects.equals(high, low)) {\n                return predicate.negate().test(low);\n            }\n            return length() == 0.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        RealSet a = new RealSet(0.0, 1.0, RangeType.LEFT_OPEN);\n        RealSet b = new RealSet(0.0, 2.0, RangeType.RIGHT_OPEN);\n        RealSet c = new RealSet(1.0, 2.0, RangeType.LEFT_OPEN);\n        RealSet d = new RealSet(0.0, 3.0, RangeType.RIGHT_OPEN);\n        RealSet e = new RealSet(0.0, 1.0, RangeType.BOTH_OPEN);\n        RealSet f = new RealSet(0.0, 1.0, RangeType.CLOSED);\n        RealSet g = new RealSet(0.0, 0.0, RangeType.CLOSED);\n\n        for (int i = 0; i <= 2; i++) {\n            Double dd = (double) i;\n            System.out.printf(\"(0, 1] \u222a [0, 2) contains %d is %s\\n\", i, a.union(b).contains(dd));\n            System.out.printf(\"[0, 2) \u2229 (1, 2] contains %d is %s\\n\", i, b.intersect(c).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 (0, 1) contains %d is %s\\n\", i, d.subtract(e).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 [0, 1] contains %d is %s\\n\", i, d.subtract(f).contains(dd));\n            System.out.println();\n        }\n\n        System.out.printf(\"[0, 0] is empty is %s\\n\", g.isEmpty());\n        System.out.println();\n\n        RealSet aa = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x * x)) > 0.5\n        );\n        RealSet bb = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x)) > 0.5\n        );\n        RealSet cc = aa.subtract(bb);\n        System.out.printf(\"Approx length of A - B is %f\\n\", cc.length());\n    }\n}\n"}
{"id": 415616, "name": "Set of real numbers", "source": "Translate Perl to Java: use utf8;\n\n\n\n\n\n\npackage BNum;\n\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'<=>'\t=> \\&_cmp,\n);\n\nsub new {\n\tmy $self = shift;\n\tbless [@_], ref $self || $self\n}\n\nsub flip {\n\tmy @a = @{+shift};\n\t$a[2] = !$a[2];\n\tbless \\@a\n}\n\nmy $brackets = qw/ [ ( ) ] /;\nsub _str {\n\tmy $v = sprintf \"%.2f\", $_[0][0];\n\t$_[0][2]\n\t\t? $v . ($_[0][1] == 1 ? \"]\" : \")\")\n\t\t: ($_[0][1] == 1 ? \"(\" : \"[\" ) . $v;\n}\n\nsub _cmp {\n\tmy ($a, $b, $swap) = @_;\n\n\t\n\tif ($swap) { return -_ncmp($a, $b) }\n\tif (!ref $b || !$b->isa(__PACKAGE__)) { return _ncmp($a, $b) }\n\n\t$a->[0] <=> $b->[0] || $a->[1] <=> $b->[1]\n}\n\nsub _ncmp {\n\t\n\tmy ($a, $b) = @_;\n\t$a->[0] <=> $b || $a->[1] <=> 0\n}\n\npackage RealSet;\nuse Carp;\nuse overload (\n\t'\"\"'\t=> \\&_str,\n\t'|'\t=> \\&_or,\n\t'&'\t=> \\&_and,\n\t'~'\t=> \\&_neg,\n\t'-'\t=> \\&_diff,\n\t'bool'\t=> \\&not_empty, \n);\n\nmy %pm = qw/ [ -1 ( 1 ) -1 ] 1 /;\nsub range {\n\tmy ($cls, $a, $b, $spec) = @_;\n\t$spec =~ /^( \\[ | \\( )( \\) | \\] )$/x\tor croak \"bad spec $spec\";\n\n\t$a = BNum->new($a, $pm{$1}, 0);\n\t$b = BNum->new($b, $pm{$2}, 1);\n\tnormalize($a < $b ? [$a, $b] : [])\n}\n\nsub normalize {\n\tmy @a = @{+shift};\n\t\n\t\n\t\n\tfor (my $i = $\n\t\tsplice @a, $i - 1, 2\n\t\t\tif $a[$i] <= $a[$i - 1]\n\t}\n\tbless \\@a\n}\n\nsub not_empty { scalar @{ normalize shift } }\n\nsub _str {\n\tmy (@a, @s) = @{+shift}\t\tor return '()';\n\tjoin \" \u222a \", map { shift(@a).\", \".shift(@a) } 0 .. $\n}\n\nsub _or {\n\t\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? () : ($_)\n\t\t\t\t: $d++ ? () : ($_) }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _neg {\n\tnormalize [\n\t\tBNum->new('-inf', 1, 0),\n\t\tmap($_->flip, @{+shift}),\n\t\tBNum->new('inf', -1, 1),\n\t]\n}\n\nsub _and {\n\tmy $d = 0;\n\tnormalize [\n\t\tmap {\t$_->[2] ? --$d ? ($_) : ()\n\t\t\t\t: $d++ ? ($_) : () }\n\t\tsort{ $a <=> $b } @{+shift}, @{+shift}\n\t];\n}\n\nsub _diff { shift() & ~shift() }\n\nsub has {\n\tmy ($a, $b) = @_;\n\tfor (my $i = 0; $i < $\n\t\treturn 1 if $a->[$i] <= $b && $b <= $a->[$i + 1]\n\t}\n\treturn 0\n}\n\nsub len {\n\tmy ($a, $l) = shift;\n\tfor (my $i = 0; $i < $\n\t\t$l += $a->[$i+1][0] - $a->[$i][0]\n\t}\n\treturn $l\n}\n\npackage main;\nuse List::Util 'reduce';\n\nsub rng { RealSet->range(@_) }\nmy @sets = (\n\trng(0, 1, '(]') | rng(0, 2, '[)'),\n\trng(0, 2, '[)') & rng(0, 2, '(]'),\n\trng(0, 3, '[)') - rng(0, 1, '()'),\n\trng(0, 3, '[)') - rng(0, 1, '[]'),\n);\n\nfor my $i (0 .. $\n\tprint \"Set $i = \", $sets[$i], \": \";\n\tfor (0 .. 2) {\n\t\tprint \"has $_; \" if $sets[$i]->has($_);\n\t}\n\tprint \"\\n\";\n}\n\n\nprint \"\\n\nsub brev { \n\tmy $x = shift;\n\treturn $x if length $x < 60;\n\tsubstr($x, 0, 30).\" ... \".substr($x, -30, 30)\n}\n\n\nmy $x = reduce { $a | $b }\n\tmap(rng(sqrt($_ + 1./6), sqrt($_ + 5./6), '()'), 0 .. 101);\n$x &= rng(0, 10, '()');\n\nprint \"A\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x\u00b2)| > 1/2 }',\n\t\"\\n\\t= \", brev($x), \"\\n\";\n\nmy $y = reduce { $a | $b }\n\tmap { rng($_ + 1./6, $_ + 5./6, '()') } 0 .. 11;\n$y &= rng(0, 10, '()');\n\nprint \"B\\t\", '= {x | 0 < x < 10 and |sin(\u03c0 x)| > 1/2 }',\n\t\"\\n\\t= \", brev($y), \"\\n\";\n\nmy $z = $x - $y;\nprint \"A - B\\t= \", brev($z), \"\\n\\tlength = \", $z->len, \"\\n\";\nprint $z ? \"not empty\\n\" : \"empty\\n\";\n", "target": "import java.util.Objects;\nimport java.util.function.Predicate;\n\npublic class RealNumberSet {\n    public enum RangeType {\n        CLOSED,\n        BOTH_OPEN,\n        LEFT_OPEN,\n        RIGHT_OPEN,\n    }\n\n    public static class RealSet {\n        private Double low;\n        private Double high;\n        private Predicate<Double> predicate;\n        private double interval = 0.00001;\n\n        public RealSet(Double low, Double high, Predicate<Double> predicate) {\n            this.low = low;\n            this.high = high;\n            this.predicate = predicate;\n        }\n\n        public RealSet(Double start, Double end, RangeType rangeType) {\n            this(start, end, d -> {\n                switch (rangeType) {\n                    case CLOSED:\n                        return start <= d && d <= end;\n                    case BOTH_OPEN:\n                        return start < d && d < end;\n                    case LEFT_OPEN:\n                        return start < d && d <= end;\n                    case RIGHT_OPEN:\n                        return start <= d && d < end;\n                    default:\n                        throw new IllegalStateException(\"Unhandled range type encountered.\");\n                }\n            });\n        }\n\n        public boolean contains(Double d) {\n            return predicate.test(d);\n        }\n\n        public RealSet union(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.or(other.predicate).test(d));\n        }\n\n        public RealSet intersect(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.and(other.predicate).test(d));\n        }\n\n        public RealSet subtract(RealSet other) {\n            return new RealSet(low, high, d -> predicate.and(other.predicate.negate()).test(d));\n        }\n\n        public double length() {\n            if (low.isInfinite() || high.isInfinite()) return -1.0; \n            if (high <= low) return 0.0;\n            Double p = low;\n            int count = 0;\n            do {\n                if (predicate.test(p)) count++;\n                p += interval;\n            } while (p < high);\n            return count * interval;\n        }\n\n        public boolean isEmpty() {\n            if (Objects.equals(high, low)) {\n                return predicate.negate().test(low);\n            }\n            return length() == 0.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        RealSet a = new RealSet(0.0, 1.0, RangeType.LEFT_OPEN);\n        RealSet b = new RealSet(0.0, 2.0, RangeType.RIGHT_OPEN);\n        RealSet c = new RealSet(1.0, 2.0, RangeType.LEFT_OPEN);\n        RealSet d = new RealSet(0.0, 3.0, RangeType.RIGHT_OPEN);\n        RealSet e = new RealSet(0.0, 1.0, RangeType.BOTH_OPEN);\n        RealSet f = new RealSet(0.0, 1.0, RangeType.CLOSED);\n        RealSet g = new RealSet(0.0, 0.0, RangeType.CLOSED);\n\n        for (int i = 0; i <= 2; i++) {\n            Double dd = (double) i;\n            System.out.printf(\"(0, 1] \u222a [0, 2) contains %d is %s\\n\", i, a.union(b).contains(dd));\n            System.out.printf(\"[0, 2) \u2229 (1, 2] contains %d is %s\\n\", i, b.intersect(c).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 (0, 1) contains %d is %s\\n\", i, d.subtract(e).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 [0, 1] contains %d is %s\\n\", i, d.subtract(f).contains(dd));\n            System.out.println();\n        }\n\n        System.out.printf(\"[0, 0] is empty is %s\\n\", g.isEmpty());\n        System.out.println();\n\n        RealSet aa = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x * x)) > 0.5\n        );\n        RealSet bb = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x)) > 0.5\n        );\n        RealSet cc = aa.subtract(bb);\n        System.out.printf(\"Approx length of A - B is %f\\n\", cc.length());\n    }\n}\n"}
{"id": 415617, "name": "State name puzzle", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\nuse feature qw{ say };\n\n\nsub uniq {\n    my %uniq;\n    undef @uniq{ @_ };\n    return keys %uniq\n}\n\n\nsub puzzle {\n    my @states = uniq(@_);\n\n    my %pairs;\n    for my $state1 (@states) {\n        for my $state2 (@states) {\n            next if $state1 le $state2;\n            my $both = join q(),\n                       grep ' ' ne $_,\n                       sort split //,\n                       lc \"$state1$state2\";\n            push @{ $pairs{$both} }, [ $state1, $state2 ];\n        }\n    }\n\n    for my $pair (keys %pairs) {\n        next if 2 > @{ $pairs{$pair} };\n\n        for my $pair1 (@{ $pairs{$pair} }) {\n            for my $pair2 (@{ $pairs{$pair} }) {\n                next if 4 > uniq(@$pair1, @$pair2)\n                     or $pair1->[0] lt $pair2->[0];\n\n                say join ' = ', map { join ' + ', @$_ } $pair1, $pair2;\n            }\n        }\n    }\n}\n\nmy @states = ( 'Alabama', 'Alaska', 'Arizona', 'Arkansas',\n               'California', 'Colorado', 'Connecticut', 'Delaware',\n               'Florida', 'Georgia', 'Hawaii',\n               'Idaho', 'Illinois', 'Indiana', 'Iowa',\n               'Kansas', 'Kentucky', 'Louisiana',\n               'Maine', 'Maryland', 'Massachusetts', 'Michigan',\n               'Minnesota', 'Mississippi', 'Missouri', 'Montana',\n               'Nebraska', 'Nevada', 'New Hampshire', 'New Jersey',\n               'New Mexico', 'New York', 'North Carolina', 'North Dakota',\n               'Ohio', 'Oklahoma', 'Oregon',\n               'Pennsylvania', 'Rhode Island',\n               'South Carolina', 'South Dakota', 'Tennessee', 'Texas',\n               'Utah', 'Vermont', 'Virginia',\n               'Washington', 'West Virginia', 'Wisconsin', 'Wyoming',\n             );\n\nmy @fictious = ( 'New Kory', 'Wen Kory', 'York New', 'Kory New', 'New Kory' );\n\nsay scalar @states, ' states:';\npuzzle(@states);\n\nsay @states + @fictious, ' states:';\npuzzle(@states, @fictious);\n", "target": "import java.util.*;\nimport java.util.stream.*;\n\npublic class StateNamePuzzle {\n\n    static String[] states = {\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\",\n        \"California\", \"Colorado\", \"Connecticut\", \"Delaware\", \"Florida\",\n        \"Georgia\", \"hawaii\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\", \"Iowa\",\n        \"Kansas\", \"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\", \"Massachusetts\",\n        \"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\", \"Montana\",\n        \"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\", \"New Mexico\",\n        \"New York\", \"North Carolina \", \"North Dakota\", \"Ohio\", \"Oklahoma\",\n        \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n        \"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n        \"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\",\n        \"New Kory\", \"Wen Kory\", \"York New\", \"Kory New\", \"New Kory\",};\n\n    public static void main(String[] args) {\n        solve(Arrays.asList(states));\n    }\n\n    static void solve(List<String> input) {\n        Map<String, String> orig = input.stream().collect(Collectors.toMap(\n                s -> s.replaceAll(\"\\\\s\", \"\").toLowerCase(), s -> s, (s, a) -> s));\n\n        input = new ArrayList<>(orig.keySet());\n\n        Map<String, List<String[]>> map = new HashMap<>();\n        for (int i = 0; i < input.size() - 1; i++) {\n            String pair0 = input.get(i);\n            for (int j = i + 1; j < input.size(); j++) {\n\n                String[] pair = {pair0, input.get(j)};\n                String s = pair0 + pair[1];\n                String key = Arrays.toString(s.chars().sorted().toArray());\n\n                List<String[]> val = map.getOrDefault(key, new ArrayList<>());\n                val.add(pair);\n                map.put(key, val);\n            }\n        }\n\n        map.forEach((key, list) -> {\n            for (int i = 0; i < list.size() - 1; i++) {\n                String[] a = list.get(i);\n                for (int j = i + 1; j < list.size(); j++) {\n                    String[] b = list.get(j);\n\n                    if (Stream.of(a[0], a[1], b[0], b[1]).distinct().count() < 4)\n                        continue;\n\n                    System.out.printf(\"%s + %s = %s + %s %n\", orig.get(a[0]),\n                            orig.get(a[1]), orig.get(b[0]), orig.get(b[1]));\n                }\n            }\n        });\n    }\n}\n"}
{"id": 415618, "name": "Super-d numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\n\nsub super {\n    my $d = shift;\n    my $run = $d x $d;\n    my @super;\n    my $i = 0;\n    my $n = 0;\n    while ( $i < 10 ) {\n        if (index($n ** $d * $d, $run) > -1) {\n            push @super, $n;\n            ++$i;\n        }\n        ++$n;\n    }\n    @super;\n}\n \nsay \"\\nFirst 10 super-$_ numbers:\\n\", join ' ', super($_) for 2..6;\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 415619, "name": "Super-d numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\n\nsub super {\n    my $d = shift;\n    my $run = $d x $d;\n    my @super;\n    my $i = 0;\n    my $n = 0;\n    while ( $i < 10 ) {\n        if (index($n ** $d * $d, $run) > -1) {\n            push @super, $n;\n            ++$i;\n        }\n        ++$n;\n    }\n    @super;\n}\n \nsay \"\\nFirst 10 super-$_ numbers:\\n\", join ' ', super($_) for 2..6;\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 415620, "name": "Textonyms", "source": "Translate Perl to Java: my $src = 'unixdict.txt';\n\n\nopen $fh, \"<\", $src;\n@words = grep { /^[a-zA-Z]+$/ } <$fh>;\nmap { tr/A-Z/a-z/ } @words;\n\n\nmap { tr/abcdefghijklmnopqrstuvwxyz/22233344455566677778889999/ } @dials = @words;\n\n\n@dials = grep {!$h{$_}++} @dials;\n@textonyms = grep { $h{$_} > 1 } @dials;\n\nprint \"There are @{[scalar @words]} words in '$src' which can be represented by the digit key mapping.\nThey require @{[scalar @dials]} digit combinations to represent them.\n@{[scalar @textonyms]} digit combinations represent Textonyms.\";\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class RTextonyms {\n\n  private static final Map<Character, Character> mapping;\n  private int total, elements, textonyms, max_found;\n  private String filename, mappingResult;\n  private Vector<String> max_strings;\n  private Map<String, Vector<String>> values;\n\n  static {\n    mapping = new HashMap<Character, Character>();\n    mapping.put('A', '2'); mapping.put('B', '2'); mapping.put('C', '2');\n    mapping.put('D', '3'); mapping.put('E', '3'); mapping.put('F', '3');\n    mapping.put('G', '4'); mapping.put('H', '4'); mapping.put('I', '4');\n    mapping.put('J', '5'); mapping.put('K', '5'); mapping.put('L', '5');\n    mapping.put('M', '6'); mapping.put('N', '6'); mapping.put('O', '6');\n    mapping.put('P', '7'); mapping.put('Q', '7'); mapping.put('R', '7'); mapping.put('S', '7');\n    mapping.put('T', '8'); mapping.put('U', '8'); mapping.put('V', '8');\n    mapping.put('W', '9'); mapping.put('X', '9'); mapping.put('Y', '9'); mapping.put('Z', '9');\n  }\n\n  public RTextonyms(String filename) {\n\n    this.filename = filename;\n    this.total = this.elements = this.textonyms = this.max_found = 0;\n    this.values = new HashMap<String, Vector<String>>();\n    this.max_strings = new Vector<String>();\n\n    return;\n  }\n\n  public void add(String line) {\n\n    String mapping = \"\";\n    total++;\n    if (!get_mapping(line)) {\n      return;\n    }\n    mapping = mappingResult;\n\n    if (values.get(mapping) == null) {\n      values.put(mapping, new Vector<String>());\n    }\n\n    int num_strings;\n    num_strings = values.get(mapping).size();\n    textonyms += num_strings == 1 ? 1 : 0;\n    elements++;\n\n    if (num_strings > max_found) {\n      max_strings.clear();\n      max_strings.add(mapping);\n      max_found = num_strings;\n    }\n    else if (num_strings == max_found) {\n      max_strings.add(mapping);\n    }\n\n    values.get(mapping).add(line);\n\n    return;\n  }\n\n  public void results() {\n\n    System.out.printf(\"Read\u00a0%,d words from %s%n%n\", total, filename);\n    System.out.printf(\"There are\u00a0%,d words in %s which can be represented by the digit key mapping.%n\", elements,\n        filename);\n    System.out.printf(\"They require\u00a0%,d digit combinations to represent them.%n\", values.size());\n    System.out.printf(\"%,d digit combinations represent Textonyms.%n\", textonyms);\n    System.out.printf(\"The numbers mapping to the most words map to\u00a0%,d words each:%n\", max_found + 1);\n    for (String key : max_strings) {\n      System.out.printf(\"%16s maps to: %s%n\", key, values.get(key).toString());\n    }\n    System.out.println();\n\n    return;\n  }\n\n  public void match(String key) {\n\n    Vector<String> match;\n    match = values.get(key);\n    if (match == null) {\n      System.out.printf(\"Key %s not found%n\", key);\n    }\n    else {\n      System.out.printf(\"Key %s matches: %s%n\", key, match.toString());\n    }\n\n    return;\n  }\n\n  private boolean get_mapping(String line) {\n\n    mappingResult = line;\n    StringBuilder mappingBuilder = new StringBuilder();\n    for (char cc : line.toCharArray()) {\n      if (Character.isAlphabetic(cc)) {\n        mappingBuilder.append(mapping.get(Character.toUpperCase(cc)));\n      }\n      else if (Character.isDigit(cc)) {\n        mappingBuilder.append(cc);\n      }\n      else {\n        return false;\n      }\n    }\n    mappingResult = mappingBuilder.toString();\n\n    return true;\n  }\n\n  public static void main(String[] args) {\n\n    String filename;\n    if (args.length > 0) {\n      filename = args[0];\n    }\n    else {\n      filename = \"./unixdict.txt\";\n    }\n    RTextonyms tc;\n    tc = new RTextonyms(filename);\n    Path fp = Paths.get(filename);\n    try (Scanner fs = new Scanner(fp, StandardCharsets.UTF_8.name())) {\n      while (fs.hasNextLine()) {\n        tc.add(fs.nextLine());\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n\n    List<String> numbers = Arrays.asList(\n        \"001\", \"228\", \"27484247\", \"7244967473642\",\n        \".\"\n        );\n\n    tc.results();\n    for (String number : numbers) {\n      if (number.equals(\".\")) {\n        System.out.println();\n      }\n      else {\n        tc.match(number);\n      }\n    }\n\n    return;\n  }\n}\n"}
{"id": 415621, "name": "Church numerals", "source": "Translate Perl to Java: use 5.020;\nuse feature qw<signatures>;\nno warnings qw<experimental::signatures>;\n\nuse constant zero  => sub ($f) {\n                      sub ($x) { $x }};\n\nuse constant succ  => sub ($n) {\n                      sub ($f) {\n                      sub ($x) { $f->($n->($f)($x)) }}};\n\nuse constant add   => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($f)($n->($f)($x)) }}}};\n\nuse constant mult  => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($n->($f))($x) }}}};\n\nuse constant power => sub ($b) {\n                      sub ($e) { $e->($b) }};\n\nuse constant countup   => sub ($i) { $i + 1 };\nuse constant countdown => sub ($i) { $i == 0 ? zero : succ->( __SUB__->($i - 1) ) };\nuse constant to_int    => sub ($f) { $f->(countup)->(0) };\nuse constant from_int  => sub ($x) { countdown->($x) };\n\nuse constant three => succ->(succ->(succ->(zero)));\nuse constant four  => from_int->(4);\n\nsay join ' ', map { to_int->($_) } (\n    add  ->( three )->( four  ),\n    mult ->( three )->( four  ),\n    power->( four  )->( three ),\n    power->( three )->( four  ),\n);\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 415622, "name": "Church numerals", "source": "Translate Perl to Java: use 5.020;\nuse feature qw<signatures>;\nno warnings qw<experimental::signatures>;\n\nuse constant zero  => sub ($f) {\n                      sub ($x) { $x }};\n\nuse constant succ  => sub ($n) {\n                      sub ($f) {\n                      sub ($x) { $f->($n->($f)($x)) }}};\n\nuse constant add   => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($f)($n->($f)($x)) }}}};\n\nuse constant mult  => sub ($n) {\n                      sub ($m) {\n                      sub ($f) {\n                      sub ($x) { $m->($n->($f))($x) }}}};\n\nuse constant power => sub ($b) {\n                      sub ($e) { $e->($b) }};\n\nuse constant countup   => sub ($i) { $i + 1 };\nuse constant countdown => sub ($i) { $i == 0 ? zero : succ->( __SUB__->($i - 1) ) };\nuse constant to_int    => sub ($f) { $f->(countup)->(0) };\nuse constant from_int  => sub ($x) { countdown->($x) };\n\nuse constant three => succ->(succ->(succ->(zero)));\nuse constant four  => from_int->(4);\n\nsay join ' ', map { to_int->($_) } (\n    add  ->( three )->( four  ),\n    mult ->( three )->( four  ),\n    power->( four  )->( three ),\n    power->( three )->( four  ),\n);\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 415623, "name": "Reflection_List methods", "source": "Translate Perl to Java: package Nums;\n\nuse overload ('<=>' => \\&compare);\nsub new     { my $self = shift; bless [@_] }\nsub flip    { my @a = @_; 1/$a }\nsub double  { my @a = @_; 2*$a }\nsub compare { my ($a, $b) = @_; abs($a) <=> abs($b) }\n\nmy $a = Nums->new(42);\nprint \"$_\\n\" for %{ref ($a).\"::\" });\n", "target": "import java.lang.reflect.Method;\n\npublic class ListMethods {\n    public int examplePublicInstanceMethod(char c, double d) {\n        return 42;\n    }\n\n    private boolean examplePrivateInstanceMethod(String s) {\n        return true;\n    }\n    \n    public static void main(String[] args) {\n        Class clazz = ListMethods.class;\n\n        System.out.println(\"All public methods (including inherited):\");\n        for (Method m : clazz.getMethods()) {\n            System.out.println(m);\n        }\n        System.out.println();\n        System.out.println(\"All declared methods (excluding inherited):\");\n        for (Method m : clazz.getDeclaredMethods()) {\n            System.out.println(m);\n        }\n    }\n}\n"}
{"id": 415624, "name": "Send an unknown method call", "source": "Translate Perl to Java: package Example;\nsub new {\n    bless {}\n}\nsub foo {\n    my ($self, $x) = @_;\n    return 42 + $x;\n}\n\npackage main;\nmy $name = \"foo\";\nprint Example->new->$name(5), \"\\n\"; \n", "target": "import java.lang.reflect.Method;\n\nclass Example {\n  public int foo(int x) {\n    return 42 + x;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) throws Exception {\n    Object example = new Example();\n    String name = \"foo\";\n    Class<?> clazz = example.getClass();\n    Method meth = clazz.getMethod(name, int.class);\n    Object result = meth.invoke(example, 5); \n    System.out.println(result);        \n  }\n}\n"}
{"id": 415625, "name": "Canonicalize CIDR", "source": "Translate Perl to Java: \nuse v5.16;\nuse Socket qw(inet_aton inet_ntoa);\n\n\nif (!@ARGV) {\n   chomp(@ARGV = <>);\n}\n\nfor (@ARGV) {\n\n  \n  my ($dotted, $size) = split m\n\n  \n  my $binary = sprintf \"%032b\", unpack('N', inet_aton $dotted);\n\n  \n  substr($binary, $size) = 0 x (32 - $size);\n\n  \n  $dotted = inet_ntoa(pack 'B32', $binary);\n\n  \n  say \"$dotted/$size\";\n}\n", "target": "import java.text.MessageFormat;\nimport java.text.ParseException;\n\npublic class CanonicalizeCIDR {\n    public static void main(String[] args) {\n        for (String test : TESTS) {\n            try {\n                CIDR cidr = new CIDR(test);\n                System.out.printf(\"%-18s -> %s\\n\", test, cidr.toString());\n            } catch (Exception ex) {\n                System.err.printf(\"Error parsing '%s': %s\\n\", test, ex.getLocalizedMessage());\n            }\n        }\n    }\n\n    private static class CIDR {\n        private CIDR(int address, int maskLength) {\n            this.address = address;\n            this.maskLength = maskLength;\n        }\n\n        private CIDR(String str) throws Exception {\n            Object[] args = new MessageFormat(FORMAT).parse(str);\n            int address = 0;\n            for (int i = 0; i < 4; ++i) {\n                int a = ((Number)args[i]).intValue();\n                if (a < 0 || a > 255)\n                    throw new Exception(\"Invalid IP address\");\n                address <<= 8;\n                address += a;\n            }\n            int maskLength = ((Number)args[4]).intValue();\n            if (maskLength < 1 || maskLength > 32)\n                throw new Exception(\"Invalid mask length\");\n            int mask = ~((1 << (32 - maskLength)) - 1);\n            this.address = address & mask;\n            this.maskLength = maskLength;\n        }\n\n        public String toString() {\n            int address = this.address;\n            int d = address & 0xFF;\n            address >>= 8;\n            int c = address & 0xFF;\n            address >>= 8;\n            int b = address & 0xFF;\n            address >>= 8;\n            int a = address & 0xFF;\n            Object[] args = { a, b, c, d, maskLength };\n            return new MessageFormat(FORMAT).format(args);\n        }\n\n        private int address;\n        private int maskLength;\n        private static final String FORMAT = \"{0,number,integer}.{1,number,integer}.{2,number,integer}.{3,number,integer}/{4,number,integer}\";\n    };\n\n    private static final String[] TESTS = {\n        \"87.70.141.1/22\",\n        \"36.18.154.103/12\",\n        \"62.62.197.11/29\",\n        \"67.137.119.181/4\",\n        \"161.214.74.21/24\",\n        \"184.232.176.184/18\"\n    };\n}\n"}
{"id": 415626, "name": "Canonicalize CIDR", "source": "Translate Perl to Java: \nuse v5.16;\nuse Socket qw(inet_aton inet_ntoa);\n\n\nif (!@ARGV) {\n   chomp(@ARGV = <>);\n}\n\nfor (@ARGV) {\n\n  \n  my ($dotted, $size) = split m\n\n  \n  my $binary = sprintf \"%032b\", unpack('N', inet_aton $dotted);\n\n  \n  substr($binary, $size) = 0 x (32 - $size);\n\n  \n  $dotted = inet_ntoa(pack 'B32', $binary);\n\n  \n  say \"$dotted/$size\";\n}\n", "target": "import java.text.MessageFormat;\nimport java.text.ParseException;\n\npublic class CanonicalizeCIDR {\n    public static void main(String[] args) {\n        for (String test : TESTS) {\n            try {\n                CIDR cidr = new CIDR(test);\n                System.out.printf(\"%-18s -> %s\\n\", test, cidr.toString());\n            } catch (Exception ex) {\n                System.err.printf(\"Error parsing '%s': %s\\n\", test, ex.getLocalizedMessage());\n            }\n        }\n    }\n\n    private static class CIDR {\n        private CIDR(int address, int maskLength) {\n            this.address = address;\n            this.maskLength = maskLength;\n        }\n\n        private CIDR(String str) throws Exception {\n            Object[] args = new MessageFormat(FORMAT).parse(str);\n            int address = 0;\n            for (int i = 0; i < 4; ++i) {\n                int a = ((Number)args[i]).intValue();\n                if (a < 0 || a > 255)\n                    throw new Exception(\"Invalid IP address\");\n                address <<= 8;\n                address += a;\n            }\n            int maskLength = ((Number)args[4]).intValue();\n            if (maskLength < 1 || maskLength > 32)\n                throw new Exception(\"Invalid mask length\");\n            int mask = ~((1 << (32 - maskLength)) - 1);\n            this.address = address & mask;\n            this.maskLength = maskLength;\n        }\n\n        public String toString() {\n            int address = this.address;\n            int d = address & 0xFF;\n            address >>= 8;\n            int c = address & 0xFF;\n            address >>= 8;\n            int b = address & 0xFF;\n            address >>= 8;\n            int a = address & 0xFF;\n            Object[] args = { a, b, c, d, maskLength };\n            return new MessageFormat(FORMAT).format(args);\n        }\n\n        private int address;\n        private int maskLength;\n        private static final String FORMAT = \"{0,number,integer}.{1,number,integer}.{2,number,integer}.{3,number,integer}/{4,number,integer}\";\n    };\n\n    private static final String[] TESTS = {\n        \"87.70.141.1/22\",\n        \"36.18.154.103/12\",\n        \"62.62.197.11/29\",\n        \"67.137.119.181/4\",\n        \"161.214.74.21/24\",\n        \"184.232.176.184/18\"\n    };\n}\n"}
{"id": 415627, "name": "Sequence of primorial primes", "source": "Translate Perl to Java: use ntheory \":all\";\nmy $i = 0;\nfor (1..1e6) { \n  my $n = pn_primorial($_);\n  if (is_prime($n-1) || is_prime($n+1)) {\n    print \"$_\\n\";\n    last if ++$i >= 20;\n  }\n}\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialPrimes {\n\n    final static int sieveLimit = 1550_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n\n        int count = 0;\n        for (int i = 1; i < 1000_000 && count < 20; i++) {\n            BigInteger b = primorial(i);\n            if (b.add(BigInteger.ONE).isProbablePrime(1)\n                    || b.subtract(BigInteger.ONE).isProbablePrime(1)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 415628, "name": "Combinations and permutations", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nshowoff( \"Permutations\", \\&P, \"P\", 1 .. 12 );\nshowoff( \"Combinations\", \\&C, \"C\", map $_*10, 1..6 );\nshowoff( \"Permutations\", \\&P_big, \"P\", 5, 50, 500, 1000, 5000, 15000 );\nshowoff( \"Combinations\", \\&C_big, \"C\", map $_*100, 1..10 );\n\nsub showoff {\n\tmy ($text, $code, $fname, @n) = @_;\n\tprint \"\\nA sample of $text from $n[0] to $n[-1]\\n\";\n\tfor my $n ( @n ) {\n\t\tmy $k = int( $n / 3 );\n\t\tprint $n, \" $fname $k = \", $code->($n, $k), \"\\n\";\n\t}\n}\n\nsub P {\n\tmy ($n, $k) = @_;\n\tmy $x = 1;\n\t$x *= $_ for $n - $k + 1 .. $n ;\n\t$x;\n}\n\nsub P_big {\n\tmy ($n, $k) = @_;\n\tmy $x = 0;\n\t$x += log($_) for $n - $k + 1 .. $n ;\n\teshow($x);\n}\n\nsub C {\n\tmy ($n, $k) = @_;\n\tmy $x = 1;\n\t$x *= ($n - $_ + 1) / $_ for 1 .. $k;\n\t$x;\n}\n\nsub C_big {\n\tmy ($n, $k) = @_;\n\tmy $x = 0;\n\t$x += log($n - $_ + 1) - log($_) for 1 .. $k;\n\texp($x);\n}\n\nsub eshow {\n\tmy ($x) = @_;\n\tmy $e = int( $x / log(10) );\n\tsprintf \"%.8Fe%+d\", exp($x - $e * log(10)), $e;\n}\n", "target": "import java.math.BigInteger;\n\npublic class CombinationsAndPermutations {\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n        System.out.println(\"A sample of permutations from 1 to 12 with exact Integer arithmetic:\");\n        for ( int n = 1 ; n <= 12 ; n++ ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, permutation(n, k));\n        }\n\n        System.out.println();\n        System.out.println(\"A sample of combinations from 10 to 60 with exact Integer arithmetic:\");\n        for ( int n = 10 ; n <= 60 ; n += 5 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, combination(n, k));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of permutations from 5 to 15000 displayed in floating point arithmetic:\");\n        System.out.printf(\"%d P %d = %s%n\", 5, 2, display(permutation(5, 2), 50));\n        for ( int n = 1000 ; n <= 15000 ; n += 1000 ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, display(permutation(n, k), 50));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of combinations from 100 to 1000 displayed in floating point arithmetic:\");\n        for ( int n = 100 ; n <= 1000 ; n += 100 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, display(combination(n, k), 50));\n        }\n\n    }\n    \n    private static String display(BigInteger val, int precision) {\n        String s = val.toString();\n        precision = Math.min(precision, s.length());\n        StringBuilder sb = new StringBuilder();\n        sb.append(s.substring(0, 1));\n        sb.append(\".\");\n        sb.append(s.substring(1, precision));\n        sb.append(\" * 10^\");\n        sb.append(s.length()-1);\n        return sb.toString();\n    }\n    \n    public static BigInteger combination(int n, int k) {\n        \n        \n        if ( n-k < k ) {\n            k = n-k;\n        }\n        BigInteger result = permutation(n, k);\n        while ( k > 0 ) {\n            result = result.divide(BigInteger.valueOf(k));\n            k--;\n        }\n        return result;\n    }\n    \n    public static BigInteger permutation(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for ( int i = n ; i >= n-k+1 ; i-- ) {\n            result = result.multiply(BigInteger.valueOf(i));\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 415629, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Perl to Java: use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   \nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 415630, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Perl to Java: use Math::BigFloat try => \"GMP,Pari\";\n\nmy $digits = shift || 100;   \nprint agm_pi($digits), \"\\n\";\n\nsub agm_pi {\n  my $digits = shift;\n  my $acc = $digits + 8;\n  my $HALF = Math::BigFloat->new(\"0.5\");\n  my ($an, $bn, $tn, $pn) = (Math::BigFloat->bone, $HALF->copy->bsqrt($acc),\n                             $HALF->copy->bmul($HALF), Math::BigFloat->bone);\n  while ($pn < $acc) {\n    my $prev_an = $an->copy;\n    $an->badd($bn)->bmul($HALF, $acc);\n    $bn->bmul($prev_an)->bsqrt($acc);\n    $prev_an->bsub($an);\n    $tn->bsub($pn * $prev_an * $prev_an);\n    $pn->badd($pn);\n  }\n  $an->badd($bn);\n  $an->bmul($an,$acc)->bdiv(4*$tn, $digits);\n  return $an;\n}\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 415631, "name": "Window creation_X11", "source": "Translate Perl to Java: \nuse strict;\nuse X11::Protocol;\n\nmy $X = X11::Protocol->new;\n\nmy $window = $X->new_rsrc;\n$X->CreateWindow ($window,\n                  $X->root,         \n                  'InputOutput',    \n                  0,                \n                  0,                \n                  0,0,              \n                  300,100,          \n                  0,                \n                  background_pixel => $X->black_pixel,\n                  event_mask       => $X->pack_event_mask('Exposure',\n                                                          'ButtonPress'),\n                 );\n\nmy $gc = $X->new_rsrc;\n$X->CreateGC ($gc, $window,\n              foreground => $X->white_pixel);\n\n$X->{'event_handler'} = sub {\n  my %event = @_;\n  my $event_name = $event{'name'};\n\n  if ($event_name eq 'Expose') {\n    $X->PolyRectangle ($window, $gc, [ 10,10,     \n                                       30,20 ]);  \n    $X->PolyText8 ($window, $gc,\n                   10, 55,    \n                   [ 0,  \n                     'Hello ... click mouse button to exit.' ]);\n\n  } elsif ($event_name eq 'ButtonPress') {\n    exit 0;\n  }\n};\n\n$X->MapWindow ($window);\nfor (;;) {\n  $X->handle_input;\n}\n", "target": "import javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class WindowExample {\n\n  public static void main(String[] args) {\n    Runnable runnable = new Runnable() {\n      public void run() {\n\tcreateAndShow();\n      }\n    };\n    SwingUtilities.invokeLater(runnable);\n  }\n\t\n  static void createAndShow() {\n    JFrame frame = new JFrame(\"Hello World\");\n    frame.setSize(640,480);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n  }\n}\n"}
{"id": 415632, "name": "Long primes", "source": "Translate Perl to Java: use ntheory qw/divisors powmod is_prime/;\n\nsub is_long_prime {\n    my($p) = @_;\n    return 0 unless is_prime($p);\n    for my $d (divisors($p-1)) {\n        return $d+1 == $p if powmod(10, $d, $p) == 1;\n    }\n    0;\n}\n\nprint \"Long primes \u2264 500:\\n\";\nprint join(' ', grep {is_long_prime($_) } 1 .. 500), \"\\n\\n\";\n\nfor my $n (500, 1000, 2000, 4000, 8000, 16000, 32000, 64000) {\n    printf \"Number of long primes \u2264 $n: %d\\n\",  scalar grep { is_long_prime($_) } 1 .. $n;\n}\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\npublic class LongPrimes\n{\n    private static void sieve(int limit, List<Integer> primes)\n    {\n        boolean[] c = new boolean[limit];\n        for (int i = 0; i < limit; i++)\n            c[i] = false;\n        \n        int p = 3, n = 0;\n        int p2 = p * p;\n        while (p2 <= limit)\n        {\n            for (int i = p2; i <= limit; i += 2 * p)\n                c[i] = true;\n            do\n                p += 2;\n            while (c[p]);\n            p2 = p * p;\n        }\n        for (int i = 3; i <= limit; i += 2)\n            if (!c[i])\n                primes.add(i);\n    }\n\n    \n    private static int findPeriod(int n)\n    {\n        int r = 1, period = 0;\n        for (int i = 1; i < n; i++)\n            r = (10 * r) % n;\n        int rr = r;\n        do\n        {\n            r = (10 * r) % n;\n            ++period;\n        }\n        while (r != rr);\n        return period;\n    }\n    \n    public static void main(String[] args)\n    {\n        int[] numbers = new int[]{500, 1000, 2000, 4000, 8000, 16000, 32000, 64000};\n        int[] totals = new int[numbers.length]; \n        List<Integer> primes = new LinkedList<Integer>();\n        List<Integer> longPrimes = new LinkedList<Integer>();\n        sieve(64000, primes);\n        for (int prime : primes)\n            if (findPeriod(prime) == prime - 1)\n                longPrimes.add(prime);\n        int count = 0, index = 0;\n        for (int longPrime : longPrimes)\n        {\n            if (longPrime > numbers[index])\n                totals[index++] = count;\n            ++count;\n        }\n        totals[numbers.length - 1] = count;\n        System.out.println(\"The long primes up to \" + numbers[0] + \" are:\");\n        System.out.println(longPrimes.subList(0, totals[0]));\n        System.out.println();\n        System.out.println(\"The number of long primes up to:\");\n        for (int i = 0; i <= 7; i++)\n            System.out.printf(\"  %5d is %d\\n\", numbers[i], totals[i]);\n    }\n}\n"}
{"id": 415633, "name": "Primorial numbers", "source": "Translate Perl to Java: use ntheory qw(pn_primorial);\n\nsay \"First ten primorials: \", join \", \", map { pn_primorial($_) } 0..9;\n\nsay \"primorial(10^$_) has \".(length pn_primorial(10**$_)).\" digits\" for 1..6;\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialNumbers {\n    final static int sieveLimit = 1300_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++)\n            System.out.printf(\"primorial(%d): %d%n\", i, primorial(i));\n\n        for (int i = 1; i < 6; i++) {\n            int len = primorial((int) Math.pow(10, i)).toString().length();\n            System.out.printf(\"primorial(10^%d) has length %d%n\", i, len);\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 415634, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nsub isEgyption{\n    my $nr = int($_[0]);\n    my $de = int($_[1]);\n    if($nr == 0 or $de == 0){\n\t\n\treturn;\n    }\n    if($de % $nr == 0){\n\t\n\tprintf \"1/\" . int($de/$nr);\n\treturn;\n    }\n    if($nr % $de == 0){\n\t\n\tprintf $nr/$de;\n\treturn;\n    }\n    if($nr > $de){\n        printf int($nr/$de) . \" + \";\n\tisEgyption($nr%$de, $de);\n\treturn;\n    }\n    \n    my $tmp = int($de/$nr) + 1;\n    printf \"1/\" . $tmp . \" + \";\n    isEgyption($nr*$tmp-$de, $de*$tmp);\n}\n\nmy $nrI = 2014;\nmy $deI = 59;\nprintf \"\\nEgyptian Fraction Representation of \" . $nrI . \"/\" . $deI . \" is: \\n\\n\";\nisEgyption($nrI,$deI);\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class EgyptianFractions {\n    private static BigInteger gcd(BigInteger a, BigInteger b) {\n        if (b.equals(BigInteger.ZERO)) {\n            return a;\n        }\n        return gcd(b, a.mod(b));\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private BigInteger num, denom;\n\n        public Frac(BigInteger n, BigInteger d) {\n            if (d.equals(BigInteger.ZERO)) {\n                throw new IllegalArgumentException(\"Parameter d may not be zero.\");\n            }\n\n            BigInteger nn = n;\n            BigInteger dd = d;\n            if (nn.equals(BigInteger.ZERO)) {\n                dd = BigInteger.ONE;\n            } else if (dd.compareTo(BigInteger.ZERO) < 0) {\n                nn = nn.negate();\n                dd = dd.negate();\n            }\n            BigInteger g = gcd(nn, dd).abs();\n            if (g.compareTo(BigInteger.ZERO) > 0) {\n                nn = nn.divide(g);\n                dd = dd.divide(g);\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac(int n, int d) {\n            this(BigInteger.valueOf(n), BigInteger.valueOf(d));\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(\n                num.multiply(rhs.denom).add(denom.multiply(rhs.num)),\n                rhs.denom.multiply(denom)\n            );\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(num.negate(), denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return plus(rhs.unaryMinus());\n        }\n\n        @Override\n        public int compareTo(Frac rhs) {\n            BigDecimal diff = this.toBigDecimal().subtract(rhs.toBigDecimal());\n            if (diff.compareTo(BigDecimal.ZERO) < 0) {\n                return -1;\n            }\n            if (BigDecimal.ZERO.compareTo(diff) < 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (null == obj || !(obj instanceof Frac)) {\n                return false;\n            }\n            Frac rhs = (Frac) obj;\n            return compareTo(rhs) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom.equals(BigInteger.ONE)) {\n                return num.toString();\n            }\n            return String.format(\"%s/%s\", num, denom);\n        }\n\n        public BigDecimal toBigDecimal() {\n            BigDecimal bdn = new BigDecimal(num);\n            BigDecimal bdd = new BigDecimal(denom);\n            return bdn.divide(bdd, MathContext.DECIMAL128);\n        }\n\n        public List<Frac> toEgyptian() {\n            if (num.equals(BigInteger.ZERO)) {\n                return Collections.singletonList(this);\n            }\n            List<Frac> fracs = new ArrayList<>();\n            if (num.abs().compareTo(denom.abs()) >= 0) {\n                Frac div = new Frac(num.divide(denom), BigInteger.ONE);\n                Frac rem = this.minus(div);\n                fracs.add(div);\n                toEgyptian(rem.num, rem.denom, fracs);\n            } else {\n                toEgyptian(num, denom, fracs);\n            }\n            return fracs;\n        }\n\n        public void toEgyptian(BigInteger n, BigInteger d, List<Frac> fracs) {\n            if (n.equals(BigInteger.ZERO)) {\n                return;\n            }\n            BigDecimal n2 = new BigDecimal(n);\n            BigDecimal d2 = new BigDecimal(d);\n            BigDecimal[] divRem = d2.divideAndRemainder(n2, MathContext.UNLIMITED);\n            BigInteger div = divRem[0].toBigInteger();\n            if (divRem[1].compareTo(BigDecimal.ZERO) > 0) {\n                div = div.add(BigInteger.ONE);\n            }\n            fracs.add(new Frac(BigInteger.ONE, div));\n            BigInteger n3 = d.negate().mod(n);\n            if (n3.compareTo(BigInteger.ZERO) < 0) {\n                n3 = n3.add(n);\n            }\n            BigInteger d3 = d.multiply(div);\n            Frac f = new Frac(n3, d3);\n            if (f.num.equals(BigInteger.ONE)) {\n                fracs.add(f);\n                return;\n            }\n            toEgyptian(f.num, f.denom, fracs);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Frac> fracs = List.of(\n            new Frac(43, 48),\n            new Frac(5, 121),\n            new Frac(2014, 59)\n        );\n        for (Frac frac : fracs) {\n            List<Frac> list = frac.toEgyptian();\n            Frac first = list.get(0);\n            if (first.denom.equals(BigInteger.ONE)) {\n                System.out.printf(\"%s -> [%s] + \", frac, first);\n            } else {\n                System.out.printf(\"%s -> %s\", frac, first);\n            }\n            for (int i = 1; i < list.size(); ++i) {\n                System.out.printf(\" + %s\", list.get(i));\n            }\n            System.out.println();\n        }\n\n        for (Integer r : List.of(98, 998)) {\n            if (r == 98) {\n                System.out.println(\"\\nFor proper fractions with 1 or 2 digits:\");\n            } else {\n                System.out.println(\"\\nFor proper fractions with 1, 2 or 3 digits:\");\n            }\n\n            int maxSize = 0;\n            List<Frac> maxSizeFracs = new ArrayList<>();\n            BigInteger maxDen = BigInteger.ZERO;\n            List<Frac> maxDenFracs = new ArrayList<>();\n            boolean[][] sieve = new boolean[r + 1][];\n            for (int i = 0; i < r + 1; ++i) {\n                sieve[i] = new boolean[r + 2];\n            }\n            for (int i = 1; i < r; ++i) {\n                for (int j = i + 1; j < r + 1; ++j) {\n                    if (sieve[i][j]) continue;\n                    Frac f = new Frac(i, j);\n                    List<Frac> list = f.toEgyptian();\n                    int listSize = list.size();\n                    if (listSize > maxSize) {\n                        maxSize = listSize;\n                        maxSizeFracs.clear();\n                        maxSizeFracs.add(f);\n                    } else if (listSize == maxSize) {\n                        maxSizeFracs.add(f);\n                    }\n                    BigInteger listDen = list.get(list.size() - 1).denom;\n                    if (listDen.compareTo(maxDen) > 0) {\n                        maxDen = listDen;\n                        maxDenFracs.clear();\n                        maxDenFracs.add(f);\n                    } else if (listDen.equals(maxDen)) {\n                        maxDenFracs.add(f);\n                    }\n                    if (i < r / 2) {\n                        int k = 2;\n                        while (true) {\n                            if (j * k > r + 1) break;\n                            sieve[i * k][j * k] = true;\n                            k++;\n                        }\n                    }\n                }\n            }\n            System.out.printf(\"  largest number of items = %s\\n\", maxSize);\n            System.out.printf(\"fraction(s) with this number\u00a0: %s\\n\", maxSizeFracs);\n            String md = maxDen.toString();\n            System.out.printf(\"  largest denominator = %s digits, \", md.length());\n            System.out.printf(\"%s...%s\\n\", md.substring(0, 20), md.substring(md.length() - 20, md.length()));\n            System.out.printf(\"fraction(s) with this denominator\u00a0: %s\\n\", maxDenFracs);\n        }\n    }\n}\n"}
{"id": 415635, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nsub isEgyption{\n    my $nr = int($_[0]);\n    my $de = int($_[1]);\n    if($nr == 0 or $de == 0){\n\t\n\treturn;\n    }\n    if($de % $nr == 0){\n\t\n\tprintf \"1/\" . int($de/$nr);\n\treturn;\n    }\n    if($nr % $de == 0){\n\t\n\tprintf $nr/$de;\n\treturn;\n    }\n    if($nr > $de){\n        printf int($nr/$de) . \" + \";\n\tisEgyption($nr%$de, $de);\n\treturn;\n    }\n    \n    my $tmp = int($de/$nr) + 1;\n    printf \"1/\" . $tmp . \" + \";\n    isEgyption($nr*$tmp-$de, $de*$tmp);\n}\n\nmy $nrI = 2014;\nmy $deI = 59;\nprintf \"\\nEgyptian Fraction Representation of \" . $nrI . \"/\" . $deI . \" is: \\n\\n\";\nisEgyption($nrI,$deI);\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class EgyptianFractions {\n    private static BigInteger gcd(BigInteger a, BigInteger b) {\n        if (b.equals(BigInteger.ZERO)) {\n            return a;\n        }\n        return gcd(b, a.mod(b));\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private BigInteger num, denom;\n\n        public Frac(BigInteger n, BigInteger d) {\n            if (d.equals(BigInteger.ZERO)) {\n                throw new IllegalArgumentException(\"Parameter d may not be zero.\");\n            }\n\n            BigInteger nn = n;\n            BigInteger dd = d;\n            if (nn.equals(BigInteger.ZERO)) {\n                dd = BigInteger.ONE;\n            } else if (dd.compareTo(BigInteger.ZERO) < 0) {\n                nn = nn.negate();\n                dd = dd.negate();\n            }\n            BigInteger g = gcd(nn, dd).abs();\n            if (g.compareTo(BigInteger.ZERO) > 0) {\n                nn = nn.divide(g);\n                dd = dd.divide(g);\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac(int n, int d) {\n            this(BigInteger.valueOf(n), BigInteger.valueOf(d));\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(\n                num.multiply(rhs.denom).add(denom.multiply(rhs.num)),\n                rhs.denom.multiply(denom)\n            );\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(num.negate(), denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return plus(rhs.unaryMinus());\n        }\n\n        @Override\n        public int compareTo(Frac rhs) {\n            BigDecimal diff = this.toBigDecimal().subtract(rhs.toBigDecimal());\n            if (diff.compareTo(BigDecimal.ZERO) < 0) {\n                return -1;\n            }\n            if (BigDecimal.ZERO.compareTo(diff) < 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (null == obj || !(obj instanceof Frac)) {\n                return false;\n            }\n            Frac rhs = (Frac) obj;\n            return compareTo(rhs) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom.equals(BigInteger.ONE)) {\n                return num.toString();\n            }\n            return String.format(\"%s/%s\", num, denom);\n        }\n\n        public BigDecimal toBigDecimal() {\n            BigDecimal bdn = new BigDecimal(num);\n            BigDecimal bdd = new BigDecimal(denom);\n            return bdn.divide(bdd, MathContext.DECIMAL128);\n        }\n\n        public List<Frac> toEgyptian() {\n            if (num.equals(BigInteger.ZERO)) {\n                return Collections.singletonList(this);\n            }\n            List<Frac> fracs = new ArrayList<>();\n            if (num.abs().compareTo(denom.abs()) >= 0) {\n                Frac div = new Frac(num.divide(denom), BigInteger.ONE);\n                Frac rem = this.minus(div);\n                fracs.add(div);\n                toEgyptian(rem.num, rem.denom, fracs);\n            } else {\n                toEgyptian(num, denom, fracs);\n            }\n            return fracs;\n        }\n\n        public void toEgyptian(BigInteger n, BigInteger d, List<Frac> fracs) {\n            if (n.equals(BigInteger.ZERO)) {\n                return;\n            }\n            BigDecimal n2 = new BigDecimal(n);\n            BigDecimal d2 = new BigDecimal(d);\n            BigDecimal[] divRem = d2.divideAndRemainder(n2, MathContext.UNLIMITED);\n            BigInteger div = divRem[0].toBigInteger();\n            if (divRem[1].compareTo(BigDecimal.ZERO) > 0) {\n                div = div.add(BigInteger.ONE);\n            }\n            fracs.add(new Frac(BigInteger.ONE, div));\n            BigInteger n3 = d.negate().mod(n);\n            if (n3.compareTo(BigInteger.ZERO) < 0) {\n                n3 = n3.add(n);\n            }\n            BigInteger d3 = d.multiply(div);\n            Frac f = new Frac(n3, d3);\n            if (f.num.equals(BigInteger.ONE)) {\n                fracs.add(f);\n                return;\n            }\n            toEgyptian(f.num, f.denom, fracs);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Frac> fracs = List.of(\n            new Frac(43, 48),\n            new Frac(5, 121),\n            new Frac(2014, 59)\n        );\n        for (Frac frac : fracs) {\n            List<Frac> list = frac.toEgyptian();\n            Frac first = list.get(0);\n            if (first.denom.equals(BigInteger.ONE)) {\n                System.out.printf(\"%s -> [%s] + \", frac, first);\n            } else {\n                System.out.printf(\"%s -> %s\", frac, first);\n            }\n            for (int i = 1; i < list.size(); ++i) {\n                System.out.printf(\" + %s\", list.get(i));\n            }\n            System.out.println();\n        }\n\n        for (Integer r : List.of(98, 998)) {\n            if (r == 98) {\n                System.out.println(\"\\nFor proper fractions with 1 or 2 digits:\");\n            } else {\n                System.out.println(\"\\nFor proper fractions with 1, 2 or 3 digits:\");\n            }\n\n            int maxSize = 0;\n            List<Frac> maxSizeFracs = new ArrayList<>();\n            BigInteger maxDen = BigInteger.ZERO;\n            List<Frac> maxDenFracs = new ArrayList<>();\n            boolean[][] sieve = new boolean[r + 1][];\n            for (int i = 0; i < r + 1; ++i) {\n                sieve[i] = new boolean[r + 2];\n            }\n            for (int i = 1; i < r; ++i) {\n                for (int j = i + 1; j < r + 1; ++j) {\n                    if (sieve[i][j]) continue;\n                    Frac f = new Frac(i, j);\n                    List<Frac> list = f.toEgyptian();\n                    int listSize = list.size();\n                    if (listSize > maxSize) {\n                        maxSize = listSize;\n                        maxSizeFracs.clear();\n                        maxSizeFracs.add(f);\n                    } else if (listSize == maxSize) {\n                        maxSizeFracs.add(f);\n                    }\n                    BigInteger listDen = list.get(list.size() - 1).denom;\n                    if (listDen.compareTo(maxDen) > 0) {\n                        maxDen = listDen;\n                        maxDenFracs.clear();\n                        maxDenFracs.add(f);\n                    } else if (listDen.equals(maxDen)) {\n                        maxDenFracs.add(f);\n                    }\n                    if (i < r / 2) {\n                        int k = 2;\n                        while (true) {\n                            if (j * k > r + 1) break;\n                            sieve[i * k][j * k] = true;\n                            k++;\n                        }\n                    }\n                }\n            }\n            System.out.printf(\"  largest number of items = %s\\n\", maxSize);\n            System.out.printf(\"fraction(s) with this number\u00a0: %s\\n\", maxSizeFracs);\n            String md = maxDen.toString();\n            System.out.printf(\"  largest denominator = %s digits, \", md.length());\n            System.out.printf(\"%s...%s\\n\", md.substring(0, 20), md.substring(md.length() - 20, md.length()));\n            System.out.printf(\"fraction(s) with this denominator\u00a0: %s\\n\", maxDenFracs);\n        }\n    }\n}\n"}
{"id": 415636, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Perl to Java: use List::Util qw(sum);\nuse constant pi => 3.14159265;\n\nsub legendre_pair {\n    my($n, $x) = @_;\n    if ($n == 1) { return $x, 1 }\n    my ($m1, $m2) = legendre_pair($n - 1, $x);\n    my $u = 1 - 1 / $n;\n    (1 + $u) * $x * $m1 - $u * $m2, $m1;\n}\n\nsub legendre {\n    my($n, $x) = @_;\n    (legendre_pair($n, $x))[0]\n}\n\nsub legendre_prime {\n    my($n, $x) = @_;\n    if ($n == 0) { return 0 }\n    if ($n == 1) { return 1 }\n    my ($m0, $m1) = legendre_pair($n, $x);\n    ($m1 - $x * $m0) * $n / (1 - $x**2);\n}\n\nsub approximate_legendre_root {\n    my($n, $k) = @_;\n    my $t = (4*$k - 1) / (4*$n + 2);\n    (1 - ($n - 1) / (8 * $n**3)) * cos(pi * $t);\n}\n\nsub newton_raphson {\n    my($n, $r) = @_;\n    while (abs(my $dr = - legendre($n,$r) / legendre_prime($n,$r)) >= 2e-16) {\n        $r += $dr;\n    }\n    $r;\n}\n\nsub legendre_root {\n    my($n, $k) = @_;\n    newton_raphson($n, approximate_legendre_root($n, $k));\n}\n\nsub weight {\n    my($n, $r) = @_;\n    2 / ((1 - $r**2) * legendre_prime($n, $r)**2)\n}\n\nsub nodes {\n    my($n) = @_;\n    my %node;\n    $node{'0'} = weight($n, 0) if 0 != $n%2;\n    for (1 .. int $n/2) {\n        my $r = legendre_root($n, $_);\n        my $w = weight($n, $r);\n        $node{$r} = $w; $node{-$r} = $w;\n    }\n    return %node\n}\n\nsub quadrature {\n    our($n, $a, $b) = @_;\n    sub scale { ($_[0] * ($b - $a) + $a + $b) / 2 }\n    %nodes = nodes($n);\n    ($b - $a) / 2 * sum map { $nodes{$_} * exp(scale($_)) } keys %nodes;\n}\n\nprintf(\"Gauss-Legendre %2d-point quadrature \u222b\u208b\u2083\u207a\u00b3 exp(x) dx \u2248\u00a0%.13f\\n\", $_, quadrature($_, -3, +3) )\n        for 5 .. 10, 20;\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class Test {\n    final static int N = 5;\n\n    static double[] lroots = new double[N];\n    static double[] weight = new double[N];\n    static double[][] lcoef = new double[N + 1][N + 1];\n\n    static void legeCoef() {\n        lcoef[0][0] = lcoef[1][1] = 1;\n\n        for (int n = 2; n <= N; n++) {\n\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n\n            for (int i = 1; i <= n; i++) {\n                lcoef[n][i] = ((2 * n - 1) * lcoef[n - 1][i - 1]\n                        - (n - 1) * lcoef[n - 2][i]) / n;\n            }\n        }\n    }\n\n    static double legeEval(int n, double x) {\n        double s = lcoef[n][n];\n        for (int i = n; i > 0; i--)\n            s = s * x + lcoef[n][i - 1];\n        return s;\n    }\n\n    static double legeDiff(int n, double x) {\n        return n * (x * legeEval(n, x) - legeEval(n - 1, x)) / (x * x - 1);\n    }\n\n    static void legeRoots() {\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = cos(PI * (i - 0.25) / (N + 0.5));\n            do {\n                x1 = x;\n                x -= legeEval(N, x) / legeDiff(N, x);\n            } while (x != x1);\n\n            lroots[i - 1] = x;\n\n            x1 = legeDiff(N, x);\n            weight[i - 1] = 2 / ((1 - x * x) * x1 * x1);\n        }\n    }\n\n    static double legeInte(Function<Double, Double> f, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weight[i] * f.apply(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n\n    public static void main(String[] args) {\n        legeCoef();\n        legeRoots();\n\n        System.out.print(\"Roots: \");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", lroots[i]);\n\n        System.out.print(\"\\nWeight:\");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", weight[i]);\n\n        System.out.printf(\"%nintegrating Exp(x) over [-3, 3]:%n\\t%10.8f,%n\"\n                + \"compared to actual%n\\t%10.8f%n\",\n                legeInte(x -> exp(x), -3, 3), exp(3) - exp(-3));\n    }\n}\n"}
{"id": 415637, "name": "Cut a rectangle", "source": "Translate Perl to Java: use strict;\nuse warnings;\nmy @grid = 0;\n \nmy ($w, $h, $len);\nmy $cnt = 0;\n \nmy @next;\nmy @dir = ([0, -1], [-1, 0], [0, 1], [1, 0]);\n\nsub walk {\n    my ($y, $x) = @_;\n\n    if (!$y || $y == $h || !$x || $x == $w) {\n\t$cnt += 2;\n\treturn;\n    }\n\n    my $t = $y * ($w + 1) + $x;\n    $grid[$_]++ for $t, $len - $t;\n \n    for my $i (0 .. 3) {\n\tif (!$grid[$t + $next[$i]]) {\n\t    walk($y + $dir[$i]->[0], $x + $dir[$i]->[1]);\n\t}\n    }\n \n    $grid[$_]-- for $t, $len - $t;\n}\n \nsub solve {\n    my ($hh, $ww, $recur) = @_;\n    my ($t, $cx, $cy, $x);\n    ($h, $w) = ($hh, $ww);\n \n    if ($h & 1) { ($t, $w, $h) = ($w, $h, $w); }\n    if ($h & 1) { return 0; }\n    if ($w == 1) { return 1; }\n    if ($w == 2) { return $h; }\n    if ($h == 2) { return $w; }\n \n    {\n\tuse integer;\n\t($cy, $cx) = ($h / 2, $w / 2);\n    }\n \n    $len = ($h + 1) * ($w + 1);\n    @grid = ();\n    $grid[$len--] = 0;\n \n    @next = (-1, -$w - 1, 1, $w + 1);\n \n    if ($recur) { $cnt = 0; }\n    for ($x = $cx + 1; $x < $w; $x++) {\n\t$t = $cy * ($w + 1) + $x;\n\t@grid[$t, $len - $t] = (1, 1);\n\twalk($cy - 1, $x);\n    }\n    $cnt++;\n \n    if ($h == $w) {\n\t$cnt *= 2;\n    } elsif (!($w & 1) && $recur) {\n\tsolve($w, $h);\n    }\n \n    return $cnt;\n}\n \nsub MAIN {\n    print \"ok\\n\";\n    my ($y, $x);\n    for my $y (1 .. 10) {\n\tfor my $x (1 .. $y) {\n\t    if (!($x & 1) || !($y & 1)) {\n\t\tprintf(\"%d x %d: %d\\n\", $y, $x, solve($y, $x, 1));\n\t    }\n\t}\n    }\n}\n\nMAIN();\n", "target": "import java.util.*;\n\npublic class CutRectangle {\n\n    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n\n    public static void main(String[] args) {\n        cutRectangle(2, 2);\n        cutRectangle(4, 3);\n    }\n\n    static void cutRectangle(int w, int h) {\n        if (w % 2 == 1 && h % 2 == 1)\n            return;\n\n        int[][] grid = new int[h][w];\n        Stack<Integer> stack = new Stack<>();\n\n        int half = (w * h) / 2;\n        long bits = (long) Math.pow(2, half) - 1;\n\n        for (; bits > 0; bits -= 2) {\n\n            for (int i = 0; i < half; i++) {\n                int r = i / w;\n                int c = i % w;\n                grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n            }\n\n            stack.push(0);\n            grid[0][0] = 2;\n            int count = 1;\n            while (!stack.empty()) {\n\n                int pos = stack.pop();\n                int r = pos / w;\n                int c = pos % w;\n\n                for (int[] dir : dirs) {\n\n                    int nextR = r + dir[0];\n                    int nextC = c + dir[1];\n\n                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n\n                        if (grid[nextR][nextC] == 1) {\n                            stack.push(nextR * w + nextC);\n                            grid[nextR][nextC] = 2;\n                            count++;\n                        }\n                    }\n                }\n            }\n            if (count == half) {\n                printResult(grid);\n            }\n        }\n    }\n\n    static void printResult(int[][] arr) {\n        for (int[] a : arr)\n            System.out.println(Arrays.toString(a));\n        System.out.println();\n    }\n}\n"}
{"id": 415638, "name": "Cut a rectangle", "source": "Translate Perl to Java: use strict;\nuse warnings;\nmy @grid = 0;\n \nmy ($w, $h, $len);\nmy $cnt = 0;\n \nmy @next;\nmy @dir = ([0, -1], [-1, 0], [0, 1], [1, 0]);\n\nsub walk {\n    my ($y, $x) = @_;\n\n    if (!$y || $y == $h || !$x || $x == $w) {\n\t$cnt += 2;\n\treturn;\n    }\n\n    my $t = $y * ($w + 1) + $x;\n    $grid[$_]++ for $t, $len - $t;\n \n    for my $i (0 .. 3) {\n\tif (!$grid[$t + $next[$i]]) {\n\t    walk($y + $dir[$i]->[0], $x + $dir[$i]->[1]);\n\t}\n    }\n \n    $grid[$_]-- for $t, $len - $t;\n}\n \nsub solve {\n    my ($hh, $ww, $recur) = @_;\n    my ($t, $cx, $cy, $x);\n    ($h, $w) = ($hh, $ww);\n \n    if ($h & 1) { ($t, $w, $h) = ($w, $h, $w); }\n    if ($h & 1) { return 0; }\n    if ($w == 1) { return 1; }\n    if ($w == 2) { return $h; }\n    if ($h == 2) { return $w; }\n \n    {\n\tuse integer;\n\t($cy, $cx) = ($h / 2, $w / 2);\n    }\n \n    $len = ($h + 1) * ($w + 1);\n    @grid = ();\n    $grid[$len--] = 0;\n \n    @next = (-1, -$w - 1, 1, $w + 1);\n \n    if ($recur) { $cnt = 0; }\n    for ($x = $cx + 1; $x < $w; $x++) {\n\t$t = $cy * ($w + 1) + $x;\n\t@grid[$t, $len - $t] = (1, 1);\n\twalk($cy - 1, $x);\n    }\n    $cnt++;\n \n    if ($h == $w) {\n\t$cnt *= 2;\n    } elsif (!($w & 1) && $recur) {\n\tsolve($w, $h);\n    }\n \n    return $cnt;\n}\n \nsub MAIN {\n    print \"ok\\n\";\n    my ($y, $x);\n    for my $y (1 .. 10) {\n\tfor my $x (1 .. $y) {\n\t    if (!($x & 1) || !($y & 1)) {\n\t\tprintf(\"%d x %d: %d\\n\", $y, $x, solve($y, $x, 1));\n\t    }\n\t}\n    }\n}\n\nMAIN();\n", "target": "import java.util.*;\n\npublic class CutRectangle {\n\n    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n\n    public static void main(String[] args) {\n        cutRectangle(2, 2);\n        cutRectangle(4, 3);\n    }\n\n    static void cutRectangle(int w, int h) {\n        if (w % 2 == 1 && h % 2 == 1)\n            return;\n\n        int[][] grid = new int[h][w];\n        Stack<Integer> stack = new Stack<>();\n\n        int half = (w * h) / 2;\n        long bits = (long) Math.pow(2, half) - 1;\n\n        for (; bits > 0; bits -= 2) {\n\n            for (int i = 0; i < half; i++) {\n                int r = i / w;\n                int c = i % w;\n                grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n            }\n\n            stack.push(0);\n            grid[0][0] = 2;\n            int count = 1;\n            while (!stack.empty()) {\n\n                int pos = stack.pop();\n                int r = pos / w;\n                int c = pos % w;\n\n                for (int[] dir : dirs) {\n\n                    int nextR = r + dir[0];\n                    int nextC = c + dir[1];\n\n                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n\n                        if (grid[nextR][nextC] == 1) {\n                            stack.push(nextR * w + nextC);\n                            grid[nextR][nextC] = 2;\n                            count++;\n                        }\n                    }\n                }\n            }\n            if (count == half) {\n                printResult(grid);\n            }\n        }\n    }\n\n    static void printResult(int[][] arr) {\n        for (int[] a : arr)\n            System.out.println(Arrays.toString(a));\n        System.out.println();\n    }\n}\n"}
{"id": 415639, "name": "Cuban primes", "source": "Translate Perl to Java: use feature 'say';\nuse ntheory 'is_prime';\n\nsub cuban_primes {\n    my ($n) = @_;\n\n    my @primes;\n    for (my $k = 1 ; ; ++$k) {\n        my $p = 3 * $k * ($k + 1) + 1;\n        if (is_prime($p)) {\n            push @primes, $p;\n            last if @primes >= $n;\n        }\n    }\n\n    return @primes;\n}\n\nsub commify {\n    scalar reverse join ',', unpack '(A3)*', reverse shift;\n}\n\nmy @c = cuban_primes(200);\n\nwhile (@c) {\n    say join ' ', map { sprintf \"%9s\", commify $_ } splice(@c, 0, 10);\n}\n\nsay '';\nfor my $n (1 .. 6) {\n    say \"10^$n-th cuban prime is: \", commify((cuban_primes(10**$n))[-1]);\n}\n", "target": "public class CubanPrimes {\n\n    private static int MAX = 1_400_000;\n    private static boolean[] primes = new boolean[MAX];\n    \n    public static void main(String[] args) {\n        preCompute();\n        cubanPrime(200, true);\n        for ( int i = 1 ; i <= 5 ; i++ ) {\n            int max = (int) Math.pow(10, i);\n            System.out.printf(\"%,d-th cuban prime =\u00a0%,d%n\", max, cubanPrime(max, false));\n        }\n    }\n    \n    private static long cubanPrime(int n, boolean display) {\n        int count = 0;\n        long result = 0;\n        for ( long i = 0 ; count < n ; i++ ) {\n            long test = 1l + 3 * i * (i+1);\n            if ( isPrime(test) ) {\n                count++;\n                result = test;\n                if ( display ) {\n                    System.out.printf(\"%10s%s\", String.format(\"%,d\", test), count % 10 == 0 ? \"\\n\" : \"\");\n                }\n            }\n        }\n        return result;\n    }\n    \n    private static boolean isPrime(long n) {\n        if ( n < MAX ) {\n            return primes[(int)n];\n        }\n        int max = (int) Math.sqrt(n);\n        for ( int i = 3 ; i <= max ; i++ ) {\n            if ( primes[i] && n % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static final void preCompute() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415640, "name": "Chaos game", "source": "Translate Perl to Java: use Imager;\n\nmy $width  = 1000;\nmy $height = 1000;\n\nmy @points = (\n    [ $width/2,         0],\n    [        0, $height-1],\n    [$height-1, $height-1],\n);\n\nmy $img = Imager->new(\n                      xsize    => $width,\n                      ysize    => $height,\n                      channels => 3,\n                     );\n\nmy $color = Imager::Color->new('\nmy $r = [int(rand($width)), int(rand($height))];\n\nforeach my $i (1 .. 100000) {\n    my $p = $points[rand @points];\n\n    my $h = [\n        int(($p->[0] + $r->[0]) / 2),\n        int(($p->[1] + $r->[1]) / 2),\n    ];\n\n    $img->setpixel(\n        x     => $h->[0],\n        y     => $h->[1],\n        color => $color,\n    );\n\n    $r = $h;\n}\n\n$img->write(file => 'chaos_game_triangle.png');\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415641, "name": "Chaos game", "source": "Translate Perl to Java: use Imager;\n\nmy $width  = 1000;\nmy $height = 1000;\n\nmy @points = (\n    [ $width/2,         0],\n    [        0, $height-1],\n    [$height-1, $height-1],\n);\n\nmy $img = Imager->new(\n                      xsize    => $width,\n                      ysize    => $height,\n                      channels => 3,\n                     );\n\nmy $color = Imager::Color->new('\nmy $r = [int(rand($width)), int(rand($height))];\n\nforeach my $i (1 .. 100000) {\n    my $p = $points[rand @points];\n\n    my $h = [\n        int(($p->[0] + $r->[0]) / 2),\n        int(($p->[1] + $r->[1]) / 2),\n    ];\n\n    $img->setpixel(\n        x     => $h->[0],\n        y     => $h->[1],\n        color => $color,\n    );\n\n    $r = $h;\n}\n\n$img->write(file => 'chaos_game_triangle.png');\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415642, "name": "World Cup group stage", "source": "Translate Perl to Java: use Math::Cartesian::Product;\n\n@scoring = (0, 1, 3);\npush @histo, [(0) x 10] for 1..4;\npush @aoa,    [(0,1,2)] for 1..6;\n\nfor $results (cartesian {@_} @aoa) {\n    my @s;\n    my @g = ([0,1],[0,2],[0,3],[1,2],[1,3],[2,3]);\n    for (0..$\n        $r = $results->[$_];\n        $s[$g[$_][0]] += $scoring[$r];\n        $s[$g[$_][1]] += $scoring[2 - $r];\n    }\n\n    my @ss = sort @s;\n    $histo[$_][$ss[$_]]++ for 0..$\n}\n\n$fmt = ('%3d ') x 10 . \"\\n\";\nprintf $fmt, @$_ for reverse @histo;\n", "target": "import java.util.Arrays;\n \npublic class GroupStage{\n    \n    static String[] games = {\"12\", \"13\", \"14\", \"23\", \"24\", \"34\"};\n    static String results = \"000000\";\n\n    private static boolean nextResult(){\n        if(results.equals(\"222222\")) return false;\n        int res = Integer.parseInt(results, 3) + 1;\n        results = Integer.toString(res, 3);\n        while(results.length() < 6) results = \"0\" + results;\t\n        return true;\n    }\n\n    public static void main(String[] args){\n        int[][] points = new int[4][10]; \t\t\n        do{\n            int[] records = {0,0,0,0};\n            for(int i = 0; i < 6; i++){\n                switch(results.charAt(i)){\n                    case '2': records[games[i].charAt(0) - '1'] += 3; break;    \n                    case '1':                                                   \n                        records[games[i].charAt(0) - '1']++;\n                        records[games[i].charAt(1) - '1']++;\n                        break;\n                    case '0': records[games[i].charAt(1) - '1'] += 3; break;    \n                }\n            }\n            Arrays.sort(records);\t\n            points[0][records[0]]++;\n            points[1][records[1]]++;\n            points[2][records[2]]++;\n            points[3][records[3]]++;\n        }while(nextResult());\n        System.out.println(\"First place: \" + Arrays.toString(points[3]));\n        System.out.println(\"Second place: \" + Arrays.toString(points[2]));\n        System.out.println(\"Third place: \" + Arrays.toString(points[1]));\n        System.out.println(\"Fourth place: \" + Arrays.toString(points[0]));\n    }\n}\n"}
{"id": 415643, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Perl to Java: my %prec = (\n    '^' => 4,\n    '*' => 3,\n    '/' => 3,\n    '+' => 2,\n    '-' => 2,\n    '(' => 1\n);\n\nmy %assoc = (\n    '^' => 'right',\n    '*' => 'left',\n    '/' => 'left',\n    '+' => 'left',\n    '-' => 'left'\n);\n\nsub shunting_yard {\n    my @inp = split ' ', $_[0];\n    my @ops;\n    my @res;\n\n    my $report = sub { printf \"%25s   \u00a0%-7s %10s %s\\n\", \"@res\", \"@ops\", $_[0], \"@inp\" };\n    my $shift  = sub { $report->(\"shift @_\");  push @ops, @_ };\n    my $reduce = sub { $report->(\"reduce @_\"); push @res, @_ };\n\n    while (@inp) {\n        my $token = shift @inp;\n        if    ( $token =~ /\\d/ ) { $reduce->($token) }\n        elsif ( $token eq '(' )  { $shift->($token) }\n        elsif ( $token eq ')' ) {\n            while ( @ops and \"(\" ne ( my $x = pop @ops ) ) { $reduce->($x) }\n        } else {\n            my $newprec = $prec{$token};\n            while (@ops) {\n                my $oldprec = $prec{ $ops[-1] };\n                last if $newprec > $oldprec;\n                last if $newprec == $oldprec and $assoc{$token} eq 'right';\n                $reduce->( pop @ops );\n            }\n            $shift->($token);\n        }\n    }\n    $reduce->( pop @ops ) while @ops;\n    @res;\n}\n\nlocal $, = \" \";\nprint shunting_yard '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3';\n", "target": "import java.util.Stack;\n\npublic class ShuntingYard {\n\n    public static void main(String[] args) {\n        String infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        System.out.printf(\"infix:   %s%n\", infix);\n        System.out.printf(\"postfix: %s%n\", infixToPostfix(infix));\n    }\n\n    static String infixToPostfix(String infix) {\n        \n        final String ops = \"-+/*^\";\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n\n        for (String token : infix.split(\"\\\\s\")) {\n            if (token.isEmpty())\n                continue;\n            char c = token.charAt(0);\n            int idx = ops.indexOf(c);\n\n            \n            if (idx != -1) {\n                if (s.isEmpty())\n                    s.push(idx);\n          \n                else {\n                    while (!s.isEmpty()) {\n                        int prec2 = s.peek() / 2;\n                        int prec1 = idx / 2;\n                        if (prec2 > prec1 || (prec2 == prec1 && c != '^'))\n                            sb.append(ops.charAt(s.pop())).append(' ');\n                        else break;\n                    }\n                    s.push(idx);\n                }\n            } \n            else if (c == '(') {\n                s.push(-2); \n            } \n            else if (c == ')') {\n                \n                while (s.peek() != -2)\n                    sb.append(ops.charAt(s.pop())).append(' ');\n                s.pop();\n            }\n            else {\n                sb.append(token).append(' ');\n            }\n        }\n        while (!s.isEmpty())\n            sb.append(ops.charAt(s.pop())).append(' ');\n        return sb.toString();\n    }\n}\n"}
{"id": 415644, "name": "Perlin noise", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse experimental 'signatures';\n\nuse constant permutation => qw{\n 151 160 137  91  90  15 131  13 201  95  96  53 194 233   7 225 140  36 103  30  69\n 142   8  99  37 240  21  10  23 190   6 148 247 120 234  75   0  26 197  62  94 252\n 219 203 117  35  11  32  57 177  33  88 237 149  56  87 174  20 125 136 171 168  68\n 175  74 165  71 134 139  48  27 166  77 146 158 231  83 111 229 122  60 211 133 230\n 220 105  92  41  55  46 245  40 244 102 143  54  65  25  63 161   1 216  80  73 209\n  76 132 187 208  89  18 169 200 196 135 130 116 188 159  86 164 100 109 198 173 186\n   3  64  52 217 226 250 124 123   5 202  38 147 118 126 255  82  85 212 207 206  59\n 227  47  16  58  17 182 189  28  42 223 183 170 213 119 248 152   2  44 154 163  70\n 221 153 101 155 167  43 172   9 129  22  39 253  19  98 108 110  79 113 224 232 178\n 185 112 104 218 246  97 228 251  34 242 193 238 210 144  12 191 179 162 241  81  51\n 145 235 249  14 239 107  49 192 214  31 181 199 106 157 184  84 204 176 115 121  50\n  45 127   4 150 254 138 236 205  93 222 114  67  29  24  72 243 141 128 195  78  66\n 215  61 156 180};\nuse constant p => permutation, permutation;\n\nsub floor ($x) { my $xi = int($x); return $x < $xi ? $xi - 1 : $xi }\n\nsub fade ($t) { $t**3 * ($t * ($t * 6 - 15) + 10) }\n\nsub lerp ($t, $a, $b) { $a + $t * ($b - $a) }\n\nsub grad ($h, $x, $y, $z) {\n    $h &= 15;\n    my $u = $h < 8 ? $x : $y;\n    my $v = $h < 4 ? $y : ($h == 12 or $h == 14) ? $x : $z;\n    (($h & 1) == 0 ? $u : -$u) + (($h & 2) == 0 ? $v : -$v);\n}\n\nsub noise ($x, $y, $z) {\n    my ($X, $Y, $Z) = map { 255 & floor $_ } $x,       $y,       $z;\n    my ($u, $v, $w) = map {        fade $_ } $x -= $X, $y -= $Y, $z -= $Z;\n    my $A = (p)[$X] + $Y;\n    my ($AA, $AB) = ( (p)[$A] + $Z, (p)[$A + 1] + $Z );\n    my $B = (p)[$X + 1] + $Y;\n    my ($BA, $BB) = ( (p)[$B] + $Z, (p)[$B + 1] + $Z );   \n    lerp($w, lerp($v, lerp($u, grad((p)[$AA    ], $x    , $y    , $z     ),\n                               grad((p)[$BA    ], $x - 1, $y    , $z     )),\n                      lerp($u, grad((p)[$AB    ], $x    , $y - 1, $z     ),\n                               grad((p)[$BB    ], $x - 1, $y - 1, $z     ))),\n             lerp($v, lerp($u, grad((p)[$AA + 1], $x    , $y    , $z - 1 ),\n                               grad((p)[$BA + 1], $x - 1, $y    , $z - 1 )),\n                      lerp($u, grad((p)[$AB + 1], $x    , $y - 1, $z - 1 ),\n                               grad((p)[$BB + 1], $x - 1, $y - 1, $z - 1 ))));\n}\n\nprint noise 3.14, 42, 7;\n", "target": "\n\npublic final class ImprovedNoise {\n   static public double noise(double x, double y, double z) {\n      int X = (int)Math.floor(x) & 255,                  \n          Y = (int)Math.floor(y) & 255,                  \n          Z = (int)Math.floor(z) & 255;\n      x -= Math.floor(x);                                \n      y -= Math.floor(y);                                \n      z -= Math.floor(z);\n      double u = fade(x),                                \n             v = fade(y),                                \n             w = fade(z);\n      int A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      \n          B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      \n\n      return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                     grad(p[BA  ], x-1, y  , z   )), \n                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                     grad(p[BB  ], x-1, y-1, z   ))),\n                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                     grad(p[BA+1], x-1, y  , z-1 )), \n                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                     grad(p[BB+1], x-1, y-1, z-1 ))));\n   }\n   static double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }\n   static double lerp(double t, double a, double b) { return a + t * (b - a); }\n   static double grad(int hash, double x, double y, double z) {\n      int h = hash & 15;                      \n      double u = h<8 ? x : y,                 \n             v = h<4 ? y : h==12||h==14 ? x : z;\n      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n   }\n   static final int p[] = new int[512], permutation[] = { 151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n   };\n   static { for (int i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i]; }\n}\n"}
{"id": 415645, "name": "A_ search algorithm", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( nsort_by );\n\nsub distance\n  {\n  my ($r1, $c1, $r2, $c2) = split /[, ]/, \"@_\";\n  sqrt( ($r1-$r2)**2 + ($c1-$c2)**2 );\n  }\n\nmy $start = '0,0';\nmy $finish = '7,7';\nmy %barrier = map {$_, 100}\n  split ' ', '2,4 2,5 2,6 3,6 4,6 5,6 5,5 5,4 5,3 5,2 4,2 3,2';\nmy %values = ( $start, 0 );\nmy @new = [ $start, 0 ];\nmy %from;\nmy $mid;\nwhile( ! exists $values{$finish} and @new )\n  {\n  my $pick = (shift @new)->[0];\n  for my $n ( nsort_by { distance($_, $finish) } \n    grep !/-|8/ && ! exists $values{$_},\n    glob $pick =~ s/\\d+/{@{[$&-1]},$&,@{[$&+1]}}/gr\n    )\n    {\n    $from{$n} = $pick;\n    $values{$n} = $values{$pick} + ( $barrier{$n} // 1 );\n    my $new = [ $n, my $dist = $values{$n} ];\n    my $low = 0; \n    my $high = @new;\n    $new[$mid = $low + $high >> 1][1] <= $dist\n      ? ($low = $mid + 1) : ($high = $mid) while $low < $high;\n    splice @new, $low, 0, $new; \n    }\n  }\n\nmy $grid = \"s.......\\n\" . ('.' x 8 . \"\\n\") x 7;\nsubstr $grid, /,/ * $` * 9 + $', 1, 'b' for keys %barrier;\nmy @path = my $pos = $finish; \nwhile( $pos ne $start )\n  {\n  substr $grid, $pos =~ /,/ ? $` * 9 + $' : die, 1, 'x';\n  unshift @path, $pos = $from{$pos};\n  }\nprint \"$grid\\nvalue $values{$finish}  path @path\\n\";\n", "target": "package astar;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\nclass AStar {\n    private final List<Node> open;\n    private final List<Node> closed;\n    private final List<Node> path;\n    private final int[][] maze;\n    private Node now;\n    private final int xstart;\n    private final int ystart;\n    private int xend, yend;\n    private final boolean diag;\n\n    \n    static class Node implements Comparable {\n        public Node parent;\n        public int x, y;\n        public double g;\n        public double h;\n        Node(Node parent, int xpos, int ypos, double g, double h) {\n            this.parent = parent;\n            this.x = xpos;\n            this.y = ypos;\n            this.g = g;\n            this.h = h;\n       }\n       \n       @Override\n       public int compareTo(Object o) {\n           Node that = (Node) o;\n           return (int)((this.g + this.h) - (that.g + that.h));\n       }\n   }\n\n    AStar(int[][] maze, int xstart, int ystart, boolean diag) {\n        this.open = new ArrayList<>();\n        this.closed = new ArrayList<>();\n        this.path = new ArrayList<>();\n        this.maze = maze;\n        this.now = new Node(null, xstart, ystart, 0, 0);\n        this.xstart = xstart;\n        this.ystart = ystart;\n        this.diag = diag;\n    }\n    \n    public List<Node> findPathTo(int xend, int yend) {\n        this.xend = xend;\n        this.yend = yend;\n        this.closed.add(this.now);\n        addNeigborsToOpenList();\n        while (this.now.x != this.xend || this.now.y != this.yend) {\n            if (this.open.isEmpty()) { \n                return null;\n            }\n            this.now = this.open.get(0); \n            this.open.remove(0); \n            this.closed.add(this.now); \n            addNeigborsToOpenList();\n        }\n        this.path.add(0, this.now);\n        while (this.now.x != this.xstart || this.now.y != this.ystart) {\n            this.now = this.now.parent;\n            this.path.add(0, this.now);\n        }\n        return this.path;\n    }\n     \n    public void expandAStar(int[][] maze, int xstart, int ystart, boolean diag){\n        Queue<Mazecoord> exploreNodes = new LinkedList<Mazecoord>();\n        if(maze[stateNode.getR()][stateNode.getC()] == 2){\n            if(isNodeILegal(stateNode, stateNode.expandDirection())){     \n                exploreNodes.add(stateNode.expandDirection());\n         }\n     }\n    \n    public void AStarSearch(){\n        this.start.setCostToGoal(this.start.calculateCost(this.goal));\n        this.start.setPathCost(0);\n        this.start.setAStartCost(this.start.getPathCost() + this.start.getCostToGoal());\n        Mazecoord intialNode = this.start;\n        Mazecoord stateNode = intialNode;\n        frontier.add(intialNode);\n        \n        while (true){\n            if(frontier.isEmpty()){\n                System.out.println(\"fail\");\n                System.out.println(explored.size());\n                System.exit(-1);\n            }\n     }\n    \n    \n    public int calculateCost(Mazecoord goal){\n        int rState = this.getR();\n        int rGoal = goal.getR();\n        int diffR = rState - rGoal;\n        int diffC = this.getC() - goal.getC();\n        if(diffR * diffC > 0) {     \n            return Math.abs(diffR) + Math.abs(diffC);\n        } else {\n            return Math.max(Math.abs(diffR), Math.abs(diffC));\n        }\n    }\n\n    public Coord getFather(){\n        return this.father;\n    }\n\n    public void setFather(Mazecoord node){\n        this.father = node;\n    }\n\n   public int getAStartCost() {\n        return AStartCost;\n    }\n\n    public void setAStartCost(int aStartCost) {\n        AStartCost = aStartCost;\n    }\n\n    public int getCostToGoal() {\n        return costToGoal;\n    }\n\n    public void setCostToGoal(int costToGoal) {\n        this.costToGoal = costToGoal;\n    }\n    \n    private double distance(int dx, int dy) {\n        if (this.diag) { \n            return Math.hypot(this.now.x + dx - this.xend, this.now.y + dy - this.yend); \n        } else {\n            return Math.abs(this.now.x + dx - this.xend) + Math.abs(this.now.y + dy - this.yend); \n        }\n    }\n    private void addNeigborsToOpenList() {\n        Node node;\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                if (!this.diag && x != 0 && y != 0) {\n                    continue; \n                }\n                node = new Node(this.now, this.now.x + x, this.now.y + y, this.now.g, this.distance(x, y));\n                if ((x != 0 || y != 0) \n                    && this.now.x + x >= 0 && this.now.x + x < this.maze[0].length \n                    && this.now.y + y >= 0 && this.now.y + y < this.maze.length\n                    && this.maze[this.now.y + y][this.now.x + x] != -1 \n                    && !findNeighborInList(this.open, node) && !findNeighborInList(this.closed, node)) { \n                        node.g = node.parent.g + 1.; \n                        node.g += maze[this.now.y + y][this.now.x + x]; \n\n                        \n                        \n                        \n                        this.open.add(node);\n                }\n            }\n        }\n        Collections.sort(this.open);\n    }\n\n    public static void main(String[] args) {\n        \n        \n        int[][] maze = {\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n        };\n        AStar as = new AStar(maze, 0, 0, true);\n        List<Node> path = as.findPathTo(7, 7);\n        if (path != null) {\n            path.forEach((n) -> {\n                System.out.print(\"[\" + n.x + \", \" + n.y + \"] \");\n                maze[n.y][n.x] = -1;\n            });\n            System.out.printf(\"\\nTotal cost:\u00a0%.02f\\n\", path.get(path.size() - 1).g);\n\n            for (int[] maze_row : maze) {\n                for (int maze_entry : maze_row) {\n                    switch (maze_entry) {\n                        case 0:\n                            System.out.print(\"_\");\n                            break;\n                        case -1:\n                            System.out.print(\"*\");\n                            break;\n                        default:\n                            System.out.print(\"#\");\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415646, "name": "A_ search algorithm", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( nsort_by );\n\nsub distance\n  {\n  my ($r1, $c1, $r2, $c2) = split /[, ]/, \"@_\";\n  sqrt( ($r1-$r2)**2 + ($c1-$c2)**2 );\n  }\n\nmy $start = '0,0';\nmy $finish = '7,7';\nmy %barrier = map {$_, 100}\n  split ' ', '2,4 2,5 2,6 3,6 4,6 5,6 5,5 5,4 5,3 5,2 4,2 3,2';\nmy %values = ( $start, 0 );\nmy @new = [ $start, 0 ];\nmy %from;\nmy $mid;\nwhile( ! exists $values{$finish} and @new )\n  {\n  my $pick = (shift @new)->[0];\n  for my $n ( nsort_by { distance($_, $finish) } \n    grep !/-|8/ && ! exists $values{$_},\n    glob $pick =~ s/\\d+/{@{[$&-1]},$&,@{[$&+1]}}/gr\n    )\n    {\n    $from{$n} = $pick;\n    $values{$n} = $values{$pick} + ( $barrier{$n} // 1 );\n    my $new = [ $n, my $dist = $values{$n} ];\n    my $low = 0; \n    my $high = @new;\n    $new[$mid = $low + $high >> 1][1] <= $dist\n      ? ($low = $mid + 1) : ($high = $mid) while $low < $high;\n    splice @new, $low, 0, $new; \n    }\n  }\n\nmy $grid = \"s.......\\n\" . ('.' x 8 . \"\\n\") x 7;\nsubstr $grid, /,/ * $` * 9 + $', 1, 'b' for keys %barrier;\nmy @path = my $pos = $finish; \nwhile( $pos ne $start )\n  {\n  substr $grid, $pos =~ /,/ ? $` * 9 + $' : die, 1, 'x';\n  unshift @path, $pos = $from{$pos};\n  }\nprint \"$grid\\nvalue $values{$finish}  path @path\\n\";\n", "target": "package astar;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\nclass AStar {\n    private final List<Node> open;\n    private final List<Node> closed;\n    private final List<Node> path;\n    private final int[][] maze;\n    private Node now;\n    private final int xstart;\n    private final int ystart;\n    private int xend, yend;\n    private final boolean diag;\n\n    \n    static class Node implements Comparable {\n        public Node parent;\n        public int x, y;\n        public double g;\n        public double h;\n        Node(Node parent, int xpos, int ypos, double g, double h) {\n            this.parent = parent;\n            this.x = xpos;\n            this.y = ypos;\n            this.g = g;\n            this.h = h;\n       }\n       \n       @Override\n       public int compareTo(Object o) {\n           Node that = (Node) o;\n           return (int)((this.g + this.h) - (that.g + that.h));\n       }\n   }\n\n    AStar(int[][] maze, int xstart, int ystart, boolean diag) {\n        this.open = new ArrayList<>();\n        this.closed = new ArrayList<>();\n        this.path = new ArrayList<>();\n        this.maze = maze;\n        this.now = new Node(null, xstart, ystart, 0, 0);\n        this.xstart = xstart;\n        this.ystart = ystart;\n        this.diag = diag;\n    }\n    \n    public List<Node> findPathTo(int xend, int yend) {\n        this.xend = xend;\n        this.yend = yend;\n        this.closed.add(this.now);\n        addNeigborsToOpenList();\n        while (this.now.x != this.xend || this.now.y != this.yend) {\n            if (this.open.isEmpty()) { \n                return null;\n            }\n            this.now = this.open.get(0); \n            this.open.remove(0); \n            this.closed.add(this.now); \n            addNeigborsToOpenList();\n        }\n        this.path.add(0, this.now);\n        while (this.now.x != this.xstart || this.now.y != this.ystart) {\n            this.now = this.now.parent;\n            this.path.add(0, this.now);\n        }\n        return this.path;\n    }\n     \n    public void expandAStar(int[][] maze, int xstart, int ystart, boolean diag){\n        Queue<Mazecoord> exploreNodes = new LinkedList<Mazecoord>();\n        if(maze[stateNode.getR()][stateNode.getC()] == 2){\n            if(isNodeILegal(stateNode, stateNode.expandDirection())){     \n                exploreNodes.add(stateNode.expandDirection());\n         }\n     }\n    \n    public void AStarSearch(){\n        this.start.setCostToGoal(this.start.calculateCost(this.goal));\n        this.start.setPathCost(0);\n        this.start.setAStartCost(this.start.getPathCost() + this.start.getCostToGoal());\n        Mazecoord intialNode = this.start;\n        Mazecoord stateNode = intialNode;\n        frontier.add(intialNode);\n        \n        while (true){\n            if(frontier.isEmpty()){\n                System.out.println(\"fail\");\n                System.out.println(explored.size());\n                System.exit(-1);\n            }\n     }\n    \n    \n    public int calculateCost(Mazecoord goal){\n        int rState = this.getR();\n        int rGoal = goal.getR();\n        int diffR = rState - rGoal;\n        int diffC = this.getC() - goal.getC();\n        if(diffR * diffC > 0) {     \n            return Math.abs(diffR) + Math.abs(diffC);\n        } else {\n            return Math.max(Math.abs(diffR), Math.abs(diffC));\n        }\n    }\n\n    public Coord getFather(){\n        return this.father;\n    }\n\n    public void setFather(Mazecoord node){\n        this.father = node;\n    }\n\n   public int getAStartCost() {\n        return AStartCost;\n    }\n\n    public void setAStartCost(int aStartCost) {\n        AStartCost = aStartCost;\n    }\n\n    public int getCostToGoal() {\n        return costToGoal;\n    }\n\n    public void setCostToGoal(int costToGoal) {\n        this.costToGoal = costToGoal;\n    }\n    \n    private double distance(int dx, int dy) {\n        if (this.diag) { \n            return Math.hypot(this.now.x + dx - this.xend, this.now.y + dy - this.yend); \n        } else {\n            return Math.abs(this.now.x + dx - this.xend) + Math.abs(this.now.y + dy - this.yend); \n        }\n    }\n    private void addNeigborsToOpenList() {\n        Node node;\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                if (!this.diag && x != 0 && y != 0) {\n                    continue; \n                }\n                node = new Node(this.now, this.now.x + x, this.now.y + y, this.now.g, this.distance(x, y));\n                if ((x != 0 || y != 0) \n                    && this.now.x + x >= 0 && this.now.x + x < this.maze[0].length \n                    && this.now.y + y >= 0 && this.now.y + y < this.maze.length\n                    && this.maze[this.now.y + y][this.now.x + x] != -1 \n                    && !findNeighborInList(this.open, node) && !findNeighborInList(this.closed, node)) { \n                        node.g = node.parent.g + 1.; \n                        node.g += maze[this.now.y + y][this.now.x + x]; \n\n                        \n                        \n                        \n                        this.open.add(node);\n                }\n            }\n        }\n        Collections.sort(this.open);\n    }\n\n    public static void main(String[] args) {\n        \n        \n        int[][] maze = {\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n        };\n        AStar as = new AStar(maze, 0, 0, true);\n        List<Node> path = as.findPathTo(7, 7);\n        if (path != null) {\n            path.forEach((n) -> {\n                System.out.print(\"[\" + n.x + \", \" + n.y + \"] \");\n                maze[n.y][n.x] = -1;\n            });\n            System.out.printf(\"\\nTotal cost:\u00a0%.02f\\n\", path.get(path.size() - 1).g);\n\n            for (int[] maze_row : maze) {\n                for (int maze_entry : maze_row) {\n                    switch (maze_entry) {\n                        case 0:\n                            System.out.print(\"_\");\n                            break;\n                        case -1:\n                            System.out.print(\"*\");\n                            break;\n                        default:\n                            System.out.print(\"#\");\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 415647, "name": "Nonogram solver", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $file = 'nonogram_problems.txt';\nopen my $fd, '<', $file or die \"$! opening $file\";\n\nwhile(my $row = <$fd> )\n  {\n  $row =~ /\\S/ or next;\n  my $column = <$fd>;\n  my @rpats = makepatterns($row);\n  my @cpats = makepatterns($column);\n  my @rows = ( '.' x @cpats ) x @rpats;\n  for( my $prev = ''; $prev ne \"@rows\"; )\n    {\n    $prev = \"@rows\";\n    try(\\@rows, \\@rpats);\n    my @cols = map { join '', map { s/.//; $& } @rows } 0..$\n    try(\\@cols, \\@cpats);\n    @rows = map { join '', map { s/.//; $& } @cols } 0..$\n    }\n  print \"\\n\", \"@rows\" =~ /\\./ ? \"Failed\\n\" : map { tr/01/.\n  }\n\nsub try\n  {\n  my ($lines, $patterns) = @_;\n  for my $i ( 0 .. $\n    {\n    while( $lines->[$i] =~ /\\./g )\n      {\n      for my $try ( 0, 1 )\n        {\n        $lines->[$i] =~ s/.\\G/$try/r =~ $patterns->[$i] or\n          $lines->[$i] =~ s// 1 - $try /e;\n        }\n      }\n    }\n  }\n\nsub makepatterns {                         \n    map { qr/^$_$/                          \n        } map {  '[0.]*'                    \n               . join('[0.]+',              \n                       map { \"[1.]{$_}\"     \n                           } map { -64+ord  \n                                 } split // \n                     )\n               . '[0.]*'                    \n              } split ' ', shift;           \n}\n", "target": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.stream.Collectors.toList;\n\npublic class NonogramSolver {\n\n    static String[] p1 = {\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"};\n\n    static String[] p2 = {\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\", \"D D AE \"\n        + \"CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"};\n\n    static String[] p3 = {\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH \"\n        + \"BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n        \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF \"\n        + \"AAAAD BDG CEF CBDB BBB FC\"};\n\n    static String[] p4 = {\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q \"\n        + \"R AN AAN EI H G\", \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ \"\n        + \"ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\"};\n\n    public static void main(String[] args) {\n        for (String[] puzzleData : new String[][]{p1, p2, p3, p4})\n            newPuzzle(puzzleData);\n    }\n\n    static void newPuzzle(String[] data) {\n        String[] rowData = data[0].split(\"\\\\s\");\n        String[] colData = data[1].split(\"\\\\s\");\n\n        List<List<BitSet>> cols, rows;\n        rows = getCandidates(rowData, colData.length);\n        cols = getCandidates(colData, rowData.length);\n\n        int numChanged;\n        do {\n            numChanged = reduceMutual(cols, rows);\n            if (numChanged == -1) {\n                System.out.println(\"No solution\");\n                return;\n            }\n        } while (numChanged > 0);\n\n        for (List<BitSet> row : rows) {\n            for (int i = 0; i < cols.size(); i++)\n                System.out.print(row.get(0).get(i) ? \"# \" : \". \");\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    \n    static List<List<BitSet>> getCandidates(String[] data, int len) {\n        List<List<BitSet>> result = new ArrayList<>();\n\n        for (String s : data) {\n            List<BitSet> lst = new LinkedList<>();\n\n            int sumChars = s.chars().map(c -> c - 'A' + 1).sum();\n            List<String> prep = stream(s.split(\"\"))\n                    .map(x -> repeat(x.charAt(0) - 'A' + 1, \"1\")).collect(toList());\n\n            for (String r : genSequence(prep, len - sumChars + 1)) {\n                char[] bits = r.substring(1).toCharArray();\n                BitSet bitset = new BitSet(bits.length);\n                for (int i = 0; i < bits.length; i++)\n                    bitset.set(i, bits[i] == '1');\n                lst.add(bitset);\n            }\n            result.add(lst);\n        }\n        return result;\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n\n    \n\n    static int reduceMutual(List<List<BitSet>> cols, List<List<BitSet>> rows) {\n        int countRemoved1 = reduce(cols, rows);\n        if (countRemoved1 == -1)\n            return -1;\n\n        int countRemoved2 = reduce(rows, cols);\n        if (countRemoved2 == -1)\n            return -1;\n\n        return countRemoved1 + countRemoved2;\n    }\n\n    static int reduce(List<List<BitSet>> a, List<List<BitSet>> b) {\n        int countRemoved = 0;\n\n        for (int i = 0; i < a.size(); i++) {\n\n            BitSet commonOn = new BitSet();\n            commonOn.set(0, b.size());\n            BitSet commonOff = new BitSet();\n\n            \n            for (BitSet candidate : a.get(i)) {\n                commonOn.and(candidate);\n                commonOff.or(candidate);\n            }\n\n            \n            for (int j = 0; j < b.size(); j++) {\n                final int fi = i, fj = j;\n\n                if (b.get(j).removeIf(cnd -> (commonOn.get(fj) && !cnd.get(fi))\n                        || (!commonOff.get(fj) && cnd.get(fi))))\n                    countRemoved++;\n\n                if (b.get(j).isEmpty())\n                    return -1;\n            }\n        }\n        return countRemoved;\n    }\n}\n"}
{"id": 415648, "name": "Nonogram solver", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $file = 'nonogram_problems.txt';\nopen my $fd, '<', $file or die \"$! opening $file\";\n\nwhile(my $row = <$fd> )\n  {\n  $row =~ /\\S/ or next;\n  my $column = <$fd>;\n  my @rpats = makepatterns($row);\n  my @cpats = makepatterns($column);\n  my @rows = ( '.' x @cpats ) x @rpats;\n  for( my $prev = ''; $prev ne \"@rows\"; )\n    {\n    $prev = \"@rows\";\n    try(\\@rows, \\@rpats);\n    my @cols = map { join '', map { s/.//; $& } @rows } 0..$\n    try(\\@cols, \\@cpats);\n    @rows = map { join '', map { s/.//; $& } @cols } 0..$\n    }\n  print \"\\n\", \"@rows\" =~ /\\./ ? \"Failed\\n\" : map { tr/01/.\n  }\n\nsub try\n  {\n  my ($lines, $patterns) = @_;\n  for my $i ( 0 .. $\n    {\n    while( $lines->[$i] =~ /\\./g )\n      {\n      for my $try ( 0, 1 )\n        {\n        $lines->[$i] =~ s/.\\G/$try/r =~ $patterns->[$i] or\n          $lines->[$i] =~ s// 1 - $try /e;\n        }\n      }\n    }\n  }\n\nsub makepatterns {                         \n    map { qr/^$_$/                          \n        } map {  '[0.]*'                    \n               . join('[0.]+',              \n                       map { \"[1.]{$_}\"     \n                           } map { -64+ord  \n                                 } split // \n                     )\n               . '[0.]*'                    \n              } split ' ', shift;           \n}\n", "target": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.stream.Collectors.toList;\n\npublic class NonogramSolver {\n\n    static String[] p1 = {\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"};\n\n    static String[] p2 = {\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\", \"D D AE \"\n        + \"CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"};\n\n    static String[] p3 = {\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH \"\n        + \"BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n        \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF \"\n        + \"AAAAD BDG CEF CBDB BBB FC\"};\n\n    static String[] p4 = {\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q \"\n        + \"R AN AAN EI H G\", \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ \"\n        + \"ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\"};\n\n    public static void main(String[] args) {\n        for (String[] puzzleData : new String[][]{p1, p2, p3, p4})\n            newPuzzle(puzzleData);\n    }\n\n    static void newPuzzle(String[] data) {\n        String[] rowData = data[0].split(\"\\\\s\");\n        String[] colData = data[1].split(\"\\\\s\");\n\n        List<List<BitSet>> cols, rows;\n        rows = getCandidates(rowData, colData.length);\n        cols = getCandidates(colData, rowData.length);\n\n        int numChanged;\n        do {\n            numChanged = reduceMutual(cols, rows);\n            if (numChanged == -1) {\n                System.out.println(\"No solution\");\n                return;\n            }\n        } while (numChanged > 0);\n\n        for (List<BitSet> row : rows) {\n            for (int i = 0; i < cols.size(); i++)\n                System.out.print(row.get(0).get(i) ? \"# \" : \". \");\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    \n    static List<List<BitSet>> getCandidates(String[] data, int len) {\n        List<List<BitSet>> result = new ArrayList<>();\n\n        for (String s : data) {\n            List<BitSet> lst = new LinkedList<>();\n\n            int sumChars = s.chars().map(c -> c - 'A' + 1).sum();\n            List<String> prep = stream(s.split(\"\"))\n                    .map(x -> repeat(x.charAt(0) - 'A' + 1, \"1\")).collect(toList());\n\n            for (String r : genSequence(prep, len - sumChars + 1)) {\n                char[] bits = r.substring(1).toCharArray();\n                BitSet bitset = new BitSet(bits.length);\n                for (int i = 0; i < bits.length; i++)\n                    bitset.set(i, bits[i] == '1');\n                lst.add(bitset);\n            }\n            result.add(lst);\n        }\n        return result;\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n\n    \n\n    static int reduceMutual(List<List<BitSet>> cols, List<List<BitSet>> rows) {\n        int countRemoved1 = reduce(cols, rows);\n        if (countRemoved1 == -1)\n            return -1;\n\n        int countRemoved2 = reduce(rows, cols);\n        if (countRemoved2 == -1)\n            return -1;\n\n        return countRemoved1 + countRemoved2;\n    }\n\n    static int reduce(List<List<BitSet>> a, List<List<BitSet>> b) {\n        int countRemoved = 0;\n\n        for (int i = 0; i < a.size(); i++) {\n\n            BitSet commonOn = new BitSet();\n            commonOn.set(0, b.size());\n            BitSet commonOff = new BitSet();\n\n            \n            for (BitSet candidate : a.get(i)) {\n                commonOn.and(candidate);\n                commonOff.or(candidate);\n            }\n\n            \n            for (int j = 0; j < b.size(); j++) {\n                final int fi = i, fj = j;\n\n                if (b.get(j).removeIf(cnd -> (commonOn.get(fj) && !cnd.get(fi))\n                        || (!commonOff.get(fj) && cnd.get(fi))))\n                    countRemoved++;\n\n                if (b.get(j).isEmpty())\n                    return -1;\n            }\n        }\n        return countRemoved;\n    }\n}\n"}
{"id": 415649, "name": "Lychrel numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse English;\nuse Const::Fast;\nuse Math::AnyNum qw(:overload);\n\nconst my $n_max       => 10_000;\nconst my $iter_cutoff => 500;\nmy(@seq_dump, @seed_lychrels, @related_lychrels);\n\nfor (my $n=1; $n<=$n_max; $n++) {\n    my @seq = lychrel_sequence($n);\n    if ($iter_cutoff == scalar @seq) {\n        if (has_overlap(\\@seq, \\@seq_dump)) { push @related_lychrels, $n }\n        else                                { push @seed_lychrels,    $n }\n        @seq_dump = set_union(\\@seq_dump, \\@seq);\n    }\n}\n\nprintf \"%45s %s\\n\", \"Number of seed Lychrels <= $n_max:\",        scalar @seed_lychrels;\nprintf \"%45s %s\\n\", \"Seed Lychrels <= $n_max:\",              join ', ', @seed_lychrels;\nprintf \"%45s %s\\n\", \"Number of related Lychrels <= $n_max:\",     scalar @related_lychrels;\nprintf \"%45s %s\\n\", \"Palindromes among seed and related <= $n_max:\",      \n                    join ', ', sort {$a <=> $b} grep { is_palindrome($ARG) } @seed_lychrels, @related_lychrels;\n\nsub lychrel_sequence {\n    my $n = shift;\n    my @seq;\n    for (1 .. $iter_cutoff) {\n        return if is_palindrome($n = next_n($n));\n        push @seq, $n;\n    }\n    @seq;\n}\n\nsub next_n        { my $n = shift; $n  + reverse($n) }\nsub is_palindrome { my $n = shift; $n eq reverse($n) }\n\nsub has_overlap {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a};\n    exists $h{$_} and return 1 for @{$b};\n    0;\n}\n\nsub set_union {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a}, @{$b};\n    keys %h;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 415650, "name": "Lychrel numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse English;\nuse Const::Fast;\nuse Math::AnyNum qw(:overload);\n\nconst my $n_max       => 10_000;\nconst my $iter_cutoff => 500;\nmy(@seq_dump, @seed_lychrels, @related_lychrels);\n\nfor (my $n=1; $n<=$n_max; $n++) {\n    my @seq = lychrel_sequence($n);\n    if ($iter_cutoff == scalar @seq) {\n        if (has_overlap(\\@seq, \\@seq_dump)) { push @related_lychrels, $n }\n        else                                { push @seed_lychrels,    $n }\n        @seq_dump = set_union(\\@seq_dump, \\@seq);\n    }\n}\n\nprintf \"%45s %s\\n\", \"Number of seed Lychrels <= $n_max:\",        scalar @seed_lychrels;\nprintf \"%45s %s\\n\", \"Seed Lychrels <= $n_max:\",              join ', ', @seed_lychrels;\nprintf \"%45s %s\\n\", \"Number of related Lychrels <= $n_max:\",     scalar @related_lychrels;\nprintf \"%45s %s\\n\", \"Palindromes among seed and related <= $n_max:\",      \n                    join ', ', sort {$a <=> $b} grep { is_palindrome($ARG) } @seed_lychrels, @related_lychrels;\n\nsub lychrel_sequence {\n    my $n = shift;\n    my @seq;\n    for (1 .. $iter_cutoff) {\n        return if is_palindrome($n = next_n($n));\n        push @seq, $n;\n    }\n    @seq;\n}\n\nsub next_n        { my $n = shift; $n  + reverse($n) }\nsub is_palindrome { my $n = shift; $n eq reverse($n) }\n\nsub has_overlap {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a};\n    exists $h{$_} and return 1 for @{$b};\n    0;\n}\n\nsub set_union {\n    my ($a, $b) = @ARG;\n    my %h;\n    $h{$_}++ for @{$a}, @{$b};\n    keys %h;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 415651, "name": "Check Machin-like formulas", "source": "Translate Perl to Java: use Math::BigRat try=>\"GMP\";\n\nsub taneval {\n  my($coef,$f) = @_;\n  $f = Math::BigRat->new($f) unless ref($f);\n  return 0 if $coef == 0;\n  return $f if $coef == 1;\n  return -taneval(-$coef, $f) if $coef < 0;\n  my($a,$b) = ( taneval($coef>>1, $f), taneval($coef-($coef>>1),$f) );\n  ($a+$b)/(1-$a*$b);\n}\n\nsub tans {\n  my @xs=@_;\n  return taneval(@{$xs[0]}) if scalar(@xs)==1;\n  my($a,$b) = ( tans(@xs[0..($\n  ($a+$b)/(1-$a*$b);\n}\n\nsub test {\n  printf \"%5s (%s)\\n\", (tans(@_)==1)?\"OK\":\"Error\", join(\" \",map{\"[@$_]\"} @_);\n}\n\ntest([1,'1/2'], [1,'1/3']);\ntest([2,'1/3'], [1,'1/7']);\ntest([4,'1/5'], [-1,'1/239']);\ntest([5,'1/7'],[2,'3/79']);\ntest([5,'29/278'],[7,'3/79']);\ntest([1,'1/2'],[1,'1/5'],[1,'1/8']);\ntest([4,'1/5'],[-1,'1/70'],[1,'1/99']);\ntest([5,'1/7'],[4,'1/53'],[2,'1/4443']);\ntest([6,'1/8'],[2,'1/57'],[1,'1/239']);\ntest([8,'1/10'],[-1,'1/239'],[-4,'1/515']);\ntest([12,'1/18'],[8,'1/57'],[-5,'1/239']);\ntest([16,'1/21'],[3,'1/239'],[4,'3/1042']);\ntest([22,'1/28'],[2,'1/443'],[-5,'1/1393'],[-10,'1/11018']);\ntest([22,'1/38'],[17,'7/601'],[10,'7/8149']);\ntest([44,'1/57'],[7,'1/239'],[-12,'1/682'],[24,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12944']);\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CheckMachinFormula {\n    \n    private static String FILE_NAME = \"MachinFormula.txt\";\n    \n    public static void main(String[] args) {\n        try {\n            runPrivate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runPrivate() throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(FILE_NAME)));) {        \n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"=\");\n                System.out.println(tanLeft(split[0].trim()) + \" = \" + split[1].trim().replaceAll(\"\\\\s+\", \" \") + \" = \" + tanRight(split[1].trim()));\n            }\n        }\n    }\n    \n    private static String tanLeft(String formula) {\n        if ( formula.compareTo(\"pi/4\") == 0 ) {\n            return \"1\";\n        }\n        throw new RuntimeException(\"ERROR 104:  Unknown left side: \" + formula);\n    }\n    \n    private static final Pattern ARCTAN_PATTERN = Pattern.compile(\"(-{0,1}\\\\d+)\\\\*arctan\\\\((\\\\d+)/(\\\\d+)\\\\)\");\n    \n    private static Fraction tanRight(String formula) {\n        Matcher matcher = ARCTAN_PATTERN.matcher(formula);\n        List<Term> terms = new ArrayList<>();\n        while ( matcher.find() ) {\n            terms.add(new Term(Integer.parseInt(matcher.group(1)), new Fraction(matcher.group(2), matcher.group(3))));\n        }\n        return evaluateArctan(terms);\n    }\n    \n    private static Fraction evaluateArctan(List<Term> terms) {\n        if ( terms.size() == 1 ) {\n            Term term = terms.get(0);\n            return evaluateArctan(term.coefficient, term.fraction);\n        }\n        int size = terms.size();\n        List<Term> left = terms.subList(0, (size+1) / 2);\n        List<Term> right = terms.subList((size+1) / 2, size);\n        return arctanFormula(evaluateArctan(left), evaluateArctan(right));\n    }\n    \n    private static Fraction evaluateArctan(int coefficient, Fraction fraction) {\n        \n        if ( coefficient == 1 ) {\n            return fraction;\n        }\n        else if ( coefficient < 0 ) {\n            return evaluateArctan(-coefficient, fraction).negate();\n        }\n        if ( coefficient % 2 == 0 ) {\n            Fraction f = evaluateArctan(coefficient/2, fraction);\n            return arctanFormula(f, f);\n        }\n        Fraction a = evaluateArctan(coefficient/2, fraction);\n        Fraction b = evaluateArctan(coefficient - (coefficient/2), fraction);\n        return arctanFormula(a, b);\n    }\n    \n    private static Fraction arctanFormula(Fraction f1, Fraction f2) {\n        return f1.add(f2).divide(Fraction.ONE.subtract(f1.multiply(f2)));\n    }\n    \n    private static class Fraction {\n        \n        public static final Fraction ONE = new Fraction(\"1\", \"1\");\n        \n        private BigInteger numerator;\n        private BigInteger denominator;\n        \n        public Fraction(String num, String den) {\n            numerator = new BigInteger(num);\n            denominator = new BigInteger(den);\n        }\n\n        public Fraction(BigInteger num, BigInteger den) {\n            numerator = num;\n            denominator = den;\n        }\n\n        public Fraction negate() {\n            return new Fraction(numerator.negate(), denominator);\n        }\n        \n        public Fraction add(Fraction f) {\n            BigInteger gcd = denominator.gcd(f.denominator);\n            BigInteger first = numerator.multiply(f.denominator.divide(gcd));\n            BigInteger second = f.numerator.multiply(denominator.divide(gcd));\n            return new Fraction(first.add(second), denominator.multiply(f.denominator).divide(gcd));\n        }\n        \n        public Fraction subtract(Fraction f) {\n            return add(f.negate());\n        }\n        \n        public Fraction multiply(Fraction f) {\n            BigInteger num = numerator.multiply(f.numerator);\n            BigInteger den = denominator.multiply(f.denominator);\n            BigInteger gcd = num.gcd(den);\n            return new Fraction(num.divide(gcd), den.divide(gcd));\n        }\n\n        public Fraction divide(Fraction f) {\n            return multiply(new Fraction(f.denominator, f.numerator));\n        }\n        \n        @Override\n        public String toString() {\n            if ( denominator.compareTo(BigInteger.ONE) == 0 ) {\n                return numerator.toString();\n            }\n            return numerator + \" / \" + denominator;\n        }\n    }\n    \n    private static class Term {\n        \n        private int coefficient;\n        private Fraction fraction;\n        \n        public Term(int c, Fraction f) {\n            coefficient = c;\n            fraction = f;\n        }\n    }\n    \n}\n"}
{"id": 415652, "name": "Check Machin-like formulas", "source": "Translate Perl to Java: use Math::BigRat try=>\"GMP\";\n\nsub taneval {\n  my($coef,$f) = @_;\n  $f = Math::BigRat->new($f) unless ref($f);\n  return 0 if $coef == 0;\n  return $f if $coef == 1;\n  return -taneval(-$coef, $f) if $coef < 0;\n  my($a,$b) = ( taneval($coef>>1, $f), taneval($coef-($coef>>1),$f) );\n  ($a+$b)/(1-$a*$b);\n}\n\nsub tans {\n  my @xs=@_;\n  return taneval(@{$xs[0]}) if scalar(@xs)==1;\n  my($a,$b) = ( tans(@xs[0..($\n  ($a+$b)/(1-$a*$b);\n}\n\nsub test {\n  printf \"%5s (%s)\\n\", (tans(@_)==1)?\"OK\":\"Error\", join(\" \",map{\"[@$_]\"} @_);\n}\n\ntest([1,'1/2'], [1,'1/3']);\ntest([2,'1/3'], [1,'1/7']);\ntest([4,'1/5'], [-1,'1/239']);\ntest([5,'1/7'],[2,'3/79']);\ntest([5,'29/278'],[7,'3/79']);\ntest([1,'1/2'],[1,'1/5'],[1,'1/8']);\ntest([4,'1/5'],[-1,'1/70'],[1,'1/99']);\ntest([5,'1/7'],[4,'1/53'],[2,'1/4443']);\ntest([6,'1/8'],[2,'1/57'],[1,'1/239']);\ntest([8,'1/10'],[-1,'1/239'],[-4,'1/515']);\ntest([12,'1/18'],[8,'1/57'],[-5,'1/239']);\ntest([16,'1/21'],[3,'1/239'],[4,'3/1042']);\ntest([22,'1/28'],[2,'1/443'],[-5,'1/1393'],[-10,'1/11018']);\ntest([22,'1/38'],[17,'7/601'],[10,'7/8149']);\ntest([44,'1/57'],[7,'1/239'],[-12,'1/682'],[24,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12943']);\ntest([88,'1/172'],[51,'1/239'],[32,'1/682'],[44,'1/5357'],[68,'1/12944']);\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CheckMachinFormula {\n    \n    private static String FILE_NAME = \"MachinFormula.txt\";\n    \n    public static void main(String[] args) {\n        try {\n            runPrivate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runPrivate() throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(FILE_NAME)));) {        \n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"=\");\n                System.out.println(tanLeft(split[0].trim()) + \" = \" + split[1].trim().replaceAll(\"\\\\s+\", \" \") + \" = \" + tanRight(split[1].trim()));\n            }\n        }\n    }\n    \n    private static String tanLeft(String formula) {\n        if ( formula.compareTo(\"pi/4\") == 0 ) {\n            return \"1\";\n        }\n        throw new RuntimeException(\"ERROR 104:  Unknown left side: \" + formula);\n    }\n    \n    private static final Pattern ARCTAN_PATTERN = Pattern.compile(\"(-{0,1}\\\\d+)\\\\*arctan\\\\((\\\\d+)/(\\\\d+)\\\\)\");\n    \n    private static Fraction tanRight(String formula) {\n        Matcher matcher = ARCTAN_PATTERN.matcher(formula);\n        List<Term> terms = new ArrayList<>();\n        while ( matcher.find() ) {\n            terms.add(new Term(Integer.parseInt(matcher.group(1)), new Fraction(matcher.group(2), matcher.group(3))));\n        }\n        return evaluateArctan(terms);\n    }\n    \n    private static Fraction evaluateArctan(List<Term> terms) {\n        if ( terms.size() == 1 ) {\n            Term term = terms.get(0);\n            return evaluateArctan(term.coefficient, term.fraction);\n        }\n        int size = terms.size();\n        List<Term> left = terms.subList(0, (size+1) / 2);\n        List<Term> right = terms.subList((size+1) / 2, size);\n        return arctanFormula(evaluateArctan(left), evaluateArctan(right));\n    }\n    \n    private static Fraction evaluateArctan(int coefficient, Fraction fraction) {\n        \n        if ( coefficient == 1 ) {\n            return fraction;\n        }\n        else if ( coefficient < 0 ) {\n            return evaluateArctan(-coefficient, fraction).negate();\n        }\n        if ( coefficient % 2 == 0 ) {\n            Fraction f = evaluateArctan(coefficient/2, fraction);\n            return arctanFormula(f, f);\n        }\n        Fraction a = evaluateArctan(coefficient/2, fraction);\n        Fraction b = evaluateArctan(coefficient - (coefficient/2), fraction);\n        return arctanFormula(a, b);\n    }\n    \n    private static Fraction arctanFormula(Fraction f1, Fraction f2) {\n        return f1.add(f2).divide(Fraction.ONE.subtract(f1.multiply(f2)));\n    }\n    \n    private static class Fraction {\n        \n        public static final Fraction ONE = new Fraction(\"1\", \"1\");\n        \n        private BigInteger numerator;\n        private BigInteger denominator;\n        \n        public Fraction(String num, String den) {\n            numerator = new BigInteger(num);\n            denominator = new BigInteger(den);\n        }\n\n        public Fraction(BigInteger num, BigInteger den) {\n            numerator = num;\n            denominator = den;\n        }\n\n        public Fraction negate() {\n            return new Fraction(numerator.negate(), denominator);\n        }\n        \n        public Fraction add(Fraction f) {\n            BigInteger gcd = denominator.gcd(f.denominator);\n            BigInteger first = numerator.multiply(f.denominator.divide(gcd));\n            BigInteger second = f.numerator.multiply(denominator.divide(gcd));\n            return new Fraction(first.add(second), denominator.multiply(f.denominator).divide(gcd));\n        }\n        \n        public Fraction subtract(Fraction f) {\n            return add(f.negate());\n        }\n        \n        public Fraction multiply(Fraction f) {\n            BigInteger num = numerator.multiply(f.numerator);\n            BigInteger den = denominator.multiply(f.denominator);\n            BigInteger gcd = num.gcd(den);\n            return new Fraction(num.divide(gcd), den.divide(gcd));\n        }\n\n        public Fraction divide(Fraction f) {\n            return multiply(new Fraction(f.denominator, f.numerator));\n        }\n        \n        @Override\n        public String toString() {\n            if ( denominator.compareTo(BigInteger.ONE) == 0 ) {\n                return numerator.toString();\n            }\n            return numerator + \" / \" + denominator;\n        }\n    }\n    \n    private static class Term {\n        \n        private int coefficient;\n        private Fraction fraction;\n        \n        public Term(int c, Fraction f) {\n            coefficient = c;\n            fraction = f;\n        }\n    }\n    \n}\n"}
{"id": 415653, "name": "The ISAAC cipher", "source": "Translate Perl to Java: use warnings;\nuse strict;\nuse Math::Random::ISAAC;\n\nmy $message = \"a Top Secret secret\";\nmy $key = \"this is my secret key\";\n\nmy $enc = xor_isaac($key, $message);\nmy $dec = xor_isaac($key, join \"\", pack \"H*\", $enc);\n\nprint \"Message: $message\\n\";\nprint \"Key   \u00a0: $key\\n\";\nprint \"XOR   \u00a0: $enc\\n\";\nprint \"XOR dcr: \", join(\"\", pack \"H*\", $dec), \"\\n\";\n\nsub xor_isaac {\n  my($key, $msg) = @_;\n\n  \n  my $rng = Math::Random::ISAAC->new( map { ord } split \"\",$key );\n\n  \n  my @iranda = map { $_ % 95 + 32 }  \n               reverse               \n               map { $rng->irand }   \n               0..255;               \n  \n  join \"\", map { sprintf \"%02X\",$_ }         \n           map { ord($_) ^ shift(@iranda) }  \n           split \"\", $msg;                   \n}\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Random;\n\n\npublic class IsaacRandom extends Random {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate final int[] randResult = new int[256];    \n\tprivate int valuesUsed;                           \n\t\n\t\n\tprivate final int[] mm = new int[256];\n\tprivate int aa, bb, cc;\n\t\n\tpublic IsaacRandom() {\n\t\tsuper(0);\n\t\tinit(null);\n\t}\n\t\n\tpublic IsaacRandom(int[] seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tpublic IsaacRandom(String seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tprivate void generateMoreResults() {\n\t\tcc++;\n\t\tbb += cc;\n\t\t\n\t\tfor (int i=0; i<256; i++) {\n\t\t\tint x = mm[i];\n\t\t\tswitch (i&3) {\n\t\t\tcase 0:\n\t\t\t\taa = aa^(aa<<13);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taa = aa^(aa>>>6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taa = aa^(aa<<2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\taa = aa^(aa>>>16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taa = mm[i^128] + aa;\n\t\t\tint y = mm[i] = mm[(x>>>2) & 0xFF] + aa + bb;\n\t\t\trandResult[i] = bb = mm[(y>>>10) & 0xFF] + x;\n\t\t}\n\t\t\n\t\tvaluesUsed = 0;\n\t}\n\t\n\tprivate static void mix(int[] s) {\n\t\t   s[0]^=s[1]<<11;  s[3]+=s[0]; s[1]+=s[2];\n\t\t   s[1]^=s[2]>>>2;  s[4]+=s[1]; s[2]+=s[3];\n\t\t   s[2]^=s[3]<<8;   s[5]+=s[2]; s[3]+=s[4];\n\t\t   s[3]^=s[4]>>>16; s[6]+=s[3]; s[4]+=s[5];\n\t\t   s[4]^=s[5]<<10;  s[7]+=s[4]; s[5]+=s[6];\n\t\t   s[5]^=s[6]>>>4;  s[0]+=s[5]; s[6]+=s[7];\n\t\t   s[6]^=s[7]<<8;   s[1]+=s[6]; s[7]+=s[0];\n\t\t   s[7]^=s[0]>>>9;  s[2]+=s[7]; s[0]+=s[1];\n\t}\n\t\n\tprivate void init(int[] seed) {\n\t\tif (seed != null && seed.length != 256) {\n\t\t\tseed = Arrays.copyOf(seed, 256);\n\t\t}\n\t\taa = bb = cc = 0;\n\t\tint[] initState = new int[8];\n\t\tArrays.fill(initState, 0x9e3779b9);\t\n\t\t\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tmix(initState);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<256; i+=8) {\n\t\t\tif (seed != null) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += seed[i+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmix(initState);\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tmm[i+j] = initState[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (seed != null) {\n\t\t\tfor (int i=0; i<256; i+=8) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += mm[i+j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmix(initState);\n\t\t\t\t\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tmm[i+j] = initState[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvaluesUsed = 256;\t\n\t}\n\t\n\t@Override\n\tprotected int next(int bits) {\n\t\tif (valuesUsed == 256) {\n\t\t\tgenerateMoreResults();\n\t\t\tassert(valuesUsed == 0);\n\t\t}\n\t\tint value = randResult[valuesUsed];\n\t\tvaluesUsed++;\n\t\treturn value >>> (32-bits);\n\t}\n\t\n\t@Override\n\tpublic synchronized void setSeed(long seed) {\n\t\tsuper.setSeed(0);\n\t\tif (mm == null) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tint[] arraySeed = new int[256];\n\t\tarraySeed[0] = (int) (seed & 0xFFFFFFFF);\n\t\tarraySeed[1] = (int) (seed >>> 32);\n\t\tinit(arraySeed);\n\t}\n\t\n\tpublic synchronized void setSeed(int[] seed) {\n\t\tsuper.setSeed(0);\n\t\tinit(seed);\n\t}\n\t\n\tpublic synchronized void setSeed(String seed) {\n\t\tsuper.setSeed(0);\n\t\tchar[] charSeed = seed.toCharArray();\n\t\tint[] intSeed = new int[charSeed.length];\n\t\tfor (int i=0; i<charSeed.length; i++) {\n\t\t\tintSeed[i] = charSeed[i];\n\t\t}\n\t\tinit(intSeed);\n\t}\n\t\n\tpublic int randomChar() {\n\t\tlong unsignedNext = nextInt() & 0xFFFFFFFFL;\t\n\t\treturn (int) (unsignedNext % 95 + 32);\t\t    \n\t}\n\t\n\tpublic enum CipherMode { ENCIPHER, DECIPHER, NONE };\n\t\n\tpublic byte[] vernamCipher(byte[] input) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = (byte) (randomChar() ^ input[i]);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static byte caesarShift(CipherMode mode, byte ch, int shift, byte modulo, byte start) {\n\t\tif (mode == CipherMode.DECIPHER) {\n\t\t\tshift = -shift;\n\t\t}\n\t\tint n = (ch-start) + shift;\n\t\tn %= modulo;\n\t\tif (n<0) {\n\t\t\tn += modulo;\n\t\t}\n\t\treturn (byte) (start + n);\n\t}\n\t\n\tpublic byte[] caesarCipher(CipherMode mode, byte[] input, byte modulo, byte start) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = caesarShift(mode, input[i], randomChar(), modulo, start);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static String toHexString(byte[] input) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder(input.length*2);\n\t\tfor (byte b : input) {\n\t\t\tsb.append(String.format(\"%02X\", b));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal byte MOD = 95;\n\t\tfinal byte START = 32;\n\t\t\n\t\tString secret = \"a Top Secret secret\";\n\t\tString key = \"this is my secret key\";\n\t\t\n\t\tIsaacRandom random = new IsaacRandom(key);\n\t\tbyte[] vernamResult;\n\t\tbyte[] caesarResult;\n\t\tString vernamDecrypted;\n\t\tString caesarDecrypted;\n\t\ttry {\n\t\t\tvernamResult = random.vernamCipher(secret.getBytes(\"ASCII\"));\n\t\t\tcaesarResult = random.caesarCipher(CipherMode.ENCIPHER, secret.getBytes(\"ASCII\"), MOD, START);\n\t\t\trandom.setSeed(key);\n\t\t\tvernamDecrypted = new String(random.vernamCipher(vernamResult), \"ASCII\");\n\t\t\tcaesarDecrypted = new String(random.caesarCipher(CipherMode.DECIPHER, caesarResult, MOD, START), \"ASCII\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new InternalError(\"JVM isn't conforming - ASCII encoding isn't available\");\n\t\t}\n\t\tSystem.out.printf(\"Message: %s\\n\", secret);\n\t\tSystem.out.printf(\"Key   \u00a0: %s\\n\", key);\n\t\tSystem.out.printf(\"XOR   \u00a0: %s\\n\", toHexString(vernamResult));\n\t\tSystem.out.printf(\"XOR dcr: %s\\n\", vernamDecrypted);\n\t\tSystem.out.printf(\"MOD   \u00a0: %s\\n\", toHexString(caesarResult));\n\t\tSystem.out.printf(\"MOD dcr: %s\\n\", caesarDecrypted);\n\t}\n}\n"}
{"id": 415654, "name": "The ISAAC cipher", "source": "Translate Perl to Java: use warnings;\nuse strict;\nuse Math::Random::ISAAC;\n\nmy $message = \"a Top Secret secret\";\nmy $key = \"this is my secret key\";\n\nmy $enc = xor_isaac($key, $message);\nmy $dec = xor_isaac($key, join \"\", pack \"H*\", $enc);\n\nprint \"Message: $message\\n\";\nprint \"Key   \u00a0: $key\\n\";\nprint \"XOR   \u00a0: $enc\\n\";\nprint \"XOR dcr: \", join(\"\", pack \"H*\", $dec), \"\\n\";\n\nsub xor_isaac {\n  my($key, $msg) = @_;\n\n  \n  my $rng = Math::Random::ISAAC->new( map { ord } split \"\",$key );\n\n  \n  my @iranda = map { $_ % 95 + 32 }  \n               reverse               \n               map { $rng->irand }   \n               0..255;               \n  \n  join \"\", map { sprintf \"%02X\",$_ }         \n           map { ord($_) ^ shift(@iranda) }  \n           split \"\", $msg;                   \n}\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Random;\n\n\npublic class IsaacRandom extends Random {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate final int[] randResult = new int[256];    \n\tprivate int valuesUsed;                           \n\t\n\t\n\tprivate final int[] mm = new int[256];\n\tprivate int aa, bb, cc;\n\t\n\tpublic IsaacRandom() {\n\t\tsuper(0);\n\t\tinit(null);\n\t}\n\t\n\tpublic IsaacRandom(int[] seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tpublic IsaacRandom(String seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tprivate void generateMoreResults() {\n\t\tcc++;\n\t\tbb += cc;\n\t\t\n\t\tfor (int i=0; i<256; i++) {\n\t\t\tint x = mm[i];\n\t\t\tswitch (i&3) {\n\t\t\tcase 0:\n\t\t\t\taa = aa^(aa<<13);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taa = aa^(aa>>>6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taa = aa^(aa<<2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\taa = aa^(aa>>>16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taa = mm[i^128] + aa;\n\t\t\tint y = mm[i] = mm[(x>>>2) & 0xFF] + aa + bb;\n\t\t\trandResult[i] = bb = mm[(y>>>10) & 0xFF] + x;\n\t\t}\n\t\t\n\t\tvaluesUsed = 0;\n\t}\n\t\n\tprivate static void mix(int[] s) {\n\t\t   s[0]^=s[1]<<11;  s[3]+=s[0]; s[1]+=s[2];\n\t\t   s[1]^=s[2]>>>2;  s[4]+=s[1]; s[2]+=s[3];\n\t\t   s[2]^=s[3]<<8;   s[5]+=s[2]; s[3]+=s[4];\n\t\t   s[3]^=s[4]>>>16; s[6]+=s[3]; s[4]+=s[5];\n\t\t   s[4]^=s[5]<<10;  s[7]+=s[4]; s[5]+=s[6];\n\t\t   s[5]^=s[6]>>>4;  s[0]+=s[5]; s[6]+=s[7];\n\t\t   s[6]^=s[7]<<8;   s[1]+=s[6]; s[7]+=s[0];\n\t\t   s[7]^=s[0]>>>9;  s[2]+=s[7]; s[0]+=s[1];\n\t}\n\t\n\tprivate void init(int[] seed) {\n\t\tif (seed != null && seed.length != 256) {\n\t\t\tseed = Arrays.copyOf(seed, 256);\n\t\t}\n\t\taa = bb = cc = 0;\n\t\tint[] initState = new int[8];\n\t\tArrays.fill(initState, 0x9e3779b9);\t\n\t\t\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tmix(initState);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<256; i+=8) {\n\t\t\tif (seed != null) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += seed[i+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmix(initState);\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tmm[i+j] = initState[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (seed != null) {\n\t\t\tfor (int i=0; i<256; i+=8) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += mm[i+j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmix(initState);\n\t\t\t\t\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tmm[i+j] = initState[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvaluesUsed = 256;\t\n\t}\n\t\n\t@Override\n\tprotected int next(int bits) {\n\t\tif (valuesUsed == 256) {\n\t\t\tgenerateMoreResults();\n\t\t\tassert(valuesUsed == 0);\n\t\t}\n\t\tint value = randResult[valuesUsed];\n\t\tvaluesUsed++;\n\t\treturn value >>> (32-bits);\n\t}\n\t\n\t@Override\n\tpublic synchronized void setSeed(long seed) {\n\t\tsuper.setSeed(0);\n\t\tif (mm == null) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tint[] arraySeed = new int[256];\n\t\tarraySeed[0] = (int) (seed & 0xFFFFFFFF);\n\t\tarraySeed[1] = (int) (seed >>> 32);\n\t\tinit(arraySeed);\n\t}\n\t\n\tpublic synchronized void setSeed(int[] seed) {\n\t\tsuper.setSeed(0);\n\t\tinit(seed);\n\t}\n\t\n\tpublic synchronized void setSeed(String seed) {\n\t\tsuper.setSeed(0);\n\t\tchar[] charSeed = seed.toCharArray();\n\t\tint[] intSeed = new int[charSeed.length];\n\t\tfor (int i=0; i<charSeed.length; i++) {\n\t\t\tintSeed[i] = charSeed[i];\n\t\t}\n\t\tinit(intSeed);\n\t}\n\t\n\tpublic int randomChar() {\n\t\tlong unsignedNext = nextInt() & 0xFFFFFFFFL;\t\n\t\treturn (int) (unsignedNext % 95 + 32);\t\t    \n\t}\n\t\n\tpublic enum CipherMode { ENCIPHER, DECIPHER, NONE };\n\t\n\tpublic byte[] vernamCipher(byte[] input) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = (byte) (randomChar() ^ input[i]);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static byte caesarShift(CipherMode mode, byte ch, int shift, byte modulo, byte start) {\n\t\tif (mode == CipherMode.DECIPHER) {\n\t\t\tshift = -shift;\n\t\t}\n\t\tint n = (ch-start) + shift;\n\t\tn %= modulo;\n\t\tif (n<0) {\n\t\t\tn += modulo;\n\t\t}\n\t\treturn (byte) (start + n);\n\t}\n\t\n\tpublic byte[] caesarCipher(CipherMode mode, byte[] input, byte modulo, byte start) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = caesarShift(mode, input[i], randomChar(), modulo, start);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static String toHexString(byte[] input) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder(input.length*2);\n\t\tfor (byte b : input) {\n\t\t\tsb.append(String.format(\"%02X\", b));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal byte MOD = 95;\n\t\tfinal byte START = 32;\n\t\t\n\t\tString secret = \"a Top Secret secret\";\n\t\tString key = \"this is my secret key\";\n\t\t\n\t\tIsaacRandom random = new IsaacRandom(key);\n\t\tbyte[] vernamResult;\n\t\tbyte[] caesarResult;\n\t\tString vernamDecrypted;\n\t\tString caesarDecrypted;\n\t\ttry {\n\t\t\tvernamResult = random.vernamCipher(secret.getBytes(\"ASCII\"));\n\t\t\tcaesarResult = random.caesarCipher(CipherMode.ENCIPHER, secret.getBytes(\"ASCII\"), MOD, START);\n\t\t\trandom.setSeed(key);\n\t\t\tvernamDecrypted = new String(random.vernamCipher(vernamResult), \"ASCII\");\n\t\t\tcaesarDecrypted = new String(random.caesarCipher(CipherMode.DECIPHER, caesarResult, MOD, START), \"ASCII\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new InternalError(\"JVM isn't conforming - ASCII encoding isn't available\");\n\t\t}\n\t\tSystem.out.printf(\"Message: %s\\n\", secret);\n\t\tSystem.out.printf(\"Key   \u00a0: %s\\n\", key);\n\t\tSystem.out.printf(\"XOR   \u00a0: %s\\n\", toHexString(vernamResult));\n\t\tSystem.out.printf(\"XOR dcr: %s\\n\", vernamDecrypted);\n\t\tSystem.out.printf(\"MOD   \u00a0: %s\\n\", toHexString(caesarResult));\n\t\tSystem.out.printf(\"MOD dcr: %s\\n\", caesarDecrypted);\n\t}\n}\n"}
{"id": 415655, "name": "Permutations_Rank of a permutation", "source": "Translate Perl to Java: use ntheory qw/:all/;\n\nmy $n = 3;\nprint \"    Iterate Lexicographic rank/unrank of $n objects\\n\";\nfor my $k (0 .. factorial($n)-1) {\n  my @perm = numtoperm($n, $k);\n  my $rank = permtonum(\\@perm);\n  die unless $rank == $k;\n  printf \"%2d --> [@perm] --> %2d\\n\", $k, $rank;\n}\nprint \"\\n\";\n\nprint \"    Four 12-object random permutations using ranks\\n\";\nprint join(\" \", numtoperm(12,urandomm(factorial(12)))), \"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 12-object random permutations using randperm\\n\";\nprint join(\" \", randperm(12)),\"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 4-object random permutations of 100k objects using randperm\\n\";\nprint join(\" \", randperm(100000,4)),\"\\n\"  for 1..4;\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass RankPermutation\n{\n  public static BigInteger getRank(int[] permutation)\n  {\n    int n = permutation.length;\n    BitSet usedDigits = new BitSet();\n    BigInteger rank = BigInteger.ZERO;\n    for (int i = 0; i < n; i++)\n    {\n      rank = rank.multiply(BigInteger.valueOf(n - i));\n      int digit = 0;\n      int v = -1;\n      while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])\n        digit++;\n      usedDigits.set(v);\n      rank = rank.add(BigInteger.valueOf(digit));\n    }\n    return rank;\n  }\n  \n  public static int[] getPermutation(int n, BigInteger rank)\n  {\n    int[] digits = new int[n];\n    for (int digit = 2; digit <= n; digit++)\n    {\n      BigInteger divisor = BigInteger.valueOf(digit);\n      digits[n - digit] = rank.mod(divisor).intValue();\n      if (digit < n)\n        rank = rank.divide(divisor);\n    }\n    BitSet usedDigits = new BitSet();\n    int[] permutation = new int[n];\n    for (int i = 0; i < n; i++)\n    {\n      int v = usedDigits.nextClearBit(0);\n      for (int j = 0; j < digits[i]; j++)\n        v = usedDigits.nextClearBit(v + 1);\n      permutation[i] = v;\n      usedDigits.set(v);\n    }\n    return permutation;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i < 6; i++)\n    {\n      int[] permutation = getPermutation(3, BigInteger.valueOf(i));\n      System.out.println(String.valueOf(i) + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n    }\n    Random rnd = new Random();\n    for (int n : new int[] { 12, 144 })\n    {\n      BigInteger factorial = BigInteger.ONE;\n      for (int i = 2; i <= n; i++)\n        factorial = factorial.multiply(BigInteger.valueOf(i));\n      \n      System.out.println(\"n = \" + n);\n      for (int i = 0; i < 5; i++)\n      {\n        BigInteger rank = new BigInteger((factorial.bitLength() + 1) << 1, rnd);\n        rank = rank.mod(factorial);\n        int[] permutation = getPermutation(n, rank);\n        System.out.println(\"  \" + rank + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n      }\n    }\n  }\n  \n}\n"}
{"id": 415656, "name": "Permutations_Rank of a permutation", "source": "Translate Perl to Java: use ntheory qw/:all/;\n\nmy $n = 3;\nprint \"    Iterate Lexicographic rank/unrank of $n objects\\n\";\nfor my $k (0 .. factorial($n)-1) {\n  my @perm = numtoperm($n, $k);\n  my $rank = permtonum(\\@perm);\n  die unless $rank == $k;\n  printf \"%2d --> [@perm] --> %2d\\n\", $k, $rank;\n}\nprint \"\\n\";\n\nprint \"    Four 12-object random permutations using ranks\\n\";\nprint join(\" \", numtoperm(12,urandomm(factorial(12)))), \"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 12-object random permutations using randperm\\n\";\nprint join(\" \", randperm(12)),\"\\n\"  for 1..4;\nprint \"\\n\";\nprint \"    Four 4-object random permutations of 100k objects using randperm\\n\";\nprint join(\" \", randperm(100000,4)),\"\\n\"  for 1..4;\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass RankPermutation\n{\n  public static BigInteger getRank(int[] permutation)\n  {\n    int n = permutation.length;\n    BitSet usedDigits = new BitSet();\n    BigInteger rank = BigInteger.ZERO;\n    for (int i = 0; i < n; i++)\n    {\n      rank = rank.multiply(BigInteger.valueOf(n - i));\n      int digit = 0;\n      int v = -1;\n      while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])\n        digit++;\n      usedDigits.set(v);\n      rank = rank.add(BigInteger.valueOf(digit));\n    }\n    return rank;\n  }\n  \n  public static int[] getPermutation(int n, BigInteger rank)\n  {\n    int[] digits = new int[n];\n    for (int digit = 2; digit <= n; digit++)\n    {\n      BigInteger divisor = BigInteger.valueOf(digit);\n      digits[n - digit] = rank.mod(divisor).intValue();\n      if (digit < n)\n        rank = rank.divide(divisor);\n    }\n    BitSet usedDigits = new BitSet();\n    int[] permutation = new int[n];\n    for (int i = 0; i < n; i++)\n    {\n      int v = usedDigits.nextClearBit(0);\n      for (int j = 0; j < digits[i]; j++)\n        v = usedDigits.nextClearBit(v + 1);\n      permutation[i] = v;\n      usedDigits.set(v);\n    }\n    return permutation;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i < 6; i++)\n    {\n      int[] permutation = getPermutation(3, BigInteger.valueOf(i));\n      System.out.println(String.valueOf(i) + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n    }\n    Random rnd = new Random();\n    for (int n : new int[] { 12, 144 })\n    {\n      BigInteger factorial = BigInteger.ONE;\n      for (int i = 2; i <= n; i++)\n        factorial = factorial.multiply(BigInteger.valueOf(i));\n      \n      System.out.println(\"n = \" + n);\n      for (int i = 0; i < 5; i++)\n      {\n        BigInteger rank = new BigInteger((factorial.bitLength() + 1) << 1, rnd);\n        rank = rank.mod(factorial);\n        int[] permutation = getPermutation(n, rank);\n        System.out.println(\"  \" + rank + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n      }\n    }\n  }\n  \n}\n"}
{"id": 415657, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse POSIX qw(fmod);\nuse Perl6::GatherTake;\n\nuse constant ln2ln10 => log(2) / log(10);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub ordinal_digit {\n    my($d) = $_[0] =~ /(.)$/;\n    $d eq '1' ? 'st' : $d eq '2' ? 'nd' : $d eq '3' ? 'rd' : 'th'\n}\n\nsub startswith12 {\n    my($nth) = @_;\n    state $i = 0;\n    state $n = 0;\n    while (1) {\n      next unless '1.2' eq substr(( 10 ** fmod(++$i * ln2ln10, 1) ), 0, 3);\n      return $i if ++$n eq $nth;\n    }\n}\n\nsub startswith123 {\n    my $pre = '1.23';\n    my ($this, $count) = (0, 0);\n\n    gather {\n      while (1) {\n        if ($this == 196) {\n            $this = 289;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 485) {\n            $this = 196;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 289) {\n            $this = 196\n        } elsif ($this ==  90) {\n            $this = 289\n        } elsif ($this ==   0) {\n            $this = 90;\n        }\n        take $count += $this;\n      }\n    }\n}\n\nmy $start_123 = startswith123(); \n\nsub p {\n    my($prefix,$nth) = @_;\n    $prefix eq '12' ? startswith12($nth) : $start_123->[$nth-1];\n}\n\nfor ([12, 1], [12, 2], [123, 45], [123, 12345], [123, 678910]) {\n    my($prefix,$nth) = @$_;\n    printf \"%-15s %9s power of two (2^n) that starts with %5s is at n = %s\\n\", \"p($prefix, $nth):\",\n        comma($nth) . ordinal_digit($nth), \"'$prefix'\", comma p($prefix, $nth);\n}\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 415658, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse POSIX qw(fmod);\nuse Perl6::GatherTake;\n\nuse constant ln2ln10 => log(2) / log(10);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub ordinal_digit {\n    my($d) = $_[0] =~ /(.)$/;\n    $d eq '1' ? 'st' : $d eq '2' ? 'nd' : $d eq '3' ? 'rd' : 'th'\n}\n\nsub startswith12 {\n    my($nth) = @_;\n    state $i = 0;\n    state $n = 0;\n    while (1) {\n      next unless '1.2' eq substr(( 10 ** fmod(++$i * ln2ln10, 1) ), 0, 3);\n      return $i if ++$n eq $nth;\n    }\n}\n\nsub startswith123 {\n    my $pre = '1.23';\n    my ($this, $count) = (0, 0);\n\n    gather {\n      while (1) {\n        if ($this == 196) {\n            $this = 289;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 485) {\n            $this = 196;\n            $this = 485 unless $pre eq substr(( 10 ** fmod(($count+$this) * ln2ln10, 1) ), 0, 4);\n        } elsif ($this == 289) {\n            $this = 196\n        } elsif ($this ==  90) {\n            $this = 289\n        } elsif ($this ==   0) {\n            $this = 90;\n        }\n        take $count += $this;\n      }\n    }\n}\n\nmy $start_123 = startswith123(); \n\nsub p {\n    my($prefix,$nth) = @_;\n    $prefix eq '12' ? startswith12($nth) : $start_123->[$nth-1];\n}\n\nfor ([12, 1], [12, 2], [123, 45], [123, 12345], [123, 678910]) {\n    my($prefix,$nth) = @$_;\n    printf \"%-15s %9s power of two (2^n) that starts with %5s is at n = %s\\n\", \"p($prefix, $nth):\",\n        comma($nth) . ordinal_digit($nth), \"'$prefix'\", comma p($prefix, $nth);\n}\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 415659, "name": "Stirling numbers of the second kind", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling2 {\n    my($n, $k) = @_;\n    my $n1 = $n - 1;\n    return 1 if     $n1 == $k;\n    return 0 unless $n1 && $k;\n    state %seen;\n    return ($seen{\"{$n1}|{$k}\"  } //= Stirling2($n1,$k  ) * $k) +\n           ($seen{\"{$n1}|{$k-1}\"} //= Stirling2($n1,$k-1))\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling2($upto+1,$_) } 0..$upto+1;\n\nsay 'Unsigned Stirling2 numbers of the second kind: S2(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (1..$upto+1) {\n    printf '%-3d', $row-1;\n    printf \"%${width}d\", Stirling2($row, $_) for 0..$row-1;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S2(100, *) row:\";\nsay max map { Stirling2(101,$_) } 0..100;\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersSecondKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Stirling numbers of the second kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling2(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S2(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling2(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling2(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( (n > 0 && k == 0) || (n == 0 && k > 0) ) {\n            return BigInteger.ZERO; \n        }\n        if ( n == k ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = BigInteger.valueOf(k).multiply(sterling2(n-1, k)).add(sterling2(n-1, k-1));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 415660, "name": "Stirling numbers of the second kind", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling2 {\n    my($n, $k) = @_;\n    my $n1 = $n - 1;\n    return 1 if     $n1 == $k;\n    return 0 unless $n1 && $k;\n    state %seen;\n    return ($seen{\"{$n1}|{$k}\"  } //= Stirling2($n1,$k  ) * $k) +\n           ($seen{\"{$n1}|{$k-1}\"} //= Stirling2($n1,$k-1))\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling2($upto+1,$_) } 0..$upto+1;\n\nsay 'Unsigned Stirling2 numbers of the second kind: S2(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (1..$upto+1) {\n    printf '%-3d', $row-1;\n    printf \"%${width}d\", Stirling2($row, $_) for 0..$row-1;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S2(100, *) row:\";\nsay max map { Stirling2(101,$_) } 0..100;\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersSecondKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Stirling numbers of the second kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling2(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S2(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling2(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling2(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( (n > 0 && k == 0) || (n == 0 && k > 0) ) {\n            return BigInteger.ZERO; \n        }\n        if ( n == k ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = BigInteger.valueOf(k).multiply(sterling2(n-1, k)).add(sterling2(n-1, k-1));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 415661, "name": "Cipolla's algorithm", "source": "Translate Perl to Java: use bigint;\nuse ntheory qw(is_prime);\n\nsub Legendre {\n    my($n,$p) = @_;\n    return -1 unless $p != 2 && is_prime($p);\n    my $x = ($n->as_int())->bmodpow(int(($p-1)/2), $p); \n    if    ($x==0) { return  0 }\n    elsif ($x==1) { return  1 }\n    else          { return -1 }\n}\n\nsub Cipolla {\n    my($n, $p) = @_;\n    return undef if Legendre($n,$p) != 1;\n\n    my $w2;\n    my $a = 0;\n    $a++ until Legendre(($w2 = ($a**2 - $n) % $p), $p) < 0;\n\n    my %r = ( x=> 1,  y=> 0 );\n    my %s = ( x=> $a, y=> 1 );\n    my $i = $p + 1;\n    while (1 <= ($i >>= 1)) {\n        %r = ( x => (($r{x} * $s{x} + $r{y} * $s{y} * $w2) % $p),\n               y => (($r{x} * $s{y} + $s{x} * $r{y})       % $p)\n             ) if $i % 2;\n        %s = ( x => (($s{x} * $s{x} + $s{y} * $s{y} * $w2) % $p),\n               y => (($s{x} * $s{y} + $s{x} * $s{y})       % $p)\n             )\n    }\n    $r{y} ? undef : $r{x}\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (8218, 10007),\n    (8219, 10007),\n    (331575, 1000003),\n    (665165880, 1000000007),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n   $n = shift @tests;\n   $p = shift @tests;\n   my $r = Cipolla($n, $p);\n   $r ? printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $r, $p-$r, $p\n      : print  \"No solution for ($n, $p)\\n\"\n}\n", "target": "import java.math.BigInteger;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class CipollasAlgorithm {\n    private static final BigInteger BIG = BigInteger.TEN.pow(50).add(BigInteger.valueOf(151));\n    private static final BigInteger BIG_TWO = BigInteger.valueOf(2);\n\n    private static class Point {\n        BigInteger x;\n        BigInteger y;\n\n        Point(BigInteger x, BigInteger y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s)\", this.x, this.y);\n        }\n    }\n\n    private static class Triple {\n        BigInteger x;\n        BigInteger y;\n        boolean b;\n\n        Triple(BigInteger x, BigInteger y, boolean b) {\n            this.x = x;\n            this.y = y;\n            this.b = b;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s, %s)\", this.x, this.y, this.b);\n        }\n    }\n\n    private static Triple c(String ns, String ps) {\n        BigInteger n = new BigInteger(ns);\n        BigInteger p = !ps.isEmpty() ? new BigInteger(ps) : BIG;\n\n        \n        Function<BigInteger, BigInteger> ls = (BigInteger a)\n            -> a.modPow(p.subtract(BigInteger.ONE).divide(BIG_TWO), p);\n\n        \n        if (!ls.apply(n).equals(BigInteger.ONE)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        BigInteger a = BigInteger.ZERO;\n        BigInteger omega2;\n        while (true) {\n            omega2 = a.multiply(a).add(p).subtract(n).mod(p);\n            if (ls.apply(omega2).equals(p.subtract(BigInteger.ONE))) {\n                break;\n            }\n            a = a.add(BigInteger.ONE);\n        }\n\n        \n        BigInteger finalOmega = omega2;\n        BiFunction<Point, Point, Point> mul = (Point aa, Point bb) -> new Point(\n            aa.x.multiply(bb.x).add(aa.y.multiply(bb.y).multiply(finalOmega)).mod(p),\n            aa.x.multiply(bb.y).add(bb.x.multiply(aa.y)).mod(p)\n        );\n\n        \n        Point r = new Point(BigInteger.ONE, BigInteger.ZERO);\n        Point s = new Point(a, BigInteger.ONE);\n        BigInteger nn = p.add(BigInteger.ONE).shiftRight(1).mod(p);\n        while (nn.compareTo(BigInteger.ZERO) > 0) {\n            if (nn.and(BigInteger.ONE).equals(BigInteger.ONE)) {\n                r = mul.apply(r, s);\n            }\n            s = mul.apply(s, s);\n            nn = nn.shiftRight(1);\n        }\n\n        \n        if (!r.y.equals(BigInteger.ZERO)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        if (!r.x.multiply(r.x).mod(p).equals(n)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        return new Triple(r.x, p.subtract(r.x), true);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(c(\"10\", \"13\"));\n        System.out.println(c(\"56\", \"101\"));\n        System.out.println(c(\"8218\", \"10007\"));\n        System.out.println(c(\"8219\", \"10007\"));\n        System.out.println(c(\"331575\", \"1000003\"));\n        System.out.println(c(\"665165880\", \"1000000007\"));\n        System.out.println(c(\"881398088036\", \"1000000000039\"));\n        System.out.println(c(\"34035243914635549601583369544560650254325084643201\", \"\"));\n    }\n}\n"}
{"id": 415662, "name": "Cipolla's algorithm", "source": "Translate Perl to Java: use bigint;\nuse ntheory qw(is_prime);\n\nsub Legendre {\n    my($n,$p) = @_;\n    return -1 unless $p != 2 && is_prime($p);\n    my $x = ($n->as_int())->bmodpow(int(($p-1)/2), $p); \n    if    ($x==0) { return  0 }\n    elsif ($x==1) { return  1 }\n    else          { return -1 }\n}\n\nsub Cipolla {\n    my($n, $p) = @_;\n    return undef if Legendre($n,$p) != 1;\n\n    my $w2;\n    my $a = 0;\n    $a++ until Legendre(($w2 = ($a**2 - $n) % $p), $p) < 0;\n\n    my %r = ( x=> 1,  y=> 0 );\n    my %s = ( x=> $a, y=> 1 );\n    my $i = $p + 1;\n    while (1 <= ($i >>= 1)) {\n        %r = ( x => (($r{x} * $s{x} + $r{y} * $s{y} * $w2) % $p),\n               y => (($r{x} * $s{y} + $s{x} * $r{y})       % $p)\n             ) if $i % 2;\n        %s = ( x => (($s{x} * $s{x} + $s{y} * $s{y} * $w2) % $p),\n               y => (($s{x} * $s{y} + $s{x} * $s{y})       % $p)\n             )\n    }\n    $r{y} ? undef : $r{x}\n}\n\nmy @tests = (\n    (10, 13),\n    (56, 101),\n    (8218, 10007),\n    (8219, 10007),\n    (331575, 1000003),\n    (665165880, 1000000007),\n    (881398088036, 1000000000039),\n);\n\nwhile (@tests) {\n   $n = shift @tests;\n   $p = shift @tests;\n   my $r = Cipolla($n, $p);\n   $r ? printf \"Roots of %d are (%d, %d) mod %d\\n\", $n, $r, $p-$r, $p\n      : print  \"No solution for ($n, $p)\\n\"\n}\n", "target": "import java.math.BigInteger;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class CipollasAlgorithm {\n    private static final BigInteger BIG = BigInteger.TEN.pow(50).add(BigInteger.valueOf(151));\n    private static final BigInteger BIG_TWO = BigInteger.valueOf(2);\n\n    private static class Point {\n        BigInteger x;\n        BigInteger y;\n\n        Point(BigInteger x, BigInteger y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s)\", this.x, this.y);\n        }\n    }\n\n    private static class Triple {\n        BigInteger x;\n        BigInteger y;\n        boolean b;\n\n        Triple(BigInteger x, BigInteger y, boolean b) {\n            this.x = x;\n            this.y = y;\n            this.b = b;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%s, %s, %s)\", this.x, this.y, this.b);\n        }\n    }\n\n    private static Triple c(String ns, String ps) {\n        BigInteger n = new BigInteger(ns);\n        BigInteger p = !ps.isEmpty() ? new BigInteger(ps) : BIG;\n\n        \n        Function<BigInteger, BigInteger> ls = (BigInteger a)\n            -> a.modPow(p.subtract(BigInteger.ONE).divide(BIG_TWO), p);\n\n        \n        if (!ls.apply(n).equals(BigInteger.ONE)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        BigInteger a = BigInteger.ZERO;\n        BigInteger omega2;\n        while (true) {\n            omega2 = a.multiply(a).add(p).subtract(n).mod(p);\n            if (ls.apply(omega2).equals(p.subtract(BigInteger.ONE))) {\n                break;\n            }\n            a = a.add(BigInteger.ONE);\n        }\n\n        \n        BigInteger finalOmega = omega2;\n        BiFunction<Point, Point, Point> mul = (Point aa, Point bb) -> new Point(\n            aa.x.multiply(bb.x).add(aa.y.multiply(bb.y).multiply(finalOmega)).mod(p),\n            aa.x.multiply(bb.y).add(bb.x.multiply(aa.y)).mod(p)\n        );\n\n        \n        Point r = new Point(BigInteger.ONE, BigInteger.ZERO);\n        Point s = new Point(a, BigInteger.ONE);\n        BigInteger nn = p.add(BigInteger.ONE).shiftRight(1).mod(p);\n        while (nn.compareTo(BigInteger.ZERO) > 0) {\n            if (nn.and(BigInteger.ONE).equals(BigInteger.ONE)) {\n                r = mul.apply(r, s);\n            }\n            s = mul.apply(s, s);\n            nn = nn.shiftRight(1);\n        }\n\n        \n        if (!r.y.equals(BigInteger.ZERO)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        if (!r.x.multiply(r.x).mod(p).equals(n)) {\n            return new Triple(BigInteger.ZERO, BigInteger.ZERO, false);\n        }\n\n        \n        return new Triple(r.x, p.subtract(r.x), true);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(c(\"10\", \"13\"));\n        System.out.println(c(\"56\", \"101\"));\n        System.out.println(c(\"8218\", \"10007\"));\n        System.out.println(c(\"8219\", \"10007\"));\n        System.out.println(c(\"331575\", \"1000003\"));\n        System.out.println(c(\"665165880\", \"1000000007\"));\n        System.out.println(c(\"881398088036\", \"1000000000039\"));\n        System.out.println(c(\"34035243914635549601583369544560650254325084643201\", \"\"));\n    }\n}\n"}
{"id": 415663, "name": "Pierpont primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse bigint try=>\"GMP\";\nuse ntheory qw<is_prime>;\n\n\nsub min_index { my $b = $_[my $i = 0]; $_[$_] < $b && ($b = $_[$i = $_]) for 0..$\n\nsub iter1 { my $m = shift; my $e = 0; return sub { $m ** $e++;    } }\nsub iter2 { my $m = shift; my $e = 1; return sub { $m * ($e *= 2) } }\n\nsub pierpont {\n    my($max ) = shift || die 'Must specify count of primes to generate.';\n    my($kind) = @_ ? shift : 1;\n    die \"Unknown type: $kind. Must be one of 1 (default) or 2\" unless $kind == 1 || $kind == 2;\n    $kind = -1 if $kind == 2;\n\n    my $po3     = 3;\n    my $add_one = 3;\n    my @iterators;\n    push @iterators, iter1(2);\n    push @iterators, iter1(3); $iterators[1]->();\n    my @head = ($iterators[0]->(), $iterators[1]->());\n\n    my @pierpont;\n    do {\n        my $key = min_index(@head);\n        my $min = $head[$key];\n        push @pierpont, $min + $kind if is_prime($min + $kind);\n\n        $head[$key] = $iterators[$key]->();\n\n        if ($min >= $add_one) {\n            push @iterators, iter2($po3);\n            $add_one = $head[$\n            $po3 *= 3;\n        }\n    } until @pierpont == $max;\n    @pierpont;\n}\n\nmy @pierpont_1st = pierpont(250,1);\nmy @pierpont_2nd = pierpont(250,2);\n\nsay \"First 50 Pierpont primes of the first kind:\";\nmy $fmt = \"%9d\"x10 . \"\\n\";\nfor my $row (0..4) { printf $fmt, map { $pierpont_1st[10*$row + $_] } 0..9 }\nsay \"\\nFirst 50 Pierpont primes of the second kind:\";\nfor my $row (0..4) { printf $fmt, map { $pierpont_2nd[10*$row + $_] } 0..9 }\n\nsay \"\\n250th Pierpont prime of the first kind:    \" . $pierpont_1st[249];\nsay \"\\n250th Pierpont prime of the second kind: \"   . $pierpont_2nd[249];\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PierpontPrimes {\n\n    public static void main(String[] args) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        display(\"First 50 Pierpont primes of the first kind:\", pierpontPrimes(50, true));\n        display(\"First 50 Pierpont primes of the second kind:\", pierpontPrimes(50, false));\n        System.out.printf(\"250th Pierpont prime of the first kind:     %s%n%n\", nf.format(pierpontPrimes(250, true).get(249)));\n        System.out.printf(\"250th Pierpont prime of the second kind: %s%n%n\", nf.format(pierpontPrimes(250, false).get(249)));\n    }\n    \n    private static void display(String message, List<BigInteger> primes) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        System.out.printf(\"%s%n\", message);\n        for ( int i = 1 ; i <= primes.size() ; i++ ) {\n            System.out.printf(\"%10s  \", nf.format(primes.get(i-1)));\n            if ( i % 10 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        System.out.printf(\"%n\");\n    }\n\n    public static List<BigInteger> pierpontPrimes(int n, boolean first) {\n        List<BigInteger> primes = new ArrayList<BigInteger>();\n        if ( first ) {\n            primes.add(BigInteger.valueOf(2));\n            n -= 1;\n        }\n\n        BigInteger two = BigInteger.valueOf(2);\n        BigInteger twoTest = two;\n        BigInteger three = BigInteger.valueOf(3);\n        BigInteger threeTest = three;\n        int twoIndex = 0, threeIndex = 0;\n        List<BigInteger> twoSmooth = new ArrayList<BigInteger>();\n\n        BigInteger one = BigInteger.ONE;\n        BigInteger mOne = BigInteger.valueOf(-1);\n        int count = 0;\n        while ( count < n ) {\n            BigInteger min = twoTest.min(threeTest);\n            twoSmooth.add(min);\n            if ( min.compareTo(twoTest) == 0 ) {\n                twoTest = two.multiply(twoSmooth.get(twoIndex));\n                twoIndex++;\n            }\n            if ( min.compareTo(threeTest) == 0 ) {\n                threeTest = three.multiply(twoSmooth.get(threeIndex));\n                threeIndex++;\n            }\n            BigInteger test = min.add(first ? one : mOne);\n            if ( test.isProbablePrime(10) ) {\n                primes.add(test);\n                count++;\n            }\n        }\n        return primes;\n    }\n    \n}\n"}
{"id": 415664, "name": "N-smooth numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw<primes>;\nuse List::Util qw<min>;\n\n\nuse Math::GMPz; \n\nsub smooth_numbers {\n\n    my @m = map { Math::GMPz->new($_) } @_;     \n    my @s;\n    push @s, [1] for 0..$\n\n    return sub {\n    my $n = $s[0][0];\n    $n = min $n, $s[$_][0] for 1..$\n    for (0..$\n            shift @{$s[$_]} if $s[$_][0] == $n;\n            push @{$s[$_]}, $n * $m[$_]\n        }\n        return $n\n    }\n}\n\nsub abbrev {\n    my($n) = @_;\n    return $n if length($n) <= 50;\n    substr($n,0,10) . \"...(@{[length($n) - 2*10]} digits omitted)...\" . substr($n, -10, 10)\n}\n\nmy @primes = @{primes(10_000)};\n\nmy $start = 3000; my $cnt = 3;\nfor my $n_smooth (0..9) {\n    say \"\\nFirst 25, and ${start}th through @{[$start+2]}nd $primes[$n_smooth]-smooth numbers:\";\n    my $s = smooth_numbers(@primes[0..$n_smooth]);\n    my @S25;\n    push @S25, $s->() for 1..25;\n    say join ' ', @S25;\n\n    my @Sm; my $c = 25;\n    do {\n        my $sn = $s->();\n        push @Sm, abbrev($sn) if ++$c >= $start;\n    } until @Sm == $cnt;\n    say join ' ', @Sm;\n}\n\n$start = 30000; $cnt = 20;\nfor my $n_smooth (95..97) { \n    say \"\\n${start}th through @{[$start+$cnt-1]}th $primes[$n_smooth]-smooth numbers:\";\n    my $s = smooth_numbers(@primes[0..$n_smooth]);\n    my(@Sm,$c);\n    do {\n        my $sn = $s->();\n        push @Sm, $sn if ++$c >= $start;\n    } until @Sm == $cnt;\n    say join ' ', @Sm;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NSmoothNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"show the first 25 n-smooth numbers for n = 2 through n = 29%n\");\n        int max = 25;\n        List<BigInteger> primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The first %d %d-smooth numbers:%n\", max, n);\n                BigInteger[] humble = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = 0 ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", humble[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"show three numbers starting with 3,000 for n-smooth numbers for n = 3 through n = 29%n\");\n        int count = 3;\n        max = 3000 + count - 1;\n        primes = new ArrayList<>();\n        primes.add(BigInteger.valueOf(2));\n        for ( int n = 3 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = max-count ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", nSmooth[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"Show twenty numbers starting with 30,000 n-smooth numbers for n=503 through n=521%n\");\n        count = 20;\n        max = 30000 + count - 1;\n        primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 521 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                if ( n >= 503 && n <= 521 ) {\n                    System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                    BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                    for ( int i = max-count ; i < max ; i++ ) {\n                        System.out.printf(\"%s \", nSmooth[i]);\n                    }\n                    System.out.printf(\"%n%n\");\n                }\n            }\n        }\n\n    }\n\n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static BigInteger[] nSmooth(int n, BigInteger[] primes) {\n        int size = primes.length;\n        BigInteger[] test = new BigInteger[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            test[i] = primes[i];\n        }\n        BigInteger[] results = new BigInteger[n];\n        results[0] = BigInteger.ONE;\n        \n        int[] indexes = new int[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            indexes[i] = 0;\n        }\n        \n        for ( int index = 1 ; index < n ; index++ ) {\n            BigInteger min = test[0];\n            for ( int i = 1 ; i < size ; i++ ) {\n                min = min.min(test[i]);\n            }\n            results[index] = min;\n            \n            for ( int i = 0 ; i < size ; i++ ) {\n                if ( results[index].compareTo(test[i]) == 0 ) {\n                    indexes[i] = indexes[i] + 1;\n                    test[i] = primes[i].multiply(results[indexes[i]]);\n                }\n            }\n        }\n        return results;\n    }\n\n}\n"}
{"id": 415665, "name": "Partition an integer x into n primes", "source": "Translate Perl to Java: use ntheory \":all\";\n\nsub prime_partition {\n  my($num, $parts) = @_;\n  return is_prime($num) ? [$num] : undef if $parts == 1;\n  my @p = @{primes($num)};\n  my $r;\n  forcomb { lastfor, $r = [@p[@_]] if vecsum(@p[@_]) == $num; } @p, $parts;\n  $r;\n}\n\nforeach my $test ([18,2], [19,3], [20,4], [99807,1], [99809,1], [2017,24], [22699,1], [22699,2], [22699,3], [22699,4], [40355,3]) {\n  my $partar = prime_partition(@$test);\n  printf \"Partition %5d into %2d prime piece%s %s\\n\", $test->[0], $test->[1], ($test->[1] == 1) ? \": \" : \"s:\", defined($partar) ? join(\"+\",@$partar) : \"not possible\";\n}\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PartitionInteger {\n    private static final int[] primes = IntStream.concat(IntStream.of(2), IntStream.iterate(3, n -> n + 2))\n        .filter(PartitionInteger::isPrime)\n        .limit(50_000)\n        .toArray();\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    private static boolean findCombo(int k, int x, int m, int n, int[] combo) {\n        boolean foundCombo = false;\n        if (k >= m) {\n            if (Arrays.stream(combo).map(i -> primes[i]).sum() == x) {\n                String s = m > 1 ? \"s\" : \"\";\n                System.out.printf(\"Partitioned %5d with %2d prime%s: \", x, m, s);\n                for (int i = 0; i < m; ++i) {\n                    System.out.print(primes[combo[i]]);\n                    if (i < m - 1) System.out.print('+');\n                    else System.out.println();\n                }\n                foundCombo = true;\n            }\n        } else {\n            for (int j = 0; j < n; ++j) {\n                if (k == 0 || j > combo[k - 1]) {\n                    combo[k] = j;\n                    if (!foundCombo) {\n                        foundCombo = findCombo(k + 1, x, m, n, combo);\n                    }\n                }\n            }\n        }\n        return foundCombo;\n    }\n\n    private static void partition(int x, int m) {\n        if (x < 2 || m < 1 || m >= x) {\n            throw new IllegalArgumentException();\n        }\n        int[] filteredPrimes = Arrays.stream(primes).filter(it -> it <= x).toArray();\n        int n = filteredPrimes.length;\n        if (n < m) throw new IllegalArgumentException(\"Not enough primes\");\n        int[] combo = new int[m];\n        boolean foundCombo = findCombo(0, x, m, n, combo);\n        if (!foundCombo) {\n            String s = m > 1 ? \"s\" : \" \";\n            System.out.printf(\"Partitioned %5d with %2d prime%s: (not possible)\\n\", x, m, s);\n        }\n    }\n\n    public static void main(String[] args) {\n        partition(99809, 1);\n        partition(18, 2);\n        partition(19, 3);\n        partition(20, 4);\n        partition(2017, 24);\n        partition(22699, 1);\n        partition(22699, 2);\n        partition(22699, 3);\n        partition(22699, 4);\n        partition(40355, 3);\n    }\n}\n"}
{"id": 415666, "name": "Zeckendorf arithmetic", "source": "Translate Perl to Java: use v5.36;\n\npackage Zeckendorf;\nuse overload qw(\"\" zstring + zadd - zsub ++ zinc -- zdec * zmul / zdiv ge zge);\n\nsub new ($class, $value) {\n    bless \\$value, ref $class || $class;\n}\n\nsub zinc ($self, $, $) {\n    local $_ = $$self;\n    s/0$/1/ or s/(?:^|0)1$/10/;\n    1 while s/(?:^|0)11/100/;\n    $$self = $self->new( s/^0+\\B//r )\n}\n\nsub zdec ($self, $, $) {\n    local $_ = $$self;\n    1 while s/100(?=0*$)/011/;\n    s/1$/0/ || s/10$/01/;\n    $$self = $self->new( s/^0+\\B//r )\n}\n\nsub zadd ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    $x++, $y-- while $$y;\n    $x\n}\n\nsub zsub ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    $x--, $y-- while $$y;\n    $x\n}\n\nsub zmul ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    my $product = Zeckendorf->new(0);\n    $product = $product + $x, $y-- while $y;\n    $product\n}\n\nsub zdiv ($self, $other, $) {\n    my ($x, $y) = map $self->new($$_), $self, $other;\n    my $quotient = Zeckendorf->new(0);\n    $quotient++, $x = $x - $y while $x ge $y;\n    $quotient\n}\n\nsub zge ($self, $other, $) {\n    my $l; $l = length $$other if length $other > ($l = length $$self);\n    0 x ($l - length $$self) . $$self ge 0 x ($l - length $$other) . $$other;\n}\n\nsub asdecimal ($self) {\n    my($aa, $bb, $n) = (1, 1, 0);\n    for ( reverse split '', $$self ) {\n        $n += $bb * $_;\n        ($aa, $bb) = ($bb, $aa + $bb);\n    }\n    $n\n}\n\nsub fromdecimal ($self, $value) {\n    my $z = $self->new(0);\n    $z++ for 1 .. $value;\n    $z\n}\n\nsub zstring { ${ shift() } }\n\npackage main;\n\nfor ( split /\\n/, <<END ) \n  1 + 1\n  10 + 10\n  10100 + 1010\n  10100 - 1010\n  10100 * 1010\n  100010 * 100101\n  10100 / 1010\n  101000 / 1000\n  100001000001 / 100010\n  100001000001 / 100101\nEND\n  {\n  my ($left, $op, $right) = split;\n  my ($x, $y) = map Zeckendorf->new($_), $left, $right;\n  my $answer =\n    $op eq '+' ? $x + $y :\n    $op eq '-' ? $x - $y :\n    $op eq '*' ? $x * $y :\n    $op eq '/' ? $x / $y :\n    die \"bad op <$op>\";\n    printf \"%12s %s\u00a0%-9s => %12s  in Zeckendorf\\n\", $x, $op, $y, $answer;\n    printf \"%12d %s\u00a0%-9d => %12d  in decimal\\n\\n\",\n    $x->asdecimal, $op, $y->asdecimal, $answer->asdecimal;\n  }\n", "target": "import java.util.List;\n\npublic class Zeckendorf implements Comparable<Zeckendorf> {\n    private static List<String> dig = List.of(\"00\", \"01\", \"10\");\n    private static List<String> dig1 = List.of(\"\", \"1\", \"10\");\n\n    private String x;\n    private int dVal = 0;\n    private int dLen = 0;\n\n    public Zeckendorf() {\n        this(\"0\");\n    }\n\n    public Zeckendorf(String x) {\n        this.x = x;\n\n        int q = 1;\n        int i = x.length() - 1;\n        dLen = i / 2;\n        while (i >= 0) {\n            dVal += (x.charAt(i) - '0') * q;\n            q *= 2;\n            i--;\n        }\n    }\n\n    private void a(int n) {\n        int i = n;\n        while (true) {\n            if (dLen < i) dLen = i;\n            int j = (dVal >> (i * 2)) & 3;\n            switch (j) {\n                case 0:\n                case 1:\n                    return;\n                case 2:\n                    if (((dVal >> ((i + 1) * 2)) & 1) != 1) return;\n                    dVal += 1 << (i * 2 + 1);\n                    return;\n                case 3:\n                    int temp = 3 << (i * 2);\n                    temp ^= -1;\n                    dVal = dVal & temp;\n                    b((i + 1) * 2);\n                    break;\n            }\n            i++;\n        }\n    }\n\n    private void b(int pos) {\n        if (pos == 0) {\n            Zeckendorf thiz = this;\n            thiz.inc();\n            return;\n        }\n        if (((dVal >> pos) & 1) == 0) {\n            dVal += 1 << pos;\n            a(pos / 2);\n            if (pos > 1) a(pos / 2 - 1);\n        } else {\n            int temp = 1 << pos;\n            temp ^= -1;\n            dVal = dVal & temp;\n            b(pos + 1);\n            b(pos - (pos > 1 ? 2 : 1));\n        }\n    }\n\n    private void c(int pos) {\n        if (((dVal >> pos) & 1) == 1) {\n            int temp = 1 << pos;\n            temp ^= -1;\n            dVal = dVal & temp;\n            return;\n        }\n        c(pos + 1);\n        if (pos > 0) {\n            b(pos - 1);\n        } else {\n            Zeckendorf thiz = this;\n            thiz.inc();\n        }\n    }\n\n    public Zeckendorf inc() {\n        dVal++;\n        a(0);\n        return this;\n    }\n\n    public void plusAssign(Zeckendorf other) {\n        for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n            if (((other.dVal >> gn) & 1) == 1) {\n                b(gn);\n            }\n        }\n    }\n\n    public void minusAssign(Zeckendorf other) {\n        for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n            if (((other.dVal >> gn) & 1) == 1) {\n                c(gn);\n            }\n        }\n        while ((((dVal >> dLen * 2) & 3) == 0) || (dLen == 0)) {\n            dLen--;\n        }\n    }\n\n    public void timesAssign(Zeckendorf other) {\n        Zeckendorf na = other.copy();\n        Zeckendorf nb = other.copy();\n        Zeckendorf nt;\n        Zeckendorf nr = new Zeckendorf();\n        for (int i = 0; i < (dLen + 1) * 2; i++) {\n            if (((dVal >> i) & 1) > 0) {\n                nr.plusAssign(nb);\n            }\n            nt = nb.copy();\n            nb.plusAssign(na);\n            na = nt.copy();\n        }\n        dVal = nr.dVal;\n        dLen = nr.dLen;\n    }\n\n    private Zeckendorf copy() {\n        Zeckendorf z = new Zeckendorf();\n        z.dVal = dVal;\n        z.dLen = dLen;\n        return z;\n    }\n\n    @Override\n    public int compareTo(Zeckendorf other) {\n        return ((Integer) dVal).compareTo(other.dVal);\n    }\n\n    @Override\n    public String toString() {\n        if (dVal == 0) {\n            return \"0\";\n        }\n\n        int idx = (dVal >> (dLen * 2)) & 3;\n        StringBuilder stringBuilder = new StringBuilder(dig1.get(idx));\n        for (int i = dLen - 1; i >= 0; i--) {\n            idx = (dVal >> (i * 2)) & 3;\n            stringBuilder.append(dig.get(idx));\n        }\n        return stringBuilder.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Addition:\");\n        Zeckendorf g = new Zeckendorf(\"10\");\n        g.plusAssign(new Zeckendorf(\"10\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"10\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"1001\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"1000\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"10101\"));\n        System.out.println(g);\n\n        System.out.println(\"\\nSubtraction:\");\n        g = new Zeckendorf(\"1000\");\n        g.minusAssign(new Zeckendorf(\"101\"));\n        System.out.println(g);\n        g = new Zeckendorf(\"10101010\");\n        g.minusAssign(new Zeckendorf(\"1010101\"));\n        System.out.println(g);\n\n        System.out.println(\"\\nMultiplication:\");\n        g = new Zeckendorf(\"1001\");\n        g.timesAssign(new Zeckendorf(\"101\"));\n        System.out.println(g);\n        g = new Zeckendorf(\"101010\");\n        g.plusAssign(new Zeckendorf(\"101\"));\n        System.out.println(g);\n    }\n}\n"}
{"id": 415667, "name": "Stirling numbers of the first kind", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling1 {\n    my($n, $k) = @_;\n    return 1 unless $n || $k;\n    return 0 unless $n && $k;\n    state %seen;\n    return ($seen{\"{$n-1}|{$k-1}\"} //= Stirling1($n-1, $k-1)) +\n           ($seen{\"{$n-1}|{$k}\"  } //= Stirling1($n-1, $k  )) * ($n-1)\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling1($upto,$_) } 0..$upto;\n\nsay 'Unsigned Stirling1 numbers of the first kind: S1(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    printf \"%${width}d\", Stirling1($row, $_) for 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S1(100, *) row:\";\nsay max map { Stirling1(100,$_) } 0..100;\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersFirstKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Unsigned Stirling numbers of the first kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling1(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S1(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling1(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling1(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( n > 0 && k == 0 ) {\n            return BigInteger.ZERO; \n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = sterling1(n-1, k-1).add(BigInteger.valueOf(n-1).multiply(sterling1(n-1, k)));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 415668, "name": "Stirling numbers of the first kind", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nuse feature 'say';\nuse feature 'state';\nno warnings 'recursion';\nuse List::Util qw(max);\n\nsub Stirling1 {\n    my($n, $k) = @_;\n    return 1 unless $n || $k;\n    return 0 unless $n && $k;\n    state %seen;\n    return ($seen{\"{$n-1}|{$k-1}\"} //= Stirling1($n-1, $k-1)) +\n           ($seen{\"{$n-1}|{$k}\"  } //= Stirling1($n-1, $k  )) * ($n-1)\n}\n\nmy $upto  = 12;\nmy $width = 1 + length max map { Stirling1($upto,$_) } 0..$upto;\n\nsay 'Unsigned Stirling1 numbers of the first kind: S1(n, k):';\nprint 'n\\k' . sprintf \"%${width}s\"x(1+$upto).\"\\n\", 0..$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    printf \"%${width}d\", Stirling1($row, $_) for 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the S1(100, *) row:\";\nsay max map { Stirling1(100,$_) } 0..100;\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersFirstKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Unsigned Stirling numbers of the first kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling1(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S1(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling1(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling1(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( n > 0 && k == 0 ) {\n            return BigInteger.ZERO; \n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = sterling1(n-1, k-1).add(BigInteger.valueOf(n-1).multiply(sterling1(n-1, k)));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 415669, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::MoreUtils qw(firstidx minmax);\n\nmy $epsilon = 1;\n\nsub norm {\n    my(@list) = @_;\n    my $sum;\n    $sum += $_**2 for @list;\n    sqrt($sum)\n}\n\nsub perpendicular_distance {\n    our(@start,@end,@point);\n    local(*start,*end,*point) = (shift, shift, shift);\n    return 0 if $start[0]==$point[0] && $start[1]==$point[1]\n             or   $end[0]==$point[0] &&   $end[1]==$point[1];\n    my ( $dx,  $dy)  = (  $end[0]-$start[0],  $end[1]-$start[1]);\n    my ($dpx, $dpy)  = ($point[0]-$start[0],$point[1]-$start[1]);\n    my $t = norm($dx, $dy);\n    $dx /= $t;\n    $dy /= $t;\n    norm($dpx - $dx*($dx*$dpx + $dy*$dpy), $dpy - $dy*($dx*$dpx + $dy*$dpy));\n}\n\nsub Ramer_Douglas_Peucker {\n    my(@points) = @_;\n    return @points if @points == 2;\n    my @d;\n    push @d, perpendicular_distance(@points[0, -1, $_]) for 0..@points-1;\n    my(undef,$dmax) = minmax @d;\n    my $index = firstidx { $_ == $dmax } @d;\n    if ($dmax > $epsilon) {\n        my @lo = Ramer_Douglas_Peucker( @points[0..$index]);\n        my @hi = Ramer_Douglas_Peucker( @points[$index..$\n        return  @lo[0..@lo-2], @hi;\n    }\n    @points[0, -1];\n}\n\nsay '(' . join(' ', @$_) . ') '\n    for Ramer_Douglas_Peucker( [0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9] )\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 415670, "name": "Ramer-Douglas-Peucker line simplification", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::MoreUtils qw(firstidx minmax);\n\nmy $epsilon = 1;\n\nsub norm {\n    my(@list) = @_;\n    my $sum;\n    $sum += $_**2 for @list;\n    sqrt($sum)\n}\n\nsub perpendicular_distance {\n    our(@start,@end,@point);\n    local(*start,*end,*point) = (shift, shift, shift);\n    return 0 if $start[0]==$point[0] && $start[1]==$point[1]\n             or   $end[0]==$point[0] &&   $end[1]==$point[1];\n    my ( $dx,  $dy)  = (  $end[0]-$start[0],  $end[1]-$start[1]);\n    my ($dpx, $dpy)  = ($point[0]-$start[0],$point[1]-$start[1]);\n    my $t = norm($dx, $dy);\n    $dx /= $t;\n    $dy /= $t;\n    norm($dpx - $dx*($dx*$dpx + $dy*$dpy), $dpy - $dy*($dx*$dpx + $dy*$dpy));\n}\n\nsub Ramer_Douglas_Peucker {\n    my(@points) = @_;\n    return @points if @points == 2;\n    my @d;\n    push @d, perpendicular_distance(@points[0, -1, $_]) for 0..@points-1;\n    my(undef,$dmax) = minmax @d;\n    my $index = firstidx { $_ == $dmax } @d;\n    if ($dmax > $epsilon) {\n        my @lo = Ramer_Douglas_Peucker( @points[0..$index]);\n        my @hi = Ramer_Douglas_Peucker( @points[$index..$\n        return  @lo[0..@lo-2], @hi;\n    }\n    @points[0, -1];\n}\n\nsay '(' . join(' ', @$_) . ') '\n    for Ramer_Douglas_Peucker( [0,0],[1,0.1],[2,-0.1],[3,5],[4,6],[5,7],[6,8.1],[7,9],[8,9],[9,9] )\n", "target": "import javafx.util.Pair;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class LineSimplification {\n    private static class Point extends Pair<Double, Double> {\n        Point(Double key, Double value) {\n            super(key, value);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", getKey(), getValue());\n        }\n    }\n\n    private static double perpendicularDistance(Point pt, Point lineStart, Point lineEnd) {\n        double dx = lineEnd.getKey() - lineStart.getKey();\n        double dy = lineEnd.getValue() - lineStart.getValue();\n\n        \n        double mag = Math.hypot(dx, dy);\n        if (mag > 0.0) {\n            dx /= mag;\n            dy /= mag;\n        }\n        double pvx = pt.getKey() - lineStart.getKey();\n        double pvy = pt.getValue() - lineStart.getValue();\n\n        \n        double pvdot = dx * pvx + dy * pvy;\n\n        \n        double ax = pvx - pvdot * dx;\n        double ay = pvy - pvdot * dy;\n\n        return Math.hypot(ax, ay);\n    }\n\n    private static void ramerDouglasPeucker(List<Point> pointList, double epsilon, List<Point> out) {\n        if (pointList.size() < 2) throw new IllegalArgumentException(\"Not enough points to simplify\");\n\n        \n        double dmax = 0.0;\n        int index = 0;\n        int end = pointList.size() - 1;\n        for (int i = 1; i < end; ++i) {\n            double d = perpendicularDistance(pointList.get(i), pointList.get(0), pointList.get(end));\n            if (d > dmax) {\n                index = i;\n                dmax = d;\n            }\n        }\n\n        \n        if (dmax > epsilon) {\n            List<Point> recResults1 = new ArrayList<>();\n            List<Point> recResults2 = new ArrayList<>();\n            List<Point> firstLine = pointList.subList(0, index + 1);\n            List<Point> lastLine = pointList.subList(index, pointList.size());\n            ramerDouglasPeucker(firstLine, epsilon, recResults1);\n            ramerDouglasPeucker(lastLine, epsilon, recResults2);\n\n            \n            out.addAll(recResults1.subList(0, recResults1.size() - 1));\n            out.addAll(recResults2);\n            if (out.size() < 2) throw new RuntimeException(\"Problem assembling output\");\n        } else {\n            \n            out.clear();\n            out.add(pointList.get(0));\n            out.add(pointList.get(pointList.size() - 1));\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Point> pointList = List.of(\n                new Point(0.0, 0.0),\n                new Point(1.0, 0.1),\n                new Point(2.0, -0.1),\n                new Point(3.0, 5.0),\n                new Point(4.0, 6.0),\n                new Point(5.0, 7.0),\n                new Point(6.0, 8.1),\n                new Point(7.0, 9.0),\n                new Point(8.0, 9.0),\n                new Point(9.0, 9.0)\n        );\n        List<Point> pointListOut = new ArrayList<>();\n        ramerDouglasPeucker(pointList, 1.0, pointListOut);\n        System.out.println(\"Points remaining after simplification:\");\n        pointListOut.forEach(System.out::println);\n    }\n}\n"}
{"id": 415671, "name": "Bilinear interpolation", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse GD;\n\nmy $image = GD::Image->newFromPng('color_wheel.png');\n$image->interpolationMethod( ['GD_BILINEAR_FIXED'] );\nmy($width,$height) = $image->getBounds();\nmy $image2 = $image->copyScaleInterpolated( 1.6*$width, 1.6*$height );\n\n$image2->_file('color_wheel_interpolated.png');\n", "target": "import javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class BilinearInterpolation {\n    \n    private static int get(int self, int n) {\n        return (self >> (n * 8)) & 0xFF;\n    }\n\n    private static float lerp(float s, float e, float t) {\n        return s + (e - s) * t;\n    }\n\n    private static float blerp(final Float c00, float c10, float c01, float c11, float tx, float ty) {\n        return lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty);\n    }\n\n    private static BufferedImage scale(BufferedImage self, float scaleX, float scaleY) {\n        int newWidth = (int) (self.getWidth() * scaleX);\n        int newHeight = (int) (self.getHeight() * scaleY);\n        BufferedImage newImage = new BufferedImage(newWidth, newHeight, self.getType());\n        for (int x = 0; x < newWidth; ++x) {\n            for (int y = 0; y < newHeight; ++y) {\n                float gx = ((float) x) / newWidth * (self.getWidth() - 1);\n                float gy = ((float) y) / newHeight * (self.getHeight() - 1);\n                int gxi = (int) gx;\n                int gyi = (int) gy;\n                int rgb = 0;\n                int c00 = self.getRGB(gxi, gyi);\n                int c10 = self.getRGB(gxi + 1, gyi);\n                int c01 = self.getRGB(gxi, gyi + 1);\n                int c11 = self.getRGB(gxi + 1, gyi + 1);\n                for (int i = 0; i <= 2; ++i) {\n                    float b00 = get(c00, i);\n                    float b10 = get(c10, i);\n                    float b01 = get(c01, i);\n                    float b11 = get(c11, i);\n                    int ble = ((int) blerp(b00, b10, b01, b11, gx - gxi, gy - gyi)) << (8 * i);\n                    rgb = rgb | ble;\n                }\n                newImage.setRGB(x, y, rgb);\n            }\n        }\n        return newImage;\n    }\n\n    public static void main(String[] args) throws IOException {\n        File lenna = new File(\"Lenna100.jpg\");\n        BufferedImage image = ImageIO.read(lenna);\n        BufferedImage image2 = scale(image, 1.6f, 1.6f);\n        File lenna2 = new File(\"Lenna100_larger.jpg\");\n        ImageIO.write(image2, \"jpg\", lenna2);\n    }\n}\n"}
{"id": 415672, "name": "Bilinear interpolation", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse GD;\n\nmy $image = GD::Image->newFromPng('color_wheel.png');\n$image->interpolationMethod( ['GD_BILINEAR_FIXED'] );\nmy($width,$height) = $image->getBounds();\nmy $image2 = $image->copyScaleInterpolated( 1.6*$width, 1.6*$height );\n\n$image2->_file('color_wheel_interpolated.png');\n", "target": "import javax.imageio.ImageIO;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\n\npublic class BilinearInterpolation {\n    \n    private static int get(int self, int n) {\n        return (self >> (n * 8)) & 0xFF;\n    }\n\n    private static float lerp(float s, float e, float t) {\n        return s + (e - s) * t;\n    }\n\n    private static float blerp(final Float c00, float c10, float c01, float c11, float tx, float ty) {\n        return lerp(lerp(c00, c10, tx), lerp(c01, c11, tx), ty);\n    }\n\n    private static BufferedImage scale(BufferedImage self, float scaleX, float scaleY) {\n        int newWidth = (int) (self.getWidth() * scaleX);\n        int newHeight = (int) (self.getHeight() * scaleY);\n        BufferedImage newImage = new BufferedImage(newWidth, newHeight, self.getType());\n        for (int x = 0; x < newWidth; ++x) {\n            for (int y = 0; y < newHeight; ++y) {\n                float gx = ((float) x) / newWidth * (self.getWidth() - 1);\n                float gy = ((float) y) / newHeight * (self.getHeight() - 1);\n                int gxi = (int) gx;\n                int gyi = (int) gy;\n                int rgb = 0;\n                int c00 = self.getRGB(gxi, gyi);\n                int c10 = self.getRGB(gxi + 1, gyi);\n                int c01 = self.getRGB(gxi, gyi + 1);\n                int c11 = self.getRGB(gxi + 1, gyi + 1);\n                for (int i = 0; i <= 2; ++i) {\n                    float b00 = get(c00, i);\n                    float b10 = get(c10, i);\n                    float b01 = get(c01, i);\n                    float b11 = get(c11, i);\n                    int ble = ((int) blerp(b00, b10, b01, b11, gx - gxi, gy - gyi)) << (8 * i);\n                    rgb = rgb | ble;\n                }\n                newImage.setRGB(x, y, rgb);\n            }\n        }\n        return newImage;\n    }\n\n    public static void main(String[] args) throws IOException {\n        File lenna = new File(\"Lenna100.jpg\");\n        BufferedImage image = ImageIO.read(lenna);\n        BufferedImage image2 = scale(image, 1.6f, 1.6f);\n        File lenna2 = new File(\"Lenna100_larger.jpg\");\n        ImageIO.write(image2, \"jpg\", lenna2);\n    }\n}\n"}
{"id": 415673, "name": "Vector", "source": "Translate Perl to Java: use v5.36;\n\npackage Vector;\nuse Moose;\nuse overload '+'  => \\&add,\n             '-'  => \\&sub,\n             '*'  => \\&mul,\n             '/'  => \\&div,\n             '\"\"' => \\&stringify;\n\nhas 'x' => (is =>'rw', isa => 'Num', required => 1);\nhas 'y' => (is =>'rw', isa => 'Num', required => 1);\n\nsub add ($a, $b, $) { Vector->new( x => $a->x + $b->x, y => $a->y + $b->y) }\nsub sub ($a, $b, $) { Vector->new( x => $a->x - $b->x, y => $a->y - $b->y) }\nsub mul ($a, $b, $) { Vector->new( x => $a->x * $b,    y => $a->y * $b)    }\nsub div ($a, $b, $) { Vector->new( x => $a->x / $b,    y => $a->y / $b)    }\nsub stringify ($self, $, $) { '(' . $self->x . ',' . $self->y . ')' }\n\npackage main;\n\nmy $a = Vector->new(x => 5, y => 7);\nmy $b = Vector->new(x => 2, y => 3);\nsay \"a:    $a\";\nsay \"b:    $b\";\nsay \"a+b:  \",$a+$b;\nsay \"a-b:  \",$a-$b;\nsay \"a*11: \",$a*11;\nsay \"a/2:  \",$a/2;\n", "target": "import java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(new Vec2(5, 7).add(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).sub(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).mult(11));\n        System.out.println(new Vec2(5, 7).div(2));\n    }\n}\n\nclass Vec2 {\n    final double x, y;\n\n    Vec2(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Vec2 add(Vec2 v) {\n        return new Vec2(x + v.x, y + v.y);\n    }\n\n    Vec2 sub(Vec2 v) {\n        return new Vec2(x - v.x, y - v.y);\n    }\n\n    Vec2 div(double val) {\n        return new Vec2(x / val, y / val);\n    }\n\n    Vec2 mult(double val) {\n        return new Vec2(x * val, y * val);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(Locale.US, \"[%s, %s]\", x, y);\n    }\n}\n"}
{"id": 415674, "name": "Elliptic curve arithmetic", "source": "Translate Perl to Java: package EC;\n{\n    our ($A, $B) = (0, 7);\n    package EC::Point;\n    sub new { my $class = shift; bless [ @_ ], $class }\n    sub zero { bless [], shift }\n    sub x { shift->[0] }; sub y { shift->[1] };\n    sub double {\n        my $self = shift;\n        return $self unless @$self;\n        my $L = (3 * $self->x**2) / (2*$self->y);\n        my $x = $L**2 - 2*$self->x;\n        bless [ $x, $L * ($self->x - $x) - $self->y ], ref $self;\n    }\n    use overload\n    '==' => sub { my ($p, $q) = @_; $p->x == $q->x and $p->y == $q->y },\n    '+' => sub {\n        my ($p, $q) = @_;\n        return $p->double if $p == $q;\n        return $p unless @$q;\n        return $q unless @$p;\n        my $slope = ($q->y - $p->y) / ($q->x - $p->x);\n        my $x = $slope**2 - $p->x - $q->x;\n        bless [ $x, $slope * ($p->x - $x)  - $p->y ], ref $p;\n    },\n    q{\"\"} => sub {\n        my $self = shift;\n        return @$self\n        ? sprintf \"EC-point at x=%f, y=%f\", @$self\n        : 'EC point at infinite';\n    }\n}\n\npackage Test;\nmy $p = +EC::Point->new(-($EC::B - 1)**(1/3), 1);\nmy $q = +EC::Point->new(-($EC::B - 4)**(1/3), 2);\nmy $s = $p + $q, \"\\n\";\nprint \"$_\\n\" for $p, $q, $s;\nprint \"check alignment... \";\nprint abs(($q->x - $p->x)*(-$s->y - $p->y) - ($q->y - $p->y)*($s->x - $p->x)) < 0.001\n    ? \"ok\" : \"wrong\";\n", "target": "import static java.lang.Math.*;\nimport java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Pt a = Pt.fromY(1);\n        Pt b = Pt.fromY(2);\n        System.out.printf(\"a = %s%n\", a);\n        System.out.printf(\"b = %s%n\", b);\n        Pt c = a.plus(b);\n        System.out.printf(\"c = a + b = %s%n\", c);\n        Pt d = c.neg();\n        System.out.printf(\"d = -c = %s%n\", d);\n        System.out.printf(\"c + d = %s%n\", c.plus(d));\n        System.out.printf(\"a + b + d = %s%n\", a.plus(b).plus(d));\n        System.out.printf(\"a * 12345 = %s%n\", a.mult(12345));\n    }\n}\n\nclass Pt {\n    final static int bCoeff = 7;\n\n    double x, y;\n\n    Pt(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    static Pt zero() {\n        return new Pt(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    boolean isZero() {\n        return this.x > 1e20 || this.x < -1e20;\n    }\n\n    static Pt fromY(double y) {\n        return new Pt(cbrt(pow(y, 2) - bCoeff), y);\n    }\n\n    Pt dbl() {\n        if (isZero())\n            return this;\n        double L = (3 * this.x * this.x) / (2 * this.y);\n        double x2 = pow(L, 2) - 2 * this.x;\n        return new Pt(x2, L * (this.x - x2) - this.y);\n    }\n\n    Pt neg() {\n        return new Pt(this.x, -this.y);\n    }\n\n    Pt plus(Pt q) {\n        if (this.x == q.x && this.y == q.y)\n            return dbl();\n\n        if (isZero())\n            return q;\n\n        if (q.isZero())\n            return this;\n\n        double L = (q.y - this.y) / (q.x - this.x);\n        double xx = pow(L, 2) - this.x - q.x;\n        return new Pt(xx, L * (this.x - xx) - this.y);\n    }\n\n    Pt mult(int n) {\n        Pt r = Pt.zero();\n        Pt p = this;\n        for (int i = 1; i <= n; i <<= 1) {\n            if ((i & n) != 0)\n                r = r.plus(p);\n            p = p.dbl();\n        }\n        return r;\n    }\n\n    @Override\n    public String toString() {\n        if (isZero())\n            return \"Zero\";\n        return String.format(Locale.US, \"(%.3f,%.3f)\", this.x, this.y);\n    }\n}\n"}
{"id": 415675, "name": "Elliptic curve arithmetic", "source": "Translate Perl to Java: package EC;\n{\n    our ($A, $B) = (0, 7);\n    package EC::Point;\n    sub new { my $class = shift; bless [ @_ ], $class }\n    sub zero { bless [], shift }\n    sub x { shift->[0] }; sub y { shift->[1] };\n    sub double {\n        my $self = shift;\n        return $self unless @$self;\n        my $L = (3 * $self->x**2) / (2*$self->y);\n        my $x = $L**2 - 2*$self->x;\n        bless [ $x, $L * ($self->x - $x) - $self->y ], ref $self;\n    }\n    use overload\n    '==' => sub { my ($p, $q) = @_; $p->x == $q->x and $p->y == $q->y },\n    '+' => sub {\n        my ($p, $q) = @_;\n        return $p->double if $p == $q;\n        return $p unless @$q;\n        return $q unless @$p;\n        my $slope = ($q->y - $p->y) / ($q->x - $p->x);\n        my $x = $slope**2 - $p->x - $q->x;\n        bless [ $x, $slope * ($p->x - $x)  - $p->y ], ref $p;\n    },\n    q{\"\"} => sub {\n        my $self = shift;\n        return @$self\n        ? sprintf \"EC-point at x=%f, y=%f\", @$self\n        : 'EC point at infinite';\n    }\n}\n\npackage Test;\nmy $p = +EC::Point->new(-($EC::B - 1)**(1/3), 1);\nmy $q = +EC::Point->new(-($EC::B - 4)**(1/3), 2);\nmy $s = $p + $q, \"\\n\";\nprint \"$_\\n\" for $p, $q, $s;\nprint \"check alignment... \";\nprint abs(($q->x - $p->x)*(-$s->y - $p->y) - ($q->y - $p->y)*($s->x - $p->x)) < 0.001\n    ? \"ok\" : \"wrong\";\n", "target": "import static java.lang.Math.*;\nimport java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Pt a = Pt.fromY(1);\n        Pt b = Pt.fromY(2);\n        System.out.printf(\"a = %s%n\", a);\n        System.out.printf(\"b = %s%n\", b);\n        Pt c = a.plus(b);\n        System.out.printf(\"c = a + b = %s%n\", c);\n        Pt d = c.neg();\n        System.out.printf(\"d = -c = %s%n\", d);\n        System.out.printf(\"c + d = %s%n\", c.plus(d));\n        System.out.printf(\"a + b + d = %s%n\", a.plus(b).plus(d));\n        System.out.printf(\"a * 12345 = %s%n\", a.mult(12345));\n    }\n}\n\nclass Pt {\n    final static int bCoeff = 7;\n\n    double x, y;\n\n    Pt(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    static Pt zero() {\n        return new Pt(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    boolean isZero() {\n        return this.x > 1e20 || this.x < -1e20;\n    }\n\n    static Pt fromY(double y) {\n        return new Pt(cbrt(pow(y, 2) - bCoeff), y);\n    }\n\n    Pt dbl() {\n        if (isZero())\n            return this;\n        double L = (3 * this.x * this.x) / (2 * this.y);\n        double x2 = pow(L, 2) - 2 * this.x;\n        return new Pt(x2, L * (this.x - x2) - this.y);\n    }\n\n    Pt neg() {\n        return new Pt(this.x, -this.y);\n    }\n\n    Pt plus(Pt q) {\n        if (this.x == q.x && this.y == q.y)\n            return dbl();\n\n        if (isZero())\n            return q;\n\n        if (q.isZero())\n            return this;\n\n        double L = (q.y - this.y) / (q.x - this.x);\n        double xx = pow(L, 2) - this.x - q.x;\n        return new Pt(xx, L * (this.x - xx) - this.y);\n    }\n\n    Pt mult(int n) {\n        Pt r = Pt.zero();\n        Pt p = this;\n        for (int i = 1; i <= n; i <<= 1) {\n            if ((i & n) != 0)\n                r = r.plus(p);\n            p = p.dbl();\n        }\n        return r;\n    }\n\n    @Override\n    public String toString() {\n        if (isZero())\n            return \"Zero\";\n        return String.format(Locale.US, \"(%.3f,%.3f)\", this.x, this.y);\n    }\n}\n"}
{"id": 415676, "name": "Chebyshev coefficients", "source": "Translate Perl to Java: use constant PI => 2 * atan2(1, 0);\n\nsub chebft {\n  my($func, $a, $b, $n) = @_;\n  my($bma, $bpa) = ( 0.5*($b-$a), 0.5*($b+$a) );\n\n  my @pin = map { ($_ + 0.5) * (PI/$n) } 0..$n-1;\n  my @f   = map { $func->( cos($_) * $bma + $bpa ) } @pin;\n  my @c   = (0) x $n;\n  for my $j (0 .. $n-1) {\n      $c[$j] += $f[$_] * cos($j * $pin[$_]) for 0..$n-1;\n      $c[$j] *= (2.0/$n);\n  }\n  @c\n}\n\nprintf \"%+13.7e\\n\", $_ for chebft(sub{cos($_[0])}, 0, 1, 10);\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class ChebyshevCoefficients {\n\n    static double map(double x, double min_x, double max_x, double min_to,\n            double max_to) {\n        return (x - min_x) / (max_x - min_x) * (max_to - min_to) + min_to;\n    }\n\n    static void chebyshevCoef(Function<Double, Double> func, double min,\n            double max, double[] coef) {\n\n        int N = coef.length;\n\n        for (int i = 0; i < N; i++) {\n\n            double m = map(cos(PI * (i + 0.5f) / N), -1, 1, min, max);\n            double f = func.apply(m) * 2 / N;\n\n            for (int j = 0; j < N; j++) {\n                coef[j] += f * cos(PI * j * (i + 0.5f) / N);\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        final int N = 10;\n        double[] c = new double[N];\n        double min = 0, max = 1;\n        chebyshevCoef(x -> cos(x), min, max, c);\n\n        System.out.println(\"Coefficients:\");\n        for (double d : c)\n            System.out.println(d);\n    }\n}\n"}
{"id": 415677, "name": "Burrows\u2013Wheeler transform", "source": "Translate Perl to Java: use utf8;\nbinmode STDOUT, \":utf8\";\n\nuse constant STX => '\ud83d\udc4d ';\n\nsub transform {\n    my($s) = @_;\n    my($t);\n    warn \"String can't contain STX character.\" and exit if $s =~ /STX/;\n    $s = STX . $s;\n    $t .= substr($_,-1,1) for sort map { rotate($s,$_) } 1..length($s);\n    return $t;\n}\n\nsub rotate { my($s,$n) = @_; join '', (split '', $s)[$n..length($s)-1, 0..$n-1] }\n\nsub \u026f\u0279o\u025fsu\u0250\u0279\u0287 {\n    my($s) = @_;\n    my @s = split '', $s;\n    my @t = sort @s;\n    map { @t = sort map { $s[$_] . $t[$_] } 0..length($s)-1 } 1..length($s)-1;\n    for (@t) {\n        next unless /${\\(STX)}$/;  \n        chop $_ and return $_\n    }\n}\n\nfor $phrase (qw<BANANA dogwood SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES>,\n    'TO BE OR NOT TO BE OR WANT TO BE OR NOT?') {\n    push @res, 'Original:            '. $phrase;\n    push @res, 'Transformed:         '. transform $phrase;\n    push @res, 'Inverse transformed: '. \u026f\u0279o\u025fsu\u0250\u0279\u0287 transform $phrase;\n    push @res, '';\n}\n\nprint join \"\\n\", @res;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 415678, "name": "Burrows\u2013Wheeler transform", "source": "Translate Perl to Java: use utf8;\nbinmode STDOUT, \":utf8\";\n\nuse constant STX => '\ud83d\udc4d ';\n\nsub transform {\n    my($s) = @_;\n    my($t);\n    warn \"String can't contain STX character.\" and exit if $s =~ /STX/;\n    $s = STX . $s;\n    $t .= substr($_,-1,1) for sort map { rotate($s,$_) } 1..length($s);\n    return $t;\n}\n\nsub rotate { my($s,$n) = @_; join '', (split '', $s)[$n..length($s)-1, 0..$n-1] }\n\nsub \u026f\u0279o\u025fsu\u0250\u0279\u0287 {\n    my($s) = @_;\n    my @s = split '', $s;\n    my @t = sort @s;\n    map { @t = sort map { $s[$_] . $t[$_] } 0..length($s)-1 } 1..length($s)-1;\n    for (@t) {\n        next unless /${\\(STX)}$/;  \n        chop $_ and return $_\n    }\n}\n\nfor $phrase (qw<BANANA dogwood SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES>,\n    'TO BE OR NOT TO BE OR WANT TO BE OR NOT?') {\n    push @res, 'Original:            '. $phrase;\n    push @res, 'Transformed:         '. transform $phrase;\n    push @res, 'Inverse transformed: '. \u026f\u0279o\u025fsu\u0250\u0279\u0287 transform $phrase;\n    push @res, '';\n}\n\nprint join \"\\n\", @res;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 415679, "name": "Card shuffles", "source": "Translate Perl to Java: sub overhand {\n    our @cards; local *cards = shift;\n    my(@splits,@shuffle);\n    my $x = int +@cards / 5;\n    push @splits, (1..$x)[int rand $x] for 1..+@cards;\n    while (@cards) {\n        push @shuffle, [splice @cards, 0, shift @splits];\n    }\n    @cards = flatten(reverse @shuffle);\n}\n\nsub flatten { map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_ }\n\nsub riffle {\n    our @cards; local *cards = shift;\n    splice @cards, @cards/2 - $_, 0, pop @cards for 0 .. (@cards/2)-1;\n}\n\n@cards = 1..20;\noverhand(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n\n@cards = 1..20;\nriffle(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class CardShuffles{\n\n\tprivate static final Random rand = new Random();\n\n\tpublic static <T> LinkedList<T> riffleShuffle(List<T> list, int flips){\n\t\tLinkedList<T> newList = new LinkedList<T>();\n\n\t\tnewList.addAll(list);\n\n\t\tfor(int n = 0; n < flips; n++){\n\t\t\t\n\t\t\tint cutPoint = newList.size() / 2 \n\t\t\t\t+ (rand.nextBoolean() ? -1 : 1 ) * rand.nextInt((int)(newList.size() * 0.1));\n\n\t\t\t\n\t\t\tList<T> left = new LinkedList<T>();\n\t\t\tleft.addAll(newList.subList(0, cutPoint));\n\t\t\tList<T> right = new LinkedList<T>();\n\t\t\tright.addAll(newList.subList(cutPoint, newList.size()));\n\n\t\t\tnewList.clear();\n\n\t\t\twhile(left.size() > 0 && right.size() > 0){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble() >= ((double)left.size() / right.size()) / 2){\n\t\t\t\t\tnewList.add(right.remove(0));\n\t\t\t\t}else{\n\t\t\t\t\tnewList.add(left.remove(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif(left.size() > 0) newList.addAll(left);\n\t\t\tif(right.size() > 0) newList.addAll(right);\n\t\t}\n\t\treturn newList;\n\t}\n\n\tpublic static <T> LinkedList<T> overhandShuffle(List<T> list, int passes){\n\t\tLinkedList<T> mainHand = new LinkedList<T>();\n\n\t\tmainHand.addAll(list);\n\t\tfor(int n = 0; n < passes; n++){\n\t\t\tLinkedList<T> otherHand = new LinkedList<T>();\n\n\t\t\twhile(mainHand.size() > 0){\n\t\t\t\t\n\t\t\t\tint cutSize = rand.nextInt((int)(list.size() * 0.2)) + 1;\n\n\t\t\t\tLinkedList<T> temp = new LinkedList<T>();\n\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < cutSize && mainHand.size() > 0; i++){\n\t\t\t\t\ttemp.add(mainHand.remove());\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble()  >= 0.1){\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(0, temp);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(temp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tmainHand = otherHand;\n\t\t}\t\t\n\t\treturn mainHand;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tList<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tCollections.shuffle(list);\n\t\tSystem.out.println(list + \"\\n\");\n\t}\n}\n"}
{"id": 415680, "name": "Card shuffles", "source": "Translate Perl to Java: sub overhand {\n    our @cards; local *cards = shift;\n    my(@splits,@shuffle);\n    my $x = int +@cards / 5;\n    push @splits, (1..$x)[int rand $x] for 1..+@cards;\n    while (@cards) {\n        push @shuffle, [splice @cards, 0, shift @splits];\n    }\n    @cards = flatten(reverse @shuffle);\n}\n\nsub flatten { map { ref $_ eq 'ARRAY' ? @$_ : $_ } @_ }\n\nsub riffle {\n    our @cards; local *cards = shift;\n    splice @cards, @cards/2 - $_, 0, pop @cards for 0 .. (@cards/2)-1;\n}\n\n@cards = 1..20;\noverhand(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n\n@cards = 1..20;\nriffle(\\@cards) for 1..10;\nprint join ' ', @cards, \"\\n\";\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Random;\n\npublic class CardShuffles{\n\n\tprivate static final Random rand = new Random();\n\n\tpublic static <T> LinkedList<T> riffleShuffle(List<T> list, int flips){\n\t\tLinkedList<T> newList = new LinkedList<T>();\n\n\t\tnewList.addAll(list);\n\n\t\tfor(int n = 0; n < flips; n++){\n\t\t\t\n\t\t\tint cutPoint = newList.size() / 2 \n\t\t\t\t+ (rand.nextBoolean() ? -1 : 1 ) * rand.nextInt((int)(newList.size() * 0.1));\n\n\t\t\t\n\t\t\tList<T> left = new LinkedList<T>();\n\t\t\tleft.addAll(newList.subList(0, cutPoint));\n\t\t\tList<T> right = new LinkedList<T>();\n\t\t\tright.addAll(newList.subList(cutPoint, newList.size()));\n\n\t\t\tnewList.clear();\n\n\t\t\twhile(left.size() > 0 && right.size() > 0){\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble() >= ((double)left.size() / right.size()) / 2){\n\t\t\t\t\tnewList.add(right.remove(0));\n\t\t\t\t}else{\n\t\t\t\t\tnewList.add(left.remove(0));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tif(left.size() > 0) newList.addAll(left);\n\t\t\tif(right.size() > 0) newList.addAll(right);\n\t\t}\n\t\treturn newList;\n\t}\n\n\tpublic static <T> LinkedList<T> overhandShuffle(List<T> list, int passes){\n\t\tLinkedList<T> mainHand = new LinkedList<T>();\n\n\t\tmainHand.addAll(list);\n\t\tfor(int n = 0; n < passes; n++){\n\t\t\tLinkedList<T> otherHand = new LinkedList<T>();\n\n\t\t\twhile(mainHand.size() > 0){\n\t\t\t\t\n\t\t\t\tint cutSize = rand.nextInt((int)(list.size() * 0.2)) + 1;\n\n\t\t\t\tLinkedList<T> temp = new LinkedList<T>();\n\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < cutSize && mainHand.size() > 0; i++){\n\t\t\t\t\ttemp.add(mainHand.remove());\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif(rand.nextDouble()  >= 0.1){\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(0, temp);\n\t\t\t\t}else{\n\t\t\t\t\t\n\t\t\t\t\totherHand.addAll(temp);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tmainHand = otherHand;\n\t\t}\t\t\n\t\treturn mainHand;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tList<Integer> list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = riffleShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 10);\n\t\tSystem.out.println(list + \"\\n\");\n\n                list = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tlist = overhandShuffle(list, 1);\n\t\tSystem.out.println(list + \"\\n\");\n\n\t\tlist = Arrays.asList(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20);\n\t\tSystem.out.println(list);\n\t\tCollections.shuffle(list);\n\t\tSystem.out.println(list + \"\\n\");\n\t}\n}\n"}
{"id": 415681, "name": "Faulhaber's triangle", "source": "Translate Perl to Java: use 5.010;\nuse List::Util qw(sum);\nuse Math::BigRat try => 'GMP';\nuse ntheory qw(binomial bernfrac);\n\nsub faulhaber_triangle {\n    my ($p) = @_;\n    map {\n        Math::BigRat->new(bernfrac($_))\n          * binomial($p, $_)\n          / $p\n    } reverse(0 .. $p-1);\n}\n\n\nforeach my $p (1 .. 10) {\n    say map { sprintf(\"%6s\", $_) } faulhaber_triangle($p);\n}\n\n\nmy $p = 17;\nmy $n = Math::BigInt->new(1000);\nmy @r = faulhaber_triangle($p+1);\nsay \"\\n\", sum(map { $r[$_] * $n**($_ + 1) } 0 .. $\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\n\npublic class FaulhabersTriangle {\n    private static final MathContext MC = new MathContext(256);\n\n    private static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private long num;\n        private long denom;\n\n        public static final Frac ZERO = new Frac(0, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) throw new IllegalArgumentException(\"d must not be zero\");\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            } else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.abs(gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(num * rhs.denom + denom * rhs.num, rhs.denom * denom);\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(-num, denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return this.plus(rhs.unaryMinus());\n        }\n\n        public Frac times(Frac rhs) {\n            return new Frac(this.num * rhs.num, this.denom * rhs.denom);\n        }\n\n        @Override\n        public int compareTo(Frac o) {\n            double diff = toDouble() - o.toDouble();\n            return Double.compare(diff, 0.0);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return null != obj && obj instanceof Frac && this.compareTo((Frac) obj) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom == 1) {\n                return Long.toString(num);\n            }\n            return String.format(\"%d/%d\", num, denom);\n        }\n\n        public double toDouble() {\n            return (double) num / denom;\n        }\n\n        public BigDecimal toBigDecimal() {\n            return BigDecimal.valueOf(num).divide(BigDecimal.valueOf(denom), MC);\n        }\n    }\n\n    private static Frac bernoulli(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n may not be negative or zero\");\n        Frac[] a = new Frac[n + 1];\n        Arrays.fill(a, Frac.ZERO);\n        for (int m = 0; m <= n; ++m) {\n            a[m] = new Frac(1, m + 1);\n            for (int j = m; j >= 1; --j) {\n                a[j - 1] = a[j - 1].minus(a[j]).times(new Frac(j, 1));\n            }\n        }\n        \n        if (n != 1) return a[0];\n        return a[0].unaryMinus();\n    }\n\n    private static long binomial(int n, int k) {\n        if (n < 0 || k < 0 || n < k) throw new IllegalArgumentException();\n        if (n == 0 || k == 0) return 1;\n        long num = LongStream.rangeClosed(k + 1, n).reduce(1, (a, b) -> a * b);\n        long den = LongStream.rangeClosed(2, n - k).reduce(1, (acc, i) -> acc * i);\n        return num / den;\n    }\n\n    private static Frac[] faulhaberTriangle(int p) {\n        Frac[] coeffs = new Frac[p + 1];\n        Arrays.fill(coeffs, Frac.ZERO);\n        Frac q = new Frac(1, p + 1);\n        int sign = -1;\n        for (int j = 0; j <= p; ++j) {\n            sign *= -1;\n            coeffs[p - j] = q.times(new Frac(sign, 1)).times(new Frac(binomial(p + 1, j), 1)).times(bernoulli(j));\n        }\n        return coeffs;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i <= 9; ++i) {\n            Frac[] coeffs = faulhaberTriangle(i);\n            for (Frac coeff : coeffs) {\n                System.out.printf(\"%5s  \", coeff);\n            }\n            System.out.println();\n        }\n        System.out.println();\n        \n        int k = 17;\n        Frac[] cc = faulhaberTriangle(k);\n        int n = 1000;\n        BigDecimal nn = BigDecimal.valueOf(n);\n        BigDecimal np = BigDecimal.ONE;\n        BigDecimal sum = BigDecimal.ZERO;\n        for (Frac c : cc) {\n            np = np.multiply(nn);\n            sum = sum.add(np.multiply(c.toBigDecimal()));\n        }\n        System.out.println(sum.toBigInteger());\n    }\n}\n"}
{"id": 415682, "name": "Paraffins", "source": "Translate Perl to Java: use Math::GMPz;\n\nmy $nmax = 250;\nmy $nbranches = 4;\n\nmy @rooted   = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @unrooted = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @c        = map { Math::GMPz->new(0) } 0 .. $nbranches-1;\n\nsub tree {\n  my($br, $n, $l, $sum, $cnt) = @_;\n  for my $b ($br+1 .. $nbranches) {\n    $sum += $n;\n    return if $sum > $nmax || ($l*2 >= $sum && $b >= $nbranches);\n    if ($b == $br+1) {\n      $c[$br] = $rooted[$n] * $cnt;\n    } else {\n      $c[$br] *= $rooted[$n] + $b - $br - 1;\n      $c[$br] /= $b - $br;\n    }\n    $unrooted[$sum] += $c[$br] if $l*2 < $sum;\n    return if $b >= $nbranches;\n    $rooted[$sum] += $c[$br];\n    for my $m (reverse 1 .. $n-1) {\n      next if $sum+$m > $nmax;\n      tree($b, $m, $l, $sum, $c[$br]);\n    }\n  }\n}\n\nsub bicenter {\n  my $s = shift;\n  $unrooted[$s] += $rooted[$s/2] * ($rooted[$s/2]+1) / 2  unless $s & 1;\n}\n\nfor my $n (1 .. $nmax) {\n  tree(0, $n, $n, 1, Math::GMPz->new(1));\n  bicenter($n);\n  print \"$n: $unrooted[$n]\\n\";\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}\n"}
{"id": 415683, "name": "Paraffins", "source": "Translate Perl to Java: use Math::GMPz;\n\nmy $nmax = 250;\nmy $nbranches = 4;\n\nmy @rooted   = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @unrooted = map { Math::GMPz->new($_) } 1,1,(0) x $nmax;\nmy @c        = map { Math::GMPz->new(0) } 0 .. $nbranches-1;\n\nsub tree {\n  my($br, $n, $l, $sum, $cnt) = @_;\n  for my $b ($br+1 .. $nbranches) {\n    $sum += $n;\n    return if $sum > $nmax || ($l*2 >= $sum && $b >= $nbranches);\n    if ($b == $br+1) {\n      $c[$br] = $rooted[$n] * $cnt;\n    } else {\n      $c[$br] *= $rooted[$n] + $b - $br - 1;\n      $c[$br] /= $b - $br;\n    }\n    $unrooted[$sum] += $c[$br] if $l*2 < $sum;\n    return if $b >= $nbranches;\n    $rooted[$sum] += $c[$br];\n    for my $m (reverse 1 .. $n-1) {\n      next if $sum+$m > $nmax;\n      tree($b, $m, $l, $sum, $c[$br]);\n    }\n  }\n}\n\nsub bicenter {\n  my $s = shift;\n  $unrooted[$s] += $rooted[$s/2] * ($rooted[$s/2]+1) / 2  unless $s & 1;\n}\n\nfor my $n (1 .. $nmax) {\n  tree(0, $n, $n, 1, Math::GMPz->new(1));\n  bicenter($n);\n  print \"$n: $unrooted[$n]\\n\";\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}\n"}
{"id": 415684, "name": "NYSIIS", "source": "Translate Perl to Java: sub no_suffix {\n    my($name) = @_;\n    $name =~ s/\\h([JS]R)|([IVX]+)$//i;\n    return uc $name;\n}\n\nsub nysiis {\n    my($name) = @_;\n    local($_) = uc $name;\n\n    s/[^A-Z]//g;\n    s/^MAC/MCC/;\n    s/^P[FH]/FF/;\n    s/^SCH/SSS/;\n    s/^KN/N/;\n    s/[IE]E$/Y/;\n    s/[DRN]T$/D/;\n    s/[RN]D$/D/;\n    s/(.)EV/$1AF/g;\n    s/(.)[AEIOU]+/$1A/g;\n    s/(.)Q/$1G/g;\n    s/(.)Z/$1S/g;\n    s/(.)M/$1N/g;\n    s/(.)KN/$1N/g;\n    s/(.)K/$1C/g;\n    s/(.)SCH/$1S/g;\n    s/(.)PF/$1F/g;\n    s/(.)K/$1C/g;\n    s/(.)H([^AEIOU])/$1$2/g;\n    s/([^AEIOU])H/$1/g;\n    s/(.)W/$1/g;\n    s/AY$/Y/;\n    s/S$//;\n    s/A$//;\n    s/(.)\\1+/$1/g;\n    return $_;\n}\n\nfor (\n    \"knight\",     \"mitchell\",  \"o'daniel\",    \"brown sr\",   \"browne III\",\n    \"browne IV\",  \"O'Banion\",  \"Mclaughlin\",  \"McCormack\",  \"Chapman\",\n    \"Silva\",      \"McDonald\",  \"Lawson\",      \"Jacobs\",     \"Greene\",\n    \"O'Brien\",    \"Morrison\",  \"Larson\",      \"Willis\",     \"Mackenzie\",\n    \"Carr\",       \"Lawrence\",  \"Matthews\",    \"Richards\",   \"Bishop\",\n    \"Franklin\",   \"McDaniel\",  \"Harper\",      \"Lynch\",      \"Watkins\",\n    \"Carlson\",    \"Wheeler\",   \"Louis XVI\"\n) {\n    my $nysiis = nysiis no_suffix $_;\n    $nysiis =~ s/^(......)(.*)$/$1\\[$2\\]/ if length($nysiis) > 6;\n    printf \"%10s,  %s\\n\", $_, $nysiis;\n}\n", "target": "import static java.util.Arrays.*;\nimport static java.lang.System.out;\n\npublic class NYSIIS {\n\n    final static String[][] first = {{\"MAC\", \"MCC\"}, {\"KN\", \"N\"}, {\"K\", \"C\"},\n    {\"PH\", \"FF\"}, {\"PF\", \"FF\"}, {\"SCH\", \"SSS\"}};\n\n    final static String[][] last = {{\"EE\", \"Y\"}, {\"IE\", \"Y\"}, {\"DT\", \"D\"},\n    {\"RT\", \"D\"}, {\"RD\", \"D\"}, {\"NT\", \"D\"}, {\"ND\", \"D\"}};\n\n    final static String Vowels = \"AEIOU\";\n\n    public static void main(String[] args) {\n        stream(args).parallel().map(n -> transcode(n)).forEach(out::println);\n    }\n\n    static String transcode(String s) {\n        int len = s.length();\n        StringBuilder sb = new StringBuilder(len);\n\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (c >= 'a' && c <= 'z')\n                sb.append((char) (c - 32));\n            else if (c >= 'A' && c <= 'Z')\n                sb.append(c);\n        }\n\n        replace(sb, 0, first);\n        replace(sb, sb.length() - 2, last);\n\n        len = sb.length();\n        sb.append(\" \");\n        for (int i = 1; i < len; i++) {\n            char prev = sb.charAt(i - 1);\n            char curr = sb.charAt(i);\n            char next = sb.charAt(i + 1);\n\n            if (curr == 'E' && next == 'V')\n                sb.replace(i, i + 2, \"AF\");\n\n            else if (isVowel(curr))\n                sb.setCharAt(i, 'A');\n\n            else if (curr == 'Q')\n                sb.setCharAt(i, 'G');\n\n            else if (curr == 'Z')\n                sb.setCharAt(i, 'S');\n\n            else if (curr == 'M')\n                sb.setCharAt(i, 'N');\n\n            else if (curr == 'K' && next == 'N')\n                sb.setCharAt(i, 'N');\n\n            else if (curr == 'K')\n                sb.setCharAt(i, 'C');\n\n            else if (sb.indexOf(\"SCH\", i) == i)\n                sb.replace(i, i + 3, \"SSS\");\n\n            else if (curr == 'P' && next == 'H')\n                sb.replace(i, i + 2, \"FF\");\n\n            else if (curr == 'H' && (!isVowel(prev) || !isVowel(next)))\n                sb.setCharAt(i, prev);\n\n            else if (curr == 'W' && isVowel(prev))\n                sb.setCharAt(i, prev);\n\n            if (sb.charAt(i) == prev) {\n                sb.deleteCharAt(i--);\n                len--;\n            }\n        }\n        sb.setLength(sb.length() - 1); \n\n        int lastPos = sb.length() - 1;\n        if (lastPos > 1) {\n\n            if (sb.lastIndexOf(\"AY\") == lastPos - 1)\n                sb.delete(lastPos - 1, lastPos + 1).append(\"Y\");\n\n            else if (sb.charAt(lastPos) == 'S')\n                sb.setLength(lastPos);\n\n            else if (sb.charAt(lastPos) == 'A')\n                sb.setLength(lastPos);\n        }\n\n        if (sb.length() > 6)\n            sb.insert(6, '[').append(']');\n\n        return String.format(\"%s -> %s\", s, sb);\n    }\n\n    private static void replace(StringBuilder sb, int start, String[][] maps) {\n        if (start >= 0)\n            for (String[] map : maps) {\n                if (sb.indexOf(map[0]) == start) {\n                    sb.replace(start, start + map[0].length(), map[1]);\n                    break;\n                }\n            }\n    }\n\n    private static boolean isVowel(char c) {\n        return Vowels.indexOf(c) != -1;\n    }\n}\n"}
{"id": 415685, "name": "NYSIIS", "source": "Translate Perl to Java: sub no_suffix {\n    my($name) = @_;\n    $name =~ s/\\h([JS]R)|([IVX]+)$//i;\n    return uc $name;\n}\n\nsub nysiis {\n    my($name) = @_;\n    local($_) = uc $name;\n\n    s/[^A-Z]//g;\n    s/^MAC/MCC/;\n    s/^P[FH]/FF/;\n    s/^SCH/SSS/;\n    s/^KN/N/;\n    s/[IE]E$/Y/;\n    s/[DRN]T$/D/;\n    s/[RN]D$/D/;\n    s/(.)EV/$1AF/g;\n    s/(.)[AEIOU]+/$1A/g;\n    s/(.)Q/$1G/g;\n    s/(.)Z/$1S/g;\n    s/(.)M/$1N/g;\n    s/(.)KN/$1N/g;\n    s/(.)K/$1C/g;\n    s/(.)SCH/$1S/g;\n    s/(.)PF/$1F/g;\n    s/(.)K/$1C/g;\n    s/(.)H([^AEIOU])/$1$2/g;\n    s/([^AEIOU])H/$1/g;\n    s/(.)W/$1/g;\n    s/AY$/Y/;\n    s/S$//;\n    s/A$//;\n    s/(.)\\1+/$1/g;\n    return $_;\n}\n\nfor (\n    \"knight\",     \"mitchell\",  \"o'daniel\",    \"brown sr\",   \"browne III\",\n    \"browne IV\",  \"O'Banion\",  \"Mclaughlin\",  \"McCormack\",  \"Chapman\",\n    \"Silva\",      \"McDonald\",  \"Lawson\",      \"Jacobs\",     \"Greene\",\n    \"O'Brien\",    \"Morrison\",  \"Larson\",      \"Willis\",     \"Mackenzie\",\n    \"Carr\",       \"Lawrence\",  \"Matthews\",    \"Richards\",   \"Bishop\",\n    \"Franklin\",   \"McDaniel\",  \"Harper\",      \"Lynch\",      \"Watkins\",\n    \"Carlson\",    \"Wheeler\",   \"Louis XVI\"\n) {\n    my $nysiis = nysiis no_suffix $_;\n    $nysiis =~ s/^(......)(.*)$/$1\\[$2\\]/ if length($nysiis) > 6;\n    printf \"%10s,  %s\\n\", $_, $nysiis;\n}\n", "target": "import static java.util.Arrays.*;\nimport static java.lang.System.out;\n\npublic class NYSIIS {\n\n    final static String[][] first = {{\"MAC\", \"MCC\"}, {\"KN\", \"N\"}, {\"K\", \"C\"},\n    {\"PH\", \"FF\"}, {\"PF\", \"FF\"}, {\"SCH\", \"SSS\"}};\n\n    final static String[][] last = {{\"EE\", \"Y\"}, {\"IE\", \"Y\"}, {\"DT\", \"D\"},\n    {\"RT\", \"D\"}, {\"RD\", \"D\"}, {\"NT\", \"D\"}, {\"ND\", \"D\"}};\n\n    final static String Vowels = \"AEIOU\";\n\n    public static void main(String[] args) {\n        stream(args).parallel().map(n -> transcode(n)).forEach(out::println);\n    }\n\n    static String transcode(String s) {\n        int len = s.length();\n        StringBuilder sb = new StringBuilder(len);\n\n        for (int i = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (c >= 'a' && c <= 'z')\n                sb.append((char) (c - 32));\n            else if (c >= 'A' && c <= 'Z')\n                sb.append(c);\n        }\n\n        replace(sb, 0, first);\n        replace(sb, sb.length() - 2, last);\n\n        len = sb.length();\n        sb.append(\" \");\n        for (int i = 1; i < len; i++) {\n            char prev = sb.charAt(i - 1);\n            char curr = sb.charAt(i);\n            char next = sb.charAt(i + 1);\n\n            if (curr == 'E' && next == 'V')\n                sb.replace(i, i + 2, \"AF\");\n\n            else if (isVowel(curr))\n                sb.setCharAt(i, 'A');\n\n            else if (curr == 'Q')\n                sb.setCharAt(i, 'G');\n\n            else if (curr == 'Z')\n                sb.setCharAt(i, 'S');\n\n            else if (curr == 'M')\n                sb.setCharAt(i, 'N');\n\n            else if (curr == 'K' && next == 'N')\n                sb.setCharAt(i, 'N');\n\n            else if (curr == 'K')\n                sb.setCharAt(i, 'C');\n\n            else if (sb.indexOf(\"SCH\", i) == i)\n                sb.replace(i, i + 3, \"SSS\");\n\n            else if (curr == 'P' && next == 'H')\n                sb.replace(i, i + 2, \"FF\");\n\n            else if (curr == 'H' && (!isVowel(prev) || !isVowel(next)))\n                sb.setCharAt(i, prev);\n\n            else if (curr == 'W' && isVowel(prev))\n                sb.setCharAt(i, prev);\n\n            if (sb.charAt(i) == prev) {\n                sb.deleteCharAt(i--);\n                len--;\n            }\n        }\n        sb.setLength(sb.length() - 1); \n\n        int lastPos = sb.length() - 1;\n        if (lastPos > 1) {\n\n            if (sb.lastIndexOf(\"AY\") == lastPos - 1)\n                sb.delete(lastPos - 1, lastPos + 1).append(\"Y\");\n\n            else if (sb.charAt(lastPos) == 'S')\n                sb.setLength(lastPos);\n\n            else if (sb.charAt(lastPos) == 'A')\n                sb.setLength(lastPos);\n        }\n\n        if (sb.length() > 6)\n            sb.insert(6, '[').append(']');\n\n        return String.format(\"%s -> %s\", s, sb);\n    }\n\n    private static void replace(StringBuilder sb, int start, String[][] maps) {\n        if (start >= 0)\n            for (String[] map : maps) {\n                if (sb.indexOf(map[0]) == start) {\n                    sb.replace(start, start + map[0].length(), map[1]);\n                    break;\n                }\n            }\n    }\n\n    private static boolean isVowel(char c) {\n        return Vowels.indexOf(c) != -1;\n    }\n}\n"}
{"id": 415686, "name": "Faulhaber's formula", "source": "Translate Perl to Java: use 5.014;\nuse Math::Algebra::Symbols;\n\nsub bernoulli_number {\n    my ($n) = @_;\n\n    return 0 if $n > 1 && $n % 2;\n\n    my @A;\n    for my $m (0 .. $n) {\n        $A[$m] = symbols(1) / ($m + 1);\n\n        for (my $j = $m ; $j > 0 ; $j--) {\n            $A[$j - 1] = $j * ($A[$j - 1] - $A[$j]);\n        }\n    }\n\n    return $A[0];\n}\n\nsub binomial {\n    my ($n, $k) = @_;\n    return 1 if $k == 0 || $n == $k;\n    binomial($n - 1, $k - 1) + binomial($n - 1, $k);\n}\n\nsub faulhaber_s_formula {\n    my ($p) = @_;\n\n    my $formula = 0;\n    for my $j (0 .. $p) {\n        $formula += binomial($p + 1, $j)\n                 *  bernoulli_number($j)\n                 *  symbols('n')**($p + 1 - $j);\n    }\n\n    (symbols(1) / ($p + 1) * $formula)\n        =~ s/\\$n/n/gr =~ s/\\*\\*/^/gr =~ s/\\*/ /gr;\n}\n\nforeach my $i (0 .. 9) {\n    say \"$i: \", faulhaber_s_formula($i);\n}\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class FaulhabersFormula {\n    private static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private long num;\n        private long denom;\n\n        public static final Frac ZERO = new Frac(0, 1);\n        public static final Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) throw new IllegalArgumentException(\"d must not be zero\");\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            } else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.abs(gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(num * rhs.denom + denom * rhs.num, rhs.denom * denom);\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(-num, denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return this.plus(rhs.unaryMinus());\n        }\n\n        public Frac times(Frac rhs) {\n            return new Frac(this.num * rhs.num, this.denom * rhs.denom);\n        }\n\n        @Override\n        public int compareTo(Frac o) {\n            double diff = toDouble() - o.toDouble();\n            return Double.compare(diff, 0.0);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return null != obj && obj instanceof Frac && this.compareTo((Frac) obj) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom == 1) {\n                return Long.toString(num);\n            }\n            return String.format(\"%d/%d\", num, denom);\n        }\n\n        private double toDouble() {\n            return (double) num / denom;\n        }\n    }\n\n    private static Frac bernoulli(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n may not be negative or zero\");\n        Frac[] a = new Frac[n + 1];\n        Arrays.fill(a, Frac.ZERO);\n        for (int m = 0; m <= n; ++m) {\n            a[m] = new Frac(1, m + 1);\n            for (int j = m; j >= 1; --j) {\n                a[j - 1] = a[j - 1].minus(a[j]).times(new Frac(j, 1));\n            }\n        }\n        \n        if (n != 1) return a[0];\n        return a[0].unaryMinus();\n    }\n\n    private static int binomial(int n, int k) {\n        if (n < 0 || k < 0 || n < k) throw new IllegalArgumentException();\n        if (n == 0 || k == 0) return 1;\n        int num = IntStream.rangeClosed(k + 1, n).reduce(1, (a, b) -> a * b);\n        int den = IntStream.rangeClosed(2, n - k).reduce(1, (acc, i) -> acc * i);\n        return num / den;\n    }\n\n    private static void faulhaber(int p) {\n        System.out.printf(\"%d\u00a0: \", p);\n        Frac q = new Frac(1, p + 1);\n        int sign = -1;\n        for (int j = 0; j <= p; ++j) {\n            sign *= -1;\n            Frac coeff = q.times(new Frac(sign, 1)).times(new Frac(binomial(p + 1, j), 1)).times(bernoulli(j));\n            if (Frac.ZERO.equals(coeff)) continue;\n            if (j == 0) {\n                if (!Frac.ONE.equals(coeff)) {\n                    if (Frac.ONE.unaryMinus().equals(coeff)) {\n                        System.out.print(\"-\");\n                    } else {\n                        System.out.print(coeff);\n                    }\n                }\n            } else {\n                if (Frac.ONE.equals(coeff)) {\n                    System.out.print(\" + \");\n                } else if (Frac.ONE.unaryMinus().equals(coeff)) {\n                    System.out.print(\" - \");\n                } else if (coeff.compareTo(Frac.ZERO) > 0) {\n                    System.out.printf(\" + %s\", coeff);\n                } else {\n                    System.out.printf(\" - %s\", coeff.unaryMinus());\n                }\n            }\n            int pwr = p + 1 - j;\n            if (pwr > 1)\n                System.out.printf(\"n^%d\", pwr);\n            else\n                System.out.print(\"n\");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i <= 9; ++i) {\n            faulhaber(i);\n        }\n    }\n}\n"}
{"id": 415687, "name": "Active Directory_Search for a user", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nuse Net::LDAP;\n\nmy $ldap = Net::LDAP->new( 'ldap://ldap.forumsys.com' )  or  die \"$@\";\n\nmy $mesg = $ldap->bind( \"cn=read-only-admin,dc=example,dc=com\",\n                        password => \"password\"                  );\n              \n$mesg->code and die $mesg->error;\n\nmy $srch = $ldap->search( base   => \"dc=example,dc=com\",\n                          filter => \"(|(uid=gauss))\"     );\n\n$srch->code and die $srch->error;\n\nforeach my $entry ($srch->entries) { $entry->dump }\n\n$mesg = $ldap->unbind;\n", "target": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.cursor.CursorException;\nimport org.apache.directory.api.ldap.model.cursor.EntryCursor;\nimport org.apache.directory.api.ldap.model.entry.Entry;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.api.ldap.model.message.SearchScope;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapSearchDemo {\n\n    public static void main(String[] args) throws IOException, LdapException, CursorException {\n        new LdapSearchDemo().demonstrateSearch();\n    }\n\n    private void demonstrateSearch() throws IOException, LdapException, CursorException {\n        try (LdapConnection conn = new LdapNetworkConnection(\"localhost\", 11389)) {\n            conn.bind(\"uid=admin,ou=system\", \"********\");\n            search(conn, \"*mil*\");\n            conn.unBind();\n        }\n    }\n\n    private void search(LdapConnection connection, String uid) throws LdapException, CursorException {\n        String baseDn = \"ou=users,o=mojo\";\n        String filter = \"(&(objectClass=person)(&(uid=\" + uid + \")))\";\n        SearchScope scope = SearchScope.SUBTREE;\n        String[] attributes = {\"dn\", \"cn\", \"sn\", \"uid\"};\n        int ksearch = 0;\n\n        EntryCursor cursor = connection.search(baseDn, filter, scope, attributes);\n        while (cursor.next()) {\n            ksearch++;\n            Entry entry = cursor.get();\n            System.out.printf(\"Search entry %d = %s%n\", ksearch, entry);\n        }\n    }\n}\n"}
{"id": 415688, "name": "Prime conspiracy", "source": "Translate Perl to Java: use ntheory qw/forprimes nth_prime/;\n\nmy $upto = 1_000_000;\nmy %freq;\nmy($this_digit,$last_digit)=(2,0);\n\nforprimes {\n  ($last_digit,$this_digit) = ($this_digit, $_ % 10);\n  $freq{$last_digit . $this_digit}++;\n} 3,nth_prime($upto);\n\nprint \"$upto first primes.  Transitions prime\u00a0% 10 \u2192 next-prime\u00a0% 10.\\n\";\nprintf \"%s \u2192 %s count:\\t%7d\\tfrequency: %4.2f\u00a0%%\\n\",\n  substr($_,0,1), substr($_,1,1), $freq{$_}, 100*$freq{$_}/$upto\n    for sort keys %freq;\n", "target": "public class PrimeConspiracy {\n\n    public static void main(String[] args) {\n        final int limit = 1000_000;\n        final int sieveLimit = 15_500_000;\n\n        int[][] buckets = new int[10][10];\n        int prevDigit = 2;\n        boolean[] notPrime = sieve(sieveLimit);\n\n        for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n            if (notPrime[n])\n                continue;\n\n            int digit = n % 10;\n            buckets[prevDigit][digit]++;\n            prevDigit = digit;\n            primeCount++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (buckets[i][j] != 0) {\n                    System.out.printf(\"%d -> %d\u00a0: %2f%n\", i,\n                            j, buckets[i][j] / (limit / 100.0));\n                }\n            }\n        }\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 415689, "name": "List rooted trees", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub bagchain {\n    my($x, $n, $bb, $start) = @_;\n    return [@$x] unless $n;\n\n    my @sets;\n    $start //= 0;\n    for my $i ($start .. @$bb-1) {\n        my($c, $s) = @{$$bb[$i]};\n        push @sets, bagchain([$$x[0] + $c, $$x[1] . $s], $n-$c, $bb, $i) if $c <= $n\n    }\n    @sets\n}\n\nsub bags {\n    my($n) = @_;\n    return [0, ''] unless $n;\n\n    my(@upto,@sets);\n    push @upto, bags($_) for reverse 1 .. $n-1;\n    for ( bagchain([0, ''], $n-1, \\@upto) ) {\n        my($c,$s) = @$_;\n        push @sets, [$c+1, '(' . $s . ')']\n    }\n    @sets;\n}\n\nsub replace_brackets {\n    my $bags;\n    my $depth = 0;\n    for my $b (split //, $_[0]) {\n        if ($b eq '(') { $bags .= (qw<( [ {>)[$depth++ % 3] }\n        else           { $bags .= (qw<) ] }>)[--$depth % 3] }\n    }\n    $bags\n}\n\nsay replace_brackets $$_[1] for bags(5);\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListRootedTrees {\n    private static final List<Long> TREE_LIST = new ArrayList<>();\n\n    private static final List<Integer> OFFSET = new ArrayList<>();\n\n    static {\n        for (int i = 0; i < 32; i++) {\n            if (i == 1) {\n                OFFSET.add(1);\n            } else {\n                OFFSET.add(0);\n            }\n        }\n    }\n\n    private static void append(long t) {\n        TREE_LIST.add(1 | (t << 1));\n    }\n\n    private static void show(long t, int l) {\n        while (l-- > 0) {\n            if (t % 2 == 1) {\n                System.out.print('(');\n            } else {\n                System.out.print(')');\n            }\n            t = t >> 1;\n        }\n    }\n\n    private static void listTrees(int n) {\n        for (int i = OFFSET.get(n); i < OFFSET.get(n + 1); i++) {\n            show(TREE_LIST.get(i), n * 2);\n            System.out.println();\n        }\n    }\n\n    private static void assemble(int n, long t, int sl, int pos, int rem) {\n        if (rem == 0) {\n            append(t);\n            return;\n        }\n\n        var pp = pos;\n        var ss = sl;\n\n        if (sl > rem) {\n            ss = rem;\n            pp = OFFSET.get(ss);\n        } else if (pp >= OFFSET.get(ss + 1)) {\n            ss--;\n            if (ss == 0) {\n                return;\n            }\n            pp = OFFSET.get(ss);\n        }\n\n        assemble(n, t << (2 * ss) | TREE_LIST.get(pp), ss, pp, rem - ss);\n        assemble(n, t, ss, pp + 1, rem);\n    }\n\n    private static void makeTrees(int n) {\n        if (OFFSET.get(n + 1) != 0) {\n            return;\n        }\n        if (n > 0) {\n            makeTrees(n - 1);\n        }\n        assemble(n, 0, n - 1, OFFSET.get(n - 1), n - 1);\n        OFFSET.set(n + 1, TREE_LIST.size());\n    }\n\n    private static void test(int n) {\n        if (n < 1 || n > 12) {\n            throw new IllegalArgumentException(\"Argument must be between 1 and 12\");\n        }\n\n        append(0);\n\n        makeTrees(n);\n        System.out.printf(\"Number of %d-trees: %d\\n\", n, OFFSET.get(n + 1) - OFFSET.get(n));\n        listTrees(n);\n    }\n\n    public static void main(String[] args) {\n        test(5);\n    }\n}\n"}
{"id": 415690, "name": "Lucky and even lucky numbers", "source": "Translate Perl to Java: use Perl6::GatherTake;\n\nsub luck {\nmy($a,$b) = @_;\n\ngather {\n    my $i = $b;\n    my(@taken,@rotor,$j);\n\n    take 0; \n    push @taken, take $a;\n\n    while () {\n        for ($j = 0; $j < @rotor; $j++) {\n            --$rotor[$j] or last;\n        }\n        if ($j < @rotor) {\n            $rotor[$j] = $taken[$j+1];\n        }\n        else {\n            take $i;\n            push @taken, $i;\n            push @rotor, $i - @taken;\n        }\n        $i += 2;\n    }\n}\n}\n\n\n$j = shift || usage();\n$k = shift || ',';\n$l = shift || 'lucky';\nusage() unless $k =~ /,|-?\\d+/;\nusage() unless $l =~ /^(even)?lucky$/i;\nsub usage { print \"Args must be:  j [,|k|-k] [lucky|evenlucky]\\n\" and exit }\n\n\nmy $lucky = $l =~ /^l/i ? luck(1,3) : luck(2,4);\n\n\nif ($k eq ',') {\n    print $lucky->[$j]\n} elsif ($k > $j) {\n    print $lucky->[$_] . ' ' for $j..$k\n} elsif ($k < 0) {\n    while () { last if abs($k) < $lucky->[$i++] } \n    print join ' ', grep { $_ >= $j and $_ <= abs($k) } @$lucky\n}\n\nprint \"\\n\"\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class LuckyNumbers {\n\n    private static int MAX = 200000;\n    private static List<Integer> luckyEven = luckyNumbers(MAX, true);\n    private static List<Integer> luckyOdd = luckyNumbers(MAX, false);\n    \n    public static void main(String[] args) {\n        \n        if ( args.length == 1 || ( args.length == 2 && args[1].compareTo(\"lucky\") == 0 ) ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"LuckyNumber(%d) = %d%n\", n, luckyOdd.get(n-1));\n        }\n        \n        else if ( args.length == 2 && args[1].compareTo(\"evenLucky\") == 0 ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"EvenLuckyNumber(%d) = %d%n\", n, luckyEven.get(n-1));            \n        }\n        \n        else if ( args.length == 2 || args.length == 3 ) {\n            int j = Integer.parseInt(args[0]);\n            int k = Integer.parseInt(args[1]);\n            \n            if ( ( args.length == 2 && k > 0 ) || (args.length == 3 && k > 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                System.out.printf(\"LuckyNumber(%d) through LuckyNumber(%d) = %s%n\", j, k, luckyOdd.subList(j-1, k));\n            }\n            \n            else if ( args.length == 3 && k > 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                System.out.printf(\"EvenLuckyNumber(%d) through EvenLuckyNumber(%d) = %s%n\", j, k, luckyEven.subList(j-1, k));\n            }\n            \n            else if ( ( args.length == 2 && k < 0 ) || (args.length == 3 && k < 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                int n = Collections.binarySearch(luckyOdd, j);\n                int m = Collections.binarySearch(luckyOdd, -k);\n                System.out.printf(\"Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyOdd.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n            \n            else if ( args.length == 3 && k < 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                int n = Collections.binarySearch(luckyEven, j);\n                int m = Collections.binarySearch(luckyEven, -k);\n                System.out.printf(\"Even Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyEven.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n        }\n    }\n    \n    private static List<Integer> luckyNumbers(int max, boolean even) {\n        List<Integer> luckyList = new ArrayList<>();\n        for ( int i = even ? 2 : 1 ; i <= max ; i += 2 ) {\n            luckyList.add(i);\n        }\n        int start = 1;\n        boolean removed = true;\n        while ( removed ) {\n            removed = false;\n            int increment = luckyList.get(start);\n            List<Integer> remove = new ArrayList<>();\n            for ( int i = increment-1 ; i < luckyList.size() ; i += increment ) {\n                remove.add(0, i);\n                removed = true;\n            }\n            for ( int i : remove ) {\n                luckyList.remove(i);\n            }\n            start++;\n        }\n        return luckyList;\n    }\n\n}\n"}
{"id": 415691, "name": "Imaginary base numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse Math::Complex;\nuse List::AllUtils qw(sum mesh);\nuse ntheory qw<todigitstring fromdigits>;\n\nsub zip {\n    my($a,$b) = @_;\n    my($la, $lb) = (length $a, length $b);\n    my $l = '0' x abs $la - $lb;\n    $a .= $l if $la < $lb;\n    $b .= $l if $lb < $la;\n    (join('', mesh(@{[split('',$a),]}, @{[split('',$b),]})) =~ s/0+$//r) or 0;\n}\n\nsub base_i {\n    my($num,$radix,$precision) = @_;\n    die unless $radix > -37 and $radix < -1;\n    return '0' unless $num;\n    my $value  = $num;\n    my $result = '';\n    my $place  = 0;\n    my $upper_bound = 1 / (-$radix + 1);\n    my $lower_bound = $radix * $upper_bound;\n\n    $value = $num / $radix ** ++$place until $lower_bound <= $value and $value < $upper_bound;\n\n    while (($value or $place > 0) and $place > $precision) {\n        my $digit = int $radix * $value - $lower_bound;\n        $value    =  $radix * $value - $digit;\n        $result  .= '.' unless $place or not index($result, '.');\n        $result  .= $digit == -$radix ? todigitstring($digit-1, -$radix) . '0' : (todigitstring($digit, -$radix) or '0');\n        $place--;\n    }\n    $result\n}\n\nsub base_c {\n    my($num, $radix, $precision) = @_;\n    die \"Base $radix out of range\" unless\n        (-6 <= $radix->Im or $radix->Im <= -2) or (2 <= $radix->Im or $radix->Im <= 6);\n    my ($re,$im);\n    defined $num->Im ? ($re, $im) = ($num->Re, $num->Im) : $re = $num;\n    my ($re_wh, $re_fr) = split /\\./, base_i(  $re,               -1 * int($radix->Im**2), $precision);\n    my ($im_wh, $im_fr) = split /\\./, base_i( ($im/($radix->Im)), -1 * int($radix->Im**2), $precision);\n    $_ //= '' for $re_fr, $im_fr;\n\n    my $whole = reverse zip scalar reverse($re_wh), scalar reverse($im_wh);\n    my $fraction = zip $im_fr, $re_fr;\n    $fraction eq 0 ? \"$whole\" : \"$whole.$fraction\"\n}\n\nsub parse_base {\n    my($str, $radix) = @_;\n    return -1 * parse_base( substr($str,1), $radix) if substr($str,0,1) eq '-';\n    my($whole, $frac) = split /\\./, $str;\n    my $fraction = 0;\n    my $k = 0;\n    $fraction = sum map { (fromdigits($_, int $radix->Im**2) || 0) * $radix ** -($k++ +1) } split '', $frac\n        if $frac;\n    $k = 0;\n    $fraction + sum map { (fromdigits($_, int $radix->Im**2) || 0) * $radix ** $k++  } reverse split '', $whole;\n}\n\nfor (\n    [  0*i,  2*i], [1+0*i,  2*i], [5+0*i,      2*i], [ -13+0*i, 2*i],\n    [  9*i,  2*i], [ -3*i,  2*i], [7.75-7.5*i, 2*i], [0.25+0*i, 2*i],\n    [5+5*i,  2*i], [5+5*i,  3*i], [5+5*i,  4*i], [5+5*i,  5*i], [5+5*i,  6*i],\n    [5+5*i, -2*i], [5+5*i, -3*i], [5+5*i, -4*i], [5+5*i, -5*i], [5+5*i, -6*i]\n) {\n    my($v,$r) = @$_;\n    my $ibase = base_c($v, $r, -6);\n    my $rt = cplx parse_base($ibase, $r);\n    $rt->display_format('format' => '%.2f');\n    printf \"base(%3s): %10s  => %9s  => %13s\\n\", $r, $v, $ibase, $rt;\n}\n\nsay '';\nsay 'base( 6i): 31432.6219135802-2898.5266203704*i => ' .\n         base_c(31432.6219135802-2898.5266203704*i, 0+6*i, -3);\n", "target": "public class ImaginaryBaseNumber {\n    private static class Complex {\n        private Double real, imag;\n\n        public Complex(double r, double i) {\n            this.real = r;\n            this.imag = i;\n        }\n\n        public Complex(int r, int i) {\n            this.real = (double) r;\n            this.imag = (double) i;\n        }\n\n        public Complex add(Complex rhs) {\n            return new Complex(\n                real + rhs.real,\n                imag + rhs.imag\n            );\n        }\n\n        public Complex times(Complex rhs) {\n            return new Complex(\n                real * rhs.real - imag * rhs.imag,\n                real * rhs.imag + imag * rhs.real\n            );\n        }\n\n        public Complex times(double rhs) {\n            return new Complex(\n                real * rhs,\n                imag * rhs\n            );\n        }\n\n        public Complex inv() {\n            double denom = real * real + imag * imag;\n            return new Complex(\n                real / denom,\n                -imag / denom\n            );\n        }\n\n        public Complex unaryMinus() {\n            return new Complex(-real, -imag);\n        }\n\n        public Complex divide(Complex rhs) {\n            return this.times(rhs.inv());\n        }\n\n        \n        public QuaterImaginary toQuaterImaginary() {\n            if (real == 0.0 && imag == 0.0) return new QuaterImaginary(\"0\");\n            int re = real.intValue();\n            int im = imag.intValue();\n            int fi = -1;\n            StringBuilder sb = new StringBuilder();\n            while (re != 0) {\n                int rem = re % -4;\n                re /= -4;\n                if (rem < 0) {\n                    rem += 4;\n                    re++;\n                }\n                sb.append(rem);\n                sb.append(0);\n            }\n            if (im != 0) {\n                Double f = new Complex(0.0, imag).divide(new Complex(0.0, 2.0)).real;\n                im = ((Double) Math.ceil(f)).intValue();\n                f = -4.0 * (f - im);\n                int index = 1;\n                while (im != 0) {\n                    int rem = im % -4;\n                    im /= -4;\n                    if (rem < 0) {\n                        rem += 4;\n                        im++;\n                    }\n                    if (index < sb.length()) {\n                        sb.setCharAt(index, (char) (rem + 48));\n                    } else {\n                        sb.append(0);\n                        sb.append(rem);\n                    }\n                    index += 2;\n                }\n                fi = f.intValue();\n            }\n            sb.reverse();\n            if (fi != -1) sb.append(\".\").append(fi);\n            while (sb.charAt(0) == '0') sb.deleteCharAt(0);\n            if (sb.charAt(0) == '.') sb.insert(0, '0');\n            return new QuaterImaginary(sb.toString());\n        }\n\n        @Override\n        public String toString() {\n            double real2 = real == -0.0 ? 0.0 : real;  \n            double imag2 = imag == -0.0 ? 0.0 : imag;  \n            String result = imag2 >= 0.0 ? String.format(\"%.0f +\u00a0%.0fi\", real2, imag2) : String.format(\"%.0f -\u00a0%.0fi\", real2, -imag2);\n            result = result.replace(\".0 \", \" \").replace(\".0i\", \"i\").replace(\" + 0i\", \"\");\n            if (result.startsWith(\"0 + \")) result = result.substring(4);\n            if (result.startsWith(\"0 - \")) result = result.substring(4);\n            return result;\n        }\n    }\n\n    private static class QuaterImaginary {\n        private static final Complex TWOI = new Complex(0.0, 2.0);\n        private static final Complex INVTWOI = TWOI.inv();\n\n        private String b2i;\n\n        public QuaterImaginary(String b2i) {\n            if (b2i.equals(\"\") || !b2i.chars().allMatch(c -> \"0123.\".indexOf(c) > -1) || b2i.chars().filter(c -> c == '.').count() > 1) {\n                throw new RuntimeException(\"Invalid Base 2i number\");\n            }\n            this.b2i = b2i;\n        }\n\n        public Complex toComplex() {\n            int pointPos = b2i.indexOf(\".\");\n            int posLen = pointPos != -1 ? pointPos : b2i.length();\n            Complex sum = new Complex(0, 0);\n            Complex prod = new Complex(1, 0);\n\n            for (int j = 0; j < posLen; ++j) {\n                double k = b2i.charAt(posLen - 1 - j) - '0';\n                if (k > 0.0) sum = sum.add(prod.times(k));\n                prod = prod.times(TWOI);\n            }\n            if (pointPos != -1) {\n                prod = INVTWOI;\n                for (int j = posLen + 1; j < b2i.length(); ++j) {\n                    double k = b2i.charAt(j) - '0';\n                    if (k > 0.0) sum = sum.add(prod.times(k));\n                    prod = prod.times(INVTWOI);\n                }\n            }\n\n            return sum;\n        }\n\n        @Override\n        public String toString() {\n            return b2i;\n        }\n    }\n\n    public static void main(String[] args) {\n        String fmt = \"%4s -> %8s -> %4s\";\n        for (int i = 1; i <= 16; ++i) {\n            Complex c1 = new Complex(i, 0);\n            QuaterImaginary qi = c1.toQuaterImaginary();\n            Complex c2 = qi.toComplex();\n            System.out.printf(fmt + \"     \", c1, qi, c2);\n            c1 = c2.unaryMinus();\n            qi = c1.toQuaterImaginary();\n            c2 = qi.toComplex();\n            System.out.printf(fmt, c1, qi, c2);\n            System.out.println();\n        }\n        System.out.println();\n        for (int i = 1; i <= 16; ++i) {\n            Complex c1 = new Complex(0, i);\n            QuaterImaginary qi = c1.toQuaterImaginary();\n            Complex c2 = qi.toComplex();\n            System.out.printf(fmt + \"     \", c1, qi, c2);\n            c1 = c2.unaryMinus();\n            qi = c1.toQuaterImaginary();\n            c2 = qi.toComplex();\n            System.out.printf(fmt, c1, qi, c2);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415692, "name": "Statistics_Normal distribution", "source": "Translate Perl to Java: use constant pi => 3.14159265;\nuse List::Util qw(sum reduce min max);\n\nsub normdist {\n    my($m, $sigma) = @_;\n    my $r = sqrt -2 * log rand;\n    my $theta = 2 * pi * rand;\n    $r * cos($theta) * $sigma + $m;\n}\n\n$size = 100000; $mean = 50; $stddev = 4;\n\npush @dataset, normdist($mean,$stddev) for 1..$size;\n\nmy $m = sum(@dataset) / $size;\nprint \"m = $m\\n\";\n\nmy $sigma = sqrt( (reduce { $a + $b **2 } 0,@dataset) / $size - $m**2 );\nprint \"sigma = $sigma\\n\";\n\n    $hash{int $_}++ for @dataset;\n    my $scale = 180 * $stddev / $size;\n    my @subbar = < \u23b8 \u258f \u258e \u258d \u258c \u258b \u258a \u2589 \u2588 >;\n    for $i (min(@dataset)..max(@dataset)) {\n        my $x = ($hash{$i} // 0) * $scale;\n        my $full = int $x;\n        my $part = 8 * ($x - $full);\n        my $t1 = '\u2588' x $full;\n        my $t2 = $subbar[$part];\n        print \"$i\\t$t1$t2\\n\";\n    }\n", "target": "import static java.lang.Math.*;\nimport static java.util.Arrays.stream;\nimport java.util.Locale;\nimport java.util.function.DoubleSupplier;\nimport static java.util.stream.Collectors.joining;\nimport java.util.stream.DoubleStream;\nimport static java.util.stream.IntStream.range;\n\npublic class Test implements DoubleSupplier {\n\n    private double mu, sigma;\n    private double[] state = new double[2];\n    private int index = state.length;\n\n    Test(double m, double s) {\n        mu = m;\n        sigma = s;\n    }\n\n    static double[] meanStdDev(double[] numbers) {\n        if (numbers.length == 0)\n            return new double[]{0.0, 0.0};\n\n        double sx = 0.0, sxx = 0.0;\n        long n = 0;\n        for (double x : numbers) {\n            sx += x;\n            sxx += pow(x, 2);\n            n++;\n        }\n\n        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};\n    }\n\n    static String replicate(int n, String s) {\n        return range(0, n + 1).mapToObj(i -> s).collect(joining());\n    }\n\n    static void showHistogram01(double[] numbers) {\n        final int maxWidth = 50;\n        long[] bins = new long[10];\n\n        for (double x : numbers)\n            bins[(int) (x * bins.length)]++;\n\n        double maxFreq = stream(bins).max().getAsLong();\n\n        for (int i = 0; i < bins.length; i++)\n            System.out.printf(\" %3.1f: %s%n\", i / (double) bins.length,\n                    replicate((int) (bins[i] / maxFreq * maxWidth), \"*\"));\n        System.out.println();\n    }\n\n    @Override\n    public double getAsDouble() {\n        index++;\n        if (index >= state.length) {\n            double r = sqrt(-2 * log(random())) * sigma;\n            double x = 2 * PI * random();\n            state = new double[]{mu + r * sin(x), mu + r * cos(x)};\n            index = 0;\n        }\n        return state[index];\n\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.US);\n        double[] data = DoubleStream.generate(new Test(0.0, 0.5)).limit(100_000)\n                .toArray();\n\n        double[] res = meanStdDev(data);\n        System.out.printf(\"Mean: %8.6f, SD: %8.6f%n\", res[0], res[1]);\n\n        showHistogram01(stream(data).map(a -> max(0.0, min(0.9999, a / 3 + 0.5)))\n                .toArray());\n    }\n}\n"}
{"id": 415693, "name": "Vogel's approximation method", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse List::AllUtils qw( max_by nsort_by min );\n\nmy $data = <<END;\nA=30 B=20 C=70 D=30 E=60\nW=50 X=60 Y=50 Z=50\nAW=16 BW=16 CW=13 DW=22 EW=17\nAX=14 BX=14 CX=13 DX=19 EX=15\nAY=19 BY=19 CY=20 DY=23 EY=50\nAZ=50 BZ=12 CZ=50 DZ=15 EZ=11\nEND\nmy $table = sprintf +('%4s' x 6 . \"\\n\") x 5,\n  map {my $t = $_; map \"$_$t\", '', 'A' .. 'E' } '' , 'W' .. 'Z';\n\nmy ($cost, %assign) = (0);\nwhile( $data =~ /\\b\\w=\\d/ )\n  {\n  my @penalty;\n  for ( $data =~ /\\b(\\w)=\\d/g )\n    {\n    my @all = map /(\\d+)/, nsort_by { /\\d+/ && $& }\n      grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n      $data =~ /$_\\w=\\d+|\\w$_=\\d+/g;\n    push @penalty, [ $_, ($all[1] // 0) - $all[0] ];\n    }\n  my $rc = (max_by { $_->[1] } nsort_by\n    { my $x = $_->[0]; $data =~ /(?:$x\\w|\\w$x)=(\\d+)/ && $1 } @penalty)->[0];\n  my @lowest = nsort_by { /\\d+/ && $& }\n    grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n    $data =~ /$rc\\w=\\d+|\\w$rc=\\d+/g;\n  my ($t, $c) = $lowest[0] =~ /(.)(.)/;\n  my $allocate = min $data =~ /\\b[$t$c]=(\\d+)/g;\n  $table =~ s/$t$c/ sprintf \"%2d\", $allocate/e;\n  $cost += $data =~ /$t$c=(\\d+)/ && $1 * $allocate;\n  $data =~ s/\\b$_=\\K\\d+/ $& - $allocate || '' /e for $t, $c;\n  }\nprint \"cost $cost\\n\\n\", $table =~ s/[A-Z]{2}/--/gr;\n", "target": "import java.util.Arrays;\nimport static java.util.Arrays.stream;\nimport java.util.concurrent.*;\n\npublic class VogelsApproximationMethod {\n\n    final static int[] demand = {30, 20, 70, 30, 60};\n    final static int[] supply = {50, 60, 50, 50};\n    final static int[][] costs = {{16, 16, 13, 22, 17}, {14, 14, 13, 19, 15},\n    {19, 19, 20, 23, 50}, {50, 12, 50, 15, 11}};\n\n    final static int nRows = supply.length;\n    final static int nCols = demand.length;\n\n    static boolean[] rowDone = new boolean[nRows];\n    static boolean[] colDone = new boolean[nCols];\n    static int[][] result = new int[nRows][nCols];\n\n    static ExecutorService es = Executors.newFixedThreadPool(2);\n\n    public static void main(String[] args) throws Exception {\n        int supplyLeft = stream(supply).sum();\n        int totalCost = 0;\n\n        while (supplyLeft > 0) {\n            int[] cell = nextCell();\n            int r = cell[0];\n            int c = cell[1];\n\n            int quantity = Math.min(demand[c], supply[r]);\n            demand[c] -= quantity;\n            if (demand[c] == 0)\n                colDone[c] = true;\n\n            supply[r] -= quantity;\n            if (supply[r] == 0)\n                rowDone[r] = true;\n\n            result[r][c] = quantity;\n            supplyLeft -= quantity;\n\n            totalCost += quantity * costs[r][c];\n        }\n\n        stream(result).forEach(a -> System.out.println(Arrays.toString(a)));\n        System.out.println(\"Total cost: \" + totalCost);\n\n        es.shutdown();\n    }\n\n    static int[] nextCell() throws Exception {\n        Future<int[]> f1 = es.submit(() -> maxPenalty(nRows, nCols, true));\n        Future<int[]> f2 = es.submit(() -> maxPenalty(nCols, nRows, false));\n\n        int[] res1 = f1.get();\n        int[] res2 = f2.get();\n\n        if (res1[3] == res2[3])\n            return res1[2] < res2[2] ? res1 : res2;\n\n        return (res1[3] > res2[3]) ? res2 : res1;\n    }\n\n    static int[] diff(int j, int len, boolean isRow) {\n        int min1 = Integer.MAX_VALUE, min2 = Integer.MAX_VALUE;\n        int minP = -1;\n        for (int i = 0; i < len; i++) {\n            if (isRow ? colDone[i] : rowDone[i])\n                continue;\n            int c = isRow ? costs[j][i] : costs[i][j];\n            if (c < min1) {\n                min2 = min1;\n                min1 = c;\n                minP = i;\n            } else if (c < min2)\n                min2 = c;\n        }\n        return new int[]{min2 - min1, min1, minP};\n    }\n\n    static int[] maxPenalty(int len1, int len2, boolean isRow) {\n        int md = Integer.MIN_VALUE;\n        int pc = -1, pm = -1, mc = -1;\n        for (int i = 0; i < len1; i++) {\n            if (isRow ? rowDone[i] : colDone[i])\n                continue;\n            int[] res = diff(i, len2, isRow);\n            if (res[0] > md) {\n                md = res[0];  \n                pm = i;       \n                mc = res[1];  \n                pc = res[2];  \n            }\n        }\n        return isRow ? new int[]{pm, pc, mc, md} : new int[]{pc, pm, mc, md};\n    }\n}\n"}
{"id": 415694, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::AnyNum qw(:overload as_bin digits2num);\n\nfor my $x (1..10, 95..105, 297, 576, 594, 891, 909, 999) {\n    my $y;\n    if ($x =~ /^9+$/) { $y = digits2num([(1) x (9 * length $x)],2)  } \n    else              { while (1) { last unless as_bin(++$y) % $x } }\n    printf \"%4d: %28s  %s\\n\", $x, as_bin($y), as_bin($y)/$x;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class MinimumNumberOnlyZeroAndOne {\n\n    public static void main(String[] args) {\n        for ( int n : getTestCases() ) {\n            BigInteger result = getA004290(n);\n            System.out.printf(\"A004290(%d) = %s = %s * %s%n\", n, result, n, result.divide(BigInteger.valueOf(n)));\n        }\n    }\n    \n    private static List<Integer> getTestCases() {\n        List<Integer> testCases = new ArrayList<>();\n        for ( int i = 1 ; i <= 10 ; i++ ) {\n            testCases.add(i);\n        }\n        for ( int i = 95 ; i <= 105 ; i++ ) {\n            testCases.add(i);\n        }\n        for (int i : new int[] {297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878} ) {\n            testCases.add(i);\n        }\n        return testCases;\n    }\n    \n    private static BigInteger getA004290(int n) {\n        if ( n == 1 ) {\n            return BigInteger.valueOf(1);\n        }\n        int[][] L = new int[n][n];\n        for ( int i = 2 ; i < n ; i++ ) {\n            L[0][i] = 0;\n        }\n        L[0][0] = 1;\n        L[0][1] = 1;\n        int m = 0;\n        BigInteger ten = BigInteger.valueOf(10);\n        BigInteger nBi = BigInteger.valueOf(n);\n        while ( true ) {\n            m++;\n            \n            if ( L[m-1][mod(ten.pow(m).negate(), nBi).intValue()] == 1 ) {\n                break;\n            }\n            L[m][0] = 1;\n            for ( int k = 1 ; k < n ; k++ ) {\n                \n                L[m][k] = Math.max(L[m-1][k], L[m-1][mod(BigInteger.valueOf(k).subtract(ten.pow(m)), nBi).intValue()]);\n            }\n            \n        }\n        \n        \n        BigInteger r = ten.pow(m);\n        BigInteger k = mod(r.negate(), nBi);\n        for ( int j = m-1 ; j >= 1 ; j-- ) {\n            if ( L[j-1][k.intValue()] == 0 ) {\n                \n                \n                r = r.add(ten.pow(j));\n                k = mod(k.subtract(ten.pow(j)), nBi);\n            }\n        }\n        if ( k.compareTo(BigInteger.ONE) == 0 ) {\n            r = r.add(BigInteger.ONE);\n        }\n        return r;\n    }\n\n    private static BigInteger mod(BigInteger m, BigInteger n) {\n        BigInteger result = m.mod(n);\n        if ( result.compareTo(BigInteger.ZERO) < 0 ) {\n            result = result.add(n);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int mod(int m, int n) {\n        int result = m % n;\n        if ( result < 0 ) {\n            result += n;\n        }\n        return result;\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static int pow(int base, int exp) {\n        return (int) Math.pow(base, exp);\n    }\n}\n"}
{"id": 415695, "name": "Weird numbers", "source": "Translate Perl to Java: use strict;\nuse feature 'say';\n\nuse List::Util 'sum';\nuse POSIX 'floor';\nuse Algorithm::Combinatorics 'subsets';\nuse ntheory <is_prime divisors>;\n\nsub abundant {\n    my($x) = @_;\n    my $s = sum( my @l = is_prime($x) ? 1 : grep { $x != $_ } divisors($x) );\n    $s > $x ? ($s, sort { $b <=> $a } @l) : ();\n}\n\nmy(@weird,$n);\nwhile () {\n    $n++;\n    my ($sum, @div) = abundant($n);\n    next unless $sum;        \n    next if $sum / $n > 1.1; \n\n    if ($n >= 10430 and (! int $n%70) and is_prime(int $n/70)) {\n        \n    } else {\n        my $next;\n        my $l = shift @div;\n        my $iter = subsets(\\@div);\n        while (my $s = $iter->next) {\n            ++$next and last if sum(@$s) == $n - $l;\n        }\n        next if $next;\n    }\n    push @weird, $n;\n    last if @weird == 25;\n}\n\nsay \"The first 25 weird numbers:\\n\" . join ' ', @weird;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class WeirdNumbers {\n\n    public static void main(String[] args) {\n        int n = 2;\n        \n        for ( int count = 1 ; count <= 25 ; n += 2 ) {\n            if ( isWeird(n) ) {\n                System.out.printf(\"w(%d) = %d%n\", count, n);\n                count++;\n            }\n        }\n    }\n    \n    private static boolean isWeird(int n) {\n        List<Integer> properDivisors = getProperDivisors(n);\n        return isAbundant(properDivisors, n) && ! isSemiPerfect(properDivisors, n);\n    }\n    \n    private static boolean isAbundant(List<Integer> divisors, int n) {\n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        return divisorSum > n;\n    }\n    \n    \n    private static boolean isSemiPerfect(List<Integer> divisors, int sum) {\n        int size = divisors.size();\n        \n        \n        boolean subset[][] = new boolean[sum+1][size+1];\n\n        \n        for (int i = 0; i <= size; i++) {\n            subset[0][i] = true; \n        }\n        \n        \n        for (int i = 1; i <= sum; i++) {\n            subset[i][0] = false; \n        }\n        \n        \n        for ( int i = 1 ; i <= sum ; i++ ) {\n            for ( int j = 1 ; j <= size ; j++ ) {\n                subset[i][j] = subset[i][j-1];\n                int test = divisors.get(j-1);\n                if ( i >= test ) {\n                    subset[i][j] = subset[i][j] || subset[i - test][j-1]; \n                }\n            } \n        } \n\n        return subset[sum][size];\n    }\n\n    private static final List<Integer> getProperDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i && div != number ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 415696, "name": "ASCII art diagram converter", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\n$_ = <<END;\n\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                      ID                       |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    QDCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ANCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    NSCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    |                    ARCOUNT                    |\n    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\nEND\n\nmy $template;\nmy @names;\nwhile( /\\| *(\\w+) */g )\n  {\n  printf \"%10s is %2d bits\\n\", $1, my $length = length($&) / 3;\n  push @names, $1;\n  $template .= \"A$length \";\n  }\n\nmy $input = '78477bbf5496e12e1bf169a4'; \n\nmy %datastructure;\n@datastructure{ @names } = unpack $template, unpack 'B*', pack 'H*', $input;\n\nprint \"\\ntemplate = $template\\n\\n\";\nuse Data::Dump 'dd'; dd 'datastructure', \\%datastructure;\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AsciiArtDiagramConverter {\n\n    private static final String TEST = \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                      ID                       |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    QDCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ANCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    NSCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ARCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\";\n\n    public static void main(String[] args) {\n        validate(TEST);\n        display(TEST);\n        Map<String,List<Integer>> asciiMap = decode(TEST);\n        displayMap(asciiMap);\n        displayCode(asciiMap, \"78477bbf5496e12e1bf169a4\");\n    }\n\n    private static void displayCode(Map<String,List<Integer>> asciiMap, String hex) {\n        System.out.printf(\"%nTest string in hex:%n%s%n%n\", hex);\n\n        String bin = new BigInteger(hex,16).toString(2);\n\n        \n        int length = 0;\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            length += pos.get(1) - pos.get(0) + 1;\n        }\n        while ( length > bin.length() ) {\n            bin = \"0\" + bin;\n        }\n        System.out.printf(\"Test string in binary:%n%s%n%n\", bin);\n\n        System.out.printf(\"Name      Size  Bit Pattern%n\");\n        System.out.printf(\"-------- -----  -----------%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            int start = pos.get(0);\n            int end   = pos.get(1);\n            System.out.printf(\"%-8s    %2d  %s%n\", code, end-start+1, bin.substring(start, end+1));\n        }\n\n    }\n\n\n    private static void display(String ascii) {\n        System.out.printf(\"%nDiagram:%n%n\");\n        for ( String s : TEST.split(\"\\\\r\\\\n\") ) {\n            System.out.println(s);\n        }\n    }\n\n    private static void displayMap(Map<String,List<Integer>> asciiMap) {\n        System.out.printf(\"%nDecode:%n%n\");\n\n\n        System.out.printf(\"Name      Size  Start    End%n\");\n        System.out.printf(\"-------- -----  -----  -----%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            System.out.printf(\"%-8s    %2d     %2d     %2d%n\", code, pos.get(1)-pos.get(0)+1, pos.get(0), pos.get(1));\n        }\n\n    }\n\n    private static Map<String,List<Integer>> decode(String ascii) {\n        Map<String,List<Integer>> map = new LinkedHashMap<>();\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        int size = split[0].indexOf(\"+\", 1) - split[0].indexOf(\"+\");\n        int length = split[0].length() - 1;\n        for ( int i = 1 ; i < split.length ; i += 2 ) {\n            int barIndex = 1;\n            String test = split[i];\n            int next;\n            while ( barIndex < length && (next = test.indexOf(\"|\", barIndex)) > 0 ) {\n                \n                List<Integer> startEnd = new ArrayList<>();\n                startEnd.add((barIndex/size) + (i/2)*(length/size));\n                startEnd.add(((next-1)/size) + (i/2)*(length/size));\n                String code = test.substring(barIndex, next).replace(\" \", \"\");\n                map.put(code, startEnd);\n                \n                barIndex = next + 1;\n            }\n        }\n\n        return map;\n    }\n\n    private static void validate(String ascii) {\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        if ( split.length % 2 != 1 ) {\n            throw new RuntimeException(\"ERROR 1:  Invalid number of input lines.  Line count = \" + split.length);\n        }\n        int size = 0;\n        for ( int i = 0 ; i < split.length ; i++ ) {\n            String test = split[i];\n            if ( i % 2 == 0 ) {\n                \n                if ( ! test.matches(\"^\\\\+([-]+\\\\+)+$\") ) {\n                    throw new RuntimeException(\"ERROR 2:  Improper line format.  Line = \" + test);\n                }\n                if ( size == 0 ) {\n                    int firstPlus = test.indexOf(\"+\");\n                    int secondPlus = test.indexOf(\"+\", 1);\n                    size = secondPlus - firstPlus;\n                }\n                if ( ((test.length()-1) % size) != 0 ) {\n                    throw new RuntimeException(\"ERROR 3:  Improper line format.  Line = \" + test);\n                }\n                \n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    if ( test.charAt(j) != '+' ) {\n                        throw new RuntimeException(\"ERROR 4:  Improper line format.  Line = \" + test);\n                    }\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        if ( test.charAt(k) != '-' ) {\n                            throw new RuntimeException(\"ERROR 5:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n            }\n            else {\n                \n                if ( ! test.matches(\"^\\\\|(\\\\s*[A-Za-z]+\\\\s*\\\\|)+$\") ) {\n                    throw new RuntimeException(\"ERROR 6:  Improper line format.  Line = \" + test);\n                }\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        \n                        if ( test.charAt(k) == '|' ) {\n                            throw new RuntimeException(\"ERROR 7:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n}\n"}
{"id": 415697, "name": "Peaceful chess queen armies", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $m = shift // 4;\nmy $n = shift // 5;\nmy %seen;\nmy $gaps = join '|', qr/-*/, map qr/.{$_}(?:-.{$_})*/s, $n-1, $n, $n+1;\nmy $attack = qr/(\\w)(?:$gaps)(?!\\1)\\w/;\n\nplace( scalar ('-' x $n . \"\\n\") x $n );\nprint \"No solution to $m $n\\n\";\n\nsub place\n  {\n  local $_ = shift;\n  $seen{$_}++ || /$attack/ and return; \n  (my $have = tr/WB//) < $m * 2 or exit !print \"Solution to $m $n\\n\\n$_\";\n  place( s/-\\G/ qw(W B)[$have\u00a0% 2] /er ) while /-/g; \n  }\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Peaceful {\n    enum Piece {\n        Empty,\n        Black,\n        White,\n    }\n\n    public static class Position {\n        public int x, y;\n\n        public Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj instanceof Position) {\n                Position pos = (Position) obj;\n                return pos.x == x && pos.y == y;\n            }\n            return false;\n        }\n    }\n\n    private static boolean place(int m, int n, List<Position> pBlackQueens, List<Position> pWhiteQueens) {\n        if (m == 0) {\n            return true;\n        }\n        boolean placingBlack = true;\n        for (int i = 0; i < n; ++i) {\n            inner:\n            for (int j = 0; j < n; ++j) {\n                Position pos = new Position(i, j);\n                for (Position queen : pBlackQueens) {\n                    if (pos.equals(queen) || !placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                for (Position queen : pWhiteQueens) {\n                    if (pos.equals(queen) || placingBlack && isAttacking(queen, pos)) {\n                        continue inner;\n                    }\n                }\n                if (placingBlack) {\n                    pBlackQueens.add(pos);\n                    placingBlack = false;\n                } else {\n                    pWhiteQueens.add(pos);\n                    if (place(m - 1, n, pBlackQueens, pWhiteQueens)) {\n                        return true;\n                    }\n                    pBlackQueens.remove(pBlackQueens.size() - 1);\n                    pWhiteQueens.remove(pWhiteQueens.size() - 1);\n                    placingBlack = true;\n                }\n            }\n        }\n        if (!placingBlack) {\n            pBlackQueens.remove(pBlackQueens.size() - 1);\n        }\n        return false;\n    }\n\n    private static boolean isAttacking(Position queen, Position pos) {\n        return queen.x == pos.x\n            || queen.y == pos.y\n            || Math.abs(queen.x - pos.x) == Math.abs(queen.y - pos.y);\n    }\n\n    private static void printBoard(int n, List<Position> blackQueens, List<Position> whiteQueens) {\n        Piece[] board = new Piece[n * n];\n        Arrays.fill(board, Piece.Empty);\n\n        for (Position queen : blackQueens) {\n            board[queen.x + n * queen.y] = Piece.Black;\n        }\n        for (Position queen : whiteQueens) {\n            board[queen.x + n * queen.y] = Piece.White;\n        }\n        for (int i = 0; i < board.length; ++i) {\n            if ((i != 0) && i % n == 0) {\n                System.out.println();\n            }\n\n            Piece b = board[i];\n            if (b == Piece.Black) {\n                System.out.print(\"B \");\n            } else if (b == Piece.White) {\n                System.out.print(\"W \");\n            } else {\n                int j = i / n;\n                int k = i - j * n;\n                if (j % 2 == k % 2) {\n                    System.out.print(\"\u2022 \");\n                } else {\n                    System.out.print(\"\u25e6 \");\n                }\n            }\n        }\n        System.out.println('\\n');\n    }\n\n    public static void main(String[] args) {\n        List<Position> nms = List.of(\n            new Position(2, 1),\n            new Position(3, 1),\n            new Position(3, 2),\n            new Position(4, 1),\n            new Position(4, 2),\n            new Position(4, 3),\n            new Position(5, 1),\n            new Position(5, 2),\n            new Position(5, 3),\n            new Position(5, 4),\n            new Position(5, 5),\n            new Position(6, 1),\n            new Position(6, 2),\n            new Position(6, 3),\n            new Position(6, 4),\n            new Position(6, 5),\n            new Position(6, 6),\n            new Position(7, 1),\n            new Position(7, 2),\n            new Position(7, 3),\n            new Position(7, 4),\n            new Position(7, 5),\n            new Position(7, 6),\n            new Position(7, 7)\n        );\n        for (Position nm : nms) {\n            int m = nm.y;\n            int n = nm.x;\n            System.out.printf(\"%d black and %d white queens on a %d x %d board:\\n\", m, m, n, n);\n            List<Position> blackQueens = new ArrayList<>();\n            List<Position> whiteQueens = new ArrayList<>();\n            if (place(m, n, blackQueens, whiteQueens)) {\n                printBoard(n, blackQueens, whiteQueens);\n            } else {\n                System.out.println(\"No solution exists.\\n\");\n            }\n        }\n    }\n}\n"}
{"id": 415698, "name": "Sequence_ nth number with exactly n divisors", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse bigint;\nuse ntheory <nth_prime is_prime divisors>;\n\nmy $limit = 20;\n\nprint \"First $limit terms of OEIS:A073916\\n\";\n\nfor my $n (1..$limit) {\n    if ($n > 4 and is_prime($n)) {\n        print nth_prime($n)**($n-1) . ' ';\n    } else {\n        my $i = my $x = 0;\n        while (1) {\n            my $nn = $n%2 ? ++$x**2 : ++$x;\n            next unless $n == divisors($nn) and ++$i == $n;\n            print \"$nn \" and last;\n      }\n    }\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SequenceNthNumberWithExactlyNDivisors {\n\n    public static void main(String[] args) {\n        int max = 45;\n        smallPrimes(max);\n        for ( int n = 1; n <= max ; n++ ) {\n            System.out.printf(\"A073916(%d) = %s%n\", n, OEISA073916(n));\n        }\n    }\n    \n    private static List<Integer> smallPrimes = new ArrayList<>();\n    \n    private static void smallPrimes(int numPrimes) {\n        smallPrimes.add(2);\n        for ( int n = 3, count = 0 ; count < numPrimes ; n += 2 ) {\n            if ( isPrime(n) ) {\n                smallPrimes.add(n);\n                count++;\n            }\n        }\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) {\n            return false;\n        }\n        for ( long d = 3 ; d*d <= test ; d += 2 ) {\n            if ( test % d == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int getDivisorCount(long n) {\n        int count = 1;\n        while ( n % 2 == 0 ) {\n            n /= 2;\n            count += 1;\n        }\n        for ( long d = 3 ; d*d <= n ; d += 2 ) {\n            long q = n / d;\n            long r = n % d;\n            int dc = 0;\n            while ( r == 0 ) {\n                dc += count;\n                n = q;\n                q = n / d;\n                r = n % d;\n            }\n            count += dc;\n        }\n        if ( n != 1 ) {\n            count *= 2;\n        }\n        return count;\n    }\n    \n    private static BigInteger OEISA073916(int n) {\n        if ( isPrime(n) ) {\n            return BigInteger.valueOf(smallPrimes.get(n-1)).pow(n - 1);\n        }\n        int count = 0;\n        int result = 0;\n        for ( int i = 1 ; count < n ; i++ ) {\n            if ( n % 2 == 1 ) {\n                \n                int sqrt = (int) Math.sqrt(i);\n                if ( sqrt*sqrt != i ) {\n                    continue;\n                }\n            }\n            if ( getDivisorCount(i) == n ) {\n                count++;\n                result = i;\n            }\n        }\n        return BigInteger.valueOf(result);\n    }\n\n}\n"}
{"id": 415699, "name": "N-body problem", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse constant PI         => 3.141592653589793;\nuse constant SOLAR_MASS => (4 * PI * PI);\nuse constant YEAR       => 365.24;\n\nsub solar_offset {\n    my($vxs, $vys, $vzs, $mass) = @_;\n    my($px, $py, $pz);\n    for (0..@$mass-1) {\n        $px += @$vxs[$_] * @$mass[$_];\n        $py += @$vys[$_] * @$mass[$_];\n        $pz += @$vzs[$_] * @$mass[$_];\n    }\n    (@$vxs[0], @$vys[0], @$vzs[0]) = ((-$px/SOLAR_MASS), (-$py/SOLAR_MASS), (-$pz/SOLAR_MASS));\n}\n\nsub orbit {\n    my ($dt, $xs, $ys, $zs, $vxs, $vys, $vzs, $mass) = @_;\n    for (0..@$mass-1) {\n        for (my $j = $_ + 1; $j < @$mass; $j++) {\n            my($dx, $dy, $dz) = ((@$xs[$_] - @$xs[$j]), (@$ys[$_] - @$ys[$j]), (@$zs[$_] - @$zs[$j]));\n            my $mag = $dt / ($dx**2 + $dy**2 + $dz**2)**(3/2);\n            my($mm, $mm2) = ((@$mass[$_] * $mag), (@$mass[$j] * $mag));\n            @$vxs[$_] -= $dx * $mm2;\n            @$vxs[$j] += $dx * $mm;\n            @$vys[$_] -= $dy * $mm2;\n            @$vys[$j] += $dy * $mm;\n            @$vzs[$_] -= $dz * $mm2;\n            @$vzs[$j] += $dz * $mm;\n        }\n        @$xs[$_] += $dt * @$vxs[$_];\n        @$ys[$_] += $dt * @$vys[$_];\n        @$zs[$_] += $dt * @$vzs[$_];\n    }\n}\n\nsub display {\n    my($t,$xs,$ys) = @_;\n    printf '%6d', $t;\n    printf '%7.2f' x 2, @$xs[$_],@$ys[$_] for 1..4;\n    print \"\\n\";\n}\n\nmy @ns =                         <Sun   Jupiter          Saturn           Uranus           Neptune       >;\nmy @xs =                         <0     4.84143144e+00   8.34336671e+00   1.28943695e+01   1.53796971e+01>;\nmy @ys =                         <0    -1.16032004e+00   4.12479856e+00  -1.51111514e+01  -2.59193146e+01>;\nmy @zs =                         <0    -1.03622044e-01  -4.03523417e-01  -2.23307578e-01   1.79258772e-01>;\nmy @vxs = map {$_ * YEAR}        <0     1.66007664e-03  -2.76742510e-03   2.96460137e-03   2.68067772e-03>;\nmy @vys = map {$_ * YEAR}        <0     7.69901118e-03   4.99852801e-03   2.37847173e-03   1.62824170e-03>;\nmy @vzs = map {$_ * YEAR}        <0    -6.90460016e-05   2.30417297e-05  -2.96589568e-05  -9.51592254e-05>;\nmy @mass = map {$_ * SOLAR_MASS} <1     9.54791938e-04   2.85885980e-04   4.36624404e-05   5.15138902e-05>;\nsolar_offset(\\@vxs, \\@vys, \\@vzs, \\@mass);\n\nprintf '     t' . '%14s'x4 . \"\\n\", @ns[1..4];\ndisplay(0, \\@xs, \\@ys);\nmy $steps = 16567;\nfor my $t (1 .. $steps) {\n    orbit(0.01, \\@xs, \\@ys, \\@zs, \\@vxs, \\@vys, \\@vzs, \\@mass);\n    display($t,\\@xs, \\@ys) unless $t % 1000;\n}\ndisplay($steps, \\@xs, \\@ys);\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class NBodySim {\n    private static class Vector3D {\n        double x, y, z;\n\n        public Vector3D(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n\n        public Vector3D plus(Vector3D rhs) {\n            return new Vector3D(x + rhs.x, y + rhs.y, z + rhs.z);\n        }\n\n        public Vector3D minus(Vector3D rhs) {\n            return new Vector3D(x - rhs.x, y - rhs.y, z - rhs.z);\n        }\n\n        public Vector3D times(double s) {\n            return new Vector3D(s * x, s * y, s * z);\n        }\n\n        public double mod() {\n            return Math.sqrt(x * x + y * y + z * z);\n        }\n    }\n\n    private static final Vector3D origin = new Vector3D(0, 0, 0);\n\n    private static class NBody {\n        private double gc;\n        private int bodies;\n        public final int timeSteps;\n        private double[] masses;\n        private Vector3D[] positions;\n        private Vector3D[] velocities;\n        private Vector3D[] accelerations;\n\n        public NBody(String fileName) throws IOException {\n            Path path = Paths.get(fileName);\n            List<String> lines = Files.readAllLines(path);\n\n            String[] gbt = lines.get(0).split(\" \");\n            gc = Double.parseDouble(gbt[0]);\n            bodies = Integer.parseInt(gbt[1]);\n            timeSteps = Integer.parseInt(gbt[2]);\n            masses = new double[bodies];\n            positions = new Vector3D[bodies];\n            Arrays.fill(positions, origin);\n            velocities = new Vector3D[bodies];\n            Arrays.fill(velocities, origin);\n            accelerations = new Vector3D[bodies];\n            Arrays.fill(accelerations, origin);\n            for (int i = 0; i < bodies; ++i) {\n                masses[i] = Double.parseDouble(lines.get(i * 3 + 1));\n                positions[i] = decompose(lines.get(i * 3 + 2));\n                velocities[i] = decompose(lines.get(i * 3 + 3));\n            }\n            System.out.printf(\"Contents of %s\\n\", fileName);\n            for (String line : lines) {\n                System.out.println(line);\n            }\n            System.out.println();\n            System.out.print(\"Body  \u00a0:      x          y          z    |\");\n            System.out.println(\"     vx         vy         vz\");\n        }\n\n        private Vector3D decompose(String line) {\n            String[] xyz = line.split(\" \");\n            double x = Double.parseDouble(xyz[0]);\n            double y = Double.parseDouble(xyz[1]);\n            double z = Double.parseDouble(xyz[2]);\n            return new Vector3D(x, y, z);\n        }\n\n        private void resolveCollisions() {\n            for (int i = 0; i < bodies; ++i) {\n                for (int j = i + 1; j < bodies; ++j) {\n                    if (positions[i].x == positions[j].x\n                        && positions[i].y == positions[j].y\n                        && positions[i].z == positions[j].z) {\n                        Vector3D temp = velocities[i];\n                        velocities[i] = velocities[j];\n                        velocities[j] = temp;\n                    }\n                }\n            }\n        }\n\n        private void computeAccelerations() {\n            for (int i = 0; i < bodies; ++i) {\n                accelerations[i] = origin;\n                for (int j = 0; j < bodies; ++j) {\n                    if (i != j) {\n                        double temp = gc * masses[j] / Math.pow((positions[i].minus(positions[j])).mod(), 3);\n                        accelerations[i] = accelerations[i].plus(positions[j].minus(positions[i]).times(temp));\n                    }\n                }\n            }\n        }\n\n        private void computeVelocities() {\n            for (int i = 0; i < bodies; ++i) {\n                velocities[i] = velocities[i].plus(accelerations[i]);\n            }\n        }\n\n        private void computePositions() {\n            for (int i = 0; i < bodies; ++i) {\n                positions[i] = positions[i].plus(velocities[i]).plus(accelerations[i].times(0.5));\n            }\n        }\n\n        public void simulate() {\n            computeAccelerations();\n            computePositions();\n            computeVelocities();\n            resolveCollisions();\n        }\n\n        public void printResults() {\n            String fmt = \"Body %d\u00a0:\u00a0% 8.6f \u00a0% 8.6f \u00a0% 8.6f |\u00a0% 8.6f \u00a0% 8.6f \u00a0% 8.6f\\n\";\n            for (int i = 0; i < bodies; ++i) {\n                System.out.printf(\n                    fmt,\n                    i + 1,\n                    positions[i].x, positions[i].y, positions[i].z,\n                    velocities[i].x, velocities[i].y, velocities[i].z\n                );\n            }\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        String filename = \"nbody.txt\";\n        NBody nb = new NBody(filename);\n        for (int i = 0; i < nb.timeSteps; ++i) {\n            System.out.printf(\"\\nCycle %s\\n\", i + 1);\n            nb.simulate();\n            nb.printResults();\n        }\n    }\n}\n"}
{"id": 415700, "name": "Readline interface", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Term::ReadLine;\nuse POSIX;\n\nmy $term = Term::ReadLine->new( 'simple Perl shell' );\nmy $attribs = $term->Attribs;\n$attribs->{completion_append_character}     = ' ';\n$attribs->{attempted_completion_function}   = \\&attempt_perl_completion;\n$attribs->{completion_display_matches_hook} = \\&perl_symbol_display_match_list;\n\nwhile (defined(my $command = &reader)) {\n    my @result = eval (\"package main; $command\");\n    print \"$_\\n\" for @result;\n}\n\nsub reader {\n    my $command = $term->readline('> ');\n    $term->addhistory($command) if $command;\n    $command;\n}\n\nsub perl_symbol_display_match_list {\n    my($matches, $num_matches, $max_length) = @_;\n    map { $_ =~ s/^((\\$\n    $term->display_match_list($matches);\n    $term->forced_update_display;\n}\n\nsub attempt_perl_completion {\n    my ($text, $line, $start, $end) = @_;\n    $term->completion_matches($text, \\&perl_symbol_completion_function);\n}\n\nuse vars qw($i @matches $prefix);\nsub perl_symbol_completion_function {\n    my($text, $state) = @_;\n    my %type = ('$' => 'SCALAR', '*' => 'SCALAR', '@' => 'ARRAY', '$\n\n    if ($state) {\n        $i++;\n    } else {\n        my ($pre, $pkg, $sym);\n        $i = 0;\n\n        no strict qw(refs);\n        ($prefix, $pre, $pkg) = ($text =~ m/^((\\$\n        @matches = grep /::$/, $pkg ? keys %$pkg : keys %::;\n        $pkg = '::' unless $pkg;\n        @matches = (@matches, grep (/^\\w+$/ && ($sym = $pkg . $_, defined *$sym{$type{$pre}}), keys %$pkg));\n    }\n    my $entry;\n    for (; $i <= $\n        $entry = $prefix . $matches[$i];\n        return $entry if ($entry =~ /^\\Q$text/);\n    }\n    undef;\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\n\npublic class ReadlineInterface {\n    private static LinkedList<String> histArr = new LinkedList<>();\n\n    private static void hist() {\n        if (histArr.isEmpty()) {\n            System.out.println(\"No history\");\n        } else {\n            histArr.forEach(cmd -> System.out.printf(\" - %s\\n\", cmd));\n        }\n\n        class Crutch {}\n        histArr.add(Crutch.class.getEnclosingMethod().getName());\n    }\n\n    private static void hello() {\n        System.out.println(\"Hello World!\");\n\n        class Crutch {}\n        histArr.add(Crutch.class.getEnclosingMethod().getName());\n    }\n\n    private static void help() {\n        System.out.println(\"Available commands:\");\n        System.out.println(\"  hello\");\n        System.out.println(\"  hist\");\n        System.out.println(\"  exit\");\n        System.out.println(\"  help\");\n\n        class Crutch {}\n        histArr.add(Crutch.class.getEnclosingMethod().getName());\n    }\n\n    public static void main(String[] args) throws IOException {\n        Map<String, Runnable> cmdMap = new HashMap<>();\n        cmdMap.put(\"help\", ReadlineInterface::help);\n        cmdMap.put(\"hist\", ReadlineInterface::hist);\n        cmdMap.put(\"hello\", ReadlineInterface::hello);\n\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        System.out.println(\"Enter a command, type help for a listing.\");\n        while (true) {\n            System.out.print(\">\");\n            String line = in.readLine();\n            if (\"exit\".equals(line)) {\n                break;\n            }\n\n            cmdMap.getOrDefault(line, ReadlineInterface::help).run();\n        }\n    }\n}\n"}
{"id": 415701, "name": "Rosetta Code_Tasks without examples", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse LWP::UserAgent;\nmy $ua = LWP::UserAgent->new;\n\n\nmy $html  = $ua->request( HTTP::Request->new( GET => 'http://rosettacode.org/wiki/Category:Programming_Tasks'))->content;\nmy @tasks = $html =~ m\n\n\nfor my $title (@tasks) {\n    my $html = $ua->request( HTTP::Request->new( GET => \"http://rosettacode.org/wiki/$title\" ))->content;\n    my($task_at_hand) = $html =~ m\n    print \"$title\\n$task_at_hand\\n\\n\";\n    sleep 10; \n}\n", "target": "import java.io.IOException;\nimport java.net.URI;\nimport java.net.URISyntaxException;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.time.Duration;\nimport java.util.ArrayList;\nimport java.util.regex.Pattern;\n\npublic class TasksWithoutExamples {\n    private static String readPage(HttpClient client, URI uri) throws IOException, InterruptedException {\n        var request = HttpRequest.newBuilder()\n            .GET()\n            .uri(uri)\n            .timeout(Duration.ofSeconds(5))\n            .setHeader(\"accept\", \"text/html\")\n            .build();\n\n        var response = client.send(request, HttpResponse.BodyHandlers.ofString());\n        return response.body();\n    }\n\n    private static void process(HttpClient client, String base, String task) {\n        try {\n            var re = Pattern.compile(\".*using any language you may know.</div>(.*?)<div id=\\\"toc\\\".*\", Pattern.DOTALL + Pattern.MULTILINE);\n            var re2 = Pattern.compile(\"</?[^>]*>\");\n\n            var page = base + task;\n            String body = readPage(client, new URI(page));\n\n            var matcher = re.matcher(body);\n            if (matcher.matches()) {\n                var group = matcher.group(1);\n                var m2 = re2.matcher(group);\n                var text = m2.replaceAll(\"\");\n                System.out.println(text);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) throws URISyntaxException, IOException, InterruptedException {\n        var re = Pattern.compile(\"<li><a href=\\\"/wiki/(.*?)\\\"\", Pattern.DOTALL + Pattern.MULTILINE);\n\n        var client = HttpClient.newBuilder()\n            .version(HttpClient.Version.HTTP_1_1)\n            .followRedirects(HttpClient.Redirect.NORMAL)\n            .connectTimeout(Duration.ofSeconds(5))\n            .build();\n\n        var uri = new URI(\"http\", \"rosettacode.org\", \"/wiki/Category:Programming_Tasks\", \"\");\n        var body = readPage(client, uri);\n        var matcher = re.matcher(body);\n\n        var tasks = new ArrayList<String>();\n        while (matcher.find()) {\n            tasks.add(matcher.group(1));\n        }\n\n        var base = \"http:\n        var limit = 3L;\n\n        tasks.stream().limit(limit).forEach(task -> process(client, base, task));\n    }\n}\n"}
{"id": 415702, "name": "Just in time processing on a character stream", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse feature 'state';\n\nuse ntheory qw/fromdigits todigitstring/;\n\nmy $key = 'perl5';\nsrand fromdigits($key,36) % 2**63;\n\nmy @stream;\n\nsub stream {\n    my($i) = shift;\n    state @chars;\n    push @chars, chr($_) for 14..127;\n    $stream[$i] = $chars[rand 1+127-14] unless $stream[$i];\n}\n\nsub jit_encode {\n    my($str) = shift;\n    my $i = 0;\n    my $last = 0;\n    my $enc = '';\n    for my $c (split '', $str) {\n        my $h;\n        my $l = '';\n        ++$i until $c eq stream($i);\n        my $o = $i - $last;\n        $l    = $o % 26;\n        $h    = $o - $l if $o > 26;\n        $l   += 10;\n        $enc .= ($h ? uc todigitstring($h,36) : '') . lc todigitstring($l,36);\n        $last = $i;\n    }\n    $enc\n}\n\nsub jit_decode {\n    my($str) = shift;\n    my @matches = $str =~ /((.*?) ([a-z]))/gx;\n    my $dec = '';\n    my $i = 0;\n    for my $j (0 .. @matches/3 - 1) {\n        my $o = ( fromdigits($matches[3*$j+1],36) - 10 // 0) +\n                ( fromdigits($matches[3*$j+2],36)      // 0);\n        $i   += $o;\n        $dec .= $stream[$i];\n    }\n    $dec\n}\n\nmy $enc = jit_encode('The slithey toves did gyre and gimble in the wabe');\nsay my $result = \"Encoded\\n$enc\\n\\nDecoded\\n\" . jit_decode($enc);\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Predicate;\n\npublic class Processing {\n    private static class UserInput {\n        private char formFeed;\n        private char lineFeed;\n        private char tab;\n        private char space;\n\n        private UserInput(char formFeed, char lineFeed, char tab, char space) {\n            this.formFeed = formFeed;\n            this.lineFeed = lineFeed;\n            this.tab = tab;\n            this.space = space;\n        }\n\n        char getFormFeed() {\n            return formFeed;\n        }\n\n        char getLineFeed() {\n            return lineFeed;\n        }\n\n        char getTab() {\n            return tab;\n        }\n\n        char getSpace() {\n            return space;\n        }\n    }\n\n    private static List<UserInput> getUserInput() {\n        String h = \"0 18 0 0 0 68 0 1 0 100 0 32 0 114 0 45 0 38 0 26 0 16 0 21 0 17 0 59 0 11 \" +\n            \"0 29 0 102 0 0 0 10 0 50 0 39 0 42 0 33 0 50 0 46 0 54 0 76 0 47 0 84 2 28\";\n        String[] s = h.split(\" \");\n\n        List<UserInput> uiList = new ArrayList<>();\n        for (int idx = 0; idx + 3 < s.length; idx += 4) {\n            char c0 = (char) Integer.parseInt(s[idx + 0]);\n            char c1 = (char) Integer.parseInt(s[idx + 1]);\n            char c2 = (char) Integer.parseInt(s[idx + 2]);\n            char c3 = (char) Integer.parseInt(s[idx + 3]);\n\n            UserInput userInput = new UserInput(c0, c1, c2, c3);\n            uiList.add(userInput);\n        }\n        return uiList;\n    }\n\n    private static void decode(String fileName, List<UserInput> uiList) throws IOException {\n        Path path = Paths.get(fileName);\n        byte[] bytes = Files.readAllBytes(path);\n        String text = new String(bytes, StandardCharsets.UTF_8);\n\n        Predicate<UserInput> decode2 = (UserInput ui) -> {\n            char f = 0;\n            char l = 0;\n            char t = 0;\n            char s = 0;\n            char ff = ui.getFormFeed();\n            char lf = ui.getLineFeed();\n            char tb = ui.getTab();\n            char sp = ui.getSpace();\n\n            for (char c : text.toCharArray()) {\n                if (f == ff && l == lf && t == tb && s == sp) {\n                    if (c == '!') {\n                        return false;\n                    }\n                    System.out.print(c);\n                    return true;\n                }\n                switch (c) {\n                    case '\\u000c':\n                        f++;\n                        l = 0;\n                        t = 0;\n                        s = 0;\n                        break;\n                    case '\\n':\n                        l++;\n                        t = 0;\n                        s = 0;\n                        break;\n                    case '\\t':\n                        t++;\n                        s = 0;\n                        break;\n                    default:\n                        s++;\n                        break;\n                }\n            }\n\n            return false;\n        };\n\n        for (UserInput ui : uiList) {\n            if (!decode2.test(ui)) {\n                break;\n            }\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) throws IOException {\n        List<UserInput> uiList = getUserInput();\n        decode(\"theRaven.txt\", uiList);\n    }\n}\n"}
{"id": 415703, "name": "Print debugging statement", "source": "Translate Perl to Java: use Carp;\n\n$str = 'Resistance'; carp \"'$str' is futile.\"; print \"\\n\";\n\ndoodle($str); print \"\\n\";\n\nfiddle(7);\n\nsub doodle { my ($str) = @_; carp \"'$str' is still futile.\" }\n\nsub fiddle { faddle(2*shift) }\nsub faddle { fuddle(3*shift) }\nsub fuddle { ( carp(\"'$_[0]', interesting number.\") ); }\n", "target": "import java.util.Objects;\n\npublic class PrintDebugStatement {\n    \n    private static void printDebug(String message) {\n        Objects.requireNonNull(message);\n\n        RuntimeException exception = new RuntimeException();\n        StackTraceElement[] stackTrace = exception.getStackTrace();\n        \n        \n        StackTraceElement stackTraceElement = stackTrace[1];\n        String fileName = stackTraceElement.getFileName();\n        String className = stackTraceElement.getClassName();\n        String methodName = stackTraceElement.getMethodName();\n        int lineNumber = stackTraceElement.getLineNumber();\n\n        System.out.printf(\"[DEBUG][%s %s.%s#%d] %s\\n\", fileName, className, methodName, lineNumber, message);\n    }\n\n    private static void blah() {\n        printDebug(\"Made It!\");\n    }\n\n    public static void main(String[] args) {\n        printDebug(\"Hello world.\");\n        blah();\n\n        Runnable oops = () -> printDebug(\"oops\");\n        oops.run();\n    }\n}\n"}
{"id": 415704, "name": "Montgomery reduction", "source": "Translate Perl to Java: use bigint;\nuse ntheory qw(powmod);\n\nsub msb {\n  my ($n, $base) = (shift, 0);\n  $base++ while $n >>= 1;\n  $base;\n}\n\nsub montgomery_reduce {\n    my($m, $a) = @_;\n    for (0 .. msb($m)) {\n        $a += $m if $a & 1;\n        $a >>= 1\n    }\n    $a % $m\n}\n\nmy $m  = 750791094644726559640638407699;\nmy $t1 = 323165824550862327179367294465482435542970161392400401329100;\n\nmy $r1 = 440160025148131680164261562101;\nmy $r2 = 435362628198191204145287283255;\n\nmy $x1 = 540019781128412936473322405310;\nmy $x2 = 515692107665463680305819378593;\n\nprintf \"Original x1:       %s\\n\", $x1;\nprintf \"Recovered from r1: %s\\n\", montgomery_reduce($m, $r1);\nprintf \"Original x2:       %s\\n\", $x2;\nprintf \"Recovered from r2: %s\\n\", montgomery_reduce($m, $r2);\n\nprint \"\\nMontgomery  computation x1**x2 mod m: \";\nmy $prod = montgomery_reduce($m, $t1/$x1);\nmy $base = montgomery_reduce($m, $t1);\n\nfor (my $exponent = $x2; $exponent >= 0; $exponent >>= 1) {\n    $prod = montgomery_reduce($m, $prod * $base) if $exponent & 1;\n    $base = montgomery_reduce($m, $base * $base);\n    last if $exponent == 0;\n}\n\nprint montgomery_reduce($m, $prod) . \"\\n\";\nprintf \"Built-in op computation x1**x2 mod m: %s\\n\", powmod($x1, $x2, $m);\n", "target": "import java.math.BigInteger;\n\npublic class MontgomeryReduction {\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    public static class Montgomery {\n        public static final int BASE = 2;\n\n        BigInteger m;\n        BigInteger rrm;\n        int n;\n\n        public Montgomery(BigInteger m) {\n            if (m.compareTo(BigInteger.ZERO) <= 0 || !m.testBit(0)) {\n                throw new IllegalArgumentException();\n            }\n            this.m = m;\n            this.n = m.bitLength();\n            this.rrm = ONE.shiftLeft(n * 2).mod(m);\n        }\n\n        public BigInteger reduce(BigInteger t) {\n            BigInteger a = t;\n            for (int i = 0; i < n; i++) {\n                if (a.testBit(0)) a = a.add(this.m);\n                a = a.shiftRight(1);\n            }\n            if (a.compareTo(m) >= 0) a = a.subtract(this.m);\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        BigInteger m  = new BigInteger(\"750791094644726559640638407699\");\n        BigInteger x1 = new BigInteger(\"540019781128412936473322405310\");\n        BigInteger x2 = new BigInteger(\"515692107665463680305819378593\");\n\n        Montgomery mont = new Montgomery(m);\n        BigInteger t1 = x1.multiply(mont.rrm);\n        BigInteger t2 = x2.multiply(mont.rrm);\n\n        BigInteger r1 = mont.reduce(t1);\n        BigInteger r2 = mont.reduce(t2);\n        BigInteger r = ONE.shiftLeft(mont.n);\n\n        System.out.printf(\"b\u00a0:  %s\\n\", Montgomery.BASE);\n        System.out.printf(\"n\u00a0:  %s\\n\", mont.n);\n        System.out.printf(\"r\u00a0:  %s\\n\", r);\n        System.out.printf(\"m\u00a0:  %s\\n\", mont.m);\n        System.out.printf(\"t1:  %s\\n\", t1);\n        System.out.printf(\"t2:  %s\\n\", t2);\n        System.out.printf(\"r1:  %s\\n\", r1);\n        System.out.printf(\"r2:  %s\\n\", r2);\n        System.out.println();\n        System.out.printf(\"Original x1      \u00a0:  %s\\n\", x1);\n        System.out.printf(\"Recovered from r1\u00a0:  %s\\n\", mont.reduce(r1));\n        System.out.printf(\"Original x2      \u00a0:  %s\\n\", x2);\n        System.out.printf(\"Recovered from r2\u00a0:  %s\\n\", mont.reduce(r2));\n\n        System.out.println();\n        System.out.println(\"Montgomery computation of x1 ^ x2 mod m\u00a0:\");\n        BigInteger prod = mont.reduce(mont.rrm);\n        BigInteger base = mont.reduce(x1.multiply(mont.rrm));\n        BigInteger exp = x2;\n        while (exp.bitLength()>0) {\n            if (exp.testBit(0)) prod=mont.reduce(prod.multiply(base));\n            exp = exp.shiftRight(1);\n            base = mont.reduce(base.multiply(base));\n        }\n        System.out.println(mont.reduce(prod));\n\n        System.out.println();\n        System.out.println(\"Library-based computation of x1 ^ x2 mod m\u00a0:\");\n        System.out.println(x1.modPow(x2, m));\n    }\n}\n"}
{"id": 415705, "name": "Finite state machine", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy ($state, $action, %fsm) = 'ready';\nwhile( <DATA> )\n  {\n  my ($start, $action, $end, $message) = split ' ', $_, 4;\n  $fsm{$start}{$action} = { next => $end, message => $message || \"\\n\" };\n  }\n\nwhile( $state ne 'exit' )\n  {\n  print \"in state $state\\n\";\n  do\n    {\n    ($action) = grep $_ eq 'IMPLICIT', my @actions = sort keys %{$fsm{$state}};\n    if( not $action )\n      {\n      print \"Enter \", join(' or ', @actions), \"\u00a0: \";\n      chomp($action = uc <STDIN>);\n      }\n    }\n  until $fsm{$state}{$action};\n  print $fsm{$state}{$action}{message};\n  $state = $fsm{$state}{$action}{next};\n  }\n\n\n", "target": "import java.util.*;\n\npublic class FiniteStateMachine {\n\n    private enum State {\n        Ready(true, \"Deposit\", \"Quit\"),\n        Waiting(true, \"Select\", \"Refund\"),\n        Dispensing(true, \"Remove\"),\n        Refunding(false, \"Refunding\"),\n        Exiting(false, \"Quiting\");\n\n        State(boolean exp, String... in) {\n            inputs = Arrays.asList(in);\n            explicit = exp;\n        }\n\n        State nextState(String input, State current) {\n            if (inputs.contains(input)) {\n                return map.getOrDefault(input, current);\n            }\n            return current;\n        }\n\n        final List<String> inputs;\n        final static Map<String, State> map = new HashMap<>();\n        final boolean explicit;\n\n        static {\n            map.put(\"Deposit\", State.Waiting);\n            map.put(\"Quit\", State.Exiting);\n            map.put(\"Select\", State.Dispensing);\n            map.put(\"Refund\", State.Refunding);\n            map.put(\"Remove\", State.Ready);\n            map.put(\"Refunding\", State.Ready);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        State state = State.Ready;\n\n        while (state != State.Exiting) {\n            System.out.println(state.inputs);\n            if (state.explicit){\n                System.out.print(\"> \");\n                state = state.nextState(sc.nextLine().trim(), state);\n            } else {\n                state = state.nextState(state.inputs.get(0), state);\n            }\n        }\n    }\n}\n"}
{"id": 415706, "name": "Sokoban", "source": "Translate Perl to Java: \nuse strict;\nuse warnings qw(FATAL all);\nmy @initial = split /\\n/, <<'';\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n=for\nspace is an empty square\n\n@ is the player\n$ is a box\n. is a goal\n+ is the player on a goal\n* is a box on a goal\n=cut\n\n\nmy $cols = length($initial[0]);\nmy $initial = join '', @initial;\nmy $size = length($initial);\ndie unless $size == $cols * @initial;\n\nsub WALL() { 1 }\nsub PLAYER() { 2 }\nsub BOX() { 4 }\nsub GOAL() { 8 }\n\nmy %input = (\n\t' ' => 0, '\n\t'.' => GOAL, '+' => PLAYER|GOAL, '*' => BOX|GOAL,\n);\nmy %output = reverse(%input);\n\nsub packed_initial {\n\tmy $ret = '';\n\tvec( $ret, $_, 4 ) = $input{substr $initial, $_, 1}\n\t\tfor( 0 .. $size-1 );\n\t$ret;\n}\n\nsub printable_board {\n\tmy $board = shift;\n\tmy @c = @output{map vec($board, $_, 4), 0 .. $size-1};\n\tmy $ret = '';\n\twhile( my @row = splice @c, 0, $cols ) {\n\t\t$ret .= join '', @row, \"\\n\";\n\t}\n\t$ret;\n}\n\nmy $packed = packed_initial();\n\nmy @udlr = qw(u d l r);\nmy @UDLR = qw(U D L R);\nmy @deltas = (-$cols, +$cols, -1, +1);\n\nmy %fseen;\nINIT_FORWARD: {\n\t$initial =~ /(\\@|\\+)/ or die;\n\tuse vars qw(@ftodo @fnext);\n\t@ftodo = ([\"\", $packed,  $-[0]]);\n\t$fseen{$packed} = '';\n}\n\nmy %rseen;\nINIT_REVERSE: {\n\tmy $goal = $packed;\n\tvec($goal, $ftodo[0][2], 4) -= PLAYER;\n\tmy @u = grep { my $t = vec($goal, $_, 4); $t & GOAL and not $t & BOX } 0 .. $size-1;\n\tmy @b = grep { my $t = vec($goal, $_, 4); $t & BOX and not $t & GOAL } 0 .. $size-1;\n\tdie unless @u == @b;\n\tvec($goal, $_, 4) += BOX for @u;\n\tvec($goal, $_, 4) -= BOX for @b;\n\tuse vars qw(@rtodo @rnext);\n\tFINAL_PLACE: for my $player (0 .. $size-1) {\n\t\tnext if vec($goal, $player, 4);\n\t\tFIND_GOAL: {\n\t\t\tvec($goal, $player + $_, 4) & GOAL and last FIND_GOAL for @deltas;\n\t\t\tnext FINAL_PLACE;\n\t\t}\n\t\tmy $a_goal = $goal;\n\t\tvec($a_goal, $player, 4) += PLAYER;\n\t\tpush @rtodo, [\"\", $a_goal, $player ];\n\t\t$rseen{$a_goal} = '';\n\t\t\n\t}\n}\n\nmy $movelen = -1;\nmy ($solution);\nMAIN: while( @ftodo and @rtodo ) {\n\n\tFORWARD: {\n\t\tmy ($moves, $level, $player) = @{pop @ftodo};\n\t\tdie unless vec($level, $player, 4) & PLAYER;\n\n\t\tfor my $dir_num (0 .. 3) {\n\t\t\tmy $delta = $deltas[$dir_num];\n\t\t\tmy @loc = map $player + $delta * $_, 0 .. 2;\n\t\t\tmy @val = map vec($level, $_, 4), @loc;\n\n\t\t\tnext if $val[1] & WALL or ($val[1] & BOX and $val[2] & (BOX|WALL));\n\t\t\t\n\t\t\tmy $new = $level;\n\t\t\tvec($new, $loc[0], 4) -= PLAYER;\n\t\t\tvec($new, $loc[1], 4) += PLAYER;\n\t\t\tmy $nmoves;\n\t\t\tif( $val[1] & BOX ) {\n\t\t\t\tvec($new, $loc[1], 4) -= BOX;\n\t\t\t\tvec($new, $loc[2], 4) += BOX;\n\t\t\t\t$nmoves = $moves . $UDLR[$dir_num];\n\t\t\t} else {\n\t\t\t\t$nmoves = $moves . $udlr[$dir_num];\n\t\t\t}\n\t\t\t\n\t\t\tnext if exists $fseen{$new};\n\t\t\t$fseen{$new} = $nmoves;\n\n\t\t\tpush @fnext, [ $nmoves, $new, $loc[1] ];\n\n\t\t\texists $rseen{$new} or next;\n\t\t\t\n\t\t\t$solution = $new;\n\t\t\tlast MAIN;\n\t\t}\n\n\t\tlast FORWARD if @ftodo;\n\t\tuse vars qw(*ftodo *fnext);\n\t\t(*ftodo, *fnext) = (\\@fnext, \\@ftodo);\n\t} \n\t\n\tBACKWARD: {\n\t\tmy ($moves, $level, $player) = @{pop @rtodo};\n\t\tdie \"<$level>\" unless vec($level, $player, 4) & PLAYER;\n\n\t\tfor my $dir_num (0 .. 3) {\n\t\t\tmy $delta = $deltas[$dir_num];\n\t\t\t\n\t\t\tmy @loc = map $player + $delta * $_, -1 .. 1;\n\t\t\tmy @val = map vec($level, $_, 4), @loc;\n\n\t\t\t\n\t\t\tnext if $val[0] & (WALL|BOX);\n\t\t\tmy $new = $level;\n\t\t\tvec($new, $loc[0], 4) += PLAYER;\n\t\t\tvec($new, $loc[1], 4) -= PLAYER;\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif( $val[2] & BOX ) {\n\t\t\t\tmy $pull = $new;\n\t\t\t\tvec($pull, $loc[2], 4) -= BOX;\n\t\t\t\tvec($pull, $loc[1], 4) += BOX;\n\t\t\t\tgoto RWALK if exists $rseen{$pull};\n\t\t\t\tmy $pmoves = $UDLR[$dir_num] . $moves;\n\t\t\t\t$rseen{$pull} = $pmoves;\n\t\t\t\tpush @rnext, [$pmoves, $pull, $loc[0]];\n\t\t\t\tgoto RWALK unless exists $fseen{$pull};\n\t\t\t\tprint \"Doing pull\\n\";\n\t\t\t\t$solution = $pull;\n\t\t\t\tlast MAIN;\n\t\t\t}\n\t\t\tRWALK:\n\t\t\tnext if exists $rseen{$new}; \n\t\t\tmy $wmoves = $udlr[$dir_num] . $moves;\n\t\t\t$rseen{$new} = $wmoves;\n\t\t\tpush @rnext, [$wmoves, $new, $loc[0]];\n\t\t\tnext unless exists $fseen{$new};\n\t\t\tprint \"Rwalk\\n\";\n\t\t\t$solution = $new;\n\t\t\tlast MAIN;\n\t\t}\n\n\t\tlast BACKWARD if @rtodo;\n\t\tuse vars qw(*rtodo *rnext);\n\t\t(*rtodo, *rnext) = (\\@rnext, \\@rtodo);\n\t} \n}\n\nif( $solution ) {\n\tmy $fmoves = $fseen{$solution};\n\tmy $rmoves = $rseen{$solution};\n\tprint \"Solution found!\\n\";\n\tprint \"Time: \", (time() - $^T), \" seconds\\n\";\n\tprint \"Moves: $fmoves $rmoves\\n\";\n\tprint \"Move Length: \", length($fmoves . $rmoves), \"\\n\";\n\tprint \"Middle Board: \\n\", printable_board($solution);\n} else {\n\tprint \"No solution found!\\n\";\n}\n", "target": "import java.util.*;\n\npublic class Sokoban {\n    String destBoard, currBoard;\n    int playerX, playerY, nCols;\n\n    Sokoban(String[] board) {\n        nCols = board[0].length();\n        StringBuilder destBuf = new StringBuilder();\n        StringBuilder currBuf = new StringBuilder();\n\n        for (int r = 0; r < board.length; r++) {\n            for (int c = 0; c < nCols; c++) {\n\n                char ch = board[r].charAt(c);\n\n                destBuf.append(ch != '$' && ch != '@' ? ch : ' ');\n                currBuf.append(ch != '.' ? ch : ' ');\n\n                if (ch == '@') {\n                    this.playerX = c;\n                    this.playerY = r;\n                }\n            }\n        }\n        destBoard = destBuf.toString();\n        currBoard = currBuf.toString();\n    }\n\n    String move(int x, int y, int dx, int dy, String trialBoard) {\n\n        int newPlayerPos = (y + dy) * nCols + x + dx;\n\n        if (trialBoard.charAt(newPlayerPos) != ' ')\n            return null;\n\n        char[] trial = trialBoard.toCharArray();\n        trial[y * nCols + x] = ' ';\n        trial[newPlayerPos] = '@';\n\n        return new String(trial);\n    }\n\n    String push(int x, int y, int dx, int dy, String trialBoard) {\n\n        int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;\n\n        if (trialBoard.charAt(newBoxPos) != ' ')\n            return null;\n\n        char[] trial = trialBoard.toCharArray();\n        trial[y * nCols + x] = ' ';\n        trial[(y + dy) * nCols + x + dx] = '@';\n        trial[newBoxPos] = '$';\n\n        return new String(trial);\n    }\n\n    boolean isSolved(String trialBoard) {\n        for (int i = 0; i < trialBoard.length(); i++)\n            if ((destBoard.charAt(i) == '.')\n                    != (trialBoard.charAt(i) == '$'))\n                return false;\n        return true;\n    }\n\n    String solve() {\n        class Board {\n            String cur, sol;\n            int x, y;\n\n            Board(String s1, String s2, int px, int py) {\n                cur = s1;\n                sol = s2;\n                x = px;\n                y = py;\n            }\n        }\n        char[][] dirLabels = {{'u', 'U'}, {'r', 'R'}, {'d', 'D'}, {'l', 'L'}};\n        int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n\n        Set<String> history = new HashSet<>();\n        LinkedList<Board> open = new LinkedList<>();\n\n        history.add(currBoard);\n        open.add(new Board(currBoard, \"\", playerX, playerY));\n\n        while (!open.isEmpty()) {\n            Board item = open.poll();\n            String cur = item.cur;\n            String sol = item.sol;\n            int x = item.x;\n            int y = item.y;\n\n            for (int i = 0; i < dirs.length; i++) {\n                String trial = cur;\n                int dx = dirs[i][0];\n                int dy = dirs[i][1];\n\n                \n                if (trial.charAt((y + dy) * nCols + x + dx) == '$') {\n\n                    \n                    if ((trial = push(x, y, dx, dy, trial)) != null) {\n\n                        \n                        if (!history.contains(trial)) {\n\n                            String newSol = sol + dirLabels[i][1];\n\n                            if (isSolved(trial))\n                                return newSol;\n\n                            open.add(new Board(trial, newSol, x + dx, y + dy));\n                            history.add(trial);\n                        }\n                    }\n\n                \n                } else if ((trial = move(x, y, dx, dy, trial)) != null) {\n\n                    if (!history.contains(trial)) {\n                        String newSol = sol + dirLabels[i][0];\n                        open.add(new Board(trial, newSol, x + dx, y + dy));\n                        history.add(trial);\n                    }\n                }\n            }\n        }\n        return \"No solution\";\n    }\n\n    public static void main(String[] a) {\n        String level = \"#######,#     #,#     #,#. #  #,#. $$ #,\"\n                + \"#.$$  #,#.#  @#,#######\";\n        System.out.println(new Sokoban(level.split(\",\")).solve());\n    }\n}\n"}
{"id": 415707, "name": "Zumkeller numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <is_prime divisor_sum divisors vecsum forcomb lastfor>;\n\nsub in_columns {\n    my($columns, $values) = @_;\n    my @v = split ' ', $values;\n    my $width = int(80/$columns);\n    printf \"%${width}d\"x$columns.\"\\n\", @v[$_*$columns .. -1+(1+$_)*$columns] for 0..-1+@v/$columns;\n    print \"\\n\";\n}\n\nsub is_Zumkeller {\n    my($n) = @_;\n    return 0 if is_prime($n);\n    my @divisors = divisors($n);\n    return 0 unless @divisors > 2 && 0 == @divisors % 2;\n    my $sigma = divisor_sum($n);\n    return 0 unless 0 == $sigma%2 && ($sigma/2) >= $n;\n    if (1 == $n%2) {\n        return 1\n    } else {\n        my $Z = 0;\n        forcomb { $Z++, lastfor if vecsum(@divisors[@_]) == $sigma/2 } @divisors;\n        return $Z;\n    }\n}\n\nuse constant Inf  => 1e10;\n\nsay 'First 220 Zumkeller numbers:';\nmy $n = 0; my $z;\n$z .= do { $n < 220 ? (is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(20, $z);\n\nsay 'First 40 odd Zumkeller numbers:';\n$n = 0; $z = '';\n$z .= do { $n < 40 ? (!!($_%2) and is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(10, $z);\n\nsay 'First 40 odd Zumkeller numbers not divisible by 5:';\n$n = 0; $z = '';\n$z .= do { $n < 40 ? (!!($_%2 and $_%5) and is_Zumkeller($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\nin_columns(10, $z);\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ZumkellerNumbers {\n\n    public static void main(String[] args) {\n        int n = 1;\n        System.out.printf(\"First 220 Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 220 ; n += 1 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%3d  \", n);\n                if ( count % 20 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%6d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers that do not end in a 5:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( n % 5 != 0 && isZumkeller(n) ) {\n                System.out.printf(\"%8d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n\n    }\n    \n    private static boolean isZumkeller(int n) {\n        \n        if ( n % 18 == 6 || n % 18 == 12 ) {\n            return true;\n        }\n        \n        List<Integer> divisors = getDivisors(n);        \n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        \n        \n        if ( divisorSum % 2 == 1 ) {\n            return false;\n        }\n        \n        \n        int abundance = divisorSum - 2 * n;\n        if ( n % 2 == 1 && abundance > 0 && abundance % 2 == 0 ) {\n            return true;\n        }\n        \n        Collections.sort(divisors);\n        int j = divisors.size() - 1;\n        int sum = divisorSum/2;\n        \n        \n        if ( divisors.get(j) > sum ) {\n            return false;\n        }\n        \n        return canPartition(j, divisors, sum, new int[2]);\n    }\n    \n    private static boolean canPartition(int j, List<Integer> divisors, int sum, int[] buckets) {\n        if ( j < 0 ) {\n            return true;\n        }\n        for ( int i = 0 ; i < 2 ; i++ ) {\n            if ( buckets[i] + divisors.get(j) <= sum ) {\n                buckets[i] += divisors.get(j);\n                if ( canPartition(j-1, divisors, sum, buckets) ) {\n                    return true;\n                }\n                buckets[i] -= divisors.get(j);\n            }\n            if( buckets[i] == 0 ) {\n                break;\n            }\n        }\n        return false;\n    }\n    \n    private static final List<Integer> getDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 415708, "name": "Commatizing numbers", "source": "Translate Perl to Java: @input = (\n    ['pi=3.14159265358979323846264338327950288419716939937510582097494459231', ' ', 5],\n    ['The author has two Z$100000000000000 Zimbabwe notes (100 trillion).', '.'],\n    ['-in Aus$+1411.8millions'],\n    ['===US$0017440 millions=== (in 2000 dollars)'],\n    ['123.e8000 is pretty big.'],\n    ['The land area of the earth is  57268900(29% of the surface)  square miles.'],\n    ['Ain\\'t no numbers in this here words, nohow, no way, Jose.'],\n    ['James was never known as  0000000007'],\n    ['Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.'],\n    ['   $-140000\u00b1100  millions.'],\n    ['5/9/1946 was a good year for some.']\n);\n\nfor $i (@input) {\n    $old = @$i[0];\n    $new = commatize(@$i);\n    printf(\"%s\\n%s\\n\\n\", $old, $new) if $old ne $new;\n}\n\nsub commatize {\n    my($str,$sep,$by) = @_;\n    $sep = ',' unless $sep;\n    $by  = 3   unless $by;\n\n    $str =~ s/                      \n            (?<![eE\\/])             \n            ([1-9]\\d{$by,})         \n            /c_ins($1,$by,$sep)/ex; \n    return $str;\n}\n\nsub c_ins {\n    my($s,$by,$sep) = @_;\n    ($c = reverse $s) =~ s/(.{$by})/$1$sep/g;\n    $c =~ s/$sep$//;\n    return reverse $c;\n}\n", "target": "import java.io.File;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class CommatizingNumbers {\n\n    public static void main(String[] args) throws Exception {\n        commatize(\"pi=3.14159265358979323846264338327950288419716939937510582\"\n                + \"097494459231\", 6, 5, \" \");\n\n        commatize(\"The author has two Z$100000000000000 Zimbabwe notes (100 \"\n                + \"trillion).\", 0, 3, \".\");\n\n        try (Scanner sc = new Scanner(new File(\"input.txt\"))) {\n            while(sc.hasNext())\n                commatize(sc.nextLine());\n        }\n    }\n\n    static void commatize(String s) {\n        commatize(s, 0, 3, \",\");\n    }\n\n    static void commatize(String s, int start, int step, String ins) {\n        if (start < 0 || start > s.length() || step < 1 || step > s.length())\n            return;\n\n        Matcher m = Pattern.compile(\"([1-9][0-9]*)\").matcher(s.substring(start));\n        StringBuffer result = new StringBuffer(s.substring(0, start));\n\n        if (m.find()) {\n            StringBuilder sb = new StringBuilder(m.group(1)).reverse();\n            for (int i = step; i < sb.length(); i += step)\n                sb.insert(i++, ins);\n            m.appendReplacement(result, sb.reverse().toString());\n        }\n\n        System.out.println(m.appendTail(result));\n    }\n}\n"}
{"id": 415709, "name": "Rare numbers", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse integer;\n\nmy $count = 0;\nmy @squares;\nfor my $large ( 0 .. 1e5 )\n  {\n  my $largesquared = $squares[$large] = $large * $large; \n  for my $small ( 0 .. $large - 1 )\n    {\n    my $n = $largesquared + $squares[$small];\n    2 * $large * $small == reverse $n or next;\n    printf \"%12s %s\\n\", $n, scalar reverse $n;\n    $n == reverse $n and die \"oops!\"; \n    ++$count >= 5 and exit;\n    }\n  }\n", "target": "import java.time.Duration;\nimport java.time.LocalDateTime;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\n\npublic class RareNumbers {\n    public interface Consumer5<A, B, C, D, E> {\n        void apply(A a, B b, C c, D d, E e);\n    }\n\n    public interface Consumer7<A, B, C, D, E, F, G> {\n        void apply(A a, B b, C c, D d, E e, F f, G g);\n    }\n\n    public interface Recursable5<A, B, C, D, E> {\n        void apply(A a, B b, C c, D d, E e, Recursable5<A, B, C, D, E> r);\n    }\n\n    public interface Recursable7<A, B, C, D, E, F, G> {\n        void apply(A a, B b, C c, D d, E e, F f, G g, Recursable7<A, B, C, D, E, F, G> r);\n    }\n\n    public static <A, B, C, D, E> Consumer5<A, B, C, D, E> recurse(Recursable5<A, B, C, D, E> r) {\n        return (a, b, c, d, e) -> r.apply(a, b, c, d, e, r);\n    }\n\n    public static <A, B, C, D, E, F, G> Consumer7<A, B, C, D, E, F, G> recurse(Recursable7<A, B, C, D, E, F, G> r) {\n        return (a, b, c, d, e, f, g) -> r.apply(a, b, c, d, e, f, g, r);\n    }\n\n    private static class Term {\n        long coeff;\n        byte ix1, ix2;\n\n        public Term(long coeff, byte ix1, byte ix2) {\n            this.coeff = coeff;\n            this.ix1 = ix1;\n            this.ix2 = ix2;\n        }\n    }\n\n    private static final int MAX_DIGITS = 16;\n\n    private static long toLong(List<Byte> digits, boolean reverse) {\n        long sum = 0;\n        if (reverse) {\n            for (int i = digits.size() - 1; i >= 0; --i) {\n                sum = sum * 10 + digits.get(i);\n            }\n        } else {\n            for (Byte digit : digits) {\n                sum = sum * 10 + digit;\n            }\n        }\n        return sum;\n    }\n\n    private static boolean isNotSquare(long n) {\n        long root = (long) Math.sqrt(n);\n        return root * root != n;\n    }\n\n    private static List<Byte> seq(byte from, byte to, byte step) {\n        List<Byte> res = new ArrayList<>();\n        for (byte i = from; i <= to; i += step) {\n            res.add(i);\n        }\n        return res;\n    }\n\n    private static String commatize(long n) {\n        String s = String.valueOf(n);\n        int le = s.length();\n        int i = le - 3;\n        while (i >= 1) {\n            s = s.substring(0, i) + \",\" + s.substring(i);\n            i -= 3;\n        }\n        return s;\n    }\n\n    public static void main(String[] args) {\n        final LocalDateTime startTime = LocalDateTime.now();\n        long pow = 1L;\n        System.out.println(\"Aggregate timings to process all numbers up to:\");\n        \n        List<List<Term>> allTerms = new ArrayList<>();\n        for (int i = 0; i < MAX_DIGITS - 1; ++i) {\n            allTerms.add(new ArrayList<>());\n        }\n        for (int r = 2; r <= MAX_DIGITS; ++r) {\n            List<Term> terms = new ArrayList<>();\n            pow *= 10;\n            long pow1 = pow;\n            long pow2 = 1;\n            byte i1 = 0;\n            byte i2 = (byte) (r - 1);\n            while (i1 < i2) {\n                terms.add(new Term(pow1 - pow2, i1, i2));\n\n                pow1 /= 10;\n                pow2 *= 10;\n\n                i1++;\n                i2--;\n            }\n            allTerms.set(r - 2, terms);\n        }\n        \n        Map<Byte, List<List<Byte>>> fml = Map.of(\n            (byte) 0, List.of(List.of((byte) 2, (byte) 2), List.of((byte) 8, (byte) 8)),\n            (byte) 1, List.of(List.of((byte) 6, (byte) 5), List.of((byte) 8, (byte) 7)),\n            (byte) 4, List.of(List.of((byte) 4, (byte) 0)),\n            (byte) 6, List.of(List.of((byte) 6, (byte) 0), List.of((byte) 8, (byte) 2))\n        );\n        \n        Map<Byte, List<List<Byte>>> dmd = new HashMap<>();\n        for (int i = 0; i < 100; ++i) {\n            List<Byte> a = List.of((byte) (i / 10), (byte) (i % 10));\n\n            int d = a.get(0) - a.get(1);\n            dmd.computeIfAbsent((byte) d, k -> new ArrayList<>()).add(a);\n        }\n        List<Byte> fl = List.of((byte) 0, (byte) 1, (byte) 4, (byte) 6);\n        List<Byte> dl = seq((byte) -9, (byte) 9, (byte) 1); \n        List<Byte> zl = List.of((byte) 0);                  \n        List<Byte> el = seq((byte) -8, (byte) 8, (byte) 2); \n        List<Byte> ol = seq((byte) -9, (byte) 9, (byte) 2); \n        List<Byte> il = seq((byte) 0, (byte) 9, (byte) 1);\n        List<Long> rares = new ArrayList<>();\n        List<List<List<Byte>>> lists = new ArrayList<>();\n        for (int i = 0; i < 4; ++i) {\n            lists.add(new ArrayList<>());\n        }\n        for (int i = 0; i < fl.size(); ++i) {\n            List<List<Byte>> temp1 = new ArrayList<>();\n            List<Byte> temp2 = new ArrayList<>();\n            temp2.add(fl.get(i));\n            temp1.add(temp2);\n            lists.set(i, temp1);\n        }\n        final AtomicReference<List<Byte>> digits = new AtomicReference<>(new ArrayList<>());\n        AtomicInteger count = new AtomicInteger();\n\n        \n        \n        Consumer7<List<Byte>, List<Byte>, List<List<Byte>>, List<List<Byte>>, Long, Integer, Integer> fnpr = recurse((cand, di, dis, indicies, nmr, nd, level, func) -> {\n            if (level == dis.size()) {\n                digits.get().set(indicies.get(0).get(0), fml.get(cand.get(0)).get(di.get(0)).get(0));\n                digits.get().set(indicies.get(0).get(1), fml.get(cand.get(0)).get(di.get(0)).get(1));\n                int le = di.size();\n                if (nd % 2 == 1) {\n                    le--;\n                    digits.get().set(nd / 2, di.get(le));\n                }\n                for (int i = 1; i < le; ++i) {\n                    digits.get().set(indicies.get(i).get(0), dmd.get(cand.get(i)).get(di.get(i)).get(0));\n                    digits.get().set(indicies.get(i).get(1), dmd.get(cand.get(i)).get(di.get(i)).get(1));\n                }\n                long r = toLong(digits.get(), true);\n                long npr = nmr + 2 * r;\n                if (isNotSquare(npr)) {\n                    return;\n                }\n                count.getAndIncrement();\n                System.out.printf(\"     R/N %2d:\", count.get());\n                LocalDateTime checkPoint = LocalDateTime.now();\n                long elapsed = Duration.between(startTime, checkPoint).toMillis();\n                System.out.printf(\"  %9sms\", elapsed);\n                long n = toLong(digits.get(), false);\n                System.out.printf(\"  (%s)\\n\", commatize(n));\n                rares.add(n);\n            } else {\n                for (Byte num : dis.get(level)) {\n                    di.set(level, num);\n                    func.apply(cand, di, dis, indicies, nmr, nd, level + 1, func);\n                }\n            }\n        });\n\n        \n        Consumer5<List<Byte>, List<List<Byte>>, List<List<Byte>>, Integer, Integer> fnmr = recurse((cand, list, indicies, nd, level, func) -> {\n            if (level == list.size()) {\n                long nmr = 0;\n                long nmr2 = 0;\n                List<Term> terms = allTerms.get(nd - 2);\n                for (int i = 0; i < terms.size(); ++i) {\n                    Term t = terms.get(i);\n                    if (cand.get(i) >= 0) {\n                        nmr += t.coeff * cand.get(i);\n                    } else {\n                        nmr2 += t.coeff * -cand.get(i);\n                        if (nmr >= nmr2) {\n                            nmr -= nmr2;\n                            nmr2 = 0;\n                        } else {\n                            nmr2 -= nmr;\n                            nmr = 0;\n                        }\n                    }\n                }\n                if (nmr2 >= nmr) {\n                    return;\n                }\n                nmr -= nmr2;\n                if (isNotSquare(nmr)) {\n                    return;\n                }\n                List<List<Byte>> dis = new ArrayList<>();\n                dis.add(seq((byte) 0, (byte) (fml.get(cand.get(0)).size() - 1), (byte) 1));\n                for (int i = 1; i < cand.size(); ++i) {\n                    dis.add(seq((byte) 0, (byte) (dmd.get(cand.get(i)).size() - 1), (byte) 1));\n                }\n                if (nd % 2 == 1) {\n                    dis.add(il);\n                }\n                List<Byte> di = new ArrayList<>();\n                for (int i = 0; i < dis.size(); ++i) {\n                    di.add((byte) 0);\n                }\n                fnpr.apply(cand, di, dis, indicies, nmr, nd, 0);\n            } else {\n                for (Byte num : list.get(level)) {\n                    cand.set(level, num);\n                    func.apply(cand, list, indicies, nd, level + 1, func);\n                }\n            }\n        });\n\n        for (int nd = 2; nd <= MAX_DIGITS; ++nd) {\n            digits.set(new ArrayList<>());\n            for (int i = 0; i < nd; ++i) {\n                digits.get().add((byte) 0);\n            }\n            if (nd == 4) {\n                lists.get(0).add(zl);\n                lists.get(1).add(ol);\n                lists.get(2).add(el);\n                lists.get(3).add(ol);\n            } else if (allTerms.get(nd - 2).size() > lists.get(0).size()) {\n                for (int i = 0; i < 4; ++i) {\n                    lists.get(i).add(dl);\n                }\n            }\n            List<List<Byte>> indicies = new ArrayList<>();\n            for (Term t : allTerms.get(nd - 2)) {\n                indicies.add(List.of(t.ix1, t.ix2));\n            }\n            for (List<List<Byte>> list : lists) {\n                List<Byte> cand = new ArrayList<>();\n                for (int i = 0; i < list.size(); ++i) {\n                    cand.add((byte) 0);\n                }\n                fnmr.apply(cand, list, indicies, nd, 0);\n            }\n            LocalDateTime checkPoint = LocalDateTime.now();\n            long elapsed = Duration.between(startTime, checkPoint).toMillis();\n            System.out.printf(\"  %2d digits:  %9sms\\n\", nd, elapsed);\n        }\n\n        Collections.sort(rares);\n        System.out.printf(\"\\nThe rare numbers with up to %d digits are:\\n\", MAX_DIGITS);\n        for (int i = 0; i < rares.size(); ++i) {\n            System.out.printf(\"  %2d:  %25s\\n\", i + 1, commatize(rares.get(i)));\n        }\n    }\n}\n"}
{"id": 415710, "name": "Suffix tree", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Data::Dumper;\n \nsub classify {\n    my $h = {};\n    for (@_) { push @{$h->{substr($_,0,1)}}, $_ }\n    return $h;\n}\nsub suffixes {\n    my $str = shift;\n    map { substr $str, $_ } 0 .. length($str) - 1;\n}\nsub suffix_tree {\n    return +{} if @_ == 0;\n    return +{ $_[0] => +{} } if @_ == 1;\n    my $h = {};\n    my $classif = classify @_;\n    for my $key (keys %$classif) {\n        my $subtree = suffix_tree(\n            map { substr $_, 1 } @{$classif->{$key}}\n        );\n        my @subkeys = keys %$subtree;\n        if (@subkeys == 1) {\n            my ($subkey) = @subkeys;\n            $h->{\"$key$subkey\"} = $subtree->{$subkey};\n        } else { $h->{$key} = $subtree }\n    }\n    return $h;\n}\nprint +Dumper suffix_tree suffixes 'banana$';\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SuffixTreeProblem {\n    private static class Node {\n        String sub = \"\";                       \n        List<Integer> ch = new ArrayList<>();  \n    }\n\n    private static class SuffixTree {\n        private List<Node> nodes = new ArrayList<>();\n\n        public SuffixTree(String str) {\n            nodes.add(new Node());\n            for (int i = 0; i < str.length(); ++i) {\n                addSuffix(str.substring(i));\n            }\n        }\n\n        private void addSuffix(String suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.length()) {\n                char b = suf.charAt(i);\n                List<Integer> children = nodes.get(n).ch;\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    if (x2 == children.size()) {\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = suf.substring(i);\n                        nodes.add(temp);\n                        children.add(n2);\n                        return;\n                    }\n                    n2 = children.get(x2);\n                    if (nodes.get(n2).sub.charAt(0) == b) break;\n                    x2++;\n                }\n                \n                String sub2 = nodes.get(n2).sub;\n                int j = 0;\n                while (j < sub2.length()) {\n                    if (suf.charAt(i + j) != sub2.charAt(j)) {\n                        \n                        int n3 = n2;\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = sub2.substring(0, j);\n                        temp.ch.add(n3);\n                        nodes.add(temp);\n                        nodes.get(n3).sub = sub2.substring(j);  \n                        nodes.get(n).ch.set(x2, n2);\n                        break;  \n                    }\n                    j++;\n                }\n                i += j;  \n                n = n2;  \n            }\n        }\n\n        public void visualize() {\n            if (nodes.isEmpty()) {\n                System.out.println(\"<empty>\");\n                return;\n            }\n            visualize_f(0, \"\");\n        }\n\n        private void visualize_f(int n, String pre) {\n            List<Integer> children = nodes.get(n).ch;\n            if (children.isEmpty()) {\n                System.out.println(\"- \" + nodes.get(n).sub);\n                return;\n            }\n            System.out.println(\"\u2510 \" + nodes.get(n).sub);\n            for (int i = 0; i < children.size() - 1; i++) {\n                Integer c = children.get(i);\n                System.out.print(pre + \"\u251c\u2500\");\n                visualize_f(c, pre + \"\u2502 \");\n            }\n            System.out.print(pre + \"\u2514\u2500\");\n            visualize_f(children.get(children.size() - 1), pre + \"  \");\n        }\n    }\n\n    public static void main(String[] args) {\n        new SuffixTree(\"banana$\").visualize();\n    }\n}\n"}
{"id": 415711, "name": "Suffix tree", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Data::Dumper;\n \nsub classify {\n    my $h = {};\n    for (@_) { push @{$h->{substr($_,0,1)}}, $_ }\n    return $h;\n}\nsub suffixes {\n    my $str = shift;\n    map { substr $str, $_ } 0 .. length($str) - 1;\n}\nsub suffix_tree {\n    return +{} if @_ == 0;\n    return +{ $_[0] => +{} } if @_ == 1;\n    my $h = {};\n    my $classif = classify @_;\n    for my $key (keys %$classif) {\n        my $subtree = suffix_tree(\n            map { substr $_, 1 } @{$classif->{$key}}\n        );\n        my @subkeys = keys %$subtree;\n        if (@subkeys == 1) {\n            my ($subkey) = @subkeys;\n            $h->{\"$key$subkey\"} = $subtree->{$subkey};\n        } else { $h->{$key} = $subtree }\n    }\n    return $h;\n}\nprint +Dumper suffix_tree suffixes 'banana$';\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SuffixTreeProblem {\n    private static class Node {\n        String sub = \"\";                       \n        List<Integer> ch = new ArrayList<>();  \n    }\n\n    private static class SuffixTree {\n        private List<Node> nodes = new ArrayList<>();\n\n        public SuffixTree(String str) {\n            nodes.add(new Node());\n            for (int i = 0; i < str.length(); ++i) {\n                addSuffix(str.substring(i));\n            }\n        }\n\n        private void addSuffix(String suf) {\n            int n = 0;\n            int i = 0;\n            while (i < suf.length()) {\n                char b = suf.charAt(i);\n                List<Integer> children = nodes.get(n).ch;\n                int x2 = 0;\n                int n2;\n                while (true) {\n                    if (x2 == children.size()) {\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = suf.substring(i);\n                        nodes.add(temp);\n                        children.add(n2);\n                        return;\n                    }\n                    n2 = children.get(x2);\n                    if (nodes.get(n2).sub.charAt(0) == b) break;\n                    x2++;\n                }\n                \n                String sub2 = nodes.get(n2).sub;\n                int j = 0;\n                while (j < sub2.length()) {\n                    if (suf.charAt(i + j) != sub2.charAt(j)) {\n                        \n                        int n3 = n2;\n                        \n                        n2 = nodes.size();\n                        Node temp = new Node();\n                        temp.sub = sub2.substring(0, j);\n                        temp.ch.add(n3);\n                        nodes.add(temp);\n                        nodes.get(n3).sub = sub2.substring(j);  \n                        nodes.get(n).ch.set(x2, n2);\n                        break;  \n                    }\n                    j++;\n                }\n                i += j;  \n                n = n2;  \n            }\n        }\n\n        public void visualize() {\n            if (nodes.isEmpty()) {\n                System.out.println(\"<empty>\");\n                return;\n            }\n            visualize_f(0, \"\");\n        }\n\n        private void visualize_f(int n, String pre) {\n            List<Integer> children = nodes.get(n).ch;\n            if (children.isEmpty()) {\n                System.out.println(\"- \" + nodes.get(n).sub);\n                return;\n            }\n            System.out.println(\"\u2510 \" + nodes.get(n).sub);\n            for (int i = 0; i < children.size() - 1; i++) {\n                Integer c = children.get(i);\n                System.out.print(pre + \"\u251c\u2500\");\n                visualize_f(c, pre + \"\u2502 \");\n            }\n            System.out.print(pre + \"\u2514\u2500\");\n            visualize_f(children.get(children.size() - 1), pre + \"  \");\n        }\n    }\n\n    public static void main(String[] args) {\n        new SuffixTree(\"banana$\").visualize();\n    }\n}\n"}
{"id": 415712, "name": "Reflection_List properties", "source": "Translate Perl to Java: {\n     package Point;\n     use Class::Spiffy -base;\n\n     field 'x';\n     field 'y';\n}\n\n{\n     package Circle;\n     use base qw(Point);\n     field 'r';\n}\n\nmy $p1 = Point->new(x => 8, y => -5);\nmy $c1 = Circle->new(r => 4);\nmy $c2 = Circle->new(x => 1, y => 2, r => 3);\n\nuse Data::Dumper;\nsay Dumper $p1;\nsay Dumper $c1;\nsay Dumper $c2;\n", "target": "import java.lang.reflect.Field;\n\npublic class ListFields {\n    public int examplePublicField = 42;\n    private boolean examplePrivateField = true;\n    \n    public static void main(String[] args) throws IllegalAccessException {\n        ListFields obj = new ListFields();\n        Class clazz = obj.getClass();\n\n        System.out.println(\"All public fields (including inherited):\");\n        for (Field f : clazz.getFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n        System.out.println();\n        System.out.println(\"All declared fields (excluding inherited):\");\n        for (Field f : clazz.getDeclaredFields()) {\n            System.out.printf(\"%s\\t%s\\n\", f, f.get(obj));\n        }\n    }\n}\n"}
{"id": 415713, "name": "Eertree", "source": "Translate Perl to Java: $str = \"eertree\";\n\nfor $n (1 .. length($str)) {\n   for $m (1 .. length($str)) {\n      $strrev = \"\";\n      $strpal = substr($str, $n-1, $m);\n      if ($strpal ne \"\") {\n         for $p (reverse 1 .. length($strpal)) {\n            $strrev .= substr($strpal, $p-1, 1);\n         }\n         ($strpal eq $strrev) and push @pal, $strpal;\n      }\n   }\n}\n\nprint join ' ', grep {not $seen{$_}++} @pal, \"\\n\";\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Eertree {\n    public static void main(String[] args) {\n        List<Node> tree = eertree(\"eertree\");\n        List<String> result = subPalindromes(tree);\n        System.out.println(result);\n    }\n\n    private static class Node {\n        int length;\n        Map<Character, Integer> edges = new HashMap<>();\n        int suffix;\n\n        public Node(int length) {\n            this.length = length;\n        }\n\n        public Node(int length, Map<Character, Integer> edges, int suffix) {\n            this.length = length;\n            this.edges = edges != null ? edges : new HashMap<>();\n            this.suffix = suffix;\n        }\n    }\n\n    private static final int EVEN_ROOT = 0;\n    private static final int ODD_ROOT = 1;\n\n    private static List<Node> eertree(String s) {\n        List<Node> tree = new ArrayList<>();\n        tree.add(new Node(0, null, ODD_ROOT));\n        tree.add(new Node(-1, null, ODD_ROOT));\n        int suffix = ODD_ROOT;\n        int n, k;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            for (n = suffix; ; n = tree.get(n).suffix) {\n                k = tree.get(n).length;\n                int b = i - k - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            if (tree.get(n).edges.containsKey(c)) {\n                suffix = tree.get(n).edges.get(c);\n                continue;\n            }\n            suffix = tree.size();\n            tree.add(new Node(k + 2));\n            tree.get(n).edges.put(c, suffix);\n            if (tree.get(suffix).length == 1) {\n                tree.get(suffix).suffix = 0;\n                continue;\n            }\n            while (true) {\n                n = tree.get(n).suffix;\n                int b = i - tree.get(n).length - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            tree.get(suffix).suffix = tree.get(n).edges.get(c);\n        }\n        return tree;\n    }\n\n    private static List<String> subPalindromes(List<Node> tree) {\n        List<String> s = new ArrayList<>();\n        subPalindromes_children(0, \"\", tree, s);\n        for (Map.Entry<Character, Integer> cm : tree.get(1).edges.entrySet()) {\n            String ct = String.valueOf(cm.getKey());\n            s.add(ct);\n            subPalindromes_children(cm.getValue(), ct, tree, s);\n        }\n        return s;\n    }\n\n    \n    private static void subPalindromes_children(final int n, final String p, final List<Node> tree, List<String> s) {\n        for (Map.Entry<Character, Integer> cm : tree.get(n).edges.entrySet()) {\n            Character c = cm.getKey();\n            Integer m = cm.getValue();\n            String pl = c + p + c;\n            s.add(pl);\n            subPalindromes_children(m, pl, tree, s);\n        }\n    }\n}\n"}
{"id": 415714, "name": "Eertree", "source": "Translate Perl to Java: $str = \"eertree\";\n\nfor $n (1 .. length($str)) {\n   for $m (1 .. length($str)) {\n      $strrev = \"\";\n      $strpal = substr($str, $n-1, $m);\n      if ($strpal ne \"\") {\n         for $p (reverse 1 .. length($strpal)) {\n            $strrev .= substr($strpal, $p-1, 1);\n         }\n         ($strpal eq $strrev) and push @pal, $strpal;\n      }\n   }\n}\n\nprint join ' ', grep {not $seen{$_}++} @pal, \"\\n\";\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class Eertree {\n    public static void main(String[] args) {\n        List<Node> tree = eertree(\"eertree\");\n        List<String> result = subPalindromes(tree);\n        System.out.println(result);\n    }\n\n    private static class Node {\n        int length;\n        Map<Character, Integer> edges = new HashMap<>();\n        int suffix;\n\n        public Node(int length) {\n            this.length = length;\n        }\n\n        public Node(int length, Map<Character, Integer> edges, int suffix) {\n            this.length = length;\n            this.edges = edges != null ? edges : new HashMap<>();\n            this.suffix = suffix;\n        }\n    }\n\n    private static final int EVEN_ROOT = 0;\n    private static final int ODD_ROOT = 1;\n\n    private static List<Node> eertree(String s) {\n        List<Node> tree = new ArrayList<>();\n        tree.add(new Node(0, null, ODD_ROOT));\n        tree.add(new Node(-1, null, ODD_ROOT));\n        int suffix = ODD_ROOT;\n        int n, k;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            for (n = suffix; ; n = tree.get(n).suffix) {\n                k = tree.get(n).length;\n                int b = i - k - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            if (tree.get(n).edges.containsKey(c)) {\n                suffix = tree.get(n).edges.get(c);\n                continue;\n            }\n            suffix = tree.size();\n            tree.add(new Node(k + 2));\n            tree.get(n).edges.put(c, suffix);\n            if (tree.get(suffix).length == 1) {\n                tree.get(suffix).suffix = 0;\n                continue;\n            }\n            while (true) {\n                n = tree.get(n).suffix;\n                int b = i - tree.get(n).length - 1;\n                if (b >= 0 && s.charAt(b) == c) {\n                    break;\n                }\n            }\n            tree.get(suffix).suffix = tree.get(n).edges.get(c);\n        }\n        return tree;\n    }\n\n    private static List<String> subPalindromes(List<Node> tree) {\n        List<String> s = new ArrayList<>();\n        subPalindromes_children(0, \"\", tree, s);\n        for (Map.Entry<Character, Integer> cm : tree.get(1).edges.entrySet()) {\n            String ct = String.valueOf(cm.getKey());\n            s.add(ct);\n            subPalindromes_children(cm.getValue(), ct, tree, s);\n        }\n        return s;\n    }\n\n    \n    private static void subPalindromes_children(final int n, final String p, final List<Node> tree, List<String> s) {\n        for (Map.Entry<Character, Integer> cm : tree.get(n).edges.entrySet()) {\n            Character c = cm.getKey();\n            Integer m = cm.getValue();\n            String pl = c + p + c;\n            s.add(pl);\n            subPalindromes_children(m, pl, tree, s);\n        }\n    }\n}\n"}
{"id": 415715, "name": "Base58Check encoding", "source": "Translate Perl to Java: use Math::BigInt;\n\nsub encode_base58 {\n    my ($num) = @_;\n    $num = Math::BigInt->new($num);\n\n    my $chars = [qw(\n    1 2 3 4 5 6 7 8 9\n    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z\n    a b c d e f g h i j k   m n o p q r s t u v w x y z\n    )];\n\n    my $base58;\n    while ($num->is_pos) {\n        my ($quotient, $remainder) = $num->bdiv(58);\n        $base58 = $chars->[$remainder] . $base58;\n    }\n    $base58\n}\n\nprintf \"%56s -> %s\\n\", $_, encode_base58(+$_)\n    for qw(\n     25420294593250030202636073700053352635053786165627414518\n     0x61\n     0x626262\n     0x636363\n     0x73696d706c792061206c6f6e6720737472696e67\n     0x516b6fcd0f\n     0xbf4f89001e670274dd\n     0x572e4794\n     0xecac89cad93923c02321\n     0x10c8511e\n    );\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Base58CheckEncoding {\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    private static final BigInteger BIG0 = BigInteger.ZERO;\n    private static final BigInteger BIG58 = BigInteger.valueOf(58);\n\n    private static String convertToBase58(String hash) {\n        return convertToBase58(hash, 16);\n    }\n\n    private static String convertToBase58(String hash, int base) {\n        BigInteger x;\n        if (base == 16 && hash.substring(0, 2).equals(\"0x\")) {\n            x = new BigInteger(hash.substring(2), 16);\n        } else {\n            x = new BigInteger(hash, base);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (x.compareTo(BIG0) > 0) {\n            int r = x.mod(BIG58).intValue();\n            sb.append(ALPHABET.charAt(r));\n            x = x.divide(BIG58);\n        }\n\n        return sb.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"25420294593250030202636073700053352635053786165627414518\";\n        String b = convertToBase58(s, 10);\n        System.out.printf(\"%s -> %s\\n\", s, b);\n\n        List<String> hashes = List.of(\n            \"0x61\",\n            \"0x626262\",\n            \"0x636363\",\n            \"0x73696d706c792061206c6f6e6720737472696e67\",\n            \"0x516b6fcd0f\",\n            \"0xbf4f89001e670274dd\",\n            \"0x572e4794\",\n            \"0xecac89cad93923c02321\",\n            \"0x10c8511e\"\n        );\n        for (String hash : hashes) {\n            String b58 = convertToBase58(hash);\n            System.out.printf(\"%-56s -> %s\\n\", hash, b58);\n        }\n    }\n}\n"}
{"id": 415716, "name": "Base58Check encoding", "source": "Translate Perl to Java: use Math::BigInt;\n\nsub encode_base58 {\n    my ($num) = @_;\n    $num = Math::BigInt->new($num);\n\n    my $chars = [qw(\n    1 2 3 4 5 6 7 8 9\n    A B C D E F G H   J K L M N   P Q R S T U V W X Y Z\n    a b c d e f g h i j k   m n o p q r s t u v w x y z\n    )];\n\n    my $base58;\n    while ($num->is_pos) {\n        my ($quotient, $remainder) = $num->bdiv(58);\n        $base58 = $chars->[$remainder] . $base58;\n    }\n    $base58\n}\n\nprintf \"%56s -> %s\\n\", $_, encode_base58(+$_)\n    for qw(\n     25420294593250030202636073700053352635053786165627414518\n     0x61\n     0x626262\n     0x636363\n     0x73696d706c792061206c6f6e6720737472696e67\n     0x516b6fcd0f\n     0xbf4f89001e670274dd\n     0x572e4794\n     0xecac89cad93923c02321\n     0x10c8511e\n    );\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Base58CheckEncoding {\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    private static final BigInteger BIG0 = BigInteger.ZERO;\n    private static final BigInteger BIG58 = BigInteger.valueOf(58);\n\n    private static String convertToBase58(String hash) {\n        return convertToBase58(hash, 16);\n    }\n\n    private static String convertToBase58(String hash, int base) {\n        BigInteger x;\n        if (base == 16 && hash.substring(0, 2).equals(\"0x\")) {\n            x = new BigInteger(hash.substring(2), 16);\n        } else {\n            x = new BigInteger(hash, base);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (x.compareTo(BIG0) > 0) {\n            int r = x.mod(BIG58).intValue();\n            sb.append(ALPHABET.charAt(r));\n            x = x.divide(BIG58);\n        }\n\n        return sb.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"25420294593250030202636073700053352635053786165627414518\";\n        String b = convertToBase58(s, 10);\n        System.out.printf(\"%s -> %s\\n\", s, b);\n\n        List<String> hashes = List.of(\n            \"0x61\",\n            \"0x626262\",\n            \"0x636363\",\n            \"0x73696d706c792061206c6f6e6720737472696e67\",\n            \"0x516b6fcd0f\",\n            \"0xbf4f89001e670274dd\",\n            \"0x572e4794\",\n            \"0xecac89cad93923c02321\",\n            \"0x10c8511e\"\n        );\n        for (String hash : hashes) {\n            String b58 = convertToBase58(hash);\n            System.out.printf(\"%-56s -> %s\\n\", hash, b58);\n        }\n    }\n}\n"}
{"id": 415717, "name": "Latin Squares in reduced form", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy $n = 0;\nmy $count;\nour @perms;\n\nwhile( ++$n <= 7 )\n  {\n  $count = 0;\n  @perms = perm( my $start = join '', 1 .. $n );\n  find( $start );\n  print \"order $n size $count total @{[$count * fact($n) * fact($n-1)]}\\n\\n\";\n  }\n\nsub find\n  {\n  @_ >= $n and return $count += ($n != 4) || print join \"\\n\", @_, \"\\n\";\n  local @perms = grep 0 == ($_[-1] ^ $_) =~ tr/\\0//, @perms;\n  my $row = @_ + 1;\n  find( @_, $_ ) for grep /^$row/, @perms;\n  }\n\nsub fact { $_[0] > 1 ? $_[0] * fact($_[0] - 1) : 1 }\n\nsub perm\n  {\n  my $s = shift;\n  length $s <= 1 ? $s :\n    map { my $f = $_; map \"$f$_\", perm( $s =~ s/$_//r ) } split //, $s;\n  }\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class LatinSquaresInReducedForm {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Reduced latin squares of order 4:%n\");\n        for ( LatinSquare square : getReducedLatinSquares(4) ) {\n            System.out.printf(\"%s%n\", square);\n        }\n        \n        System.out.printf(\"Compute the number of latin squares from count of reduced latin squares:%n(Reduced Latin Square Count) * n! * (n-1)! = Latin Square Count%n\");\n        for ( int n = 1 ; n <= 6 ; n++ ) {\n            List<LatinSquare> list = getReducedLatinSquares(n);\n            System.out.printf(\"Size = %d, %d * %d * %d =\u00a0%,d%n\", n, list.size(), fact(n), fact(n-1), list.size()*fact(n)*fact(n-1));\n        }\n    }\n    \n    private static long fact(int n) {\n        if ( n == 0 ) {\n            return 1;\n        }\n        int prod = 1;\n        for ( int i = 1 ; i <= n ; i++ ) {\n            prod *= i;\n        }\n        return prod;\n    }\n    \n    private static List<LatinSquare> getReducedLatinSquares(int n) {\n        List<LatinSquare> squares = new ArrayList<>();\n        \n        squares.add(new LatinSquare(n));\n        PermutationGenerator permGen = new PermutationGenerator(n);\n        for ( int fillRow = 1 ; fillRow < n ; fillRow++ ) {\n            List<LatinSquare> squaresNext = new ArrayList<>();\n            for ( LatinSquare square : squares ) {\n                while ( permGen.hasMore() ) {\n                    int[] perm = permGen.getNext();\n                    \n                    \n                    if ( (perm[0]+1) != (fillRow+1) ) {\n                        continue;\n                    }\n                    \n                    \n                    boolean permOk = true;\n                    done:\n                    for ( int row = 0 ; row < fillRow ; row++ ) {\n                        for ( int col = 0 ; col < n ; col++ ) {\n                            if ( square.get(row, col) == (perm[col]+1) ) {\n                                permOk = false;\n                                break done;\n                            }\n                        }\n                    }\n                    if ( permOk ) {\n                        LatinSquare newSquare = new LatinSquare(square);\n                        for ( int col = 0 ; col < n ; col++ ) {\n                            newSquare.set(fillRow, col, perm[col]+1);\n                        }\n                        squaresNext.add(newSquare);\n                    }\n                }\n                permGen.reset();\n            }\n            squares = squaresNext;\n        }\n        \n        return squares;\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static int[] display(int[] in) {\n        int [] out = new int[in.length];\n        for ( int i = 0 ; i < in.length ; i++ ) {\n            out[i] = in[i] + 1;\n        }\n        return out;\n    }\n    \n    private static class LatinSquare {\n        \n        int[][] square;\n        int size;\n        \n        public LatinSquare(int n) {\n            square = new int[n][n];\n            size = n;\n            for ( int col = 0 ; col < n ; col++ ) {\n                set(0, col, col + 1);\n            }\n        }\n        \n        public LatinSquare(LatinSquare ls) {\n            int n = ls.size;\n            square = new int[n][n];\n            size = n;\n            for ( int row = 0 ; row < n ; row++ ) {\n                for ( int col = 0 ; col < n ; col++ ) {\n                    set(row, col, ls.get(row, col));\n                }\n            }\n        }\n        \n        public void set(int row, int col, int value) {\n            square[row][col] = value;\n        }\n\n        public int get(int row, int col) {\n            return square[row][col];\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            for ( int row = 0 ; row < size ; row++ ) {\n                sb.append(Arrays.toString(square[row]));\n                sb.append(\"\\n\");\n            }\n            return sb.toString();\n        }\n        \n        \n    }\n\n    private static class PermutationGenerator {\n\n        private int[] a;\n        private BigInteger numLeft;\n        private BigInteger total;\n\n        public PermutationGenerator (int n) {\n            if (n < 1) {\n                throw new IllegalArgumentException (\"Min 1\");\n            }\n            a = new int[n];\n            total = getFactorial(n);\n            reset();\n        }\n\n        private void reset () {\n            for ( int i = 0 ; i < a.length ; i++ ) {\n                a[i] = i;\n            }\n            numLeft = new BigInteger(total.toString());\n        }\n\n        public boolean hasMore() {\n            return numLeft.compareTo(BigInteger.ZERO) == 1;\n        }\n\n        private static BigInteger getFactorial (int n) {\n            BigInteger fact = BigInteger.ONE;\n            for ( int i = n ; i > 1 ; i-- ) {\n                fact = fact.multiply(new BigInteger(Integer.toString(i)));\n            }\n            return fact;\n        }\n\n        \n        public int[] getNext() {\n            if ( numLeft.equals(total) ) {\n                numLeft = numLeft.subtract (BigInteger.ONE);\n                return a;\n            }\n\n            \n            int j = a.length - 2;\n            while ( a[j] > a[j+1] ) {\n                j--;\n            }\n\n            \n            int k = a.length - 1;\n            while ( a[j] > a[k] ) {\n                k--;\n            }\n\n            \n            int temp = a[k];\n            a[k] = a[j];\n            a[j] = temp;\n\n            \n            int r = a.length - 1;\n            int s = j + 1;\n            while (r > s) {\n                int temp2 = a[s];\n                a[s] = a[r];\n                a[r] = temp2;\n                r--;\n                s++;\n            }\n\n            numLeft = numLeft.subtract(BigInteger.ONE);\n            return a;\n        }\n    }\n\n}\n"}
{"id": 415718, "name": "Kosaraju", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub kosaraju {\n    our(%k) = @_;\n    our %g = ();\n    our %h;\n    my $i = 0;\n    $g{$_}     = $i++ for sort keys %k;\n    $h{$g{$_}} = $_   for      keys %g; \n\n    our(%visited, @stack, @transpose, @connected);\n    sub visit {\n        my($u) = @_;\n        unless ($visited{$u}) {\n            $visited{$u} = 1;\n            for my $v (@{$k{$u}}) {\n                visit($v);\n                push @{$transpose[$g{$v}]}, $u;\n            }\n            push @stack, $u;\n        }\n    }\n\n    sub assign {\n        my($u, $root) = @_;\n        if ($visited{$u}) {\n            $visited{$u} = 0;\n            $connected[$g{$u}] = $root;\n            assign($_, $root) for @{$transpose[$g{$u}]};\n        }\n    }\n\n    visit($_) for sort keys %g;\n    assign($_, $_) for reverse @stack;\n\n    my %groups;\n    for my $i (0..$\n        my $id = $g{$connected[$i]};\n        push @{$groups{$id}}, $h{$i};\n    }\n    say join ' ', @{$groups{$_}} for sort keys %groups;\n}\n\nmy %test1 = (\n    0 => [1],\n    1 => [2],\n    2 => [0],\n    3 => [1, 2, 4],\n    4 => [3, 5],\n    5 => [2, 6],\n    6 => [5],\n    7 => [4, 6, 7]\n);\n\nmy %test2 = (\n   'Andy' => ['Bart'],\n   'Bart' => ['Carl'],\n   'Carl' => ['Andy'],\n   'Dave' => [<Bart Carl Earl>],\n   'Earl' => [<Dave Fred>],\n   'Fred' => [<Carl Gary>],\n   'Gary' => ['Fred'],\n   'Hank' => [<Earl Gary Hank>]\n);\n\nkosaraju(%test1);\nsay '';\nkosaraju(%test2);\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.BiConsumer;\nimport java.util.function.IntConsumer;\nimport java.util.stream.Collectors;\n\npublic class Kosaraju {\n    static class Recursive<I> {\n        I func;\n    }\n\n    private static List<Integer> kosaraju(List<List<Integer>> g) {\n        \n        int size = g.size();\n        boolean[] vis = new boolean[size];\n        int[] l = new int[size];\n        AtomicInteger x = new AtomicInteger(size);\n\n        List<List<Integer>> t = new ArrayList<>();\n        for (int i = 0; i < size; ++i) {\n            t.add(new ArrayList<>());\n        }\n\n        Recursive<IntConsumer> visit = new Recursive<>();\n        visit.func = (int u) -> {\n            if (!vis[u]) {\n                vis[u] = true;\n                for (Integer v : g.get(u)) {\n                    visit.func.accept(v);\n                    t.get(v).add(u);\n                }\n                int xval = x.decrementAndGet();\n                l[xval] = u;\n            }\n        };\n\n        \n        for (int i = 0; i < size; ++i) {\n            visit.func.accept(i);\n        }\n        int[] c = new int[size];\n\n        Recursive<BiConsumer<Integer, Integer>> assign = new Recursive<>();\n        assign.func = (Integer u, Integer root) -> {\n            if (vis[u]) {  \n                vis[u] = false;\n                c[u] = root;\n                for (Integer v : t.get(u)) {\n                    assign.func.accept(v, root);\n                }\n            }\n        };\n\n        \n        for (int u : l) {\n            assign.func.accept(u, u);\n        }\n\n        return Arrays.stream(c).boxed().collect(Collectors.toList());\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> g = new ArrayList<>();\n        for (int i = 0; i < 8; ++i) {\n            g.add(new ArrayList<>());\n        }\n        g.get(0).add(1);\n        g.get(1).add(2);\n        g.get(2).add(0);\n        g.get(3).add(1);\n        g.get(3).add(2);\n        g.get(3).add(4);\n        g.get(4).add(3);\n        g.get(4).add(5);\n        g.get(5).add(2);\n        g.get(5).add(6);\n        g.get(6).add(5);\n        g.get(7).add(4);\n        g.get(7).add(6);\n        g.get(7).add(7);\n\n        List<Integer> output = kosaraju(g);\n        System.out.println(output);\n    }\n}\n"}
{"id": 415719, "name": "Word search", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature <bitwise>;\nuse Path::Tiny;\nuse List::Util qw( shuffle );\n\nmy $size = 10;\nmy $s1 = $size + 1;\n$_ = <<END;\n.....R....\n......O...\n.......S..\n........E.\nT........T\n.A........\n..C.......\n...O......\n....D.....\n.....E....\nEND\n\nmy @words = shuffle path('/usr/share/dict/words')->slurp =~ /^[a-z]{3,7}$/gm;\nmy @played;\nmy %used;\n\nfor my $word ( (@words) x 5 )\n  {\n  my ($pat, $start, $end, $mask, $nulls) = find( $word );\n  defined $pat or next;\n  $used{$word}++ and next; \n  $nulls //= '';\n  my $expand = $word =~ s/\\B/$nulls/gr;\n  my $pos = $start;\n  if( $start > $end )\n    {\n    $pos = $end;\n    $expand = reverse $expand;\n    }\n  substr $_, $pos, length $mask,\n    (substr( $_, $pos, length $mask ) &. ~. \"$mask\") |. \"$expand\";\n  push @played, join ' ', $word, $start, $end;\n  tr/.// > 0 or last;\n  }\n\nprint \"   0 1 2 3 4 5 6 7 8 9\\n\\n\";\nmy $row = 0;\nprint s/(?<=.)(?=.)/ /gr =~ s/^/ $row++ . '  ' /gemr;\nprint \"\\nNumber of words: \", @played . \"\\n\\n\";\nmy @where = map\n  {\n  my ($word, $start, $end) = split;\n  sprintf \"%11s %s\", $word, $start < $end\n    ? \"(@{[$start\u00a0% $s1]},@{[int $start / $s1]})->\" .\n      \"(@{[$end\u00a0% $s1 - 1]},@{[int $end / $s1]})\"\n    : \"(@{[$start\u00a0% $s1 - 1]},@{[int $start / $s1]})->\" .\n      \"(@{[$end\u00a0% $s1]},@{[int $end / $s1]})\";\n  } sort @played;\nprint splice(@where, 0, 3), \"\\n\" while @where;\ntr/.// and die \"incomplete\";\n\nsub find\n  {\n  my ($word) = @_;\n  my $n = length $word;\n  my $nm1 = $n - 1;\n  my %pats;\n\n  for my $space ( 0, $size - 1 .. $size + 1 )\n    {\n    my $nulls = \"\\0\" x $space;\n    my $mask = \"\\xff\" . ($nulls . \"\\xff\") x $nm1; \n    my $gap = qr/.{$space}/s;\n    while( /(?=(.(?:$gap.){$nm1}))/g )\n      {\n      my $pat = ($1 &. $mask) =~ tr/\\0//dr;\n      $pat =~ tr/.// or next;\n      my $pos = \"$-[1] $+[1]\";\n      $word =~ /$pat/ or reverse($word) =~ /$pat/ or next;\n      push @{ $pats{$pat} }, \"$pos $mask $nulls\";\n      }\n    }\n\n  for my $key ( sort keys %pats )\n    {\n    if( $word =~ /^$key$/ )\n      {\n      my @all = @{ $pats{$key} };\n      return $key, split ' ', $all[ rand @all ];\n      }\n    elsif( (reverse $word) =~ /^$key$/ )\n      {\n      my @all = @{ $pats{$key} };\n      my @parts = split ' ', $all[ rand @all ];\n      return $key, @parts[ 1, 0, 2, 3]\n      }\n    }\n\n  return undef;\n  }\n", "target": "import java.io.*;\nimport static java.lang.String.format;\nimport java.util.*;\n\npublic class WordSearch {\n    static class Grid {\n        int numAttempts;\n        char[][] cells = new char[nRows][nCols];\n        List<String> solutions = new ArrayList<>();\n    }\n\n    final static int[][] dirs = {{1, 0}, {0, 1}, {1, 1}, {1, -1}, {-1, 0},\n    {0, -1}, {-1, -1}, {-1, 1}};\n\n    final static int nRows = 10;\n    final static int nCols = 10;\n    final static int gridSize = nRows * nCols;\n    final static int minWords = 25;\n\n    final static Random rand = new Random();\n\n    public static void main(String[] args) {\n        printResult(createWordSearch(readWords(\"unixdict.txt\")));\n    }\n\n    static List<String> readWords(String filename) {\n        int maxLen = Math.max(nRows, nCols);\n\n        List<String> words = new ArrayList<>();\n        try (Scanner sc = new Scanner(new FileReader(filename))) {\n            while (sc.hasNext()) {\n                String s = sc.next().trim().toLowerCase();\n                if (s.matches(\"^[a-z]{3,\" + maxLen + \"}$\"))\n                    words.add(s);\n            }\n        } catch (FileNotFoundException e) {\n            System.out.println(e);\n        }\n        return words;\n    }\n\n    static Grid createWordSearch(List<String> words) {\n        Grid grid = null;\n        int numAttempts = 0;\n\n        outer:\n        while (++numAttempts < 100) {\n            Collections.shuffle(words);\n\n            grid = new Grid();\n            int messageLen = placeMessage(grid, \"Rosetta Code\");\n            int target = gridSize - messageLen;\n\n            int cellsFilled = 0;\n            for (String word : words) {\n                cellsFilled += tryPlaceWord(grid, word);\n                if (cellsFilled == target) {\n                    if (grid.solutions.size() >= minWords) {\n                        grid.numAttempts = numAttempts;\n                        break outer;\n                    } else break; \n                }\n            }\n        }\n\n        return grid;\n    }\n\n    static int placeMessage(Grid grid, String msg) {\n        msg = msg.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n\n        int messageLen = msg.length();\n        if (messageLen > 0 && messageLen < gridSize) {\n            int gapSize = gridSize / messageLen;\n\n            for (int i = 0; i < messageLen; i++) {\n                int pos = i * gapSize + rand.nextInt(gapSize);\n                grid.cells[pos / nCols][pos % nCols] = msg.charAt(i);\n            }\n            return messageLen;\n        }\n        return 0;\n    }\n\n    static int tryPlaceWord(Grid grid, String word) {\n        int randDir = rand.nextInt(dirs.length);\n        int randPos = rand.nextInt(gridSize);\n\n        for (int dir = 0; dir < dirs.length; dir++) {\n            dir = (dir + randDir) % dirs.length;\n\n            for (int pos = 0; pos < gridSize; pos++) {\n                pos = (pos + randPos) % gridSize;\n\n                int lettersPlaced = tryLocation(grid, word, dir, pos);\n                if (lettersPlaced > 0)\n                    return lettersPlaced;\n            }\n        }\n        return 0;\n    }\n\n    static int tryLocation(Grid grid, String word, int dir, int pos) {\n\n        int r = pos / nCols;\n        int c = pos % nCols;\n        int len = word.length();\n\n        \n        if ((dirs[dir][0] == 1 && (len + c) > nCols)\n                || (dirs[dir][0] == -1 && (len - 1) > c)\n                || (dirs[dir][1] == 1 && (len + r) > nRows)\n                || (dirs[dir][1] == -1 && (len - 1) > r))\n            return 0;\n\n        int rr, cc, i, overlaps = 0;\n\n        \n        for (i = 0, rr = r, cc = c; i < len; i++) {\n            if (grid.cells[rr][cc] != 0 && grid.cells[rr][cc] != word.charAt(i))\n                return 0;\n            cc += dirs[dir][0];\n            rr += dirs[dir][1];\n        }\n\n        \n        for (i = 0, rr = r, cc = c; i < len; i++) {\n            if (grid.cells[rr][cc] == word.charAt(i))\n                overlaps++;\n            else\n                grid.cells[rr][cc] = word.charAt(i);\n\n            if (i < len - 1) {\n                cc += dirs[dir][0];\n                rr += dirs[dir][1];\n            }\n        }\n\n        int lettersPlaced = len - overlaps;\n        if (lettersPlaced > 0) {\n            grid.solutions.add(format(\"%-10s (%d,%d)(%d,%d)\", word, c, r, cc, rr));\n        }\n\n        return lettersPlaced;\n    }\n\n    static void printResult(Grid grid) {\n        if (grid == null || grid.numAttempts == 0) {\n            System.out.println(\"No grid to display\");\n            return;\n        }\n        int size = grid.solutions.size();\n\n        System.out.println(\"Attempts: \" + grid.numAttempts);\n        System.out.println(\"Number of words: \" + size);\n\n        System.out.println(\"\\n     0  1  2  3  4  5  6  7  8  9\");\n        for (int r = 0; r < nRows; r++) {\n            System.out.printf(\"%n%d   \", r);\n            for (int c = 0; c < nCols; c++)\n                System.out.printf(\" %c \", grid.cells[r][c]);\n        }\n\n        System.out.println(\"\\n\");\n\n        for (int i = 0; i < size - 1; i += 2) {\n            System.out.printf(\"%s   %s%n\", grid.solutions.get(i),\n                    grid.solutions.get(i + 1));\n        }\n        if (size % 2 == 1)\n            System.out.println(grid.solutions.get(size - 1));\n    }\n}\n"}
{"id": 415720, "name": "Markov chain text generator", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $file = shift || 'alice_oz.txt';\nmy $n    = shift || 3;\nmy $max  = shift || 200;\n\nsub build_dict {\n    my ($n, @words) = @_;\n    my %dict;\n    for my $i (0 .. $\n        my @prefix = @words[$i .. $i+$n-1];\n        push @{$dict{join ' ', @prefix}}, $words[$i+$n];\n    }\n    return %dict;\n}\n\nsub pick1 { $_[rand @_] }\n\nmy $text = do {\n    open my $fh, '<', $file;\n    local $/;\n    <$fh>;\n};\n\nmy @words = split ' ', $text;\npush @words, @words[0..$n-1];\nmy %dict  = build_dict($n, @words);\nmy @rotor = @words[0..$n-1];\nmy @chain = @rotor;\n\nfor (1 .. $max) {\n    my $new = pick1(@{$dict{join ' ', @rotor}});\n    shift @rotor;\n    push @rotor, $new;\n    push @chain, $new;\n}\n\nprint join(' ', @chain) . \"\\n\";\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Random;\n\npublic class MarkovChain {\n    private static Random r = new Random();\n\n    private static String markov(String filePath, int keySize, int outputSize) throws IOException {\n        if (keySize < 1) throw new IllegalArgumentException(\"Key size can't be less than 1\");\n        Path path = Paths.get(filePath);\n        byte[] bytes = Files.readAllBytes(path);\n        String[] words = new String(bytes).trim().split(\" \");\n        if (outputSize < keySize || outputSize >= words.length) {\n            throw new IllegalArgumentException(\"Output size is out of range\");\n        }\n        Map<String, List<String>> dict = new HashMap<>();\n\n        for (int i = 0; i < (words.length - keySize); ++i) {\n            StringBuilder key = new StringBuilder(words[i]);\n            for (int j = i + 1; j < i + keySize; ++j) {\n                key.append(' ').append(words[j]);\n            }\n            String value = (i + keySize < words.length) ? words[i + keySize] : \"\";\n            if (!dict.containsKey(key.toString())) {\n                ArrayList<String> list = new ArrayList<>();\n                list.add(value);\n                dict.put(key.toString(), list);\n            } else {\n                dict.get(key.toString()).add(value);\n            }\n        }\n\n        int n = 0;\n        int rn = r.nextInt(dict.size());\n        String prefix = (String) dict.keySet().toArray()[rn];\n        List<String> output = new ArrayList<>(Arrays.asList(prefix.split(\" \")));\n\n        while (true) {\n            List<String> suffix = dict.get(prefix);\n            if (suffix.size() == 1) {\n                if (Objects.equals(suffix.get(0), \"\")) return output.stream().reduce(\"\", (a, b) -> a + \" \" + b);\n                output.add(suffix.get(0));\n            } else {\n                rn = r.nextInt(suffix.size());\n                output.add(suffix.get(rn));\n            }\n            if (output.size() >= outputSize) return output.stream().limit(outputSize).reduce(\"\", (a, b) -> a + \" \" + b);\n            n++;\n            prefix = output.stream().skip(n).limit(keySize).reduce(\"\", (a, b) -> a + \" \" + b).trim();\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        System.out.println(markov(\"alice_oz.txt\", 3, 200));\n    }\n}\n"}
{"id": 415721, "name": "Arithmetic coding_As a generalized change of radix", "source": "Translate Perl to Java: use Math::BigInt (try => 'GMP');\n\nsub cumulative_freq {\n    my ($freq) = @_;\n\n    my %cf;\n    my $total = Math::BigInt->new(0);\n    foreach my $c (sort keys %$freq) {\n        $cf{$c} = $total;\n        $total += $freq->{$c};\n    }\n\n    return %cf;\n}\n\nsub arithmethic_coding {\n    my ($str, $radix) = @_;\n    my @chars = split(//, $str);\n\n    \n    my %freq;\n    $freq{$_}++ for @chars;\n\n    \n    my %cf = cumulative_freq(\\%freq);\n\n    \n    my $base = Math::BigInt->new(scalar @chars);\n\n    \n    my $L = Math::BigInt->new(0);\n\n    \n    my $pf = Math::BigInt->new(1);\n\n    \n    \n    foreach my $c (@chars) {\n        $L->bmuladd($base, $cf{$c} * $pf);\n        $pf->bmul($freq{$c});\n    }\n\n    \n    my $U = $L + $pf;\n\n    my $pow = Math::BigInt->new($pf)->blog($radix);\n    my $enc = ($U - 1)->bdiv(Math::BigInt->new($radix)->bpow($pow));\n\n    return ($enc, $pow, \\%freq);\n}\n\nsub arithmethic_decoding {\n    my ($enc, $radix, $pow, $freq) = @_;\n\n    \n    $enc *= $radix**$pow;\n\n    \n    my $base = Math::BigInt->new(0);\n    $base += $_ for values %{$freq};\n\n    \n    my %cf = cumulative_freq($freq);\n\n    \n    my %dict;\n    while (my ($k, $v) = each %cf) {\n        $dict{$v} = $k;\n    }\n\n    \n    my $lchar;\n    foreach my $i (0 .. $base - 1) {\n        if (exists $dict{$i}) {\n            $lchar = $dict{$i};\n        }\n        elsif (defined $lchar) {\n            $dict{$i} = $lchar;\n        }\n    }\n\n    \n    my $decoded = '';\n    for (my $pow = $base**($base - 1) ; $pow > 0 ; $pow /= $base) {\n        my $div = $enc / $pow;\n\n        my $c  = $dict{$div};\n        my $fv = $freq->{$c};\n        my $cv = $cf{$c};\n\n        $enc = ($enc - $pow * $cv) / $fv;\n        $decoded .= $c;\n    }\n\n    \n    return $decoded;\n}\n\nmy $radix = 10;    \n\nforeach my $str (qw(DABDDB DABDDBBDDBA ABRACADABRA TOBEORNOTTOBEORTOBEORNOT)) {\n    my ($enc, $pow, $freq) = arithmethic_coding($str, $radix);\n    my $dec = arithmethic_decoding($enc, $radix, $pow, $freq);\n\n    printf(\"%-25s=> %19s * %d^%s\\n\", $str, $enc, $radix, $pow);\n\n    if ($str ne $dec) {\n        die \"\\tHowever that is incorrect!\";\n    }\n}\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Objects;\n\npublic class ArithmeticCoding {\n    private static class Triple<A, B, C> {\n        A a;\n        B b;\n        C c;\n\n        Triple(A a, B b, C c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n    }\n\n    private static class Freq extends HashMap<Character, Long> {\n        \n    }\n\n    private static Freq cumulativeFreq(Freq freq) {\n        long total = 0;\n        Freq cf = new Freq();\n        for (int i = 0; i < 256; ++i) {\n            char c = (char) i;\n            Long v = freq.get(c);\n            if (v != null) {\n                cf.put(c, total);\n                total += v;\n            }\n        }\n        return cf;\n    }\n\n    private static Triple<BigInteger, Integer, Freq> arithmeticCoding(String str, Long radix) {\n        \n        char[] chars = str.toCharArray();\n\n        \n        Freq freq = new Freq();\n        for (char c : chars) {\n            if (!freq.containsKey(c))\n                freq.put(c, 1L);\n            else\n                freq.put(c, freq.get(c) + 1);\n        }\n\n        \n        Freq cf = cumulativeFreq(freq);\n\n        \n        BigInteger base = BigInteger.valueOf(chars.length);\n\n        \n        BigInteger lower = BigInteger.ZERO;\n\n        \n        BigInteger pf = BigInteger.ONE;\n\n        \n        \n        for (char c : chars) {\n            BigInteger x = BigInteger.valueOf(cf.get(c));\n            lower = lower.multiply(base).add(x.multiply(pf));\n            pf = pf.multiply(BigInteger.valueOf(freq.get(c)));\n        }\n\n        \n        BigInteger upper = lower.add(pf);\n\n        int powr = 0;\n        BigInteger bigRadix = BigInteger.valueOf(radix);\n\n        while (true) {\n            pf = pf.divide(bigRadix);\n            if (pf.equals(BigInteger.ZERO)) break;\n            powr++;\n        }\n\n        BigInteger diff = upper.subtract(BigInteger.ONE).divide(bigRadix.pow(powr));\n        return new Triple<>(diff, powr, freq);\n    }\n\n    private static String arithmeticDecoding(BigInteger num, long radix, int pwr, Freq freq) {\n        BigInteger powr = BigInteger.valueOf(radix);\n        BigInteger enc = num.multiply(powr.pow(pwr));\n        long base = 0;\n        for (Long v : freq.values()) base += v;\n\n        \n        Freq cf = cumulativeFreq(freq);\n\n        \n        Map<Long, Character> dict = new HashMap<>();\n        for (Map.Entry<Character, Long> entry : cf.entrySet()) dict.put(entry.getValue(), entry.getKey());\n\n        \n        long lchar = -1;\n        for (long i = 0; i < base; ++i) {\n            Character v = dict.get(i);\n            if (v != null) {\n                lchar = v;\n            } else if (lchar != -1) {\n                dict.put(i, (char) lchar);\n            }\n        }\n\n        \n        StringBuilder decoded = new StringBuilder((int) base);\n        BigInteger bigBase = BigInteger.valueOf(base);\n        for (long i = base - 1; i >= 0; --i) {\n            BigInteger pow = bigBase.pow((int) i);\n            BigInteger div = enc.divide(pow);\n            Character c = dict.get(div.longValue());\n            BigInteger fv = BigInteger.valueOf(freq.get(c));\n            BigInteger cv = BigInteger.valueOf(cf.get(c));\n            BigInteger diff = enc.subtract(pow.multiply(cv));\n            enc = diff.divide(fv);\n            decoded.append(c);\n        }\n        \n        return decoded.toString();\n    }\n\n    public static void main(String[] args) {\n        long radix = 10;\n        String[] strings = {\"DABDDB\", \"DABDDBBDDBA\", \"ABRACADABRA\", \"TOBEORNOTTOBEORTOBEORNOT\"};\n        String fmt = \"%-25s=> %19s * %d^%s\\n\";\n        for (String str : strings) {\n            Triple<BigInteger, Integer, Freq> encoded = arithmeticCoding(str, radix);\n            String dec = arithmeticDecoding(encoded.a, radix, encoded.b, encoded.c);\n            System.out.printf(fmt, str, encoded.a, radix, encoded.b);\n            if (!Objects.equals(str, dec)) throw new RuntimeException(\"\\tHowever that is incorrect!\");\n        }\n    }\n}\n"}
{"id": 415722, "name": "Playfair cipher", "source": "Translate Perl to Java: use Math::Cartesian::Product;\n\n\nsub playfair {\n    our($key,$from) = @_;\n    $from //= 'J';\n    our $to = $from eq 'J' ? 'I' : '';\n    my(%ENC,%DEC,%seen,@m);\n\n    sub canon {\n        my($str) = @_;\n        $str =~ s/[^[:alpha:]]//g;\n        $str =~ s/$from/$to/gi;\n        uc $str;\n    }\n\n    my @uniq = grep { ! $seen{$_}++ } split '', canon($key . join '', 'A'..'Z');\n    while (@uniq) { push @m, [splice @uniq, 0, 5] }\n\n    \n    for my $r (@m)  {\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ @$r[$i] . @$r[$j] } =  @$r[($i+1)%5] . @$r[($j+1)%5];\n        }\n    }\n\n    \n    for my $c (0..4) {\n        my @c = map { @$_[$c] } @m;\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ $c[$i] . $c[$j] } = $c[($i+1)%5] . $c[($j+1)%5];\n        }\n    }\n\n    \n    for my $x (cartesian {@_} [0..4], [0..4], [0..4], [0..4]) {\n        my($i1,$j1,$i2,$j2) = @$x;\n        next if $i1 == $i2 or $j1 == $j2;\n        $ENC{ $m[$i1][$j1] . $m[$i2][$j2] } = $m[$i1][$j2] . $m[$i2][$j1];\n    }\n\n    \n     while (my ($k, $v) = each %ENC) { $DEC{$v} = $k }\n\n    \n    return\n    sub { my($red) = @_; \n        my $str = canon($red);\n\n        my @list;\n        while ($str =~ /(.)(?(?=\\1)|(.?))/g) {\n            push @list, substr($str,$-[0], $-[2] ? 2 : 1);\n        }\n        join ' ', map { length($_)==1 ? $ENC{$_.'X'} : $ENC{$_} } @list;\n    },\n    sub { my($black) = @_; \n        join ' ', map { $DEC{$_} } canon($black) =~ /../g;\n    }\n}\n\nmy($encode,$decode) = playfair('Playfair example');\n\nmy $orig  = \"Hide the gold in...the TREESTUMP!!!\";\nmy $black = &$encode($orig);\nmy $red   = &$decode($black);\nprint \" orig:\\t$orig\\n\";\nprint \"black:\\t$black\\n\";\nprint \"  red:\\t$red\\n\";\n", "target": "import java.awt.Point;\nimport java.util.Scanner;\n\npublic class PlayfairCipher {\n    private static char[][] charTable;\n    private static Point[] positions;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String key = prompt(\"Enter an encryption key (min length 6): \", sc, 6);\n        String txt = prompt(\"Enter the message: \", sc, 1);\n        String jti = prompt(\"Replace J with I? y/n: \", sc, 1);\n\n        boolean changeJtoI = jti.equalsIgnoreCase(\"y\");\n\n        createTable(key, changeJtoI);\n\n        String enc = encode(prepareText(txt, changeJtoI));\n\n        System.out.printf(\"%nEncoded message: %n%s%n\", enc);\n        System.out.printf(\"%nDecoded message: %n%s%n\", decode(enc));\n    }\n\n    private static String prompt(String promptText, Scanner sc, int minLen) {\n        String s;\n        do {\n            System.out.print(promptText);\n            s = sc.nextLine().trim();\n        } while (s.length() < minLen);\n        return s;\n    }\n\n    private static String prepareText(String s, boolean changeJtoI) {\n        s = s.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n        return changeJtoI ? s.replace(\"J\", \"I\") : s.replace(\"Q\", \"\");\n    }\n\n    private static void createTable(String key, boolean changeJtoI) {\n        charTable = new char[5][5];\n        positions = new Point[26];\n\n        String s = prepareText(key + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", changeJtoI);\n\n        int len = s.length();\n        for (int i = 0, k = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (positions[c - 'A'] == null) {\n                charTable[k / 5][k % 5] = c;\n                positions[c - 'A'] = new Point(k % 5, k / 5);\n                k++;\n            }\n        }\n    }\n\n    private static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s);\n\n        for (int i = 0; i < sb.length(); i += 2) {\n\n            if (i == sb.length() - 1)\n                sb.append(sb.length() % 2 == 1 ? 'X' : \"\");\n\n            else if (sb.charAt(i) == sb.charAt(i + 1))\n                sb.insert(i + 1, 'X');\n        }\n        return codec(sb, 1);\n    }\n\n    private static String decode(String s) {\n        return codec(new StringBuilder(s), 4);\n    }\n\n    private static String codec(StringBuilder text, int direction) {\n        int len = text.length();\n        for (int i = 0; i < len; i += 2) {\n            char a = text.charAt(i);\n            char b = text.charAt(i + 1);\n\n            int row1 = positions[a - 'A'].y;\n            int row2 = positions[b - 'A'].y;\n            int col1 = positions[a - 'A'].x;\n            int col2 = positions[b - 'A'].x;\n\n            if (row1 == row2) {\n                col1 = (col1 + direction) % 5;\n                col2 = (col2 + direction) % 5;\n\n            } else if (col1 == col2) {\n                row1 = (row1 + direction) % 5;\n                row2 = (row2 + direction) % 5;\n\n            } else {\n                int tmp = col1;\n                col1 = col2;\n                col2 = tmp;\n            }\n\n            text.setCharAt(i, charTable[row1][col1]);\n            text.setCharAt(i + 1, charTable[row2][col2]);\n        }\n        return text.toString();\n    }\n}\n"}
{"id": 415723, "name": "Playfair cipher", "source": "Translate Perl to Java: use Math::Cartesian::Product;\n\n\nsub playfair {\n    our($key,$from) = @_;\n    $from //= 'J';\n    our $to = $from eq 'J' ? 'I' : '';\n    my(%ENC,%DEC,%seen,@m);\n\n    sub canon {\n        my($str) = @_;\n        $str =~ s/[^[:alpha:]]//g;\n        $str =~ s/$from/$to/gi;\n        uc $str;\n    }\n\n    my @uniq = grep { ! $seen{$_}++ } split '', canon($key . join '', 'A'..'Z');\n    while (@uniq) { push @m, [splice @uniq, 0, 5] }\n\n    \n    for my $r (@m)  {\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ @$r[$i] . @$r[$j] } =  @$r[($i+1)%5] . @$r[($j+1)%5];\n        }\n    }\n\n    \n    for my $c (0..4) {\n        my @c = map { @$_[$c] } @m;\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ $c[$i] . $c[$j] } = $c[($i+1)%5] . $c[($j+1)%5];\n        }\n    }\n\n    \n    for my $x (cartesian {@_} [0..4], [0..4], [0..4], [0..4]) {\n        my($i1,$j1,$i2,$j2) = @$x;\n        next if $i1 == $i2 or $j1 == $j2;\n        $ENC{ $m[$i1][$j1] . $m[$i2][$j2] } = $m[$i1][$j2] . $m[$i2][$j1];\n    }\n\n    \n     while (my ($k, $v) = each %ENC) { $DEC{$v} = $k }\n\n    \n    return\n    sub { my($red) = @_; \n        my $str = canon($red);\n\n        my @list;\n        while ($str =~ /(.)(?(?=\\1)|(.?))/g) {\n            push @list, substr($str,$-[0], $-[2] ? 2 : 1);\n        }\n        join ' ', map { length($_)==1 ? $ENC{$_.'X'} : $ENC{$_} } @list;\n    },\n    sub { my($black) = @_; \n        join ' ', map { $DEC{$_} } canon($black) =~ /../g;\n    }\n}\n\nmy($encode,$decode) = playfair('Playfair example');\n\nmy $orig  = \"Hide the gold in...the TREESTUMP!!!\";\nmy $black = &$encode($orig);\nmy $red   = &$decode($black);\nprint \" orig:\\t$orig\\n\";\nprint \"black:\\t$black\\n\";\nprint \"  red:\\t$red\\n\";\n", "target": "import java.awt.Point;\nimport java.util.Scanner;\n\npublic class PlayfairCipher {\n    private static char[][] charTable;\n    private static Point[] positions;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String key = prompt(\"Enter an encryption key (min length 6): \", sc, 6);\n        String txt = prompt(\"Enter the message: \", sc, 1);\n        String jti = prompt(\"Replace J with I? y/n: \", sc, 1);\n\n        boolean changeJtoI = jti.equalsIgnoreCase(\"y\");\n\n        createTable(key, changeJtoI);\n\n        String enc = encode(prepareText(txt, changeJtoI));\n\n        System.out.printf(\"%nEncoded message: %n%s%n\", enc);\n        System.out.printf(\"%nDecoded message: %n%s%n\", decode(enc));\n    }\n\n    private static String prompt(String promptText, Scanner sc, int minLen) {\n        String s;\n        do {\n            System.out.print(promptText);\n            s = sc.nextLine().trim();\n        } while (s.length() < minLen);\n        return s;\n    }\n\n    private static String prepareText(String s, boolean changeJtoI) {\n        s = s.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n        return changeJtoI ? s.replace(\"J\", \"I\") : s.replace(\"Q\", \"\");\n    }\n\n    private static void createTable(String key, boolean changeJtoI) {\n        charTable = new char[5][5];\n        positions = new Point[26];\n\n        String s = prepareText(key + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", changeJtoI);\n\n        int len = s.length();\n        for (int i = 0, k = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (positions[c - 'A'] == null) {\n                charTable[k / 5][k % 5] = c;\n                positions[c - 'A'] = new Point(k % 5, k / 5);\n                k++;\n            }\n        }\n    }\n\n    private static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s);\n\n        for (int i = 0; i < sb.length(); i += 2) {\n\n            if (i == sb.length() - 1)\n                sb.append(sb.length() % 2 == 1 ? 'X' : \"\");\n\n            else if (sb.charAt(i) == sb.charAt(i + 1))\n                sb.insert(i + 1, 'X');\n        }\n        return codec(sb, 1);\n    }\n\n    private static String decode(String s) {\n        return codec(new StringBuilder(s), 4);\n    }\n\n    private static String codec(StringBuilder text, int direction) {\n        int len = text.length();\n        for (int i = 0; i < len; i += 2) {\n            char a = text.charAt(i);\n            char b = text.charAt(i + 1);\n\n            int row1 = positions[a - 'A'].y;\n            int row2 = positions[b - 'A'].y;\n            int col1 = positions[a - 'A'].x;\n            int col2 = positions[b - 'A'].x;\n\n            if (row1 == row2) {\n                col1 = (col1 + direction) % 5;\n                col2 = (col2 + direction) % 5;\n\n            } else if (col1 == col2) {\n                row1 = (row1 + direction) % 5;\n                row2 = (row2 + direction) % 5;\n\n            } else {\n                int tmp = col1;\n                col1 = col2;\n                col2 = tmp;\n            }\n\n            text.setCharAt(i, charTable[row1][col1]);\n            text.setCharAt(i + 1, charTable[row2][col2]);\n        }\n        return text.toString();\n    }\n}\n"}
{"id": 415724, "name": "Word break problem", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy @words = <a o is pi ion par per sip miss able>;\nprint \"$_: \" . word_break($_,@words) . \"\\n\" for <a aa amiss parable opera operable inoperable permission mississippi>;\n\nsub word_break {\n    my($word,@dictionary) = @_;\n    my @matches;\n    my $one_of = join '|', @dictionary;\n    @matches = $word =~ /^ ($one_of) ($one_of)? ($one_of)? ($one_of)? $/x; \n    return join(' ', grep {$_} @matches) || \"(not possible)\";\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class WordBreak {\n\n    public static void main(String[] args) {\n        List<String> dict = Arrays.asList(\"a\", \"aa\", \"b\", \"ab\", \"aab\");\n        for ( String testString : Arrays.asList(\"aab\", \"aa b\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n        dict = Arrays.asList(\"abc\", \"a\", \"ac\", \"b\", \"c\", \"cb\", \"d\");\n        for ( String testString : Arrays.asList(\"abcd\", \"abbc\", \"abcbcd\", \"acdbc\", \"abcdd\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    private static List<List<String>> wordBreak(String s, List<String> dictionary) {\n        List<List<String>> matches = new ArrayList<>();\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(new Node(s));\n        while ( ! queue.isEmpty() ) {\n            Node node = queue.remove();\n            \n            if ( node.val.length() == 0 ) {\n                matches.add(node.parsed);\n            }\n            else {\n                for ( String word : dictionary ) {\n                    \n                    if ( node.val.startsWith(word) ) {\n                        String valNew = node.val.substring(word.length(), node.val.length());\n                        List<String> parsedNew = new ArrayList<>();\n                        parsedNew.addAll(node.parsed);\n                        parsedNew.add(word);\n                        queue.add(new Node(valNew, parsedNew));\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    \n    private static class Node {\n        private String val;  \n        private List<String> parsed;  \n        public Node(String initial) {\n            val = initial;\n            parsed = new ArrayList<>();\n        }\n        public Node(String s, List<String> p) {\n            val = s;\n            parsed = p;\n        }\n    }\n\n}\n"}
{"id": 415725, "name": "Create an object_Native demonstration", "source": "Translate Perl to Java: use strict;\n\npackage LockedHash;\nuse parent 'Tie::Hash';\nuse Carp;\n\nsub TIEHASH {\n\tmy $cls = shift;\n\tmy %h = @_;\n\tbless \\%h, ref $cls || $cls;\n}\n\nsub STORE {\n\tmy ($self, $k, $v) = @_;\n\tcroak \"Can't add key $k\" unless exists $self->{$k};\n\t$self->{$k} = $v;\n}\n\nsub FETCH {\n\tmy ($self, $k) = @_;\n\tcroak \"No key $k\" unless exists $self->{$k};\n\t$self->{$k};\n}\n\nsub DELETE {\n\tmy ($self, $k) = @_;\n\tcroak \"No key $k\" unless exists $self->{$k};\n\t$self->{$k} = 0;\n}\n\nsub CLEAR { } \nsub EXISTS { exists shift->{+shift} }\n\nsub FIRSTKEY {\n\tmy $self = shift;\n\tkeys %$self;\n\teach %$self;\n}\n\nsub NEXTKEY {\n\tmy $self = shift;\n\teach %$self;\n}\n\nsub lock_hash :prototype(\\%) {\n\tmy $ref = shift;\n\ttie(%$ref, __PACKAGE__, %$ref);\n}\n\n1;\n\nmy %h = (a => 3, b => 4, c => 5);\n\n\nLockedHash::lock_hash(%h);\n\n\nfor (sort keys %h) { print \"$_ => $h{$_}\\n\"; }\n\n\ndelete $h{b};\nprint \"\\nafter deleting b: b => $h{b}\\n\";\n\n\n$h{a} = 100;\nprint \"\\na => $h{a}\\n\";\n\n\neval { $h{x} = 1 };\nif ($@) { print \"Operation error: $@\" }\n", "target": "import java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\n\n\n\npublic class ImmutableMap {\n\n    public static void main(String[] args) {\n        Map<String,Integer> hashMap = getImmutableMap();\n        try {\n            hashMap.put(\"Test\", 23);\n        }\n        catch (UnsupportedOperationException e) {\n            System.out.println(\"ERROR:  Unable to put new value.\");\n        }\n        try {\n            hashMap.clear();\n        }\n        catch (UnsupportedOperationException e) {\n            System.out.println(\"ERROR:  Unable to clear map.\");\n        }\n        try {\n            hashMap.putIfAbsent(\"Test\", 23);\n        }\n        catch (UnsupportedOperationException e) {\n            System.out.println(\"ERROR:  Unable to put if absent.\");\n        }\n        \n        for ( String key : hashMap.keySet() ) {\n            System.out.printf(\"key = %s, value = %s%n\", key, hashMap.get(key));\n        }\n    }\n    \n    private static Map<String,Integer> getImmutableMap() {\n        Map<String,Integer> hashMap = new HashMap<>();\n        hashMap.put(\"Key 1\", 34);\n        hashMap.put(\"Key 2\", 105);\n        hashMap.put(\"Key 3\", 144);\n\n        return Collections.unmodifiableMap(hashMap);\n    }\n    \n}\n"}
{"id": 415726, "name": "Decimal floating point number to binary", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub dec2bin {\n    my($l,$r) = split /\\./, shift;\n    my $int  = unpack('B*',  pack('N',               $l ));\n    my $frac = unpack('B32', pack('N',4294967296 * \".$r\"));\n    \"$int.$frac\" =~ s/^0*(.*?)0*$/$1/r;\n}\n\nsub bin2dec {\n    my($l,$r) = split /\\./, shift;\n    my $frac = my $i = 0;\n    --$i, $frac += $_ * 2**$i for split '', $r;\n    eval('0b'.$l) + $frac;\n}\n\nsay dec2bin(23.34375);\nsay bin2dec('1011.11101');\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 415727, "name": "Decimal floating point number to binary", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub dec2bin {\n    my($l,$r) = split /\\./, shift;\n    my $int  = unpack('B*',  pack('N',               $l ));\n    my $frac = unpack('B32', pack('N',4294967296 * \".$r\"));\n    \"$int.$frac\" =~ s/^0*(.*?)0*$/$1/r;\n}\n\nsub bin2dec {\n    my($l,$r) = split /\\./, shift;\n    my $frac = my $i = 0;\n    --$i, $frac += $_ * 2**$i for split '', $r;\n    eval('0b'.$l) + $frac;\n}\n\nsay dec2bin(23.34375);\nsay bin2dec('1011.11101');\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 415728, "name": "Free polyominoes enumeration", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nmy @new = \"\n\nfor my $N ( 2 .. 10 )\n  {\n  @new = find( @new );\n  my %allbest;\n  $allbest{best($_)}++ for @new;\n  my @show = @new = sort keys %allbest;\n  printf \"rank: %2d  count: %d\\n\\n\", $N, scalar @show;\n  if( @show <= 12 )\n    {\n    my $fmt = join '', map({ /\\n/; '%' . ($+[0] + 1) . 's' } @show), \"\\n\";\n    grep $_, @show and printf $fmt, map s/(.*)\\n// && $1, @show for 0 .. $N;\n    print \"\\n\";\n    }\n  }\n\nsub bare\n  {\n  local $_ = shift;\n  s/^ *\\n//gm;\n  s/^ //gm until /^\n  s/ $//gm until /\n  $_;\n  }\n\nsub transpose\n  {\n  local $_ = shift;\n  my $t = '';\n  $t .= \"\\n\" while s/^./ $t .= $&; '' /gem;\n  $t;\n  }\n\nsub rotate\n  {\n  local $_ = shift;\n  my $t = '';\n  $t .= \"\\n\" while s/.$/ $t .= $&; '' /gem;\n  $t;\n  }\n\nsub best\n  {\n  my %all = (shift, 1);\n  for my $p (keys %all)\n    {\n    $all{ my $tmp = rotate $p }++;\n    $all{ rotate $tmp }++;\n    }\n  $all{ transpose $_ }++ for keys %all;\n  $all{ s/(.+)/reverse $1/ger }++ for keys %all;        \n  (sort keys %all)[-1];\n  }\n\nsub find\n  {\n  my @before = @_;\n  my %new;\n  for my $p ( @before )\n    {\n    local $_ = $p;\n    s/^/ /gm;\n    s/\\n/ \\n/g;\n    my $line = s/\\n.*/\\n/sr =~ tr/\\n/ /cr;\n    $_ = $line . $_ . $line;\n    my $n = -1 + length $line;\n    my $gap = qr/.{$n}/s;\n    $new{ bare \"$`\n    $new{ bare \"$`\n    $new{ bare \"$`\n    $new{ bare \"$`\n    }\n  keys %new;\n  }\n", "target": "import java.awt.Point;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport java.util.function.Function;\nimport static java.util.Comparator.comparing;\nimport static java.util.stream.Collectors.toList;\n\npublic class FreePolyominoesEnum {\n    static final List<Function<Point, Point>> transforms = new ArrayList<>();\n\n    static {\n        transforms.add(p -> new Point(p.y, -p.x));\n        transforms.add(p -> new Point(-p.x, -p.y));\n        transforms.add(p -> new Point(-p.y, p.x));\n        transforms.add(p -> new Point(-p.x, p.y));\n        transforms.add(p -> new Point(-p.y, -p.x));\n        transforms.add(p -> new Point(p.x, -p.y));\n        transforms.add(p -> new Point(p.y, p.x));\n    }\n\n    static Point findMinima(List<Point> poly) {\n        return new Point(\n                poly.stream().mapToInt(a -> a.x).min().getAsInt(),\n                poly.stream().mapToInt(a -> a.y).min().getAsInt());\n    }\n\n    static List<Point> translateToOrigin(List<Point> poly) {\n        final Point min = findMinima(poly);\n        poly.replaceAll(p -> new Point(p.x - min.x, p.y - min.y));\n        return poly;\n    }\n\n    static List<List<Point>> rotationsAndReflections(List<Point> poly) {\n        List<List<Point>> lst = new ArrayList<>();\n        lst.add(poly);\n        for (Function<Point, Point> t : transforms)\n            lst.add(poly.stream().map(t).collect(toList()));\n        return lst;\n    }\n\n    static Comparator<Point> byCoords = Comparator.<Point>comparingInt(p -> p.x)\n            .thenComparingInt(p -> p.y);\n\n    static List<Point> normalize(List<Point> poly) {\n        return rotationsAndReflections(poly).stream()\n                .map(lst -> translateToOrigin(lst))\n                .map(lst -> lst.stream().sorted(byCoords).collect(toList()))\n                .min(comparing(Object::toString)) \n                .get();\n    }\n\n    static List<Point> neighborhoods(Point p) {\n        return asList(new Point(p.x - 1, p.y), new Point(p.x + 1, p.y),\n                new Point(p.x, p.y - 1), new Point(p.x, p.y + 1));\n    }\n\n    static List<Point> concat(List<Point> lst, Point pt) {\n        List<Point> r = new ArrayList<>();\n        r.addAll(lst);\n        r.add(pt);\n        return r;\n    }\n\n    static List<Point> newPoints(List<Point> poly) {\n        return poly.stream()\n                .flatMap(p -> neighborhoods(p).stream())\n                .filter(p -> !poly.contains(p))\n                .distinct()\n                .collect(toList());\n    }\n\n    static List<List<Point>> constructNextRank(List<Point> poly) {\n        return newPoints(poly).stream()\n                .map(p -> normalize(concat(poly, p)))\n                .distinct()\n                .collect(toList());\n    }\n\n    static List<List<Point>> rank(int n) {\n        if (n < 0)\n            throw new IllegalArgumentException(\"n cannot be negative\");\n\n        if (n < 2) {\n            List<List<Point>> r = new ArrayList<>();\n            if (n == 1)\n                r.add(asList(new Point(0, 0)));\n            return r;\n        }\n\n        return rank(n - 1).stream()\n                .parallel()\n                .flatMap(lst -> constructNextRank(lst).stream())\n                .distinct()\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        for (List<Point> poly : rank(5)) {\n            for (Point p : poly)\n                System.out.printf(\"(%d,%d) \", p.x, p.y);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415729, "name": "Particle swarm optimization", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse constant PI  => 2 * atan2(1, 0);\nuse constant Inf => 1e10;\n\nsub pso_init {\n    my(%y) = @_;\n    my $d = @{$y{'min'}};\n    my $n = $y{'n'};\n\n    $y{'gbval'} = Inf;\n    $y{'gbpos'} = [(Inf) x $d];\n    $y{'bval'}  = [(Inf) x $n];\n    $y{'bpos'}  = [($y{'min'}) x $n];\n    $y{'pos'}   = [($y{'min'}) x $n];\n    $y{'vel'}   = [([(0) x $d]) x $n];\n\n    %y\n}\n\nsub pso {\n    my($fn, %y) = @_;\n    my $p      = $y{'p'};\n    my $n      = $y{'n'};\n    my $d      = @{$y{'min'}};\n    my @bpos   = ($y{'min'}) x $n;\n    my $gbval  = Inf;\n    my $rand_g = rand;\n    my (@pos, @vel, @v, @gbpos, @bval);\n\n    for my $j (0 .. $n-1) {\n        $v[$j] = &$fn(@{$y{'pos'}[$j]}); \n\n        \n        if ($v[$j] < $y{'bval'}[$j]) {\n            $bpos[$j] = $y{'pos'}[$j];\n            $bval[$j] = $v[$j];\n        } else {\n            $bpos[$j] = $y{'bpos'}[$j];\n            $bval[$j] = $y{'bval'}[$j];\n        }\n        if ($bval[$j] < $gbval) {\n            @gbpos = @{$bpos[$j]};\n            $gbval = $bval[$j];\n        }\n    }\n\n    \n    for my $j (0 .. $n-1) {\n        my $rand_p = rand;\n        my $ok = 1;\n        for my $k (0 .. $d-1) {\n            $vel[$j][$k] = $$p{'omega'} * $y{'vel'}[$j][$k]\n                       + $$p{'phi_p'} * $rand_p * ($bpos[$j][$k] - $y{'pos'}[$j][$k])\n                       + $$p{'phi_g'} * $rand_g * ($gbpos[$k]    - $y{'pos'}[$j][$k]);\n            $pos[$j][$k] = $y{'pos'}[$j][$k] + $vel[$j][$k];\n            $ok = ($y{'min'}[$k] < $pos[$j][$k]) && ($pos[$j][$k] < $y{'max'}[$k]) && $ok;\n        }\n        next if $ok;\n        $pos[$j][$_] = $y{'min'}[$_] + ($y{'max'}[$_] - $y{'min'}[$_]) * rand for 0 .. $d-1;\n    }\n    return {gbpos => \\@gbpos, gbval => $gbval, bpos => \\@bpos, bval => \\@bval, pos => \\@pos, vel => \\@vel,\n               min => $y{'min'}, max => $y{'max'}, p=> $y{'p'}, n => $n};\n}\n\nsub report {\n    my($function_name, %state) = @_;\n    say $function_name;\n    say 'Global best position: ' . sprintf \"%.5f\u00a0%.5f\", @{$state{'gbpos'}};\n    say 'Global best value:    ' . sprintf \"%.5f\",      $state{'gbval'};\n    say '';\n}\n\n\nsub mccormick {\n    my($a,$b) = @_;\n    sin($a+$b) + ($a-$b)**2 + (1 + 2.5*$b - 1.5*$a)\n}\n\nmy %state = pso_init( (\n    min => [-1.5, -3],\n    max => [4, 4],\n    n   => 100,\n    p   => {omega => 0, phi_p => 0.6, phi_g => 0.3},\n) );\n%state = %{pso(\\&mccormick, %state)} for 1 .. 40;\nreport('McCormick', %state);\n\n\nsub michalewicz {\n    my(@x) = @_;\n    my $sum;\n    my $m = 10;\n    for my $i (1..@x) {\n        my $j = $x[$i - 1];\n        my $k = sin($i * $j**2/PI);\n        $sum += sin($j) * $k**(2*$m)\n    }\n    -$sum\n}\n\n%state = pso_init( (\n    min => [0, 0],\n    max => [PI, PI],\n    n   => 1000,\n    p   => {omega => 0.3, phi_p => 0.3, phi_g => 0.3},\n) );\n%state = %{pso(\\&michalewicz, %state)} for 1 .. 30;\nreport('Michalewicz', %state);\n", "target": "import java.util.Arrays;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.function.Function;\n\npublic class App {\n    static class Parameters {\n        double omega;\n        double phip;\n        double phig;\n\n        Parameters(double omega, double phip, double phig) {\n            this.omega = omega;\n            this.phip = phip;\n            this.phig = phig;\n        }\n    }\n\n    static class State {\n        int iter;\n        double[] gbpos;\n        double gbval;\n        double[] min;\n        double[] max;\n        Parameters parameters;\n        double[][] pos;\n        double[][] vel;\n        double[][] bpos;\n        double[] bval;\n        int nParticles;\n        int nDims;\n\n        State(int iter, double[] gbpos, double gbval, double[] min, double[] max, Parameters parameters, double[][] pos, double[][] vel, double[][] bpos, double[] bval, int nParticles, int nDims) {\n            this.iter = iter;\n            this.gbpos = gbpos;\n            this.gbval = gbval;\n            this.min = min;\n            this.max = max;\n            this.parameters = parameters;\n            this.pos = pos;\n            this.vel = vel;\n            this.bpos = bpos;\n            this.bval = bval;\n            this.nParticles = nParticles;\n            this.nDims = nDims;\n        }\n\n        void report(String testfunc) {\n            System.out.printf(\"Test Function       \u00a0: %s\\n\", testfunc);\n            System.out.printf(\"Iterations          \u00a0: %d\\n\", iter);\n            System.out.printf(\"Global Best Position\u00a0: %s\\n\", Arrays.toString(gbpos));\n            System.out.printf(\"Global Best value   \u00a0:\u00a0%.15f\\n\", gbval);\n        }\n    }\n\n    private static State psoInit(double[] min, double[] max, Parameters parameters, int nParticles) {\n        int nDims = min.length;\n        double[][] pos = new double[nParticles][];\n        for (int i = 0; i < nParticles; ++i) {\n            pos[i] = min.clone();\n        }\n        double[][] vel = new double[nParticles][nDims];\n        double[][] bpos = new double[nParticles][];\n        for (int i = 0; i < nParticles; ++i) {\n            bpos[i] = min.clone();\n        }\n        double[] bval = new double[nParticles];\n        for (int i = 0; i < bval.length; ++i) {\n            bval[i] = Double.POSITIVE_INFINITY;\n        }\n        int iter = 0;\n        double[] gbpos = new double[nDims];\n        for (int i = 0; i < gbpos.length; ++i) {\n            gbpos[i] = Double.POSITIVE_INFINITY;\n        }\n        double gbval = Double.POSITIVE_INFINITY;\n        return new State(iter, gbpos, gbval, min, max, parameters, pos, vel, bpos, bval, nParticles, nDims);\n    }\n\n    private static Random r = new Random();\n\n    private static State pso(Function<double[], Double> fn, State y) {\n        Parameters p = y.parameters;\n        double[] v = new double[y.nParticles];\n        double[][] bpos = new double[y.nParticles][];\n        for (int i = 0; i < y.nParticles; ++i) {\n            bpos[i] = y.min.clone();\n        }\n        double[] bval = new double[y.nParticles];\n        double[] gbpos = new double[y.nDims];\n        double gbval = Double.POSITIVE_INFINITY;\n        for (int j = 0; j < y.nParticles; ++j) {\n            \n            v[j] = fn.apply(y.pos[j]);\n            \n            if (v[j] < y.bval[j]) {\n                bpos[j] = y.pos[j];\n                bval[j] = v[j];\n            } else {\n                bpos[j] = y.bpos[j];\n                bval[j] = y.bval[j];\n            }\n            if (bval[j] < gbval) {\n                gbval = bval[j];\n                gbpos = bpos[j];\n            }\n        }\n        double rg = r.nextDouble();\n        double[][] pos = new double[y.nParticles][y.nDims];\n        double[][] vel = new double[y.nParticles][y.nDims];\n        for (int j = 0; j < y.nParticles; ++j) {\n            \n            double rp = r.nextDouble();\n            boolean ok = true;\n            Arrays.fill(vel[j], 0.0);\n            Arrays.fill(pos[j], 0.0);\n            for (int k = 0; k < y.nDims; ++k) {\n                vel[j][k] = p.omega * y.vel[j][k] +\n                    p.phip * rp * (bpos[j][k] - y.pos[j][k]) +\n                    p.phig * rg * (gbpos[k] - y.pos[j][k]);\n                pos[j][k] = y.pos[j][k] + vel[j][k];\n                ok = ok && y.min[k] < pos[j][k] && y.max[k] > pos[j][k];\n            }\n            if (!ok) {\n                for (int k = 0; k < y.nDims; ++k) {\n                    pos[j][k] = y.min[k] + (y.max[k] - y.min[k]) * r.nextDouble();\n                }\n            }\n        }\n        int iter = 1 + y.iter;\n        return new State(\n            iter, gbpos, gbval, y.min, y.max, y.parameters,\n            pos, vel, bpos, bval, y.nParticles, y.nDims\n        );\n    }\n\n    private static State iterate(Function<double[], Double> fn, int n, State y) {\n        State r = y;\n        if (n == Integer.MAX_VALUE) {\n            State old = y;\n            while (true) {\n                r = pso(fn, r);\n                if (Objects.equals(r, old)) break;\n                old = r;\n            }\n        } else {\n            for (int i = 0; i < n; ++i) {\n                r = pso(fn, r);\n            }\n        }\n        return r;\n    }\n\n    private static double mccormick(double[] x) {\n        double a = x[0];\n        double b = x[1];\n        return Math.sin(a + b) + (a - b) * (a - b) + 1.0 + 2.5 * b - 1.5 * a;\n    }\n\n    private static double michalewicz(double[] x) {\n        int m = 10;\n        int d = x.length;\n        double sum = 0.0;\n        for (int i = 1; i < d; ++i) {\n            double j = x[i - 1];\n            double k = Math.sin(i * j * j / Math.PI);\n            sum += Math.sin(j) * Math.pow(k, 2.0 * m);\n        }\n        return -sum;\n    }\n\n    public static void main(String[] args) {\n        State state = psoInit(\n            new double[]{-1.5, -3.0},\n            new double[]{4.0, 4.0},\n            new Parameters(0.0, 0.6, 0.3),\n            100\n        );\n        state = iterate(App::mccormick, 40, state);\n        state.report(\"McCormick\");\n        System.out.printf(\"f(-.54719, -1.54719)\u00a0:\u00a0%.15f\\n\", mccormick(new double[]{-.54719, -1.54719}));\n        System.out.println();\n\n        state = psoInit(\n            new double[]{0.0, 0.0},\n            new double[]{Math.PI, Math.PI},\n            new Parameters(0.3, 3.0, 0.3),\n            1000\n        );\n        state = iterate(App::michalewicz, 30, state);\n        state.report(\"Michalewicz (2D)\");\n        System.out.printf(\"f(2.20, 1.57)       \u00a0:\u00a0%.15f\\n\", michalewicz(new double[]{2.20, 1.57}));\n    }\n}\n"}
{"id": 415730, "name": "Solve triangle solitare puzzle", "source": "Translate Perl to Java: @start = qw<\n        0\n       1 1\n      1 1 1\n     1 1 1 1\n    1 1 1 1 1\n>;\n\n@moves = (\n    [ 0, 1, 3], [ 0, 2, 5], [ 1, 3, 6],\n    [ 1, 4, 8], [ 2, 4, 7], [ 2, 5, 9],\n    [ 3, 4, 5], [ 3, 6,10], [ 3, 7,12],\n    [ 4, 7,11], [ 4, 8,13], [ 5, 8,12],\n    [ 5, 9,14], [ 6, 7, 8], [ 7, 8, 9],\n    [10,11,12], [11,12,13], [12,13,14]\n);\n\n$format .= (\" \" x (5-$_)) . (\"%d \" x $_) . \"\\n\" for 1..5;\n\nsub solve {\n    my ($move, $turns, @board) = @_;\n    $turns = 1 unless $turns;\n    return \"\\nSolved\" if $turns + 1 == @board;\n    return undef if $board[$$move[1]] == 0;\n    my $valid = do  {\n        if ($board[$$move[0]] == 0) {\n            return undef if $board[$$move[2]] == 0;\n            \"\\nmove $$move[2] to $$move[0]\\n\";\n        } else {\n            return undef if $board[$$move[2]] == 1;\n            \"\\nmove $$move[0] to $$move[2]\\n\";\n        }\n    };\n\n    my $new_result;\n    my @new_layout = @board;\n    @new_layout[$_] = 1 - @new_layout[$_] for @$move;\n    for $this_move (@moves) {\n        $new_result = solve(\\@$this_move, $turns + 1, @new_layout);\n        last if $new_result\n    }\n    $new_result ? \"$valid\\n\" . sprintf($format, @new_layout) . $new_result : $new_result}\n\n$result = \"Starting with\\n\\n\" . sprintf($format, @start), \"\\n\";\n\nfor $this_move (@moves) {\n    $result .= solve(\\@$this_move, 1, @start);\n    last if $result\n}\n\nprint $result ? $result : \"No solution found\";\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Stack;\n\npublic class IQPuzzle {\n\n    public static void main(String[] args) {\n        System.out.printf(\"  \");\n        for ( int start = 1 ; start < Puzzle.MAX_PEGS ; start++ ) {\n            System.out.printf(\" \u00a0%,6d\", start);\n        }\n        System.out.printf(\"%n\");\n        for ( int start = 1 ; start < Puzzle.MAX_PEGS ; start++ ) {\n            System.out.printf(\"%2d\", start);\n            Map<Integer,Integer> solutions = solve(start);    \n            for ( int end = 1 ; end < Puzzle.MAX_PEGS ; end++ ) {\n                System.out.printf(\" \u00a0%,6d\", solutions.containsKey(end) ? solutions.get(end) : 0);\n            }\n            System.out.printf(\"%n\");\n        }\n        int moveNum = 0;\n        System.out.printf(\"%nOne Solution:%n\");\n        for ( Move m : oneSolution ) {\n            moveNum++;\n            System.out.printf(\"Move %d = %s%n\", moveNum, m);\n        }\n    }\n    \n    private static List<Move> oneSolution = null;\n    \n    private static Map<Integer, Integer> solve(int emptyPeg) {\n        Puzzle puzzle = new Puzzle(emptyPeg);\n        Map<Integer,Integer> solutions = new HashMap<>();\n        Stack<Puzzle> stack = new Stack<Puzzle>();\n        stack.push(puzzle);\n        while ( ! stack.isEmpty() ) {\n            Puzzle p = stack.pop();\n            if ( p.solved() ) {\n                solutions.merge(p.getLastPeg(), 1, (v1,v2) -> v1 + v2);\n                if ( oneSolution == null ) {\n                    oneSolution = p.moves;\n                }\n                continue;\n            }\n            for ( Move move : p.getValidMoves() ) {\n                Puzzle pMove = p.move(move);\n                stack.add(pMove);\n            }\n        }\n        \n        return solutions;\n    }\n    \n    private static class Puzzle {\n        \n        public static int MAX_PEGS = 16;\n        private boolean[] pegs = new boolean[MAX_PEGS];  \n        \n        private List<Move> moves;\n\n        public Puzzle(int emptyPeg) {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                pegs[i] = true;\n            }\n            pegs[emptyPeg] = false;\n            moves = new ArrayList<>();\n        }\n\n        public Puzzle() {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                pegs[i] = true;\n            }\n            moves = new ArrayList<>();\n        }\n\n        private static Map<Integer,List<Move>> validMoves = new HashMap<>(); \n        static {\n            validMoves.put(1, Arrays.asList(new Move(1, 2, 4), new Move(1, 3, 6)));\n            validMoves.put(2, Arrays.asList(new Move(2, 4, 7), new Move(2, 5, 9)));\n            validMoves.put(3, Arrays.asList(new Move(3, 5, 8), new Move(3, 6, 10)));\n            validMoves.put(4, Arrays.asList(new Move(4, 2, 1), new Move(4, 5, 6), new Move(4, 8, 13), new Move(4, 7, 11)));\n            validMoves.put(5, Arrays.asList(new Move(5, 8, 12), new Move(5, 9, 14)));\n            validMoves.put(6, Arrays.asList(new Move(6, 3, 1), new Move(6, 5, 4), new Move(6, 9, 13), new Move(6, 10, 15)));\n            validMoves.put(7, Arrays.asList(new Move(7, 4, 2), new Move(7, 8, 9)));\n            validMoves.put(8, Arrays.asList(new Move(8, 5, 3), new Move(8, 9, 10)));\n            validMoves.put(9, Arrays.asList(new Move(9, 5, 2), new Move(9, 8, 7)));\n            validMoves.put(10, Arrays.asList(new Move(10, 6, 3), new Move(10, 9, 8)));\n            validMoves.put(11, Arrays.asList(new Move(11, 7, 4), new Move(11, 12, 13)));\n            validMoves.put(12, Arrays.asList(new Move(12, 8, 5), new Move(12, 13, 14)));\n            validMoves.put(13, Arrays.asList(new Move(13, 12, 11), new Move(13, 8, 4), new Move(13, 9, 6), new Move(13, 14, 15)));\n            validMoves.put(14, Arrays.asList(new Move(14, 13, 12), new Move(14, 9, 5)));\n            validMoves.put(15, Arrays.asList(new Move(15, 14, 13), new Move(15, 10, 6)));\n        }\n        \n        public List<Move> getValidMoves() {\n            List<Move> moves = new ArrayList<Move>();\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    for ( Move testMove : validMoves.get(i) ) {\n                        if ( pegs[testMove.jump] && ! pegs[testMove.end] ) {\n                            moves.add(testMove);\n                        }\n                    }\n                }\n            }\n            return moves;\n        }\n\n        public boolean solved() {\n            boolean foundFirstPeg = false;\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    if ( foundFirstPeg ) {\n                        return false;\n                    }\n                    foundFirstPeg = true;\n                }\n            }\n            return true;\n        }\n        \n        public Puzzle move(Move move) {\n            Puzzle p = new Puzzle();\n            if ( ! pegs[move.start] || ! pegs[move.jump] || pegs[move.end] ) {\n                throw new RuntimeException(\"Invalid move.\");\n            }\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                p.pegs[i] = pegs[i];\n            }\n            p.pegs[move.start] = false;\n            p.pegs[move.jump] = false;\n            p.pegs[move.end] = true;\n            for ( Move m : moves ) {\n                p.moves.add(new Move(m.start, m.jump, m.end));\n            }\n            p.moves.add(new Move(move.start, move.jump, move.end));\n            return p;\n        }\n        \n        public int getLastPeg() {\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                if ( pegs[i] ) {\n                    return i;\n                }\n            }\n            throw new RuntimeException(\"ERROR:  Illegal position.\");\n        }\n        \n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"[\");\n            for ( int i = 1 ; i < MAX_PEGS ; i++ ) {\n                sb.append(pegs[i] ? 1 : 0);\n                sb.append(\",\");\n            }\n            sb.setLength(sb.length()-1);            \n            sb.append(\"]\");\n            return sb.toString();\n        }\n    }\n    \n    private static class Move {\n        int start;\n        int jump;\n        int end;\n        \n        public Move(int s, int j, int e) {\n            start = s; jump = j; end = e;\n        }\n        \n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"{\");\n            sb.append(\"s=\" + start);\n            sb.append(\", j=\" + jump);\n            sb.append(\", e=\" + end);\n            sb.append(\"}\");\n            return sb.toString();\n        }\n    }\n\n}\n"}
{"id": 415731, "name": "SHA-256 Merkle tree", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nuse Crypt::Digest::SHA256 'sha256' ;\n\nmy @blocks;\n\nopen my $fh, '<:raw', './title.png';\n\nwhile ( read $fh, my $chunk, 1024 ) { push @blocks, sha256 $chunk }\n\nwhile ( scalar @blocks > 1 ) {\n   my @clone = @blocks and @blocks = ();\n   while ( @_ = splice @clone, 0, 2 ) {\n      push @blocks, scalar @_ == 1 ? $_[0] : sha256 $_[0].$_[1]\n   }\n}\n\nprint unpack ( 'H*', $blocks[0] ) , \"\\n\";\n", "target": "import java.io.*;\nimport java.security.*;\nimport java.util.*;\n\npublic class SHA256MerkleTree {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"missing file argument\");\n            System.exit(1);\n        }\n        try (InputStream in = new BufferedInputStream(new FileInputStream(args[0]))) {\n            byte[] digest = sha256MerkleTree(in, 1024);\n            if (digest != null)\n                System.out.println(digestToString(digest));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String digestToString(byte[] digest) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < digest.length; ++i)\n            result.append(String.format(\"%02x\", digest[i]));\n        return result.toString();\n    }\n\n    private static byte[] sha256MerkleTree(InputStream in, int blockSize) throws Exception {\n        byte[] buffer = new byte[blockSize];\n        int bytes;\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        List<byte[]> digests = new ArrayList<>();\n        while ((bytes = in.read(buffer)) > 0) {\n            md.reset();\n            md.update(buffer, 0, bytes);\n            digests.add(md.digest());\n        }\n        int length = digests.size();\n        if (length == 0)\n            return null;\n        while (length > 1) {\n            int j = 0;\n            for (int i = 0; i < length; i += 2, ++j) {\n                byte[] digest1 = digests.get(i);\n                if (i + 1 < length) {\n                    byte[] digest2 = digests.get(i + 1);\n                    md.reset();\n                    md.update(digest1);\n                    md.update(digest2);\n                    digests.set(j, md.digest());\n                } else {\n                    digests.set(j, digest1);\n                }\n            }\n            length = j;\n        }\n        return digests.get(0);\n    }\n}\n"}
{"id": 415732, "name": "Partition function P", "source": "Translate Perl to Java: use strict;\nuse warnings;\nno warnings qw(recursion);\nuse Math::AnyNum qw(:overload);\nuse Memoize;\n\nmemoize('partitionsP');\nmemoize('partDiff');\n\nsub partDiffDiff { my($n) = @_; $n%2 != 0 ? ($n+1)/2 : $n+1 }\n\nsub partDiff { my($n) = @_; $n<2 ? 1 : partDiff($n-1) + partDiffDiff($n-1) }\n\nsub partitionsP {\n    my($n) = @_;\n    return 1 if $n < 2;\n\n    my $psum = 0;\n    for my $i (1..$n) {\n        my $pd = partDiff($i);\n        last if $pd > $n;\n        if ( (($i-1)%4) < 2 ) { $psum += partitionsP($n-$pd) }\n        else                  { $psum -= partitionsP($n-$pd) }\n    }\n    return $psum\n}\n\nprint partitionsP($_) . ' ' for 0..25; print \"\\n\";\nprint partitionsP(6666) . \"\\n\";\n", "target": "import java.math.BigInteger;\n\npublic class PartitionFunction {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        BigInteger result = partitions(6666);\n        long end = System.currentTimeMillis();\n        System.out.println(\"P(6666) = \" + result);\n        System.out.printf(\"elapsed time: %d milliseconds\\n\", end - start);\n    }\n\n    private static BigInteger partitions(int n) {\n        BigInteger[] p = new BigInteger[n + 1];\n        p[0] = BigInteger.ONE;\n        for (int i = 1; i <= n; ++i) {\n            p[i] = BigInteger.ZERO;\n            for (int k = 1; ; ++k) {\n                int j = (k * (3 * k - 1))/2;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n                j += k;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n            }\n        }\n        return p[n];\n    }\n}\n"}
{"id": 415733, "name": "Nimber arithmetic", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Math::AnyNum qw(:overload);\n\nsub msb {\n    my($n, $base) = (shift, 0);\n    $base++ while $n >>= 1;\n    $base;\n}\n\nsub lsb {\n    my $n = shift;\n    msb($n & -$n);\n}\n\nsub nim_sum {\n    my($x,$y) = @_;\n    $x ^ $y\n}\n\nsub nim_prod {\n    no warnings qw(recursion);\n    my($x,$y) = @_;\n    return $x * $y if $x < 2 or $y < 2;\n    my $h = 2 ** lsb($x);\n    return nim_sum( nim_prod($h, $y), nim_prod(nim_sum($x,$h), $y)) if $x > $h;\n    return nim_prod($y,$x) if lsb($y) < msb($y);\n    return $x * $y unless my $comp = lsb($x) & lsb($y);\n    $h = 2 ** lsb($comp);\n    nim_prod(nim_prod(($x >> $h),($y >> $h)), (3 << ($h - 1)));\n}\n\nmy $upto = 15;\nfor (['+', \\&nim_sum], ['*', \\&nim_prod]) {\n    my($op, $f) = @$_;\n    print \" $op |\"; printf '%3d', $_ for 0..$upto;\n    say \"\\n\u2500\u2500\u2500\u253c\" . ('\u2500\u2500\u2500\u2500' x ($upto-3));\n    for my $r (0..$upto) {\n        printf('%2s |', $r);\n        printf '%3s', &$f($r, $_) for 0..$upto;\n        print \"\\n\";\n    }\n    print \"\\n\";\n}\n\nsay nim_sum(21508, 42689);\nsay nim_prod(21508, 42689);\nsay nim_sum(2150821508215082150821508, 4268942689426894268942689);\nsay nim_prod(2150821508215082150821508, 4268942689426894268942689); \n", "target": "import java.util.function.IntBinaryOperator;\n\npublic class Nimber {\n    public static void main(String[] args) {\n        printTable(15, '+', (x, y) -> nimSum(x, y));\n        System.out.println();\n        printTable(15, '*', (x, y) -> nimProduct(x, y));\n        System.out.println();\n\n        int a = 21508, b = 42689;\n        System.out.println(a + \" + \" + b +  \" = \" + nimSum(a, b));\n        System.out.println(a + \" * \" + b +  \" = \" + nimProduct(a, b));\n    }\n\n    \n    public static int nimSum(int x, int y) {\n        return x ^ y;\n    }\n\n    \n    public static int nimProduct(int x, int y) {\n        if (x < 2 || y < 2)\n            return x * y;\n        int h = hpo2(x);\n        if (x > h)\n            return nimProduct(h, y) ^ nimProduct(x ^ h, y);\n        if (hpo2(y) < y)\n            return nimProduct(y, x);\n        int xp = lhpo2(x), yp = lhpo2(y);\n        int comp = xp & yp;\n        if (comp == 0)\n            return x * y;\n        h = hpo2(comp);\n        return nimProduct(nimProduct(x >> h, y >> h), 3 << (h - 1));\n    }\n\n    \n    private static int hpo2(int n) {\n        return n & -n;\n    }\n    \n    \n    private static int lhpo2(int n) {\n        int q = 0, m = hpo2(n);\n        for (; m % 2 == 0; m >>= 1, ++q) {}\n        return q;\n    }\n\n    private static void printTable(int n, char op, IntBinaryOperator func) {\n        System.out.print(\" \" + op + \" |\");\n        for (int a = 0; a <= n; ++a)\n            System.out.printf(\"%3d\", a);\n        System.out.print(\"\\n--- -\");\n        for (int a = 0; a <= n; ++a)\n            System.out.print(\"---\");\n        System.out.println();\n        for (int b = 0; b <= n; ++b) {\n            System.out.printf(\"%2d |\", b);\n            for (int a = 0; a <= n; ++a)\n                System.out.printf(\"%3d\", func.applyAsInt(a, b));\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 415734, "name": "Polynomial synthetic division", "source": "Translate Perl to Java: sub synthetic_division {\n    my($numerator,$denominator) = @_;\n    my @result = @$numerator;\n    my $end    = @$denominator-1;\n\n    for my $i (0 .. @$numerator-($end+1)) {\n        next unless $result[$i];\n        $result[$i]    /= @$denominator[0];\n        $result[$i+$_] -= @$denominator[$_] * $result[$i] for 1 .. $end;\n    }\n\n    return join(' ', @result[0 .. @result-($end+1)]), join(' ', @result[-$end .. -1]);\n}\n\nsub poly_divide {\n    *n = shift; *d = shift;\n    my($quotient,$remainder)= synthetic_division( \\@n, \\@d );\n    \"[@n] / [@d] = [$quotient], remainder [$remainder]\\n\";\n}\n\nprint poly_divide([1, -12, 0, -42], [1, -3]);\nprint poly_divide([1, 0, 0, 0, -2], [1, 1, 1, 1]);\n", "target": "import java.util.Arrays;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] N = {1, -12, 0, -42};\n        int[] D = {1, -3};\n\n        System.out.printf(\"%s / %s = %s\",\n                Arrays.toString(N),\n                Arrays.toString(D),\n                Arrays.deepToString(extendedSyntheticDivision(N, D)));\n    }\n\n    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {\n        int[] out = dividend.clone();\n        int normalizer = divisor[0];\n\n        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {\n            out[i] /= normalizer;\n\n            int coef = out[i];\n            if (coef != 0) {\n                for (int j = 1; j < divisor.length; j++)\n                    out[i + j] += -divisor[j] * coef;\n            }\n        }\n\n        int separator = out.length - (divisor.length - 1);\n\n        return new int[][]{\n            Arrays.copyOfRange(out, 0, separator),\n            Arrays.copyOfRange(out, separator, out.length)\n        };\n    }\n}\n"}
{"id": 415735, "name": "Polynomial synthetic division", "source": "Translate Perl to Java: sub synthetic_division {\n    my($numerator,$denominator) = @_;\n    my @result = @$numerator;\n    my $end    = @$denominator-1;\n\n    for my $i (0 .. @$numerator-($end+1)) {\n        next unless $result[$i];\n        $result[$i]    /= @$denominator[0];\n        $result[$i+$_] -= @$denominator[$_] * $result[$i] for 1 .. $end;\n    }\n\n    return join(' ', @result[0 .. @result-($end+1)]), join(' ', @result[-$end .. -1]);\n}\n\nsub poly_divide {\n    *n = shift; *d = shift;\n    my($quotient,$remainder)= synthetic_division( \\@n, \\@d );\n    \"[@n] / [@d] = [$quotient], remainder [$remainder]\\n\";\n}\n\nprint poly_divide([1, -12, 0, -42], [1, -3]);\nprint poly_divide([1, 0, 0, 0, -2], [1, 1, 1, 1]);\n", "target": "import java.util.Arrays;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] N = {1, -12, 0, -42};\n        int[] D = {1, -3};\n\n        System.out.printf(\"%s / %s = %s\",\n                Arrays.toString(N),\n                Arrays.toString(D),\n                Arrays.deepToString(extendedSyntheticDivision(N, D)));\n    }\n\n    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {\n        int[] out = dividend.clone();\n        int normalizer = divisor[0];\n\n        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {\n            out[i] /= normalizer;\n\n            int coef = out[i];\n            if (coef != 0) {\n                for (int j = 1; j < divisor.length; j++)\n                    out[i + j] += -divisor[j] * coef;\n            }\n        }\n\n        int separator = out.length - (divisor.length - 1);\n\n        return new int[][]{\n            Arrays.copyOfRange(out, 0, separator),\n            Arrays.copyOfRange(out, separator, out.length)\n        };\n    }\n}\n"}
{"id": 415736, "name": "Color wheel", "source": "Translate Perl to Java: use Imager;\nuse Math::Complex qw(cplx i pi);\n\nmy ($width, $height) = (300, 300);\nmy $center = cplx($width/2, $height/2);\n\nmy $img = Imager->new(xsize => $width,\n                      ysize => $height);\n\nforeach my $y (0 .. $height - 1) {\n    foreach my $x (0 .. $width - 1) {\n\n        my $vec = $center - $x - $y * i;\n        my $mag = 2 * abs($vec) / $width;\n        my $dir = (pi + atan2($vec->Re, $vec->Im)) / (2 * pi);\n\n        $img->setpixel(x => $x, y => $y,\n            color => {hsv => [360 * $dir, $mag, $mag < 1 ? 1 : 0]});\n    }\n}\n\n$img->write(file => 'color_wheel.png');\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class ColorWheel {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                ColorWheelFrame frame = new ColorWheelFrame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class ColorWheelFrame extends JFrame {\n        private ColorWheelFrame() {\n            super(\"Color Wheel\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            getContentPane().add(new ColorWheelPanel());\n            pack();\n        }\n    }\n\n    private static class ColorWheelPanel extends JComponent {\n        private ColorWheelPanel() {\n            setPreferredSize(new Dimension(400, 400));\n        }\n        public void paint(Graphics g) {\n            Graphics2D g2 = (Graphics2D)g;\n            int w = getWidth();\n            int h = getHeight();\n            int margin = 10;\n            int radius = (Math.min(w, h) - 2 * margin)/2;\n            int cx = w/2;\n            int cy = h/2;\n            float[] dist = {0.F, 1.0F};\n            g2.setColor(Color.BLACK);\n            g2.fillRect(0, 0, w, h);\n            for (int angle = 0; angle < 360; ++angle) {\n                Color color = hsvToRgb(angle, 1.0, 1.0);\n                Color[] colors = {Color.WHITE, color};\n                RadialGradientPaint paint = new RadialGradientPaint(cx, cy,\n                        radius, dist, colors);\n                g2.setPaint(paint);\n                g2.fillArc(cx - radius, cy - radius, radius*2, radius*2,\n                        angle, 1);\n            }\n        }\n    }\n\n    private static Color hsvToRgb(int h, double s, double v) {\n        double hp = h/60.0;\n        double c = s * v;\n        double x = c * (1 - Math.abs(hp % 2.0 - 1));\n        double m = v - c;\n        double r = 0, g = 0, b = 0;\n        if (hp <= 1) {\n            r = c;\n            g = x;\n        } else if (hp <= 2) {\n            r = x;\n            g = c;\n        } else if (hp <= 3) {\n            g = c;\n            b = x;\n        } else if (hp <= 4) {\n            g = x;\n            b = c;\n        } else if (hp <= 5) {\n            r = x;\n            b = c;\n        } else {\n            r = c;\n            b = x;\n        }\n        r += m;\n        g += m;\n        b += m;\n        return new Color((int)(r * 255), (int)(g * 255), (int)(b * 255));\n    }\n}\n"}
{"id": 415737, "name": "Pseudorandom number generator image", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse GD;\n\nmy $img = GD::Image->new(500, 500, 1);\n\nfor my $y (0..500) {\n        for my $x (0..500) {\n                my $color = $img->colorAllocate(rand 256, rand 256, rand 256);\n                $img->setPixel($x, $y, $color);\n        }\n}\n\nopen  F, \"image500.png\";\nprint F  $img->png;\n", "target": "import javax.imageio.ImageIO;\nimport java.awt.*;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.security.SecureRandom;\nimport java.util.Random;\nimport java.util.Scanner;\n\n\npublic class csprngBBS {\n    public static Scanner input = new Scanner(System.in);\n    private static final String fileformat = \"png\";\n    private static String bitsStri = \"\";\n    private static String parityEven = \"\";\n    private static String leastSig = \"\";\n    private static String randomJavaUtil = \"\";\n    private static int width = 0;\n    private static int BIT_LENGTH = 0;\n    private static final Random rand = new SecureRandom();\n    private static BigInteger p = null; \n    private static BigInteger q = null; \n    private static BigInteger m = null;\n    private static BigInteger seed = null; \n    private static BigInteger seedFinal = null;\n    private static final Random randMathUtil = new SecureRandom();\n    public static void main(String[] args) throws IOException {\n        System.out.print(\"Width: \");\n        width = input.nextInt();\n        System.out.print(\"Bit-Length: \");\n        BIT_LENGTH = input.nextInt();\n        System.out.print(\"Generator format: \");\n        String useGenerator = input.next();\n        p = BigInteger.probablePrime(BIT_LENGTH, rand);\n        q = BigInteger.probablePrime(BIT_LENGTH, rand);\n        m = p.multiply(q);\n        seed = BigInteger.probablePrime(BIT_LENGTH,rand);\n        seedFinal = seed.add(BigInteger.ZERO);\n        if(useGenerator.contains(\"parity\") && useGenerator.contains(\"significant\")) {\n            findLeastSignificant();\n            findBitParityEven();\n            createImage(parityEven, \"parityEven\");\n            createImage(leastSig, \"significant\");\n        }\n\n        if(useGenerator.contains(\"parity\") && !useGenerator.contains(\"significant\")){\n            findBitParityEven();\n        }\n\n        if(useGenerator.contains(\"significant\") && !useGenerator.contains(\"parity\")){\n            findLeastSignificant();\n            createImage(leastSig, \"significant\");\n        }\n\n        if(useGenerator.contains(\"util\")){\n            findRandomJava(randMathUtil);\n            createImage(randomJavaUtil, \"randomUtilJava\");\n        }\n    }\n    public static void findRandomJava(Random random){\n        for(int x = 1; x <= Math.pow(width, 2); x++){\n            randomJavaUtil += random.nextInt(2);\n        }\n    }\n\n    public static void findBitParityEven(){\n        for(int x = 1; x <= Math.pow(width, 2); x++) {\n            seed = seed.pow(2).mod(m);\n            bitsStri = convertBinary(seed);\n            char[] bits = bitsStri.toCharArray();\n            int counter = 0;\n            for (char bit : bits) {\n                if (bit == '1') {\n                    counter++;\n                }\n            }\n            if (counter % 2 != 0) {\n                parityEven += \"1\";\n            } else {\n                parityEven += \"0\";\n            }\n        }\n    }\n\n    public static void findLeastSignificant(){\n        seed = seedFinal;\n        for(int x = 1; x <= Math.pow(width, 2); x++){\n            seed = seed.pow(2).mod(m);\n            leastSig += bitsStri.substring(bitsStri.length() - 1);\n        }\n    }\n\n    public static String convertBinary(BigInteger value){\n        StringBuilder total = new StringBuilder();\n        BigInteger two = BigInteger.TWO;\n        while(value.compareTo(BigInteger.ZERO) > 0){\n            total.append(value.mod(two));\n            value = value.divide(two);\n        }\n        return total.reverse().toString();\n    }\n\n    public static void createImage(String useThis, String fileName) throws IOException {\n        int length = csprngBBS.width;\n        \n        BufferedImage bufferedImage = new BufferedImage(length, length, 1);\n        \n        Graphics2D g2d = bufferedImage.createGraphics();\n        for (int y = 1; y <= length; y++) {\n            for (int x = 1; x <= length; x++) {\n                if (useThis.startsWith(\"1\")) {\n                    useThis = useThis.substring(1);\n                    g2d.setColor(Color.BLACK);\n                    g2d.fillRect(x, y, 1, 1);\n                } else if (useThis.startsWith(\"0\")) {\n                    useThis = useThis.substring(1);\n                    g2d.setColor(Color.WHITE);\n                    g2d.fillRect(x, y, 1, 1);\n                }\n            }\n            System.out.print(y + \"\\t\");\n        }\n        \n        g2d.dispose();\n        \n        File file = new File(\"REPLACEFILEPATHHERE\" + fileName + \".\" + fileformat);\n        ImageIO.write(bufferedImage, fileformat, file);\n    }\n}\n"}
{"id": 415738, "name": "Find duplicate files", "source": "Translate Perl to Java: use File::Find qw(find);\nuse File::Compare qw(compare);\nuse Sort::Naturally;\nuse Getopt::Std qw(getopts);\n\nmy %opts;\n$opts{s} = 1;\ngetopts(\"s:\", \\%opts);\n\nsub find_dups {\n    my($dir) = @_;\n\n    my @results;\n    my %files;\n    find {\n        no_chdir => 1,\n        wanted => sub { lstat; -f _ && (-s >= $opt{s} ) && push @{$files{-s _}}, $_ }\n    } => $dir;\n\n    foreach my $files (values %files) {\n        next unless @$files;\n\n        my %dups;\n        foreach my $a (0 .. @$files - 1) {\n            for (my $b = $a + 1 ; $b < @$files ; $b++) {\n                next if compare(@$files[$a], @$files[$b]);\n                push @{$dups{ @$files[$a] }}, splice @$files, $b--, 1;\n            }\n        }\n\n        while (my ($original, $clones) = each %dups) {\n            push @results, sprintf \"%8d %s\\n\", (stat($original))[7], join ', ', sort $original, @$clones;\n        }\n    }\n    reverse nsort @results;\n\n}\n\nprint for find_dups(@ARGV);\n", "target": "import java.io.*;\nimport java.nio.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.*;\nimport java.security.*;\nimport java.util.*;\n\npublic class DuplicateFiles {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.err.println(\"Directory name and minimum file size are required.\");\n            System.exit(1);\n        }\n        try {\n            findDuplicateFiles(args[0], Long.parseLong(args[1]));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void findDuplicateFiles(String directory, long minimumSize)\n        throws IOException, NoSuchAlgorithmException {\n        System.out.println(\"Directory: '\" + directory + \"', minimum size: \" + minimumSize + \" bytes.\");\n        Path path = FileSystems.getDefault().getPath(directory);\n        FileVisitor visitor = new FileVisitor(path, minimumSize);\n        Files.walkFileTree(path, visitor);\n        System.out.println(\"The following sets of files have the same size and checksum:\");\n        for (Map.Entry<FileKey, Map<Object, List<String>>> e : visitor.fileMap_.entrySet()) {\n            Map<Object, List<String>> map = e.getValue();\n            if (!containsDuplicates(map))\n                continue;\n            List<List<String>> fileSets = new ArrayList<>(map.values());\n            for (List<String> files : fileSets)\n                Collections.sort(files);\n            Collections.sort(fileSets, new StringListComparator());\n            FileKey key = e.getKey();\n            System.out.println();\n            System.out.println(\"Size: \" + key.size_ + \" bytes\");\n            for (List<String> files : fileSets) {\n                for (int i = 0, n = files.size(); i < n; ++i) {\n                    if (i > 0)\n                        System.out.print(\" = \");\n                    System.out.print(files.get(i));\n                }\n                System.out.println();\n            }\n        }\n    }\n\n    private static class StringListComparator implements Comparator<List<String>> {\n        public int compare(List<String> a, List<String> b) {\n            int len1 = a.size(), len2 = b.size();\n            for (int i = 0; i < len1 && i < len2; ++i) {\n                int c = a.get(i).compareTo(b.get(i));\n                if (c != 0)\n                    return c;\n            }\n            return Integer.compare(len1, len2);\n        }\n    }\n\n    private static boolean containsDuplicates(Map<Object, List<String>> map) {\n        if (map.size() > 1)\n            return true;\n        for (List<String> files : map.values()) {\n            if (files.size() > 1)\n                return true;\n        }\n        return false;\n    }\n\n    private static class FileVisitor extends SimpleFileVisitor<Path> {\n        private MessageDigest digest_;\n        private Path directory_;\n        private long minimumSize_;\n        private Map<FileKey, Map<Object, List<String>>> fileMap_ = new TreeMap<>();\n\n        private FileVisitor(Path directory, long minimumSize) throws NoSuchAlgorithmException {\n            directory_ = directory;\n            minimumSize_ = minimumSize;\n            digest_ = MessageDigest.getInstance(\"MD5\");\n        }\n\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            if (attrs.size() >= minimumSize_) {\n                FileKey key = new FileKey(file, attrs, getMD5Sum(file));\n                Map<Object, List<String>> map = fileMap_.get(key);\n                if (map == null)\n                    fileMap_.put(key, map = new HashMap<>());\n                List<String> files = map.get(attrs.fileKey());\n                if (files == null)\n                    map.put(attrs.fileKey(), files = new ArrayList<>());\n                Path relative = directory_.relativize(file);\n                files.add(relative.toString());\n            }\n            return FileVisitResult.CONTINUE;\n        }\n\n        private byte[] getMD5Sum(Path file) throws IOException {\n            digest_.reset();\n            try (InputStream in = new FileInputStream(file.toString())) {\n                byte[] buffer = new byte[8192];\n                int bytes;\n                while ((bytes = in.read(buffer)) != -1) {\n                    digest_.update(buffer, 0, bytes);\n                }\n            }\n            return digest_.digest();\n        }\n    }\n\n    private static class FileKey implements Comparable<FileKey> {\n        private byte[] hash_;\n        private long size_;\n\n        private FileKey(Path file, BasicFileAttributes attrs, byte[] hash) throws IOException {\n            size_ = attrs.size();\n            hash_ = hash;\n        }\n\n        public int compareTo(FileKey other) {\n            int c = Long.compare(other.size_, size_);\n            if (c == 0)\n                c = hashCompare(hash_, other.hash_);\n            return c;\n        }\n    }\n\n    private static int hashCompare(byte[] a, byte[] b) {\n        int len1 = a.length, len2 = b.length;\n        for (int i = 0; i < len1 && i < len2; ++i) {\n            int c = Byte.compare(a[i], b[i]);\n            if (c != 0)\n                return c;\n        }\n        return Integer.compare(len1, len2);\n    }\n}\n"}
{"id": 415739, "name": "Legendre prime counting function", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nno warnings qw(recursion);\nuse ntheory qw( nth_prime prime_count );\n\nmy (%cachephi, %cachepi);\n\nsub phi\n  {\n  return $cachephi{\"@_\"} //= do {\n    my ($x, $aa) = @_;\n    $aa <= 0 ? $x : phi($x, $aa - 1) - phi(int $x / nth_prime($aa), $aa - 1) };\n  }\n\nsub pi\n  {\n  return $cachepi{$_[0]} //= do {\n    my $n = shift;\n    $n < 2 ? 0 : do{ my $aa = pi(int sqrt $n); phi($n, $aa) + $aa - 1 } };\n  }\n\nprint \"e             n   Legendre    ntheory\\n\",\n      \"-             -   --------    -------\\n\";\nfor (1 .. 9)\n  {\n  printf \"%d  %12d %10d %10d\\n\", $_, 10**$_, pi(10**$_), prime_count(10**$_);\n  }\n", "target": "import java.util.*;\n\npublic class LegendrePrimeCounter {\n    public static void main(String[] args) {\n        LegendrePrimeCounter counter = new LegendrePrimeCounter(1000000000);\n        for (int i = 0, n = 1; i < 10; ++i, n *= 10)\n            System.out.printf(\"10^%d\\t%d\\n\", i, counter.primeCount((n)));\n    }\n\n    private List<Integer> primes;\n\n    public LegendrePrimeCounter(int limit) {\n        primes = generatePrimes((int)Math.sqrt((double)limit));\n    }\n\n    public int primeCount(int n) {\n        if (n < 2)\n            return 0;\n        int a = primeCount((int)Math.sqrt((double)n));\n        return phi(n, a) + a - 1;\n    }\n\n    private int phi(int x, int a) {\n        if (a == 0)\n            return x;\n        if (a == 1)\n            return x - (x >> 1);\n        int pa = primes.get(a - 1);\n        if (x <= pa)\n            return 1;\n        return phi(x, a - 1) - phi(x / pa, a - 1);\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit >> 1];\n        Arrays.fill(sieve, true);\n        for (int p = 3, s = 9; s < limit; p += 2) {\n            if (sieve[p >> 1]) {\n                for (int q = s; q < limit; q += p << 1)\n                    sieve[q >> 1] = false;\n            }\n            s += (p + 1) << 2;\n        }\n        List<Integer> primes = new ArrayList<>();\n        if (limit > 2)\n            primes.add(2);\n        for (int i = 1; i < sieve.length; ++i) {\n            if (sieve[i])\n                primes.add((i << 1) + 1);\n        } \n        return primes;\n    }\n}\n"}
{"id": 415740, "name": "Rosetta Code_Find bare lang tags", "source": "Translate Perl to Java: my $lang = 'no language';\nmy $total = 0;\nmy %blanks = ();\nwhile (<>) {\n  if (m/<lang>/) {\n    if (exists $blanks{lc $lang}) {\n      $blanks{lc $lang}++\n    } else {\n      $blanks{lc $lang} = 1\n    }\n    $total++\n  } elsif (m/==\\s*\\{\\{\\s*header\\s*\\|\\s*([^\\s\\}]+)\\s*\\}\\}\\s*==/) {\n    $lang = lc $1\n  }\n}\n\nif ($total) {\n\tprint \"$total bare language tag\" . ($total > 1 ? 's' : '') . \".\\n\\n\";\n\twhile ( my ($k, $v) = each(%blanks) ) {\n\t\tprint \"$k in $v\\n\"\n\t}\n}\n", "target": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class FindBareTags {\n    private static final String BASE = \"http:\n\n    private static final Pattern TITLE_PATTERN = Pattern.compile(\"\\\"title\\\": \\\"([^\\\"]+)\\\"\");\n    private static final Pattern HEADER_PATTERN = Pattern.compile(\"==\\\\{\\\\{header\\\\|([^}]+)}}==\");\n    private static final Predicate<String> BARE_PREDICATE = Pattern.compile(\"<lang>\").asPredicate();\n\n    public static void main(String[] args) throws Exception {\n        var client = HttpClient.newBuilder().build();\n\n        URI titleUri = URI.create(BASE + \"/mw/api.php?action=query&list=categorymembers&cmtitle=Category:Programming_Tasks\");\n        var titleRequest = HttpRequest.newBuilder(titleUri).GET().build();\n\n        var titleResponse = client.send(titleRequest, HttpResponse.BodyHandlers.ofString());\n        if (titleResponse.statusCode() == 200) {\n            var titleBody = titleResponse.body();\n\n            var titleMatcher = TITLE_PATTERN.matcher(titleBody);\n            var titleList = titleMatcher.results().map(mr -> mr.group(1)).collect(Collectors.toList());\n\n            var countMap = new HashMap<String, Integer>();\n            for (String title : titleList) {\n                var pageUri = new URI(\"http\", null, \"\n                var pageRequest = HttpRequest.newBuilder(pageUri).GET().build();\n                var pageResponse = client.send(pageRequest, HttpResponse.BodyHandlers.ofString());\n                if (pageResponse.statusCode() == 200) {\n                    var pageBody = pageResponse.body();\n\n                    AtomicReference<String> language = new AtomicReference<>(\"no language\");\n                    pageBody.lines().forEach(line -> {\n                        var headerMatcher = HEADER_PATTERN.matcher(line);\n                        if (headerMatcher.matches()) {\n                            language.set(headerMatcher.group(1));\n                        } else if (BARE_PREDICATE.test(line)) {\n                            int count = countMap.getOrDefault(language.get(), 0) + 1;\n                            countMap.put(language.get(), count);\n                        }\n                    });\n                } else {\n                    System.out.printf(\"Got a %d status code%n\", pageResponse.statusCode());\n                }\n            }\n\n            for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n                System.out.printf(\"%d in %s%n\", entry.getValue(), entry.getKey());\n            }\n        } else {\n            System.out.printf(\"Got a %d status code%n\", titleResponse.statusCode());\n        }\n    }\n}\n"}
{"id": 415741, "name": "Permuted multiples", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy $n = 3;\n1 while do {\n  length($n += 3) < length 6 * $n and $n = 1 . $n =~ s/./0/gr + 2;\n  my $sorted = join '', sort split //, $n * 6;\n  $sorted ne join '', sort split //, $n * 1 or\n  $sorted ne join '', sort split //, $n * 2 or\n  $sorted ne join '', sort split //, $n * 3 or\n  $sorted ne join '', sort split //, $n * 4 or\n  $sorted ne join '', sort split //, $n * 5\n  };\nprintf \" n  %s\\n\", $n;\nprintf \"%dn  %s\\n\", $_ , $n * $_ for 2 .. 6;\n", "target": "import java.util.*;\n\npublic class PermutedMultiples {\n    public static void main(String[] args) {\n        for (int p = 100; ; p *= 10) {\n            int max = (p * 10) / 6;\n            for (int n = p + 2; n <= max; n += 3) {\n                if (sameDigits(n)) {\n                    System.out.printf(\" n = %d\\n\", n);\n                    for (int i = 2; i <= 6; ++i)\n                        System.out.printf(\"%dn = %d\\n\", i, n * i);\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    private static boolean sameDigits(int n) {\n        int[] digits = getDigits(n);\n        for (int i = 0, m = n; i < 5; ++i) {\n            m += n;\n            if (!Arrays.equals(getDigits(m), digits))\n                return false;\n        }\n        return true;\n    }\n\n    private static int[] getDigits(int n) {\n        int[] digits = new int[10];\n        do {\n            ++digits[n % 10];\n            n /= 10;\n        } while (n > 0);\n        return digits;\n    }\n}\n"}
{"id": 415742, "name": "Permuted multiples", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nmy $n = 3;\n1 while do {\n  length($n += 3) < length 6 * $n and $n = 1 . $n =~ s/./0/gr + 2;\n  my $sorted = join '', sort split //, $n * 6;\n  $sorted ne join '', sort split //, $n * 1 or\n  $sorted ne join '', sort split //, $n * 2 or\n  $sorted ne join '', sort split //, $n * 3 or\n  $sorted ne join '', sort split //, $n * 4 or\n  $sorted ne join '', sort split //, $n * 5\n  };\nprintf \" n  %s\\n\", $n;\nprintf \"%dn  %s\\n\", $_ , $n * $_ for 2 .. 6;\n", "target": "import java.util.*;\n\npublic class PermutedMultiples {\n    public static void main(String[] args) {\n        for (int p = 100; ; p *= 10) {\n            int max = (p * 10) / 6;\n            for (int n = p + 2; n <= max; n += 3) {\n                if (sameDigits(n)) {\n                    System.out.printf(\" n = %d\\n\", n);\n                    for (int i = 2; i <= 6; ++i)\n                        System.out.printf(\"%dn = %d\\n\", i, n * i);\n                    return;\n                }\n            }\n        }\n    }\n\n    \n    private static boolean sameDigits(int n) {\n        int[] digits = getDigits(n);\n        for (int i = 0, m = n; i < 5; ++i) {\n            m += n;\n            if (!Arrays.equals(getDigits(m), digits))\n                return false;\n        }\n        return true;\n    }\n\n    private static int[] getDigits(int n) {\n        int[] digits = new int[10];\n        do {\n            ++digits[n % 10];\n            n /= 10;\n        } while (n > 0);\n        return digits;\n    }\n}\n"}
{"id": 415743, "name": "Palindromic gapful numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse constant Inf  => 1e10;\n\nsub is_p_gapful {\n    my($d,$n) = @_;\n    return '' unless 0 == $n % 11;\n    my @digits = split //, $n;\n    $d eq $digits[0] and (0 == $n % ($digits[0].$digits[-1])) and $n eq join '', reverse @digits;\n}\n\nfor ([1, 20], [86, 15]) {\n    my($offset, $count) = @$_;\n    say \"Palindromic gapful numbers starting at $offset:\";\n    for my $d ('1'..'9') {\n        my $n = 0; my $out = \"$d: \";\n        $out .= do { $n+1 < $count+$offset ? (is_p_gapful($d,$_) and ++$n and $n >= $offset and \"$_ \") : last } for 100 .. Inf;\n        say $out\n    }\n    say ''\n}\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PalindromicGapfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 20 palindromic gapful numbers ending in:\");\n        displayMap(getPalindromicGapfulEnding(20, 20));\n\n        System.out.printf(\"%nLast 15 of first 100 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(15, 100));\n\n        System.out.printf(\"%nLast 10 of first 1000 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(10, 1000));\n    }\n    \n    private static void displayMap(Map<Integer,List<Long>> map) {\n        for ( int key = 1 ; key <= 9 ; key++ ) {\n            System.out.println(key + \"\u00a0: \" + map.get(key));\n        }\n    }\n    \n    public static Map<Integer,List<Long>> getPalindromicGapfulEnding(int countReturned, int firstHowMany) {\n        Map<Integer,List<Long>> map = new HashMap<>();\n        Map<Integer,Integer> mapCount = new HashMap<>();\n        for ( int i = 1 ; i <= 9 ; i++ ) {\n            map.put(i, new ArrayList<>());\n            mapCount.put(i, 0);\n        }\n        boolean notPopulated = true;\n        for ( long n = 101 ; notPopulated ; n = nextPalindrome(n) ) {\n            if ( isGapful(n) ) {\n                int index = (int) (n % 10);\n                if ( mapCount.get(index) < firstHowMany ) {\n                    map.get(index).add(n);\n                    mapCount.put(index, mapCount.get(index) + 1);\n                    if ( map.get(index).size() > countReturned ) {\n                        map.get(index).remove(0);\n                    }\n                }\n                boolean finished = true;\n                for ( int i = 1 ; i <= 9 ; i++ ) {\n                    if ( mapCount.get(i) < firstHowMany ) {\n                        finished = false;\n                        break;\n                    }\n                }\n                if ( finished ) {\n                    notPopulated = false;\n                }\n            }\n        }\n        return map;\n    }\n    \n    public static boolean isGapful(long n) {\n        String s = Long.toString(n);\n        return n % Long.parseLong(\"\" + s.charAt(0) + s.charAt(s.length()-1)) == 0;\n    }\n    \n    public static int length(long n) {\n        int length = 0;\n        while ( n > 0 ) {\n            length += 1;\n            n /= 10;\n        }\n        return length;\n    }\n    \n    public static long nextPalindrome(long n) {\n        int length = length(n);\n        if ( length % 2 == 0 ) {\n            length /= 2;\n            while ( length > 0 ) {\n                n /= 10;\n                length--;\n            }\n            n += 1;\n            if ( powerTen(n) ) {\n                return Long.parseLong(n + reverse(n/10));\n            }\n            return Long.parseLong(n + reverse(n));\n        }\n        length = (length - 1) / 2;\n        while ( length > 0 ) {\n            n /= 10;\n            length--;\n        }\n        n += 1;\n        if ( powerTen(n) ) {\n            return Long.parseLong(n + reverse(n/100));\n        }\n        return Long.parseLong(n + reverse(n/10));\n    }\n    \n    private static boolean powerTen(long n) {\n        while ( n > 9 && n % 10 == 0 ) {\n            n /= 10;\n        }\n        return n == 1;\n    }\n        \n    private static String reverse(long n) {\n        return (new StringBuilder(n + \"\")).reverse().toString();\n    }\n\n}\n"}
{"id": 415744, "name": "Palindromic gapful numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse constant Inf  => 1e10;\n\nsub is_p_gapful {\n    my($d,$n) = @_;\n    return '' unless 0 == $n % 11;\n    my @digits = split //, $n;\n    $d eq $digits[0] and (0 == $n % ($digits[0].$digits[-1])) and $n eq join '', reverse @digits;\n}\n\nfor ([1, 20], [86, 15]) {\n    my($offset, $count) = @$_;\n    say \"Palindromic gapful numbers starting at $offset:\";\n    for my $d ('1'..'9') {\n        my $n = 0; my $out = \"$d: \";\n        $out .= do { $n+1 < $count+$offset ? (is_p_gapful($d,$_) and ++$n and $n >= $offset and \"$_ \") : last } for 100 .. Inf;\n        say $out\n    }\n    say ''\n}\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PalindromicGapfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 20 palindromic gapful numbers ending in:\");\n        displayMap(getPalindromicGapfulEnding(20, 20));\n\n        System.out.printf(\"%nLast 15 of first 100 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(15, 100));\n\n        System.out.printf(\"%nLast 10 of first 1000 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(10, 1000));\n    }\n    \n    private static void displayMap(Map<Integer,List<Long>> map) {\n        for ( int key = 1 ; key <= 9 ; key++ ) {\n            System.out.println(key + \"\u00a0: \" + map.get(key));\n        }\n    }\n    \n    public static Map<Integer,List<Long>> getPalindromicGapfulEnding(int countReturned, int firstHowMany) {\n        Map<Integer,List<Long>> map = new HashMap<>();\n        Map<Integer,Integer> mapCount = new HashMap<>();\n        for ( int i = 1 ; i <= 9 ; i++ ) {\n            map.put(i, new ArrayList<>());\n            mapCount.put(i, 0);\n        }\n        boolean notPopulated = true;\n        for ( long n = 101 ; notPopulated ; n = nextPalindrome(n) ) {\n            if ( isGapful(n) ) {\n                int index = (int) (n % 10);\n                if ( mapCount.get(index) < firstHowMany ) {\n                    map.get(index).add(n);\n                    mapCount.put(index, mapCount.get(index) + 1);\n                    if ( map.get(index).size() > countReturned ) {\n                        map.get(index).remove(0);\n                    }\n                }\n                boolean finished = true;\n                for ( int i = 1 ; i <= 9 ; i++ ) {\n                    if ( mapCount.get(i) < firstHowMany ) {\n                        finished = false;\n                        break;\n                    }\n                }\n                if ( finished ) {\n                    notPopulated = false;\n                }\n            }\n        }\n        return map;\n    }\n    \n    public static boolean isGapful(long n) {\n        String s = Long.toString(n);\n        return n % Long.parseLong(\"\" + s.charAt(0) + s.charAt(s.length()-1)) == 0;\n    }\n    \n    public static int length(long n) {\n        int length = 0;\n        while ( n > 0 ) {\n            length += 1;\n            n /= 10;\n        }\n        return length;\n    }\n    \n    public static long nextPalindrome(long n) {\n        int length = length(n);\n        if ( length % 2 == 0 ) {\n            length /= 2;\n            while ( length > 0 ) {\n                n /= 10;\n                length--;\n            }\n            n += 1;\n            if ( powerTen(n) ) {\n                return Long.parseLong(n + reverse(n/10));\n            }\n            return Long.parseLong(n + reverse(n));\n        }\n        length = (length - 1) / 2;\n        while ( length > 0 ) {\n            n /= 10;\n            length--;\n        }\n        n += 1;\n        if ( powerTen(n) ) {\n            return Long.parseLong(n + reverse(n/100));\n        }\n        return Long.parseLong(n + reverse(n/10));\n    }\n    \n    private static boolean powerTen(long n) {\n        while ( n > 9 && n % 10 == 0 ) {\n            n /= 10;\n        }\n        return n == 1;\n    }\n        \n    private static String reverse(long n) {\n        return (new StringBuilder(n + \"\")).reverse().toString();\n    }\n\n}\n"}
{"id": 415745, "name": "Chernick's Carmichael numbers", "source": "Translate Perl to Java: use 5.020;\nuse warnings;\nuse ntheory qw/:all/;\nuse experimental qw/signatures/;\n\nsub chernick_carmichael_factors ($n, $m) {\n    (6*$m + 1, 12*$m + 1, (map { (1 << $_) * 9*$m + 1 } 1 .. $n-2));\n}\n\nsub chernick_carmichael_number ($n, $callback) {\n\n    my $multiplier = ($n > 4) ? (1 << ($n-4)) : 1;\n\n    for (my $m = 1 ; ; ++$m) {\n        my @f = chernick_carmichael_factors($n, $m * $multiplier);\n        next if not vecall { is_prime($_) } @f;\n        $callback->(@f);\n        last;\n    }\n}\n\nforeach my $n (3..9) {\n    chernick_carmichael_number($n, sub (@f) { say \"a($n) = \", vecprod(@f) });\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ChernicksCarmichaelNumbers {\n\n    public static void main(String[] args) {\n        for ( long n = 3 ; n < 10 ; n++ ) {\n            long m = 0;\n            boolean foundComposite = true;\n            List<Long> factors = null;\n            while ( foundComposite ) {\n                m += (n <= 4 ? 1 : (long) Math.pow(2, n-4) * 5);\n                factors = U(n, m);\n                foundComposite = false;\n                for ( long factor : factors ) {\n                    if ( ! isPrime(factor) ) {\n                        foundComposite = true;\n                        break;\n                    }\n                }\n            }\n            System.out.printf(\"U(%d, %d) = %s = %s %n\", n, m, display(factors), multiply(factors));\n        }\n    }\n    \n    private static String display(List<Long> factors) {\n        return factors.toString().replace(\"[\", \"\").replace(\"]\", \"\").replaceAll(\", \", \" * \");\n    }\n    \n    private static BigInteger multiply(List<Long> factors) {\n        BigInteger result = BigInteger.ONE;\n        for ( long factor : factors ) {\n            result = result.multiply(BigInteger.valueOf(factor));\n        }\n        return result;\n    }\n    \n    private static List<Long> U(long n, long m) {\n        List<Long> factors = new ArrayList<>();\n        factors.add(6*m + 1);\n        factors.add(12*m + 1);\n        for ( int i = 1 ; i <= n-2 ; i++ ) {\n            factors.add(((long)Math.pow(2, i)) * 9 * m + 1);\n        }\n        return factors;\n    }\n\n    private static final int MAX = 100_000;\n    private static final boolean[] primes = new boolean[MAX];\n    private static boolean SIEVE_COMPLETE = false;\n    \n    private static final boolean isPrimeTrivial(long test) {\n        if ( ! SIEVE_COMPLETE ) {\n            sieve();\n            SIEVE_COMPLETE = true;\n        }\n        return primes[(int) test];\n    }\n    \n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n    \n    public static final boolean isPrime(long testValue) {\n        if ( testValue == 2 ) return true;\n        if ( testValue % 2 == 0 ) return false;\n        if ( testValue <= MAX ) return isPrimeTrivial(testValue);\n        long d = testValue-1;\n        int s = 0;\n        while ( d % 2 == 0 ) {\n            s += 1;\n            d /= 2;\n        }\n        if ( testValue < 1373565L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 4759123141L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(7, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(61, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 10000000000000000L ) {\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(24251, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        \n        if ( ! aSrp(37, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(47, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(61, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(73, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(83, s, d, testValue) ) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private static final boolean aSrp(int a, int s, long d, long n) {\n        long modPow = modPow(a, d, n);\n        \n        if ( modPow == 1 ) {\n            return true;\n        }\n        int twoExpR = 1;\n        for ( int r = 0 ; r < s ; r++ ) {\n            if ( modPow(modPow, twoExpR, n) == n-1 ) {\n                return true;\n            }\n            twoExpR *= 2;\n        }\n        return false;\n    }\n    \n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n    \n    public static final long modPow(long base, long exponent, long modulus) {\n        long result = 1;\n        while ( exponent > 0 ) {\n            if ( exponent % 2 == 1 ) {\n                if ( result > SQRT || base > SQRT ) {\n                    result = multiply(result, base, modulus);\n                }\n                else {\n                    result = (result * base) % modulus;\n                }\n            }\n            exponent >>= 1;\n            if ( base > SQRT ) {\n                base = multiply(base, base, modulus);\n            }\n            else {\n                base = (base * base) % modulus;\n            }\n        }\n        return result;\n    }\n\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        return x % modulus;\n    }\n\n}\n"}
{"id": 415746, "name": "Wilson primes of order n", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory <primes factorial>;\n\nmy @primes = @{primes( 10500 )};\n\nfor my $n (1..11) {\n    printf \"%3d: %s\\n\", $n, join ' ', grep { $_ >= $n && 0 == (factorial($n-1) * factorial($_-$n) - (-1)**$n) % $_**2 } @primes\n}\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class WilsonPrimes {\n    public static void main(String[] args) {\n        final int limit = 11000;\n        BigInteger[] f = new BigInteger[limit];\n        f[0] = BigInteger.ONE;\n        BigInteger factorial = BigInteger.ONE;\n        for (int i = 1; i < limit; ++i) {\n            factorial = factorial.multiply(BigInteger.valueOf(i));\n            f[i] = factorial;\n        }\n        List<Integer> primes = generatePrimes(limit);\n        System.out.printf(\" n | Wilson primes\\n--------------------\\n\");\n        BigInteger s = BigInteger.valueOf(-1);\n        for (int n = 1; n <= 11; ++n) {\n            System.out.printf(\"%2d |\", n);\n            for (int p : primes) {\n                if (p >= n && f[n - 1].multiply(f[p - n]).subtract(s)\n                        .mod(BigInteger.valueOf(p * p))\n                        .equals(BigInteger.ZERO))\n                    System.out.printf(\" %d\", p);\n            }\n            s = s.negate();\n            System.out.println();\n        }\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit >> 1];\n        Arrays.fill(sieve, true);\n        for (int p = 3, s = 9; s < limit; p += 2) {\n            if (sieve[p >> 1]) {\n                for (int q = s; q < limit; q += p << 1)\n                    sieve[q >> 1] = false;\n            }\n            s += (p + 1) << 2;\n        }\n        List<Integer> primes = new ArrayList<>();\n        if (limit > 2)\n            primes.add(2);\n        for (int i = 1; i < sieve.length; ++i) {\n            if (sieve[i])\n                primes.add((i << 1) + 1);\n        } \n        return primes;\n    }\n}\n"}
{"id": 415747, "name": "Prime triangle", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\nuse List::MoreUtils qw(zip slideatatime);\nuse Algorithm::Combinatorics qw(permutations);\n\nsay '1 2';\n\nmy @count = (0, 0, 1);\n\nfor my $n (3..17) {\n    my @even_nums = grep { 0 == $_ % 2 } 2..$n-1;\n    my @odd_nums  = grep { 1 == $_ % 2 } 3..$n-1;\n    for my $e (permutations [@even_nums]) {\n        next if $$e[0] == 8 or $$e[0] == 14;\n        my $nope = 0;\n        for my $o (permutations [@odd_nums]) {\n            my @list = (zip(@$e, @$o), $n);                 \n            splice @list, -2, -1 if not defined $list[-2];  \n            my $it = slideatatime(1, 2, @list);\n            while ( my @rr = $it->() ) {\n                last unless defined $rr[1];\n                $nope++ and last unless is_prime $rr[0]+$rr[1];\n            }\n            unless ($nope) {\n                say '1 ' . join ' ', @list unless $count[$n];\n                $count[$n]++;\n            }\n            $nope = 0;\n        }\n    }\n}\n\nsay \"\\n\" . join ' ', @count[2..$\n", "target": "public class PrimeTriangle {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (findRow(a, 0, i))\n                printRow(a);                \n        }\n        System.out.println();\n        StringBuilder s = new StringBuilder();\n        for (int i = 2; i <= 20; ++i) {\n            int[] a = new int[i];\n            for (int j = 0; j < i; ++j)\n                a[j] = j + 1;\n            if (i > 2)\n                s.append(\" \");\n            s.append(countRows(a, 0, i));\n        }\n        System.out.println(s);\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"\\nElapsed time: %d milliseconds\\n\", finish - start);\n    }\n\n    private static void printRow(int[] a) {\n        for (int i = 0; i < a.length; ++i) {\n            if (i != 0)\n                System.out.print(\" \");\n            System.out.printf(\"%2d\", a[i]);\n        }\n        System.out.println();\n    }\n\n    private static boolean findRow(int[] a, int start, int length) {\n        if (length == 2)\n            return isPrime(a[start] + a[start + 1]);\n        for (int i = 1; i + 1 < length; i += 2) {\n            if (isPrime(a[start] + a[start + i])) {\n                swap(a, start + i, start + 1);\n                if (findRow(a, start + 1, length - 1))\n                    return true;\n                swap(a, start + i, start + 1);\n            }\n        }\n        return false;\n    }\n\n    private static int countRows(int[] a, int start, int length) {\n        int count = 0;\n        if (length == 2) {\n            if (isPrime(a[start] + a[start + 1]))\n                ++count;\n        } else {\n            for (int i = 1; i + 1 < length; i += 2) {\n                if (isPrime(a[start] + a[start + i])) {\n                    swap(a, start + i, start + 1);\n                    count += countRows(a, start + 1, length - 1);\n                    swap(a, start + i, start + 1);\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void swap(int[] a, int i, int j) {\n        int tmp = a[i];\n        a[i] = a[j];\n        a[j] = tmp;\n    }\n\n    private static boolean isPrime(int n) {\n        return ((1L << n) & 0x28208a20a08a28acL) != 0;\n    }\n}\n"}
{"id": 415748, "name": "XML validation", "source": "Translate Perl to Java: \nuse 5.018_002;\nuse warnings;\nuse Try::Tiny;\nuse XML::LibXML;\n\nour $VERSION = 1.000_000;\n\nmy $parser = XML::LibXML->new();\n\nmy $good_xml         = '<a>5</a>';\nmy $bad_xml          = '<a>5<b>foobar</b></a>';\nmy $xmlschema_markup = <<'END';\n<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">\n  <xsd:element name=\"a\" type=\"xsd:integer\"/>\n</xsd:schema>\nEND\n\nmy $xmlschema = XML::LibXML::Schema->new( string => $xmlschema_markup );\n\nfor ( $good_xml, $bad_xml ) {\n    my $doc = $parser->parse_string($_);\n    try {\n        $xmlschema->validate($doc);\n    }\n    finally {\n        if (@_) {\n            say \"Not valid: @_\";\n        }\n        else {\n            say 'Valid';\n        }\n    };\n}\n", "target": "import static javax.xml.XMLConstants.W3C_XML_SCHEMA_NS_URI;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport javax.xml.transform.stream.StreamSource;\nimport javax.xml.validation.SchemaFactory;\nimport javax.xml.validation.Validator;\nimport javax.xml.ws.Holder;\n\nimport org.xml.sax.ErrorHandler;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\npublic class XmlValidation {\n\tpublic static void main(String... args) throws MalformedURLException {\n\t\tURL schemaLocation = new URL(\"http:\n\t\tURL documentLocation = new URL(\"http:\n\t\tif (validate(schemaLocation, documentLocation)) {\n\t\t\tSystem.out.println(\"document is valid\");\n\t\t} else {\n\t\t\tSystem.out.println(\"document is invalid\");\n\t\t}\n\t}\n\n\t\n\tpublic static boolean minimalValidate(URL schemaLocation, URL documentLocation) {\n\t\tSchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);\n\t\ttry {\n\t\t\tValidator validator = factory.newSchema(schemaLocation).newValidator();\n\t\t\tvalidator.validate(new StreamSource(documentLocation.toString()));\n\t\t\treturn true;\n\t\t} catch (Exception e) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\t\n\tpublic static boolean validate(URL schemaLocation, URL documentLocation) {\n\t\tSchemaFactory factory = SchemaFactory.newInstance(W3C_XML_SCHEMA_NS_URI);\n\t\tfinal Holder<Boolean> valid = new Holder<>(true);\n\t\ttry {\n\t\t\tValidator validator = factory.newSchema(schemaLocation).newValidator();\n\t\t\t\n\t\t\tvalidator.setErrorHandler(new ErrorHandler(){\n\t\t\t\t@Override\n\t\t\t\tpublic void warning(SAXParseException exception) {\n\t\t\t\t\tSystem.out.println(\"warning: \" + exception.getMessage());\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void error(SAXParseException exception) {\n\t\t\t\t\tSystem.out.println(\"error: \" + exception.getMessage());\n\t\t\t\t\tvalid.value = false;\n\t\t\t\t}\n\n\t\t\t\t@Override\n\t\t\t\tpublic void fatalError(SAXParseException exception) throws SAXException {\n\t\t\t\t\tSystem.out.println(\"fatal error: \" + exception.getMessage());\n\t\t\t\t\tthrow exception;\n\t\t\t\t}});\n\t\t\tvalidator.validate(new StreamSource(documentLocation.toString()));\n\t\t\treturn valid.value;\n\t\t} catch (SAXException e) {\n\t\t\t\n\t\t\treturn false;\n\t\t} catch (Exception e) {\n\t\t\t\n\t\t\tSystem.err.println(e);\n\t\t\treturn false;\n\t\t}\n\t}\n}\n"}
{"id": 415749, "name": "Metallic ratios", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature qw(say state);\nuse Math::AnyNum qw<:overload as_dec>;\n\nsub gen_lucas {\n    my $b = shift;\n    my $i = 0;\n    return sub {\n        state @seq = (state $v1 = 1, state $v2 = 1);\n        ($v2, $v1) = ($v1, $v2 + $b*$v1) and push(@seq, $v1) unless defined $seq[$i+1];\n        return $seq[$i++];\n    }\n}\n\nsub metallic {\n    my $lucas  = shift;\n    my $places = shift || 32;\n    my $n = my $last = 0;\n    my @seq = $lucas->();\n    while (1) {\n        push @seq, $lucas->();\n        my $this = as_dec( $seq[-1]/$seq[-2], $places+1 );\n        last if $this eq $last;\n        $last = $this;\n        $n++;\n    }\n    $last, $n\n}\n\nmy @name = <Platinum Golden Silver Bronze Copper Nickel Aluminum Iron Tin Lead>;\n\nfor my $b (0..$\n    my $lucas = gen_lucas($b);\n    printf \"\\n'Lucas' sequence for $name[$b] ratio, where b = $b:\\nFirst 15 elements: \" . join ', ', map { $lucas->() } 1..15;\n    printf \"Approximated value %s reached after %d iterations\\n\", metallic(gen_lucas($b));\n}\n\nprintf \"\\nGolden ratio to 256 decimal places %s reached after %d iterations\", metallic(gen_lucas(1),256);\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MetallicRatios {\n\n    private static String[] ratioDescription = new String[] {\"Platinum\", \"Golden\", \"Silver\", \"Bronze\", \"Copper\", \"Nickel\", \"Aluminum\", \"Iron\", \"Tin\", \"Lead\"};\n    \n    public static void main(String[] args) {\n        int elements = 15;\n        for ( int b = 0 ; b < 10 ; b++ ) {\n            System.out.printf(\"Lucas sequence for %s ratio, where b = %d:%n\", ratioDescription[b], b);\n            System.out.printf(\"First %d elements: %s%n\", elements, lucasSequence(1, 1, b, elements));\n            int decimalPlaces = 32;\n            BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n            System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n            System.out.printf(\"%n\");\n        }\n        int b = 1;\n        int decimalPlaces = 256;\n        System.out.printf(\"%s ratio, where b = %d:%n\", ratioDescription[b], b);\n        BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n        System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n    }\n    \n    private static BigDecimal[] lucasSequenceRatio(int x0, int x1, int b, int digits) {\n        BigDecimal x0Bi = BigDecimal.valueOf(x0);\n        BigDecimal x1Bi = BigDecimal.valueOf(x1);\n        BigDecimal bBi = BigDecimal.valueOf(b);\n        MathContext mc = new MathContext(digits);\n        BigDecimal fractionPrior = x1Bi.divide(x0Bi, mc);\n        int iterations = 0;\n        while ( true ) {\n            iterations++;\n            BigDecimal x = bBi.multiply(x1Bi).add(x0Bi);\n            BigDecimal fractionCurrent = x.divide(x1Bi, mc);\n            if ( fractionCurrent.compareTo(fractionPrior) == 0 ) {\n                break;\n            }\n            x0Bi = x1Bi;\n            x1Bi = x;\n            fractionPrior = fractionCurrent;\n        }\n        return new BigDecimal[] {fractionPrior, BigDecimal.valueOf(iterations)};\n    }\n\n    private static List<BigInteger> lucasSequence(int x0, int x1, int b, int n) {\n        List<BigInteger> list = new ArrayList<>();\n        BigInteger x0Bi = BigInteger.valueOf(x0);\n        BigInteger x1Bi = BigInteger.valueOf(x1);\n        BigInteger bBi = BigInteger.valueOf(b);\n        if ( n > 0 ) {\n            list.add(x0Bi);\n        }\n        if ( n > 1 ) {\n            list.add(x1Bi);\n        }\n        while ( n > 2 ) {\n            BigInteger x = bBi.multiply(x1Bi).add(x0Bi);\n            list.add(x);\n            n--;\n            x0Bi = x1Bi;\n            x1Bi = x;\n        }\n        return list;\n    }\n    \n}\n"}
{"id": 415750, "name": "Metallic ratios", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature qw(say state);\nuse Math::AnyNum qw<:overload as_dec>;\n\nsub gen_lucas {\n    my $b = shift;\n    my $i = 0;\n    return sub {\n        state @seq = (state $v1 = 1, state $v2 = 1);\n        ($v2, $v1) = ($v1, $v2 + $b*$v1) and push(@seq, $v1) unless defined $seq[$i+1];\n        return $seq[$i++];\n    }\n}\n\nsub metallic {\n    my $lucas  = shift;\n    my $places = shift || 32;\n    my $n = my $last = 0;\n    my @seq = $lucas->();\n    while (1) {\n        push @seq, $lucas->();\n        my $this = as_dec( $seq[-1]/$seq[-2], $places+1 );\n        last if $this eq $last;\n        $last = $this;\n        $n++;\n    }\n    $last, $n\n}\n\nmy @name = <Platinum Golden Silver Bronze Copper Nickel Aluminum Iron Tin Lead>;\n\nfor my $b (0..$\n    my $lucas = gen_lucas($b);\n    printf \"\\n'Lucas' sequence for $name[$b] ratio, where b = $b:\\nFirst 15 elements: \" . join ', ', map { $lucas->() } 1..15;\n    printf \"Approximated value %s reached after %d iterations\\n\", metallic(gen_lucas($b));\n}\n\nprintf \"\\nGolden ratio to 256 decimal places %s reached after %d iterations\", metallic(gen_lucas(1),256);\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MetallicRatios {\n\n    private static String[] ratioDescription = new String[] {\"Platinum\", \"Golden\", \"Silver\", \"Bronze\", \"Copper\", \"Nickel\", \"Aluminum\", \"Iron\", \"Tin\", \"Lead\"};\n    \n    public static void main(String[] args) {\n        int elements = 15;\n        for ( int b = 0 ; b < 10 ; b++ ) {\n            System.out.printf(\"Lucas sequence for %s ratio, where b = %d:%n\", ratioDescription[b], b);\n            System.out.printf(\"First %d elements: %s%n\", elements, lucasSequence(1, 1, b, elements));\n            int decimalPlaces = 32;\n            BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n            System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n            System.out.printf(\"%n\");\n        }\n        int b = 1;\n        int decimalPlaces = 256;\n        System.out.printf(\"%s ratio, where b = %d:%n\", ratioDescription[b], b);\n        BigDecimal[] ratio = lucasSequenceRatio(1, 1, b, decimalPlaces+1);\n        System.out.printf(\"Value to %d decimal places after %s iterations\u00a0: %s%n\", decimalPlaces, ratio[1], ratio[0]);\n    }\n    \n    private static BigDecimal[] lucasSequenceRatio(int x0, int x1, int b, int digits) {\n        BigDecimal x0Bi = BigDecimal.valueOf(x0);\n        BigDecimal x1Bi = BigDecimal.valueOf(x1);\n        BigDecimal bBi = BigDecimal.valueOf(b);\n        MathContext mc = new MathContext(digits);\n        BigDecimal fractionPrior = x1Bi.divide(x0Bi, mc);\n        int iterations = 0;\n        while ( true ) {\n            iterations++;\n            BigDecimal x = bBi.multiply(x1Bi).add(x0Bi);\n            BigDecimal fractionCurrent = x.divide(x1Bi, mc);\n            if ( fractionCurrent.compareTo(fractionPrior) == 0 ) {\n                break;\n            }\n            x0Bi = x1Bi;\n            x1Bi = x;\n            fractionPrior = fractionCurrent;\n        }\n        return new BigDecimal[] {fractionPrior, BigDecimal.valueOf(iterations)};\n    }\n\n    private static List<BigInteger> lucasSequence(int x0, int x1, int b, int n) {\n        List<BigInteger> list = new ArrayList<>();\n        BigInteger x0Bi = BigInteger.valueOf(x0);\n        BigInteger x1Bi = BigInteger.valueOf(x1);\n        BigInteger bBi = BigInteger.valueOf(b);\n        if ( n > 0 ) {\n            list.add(x0Bi);\n        }\n        if ( n > 1 ) {\n            list.add(x1Bi);\n        }\n        while ( n > 2 ) {\n            BigInteger x = bBi.multiply(x1Bi).add(x0Bi);\n            list.add(x);\n            n--;\n            x0Bi = x1Bi;\n            x1Bi = x;\n        }\n        return list;\n    }\n    \n}\n"}
{"id": 415751, "name": "Data Encryption Standard", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Crypt::DES;\n\nmy $key        = pack(\"H*\", \"0E329232EA6D0D73\");\nmy $cipher     = Crypt::DES->new($key);\nmy $ciphertext = $cipher->encrypt(pack(\"H*\", \"8787878787878787\"));\nprint \"Encoded\u00a0: \", unpack(\"H*\", $ciphertext), \"\\n\";\nprint \"Decoded\u00a0: \", unpack(\"H*\", $cipher->decrypt($ciphertext)), \"\\n\";\n", "target": "import javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\n\npublic class DataEncryptionStandard {\n    private static byte[] toHexByteArray(String self) {\n        byte[] bytes = new byte[self.length() / 2];\n        for (int i = 0; i < bytes.length; ++i) {\n            bytes[i] = ((byte) Integer.parseInt(self.substring(i * 2, i * 2 + 2), 16));\n        }\n        return bytes;\n    }\n\n    private static void printHexBytes(byte[] self, String label) {\n        System.out.printf(\"%s: \", label);\n        for (byte b : self) {\n            int bb = (b >= 0) ? ((int) b) : b + 256;\n            String ts = Integer.toString(bb, 16);\n            if (ts.length() < 2) {\n                ts = \"0\" + ts;\n            }\n            System.out.print(ts);\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) throws Exception {\n        String strKey = \"0e329232ea6d0d73\";\n        byte[] keyBytes = toHexByteArray(strKey);\n        SecretKeySpec key = new SecretKeySpec(keyBytes, \"DES\");\n        Cipher encCipher = Cipher.getInstance(\"DES\");\n        encCipher.init(Cipher.ENCRYPT_MODE, key);\n        String strPlain = \"8787878787878787\";\n        byte[] plainBytes = toHexByteArray(strPlain);\n        byte[] encBytes = encCipher.doFinal(plainBytes);\n        printHexBytes(encBytes, \"Encoded\");\n\n        Cipher decCipher = Cipher.getInstance(\"DES\");\n        decCipher.init(Cipher.DECRYPT_MODE, key);\n        byte[] decBytes = decCipher.doFinal(encBytes);\n        printHexBytes(decBytes, \"Decoded\");\n    }\n}\n"}
{"id": 415752, "name": "Ramanujan primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory 'primes';\n\nsub count {\n    my($n,$p) = @_;\n    my $c = -1;\n    do { $c++ } until $$p[$c] > $n;\n    return $c;\n}\n\nmy(@rp,@mem);\nmy $primes = primes( 100_000_000 );\n\nsub r_prime {\n    my $n = shift;\n    for my $x ( reverse 1 .. int 4*$n * log(4*$n) / log 2 ) {\n        my $y = int $x / 2;\n        return 1 + $x if ($mem[$x] //= count($x,$primes)) - ($mem[$y] //= count($y,$primes)) < $n\n    }\n}\n\npush @rp, r_prime($_) for 1..100;\nprint \"First 100:\\n\" . (sprintf \"@{['%5d' x 100]}\", @rp) =~ s/(.{100})/$1\\n/gr;\n\nprint \"\\n\\n 1000th: \" . r_prime( 1000) . \"\\n\";\nprint   \"\\n10000th: \" . r_prime(10000) . \"\\n\"; \n", "target": "import java.util.Arrays;\n\npublic class RamanujanPrimes {\n    public static void main(String[] args) {\n        long start = System.nanoTime();\n        System.out.println(\"First 100 Ramanujan primes:\");\n        PrimeCounter pc = new PrimeCounter(1 + ramanujanMax(100000));\n        for (int i = 1; i <= 100; ++i) {\n            int p = ramanujanPrime(pc, i);\n            System.out.printf(\"%,5d%c\", p, i % 10 == 0 ? '\\n' : ' ');\n        }\n        System.out.println();\n        for (int i = 1000; i <= 100000; i *= 10) {\n            int p = ramanujanPrime(pc, i);\n            System.out.printf(\"The\u00a0%,dth Ramanujan prime is\u00a0%,d.\\n\", i, p);\n        }\n        long end = System.nanoTime();\n        System.out.printf(\"\\nElapsed time:\u00a0%.1f milliseconds\\n\", (end - start) / 1e6);\n    }\n\n    private static int ramanujanMax(int n) {\n        return (int)Math.ceil(4 * n * Math.log(4 * n));\n    }\n\n    private static int ramanujanPrime(PrimeCounter pc, int n) {\n        for (int i = ramanujanMax(n); i >= 0; --i) {\n            if (pc.primeCount(i) - pc.primeCount(i / 2) < n)\n                return i + 1;\n        }\n        return 0;\n    }\n\n    private static class PrimeCounter {\n        private PrimeCounter(int limit) {\n            count = new int[limit];\n            Arrays.fill(count, 1);\n            if (limit > 0)\n                count[0] = 0;\n            if (limit > 1)\n                count[1] = 0;\n            for (int i = 4; i < limit; i += 2)\n                count[i] = 0;\n            for (int p = 3, sq = 9; sq < limit; p += 2) {\n                if (count[p] != 0) {\n                    for (int q = sq; q < limit; q += p << 1)\n                        count[q] = 0;\n                }\n                sq += (p + 1) << 2;\n            }\n            Arrays.parallelPrefix(count, (x, y) -> x + y);\n        }\n\n        private int primeCount(int n) {\n            return n < 1 ? 0 : count[n];\n        }\n\n        private int[] count;\n    }\n}\n"}
{"id": 415753, "name": "Ramanujan primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory 'primes';\n\nsub count {\n    my($n,$p) = @_;\n    my $c = -1;\n    do { $c++ } until $$p[$c] > $n;\n    return $c;\n}\n\nmy(@rp,@mem);\nmy $primes = primes( 100_000_000 );\n\nsub r_prime {\n    my $n = shift;\n    for my $x ( reverse 1 .. int 4*$n * log(4*$n) / log 2 ) {\n        my $y = int $x / 2;\n        return 1 + $x if ($mem[$x] //= count($x,$primes)) - ($mem[$y] //= count($y,$primes)) < $n\n    }\n}\n\npush @rp, r_prime($_) for 1..100;\nprint \"First 100:\\n\" . (sprintf \"@{['%5d' x 100]}\", @rp) =~ s/(.{100})/$1\\n/gr;\n\nprint \"\\n\\n 1000th: \" . r_prime( 1000) . \"\\n\";\nprint   \"\\n10000th: \" . r_prime(10000) . \"\\n\"; \n", "target": "import java.util.Arrays;\n\npublic class RamanujanPrimes {\n    public static void main(String[] args) {\n        long start = System.nanoTime();\n        System.out.println(\"First 100 Ramanujan primes:\");\n        PrimeCounter pc = new PrimeCounter(1 + ramanujanMax(100000));\n        for (int i = 1; i <= 100; ++i) {\n            int p = ramanujanPrime(pc, i);\n            System.out.printf(\"%,5d%c\", p, i % 10 == 0 ? '\\n' : ' ');\n        }\n        System.out.println();\n        for (int i = 1000; i <= 100000; i *= 10) {\n            int p = ramanujanPrime(pc, i);\n            System.out.printf(\"The\u00a0%,dth Ramanujan prime is\u00a0%,d.\\n\", i, p);\n        }\n        long end = System.nanoTime();\n        System.out.printf(\"\\nElapsed time:\u00a0%.1f milliseconds\\n\", (end - start) / 1e6);\n    }\n\n    private static int ramanujanMax(int n) {\n        return (int)Math.ceil(4 * n * Math.log(4 * n));\n    }\n\n    private static int ramanujanPrime(PrimeCounter pc, int n) {\n        for (int i = ramanujanMax(n); i >= 0; --i) {\n            if (pc.primeCount(i) - pc.primeCount(i / 2) < n)\n                return i + 1;\n        }\n        return 0;\n    }\n\n    private static class PrimeCounter {\n        private PrimeCounter(int limit) {\n            count = new int[limit];\n            Arrays.fill(count, 1);\n            if (limit > 0)\n                count[0] = 0;\n            if (limit > 1)\n                count[1] = 0;\n            for (int i = 4; i < limit; i += 2)\n                count[i] = 0;\n            for (int p = 3, sq = 9; sq < limit; p += 2) {\n                if (count[p] != 0) {\n                    for (int q = sq; q < limit; q += p << 1)\n                        count[q] = 0;\n                }\n                sq += (p + 1) << 2;\n            }\n            Arrays.parallelPrefix(count, (x, y) -> x + y);\n        }\n\n        private int primeCount(int n) {\n            return n < 1 ? 0 : count[n];\n        }\n\n        private int[] count;\n    }\n}\n"}
{"id": 415754, "name": "Erd\u00f6s-Selfridge categorization of primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'max';\nuse ntheory qw/factor/;\nuse Primesieve qw(generate_primes);\n\nmy @primes = (0, generate_primes (1, 10**8));\nmy %cat = (2 => 1, 3 => 1);\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nsub ES {\n    my ($n) = @_;\n    my @factors = factor $n + 1;\n    my $category = max map { defined $cat{$_} and $cat{$_} } @factors;\n    unless (defined $cat{ $factors[-1] }) {\n        $category = max $category, (1 + max map { $cat{$_} } factor 1 + $factors[-1]);\n        $cat{ $factors[-1] } = $category;\n    }\n    $category\n}\n\nmy %es;\nmy $upto = 200;\npush @{$es{ES($_)}}, $_ for @primes[1..$upto];\nsay \"First $upto primes, Erd\u00f6s-Selfridge categorized:\";\nsay \"$_: \" . join ' ', sort {$a <=> $b} @{$es{$_}} for sort keys %es;\n\n%es = ();\n$upto = 1_000_000;\nsay \"\\nSummary of first @{[comma $upto]} primes, Erd\u00f6s-Selfridge categorized:\";\npush @{$es{ES($_)}}, $_ for @primes[1..$upto];\nprintf \"Category %2d:  first: %9s  last: %10s  count: %s\\n\",\n    map { comma $_ } $_, (sort {$a <=> $b} @{$es{$_}})[0, -1], scalar @{$es{$_}}\n        for sort {$a <=> $b} keys %es;\n", "target": "import java.util.*;\n\npublic class ErdosSelfridge {\n    private int[] primes;\n    private int[] category;\n\n    public static void main(String[] args) {\n        ErdosSelfridge es = new ErdosSelfridge(1000000);\n\n        System.out.println(\"First 200 primes:\");\n        for (var e : es.getPrimesByCategory(200).entrySet()) {\n            int category = e.getKey();\n            List<Integer> primes = e.getValue();\n            System.out.printf(\"Category %d:\\n\", category);\n            for (int i = 0, n = primes.size(); i != n; ++i)\n                System.out.printf(\"%4d%c\", primes.get(i), (i + 1) % 15 == 0 ? '\\n' : ' ');\n            System.out.printf(\"\\n\\n\");\n        }\n\n        System.out.println(\"First 1,000,000 primes:\");\n        for (var e : es.getPrimesByCategory(1000000).entrySet()) {\n            int category = e.getKey();\n            List<Integer> primes = e.getValue();\n            System.out.printf(\"Category %2d: first = %7d  last = %8d  count = %d\\n\", category,\n                              primes.get(0), primes.get(primes.size() - 1), primes.size());\n        }\n    }\n\n    private ErdosSelfridge(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 200000);\n        List<Integer> primeList = new ArrayList<>();\n        for (int i = 0; i < limit; ++i)\n            primeList.add(primeGen.nextPrime());\n        primes = new int[primeList.size()];\n        for (int i = 0; i < primes.length; ++i)\n            primes[i] = primeList.get(i);\n        category = new int[primes.length];\n    }\n\n    private Map<Integer, List<Integer>> getPrimesByCategory(int limit) {\n        Map<Integer, List<Integer>> result = new TreeMap<>();\n        for (int i = 0; i < limit; ++i) {\n            var p = result.computeIfAbsent(getCategory(i), k -> new ArrayList<Integer>());\n            p.add(primes[i]);\n        }\n        return result;\n    }\n\n    private int getCategory(int index) {\n        if (category[index] != 0)\n            return category[index];\n        int maxCategory = 0;\n        int n = primes[index] + 1;\n        for (int i = 0; n > 1; ++i) {\n            int p = primes[i];\n            if (p * p > n)\n                break;\n            int count = 0;\n            for (; n % p == 0; ++count)\n                n /= p;\n            if (count != 0) {\n                int category = (p <= 3) ? 1 : 1 + getCategory(i);\n                maxCategory = Math.max(maxCategory, category);\n            }\n        }\n        if (n > 1) {\n            int category = (n <= 3) ? 1 : 1 + getCategory(getIndex(n));\n            maxCategory = Math.max(maxCategory, category);\n        }\n        category[index] = maxCategory;\n        return maxCategory;\n    }\n\n    private int getIndex(int prime) {\n       return Arrays.binarySearch(primes, prime);\n    }\n}\n"}
{"id": 415755, "name": "Earliest difference between prime gaps", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse ntheory qw( primes );\n\nmy @gaps;\nmy $primeref = primes( 1e9 );\nfor my $i ( 2 .. $\n  {\n  my $diff = $primeref->[$i] - $primeref->[$i - 1];\n  $gaps[ $diff >> 1 ] //= $primeref->[$i - 1];\n  }\nmy %first;\nfor my $i ( 1 .. $\n  {\n  defined $gaps[$i] && defined $gaps[$i-1] or next;\n  my $diff = abs $gaps[$i] - $gaps[$i-1];\n  for my $m ( map 10 ** $_, 1 .. 10 )\n    {\n    $diff > $m and !$first{$m}++ and\n      print \"above $m gap @{[$i * 2 - 2 ]} abs( $gaps[$i-1] - $gaps[$i] )\\n\";\n    }\n  }\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class PrimeGaps {\n    private Map<Integer, Integer> gapStarts = new HashMap<>();\n    private int lastPrime;\n    private PrimeGenerator primeGenerator = new PrimeGenerator(1000, 500000);\n\n    public static void main(String[] args) {\n        final int limit = 100000000;\n        PrimeGaps pg = new PrimeGaps();\n        for (int pm = 10, gap1 = 2;;) {\n            int start1 = pg.findGapStart(gap1);\n            int gap2 = gap1 + 2;\n            int start2 = pg.findGapStart(gap2);\n            int diff = start2 > start1 ? start2 - start1 : start1 - start2;\n            if (diff > pm) {\n                System.out.printf(\n                    \"Earliest difference >\u00a0%,d between adjacent prime gap starting primes:\\n\"\n                    + \"Gap\u00a0%,d starts at\u00a0%,d, gap\u00a0%,d starts at\u00a0%,d, difference is\u00a0%,d.\\n\\n\",\n                    pm, gap1, start1, gap2, start2, diff);\n                if (pm == limit)\n                    break;\n                pm *= 10;\n            } else {\n                gap1 = gap2;\n            }\n        }\n    }\n\n    private int findGapStart(int gap) {\n        Integer start = gapStarts.get(gap);\n        if (start != null)\n            return start;\n        for (;;) {\n            int prev = lastPrime;\n            lastPrime = primeGenerator.nextPrime();\n            int diff = lastPrime - prev;\n            gapStarts.putIfAbsent(diff, prev);\n            if (diff == gap)\n                return prev;\n        }\n    }\n}\n"}
{"id": 415756, "name": "Word ladder", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy %dict;\n\nopen my $handle, '<', 'unixdict.txt';\nwhile (my $word = <$handle>) {\n    chomp($word);\n    my $len = length $word;\n    if (exists $dict{$len}) {\n        push @{ $dict{ $len } }, $word;\n    } else {\n        my @words = ( $word );\n        $dict{$len} = \\@words;\n    }\n}\nclose $handle;\n\nsub distance {\n    my $w1 = shift;\n    my $w2 = shift;\n\n    my $dist = 0;\n    for my $i (0 .. length($w1) - 1) {\n        my $c1 = substr($w1, $i, 1);\n        my $c2 = substr($w2, $i, 1);\n        if (not ($c1 eq $c2)) {\n            $dist++;\n        }\n    }\n    return $dist;\n}\n\nsub contains {\n    my $aref = shift;\n    my $needle = shift;\n\n    for my $v (@$aref) {\n        if ($v eq $needle) {\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\nsub word_ladder {\n    my $fw = shift;\n    my $tw = shift;\n\n    if (exists $dict{length $fw}) {\n        my @poss = @{ $dict{length $fw} };\n        my @queue = ([$fw]);\n        while (scalar @queue > 0) {\n            my $curr_ref = shift @queue;\n            my $last = $curr_ref->[-1];\n\n            my @next;\n            for my $word (@poss) {\n                if (distance($last, $word) == 1) {\n                    push @next, $word;\n                }\n            }\n\n            if (contains(\\@next, $tw)) {\n                push @$curr_ref, $tw;\n                print join (' -> ', @$curr_ref), \"\\n\";\n                return;\n            }\n\n            for my $word (@next) {\n                for my $i (0 .. scalar @poss - 1) {\n                    if ($word eq $poss[$i]) {\n                        splice @poss, $i, 1;\n                        last;\n                    }\n                }\n            }\n\n            for my $word (@next) {\n                my @temp = @$curr_ref;\n                push @temp, $word;\n\n                push @queue, \\@temp;\n            }\n        }\n    }\n\n    print STDERR \"Cannot change $fw into $tw\\n\";\n}\n\nword_ladder('boy', 'man');\nword_ladder('girl', 'lady');\nword_ladder('john', 'jane');\nword_ladder('child', 'adult');\nword_ladder('cat', 'dog');\nword_ladder('lead', 'gold');\nword_ladder('white', 'black');\nword_ladder('bubble', 'tickle');\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class WordLadder {\n    private static int distance(String s1, String s2) {\n        assert s1.length() == s2.length();\n        return (int) IntStream.range(0, s1.length())\n            .filter(i -> s1.charAt(i) != s2.charAt(i))\n            .count();\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw) {\n        wordLadder(words, fw, tw, 8);\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw, int limit) {\n        if (fw.length() != tw.length()) {\n            throw new IllegalArgumentException(\"From word and to word must have the same length\");\n        }\n\n        Set<String> ws = words.get(fw.length());\n        if (ws.contains(fw)) {\n            List<String> primeList = new ArrayList<>();\n            primeList.add(fw);\n\n            PriorityQueue<List<String>> queue = new PriorityQueue<>((chain1, chain2) -> {\n                int cmp1 = Integer.compare(chain1.size(), chain2.size());\n                if (cmp1 == 0) {\n                    String last1 = chain1.get(chain1.size() - 1);\n                    int d1 = distance(last1, tw);\n\n                    String last2 = chain2.get(chain2.size() - 1);\n                    int d2 = distance(last2, tw);\n\n                    return Integer.compare(d1, d2);\n                }\n                return cmp1;\n            });\n            queue.add(primeList);\n\n            while (queue.size() > 0) {\n                List<String> curr = queue.remove();\n                if (curr.size() > limit) {\n                    continue;\n                }\n\n                String last = curr.get(curr.size() - 1);\n                for (String word : ws) {\n                    if (distance(last, word) == 1) {\n                        if (word.equals(tw)) {\n                            curr.add(word);\n                            System.out.println(String.join(\" -> \", curr));\n                            return;\n                        }\n\n                        if (!curr.contains(word)) {\n                            List<String> cp = new ArrayList<>(curr);\n                            cp.add(word);\n                            queue.add(cp);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.err.printf(\"Cannot turn `%s` into `%s`%n\", fw, tw);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Map<Integer, Set<String>> words = new HashMap<>();\n        for (String line : Files.readAllLines(Path.of(\"unixdict.txt\"))) {\n            Set<String> wl = words.computeIfAbsent(line.length(), HashSet::new);\n            wl.add(line);\n        }\n\n        wordLadder(words, \"boy\", \"man\");\n        wordLadder(words, \"girl\", \"lady\");\n        wordLadder(words, \"john\", \"jane\");\n        wordLadder(words, \"child\", \"adult\");\n        wordLadder(words, \"cat\", \"dog\");\n        wordLadder(words, \"lead\", \"gold\");\n        wordLadder(words, \"white\", \"black\");\n        wordLadder(words, \"bubble\", \"tickle\", 12);\n    }\n}\n"}
{"id": 415757, "name": "Non-transitive dice", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub fourFaceCombs {\n    my %found = ();\n    my @res = ();\n    for (my $i = 1; $i <= 4; $i++) {\n        for (my $j = 1; $j <= 4; $j++) {\n            for (my $k = 1; $k <= 4; $k++) {\n                for (my $l = 1; $l <= 4; $l++) {\n                    my @c = sort ($i, $j, $k, $l);\n                    my $key = 0;\n                    for my $p (@c) {\n                        $key = 10 * $key + $p;\n                    }\n                    if (not exists $found{$key}) {\n                        $found{$key} = 1;\n                        push @res, \\@c;\n                    }\n                }\n            }\n        }\n    }\n    return @res;\n}\n\nsub compare {\n    my $xref = shift;\n    my $yref = shift;\n\n    my @x = @$xref;\n    my $xw = 0;\n\n    my @y = @$yref;\n    my $yw = 0;\n\n    for my $i (@x) {\n        for my $j (@y) {\n            if ($i < $j) {\n                $yw++;\n            }\n            if ($j < $i) {\n                $xw++;\n            }\n        }\n    }\n\n    if ($xw < $yw) {\n        return -1;\n    }\n    if ($yw < $xw) {\n        return 1;\n    }\n    return 0;\n}\n\nsub findIntransitive3 {\n    my $dice_ref = shift;\n    my @dice = @$dice_ref;\n    my $len = scalar @dice;\n\n    my @res = ();\n    for (my $i = 0; $i < $len; $i++) {\n        for (my $j = 0; $j < $len; $j++) {\n            my $first = compare($dice[$i], $dice[$j]);\n            if ($first == 1) {\n                for (my $k = 0; $k < $len; $k++) {\n                    my $second = compare($dice[$j], $dice[$k]);\n                    if ($second == 1) {\n                        my $third = compare($dice[$k], $dice[$i]);\n                        if ($third == 1) {\n                            my $d1r = $dice[$i];\n                            my $d2r = $dice[$j];\n                            my $d3r = $dice[$k];\n                            my @itd = ($d1r, $d2r, $d3r);\n                            push @res, \\@itd;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return @res;\n}\n\nsub findIntransitive4 {\n    my $dice_ref = shift;\n    my @dice = @$dice_ref;\n    my $len = scalar @dice;\n\n    my @res = ();\n    for (my $i = 0; $i < $len; $i++) {\n        for (my $j = 0; $j < $len; $j++) {\n            for (my $k = 0; $k < $len; $k++) {\n                for (my $l = 0; $l < $len; $l++) {\n                    my $first = compare($dice[$i], $dice[$j]);\n                    if ($first == 1) {\n                        my $second = compare($dice[$j], $dice[$k]);\n                        if ($second == 1) {\n                            my $third = compare($dice[$k], $dice[$l]);\n                            if ($third == 1) {\n                                my $fourth = compare($dice[$l], $dice[$i]);\n                                if ($fourth == 1) {\n                                    my $d1r = $dice[$i];\n                                    my $d2r = $dice[$j];\n                                    my $d3r = $dice[$k];\n                                    my $d4r = $dice[$l];\n                                    my @itd = ($d1r, $d2r, $d3r, $d4r);\n                                    push @res, \\@itd;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return @res;\n}\n\nsub main {\n    my @dice = fourFaceCombs();\n    my $len = scalar @dice;\n    print \"Number of eligible 4-faced dice: $len\\n\\n\";\n\n    my @it3 = findIntransitive3(\\@dice);\n    my $count3 = scalar @it3;\n    print \"$count3 ordered lists of 3 non-transitive dice found, namely:\\n\";\n    for my $itref (@it3) {\n        print \"[ \";\n        for my $r (@$itref) {\n            print \"[@$r] \";\n        }\n        print \"]\\n\";\n    }\n    print \"\\n\";\n\n    my @it4 = findIntransitive4(\\@dice);\n    my $count = scalar @it4;\n    print \"$count ordered lists of 4 non-transitive dice found, namely:\\n\";\n    for my $itref (@it4) {\n        print \"[ \";\n        for my $r (@$itref) {\n            print \"[@$r] \";\n        }\n        print \"]\\n\";\n    }\n}\n\nmain();\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static List<List<Integer>> fourFaceCombos() {\n        List<List<Integer>> res = new ArrayList<>();\n        Set<Integer> found = new HashSet<>();\n\n        for (int i = 1; i <= 4; i++) {\n            for (int j = 1; j <= 4; j++) {\n                for (int k = 1; k <= 4; k++) {\n                    for (int l = 1; l <= 4; l++) {\n                        List<Integer> c = IntStream.of(i, j, k, l).sorted().boxed().collect(Collectors.toList());\n\n                        int key = 64 * (c.get(0) - 1) + 16 * (c.get(1) - 1) + 4 * (c.get(2) - 1) + (c.get(3) - 1);\n                        if (found.add(key)) {\n                            res.add(c);\n                        }\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    private static int cmp(List<Integer> x, List<Integer> y) {\n        int xw = 0;\n        int yw = 0;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (x.get(i) > y.get(j)) {\n                    xw++;\n                } else if (x.get(i) < y.get(j)) {\n                    yw++;\n                }\n            }\n        }\n        return Integer.compare(xw, yw);\n    }\n\n    private static List<List<List<Integer>>> findIntransitive3(List<List<Integer>> cs) {\n        int c = cs.size();\n        List<List<List<Integer>>> res = new ArrayList<>();\n\n        for (int i = 0; i < c; i++) {\n            for (int j = 0; j < c; j++) {\n                if (cmp(cs.get(i), cs.get(j)) == -1) {\n                    for (List<Integer> kl : cs) {\n                        if (cmp(cs.get(j), kl) == -1 && cmp(kl, cs.get(i)) == -1) {\n                            res.add(List.of(cs.get(i), cs.get(j), kl));\n                        }\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    private static List<List<List<Integer>>> findIntransitive4(List<List<Integer>> cs) {\n        int c = cs.size();\n        List<List<List<Integer>>> res = new ArrayList<>();\n\n        for (int i = 0; i < c; i++) {\n            for (int j = 0; j < c; j++) {\n                if (cmp(cs.get(i), cs.get(j)) == -1) {\n                    for (int k = 0; k < cs.size(); k++) {\n                        if (cmp(cs.get(j), cs.get(k)) == -1) {\n                            for (List<Integer> ll : cs) {\n                                if (cmp(cs.get(k), ll) == -1 && cmp(ll, cs.get(i)) == -1) {\n                                    res.add(List.of(cs.get(i), cs.get(j), cs.get(k), ll));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> combos = fourFaceCombos();\n        System.out.printf(\"Number of eligible 4-faced dice: %d%n\", combos.size());\n        System.out.println();\n\n        List<List<List<Integer>>> it3 = findIntransitive3(combos);\n        System.out.printf(\"%d ordered lists of 3 non-transitive dice found, namely:%n\", it3.size());\n        for (List<List<Integer>> a : it3) {\n            System.out.println(a);\n        }\n        System.out.println();\n\n        List<List<List<Integer>>> it4 = findIntransitive4(combos);\n        System.out.printf(\"%d ordered lists of 4 non-transitive dice found, namely:%n\", it4.size());\n        for (List<List<Integer>> a : it4) {\n            System.out.println(a);\n        }\n    }\n}\n"}
{"id": 415758, "name": "Doomsday rule", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nsub dow ($) {\n   my ($year, $month, $day) = split /-/;\n   my @D = $year%($year%25?4:16) ? (3,7,7,4,2,6,4,1,5,3,7,5) : (4,1,7,2,4,6,4,1,5,3,7,5);\n   my $c = int($year / 100);\n   my $s = ($year % 100) / 12;\n   my $t = ($year % 100) % 12;\n   my $a = ( 5 * ($c % 4) + 2 ) % 7;\n   my $b = ( $s + $t + int($t / 4) + $a ) % 7;\n\n   qw ( Sunday Monday Tuesday Wednesday Thursday Friday Saturday ) [\n      ($b + $day - $D[$month - 1] + 7) % 7 ]\n}\n\nfor (qw( 1800-01-06 1875-03-29 1915-12-07 1970-12-23 2043-05-14 2077-02-12 2101-04-02 )) {\n   print  $_, \" is a\u00a0: \", dow $_, \"\\n\";\n}\n", "target": "class Doom {\n    public static void main(String[] args) {\n        final Date[] dates = {\n            new Date(1800,1,6),\n            new Date(1875,3,29),\n            new Date(1915,12,7),\n            new Date(1970,12,23),\n            new Date(2043,5,14),\n            new Date(2077,2,12),\n            new Date(2101,4,2)\n        };\n        \n        for (Date d : dates)\n            System.out.println(\n                String.format(\"%s: %s\", d.format(), d.weekday()));\n    }\n}\n\nclass Date {\n    private int year, month, day;\n    \n    private static final int[] leapdoom = {4,1,7,4,2,6,4,1,5,3,7,5};\n    private static final int[] normdoom = {3,7,7,4,2,6,4,1,5,3,7,5};\n    public static final String[] weekdays = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n        \"Thursday\", \"Friday\", \"Saturday\"\n    };\n    \n    public Date(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n    \n    public boolean isLeapYear() {\n        return year%4 == 0 && (year%100 != 0 || year%400 == 0);\n    }\n    \n    public String format() {\n        return String.format(\"%02d/%02d/%04d\", month, day, year);\n    }\n    \n    public String weekday() {\n        final int c = year/100;\n        final int r = year%100;\n        final int s = r/12;\n        final int t = r%12;\n        \n        final int c_anchor = (5 * (c%4) + 2) % 7;\n        final int doom = (s + t + t/4 + c_anchor) % 7;\n        final int anchor = \n            isLeapYear() ? leapdoom[month-1] : normdoom[month-1];\n        \n        return weekdays[(doom + day - anchor + 7) % 7];\n    }\n}\n"}
{"id": 415759, "name": "Doomsday rule", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nsub dow ($) {\n   my ($year, $month, $day) = split /-/;\n   my @D = $year%($year%25?4:16) ? (3,7,7,4,2,6,4,1,5,3,7,5) : (4,1,7,2,4,6,4,1,5,3,7,5);\n   my $c = int($year / 100);\n   my $s = ($year % 100) / 12;\n   my $t = ($year % 100) % 12;\n   my $a = ( 5 * ($c % 4) + 2 ) % 7;\n   my $b = ( $s + $t + int($t / 4) + $a ) % 7;\n\n   qw ( Sunday Monday Tuesday Wednesday Thursday Friday Saturday ) [\n      ($b + $day - $D[$month - 1] + 7) % 7 ]\n}\n\nfor (qw( 1800-01-06 1875-03-29 1915-12-07 1970-12-23 2043-05-14 2077-02-12 2101-04-02 )) {\n   print  $_, \" is a\u00a0: \", dow $_, \"\\n\";\n}\n", "target": "class Doom {\n    public static void main(String[] args) {\n        final Date[] dates = {\n            new Date(1800,1,6),\n            new Date(1875,3,29),\n            new Date(1915,12,7),\n            new Date(1970,12,23),\n            new Date(2043,5,14),\n            new Date(2077,2,12),\n            new Date(2101,4,2)\n        };\n        \n        for (Date d : dates)\n            System.out.println(\n                String.format(\"%s: %s\", d.format(), d.weekday()));\n    }\n}\n\nclass Date {\n    private int year, month, day;\n    \n    private static final int[] leapdoom = {4,1,7,4,2,6,4,1,5,3,7,5};\n    private static final int[] normdoom = {3,7,7,4,2,6,4,1,5,3,7,5};\n    public static final String[] weekdays = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n        \"Thursday\", \"Friday\", \"Saturday\"\n    };\n    \n    public Date(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n    \n    public boolean isLeapYear() {\n        return year%4 == 0 && (year%100 != 0 || year%400 == 0);\n    }\n    \n    public String format() {\n        return String.format(\"%02d/%02d/%04d\", month, day, year);\n    }\n    \n    public String weekday() {\n        final int c = year/100;\n        final int r = year%100;\n        final int s = r/12;\n        final int t = r%12;\n        \n        final int c_anchor = (5 * (c%4) + 2) % 7;\n        final int doom = (s + t + t/4 + c_anchor) % 7;\n        final int anchor = \n            isLeapYear() ? leapdoom[month-1] : normdoom[month-1];\n        \n        return weekdays[(doom + day - anchor + 7) % 7];\n    }\n}\n"}
{"id": 415760, "name": "Gauss-Jordan matrix inversion", "source": "Translate Perl to Java: sub rref {\n  our @m; local *m = shift;\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n\n      ++$lead;}\n}\n\nsub display { join(\"\\n\" => map join(\" \" => map(sprintf(\"%6.2f\", $_), @$_)), @{+shift}).\"\\n\" }\n\nsub gauss_jordan_invert {\n    my(@m) = @_;\n    my $rows = @m;\n    my @i = identity(scalar @m);\n    push @{$m[$_]}, @{$i[$_]} for 0..$rows-1;\n    rref(\\@m);\n    map { splice @$_, 0, $rows } @m;\n    @m;\n}\n\nsub identity {\n    my($n) = @_;\n    map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1\n}\n\nmy @tests = (\n    [\n      [ 2, -1,  0 ],\n      [-1,  2, -1 ],\n      [ 0, -1,  2 ]\n    ],\n    [\n      [ -1, -2, 3, 2 ],\n      [ -4, -1, 6, 2 ],\n      [  7, -8, 9, 1 ],\n      [  1, -2, 1, 3 ]\n    ],\n);\n\nfor my $matrix (@tests) {\n    print \"Original Matrix:\\n\" . display(\\@$matrix) . \"\\n\";\n    my @gj = gauss_jordan_invert( @$matrix );\n    print \"Gauss-Jordan Inverted Matrix:\\n\" . display(\\@gj) . \"\\n\";\n    my @rt = gauss_jordan_invert( @gj );\n    print \"After round-trip:\\n\" . display(\\@rt) . \"\\n\";} . \"\\n\"\n}\n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 415761, "name": "Gauss-Jordan matrix inversion", "source": "Translate Perl to Java: sub rref {\n  our @m; local *m = shift;\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  foreach my $r (0 .. $rows - 1) {\n     $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead])\n         {++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;}\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      foreach my $i (0 .. $rows - 1)\n         {$i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };}\n\n      ++$lead;}\n}\n\nsub display { join(\"\\n\" => map join(\" \" => map(sprintf(\"%6.2f\", $_), @$_)), @{+shift}).\"\\n\" }\n\nsub gauss_jordan_invert {\n    my(@m) = @_;\n    my $rows = @m;\n    my @i = identity(scalar @m);\n    push @{$m[$_]}, @{$i[$_]} for 0..$rows-1;\n    rref(\\@m);\n    map { splice @$_, 0, $rows } @m;\n    @m;\n}\n\nsub identity {\n    my($n) = @_;\n    map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1\n}\n\nmy @tests = (\n    [\n      [ 2, -1,  0 ],\n      [-1,  2, -1 ],\n      [ 0, -1,  2 ]\n    ],\n    [\n      [ -1, -2, 3, 2 ],\n      [ -4, -1, 6, 2 ],\n      [  7, -8, 9, 1 ],\n      [  1, -2, 1, 3 ]\n    ],\n);\n\nfor my $matrix (@tests) {\n    print \"Original Matrix:\\n\" . display(\\@$matrix) . \"\\n\";\n    my @gj = gauss_jordan_invert( @$matrix );\n    print \"Gauss-Jordan Inverted Matrix:\\n\" . display(\\@gj) . \"\\n\";\n    my @rt = gauss_jordan_invert( @gj );\n    print \"After round-trip:\\n\" . display(\\@rt) . \"\\n\";} . \"\\n\"\n}\n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 415762, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub adaptive_Simpson_quadrature {\n    my($f, $left, $right, $eps) = @_;\n    my $lf = eval \"$f($left)\";\n    my $rf = eval \"$f($right)\";\n    my ($mid, $midf, $whole) = Simpson_quadrature_mid($f, $left, $lf, $right, $rf);\n    return recursive_Simpsons_asr($f, $left, $lf, $right, $rf, $eps, $whole, $mid, $midf);\n\n    sub Simpson_quadrature_mid {\n        my($g, $l, $lf, $r, $rf) = @_;\n        my $mid = ($l + $r) / 2;\n        my $midf = eval \"$g($mid)\";\n        ($mid, $midf, abs($r - $l) / 6 * ($lf + 4 * $midf + $rf))\n    }\n\n    sub recursive_Simpsons_asr {\n        my($h, $a, $fa, $b, $fb, $eps, $whole, $m, $fm) = @_;\n        my ($lm, $flm, $left)  = Simpson_quadrature_mid($h, $a, $fa, $m, $fm);\n        my ($rm, $frm, $right) = Simpson_quadrature_mid($h, $m, $fm, $b, $fb);\n        my $delta = $left + $right - $whole;\n        abs($delta) <= 15 * $eps\n            ? $left + $right + $delta / 15\n            : recursive_Simpsons_asr($h, $a, $fa, $m, $fm, $eps/2, $left,  $lm, $flm) +\n              recursive_Simpsons_asr($h, $m, $fm, $b, $fb, $eps/2, $right, $rm, $frm)\n    }\n}\n\nmy ($a, $b) = (0, 1);\nmy $sin = adaptive_Simpson_quadrature('sin', $a, $b, 1e-9);\nprintf \"Simpson's integration of sine from $a to $b =\u00a0%.9f\", $sin\n", "target": "import java.util.function.Function;\n\npublic class NumericalIntegrationAdaptiveSimpsons {\n\n    public static void main(String[] args) {\n        Function<Double,Double> f = x -> sin(x);\n        System.out.printf(\"integrate sin(x), x = 0 .. Pi = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, Math.PI, 1e-8), functionCount);\n        functionCount = 0;\n        System.out.printf(\"integrate sin(x), x = 0 .. 1 = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, 1, 1e-8), functionCount);\n    }\n    \n    private static double quadratureAdaptiveSimpsons(Function<Double,Double> function, double a, double b, double error) {\n        double fa = function.apply(a);\n        double fb = function.apply(b);\n        Triple t =  quadratureAdaptiveSimpsonsOne(function, a, fa, b ,fb);\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, b, fb, error, t.s, t.x, t.fx);\n    }\n    \n    private static double quadratureAdaptiveSimpsonsRecursive(Function<Double,Double> function, double a, double fa, double b, double fb, double error, double whole, double m, double fm) {\n        Triple left  = quadratureAdaptiveSimpsonsOne(function, a, fa, m, fm);\n        Triple right = quadratureAdaptiveSimpsonsOne(function, m, fm, b, fb);\n        double delta = left.s + right.s - whole;\n        if ( Math.abs(delta) <= 15*error ) {\n            return left.s + right.s + delta / 15;\n        }\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, m, fm, error/2, left.s, left.x, left.fx) +\n               quadratureAdaptiveSimpsonsRecursive(function, m, fm, b, fb, error/2, right.s, right.x, right.fx);\n    }\n    \n    private static Triple quadratureAdaptiveSimpsonsOne(Function<Double,Double> function, double a, double fa, double b, double fb) {\n        double m = (a + b) / 2;\n        double fm = function.apply(m);\n        return new Triple(m, fm, Math.abs(b-a) / 6 * (fa + 4*fm + fb));\n    }\n    \n    private static class Triple {\n        double x, fx, s;\n        private Triple(double m, double fm, double s) {\n            this.x = m;\n            this.fx = fm;\n            this.s = s;\n        }\n    }\n    \n    private static int functionCount = 0;\n    \n    private static double sin(double x) {\n        functionCount++;\n        return Math.sin(x);\n    }\n    \n}\n"}
{"id": 415763, "name": "Numerical integration_Adaptive Simpson's method", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub adaptive_Simpson_quadrature {\n    my($f, $left, $right, $eps) = @_;\n    my $lf = eval \"$f($left)\";\n    my $rf = eval \"$f($right)\";\n    my ($mid, $midf, $whole) = Simpson_quadrature_mid($f, $left, $lf, $right, $rf);\n    return recursive_Simpsons_asr($f, $left, $lf, $right, $rf, $eps, $whole, $mid, $midf);\n\n    sub Simpson_quadrature_mid {\n        my($g, $l, $lf, $r, $rf) = @_;\n        my $mid = ($l + $r) / 2;\n        my $midf = eval \"$g($mid)\";\n        ($mid, $midf, abs($r - $l) / 6 * ($lf + 4 * $midf + $rf))\n    }\n\n    sub recursive_Simpsons_asr {\n        my($h, $a, $fa, $b, $fb, $eps, $whole, $m, $fm) = @_;\n        my ($lm, $flm, $left)  = Simpson_quadrature_mid($h, $a, $fa, $m, $fm);\n        my ($rm, $frm, $right) = Simpson_quadrature_mid($h, $m, $fm, $b, $fb);\n        my $delta = $left + $right - $whole;\n        abs($delta) <= 15 * $eps\n            ? $left + $right + $delta / 15\n            : recursive_Simpsons_asr($h, $a, $fa, $m, $fm, $eps/2, $left,  $lm, $flm) +\n              recursive_Simpsons_asr($h, $m, $fm, $b, $fb, $eps/2, $right, $rm, $frm)\n    }\n}\n\nmy ($a, $b) = (0, 1);\nmy $sin = adaptive_Simpson_quadrature('sin', $a, $b, 1e-9);\nprintf \"Simpson's integration of sine from $a to $b =\u00a0%.9f\", $sin\n", "target": "import java.util.function.Function;\n\npublic class NumericalIntegrationAdaptiveSimpsons {\n\n    public static void main(String[] args) {\n        Function<Double,Double> f = x -> sin(x);\n        System.out.printf(\"integrate sin(x), x = 0 .. Pi = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, Math.PI, 1e-8), functionCount);\n        functionCount = 0;\n        System.out.printf(\"integrate sin(x), x = 0 .. 1 = %2.12f.  Function calls = %d%n\", quadratureAdaptiveSimpsons(f, 0, 1, 1e-8), functionCount);\n    }\n    \n    private static double quadratureAdaptiveSimpsons(Function<Double,Double> function, double a, double b, double error) {\n        double fa = function.apply(a);\n        double fb = function.apply(b);\n        Triple t =  quadratureAdaptiveSimpsonsOne(function, a, fa, b ,fb);\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, b, fb, error, t.s, t.x, t.fx);\n    }\n    \n    private static double quadratureAdaptiveSimpsonsRecursive(Function<Double,Double> function, double a, double fa, double b, double fb, double error, double whole, double m, double fm) {\n        Triple left  = quadratureAdaptiveSimpsonsOne(function, a, fa, m, fm);\n        Triple right = quadratureAdaptiveSimpsonsOne(function, m, fm, b, fb);\n        double delta = left.s + right.s - whole;\n        if ( Math.abs(delta) <= 15*error ) {\n            return left.s + right.s + delta / 15;\n        }\n        return quadratureAdaptiveSimpsonsRecursive(function, a, fa, m, fm, error/2, left.s, left.x, left.fx) +\n               quadratureAdaptiveSimpsonsRecursive(function, m, fm, b, fb, error/2, right.s, right.x, right.fx);\n    }\n    \n    private static Triple quadratureAdaptiveSimpsonsOne(Function<Double,Double> function, double a, double fa, double b, double fb) {\n        double m = (a + b) / 2;\n        double fm = function.apply(m);\n        return new Triple(m, fm, Math.abs(b-a) / 6 * (fa + 4*fm + fb));\n    }\n    \n    private static class Triple {\n        double x, fx, s;\n        private Triple(double m, double fm, double s) {\n            this.x = m;\n            this.fx = fm;\n            this.s = s;\n        }\n    }\n    \n    private static int functionCount = 0;\n    \n    private static double sin(double x) {\n        functionCount++;\n        return Math.sin(x);\n    }\n    \n}\n"}
{"id": 415764, "name": "Colorful numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse enum qw(False True);\nuse List::Util <max uniqint product>;\nuse Algorithm::Combinatorics qw(combinations permutations);\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub is_colorful {\n    my($n) = @_;\n    return True if 0 <= $n and $n <= 9;\n    return False if $n =~ /0|1/ or $n < 0;\n    my @digits = split '', $n;\n    return False unless @digits == uniqint @digits;\n    my @p;\n    for my $w (0 .. @digits) {\n        push @p, map { product @digits[$_ .. $_+$w] } 0 .. @digits-$w-1;\n        return False unless @p == uniqint @p\n    }\n    True\n}\n\nsay \"Colorful numbers less than 100:\\n\" . table 10, grep { is_colorful $_ } 0..100;\n\nmy $largest = 98765432;\n1 while not is_colorful --$largest;\nsay \"Largest magnitude colorful number: $largest\\n\";\n\nmy $total= 10;\nmap { is_colorful(join '', @$_) and $total++ } map { permutations $_ } combinations [2..9], $_ for 2..8;\nsay \"Total colorful numbers: $total\";\n", "target": "public class ColorfulNumbers {\n    private int count[] = new int[8];\n    private boolean used[] = new boolean[10];\n    private int largest = 0;\n\n    public static void main(String[] args) {\n        System.out.printf(\"Colorful numbers less than 100:\\n\");\n        for (int n = 0, count = 0; n < 100; ++n) {\n            if (isColorful(n))\n                System.out.printf(\"%2d%c\", n, ++count % 10 == 0 ? '\\n' : ' ');\n        }\n\n        ColorfulNumbers c = new ColorfulNumbers();\n\n        System.out.printf(\"\\n\\nLargest colorful number:\u00a0%,d\\n\", c.largest);\n\n        System.out.printf(\"\\nCount of colorful numbers by number of digits:\\n\");\n        int total = 0;\n        for (int d = 0; d < 8; ++d) {\n            System.out.printf(\"%d  \u00a0%,d\\n\", d + 1, c.count[d]);\n            total += c.count[d];\n        }\n        System.out.printf(\"\\nTotal:\u00a0%,d\\n\", total);\n    }\n\n    private ColorfulNumbers() {\n        countColorful(0, 0, 0);\n    }\n\n    public static boolean isColorful(int n) {\n        \n        if (n < 0 || n > 98765432)\n            return false;\n        int digit_count[] = new int[10];\n        int digits[] = new int[8];\n        int num_digits = 0;\n        for (int m = n; m > 0; m /= 10) {\n            int d = m % 10;\n            if (n > 9 && (d == 0 || d == 1))\n                return false;\n            if (++digit_count[d] > 1)\n                return false;\n            digits[num_digits++] = d;\n        }\n        \n        int products[] = new int[36];\n        for (int i = 0, product_count = 0; i < num_digits; ++i) {\n            for (int j = i, p = 1; j < num_digits; ++j) {\n                p *= digits[j];\n                for (int k = 0; k < product_count; ++k) {\n                    if (products[k] == p)\n                        return false;\n                }\n                products[product_count++] = p;\n            }\n        }\n        return true;\n    }\n\n    private void countColorful(int taken, int n, int digits) {\n        if (taken == 0) {\n            for (int d = 0; d < 10; ++d) {\n                used[d] = true;\n                countColorful(d < 2 ? 9 : 1, d, 1);\n                used[d] = false;\n            }\n        } else {\n            if (isColorful(n)) {\n                ++count[digits - 1];\n                if (n > largest)\n                    largest = n;\n            }\n            if (taken < 9) {\n                for (int d = 2; d < 10; ++d) {\n                    if (!used[d]) {\n                        used[d] = true;\n                        countColorful(taken + 1, n * 10 + d, digits + 1);\n                        used[d] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415765, "name": "Colorful numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse enum qw(False True);\nuse List::Util <max uniqint product>;\nuse Algorithm::Combinatorics qw(combinations permutations);\n\nsub table { my $t = shift() * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub is_colorful {\n    my($n) = @_;\n    return True if 0 <= $n and $n <= 9;\n    return False if $n =~ /0|1/ or $n < 0;\n    my @digits = split '', $n;\n    return False unless @digits == uniqint @digits;\n    my @p;\n    for my $w (0 .. @digits) {\n        push @p, map { product @digits[$_ .. $_+$w] } 0 .. @digits-$w-1;\n        return False unless @p == uniqint @p\n    }\n    True\n}\n\nsay \"Colorful numbers less than 100:\\n\" . table 10, grep { is_colorful $_ } 0..100;\n\nmy $largest = 98765432;\n1 while not is_colorful --$largest;\nsay \"Largest magnitude colorful number: $largest\\n\";\n\nmy $total= 10;\nmap { is_colorful(join '', @$_) and $total++ } map { permutations $_ } combinations [2..9], $_ for 2..8;\nsay \"Total colorful numbers: $total\";\n", "target": "public class ColorfulNumbers {\n    private int count[] = new int[8];\n    private boolean used[] = new boolean[10];\n    private int largest = 0;\n\n    public static void main(String[] args) {\n        System.out.printf(\"Colorful numbers less than 100:\\n\");\n        for (int n = 0, count = 0; n < 100; ++n) {\n            if (isColorful(n))\n                System.out.printf(\"%2d%c\", n, ++count % 10 == 0 ? '\\n' : ' ');\n        }\n\n        ColorfulNumbers c = new ColorfulNumbers();\n\n        System.out.printf(\"\\n\\nLargest colorful number:\u00a0%,d\\n\", c.largest);\n\n        System.out.printf(\"\\nCount of colorful numbers by number of digits:\\n\");\n        int total = 0;\n        for (int d = 0; d < 8; ++d) {\n            System.out.printf(\"%d  \u00a0%,d\\n\", d + 1, c.count[d]);\n            total += c.count[d];\n        }\n        System.out.printf(\"\\nTotal:\u00a0%,d\\n\", total);\n    }\n\n    private ColorfulNumbers() {\n        countColorful(0, 0, 0);\n    }\n\n    public static boolean isColorful(int n) {\n        \n        if (n < 0 || n > 98765432)\n            return false;\n        int digit_count[] = new int[10];\n        int digits[] = new int[8];\n        int num_digits = 0;\n        for (int m = n; m > 0; m /= 10) {\n            int d = m % 10;\n            if (n > 9 && (d == 0 || d == 1))\n                return false;\n            if (++digit_count[d] > 1)\n                return false;\n            digits[num_digits++] = d;\n        }\n        \n        int products[] = new int[36];\n        for (int i = 0, product_count = 0; i < num_digits; ++i) {\n            for (int j = i, p = 1; j < num_digits; ++j) {\n                p *= digits[j];\n                for (int k = 0; k < product_count; ++k) {\n                    if (products[k] == p)\n                        return false;\n                }\n                products[product_count++] = p;\n            }\n        }\n        return true;\n    }\n\n    private void countColorful(int taken, int n, int digits) {\n        if (taken == 0) {\n            for (int d = 0; d < 10; ++d) {\n                used[d] = true;\n                countColorful(d < 2 ? 9 : 1, d, 1);\n                used[d] = false;\n            }\n        } else {\n            if (isColorful(n)) {\n                ++count[digits - 1];\n                if (n > largest)\n                    largest = n;\n            }\n            if (taken < 9) {\n                for (int d = 2; d < 10; ++d) {\n                    if (!used[d]) {\n                        used[d] = true;\n                        countColorful(taken + 1, n * 10 + d, digits + 1);\n                        used[d] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 415766, "name": "Generate random chess position", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nuse List::AllUtils <shuffle any natatime>;\n\nsub pick1 { return @_[rand @_] }\n\nsub gen_FEN {\n    my $n = 1 + int rand 31;\n    my @n = (shuffle(0 .. 63))[1 .. $n];\n\n    my @kings;\n\n  KINGS: {\n    for my $a (@n) {\n        for my $b (@n) {\n            next unless $a != $b && abs(int($a/8) - int($b/8)) > 1 || abs($a%8 - $b%8) > 1;\n            @kings = ($a, $b);\n            last KINGS;\n        }\n        die 'No good place for kings!';\n    }\n    }\n\n    my ($row, @pp);\n    my @pieces = <p P n N b B r R q Q>;\n    my @k      = rand() < .5 ? <K k> : <k K>;\n\n    for my $sq (0 .. 63) {\n        if (any { $_ == $sq } @kings) {\n            push @pp, shift @k;\n        }\n        elsif (any { $_ == $sq } @n) {\n            $row = 7 - int $sq / 8;\n            push @pp,\n                $row == 0 ? pick1(grep { $_ ne 'P' } @pieces)\n              : $row == 7 ? pick1(grep { $_ ne 'P' } @pieces)\n              :             pick1(@pieces);\n        }\n        else {\n            push @pp, '\u00f8';\n        }\n    }\n\n    my @qq;\n    my $iter = natatime 8, @pp;\n    while (my $row = join '', $iter->()) {\n        $row =~ s/((\u00f8)\\2*)/length($1)/eg;\n        push @qq, $row;\n    }\n    return join('/', @qq) . ' w - - 0 1';\n}\n\nsay gen_FEN();\n", "target": "import static java.lang.Math.abs;\nimport java.util.Random;\n\npublic class Fen {\n    static Random rand = new Random();\n\n    public static void main(String[] args) {\n        System.out.println(createFen());\n    }\n\n    static String createFen() {\n        char[][] grid = new char[8][8];\n\n        placeKings(grid);\n        placePieces(grid, \"PPPPPPPP\", true);\n        placePieces(grid, \"pppppppp\", true);\n        placePieces(grid, \"RNBQBNR\", false);\n        placePieces(grid, \"rnbqbnr\", false);\n\n        return toFen(grid);\n    }\n\n    static void placeKings(char[][] grid) {\n        int r1, c1, r2, c2;\n        while (true) {\n            r1 = rand.nextInt(8);\n            c1 = rand.nextInt(8);\n            r2 = rand.nextInt(8);\n            c2 = rand.nextInt(8);\n            if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1)\n                break;\n        }\n        grid[r1][c1] = 'K';\n        grid[r2][c2] = 'k';\n    }\n\n    static void placePieces(char[][] grid, String pieces, boolean isPawn) {\n        int numToPlace = rand.nextInt(pieces.length());\n        for (int n = 0; n < numToPlace; n++) {\n            int r, c;\n            do {\n                r = rand.nextInt(8);\n                c = rand.nextInt(8);\n\n            } while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));\n\n            grid[r][c] = pieces.charAt(n);\n        }\n    }\n\n    static String toFen(char[][] grid) {\n        StringBuilder fen = new StringBuilder();\n        int countEmpty = 0;\n        for (int r = 0; r < 8; r++) {\n            for (int c = 0; c < 8; c++) {\n                char ch = grid[r][c];\n                System.out.printf(\"%2c \", ch == 0 ? '.' : ch);\n                if (ch == 0) {\n                    countEmpty++;\n                } else {\n                    if (countEmpty > 0) {\n                        fen.append(countEmpty);\n                        countEmpty = 0;\n                    }\n                    fen.append(ch);\n                }\n            }\n            if (countEmpty > 0) {\n                fen.append(countEmpty);\n                countEmpty = 0;\n            }\n            fen.append(\"/\");\n            System.out.println();\n        }\n        return fen.append(\" w - - 0 1\").toString();\n    }\n}\n"}
{"id": 415767, "name": "Sierpinski square curve", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\nuse constant pi => 2 * atan2(1, 0);\n\nmy $rule = 'XF-F+F-XF+F+XF-F+F-X';\nmy $S = 'F+F+XF+F+XF';\n$S =~ s/X/$rule/g for 1..5;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = pi/4;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/2; }\n    elsif (/\\-/) { $theta -= pi/2; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-square-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import java.io.*;\n\npublic class SierpinskiSquareCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"sierpinski_square.svg\"))) {\n            SierpinskiSquareCurve s = new SierpinskiSquareCurve(writer);\n            int size = 635, length = 5;\n            s.currentAngle = 0;\n            s.currentX = (size - length)/2;\n            s.currentY = length;\n            s.lineLength = length;\n            s.begin(size);\n            s.execute(rewrite(5));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private SierpinskiSquareCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY += length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = AXIOM;\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'X')\n                    sb.append(PRODUCTION);\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n\n    private static final String AXIOM = \"F+XF+F+XF\";\n    private static final String PRODUCTION = \"XF-F+F-XF+F+XF-F+F-X\";\n    private static final int ANGLE = 90;\n}\n"}
{"id": 415768, "name": "Rhonda numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw<is_prime factor vecsum vecprod todigitstring todigits>;\n\nsub rhonda {\n    my($b, $cnt) = @_;\n    my(@r,$n);\n    while (++$n) {\n        push @r, $n if ($b * vecsum factor($n)) == vecprod todigits($n,$b);\n        return @r if $cnt == @r;\n    }\n}\n\nfor my $b (grep { ! is_prime $_ } 2..36) {\n    my @Rb = map { todigitstring($_,$b) } my @R = rhonda($b, 15);\n    say <<~EOT;\n        First 15 Rhonda numbers to base $b:\n        In base $b: @Rb\n        In base 10: @R\n        EOT\n}\n", "target": "public class RhondaNumbers {\n    public static void main(String[] args) {\n        final int limit = 15;\n        for (int base = 2; base <= 36; ++base) {\n            if (isPrime(base))\n                continue;\n            System.out.printf(\"First %d Rhonda numbers to base %d:\\n\", limit, base);\n            int numbers[] = new int[limit];\n            for (int n = 1, count = 0; count < limit; ++n) {\n                if (isRhonda(base, n))\n                    numbers[count++] = n;\n            }\n            System.out.printf(\"In base 10:\");\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %d\", numbers[i]);\n            System.out.printf(\"\\nIn base %d:\", base);\n            for (int i = 0; i < limit; ++i)\n                System.out.printf(\" %s\", Integer.toString(numbers[i], base));\n            System.out.printf(\"\\n\\n\");\n        }\n    }\n    \n    private static int digitProduct(int base, int n) {\n        int product = 1;\n        for (; n != 0; n /= base)\n            product *= n % base;\n        return product;\n    }\n     \n    private static int primeFactorSum(int n) {\n        int sum = 0;\n        for (; (n & 1) == 0; n >>= 1)\n            sum += 2;\n        for (int p = 3; p * p <= n; p += 2)\n            for (; n % p == 0; n /= p)\n                sum += p;\n        if (n > 1)\n            sum += n;\n        return sum;\n    }\n     \n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n     \n    private static boolean isRhonda(int base, int n) {\n        return digitProduct(base, n) == base * primeFactorSum(n);\n    }\n}\n"}
{"id": 415769, "name": "Pisano period", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(primes factor_exp lcm);\n\nsub pisano_period_pp {\n    my($a, $b, $n, $k) = (0, 1, $_[0]**$_[1]);\n    while (++$k) {\n        ($a, $b) = ($b, ($a+$b) % $n);\n        return $k if $a == 0 and $b == 1;\n    }\n}\n\nsub pisano_period {\n    (lcm map { pisano_period_pp($$_[0],$$_[1]) } factor_exp($_[0])) or 1;\n}\n\nsub display { (sprintf \"@{['%5d' x @_]}\", @_) =~ s/(.{75})/$1\\n/gr }\n\nsay \"Pisano periods for squares of primes p <= 50:\\n\", display( map { pisano_period_pp($_, 2) } @{primes(1,  50)} ),\n  \"\\nPisano periods for primes p <= 180:\\n\",           display( map { pisano_period_pp($_, 1) } @{primes(1, 180)} ),\n\"\\n\\nPisano periods for integers n from 1 to 180:\\n\",  display( map { pisano_period   ($_   ) }          1..180   );\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class PisanoPeriod {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Print pisano(p^2) for every prime p lower than 15%n\");\n        for ( long i = 2 ; i < 15 ; i++ ) { \n            if ( isPrime(i) ) {\n                long n = i*i; \n                System.out.printf(\"pisano(%d) = %d%n\", n, pisano(n));\n            }\n        }\n\n        System.out.printf(\"%nPrint pisano(p) for every prime p lower than 180%n\");\n        for ( long n = 2 ; n < 180 ; n++ ) { \n            if ( isPrime(n) ) { \n                System.out.printf(\"pisano(%d) = %d%n\", n, pisano(n));\n            }\n        }\n\n        System.out.printf(\"%nPrint pisano(n) for every integer from 1 to 180%n\");\n        for ( long n = 1 ; n <= 180 ; n++ ) { \n            System.out.printf(\"%3d  \", pisano(n));\n            if ( n % 10 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n\n        \n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) {\n            return false;\n        }\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    \n    private static Map<Long,Long> PERIOD_MEMO = new HashMap<>();\n    static {\n        PERIOD_MEMO.put(2L, 3L);\n        PERIOD_MEMO.put(3L, 8L);\n        PERIOD_MEMO.put(5L, 20L);        \n    }\n    \n    \n    private static long pisano(long n) {\n        if ( PERIOD_MEMO.containsKey(n) ) {\n            return PERIOD_MEMO.get(n);\n        }\n        if ( n == 1 ) {\n            return 1;\n        }\n        Map<Long,Long> factors = getFactors(n);\n        \n        \n        \n        if ( factors.size() == 1 & factors.get(2L) != null && factors.get(2L) > 0 ) {\n            long result = 3 * n / 2;\n            PERIOD_MEMO.put(n, result);\n            return result;\n        }\n        \n        if ( factors.size() == 1 & factors.get(5L) != null && factors.get(5L) > 0 ) {\n            long result = 4*n;\n            PERIOD_MEMO.put(n, result);\n            return result;\n        }\n        \n        if ( factors.size() == 2 & factors.get(2L) != null && factors.get(2L) == 1 && factors.get(5L) != null && factors.get(5L) > 0 ) {\n            long result = 6*n;\n            PERIOD_MEMO.put(n, result);\n            return result;\n        }\n        \n        List<Long> primes = new ArrayList<>(factors.keySet());\n        long prime = primes.get(0);\n        if ( factors.size() == 1 && factors.get(prime) == 1 ) {\n            List<Long> divisors = new ArrayList<>();\n            if ( n % 10 == 1 || n % 10 == 9 ) {\n                for ( long divisor : getDivisors(prime-1) ) {\n                    if ( divisor % 2 == 0 ) {\n                        divisors.add(divisor);\n                    }\n                }\n            }\n            else {\n                List<Long> pPlus1Divisors = getDivisors(prime+1);\n                for ( long divisor : getDivisors(2*prime+2) ) {\n                    if ( !  pPlus1Divisors.contains(divisor) ) {\n                        divisors.add(divisor);\n                    }\n                }\n            }\n            Collections.sort(divisors);\n            for ( long divisor : divisors ) {\n                if ( fibModIdentity(divisor, prime) ) {\n                    PERIOD_MEMO.put(prime, divisor);\n                    return divisor;\n                }\n            }\n            throw new RuntimeException(\"ERROR 144: Divisor not found.\");\n        }\n        long period = (long) Math.pow(prime, factors.get(prime)-1) * pisano(prime);\n        for ( int i = 1 ; i < primes.size() ; i++ ) {\n            prime = primes.get(i);\n            period = lcm(period, (long) Math.pow(prime, factors.get(prime)-1) * pisano(prime));\n        }\n        PERIOD_MEMO.put(n, period);\n        return period;\n    }\n    \n    \n    private static boolean fibModIdentity(long n, long mod) {\n        long aRes = 0;\n        long bRes = 1;\n        long cRes = 1;\n        long aBase = 0;\n        long bBase = 1;\n        long cBase = 1;\n        while ( n > 0 ) {\n            if ( n % 2 == 1 ) {\n                long temp1 = 0, temp2 = 0, temp3 = 0;\n                if ( aRes > SQRT || aBase > SQRT || bRes > SQRT || bBase > SQRT || cBase > SQRT || cRes > SQRT ) {\n                    temp1 = (multiply(aRes, aBase, mod) + multiply(bRes, bBase, mod)) % mod;\n                    temp2 = (multiply(aBase, bRes, mod) + multiply(bBase, cRes, mod)) % mod;\n                    temp3 = (multiply(bBase, bRes, mod) + multiply(cBase, cRes, mod)) % mod;\n                }\n                else {\n                    temp1 = ((aRes*aBase % mod) + (bRes*bBase % mod)) % mod;\n                    temp2 = ((aBase*bRes % mod) + (bBase*cRes % mod)) % mod;\n                    temp3 = ((bBase*bRes % mod) + (cBase*cRes % mod)) % mod;\n                }\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            n >>= 1L;\n            long temp1 = 0, temp2 = 0, temp3 = 0; \n            if ( aBase > SQRT || bBase > SQRT || cBase > SQRT ) {\n                temp1 = (multiply(aBase, aBase, mod) + multiply(bBase, bBase, mod)) % mod;\n                temp2 = (multiply(aBase, bBase, mod) + multiply(bBase, cBase, mod)) % mod;\n                temp3 = (multiply(bBase, bBase, mod) + multiply(cBase, cBase, mod)) % mod;\n            }\n            else {\n                temp1 = ((aBase*aBase % mod) + (bBase*bBase % mod)) % mod;\n                temp2 = ((aBase*bBase % mod) + (bBase*cBase % mod)) % mod;\n                temp3 = ((bBase*bBase % mod) + (cBase*cBase % mod)) % mod;\n            }\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes % mod == 0 && bRes % mod == 1 && cRes % mod == 1;\n    }\n\n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        \n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        \n        return x % modulus;\n    }\n\n    private static final List<Long> getDivisors(long number) {\n        List<Long> divisors = new ArrayList<>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( long i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                long div = number / i;\n                if ( div != i ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n    public static long lcm(long a, long b) {\n        return a*b/gcd(a,b);\n    }\n\n    public static long gcd(long a, long b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n    private static final Map<Long,Map<Long,Long>> allFactors = new TreeMap<Long,Map<Long,Long>>();\n    static {\n        Map<Long,Long> factors = new TreeMap<Long,Long>();\n        factors.put(2L, 1L);\n        allFactors.put(2L, factors);\n    }\n\n    public static Long MAX_ALL_FACTORS = 100000L;\n\n    public static final Map<Long,Long> getFactors(Long number) {\n        if ( allFactors.containsKey(number) ) {\n            return allFactors.get(number);\n        }\n        Map<Long,Long> factors = new TreeMap<Long,Long>();\n        if ( number % 2 == 0 ) {\n            Map<Long,Long> factorsdDivTwo = getFactors(number/2);\n            factors.putAll(factorsdDivTwo);\n            factors.merge(2L, 1L, (v1, v2) -> v1 + v2);\n            if ( number < MAX_ALL_FACTORS ) {\n                allFactors.put(number, factors);\n            }\n            return factors;\n        }\n        boolean prime = true;\n        long sqrt = (long) Math.sqrt(number);\n        for ( long i = 3 ; i <= sqrt ; i += 2 ) {\n            if ( number % i == 0 ) {\n                prime = false;\n                factors.putAll(getFactors(number/i));\n                factors.merge(i, 1L, (v1, v2) -> v1 + v2);\n                if ( number < MAX_ALL_FACTORS ) {\n                    allFactors.put(number, factors);\n                }\n                return factors;\n            }\n        }\n        if ( prime ) {\n            factors.put(number, 1L);\n            if ( number < MAX_ALL_FACTORS ) { \n                allFactors.put(number, factors);\n            }\n        }\n        return factors;\n    }\n\n}\n"}
{"id": 415770, "name": "Compiler_AST interpreter", "source": "Translate Perl to Java: \n\nuse strict;   \nuse warnings; \nuse integer;\n\nmy %variables;\n\ntree()->run;\n\nsub tree\n  {\n  my $line = <> // die \"incomplete tree\\n\";\n  (local $_, my $arg) = $line =~ /^(\\w+|;)\\s+(.*)/ or die \"bad input $line\";\n  /String/ ? bless [$arg =~ tr/\"\"//dr =~ s/\\\\(.)/$1 eq 'n'\u00a0? \"\\n\"\u00a0: $1/ger], $_ :\n    /Identifier|Integer/ ? bless [ $arg ], $_ :\n    /;/ ? bless [], 'Null' :\n    bless [ tree(), tree() ], $_;\n  }\n\nsub Add::run { $_[0][0]->run + $_[0][1]->run }\nsub And::run { $_[0][0]->run && $_[0][1]->run }\nsub Assign::run { $variables{$_[0][0][0]} = $_[0][1]->run }\nsub Divide::run { $_[0][0]->run / $_[0][1]->run }\nsub Equal::run { $_[0][0]->run == $_[0][1]->run ? 1 : 0 }\nsub Greater::run { $_[0][0]->run > $_[0][1]->run ? 1 : 0 }\nsub GreaterEqual::run { $_[0][0]->run >= $_[0][1]->run ? 1 : 0 }\nsub Identifier::run { $variables{$_[0][0]} // 0 }\nsub If::run { $_[0][0]->run ? $_[0][1][0]->run : $_[0][1][1]->run }\nsub Integer::run { $_[0][0] }\nsub Less::run { $_[0][0]->run < $_[0][1]->run ? 1 : 0 }\nsub LessEqual::run { $_[0][0]->run <= $_[0][1]->run ? 1 : 0 }\nsub Mod::run { $_[0][0]->run % $_[0][1]->run }\nsub Multiply::run { $_[0][0]->run * $_[0][1]->run }\nsub Negate::run { - $_[0][0]->run }\nsub Not::run { $_[0][0]->run ? 0 : 1 }\nsub NotEqual::run { $_[0][0]->run != $_[0][1]->run ? 1 : 0 }\nsub Null::run {}\nsub Or::run { $_[0][0]->run || $_[0][1]->run }\nsub Prtc::run { print chr $_[0][0]->run }\nsub Prti::run { print $_[0][0]->run }\nsub Prts::run { print $_[0][0][0] }\nsub Sequence::run { $_->run for $_[0]->@* }\nsub Subtract::run { $_[0][0]->run - $_[0][1]->run }\nsub While::run { $_[0][1]->run while $_[0][0]->run }\n", "target": "import java.util.Scanner;\nimport java.io.File;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\nclass Interpreter {\n\tstatic Map<String, Integer> globals = new HashMap<>();\n\tstatic Scanner s;\n\tstatic List<Node> list = new ArrayList<>();\n\tstatic Map<String, NodeType> str_to_nodes = new HashMap<>();\n\n\tstatic class Node {\n\t\tpublic NodeType nt;\n\t\tpublic Node left, right;\n\t\tpublic String value;\n\t\t\n\t\tNode() {\n\t\t\tthis.nt = null;\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.value = null;\n\t\t}\n\t\tNode(NodeType node_type, Node left, Node right, String value) {\n\t\t\tthis.nt = node_type;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic static Node make_node(NodeType nodetype, Node left, Node right) {\n\t\t\treturn new Node(nodetype, left, right, \"\");\n\t\t}\n\t\tpublic static Node make_node(NodeType nodetype, Node left) {\n\t\t\treturn new Node(nodetype, left, null, \"\");\n\t\t}\n\t\tpublic static Node make_leaf(NodeType nodetype, String value) {\n\t\t\treturn new Node(nodetype, null, null, value);\n\t\t}\n\t}\n\tstatic enum NodeType {\n\t\tnd_None(\";\"), nd_Ident(\"Identifier\"), nd_String(\"String\"), nd_Integer(\"Integer\"),\n\t\tnd_Sequence(\"Sequence\"), nd_If(\"If\"),\n\t\tnd_Prtc(\"Prtc\"), nd_Prts(\"Prts\"), nd_Prti(\"Prti\"), nd_While(\"While\"),\n\t\tnd_Assign(\"Assign\"), nd_Negate(\"Negate\"), nd_Not(\"Not\"), nd_Mul(\"Multiply\"), nd_Div(\"Divide\"),\n\t\tnd_Mod(\"Mod\"), nd_Add(\"Add\"),\n\t\tnd_Sub(\"Subtract\"), nd_Lss(\"Less\"), nd_Leq(\"LessEqual\"),\n\t\tnd_Gtr(\"Greater\"), nd_Geq(\"GreaterEqual\"), nd_Eql(\"Equal\"), nd_Neq(\"NotEqual\"), nd_And(\"And\"), nd_Or(\"Or\");\n\t\t\n\t\tprivate final String name;\n\t\t\n\t\tNodeType(String name) {\tthis.name = name; }\n\t\t\n\t\t@Override\n\t\tpublic String toString() { return this.name; }\n\t}\n\tstatic String str(String s) {\n\t\tString result = \"\";\n\t\tint i = 0;\n\t\ts = s.replace(\"\\\"\", \"\");\n\t\twhile (i < s.length()) {\n\t\t\tif (s.charAt(i) == '\\\\' && i + 1 < s.length()) {\n\t\t\t\tif (s.charAt(i + 1) == 'n') {\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\ti += 2;\n\t\t\t\t} else if (s.charAt(i) == '\\\\') {\n\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\ti += 2;\n\t\t\t\t} \n\t\t\t} else {\n\t\t\t\tresult += s.charAt(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tstatic boolean itob(int i) {\n\t\treturn i != 0;\n\t}\n\tstatic int btoi(boolean b) {\n\t\treturn b ? 1 : 0;\n\t}\n\tstatic int fetch_var(String name) {\n\t\tint result;\n\t\tif (globals.containsKey(name)) {\n\t\t\tresult = globals.get(name);\n\t\t} else {\n\t\t\tglobals.put(name, 0);\n\t\t\tresult = 0;\n\t\t}\n\t\treturn result;\t\t\n\t}\n\tstatic Integer interpret(Node n) throws Exception {\n\t\tif (n == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tswitch (n.nt) {\n\t\t\tcase nd_Integer:\n\t\t\t\treturn Integer.parseInt(n.value);\n\t\t\tcase nd_Ident:\n\t\t\t\treturn fetch_var(n.value);\n\t\t\tcase nd_String:\n\t\t\t\treturn 1;\n\t\t\tcase nd_Assign:\n\t\t\t\tglobals.put(n.left.value, interpret(n.right));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Add:\n\t\t\t\treturn interpret(n.left) + interpret(n.right);\n\t\t\tcase nd_Sub:\n\t\t\t\treturn interpret(n.left) - interpret(n.right);\n\t\t\tcase nd_Mul:\n\t\t\t\treturn interpret(n.left) * interpret(n.right);\n\t\t\tcase nd_Div:\n\t\t\t\treturn interpret(n.left) / interpret(n.right);\n\t\t\tcase nd_Mod:\n\t\t\t\treturn interpret(n.left) % interpret(n.right);\n\t\t\tcase nd_Lss:\n\t\t\t\treturn btoi(interpret(n.left) < interpret(n.right));\n\t\t\tcase nd_Leq:\n\t\t\t\treturn btoi(interpret(n.left) <= interpret(n.right));\n\t\t\tcase nd_Gtr:\n\t\t\t\treturn btoi(interpret(n.left) > interpret(n.right));\n\t\t\tcase nd_Geq:\n\t\t\t\treturn btoi(interpret(n.left) >= interpret(n.right));\n\t\t\tcase nd_Eql:\n\t\t\t\treturn btoi(interpret(n.left) == interpret(n.right));\n\t\t\tcase nd_Neq:\n\t\t\t\treturn btoi(interpret(n.left) != interpret(n.right));\n\t\t\tcase nd_And:\n\t\t\t\treturn btoi(itob(interpret(n.left)) && itob(interpret(n.right)));\n\t\t\tcase nd_Or:\n\t\t\t\treturn btoi(itob(interpret(n.left)) || itob(interpret(n.right)));\n\t\t\tcase nd_Not:\n\t\t\t\tif (interpret(n.left) == 0) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tcase nd_Negate:\n\t\t\t\treturn -interpret(n.left);\n\t\t\tcase nd_If:\n\t\t\t\tif (interpret(n.left) != 0) {\n\t\t\t\t\tinterpret(n.right.left);\n\t\t\t\t} else {\n\t\t\t\t\tinterpret(n.right.right);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase nd_While:\n\t\t\t\twhile (interpret(n.left) != 0) {\n\t\t\t\t\tinterpret(n.right);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase nd_Prtc:\n\t\t\t\tSystem.out.printf(\"%c\", interpret(n.left));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Prti:\n\t\t\t\tSystem.out.printf(\"%d\", interpret(n.left));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Prts:\n\t\t\t\tSystem.out.print(str(n.left.value));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Sequence:\n\t\t\t\tinterpret(n.left);\n\t\t\t\tinterpret(n.right);\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tthrow new Exception(\"Error: '\" + n.nt + \"' found, expecting operator\");\n\t\t}\n\t}\n\tstatic Node load_ast() throws Exception {\n\t\tString command, value;\n\t\tString line;\n\t\tNode left, right;\n\t\t\n\t\twhile (s.hasNext()) {\n\t\t\tline = s.nextLine();\n\t\t\tvalue = null;\n\t\t\tif (line.length() > 16) {\n\t\t\t\tcommand = line.substring(0, 15).trim();\n\t\t\t\tvalue = line.substring(15).trim();\n\t\t\t} else {\n\t\t\t\tcommand = line.trim();\n\t\t\t}\n\t\t\tif (command.equals(\";\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!str_to_nodes.containsKey(command)) {\n\t\t\t\tthrow new Exception(\"Command not found: '\" + command + \"'\");\n\t\t\t}\n\t\t\tif (value != null) {\n\t\t\t\treturn Node.make_leaf(str_to_nodes.get(command), value);\n\t\t\t}\n\t\t\tleft = load_ast(); right = load_ast();\n\t\t\treturn Node.make_node(str_to_nodes.get(command), left, right);\n\t\t}\n\t\treturn null; \n\t}\n\tpublic static void main(String[] args) {\n\t\tNode n;\n\n\t\tstr_to_nodes.put(\";\", NodeType.nd_None);\n\t\tstr_to_nodes.put(\"Sequence\", NodeType.nd_Sequence);\n\t\tstr_to_nodes.put(\"Identifier\", NodeType.nd_Ident);\n\t\tstr_to_nodes.put(\"String\", NodeType.nd_String);\n\t\tstr_to_nodes.put(\"Integer\", NodeType.nd_Integer);\n\t\tstr_to_nodes.put(\"If\", NodeType.nd_If);\n\t\tstr_to_nodes.put(\"While\", NodeType.nd_While);\n\t\tstr_to_nodes.put(\"Prtc\", NodeType.nd_Prtc);\n\t\tstr_to_nodes.put(\"Prts\", NodeType.nd_Prts);\n\t\tstr_to_nodes.put(\"Prti\", NodeType.nd_Prti);\n\t\tstr_to_nodes.put(\"Assign\", NodeType.nd_Assign);\n\t\tstr_to_nodes.put(\"Negate\", NodeType.nd_Negate);\n\t\tstr_to_nodes.put(\"Not\", NodeType.nd_Not);\n\t\tstr_to_nodes.put(\"Multiply\", NodeType.nd_Mul);\n\t\tstr_to_nodes.put(\"Divide\", NodeType.nd_Div);\n\t\tstr_to_nodes.put(\"Mod\", NodeType.nd_Mod);\n\t\tstr_to_nodes.put(\"Add\", NodeType.nd_Add);\n\t\tstr_to_nodes.put(\"Subtract\", NodeType.nd_Sub);\n\t\tstr_to_nodes.put(\"Less\", NodeType.nd_Lss);\n\t\tstr_to_nodes.put(\"LessEqual\", NodeType.nd_Leq);\n\t\tstr_to_nodes.put(\"Greater\", NodeType.nd_Gtr);\n\t\tstr_to_nodes.put(\"GreaterEqual\", NodeType.nd_Geq);\n\t\tstr_to_nodes.put(\"Equal\", NodeType.nd_Eql);\n\t\tstr_to_nodes.put(\"NotEqual\", NodeType.nd_Neq);\n\t\tstr_to_nodes.put(\"And\", NodeType.nd_And);\n\t\tstr_to_nodes.put(\"Or\", NodeType.nd_Or);\n\t\t\n\t\tif (args.length > 0) {\n\t\t\ttry {\n\t\t\t\ts = new Scanner(new File(args[0]));\n\t\t\t\tn = load_ast();\n\t\t\t\tinterpret(n);\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.out.println(\"Ex: \"+e.getMessage());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 415771, "name": "Compiler_AST interpreter", "source": "Translate Perl to Java: \n\nuse strict;   \nuse warnings; \nuse integer;\n\nmy %variables;\n\ntree()->run;\n\nsub tree\n  {\n  my $line = <> // die \"incomplete tree\\n\";\n  (local $_, my $arg) = $line =~ /^(\\w+|;)\\s+(.*)/ or die \"bad input $line\";\n  /String/ ? bless [$arg =~ tr/\"\"//dr =~ s/\\\\(.)/$1 eq 'n'\u00a0? \"\\n\"\u00a0: $1/ger], $_ :\n    /Identifier|Integer/ ? bless [ $arg ], $_ :\n    /;/ ? bless [], 'Null' :\n    bless [ tree(), tree() ], $_;\n  }\n\nsub Add::run { $_[0][0]->run + $_[0][1]->run }\nsub And::run { $_[0][0]->run && $_[0][1]->run }\nsub Assign::run { $variables{$_[0][0][0]} = $_[0][1]->run }\nsub Divide::run { $_[0][0]->run / $_[0][1]->run }\nsub Equal::run { $_[0][0]->run == $_[0][1]->run ? 1 : 0 }\nsub Greater::run { $_[0][0]->run > $_[0][1]->run ? 1 : 0 }\nsub GreaterEqual::run { $_[0][0]->run >= $_[0][1]->run ? 1 : 0 }\nsub Identifier::run { $variables{$_[0][0]} // 0 }\nsub If::run { $_[0][0]->run ? $_[0][1][0]->run : $_[0][1][1]->run }\nsub Integer::run { $_[0][0] }\nsub Less::run { $_[0][0]->run < $_[0][1]->run ? 1 : 0 }\nsub LessEqual::run { $_[0][0]->run <= $_[0][1]->run ? 1 : 0 }\nsub Mod::run { $_[0][0]->run % $_[0][1]->run }\nsub Multiply::run { $_[0][0]->run * $_[0][1]->run }\nsub Negate::run { - $_[0][0]->run }\nsub Not::run { $_[0][0]->run ? 0 : 1 }\nsub NotEqual::run { $_[0][0]->run != $_[0][1]->run ? 1 : 0 }\nsub Null::run {}\nsub Or::run { $_[0][0]->run || $_[0][1]->run }\nsub Prtc::run { print chr $_[0][0]->run }\nsub Prti::run { print $_[0][0]->run }\nsub Prts::run { print $_[0][0][0] }\nsub Sequence::run { $_->run for $_[0]->@* }\nsub Subtract::run { $_[0][0]->run - $_[0][1]->run }\nsub While::run { $_[0][1]->run while $_[0][0]->run }\n", "target": "import java.util.Scanner;\nimport java.io.File;\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\nclass Interpreter {\n\tstatic Map<String, Integer> globals = new HashMap<>();\n\tstatic Scanner s;\n\tstatic List<Node> list = new ArrayList<>();\n\tstatic Map<String, NodeType> str_to_nodes = new HashMap<>();\n\n\tstatic class Node {\n\t\tpublic NodeType nt;\n\t\tpublic Node left, right;\n\t\tpublic String value;\n\t\t\n\t\tNode() {\n\t\t\tthis.nt = null;\n\t\t\tthis.left = null;\n\t\t\tthis.right = null;\n\t\t\tthis.value = null;\n\t\t}\n\t\tNode(NodeType node_type, Node left, Node right, String value) {\n\t\t\tthis.nt = node_type;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic static Node make_node(NodeType nodetype, Node left, Node right) {\n\t\t\treturn new Node(nodetype, left, right, \"\");\n\t\t}\n\t\tpublic static Node make_node(NodeType nodetype, Node left) {\n\t\t\treturn new Node(nodetype, left, null, \"\");\n\t\t}\n\t\tpublic static Node make_leaf(NodeType nodetype, String value) {\n\t\t\treturn new Node(nodetype, null, null, value);\n\t\t}\n\t}\n\tstatic enum NodeType {\n\t\tnd_None(\";\"), nd_Ident(\"Identifier\"), nd_String(\"String\"), nd_Integer(\"Integer\"),\n\t\tnd_Sequence(\"Sequence\"), nd_If(\"If\"),\n\t\tnd_Prtc(\"Prtc\"), nd_Prts(\"Prts\"), nd_Prti(\"Prti\"), nd_While(\"While\"),\n\t\tnd_Assign(\"Assign\"), nd_Negate(\"Negate\"), nd_Not(\"Not\"), nd_Mul(\"Multiply\"), nd_Div(\"Divide\"),\n\t\tnd_Mod(\"Mod\"), nd_Add(\"Add\"),\n\t\tnd_Sub(\"Subtract\"), nd_Lss(\"Less\"), nd_Leq(\"LessEqual\"),\n\t\tnd_Gtr(\"Greater\"), nd_Geq(\"GreaterEqual\"), nd_Eql(\"Equal\"), nd_Neq(\"NotEqual\"), nd_And(\"And\"), nd_Or(\"Or\");\n\t\t\n\t\tprivate final String name;\n\t\t\n\t\tNodeType(String name) {\tthis.name = name; }\n\t\t\n\t\t@Override\n\t\tpublic String toString() { return this.name; }\n\t}\n\tstatic String str(String s) {\n\t\tString result = \"\";\n\t\tint i = 0;\n\t\ts = s.replace(\"\\\"\", \"\");\n\t\twhile (i < s.length()) {\n\t\t\tif (s.charAt(i) == '\\\\' && i + 1 < s.length()) {\n\t\t\t\tif (s.charAt(i + 1) == 'n') {\n\t\t\t\t\tresult += '\\n';\n\t\t\t\t\ti += 2;\n\t\t\t\t} else if (s.charAt(i) == '\\\\') {\n\t\t\t\t\tresult += '\\\\';\n\t\t\t\t\ti += 2;\n\t\t\t\t} \n\t\t\t} else {\n\t\t\t\tresult += s.charAt(i);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tstatic boolean itob(int i) {\n\t\treturn i != 0;\n\t}\n\tstatic int btoi(boolean b) {\n\t\treturn b ? 1 : 0;\n\t}\n\tstatic int fetch_var(String name) {\n\t\tint result;\n\t\tif (globals.containsKey(name)) {\n\t\t\tresult = globals.get(name);\n\t\t} else {\n\t\t\tglobals.put(name, 0);\n\t\t\tresult = 0;\n\t\t}\n\t\treturn result;\t\t\n\t}\n\tstatic Integer interpret(Node n) throws Exception {\n\t\tif (n == null) {\n\t\t\treturn 0;\n\t\t}\n\t\tswitch (n.nt) {\n\t\t\tcase nd_Integer:\n\t\t\t\treturn Integer.parseInt(n.value);\n\t\t\tcase nd_Ident:\n\t\t\t\treturn fetch_var(n.value);\n\t\t\tcase nd_String:\n\t\t\t\treturn 1;\n\t\t\tcase nd_Assign:\n\t\t\t\tglobals.put(n.left.value, interpret(n.right));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Add:\n\t\t\t\treturn interpret(n.left) + interpret(n.right);\n\t\t\tcase nd_Sub:\n\t\t\t\treturn interpret(n.left) - interpret(n.right);\n\t\t\tcase nd_Mul:\n\t\t\t\treturn interpret(n.left) * interpret(n.right);\n\t\t\tcase nd_Div:\n\t\t\t\treturn interpret(n.left) / interpret(n.right);\n\t\t\tcase nd_Mod:\n\t\t\t\treturn interpret(n.left) % interpret(n.right);\n\t\t\tcase nd_Lss:\n\t\t\t\treturn btoi(interpret(n.left) < interpret(n.right));\n\t\t\tcase nd_Leq:\n\t\t\t\treturn btoi(interpret(n.left) <= interpret(n.right));\n\t\t\tcase nd_Gtr:\n\t\t\t\treturn btoi(interpret(n.left) > interpret(n.right));\n\t\t\tcase nd_Geq:\n\t\t\t\treturn btoi(interpret(n.left) >= interpret(n.right));\n\t\t\tcase nd_Eql:\n\t\t\t\treturn btoi(interpret(n.left) == interpret(n.right));\n\t\t\tcase nd_Neq:\n\t\t\t\treturn btoi(interpret(n.left) != interpret(n.right));\n\t\t\tcase nd_And:\n\t\t\t\treturn btoi(itob(interpret(n.left)) && itob(interpret(n.right)));\n\t\t\tcase nd_Or:\n\t\t\t\treturn btoi(itob(interpret(n.left)) || itob(interpret(n.right)));\n\t\t\tcase nd_Not:\n\t\t\t\tif (interpret(n.left) == 0) {\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\tcase nd_Negate:\n\t\t\t\treturn -interpret(n.left);\n\t\t\tcase nd_If:\n\t\t\t\tif (interpret(n.left) != 0) {\n\t\t\t\t\tinterpret(n.right.left);\n\t\t\t\t} else {\n\t\t\t\t\tinterpret(n.right.right);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase nd_While:\n\t\t\t\twhile (interpret(n.left) != 0) {\n\t\t\t\t\tinterpret(n.right);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\tcase nd_Prtc:\n\t\t\t\tSystem.out.printf(\"%c\", interpret(n.left));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Prti:\n\t\t\t\tSystem.out.printf(\"%d\", interpret(n.left));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Prts:\n\t\t\t\tSystem.out.print(str(n.left.value));\n\t\t\t\treturn 0;\n\t\t\tcase nd_Sequence:\n\t\t\t\tinterpret(n.left);\n\t\t\t\tinterpret(n.right);\n\t\t\t\treturn 0;\n\t\t\tdefault:\n\t\t\t\tthrow new Exception(\"Error: '\" + n.nt + \"' found, expecting operator\");\n\t\t}\n\t}\n\tstatic Node load_ast() throws Exception {\n\t\tString command, value;\n\t\tString line;\n\t\tNode left, right;\n\t\t\n\t\twhile (s.hasNext()) {\n\t\t\tline = s.nextLine();\n\t\t\tvalue = null;\n\t\t\tif (line.length() > 16) {\n\t\t\t\tcommand = line.substring(0, 15).trim();\n\t\t\t\tvalue = line.substring(15).trim();\n\t\t\t} else {\n\t\t\t\tcommand = line.trim();\n\t\t\t}\n\t\t\tif (command.equals(\";\")) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tif (!str_to_nodes.containsKey(command)) {\n\t\t\t\tthrow new Exception(\"Command not found: '\" + command + \"'\");\n\t\t\t}\n\t\t\tif (value != null) {\n\t\t\t\treturn Node.make_leaf(str_to_nodes.get(command), value);\n\t\t\t}\n\t\t\tleft = load_ast(); right = load_ast();\n\t\t\treturn Node.make_node(str_to_nodes.get(command), left, right);\n\t\t}\n\t\treturn null; \n\t}\n\tpublic static void main(String[] args) {\n\t\tNode n;\n\n\t\tstr_to_nodes.put(\";\", NodeType.nd_None);\n\t\tstr_to_nodes.put(\"Sequence\", NodeType.nd_Sequence);\n\t\tstr_to_nodes.put(\"Identifier\", NodeType.nd_Ident);\n\t\tstr_to_nodes.put(\"String\", NodeType.nd_String);\n\t\tstr_to_nodes.put(\"Integer\", NodeType.nd_Integer);\n\t\tstr_to_nodes.put(\"If\", NodeType.nd_If);\n\t\tstr_to_nodes.put(\"While\", NodeType.nd_While);\n\t\tstr_to_nodes.put(\"Prtc\", NodeType.nd_Prtc);\n\t\tstr_to_nodes.put(\"Prts\", NodeType.nd_Prts);\n\t\tstr_to_nodes.put(\"Prti\", NodeType.nd_Prti);\n\t\tstr_to_nodes.put(\"Assign\", NodeType.nd_Assign);\n\t\tstr_to_nodes.put(\"Negate\", NodeType.nd_Negate);\n\t\tstr_to_nodes.put(\"Not\", NodeType.nd_Not);\n\t\tstr_to_nodes.put(\"Multiply\", NodeType.nd_Mul);\n\t\tstr_to_nodes.put(\"Divide\", NodeType.nd_Div);\n\t\tstr_to_nodes.put(\"Mod\", NodeType.nd_Mod);\n\t\tstr_to_nodes.put(\"Add\", NodeType.nd_Add);\n\t\tstr_to_nodes.put(\"Subtract\", NodeType.nd_Sub);\n\t\tstr_to_nodes.put(\"Less\", NodeType.nd_Lss);\n\t\tstr_to_nodes.put(\"LessEqual\", NodeType.nd_Leq);\n\t\tstr_to_nodes.put(\"Greater\", NodeType.nd_Gtr);\n\t\tstr_to_nodes.put(\"GreaterEqual\", NodeType.nd_Geq);\n\t\tstr_to_nodes.put(\"Equal\", NodeType.nd_Eql);\n\t\tstr_to_nodes.put(\"NotEqual\", NodeType.nd_Neq);\n\t\tstr_to_nodes.put(\"And\", NodeType.nd_And);\n\t\tstr_to_nodes.put(\"Or\", NodeType.nd_Or);\n\t\t\n\t\tif (args.length > 0) {\n\t\t\ttry {\n\t\t\t\ts = new Scanner(new File(args[0]));\n\t\t\t\tn = load_ast();\n\t\t\t\tinterpret(n);\n\t\t\t} catch (Exception e) {\n\t\t\t\tSystem.out.println(\"Ex: \"+e.getMessage());\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 415772, "name": "Welch's t-test", "source": "Translate Perl to Java: use utf8;\nuse List::Util qw(sum);\nuse Math::AnyNum qw(gamma pi);\n\nsub p_value :prototype($$) {\n    my ($A, $B) = @_;\n\n    (@$A > 1 && @$B > 1) || return 1;\n\n    my $x\u0304_a = sum(@$A) / @$A;\n    my $x\u0304_b = sum(@$B) / @$B;\n\n    my $a_var = sum(map { ($x\u0304_a - $_)**2 } @$A) / (@$A - 1);\n    my $b_var = sum(map { ($x\u0304_b - $_)**2 } @$B) / (@$B - 1);\n\n    ($a_var && $b_var) || return 1;\n\n    my $Welsh_\ud835\udc95_statistic = ($x\u0304_a - $x\u0304_b) / sqrt($a_var/@$A + $b_var/@$B);\n\n    my $DoF = ($a_var/@$A + $b_var/@$B)**2 / (\n               $a_var**2 / (@$A**3 - @$A**2) +\n               $b_var**2 / (@$B**3 - @$B**2));\n\n    my $sa = $DoF / 2 - 1;\n    my $x  = $DoF / ($Welsh_\ud835\udc95_statistic**2 + $DoF);\n    my $N  = 65355;\n    my $h  = $x / $N;\n\n    my ($sum1, $sum2) = (0, 0);\n\n    foreach my $k (0 .. $N - 1) {\n        my $i = $h * $k;\n        $sum1 += ($i + $h/2)**$sa / sqrt(1 - ($i + $h/2));\n        $sum2 += $i**$sa / sqrt(1-$i);\n    }\n\n    ($h/6 * ($x**$sa / sqrt(1-$x) + 4*$sum1 + 2*$sum2) /\n        (gamma($sa + 1) * sqrt(pi) / gamma($sa + 1.5)))->numify;\n}\n\nmy @tests = (\n    [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4],\n    [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4],\n\n    [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8],\n    [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8],\n\n    [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0],\n    [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2],\n\n    [30.02, 29.99, 30.11, 29.97, 30.01, 29.99],\n    [29.89, 29.93, 29.72, 29.98, 30.02, 29.98],\n\n    [3.0,   4.0,   1.0, 2.1],\n    [490.2, 340.0, 433.9],\n);\n\nwhile (@tests) {\n    my ($left, $right) = splice(@tests, 0, 2);\n    print p_value($left, $right), \"\\n\";\n}\n", "target": "import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n"}
{"id": 415773, "name": "Welch's t-test", "source": "Translate Perl to Java: use utf8;\nuse List::Util qw(sum);\nuse Math::AnyNum qw(gamma pi);\n\nsub p_value :prototype($$) {\n    my ($A, $B) = @_;\n\n    (@$A > 1 && @$B > 1) || return 1;\n\n    my $x\u0304_a = sum(@$A) / @$A;\n    my $x\u0304_b = sum(@$B) / @$B;\n\n    my $a_var = sum(map { ($x\u0304_a - $_)**2 } @$A) / (@$A - 1);\n    my $b_var = sum(map { ($x\u0304_b - $_)**2 } @$B) / (@$B - 1);\n\n    ($a_var && $b_var) || return 1;\n\n    my $Welsh_\ud835\udc95_statistic = ($x\u0304_a - $x\u0304_b) / sqrt($a_var/@$A + $b_var/@$B);\n\n    my $DoF = ($a_var/@$A + $b_var/@$B)**2 / (\n               $a_var**2 / (@$A**3 - @$A**2) +\n               $b_var**2 / (@$B**3 - @$B**2));\n\n    my $sa = $DoF / 2 - 1;\n    my $x  = $DoF / ($Welsh_\ud835\udc95_statistic**2 + $DoF);\n    my $N  = 65355;\n    my $h  = $x / $N;\n\n    my ($sum1, $sum2) = (0, 0);\n\n    foreach my $k (0 .. $N - 1) {\n        my $i = $h * $k;\n        $sum1 += ($i + $h/2)**$sa / sqrt(1 - ($i + $h/2));\n        $sum2 += $i**$sa / sqrt(1-$i);\n    }\n\n    ($h/6 * ($x**$sa / sqrt(1-$x) + 4*$sum1 + 2*$sum2) /\n        (gamma($sa + 1) * sqrt(pi) / gamma($sa + 1.5)))->numify;\n}\n\nmy @tests = (\n    [27.5, 21.0, 19.0, 23.6, 17.0, 17.9, 16.9, 20.1, 21.9, 22.6, 23.1, 19.6, 19.0, 21.7, 21.4],\n    [27.1, 22.0, 20.8, 23.4, 23.4, 23.5, 25.8, 22.0, 24.8, 20.2, 21.9, 22.1, 22.9, 20.5, 24.4],\n\n    [17.2, 20.9, 22.6, 18.1, 21.7, 21.4, 23.5, 24.2, 14.7, 21.8],\n    [21.5, 22.8, 21.0, 23.0, 21.6, 23.6, 22.5, 20.7, 23.4, 21.8, 20.7, 21.7, 21.5, 22.5, 23.6, 21.5, 22.5, 23.5, 21.5, 21.8],\n\n    [19.8, 20.4, 19.6, 17.8, 18.5, 18.9, 18.3, 18.9, 19.5, 22.0],\n    [28.2, 26.6, 20.1, 23.3, 25.2, 22.1, 17.7, 27.6, 20.6, 13.7, 23.2, 17.5, 20.6, 18.0, 23.9, 21.6, 24.3, 20.4, 24.0, 13.2],\n\n    [30.02, 29.99, 30.11, 29.97, 30.01, 29.99],\n    [29.89, 29.93, 29.72, 29.98, 30.02, 29.98],\n\n    [3.0,   4.0,   1.0, 2.1],\n    [490.2, 340.0, 433.9],\n);\n\nwhile (@tests) {\n    my ($left, $right) = splice(@tests, 0, 2);\n    print p_value($left, $right), \"\\n\";\n}\n", "target": "import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n"}
{"id": 415774, "name": "Four is the number of letters in the ...", "source": "Translate Perl to Java: use feature 'state';\nuse Lingua::EN::Numbers qw(num2en num2en_ordinal);\n\nmy @sentence = split / /, 'Four is the number of letters in the first word of this sentence, ';\n\nsub extend_to {\n    my($last) = @_;\n    state $index = 1;\n    until ($\n        push @sentence, split ' ', num2en(alpha($sentence[$index])) . ' in the ' . no_c(num2en_ordinal(1+$index)) . ',';\n        $index++;\n    }\n}\n\nsub alpha { my($s) = @_; $s =~ s/\\W//gi; length $s }\nsub no_c  { my($s) = @_; $s =~ s/\\ and|,//g;   return $s }\nsub count { length(join ' ', @sentence[0..-1+$_[0]]) . \" characters in the sentence, up to and including this word.\\n\" }\n\nprint \"First 201 word lengths in the sequence:\\n\";\nextend_to(201);\nfor (0..200) {\n    printf \"%3d\", alpha($sentence[$_]);\n    print \"\\n\" unless ($_+1) % 32;\n}\nprint \"\\n\" . count(201) . \"\\n\";\n\nfor (1e3, 1e4, 1e5, 1e6, 1e7) {\n    extend_to($_);\n    print\n        ucfirst(num2en_ordinal($_)) .  \" word, '$sentence[$_-1]' has \" . alpha($sentence[$_-1]) .  \" characters. \\n\" .\n        count($_) . \"\\n\";\n}\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class FourIsTheNumberOfLetters {\n\n    public static void main(String[] args) {\n        String [] words = neverEndingSentence(201);\n        System.out.printf(\"Display the first 201 numbers in the sequence:%n%3d: \", 1);\n        for ( int i = 0 ; i < words.length ; i++ ) {\n            System.out.printf(\"%2d \", numberOfLetters(words[i]));\n            if ( (i+1) % 25 == 0 ) {\n                System.out.printf(\"%n%3d: \", i+2);\n            }\n        }\n        System.out.printf(\"%nTotal number of characters in the sentence is %d%n\", characterCount(words));\n        for ( int i = 3 ; i <= 7 ; i++ ) {\n            int index = (int) Math.pow(10, i);\n            words = neverEndingSentence(index);\n            String last = words[words.length-1].replace(\",\", \"\");\n            System.out.printf(\"Number of letters of the %s word is %d. The word is \\\"%s\\\".  The sentence length is\u00a0%,d characters.%n\", toOrdinal(index), numberOfLetters(last), last, characterCount(words));\n        }\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static void displaySentence(String[] words, int lineLength) {\n        int currentLength = 0;\n        for ( String word : words ) {\n            if ( word.length() + currentLength > lineLength ) {\n                String first = word.substring(0, lineLength-currentLength);\n                String second = word.substring(lineLength-currentLength);\n                System.out.println(first);\n                System.out.print(second);\n                currentLength = second.length();\n            }\n            else {\n                System.out.print(word);\n                currentLength += word.length();\n            }\n            if ( currentLength == lineLength ) {\n                System.out.println();\n                currentLength = 0;\n            }\n            System.out.print(\" \");\n            currentLength++;\n            if ( currentLength == lineLength ) {\n                System.out.println();\n                currentLength = 0;\n            }\n        }\n        System.out.println();\n    }\n    \n    private static int numberOfLetters(String word) {\n        return word.replace(\",\",\"\").replace(\"-\",\"\").length();\n    }\n    \n    private static long characterCount(String[] words) {\n        int characterCount = 0;\n        for ( int i = 0 ; i < words.length ; i++ ) {\n            characterCount += words[i].length() + 1;\n        }        \n        \n        characterCount--;\n        return characterCount;\n    }\n    \n    private static String[] startSentence = new String[] {\"Four\", \"is\", \"the\", \"number\", \"of\", \"letters\", \"in\", \"the\", \"first\", \"word\", \"of\", \"this\", \"sentence,\"};\n    \n    private static String[] neverEndingSentence(int wordCount) {\n        String[] words = new String[wordCount];\n        int index;\n        for ( index = 0 ; index < startSentence.length && index < wordCount ; index++ ) {\n            words[index] = startSentence[index];\n        }\n        int sentencePosition = 1;\n        while ( index < wordCount ) {\n            \n            \n            sentencePosition++;\n            String word = words[sentencePosition-1];\n            for ( String wordLoop : numToString(numberOfLetters(word)).split(\" \") ) {\n                words[index] = wordLoop;\n                index++;\n                if ( index == wordCount ) {\n                    break;\n                }\n            }\n            \n            words[index] = \"in\";\n            index++;\n            if ( index == wordCount ) {\n                break;\n            }\n            \n            words[index] = \"the\";\n            index++;\n            if ( index == wordCount ) {\n                break;\n            }\n            \n            for ( String wordLoop : (toOrdinal(sentencePosition) + \",\").split(\" \") ) {\n                words[index] = wordLoop;\n                index++;\n                if ( index == wordCount ) {\n                    break;\n                }\n            }\n        }\n        return words;\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String numToString(long n) {\n        return numToStringHelper(n);\n    }\n    \n    private static final String numToStringHelper(long n) {\n        if ( n < 0 ) {\n            return \"negative \" + numToStringHelper(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \"-\" + numToStringHelper(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToStringHelper(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToStringHelper(n % factor ) : \"\");\n    }\n\n    private static Map<String,String> ordinalMap = new HashMap<>();\n    static {\n        ordinalMap.put(\"one\", \"first\");\n        ordinalMap.put(\"two\", \"second\");\n        ordinalMap.put(\"three\", \"third\");\n        ordinalMap.put(\"five\", \"fifth\");\n        ordinalMap.put(\"eight\", \"eighth\");\n        ordinalMap.put(\"nine\", \"ninth\");\n        ordinalMap.put(\"twelve\", \"twelfth\");\n    }\n    \n    private static String toOrdinal(long n) {\n        String spelling = numToString(n);\n        String[] split = spelling.split(\" \");\n        String last = split[split.length - 1];\n        String replace = \"\";\n        if ( last.contains(\"-\") ) {\n            String[] lastSplit = last.split(\"-\");\n            String lastWithDash = lastSplit[1];\n            String lastReplace = \"\";\n            if ( ordinalMap.containsKey(lastWithDash) ) {\n                lastReplace = ordinalMap.get(lastWithDash);\n            }\n            else if ( lastWithDash.endsWith(\"y\") ) {\n                lastReplace = lastWithDash.substring(0, lastWithDash.length() - 1) + \"ieth\";\n            }\n            else {\n                lastReplace = lastWithDash + \"th\";\n            }\n            replace = lastSplit[0] + \"-\" + lastReplace;\n        }\n        else {\n            if ( ordinalMap.containsKey(last) ) {\n                replace = ordinalMap.get(last);\n            }\n            else if ( last.endsWith(\"y\") ) {\n                replace = last.substring(0, last.length() - 1) + \"ieth\";\n            }\n            else {\n                replace = last + \"th\";\n            }\n        }\n        split[split.length - 1] = replace;\n        return String.join(\" \", split);\n    }\n    \n}\n"}
{"id": 415775, "name": "Fibonacci matrix-exponentiation", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse Math::AnyNum qw(:overload fibmod floor);\nuse Math::MatrixLUP;\n\nsub fibonacci {\n    my $M = Math::MatrixLUP->new([ [1, 1], [1,0] ]);\n    (@{$M->pow(shift)})[0][1]\n}\n\nfor my $n (16, 32) {\n    my $f = fibonacci(2**$n);\n    printf \"F(2^$n) = %s ... %s\\n\",  substr($f,0,20), $f % 10**20;\n}\n\nsub binet_approx {\n    my($n) = @_;\n    use constant PHI =>   sqrt(1.25) + 0.5 ;\n    use constant IHP => -(sqrt(1.25) - 0.5);\n    (log(PHI)*$n - log(PHI-IHP))\n}\n\nsub nth_fib_first_k_digits {\n    my($n,$k) = @_;\n    my $f = binet_approx($n);\n    floor(exp($f - log(10)*(floor($f / log(10) + 1))) * 10**$k)\n}\n\nsub nth_fib_last_k_digits {\n    my($n,$k) = @_;\n    fibmod($n, 10**$k);\n}\n\nprint \"\\n\";\nfor my $n (16, 32, 64) {\n    my $first20 = nth_fib_first_k_digits(2**$n, 20);\n    my $last20  = nth_fib_last_k_digits(2**$n, 20);\n    printf \"F(2^$n) = %s ... %s\\n\", $first20, $last20;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class FibonacciMatrixExponentiation {\n\n    public static void main(String[] args) {\n        BigInteger mod = BigInteger.TEN.pow(20);\n        for ( int exp : Arrays.asList(32, 64) ) {\n            System.out.printf(\"Last 20 digits of fib(2^%d) = %s%n\", exp, fibMod(BigInteger.valueOf(2).pow(exp), mod));\n        }\n        \n        for ( int i = 1 ; i <= 7 ; i++ ) {\n            BigInteger n = BigInteger.TEN.pow(i);\n            System.out.printf(\"fib(%,d) = %s%n\", n, displayFib(fib(n)));\n        }\n    }\n    \n    private static String displayFib(BigInteger fib) {\n        String s = fib.toString();\n        if ( s.length() <= 40 ) {\n            return s;\n        }\n        return s.substring(0, 20) + \" ... \" + s.subSequence(s.length()-20, s.length());\n    }\n\n    \n    private static BigInteger fib(BigInteger k) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase));\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes));\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes));\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase));\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase));\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase));\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes;\n    }\n\n    \n    private static BigInteger fibMod(BigInteger k, BigInteger mod) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase)).mod(mod);\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes)).mod(mod);\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes)).mod(mod);\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase)).mod(mod);\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase)).mod(mod);\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase)).mod(mod);\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes.mod(mod);\n    }\n\n}\n"}
{"id": 415776, "name": "Fibonacci matrix-exponentiation", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse Math::AnyNum qw(:overload fibmod floor);\nuse Math::MatrixLUP;\n\nsub fibonacci {\n    my $M = Math::MatrixLUP->new([ [1, 1], [1,0] ]);\n    (@{$M->pow(shift)})[0][1]\n}\n\nfor my $n (16, 32) {\n    my $f = fibonacci(2**$n);\n    printf \"F(2^$n) = %s ... %s\\n\",  substr($f,0,20), $f % 10**20;\n}\n\nsub binet_approx {\n    my($n) = @_;\n    use constant PHI =>   sqrt(1.25) + 0.5 ;\n    use constant IHP => -(sqrt(1.25) - 0.5);\n    (log(PHI)*$n - log(PHI-IHP))\n}\n\nsub nth_fib_first_k_digits {\n    my($n,$k) = @_;\n    my $f = binet_approx($n);\n    floor(exp($f - log(10)*(floor($f / log(10) + 1))) * 10**$k)\n}\n\nsub nth_fib_last_k_digits {\n    my($n,$k) = @_;\n    fibmod($n, 10**$k);\n}\n\nprint \"\\n\";\nfor my $n (16, 32, 64) {\n    my $first20 = nth_fib_first_k_digits(2**$n, 20);\n    my $last20  = nth_fib_last_k_digits(2**$n, 20);\n    printf \"F(2^$n) = %s ... %s\\n\", $first20, $last20;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class FibonacciMatrixExponentiation {\n\n    public static void main(String[] args) {\n        BigInteger mod = BigInteger.TEN.pow(20);\n        for ( int exp : Arrays.asList(32, 64) ) {\n            System.out.printf(\"Last 20 digits of fib(2^%d) = %s%n\", exp, fibMod(BigInteger.valueOf(2).pow(exp), mod));\n        }\n        \n        for ( int i = 1 ; i <= 7 ; i++ ) {\n            BigInteger n = BigInteger.TEN.pow(i);\n            System.out.printf(\"fib(%,d) = %s%n\", n, displayFib(fib(n)));\n        }\n    }\n    \n    private static String displayFib(BigInteger fib) {\n        String s = fib.toString();\n        if ( s.length() <= 40 ) {\n            return s;\n        }\n        return s.substring(0, 20) + \" ... \" + s.subSequence(s.length()-20, s.length());\n    }\n\n    \n    private static BigInteger fib(BigInteger k) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase));\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes));\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes));\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase));\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase));\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase));\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes;\n    }\n\n    \n    private static BigInteger fibMod(BigInteger k, BigInteger mod) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase)).mod(mod);\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes)).mod(mod);\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes)).mod(mod);\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase)).mod(mod);\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase)).mod(mod);\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase)).mod(mod);\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes.mod(mod);\n    }\n\n}\n"}
{"id": 415777, "name": "Minimal steps down to 1", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nno warnings 'recursion';\nuse List::Util qw( first );\nuse Data::Dump 'dd';\n\nfor ( [ 2000, [2, 3], [1] ], [ 2000, [2, 3], [2] ] )\n  {\n  my ( $n, $div, $sub ) = @$_;\n  print \"\\n\", '-' x 40, \" divisors @$div subtractors @$sub\\n\";\n  my ($solve, $max) = minimal( @$_ );\n  printf \"%4d takes %s step(s): %s\\n\",\n    $_, $solve->[$_] =~ tr/ // - 1, $solve->[$_] for 1 .. 10;\n  print \"\\n\";\n  printf \"%d number(s) below %d that take $\n    $max->[-1] =~ tr/ //, $n, $max->[-1];\n  ($solve, $max) = minimal( 20000, $div, $sub );\n  printf \"%d number(s) below %d that take $\n    $max->[-1] =~ tr/ //, 20000, $max->[-1];\n  }\n\nsub minimal\n  {\n  my ($top, $div, $sub) = @_;\n  my @solve = (0, ' ');\n  my @maximal;\n  for my $n ( 2 .. $top )\n    {\n    my @pick;\n    for my $d ( @$div )\n      {\n      $n % $d and next;\n      my $ans = \"/$d $solve[$n / $d]\";\n      $pick[$ans =~ tr/ //] //= $ans;\n      }\n    for my $s ( @$sub )\n      {\n      $n > $s or next;\n      my $ans = \"-$s $solve[$n - $s]\";\n      $pick[$ans =~ tr/ //] //= $ans;\n      }\n    $solve[$n] = first { defined  } @pick;\n    $maximal[$solve[$n] =~ tr/ // - 1] .= \" $n\";\n    }\n  return \\@solve, \\@maximal;\n  }\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class MinimalStepsDownToOne {\n\n    public static void main(String[] args) {\n        runTasks(getFunctions1());\n        runTasks(getFunctions2());\n        runTasks(getFunctions3());\n    }\n    \n    private static void runTasks(List<Function> functions) {\n        Map<Integer,List<String>> minPath = getInitialMap(functions, 5);\n\n        \n        int max = 10;\n        populateMap(minPath, functions, max);\n        System.out.printf(\"%nWith functions:  %s%n\", functions);\n        System.out.printf(\"  Minimum steps to 1:%n\");\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int steps = minPath.get(n).size();\n            System.out.printf(\"    %2d: %d step%1s: %s%n\", n, steps, steps == 1 ? \"\" : \"s\", minPath.get(n));\n        }\n        \n        \n        displayMaxMin(minPath, functions, 2000);\n\n        \n        displayMaxMin(minPath, functions, 20000);\n\n        \n        displayMaxMin(minPath, functions, 100000);\n    }\n    \n    private static void displayMaxMin(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        populateMap(minPath, functions, max);\n        List<Integer> maxIntegers = getMaxMin(minPath, max);\n        int maxSteps = maxIntegers.remove(0);\n        int numCount = maxIntegers.size();\n        System.out.printf(\"  There %s %d number%s in the range 1-%d that have maximum 'minimal steps' of %d:%n    %s%n\", numCount == 1 ? \"is\" : \"are\", numCount, numCount == 1 ? \"\" : \"s\", max, maxSteps, maxIntegers);\n        \n    }\n    \n    private static List<Integer> getMaxMin(Map<Integer,List<String>> minPath, int max) {\n        int maxSteps = Integer.MIN_VALUE;\n        List<Integer> maxIntegers = new ArrayList<Integer>();\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int len = minPath.get(n).size();\n            if ( len > maxSteps ) {\n                maxSteps = len;\n                maxIntegers.clear();\n                maxIntegers.add(n);\n            }\n            else if ( len == maxSteps ) {\n                maxIntegers.add(n);\n            }\n        }\n        maxIntegers.add(0, maxSteps);\n        return maxIntegers;\n    }\n\n    private static void populateMap(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        for ( int n = 2 ; n <= max ; n++ ) {\n            if ( minPath.containsKey(n) ) {\n                continue;\n            }\n            Function minFunction = null;\n            int minSteps = Integer.MAX_VALUE;\n            for ( Function f : functions ) {\n                if ( f.actionOk(n) ) {\n                    int result = f.action(n);\n                    int steps = 1 + minPath.get(result).size();\n                    if ( steps < minSteps ) {\n                        minFunction = f;\n                        minSteps = steps;\n                    }\n                }\n            }\n            int result = minFunction.action(n);\n            List<String> path = new ArrayList<String>();\n            path.add(minFunction.toString(n));\n            path.addAll(minPath.get(result));\n            minPath.put(n, path);\n        }\n        \n    }\n\n    private static Map<Integer,List<String>> getInitialMap(List<Function> functions, int max) {\n        Map<Integer,List<String>> minPath = new HashMap<>();\n        for ( int i = 2 ; i <= max ; i++ ) {\n            for ( Function f : functions ) {\n                if ( f.actionOk(i) ) {\n                    int result = f.action(i);\n                    if ( result == 1 ) {\n                        List<String> path = new ArrayList<String>();\n                        path.add(f.toString(i));\n                        minPath.put(i, path);\n                    }\n                }\n            }\n        }\n        return minPath;\n    }\n\n    private static List<Function> getFunctions3() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide2Function());\n        functions.add(new Divide3Function());\n        functions.add(new Subtract2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions2() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract2Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions1() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n    \n    public abstract static class Function {\n        abstract public int action(int n);\n        abstract public boolean actionOk(int n);\n        abstract public String toString(int n);\n    }\n    \n    public static class Divide2Function extends Function {\n        @Override public int action(int n) {\n            return n/2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 2 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/2 -> \" + n/2;\n        }\n        \n        @Override public String toString() {\n            return \"Divisor 2\";\n        }\n        \n    }\n\n    public static class Divide3Function extends Function {\n        @Override public int action(int n) {\n            return n/3;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 3 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/3 -> \" + n/3;\n        }\n\n        @Override public String toString() {\n            return \"Divisor 3\";\n        }\n\n    }\n\n    public static class Subtract1Function extends Function {\n        @Override public int action(int n) {\n            return n-1;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return true;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-1 -> \" + (n-1);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 1\";\n        }\n\n    }\n\n    public static class Subtract2Function extends Function {\n        @Override public int action(int n) {\n            return n-2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n > 2;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-2 -> \" + (n-2);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 2\";\n        }\n\n    }\n\n}\n"}
{"id": 415778, "name": "Ramanujan's constant", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::AnyNum;\n\nsub ramanujan_const {\n    my ($x, $decimals) = @_;\n\n    $x = Math::AnyNum->new($x);\n    my $prec = (Math::AnyNum->pi * $x->sqrt)/log(10) + $decimals + 1;\n    local $Math::AnyNum::PREC = 4*$prec->round->numify;\n\n    exp(Math::AnyNum->pi * $x->sqrt)->round(-$decimals)->stringify;\n}\n\nmy $decimals = 100;\nprintf(\"Ramanujan's constant to $decimals decimals:\\n%s\\n\\n\",\n    ramanujan_const(163, $decimals));\n\nprint \"Heegner numbers yielding 'almost' integers:\\n\";\nmy @tests = (19, 96, 43, 960, 67, 5280, 163, 640320);\n\nwhile (@tests) {\n    my ($h, $x) = splice(@tests, 0, 2);\n    my $c = ramanujan_const($h, 32);\n    my $n = Math::AnyNum::ipow($x, 3) + 744;\n    printf(\"%3s: %51s \u2248 %18s (diff: %s)\\n\", $h, $c, $n, ($n - $c)->round(-32));\n}\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}\n"}
{"id": 415779, "name": "Ramanujan's constant", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::AnyNum;\n\nsub ramanujan_const {\n    my ($x, $decimals) = @_;\n\n    $x = Math::AnyNum->new($x);\n    my $prec = (Math::AnyNum->pi * $x->sqrt)/log(10) + $decimals + 1;\n    local $Math::AnyNum::PREC = 4*$prec->round->numify;\n\n    exp(Math::AnyNum->pi * $x->sqrt)->round(-$decimals)->stringify;\n}\n\nmy $decimals = 100;\nprintf(\"Ramanujan's constant to $decimals decimals:\\n%s\\n\\n\",\n    ramanujan_const(163, $decimals));\n\nprint \"Heegner numbers yielding 'almost' integers:\\n\";\nmy @tests = (19, 96, 43, 960, 67, 5280, 163, 640320);\n\nwhile (@tests) {\n    my ($h, $x) = splice(@tests, 0, 2);\n    my $c = ramanujan_const($h, 32);\n    my $n = Math::AnyNum::ipow($x, 3) + 744;\n    printf(\"%3s: %51s \u2248 %18s (diff: %s)\\n\", $h, $c, $n, ($n - $c)->round(-32));\n}\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}\n"}
{"id": 415780, "name": "Most frequent k chars distance", "source": "Translate Perl to Java: \nuse strict ;\nuse warnings ;\n\nsub mostFreqHashing {\n   my $inputstring = shift ;\n   my $howmany = shift ;\n   my $outputstring ;\n   my %letterfrequencies = findFrequencies ( $inputstring ) ;\n   my @orderedChars = sort { $letterfrequencies{$b} <=> $letterfrequencies{$a} ||\n      index( $inputstring , $a ) <=> index ( $inputstring , $b ) } keys %letterfrequencies ;\n   for my $i ( 0..$howmany - 1 ) {\n      $outputstring .= ( $orderedChars[ $i ] . $letterfrequencies{$orderedChars[ $i ]} ) ;\n   }\n   return $outputstring ;\n}\n\nsub findFrequencies {\n   my $input = shift ;\n   my %letterfrequencies ;\n   for my $i ( 0..length( $input ) - 1 ) {\n      $letterfrequencies{substr( $input , $i , 1 ) }++ ;\n   }\n   return %letterfrequencies ;\n}\n\nsub mostFreqKSimilarity {\n   my $first = shift ;\n   my $second = shift ;\n   my $similarity = 0 ;\n   my %frequencies_first = findFrequencies( $first ) ;\n   my %frequencies_second = findFrequencies( $second ) ;\n   foreach my $letter ( keys %frequencies_first ) {\n      if ( exists ( $frequencies_second{$letter} ) ) {\n\t $similarity += ( $frequencies_second{$letter} + $frequencies_first{$letter} ) ;\n      }\n   }\n   return $similarity ;\n}\n\nsub mostFreqKSDF {\n   (my $input1 , my $input2 , my $k , my $maxdistance ) = @_ ;\n   return $maxdistance - mostFreqKSimilarity( mostFreqHashing( $input1 , $k) ,\n\t mostFreqHashing( $input2 , $k) ) ;\n}\n\nmy $firststring = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\" ;\nmy $secondstring = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\" ;\nprint \"MostFreqKHashing ( \" . '$firststring , 2)' . \" is \" . mostFreqHashing( $firststring , 2 ) . \"\\n\" ;\nprint \"MostFreqKHashing ( \" . '$secondstring , 2)' . \" is \" . mostFreqHashing( $secondstring , 2 ) . \"\\n\" ;\n", "target": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class SDF {\n\n    \n    public static HashMap<Character, Integer> countElementOcurrences(char[] array) {\n\n        HashMap<Character, Integer> countMap = new HashMap<Character, Integer>();\n\n        for (char element : array) {\n            Integer count = countMap.get(element);\n            count = (count == null) ? 1 : count + 1;\n            countMap.put(element, count);\n        }\n\n        return countMap;\n    }\n    \n    \n    private static <K, V extends Comparable<? super V>>\n            HashMap<K, V> descendingSortByValues(HashMap<K, V> map) { \n\tList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>(map.entrySet());\n\t\n\tCollections.sort(list, new Comparator<Map.Entry<K, V>>() {\n\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n\t\t    return o2.getValue().compareTo(o1.getValue());\n\t\t}\n\t    });\n\n\t\n\t\n\tHashMap<K, V> sortedHashMap = new LinkedHashMap<K, V>();\n\tfor (Map.Entry<K, V> entry : list) {\n\t    sortedHashMap.put(entry.getKey(), entry.getValue());\n\t} \n\treturn sortedHashMap;\n    }\n    \n    public static String mostOcurrencesElement(char[] array, int k) {\n        HashMap<Character, Integer> countMap = countElementOcurrences(array);\n        System.out.println(countMap);\n        Map<Character, Integer> map = descendingSortByValues(countMap); \n        System.out.println(map);\n        int i = 0;\n        String output = \"\";\n        for (Map.Entry<Character, Integer> pairs : map.entrySet()) {\n\t    if (i++ >= k)\n\t\tbreak;\n            output += \"\" + pairs.getKey() + pairs.getValue();\n        }\n        return output;\n    }\n    \n    public static int getDiff(String str1, String str2, int limit) {\n        int similarity = 0;\n\tint k = 0;\n\tfor (int i = 0; i < str1.length() ; i = k) {\n\t    k ++;\n\t    if (Character.isLetter(str1.charAt(i))) {\n\t\tint pos = str2.indexOf(str1.charAt(i));\n\t\t\t\t\n\t\tif (pos >= 0) {\t\n\t\t    String digitStr1 = \"\";\n\t\t    while ( k < str1.length() && !Character.isLetter(str1.charAt(k))) {\n\t\t\tdigitStr1 += str1.charAt(k);\n\t\t\tk++;\n\t\t    }\n\t\t\t\t\t\n\t\t    int k2 = pos+1;\n\t\t    String digitStr2 = \"\";\n\t\t    while (k2 < str2.length() && !Character.isLetter(str2.charAt(k2)) ) {\n\t\t\tdigitStr2 += str2.charAt(k2);\n\t\t\tk2++;\n\t\t    }\n\t\t\t\t\t\n\t\t    similarity += Integer.parseInt(digitStr2)\n\t\t\t+ Integer.parseInt(digitStr1);\n\t\t\t\t\t\n\t\t} \n\t    }\n\t}\n\treturn Math.abs(limit - similarity);\n    }\n    \n    public static int SDFfunc(String str1, String str2, int limit) {\n        return getDiff(mostOcurrencesElement(str1.toCharArray(), 2), mostOcurrencesElement(str2.toCharArray(), 2), limit);\n    }\n\n    public static void main(String[] args) {\n        String input1 = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\";\n        String input2 = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\";\n        System.out.println(SDF.SDFfunc(input1,input2,100));\n\n    }\n\n}\n"}
{"id": 415781, "name": "One-time pad", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nuse Crypt::OTP;\nuse Bytes::Random::Secure qw( random_bytes );\n\nprint \"Message    \u00a0: \", my $message = \"show me the monKey\", \"\\n\";\n\nmy $otp = random_bytes(length $message);\nprint \"Ord(OTP)   \u00a0: \", ( map { ord($_).' ' } (split //, $otp)   ) , \"\\n\";\n\nmy $cipher = OTP( $otp, $message, 1 );\nprint \"Ord(Cipher)\u00a0: \", ( map { ord($_).' ' } (split //, $cipher) ) , \"\\n\";\n\nprint \"Decoded    \u00a0: \",  OTP( $otp, $cipher, 1 ), \"\\n\";\n", "target": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class OneTimePad {\n\n    public static void main(String[] args) {\n        String controlName = \"AtomicBlonde\";\n        generatePad(controlName, 5, 60, 65, 90);\n        String text = \"IT WAS THE BEST OF TIMES IT WAS THE WORST OF TIMES\";\n        String encrypted = parse(true, controlName, text.replaceAll(\" \", \"\"));\n        String decrypted = parse(false, controlName, encrypted);\n        System.out.println(\"Input  text    = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n\n        controlName = \"AtomicBlondeCaseSensitive\";\n        generatePad(controlName, 5, 60, 32, 126);\n        text = \"It was the best of times, it was the worst of times.\";\n        encrypted = parse(true, controlName, text);\n        decrypted = parse(false, controlName, encrypted);\n        System.out.println();\n        System.out.println(\"Input text     = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n    }\n    \n    private static String parse(boolean encryptText, String controlName, String text) {\n        StringBuilder sb = new StringBuilder();\n        int minCh = 0;\n        int maxCh = 0;\n        Pattern minChPattern = Pattern.compile(\"^#  MIN_CH = ([\\\\d]+)$\");\n        Pattern maxChPattern = Pattern.compile(\"^#  MAX_CH = ([\\\\d]+)$\");\n        boolean validated = false;\n        try (BufferedReader in = new BufferedReader(new FileReader(getFileName(controlName))); ) {\n            String inLine = null;\n            while ( (inLine = in.readLine()) != null ) {\n                Matcher minMatcher = minChPattern.matcher(inLine);\n                if ( minMatcher.matches() ) {\n                    minCh = Integer.parseInt(minMatcher.group(1));\n                    continue;\n                }\n                Matcher maxMatcher = maxChPattern.matcher(inLine);\n                if ( maxMatcher.matches() ) {\n                    maxCh = Integer.parseInt(maxMatcher.group(1));\n                    continue;\n                }\n                if ( ! validated && minCh > 0 && maxCh > 0 ) {\n                    validateText(text, minCh, maxCh);\n                    validated = true;\n                }\n                \n                if ( inLine.startsWith(\"#\") || inLine.startsWith(\"-\") ) {\n                    continue;\n                }\n                \n                String key = inLine;\n                if ( encryptText ) {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        sb.append((char) (((text.charAt(i) - minCh + key.charAt(i) - minCh) % (maxCh - minCh + 1)) + minCh));\n                    }\n                }\n                else {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        int decrypt = text.charAt(i) - key.charAt(i);\n                        if ( decrypt < 0 ) {\n                            decrypt += maxCh - minCh + 1;\n                        }\n                        decrypt += minCh;\n                        sb.append((char) decrypt);\n                    }\n                }\n                break;\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString();\n    }\n\n    private static void validateText(String text, int minCh, int maxCh) {\n        \n        for ( char ch : text.toCharArray() ) {\n            if ( ch != ' ' && (ch < minCh || ch > maxCh) ) {\n                throw new IllegalArgumentException(\"ERROR 103:  Invalid text.\");\n            }\n        }\n        \n    }\n    \n    private static String getFileName(String controlName) {\n        return controlName + \".1tp\";\n    }\n    \n    private static void generatePad(String controlName, int keys, int keyLength, int minCh, int maxCh) {\n        Random random = new Random();\n        try ( BufferedWriter writer = new BufferedWriter(new FileWriter(getFileName(controlName), false)); ) {\n            writer.write(\"#  Lines starting with '#' are ignored.\");\n            writer.newLine();\n            writer.write(\"#  Lines starting with '-' are previously used.\");\n            writer.newLine();\n            writer.write(\"#  MIN_CH = \" + minCh);\n            writer.newLine();\n            writer.write(\"#  MAX_CH = \" + maxCh);\n            writer.newLine();\n            for ( int line = 0 ; line < keys ; line++ ) {\n                StringBuilder sb = new StringBuilder();\n                for ( int ch = 0 ; ch < keyLength ; ch++ ) {\n                    sb.append((char) (random.nextInt(maxCh - minCh + 1) + minCh));\n                }\n                writer.write(sb.toString());\n                writer.newLine();\n            }\n            writer.write(\"#  EOF\");\n            writer.newLine();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n"}
{"id": 415782, "name": "One-time pad", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nuse Crypt::OTP;\nuse Bytes::Random::Secure qw( random_bytes );\n\nprint \"Message    \u00a0: \", my $message = \"show me the monKey\", \"\\n\";\n\nmy $otp = random_bytes(length $message);\nprint \"Ord(OTP)   \u00a0: \", ( map { ord($_).' ' } (split //, $otp)   ) , \"\\n\";\n\nmy $cipher = OTP( $otp, $message, 1 );\nprint \"Ord(Cipher)\u00a0: \", ( map { ord($_).' ' } (split //, $cipher) ) , \"\\n\";\n\nprint \"Decoded    \u00a0: \",  OTP( $otp, $cipher, 1 ), \"\\n\";\n", "target": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class OneTimePad {\n\n    public static void main(String[] args) {\n        String controlName = \"AtomicBlonde\";\n        generatePad(controlName, 5, 60, 65, 90);\n        String text = \"IT WAS THE BEST OF TIMES IT WAS THE WORST OF TIMES\";\n        String encrypted = parse(true, controlName, text.replaceAll(\" \", \"\"));\n        String decrypted = parse(false, controlName, encrypted);\n        System.out.println(\"Input  text    = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n\n        controlName = \"AtomicBlondeCaseSensitive\";\n        generatePad(controlName, 5, 60, 32, 126);\n        text = \"It was the best of times, it was the worst of times.\";\n        encrypted = parse(true, controlName, text);\n        decrypted = parse(false, controlName, encrypted);\n        System.out.println();\n        System.out.println(\"Input text     = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n    }\n    \n    private static String parse(boolean encryptText, String controlName, String text) {\n        StringBuilder sb = new StringBuilder();\n        int minCh = 0;\n        int maxCh = 0;\n        Pattern minChPattern = Pattern.compile(\"^#  MIN_CH = ([\\\\d]+)$\");\n        Pattern maxChPattern = Pattern.compile(\"^#  MAX_CH = ([\\\\d]+)$\");\n        boolean validated = false;\n        try (BufferedReader in = new BufferedReader(new FileReader(getFileName(controlName))); ) {\n            String inLine = null;\n            while ( (inLine = in.readLine()) != null ) {\n                Matcher minMatcher = minChPattern.matcher(inLine);\n                if ( minMatcher.matches() ) {\n                    minCh = Integer.parseInt(minMatcher.group(1));\n                    continue;\n                }\n                Matcher maxMatcher = maxChPattern.matcher(inLine);\n                if ( maxMatcher.matches() ) {\n                    maxCh = Integer.parseInt(maxMatcher.group(1));\n                    continue;\n                }\n                if ( ! validated && minCh > 0 && maxCh > 0 ) {\n                    validateText(text, minCh, maxCh);\n                    validated = true;\n                }\n                \n                if ( inLine.startsWith(\"#\") || inLine.startsWith(\"-\") ) {\n                    continue;\n                }\n                \n                String key = inLine;\n                if ( encryptText ) {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        sb.append((char) (((text.charAt(i) - minCh + key.charAt(i) - minCh) % (maxCh - minCh + 1)) + minCh));\n                    }\n                }\n                else {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        int decrypt = text.charAt(i) - key.charAt(i);\n                        if ( decrypt < 0 ) {\n                            decrypt += maxCh - minCh + 1;\n                        }\n                        decrypt += minCh;\n                        sb.append((char) decrypt);\n                    }\n                }\n                break;\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString();\n    }\n\n    private static void validateText(String text, int minCh, int maxCh) {\n        \n        for ( char ch : text.toCharArray() ) {\n            if ( ch != ' ' && (ch < minCh || ch > maxCh) ) {\n                throw new IllegalArgumentException(\"ERROR 103:  Invalid text.\");\n            }\n        }\n        \n    }\n    \n    private static String getFileName(String controlName) {\n        return controlName + \".1tp\";\n    }\n    \n    private static void generatePad(String controlName, int keys, int keyLength, int minCh, int maxCh) {\n        Random random = new Random();\n        try ( BufferedWriter writer = new BufferedWriter(new FileWriter(getFileName(controlName), false)); ) {\n            writer.write(\"#  Lines starting with '#' are ignored.\");\n            writer.newLine();\n            writer.write(\"#  Lines starting with '-' are previously used.\");\n            writer.newLine();\n            writer.write(\"#  MIN_CH = \" + minCh);\n            writer.newLine();\n            writer.write(\"#  MAX_CH = \" + maxCh);\n            writer.newLine();\n            for ( int line = 0 ; line < keys ; line++ ) {\n                StringBuilder sb = new StringBuilder();\n                for ( int ch = 0 ; ch < keyLength ; ch++ ) {\n                    sb.append((char) (random.nextInt(maxCh - minCh + 1) + minCh));\n                }\n                writer.write(sb.toString());\n                writer.newLine();\n            }\n            writer.write(\"#  EOF\");\n            writer.newLine();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n"}
{"id": 415783, "name": "Topological sort_Extracted top item", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\nuse List::Util qw( uniq );\n\nmy $deps = <<END;\ntop1    des1 ip1 ip2\ntop2    des1 ip2 ip3\nip1     extra1 ip1a ipcommon\nip2     ip2a ip2b ip2c ipcommon\ndes1    des1a des1b des1c\ndes1a   des1a1 des1a2\ndes1c   des1c1 extra1\nEND\n\nsub before\n  {\n  map { $deps =~ /^$_\\b(.+)/m ? before( split ' ', $1 ) : (), $_ } @_\n  }\n\n1 while $deps =~ s/^(\\w+)\\b.*?\\K\\h+\\1\\b//gm; \nprint \"TOP LEVELS: @{[grep $deps\u00a0!~ /\\h$_\\b/, $deps =~ /^\\w+/gm]}\\n\";\nprint \"\\nTARGET $_ ORDER: @{[ uniq before split ]}\\n\"\n  for $deps =~ /^\\w+/gm, 'top1 top2';\n", "target": "import java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\n\npublic class TopologicalSort2 {\n\n    public static void main(String[] args) {\n        String s = \"top1,top2,ip1,ip2,ip3,ip1a,ip2a,ip2b,ip2c,ipcommon,des1,\"\n                + \"des1a,des1b,des1c,des1a1,des1a2,des1c1,extra1\";\n\n        Graph g = new Graph(s, new int[][]{\n            {0, 10}, {0, 2}, {0, 3},\n            {1, 10}, {1, 3}, {1, 4},\n            {2, 17}, {2, 5}, {2, 9},\n            {3, 6}, {3, 7}, {3, 8}, {3, 9},\n            {10, 11}, {10, 12}, {10, 13},\n            {11, 14}, {11, 15},\n            {13, 16}, {13, 17},});\n\n        System.out.println(\"Top levels: \" + g.toplevels());\n        String[] files = {\"top1\", \"top2\", \"ip1\"};\n        for (String f : files)\n            System.out.printf(\"Compile order for %s %s%n\", f, g.compileOrder(f));\n    }\n}\n\nclass Graph {\n    List<String> vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = asList(s.split(\",\"));\n        numVertices = vertices.size();\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> toplevels() {\n        List<String> result = new ArrayList<>();\n        \n        outer:\n        for (int c = 0; c < numVertices; c++) {\n            for (int r = 0; r < numVertices; r++) {\n                if (adjacency[r][c])\n                    continue outer;\n            }\n            result.add(vertices.get(c));\n        }\n        return result;\n    }\n\n    List<String> compileOrder(String item) {\n        LinkedList<String> result = new LinkedList<>();\n        LinkedList<Integer> queue = new LinkedList<>();\n\n        queue.add(vertices.indexOf(item));\n\n        while (!queue.isEmpty()) {\n            int r = queue.poll();\n            for (int c = 0; c < numVertices; c++) {\n                if (adjacency[r][c] && !queue.contains(c)) {\n                    queue.add(c);\n                }\n            }\n            result.addFirst(vertices.get(r));\n        }\n        return result.stream().distinct().collect(toList());\n    }\n}\n"}
{"id": 415784, "name": "Topological sort_Extracted top item", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\nuse List::Util qw( uniq );\n\nmy $deps = <<END;\ntop1    des1 ip1 ip2\ntop2    des1 ip2 ip3\nip1     extra1 ip1a ipcommon\nip2     ip2a ip2b ip2c ipcommon\ndes1    des1a des1b des1c\ndes1a   des1a1 des1a2\ndes1c   des1c1 extra1\nEND\n\nsub before\n  {\n  map { $deps =~ /^$_\\b(.+)/m ? before( split ' ', $1 ) : (), $_ } @_\n  }\n\n1 while $deps =~ s/^(\\w+)\\b.*?\\K\\h+\\1\\b//gm; \nprint \"TOP LEVELS: @{[grep $deps\u00a0!~ /\\h$_\\b/, $deps =~ /^\\w+/gm]}\\n\";\nprint \"\\nTARGET $_ ORDER: @{[ uniq before split ]}\\n\"\n  for $deps =~ /^\\w+/gm, 'top1 top2';\n", "target": "import java.util.*;\nimport static java.util.Arrays.asList;\nimport static java.util.stream.Collectors.toList;\n\npublic class TopologicalSort2 {\n\n    public static void main(String[] args) {\n        String s = \"top1,top2,ip1,ip2,ip3,ip1a,ip2a,ip2b,ip2c,ipcommon,des1,\"\n                + \"des1a,des1b,des1c,des1a1,des1a2,des1c1,extra1\";\n\n        Graph g = new Graph(s, new int[][]{\n            {0, 10}, {0, 2}, {0, 3},\n            {1, 10}, {1, 3}, {1, 4},\n            {2, 17}, {2, 5}, {2, 9},\n            {3, 6}, {3, 7}, {3, 8}, {3, 9},\n            {10, 11}, {10, 12}, {10, 13},\n            {11, 14}, {11, 15},\n            {13, 16}, {13, 17},});\n\n        System.out.println(\"Top levels: \" + g.toplevels());\n        String[] files = {\"top1\", \"top2\", \"ip1\"};\n        for (String f : files)\n            System.out.printf(\"Compile order for %s %s%n\", f, g.compileOrder(f));\n    }\n}\n\nclass Graph {\n    List<String> vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = asList(s.split(\",\"));\n        numVertices = vertices.size();\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> toplevels() {\n        List<String> result = new ArrayList<>();\n        \n        outer:\n        for (int c = 0; c < numVertices; c++) {\n            for (int r = 0; r < numVertices; r++) {\n                if (adjacency[r][c])\n                    continue outer;\n            }\n            result.add(vertices.get(c));\n        }\n        return result;\n    }\n\n    List<String> compileOrder(String item) {\n        LinkedList<String> result = new LinkedList<>();\n        LinkedList<Integer> queue = new LinkedList<>();\n\n        queue.add(vertices.indexOf(item));\n\n        while (!queue.isEmpty()) {\n            int r = queue.poll();\n            for (int c = 0; c < numVertices; c++) {\n                if (adjacency[r][c] && !queue.contains(c)) {\n                    queue.add(c);\n                }\n            }\n            result.addFirst(vertices.get(r));\n        }\n        return result.stream().distinct().collect(toList());\n    }\n}\n"}
{"id": 415785, "name": "Sunflower fractal", "source": "Translate Perl to Java: use Game.SDL2;\nuse Game.Framework;\n\nclass Test {\n  @framework : GameFramework;\n  @colors : Color[];\n  \n  function : Main(args : String[]) ~ Nil {\n    Test->New()->Run();\n  }\n  \n  New() {\n    @framework := GameFramework->New(GameConsts->SCREEN_WIDTH, GameConsts->SCREEN_HEIGHT, \"Test\");\n    @framework->SetClearColor(Color->New(0, 0, 0));\n    @colors := Color->New[2];\n    @colors[0] := Color->New(255,128,0); \n    @colors[1] := Color->New(255,255,25); \n  }\n  \n  method : Run() ~ Nil {\n    if(@framework->IsOk()) {\n      e := @framework->GetEvent();\n      \n      quit := false;\n      while(<>quit) {\n        \n        while(e->Poll() <> 0) {\n          if(e->GetType() = EventType->SDL_QUIT) {\n            quit := true;\n          };\n        };\n\n        @framework->FrameStart();\n        Render(525,525,0.50,3000);\n        @framework->FrameEnd();\n      };\n    }\n    else {\n      \"--- Error Initializing Environment ---\"->ErrorLine();\n      return;\n    };\n\n    leaving {\n      @framework->Quit();\n    };\n  }\n\n  method : Render(winWidth : Int, winHeight : Int, diskRatio : Float, iter : Int) ~ Nil {\n    renderer := @framework->GetRenderer();\n\n    @framework->Clear();\n\n    factor := 0.5 + 1.25->SquareRoot();\n    x := winWidth / 2.0;\n    y := winHeight / 2.0;\n    maxRad := Float->Power(iter, factor) / iter;\n\n    for(i:=0;i<=iter;i+=1;) {\n      r := Float->Power(i,factor)/iter;\n      color := r/maxRad < diskRatio ? @colors[0] : @colors[1];\n      theta := 2*Float->Pi()*factor*i;\n      renderer->CircleColor(x + r*theta->Sin(), y + r*theta->Cos(), 10 * i/(1.0*iter), color);\n    };\n        \n    @framework->Show();\n  }\n}\n\nconsts GameConsts {\n  SCREEN_WIDTH := 640,\n  SCREEN_HEIGHT := 480\n}\n", "target": "\n\nsize(1000,1000);\nsurface.setTitle(\"Sunflower...\");\n\nint iter = 3000;\nfloat factor = .5 + sqrt(1.25),r,theta,diskRatio=0.5;\nfloat x = width/2.0, y = height/2.0;\ndouble maxRad = pow(iter,factor)/iter;\nint i;\n \nbackground(#add8e6); \n \nfor(i=0;i<=iter;i++){\n  r = pow(i,factor)/iter;\n\n  if(r/maxRad < diskRatio){\n    stroke(#000000);        \n  }\n  else\n    stroke(#ffff00);       \n\n  theta = 2*PI*factor*i;\n  ellipse(x + r*sin(theta), y + r*cos(theta), 10 * i/(1.0*iter),10 * i/(1.0*iter));\n}\n"}
{"id": 415786, "name": "Practical numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse enum <False True>;\nuse ntheory <divisors vecextract>;\nuse List::AllUtils <sum uniq firstidx>;\n\nsub proper_divisors {\n  return 1 if 0 == (my $n = shift);\n  my @d = divisors($n);\n  pop @d;\n  @d\n}\n\nsub powerset_sums { uniq map { sum vecextract(\\@_,$_) } 1..2**@_-1 }\n\nsub is_practical {\n    my($n) = @_;\n    return True  if $n == 1;\n    return False if 0 != $n % 2;\n    ($n-2 == firstidx { $_ == $n-1 } powerset_sums(proper_divisors($n)) ) ? True : False;\n}\n\nmy @pn;\nis_practical($_) and push @pn, $_ for 1..333;\nsay @pn . \" matching numbers:\\n\" . (sprintf \"@{['%4d' x @pn]}\", @pn) =~ s/(.{40})/$1\\n/gr;\nsay '';\nprintf \"%6d is practical? %s\\n\", $_, is_practical($_) ? 'True' : 'False' for 666, 6666, 66666;\n", "target": "import java.util.*;\n\npublic class PracticalNumbers {\n    public static void main(String[] args) {\n        final int from = 1;\n        final int to = 333;\n        List<Integer> practical = new ArrayList<>();\n        for (int i = from; i <= to; ++i) {\n            if (isPractical(i))\n                practical.add(i);\n        }\n        System.out.printf(\"Found %d practical numbers between %d and %d:\\n%s\\n\",\n                practical.size(), from, to, shorten(practical, 10));\n\n        printPractical(666);\n        printPractical(6666);\n        printPractical(66666);\n        printPractical(672);\n        printPractical(720);\n        printPractical(222222);\n    }\n\n    private static void printPractical(int n) {\n        if (isPractical(n))\n            System.out.printf(\"%d is a practical number.\\n\", n);\n        else\n            System.out.printf(\"%d is not a practical number.\\n\", n);\n    }\n\n    private static boolean isPractical(int n) {\n        int[] divisors = properDivisors(n);\n        for (int i = 1; i < n; ++i) {\n            if (!sumOfAnySubset(i, divisors, divisors.length))\n                return false;\n        }\n        return true;\n    }\n\n    private static boolean sumOfAnySubset(int n, int[] f, int len) {\n        if (len == 0)\n            return false;\n        int total = 0;\n        for (int i = 0; i < len; ++i) {\n            if (n == f[i])\n                return true;\n            total += f[i];\n        }\n        if (n == total)\n            return true;\n        if (n > total)\n            return false;\n        --len;\n        int d = n - f[len];\n        return (d > 0 && sumOfAnySubset(d, f, len)) || sumOfAnySubset(n, f, len);\n    }\n\n    private static int[] properDivisors(int n) {\n        List<Integer> divisors = new ArrayList<>();\n        divisors.add(1);\n        for (int i = 2;; ++i) {\n            int i2 = i * i;\n            if (i2 > n)\n                break;\n            if (n % i == 0) {\n                divisors.add(i);\n                if (i2 != n)\n                    divisors.add(n / i);\n            }\n        }\n        int[] result = new int[divisors.size()];\n        for (int i = 0; i < result.length; ++i)\n            result[i] = divisors.get(i);\n        Arrays.sort(result);\n        return result;\n    }\n\n    private static String shorten(List<Integer> list, int n) {\n        StringBuilder str = new StringBuilder();\n        int len = list.size(), i = 0;\n        if (n > 0 && len > 0)\n            str.append(list.get(i++));\n        for (; i < n && i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        if (len > i + n) {\n            if (n > 0)\n                str.append(\", ...\");\n            i = len - n;\n        }\n        for (; i < len; ++i) {\n            str.append(\", \");\n            str.append(list.get(i));\n        }\n        return str.toString();\n    }\n}\n"}
{"id": 415787, "name": "Transportation problem", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils qw( max_by nsort_by min );\n\nmy $data = <<END;\nA=20 B=30 C=10\nS=25 T=35\nAS=3 BS=5 CS=7\nCT=3 BT=2 CT=5\nEND\n\nmy $table = sprintf +('%4s' x 4 . \"\\n\") x 3,\n  map {my $t = $_; map \"$_$t\", '', 'A' .. 'C' } '' , 'S' .. 'T';\n\nmy ($cost, %assign) = (0);\nwhile( $data =~ /\\b\\w=\\d/ ) {\n  my @penalty;\n  for ( $data =~ /\\b(\\w)=\\d/g ) {\n    my @all = map /(\\d+)/, nsort_by { /\\d+/ && $& }\n      grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n      $data =~ /$_\\w=\\d+|\\w$_=\\d+/g;\n    push @penalty, [ $_, ($all[1] // 0) - $all[0] ];\n  }\n  my $rc = (max_by { $_->[1] } nsort_by\n    { my $x = $_->[0]; $data =~ /(?:$x\\w|\\w$x)=(\\d+)/ && $1 } @penalty)->[0];\n  my @lowest = nsort_by { /\\d+/ && $& }\n    grep { my ($t, $c) = /(.)(.)=/; $data =~ /\\b$c=\\d/ and $data =~ /\\b$t=\\d/ }\n    $data =~ /$rc\\w=\\d+|\\w$rc=\\d+/g;\n  my ($t, $c) = $lowest[0] =~ /(.)(.)/;\n  my $allocate = min $data =~ /\\b[$t$c]=(\\d+)/g;\n  $table =~ s/$t$c/ sprintf \"%2d\", $allocate/e;\n  $cost += $data =~ /$t$c=(\\d+)/ && $1 * $allocate;\n  $data =~ s/\\b$_=\\K\\d+/ $& - $allocate || '' /e for $t, $c;\n}\n\nsay my $result = \"cost $cost\\n\\n\" . $table =~ s/[A-Z]{2}/--/gr;\n", "target": "import java.io.File;\nimport java.util.*;\nimport static java.util.Arrays.stream;\nimport static java.util.stream.Collectors.toCollection;\n\npublic class TransportationProblem {\n\n    private static int[] demand;\n    private static int[] supply;\n    private static double[][] costs;\n    private static Shipment[][] matrix;\n\n    private static class Shipment {\n        final double costPerUnit;\n        final int r, c;\n        double quantity;\n\n        public Shipment(double q, double cpu, int r, int c) {\n            quantity = q;\n            costPerUnit = cpu;\n            this.r = r;\n            this.c = c;\n        }\n    }\n\n    static void init(String filename) throws Exception {\n\n        try (Scanner sc = new Scanner(new File(filename))) {\n            int numSources = sc.nextInt();\n            int numDestinations = sc.nextInt();\n\n            List<Integer> src = new ArrayList<>();\n            List<Integer> dst = new ArrayList<>();\n\n            for (int i = 0; i < numSources; i++)\n                src.add(sc.nextInt());\n\n            for (int i = 0; i < numDestinations; i++)\n                dst.add(sc.nextInt());\n\n            \n            int totalSrc = src.stream().mapToInt(i -> i).sum();\n            int totalDst = dst.stream().mapToInt(i -> i).sum();\n            if (totalSrc > totalDst)\n                dst.add(totalSrc - totalDst);\n            else if (totalDst > totalSrc)\n                src.add(totalDst - totalSrc);\n\n            supply = src.stream().mapToInt(i -> i).toArray();\n            demand = dst.stream().mapToInt(i -> i).toArray();\n\n            costs = new double[supply.length][demand.length];\n            matrix = new Shipment[supply.length][demand.length];\n\n            for (int i = 0; i < numSources; i++)\n                for (int j = 0; j < numDestinations; j++)\n                    costs[i][j] = sc.nextDouble();\n        }\n    }\n\n    static void northWestCornerRule() {\n\n        for (int r = 0, northwest = 0; r < supply.length; r++)\n            for (int c = northwest; c < demand.length; c++) {\n\n                int quantity = Math.min(supply[r], demand[c]);\n                if (quantity > 0) {\n                    matrix[r][c] = new Shipment(quantity, costs[r][c], r, c);\n\n                    supply[r] -= quantity;\n                    demand[c] -= quantity;\n\n                    if (supply[r] == 0) {\n                        northwest = c;\n                        break;\n                    }\n                }\n            }\n    }\n\n    static void steppingStone() {\n        double maxReduction = 0;\n        Shipment[] move = null;\n        Shipment leaving = null;\n\n        fixDegenerateCase();\n\n        for (int r = 0; r < supply.length; r++) {\n            for (int c = 0; c < demand.length; c++) {\n\n                if (matrix[r][c] != null)\n                    continue;\n\n                Shipment trial = new Shipment(0, costs[r][c], r, c);\n                Shipment[] path = getClosedPath(trial);\n\n                double reduction = 0;\n                double lowestQuantity = Integer.MAX_VALUE;\n                Shipment leavingCandidate = null;\n\n                boolean plus = true;\n                for (Shipment s : path) {\n                    if (plus) {\n                        reduction += s.costPerUnit;\n                    } else {\n                        reduction -= s.costPerUnit;\n                        if (s.quantity < lowestQuantity) {\n                            leavingCandidate = s;\n                            lowestQuantity = s.quantity;\n                        }\n                    }\n                    plus = !plus;\n                }\n                if (reduction < maxReduction) {\n                    move = path;\n                    leaving = leavingCandidate;\n                    maxReduction = reduction;\n                }\n            }\n        }\n\n        if (move != null) {\n            double q = leaving.quantity;\n            boolean plus = true;\n            for (Shipment s : move) {\n                s.quantity += plus ? q : -q;\n                matrix[s.r][s.c] = s.quantity == 0 ? null : s;\n                plus = !plus;\n            }\n            steppingStone();\n        }\n    }\n\n    static LinkedList<Shipment> matrixToList() {\n        return stream(matrix)\n                .flatMap(row -> stream(row))\n                .filter(s -> s != null)\n                .collect(toCollection(LinkedList::new));\n    }\n\n    static Shipment[] getClosedPath(Shipment s) {\n        LinkedList<Shipment> path = matrixToList();\n        path.addFirst(s);\n\n        \n        \n        while (path.removeIf(e -> {\n            Shipment[] nbrs = getNeighbors(e, path);\n            return nbrs[0] == null || nbrs[1] == null;\n        }));\n\n        \n        Shipment[] stones = path.toArray(new Shipment[path.size()]);\n        Shipment prev = s;\n        for (int i = 0; i < stones.length; i++) {\n            stones[i] = prev;\n            prev = getNeighbors(prev, path)[i % 2];\n        }\n        return stones;\n    }\n\n    static Shipment[] getNeighbors(Shipment s, LinkedList<Shipment> lst) {\n        Shipment[] nbrs = new Shipment[2];\n        for (Shipment o : lst) {\n            if (o != s) {\n                if (o.r == s.r && nbrs[0] == null)\n                    nbrs[0] = o;\n                else if (o.c == s.c && nbrs[1] == null)\n                    nbrs[1] = o;\n                if (nbrs[0] != null && nbrs[1] != null)\n                    break;\n            }\n        }\n        return nbrs;\n    }\n\n    static void fixDegenerateCase() {\n        final double eps = Double.MIN_VALUE;\n\n        if (supply.length + demand.length - 1 != matrixToList().size()) {\n\n            for (int r = 0; r < supply.length; r++)\n                for (int c = 0; c < demand.length; c++) {\n                    if (matrix[r][c] == null) {\n                        Shipment dummy = new Shipment(eps, costs[r][c], r, c);\n                        if (getClosedPath(dummy).length == 0) {\n                            matrix[r][c] = dummy;\n                            return;\n                        }\n                    }\n                }\n        }\n    }\n\n    static void printResult(String filename) {\n        System.out.printf(\"Optimal solution %s%n%n\", filename);\n        double totalCosts = 0;\n\n        for (int r = 0; r < supply.length; r++) {\n            for (int c = 0; c < demand.length; c++) {\n\n                Shipment s = matrix[r][c];\n                if (s != null && s.r == r && s.c == c) {\n                    System.out.printf(\" %3s \", (int) s.quantity);\n                    totalCosts += (s.quantity * s.costPerUnit);\n                } else\n                    System.out.printf(\"  -  \");\n            }\n            System.out.println();\n        }\n        System.out.printf(\"%nTotal costs: %s%n%n\", totalCosts);\n    }\n\n    public static void main(String[] args) throws Exception {\n\n        for (String filename : new String[]{\"input1.txt\", \"input2.txt\",\n            \"input3.txt\"}) {\n            init(filename);\n            northWestCornerRule();\n            steppingStone();\n            printResult(filename);\n        }\n    }\n}\n"}
{"id": 415788, "name": "Penrose tiling", "source": "Translate Perl to Java: use constant pi => 2 * atan2(1, 0);\n\n\n%rules = (\n    A => '',\n    M => 'OA++PA----NA[-OA----MA]++',\n    N => '+OA--PA[---MA--NA]+',\n    O => '-MA++NA[+++OA++PA]-',\n    P => '--OA++++MA[+PA++++NA]--NA'\n);\n$penrose = '[N]++[N]++[N]++[N]++[N]';\n$penrose =~ s/([AMNOP])/$rules{$1}/eg for 1..4;\n\n\n($x, $y) = (160, 160);\n$theta   = pi/5;\n$r       = 20;\n\nfor (split //, $penrose) {\n    if (/A/) {\n        $line  = sprintf \"<line x1='%.1f' y1='%.1f' \", $x, $y;\n        $line .= sprintf \"x2='%.1f' \", $x += $r * cos($theta);\n        $line .= sprintf \"y2='%.1f' \", $y += $r * sin($theta);\n        $line .= \"style='stroke:rgb(255,165,0)'/>\\n\";\n        $SVG{$line} = 1;\n    } elsif (/\\+/) { $theta += pi/5\n    } elsif (/\\-/) { $theta -= pi/5\n    } elsif (/\\[/) { push @stack, [$x, $y, $theta]\n    } elsif (/\\]/) { ($x, $y, $theta) = @{pop @stack} }\n}\n$svg .= $_ for keys %SVG;\nopen  $fh, '>', 'penrose_tiling.svg';\nprint $fh  qq{<svg xmlns=\"http://www.w3.org/2000/svg\" height=\"350\" width=\"350\"> <rect height=\"100%\" width=\"100%\" style=\"fill:black\" />\\n$svg</svg>};\nclose $fh;\n", "target": "import java.awt.*;\nimport java.util.List;\nimport java.awt.geom.Path2D;\nimport java.util.*;\nimport javax.swing.*;\nimport static java.lang.Math.*;\nimport static java.util.stream.Collectors.toList;\n\npublic class PenroseTiling extends JPanel {\n    \n    class Tile {\n        double x, y, angle, size;\n        Type type;\n\n        Tile(Type t, double x, double y, double a, double s) {\n            type = t;\n            this.x = x;\n            this.y = y;\n            angle = a;\n            size = s;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (o instanceof Tile) {\n                Tile t = (Tile) o;\n                return type == t.type && x == t.x && y == t.y && angle == t.angle;\n            }\n            return false;\n        }\n    }\n\n    enum Type {\n        Kite, Dart\n    }\n\n    static final double G = (1 + sqrt(5)) / 2; \n    static final double T = toRadians(36); \n\n    List<Tile> tiles = new ArrayList<>();\n\n    public PenroseTiling() {\n        int w = 700, h = 450;\n        setPreferredSize(new Dimension(w, h));\n        setBackground(Color.white);\n\n        tiles = deflateTiles(setupPrototiles(w, h), 5);\n    }\n\n    List<Tile> setupPrototiles(int w, int h) {\n        List<Tile> proto = new ArrayList<>();\n\n        \n        for (double a = PI / 2 + T; a < 3 * PI; a += 2 * T)\n            proto.add(new Tile(Type.Kite, w / 2, h / 2, a, w / 2.5));\n\n        return proto;\n    }\n\n    List<Tile> deflateTiles(List<Tile> tls, int generation) {\n        if (generation <= 0)\n            return tls;\n\n        List<Tile> next = new ArrayList<>();\n\n        for (Tile tile : tls) {\n            double x = tile.x, y = tile.y, a = tile.angle, nx, ny;\n            double size = tile.size / G;\n\n            if (tile.type == Type.Dart) {\n                next.add(new Tile(Type.Kite, x, y, a + 5 * T, size));\n\n                for (int i = 0, sign = 1; i < 2; i++, sign *= -1) {\n                    nx = x + cos(a - 4 * T * sign) * G * tile.size;\n                    ny = y - sin(a - 4 * T * sign) * G * tile.size;\n                    next.add(new Tile(Type.Dart, nx, ny, a - 4 * T * sign, size));\n                }\n\n            } else {\n\n                for (int i = 0, sign = 1; i < 2; i++, sign *= -1) {\n                    next.add(new Tile(Type.Dart, x, y, a - 4 * T * sign, size));\n\n                    nx = x + cos(a - T * sign) * G * tile.size;\n                    ny = y - sin(a - T * sign) * G * tile.size;\n                    next.add(new Tile(Type.Kite, nx, ny, a + 3 * T * sign, size));\n                }\n            }\n        }\n        \n        tls = next.stream().distinct().collect(toList());\n\n        return deflateTiles(tls, generation - 1);\n    }\n\n    void drawTiles(Graphics2D g) {\n        double[][] dist = {{G, G, G}, {-G, -1, -G}};\n        for (Tile tile : tiles) {\n            double angle = tile.angle - T;\n            Path2D path = new Path2D.Double();\n            path.moveTo(tile.x, tile.y);\n\n            int ord = tile.type.ordinal();\n            for (int i = 0; i < 3; i++) {\n                double x = tile.x + dist[ord][i] * tile.size * cos(angle);\n                double y = tile.y - dist[ord][i] * tile.size * sin(angle);\n                path.lineTo(x, y);\n                angle += T;\n            }\n            path.closePath();\n            g.setColor(ord == 0 ? Color.orange : Color.yellow);\n            g.fill(path);\n            g.setColor(Color.darkGray);\n            g.draw(path);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics og) {\n        super.paintComponent(og);\n        Graphics2D g = (Graphics2D) og;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        drawTiles(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Penrose Tiling\");\n            f.setResizable(false);\n            f.add(new PenroseTiling(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 415789, "name": "Generalised floating point addition", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::Decimal qw(dec_add dec_mul_pow10);\n\nmy $e = 63;\nfor my $n (-7..21) {\n    my $num = '12345679' . '012345679' x ($n+7);\n    my $sum = dec_mul_pow10(1, $e);\n    $sum = dec_add($sum, dec_mul_pow10($num,$e)) for 1..81;\n    printf \"$n:%s \", 10**72 == $sum ? 'Y' : 'N';\n    $e -= 9;\n}\n", "target": "import java.math.BigDecimal;\n\npublic class GeneralisedFloatingPointAddition {\n\n    public static void main(String[] args) {\n        BigDecimal oneExp72 = new BigDecimal(\"1E72\");\n        for ( int i = 0 ; i <= 21+7 ; i++ ) {\n            String s = \"12345679\";\n            for ( int j = 0 ; j < i ; j++ ) {\n                s += \"012345679\";\n            }\n            int exp = 63 - 9*i;\n            s += \"E\" + exp;\n            BigDecimal num = new BigDecimal(s).multiply(BigDecimal.valueOf(81)).add(new BigDecimal(\"1E\" + exp));\n            System.out.printf(\"Test value (%s) equals computed value: %b.  Computed = %s%n\", oneExp72, num.compareTo(oneExp72) == 0 , num);\n        }\n    }\n\n}\n"}
{"id": 415790, "name": "Generalised floating point addition", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::Decimal qw(dec_add dec_mul_pow10);\n\nmy $e = 63;\nfor my $n (-7..21) {\n    my $num = '12345679' . '012345679' x ($n+7);\n    my $sum = dec_mul_pow10(1, $e);\n    $sum = dec_add($sum, dec_mul_pow10($num,$e)) for 1..81;\n    printf \"$n:%s \", 10**72 == $sum ? 'Y' : 'N';\n    $e -= 9;\n}\n", "target": "import java.math.BigDecimal;\n\npublic class GeneralisedFloatingPointAddition {\n\n    public static void main(String[] args) {\n        BigDecimal oneExp72 = new BigDecimal(\"1E72\");\n        for ( int i = 0 ; i <= 21+7 ; i++ ) {\n            String s = \"12345679\";\n            for ( int j = 0 ; j < i ; j++ ) {\n                s += \"012345679\";\n            }\n            int exp = 63 - 9*i;\n            s += \"E\" + exp;\n            BigDecimal num = new BigDecimal(s).multiply(BigDecimal.valueOf(81)).add(new BigDecimal(\"1E\" + exp));\n            System.out.printf(\"Test value (%s) equals computed value: %b.  Computed = %s%n\", oneExp72, num.compareTo(oneExp72) == 0 , num);\n        }\n    }\n\n}\n"}
{"id": 415791, "name": "Railway circuit", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse experimental 'signatures';\nuse List::Util qw(sum);\nuse ntheory 'todigits';\n\n{\n    package Point;\n    use Class::Struct;\n    struct( x => '$', y => '$',);\n}\n\nuse constant pi => 2 * atan2(1, 0);\nuse enum qw(False True);\n\nmy @twelvesteps = map { Point->new( x => sin(pi * $_/6), y => cos(pi * $_/6) ) } 1 .. 12;\nmy @foursteps   = map { Point->new( x => sin(pi * $_/2), y => cos(pi * $_/2) ) } 1 ..  4;\n\nsub add ($p, $q) { Point->new( x => $p->x + $q->x , y => $p->y + $q->y) }\n\nsub approx_eq ($p, $q) { use constant eps => .0001; abs($p->x - $q->x)<eps and abs($p->y - $q->y)<eps }\n\nsub digits($n, $base, $pad=0) {\n    my @output = reverse todigits($n, $base);\n    push @output, (0) x ($pad - +@output) if $pad > +@output;\n    @output\n}\n\nsub rotate { my($i,@a) = @_; @a[$i .. @a-1, 0 .. $i-1] }\n\nsub circularsymmetries(@c) { map { join ' ', rotate($_, @c) } 0 .. $\n\nsub addsymmetries($infound, @turns) {\n    my @allsym;\n    push @allsym, circularsymmetries(@turns);\n    push @allsym, circularsymmetries(map { -1 * $_ } @turns);\n    $$infound{$_} = True for @allsym;\n    (sort @allsym)[-1]\n}\n\nsub isclosedpath($straight, @turns) {\n    my $start = Point->new(x=> 0, y =>0);\n    return False if sum(@turns) % ($straight ? 4 : 12);\n    my ($angl, $point) = (0, $start);\n    for my $turn (@turns) {\n        $angl  += $turn;\n        $point = add($point, $straight ? $foursteps[$angl % 4] : $twelvesteps[$angl % 12]);\n    }\n    approx_eq($point, $start);\n}\n\nsub allvalidcircuits($N, $doPrint = False, $straight = False) {\n    my ( @found, %infound );\n    say \"\\nFor N of \". $N . ' and ' . ($straight ? 'straight' : 'curved') . ' track:';\n    for my $i (0 .. ($straight ? 3 : 2)**$N - 1) {\n        my @turns = $straight ?\n            map { $_ == 0 ?  0 : ($_ == 1 ? -1 : 1) } digits($i,3,$N) :\n            map { $_ == 0 ? -1 :                 1  } digits($i,2,$N);\n        if (isclosedpath($straight, @turns) && ! exists $infound{join ' ', @turns} ) {\n            my $canon = addsymmetries(\\%infound, @turns);\n            push @found, $canon;\n        }\n    }\n    say join \"\\n\", @found if $doPrint;\n    say \"There are \" . +@found . ' unique valid circuits.';\n    @found\n}\n\nallvalidcircuits($_, True)       for 12, 16, 20;\nallvalidcircuits($_, True, True) for 4, 6, 8;\n", "target": "package railwaycircuit;\n\nimport static java.util.Arrays.stream;\nimport java.util.*;\nimport static java.util.stream.IntStream.range;\n\npublic class RailwayCircuit {\n    final static int RIGHT = 1, LEFT = -1, STRAIGHT = 0;\n\n    static String normalize(int[] tracks) {\n        char[] a = new char[tracks.length];\n        for (int i = 0; i < a.length; i++)\n            a[i] = \"abc\".charAt(tracks[i] + 1);\n\n        \n        String norm = new String(a);\n        for (int i = 0, len = a.length; i < len; i++) {\n\n            String s = new String(a);\n            if (s.compareTo(norm) < 0)\n                norm = s;\n\n            char tmp = a[0];\n            for (int j = 1; j < a.length; j++)\n                a[j - 1] = a[j];\n            a[len - 1] = tmp;\n        }\n        return norm;\n    }\n\n    static boolean fullCircleStraight(int[] tracks, int nStraight) {\n        if (nStraight == 0)\n            return true;\n\n        \n        if (stream(tracks).filter(i -> i == STRAIGHT).count() != nStraight)\n            return false;\n\n        \n        int[] straight = new int[12];\n        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {\n            if (tracks[i] == STRAIGHT)\n                straight[idx % 12]++;\n            idx += tracks[i];\n        }\n\n        return !(range(0, 6).anyMatch(i -> straight[i] != straight[i + 6])\n                && range(0, 8).anyMatch(i -> straight[i] != straight[i + 4]));\n    }\n\n    static boolean fullCircleRight(int[] tracks) {\n\n        \n        if (stream(tracks).map(i -> i * 30).sum() % 360 != 0)\n            return false;\n\n        \n        int[] rTurns = new int[12];\n        for (int i = 0, idx = 0; i < tracks.length && idx >= 0; i++) {\n            if (tracks[i] == RIGHT)\n                rTurns[idx % 12]++;\n            idx += tracks[i];\n        }\n\n        return !(range(0, 6).anyMatch(i -> rTurns[i] != rTurns[i + 6])\n                && range(0, 8).anyMatch(i -> rTurns[i] != rTurns[i + 4]));\n    }\n\n    static void circuits(int nCurved, int nStraight) {\n        Map<String, int[]> solutions = new HashMap<>();\n\n        PermutationsGen gen = getPermutationsGen(nCurved, nStraight);\n        while (gen.hasNext()) {\n\n            int[] tracks = gen.next();\n\n            if (!fullCircleStraight(tracks, nStraight))\n                continue;\n\n            if (!fullCircleRight(tracks))\n                continue;\n\n            solutions.put(normalize(tracks), tracks.clone());\n        }\n        report(solutions, nCurved, nStraight);\n    }\n\n    static PermutationsGen getPermutationsGen(int nCurved, int nStraight) {\n        assert (nCurved + nStraight - 12) % 4 == 0 : \"input must be 12 + k * 4\";\n\n        int[] trackTypes = new int[]{RIGHT, LEFT};\n\n        if (nStraight != 0) {\n            if (nCurved == 12)\n                trackTypes = new int[]{RIGHT, STRAIGHT};\n            else\n                trackTypes = new int[]{RIGHT, LEFT, STRAIGHT};\n        }\n\n        return new PermutationsGen(nCurved + nStraight, trackTypes);\n    }\n\n    static void report(Map<String, int[]> sol, int numC, int numS) {\n\n        int size = sol.size();\n        System.out.printf(\"%n%d solution(s) for C%d,%d %n\", size, numC, numS);\n\n        if (size < 10)\n            sol.values().stream().forEach(tracks -> {\n                stream(tracks).forEach(i -> System.out.printf(\"%2d \", i));\n                System.out.println();\n            });\n    }\n\n    public static void main(String[] args) {\n        circuits(12, 0);\n        circuits(16, 0);\n        circuits(20, 0);\n        circuits(24, 0);\n        circuits(12, 4);\n    }\n}\n\nclass PermutationsGen {\n    \n    private int[] indices;\n    private int[] choices;\n    private int[] sequence;\n    private int carry;\n\n    PermutationsGen(int numPositions, int[] choices) {\n        indices = new int[numPositions];\n        sequence = new int[numPositions];\n        this.choices = choices;\n    }\n\n    int[] next() {\n        carry = 1;\n        \n        for (int i = 1; i < indices.length && carry > 0; i++) {\n            indices[i] += carry;\n            carry = 0;\n\n            if (indices[i] == choices.length) {\n                carry = 1;\n                indices[i] = 0;\n            }\n        }\n\n        for (int i = 0; i < indices.length; i++)\n            sequence[i] = choices[indices[i]];\n\n        return sequence;\n    }\n\n    boolean hasNext() {\n        return carry != 1;\n    }\n}\n"}
{"id": 415792, "name": "SQL-based authentication", "source": "Translate Perl to Java: use DBI;\n\n \nsub connect_db {\n    my ($dbname, $host, $user, $pass) = @_;\n    my $db = DBI->connect(\"dbi:mysql:$dbname:$host\", $user, $pass)\n        or die $DBI::errstr;\n    $db->{RaiseError} = 1;\n    $db\n}\n\n \n \nsub create_user {\n    my ($db, $user, $pass) = @_;\n    my $salt = pack \"C*\", map {int rand 256} 1..16;\n    $db->do(\"INSERT IGNORE INTO users (username, pass_salt, pass_md5)\n        VALUES (?,\u00a0?, unhex(md5(concat(pass_salt,\u00a0?))))\",\n        undef, $user, $salt, $pass)\n      and $db->{mysql_insertid} or undef\n}\n\n \nsub authenticate_user {\n    my ($db, $user, $pass) = @_;\n    my $userid = $db->selectrow_array(\"SELECT userid FROM users WHERE\n        username=? AND pass_md5=unhex(md5(concat(pass_salt,\u00a0?)))\",\n        undef, $user, $pass);\n    $userid\n}\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.SecureRandom;\nimport java.math.BigInteger;\n\n\nclass UserManager {\n    private Connection dbConnection;\n\n    public UserManager() {\n    }\n\n    private String md5(String aString) throws NoSuchAlgorithmException, UnsupportedEncodingException {\n        MessageDigest md;\n        String hex;\n        StringBuffer hexString;\n        byte[] bytesOfMessage;\n        byte[] theDigest;\n\n        hexString = new StringBuffer();\n        bytesOfMessage = aString.getBytes(\"UTF-8\");\n        md = MessageDigest.getInstance(\"MD5\");\n        theDigest = md.digest(bytesOfMessage);\n\n        for (int i = 0; i < theDigest.length; i++) {\n            hex = Integer.toHexString(0xff & theDigest[i]);\n            if (hex.length() == 1) {\n                hexString.append('0');\n            }\n            hexString.append(hex);\n        }\n\n        return hexString.toString();\n    }\n\n    public void connectDB(String host, int port, String db, String user, String password)\n      throws ClassNotFoundException, SQLException {\n\n        Class.forName(\"com.mysql.jdbc.Driver\");\n\n        this.dbConnection =  DriverManager.getConnection(\"jdbc:mysql:\n                                + host\n                                + \":\"\n                                + port\n                                + \"/\"\n                                + db, user, password);\n    }\n\n    public boolean createUser(String user, String password) {\n        SecureRandom random;\n        String insert;\n        String salt;\n\n        random = new SecureRandom();\n        salt =  new BigInteger(130, random).toString(16);\n\n        insert = \"INSERT INTO users \"\n            + \"(username, pass_salt, pass_md5) \"\n            + \"VALUES (?,\u00a0?,\u00a0?)\";\n\n        try (PreparedStatement pstmt = this.dbConnection.prepareStatement(insert)) {\n            pstmt.setString(1, user);\n            pstmt.setString(2, salt);\n            pstmt.setString(3, this.md5(salt + password));\n            pstmt.executeUpdate();\n\n            return true;\n        } catch(NoSuchAlgorithmException | SQLException | UnsupportedEncodingException ex) {\n            return false;\n        }\n    }\n\n    public boolean authenticateUser(String user, String password) {\n        String pass_md5;\n        String pass_salt;\n        String select;\n        ResultSet res;\n\n        select = \"SELECT pass_salt, pass_md5 FROM users WHERE username =\u00a0?\";\n        res = null;\n\n        try(PreparedStatement pstmt = this.dbConnection.prepareStatement(select)) {\n            pstmt.setString(1, user);\n            res = pstmt.executeQuery();\n\n            res.next(); \n\n            pass_salt = res.getString(1);\n            pass_md5 = res.getString(2);\n\n            if (pass_md5.equals(this.md5(pass_salt + password))) {\n                return true;\n            } else {\n                return false;\n            }\n\n        } catch(NoSuchAlgorithmException | SQLException | UnsupportedEncodingException ex) {\n            return false;\n        } finally {\n            try {\n                if (res instanceof ResultSet && !res.isClosed()) {\n                    res.close();\n                }\n            } catch(SQLException ex) {\n            }\n        }\n    }\n\n    public void closeConnection() {\n        try {\n            this.dbConnection.close();\n        } catch(NullPointerException | SQLException ex) {\n        }\n    }\n\n    public static void main(String[] args) {\n        UserManager um;\n\n        um = new UserManager();\n        try {\n            um.connectDB(\"localhost\", 3306, \"test\", \"root\", \"admin\");\n\n            if (um.createUser(\"johndoe\", \"test\")) {\n                System.out.println(\"User created\");\n            }\n\n            if (um.authenticateUser(\"johndoe\", \"test\")) {\n                System.out.println(\"User authenticated\");\n            }\n        } catch(ClassNotFoundException | SQLException ex) {\n            ex.printStackTrace();\n        } finally {\n            um.closeConnection();\n        }\n    }\n}\n"}
{"id": 415793, "name": "Powerful numbers", "source": "Translate Perl to Java: use 5.020;\nuse ntheory qw(is_square_free);\nuse experimental qw(signatures);\nuse Math::AnyNum qw(:overload idiv iroot ipow is_coprime);\n\nsub powerful_numbers ($n, $k = 2) {\n\n    my @powerful;\n\n    sub ($m, $r) {\n        if ($r < $k) {\n            push @powerful, $m;\n            return;\n        }\n        for my $v (1 .. iroot(idiv($n, $m), $r)) {\n            if ($r > $k) {\n                is_square_free($v) || next;\n                is_coprime($m, $v) || next;\n            }\n            __SUB__->($m * ipow($v, $r), $r - 1);\n        }\n    }->(1, 2*$k - 1);\n\n    sort { $a <=> $b } @powerful;\n}\n\nforeach my $k (2 .. 10) {\n    my @a = powerful_numbers(10**$k, $k);\n    my $h = join(', ', @a[0..4]);\n    my $t = join(', ', @a[$\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", $k, scalar(@a), $h, $t);\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class PowerfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Task:  For k = 2..10, generate the set of k-powerful numbers <= 10^k and show the first 5 and the last 5 terms, along with the length of the set%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            BigInteger max = BigInteger.valueOf(10).pow(k);\n            List<BigInteger> powerfulNumbers = getPowerFulNumbers(max, k);\n            System.out.printf(\"There are %d %d-powerful numbers between 1 and %d.  %nList: %s%n\", powerfulNumbers.size(), k, max, getList(powerfulNumbers));\n        }\n        System.out.printf(\"%nTask:  For k = 2..10, show the number of k-powerful numbers less than or equal to 10^j, for 0 <= j < k+10%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            List<Integer> powCount = new ArrayList<>();\n            for ( int j = 0 ; j < k+10 ; j++ ) {\n                BigInteger max = BigInteger.valueOf(10).pow(j);\n                powCount.add(countPowerFulNumbers(max, k));\n            }\n            System.out.printf(\"Count of %2d-powerful numbers <= 10^j, j in [0, %d]: %s%n\", k, k+9, powCount);\n        }\n        \n    }\n    \n    private static String getList(List<BigInteger> list) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(list.subList(0, 5).toString().replace(\"]\", \"\"));\n        sb.append(\" ... \");\n        sb.append(list.subList(list.size()-5, list.size()).toString().replace(\"[\", \"\"));\n        return sb.toString();\n    }\n\n    private static int countPowerFulNumbers(BigInteger max, int k) {\n        return potentialPowerful(max, k).size();\n    }\n\n    private static List<BigInteger> getPowerFulNumbers(BigInteger max, int k) {\n        List<BigInteger> powerfulNumbers = new ArrayList<>(potentialPowerful(max, k));\n        Collections.sort(powerfulNumbers);\n        return powerfulNumbers;\n    }\n\n    private static Set<BigInteger> potentialPowerful(BigInteger max, int k) {\n        \n        int[] indexes = new int[k];\n        for ( int i = 0 ; i < k ; i++ ) {\n            indexes[i] = 1;\n        }\n\n        Set<BigInteger> powerful = new HashSet<>();\n        boolean foundPower = true;\n        while ( foundPower ) {\n            \n            boolean genPowerful = false;\n            for ( int index = 0 ; index < k ; index++ ) {\n                BigInteger power = BigInteger.ONE;\n                for ( int i = 0 ; i < k ; i++ ) {\n                    power = power.multiply(BigInteger.valueOf(indexes[i]).pow(k+i));\n                }\n                if ( power.compareTo(max) <= 0 ) {\n                    powerful.add(power);\n                    indexes[0] += 1;\n                    genPowerful = true;\n                    break;\n                }\n                else {\n                    indexes[index] = 1;\n                    if ( index < k-1 ) {\n                        indexes[index+1] += 1;\n                    }\n                }\n            }\n            if ( ! genPowerful ) {\n                foundPower = false;\n            }\n        }\n\n        return powerful;\n    }\n    \n}\n"}
{"id": 415794, "name": "Powerful numbers", "source": "Translate Perl to Java: use 5.020;\nuse ntheory qw(is_square_free);\nuse experimental qw(signatures);\nuse Math::AnyNum qw(:overload idiv iroot ipow is_coprime);\n\nsub powerful_numbers ($n, $k = 2) {\n\n    my @powerful;\n\n    sub ($m, $r) {\n        if ($r < $k) {\n            push @powerful, $m;\n            return;\n        }\n        for my $v (1 .. iroot(idiv($n, $m), $r)) {\n            if ($r > $k) {\n                is_square_free($v) || next;\n                is_coprime($m, $v) || next;\n            }\n            __SUB__->($m * ipow($v, $r), $r - 1);\n        }\n    }->(1, 2*$k - 1);\n\n    sort { $a <=> $b } @powerful;\n}\n\nforeach my $k (2 .. 10) {\n    my @a = powerful_numbers(10**$k, $k);\n    my $h = join(', ', @a[0..4]);\n    my $t = join(', ', @a[$\n    printf(\"For k=%-2d there are %d k-powerful numbers <= 10^k: [%s, ..., %s]\\n\", $k, scalar(@a), $h, $t);\n}\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class PowerfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Task:  For k = 2..10, generate the set of k-powerful numbers <= 10^k and show the first 5 and the last 5 terms, along with the length of the set%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            BigInteger max = BigInteger.valueOf(10).pow(k);\n            List<BigInteger> powerfulNumbers = getPowerFulNumbers(max, k);\n            System.out.printf(\"There are %d %d-powerful numbers between 1 and %d.  %nList: %s%n\", powerfulNumbers.size(), k, max, getList(powerfulNumbers));\n        }\n        System.out.printf(\"%nTask:  For k = 2..10, show the number of k-powerful numbers less than or equal to 10^j, for 0 <= j < k+10%n\");\n        for ( int k = 2 ; k <= 10 ; k++ ) {\n            List<Integer> powCount = new ArrayList<>();\n            for ( int j = 0 ; j < k+10 ; j++ ) {\n                BigInteger max = BigInteger.valueOf(10).pow(j);\n                powCount.add(countPowerFulNumbers(max, k));\n            }\n            System.out.printf(\"Count of %2d-powerful numbers <= 10^j, j in [0, %d]: %s%n\", k, k+9, powCount);\n        }\n        \n    }\n    \n    private static String getList(List<BigInteger> list) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(list.subList(0, 5).toString().replace(\"]\", \"\"));\n        sb.append(\" ... \");\n        sb.append(list.subList(list.size()-5, list.size()).toString().replace(\"[\", \"\"));\n        return sb.toString();\n    }\n\n    private static int countPowerFulNumbers(BigInteger max, int k) {\n        return potentialPowerful(max, k).size();\n    }\n\n    private static List<BigInteger> getPowerFulNumbers(BigInteger max, int k) {\n        List<BigInteger> powerfulNumbers = new ArrayList<>(potentialPowerful(max, k));\n        Collections.sort(powerfulNumbers);\n        return powerfulNumbers;\n    }\n\n    private static Set<BigInteger> potentialPowerful(BigInteger max, int k) {\n        \n        int[] indexes = new int[k];\n        for ( int i = 0 ; i < k ; i++ ) {\n            indexes[i] = 1;\n        }\n\n        Set<BigInteger> powerful = new HashSet<>();\n        boolean foundPower = true;\n        while ( foundPower ) {\n            \n            boolean genPowerful = false;\n            for ( int index = 0 ; index < k ; index++ ) {\n                BigInteger power = BigInteger.ONE;\n                for ( int i = 0 ; i < k ; i++ ) {\n                    power = power.multiply(BigInteger.valueOf(indexes[i]).pow(k+i));\n                }\n                if ( power.compareTo(max) <= 0 ) {\n                    powerful.add(power);\n                    indexes[0] += 1;\n                    genPowerful = true;\n                    break;\n                }\n                else {\n                    indexes[index] = 1;\n                    if ( index < k-1 ) {\n                        indexes[index+1] += 1;\n                    }\n                }\n            }\n            if ( ! genPowerful ) {\n                foundPower = false;\n            }\n        }\n\n        return powerful;\n    }\n    \n}\n"}
{"id": 415795, "name": "Execute CopyPasta Language", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Path::Tiny;\n\nsub CopyPasta {\n    my($code) = @_;\n    my @code = split /\\n/, $code =~ s/\\s*\\n+\\s*/\\n/gr;\n    return \"Program never ends!\" unless grep { $_ eq 'Pasta!' } @code;\n\n    my @cb;\n    my $PC = 0;\n    while (1) {\n        if    ($code[$PC] eq 'Copy')      {        push @cb, $code[++$PC] }\n        elsif ($code[$PC] eq 'CopyFile')  { $PC++; push @cb, join ' ', $code[$PC] eq 'TheF*ckingCode' ? @code : path($code[$PC])->slurp }\n        elsif ($code[$PC] eq 'Duplicate') {             @cb = (@cb) x $code[++$PC] }\n        elsif ($code[$PC] eq 'Pasta!')    { return @cb }\n        else                              { return \"Does not compute: $code[$PC]\" }\n        $PC++;\n    }\n}\n\npath('pasta.txt')->spew( \"I'm the pasta.txt file.\");\n\nfor my $prog (\n    \"Copy \\nRosetta Code\\n\\tDuplicate\\n2\\n\\nPasta!\\nLa Vista\",\n    \"CopyFile\\npasta.txt\\nDuplicate\\n1\\nPasta!\",\n    \"Copy\\nInvalid\\n Duplicate\\n1\\n\\nGoto\\n3\\nPasta!\",\n    \"CopyFile\\nTheF*ckingCode\\nDuplicate\\n2\\nPasta!\",\n    \"Copy\\nRosetta Code\\nDuplicate\\n2\\n\\nPasta\"\n) {\n    say for CopyPasta($prog);\n    say '';\n}\n\nunlink 'pasta.txt';\n", "target": "import java.io.File;\nimport java.nio.file.Files;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Copypasta\n{\n\t\n\tpublic static void fatal_error(String errtext)\n\t{\n\t\tStackTraceElement[] stack = Thread.currentThread().getStackTrace();\n\t\tStackTraceElement main = stack[stack.length - 1];\n\t\tString mainClass = main.getClassName();\n\t\tSystem.out.println(\"%\" + errtext);\n\t\tSystem.out.println(\"usage: \" + mainClass + \" [filename.cp]\");\n\t\tSystem.exit(1);\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\t\n\t\tString fname = null;\n\t\tString source = null;\n\t\ttry\n\t\t{\n\t\t\tfname = args[0];\n\t\t\tsource = new String(Files.readAllBytes(new File(fname).toPath()));\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tfatal_error(\"error while trying to read from specified file\");\n\t\t}\n\n\t\t\n\t\tArrayList<String> lines = new ArrayList<String>(Arrays.asList(source.split(\"\\n\")));\n\t\t\n\t\t\n\t\tString clipboard = \"\";\n\t\t\n\t\t\n\t\tint loc = 0;\n\t\twhile(loc < lines.size())\n\t\t{\n\t\t\t\n\t\t\tString command = lines.get(loc).trim();\n\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif(command.equals(\"Copy\"))\n\t\t\t\t\tclipboard += lines.get(loc + 1);\n\t\t\t\telse if(command.equals(\"CopyFile\"))\n\t\t\t\t{\n\t\t\t\t\tif(lines.get(loc + 1).equals(\"TheF*ckingCode\"))\n\t\t\t\t\t\tclipboard += source;\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tString filetext = new String(Files.readAllBytes(new File(lines.get(loc + 1)).toPath()));\n\t\t\t\t\t\tclipboard += filetext;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(command.equals(\"Duplicate\"))\n\t\t\t\t{\n\t\t\t\t\tString origClipboard = clipboard;\n\n\t\t\t\t\tint amount = Integer.parseInt(lines.get(loc + 1)) - 1;\n\t\t\t\t\tfor(int i = 0; i < amount; i++)\n\t\t\t\t\t\tclipboard += origClipboard;\n\t\t\t\t}\n\t\t\t\telse if(command.equals(\"Pasta!\"))\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(clipboard);\n\t\t\t\t\tSystem.exit(0);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfatal_error(\"unknown command '\" + command + \"' encountered on line \" + new Integer(loc + 1).toString());\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tfatal_error(\"error while executing command '\" + command + \"' on line \" + new Integer(loc + 1).toString());\n\t\t\t}\n\n\t\t\t\n\t\t\tloc += 2;\n\t\t}\n\t}\n}\n"}
{"id": 415796, "name": "B-spline", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Class::Struct;\nuse Cairo;\n\n{ package Line;\n    struct( A => '@', B => '@');\n}\n\nmy ($WIDTH,  $HEIGHT,  $W_LINE,  $CURVE_F,  $DETACHED,            $OUTPUT  ) =\n   (   400,      400,        2,      0.25,          0,  'run/b-spline.png' );\n\nmy @pt = (\n   [171, 171], [185, 111], [202, 109], [202, 189], [328, 160], [208, 254],\n   [241, 330], [164, 252], [ 69, 278], [139, 208], [ 72, 148], [168, 172]\n);\nmy $cnt = @pt;\n\nsub angle {\n    my($g) = @_;\n    atan2 $g->B->[1] - $g->A->[1], $g->B->[0] - $g->A->[0]\n}\n\nsub control_points {\n    my($g, $l) = @_;\n\n    my $h = Line->new;\n    my $lgt = sqrt( ($g->B->[0] - $l->A->[0])**2 + ($g->B->[1] - $l->A->[1])**2 );\n\n    @{$h->B} = @{$l->A};\n    @{$h->A} = ($g->B->[0] - $lgt * cos(angle $g) , $g->B->[1] - $lgt * sin(angle $g));\n    my $a    = angle $h;\n    my @p1   = ($g->B->[0] + $lgt * cos($a) * $CURVE_F,  $g->B->[1] + $lgt * sin($a) * $CURVE_F);\n\n    @{$h->A} = @{$g->B};\n    @{$h->B} = ($l->A->[0] + $lgt * cos(angle $l) , $l->A->[1] + $lgt * sin(angle $l));\n    $a       = angle $h;\n    my @p2   = ($l->A->[0] - $lgt * cos($a) * $CURVE_F,  $l->A->[1] - $lgt * sin($a) * $CURVE_F);\n\n    \\@p1, \\@p2\n}\n\nmy $surf = Cairo::ImageSurface->create ('argb32', $WIDTH, $HEIGHT);\nmy $cr   = Cairo::Context->create ($surf);\n$cr->set_line_width($W_LINE);\n$cr->move_to($pt[$DETACHED - 1 + $cnt][0], $pt[$DETACHED - 1 + $cnt][1]);\n\nmy Line ($g,$l);\nfor my $j ($DETACHED..$cnt-1) {\n    $g = Line->new( A=>$pt[($j + $cnt - 2) % $cnt], B=>$pt[($j + $cnt - 1) % $cnt]);\n    $l = Line->new( A=>$pt[($j + $cnt + 0) % $cnt], B=>$pt[($j + $cnt + 1) % $cnt]);\n    my($p1,$p2) = control_points($g, $l);\n    $cr->curve_to($$p1[0], $$p1[1], $$p2[0], $$p2[1], $pt[$j][0], $pt[$j][1]);\n}\n$cr->stroke;\n$surf->write_to_png($OUTPUT);\n", "target": "\n\nint abscissae[]={171,185,202,202,328,208,241,164,69,139,72,168};\nint ordinates[] = {171,111,109,189 ,160,254 ,330 ,252,278 ,208 ,148 ,172};\n\nvoid setup() {\n  size(450, 450);\n  background(255);\n  smooth();\n\n  noFill();\n  stroke(0);\n  \n  beginShape();\n  for(int i=0;i<abscissae.length;i++){\n    curveVertex(abscissae[i], ordinates[i]);\n  }\n  endShape();\n\n  fill(255, 0, 0);\n  noStroke();\n  for (int i = 0; i < abscissae.length; i ++) {\n    ellipse(abscissae[i], ordinates[i], 3, 3);\n  }\n}\n"}
{"id": 415797, "name": "B-spline", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Class::Struct;\nuse Cairo;\n\n{ package Line;\n    struct( A => '@', B => '@');\n}\n\nmy ($WIDTH,  $HEIGHT,  $W_LINE,  $CURVE_F,  $DETACHED,            $OUTPUT  ) =\n   (   400,      400,        2,      0.25,          0,  'run/b-spline.png' );\n\nmy @pt = (\n   [171, 171], [185, 111], [202, 109], [202, 189], [328, 160], [208, 254],\n   [241, 330], [164, 252], [ 69, 278], [139, 208], [ 72, 148], [168, 172]\n);\nmy $cnt = @pt;\n\nsub angle {\n    my($g) = @_;\n    atan2 $g->B->[1] - $g->A->[1], $g->B->[0] - $g->A->[0]\n}\n\nsub control_points {\n    my($g, $l) = @_;\n\n    my $h = Line->new;\n    my $lgt = sqrt( ($g->B->[0] - $l->A->[0])**2 + ($g->B->[1] - $l->A->[1])**2 );\n\n    @{$h->B} = @{$l->A};\n    @{$h->A} = ($g->B->[0] - $lgt * cos(angle $g) , $g->B->[1] - $lgt * sin(angle $g));\n    my $a    = angle $h;\n    my @p1   = ($g->B->[0] + $lgt * cos($a) * $CURVE_F,  $g->B->[1] + $lgt * sin($a) * $CURVE_F);\n\n    @{$h->A} = @{$g->B};\n    @{$h->B} = ($l->A->[0] + $lgt * cos(angle $l) , $l->A->[1] + $lgt * sin(angle $l));\n    $a       = angle $h;\n    my @p2   = ($l->A->[0] - $lgt * cos($a) * $CURVE_F,  $l->A->[1] - $lgt * sin($a) * $CURVE_F);\n\n    \\@p1, \\@p2\n}\n\nmy $surf = Cairo::ImageSurface->create ('argb32', $WIDTH, $HEIGHT);\nmy $cr   = Cairo::Context->create ($surf);\n$cr->set_line_width($W_LINE);\n$cr->move_to($pt[$DETACHED - 1 + $cnt][0], $pt[$DETACHED - 1 + $cnt][1]);\n\nmy Line ($g,$l);\nfor my $j ($DETACHED..$cnt-1) {\n    $g = Line->new( A=>$pt[($j + $cnt - 2) % $cnt], B=>$pt[($j + $cnt - 1) % $cnt]);\n    $l = Line->new( A=>$pt[($j + $cnt + 0) % $cnt], B=>$pt[($j + $cnt + 1) % $cnt]);\n    my($p1,$p2) = control_points($g, $l);\n    $cr->curve_to($$p1[0], $$p1[1], $$p2[0], $$p2[1], $pt[$j][0], $pt[$j][1]);\n}\n$cr->stroke;\n$surf->write_to_png($OUTPUT);\n", "target": "\n\nint abscissae[]={171,185,202,202,328,208,241,164,69,139,72,168};\nint ordinates[] = {171,111,109,189 ,160,254 ,330 ,252,278 ,208 ,148 ,172};\n\nvoid setup() {\n  size(450, 450);\n  background(255);\n  smooth();\n\n  noFill();\n  stroke(0);\n  \n  beginShape();\n  for(int i=0;i<abscissae.length;i++){\n    curveVertex(abscissae[i], ordinates[i]);\n  }\n  endShape();\n\n  fill(255, 0, 0);\n  noStroke();\n  for (int i = 0; i < abscissae.length; i ++) {\n    ellipse(abscissae[i], ordinates[i], 3, 3);\n  }\n}\n"}
{"id": 415798, "name": "Pentomino tiling", "source": "Translate Perl to Java: use strict; \nuse warnings;\nuse feature 'bitwise';\n\nmy $size = shift // 8;\n\nsub rotate\n  {\n  local $_ = shift;\n  my $ans = '';\n  $ans .= \"\\n\" while s/.$/$ans .= $&; ''/gem;\n  $ans;\n  }\n\nsub topattern\n  {\n  local $_ = shift;\n  s/.+/ $& . ' ' x ($size - length $&)/ge;\n  s/^\\s+|\\s+\\z//g;\n  [ tr/ \\nA-Z/.. /r, lc tr/ \\n/\\0/r, substr $_, 0, 1 ]; \n  }\n\nmy %all;\n@all{ \" FF\\nFF \\n F \\n\", \"IIIII\\n\", \"LLLL\\nL   \\n\", \"NNN \\n  NN\\n\",\n  \"PPP\\nPP \\n\", \"TTT\\n T \\n T \\n\", \"UUU\\nU U\\n\", \"VVV\\nV  \\nV  \\n\",\n  \"WW \\n WW\\n  W\\n\", \" X \\nXXX\\n X \\n\", \"YYYY\\n Y  \\n\", \"ZZ \\n Z \\n ZZ\\n\",\n  } = ();\n@all{map rotate($_), keys %all} = () for 1 .. 3;  \n@all{map s/.+/reverse $&/ger, keys %all} = ();    \nmy @all = map topattern($_), keys %all;\nmy $grid = ( ' ' x $size . \"\\n\" ) x $size;\nmy %used;\nfind( $grid );\n\n\nsub find\n  {\n  my $grid = shift;\n  %used >= 12 and exit not print $grid;\n  for ( grep ! $used{ $_->[2] }, @all )\n    {\n    my ($pattern, $pentomino, $letter) = @$_;\n    local $used{$letter} = 1;\n    $grid =~ /^[^ ]*\\K$pattern/s and find( $grid ^. \"\\0\" x $-[0] . $pentomino );\n    }\n  }\n", "target": "package pentominotiling;\n\nimport java.util.*;\n\npublic class PentominoTiling {\n\n    static final char[] symbols = \"FILNPTUVWXYZ-\".toCharArray();\n    static final Random rand = new Random();\n\n    static final int nRows = 8;\n    static final int nCols = 8;\n    static final int blank = 12;\n\n    static int[][] grid = new int[nRows][nCols];\n    static boolean[] placed = new boolean[symbols.length - 1];\n\n    public static void main(String[] args) {\n        shuffleShapes();\n\n        for (int r = 0; r < nRows; r++)\n            Arrays.fill(grid[r], -1);\n\n        for (int i = 0; i < 4; i++) {\n            int randRow, randCol;\n            do {\n                randRow = rand.nextInt(nRows);\n                randCol = rand.nextInt(nCols);\n            } while (grid[randRow][randCol] == blank);\n            grid[randRow][randCol] = blank;\n        }\n\n        if (solve(0, 0)) {\n            printResult();\n        } else {\n            System.out.println(\"no solution\");\n        }\n    }\n\n    static void shuffleShapes() {\n        int n = shapes.length;\n        while (n > 1) {\n            int r = rand.nextInt(n--);\n\n            int[][] tmp = shapes[r];\n            shapes[r] = shapes[n];\n            shapes[n] = tmp;\n\n            char tmpSymbol = symbols[r];\n            symbols[r] = symbols[n];\n            symbols[n] = tmpSymbol;\n        }\n    }\n\n    static void printResult() {\n        for (int[] r : grid) {\n            for (int i : r)\n                System.out.printf(\"%c \", symbols[i]);\n            System.out.println();\n        }\n    }\n\n    static boolean tryPlaceOrientation(int[] o, int r, int c, int shapeIndex) {\n\n        for (int i = 0; i < o.length; i += 2) {\n            int x = c + o[i + 1];\n            int y = r + o[i];\n            if (x < 0 || x >= nCols || y < 0 || y >= nRows || grid[y][x] != -1)\n                return false;\n        }\n\n        grid[r][c] = shapeIndex;\n        for (int i = 0; i < o.length; i += 2)\n            grid[r + o[i]][c + o[i + 1]] = shapeIndex;\n\n        return true;\n    }\n\n    static void removeOrientation(int[] o, int r, int c) {\n        grid[r][c] = -1;\n        for (int i = 0; i < o.length; i += 2)\n            grid[r + o[i]][c + o[i + 1]] = -1;\n    }\n\n    static boolean solve(int pos, int numPlaced) {\n        if (numPlaced == shapes.length)\n            return true;\n\n        int row = pos / nCols;\n        int col = pos % nCols;\n\n        if (grid[row][col] != -1)\n            return solve(pos + 1, numPlaced);\n\n        for (int i = 0; i < shapes.length; i++) {\n            if (!placed[i]) {\n                for (int[] orientation : shapes[i]) {\n\n                    if (!tryPlaceOrientation(orientation, row, col, i))\n                        continue;\n\n                    placed[i] = true;\n\n                    if (solve(pos + 1, numPlaced + 1))\n                        return true;\n\n                    removeOrientation(orientation, row, col);\n                    placed[i] = false;\n                }\n            }\n        }\n        return false;\n    }\n\n    static final int[][] F = {{1, -1, 1, 0, 1, 1, 2, 1}, {0, 1, 1, -1, 1, 0, 2, 0},\n    {1, 0, 1, 1, 1, 2, 2, 1}, {1, 0, 1, 1, 2, -1, 2, 0}, {1, -2, 1, -1, 1, 0, 2, -1},\n    {0, 1, 1, 1, 1, 2, 2, 1}, {1, -1, 1, 0, 1, 1, 2, -1}, {1, -1, 1, 0, 2, 0, 2, 1}};\n\n    static final int[][] I = {{0, 1, 0, 2, 0, 3, 0, 4}, {1, 0, 2, 0, 3, 0, 4, 0}};\n\n    static final int[][] L = {{1, 0, 1, 1, 1, 2, 1, 3}, {1, 0, 2, 0, 3, -1, 3, 0},\n    {0, 1, 0, 2, 0, 3, 1, 3}, {0, 1, 1, 0, 2, 0, 3, 0}, {0, 1, 1, 1, 2, 1, 3, 1},\n    {0, 1, 0, 2, 0, 3, 1, 0}, {1, 0, 2, 0, 3, 0, 3, 1}, {1, -3, 1, -2, 1, -1, 1, 0}};\n\n    static final int[][] N = {{0, 1, 1, -2, 1, -1, 1, 0}, {1, 0, 1, 1, 2, 1, 3, 1},\n    {0, 1, 0, 2, 1, -1, 1, 0}, {1, 0, 2, 0, 2, 1, 3, 1}, {0, 1, 1, 1, 1, 2, 1, 3},\n    {1, 0, 2, -1, 2, 0, 3, -1}, {0, 1, 0, 2, 1, 2, 1, 3}, {1, -1, 1, 0, 2, -1, 3, -1}};\n\n    static final int[][] P = {{0, 1, 1, 0, 1, 1, 2, 1}, {0, 1, 0, 2, 1, 0, 1, 1},\n    {1, 0, 1, 1, 2, 0, 2, 1}, {0, 1, 1, -1, 1, 0, 1, 1}, {0, 1, 1, 0, 1, 1, 1, 2},\n    {1, -1, 1, 0, 2, -1, 2, 0}, {0, 1, 0, 2, 1, 1, 1, 2}, {0, 1, 1, 0, 1, 1, 2, 0}};\n\n    static final int[][] T = {{0, 1, 0, 2, 1, 1, 2, 1}, {1, -2, 1, -1, 1, 0, 2, 0},\n    {1, 0, 2, -1, 2, 0, 2, 1}, {1, 0, 1, 1, 1, 2, 2, 0}};\n\n    static final int[][] U = {{0, 1, 0, 2, 1, 0, 1, 2}, {0, 1, 1, 1, 2, 0, 2, 1},\n    {0, 2, 1, 0, 1, 1, 1, 2}, {0, 1, 1, 0, 2, 0, 2, 1}};\n\n    static final int[][] V = {{1, 0, 2, 0, 2, 1, 2, 2}, {0, 1, 0, 2, 1, 0, 2, 0},\n    {1, 0, 2, -2, 2, -1, 2, 0}, {0, 1, 0, 2, 1, 2, 2, 2}};\n\n    static final int[][] W = {{1, 0, 1, 1, 2, 1, 2, 2}, {1, -1, 1, 0, 2, -2, 2, -1},\n    {0, 1, 1, 1, 1, 2, 2, 2}, {0, 1, 1, -1, 1, 0, 2, -1}};\n\n    static final int[][] X = {{1, -1, 1, 0, 1, 1, 2, 0}};\n\n    static final int[][] Y = {{1, -2, 1, -1, 1, 0, 1, 1}, {1, -1, 1, 0, 2, 0, 3, 0},\n    {0, 1, 0, 2, 0, 3, 1, 1}, {1, 0, 2, 0, 2, 1, 3, 0}, {0, 1, 0, 2, 0, 3, 1, 2},\n    {1, 0, 1, 1, 2, 0, 3, 0}, {1, -1, 1, 0, 1, 1, 1, 2}, {1, 0, 2, -1, 2, 0, 3, 0}};\n\n    static final int[][] Z = {{0, 1, 1, 0, 2, -1, 2, 0}, {1, 0, 1, 1, 1, 2, 2, 2},\n    {0, 1, 1, 1, 2, 1, 2, 2}, {1, -2, 1, -1, 1, 0, 2, -2}};\n\n    static final int[][][] shapes = {F, I, L, N, P, T, U, V, W, X, Y, Z};\n}\n"}

{"id": 333466, "name": "Range consolidation", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse List::Util qw(min max);\n\nsub consolidate {\n    our @arr; local *arr = shift;\n    my @sorted = sort { @$a[0] <=> @$b[0] } map { [sort { $a <=> $b } @$_] } @arr;\n    my @merge = shift @sorted;\n    for my $i (@sorted) {\n        if ($merge[-1][1] >= @$i[0]) {\n            $merge[-1][0] = min($merge[-1][0], @$i[0]);\n            $merge[-1][1] = max($merge[-1][1], @$i[1]);\n        } else {\n            push @merge, $i;\n        }\n    }\n    return @merge;\n}\n\nfor my $intervals (\n    [[1.1, 2.2],],\n    [[6.1, 7.2], [7.2, 8.3]],\n    [[4, 3], [2, 1]],\n    [[4, 3], [2, 1], [-1, -2], [3.9, 10]],\n    [[1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]]) {\n        my($in,$out);\n        $in   = join ', ', map { '[' . join(', ', @$_) . ']' } @$intervals;\n        $out .= join('..', @$_). ' ' for consolidate($intervals);\n        printf \"%44s => %s\\n\", $in, $out;\n}\n", "target": "def normalize(s):\n    return sorted(sorted(bounds) for bounds in s if bounds)\n\ndef consolidate(ranges):\n    norm = normalize(ranges)\n    for i, r1 in enumerate(norm):\n        if r1:\n            for r2 in norm[i+1:]:\n                if r2 and r1[-1] >= r2[0]:     \n                    r1[:] = [r1[0], max(r1[-1], r2[-1])]\n                    r2.clear()\n    return [rnge for rnge in norm if rnge]\n\nif __name__ == '__main__':\n    for s in [\n            [[1.1, 2.2]],\n            [[6.1, 7.2], [7.2, 8.3]],\n            [[4, 3], [2, 1]],\n            [[4, 3], [2, 1], [-1, -2], [3.9, 10]],\n            [[1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]],\n            ]:\n        print(f\"{str(s)[1:-1]} => {str(consolidate(s))[1:-1]}\")\n"}
{"id": 333467, "name": "Pascal matrix generation", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\nuse feature qw{ say };\n\n\nsub upper {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = $x > $y          ? 0\n                       : ! $x || $x == $y ? 1\n                                          : $m[$x-1][$y-1] + $m[$x][$y-1];\n        }\n    }\n    return \\@m\n}\n\n\nsub lower {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = $x < $y          ? 0\n                       : ! $x || $x == $y ? 1\n                                          : $m[$x-1][$y-1] + $m[$x-1][$y];\n        }\n    }\n    return \\@m\n}\n\n\nsub symmetric {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = ! $x || ! $y ? 1\n                                      : $m[$x-1][$y] + $m[$x][$y-1];\n        }\n    }\n    return \\@m\n}\n\n\nsub pretty {\n    my $m = shift;\n    for my $row (@$m) {\n        say join ', ', @$row;\n    }\n}\n\n\npretty(upper(5, 5));\nsay '-' x 14;\npretty(lower(5, 5));\nsay '-' x 14;\npretty(symmetric(5, 5));\n", "target": "from pprint import pprint as pp\n\ndef pascal_upp(n):\n    s = [[0] * n for _ in range(n)]\n    s[0] = [1] * n\n    for i in range(1, n):\n        for j in range(i, n):\n            s[i][j] = s[i-1][j-1] + s[i][j-1]\n    return s\n\ndef pascal_low(n):\n    \n    return [list(x) for x in zip(*pascal_upp(n))]\n\ndef pascal_sym(n):\n    s = [[1] * n for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, n):\n            s[i][j] = s[i-1][j] + s[i][j-1]\n    return s\n    \n\nif __name__ == \"__main__\":\n    n = 5\n    print(\"\\nUpper:\")\n    pp(pascal_upp(n))\n    print(\"\\nLower:\")\n    pp(pascal_low(n))\n    print(\"\\nSymmetric:\")\n    pp(pascal_sym(n))\n"}
{"id": 333468, "name": "Mad Libs", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\n\nmy $template = shift;\nopen my $IN, '<', $template or die $!;\nmy $story = do { local $/ ; <$IN> };\n\nmy %blanks;\nundef $blanks{$_} for $story =~ m/<(.*?)>/g;\n\nfor my $blank (sort keys %blanks) {\n    print \"$blank: \";\n    chomp (my $replacement = <>);\n    $blanks{$blank} = $replacement;\n}\n\n$story =~ s/<(.*?)>/$blanks{$1}/g;\nprint $story;\n", "target": "import re\n\n\n\n\n\ntemplate = \n\ndef madlibs(template):\n    print('The story template is:\\n' + template)\n    fields = sorted(set( re.findall('<[^>]+>', template) ))\n    values = input('\\nInput a comma-separated list of words to replace the following items'\n                   '\\n  %s: ' % ','.join(fields)).split(',')\n    story = template\n    for f,v in zip(fields, values):\n        story = story.replace(f, v)\n    print('\\nThe story becomes:\\n\\n' + story)\n\nmadlibs(template)\n"}
{"id": 333469, "name": "Shortest common supersequence", "source": "Translate Perl to Python: sub lcs { \n    my( $u, $v ) = @_;\n    return '' unless length($u) and length($v);\n    my $longest = '';\n    for my $first ( 0..length($u)-1 ) {\n        my $char = substr $u, $first, 1;\n        my $i = index( $v, $char );\n        next if -1==$i;\n        my $next = $char;\n        $next .= lcs( substr( $u, $first+1), substr( $v, $i+1 ) ) unless $i==length($v)-1;\n        $longest = $next if length($next) > length($longest);\n    }\n    return $longest;\n}\n\nsub scs { \n    my( $u, $v ) = @_;\n    my @lcs = split //, lcs $u, $v;\n    my $pat = \"(.*)\".join(\"(.*)\",@lcs).\"(.*)\"; \n    my @u = $u =~ /$pat/;\n    my @v = $v =~ /$pat/;\n    my $scs = shift(@u).shift(@v);\n    $scs .= $_.shift(@u).shift(@v) for @lcs;\n    return $scs;\n}\n\nmy $u = \"abcbdab\";\nmy $v = \"bdcaba\";\nprintf \"Strings %s %s\\n\", $u, $v;\nprintf \"Longest common subsequence:   %s\\n\", lcs $u, $v;\nprintf \"Shortest common supersquence: %s\\n\", scs $u, $v;\n", "target": "\n\ndef shortest_common_supersequence(a, b):\n    lcs = longest_common_subsequence(a, b)\n    scs = \"\"\n    \n    while len(lcs) > 0:\n        if a[0]==lcs[0] and b[0]==lcs[0]:\n        \n            scs += lcs[0]\n            lcs = lcs[1:]\n            a = a[1:]\n            b = b[1:]\n        elif a[0]==lcs[0]:\n            scs += b[0]\n            b = b[1:]\n        else:\n            scs += a[0]\n            a = a[1:]\n    \n    return scs + a + b\n"}
{"id": 333470, "name": "Long year", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse DateTime;\n\nfor my $century (19 .. 21) {\n  for my $year ($century*100 .. ++$century*100 - 1) {\n    print \"$year \" if DateTime->new(year => $year, month => 12, day => 28)->week_number > 52\n  }\n  print \"\\n\";\n}\n", "target": "\n\nfrom datetime import date\n\n\n\ndef longYear(y):\n    \n    return 52 < date(y, 12, 28).isocalendar()[1]\n\n\n\n\ndef main():\n    \n    for year in [\n            x for x in range(2000, 1 + 2100)\n            if longYear(x)\n    ]:\n        print(year)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333471, "name": "Mian-Chowla sequence", "source": "Translate Perl to Python: use strict; \nuse warnings;\nuse feature 'say';\n\nsub generate_mc {\n    my($max)  = @_;\n    my $index = 0;\n    my $test  = 1;\n    my %sums  = (2 => 1);\n    my @mc    = 1;\n    while ($test++) {\n        my %these = %sums;\n        map { next if ++$these{$_ + $test} > 1 } @mc[0..$index], $test;\n        %sums = %these;\n        $index++;\n        return @mc if (push @mc, $test) > $max-1;\n    }\n}\n\nmy @mian_chowla = generate_mc(100);\nsay \"First 30 terms in the Mian\u2013Chowla sequence:\\n\", join(' ', @mian_chowla[ 0..29]),\n    \"\\nTerms 91 through 100:\\n\",                     join(' ', @mian_chowla[90..99]);\n", "target": "from itertools import count, islice, chain\nimport time\n\ndef mian_chowla():\n    mc = [1]\n    yield mc[-1]\n    psums = set([2])\n    newsums = set([])\n    for trial in count(2):\n        for n in chain(mc, [trial]):\n            sum = n + trial\n            if sum in psums:\n                newsums.clear()\n                break\n            newsums.add(sum)\n        else:\n            psums |= newsums\n            newsums.clear()\n            mc.append(trial)\n            yield trial\n\ndef pretty(p, t, s, f):\n    print(p, t, \" \".join(str(n) for n in (islice(mian_chowla(), s, f))))\n\nif __name__ == '__main__':\n    st = time.time()\n    ts = \"of the Mian-Chowla sequence are:\\n\"\n    pretty(\"The first 30 terms\", ts, 0, 30)\n    pretty(\"\\nTerms 91 to 100\", ts, 90, 100)\n    print(\"\\nComputation time was\", (time.time()-st) * 1000, \"ms\")\n"}
{"id": 333472, "name": "Water collected between towers", "source": "Translate Perl to Python: use Modern::Perl;\nuse List::Util qw{ min max sum };\n\nsub water_collected {\n    my @t = map { { TOWER => $_, LEFT => 0, RIGHT => 0, LEVEL => 0 } } @_;\n\n    my ( $l, $r ) = ( 0, 0 );\n    $_->{LEFT}  = ( $l = max( $l, $_->{TOWER} ) ) for @t;\n    $_->{RIGHT} = ( $r = max( $r, $_->{TOWER} ) ) for reverse @t;\n    $_->{LEVEL} = min( $_->{LEFT}, $_->{RIGHT} )  for @t;\n\n    return sum map { $_->{LEVEL} > 0 ? $_->{LEVEL} - $_->{TOWER} : 0 } @t;\n}\n\nsay join ' ', map { water_collected( @{$_} ) } (\n    [ 1, 5,  3, 7, 2 ],\n    [ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ],\n    [ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ],\n    [ 5, 5,  5, 5 ],\n    [ 5, 6,  7, 8 ],\n    [ 8, 7,  7, 6 ],\n    [ 6, 7, 10, 7, 6 ],\n);\n", "target": "def water_collected(tower):\n    N = len(tower)\n    highest_left = [0] + [max(tower[:n]) for n in range(1,N)]\n    highest_right = [max(tower[n:N]) for n in range(1,N)] + [0]\n    water_level = [max(min(highest_left[n], highest_right[n]) - tower[n], 0)\n        for n in range(N)]\n    print(\"highest_left:  \", highest_left)\n    print(\"highest_right: \", highest_right)\n    print(\"water_level:   \", water_level)\n    print(\"tower_level:   \", tower)\n    print(\"total_water:   \", sum(water_level))\n    print(\"\")\n    return sum(water_level)\n\ntowers = [[1, 5, 3, 7, 2],\n    [5, 3, 7, 2, 6, 4, 5, 9, 1, 2],\n    [2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1],\n    [5, 5, 5, 5],\n    [5, 6, 7, 8],\n    [8, 7, 7, 6],\n    [6, 7, 10, 7, 6]]\n\n[water_collected(tower) for tower in towers]\n"}
{"id": 333473, "name": "FASTA format", "source": "Translate Perl to Python: my $fasta_example = <<'END_FASTA_EXAMPLE';\n>Rosetta_Example_1\nTHERECANBENOSPACE\n>Rosetta_Example_2\nTHERECANBESEVERAL\nLINESBUTTHEYALLMUST\nBECONCATENATED\nEND_FASTA_EXAMPLE\n\nmy $num_newlines = 0;\nwhile ( < $fasta_example > ) {\n\tif (/\\A\\>(.*)/) {\n\t\tprint \"\\n\" x $num_newlines, $1, ': ';\n\t}\n\telse {\n\t\t$num_newlines = 1;\n\t\tprint;\n\t}\n}\n", "target": "import io\n\nFASTA=\n\ninfile = io.StringIO(FASTA)\n\ndef fasta_parse(infile):\n    key = ''\n    for line in infile:\n        if line.startswith('>'):\n            if key:\n                yield key, val\n            key, val = line[1:].rstrip().split()[0], ''\n        elif key:\n            val += line.rstrip()\n    if key:\n        yield key, val\n\nprint('\\n'.join('%s: %s' % keyval for keyval in fasta_parse(infile)))\n"}
{"id": 333474, "name": "MAC vendor lookup", "source": "Translate Perl to Python: \nuse v5.18.2;\nuse warnings;\nuse LWP;\nuse Time::HiRes qw(sleep);\n\nour $VERSION = 1.000_000;\n\nmy $ua = LWP::UserAgent->new;\n\nno warnings 'qw';\nmy @macs = qw(\n    FC-A1-3EFC:FB:FB:01:FA:21 00,0d,4b\n    Rhubarb                   00-14-22-01-23-45\n    10:dd:b1                  D4:F4:6F:C9:EF:8D\n    FC-A1-3E                  88:53:2E:67:07:BE\n    23:45:67                  FC:FB:FB:01:FA:21\n    BC:5F:F4\n);\n\nwhile (my $mac = shift @macs) {\n    my $vendor = get_mac_vendor($mac);\n    if ($vendor) {\n        say \"$mac = $vendor\";\n    }\n    sleep 1.5 if @macs;\n}\n\nsub get_mac_vendor {\n    my $s = shift;\n\n    my $req = HTTP::Request->new( GET => \"http://api.macvendors.com/$s\" );\n    my $res = $ua->request($req);\n\n    \n    \n    if ( $res->is_error ) {\n        return;\n    }\n\n    \n    \n    if (  !$res->content\n        or $res->content eq 'Vendor not found' )\n    {\n        return 'N/A';\n    }\n\n    return $res->content;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "target": "import requests\n\nfor addr in ['88:53:2E:67:07:BE', 'FC:FB:FB:01:FA:21',\n        'D4:F4:6F:C9:EF:8D', '23:45:67']:\n    vendor = requests.get('http://api.macvendors.com/' + addr).text\n    print(addr, vendor)\n"}
{"id": 333475, "name": "Magic 8-ball", "source": "Translate Perl to Python: @a = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',\n 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',\n 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',\n 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',\n \"Don't bet on it\", 'My reply is no', 'My sources say no', 'Outlook not so good',\n 'Very doubtful');\n\nwhile () {\n    print 'Enter your question:';\n    last unless <> =~ /\\w/;\n    print @a[int rand @a], \"\\n\";\n}\n", "target": "import random\n\ns = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',\n 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',\n 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',\n 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',\n \"Don't bet on it\", 'My reply is no', 'My sources say no', 'Outlook not so good',\n 'Very doubtful')\n\nq_and_a = {}\n\nwhile True:\n    question = input('Ask your question:')\n    if len(question) == 0: break\n        \n    if question in q_and_a:\n        print('Your question has already been answered')\n    else:\n        answer = random.choice(s)\n        q_and_a[question] = answer\n        print(answer)\n"}
{"id": 333476, "name": "Validate International Securities Identification Number", "source": "Translate Perl to Python: use strict;\nuse English;\nuse POSIX;\nuse Test::Simple tests => 7;\n\nok(   validate_isin('US0378331005'),  'Test 1');\t\nok( ! validate_isin('US0373831005'),  'Test 2');\nok( ! validate_isin('U50378331005'),  'Test 3');\nok( ! validate_isin('US03378331005'), 'Test 4');\nok(   validate_isin('AU0000XVGZA3'),  'Test 5');\t\nok(   validate_isin('AU0000VXGZA3'),  'Test 6');\nok(   validate_isin('FR0000988040'),  'Test 7');\t\nexit 0;\n\nsub validate_isin {\n    my $isin = shift;\n    $isin =~ /\\A[A-Z]{2}[A-Z\\d]{9}\\d\\z/s or return 0;\n    my $base10 = join(q{}, map {scalar(POSIX::strtol($ARG, 36))}\n                               split(//s, $isin));\n    return luhn_test($base10);\n}\n", "target": "def check_isin(a):\n    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):\n        return False\n    s = \"\".join(str(int(c, 36)) for c in a)\n    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +\n                 sum(ord(c) - 48 for c in s[::-2])) % 10\n\n\ndef check_isin_alt(a):\n    if len(a) != 12:\n        return False\n    s = []\n    for i, c in enumerate(a):\n        if c.isdigit():\n            if i < 2:\n                return False\n            s.append(ord(c) - 48)\n        elif c.isupper():\n            if i == 11:\n                return False\n            s += divmod(ord(c) - 55, 10)\n        else:\n            return False\n    v = sum(s[::-2])\n    for k in s[-2::-2]:\n        k = 2 * k\n        v += k - 9 if k > 9 else k\n    return v % 10 == 0\n\n[check_isin(s) for s in [\"US0378331005\", \"US0373831005\", \"U50378331005\", \"US03378331005\",\n                         \"AU0000XVGZA3\", \"AU0000VXGZA3\", \"FR0000988040\"]]\n\n\n"}
{"id": 333477, "name": "Orbital elements", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::Vector::Real;\n\nsub orbital_state_vectors {\n    my (\n        $semimajor_axis,\n        $eccentricity,\n        $inclination,\n        $longitude_of_ascending_node,\n        $argument_of_periapsis,\n        $true_anomaly\n    ) = @_[0..5];\n\n    my ($i, $j, $k) = (V(1,0,0), V(0,1,0), V(0,0,1));\n    \n    sub rotate {\n        my $alpha = shift;\n        @_[0,1] = (\n            +cos($alpha)*$_[0] + sin($alpha)*$_[1],\n            -sin($alpha)*$_[0] + cos($alpha)*$_[1]\n        );\n    }\n\n    rotate $longitude_of_ascending_node, $i, $j;\n    rotate $inclination,                 $j, $k;\n    rotate $argument_of_periapsis,       $i, $j;\n\n    my $l = $eccentricity == 1 ? \n        2*$semimajor_axis :\n        $semimajor_axis*(1 - $eccentricity**2);\n\n    my ($c, $s) = (cos($true_anomaly), sin($true_anomaly));\n\n    my $r = $l/(1 + $eccentricity*$c);\n    my $rprime = $s*$r**2/$l;\n\n    my $position = $r*($c*$i + $s*$j);\n\n    my $speed = \n    ($rprime*$c - $r*$s)*$i + ($rprime*$s + $r*$c)*$j;\n    $speed /= abs($speed);\n    $speed *= sqrt(2/$r - 1/$semimajor_axis);\n\n    {\n        position => $position,\n        speed    => $speed\n    }\n}\n\nuse Data::Dumper;\n\nprint Dumper orbital_state_vectors\n    1,                             \n    0.1,                           \n    0,                             \n    355/113/6,                     \n    0,                             \n    0                              \n    ;\n", "target": "import math\n\nclass Vector:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\n    def __add__(self, other):\n        return Vector(self.x + other.x, self.y + other.y, self.z + other.z)\n\n    def __mul__(self, other):\n        return Vector(self.x * other, self.y * other, self.z * other)\n\n    def __div__(self, other):\n        return Vector(self.x / other, self.y / other, self.z / other)\n\n    def __str__(self):\n        return '({x}, {y}, {z})'.format(x=self.x, y=self.y, z=self.z)\n\n    def abs(self):\n        return math.sqrt(self.x*self.x + self.y*self.y + self.z*self.z)\n\ndef mulAdd(v1, x1, v2, x2):\n    return v1 * x1 + v2 * x2\n\ndef rotate(i, j, alpha):\n    return [mulAdd(i,math.cos(alpha),j,math.sin(alpha)), mulAdd(i,-math.sin(alpha),j,math.cos(alpha))]\n\ndef orbitalStateVectors(semimajorAxis, eccentricity, inclination, longitudeOfAscendingNode, argumentOfPeriapsis, trueAnomaly):\n    i = Vector(1, 0, 0)\n    j = Vector(0, 1, 0)\n    k = Vector(0, 0, 1)\n\n    p = rotate(i, j, longitudeOfAscendingNode)\n    i = p[0]\n    j = p[1]\n    p = rotate(j, k, inclination)\n    j = p[0]\n    p  =rotate(i, j, argumentOfPeriapsis)\n    i = p[0]\n    j = p[1]\n\n    l = 2.0 if (eccentricity == 1.0) else 1.0 - eccentricity * eccentricity\n    l *= semimajorAxis\n    c = math.cos(trueAnomaly)\n    s = math.sin(trueAnomaly)\n    r = 1 / (1.0 + eccentricity * c)\n    rprime = s * r * r / l\n    position = mulAdd(i, c, j, s) * r\n    speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c)\n    speed = speed / speed.abs()\n    speed = speed * math.sqrt(2.0 / r - 1.0 / semimajorAxis)\n\n    return [position, speed]\n\nps = orbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0)\nprint \"Position\u00a0:\", ps[0]\nprint \"Speed   \u00a0:\", ps[1]\n"}
{"id": 333478, "name": "Cycle detection", "source": "Translate Perl to Python: use utf8;\n\nsub cyclical_function { ($_[0] * $_[0] + 1) % 255 }\n\nsub brent {\n    my($f, $x0) = @_;\n    my $power = 1;\n    my $\u03bb = 1;\n    my $tortoise = $x0;\n    my $hare = &$f($x0);\n    while ($tortoise != $hare) {\n        if ($power == $\u03bb) {\n            $tortoise = $hare;\n            $power *= 2;\n            $\u03bb = 0;\n        }\n        $hare = &$f($hare);\n        $\u03bb += 1;\n    }\n\n    my $\u03bc = 0;\n    $tortoise = $hare = $x0;\n    $hare = &$f($hare) for 0..$\u03bb-1;\n\n    while ($tortoise != $hare) {\n        $tortoise = &$f($tortoise);\n        $hare = &$f($hare);\n        $\u03bc += 1;\n    }\n    return $\u03bb, $\u03bc;\n}\n\nmy ( $l, $s ) = brent( \\&cyclical_function, 3 );\n\nsub show_range {\n    my($start,$stop) = @_;\n    my $result;\n    my $x = 3;\n    for my $n (0..$stop) {\n        $result .= \"$x \" if $n >= $start;\n        $x = cyclical_function($x);\n    }\n    $result;\n}\n\nprint show_range(0,19) . \"\\n\";\nprint \"Cycle length $l\\n\";\nprint \"Cycle start index $s\\n\";\nprint show_range($s,$s+$l-1) . \"\\n\";\n", "target": "import itertools\n\ndef brent(f, x0):\n    \n    power = lam = 1\n    tortoise = x0\n    hare = f(x0)  \n    while tortoise != hare:\n        if power == lam:  \n            tortoise = hare\n            power *= 2\n            lam = 0\n        hare = f(hare)\n        lam += 1\n\n    \n    mu = 0\n    tortoise = hare = x0\n    for i in range(lam):\n    \n        hare = f(hare)\n    \n\n    \n    while tortoise != hare:\n        tortoise = f(tortoise)\n        hare = f(hare)\n        mu += 1\n \n    return lam, mu\n\ndef iterate(f, x0):\n    while True:\n        yield x0\n        x0 = f(x0)\n\nif __name__ == '__main__':\n    f = lambda x: (x * x + 1) % 255\n    x0 = 3\n    lam, mu = brent(f, x0)\n    print(\"Cycle length: %d\" % lam)\n    print(\"Cycle start index: %d\" % mu)\n    print(\"Cycle: %s\" % list(itertools.islice(iterate(f, x0), mu, mu+lam)))\n"}
{"id": 333479, "name": "Input_Output for pairs of numbers", "source": "Translate Perl to Python: $n = scalar <>;\n\nfor (1..$n) {\n    ($a,$b) = split ' ', <>;\n    print $a + $b . \"\\n\";\n}\n", "target": "def do_stuff(a, b):\n\treturn a + b\n\nt = input()\nfor x in range(0, t):\n\ta, b = raw_input().strip().split()\n\tprint do_stuff(int(a), int(b))\n"}
{"id": 333480, "name": "Kahan summation", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub kahan {\n    my(@nums) = @_;\n    my $summ = my $c = 0e0;\n    for my $num (@nums) {\n        my $y = $num - $c;\n        my $t = $summ + $y;\n        $c = ($t - $summ) - $y;\n        $summ = $t;\n    }\n    $summ\n}\n\nmy $eps = 1;\ndo { $eps /= 2 } until 1e0 == 1e0 + $eps;\n\nsay 'Epsilon:    ' . $eps;\nsay 'Simple sum: ' . sprintf \"%.16f\", ((1e0 + $eps) - $eps);\nsay 'Kahan sum:  ' . sprintf \"%.16f\", kahan(1e0, $eps, -$eps);\n", "target": "epsilon = 1.0\nwhile 1.0 + epsilon != 1.0:\n    epsilon = epsilon / 2.0\n"}
{"id": 333481, "name": "ABC words", "source": "Translate Perl to Python: \n\n@ARGV = 'unixdict.txt';\nprint grep /^[^bc]*a[^c]*b.*c/, <>;\n", "target": "python -c '\nimport sys\nfor ln in sys.stdin:\n    if \"a\" in ln and ln.find(\"a\") < ln.find(\"b\") < ln.find(\"c\"):\n        print(ln.rstrip())\n' < unixdict.txt\n"}
{"id": 333482, "name": "Text between", "source": "Translate Perl to Python: use feature 'say';\n\nsub text_between {\n    my($text, $start, $end) = @_;\n    return join ',', $text =~ /$start(.*?)$end/g;\n}\n\n$text = 'Hello Rosetta Code world';\n\n\nsay '1> '. text_between($text,  'Hello ', ' world' );\n\n\nsay '2> '. text_between($text,  qr/^/, ' world' );\n\n\nsay '3> '. text_between($text,  'Hello ',  qr/$/ );\n\n\nsay '4> '. text_between('</div><div style=\"chinese\">\u4f60\u597d\u55ce</div>', '<div style=\"chinese\">', '</div>' );\n\n\nsay '5> '. text_between('<text>Hello <span>Rosetta Code</span> world</text><table style=\"myTable\">', '<text>', qr/<table>|$/ );\n\n\nsay '6> '. text_between('<table style=\"myTable\"><tr><td>hello world</td></tr></table>', '<table>', '</table>' );\n\n\nsay '7> '. text_between( 'The quick brown fox jumps over the lazy other fox', 'quick ', ' fox' );\n\n\nsay '8> '. text_between( 'One fish two fish red fish blue fish', 'fish ', ' red' );\n\n\nsay '9> '. text_between('FooBarBazFooBuxQuux', 'Foo', 'Foo' );\n\n\nsay '10> '. text_between( $text, 'e', 'o' );\n\n\n$text = 'Soothe a guilty conscience today, string wrangling is not the best tool to use for this job.';\nsay '11> '.  text_between($text, qr/\\bthe /, qr/ to\\b/);\n", "target": "\nfrom sys import argv\n\n\n\n\n\n\ndef textBetween( thisText, startString, endString ):\n    try:\n    \tif startString is 'start':\n    \t\tstartIndex = 0\n    \telse:\n    \t\tstartIndex = thisText.index( startString ) \n    \t\n    \tif not (startIndex >= 0):\n    \t\treturn 'Start delimiter not found'\n    \telse:\n        \tif startString is not 'start':\n        \t\tstartIndex = startIndex + len( startString )\n        \n        returnText = thisText[startIndex:]\n\n\n    \tif endString is 'end':\n    \t\treturn returnText\n    \telse:\n    \t\tendIndex = returnText.index( endString )\n\n    \tif not (endIndex >= 0):\n    \t\treturn 'End delimiter not found'\n    \telse:\n        \treturnText = returnText[:endIndex]\n\n        return returnText\n    except ValueError:\n        return \"Value error\"\n\nscript, first, second, third = argv\n\nthisText = first\nstartString = second\nendString = third\n\nprint textBetween( thisText, startString, endString )\n"}
{"id": 333483, "name": "Two identical strings", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nwhile( 1 )\n  {\n  my $binary = ( sprintf \"%b\", ++$- ) x 2;\n  (my $decimal = oct \"b$binary\") >= 1000 and last;\n  printf \"%4d  %s\\n\", $decimal, $binary;\n  }\n", "target": "def bits(n):\n    \n    r = 0\n    while n:\n        n >>= 1\n        r += 1\n    return r\n    \ndef concat(n):\n    \n    return n << bits(n) | n\n    \nn = 1\nwhile concat(n) <= 1000:\n    print(\"{0}: {0:b}\".format(concat(n)))\n    n += 1\n"}
{"id": 333484, "name": "Sum of first n cubes", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy $sum = 0;\nprintf \"%10d%s\", $sum += $_ ** 3, $_ % 5 == 4 && \"\\n\" for 0 .. 49;\n", "target": "def main():\n    fila = 0\n    lenCubos = 51\n\n    print(\"Suma de N cubos para n = [0..49]\\n\")\n\n    for n in range(1, lenCubos):\n        sumCubos = 0\n        for m in range(1, n):\n            sumCubos = sumCubos + (m ** 3)\n            \n        fila += 1\n        print(f'{sumCubos:7} ', end='')\n        if fila % 5 == 0:\n            print(\" \")\n\n    print(f\"\\nEncontrados {fila} cubos.\")\n\nif __name__ == '__main__': main()\n"}
{"id": 333485, "name": "Pentagram", "source": "Translate Perl to Python: use SVG;\n\nmy $tau   = 2 * 4*atan2(1, 1);\nmy $dim   = 200;\nmy $sides = 5;\n\nfor $v (0, 2, 4, 1, 3, 0) {\n    push @vx, 0.9 * $dim * cos($tau * $v / $sides);\n    push @vy, 0.9 * $dim * sin($tau * $v / $sides);\n}\n\nmy $svg= SVG->new( width => 2*$dim, height => 2*$dim);\n\nmy $points = $svg->get_path(\n    x     => \\@vx,\n    y     => \\@vy,\n    -type => 'polyline',\n);\n\n$svg->rect (\n    width  => \"100%\",\n    height => \"100%\",\n    style  => {\n        'fill' => 'bisque'\n    }\n);\n\n$svg->polyline (\n    %$points,\n    style => {\n        'fill'         => 'seashell',\n        'stroke'       => 'blue',\n        'stroke-width' => 3,\n    },\n    transform => \"translate($dim,$dim) rotate(-18)\"\n);\n\nopen  $fh, '>', 'pentagram.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import turtle\n\nturtle.bgcolor(\"green\")\nt = turtle.Turtle()\nt.color(\"red\", \"blue\")\nt.begin_fill()\nfor i in range(0, 5):\n    t.forward(200)\n    t.right(144)\nt.end_fill()\n"}
{"id": 333486, "name": "Pentagram", "source": "Translate Perl to Python: use SVG;\n\nmy $tau   = 2 * 4*atan2(1, 1);\nmy $dim   = 200;\nmy $sides = 5;\n\nfor $v (0, 2, 4, 1, 3, 0) {\n    push @vx, 0.9 * $dim * cos($tau * $v / $sides);\n    push @vy, 0.9 * $dim * sin($tau * $v / $sides);\n}\n\nmy $svg= SVG->new( width => 2*$dim, height => 2*$dim);\n\nmy $points = $svg->get_path(\n    x     => \\@vx,\n    y     => \\@vy,\n    -type => 'polyline',\n);\n\n$svg->rect (\n    width  => \"100%\",\n    height => \"100%\",\n    style  => {\n        'fill' => 'bisque'\n    }\n);\n\n$svg->polyline (\n    %$points,\n    style => {\n        'fill'         => 'seashell',\n        'stroke'       => 'blue',\n        'stroke-width' => 3,\n    },\n    transform => \"translate($dim,$dim) rotate(-18)\"\n);\n\nopen  $fh, '>', 'pentagram.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import turtle\n\nturtle.bgcolor(\"green\")\nt = turtle.Turtle()\nt.color(\"red\", \"blue\")\nt.begin_fill()\nfor i in range(0, 5):\n    t.forward(200)\n    t.right(144)\nt.end_fill()\n"}
{"id": 333487, "name": "Median filter", "source": "Translate Perl to Python: use strict 'vars';\nuse warnings;\n\nuse PDL;\nuse PDL::Image2D;\n\nmy $image = rpic 'plasma.png';\nmy $smoothed = med2d $image, ones(3,3), {Boundary => Truncate};\nwpic $smoothed, 'plasma_median.png';\n", "target": "import Image, ImageFilter\nim = Image.open('image.ppm')\n\nmedian = im.filter(ImageFilter.MedianFilter(3))\nmedian.save('image2.ppm')\n"}
{"id": 333488, "name": "Verify distribution uniformity_Chi-squared test", "source": "Translate Perl to Python: use List::Util qw(sum reduce);\nuse constant pi => 3.14159265;\n\nsub incomplete_G_series {\n    my($s, $z) = @_;\n    my $n = 10;\n    push @numers, $z**$_ for 1..$n;\n    my @denoms = $s+1;\n    push @denoms, $denoms[-1]*($s+$_) for 2..$n;\n    my $M = 1;\n    $M += $numers[$_-1]/$denoms[$_-1] for 1..$n;\n    $z**$s / $s * exp(-$z) * $M;\n}\n\nsub G_of_half {\n    my($n) = @_;\n    if ($n % 2) { f(2*$_) / (4**$_ * f($_)) * sqrt(pi) for int ($n-1) / 2 }\n    else        { f(($n/2)-1) }\n}\n\nsub f { reduce { $a * $b } 1, 1 .. $_[0] } \n\nsub chi_squared_cdf {\n    my($k, $x) = @_;\n    my $f = $k < 20 ? 20 : 10;\n    if ($x == 0)                  { 0.0 }\n    elsif ($x < $k + $f*sqrt($k)) { incomplete_G_series($k/2, $x/2) / G_of_half($k) }\n    else                          { 1.0 }\n}\nsub chi_squared_test {\n    my(@bins) = @_;\n    $significance = 0.05;\n    my $n = @bins;\n    my $N = sum @bins;\n    my $expected = $N / $n;\n    my $chi_squared = sum map { ($_ - $expected)**2 / $expected } @bins;\n    my $p_value = 1 - chi_squared_cdf($n-1, $chi_squared);\n    return $chi_squared, $p_value, $p_value > $significance ? 'True' : 'False';\n}\n\nfor $dataset ([199809, 200665, 199607, 200270, 199649], [522573, 244456, 139979, 71531, 21461]) {\n    printf \"C2 = %10.3f, p-value =\u00a0%.3f, uniform = %s\\n\", chi_squared_test(@$dataset);\n}\n", "target": "import math\nimport random\n\ndef GammaInc_Q( a, x):\n    a1 = a-1\n    a2 = a-2\n    def f0( t ):\n        return t**a1*math.exp(-t)\n\n    def df0(t):\n        return (a1-t)*t**a2*math.exp(-t)\n    \n    y = a1\n    while f0(y)*(x-y) >2.0e-8 and y < x: y += .3\n    if y > x: y = x\n\n    h = 3.0e-4\n    n = int(y/h)\n    h = y/n\n    hh = 0.5*h\n    gamax = h * sum( f0(t)+hh*df0(t) for t in ( h*j for j in xrange(n-1, -1, -1)))\n\n    return gamax/gamma_spounge(a)\n\nc = None\ndef gamma_spounge( z):\n    global c\n    a = 12\n\n    if c is None:\n       k1_factrl = 1.0\n       c = []\n       c.append(math.sqrt(2.0*math.pi))\n       for k in range(1,a):\n          c.append( math.exp(a-k) * (a-k)**(k-0.5) / k1_factrl )\n          k1_factrl *= -k\n    \n    accm = c[0]\n    for k in range(1,a):\n        accm += c[k] / (z+k)\n    accm *= math.exp( -(z+a)) * (z+a)**(z+0.5)\n    return accm/z;\n\ndef chi2UniformDistance( dataSet ):\n    expected = sum(dataSet)*1.0/len(dataSet)\n    cntrd = (d-expected for d in dataSet)\n    return sum(x*x for x in cntrd)/expected\n\ndef chi2Probability(dof, distance):\n    return 1.0 - GammaInc_Q( 0.5*dof, 0.5*distance)\n\ndef chi2IsUniform(dataSet, significance):\n    dof = len(dataSet)-1\n    dist = chi2UniformDistance(dataSet)\n    return chi2Probability( dof, dist ) > significance\n\ndset1 = [ 199809, 200665, 199607, 200270, 199649 ]\ndset2 = [ 522573, 244456, 139979,  71531,  21461 ]\n\nfor ds in (dset1, dset2):\n    print \"Data set:\", ds\n    dof = len(ds)-1\n    distance =chi2UniformDistance(ds)\n    print \"dof: %d distance: %.4f\" % (dof, distance),\n    prob = chi2Probability( dof, distance)\n    print \"probability: %.4f\"%prob,\n    print \"uniform? \", \"Yes\"if chi2IsUniform(ds,0.05) else \"No\"\n"}
{"id": 333489, "name": "CSV to HTML translation", "source": "Translate Perl to Python: use HTML::Entities;\n\nsub row {\n    my $elem = shift;\n    my @cells = map {\"<$elem>$_</$elem>\"} split ',', shift;\n    print '<tr>', @cells, \"</tr>\\n\";\n}\n\nmy ($first, @rest) = map\n    {my $x = $_; chomp $x; encode_entities $x}\n    <STDIN>;\nprint \"<table>\\n\";\nrow @ARGV ? 'th' : 'td', $first;\nrow 'td', $_ foreach @rest;\nprint \"</table>\\n\";\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 333490, "name": "CSV to HTML translation", "source": "Translate Perl to Python: use HTML::Entities;\n\nsub row {\n    my $elem = shift;\n    my @cells = map {\"<$elem>$_</$elem>\"} split ',', shift;\n    print '<tr>', @cells, \"</tr>\\n\";\n}\n\nmy ($first, @rest) = map\n    {my $x = $_; chomp $x; encode_entities $x}\n    <STDIN>;\nprint \"<table>\\n\";\nrow @ARGV ? 'th' : 'td', $first;\nrow 'td', $_ foreach @rest;\nprint \"</table>\\n\";\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 333491, "name": "Alternade words", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy $words = do { local (@ARGV, $/) = 'unixdict.txt'; <> };\nmy %words = map { $_, 1 } $words =~ /^.{3,}$/gm;\nfor ( $words =~ /^.{6,}$/gm )\n  {\n  my $even = s/(.).?/$1/gr;\n  my $odd = s/.(.?)/$1/gr;\n  $words{$even} && $words{$odd} and print \"$_ => [ $even $odd ]\\n\";\n  }\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 333492, "name": "Alternade words", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy $words = do { local (@ARGV, $/) = 'unixdict.txt'; <> };\nmy %words = map { $_, 1 } $words =~ /^.{3,}$/gm;\nfor ( $words =~ /^.{6,}$/gm )\n  {\n  my $even = s/(.).?/$1/gr;\n  my $odd = s/.(.?)/$1/gr;\n  $words{$even} && $words{$odd} and print \"$_ => [ $even $odd ]\\n\";\n  }\n", "target": "WORDFILE = 'unixdict.txt'\nMINLEN = 6\n\nclass Trie(object):\n    \n    class Node(object):\n        \n        def __init__(self, char='\\0', parent=None):\n            self.children = {}\n            self.char = char\n            self.final = False\n            self.parent = parent\n            \n        def descend(self, char, extend=False):\n            \n            if not char in self.children:\n                if not extend: return None\n                self.children[char] = Trie.Node(char,self)\n            return self.children[char]\n        \n    def __init__(self):\n        self.root = Trie.Node()\n    \n    def insert(self, word):\n        \n        node = self.root\n        for char in word: node = node.descend(char, extend=True)\n        node.final = True\n        return node\n    \n    def __contains__(self, word):\n        \n        node = self.root\n        for char in word:\n            node = node.descend(char)\n            if not node: return False\n        return node.final \n    \n    def words(self):\n        \n        nodes = [self.root]\n        while nodes:\n            node = nodes.pop()\n            nodes += node.children.values()\n            if node.final:\n                word = []\n                while node:\n                    if node.char != '\\0': word.append(node.char)\n                    node = node.parent\n                yield \"\".join(reversed(word))\n    \n    def __iter__(self):\n        return self.words()\n                \n\nwords = Trie()\nwith open(WORDFILE, \"rt\") as f:\n    for word in f.readlines():\n        words.insert(word.strip())\n\nfor word in words:\n    if len(word) < MINLEN: continue\n    even = word[::2]\n    odd = word[1::2]\n    if even in words and odd in words:\n        print(word, even, odd)\n"}
{"id": 333493, "name": "Count how many vowels and consonants occur in a string", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"@{[ $- = tr/aeiouAEIOU// ]} vowels @{[ tr/a-zA-Z// - $-\n    ]} consonants in: $_\\n\"\n  }\n\n", "target": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n"}
{"id": 333494, "name": "Count how many vowels and consonants occur in a string", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nwhile( <DATA> )\n  {\n  print \"@{[ $- = tr/aeiouAEIOU// ]} vowels @{[ tr/a-zA-Z// - $-\n    ]} consonants in: $_\\n\"\n  }\n\n", "target": "def isvowel(c):\n    \n    return c in ['a', 'e', 'i', 'o', 'u', 'A', 'E', \"I\", 'O', 'U']\n\ndef isletter(c):\n    \n    return 'a' <= c <= 'z' or 'A' <= c <= 'Z'\n\ndef isconsonant(c):\n    \n    return  not isvowel(c) and isletter(c)\n\ndef vccounts(s):\n    \n    a = list(s.lower())\n    au = set(a)\n    return sum([isvowel(c) for c in a]), sum([isconsonant(c) for c in a]), \\\n        sum([isvowel(c) for c in au]), sum([isconsonant(c) for c in au])\n\ndef testvccount():\n    teststrings = [\n        \"Forever Python programming language\",\n        \"Now is the time for all good men to come to the aid of their country.\"]\n    for s in teststrings:\n        vcnt, ccnt, vu, cu = vccounts(s)\n        print(f\"String: {s}\\n    Vowels: {vcnt} (distinct {vu})\\n    Consonants: {ccnt} (distinct {cu})\\n\")\n\ntestvccount()\n"}
{"id": 333495, "name": "Pythagorean triples", "source": "Translate Perl to Python: sub gcd {\n    my ($n, $m) = @_;\n    while($n){\n        my $t = $n;\n        $n = $m % $n;\n        $m = $t;\n    }\n    return $m;\n}\n\nsub tripel {\n    my $pmax  = shift;\n    my $prim  = 0;\n    my $count = 0;\n    my $nmax = sqrt($pmax)/2;\n    for( my $n=1; $n<=$nmax; $n++ ) {\n        for( my $m=$n+1; (my $p = 2*$m*($m+$n)) <= $pmax; $m+=2 ) {\n            next unless 1==gcd($m,$n);\n            $prim++;\n            $count += int $pmax/$p;\n        }\n    }\n    printf \"Max. perimeter: %d, Total: %d, Primitive: %d\\n\", $pmax, $count, $prim;\n}\n\ntripel 10**$_ for 1..8;\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 333496, "name": "Pythagorean triples", "source": "Translate Perl to Python: sub gcd {\n    my ($n, $m) = @_;\n    while($n){\n        my $t = $n;\n        $n = $m % $n;\n        $m = $t;\n    }\n    return $m;\n}\n\nsub tripel {\n    my $pmax  = shift;\n    my $prim  = 0;\n    my $count = 0;\n    my $nmax = sqrt($pmax)/2;\n    for( my $n=1; $n<=$nmax; $n++ ) {\n        for( my $m=$n+1; (my $p = 2*$m*($m+$n)) <= $pmax; $m+=2 ) {\n            next unless 1==gcd($m,$n);\n            $prim++;\n            $count += int $pmax/$p;\n        }\n    }\n    printf \"Max. perimeter: %d, Total: %d, Primitive: %d\\n\", $pmax, $count, $prim;\n}\n\ntripel 10**$_ for 1..8;\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 333497, "name": "Call a foreign-language function", "source": "Translate Perl to Python: use Inline C => q{\n    char *copy;\n    char * c_dup(char *orig) {\n        return copy = strdup(orig);\n    }\n    void c_free() {\n        free(copy);\n    }\n};\nprint c_dup('Hello'), \"\\n\";\nc_free();\n", "target": "import ctypes\nlibc = ctypes.CDLL(\"/lib/libc.so.6\")\nlibc.strcmp(\"abc\", \"def\")     \nlibc.strcmp(\"hello\", \"hello\") \n"}
{"id": 333498, "name": "Yellowstone sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::Util qw(first);\nuse GD::Graph::bars;\n\nuse constant Inf  => 1e5;\n\nsub gcd {\n  my ($u, $v) = @_;\n  while ($v) {\n    ($u, $v) = ($v, $u % $v);\n  }\n  return abs($u);\n}\n\nsub yellowstone {\n    my($terms) = @_;\n    my @s = (1, 2, 3);\n    my @used = (1) x 4;\n    my $min  = 3;\n    while (1) {\n        my $index = first { not defined $used[$_] and gcd($_,$s[-2]) != 1 and gcd($_,$s[-1]) == 1 } $min .. Inf;\n        $used[$index] = 1;\n        $min = (first { not defined $used[$_] } 0..@used-1) || @used-1;\n        push @s, $index;\n        last if @s == $terms;\n    }\n    @s;\n}\n\nsay \"The first 30 terms in the Yellowstone sequence:\\n\" . join ' ', yellowstone(30);\n\nmy @data = ( [1..500], [yellowstone(500)]);\nmy $graph = GD::Graph::bars->new(800, 600);\n$graph->set(\n    title          => 'Yellowstone sequence',\n    y_max_value    => 1400,\n    x_tick_number  => 5,\n    r_margin       => 10,\n    dclrs          => [ 'blue' ],\n) or die $graph->error;\nmy $gd = $graph->plot(\\@data) or die $graph->error;\n\nopen my $fh, '>', 'yellowstone-sequence.png';\nbinmode $fh;\nprint $fh $gd->png();\nclose $fh;\n", "target": "\n\nfrom itertools import chain, count, islice\nfrom operator import itemgetter\nfrom math import gcd\n\nfrom matplotlib import pyplot\n\n\n\ndef yellowstone():\n    \n    \n    def relativelyPrime(a):\n        return lambda b: 1 == gcd(a, b)\n\n    \n    def nextWindow(triple):\n        p2, p1, rest = triple\n        [rp2, rp1] = map(relativelyPrime, [p2, p1])\n\n        \n        def match(xxs):\n            x, xs = uncons(xxs)['Just']\n            return (x, xs) if rp1(x) and not rp2(x) else (\n                second(cons(x))(\n                    match(xs)\n                )\n            )\n        n, residue = match(rest)\n        return (p1, n, residue)\n\n    return chain(\n        range(1, 3),\n        map(\n            itemgetter(1),\n            iterate(nextWindow)(\n                (2, 3, count(4))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n\n    print(showList(\n        take(30)(yellowstone())\n    ))\n    pyplot.plot(\n        take(100)(yellowstone())\n    )\n    pyplot.xlabel(main.__doc__)\n    pyplot.show()\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef cons(x):\n    \n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else x + xs if (\n        isinstance(xs, str)\n    ) else chain([x], xs)\n\n\n\ndef iterate(f):\n    \n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(repr(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, (list, tuple))\n        else list(islice(xs, n))\n    )\n\n\n\ndef uncons(xs):\n    \n    if isinstance(xs, list):\n        return Just((xs[0], xs[1:])) if xs else Nothing()\n    else:\n        nxt = take(1)(xs)\n        return Just((nxt[0], xs)) if nxt else Nothing()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333499, "name": "Yellowstone sequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::Util qw(first);\nuse GD::Graph::bars;\n\nuse constant Inf  => 1e5;\n\nsub gcd {\n  my ($u, $v) = @_;\n  while ($v) {\n    ($u, $v) = ($v, $u % $v);\n  }\n  return abs($u);\n}\n\nsub yellowstone {\n    my($terms) = @_;\n    my @s = (1, 2, 3);\n    my @used = (1) x 4;\n    my $min  = 3;\n    while (1) {\n        my $index = first { not defined $used[$_] and gcd($_,$s[-2]) != 1 and gcd($_,$s[-1]) == 1 } $min .. Inf;\n        $used[$index] = 1;\n        $min = (first { not defined $used[$_] } 0..@used-1) || @used-1;\n        push @s, $index;\n        last if @s == $terms;\n    }\n    @s;\n}\n\nsay \"The first 30 terms in the Yellowstone sequence:\\n\" . join ' ', yellowstone(30);\n\nmy @data = ( [1..500], [yellowstone(500)]);\nmy $graph = GD::Graph::bars->new(800, 600);\n$graph->set(\n    title          => 'Yellowstone sequence',\n    y_max_value    => 1400,\n    x_tick_number  => 5,\n    r_margin       => 10,\n    dclrs          => [ 'blue' ],\n) or die $graph->error;\nmy $gd = $graph->plot(\\@data) or die $graph->error;\n\nopen my $fh, '>', 'yellowstone-sequence.png';\nbinmode $fh;\nprint $fh $gd->png();\nclose $fh;\n", "target": "\n\nfrom itertools import chain, count, islice\nfrom operator import itemgetter\nfrom math import gcd\n\nfrom matplotlib import pyplot\n\n\n\ndef yellowstone():\n    \n    \n    def relativelyPrime(a):\n        return lambda b: 1 == gcd(a, b)\n\n    \n    def nextWindow(triple):\n        p2, p1, rest = triple\n        [rp2, rp1] = map(relativelyPrime, [p2, p1])\n\n        \n        def match(xxs):\n            x, xs = uncons(xxs)['Just']\n            return (x, xs) if rp1(x) and not rp2(x) else (\n                second(cons(x))(\n                    match(xs)\n                )\n            )\n        n, residue = match(rest)\n        return (p1, n, residue)\n\n    return chain(\n        range(1, 3),\n        map(\n            itemgetter(1),\n            iterate(nextWindow)(\n                (2, 3, count(4))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n\n    print(showList(\n        take(30)(yellowstone())\n    ))\n    pyplot.plot(\n        take(100)(yellowstone())\n    )\n    pyplot.xlabel(main.__doc__)\n    pyplot.show()\n\n\n\n\n\ndef Just(x):\n    \n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n\ndef Nothing():\n    \n    return {'type': 'Maybe', 'Nothing': True}\n\n\n\ndef cons(x):\n    \n    return lambda xs: [x] + xs if (\n        isinstance(xs, list)\n    ) else x + xs if (\n        isinstance(xs, str)\n    ) else chain([x], xs)\n\n\n\ndef iterate(f):\n    \n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(repr(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, (list, tuple))\n        else list(islice(xs, n))\n    )\n\n\n\ndef uncons(xs):\n    \n    if isinstance(xs, list):\n        return Just((xs[0], xs[1:])) if xs else Nothing()\n    else:\n        nxt = take(1)(xs)\n        return Just((nxt[0], xs)) if nxt else Nothing()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333500, "name": "Sorting algorithms_Patience sort", "source": "Translate Perl to Python: sub patience_sort {\n    my @s = [shift];\n    for my $card (@_) {\n\tmy @t = grep { $_->[-1] > $card } @s;\n\tif (@t) { push @{shift(@t)}, $card }\n\telse { push @s, [$card] }\n    }\n    my @u;\n    while (my @v = grep @$_, @s) {\n\tmy $value = (my $min = shift @v)->[-1];\n\tfor (@v) {\n\t    ($min, $value) =\n\t    ($_, $_->[-1]) if $_->[-1] < $value\n\t}\n\tpush @u, pop @$min;\n    }\n    return @u\n}\n\nprint join ' ', patience_sort qw(4 3 6 2 -1 13 12 9);\n", "target": "from functools import total_ordering\nfrom bisect import bisect_left\nfrom heapq import merge\n\n@total_ordering\nclass Pile(list):\n    def __lt__(self, other): return self[-1] < other[-1]\n    def __eq__(self, other): return self[-1] == other[-1]\n\ndef patience_sort(n):\n    piles = []\n    \n    for x in n:\n        new_pile = Pile([x])\n        i = bisect_left(piles, new_pile)\n        if i != len(piles):\n            piles[i].append(x)\n        else:\n            piles.append(new_pile)\n\n    \n    n[:] = merge(*[reversed(pile) for pile in piles])\n\nif __name__ == \"__main__\":\n    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n    patience_sort(a)\n    print a\n"}
{"id": 333501, "name": "Extensible prime generator", "source": "Translate Perl to Python: use Math::Prime::Util qw(nth_prime prime_count primes);\n\n\n\n\nsay \"First 20: \", join(\" \", @{primes(nth_prime(20))});\nsay \"Between 100 and 150: \", join(\" \", @{primes(100,150)});\nsay prime_count(7700,8000), \" primes between 7700 and 8000\";\nsay \"${_}th prime: \", nth_prime($_) for map { 10**$_ } 1..8;\n", "target": "islice(count(7), 0, None, 2)\n"}
{"id": 333502, "name": "Flipping bits game", "source": "Translate Perl to Python: use strict;\nuse warnings qw(FATAL all);\nuse feature 'bitwise';\n\nmy $n = shift(@ARGV) || 4;\nif( $n < 2 or $n > 26 ) {\n\tdie \"You can't play a size $n game\\n\";\n}\n\nmy $n2 = $n*$n;\n\nmy (@rows, @cols);\nfor my $i ( 0 .. $n-1 ) {\n\tmy $row = my $col = \"\\x00\" x $n2;\n\tvec($row, $i * $n + $_, 8) ^= 1 for 0 .. $n-1;\n\tvec($col, $i + $_ * $n, 8) ^= 1 for 0 .. $n-1;\n\tpush @rows, $row;\n\tpush @cols, $col;\n}\n\nmy $goal = \"0\" x $n2;\nint(rand(2)) or (vec($goal, $_, 8) ^= 1) for 0 .. $n2-1;\nmy $start = $goal;\n{\n\tfor(@rows, @cols) {\n\t\t$start ^.= $_ if int rand 2;\n\t}\n\tredo if $start eq $goal; \n}\n\nmy @letters = ('a'..'z')[0..$n-1];\nsub to_strings {\n\tmy $board = shift;\n\tmy @result = join(\" \", \"  \", @letters);\n\tfor( 0 .. $n-1 ) {\n\t\tmy $res = sprintf(\"%2d \",$_+1);\n\t\t$res .= join \" \", split //, substr $board, $_*$n, $n;\n\t\tpush @result, $res;\n\t}\n\t\\@result;\n}\n\nmy $fmt;\nmy ($stext, $etext) = (\"Starting board\", \"Ending board\");\nmy $re = join \"|\", reverse 1 .. $n, @letters;\nmy $moves_so_far = 0;\nwhile( 1 ) {\n\tmy ($from, $to) = (to_strings($start), to_strings($goal));\n\tunless( $fmt ) {\n\t\tmy $len = length $from->[0];\n\t\t$len = length($stext) if $len < length $stext;\n\t\t$fmt = join($len, \"%\", \"s%\", \"s\\n\");\n\t}\n\tprintf $fmt, $stext, $etext;\n\tprintf $fmt, $from->[$_], $to->[$_] for 0 .. $n;\n\tlast if $start eq $goal;\n\tINPUT_LOOP: {\n\t\tprintf \"Move \n\t\t\t$moves_so_far+1;\n\t\tmy $input = <>;\n\t\tdie unless defined $input;\n\t\tmy $did_one;\n\t\tfor( $input =~ /($re)/gi ) {\n\t\t\t$did_one = 1;\n\t\t\tif( /\\d/ ) {\n\t\t\t\t$start ^.= $rows[$_-1];\n\t\t\t} else {\n\t\t\t\t$_ = ord(lc) - ord('a');\n\t\t\t\t$start ^.= $cols[$_];\n\t\t\t}\n\t\t\t++$moves_so_far;\n\t\t}\n\t\tredo INPUT_LOOP unless $did_one;\n\t}\n}\nprint \"You won after $moves_so_far moves.\\n\";\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 333503, "name": "Flipping bits game", "source": "Translate Perl to Python: use strict;\nuse warnings qw(FATAL all);\nuse feature 'bitwise';\n\nmy $n = shift(@ARGV) || 4;\nif( $n < 2 or $n > 26 ) {\n\tdie \"You can't play a size $n game\\n\";\n}\n\nmy $n2 = $n*$n;\n\nmy (@rows, @cols);\nfor my $i ( 0 .. $n-1 ) {\n\tmy $row = my $col = \"\\x00\" x $n2;\n\tvec($row, $i * $n + $_, 8) ^= 1 for 0 .. $n-1;\n\tvec($col, $i + $_ * $n, 8) ^= 1 for 0 .. $n-1;\n\tpush @rows, $row;\n\tpush @cols, $col;\n}\n\nmy $goal = \"0\" x $n2;\nint(rand(2)) or (vec($goal, $_, 8) ^= 1) for 0 .. $n2-1;\nmy $start = $goal;\n{\n\tfor(@rows, @cols) {\n\t\t$start ^.= $_ if int rand 2;\n\t}\n\tredo if $start eq $goal; \n}\n\nmy @letters = ('a'..'z')[0..$n-1];\nsub to_strings {\n\tmy $board = shift;\n\tmy @result = join(\" \", \"  \", @letters);\n\tfor( 0 .. $n-1 ) {\n\t\tmy $res = sprintf(\"%2d \",$_+1);\n\t\t$res .= join \" \", split //, substr $board, $_*$n, $n;\n\t\tpush @result, $res;\n\t}\n\t\\@result;\n}\n\nmy $fmt;\nmy ($stext, $etext) = (\"Starting board\", \"Ending board\");\nmy $re = join \"|\", reverse 1 .. $n, @letters;\nmy $moves_so_far = 0;\nwhile( 1 ) {\n\tmy ($from, $to) = (to_strings($start), to_strings($goal));\n\tunless( $fmt ) {\n\t\tmy $len = length $from->[0];\n\t\t$len = length($stext) if $len < length $stext;\n\t\t$fmt = join($len, \"%\", \"s%\", \"s\\n\");\n\t}\n\tprintf $fmt, $stext, $etext;\n\tprintf $fmt, $from->[$_], $to->[$_] for 0 .. $n;\n\tlast if $start eq $goal;\n\tINPUT_LOOP: {\n\t\tprintf \"Move \n\t\t\t$moves_so_far+1;\n\t\tmy $input = <>;\n\t\tdie unless defined $input;\n\t\tmy $did_one;\n\t\tfor( $input =~ /($re)/gi ) {\n\t\t\t$did_one = 1;\n\t\t\tif( /\\d/ ) {\n\t\t\t\t$start ^.= $rows[$_-1];\n\t\t\t} else {\n\t\t\t\t$_ = ord(lc) - ord('a');\n\t\t\t\t$start ^.= $cols[$_];\n\t\t\t}\n\t\t\t++$moves_so_far;\n\t\t}\n\t\tredo INPUT_LOOP unless $did_one;\n\t}\n}\nprint \"You won after $moves_so_far moves.\\n\";\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 333504, "name": "Gray code", "source": "Translate Perl to Python: sub bin2gray\n{\n    return $_[0] ^ ($_[0] >> 1);\n}\n\nsub gray2bin\n{\n    my ($num)= @_;\n    my $bin= $num;\n    while( $num >>= 1 ) {\n        \n        $bin ^= $num;   \n    }                   \n    return $bin;\n}\n\nfor (0..31) {\n    my $gr= bin2gray($_);\n    printf \"%d\\t%b\\t%b\\t%b\\n\", $_, $_, $gr, gray2bin($gr);\n}\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 333505, "name": "Gray code", "source": "Translate Perl to Python: sub bin2gray\n{\n    return $_[0] ^ ($_[0] >> 1);\n}\n\nsub gray2bin\n{\n    my ($num)= @_;\n    my $bin= $num;\n    while( $num >>= 1 ) {\n        \n        $bin ^= $num;   \n    }                   \n    return $bin;\n}\n\nfor (0..31) {\n    my $gr= bin2gray($_);\n    printf \"%d\\t%b\\t%b\\t%b\\n\", $_, $_, $gr, gray2bin($gr);\n}\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 333506, "name": "Vigen\u00e8re cipher_Cryptanalysis", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\n\nmy %English_letter_freq = (\n     E => 12.70,  L => 4.03,  Y => 1.97,  P => 1.93,  T => 9.06,  A => 8.17,  O => 7.51,  I => 6.97,  N => 6.75,\n     S =>  6.33,  H => 6.09,  R => 5.99,  D => 4.25,  C => 2.78,  U => 2.76,  M => 2.41,  W => 2.36,  F => 2.23,\n     G =>  2.02,  B => 1.29,  V => 0.98,  K => 0.77,  J => 0.15,  X => 0.15,  Q => 0.10,  Z => 0.07\n);\nmy @alphabet = sort keys %English_letter_freq;\nmy $max_key_lengths = 5; \n\nsub myguess {\n    my ($text) = (@_);\n    my ($seqtext, @spacing, @factors, @sortedfactors, $pos, %freq, %Keys);\n\n    \n    $seqtext = $text;\n    while ($seqtext =~ /(...).*\\1/) {\n        $seqtext = substr($seqtext, 1+index($seqtext, $1));\n        push @spacing,  1 + index($seqtext, $1);\n    }\n\n    for my $j (@spacing) {\n        push @factors, grep { $j % $_ == 0 } 2..$j;\n    }\n    $freq{$_}++ for @factors;\n    @sortedfactors = grep { $_ >= 4 } sort { $freq{$b} <=> $freq{$a} } keys %freq; \n\n    for my $keylen ( @sortedfactors[0..$max_key_lengths-1] ) {\n        my $keyguess = '';\n        for (my $i = 0; $i < $keylen; $i++) {\n            my($mykey, %chi_values, $bestguess);\n            for (my $j = 0; $j < length($text); $j += $keylen) {\n                $mykey .= substr($text, ($j+$i) % length($text), 1);\n            }\n\n            for my $subkey (@alphabet) {\n                my $decrypted = mycrypt($mykey, $subkey);\n                my $length    = length($decrypted);\n                for my $char (@alphabet) {\n                    my $expected = $English_letter_freq{$char} * $length / 100;\n                    my $observed;\n                    ++$observed while $decrypted =~ /$char/g;\n                    $chi_values{$subkey} += ($observed - $expected)**2 / $expected if $observed;\n                }\n            }\n\n            $Keys{$keylen}{score} = $chi_values{'A'};\n            for my $sk (sort keys %chi_values) {\n                if ($chi_values{$sk} <= $Keys{$keylen}{score}) {\n                    $bestguess = $sk;\n                    $Keys{$keylen}{score} = $chi_values{$sk};\n                }\n            }\n            $keyguess .= $bestguess;\n        }\n        $Keys{$keylen}{key} = $keyguess;\n    }\n    map { $Keys{$_}{key} } sort { $Keys{$a}{score} <=> $Keys{$b}{score}} keys %Keys;\n}\n\nsub mycrypt {\n    my ($text, $key) = @_;\n    my ($new_text, %values_numbers);\n\n    my $keylen = length($key);\n    @values_numbers{@alphabet} = 0..25;\n    my %values_letters = reverse %values_numbers;\n\n    for (my $i = 0; $i < length($text); $i++) {\n        my $val =  -1 * $values_numbers{substr( $key, $i%$keylen, 1)} \n                 +      $values_numbers{substr($text, $i,         1)};\n        $new_text .= $values_letters{ $val % 26 };\n    }\n    return $new_text;\n}\n\nmy $cipher_text = <<~'EOD';\n    MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH\n    VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD\n    ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS\n    FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG\n    ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ\n    ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS\n    JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT\n    LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST\n    MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH\n    QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV\n    RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW\n    TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO\n    SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR\n    ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX\n    BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB\n    BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA\n    FWAML ZZRXJ EKAHV FASMU LVVUT TGK\nEOD\n\nmy $text = uc($cipher_text) =~ s/[^@{[join '', @alphabet]}]//gr;\n\nfor my $key ( myguess($text) ) {\n    say \"Key        $key\\n\" .\n        \"Key length \" . length($key) . \"\\n\" .\n        \"Plaintext  \" . substr(mycrypt($text, $key), 0, 80) . \"...\\n\";\n}\n", "target": "from string import uppercase\nfrom operator import itemgetter\n\ndef vigenere_decrypt(target_freqs, input):\n    nchars = len(uppercase)\n    ordA = ord('A')\n    sorted_targets = sorted(target_freqs)\n\n    def frequency(input):\n        result = [[c, 0.0] for c in uppercase]\n        for c in input:\n            result[c - ordA][1] += 1\n        return result\n\n    def correlation(input):\n        result = 0.0\n        freq = frequency(input)\n        freq.sort(key=itemgetter(1))\n\n        for i, f in enumerate(freq):\n            result += f[1] * sorted_targets[i]\n        return result\n\n    cleaned = [ord(c) for c in input.upper() if c.isupper()]\n    best_len = 0\n    best_corr = -100.0\n\n    \n    \n    for i in xrange(2, len(cleaned) // 20):\n        pieces = [[] for _ in xrange(i)]\n        for j, c in enumerate(cleaned):\n            pieces[j % i].append(c)\n\n        \n        \n        corr = -0.5 * i + sum(correlation(p) for p in pieces)\n\n        if corr > best_corr:\n            best_len = i\n            best_corr = corr\n\n    if best_len == 0:\n        return (\"Text is too short to analyze\", \"\")\n\n    pieces = [[] for _ in xrange(best_len)]\n    for i, c in enumerate(cleaned):\n        pieces[i % best_len].append(c)\n\n    freqs = [frequency(p) for p in pieces]\n\n    key = \"\"\n    for fr in freqs:\n        fr.sort(key=itemgetter(1), reverse=True)\n\n        m = 0\n        max_corr = 0.0\n        for j in xrange(nchars):\n            corr = 0.0\n            c = ordA + j\n            for frc in fr:\n                d = (ord(frc[0]) - c + nchars) % nchars\n                corr += frc[1] * target_freqs[d]\n\n            if corr > max_corr:\n                m = j\n                max_corr = corr\n\n        key += chr(m + ordA)\n\n    r = (chr((c - ord(key[i % best_len]) + nchars) % nchars + ordA)\n         for i, c in enumerate(cleaned))\n    return (key, \"\".join(r))\n\n\ndef main():\n    encoded = \n\n    english_frequences = [\n        0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,\n        0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,\n        0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,\n        0.00978, 0.02360, 0.00150, 0.01974, 0.00074]\n\n    (key, decoded) = vigenere_decrypt(english_frequences, encoded)\n    print \"Key:\", key\n    print \"\\nText:\", decoded\n\nmain()\n"}
{"id": 333507, "name": "File extension is in extensions list", "source": "Translate Perl to Python: sub check_extension {\n    my ($filename, @extensions) = @_;\n    my $extensions = join '|', map quotemeta, @extensions;\n    scalar $filename =~ / \\. (?: $extensions ) $ /xi\n}\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 333508, "name": "File extension is in extensions list", "source": "Translate Perl to Python: sub check_extension {\n    my ($filename, @extensions) = @_;\n    my $extensions = join '|', map quotemeta, @extensions;\n    scalar $filename =~ / \\. (?: $extensions ) $ /xi\n}\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 333509, "name": "Extreme floating point values", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\n\nmy $nzero = -0.0;\nmy $nan = 0 + \"nan\";\nmy $pinf = +\"inf\";\nmy $ninf = -\"inf\";\n\nprintf \"\\$nzero =\u00a0%.1f\\n\", $nzero;\nprint \"\\$nan = $nan\\n\";\nprint \"\\$pinf = $pinf\\n\";\nprint \"\\$ninf = $ninf\\n\\n\";\n\nprintf \"atan2(0, 0) = %g\\n\", atan2(0, 0);\nprintf \"atan2(0, \\$nzero) = %g\\n\", atan2(0, $nzero);\nprintf \"sin(\\$pinf) = %g\\n\", sin($pinf);\nprintf \"\\$pinf / -1 = %g\\n\", $pinf / -1;\nprintf \"\\$ninf + 1e100 = %g\\n\\n\", $ninf + 1e100;\n\nprintf \"nan test: %g\\n\", (1 + 2 * 3 - 4) / (-5.6e7 * $nan);\nprintf \"nan == nan? %s\\n\", ($nan == $nan) ? \"yes\" : \"no\";\nprintf \"nan == 42? %s\\n\", ($nan == 42) ? \"yes\" : \"no\";\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 333510, "name": "Extreme floating point values", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\n\nmy $nzero = -0.0;\nmy $nan = 0 + \"nan\";\nmy $pinf = +\"inf\";\nmy $ninf = -\"inf\";\n\nprintf \"\\$nzero =\u00a0%.1f\\n\", $nzero;\nprint \"\\$nan = $nan\\n\";\nprint \"\\$pinf = $pinf\\n\";\nprint \"\\$ninf = $ninf\\n\\n\";\n\nprintf \"atan2(0, 0) = %g\\n\", atan2(0, 0);\nprintf \"atan2(0, \\$nzero) = %g\\n\", atan2(0, $nzero);\nprintf \"sin(\\$pinf) = %g\\n\", sin($pinf);\nprintf \"\\$pinf / -1 = %g\\n\", $pinf / -1;\nprintf \"\\$ninf + 1e100 = %g\\n\\n\", $ninf + 1e100;\n\nprintf \"nan test: %g\\n\", (1 + 2 * 3 - 4) / (-5.6e7 * $nan);\nprintf \"nan == nan? %s\\n\", ($nan == $nan) ? \"yes\" : \"no\";\nprintf \"nan == 42? %s\\n\", ($nan == 42) ? \"yes\" : \"no\";\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 333511, "name": "Soundex", "source": "Translate Perl to Python: use Text::Soundex;\nprint soundex(\"Soundex\"), \"\\n\"; \nprint soundex(\"Example\"), \"\\n\"; \nprint soundex(\"Sownteks\"), \"\\n\"; \nprint soundex(\"Ekzampul\"), \"\\n\"; \n", "target": "from itertools import groupby\n\ndef soundex(word):\n   codes = (\"bfpv\",\"cgjkqsxz\", \"dt\", \"l\", \"mn\", \"r\")\n   soundDict = dict((ch, str(ix+1)) for ix,cod in enumerate(codes) for ch in cod)\n   cmap2 = lambda kar: soundDict.get(kar, '9')\n   sdx =  ''.join(cmap2(kar) for kar in word.lower())\n   sdx2 = word[0].upper() + ''.join(k for k,g in list(groupby(sdx))[1:] if k!='9')\n   sdx3 = sdx2[0:4].ljust(4,'0')\n   return sdx3\n"}
{"id": 333512, "name": "Knuth's algorithm S", "source": "Translate Perl to Python: use strict;\n\nsub s_of_n_creator {\n    my $n = shift;\n    my @sample;\n    my $i = 0;\n    sub {\n        my $item = shift;\n        $i++;\n        if ($i <= $n) {\n            \n            push @sample, $item;\n        } elsif (rand() < $n / $i) {\n            \n            @sample[rand $n] = $item;\n        }\n        @sample\n    }\n}\n\nmy @items = (0..9);\nmy @bin;\n\nforeach my $trial (1 .. 100000) {\n    my $s_of_n = s_of_n_creator(3);\n    my @sample;\n    foreach my $item (@items) {\n        @sample = $s_of_n->($item);\n    }\n    foreach my $s (@sample) {\n        $bin[$s]++;\n    }\n}\nprint \"@bin\\n\";\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 333513, "name": "Knuth's algorithm S", "source": "Translate Perl to Python: use strict;\n\nsub s_of_n_creator {\n    my $n = shift;\n    my @sample;\n    my $i = 0;\n    sub {\n        my $item = shift;\n        $i++;\n        if ($i <= $n) {\n            \n            push @sample, $item;\n        } elsif (rand() < $n / $i) {\n            \n            @sample[rand $n] = $item;\n        }\n        @sample\n    }\n}\n\nmy @items = (0..9);\nmy @bin;\n\nforeach my $trial (1 .. 100000) {\n    my $s_of_n = s_of_n_creator(3);\n    my @sample;\n    foreach my $item (@items) {\n        @sample = $s_of_n->($item);\n    }\n    foreach my $s (@sample) {\n        $bin[$s]++;\n    }\n}\nprint \"@bin\\n\";\n", "target": "from random import randrange\n\ndef s_of_n_creator(n):\n    sample, i = [], 0\n    def s_of_n(item):\n        nonlocal i\n\n        i += 1\n        if i <= n:\n            \n            sample.append(item)\n        elif randrange(i) < n:\n            \n            sample[randrange(n)] = item\n        return sample\n    return s_of_n\n\nif __name__ == '__main__':\n    bin = [0]* 10\n    items = range(10)\n    print(\"Single run samples for n = 3:\")\n    s_of_n = s_of_n_creator(3)\n    for item in items:\n        sample = s_of_n(item)\n        print(\"  Item: %i -> sample: %s\" % (item, sample))\n    \n    for trial in range(100000):\n        s_of_n = s_of_n_creator(3)\n        for item in items:\n            sample = s_of_n(item)\n        for s in sample:\n            bin[s] += 1\n    print(\"\\nTest item frequencies for 100000 runs:\\n \",\n          '\\n  '.join(\"%i:%i\" % x for x in enumerate(bin)))\n"}
{"id": 333514, "name": "Conjugate transpose", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse English;\nuse Math::Complex;\nuse Math::MatrixReal;\n\nmy @examples = (example1(), example2(), example3());\nforeach my $m (@examples) {\n    print \"Starting matrix:\\n\", cmat_as_string($m), \"\\n\";\n    my $m_ct = conjugate_transpose($m);\n    print \"Its conjugate transpose:\\n\", cmat_as_string($m_ct), \"\\n\";\n    print \"Is Hermitian? \", (cmats_are_equal($m, $m_ct) ? 'TRUE' : 'FALSE'), \"\\n\";\n    my $product = $m_ct * $m;\n    print \"Is normal? \", (cmats_are_equal($product, $m * $m_ct) ? 'TRUE' : 'FALSE'), \"\\n\";\n    my $I = identity(($m->dim())[0]);\n    print \"Is unitary? \", (cmats_are_equal($product, $I) ? 'TRUE' : 'FALSE'), \"\\n\";\n    print \"\\n\";\n}\nexit 0;\n\nsub cmats_are_equal {\n    my ($m1, $m2) = @ARG;\n    my $max_norm = 1.0e-7;\n    return abs($m1 - $m2) < $max_norm;  \n}\n\n\n\nsub conjugate_transpose {\n    my $m_T = ~ shift;\n    my $result = $m_T->each(sub {~ $ARG[0]});\n    return $result;\n}\n\nsub cmat_as_string {\n    my $m = shift;\n    my $n_rows = ($m->dim())[0];\n    my @row_strings = map { q{[} . join(q{, }, $m->row($ARG)->as_list) . q{]} }\n                          (1 .. $n_rows);\n    return join(\"\\n\", @row_strings);\n}\n\nsub identity {\n    my $N = shift;\n    my $m = Math::MatrixReal->new($N, $N);\n    $m->one();\n    return $m;\n}\n\nsub example1 {\n    my $m = Math::MatrixReal->new(2, 2);\n    $m->assign(1, 1, cplx(3, 0));\n    $m->assign(1, 2, cplx(2, 1));\n    $m->assign(2, 1, cplx(2, -1));\n    $m->assign(2, 2, cplx(1, 0));\n    return $m;\n}\n\nsub example2 {\n    my $m = Math::MatrixReal->new(3, 3);\n    $m->assign(1, 1, cplx(1, 0));\n    $m->assign(1, 2, cplx(1, 0));\n    $m->assign(1, 3, cplx(0, 0));\n    $m->assign(2, 1, cplx(0, 0));\n    $m->assign(2, 2, cplx(1, 0));\n    $m->assign(2, 3, cplx(1, 0));\n    $m->assign(3, 1, cplx(1, 0));\n    $m->assign(3, 2, cplx(0, 0));\n    $m->assign(3, 3, cplx(1, 0));\n    return $m;\n}\n\nsub example3 {\n    my $m = Math::MatrixReal->new(3, 3);\n    $m->assign(1, 1, cplx(0.70710677, 0));\n    $m->assign(1, 2, cplx(0.70710677, 0));\n    $m->assign(1, 3, cplx(0, 0));\n    $m->assign(2, 1, cplx(0, -0.70710677));\n    $m->assign(2, 2, cplx(0, 0.70710677));\n    $m->assign(2, 3, cplx(0, 0));\n    $m->assign(3, 1, cplx(0, 0));\n    $m->assign(3, 2, cplx(0, 0));\n    $m->assign(3, 3, cplx(0, 1));\n    return $m;\n}\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 333515, "name": "Conjugate transpose", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse English;\nuse Math::Complex;\nuse Math::MatrixReal;\n\nmy @examples = (example1(), example2(), example3());\nforeach my $m (@examples) {\n    print \"Starting matrix:\\n\", cmat_as_string($m), \"\\n\";\n    my $m_ct = conjugate_transpose($m);\n    print \"Its conjugate transpose:\\n\", cmat_as_string($m_ct), \"\\n\";\n    print \"Is Hermitian? \", (cmats_are_equal($m, $m_ct) ? 'TRUE' : 'FALSE'), \"\\n\";\n    my $product = $m_ct * $m;\n    print \"Is normal? \", (cmats_are_equal($product, $m * $m_ct) ? 'TRUE' : 'FALSE'), \"\\n\";\n    my $I = identity(($m->dim())[0]);\n    print \"Is unitary? \", (cmats_are_equal($product, $I) ? 'TRUE' : 'FALSE'), \"\\n\";\n    print \"\\n\";\n}\nexit 0;\n\nsub cmats_are_equal {\n    my ($m1, $m2) = @ARG;\n    my $max_norm = 1.0e-7;\n    return abs($m1 - $m2) < $max_norm;  \n}\n\n\n\nsub conjugate_transpose {\n    my $m_T = ~ shift;\n    my $result = $m_T->each(sub {~ $ARG[0]});\n    return $result;\n}\n\nsub cmat_as_string {\n    my $m = shift;\n    my $n_rows = ($m->dim())[0];\n    my @row_strings = map { q{[} . join(q{, }, $m->row($ARG)->as_list) . q{]} }\n                          (1 .. $n_rows);\n    return join(\"\\n\", @row_strings);\n}\n\nsub identity {\n    my $N = shift;\n    my $m = Math::MatrixReal->new($N, $N);\n    $m->one();\n    return $m;\n}\n\nsub example1 {\n    my $m = Math::MatrixReal->new(2, 2);\n    $m->assign(1, 1, cplx(3, 0));\n    $m->assign(1, 2, cplx(2, 1));\n    $m->assign(2, 1, cplx(2, -1));\n    $m->assign(2, 2, cplx(1, 0));\n    return $m;\n}\n\nsub example2 {\n    my $m = Math::MatrixReal->new(3, 3);\n    $m->assign(1, 1, cplx(1, 0));\n    $m->assign(1, 2, cplx(1, 0));\n    $m->assign(1, 3, cplx(0, 0));\n    $m->assign(2, 1, cplx(0, 0));\n    $m->assign(2, 2, cplx(1, 0));\n    $m->assign(2, 3, cplx(1, 0));\n    $m->assign(3, 1, cplx(1, 0));\n    $m->assign(3, 2, cplx(0, 0));\n    $m->assign(3, 3, cplx(1, 0));\n    return $m;\n}\n\nsub example3 {\n    my $m = Math::MatrixReal->new(3, 3);\n    $m->assign(1, 1, cplx(0.70710677, 0));\n    $m->assign(1, 2, cplx(0.70710677, 0));\n    $m->assign(1, 3, cplx(0, 0));\n    $m->assign(2, 1, cplx(0, -0.70710677));\n    $m->assign(2, 2, cplx(0, 0.70710677));\n    $m->assign(2, 3, cplx(0, 0));\n    $m->assign(3, 1, cplx(0, 0));\n    $m->assign(3, 2, cplx(0, 0));\n    $m->assign(3, 3, cplx(0, 1));\n    return $m;\n}\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 333516, "name": "Disarium numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy ($n,@D) = (0, 0);\nwhile (++$n) {\n    my($m,$sum);\n    map { $sum += $_ ** ++$m } split '', $n;\n    push @D, $n if $n == $sum;\n    last if 19 == @D;\n}\nprint \"@D\\n\";\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 333517, "name": "Disarium numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy ($n,@D) = (0, 0);\nwhile (++$n) {\n    my($m,$sum);\n    map { $sum += $_ ** ++$m } split '', $n;\n    push @D, $n if $n == $sum;\n    last if 19 == @D;\n}\nprint \"@D\\n\";\n", "target": "\n\ndef isDisarium(n):\n    digitos = len(str(n))\n    suma = 0\n    x = n\n    while x != 0:\n        suma += (x % 10) ** digitos\n        digitos -= 1\n        x //= 10\n    if suma == n:\n        return True\n    else:\n        return False\n\nif __name__ == '__main__':\n    limite = 19\n    cont = 0\n    n = 0\n    print(\"The first\",limite,\"Disarium numbers are:\")\n    while cont < limite:\n        if isDisarium(n):\n            print(n, end = \" \")\n            cont += 1\n        n += 1\n"}
{"id": 333518, "name": "Cousin primes", "source": "Translate Perl to Python: use warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\n\nmy($limit, @cp) = 1000;\nis_prime($_) and is_prime($_+4) and push @cp, \"$_/@{[$_+4]}\" for 2..$limit;\nsay @cp . \" cousin prime pairs < $limit:\\n\" . (sprintf \"@{['%8s' x @cp]}\", @cp) =~ s/(.{56})/$1\\n/gr;\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333519, "name": "Cousin primes", "source": "Translate Perl to Python: use warnings;\nuse feature 'say';\nuse ntheory 'is_prime';\n\nmy($limit, @cp) = 1000;\nis_prime($_) and is_prime($_+4) and push @cp, \"$_/@{[$_+4]}\" for 2..$limit;\nsay @cp . \" cousin prime pairs < $limit:\\n\" . (sprintf \"@{['%8s' x @cp]}\", @cp) =~ s/(.{56})/$1\\n/gr;\n", "target": "\n\nfrom itertools import chain, takewhile\n\n\n\ndef cousinPrimes():\n    \n    def go(x):\n        n = 4 + x\n        return [(x, n)] if isPrime(n) else []\n\n    return chain.from_iterable(\n        map(go, primes())\n    )\n\n\n\n\ndef main():\n    \n\n    pairs = list(\n        takewhile(\n            lambda ab: 1000 > ab[1],\n            cousinPrimes()\n        )\n    )\n\n    print(f'{len(pairs)} cousin pairs below 1000:\\n')\n    print(\n        spacedTable(list(\n            chunksOf(4)([\n                repr(x) for x in pairs\n            ])\n        ))\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef listTranspose(xss):\n    \n    def go(xss):\n        if xss:\n            h, *t = xss\n            return (\n                [[h[0]] + [xs[0] for xs in t if xs]] + (\n                    go([h[1:]] + [xs[1:] for xs in t])\n                )\n            ) if h and isinstance(h, list) else go(t)\n        else:\n            return []\n    return go(xss)\n\n\n\ndef spacedTable(rows):\n    \n    columnWidths = [\n        len(str(row[-1])) for row in listTranspose(rows)\n    ]\n    return '\\n'.join([\n        ' '.join(\n            map(\n                lambda w, s: s.rjust(w, ' '),\n                columnWidths, row\n            )\n        ) for row in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333520, "name": "Flow-control structures", "source": "Translate Perl to Python: FORK:\n\ngoto FORK;\n", "target": "\nfor i in range(n):\n    if (n%2) == 0:\n        continue\n    if (n%i) == 0:\n        result = i\n        break\nelse:\n    result = None\n    print \"No odd factors found\"\n"}
{"id": 333521, "name": "Find if a point is within a triangle", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse List::AllUtils qw(min max natatime);\nuse constant EPSILON        =>           0.001;\nuse constant EPSILON_SQUARE => EPSILON*EPSILON;\n\nsub side {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   return ($y2 - $y1)*($x - $x1) + (-$x2 + $x1)*($y - $y1);\n}\n\nsub naivePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $checkSide1 = side($x1, $y1, $x2, $y2, $x, $y) >= 0 ;\n   my $checkSide2 = side($x2, $y2, $x3, $y3, $x, $y) >= 0 ;\n   my $checkSide3 = side($x3, $y3, $x1, $y1, $x, $y) >= 0 ;\n   return $checkSide1 && $checkSide2 && $checkSide3  || 0 ;\n}\n\nsub pointInTriangleBoundingBox {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $xMin = min($x1, min($x2, $x3)) - EPSILON;\n   my $xMax = max($x1, max($x2, $x3)) + EPSILON;\n   my $yMin = min($y1, min($y2, $y3)) - EPSILON;\n   my $yMax = max($y1, max($y2, $y3)) + EPSILON;\n   ( $x < $xMin || $xMax < $x || $y < $yMin || $yMax < $y ) ? 0 : 1\n}\n\nsub distanceSquarePointToSegment {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   my $p1_p2_squareLength = ($x2 - $x1)**2 + ($y2 - $y1)**2;\n   my $dotProduct = ($x-$x1)*($x2-$x1)+($y-$y1)*($y2-$y1) ;\n   if ( $dotProduct < 0 ) {\n      return ($x - $x1)**2 + ($y - $y1)**2;\n   } elsif ( $dotProduct <= $p1_p2_squareLength ) {\n      my $p_p1_squareLength = ($x1 - $x)**2 + ($y1 - $y)**2;\n      return $p_p1_squareLength - $dotProduct**2 / $p1_p2_squareLength;\n   } else {\n      return ($x - $x2)**2 + ($y - $y2)**2;\n   }\n}\n\nsub accuratePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   return 0 unless pointInTriangleBoundingBox($x1,$y1,$x2,$y2,$x3,$y3,$x,$y);\n   return 1 if ( naivePointInTriangle($x1, $y1, $x2, $y2, $x3, $y3, $x, $y)\n      or distanceSquarePointToSegment($x1, $y1, $x2, $y2, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x2, $y2, $x3, $y3, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x3, $y3, $x1, $y1, $x, $y) <= EPSILON_SQUARE);\n   return 0\n}\n\nmy @DATA = (1.5, 2.4, 5.1, -3.1, -3.8, 0.5);\n\nfor my $point ( [0,0] , [0,1] ,[3,1] ) {\n   print \"Point (\", join(',',@$point), \") is within triangle \";\n   my $iter = natatime 2, @DATA;\n   while ( my @vertex = $iter->()) { print '(',join(',',@vertex),') ' }\n   print ': ',naivePointInTriangle (@DATA, @$point) ? 'True' : 'False', \"\\n\" ;\n}\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 333522, "name": "Find if a point is within a triangle", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nuse List::AllUtils qw(min max natatime);\nuse constant EPSILON        =>           0.001;\nuse constant EPSILON_SQUARE => EPSILON*EPSILON;\n\nsub side {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   return ($y2 - $y1)*($x - $x1) + (-$x2 + $x1)*($y - $y1);\n}\n\nsub naivePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $checkSide1 = side($x1, $y1, $x2, $y2, $x, $y) >= 0 ;\n   my $checkSide2 = side($x2, $y2, $x3, $y3, $x, $y) >= 0 ;\n   my $checkSide3 = side($x3, $y3, $x1, $y1, $x, $y) >= 0 ;\n   return $checkSide1 && $checkSide2 && $checkSide3  || 0 ;\n}\n\nsub pointInTriangleBoundingBox {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $xMin = min($x1, min($x2, $x3)) - EPSILON;\n   my $xMax = max($x1, max($x2, $x3)) + EPSILON;\n   my $yMin = min($y1, min($y2, $y3)) - EPSILON;\n   my $yMax = max($y1, max($y2, $y3)) + EPSILON;\n   ( $x < $xMin || $xMax < $x || $y < $yMin || $yMax < $y ) ? 0 : 1\n}\n\nsub distanceSquarePointToSegment {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   my $p1_p2_squareLength = ($x2 - $x1)**2 + ($y2 - $y1)**2;\n   my $dotProduct = ($x-$x1)*($x2-$x1)+($y-$y1)*($y2-$y1) ;\n   if ( $dotProduct < 0 ) {\n      return ($x - $x1)**2 + ($y - $y1)**2;\n   } elsif ( $dotProduct <= $p1_p2_squareLength ) {\n      my $p_p1_squareLength = ($x1 - $x)**2 + ($y1 - $y)**2;\n      return $p_p1_squareLength - $dotProduct**2 / $p1_p2_squareLength;\n   } else {\n      return ($x - $x2)**2 + ($y - $y2)**2;\n   }\n}\n\nsub accuratePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   return 0 unless pointInTriangleBoundingBox($x1,$y1,$x2,$y2,$x3,$y3,$x,$y);\n   return 1 if ( naivePointInTriangle($x1, $y1, $x2, $y2, $x3, $y3, $x, $y)\n      or distanceSquarePointToSegment($x1, $y1, $x2, $y2, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x2, $y2, $x3, $y3, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x3, $y3, $x1, $y1, $x, $y) <= EPSILON_SQUARE);\n   return 0\n}\n\nmy @DATA = (1.5, 2.4, 5.1, -3.1, -3.8, 0.5);\n\nfor my $point ( [0,0] , [0,1] ,[3,1] ) {\n   print \"Point (\", join(',',@$point), \") is within triangle \";\n   my $iter = natatime 2, @DATA;\n   while ( my @vertex = $iter->()) { print '(',join(',',@vertex),') ' }\n   print ': ',naivePointInTriangle (@DATA, @$point) ? 'True' : 'False', \"\\n\" ;\n}\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 333523, "name": "Return multiple values", "source": "Translate Perl to Python: sub foo {\n    my ($a, $b) = @_;\n    return $a + $b, $a * $b;\n}\n", "target": "def addsub(x, y):\n  return x + y, x - y\n"}
{"id": 333524, "name": "Change e letters to i in words", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nno warnings 'uninitialized';\n\nmy $file = do { local (@ARGV, $/) = 'unixdict.txt'; <> };\nmy %i = map { tr/i/e/r => sprintf \"%30s  %s\\n\", tr/i/e/r, $_ }\n  grep !/e/, grep 5 <= length, $file =~ /^.*i.*$/gm;\nprint @i{ split ' ', $file };\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333525, "name": "Change e letters to i in words", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nno warnings 'uninitialized';\n\nmy $file = do { local (@ARGV, $/) = 'unixdict.txt'; <> };\nmy %i = map { tr/i/e/r => sprintf \"%30s  %s\\n\", tr/i/e/r, $_ }\n  grep !/e/, grep 5 <= length, $file =~ /^.*i.*$/gm;\nprint @i{ split ' ', $file };\n", "target": "\n\n\n\ndef ieTwins(s):\n    \n    longWords = [\n        w for w in s.splitlines()\n        if 5 < len(w)\n    ]\n    lexicon = {\n        w for w in longWords\n        if 'i' in w\n    }\n\n    return [\n        (w, twin) for w in longWords\n        if 'e' in w and (\n            twin := w.replace('e', 'i')\n        ) in lexicon\n    ]\n\n\n\n\ndef main():\n    \n    for pair in ieTwins(\n        readFile(\"unixdict.txt\")\n    ):\n        print(pair)\n\n\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333526, "name": "Fractran", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::BigRat;\n\nmy ($n, @P) = map Math::BigRat->new($_), qw{\n2 17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\n};\n\n$|=1;\nMAIN: for( 1 .. 5000 ) {\n\tprint \" \" if $_ > 1;\n\tmy ($pow, $rest) = (0, $n->copy);\n\tuntil( $rest->is_odd ) {\n\t\t++$pow;\n\t\t$rest->bdiv(2);\n\t}\n\tif( $rest->is_one ) {\n\t\tprint \"2**$pow\";\n\t} else {\n\t\t\n\t}\n\tfor my $f_i (@P) {\n\t\tmy $nf_i = $n * $f_i;\n\t\tnext unless $nf_i->is_int;\n\t\t$n = $nf_i;\n\t\tnext MAIN;\n\t}\n\tlast;\n}\n\nprint \"\\n\";\n", "target": "from fractions import Fraction\n\ndef fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'\n                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'\n                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):\n    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]\n\n    n = Fraction(n)\n    while True:\n        yield n.numerator\n        for f in flist:\n            if (n * f).denominator == 1:\n                break\n        else:\n            break\n        n *= f\n    \nif __name__ == '__main__':\n    n, m = 2, 15\n    print('First %i members of fractran(%i):\\n  ' % (m, n) +\n          ', '.join(str(f) for f,i in zip(fractran(n), range(m))))\n"}
{"id": 333527, "name": "Substring_Top and tail", "source": "Translate Perl to Python: print substr(\"knight\",1), \"\\n\";        \nprint substr(\"socks\", 0, -1), \"\\n\";    \nprint substr(\"brooms\", 1, -1), \"\\n\";   \n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 333528, "name": "Substring_Top and tail", "source": "Translate Perl to Python: print substr(\"knight\",1), \"\\n\";        \nprint substr(\"socks\", 0, -1), \"\\n\";    \nprint substr(\"brooms\", 1, -1), \"\\n\";   \n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 333529, "name": "Boolean values", "source": "Translate Perl to Python: my $x = 0.0;\nmy $true_or_false = $x ? 'true' : 'false';     \n", "target": ">>> True\nTrue\n>>> not True\nFalse\n>>> \n>>> False + 0\n0\n>>> True + 0\n1\n>>> False + 0j\n0j\n>>> True * 3.141\n3.141\n>>> \n>>> not 0\nTrue\n>>> not not 0\nFalse\n>>> not 1234\nFalse\n>>> bool(0.0)\nFalse\n>>> bool(0j)\nFalse\n>>> bool(1+2j)\nTrue\n>>> \n>>> bool([])\nFalse\n>>> bool([None])\nTrue\n>>> 'I contain something' if (None,) else 'I am empty'\n'I contain something'\n>>> bool({})\nFalse\n>>> bool(\"\")\nFalse\n>>> bool(\"False\")\nTrue\n"}
{"id": 333530, "name": "Multiline shebang", "source": "Translate Perl to Python: \neval '(exit $?0)' && eval 'exec perl -wS $0 ${1+\"$@\"}'\n& eval 'exec /usr/bin/perl -wS $0 $argv:q'\n\tif $running_under_some_shell;\n", "target": "\n\"exec\" \"python\" \"$0\"\n\nprint \"Hello World\"\n"}
{"id": 333531, "name": "Multiline shebang", "source": "Translate Perl to Python: \neval '(exit $?0)' && eval 'exec perl -wS $0 ${1+\"$@\"}'\n& eval 'exec /usr/bin/perl -wS $0 $argv:q'\n\tif $running_under_some_shell;\n", "target": "\n\"exec\" \"python\" \"$0\"\n\nprint \"Hello World\"\n"}
{"id": 333532, "name": "Plot coordinate pairs", "source": "Translate Perl to Python: use GD::Graph::points;\n\n@data = (\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n  [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0],\n);\n\n$graph = GD::Graph::points->new(400, 300);\nopen my $fh, '>', \"qsort-range-10-9.png\";\nbinmode $fh;\nprint $fh $graph->plot(\\@data)->png;\nclose $fh;\n", "target": ">>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\n>>> import pylab\n>>> pylab.plot(x, y, 'bo')\n>>> pylab.savefig('qsort-range-10-9.png')\n"}
{"id": 333533, "name": "Plot coordinate pairs", "source": "Translate Perl to Python: use GD::Graph::points;\n\n@data = (\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n  [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0],\n);\n\n$graph = GD::Graph::points->new(400, 300);\nopen my $fh, '>', \"qsort-range-10-9.png\";\nbinmode $fh;\nprint $fh $graph->plot(\\@data)->png;\nclose $fh;\n", "target": ">>> x = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> y = [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0]\n\n>>> import pylab\n>>> pylab.plot(x, y, 'bo')\n>>> pylab.savefig('qsort-range-10-9.png')\n"}
{"id": 333534, "name": "LZW compression", "source": "Translate Perl to Python: \nsub compress {\n    my $uncompressed = shift;\n\n    \n    my $dict_size = 256;\n    my %dictionary = map {chr $_ => chr $_} 0..$dict_size-1;\n\n    my $w = \"\";\n    my @result;\n    foreach my $c (split '', $uncompressed) {\n        my $wc = $w . $c;\n        if (exists $dictionary{$wc}) {\n            $w = $wc;\n        } else {\n            push @result, $dictionary{$w};\n            \n            $dictionary{$wc} = $dict_size;\n            $dict_size++;\n            $w = $c;\n        }\n    }\n\n    \n    if ($w) {\n        push @result, $dictionary{$w};\n    }\n    return @result;\n}\n\n\nsub decompress {\n    my @compressed = @_;\n\n    \n    my $dict_size = 256;\n    my %dictionary = map {chr $_ => chr $_} 0..$dict_size-1;\n\n    my $w = shift @compressed;\n    my $result = $w;\n    foreach my $k (@compressed) {\n        my $entry;\n        if (exists $dictionary{$k}) {\n            $entry = $dictionary{$k};\n        } elsif ($k == $dict_size) {\n            $entry = $w . substr($w,0,1);\n        } else {\n            die \"Bad compressed k: $k\";\n        }\n        $result .= $entry;\n\n        \n        $dictionary{$dict_size} = $w . substr($entry,0,1);\n        $dict_size++;\n\n        $w = $entry;\n    }\n    return $result;\n}\n\n\nmy @compressed = compress('TOBEORNOTTOBEORTOBEORNOT');\nprint \"@compressed\\n\";\nmy $decompressed = decompress(@compressed);\nprint \"$decompressed\\n\";\n", "target": "def compress(uncompressed):\n    \n\n    \n    dict_size = 256\n    dictionary = dict((chr(i), i) for i in range(dict_size))\n    \n\n    w = \"\"\n    result = []\n    for c in uncompressed:\n        wc = w + c\n        if wc in dictionary:\n            w = wc\n        else:\n            result.append(dictionary[w])\n            \n            dictionary[wc] = dict_size\n            dict_size += 1\n            w = c\n\n    \n    if w:\n        result.append(dictionary[w])\n    return result\n\n\ndef decompress(compressed):\n    \n    from io import StringIO\n\n    \n    dict_size = 256\n    dictionary = dict((i, chr(i)) for i in range(dict_size))\n    \n\n    \n    \n    result = StringIO()\n    w = chr(compressed.pop(0))\n    result.write(w)\n    for k in compressed:\n        if k in dictionary:\n            entry = dictionary[k]\n        elif k == dict_size:\n            entry = w + w[0]\n        else:\n            raise ValueError('Bad compressed k: %s' % k)\n        result.write(entry)\n\n        \n        dictionary[dict_size] = w + entry[0]\n        dict_size += 1\n\n        w = entry\n    return result.getvalue()\n\n\n\ncompressed = compress('TOBEORNOTTOBEORTOBEORNOT')\nprint (compressed)\ndecompressed = decompress(compressed)\nprint (decompressed)\n"}
{"id": 333535, "name": "Peano curve", "source": "Translate Perl to Python: use SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\n\nmy %rules = (\n    L => 'LFRFL-F-RFLFR+F+LFRFL',\n    R => 'RFLFR+F+LFRFL-F-RFLFR'\n);\nmy $peano = 'L';\n$peano =~ s/([LR])/$rules{$1}/eg for 1..4;\n\n\n($x, $y) = (0, 0);\n$theta   = pi/2;\n$r       = 4;\n\nfor (split //, $peano) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/2; }\n    elsif (/\\-/) { $theta -= pi/2; }\n}\n\n$max =  max(@X,@Y);\n$xt  = -min(@X)+10;\n$yt  = -min(@Y)+10;\n$svg = SVG->new(width=>$max+20, height=>$max+20);\n$points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen  $fh, '>', 'peano_curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import turtle as tt\nimport inspect\n\nstack = [] \ndef peano(iterations=1):\n    global stack\n\n    \n    ivan = tt.Turtle(shape = \"classic\", visible = True)\n\n\n    \n    screen = tt.Screen()\n    screen.title(\"Desenhin do Peano\")\n    screen.bgcolor(\"\n    screen.delay(0) \n    screen.setup(width=0.95, height=0.9)\n\n    \n    walk = 1\n\n    def screenlength(k):\n        \n        \n        if k != 0:\n            length = screenlength(k-1)\n            return 2*length + 1\n        else: return 0\n\n    kkkj = screenlength(iterations)\n    screen.setworldcoordinates(-1, -1, kkkj + 1, kkkj + 1)\n    ivan.color(\"\n\n\n    \n    def step1(k):\n        global stack\n        stack.append(len(inspect.stack()))\n        if k != 0:\n            ivan.left(90)\n            step2(k - 1)\n            ivan.forward(walk)\n            ivan.right(90)\n            step1(k - 1)\n            ivan.forward(walk)\n            step1(k - 1)\n            ivan.right(90)\n            ivan.forward(walk)\n            step2(k - 1)\n            ivan.left(90)\n    def step2(k):\n        global stack\n        stack.append(len(inspect.stack()))\n        if k != 0:\n            ivan.right(90)\n            step1(k - 1)\n            ivan.forward(walk)\n            ivan.left(90)\n            step2(k - 1)\n            ivan.forward(walk)\n            step2(k - 1)\n            ivan.left(90)\n            ivan.forward(walk)\n            step1(k - 1)\n            ivan.right(90)\n\n    \n    ivan.left(90)\n    step2(iterations)\n\n    tt.done()\n\nif __name__ == \"__main__\":\n    peano(4)\n    import pylab as P \n    P.plot(stack)\n    P.show()\n"}
{"id": 333536, "name": "Check input device is a terminal", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse 5.010;\nif (-t) {\n    say \"Input comes from tty.\";\n}\nelse {\n    say \"Input doesn't come from tty.\";\n}\n", "target": "from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n"}
{"id": 333537, "name": "Check input device is a terminal", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse 5.010;\nif (-t) {\n    say \"Input comes from tty.\";\n}\nelse {\n    say \"Input doesn't come from tty.\";\n}\n", "target": "from sys import stdin\nif stdin.isatty():\n    print(\"Input comes from tty.\")\nelse:\n    print(\"Input doesn't come from tty.\")\n"}
{"id": 333538, "name": "First 9 prime Fibonacci number", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nmy @first;\nmy $x = my $y = 1;\nwhile( @first < 9 )\n  {\n  ($x, $y) = ($x + $y, $x);\n  is_prime( $x ) and push @first, $x;\n  }\nprint \"@first\\n\";\n", "target": "from math import sqrt\nfrom time import time\n\nn = 12\nstart = time()\n\n\ndef prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3:\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\n\na, b, = 1, 1\nfibn = 3\nf = []\nwhile len(f) < n:\n    a, b, = b, a + b\n    if prime(b):\n        f.append(b)\n        print(\"fib(%d): %s (%s s)\" % (fibn, b, time() - start))\n    fibn += 1\n"}
{"id": 333539, "name": "First 9 prime Fibonacci number", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nmy @first;\nmy $x = my $y = 1;\nwhile( @first < 9 )\n  {\n  ($x, $y) = ($x + $y, $x);\n  is_prime( $x ) and push @first, $x;\n  }\nprint \"@first\\n\";\n", "target": "from math import sqrt\nfrom time import time\n\nn = 12\nstart = time()\n\n\ndef prime(x):\n    if x < 2:\n        return False\n    if x == 2 or x == 3:\n        return True\n    if x % 2 == 0:\n        return False\n    for i in range(3, int(sqrt(x)) + 1, 2):\n        if x % i == 0:\n            return False\n    return True\n\n\na, b, = 1, 1\nfibn = 3\nf = []\nwhile len(f) < n:\n    a, b, = b, a + b\n    if prime(b):\n        f.append(b)\n        print(\"fib(%d): %s (%s s)\" % (fibn, b, time() - start))\n    fibn += 1\n"}
{"id": 333540, "name": "Bioinformatics_base count", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy %cnt;\nmy $total = 0;\n\nwhile ($_ = <DATA>) {\n    chomp;\n    printf \"%4d: %s\\n\", $total+1, s/(.{10})/$1 /gr;\n    $total += length;\n    $cnt{$_}++ for split //\n}\n\nsay \"\\nTotal bases: $total\";\nsay \"$_: \" . ($cnt{$_}//0) for <A C G T>;\n\n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 333541, "name": "Bioinformatics_base count", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy %cnt;\nmy $total = 0;\n\nwhile ($_ = <DATA>) {\n    chomp;\n    printf \"%4d: %s\\n\", $total+1, s/(.{10})/$1 /gr;\n    $total += length;\n    $cnt{$_}++ for split //\n}\n\nsay \"\\nTotal bases: $total\";\nsay \"$_: \" . ($cnt{$_}//0) for <A C G T>;\n\n", "target": "from collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n    \nif __name__ == '__main__':\n    print(\"SEQUENCE:\")\n    sequence = \n    seq_pp(sequence)\n"}
{"id": 333542, "name": "Wireworld", "source": "Translate Perl to Python: my @f = ([],(map {chomp;['',( split // ),'']} <>),[]);\n\nfor (1 .. 10) {\n\tprint join \"\", map {\"@$_\\n\"} @f;\n\tmy @a = ([]);\n\tfor my $y (1 .. $\n\t\tmy $r = $f[$y];\n\t\tmy $rr = [''];\n\t\tfor my $x (1 .. $\n\t\t\tmy $c = $r->[$x];\n\t\t\tpush @$rr,\n\t\t\t\t$c eq 'H' ? 't' :\n\t\t\t\t$c eq 't' ? '.' :\n\t\t\t\t$c eq '.' ? (join('', map {\"@{$f[$_]}[$x-1 .. $x+1]\"=~/H/g} ($y-1 .. $y+1)) =~ /^H{1,2}$/ ? 'H' : '.') :\n\t\t\t\t$c;\n\t\t}\n\t\tpush @$rr, '';\n\t\tpush @a, $rr;\n\t}\n\t@f = (@a,[]);\n}\n", "target": "\n\nfrom io import StringIO\nfrom collections import namedtuple\nfrom pprint import pprint as pp\nimport copy\n\nWW = namedtuple('WW', 'world, w, h')\nhead, tail, conductor, empty = allstates = 'Ht. '\n\n\ninfile = StringIO()\n\ndef readfile(f):\n    \n    world  = [row.rstrip('\\r\\n') for row in f]\n    height = len(world)\n    width  = max(len(row) for row in world)\n    \n    nonrow = [ \" %*s \" % (-width, \"\") ]\n    world  = nonrow + \\\n               [ \" %*s \" % (-width, row) for row in world ] + \\\n               nonrow   \n    world = [list(row) for row in world]\n    return WW(world, width, height)\n\ndef newcell(currentworld, x, y):\n    istate = currentworld[y][x]\n    assert istate in allstates, 'Wireworld cell set to unknown value \"%s\"' % istate\n    if istate == head:\n        ostate = tail\n    elif istate == tail:\n        ostate = conductor\n    elif istate == empty:\n        ostate = empty\n    else: \n        n = sum( currentworld[y+dy][x+dx] == head\n                 for dx,dy in ( (-1,-1), (-1,+0), (-1,+1),\n                                (+0,-1),          (+0,+1),\n                                (+1,-1), (+1,+0), (+1,+1) ) )\n        ostate = head if 1 <= n <= 2 else conductor\n    return ostate\n\ndef nextgen(ww):\n    'compute next generation of wireworld'\n    world, width, height = ww\n    newworld = copy.deepcopy(world)\n    for x in range(1, width+1):\n        for y in range(1, height+1):\n            newworld[y][x] = newcell(world, x, y)\n    return WW(newworld, width, height)\n\ndef world2string(ww):\n    return '\\n'.join( ''.join(row[1:-1]).rstrip() for row in ww.world[1:-1] )\n\nww = readfile(infile)\ninfile.close()\n\nfor gen in range(10):\n    print ( (\"\\n%3i \" % gen) + '=' * (ww.w-4) + '\\n' )\n    print ( world2string(ww) )\n    ww = nextgen(ww)\n"}
{"id": 333543, "name": "Terminal control_Inverse video", "source": "Translate Perl to Python: print \"normal\\n\";\nsystem \"tput rev\";\nprint \"reversed\\n\";\nsystem \"tput sgr0\";\nprint \"normal\\n\";\n", "target": "\n\nprint \"\\033[7mReversed\\033[m Normal\"\n"}
{"id": 333544, "name": "Ulam spiral (for primes)", "source": "Translate Perl to Python: use ntheory qw/is_prime/;\nuse Imager;\n\nmy $n = shift || 512;\nmy $start = shift || 1;\nmy $file = \"ulam.png\";\n\nsub cell {\n  my($n, $x, $y, $start) = @_;\n  $y -= $n>>1;\n  $x -= ($n-1)>>1;\n  my $l = 2*(abs($x) > abs($y) ? abs($x) : abs($y));\n  my $d = ($y > $x)  ?  $l*3 + $x + $y  : $l-$x-$y;\n  ($l-1)**2 + $d + $start - 1;\n}\n\nmy $black = Imager::Color->new('\nmy $white = Imager::Color->new('\nmy $img = Imager->new(xsize => $n, ysize => $n, channels => 1);\n$img->box(filled=>1, color=>$white);\n\nfor my $y (0 .. $n-1) {\n  for my $x (0 .. $n-1) {\n    my $v = cell($n, $x, $y, $start);\n    $img->setpixel(x => $x, y => $y, color => $black) if is_prime($v);\n  }\n}\n\n$img->write(file => $file) or die \"Cannot write $file: \", $img->errstr, \"\\n\";\n", "target": "\nfrom __future__ import print_function, division\nfrom math import sqrt\n\ndef cell(n, x, y, start=1):\n    d, y, x = 0, y - n//2, x - (n - 1)//2\n    l = 2*max(abs(x), abs(y))\n    d = (l*3 + x + y) if y >= x else (l - x - y)\n    return (l - 1)**2 + d + start - 1\n\ndef show_spiral(n, symbol='\n    top = start + n*n + 1\n    is_prime = [False,False,True] + [True,False]*(top//2)\n    for x in range(3, 1 + int(sqrt(top))):\n        if not is_prime[x]: continue\n        for i in range(x*x, top, x*2):\n            is_prime[i] = False\n\n    cell_str = lambda x: f(x) if is_prime[x] else space\n    f = lambda _: symbol \n\n    if space == None: space = ' '*len(symbol)\n\n    if not len(symbol): \n        max_str = len(str(n*n + start - 1))\n        if space == None: space = '.'*max_str + ' '\n        f = lambda x: ('%' + str(max_str) + 'd ')%x\n\n    for y in range(n):\n        print(''.join(cell_str(v) for v in [cell(n, x, y, start) for x in range(n)]))\n    print()\n\nshow_spiral(10, symbol=u'\u265e', space=u'\u2658') \nshow_spiral(9, symbol='', space=' - ')\n\n\n"}
{"id": 333545, "name": "Fibonacci word", "source": "Translate Perl to Python: sub fiboword;\n{\n    my ($a, $b, $count) = (1, 0, 0);\n    sub fiboword {\n        $count++;\n        return $a if $count == 1;\n        return $b if $count == 2;\n        ($a, $b) = ($b, \"$b$a\");\n        return $b;\n    }\n}\nsub entropy {\n    my %c;\n    $c{$_}++ for split //, my $str = shift;\n    my $e = 0;\n    for (values %c) {\n        my $p = $_ / length $str;\n        $e -= $p * log $p;\n    }\n    return $e / log 2;\n}\n\nmy $count;\nwhile ($count++ < 37) {\n    my $word = fiboword;\n    printf \"%5d\\t%10d\\t%.8e\\t%s\\n\",\n    $count,\n    length($word),\n    entropy($word),\n    $count > 9 ? '' : $word\n}\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 333546, "name": "Fibonacci word", "source": "Translate Perl to Python: sub fiboword;\n{\n    my ($a, $b, $count) = (1, 0, 0);\n    sub fiboword {\n        $count++;\n        return $a if $count == 1;\n        return $b if $count == 2;\n        ($a, $b) = ($b, \"$b$a\");\n        return $b;\n    }\n}\nsub entropy {\n    my %c;\n    $c{$_}++ for split //, my $str = shift;\n    my $e = 0;\n    for (values %c) {\n        my $p = $_ / length $str;\n        $e -= $p * log $p;\n    }\n    return $e / log 2;\n}\n\nmy $count;\nwhile ($count++ < 37) {\n    my $word = fiboword;\n    printf \"%5d\\t%10d\\t%.8e\\t%s\\n\",\n    $count,\n    length($word),\n    entropy($word),\n    $count > 9 ? '' : $word\n}\n", "target": ">>> import math\n>>> from collections import Counter\n>>> \n>>> def entropy(s):\n...     p, lns = Counter(s), float(len(s))\n...     return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n... \n>>> \n>>> def fibword(nmax=37):\n...     fwords = ['1', '0']\n...     print('%-3s %10s %-10s %s' % tuple('N Length Entropy Fibword'.split()))\n...     def pr(n, fwords):\n...         while len(fwords) < n:\n...             fwords += [''.join(fwords[-2:][::-1])]\n...         v = fwords[n-1]\n...         print('%3i %10i %10.7g %s' % (n, len(v), entropy(v), v if len(v) < 20 else '<too long>'))\n...     for n in range(1, nmax+1): pr(n, fwords)\n... \n>>> fibword()\nN       Length Entropy    Fibword\n  1          1         -0 1\n  2          1         -0 0\n  3          2          1 01\n  4          3  0.9182958 010\n  5          5  0.9709506 01001\n  6          8   0.954434 01001010\n  7         13  0.9612366 0100101001001\n  8         21  0.9587119 <too long>\n  9         34  0.9596869 <too long>\n 10         55   0.959316 <too long>\n 11         89  0.9594579 <too long>\n 12        144  0.9594038 <too long>\n 13        233  0.9594244 <too long>\n 14        377  0.9594165 <too long>\n 15        610  0.9594196 <too long>\n 16        987  0.9594184 <too long>\n 17       1597  0.9594188 <too long>\n 18       2584  0.9594187 <too long>\n 19       4181  0.9594187 <too long>\n 20       6765  0.9594187 <too long>\n 21      10946  0.9594187 <too long>\n 22      17711  0.9594187 <too long>\n 23      28657  0.9594187 <too long>\n 24      46368  0.9594187 <too long>\n 25      75025  0.9594187 <too long>\n 26     121393  0.9594187 <too long>\n 27     196418  0.9594187 <too long>\n 28     317811  0.9594187 <too long>\n 29     514229  0.9594187 <too long>\n 30     832040  0.9594187 <too long>\n 31    1346269  0.9594187 <too long>\n 32    2178309  0.9594187 <too long>\n 33    3524578  0.9594187 <too long>\n 34    5702887  0.9594187 <too long>\n 35    9227465  0.9594187 <too long>\n 36   14930352  0.9594187 <too long>\n 37   24157817  0.9594187 <too long>\n>>>\n"}
{"id": 333547, "name": "Text processing_1", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $nodata = 0;               \nmy $nodata_max = -1;          \nmy $nodata_maxline = \"!\";     \n\nmy $infiles = join \", \", @ARGV;\n\nmy $tot_file = 0;\nmy $num_file = 0;\n\nwhile (<>) {\n  chomp;\n  my $tot_line = 0;             \n  my $num_line = 0;             \n  my $rejects  = 0;\n \n  \n  my ($date, @fields) = split;\n  while (@fields and my ($datum, $flag) = splice @fields, 0, 2) {\n    if ($flag+1 < 2) {\n      $nodata++;\n      $rejects++;\n      next;\n    }\n\n    \n    if($nodata_max == $nodata and $nodata > 0){\n      $nodata_maxline = \"$nodata_maxline, $date\";\n    }\n    if($nodata_max < $nodata and $nodata > 0){\n      $nodata_max = $nodata;\n      $nodata_maxline = $date;\n    }\n    \n    $nodata = 0; \n    \n    $tot_line += $datum;\n    $num_line++;\n  }\n \n  \n  $tot_file += $tot_line;\n  $num_file += $num_line;\n \n  printf \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\\n\",\n         $date, $rejects, $num_line, $tot_line, ($num_line>0)? $tot_line/$num_line: 0;\n \n}\n \nprintf \"\\n\";\nprintf \"File(s)  = %s\\n\", $infiles;\nprintf \"Total    = %10.3f\\n\", $tot_file;\nprintf \"Readings = %6i\\n\", $num_file;\nprintf \"Average  = %10.3f\\n\", $tot_file / $num_file;\n \nprintf \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\\n\", \n       $nodata_max, $nodata_maxline;\n", "target": "import fileinput\nimport sys\n\nnodata = 0;             \nnodata_max=-1;          \nnodata_maxline=[];      \n\ntot_file = 0            \nnum_file = 0            \n\ninfiles = sys.argv[1:]\n\nfor line in fileinput.input():\n  tot_line=0;             \n  num_line=0;             \n\n  \n  field = line.split()\n  date  = field[0]\n  data  = [float(f) for f in field[1::2]]\n  flags = [int(f)   for f in field[2::2]]\n\n  for datum, flag in zip(data, flags):\n    if flag<1:\n      nodata += 1\n    else:\n      \n      if nodata_max==nodata and nodata>0:\n        nodata_maxline.append(date)\n      if nodata_max<nodata and nodata>0:\n        nodata_max=nodata\n        nodata_maxline=[date]\n      \n      nodata=0; \n      \n      tot_line += datum\n      num_line += 1\n\n  \n  tot_file += tot_line\n  num_file += num_line\n\n  print \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\" % (\n        date, \n        len(data) -num_line, \n        num_line, tot_line, \n        tot_line/num_line if (num_line>0) else 0)\n\nprint \"\"\nprint \"File(s)  = %s\" % (\", \".join(infiles),)\nprint \"Total    = %10.3f\" % (tot_file,)\nprint \"Readings = %6i\" % (num_file,)\nprint \"Average  = %10.3f\" % (tot_file / num_file,)\n\nprint \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\" % (\n    nodata_max, \", \".join(nodata_maxline))\n"}
{"id": 333548, "name": "Death Star", "source": "Translate Perl to Python: use strict;\n\nsub sq {\n\tmy $s = 0;\n\t$s += $_ ** 2 for @_;\n\t$s;\n}\n\nsub hit {\n\tmy ($sph, $x, $y) = @_;\n\t$x -= $sph->[0];\n\t$y -= $sph->[1];\n\n\tmy $z = sq($sph->[3]) - sq($x, $y);\n\treturn\tif $z < 0;\n\n\t$z = sqrt $z;\n\treturn $sph->[2] - $z, $sph->[2] + $z;\n}\n\nsub normalize {\n\tmy $v = shift;\n\tmy $n = sqrt sq(@$v);\n\t$_ /= $n for @$v;\n\t$v;\n}\n\nsub dot {\n\tmy ($x, $y) = @_;\n\tmy $s = $x->[0] * $y->[0] + $x->[1] * $y->[1] + $x->[2] * $y->[2];\n\t$s > 0 ? $s : 0;\n}\n\nmy $pos = [ 120, 120, 0, 120 ];\nmy $neg = [ -77, -33, -100, 190 ];\nmy $light = normalize([ -12, 13, -10 ]);\nsub draw {\n\tmy ($k, $amb) = @_;\n\tbinmode STDOUT, \":raw\";\n\tprint \"P5\\n\", $pos->[0] * 2 + 3, \" \", $pos->[1] * 2 + 3, \"\\n255\\n\";\n\tfor my $y (($pos->[1] - $pos->[3] - 1) .. ($pos->[1] + $pos->[3] + 1)) {\n\t\tmy @row = ();\n\t\tfor my $x (($pos->[0] - $pos->[3] - 1) .. ($pos->[0] + $pos->[3] + 1)) {\n\t\t\tmy ($hit, @hs) = 0;\n\t\t\tmy @h = hit($pos, $x, $y);\n\n\t\t\tif (!@h) { $hit = 0 }\n\t\t\telsif (!(@hs = hit($neg, $x, $y))) { $hit = 1 }\n\t\t\telsif ($hs[0] > $h[0]) { $hit = 1 }\n\t\t\telsif ($hs[1] > $h[0]) { $hit = $hs[1] > $h[1] ? 0 : 2 }\n\t\t\telse { $hit = 1 }\n\n\t\t\tmy ($val, $v);\n\t\t\tif ($hit == 0) { $val = 0 }\n\t\t\telsif ($hit == 1) {\n\t\t\t\t$v = [\t$x - $pos->[0],\n\t\t\t\t\t$y - $pos->[1],\n\t\t\t\t\t$h[0] - $pos->[2] ];\n\t\t\t} else {\n\t\t\t\t$v = [\t$neg->[0] - $x,\n\t\t\t\t\t$neg->[1] - $y,\n\t\t\t\t\t$neg->[2] - $hs[1] ];\n\t\t\t}\n\t\t\tif ($v) {\n\t\t\t\tnormalize($v);\n\t\t\t\t$val = int((dot($v, $light) ** $k + $amb) * 255);\n\t\t\t\t$val = ($val > 255) ? 255 : ($val < 0) ? 0 : $val;\n\t\t\t}\n\t\t\tpush @row, $val;\n\t\t}\n\t\tprint pack(\"C*\", @row);\n\t}\n}\n\ndraw(2, 0.2);\n", "target": "import sys, math, collections\n\nSphere = collections.namedtuple(\"Sphere\", \"cx cy cz r\")\nV3 = collections.namedtuple(\"V3\", \"x y z\")\n\ndef normalize((x, y, z)):\n    len = math.sqrt(x**2 + y**2 + z**2)\n    return V3(x / len, y / len, z / len)\n\ndef dot(v1, v2):\n    d = v1.x*v2.x + v1.y*v2.y + v1.z*v2.z\n    return -d if d < 0 else 0.0\n\ndef hit_sphere(sph, x0, y0):\n    x = x0 - sph.cx\n    y = y0 - sph.cy\n    zsq = sph.r ** 2 - (x ** 2 + y ** 2)\n    if zsq < 0:\n        return (False, 0, 0)\n    szsq = math.sqrt(zsq)\n    return (True, sph.cz - szsq, sph.cz + szsq)\n\ndef draw_sphere(k, ambient, light):\n    shades = \".:!*oe&\n    pos = Sphere(20.0, 20.0, 0.0, 20.0)\n    neg = Sphere(1.0, 1.0, -6.0, 20.0)\n\n    for i in xrange(int(math.floor(pos.cy - pos.r)),\n                    int(math.ceil(pos.cy + pos.r) + 1)):\n        y = i + 0.5\n        for j in xrange(int(math.floor(pos.cx - 2 * pos.r)),\n                        int(math.ceil(pos.cx + 2 * pos.r) + 1)):\n            x = (j - pos.cx) / 2.0 + 0.5 + pos.cx\n\n            (h, zb1, zb2) = hit_sphere(pos, x, y)\n            if not h:\n                hit_result = 0\n            else:\n                (h, zs1, zs2) = hit_sphere(neg, x, y)\n                if not h:\n                    hit_result = 1\n                elif zs1 > zb1:\n                    hit_result = 1\n                elif zs2 > zb2:\n                    hit_result = 0\n                elif zs2 > zb1:\n                    hit_result = 2\n                else:\n                    hit_result = 1\n\n            if hit_result == 0:\n                sys.stdout.write(' ')\n                continue\n            elif hit_result == 1:\n                vec = V3(x - pos.cx, y - pos.cy, zb1 - pos.cz)\n            elif hit_result == 2:\n                vec = V3(neg.cx-x, neg.cy-y, neg.cz-zs2)\n            vec = normalize(vec)\n\n            b = dot(light, vec) ** k + ambient\n            intensity = int((1 - b) * len(shades))\n            intensity = min(len(shades), max(0, intensity))\n            sys.stdout.write(shades[intensity])\n        print\n\nlight = normalize(V3(-50, 30, 50))\ndraw_sphere(2, 0.5, light)\n"}
{"id": 333549, "name": "Colour pinstripe_Display", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse GD;\n\nmy %colors = (\n\"white\"   => [255,255,255], \"red\"    => [255,  0,  0], \"green\" => [  0,255,  0], \"blue\"  => [  0,  0,255],\n\"magenta\" => [255,  0,255], \"yellow\" => [255,255,  0], \"cyan\"  => [  0,255,255], \"black\" => [  0,  0,  0]);\n\nmy($height, $width) = (240, 320);\nmy $image = GD::Image->new( $width , $height );\n\nmy @paintcolors;\nmy $barheight = $height / 4;\nmy($startx, $starty, $run, $colorindex) = (0) x 4;\n\nfor my $color ( sort keys %colors ) {\n    push @paintcolors, $image->colorAllocate( @{$colors{ $color }} );\n}\n\nwhile ( $run < 4 ) {\n    my $barwidth =  $run + 1;\n    while ( $startx + $barwidth < $width ) {\n        $image->filledRectangle( $startx, $starty,\n                                 $startx + $barwidth,\n                                 $starty + $barheight - 1,\n                                 $paintcolors[ $colorindex % 8 ] );\n        $startx += $barwidth;\n        $colorindex++;\n    }\n    $starty    += $barheight;\n    $startx     = 0;\n    $colorindex = 0;\n    $run++;\n}\n\nopen ( DISPLAY , '>' , 'pinstripes.png' ) or die;\nbinmode DISPLAY;\nprint DISPLAY $image->png;\nclose DISPLAY;\n", "target": "from turtle import *\n\ncolors = [\"black\", \"red\", \"green\", \"blue\", \"magenta\", \"cyan\", \"yellow\", \"white\"]\n\n\n\nscreen = getscreen()\n\nleft_edge = -screen.window_width()//2\n\nright_edge = screen.window_width()//2\n\nquarter_height = screen.window_height()//4\n\nhalf_height = quarter_height * 2\n\nspeed(\"fastest\")\n\nfor quarter in range(4):\n    pensize(quarter+1)\n    colornum = 0\n\n    min_y = half_height - ((quarter + 1) * quarter_height)\n    max_y = half_height - ((quarter) * quarter_height)\n    \n    for x in range(left_edge,right_edge,quarter+1):\n        penup()\n        pencolor(colors[colornum])\n        colornum = (colornum + 1) % len(colors)\n        setposition(x,min_y)\n        pendown()\n        setposition(x,max_y)\n         \nnotused = input(\"Hit enter to continue: \")\n"}
{"id": 333550, "name": "Birthday problem", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::AllUtils qw(max min uniqnum count_by any);\nuse Math::Random qw(random_uniform_integer);\n\nsub simulation {\n    my($c) = shift;\n    my $max_trials = 1_000_000;\n    my $min_trials =    10_000;\n    my $n = int 47 * ($c-1.5)**1.5; \n    my $N = min $max_trials, max $min_trials, 1000 * sqrt $n;\n\n    while (1) {\n        my $yes = 0;\n        for (1..$N) {\n            my %birthday_freq = count_by { $_ } random_uniform_integer($n, 1, 365);\n            $yes++ if any { $birthday_freq{$_} >= $c } keys %birthday_freq;\n        }\n        my $p = $yes/$N;\n        return($n, $p) if $p > 0.5;\n        $N = min $max_trials, max $min_trials, int 1000/(0.5-$p)**1.75;\n        $n++;\n    }\n}\n\nprintf \"$_ people in a group of %s share a common birthday. (%.4f)\\n\", simulation($_) for 2..5\n", "target": "from random import randint\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday may have 2 dates shared between two people each' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = sum((groupsize - len(set(randint(1,365) for i in g)) >= sh)\n             for j in range(rep))\n    return (eq * 100.) / rep\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday must all share same common day' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = 0\n    for j in range(rep):\n        group = [randint(1,365) for i in g]\n        if (groupsize - len(set(group)) >= sh and\n            any( group.count(member) >= sharers for member in set(group))):\n            eq += 1\n    return (eq * 100.) / rep\n\ngroup_est = [2]\nfor sharers in (2, 3, 4, 5):\n    groupsize = group_est[-1]+1\n    while equal_birthdays(sharers, groupsize, 100) < 50.:\n        \n        groupsize += 1\n    for groupsize in range(int(groupsize - (groupsize - group_est[-1])/4.), groupsize + 999):\n        \n        eq = equal_birthdays(sharers, groupsize, 250)\n        if eq > 50.:\n            break\n    for groupsize in range(groupsize - 1, groupsize +999):\n        \n        eq = equal_birthdays(sharers, groupsize, 50000)\n        if eq > 50.:\n            break\n    group_est.append(groupsize)\n    print(\"%i independent people in a group of %s share a common birthday. (%5.1f)\" % (sharers, groupsize, eq))\n"}
{"id": 333551, "name": "Birthday problem", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::AllUtils qw(max min uniqnum count_by any);\nuse Math::Random qw(random_uniform_integer);\n\nsub simulation {\n    my($c) = shift;\n    my $max_trials = 1_000_000;\n    my $min_trials =    10_000;\n    my $n = int 47 * ($c-1.5)**1.5; \n    my $N = min $max_trials, max $min_trials, 1000 * sqrt $n;\n\n    while (1) {\n        my $yes = 0;\n        for (1..$N) {\n            my %birthday_freq = count_by { $_ } random_uniform_integer($n, 1, 365);\n            $yes++ if any { $birthday_freq{$_} >= $c } keys %birthday_freq;\n        }\n        my $p = $yes/$N;\n        return($n, $p) if $p > 0.5;\n        $N = min $max_trials, max $min_trials, int 1000/(0.5-$p)**1.75;\n        $n++;\n    }\n}\n\nprintf \"$_ people in a group of %s share a common birthday. (%.4f)\\n\", simulation($_) for 2..5\n", "target": "from random import randint\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday may have 2 dates shared between two people each' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = sum((groupsize - len(set(randint(1,365) for i in g)) >= sh)\n             for j in range(rep))\n    return (eq * 100.) / rep\n\ndef equal_birthdays(sharers=2, groupsize=23, rep=100000):\n    'Note: 4 sharing common birthday must all share same common day' \n    g = range(groupsize)\n    sh = sharers - 1\n    eq = 0\n    for j in range(rep):\n        group = [randint(1,365) for i in g]\n        if (groupsize - len(set(group)) >= sh and\n            any( group.count(member) >= sharers for member in set(group))):\n            eq += 1\n    return (eq * 100.) / rep\n\ngroup_est = [2]\nfor sharers in (2, 3, 4, 5):\n    groupsize = group_est[-1]+1\n    while equal_birthdays(sharers, groupsize, 100) < 50.:\n        \n        groupsize += 1\n    for groupsize in range(int(groupsize - (groupsize - group_est[-1])/4.), groupsize + 999):\n        \n        eq = equal_birthdays(sharers, groupsize, 250)\n        if eq > 50.:\n            break\n    for groupsize in range(groupsize - 1, groupsize +999):\n        \n        eq = equal_birthdays(sharers, groupsize, 50000)\n        if eq > 50.:\n            break\n    group_est.append(groupsize)\n    print(\"%i independent people in a group of %s share a common birthday. (%5.1f)\" % (sharers, groupsize, eq))\n"}
{"id": 333552, "name": "Draw a sphere", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $x = my $y = 255;\n$x |= 1; \nmy $depth = 255;\n\nmy $light = Vector->new(rand, rand, rand)->normalized;\n\nprint \"P2\\n$x $y\\n$depth\\n\";\n\nmy ($r, $ambient) = (($x - 1)/2, 0);\nmy ($r2) = $r ** 2;\n{\n    for my $x (-$r .. $r) {\n\tmy $x2 = $x**2;\n\tfor my $y (-$r .. $r) {\n\t    my $y2 = $y**2;\n\t    my $pixel = 0;\n\t    if ($x2 + $y2 < $r2) {\n\t\tmy $v = Vector->new($x, $y, sqrt($r2 - $x2 - $y2))->normalized;\n\t\tmy $I = $light . $v + $ambient;\n\t\t$I = $I < 0 ? 0 : $I > 1 ? 1 : $I;\n\t\t$pixel = int($I * $depth);\n\t    }\n\t    print $pixel;\n\t    print $y == $r ? \"\\n\" : \" \";\n\t}\n    }\n}\n\npackage Vector {\n    sub new {\n\tmy $class = shift;\n\tbless ref($_[0]) eq 'Array' ? $_[0] : [ @_ ], $class;\n    }\n    sub normalized {\n\tmy $this = shift;\n\tmy $norm = sqrt($this . $this);\n\tref($this)->new( map $_/$norm, @$this );\n    }\n    use overload q{.} => sub {\n\tmy ($a, $b) = @_;\n\tmy $sum = 0;\n\tfor (0 .. @$a - 1) {\n\t    $sum += $a->[$_] * $b->[$_]\n\t}\n\treturn $sum;\n    },\n    q{\"\"} => sub { sprintf \"Vector:[%s]\", join ' ', @{shift()} };\n}\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 333553, "name": "Draw a sphere", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $x = my $y = 255;\n$x |= 1; \nmy $depth = 255;\n\nmy $light = Vector->new(rand, rand, rand)->normalized;\n\nprint \"P2\\n$x $y\\n$depth\\n\";\n\nmy ($r, $ambient) = (($x - 1)/2, 0);\nmy ($r2) = $r ** 2;\n{\n    for my $x (-$r .. $r) {\n\tmy $x2 = $x**2;\n\tfor my $y (-$r .. $r) {\n\t    my $y2 = $y**2;\n\t    my $pixel = 0;\n\t    if ($x2 + $y2 < $r2) {\n\t\tmy $v = Vector->new($x, $y, sqrt($r2 - $x2 - $y2))->normalized;\n\t\tmy $I = $light . $v + $ambient;\n\t\t$I = $I < 0 ? 0 : $I > 1 ? 1 : $I;\n\t\t$pixel = int($I * $depth);\n\t    }\n\t    print $pixel;\n\t    print $y == $r ? \"\\n\" : \" \";\n\t}\n    }\n}\n\npackage Vector {\n    sub new {\n\tmy $class = shift;\n\tbless ref($_[0]) eq 'Array' ? $_[0] : [ @_ ], $class;\n    }\n    sub normalized {\n\tmy $this = shift;\n\tmy $norm = sqrt($this . $this);\n\tref($this)->new( map $_/$norm, @$this );\n    }\n    use overload q{.} => sub {\n\tmy ($a, $b) = @_;\n\tmy $sum = 0;\n\tfor (0 .. @$a - 1) {\n\t    $sum += $a->[$_] * $b->[$_]\n\t}\n\treturn $sum;\n    },\n    q{\"\"} => sub { sprintf \"Vector:[%s]\", join ' ', @{shift()} };\n}\n", "target": "import math\n\nshades = ('.',':','!','*','o','e','&','\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n"}
{"id": 333554, "name": "Thiele's interpolation formula", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Math::Trig;\nuse utf8;\n\nsub thiele {\n    my($x, $y) = @_;\n\n    my @\u03c1;\n    push @\u03c1, [($$y[$_]) x (@$y-$_)] for 0 .. @$y-1;\n    for my $i (0 .. @\u03c1 - 2) {\n        $\u03c1[$i][1] = (($$x[$i] - $$x[$i+1]) / ($\u03c1[$i][0] - $\u03c1[$i+1][0]))\n    }\n    for my $i (2 .. @\u03c1 - 2) {\n        for my $j (0 .. (@\u03c1 - 2) - $i) {\n            $\u03c1[$j][$i] = ((($$x[$j]-$$x[$j+$i]) / ($\u03c1[$j][$i-1]-$\u03c1[$j+1][$i-1])) + $\u03c1[$j+1][$i-2])\n        }\n    }\n    my @\u03c10 = @{$\u03c1[0]};\n\n    return sub {\n        my($xin) = @_;\n\n        my $a = 0;\n        for my $i (reverse 2 .. @\u03c10 - 2) {\n            $a = (($xin - $$x[$i-1]) / ($\u03c10[$i] - $\u03c10[$i-2] + $a))\n        }\n        $$y[0] + (($xin - $$x[0]) / ($\u03c10[1] + $a))\n    }\n}\n\nmy(@x,@sin_table,@cos_table,@tan_table);\npush @x,  .05 * $_ for 0..31;\npush @sin_table, sin($_) for @x;\npush @cos_table, cos($_) for @x;\npush @tan_table, tan($_) for @x;\n\nmy $sin_inverse = thiele(\\@sin_table, \\@x);\nmy $cos_inverse = thiele(\\@cos_table, \\@x);\nmy $tan_inverse = thiele(\\@tan_table, \\@x);\n\nsay 6 * &$sin_inverse(0.5);\nsay 3 * &$cos_inverse(0.5);\nsay 4 * &$tan_inverse(1.0);\n", "target": "\n\nimport math\n\ndef thieleInterpolator(x, y):\n    \u03c1 = [[yi]*(len(y)-i) for i, yi in enumerate(y)]\n    for i in range(len(\u03c1)-1):\n        \u03c1[i][1] = (x[i] - x[i+1]) / (\u03c1[i][0] - \u03c1[i+1][0])\n    for i in range(2, len(\u03c1)):\n        for j in range(len(\u03c1)-i):\n            \u03c1[j][i] = (x[j]-x[j+i]) / (\u03c1[j][i-1]-\u03c1[j+1][i-1]) + \u03c1[j+1][i-2]\n    \u03c10 = \u03c1[0]\n    def t(xin):\n        a = 0\n        for i in range(len(\u03c10)-1, 1, -1):\n            a = (xin - x[i-1]) / (\u03c10[i] - \u03c10[i-2] + a)\n        return y[0] + (xin-x[0]) / (\u03c10[1]+a)\n    return t\n\n\nxVal = [i*.05 for i in range(32)]\ntSin = [math.sin(x) for x in xVal]\ntCos = [math.cos(x) for x in xVal]\ntTan = [math.tan(x) for x in xVal]\n\niSin = thieleInterpolator(tSin, xVal)\niCos = thieleInterpolator(tCos, xVal)\niTan = thieleInterpolator(tTan, xVal)\n\nprint('{:16.14f}'.format(6*iSin(.5)))\nprint('{:16.14f}'.format(3*iCos(.5)))\nprint('{:16.14f}'.format(4*iTan(1)))\n"}
{"id": 333555, "name": "Longest string challenge", "source": "Translate Perl to Python: \nEND{ print $all }\n\nsubstr($_, length($l)) and $all = $l = $_\n\tor substr($l, length) or $all .= $_;\n", "target": "import fileinput\n\n\n\n\n\n\ndef longer(a, b):\n    try:\n        b[len(a)-1]\n        return False\n    except:\n        return True\n\nlongest, lines = '', ''\nfor x in fileinput.input():\n    if longer(x, longest):\n        lines, longest = x, x\n    elif not longer(longest, x):\n        lines += x\n\nprint(lines, end='')\n"}
{"id": 333556, "name": "Sierpinski arrowhead curve", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\nuse constant pi => 2 * atan2(1, 0);\n\nmy %rules = (\n    X => 'YF+XF+Y',\n    Y => 'XF-YF-X'\n);\nmy $S = 'Y';\n$S =~ s/([XY])/$rules{$1}/eg for 1..7;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = 0;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/3; }\n    elsif (/\\-/) { $theta -= pi/3; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-arrowhead-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "t = { 'x': 20, 'y': 30, 'a': 60 }\n\ndef setup():\n    size(450, 400)\n    background(0, 0, 200)\n    stroke(-1)\n    sc(7, 400, -60)\n\ndef sc(o, l, a, s = t, X = 'x', Y = 'y', A = 'a', HALF = .5):\n    if o:\n        o -= 1\n        l *= HALF\n        sc(o, l, -a)[A] += a\n        sc(o, l, a)[A] += a\n        sc(o, l, -a)\n    else:\n        x, y = s[X], s[Y]\n        s[X] += cos(radians(s[A])) * l\n        s[Y] += sin(radians(s[A])) * l\n        line(x, y, s[X], s[Y])\n\n    return s\n"}
{"id": 333557, "name": "Hello world_Line printer", "source": "Translate Perl to Python: open O, \">\", \"/dev/lp0\";\nprint O \"Hello World!\\n\";\nclose O;\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 333558, "name": "Hello world_Line printer", "source": "Translate Perl to Python: open O, \">\", \"/dev/lp0\";\nprint O \"Hello World!\\n\";\nclose O;\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 333559, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub intersection {\n    my($L11, $L12, $L21, $L22) = @_;\n    my ($d1x, $d1y) = ($$L11[0] - $$L12[0], $$L11[1] - $$L12[1]);\n    my ($d2x, $d2y) = ($$L21[0] - $$L22[0], $$L21[1] - $$L22[1]);\n    my $n1 = $$L11[0] * $$L12[1] - $$L11[1] * $$L12[0];\n    my $n2 = $$L21[0] * $$L22[1] - $$L21[1] * $$L22[0];\n    my $n3 = 1 / ($d1x * $d2y - $d2x * $d1y);\n    [($n1 * $d2x - $n2 * $d1x) * $n3, ($n1 * $d2y - $n2 * $d1y) * $n3]\n}\n\nsub is_inside {\n    my($p1, $p2, $p3) = @_;\n    ($$p2[0] - $$p1[0]) * ($$p3[1] - $$p1[1]) > ($$p2[1] - $$p1[1]) * ($$p3[0] - $$p1[0])\n}\n\nsub sutherland_hodgman {\n    my($polygon, $clip) = @_;\n    my @output = @$polygon;\n    my $clip_point1 = $$clip[-1];\n    for my $clip_point2 (@$clip) {\n        my @input = @output;\n        @output = ();\n        my $start = $input[-1];\n        for my $end (@input) {\n            if (is_inside($clip_point1, $clip_point2, $end)) {\n                push @output, intersection($clip_point1, $clip_point2, $start, $end)\n                  unless is_inside($clip_point1, $clip_point2, $start);\n                push @output, $end;\n            } elsif (is_inside($clip_point1, $clip_point2, $start)) {\n                push @output, intersection($clip_point1, $clip_point2, $start, $end);\n            }\n            $start = $end;\n        }\n        $clip_point1 = $clip_point2;\n    }\n    @output\n}\n\nmy @polygon = ([50,  150], [200, 50],  [350, 150], [350, 300], [250, 300],\n              [200, 250], [150, 350], [100, 250], [100, 200]);\n\nmy @clip    = ([100, 100], [300, 100], [300, 300], [100, 300]);\n\nmy @clipped = sutherland_hodgman(\\@polygon, \\@clip);\n\nprint \"Clipped polygon:\\n\";\nprint '(' . join(' ', @$_) . ') ' for @clipped;\n", "target": "def clip(subjectPolygon, clipPolygon):\n   def inside(p):\n      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])\n      \n   def computeIntersection():\n      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]\n      dp = [ s[0] - e[0], s[1] - e[1] ]\n      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]\n      n2 = s[0] * e[1] - s[1] * e[0] \n      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])\n      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]\n\n   outputList = subjectPolygon\n   cp1 = clipPolygon[-1]\n   \n   for clipVertex in clipPolygon:\n      cp2 = clipVertex\n      inputList = outputList\n      outputList = []\n      s = inputList[-1]\n\n      for subjectVertex in inputList:\n         e = subjectVertex\n         if inside(e):\n            if not inside(s):\n               outputList.append(computeIntersection())\n            outputList.append(e)\n         elif inside(s):\n            outputList.append(computeIntersection())\n         s = e\n      cp1 = cp2\n   return(outputList)\n"}
{"id": 333560, "name": "Sorting algorithms_Pancake sort", "source": "Translate Perl to Python: sub pancake {\n        my @x = @_;\n        for my $idx (0 .. $\n                my $min = $idx;\n                $x[$min] > $x[$_] and $min = $_           for $idx + 1 .. $\n\n                next if $x[$min] == $x[$idx];\n\n                @x[$min .. $\n                @x[$idx .. $\n        }\n        @x;\n}\n\nmy @a = map (int rand(100), 1 .. 10);\nprint \"Before @a\\n\";\n@a = pancake(@a);\nprint \"After  @a\\n\";\n", "target": "tutor = False\n\ndef pancakesort(data):\n    if len(data) <= 1:\n        return data\n    if tutor: print()\n    for size in range(len(data), 1, -1):\n        maxindex = max(range(size), key=data.__getitem__)\n        if maxindex+1 != size:\n            \n            if maxindex != 0:\n                \n                if tutor: print('With: %r doflip  %i'\n                                % ( ' '.join(str(x) for x in data), maxindex+1 ))\n                data[:maxindex+1] = reversed(data[:maxindex+1])\n            \n            if tutor: print('With: %r  doflip %i'\n                                % ( ' '.join(str(x) for x in data), size ))\n            data[:size] = reversed(data[:size])\n    if tutor: print()\n"}
{"id": 333561, "name": "Call a function", "source": "Translate Perl to Python: foo();              \n&foo();             \nfoo($arg1, $arg2);  \n&foo($arg1, $arg2); \n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 333562, "name": "Call a function", "source": "Translate Perl to Python: foo();              \n&foo();             \nfoo($arg1, $arg2);  \n&foo($arg1, $arg2); \n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 333563, "name": "Extract file extension", "source": "Translate Perl to Python: sub extension {\n    my $path = shift;\n    $path =~ / \\. [a-z0-9]+ $ /xi;\n    $& // '';\n}\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 333564, "name": "Extract file extension", "source": "Translate Perl to Python: sub extension {\n    my $path = shift;\n    $path =~ / \\. [a-z0-9]+ $ /xi;\n    $& // '';\n}\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 333565, "name": "Solve the no connection puzzle", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy $gap = qr/.{3}/s;\n\nfind( <<terminator );\n-AB-\nCDEF\n-GH-\nterminator\n\nsub find\n  {\n  my $p = shift;\n  $p =~ /(\\d)$gap.{0,2}(\\d)(??{abs $1 - $2 <= 1\u00a0? ''\u00a0: '(*F)'})/ ||\n    $p =~ /^.*\\n.*(\\d)(\\d)(??{abs $1 - $2 <= 1\u00a0? ''\u00a0: '(*F)'})/ and return;\n  if( $p =~ /[A-H]/ )\n    {\n    find( $p =~ s/[A-H]/$_/r ) for grep $p !~ $_, 1 .. 8;\n    }\n  else\n    {\n    print $p =~ tr/-/ /r;\n    exit;\n    }\n  }\n", "target": "from __future__ import print_function\nfrom itertools import permutations\nfrom enum import Enum\n\nA, B, C, D, E, F, G, H = Enum('Peg', 'A, B, C, D, E, F, G, H')\n\nconnections = ((A, C), (A, D), (A, E),\n               (B, D), (B, E), (B, F),\n               (G, C), (G, D), (G, E),\n               (H, D), (H, E), (H, F),\n               (C, D), (D, E), (E, F))\n\n\ndef ok(conn, perm):\n    \n    this, that = (c.value - 1 for c in conn)\n    return abs(perm[this] - perm[that]) != 1\n\n\ndef solve():\n    return [perm for perm in permutations(range(1, 9))\n            if all(ok(conn, perm) for conn in connections)]\n\n\nif __name__ == '__main__':\n    solutions = solve()\n    print(\"A, B, C, D, E, F, G, H =\", ', '.join(str(i) for i in solutions[0]))\n"}
{"id": 333566, "name": "Permutation test", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\n\nuse List::Util qw{ sum };\n\n\nsub means {\n    my @groups = @_;\n    return map sum(@$_) / @$_, @groups;\n}\n\n\nsub following {\n    my $pattern    = shift;\n    my $orig_count = grep $_, @$pattern;\n    my $count;\n    do {\n        my $i = $\n        until (0 > $i) {\n            $pattern->[$i] = $pattern->[$i] ? 0 : 1;\n            last if $pattern->[$i];\n            --$i;\n        }\n        $count = grep $_, @$pattern;\n    } until $count == $orig_count or not $count;\n    undef @$pattern unless $count;\n}\n\n\nmy @groups;\nmy $i = 0;\nwhile (<DATA>) {\n    chomp;\n    $i++, next if /^$/;\n    push @{ $groups[$i] }, $_;\n}\n\nmy @orig_means = means(@groups);\nmy $orig_cmp   = $orig_means[0] - $orig_means[1];\n\nmy $pattern = [ (0) x @{ $groups[0] },\n                (1) x @{ $groups[1] }\n              ];\n\nmy @cmp = (0) x 3;\nwhile (@$pattern) {\n    my @perms = map { my $g = $_;\n                      [ (@{ $groups[0] }, @{ $groups[1] } ) [ grep $pattern->[$_] == $g, 0 .. $\n                  } 0, 1;\n    my @means = means(@perms);\n    $cmp[ ($means[0] - $means[1]) <=> $orig_cmp ]++;\n} continue {\n    following($pattern);\n}\nmy $all    = sum(@cmp);\nmy $length = length $all;\nfor (0, -1, 1) {\n    printf \"%-7s\u00a0%${length}d %6.3f%%\\n\",\n        (qw(equal greater less))[$_], $cmp[$_], 100 * $cmp[$_] / $all;\n}\n\n\n", "target": "from itertools import combinations as comb\n\ndef statistic(ab, a):\n    sumab, suma = sum(ab), sum(a)\n    return ( suma / len(a) -\n             (sumab -suma) / (len(ab) - len(a)) )\n\ndef permutationTest(a, b):\n    ab = a + b\n    Tobs = statistic(ab, a)\n    under = 0\n    for count, perm in enumerate(comb(ab, len(a)), 1):\n        if statistic(ab, perm) <= Tobs:\n            under += 1\n    return under * 100. / count\n\ntreatmentGroup = [85, 88, 75, 66, 25, 29, 83, 39, 97]\ncontrolGroup   = [68, 41, 10, 49, 16, 65, 32, 92, 28, 98]\nunder = permutationTest(treatmentGroup, controlGroup)\nprint(\"under=%.2f%%, over=%.2f%%\" % (under, 100. - under))\n"}
{"id": 333567, "name": "Image convolution", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nuse PDL;\nuse PDL::Image2D;\n\nmy $kernel = pdl [[-2, -1, 0],[-1, 1, 1], [0, 1, 2]]; \n\nmy $image = rpic 'pythagoras_tree.png';\nmy $smoothed = conv2d $image, $kernel, {Boundary => 'Truncate'};\nwpic $smoothed, 'pythagoras_convolution.png';\n", "target": "\nfrom PIL import Image, ImageFilter\n\nif __name__==\"__main__\":\n\tim = Image.open(\"test.jpg\")\n\n\tkernelValues = [-2,-1,0,-1,1,1,0,1,2] \n\tkernel = ImageFilter.Kernel((3,3), kernelValues)\n\n\tim2 = im.filter(kernel)\n\n\tim2.show()\n"}
{"id": 333568, "name": "Compiler_lexical analyzer", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nno warnings 'once';\n\n\n\n\nmy @tokens = (\n    \n    \n    ['Op_multiply'    , '*'                  ,             ],\n    ['Op_divide'      , '/'                  ,             ],\n    ['Op_mod'         , '%'                  ,             ],\n    ['Op_add'         , '+'                  ,             ],\n    ['Op_subtract'    , '-'                  ,             ],\n    ['Op_lessequal'   , '<='                 ,             ],\n    ['Op_less'        , '<'                  ,             ],\n    ['Op_greaterequal', '>='                 ,             ],\n    ['Op_greater'     , '>'                  ,             ],\n    ['Op_equal'       , '=='                 ,             ],\n    ['Op_assign'      , '='                  ,             ],\n    ['Op_not'         , '!'                  ,             ],\n    ['Op_notequal'    , '!='                 ,             ],\n    ['Op_and'         , '&&'                 ,             ],\n    ['Op_or'          , '||'                 ,             ],\n    ['Keyword_else'   , qr/else\\b/           ,             ],\n    ['Keyword_if'     , qr/if\\b/             ,             ],\n    ['Keyword_while'  , qr/while\\b/          ,             ],\n    ['Keyword_print'  , qr/print\\b/          ,             ],\n    ['Keyword_putc'   , qr/putc\\b/           ,             ],\n\n    ['LeftParen'      , '('                  ,             ],\n    ['RightParen'     , ')'                  ,             ],\n    ['LeftBrace'      , '{'                  ,             ],\n    ['RightBrace'     , '}'                  ,             ],\n    ['Semicolon'      , ';'                  ,             ],\n    ['Comma'          , ','                  ,             ],\n\n    ['Identifier'     , qr/[_a-z][_a-z0-9]*/i, \\&raw       ],\n    ['Integer'        , qr/[0-9]+\\b/         , \\&raw       ],\n    ['Integer'        , qr/'([^']*)(')?/     , \\&char_val  ],\n    ['String'         , qr/\"([^\"]*)(\")?/     , \\&string_raw],\n\n    ['End_of_input'   , qr/$/                ,             ],\n);\n\nmy $comment = qr/\\/\\* .+? (?: \\*\\/ | $ (?{die \"End-of-file in comment\\n\"}) )/xs;\nmy $whitespace = qr/(?: \\s | $comment)*/x;\nmy $unrecognized = qr/\\w+ | ./x;\n\n\nsub char_val {\n    my $str = string_val();\n    die \"Multiple characters\\n\" if length $str > 1;\n    die \"No character\\n\"        if length $str == 0;\n    ord $str;\n}\n\n\nsub string_val {\n    my ($str, $end) = ($1, $2);\n    die \"End-of-file\\n\" if not defined $end;\n    die \"End-of-line\\n\" if $str =~ /\\n/;\n    $str =~ s/\\\\(.)/\n          $1 eq 'n' \u00a0? \"\\n\"\n       \u00a0: $1 eq '\\\\'\u00a0? $1\n       \u00a0: $1 eq $end\u00a0? $1\n       \u00a0: die \"Unknown escape sequence \\\\$1\\n\"\n    /rge;\n}\n\n\nsub raw { $& }\n\n\nsub string_raw {\n    string_val(); \n    $&;\n}\n\n\n\n\n\n\nmy $tokens =\n    join \"|\",\n    map {\n        my $format = $tokens[$_][1];\n        \"\\n\".(ref $format ? $format : quotemeta $format).\" (*MARK:$_) \";\n    } 0..$\n\nmy $regex = qr/\n    \\G (?| $whitespace  \\K (?| $tokens )\n         | $whitespace? \\K ($unrecognized) (*MARK:!) )\n/x;\n\n\n\n\nmy $input = do { local $/ = undef; <STDIN> };\nmy $pos = 0;\nmy $linecol = linecol_accumulator();\n\nwhile ($input =~ /$regex/g) {\n    \n    my ($line, $col) = $linecol->(substr $input, $pos, $-[0] - $pos);\n    $pos = $-[0];\n\n    \n    my $type = $main::REGMARK;\n    die \"Unrecognized token $1 at line $line, col $col\\n\" if $type eq '!';\n    my ($name, $evaluator) = @{$tokens[$type]}[0, 2];\n\n    \n    my $value;\n    if ($evaluator) {\n        eval { $value = $evaluator->() };\n        if ($@) { chomp $@; die \"$@ in $name at line $line, col $col\\n\" }\n    }\n\n    \n    print \"$line\\t$col\\t$name\".($value ? \"\\t$value\" : '').\"\\n\";\n}\n\n\n\nsub linecol_accumulator {\n    my ($line, $col) = (1, 1);\n    sub {\n        my $str = shift;\n        my @lines = split \"\\n\", $str, -1;\n        my ($l, $c) = @lines ? (@lines - 1, length $lines[-1]) : (0, 0);\n        if ($l) { $line += $l;  $col = 1 + $c }\n        else    { $col += $c }\n        ($line, $col)\n    }\n}\n", "target": "from __future__ import print_function\nimport sys\n\n\n\ntk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \\\ntk_Geq, tk_Eq, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,       \\\ntk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \\\ntk_Integer, tk_String = range(31)\n\nall_syms = [\"End_of_input\", \"Op_multiply\", \"Op_divide\", \"Op_mod\", \"Op_add\", \"Op_subtract\",\n    \"Op_negate\", \"Op_not\", \"Op_less\", \"Op_lessequal\", \"Op_greater\", \"Op_greaterequal\",\n    \"Op_equal\", \"Op_notequal\", \"Op_assign\", \"Op_and\", \"Op_or\", \"Keyword_if\",\n    \"Keyword_else\", \"Keyword_while\", \"Keyword_print\", \"Keyword_putc\", \"LeftParen\",\n    \"RightParen\", \"LeftBrace\", \"RightBrace\", \"Semicolon\", \"Comma\", \"Identifier\",\n    \"Integer\", \"String\"]\n\n\nsymbols = { '{': tk_Lbrace, '}': tk_Rbrace, '(': tk_Lparen, ')': tk_Rparen, '+': tk_Add, '-': tk_Sub,\n    '*': tk_Mul, '%': tk_Mod, ';': tk_Semi, ',': tk_Comma }\n\nkey_words = {'if': tk_If, 'else': tk_Else, 'print': tk_Print, 'putc': tk_Putc, 'while': tk_While}\n\nthe_ch = \" \"    \nthe_col = 0\nthe_line = 1\ninput_file = None\n\n\ndef error(line, col, msg):\n    print(line, col, msg)\n    exit(1)\n\n\ndef next_ch():\n    global the_ch, the_col, the_line\n\n    the_ch = input_file.read(1)\n    the_col += 1\n    if the_ch == '\\n':\n        the_line += 1\n        the_col = 0\n    return the_ch\n\n\ndef char_lit(err_line, err_col):\n    n = ord(next_ch())              \n    if the_ch == '\\'':\n        error(err_line, err_col, \"empty character constant\")\n    elif the_ch == '\\\\':\n        next_ch()\n        if the_ch == 'n':\n            n = 10\n        elif the_ch == '\\\\':\n            n = ord('\\\\')\n        else:\n            error(err_line, err_col, \"unknown escape sequence \\\\%c\" % (the_ch))\n    if next_ch() != '\\'':\n        error(err_line, err_col, \"multi-character constant\")\n    next_ch()\n    return tk_Integer, err_line, err_col, n\n\n\ndef div_or_cmt(err_line, err_col):\n    if next_ch() != '*':\n        return tk_Div, err_line, err_col\n\n    \n    next_ch()\n    while True:\n        if the_ch == '*':\n            if next_ch() == '/':\n                next_ch()\n                return gettok()\n        elif len(the_ch) == 0:\n            error(err_line, err_col, \"EOF in comment\")\n        else:\n            next_ch()\n\n\ndef string_lit(start, err_line, err_col):\n    global the_ch\n    text = \"\"\n\n    while next_ch() != start:\n        if len(the_ch) == 0:\n            error(err_line, err_col, \"EOF while scanning string literal\")\n        if the_ch == '\\n':\n            error(err_line, err_col, \"EOL while scanning string literal\")\n        if the_ch == '\\\\':\n            next_ch()\n            if the_ch != 'n':\n                error(err_line, err_col, \"escape sequence unknown \\\\%c\" % the_ch)\n            the_ch = '\\n'\n        text += the_ch\n\n    next_ch()\n    return tk_String, err_line, err_col, text\n\n\ndef ident_or_int(err_line, err_col):\n    is_number = True\n    text = \"\"\n\n    while the_ch.isalnum() or the_ch == '_':\n        text += the_ch\n        if not the_ch.isdigit():\n            is_number = False\n        next_ch()\n\n    if len(text) == 0:\n        error(err_line, err_col, \"ident_or_int: unrecognized character: (%d) '%c'\" % (ord(the_ch), the_ch))\n\n    if text[0].isdigit():\n        if not is_number:\n            error(err_line, err_col, \"invalid number: %s\" % (text))\n        n = int(text)\n        return tk_Integer, err_line, err_col, n\n\n    if text in key_words:\n        return key_words[text], err_line, err_col\n\n    return tk_Ident, err_line, err_col, text\n\n\ndef follow(expect, ifyes, ifno, err_line, err_col):\n    if next_ch() == expect:\n        next_ch()\n        return ifyes, err_line, err_col\n\n    if ifno == tk_EOI:\n        error(err_line, err_col, \"follow: unrecognized character: (%d) '%c'\" % (ord(the_ch), the_ch))\n\n    return ifno, err_line, err_col\n\n\ndef gettok():\n    while the_ch.isspace():\n        next_ch()\n\n    err_line = the_line\n    err_col  = the_col\n\n    if len(the_ch) == 0:    return tk_EOI, err_line, err_col\n    elif the_ch == '/':     return div_or_cmt(err_line, err_col)\n    elif the_ch == '\\'':    return char_lit(err_line, err_col)\n    elif the_ch == '<':     return follow('=', tk_Leq, tk_Lss,    err_line, err_col)\n    elif the_ch == '>':     return follow('=', tk_Geq, tk_Gtr,    err_line, err_col)\n    elif the_ch == '=':     return follow('=', tk_Eq,  tk_Assign, err_line, err_col)\n    elif the_ch == '!':     return follow('=', tk_Neq, tk_Not,    err_line, err_col)\n    elif the_ch == '&':     return follow('&', tk_And, tk_EOI,    err_line, err_col)\n    elif the_ch == '|':     return follow('|', tk_Or,  tk_EOI,    err_line, err_col)\n    elif the_ch == '\"':     return string_lit(the_ch, err_line, err_col)\n    elif the_ch in symbols:\n        sym = symbols[the_ch]\n        next_ch()\n        return sym, err_line, err_col\n    else: return ident_or_int(err_line, err_col)\n\n\ninput_file = sys.stdin\nif len(sys.argv) > 1:\n    try:\n        input_file = open(sys.argv[1], \"r\", 4096)\n    except IOError as e:\n        error(0, 0, \"Can't open %s\" % sys.argv[1])\n\nwhile True:\n    t = gettok()\n    tok  = t[0]\n    line = t[1]\n    col  = t[2]\n\n    print(\"%5d  %5d   %-14s\" % (line, col, all_syms[tok]), end='')\n\n    if tok == tk_Integer:  print(\"   %5d\" % (t[3]))\n    elif tok == tk_Ident:  print(\"  %s\" %   (t[3]))\n    elif tok == tk_String: print('  \"%s\"' % (t[3]))\n    else:                  print(\"\")\n\n    if tok == tk_EOI:\n        break\n"}
{"id": 333569, "name": "Compiler_lexical analyzer", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nno warnings 'once';\n\n\n\n\nmy @tokens = (\n    \n    \n    ['Op_multiply'    , '*'                  ,             ],\n    ['Op_divide'      , '/'                  ,             ],\n    ['Op_mod'         , '%'                  ,             ],\n    ['Op_add'         , '+'                  ,             ],\n    ['Op_subtract'    , '-'                  ,             ],\n    ['Op_lessequal'   , '<='                 ,             ],\n    ['Op_less'        , '<'                  ,             ],\n    ['Op_greaterequal', '>='                 ,             ],\n    ['Op_greater'     , '>'                  ,             ],\n    ['Op_equal'       , '=='                 ,             ],\n    ['Op_assign'      , '='                  ,             ],\n    ['Op_not'         , '!'                  ,             ],\n    ['Op_notequal'    , '!='                 ,             ],\n    ['Op_and'         , '&&'                 ,             ],\n    ['Op_or'          , '||'                 ,             ],\n    ['Keyword_else'   , qr/else\\b/           ,             ],\n    ['Keyword_if'     , qr/if\\b/             ,             ],\n    ['Keyword_while'  , qr/while\\b/          ,             ],\n    ['Keyword_print'  , qr/print\\b/          ,             ],\n    ['Keyword_putc'   , qr/putc\\b/           ,             ],\n\n    ['LeftParen'      , '('                  ,             ],\n    ['RightParen'     , ')'                  ,             ],\n    ['LeftBrace'      , '{'                  ,             ],\n    ['RightBrace'     , '}'                  ,             ],\n    ['Semicolon'      , ';'                  ,             ],\n    ['Comma'          , ','                  ,             ],\n\n    ['Identifier'     , qr/[_a-z][_a-z0-9]*/i, \\&raw       ],\n    ['Integer'        , qr/[0-9]+\\b/         , \\&raw       ],\n    ['Integer'        , qr/'([^']*)(')?/     , \\&char_val  ],\n    ['String'         , qr/\"([^\"]*)(\")?/     , \\&string_raw],\n\n    ['End_of_input'   , qr/$/                ,             ],\n);\n\nmy $comment = qr/\\/\\* .+? (?: \\*\\/ | $ (?{die \"End-of-file in comment\\n\"}) )/xs;\nmy $whitespace = qr/(?: \\s | $comment)*/x;\nmy $unrecognized = qr/\\w+ | ./x;\n\n\nsub char_val {\n    my $str = string_val();\n    die \"Multiple characters\\n\" if length $str > 1;\n    die \"No character\\n\"        if length $str == 0;\n    ord $str;\n}\n\n\nsub string_val {\n    my ($str, $end) = ($1, $2);\n    die \"End-of-file\\n\" if not defined $end;\n    die \"End-of-line\\n\" if $str =~ /\\n/;\n    $str =~ s/\\\\(.)/\n          $1 eq 'n' \u00a0? \"\\n\"\n       \u00a0: $1 eq '\\\\'\u00a0? $1\n       \u00a0: $1 eq $end\u00a0? $1\n       \u00a0: die \"Unknown escape sequence \\\\$1\\n\"\n    /rge;\n}\n\n\nsub raw { $& }\n\n\nsub string_raw {\n    string_val(); \n    $&;\n}\n\n\n\n\n\n\nmy $tokens =\n    join \"|\",\n    map {\n        my $format = $tokens[$_][1];\n        \"\\n\".(ref $format ? $format : quotemeta $format).\" (*MARK:$_) \";\n    } 0..$\n\nmy $regex = qr/\n    \\G (?| $whitespace  \\K (?| $tokens )\n         | $whitespace? \\K ($unrecognized) (*MARK:!) )\n/x;\n\n\n\n\nmy $input = do { local $/ = undef; <STDIN> };\nmy $pos = 0;\nmy $linecol = linecol_accumulator();\n\nwhile ($input =~ /$regex/g) {\n    \n    my ($line, $col) = $linecol->(substr $input, $pos, $-[0] - $pos);\n    $pos = $-[0];\n\n    \n    my $type = $main::REGMARK;\n    die \"Unrecognized token $1 at line $line, col $col\\n\" if $type eq '!';\n    my ($name, $evaluator) = @{$tokens[$type]}[0, 2];\n\n    \n    my $value;\n    if ($evaluator) {\n        eval { $value = $evaluator->() };\n        if ($@) { chomp $@; die \"$@ in $name at line $line, col $col\\n\" }\n    }\n\n    \n    print \"$line\\t$col\\t$name\".($value ? \"\\t$value\" : '').\"\\n\";\n}\n\n\n\nsub linecol_accumulator {\n    my ($line, $col) = (1, 1);\n    sub {\n        my $str = shift;\n        my @lines = split \"\\n\", $str, -1;\n        my ($l, $c) = @lines ? (@lines - 1, length $lines[-1]) : (0, 0);\n        if ($l) { $line += $l;  $col = 1 + $c }\n        else    { $col += $c }\n        ($line, $col)\n    }\n}\n", "target": "from __future__ import print_function\nimport sys\n\n\n\ntk_EOI, tk_Mul, tk_Div, tk_Mod, tk_Add, tk_Sub, tk_Negate, tk_Not, tk_Lss, tk_Leq, tk_Gtr, \\\ntk_Geq, tk_Eq, tk_Neq, tk_Assign, tk_And, tk_Or, tk_If, tk_Else, tk_While, tk_Print,       \\\ntk_Putc, tk_Lparen, tk_Rparen, tk_Lbrace, tk_Rbrace, tk_Semi, tk_Comma, tk_Ident,          \\\ntk_Integer, tk_String = range(31)\n\nall_syms = [\"End_of_input\", \"Op_multiply\", \"Op_divide\", \"Op_mod\", \"Op_add\", \"Op_subtract\",\n    \"Op_negate\", \"Op_not\", \"Op_less\", \"Op_lessequal\", \"Op_greater\", \"Op_greaterequal\",\n    \"Op_equal\", \"Op_notequal\", \"Op_assign\", \"Op_and\", \"Op_or\", \"Keyword_if\",\n    \"Keyword_else\", \"Keyword_while\", \"Keyword_print\", \"Keyword_putc\", \"LeftParen\",\n    \"RightParen\", \"LeftBrace\", \"RightBrace\", \"Semicolon\", \"Comma\", \"Identifier\",\n    \"Integer\", \"String\"]\n\n\nsymbols = { '{': tk_Lbrace, '}': tk_Rbrace, '(': tk_Lparen, ')': tk_Rparen, '+': tk_Add, '-': tk_Sub,\n    '*': tk_Mul, '%': tk_Mod, ';': tk_Semi, ',': tk_Comma }\n\nkey_words = {'if': tk_If, 'else': tk_Else, 'print': tk_Print, 'putc': tk_Putc, 'while': tk_While}\n\nthe_ch = \" \"    \nthe_col = 0\nthe_line = 1\ninput_file = None\n\n\ndef error(line, col, msg):\n    print(line, col, msg)\n    exit(1)\n\n\ndef next_ch():\n    global the_ch, the_col, the_line\n\n    the_ch = input_file.read(1)\n    the_col += 1\n    if the_ch == '\\n':\n        the_line += 1\n        the_col = 0\n    return the_ch\n\n\ndef char_lit(err_line, err_col):\n    n = ord(next_ch())              \n    if the_ch == '\\'':\n        error(err_line, err_col, \"empty character constant\")\n    elif the_ch == '\\\\':\n        next_ch()\n        if the_ch == 'n':\n            n = 10\n        elif the_ch == '\\\\':\n            n = ord('\\\\')\n        else:\n            error(err_line, err_col, \"unknown escape sequence \\\\%c\" % (the_ch))\n    if next_ch() != '\\'':\n        error(err_line, err_col, \"multi-character constant\")\n    next_ch()\n    return tk_Integer, err_line, err_col, n\n\n\ndef div_or_cmt(err_line, err_col):\n    if next_ch() != '*':\n        return tk_Div, err_line, err_col\n\n    \n    next_ch()\n    while True:\n        if the_ch == '*':\n            if next_ch() == '/':\n                next_ch()\n                return gettok()\n        elif len(the_ch) == 0:\n            error(err_line, err_col, \"EOF in comment\")\n        else:\n            next_ch()\n\n\ndef string_lit(start, err_line, err_col):\n    global the_ch\n    text = \"\"\n\n    while next_ch() != start:\n        if len(the_ch) == 0:\n            error(err_line, err_col, \"EOF while scanning string literal\")\n        if the_ch == '\\n':\n            error(err_line, err_col, \"EOL while scanning string literal\")\n        if the_ch == '\\\\':\n            next_ch()\n            if the_ch != 'n':\n                error(err_line, err_col, \"escape sequence unknown \\\\%c\" % the_ch)\n            the_ch = '\\n'\n        text += the_ch\n\n    next_ch()\n    return tk_String, err_line, err_col, text\n\n\ndef ident_or_int(err_line, err_col):\n    is_number = True\n    text = \"\"\n\n    while the_ch.isalnum() or the_ch == '_':\n        text += the_ch\n        if not the_ch.isdigit():\n            is_number = False\n        next_ch()\n\n    if len(text) == 0:\n        error(err_line, err_col, \"ident_or_int: unrecognized character: (%d) '%c'\" % (ord(the_ch), the_ch))\n\n    if text[0].isdigit():\n        if not is_number:\n            error(err_line, err_col, \"invalid number: %s\" % (text))\n        n = int(text)\n        return tk_Integer, err_line, err_col, n\n\n    if text in key_words:\n        return key_words[text], err_line, err_col\n\n    return tk_Ident, err_line, err_col, text\n\n\ndef follow(expect, ifyes, ifno, err_line, err_col):\n    if next_ch() == expect:\n        next_ch()\n        return ifyes, err_line, err_col\n\n    if ifno == tk_EOI:\n        error(err_line, err_col, \"follow: unrecognized character: (%d) '%c'\" % (ord(the_ch), the_ch))\n\n    return ifno, err_line, err_col\n\n\ndef gettok():\n    while the_ch.isspace():\n        next_ch()\n\n    err_line = the_line\n    err_col  = the_col\n\n    if len(the_ch) == 0:    return tk_EOI, err_line, err_col\n    elif the_ch == '/':     return div_or_cmt(err_line, err_col)\n    elif the_ch == '\\'':    return char_lit(err_line, err_col)\n    elif the_ch == '<':     return follow('=', tk_Leq, tk_Lss,    err_line, err_col)\n    elif the_ch == '>':     return follow('=', tk_Geq, tk_Gtr,    err_line, err_col)\n    elif the_ch == '=':     return follow('=', tk_Eq,  tk_Assign, err_line, err_col)\n    elif the_ch == '!':     return follow('=', tk_Neq, tk_Not,    err_line, err_col)\n    elif the_ch == '&':     return follow('&', tk_And, tk_EOI,    err_line, err_col)\n    elif the_ch == '|':     return follow('|', tk_Or,  tk_EOI,    err_line, err_col)\n    elif the_ch == '\"':     return string_lit(the_ch, err_line, err_col)\n    elif the_ch in symbols:\n        sym = symbols[the_ch]\n        next_ch()\n        return sym, err_line, err_col\n    else: return ident_or_int(err_line, err_col)\n\n\ninput_file = sys.stdin\nif len(sys.argv) > 1:\n    try:\n        input_file = open(sys.argv[1], \"r\", 4096)\n    except IOError as e:\n        error(0, 0, \"Can't open %s\" % sys.argv[1])\n\nwhile True:\n    t = gettok()\n    tok  = t[0]\n    line = t[1]\n    col  = t[2]\n\n    print(\"%5d  %5d   %-14s\" % (line, col, all_syms[tok]), end='')\n\n    if tok == tk_Integer:  print(\"   %5d\" % (t[3]))\n    elif tok == tk_Ident:  print(\"  %s\" %   (t[3]))\n    elif tok == tk_String: print('  \"%s\"' % (t[3]))\n    else:                  print(\"\")\n\n    if tok == tk_EOI:\n        break\n"}
{"id": 333570, "name": "Copy a string", "source": "Translate Perl to Python: my $original = 'Hello.';\nmy $new = $original;\n$new = 'Goodbye.';\nprint \"$original\\n\";   \n", "target": ">>> src = \"hello\"\n>>> a = src\n>>> b = src[:]\n>>> import copy\n>>> c = copy.copy(src)\n>>> d = copy.deepcopy(src)\n>>> src is a is b is c is d\nTrue\n"}
{"id": 333571, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Perl to Python: use Term::ReadKey;\n\nReadMode 4; \n\nmy $key = '';\n\nwhile($key !~ /(Y|N)/i) {\n    1 while defined ReadKey -1; \n    print \"Type Y/N: \";\n    $key = ReadKey 0; \n    print \"$key\\n\";\n}\n\nReadMode 0; \n\nprint \"\\nYou typed: $key\\n\";\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 333572, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Perl to Python: use Term::ReadKey;\n\nReadMode 4; \n\nmy $key = '';\n\nwhile($key !~ /(Y|N)/i) {\n    1 while defined ReadKey -1; \n    print \"Type Y/N: \";\n    $key = ReadKey 0; \n    print \"$key\\n\";\n}\n\nReadMode 0; \n\nprint \"\\nYou typed: $key\\n\";\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 333573, "name": "Abbreviations, simple", "source": "Translate Perl to Python: @c = (uc join ' ', qw<\nadd 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\ncompress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\nforward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\nlocate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\nmsg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\nrefresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\n>) =~ /([a-zA-Z]+(?:\\s+\\d+)?)(?=\\s+[a-zA-Z]|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor (@c) {\n    ($w,$sl) = split ' ', $_;\n    $ll = length($w);\n    $sl = $ll unless $sl;\n    $abr{substr($w,0,$sl)} = $w;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\";\n", "target": "command_table_text = \n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    input_iter = iter(command_table_text.split())\n\n    word = None\n    try:\n        while True:\n            if word is None:\n                word = next(input_iter)\n            abbr_len = next(input_iter, len(word))\n            try:\n                command_table[word] = int(abbr_len)\n                word = None\n            except ValueError:\n                command_table[word] = len(word)\n                word = abbr_len\n    except StopIteration:\n        pass\n    return command_table\n\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 333574, "name": "Abbreviations, simple", "source": "Translate Perl to Python: @c = (uc join ' ', qw<\nadd 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\ncompress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\nforward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\nlocate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\nmsg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\nrefresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\n>) =~ /([a-zA-Z]+(?:\\s+\\d+)?)(?=\\s+[a-zA-Z]|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor (@c) {\n    ($w,$sl) = split ' ', $_;\n    $ll = length($w);\n    $sl = $ll unless $sl;\n    $abr{substr($w,0,$sl)} = $w;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\";\n", "target": "command_table_text = \n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    input_iter = iter(command_table_text.split())\n\n    word = None\n    try:\n        while True:\n            if word is None:\n                word = next(input_iter)\n            abbr_len = next(input_iter, len(word))\n            try:\n                command_table[word] = int(abbr_len)\n                word = None\n            except ValueError:\n                command_table[word] = len(word)\n                word = abbr_len\n    except StopIteration:\n        pass\n    return command_table\n\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 333575, "name": "String comparison", "source": "Translate Perl to Python: use v5.16;  \n            \n\nsub compare {\n    my ($a, $b) = @_;\n    my $A = \"'$a'\";\n    my $B = \"'$b'\";\n    \n    print \"$A and $B are lexically equal.\\n\"     if $a eq $b;\n    print \"$A and $B are not lexically equal.\\n\" if $a ne $b;\n    \n    print \"$A is lexically before $B.\\n\"         if $a lt $b;\n    print \"$A is lexically after $B.\\n\"          if $a gt $b;\n    \n    print \"$A is not lexically before $B.\\n\"     if $a ge $b;\n    print \"$A is not lexically after $B.\\n\"      if $a le $b;\n    \n    print \"The lexical relationship is: \", $a cmp $b, \"\\n\";\n    print \"The case-insensitive lexical relationship is: \", fc($a) cmp fc($b), \"\\n\";\n    print \"\\n\";\n}\n\ncompare('Hello', 'Hello');\ncompare('5', '5.0');\ncompare('perl', 'Perl');\n", "target": "fun compare(a, b):\n    print(\"\\n$a is of type ${typeof(a)} and $b is of type ${typeof(b)}\")\n    if a < b: print(\"$a is strictly less than $b\")\n    if a <= b: print(\"$a is less than or equal to $b\")\n    if a >  b: print(\"$a is strictly greater than $b\")\n    if a >= b: print(\"$a is greater than or equal to $b\")\n    if a == b: print(\"$a is equal to $b\")\n    if a != b: print(\"$a is not equal to $b\")\n    if a is b: print(\"$a has object identity with $b\")\n    if a is not b: print(\"$a has negated object identity with $b\")\n\ncompare(\"YUP\", \"YUP\")\ncompare('a', 'z')\ncompare(\"24\", \"123\")\ncompare(24, 123)\ncompare(5.0, 5)\n"}
{"id": 333576, "name": "Find prime numbers of the form n_n_n+2", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\n\nsay join ' ', grep { is_prime $_ } map { $_**3 + 2 } grep { 0 != $_%2 } 1..199;\n\n\nuse Math::AnyNum ':all'; \nsay '   ' . sprintf '%4d'x11 , 1..10;\nfor my $e (1..10) {\n  printf  '%2d ', $e;\n  for my $o (1..10) {\n    printf  '%4d', scalar grep { is_prime $_ } map { $_**$e + $o } 1..199;\n  }\n  print \"\\n\";\n}\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    for n in range(1, 200):\n        if isPrime(n**3+2):\n            print(f'{n}\\t{n**3+2}');\n"}
{"id": 333577, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nsub msq\n  {\n  use feature qw( state );\n  state $seed = 675248;\n  $seed = sprintf \"%06d\", $seed ** 2 / 1000 % 1e6;\n  }\n\nprint msq, \"\\n\" for 1 .. 5;\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
{"id": 333578, "name": "Pseudo-random numbers_Middle-square method", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nsub msq\n  {\n  use feature qw( state );\n  state $seed = 675248;\n  $seed = sprintf \"%06d\", $seed ** 2 / 1000 % 1e6;\n  }\n\nprint msq, \"\\n\" for 1 .. 5;\n", "target": "seed = 675248\ndef random():\n    global seed\n    seed = int(str(seed ** 2).zfill(12)[3:9])\n    return seed\nfor _ in range(5):\n    print(random())\n"}
{"id": 333579, "name": "Entropy_Narcissist", "source": "Translate Perl to Python: \nuse strict ;\nuse warnings ;\nuse feature 'say' ;\n\nsub log2 {\n   my $number = shift ;\n   return log( $number ) / log( 2 ) ;\n}\n\nopen my $fh , \"<\" , $ARGV[ 0 ] or die \"Can't open $ARGV[ 0 ]$!\\n\" ;\nmy %frequencies ;\nmy $totallength = 0 ;\nwhile ( my $line = <$fh> ) {\n   chomp $line ;\n   next if $line =~ /^$/ ;\n   map { $frequencies{ $_ }++ } split( // , $line ) ;\n   $totallength += length ( $line ) ;\n}\nclose $fh ;\nmy $infocontent = 0 ;\nfor my $letter ( keys %frequencies ) {\n   my $content = $frequencies{ $letter } / $totallength ;\n   $infocontent += $content * log2( $content ) ;\n}\n$infocontent *= -1 ;\nsay \"The information content of the source file is $infocontent\u00a0!\" ;\n", "target": "import math\nfrom collections import Counter\n\ndef entropy(s):\n    p, lns = Counter(s), float(len(s))\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n\nwith open(__file__) as f:\n    b=f.read()\n    \nprint(entropy(b))\n"}
{"id": 333580, "name": "Entropy_Narcissist", "source": "Translate Perl to Python: \nuse strict ;\nuse warnings ;\nuse feature 'say' ;\n\nsub log2 {\n   my $number = shift ;\n   return log( $number ) / log( 2 ) ;\n}\n\nopen my $fh , \"<\" , $ARGV[ 0 ] or die \"Can't open $ARGV[ 0 ]$!\\n\" ;\nmy %frequencies ;\nmy $totallength = 0 ;\nwhile ( my $line = <$fh> ) {\n   chomp $line ;\n   next if $line =~ /^$/ ;\n   map { $frequencies{ $_ }++ } split( // , $line ) ;\n   $totallength += length ( $line ) ;\n}\nclose $fh ;\nmy $infocontent = 0 ;\nfor my $letter ( keys %frequencies ) {\n   my $content = $frequencies{ $letter } / $totallength ;\n   $infocontent += $content * log2( $content ) ;\n}\n$infocontent *= -1 ;\nsay \"The information content of the source file is $infocontent\u00a0!\" ;\n", "target": "import math\nfrom collections import Counter\n\ndef entropy(s):\n    p, lns = Counter(s), float(len(s))\n    return -sum( count/lns * math.log(count/lns, 2) for count in p.values())\n\nwith open(__file__) as f:\n    b=f.read()\n    \nprint(entropy(b))\n"}
{"id": 333581, "name": "Draw a pixel", "source": "Translate Perl to Python: use Gtk3 '-init';\n\nmy $window = Gtk3::Window->new();\n$window->set_default_size(320, 240);\n$window->set_border_width(10);\n$window->set_title(\"Draw a Pixel\");\n$window->set_app_paintable(TRUE);\n\nmy $da = Gtk3::DrawingArea->new();\n$da->signal_connect('draw' => \\&draw_in_drawingarea);\n$window->add($da);\n$window->show_all();\n\nGtk3->main;\n\nsub draw_in_drawingarea\n{\n  my ($widget, $cr, $data) = @_;\n  $cr->set_source_rgb(1, 0, 0);\n  $cr->set_line_width(1);\n  $cr->rectangle( 100, 100, 1, 1);\n  $cr->stroke;\n}\n", "target": "from PIL import Image\n\nimg = Image.new('RGB', (320, 240))\npixels = img.load()\npixels[100,100] = (255,0,0)\nimg.show()\n"}
{"id": 333582, "name": "Verify distribution uniformity_Naive", "source": "Translate Perl to Python: sub roll7 { 1+int rand(7) }\nsub roll5 { 1+int rand(5) }\nsub roll7_5 {\n  while(1) {\n    my $d7 = (5*&roll5 + &roll5 - 6) % 8;\n    return $d7 if $d7;\n  }\n}\n\nmy $threshold = 5;\n\nprint dist( $_, $threshold,  \\&roll7   ) for <1001 1000006>;\nprint dist( $_, $threshold,  \\&roll7_5 ) for <1001 1000006>;\n\nsub dist {\nmy($n, $threshold, $producer) = @_;\n    my @dist;\n    my $result;\n    my $expect = $n / 7;\n    $result .= sprintf \"%10d expected\\n\", $expect;\n\n    for (1..$n) { @dist[&$producer]++; }\n\n    for my $i (1..7) {\n        my $v = @dist[$i];\n        my $pct = ($v - $expect)/$expect*100;\n        $result .= sprintf \"%d %8d %6.1f%%%s\\n\", $i, $v, $pct, (abs($pct) > $threshold ? ' - skewed' : '');\n    }\n    return $result . \"\\n\";\n}\n", "target": "from collections import Counter\nfrom pprint import pprint as pp\n\ndef distcheck(fn, repeats, delta):\n    \n    bin = Counter(fn() for i in range(repeats))\n    target = repeats // len(bin)\n    deltacount = int(delta / 100. * target)\n    assert all( abs(target - count) < deltacount\n                for count in bin.values() ), \"Bin distribution skewed from %i +/- %i: %s\" % (\n                    target, deltacount, [ (key, target - count)\n                                          for key, count in sorted(bin.items()) ]\n                    )\n    pp(dict(bin))\n"}
{"id": 333583, "name": "Find first and last set bit of a long integer", "source": "Translate Perl to Python: sub msb {\n  my ($n, $base) = (shift, 0);\n  $base++ while $n >>= 1;\n  $base;\n}\nsub lsb {\n  my $n = shift;\n  msb($n & -$n);\n}\n", "target": "def msb(x):\n    return x.bit_length() - 1\n\ndef lsb(x):\n    return msb(x & -x)\n\nfor i in range(6):\n    x = 42 ** i\n    print(\"%10d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n\nfor i in range(6):\n    x = 1302 ** i\n    print(\"%20d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n"}
{"id": 333584, "name": "Find first and last set bit of a long integer", "source": "Translate Perl to Python: sub msb {\n  my ($n, $base) = (shift, 0);\n  $base++ while $n >>= 1;\n  $base;\n}\nsub lsb {\n  my $n = shift;\n  msb($n & -$n);\n}\n", "target": "def msb(x):\n    return x.bit_length() - 1\n\ndef lsb(x):\n    return msb(x & -x)\n\nfor i in range(6):\n    x = 42 ** i\n    print(\"%10d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n\nfor i in range(6):\n    x = 1302 ** i\n    print(\"%20d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n"}
{"id": 333585, "name": "Bioinformatics_Sequence mutation", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @bases = <A C G T>;\n\nmy $dna;\n$dna .= $bases[int rand 4] for 1..200;\n\nmy %cnt;\n$cnt{$_}++ for split //, $dna;\n\nsub pretty {\n    my($string) = @_;\n    my $chunk = 10;\n    my $wrap  = 5 * ($chunk+1);\n    ($string =~ s/(.{$chunk})/$1 /gr) =~ s/(.{$wrap})/$1\\n/gr;\n}\n\nsub mutate {\n    my($dna,$count) = @_;\n    my $orig = $dna;\n    substr($dna,rand length $dna,1) = $bases[int rand 4] while $count > diff($orig, $dna) =~ tr/acgt//;\n    $dna\n}\n\nsub diff {\n    my($orig, $repl) = @_;\n    for my $i (0 .. -1+length $orig) {\n        substr($repl,$i,1, lc substr $repl,$i,1) if substr($orig,$i,1) ne substr($repl,$i,1);\n    }\n    $repl;\n}\n\nsay \"Original DNA strand:\\n\" . pretty($dna);\nsay \"Total bases: \". length $dna;\nsay \"$_: $cnt{$_}\" for @bases;\n\nmy $mutate = mutate($dna, 10);\n%cnt = ();\n$cnt{$_}++ for split //, $mutate;\nsay \"\\nMutated DNA strand:\\n\" . pretty diff $dna, $mutate;\nsay \"Total bases: \". length $mutate;\nsay \"$_: $cnt{$_}\" for @bases;\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 333586, "name": "Bioinformatics_Sequence mutation", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @bases = <A C G T>;\n\nmy $dna;\n$dna .= $bases[int rand 4] for 1..200;\n\nmy %cnt;\n$cnt{$_}++ for split //, $dna;\n\nsub pretty {\n    my($string) = @_;\n    my $chunk = 10;\n    my $wrap  = 5 * ($chunk+1);\n    ($string =~ s/(.{$chunk})/$1 /gr) =~ s/(.{$wrap})/$1\\n/gr;\n}\n\nsub mutate {\n    my($dna,$count) = @_;\n    my $orig = $dna;\n    substr($dna,rand length $dna,1) = $bases[int rand 4] while $count > diff($orig, $dna) =~ tr/acgt//;\n    $dna\n}\n\nsub diff {\n    my($orig, $repl) = @_;\n    for my $i (0 .. -1+length $orig) {\n        substr($repl,$i,1, lc substr $repl,$i,1) if substr($orig,$i,1) ne substr($repl,$i,1);\n    }\n    $repl;\n}\n\nsay \"Original DNA strand:\\n\" . pretty($dna);\nsay \"Total bases: \". length $dna;\nsay \"$_: $cnt{$_}\" for @bases;\n\nmy $mutate = mutate($dna, 10);\n%cnt = ();\n$cnt{$_}++ for split //, $mutate;\nsay \"\\nMutated DNA strand:\\n\" . pretty diff $dna, $mutate;\nsay \"Total bases: \". length $mutate;\nsay \"$_: $cnt{$_}\" for @bases;\n", "target": "import random\nfrom collections import Counter\n\ndef basecount(dna):\n    return sorted(Counter(dna).items())\n\ndef seq_split(dna, n=50):\n    return [dna[i: i+n] for i in range(0, len(dna), n)]\n\ndef seq_pp(dna, n=50):\n    for i, part in enumerate(seq_split(dna, n)):\n        print(f\"{i*n:>5}: {part}\")\n    print(\"\\n  BASECOUNT:\")\n    tot = 0\n    for base, count in basecount(dna):\n        print(f\"    {base:>3}: {count}\")\n        tot += count\n    base, count = 'TOT', tot\n    print(f\"    {base:>3}= {count}\")\n\ndef seq_mutate(dna, count=1, kinds=\"IDSSSS\", choice=\"ATCG\" ):\n    mutation = []\n    k2txt = dict(I='Insert', D='Delete', S='Substitute')\n    for _ in range(count):\n        kind = random.choice(kinds)\n        index = random.randint(0, len(dna))\n        if kind == 'I':    \n            dna = dna[:index] + random.choice(choice) + dna[index:]\n        elif kind == 'D' and dna:  \n            dna = dna[:index] + dna[index+1:]\n        elif kind == 'S' and dna:  \n            dna = dna[:index] + random.choice(choice) + dna[index+1:]\n        mutation.append((k2txt[kind], index))\n    return dna, mutation\n\nif __name__ == '__main__':\n    length = 250\n    print(\"SEQUENCE:\")\n    sequence = ''.join(random.choices('ACGT', weights=(1, 0.8, .9, 1.1), k=length))\n    seq_pp(sequence)\n    print(\"\\n\\nMUTATIONS:\")\n    mseq, m = seq_mutate(sequence, 10)\n    for kind, index in m:\n        print(f\" {kind:>10} @{index}\")\n    print()\n    seq_pp(mseq)\n"}
{"id": 333587, "name": "Colour bars_Display", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse GD;\n\nmy %colors = (\nwhite   => [255,255,255], red    => [255,  0,  0], green => [  0,255,  0], blue  => [  0,  0,255],\nmagenta => [255,  0,255], yellow => [255,255,  0], cyan  => [  0,255,255], black => [  0,  0,  0]);\n\nmy $start    = 0;\nmy $barwidth = 160 / 8;\nmy $image    = GD::Image->new( 160 , 100 );\n\nfor my $rgb ( values %colors ) {\n   $image->filledRectangle( $start * $barwidth , 0 , $start * $barwidth + \n\t                        $barwidth - 1 , 99 , $image->colorAllocate( @$rgb ) );\n   $start++ ;\n}\nopen ( DISPLAY , \">\" , \"bars.png\" ) or die;\nbinmode DISPLAY;\nprint DISPLAY $image->png;\nclose DISPLAY;\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 333588, "name": "Colour bars_Display", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse GD;\n\nmy %colors = (\nwhite   => [255,255,255], red    => [255,  0,  0], green => [  0,255,  0], blue  => [  0,  0,255],\nmagenta => [255,  0,255], yellow => [255,255,  0], cyan  => [  0,255,255], black => [  0,  0,  0]);\n\nmy $start    = 0;\nmy $barwidth = 160 / 8;\nmy $image    = GD::Image->new( 160 , 100 );\n\nfor my $rgb ( values %colors ) {\n   $image->filledRectangle( $start * $barwidth , 0 , $start * $barwidth + \n\t                        $barwidth - 1 , 99 , $image->colorAllocate( @$rgb ) );\n   $start++ ;\n}\nopen ( DISPLAY , \">\" , \"bars.png\" ) or die;\nbinmode DISPLAY;\nprint DISPLAY $image->png;\nclose DISPLAY;\n", "target": "\n\n\nfrom livewires import *\n\nhoriz=640; vert=480\nbegin_graphics(width=horiz,height=vert,title=\"v_stripes\",background=Colour.black)\nNameColors=[\"black\",\"red\",\"green\",\"dark_blue\",\"purple\",\"blue\",\"yellow\",\"white\"]\nstepik=horiz/len(NameColors)\n\nfor index,each in enumerate(NameColors):\n\tExcStrng=\"set_colour(Colour.\"+each+\")\"\n\texec ExcStrng\n\tbox(index*stepik,0,(index+1)*stepik,vert,filled=1)\n\nwhile keys_pressed() != ['x']: \n\tpass\n\nend_graphics()\n"}
{"id": 333589, "name": "Ray-casting algorithm", "source": "Translate Perl to Python: use strict;\nuse List::Util qw(max min);\n\nsub point_in_polygon\n{\n    my ( $point, $polygon ) = @_;\n\n    my $count = 0;\n    foreach my $side ( @$polygon ) {\n\t$count++ if ray_intersect_segment($point, $side);\n    }\n    return ($count % 2 == 0) ? 0 : 1;\n}\n\n\nmy $eps = 0.0001;\nmy $inf = 1e600;\n\nsub ray_intersect_segment\n{\n    my ($point, $segment) = @_;\n\n    my ($A, $B) = @$segment;\n\n    my @P = @$point; \n\n    ($A, $B) = ($B, $A) if $A->[1] > $B->[1];\n\n    $P[1] += $eps if ($P[1] == $A->[1]) || ($P[1] == $B->[1]);\n\n    return 0 if ($P[1] < $A->[1]) || ( $P[1] > $B->[1]) || ($P[0] > max($A->[0],$B->[1]) );\n    return 1 if $P[0] < min($A->[0], $B->[0]);\n\n    my $m_red = ($A->[0] != $B->[0]) ? ( $B->[1] - $A->[1] )/($B->[0] - $A->[0]) : $inf;\n    my $m_blue = ($A->[0] != $P[0]) ? ( $P[1] - $A->[1] )/($P[0] - $A->[0]) : $inf;\n\n    return ($m_blue >= $m_red) ? 1 : 0;\n}\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\nimport sys\n\nPt = namedtuple('Pt', 'x, y')               \nEdge = namedtuple('Edge', 'a, b')           \nPoly = namedtuple('Poly', 'name, edges')    \n\n_eps = 0.00001\n_huge = sys.float_info.max\n_tiny = sys.float_info.min\n\ndef rayintersectseg(p, edge):\n    \n    a,b = edge\n    if a.y > b.y:\n        a,b = b,a\n    if p.y == a.y or p.y == b.y:\n        p = Pt(p.x, p.y + _eps)\n\n    intersect = False\n\n    if (p.y > b.y or p.y < a.y) or (\n        p.x > max(a.x, b.x)):\n        return False\n\n    if p.x < min(a.x, b.x):\n        intersect = True\n    else:\n        if abs(a.x - b.x) > _tiny:\n            m_red = (b.y - a.y) / float(b.x - a.x)\n        else:\n            m_red = _huge\n        if abs(a.x - p.x) > _tiny:\n            m_blue = (p.y - a.y) / float(p.x - a.x)\n        else:\n            m_blue = _huge\n        intersect = m_blue >= m_red\n    return intersect\n\ndef _odd(x): return x%2 == 1\n\ndef ispointinside(p, poly):\n    ln = len(poly)\n    return _odd(sum(rayintersectseg(p, edge)\n                    for edge in poly.edges ))\n\ndef polypp(poly):\n    print (\"\\n  Polygon(name='%s', edges=(\" % poly.name)\n    print ('   ', ',\\n    '.join(str(e) for e in poly.edges) + '\\n    ))')\n\nif __name__ == '__main__':\n    polys = [\n      Poly(name='square', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0))\n        )),\n      Poly(name='square_hole', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0)),\n        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=7.5, y=2.5)),\n        Edge(a=Pt(x=7.5, y=2.5), b=Pt(x=7.5, y=7.5)),\n        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=2.5, y=7.5)),\n        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=2.5, y=2.5))\n        )),\n      Poly(name='strange', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=2.5, y=2.5)),\n        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=2.5, y=7.5)),\n        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=7.5, y=7.5)),\n        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=2.5, y=2.5))\n        )),\n      Poly(name='exagon', edges=(\n        Edge(a=Pt(x=3, y=0), b=Pt(x=7, y=0)),\n        Edge(a=Pt(x=7, y=0), b=Pt(x=10, y=5)),\n        Edge(a=Pt(x=10, y=5), b=Pt(x=7, y=10)),\n        Edge(a=Pt(x=7, y=10), b=Pt(x=3, y=10)),\n        Edge(a=Pt(x=3, y=10), b=Pt(x=0, y=5)),\n        Edge(a=Pt(x=0, y=5), b=Pt(x=3, y=0))\n        )),\n      ]\n    testpoints = (Pt(x=5, y=5), Pt(x=5, y=8),\n                  Pt(x=-10, y=5), Pt(x=0, y=5),\n                  Pt(x=10, y=5), Pt(x=8, y=5),\n                  Pt(x=10, y=10))\n    \n    print (\"\\n TESTING WHETHER POINTS ARE WITHIN POLYGONS\")\n    for poly in polys:\n        polypp(poly)\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[:3]))\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[3:6]))\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[6:]))\n"}
{"id": 333590, "name": "Dining philosophers", "source": "Translate Perl to Python: use threads;\nuse threads::shared;\nmy @names = qw(Aristotle Kant Spinoza Marx Russell);\n\nmy @forks = ('On Table') x @names;\nshare $forks[$_] for 0 .. $\n\nsub pick_up_forks {\n   my $philosopher = shift;\n   my ($first, $second) = ($philosopher, $philosopher-1);\n   ($first, $second) = ($second, $first) if $philosopher % 2;\n   for my $fork ( @forks[ $first, $second ] ) {\n      lock $fork;\n      cond_wait($fork) while $fork ne 'On Table';\n      $fork = 'In Hand';\n   }\n}\n\nsub drop_forks {\n   my $philosopher = shift;\n   for my $fork ( @forks[$philosopher, $philosopher-1] ) {\n      lock $fork;\n      die unless $fork eq 'In Hand';\n      $fork = 'On Table';\n      cond_signal($fork);\n   }\n}\n\nsub philosopher {\n   my $philosopher = shift;\n   my $name = $names[$philosopher];\n   for my $meal ( 1..5 ) {\n      print $name, \" is pondering\\n\";\n      sleep 1 + rand 8;\n      print $name, \" is hungry\\n\";\n      pick_up_forks( $philosopher );\n      print $name, \" is eating\\n\";\n      sleep 1 + rand 8;\n      drop_forks( $philosopher );\n   }\n   print $name, \" is done\\n\";\n}\n\nmy @t = map { threads->new(\\&philosopher, $_) } 0 .. $\nfor my $thread ( @t ) {\n   $thread->join;\n}\n\nprint \"Done\\n\";\n", "target": "import threading\nimport random\nimport time\n\n\n\n\n\n\n\n\n\n\nclass Philosopher(threading.Thread):\n    \n    running = True\n\n    def __init__(self, xname, forkOnLeft, forkOnRight):\n        threading.Thread.__init__(self)\n        self.name = xname\n        self.forkOnLeft = forkOnLeft\n        self.forkOnRight = forkOnRight\n\n    def run(self):\n        while(self.running):\n            \n            time.sleep( random.uniform(3,13))\n            print '%s is hungry.' % self.name\n            self.dine()\n\n    def dine(self):\n        fork1, fork2 = self.forkOnLeft, self.forkOnRight\n\n        while self.running:\n            fork1.acquire(True)\n            locked = fork2.acquire(False)\n            if locked: break\n            fork1.release()\n            print '%s swaps forks' % self.name\n            fork1, fork2 = fork2, fork1\n        else:\n            return\n\n        self.dining()\n        fork2.release()\n        fork1.release()\n\n    def dining(self):\t\t\t\n        print '%s starts eating '% self.name\n        time.sleep(random.uniform(1,10))\n        print '%s finishes eating and leaves to think.' % self.name\n\ndef DiningPhilosophers():\n    forks = [threading.Lock() for n in range(5)]\n    philosopherNames = ('Aristotle','Kant','Spinoza','Marx', 'Russel')\n\n    philosophers= [Philosopher(philosopherNames[i], forks[i%5], forks[(i+1)%5]) \\\n            for i in range(5)]\n\n    random.seed(507129)\n    Philosopher.running = True\n    for p in philosophers: p.start()\n    time.sleep(100)\n    Philosopher.running = False\n    print (\"Now we're finishing.\")\n\nDiningPhilosophers()\n"}
{"id": 333591, "name": "Exceptions", "source": "Translate Perl to Python: \ndie \"Danger, danger, Will Robinson!\";\n\n\neval {\n    die \"this could go wrong mightily\";\n};\nprint $@ if $@;\n\n\ndie $@;\n", "target": "import exceptions\nclass SillyError(exceptions.Exception):\n    def __init__(self,args=None):\n         self.args=args\n"}
{"id": 333592, "name": "24 game", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q') \n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  \n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  \n      $entry =~ /\\d\\d/ ||                \n      $entry =~ m|[-+*/]{2}| ||          \n      $entry =~ tr|-0-9()+*/||c)         \n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 333593, "name": "24 game", "source": "Translate Perl to Python: \nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q') \n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  \n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  \n      $entry =~ /\\d\\d/ ||                \n      $entry =~ m|[-+*/]{2}| ||          \n      $entry =~ tr|-0-9()+*/||c)         \n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 333594, "name": "Enforced immutability", "source": "Translate Perl to Python: use constant PI => 3.14159;\nuse constant MSG => \"Hello World\";\n", "target": ">>> s = \"Hello\"\n>>> s[0] = \"h\"\n\nTraceback (most recent call last):\n  File \"<pyshell\n    s[0] = \"h\"\nTypeError: 'str' object does not support item assignment\n"}
{"id": 333595, "name": "Strange numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Quantum::Superpositions;\n\nsub is_strange {\n    my @digits = split '', $_;\n    my @deltas = map { abs $digits[$_-1] - $digits[$_] } 1..$\n    all(@deltas) == any(2, 3, 5, 7);\n}\n\nmy($low, $high) = (100, 500);\nmy $cnt = my @strange = grep { is_strange($_) } $low+1 .. $high-1;\nsay \"Between $low and $high there are $cnt strange numbers:\\n\" .\n    (sprintf \"@{['%5d' x $cnt]}\", @strange[0..$cnt-1]) =~ s/(.{80})/$1\\n/gr;\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333596, "name": "Strange numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Quantum::Superpositions;\n\nsub is_strange {\n    my @digits = split '', $_;\n    my @deltas = map { abs $digits[$_-1] - $digits[$_] } 1..$\n    all(@deltas) == any(2, 3, 5, 7);\n}\n\nmy($low, $high) = (100, 500);\nmy $cnt = my @strange = grep { is_strange($_) } $low+1 .. $high-1;\nsay \"Between $low and $high there are $cnt strange numbers:\\n\" .\n    (sprintf \"@{['%5d' x $cnt]}\", @strange[0..$cnt-1]) =~ s/(.{80})/$1\\n/gr;\n", "target": "\n\n\n\ndef isStrange(n):\n    \n    def test(a, b):\n        return abs(a - b) in [2, 3, 5, 7]\n\n    xs = digits(n)\n    return all(map(test, xs, xs[1:]))\n\n\n\n\ndef main():\n    \n\n    xs = [\n        n for n in range(100, 1 + 500)\n        if isStrange(n)\n    ]\n    print('\\nStrange numbers in range [100..500]\\n')\n    print('(Total: ' + str(len(xs)) + ')\\n')\n    print(\n        '\\n'.join(\n            ' '.join(\n                str(x) for x in row\n            ) for row in chunksOf(10)(xs)\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digits(n):\n    \n    return [int(c) for c in str(n)]\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333597, "name": "Hofstadter Q sequence", "source": "Translate Perl to Python: my @Q = (0,1,1);\npush @Q, $Q[-$Q[-1]] + $Q[-$Q[-2]] for 1..100_000;\nsay \"First 10 terms: [@Q[1..10]]\";\nsay \"Term 1000: $Q[1000]\";\nsay \"Terms less than preceding in first 100k: \",scalar(grep { $Q[$_] < $Q[$_-1] } 2..100000);\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 333598, "name": "Hofstadter Q sequence", "source": "Translate Perl to Python: my @Q = (0,1,1);\npush @Q, $Q[-$Q[-1]] + $Q[-$Q[-2]] for 1..100_000;\nsay \"First 10 terms: [@Q[1..10]]\";\nsay \"Term 1000: $Q[1000]\";\nsay \"Terms less than preceding in first 100k: \",scalar(grep { $Q[$_] < $Q[$_-1] } 2..100000);\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 333599, "name": "Count occurrences of a substring", "source": "Translate Perl to Python: sub countSubstring {\n  my $str = shift;\n  my $sub = quotemeta(shift);\n  my $count = () = $str =~ /$sub/g;\n  return $count;\n\n}\n  \nprint countSubstring(\"the three truths\",\"th\"), \"\\n\"; \nprint countSubstring(\"ababababab\",\"abab\"), \"\\n\"; \n", "target": ">>> \"the three truths\".count(\"th\")\n3\n>>> \"ababababab\".count(\"abab\")\n2\n"}
{"id": 333600, "name": "Append numbers at same position in strings", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy @a = < 1  2  3  4  5  6  7  8  9>;\nmy @b = <10 11 12 13 14 15 16 17 18>;\nmy @c = <19 20 21 22 23 24 25 26 27>;\nmy @d = <1  2  2  2  2  2  2  2  2 >;\nmy @e = < 9  0  1  2  3  4  5  6  7>;\nmy @f = (\\@a, \\@b, \\@d, \\@e);\n\n\nprint $a[$_] . $b[$_] . $c[$_] . ' ' for 0..$\n\n\nfor my $i (0 .. $\n    map {print $f[$_][$i] } 0 .. $\n}\nprint \"\\n\";\n", "target": "list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nlist2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]\nlist3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]\n\nprint([\n    ''.join(str(n) for n in z) for z\n    in zip(list1, list2, list3)\n])\n"}
{"id": 333601, "name": "Append numbers at same position in strings", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy @a = < 1  2  3  4  5  6  7  8  9>;\nmy @b = <10 11 12 13 14 15 16 17 18>;\nmy @c = <19 20 21 22 23 24 25 26 27>;\nmy @d = <1  2  2  2  2  2  2  2  2 >;\nmy @e = < 9  0  1  2  3  4  5  6  7>;\nmy @f = (\\@a, \\@b, \\@d, \\@e);\n\n\nprint $a[$_] . $b[$_] . $c[$_] . ' ' for 0..$\n\n\nfor my $i (0 .. $\n    map {print $f[$_][$i] } 0 .. $\n}\nprint \"\\n\";\n", "target": "list1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nlist2 = [10, 11, 12, 13, 14, 15, 16, 17, 18]\nlist3 = [19, 20, 21, 22, 23, 24, 25, 26, 27]\n\nprint([\n    ''.join(str(n) for n in z) for z\n    in zip(list1, list2, list3)\n])\n"}
{"id": 333602, "name": "Logistic curve fitting in epidemiology", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nmy $K  = 7_800_000_000; \nmy $n0 = 27;            \n\nmy @y = (\n    27,     27,     27,     44,     44,     59,     59,     59,    59,      59,     59,     59,     59,\n    60,     60,     61,     61,     66,     83,    219,    239,    392,    534,    631,    897,   1350,\n  2023,   2820,   4587,   6067,   7823,   9826,  11946,  14554,  17372,  20615,  24522,  28273,  31491,\n 34933,  37552,  40540,  43105,  45177,  60328,  64543,  67103,  69265,  71332,  73327,  75191,  75723,\n 76719,  77804,  78812,  79339,  80132,  80995,  82101,  83365,  85203,  87024,  89068,  90664,  93077,\n 95316,  98172, 102133, 105824, 109695, 114232, 118610, 125497, 133852, 143227, 151367, 167418, 180096,\n194836, 213150, 242364, 271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704, 656866, 715353,\n777796, 851308, 928436,1000249,1082054,1174652\n);\n\nsub logistic_func {\n    my($r) = @_;\n    my $sq = 0;\n    for my $i (0 .. @y-1) {\n        my $eri = exp($r * $i);\n        my $dst = ($n0 * $eri) / (1 + $n0 * ($eri-1) / $K) - $y[$i];\n        $sq = $sq + $dst**2;\n    }\n    $sq\n}\n\nsub solve {\n    my($fn, $guess, $epsilon) = @_;\n    my($nfm,$nfp);\n    my $f0 = &$fn($guess);\n    my $delta = $guess;\n    my $factor = 2;\n    while ($delta > $epsilon) {\n        ($nfm = &$fn($guess - $delta)) < $f0 ?\n            ($f0 = $nfm, $guess -= $delta, $delta *= $factor)\n        :\n        ($nfp = &$fn($guess + $delta)) < $f0 ?\n            ($f0 = $nfp, $guess += $delta, $delta *= $factor)\n        :\n            $delta /= $factor\n    }\n    $guess\n}\n\nmy $r  = solve(\\&logistic_func, 0.5, 0);\nmy $R0 = exp(12 * $r);\nprintf \"r =\u00a0%%(%.3f), R0 =\u00a0%%(%.3f)\\n\", $r, $R0;\n", "target": "import numpy as np\nimport scipy.optimize as opt\n\nn0, K = 27, 7_800_000_000\n\ndef f(t, r):\n    return (n0 * np.exp(r * t)) / (( 1 + n0 * (np.exp(r * t) - 1) / K))\n\ny = [\n27, 27, 27, 44, 44, 59, 59, 59, 59, 59, 59, 59, 59, 60, 60,\n61, 61, 66, 83, 219, 239, 392, 534, 631, 897, 1350, 2023,\n2820, 4587, 6067, 7823, 9826, 11946, 14554, 17372, 20615,\n24522, 28273, 31491, 34933, 37552, 40540, 43105, 45177,\n60328, 64543, 67103, 69265, 71332, 73327, 75191, 75723,\n76719, 77804, 78812, 79339, 80132, 80995, 82101, 83365,\n85203, 87024, 89068, 90664, 93077, 95316, 98172, 102133,\n105824, 109695, 114232, 118610, 125497, 133852, 143227,\n151367, 167418, 180096, 194836, 213150, 242364, 271106,\n305117, 338133, 377918, 416845, 468049, 527767, 591704,\n656866, 715353, 777796, 851308, 928436, 1000249, 1082054,\n1174652,\n]\nx = np.linspace(0.0, 96, 97)\n\nr, cov = opt.curve_fit(f, x, y, [0.5])\n\n\nprint(\"The r for the world Covid-19 data is:\", r,\n    \", with covariance of\", cov)   \nprint(\"The calculated R0 is then\", np.exp(12 * r))\n"}
{"id": 333603, "name": "User input_Graphical", "source": "Translate Perl to Python: use Wx;\n\npackage MyApp;\nuse base 'Wx::App';\nuse Wx qw(wxHORIZONTAL wxVERTICAL wxALL wxALIGN_CENTER);\nuse Wx::Event 'EVT_BUTTON';\n\nour ($frame, $text_input, $integer_input);\n\nsub OnInit\n   {$frame = new Wx::Frame\n       (undef, -1, 'Input window', [-1, -1], [250, 150]);\n\n    my $panel = new Wx::Panel($frame, -1);\n    $text_input = new Wx::TextCtrl($panel, -1, '');\n    $integer_input = new Wx::SpinCtrl\n       ($panel, -1, '', [-1, -1], [-1, -1],\n        0, 0, 100_000);\n\n    my $okay_button = new Wx::Button($panel, -1, 'OK');\n    EVT_BUTTON($frame, $okay_button, \\&OnQuit);\n\n    my $sizer = new Wx::BoxSizer(wxVERTICAL);\n    $sizer->Add($_, 0, wxALL | wxALIGN_CENTER, 5)\n        foreach $text_input, $integer_input, $okay_button;\n    $panel->SetSizer($sizer);\n\n    $frame->Show(1);}\n\nsub OnQuit\n   {print 'String: ', $text_input->GetValue, \"\\n\";\n    print 'Integer: ', $integer_input->GetValue, \"\\n\";\n    $frame->Close;}\n\n\n\npackage main;\n\nMyApp->new->MainLoop;\n", "target": "from javax.swing import JOptionPane\n\ndef to_int(n, default=0):\n    try:\n        return int(n)\n    except ValueError:\n        return default\n\nnumber = to_int(JOptionPane.showInputDialog (\"Enter an Integer\")) \nprintln(number)\n\na_string = JOptionPane.showInputDialog (\"Enter a String\")\nprintln(a_string)\n"}
{"id": 333604, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Perl to Python: use ntheory qw/forprimes is_prime vecprod/;\n\nforprimes { my $p = $_;\n   for my $h3 (2 .. $p-1) {\n      my $ph3 = $p + $h3;\n      for my $d (1 .. $ph3-1) {               \n         next if ((-$p*$p) % $h3) != ($d % $h3);\n         next if (($p-1)*$ph3) % $d;\n         my $q = 1 + ($p-1)*$ph3 / $d;        \n         next unless is_prime($q);\n         my $r = 1 + ($p*$q-1) / $h3;         \n         next unless is_prime($r);\n         next unless ($q*$r) % ($p-1) == 1;\n         printf \"%2d x %5d x %5d = %s\\n\",$p,$q,$r,vecprod($p,$q,$r);\n      }\n   }\n} 3,61;\n", "target": "class Isprime():\n    \n    multiples = {2}\n    primes = [2]\n    nmax = 2\n    \n    def __init__(self, nmax):\n        if nmax > self.nmax:\n            self.check(nmax)\n\n    def check(self, n):\n        if type(n) == float:\n            if not n.is_integer(): return False\n            n = int(n)\n        multiples = self.multiples\n        if n <= self.nmax:\n            return n not in multiples\n        else:\n            \n            primes, nmax = self.primes, self.nmax\n            newmax = max(nmax*2, n)\n            for p in primes:\n                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))\n            for i in range(nmax+1, newmax+1):\n                if i not in multiples:\n                    primes.append(i)\n                    multiples.update(range(i*2, newmax+1, i))\n            self.nmax = newmax\n            return n not in multiples\n\n    __call__ = check\n            \n        \ndef carmichael(p1):\n    ans = []\n    if isprime(p1):\n        for h3 in range(2, p1):\n            g = h3 + p1\n            for d in range(1, g):\n                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:\n                    p2 = 1 + ((p1 - 1)* g // d)\n                    if isprime(p2):\n                        p3 = 1 + (p1 * p2 // h3)\n                        if isprime(p3):\n                            if (p2 * p3) % (p1 - 1) == 1:\n                                \n                                ans += [tuple(sorted((p1, p2, p3)))]\n    return ans\n                \nisprime = Isprime(2)\n \nans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))\nprint(',\\n'.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))\n"}
{"id": 333605, "name": "Find square difference", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy $n = 1;\n$n++ until $n ** 2 - ($n-1) ** 2 > 1000;\nprint \"$n\\n\";\n", "target": "import math\nprint(\"working...\")\nlimit1 = 6000\nlimit2 = 1000\noldSquare = 0\nnewSquare = 0\n\nfor n in range(limit1):\n    newSquare = n*n\n    if (newSquare - oldSquare > limit2):\n     print(\"Least number is = \", end = \"\");\n     print(int(math.sqrt(newSquare)))\n     break\n    oldSquare = n*n\n\nprint(\"done...\")\nprint()\n"}
{"id": 333606, "name": "Find square difference", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy $n = 1;\n$n++ until $n ** 2 - ($n-1) ** 2 > 1000;\nprint \"$n\\n\";\n", "target": "import math\nprint(\"working...\")\nlimit1 = 6000\nlimit2 = 1000\noldSquare = 0\nnewSquare = 0\n\nfor n in range(limit1):\n    newSquare = n*n\n    if (newSquare - oldSquare > limit2):\n     print(\"Least number is = \", end = \"\");\n     print(int(math.sqrt(newSquare)))\n     break\n    oldSquare = n*n\n\nprint(\"done...\")\nprint()\n"}
{"id": 333607, "name": "Snake", "source": "Translate Perl to Python: use utf8;\nuse Time::HiRes qw(sleep);\nuse Term::ANSIColor qw(colored);\nuse Term::ReadKey qw(ReadMode ReadLine);\n\nbinmode(STDOUT, ':utf8');\n\nuse constant {\n              VOID => 0,\n              HEAD => 1,\n              BODY => 2,\n              TAIL => 3,\n              FOOD => 4,\n             };\n\nuse constant {\n              LEFT  => [+0, -1],\n              RIGHT => [+0, +1],\n              UP    => [-1, +0],\n              DOWN  => [+1, +0],\n             };\n\nuse constant {\n              BG_COLOR  => \"on_black\",\n              SLEEP_SEC => 0.05,\n             };\n\nuse constant {\n              SNAKE_COLOR => ('bold green' . ' ' . BG_COLOR),\n              FOOD_COLOR  => ('red'        . ' ' . BG_COLOR),\n             };\n\nuse constant {\n    U_HEAD => colored('\u25b2', SNAKE_COLOR),\n    D_HEAD => colored('\u25bc', SNAKE_COLOR),\n    L_HEAD => colored('\u25c0', SNAKE_COLOR),\n    R_HEAD => colored('\u25b6', SNAKE_COLOR),\n\n    U_BODY => colored('\u2579', SNAKE_COLOR),\n    D_BODY => colored('\u257b', SNAKE_COLOR),\n    L_BODY => colored('\u2574', SNAKE_COLOR),\n    R_BODY => colored('\u2576', SNAKE_COLOR),\n\n    U_TAIL => colored('\u257d', SNAKE_COLOR),\n    D_TAIL => colored('\u257f', SNAKE_COLOR),\n    L_TAIL => colored('\u257c', SNAKE_COLOR),\n    R_TAIL => colored('\u257e', SNAKE_COLOR),\n\n    A_VOID => colored(' ',   BG_COLOR),\n    A_FOOD => colored('\u2747', FOOD_COLOR),\n             };\n\nlocal $| = 1;\n\nmy $w = eval { `tput cols` }  || 80;\nmy $h = eval { `tput lines` } || 24;\nmy $r = \"\\033[H\";\n\nmy @grid = map {\n    [map { [VOID] } 1 .. $w]\n} 1 .. $h;\n\nmy $dir      = LEFT;\nmy @head_pos = ($h / 2, $w / 2);\nmy @tail_pos = ($head_pos[0], $head_pos[1] + 1);\n\n$grid[$head_pos[0]][$head_pos[1]] = [HEAD, $dir];    \n$grid[$tail_pos[0]][$tail_pos[1]] = [TAIL, $dir];    \n\nsub create_food {\n    my ($food_x, $food_y);\n\n    do {\n        $food_x = rand($w);\n        $food_y = rand($h);\n    } while ($grid[$food_y][$food_x][0] != VOID);\n\n    $grid[$food_y][$food_x][0] = FOOD;\n}\n\ncreate_food();\n\nsub display {\n    my $i = 0;\n\n    print $r, join(\"\\n\",\n        map {\n            join(\"\",\n                map {\n                    my $t = $_->[0];\n                    if ($t != FOOD and $t != VOID) {\n                        my $p = $_->[1];\n                        $i =\n                            $p eq UP   ? 0\n                          : $p eq DOWN ? 1\n                          : $p eq LEFT ? 2\n                          :              3;\n                    }\n                        $t == HEAD ? (U_HEAD, D_HEAD, L_HEAD, R_HEAD)[$i]\n                      : $t == BODY ? (U_BODY, D_BODY, L_BODY, R_BODY)[$i]\n                      : $t == TAIL ? (U_TAIL, D_TAIL, L_TAIL, R_TAIL)[$i]\n                      : $t == FOOD ? (A_FOOD)\n                      :              (A_VOID);\n\n                  } @{$_}\n                )\n          } @grid\n    );\n}\n\nsub move {\n    my $grew = 0;\n\n    \n    {\n        my ($y, $x) = @head_pos;\n\n        my $new_y = ($y + $dir->[0]) % $h;\n        my $new_x = ($x + $dir->[1]) % $w;\n\n        my $cell = $grid[$new_y][$new_x];\n        my $t    = $cell->[0];\n\n        if ($t == BODY or $t == TAIL) {\n            die \"Game over!\\n\";\n        }\n        elsif ($t == FOOD) {\n            create_food();\n            $grew = 1;\n        }\n\n        \n        $grid[$new_y][$new_x] = [HEAD, $dir];\n\n        \n        $grid[$y][$x] = [BODY, $dir];\n\n        \n        @head_pos = ($new_y, $new_x);\n    }\n\n    \n    if (not $grew) {\n        my ($y, $x) = @tail_pos;\n\n        my $pos   = $grid[$y][$x][1];\n        my $new_y = ($y + $pos->[0]) % $h;\n        my $new_x = ($x + $pos->[1]) % $w;\n\n        $grid[$y][$x][0]         = VOID;    \n        $grid[$new_y][$new_x][0] = TAIL;    \n\n        \n        @tail_pos = ($new_y, $new_x);\n    }\n}\n\nReadMode(3);\nwhile (1) {\n    my $key;\n    until (defined($key = ReadLine(-1))) {\n        move();\n        display();\n        sleep(SLEEP_SEC);\n    }\n\n    if    ($key eq \"\\e[A\" and $dir ne DOWN ) { $dir = UP    }\n    elsif ($key eq \"\\e[B\" and $dir ne UP   ) { $dir = DOWN  }\n    elsif ($key eq \"\\e[C\" and $dir ne LEFT ) { $dir = RIGHT }\n    elsif ($key eq \"\\e[D\" and $dir ne RIGHT) { $dir = LEFT  }\n}\n", "target": "from __future__ import annotations\n\nimport itertools\nimport random\n\nfrom enum import Enum\n\nfrom typing import Any\nfrom typing import Tuple\n\nimport pygame as pg\n\nfrom pygame import Color\nfrom pygame import Rect\n\nfrom pygame.surface import Surface\n\nfrom pygame.sprite import AbstractGroup\nfrom pygame.sprite import Group\nfrom pygame.sprite import RenderUpdates\nfrom pygame.sprite import Sprite\n\n\nclass Direction(Enum):\n    UP = (0, -1)\n    DOWN = (0, 1)\n    LEFT = (-1, 0)\n    RIGHT = (1, 0)\n\n    def opposite(self, other: Direction):\n        return (self[0] + other[0], self[1] + other[1]) == (0, 0)\n\n    def __getitem__(self, i: int):\n        return self.value[i]\n\n\nclass SnakeHead(Sprite):\n    def __init__(\n        self,\n        size: int,\n        position: Tuple[int, int],\n        facing: Direction,\n        bounds: Rect,\n    ) -> None:\n        super().__init__()\n        self.image = Surface((size, size))\n        self.image.fill(Color(\"aquamarine4\"))\n        self.rect = self.image.get_rect()\n        self.rect.center = position\n        self.facing = facing\n        self.size = size\n        self.speed = size\n        self.bounds = bounds\n\n    def update(self, *args: Any, **kwargs: Any) -> None:\n        \n        self.rect.move_ip(\n            (\n                self.facing[0] * self.speed,\n                self.facing[1] * self.speed,\n            )\n        )\n\n        \n        if self.rect.right > self.bounds.right:\n            self.rect.left = 0\n        elif self.rect.left < 0:\n            self.rect.right = self.bounds.right\n\n        if self.rect.bottom > self.bounds.bottom:\n            self.rect.top = 0\n        elif self.rect.top < 0:\n            self.rect.bottom = self.bounds.bottom\n\n    def change_direction(self, direction: Direction):\n        if not self.facing == direction and not direction.opposite(self.facing):\n            self.facing = direction\n\n\nclass SnakeBody(Sprite):\n    def __init__(\n        self,\n        size: int,\n        position: Tuple[int, int],\n        colour: str = \"white\",\n    ) -> None:\n        super().__init__()\n        self.image = Surface((size, size))\n        self.image.fill(Color(colour))\n        self.rect = self.image.get_rect()\n        self.rect.center = position\n\n\nclass Snake(RenderUpdates):\n    def __init__(self, game: Game) -> None:\n        self.segment_size = game.segment_size\n        self.colours = itertools.cycle([\"aquamarine1\", \"aquamarine3\"])\n\n        self.head = SnakeHead(\n            size=self.segment_size,\n            position=game.rect.center,\n            facing=Direction.RIGHT,\n            bounds=game.rect,\n        )\n\n        neck = [\n            SnakeBody(\n                size=self.segment_size,\n                position=game.rect.center,\n                colour=next(self.colours),\n            )\n            for _ in range(2)\n        ]\n\n        super().__init__(*[self.head, *neck])\n\n        self.body = Group()\n        self.tail = neck[-1]\n\n    def update(self, *args: Any, **kwargs: Any) -> None:\n        self.head.update()\n\n        \n        segments = self.sprites()\n        for i in range(len(segments) - 1, 0, -1):\n            \n            segments[i].rect.center = segments[i - 1].rect.center\n\n    def change_direction(self, direction: Direction):\n        self.head.change_direction(direction)\n\n    def grow(self):\n        tail = SnakeBody(\n            size=self.segment_size,\n            position=self.tail.rect.center,\n            colour=next(self.colours),\n        )\n        self.tail = tail\n        self.add(self.tail)\n        self.body.add(self.tail)\n\n\nclass SnakeFood(Sprite):\n    def __init__(self, game: Game, size: int, *groups: AbstractGroup) -> None:\n        super().__init__(*groups)\n        self.image = Surface((size, size))\n        self.image.fill(Color(\"red\"))\n        self.rect = self.image.get_rect()\n\n        self.rect.topleft = (\n            random.randint(0, game.rect.width),\n            random.randint(0, game.rect.height),\n        )\n\n        self.rect.clamp_ip(game.rect)\n\n        \n        \n        while pg.sprite.spritecollideany(self, game.snake):\n            self.rect.topleft = (\n                random.randint(0, game.rect.width),\n                random.randint(0, game.rect.height),\n            )\n\n            self.rect.clamp_ip(game.rect)\n\n\nclass Game:\n    def __init__(self) -> None:\n        self.rect = Rect(0, 0, 640, 480)\n        self.background = Surface(self.rect.size)\n        self.background.fill(Color(\"black\"))\n\n        self.score = 0\n        self.framerate = 16\n\n        self.segment_size = 10\n        self.snake = Snake(self)\n        self.food_group = RenderUpdates(SnakeFood(game=self, size=self.segment_size))\n\n        pg.init()\n\n    def _init_display(self) -> Surface:\n        bestdepth = pg.display.mode_ok(self.rect.size, 0, 32)\n        screen = pg.display.set_mode(self.rect.size, 0, bestdepth)\n\n        pg.display.set_caption(\"Snake\")\n        pg.mouse.set_visible(False)\n\n        screen.blit(self.background, (0, 0))\n        pg.display.flip()\n\n        return screen\n\n    def draw(self, screen: Surface):\n        dirty = self.snake.draw(screen)\n        pg.display.update(dirty)\n\n        dirty = self.food_group.draw(screen)\n        pg.display.update(dirty)\n\n    def update(self, screen):\n        self.food_group.clear(screen, self.background)\n        self.food_group.update()\n        self.snake.clear(screen, self.background)\n        self.snake.update()\n\n    def main(self) -> int:\n        screen = self._init_display()\n        clock = pg.time.Clock()\n\n        while self.snake.head.alive():\n            for event in pg.event.get():\n                if event.type == pg.QUIT or (\n                    event.type == pg.KEYDOWN and event.key in (pg.K_ESCAPE, pg.K_q)\n                ):\n                    return self.score\n\n            \n            keystate = pg.key.get_pressed()\n\n            if keystate[pg.K_RIGHT]:\n                self.snake.change_direction(Direction.RIGHT)\n            elif keystate[pg.K_LEFT]:\n                self.snake.change_direction(Direction.LEFT)\n            elif keystate[pg.K_UP]:\n                self.snake.change_direction(Direction.UP)\n            elif keystate[pg.K_DOWN]:\n                self.snake.change_direction(Direction.DOWN)\n\n            \n            self.update(screen)\n\n            \n            for food in pg.sprite.spritecollide(\n                self.snake.head, self.food_group, dokill=False\n            ):\n                food.kill()\n                self.snake.grow()\n                self.score += 1\n\n                \n                if self.score % 5 == 0:\n                    self.framerate += 1\n\n                self.food_group.add(SnakeFood(self, self.segment_size))\n\n            \n            if pg.sprite.spritecollideany(self.snake.head, self.snake.body):\n                self.snake.head.kill()\n\n            self.draw(screen)\n            clock.tick(self.framerate)\n\n        return self.score\n\n\nif __name__ == \"__main__\":\n    game = Game()\n    score = game.main()\n    print(score)\n"}
{"id": 333608, "name": "Pascal's triangle_Puzzle", "source": "Translate Perl to Python: \nmy $rows = 5;\nmy @tri = map { [ map { {x=>0,z=>0,v=>0,rhs=>undef} } 1..$_ ] } 1..$rows;\n$tri[0][0]{rhs} = 151;\n$tri[2][0]{rhs} = 40;\n$tri[4][0]{x} = 1;\n$tri[4][1]{v} = 11;\n$tri[4][2]{x} = 1;\n$tri[4][2]{z} = 1;\n$tri[4][3]{v} = 4;\n$tri[4][4]{z} = 1;\n\n\nfor my $row ( reverse 0..@tri-2 ) {\n    for my $col ( 0..@{$tri[$row]}-1 ){\n        $tri[$row][$col]{$_} = $tri[$row+1][$col]{$_}+$tri[$row+1][$col+1]{$_} for 'x','z','v';\n    }\n}\n\nmy @eqn;\nfor my $row ( @tri ) {\n    for my $col ( @$row ){\n        push @eqn, [ $$col{x}, $$col{z}, $$col{rhs}-$$col{v} ] if defined $$col{rhs};\n    }\n}\n\nprint \"Equations:\\n\";\nprint \"  x +   z = y\\n\";\nprintf \"%d x + %d z = %d\\n\", @$_ for @eqn;\n\nmy $f = $eqn[0][1] / $eqn[1][1];\n$eqn[0][$_] -=  $f * $eqn[1][$_] for 0..2;\n$f = $eqn[1][0] / $eqn[0][0];\n$eqn[1][$_] -=  $f * $eqn[0][$_] for 0..2;\n\nprint \"Solution:\\n\";\nmy $x = $eqn[0][2]/$eqn[0][0];\nmy $z = $eqn[1][2]/$eqn[1][1];\nmy $y = $x+$z;\nprintf \"x=%d, y=%d, z=%d\\n\", $x, $y, $z;\n", "target": "\n\n\n\n\n\n\n\ndef combine( snl, snr ):\n\n\tcl = {}\n\tif isinstance(snl, int):\n\t\tcl['1'] = snl\n\telif isinstance(snl, string):\n\t\tcl[snl] = 1\n\telse:\n\t\tcl.update( snl)\n\n\tif isinstance(snr, int):\n\t\tn = cl.get('1', 0)\n\t\tcl['1'] = n + snr\n\telif isinstance(snr, string):\n\t\tn = cl.get(snr, 0)\n\t\tcl[snr] = n + 1\n\telse:\n\t\tfor k,v in snr.items():\n\t\t\tn = cl.get(k, 0)\n\t\t\tcl[k] = n+v\n\treturn cl\n\n\ndef constrain(nsum, vn ):\n\tnn = {}\n\tnn.update(vn)\n\tn = nn.get('1', 0)\n\tnn['1'] = n - nsum\n\treturn nn\n\ndef makeMatrix( constraints ):\n\tvmap = set()\n\tfor c in constraints:\n\t\tvmap.update( c.keys())\n\tvmap.remove('1')\n\tnvars = len(vmap)\n\tvmap = sorted(vmap)\t\t\n\tmtx = []\n\tfor c in constraints:\n\t\trow = []\n\t\tfor vv in vmap:\n\t\t\trow.append(float(c.get(vv, 0)))\n\t\trow.append(-float(c.get('1',0)))\n\t\tmtx.append(row)\n\t\n\tif len(constraints) == nvars:\n\t\tprint 'System appears solvable'\n\telif len(constraints) < nvars:\n\t\tprint 'System is not solvable - needs more constraints.'\n\treturn mtx, vmap\n\n\ndef SolvePyramid( vl, cnstr ):\n\n\tvl.reverse()\n\tconstraints = [cnstr]\n\tlvls = len(vl)\n\tfor lvln in range(1,lvls):\n\t\tlvd = vl[lvln]\n\t\tfor k in range(lvls - lvln):\n\t\t\tsn = lvd[k]\n\t\t\tll = vl[lvln-1]\n\t\t\tvn = combine(ll[k], ll[k+1])\n\t\t\tif sn is None:\n\t\t\t\tlvd[k] = vn\n\t\t\telse:\n\t\t\t\tconstraints.append(constrain( sn, vn ))\n\n\tprint 'Constraint Equations:'\n\tfor cstr in constraints:\n\t\tfset = ('%d*%s'%(v,k) for k,v in cstr.items() )\n\t\tprint ' + '.join(fset), ' = 0'\n\n\tmtx,vmap = makeMatrix(constraints)\n\n\tMtxSolve(mtx)\n\n\td = len(vmap)\n\tfor j in range(d):\n\t\tprint vmap[j],'=', mtx[j][d]\n\n\ndef MtxSolve(mtx):\n\t\n\n\tmDim = len(mtx)\t\t\t\n\tfor j in range(mDim):\n\t\trw0= mtx[j]\n\t\tf = 1.0/rw0[j]\n\t\tfor k in range(j, mDim+1):\n\t\t\trw0[k] *= f\n\t\t\n\t\tfor l in range(1+j,mDim):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\tfor k in range(j, mDim+1):\n\t\t\t\trwl[k] += f * rw0[k]\n\n\t\n\tfor j1 in range(1,mDim):\n\t\tj = mDim - j1\n\t\trw0= mtx[j]\n\t\tfor l in range(0, j):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\trwl[j]    += f * rw0[j]\n\t\t\trwl[mDim] += f * rw0[mDim]\n\n\treturn mtx\n\n\np = [ [151], [None,None], [40,None,None], [None,None,None,None], ['X', 11, 'Y', 4, 'Z'] ]\naddlConstraint = { 'X':1, 'Y':-1, 'Z':1, '1':0 }\nSolvePyramid( p, addlConstraint)\n"}
{"id": 333609, "name": "Pascal's triangle_Puzzle", "source": "Translate Perl to Python: \nmy $rows = 5;\nmy @tri = map { [ map { {x=>0,z=>0,v=>0,rhs=>undef} } 1..$_ ] } 1..$rows;\n$tri[0][0]{rhs} = 151;\n$tri[2][0]{rhs} = 40;\n$tri[4][0]{x} = 1;\n$tri[4][1]{v} = 11;\n$tri[4][2]{x} = 1;\n$tri[4][2]{z} = 1;\n$tri[4][3]{v} = 4;\n$tri[4][4]{z} = 1;\n\n\nfor my $row ( reverse 0..@tri-2 ) {\n    for my $col ( 0..@{$tri[$row]}-1 ){\n        $tri[$row][$col]{$_} = $tri[$row+1][$col]{$_}+$tri[$row+1][$col+1]{$_} for 'x','z','v';\n    }\n}\n\nmy @eqn;\nfor my $row ( @tri ) {\n    for my $col ( @$row ){\n        push @eqn, [ $$col{x}, $$col{z}, $$col{rhs}-$$col{v} ] if defined $$col{rhs};\n    }\n}\n\nprint \"Equations:\\n\";\nprint \"  x +   z = y\\n\";\nprintf \"%d x + %d z = %d\\n\", @$_ for @eqn;\n\nmy $f = $eqn[0][1] / $eqn[1][1];\n$eqn[0][$_] -=  $f * $eqn[1][$_] for 0..2;\n$f = $eqn[1][0] / $eqn[0][0];\n$eqn[1][$_] -=  $f * $eqn[0][$_] for 0..2;\n\nprint \"Solution:\\n\";\nmy $x = $eqn[0][2]/$eqn[0][0];\nmy $z = $eqn[1][2]/$eqn[1][1];\nmy $y = $x+$z;\nprintf \"x=%d, y=%d, z=%d\\n\", $x, $y, $z;\n", "target": "\n\n\n\n\n\n\n\ndef combine( snl, snr ):\n\n\tcl = {}\n\tif isinstance(snl, int):\n\t\tcl['1'] = snl\n\telif isinstance(snl, string):\n\t\tcl[snl] = 1\n\telse:\n\t\tcl.update( snl)\n\n\tif isinstance(snr, int):\n\t\tn = cl.get('1', 0)\n\t\tcl['1'] = n + snr\n\telif isinstance(snr, string):\n\t\tn = cl.get(snr, 0)\n\t\tcl[snr] = n + 1\n\telse:\n\t\tfor k,v in snr.items():\n\t\t\tn = cl.get(k, 0)\n\t\t\tcl[k] = n+v\n\treturn cl\n\n\ndef constrain(nsum, vn ):\n\tnn = {}\n\tnn.update(vn)\n\tn = nn.get('1', 0)\n\tnn['1'] = n - nsum\n\treturn nn\n\ndef makeMatrix( constraints ):\n\tvmap = set()\n\tfor c in constraints:\n\t\tvmap.update( c.keys())\n\tvmap.remove('1')\n\tnvars = len(vmap)\n\tvmap = sorted(vmap)\t\t\n\tmtx = []\n\tfor c in constraints:\n\t\trow = []\n\t\tfor vv in vmap:\n\t\t\trow.append(float(c.get(vv, 0)))\n\t\trow.append(-float(c.get('1',0)))\n\t\tmtx.append(row)\n\t\n\tif len(constraints) == nvars:\n\t\tprint 'System appears solvable'\n\telif len(constraints) < nvars:\n\t\tprint 'System is not solvable - needs more constraints.'\n\treturn mtx, vmap\n\n\ndef SolvePyramid( vl, cnstr ):\n\n\tvl.reverse()\n\tconstraints = [cnstr]\n\tlvls = len(vl)\n\tfor lvln in range(1,lvls):\n\t\tlvd = vl[lvln]\n\t\tfor k in range(lvls - lvln):\n\t\t\tsn = lvd[k]\n\t\t\tll = vl[lvln-1]\n\t\t\tvn = combine(ll[k], ll[k+1])\n\t\t\tif sn is None:\n\t\t\t\tlvd[k] = vn\n\t\t\telse:\n\t\t\t\tconstraints.append(constrain( sn, vn ))\n\n\tprint 'Constraint Equations:'\n\tfor cstr in constraints:\n\t\tfset = ('%d*%s'%(v,k) for k,v in cstr.items() )\n\t\tprint ' + '.join(fset), ' = 0'\n\n\tmtx,vmap = makeMatrix(constraints)\n\n\tMtxSolve(mtx)\n\n\td = len(vmap)\n\tfor j in range(d):\n\t\tprint vmap[j],'=', mtx[j][d]\n\n\ndef MtxSolve(mtx):\n\t\n\n\tmDim = len(mtx)\t\t\t\n\tfor j in range(mDim):\n\t\trw0= mtx[j]\n\t\tf = 1.0/rw0[j]\n\t\tfor k in range(j, mDim+1):\n\t\t\trw0[k] *= f\n\t\t\n\t\tfor l in range(1+j,mDim):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\tfor k in range(j, mDim+1):\n\t\t\t\trwl[k] += f * rw0[k]\n\n\t\n\tfor j1 in range(1,mDim):\n\t\tj = mDim - j1\n\t\trw0= mtx[j]\n\t\tfor l in range(0, j):\n\t\t\trwl = mtx[l]\n\t\t\tf = -rwl[j]\n\t\t\trwl[j]    += f * rw0[j]\n\t\t\trwl[mDim] += f * rw0[mDim]\n\n\treturn mtx\n\n\np = [ [151], [None,None], [40,None,None], [None,None,None,None], ['X', 11, 'Y', 4, 'Z'] ]\naddlConstraint = { 'X':1, 'Y':-1, 'Z':1, '1':0 }\nSolvePyramid( p, addlConstraint)\n"}
{"id": 333610, "name": "Keyboard input_Flush the keyboard buffer", "source": "Translate Perl to Python: use Term::ReadKey;\nReadMode 'restore';    \n\n\n\n\n\nuse Term::ReadKey;\nReadMode 'cbreak';\n\n\nwhile (defined ReadKey -1) {\n  \n}\n\n\nReadMode 'restore';\n", "target": "def flush_input():\n    try:\n        import msvcrt\n        while msvcrt.kbhit():\n            msvcrt.getch()\n    except ImportError:\n        import sys, termios\n        termios.tcflush(sys.stdin, termios.TCIOFLUSH)\n"}
{"id": 333611, "name": "Fractal tree", "source": "Translate Perl to Python: use GD::Simple;\n\nmy ($width, $height) = (1000,1000); \nmy $scale = 6/10; \nmy $length = 400; \n\nmy $img = GD::Simple->new($width,$height);\n$img->fgcolor('black');\n$img->penSize(1,1);\n\ntree($width/2, $height, $length, 270);\n\nprint $img->png;\n\n\nsub tree\n{\n        my ($x, $y, $len, $angle) = @_;\n\n        return if $len < 1;\n\n        $img->moveTo($x,$y);\n        $img->angle($angle);\n        $img->line($len);\n\n        ($x, $y) = $img->curPos();\n\n        tree($x, $y, $len*$scale, $angle+35);\n        tree($x, $y, $len*$scale, $angle-35);\n}\n", "target": "def setup():\n    size(600, 600)\n    background(0)\n    stroke(255)\n    drawTree(300, 550, 9)\n    \ndef drawTree(x, y, depth):\n    fork_ang = radians(20)\n    base_len = 10\n    if depth > 0:\n        pushMatrix()\n        translate(x, y - baseLen * depth)\n        line(0, baseLen * depth, 0, 0)  \n        rotate(fork_ang)\n        drawTree(0, 0, depth - 1)  \n        rotate(2 * -fork_ang)\n        drawTree(0, 0, depth - 1) \n        popMatrix()\n"}
{"id": 333612, "name": "Rock-paper-scissors", "source": "Translate Perl to Python: use 5.012;\nuse warnings;\nuse utf8;\nuse open qw(:encoding(utf-8) :std);\nuse Getopt::Long;\n\npackage Game {\n    use List::Util qw(shuffle first);\n\n    my $turns        = 0;\n    my %human_choice = ( rock => 0, paper => 0, scissors => 0, );\n    my %comp_choice  = ( rock => 0, paper => 0, scissors => 0, );\n    my %what_beats =\n      ( rock => 'paper', paper => 'scissors', scissors => 'rock', );\n    my $comp_wins  = 0;\n    my $human_wins = 0;\n    my $draws      = 0;\n\n    sub save_human_choice {\n        my $ch = lc pop;\n        if ( exists $human_choice{ $ch } ) {\n            ++$human_choice{ $ch };\n        }\n        else {\n            die __PACKAGE__ . \":: wrong choice: '$ch'\";\n        }\n    }\n\n    sub get_comp_choice {\n        my @keys = shuffle keys %human_choice;\n        my $ch;\n        my ( $prob, $rand ) = ( 0, rand );\n        $ch = ( first { $rand <= ( $prob += ( $human_choice{ $_ } / $turns ) ) } @keys )\n            if $turns > 0;\n        $ch //= $keys[0];\n        $ch = $what_beats{ $ch };\n        ++$comp_choice{ $ch };\n        return $ch;\n    }\n\n    sub make_turn {\n        my ( $comp_ch, $human_ch ) = ( pop(), pop() );\n        ++$turns;\n        if ( $what_beats{ $human_ch } eq $comp_ch ) {\n            ++$comp_wins;\n            return 'I win!';\n        }\n        elsif ( $what_beats{ $comp_ch } eq $human_ch ) {\n            ++$human_wins;\n            return 'You win!';\n        }\n        else {\n            ++$draws;\n            return 'Draw!';\n        }\n    }\n\n    sub get_final_report {\n        my $report =\n            \"You chose:\\n\"\n          . \"  rock     = $human_choice{rock} times,\\n\"\n          . \"  paper    = $human_choice{paper} times,\\n\"\n          . \"  scissors = $human_choice{scissors} times,\\n\"\n          . \"I chose:\\n\"\n          . \"  rock     = $comp_choice{rock} times,\\n\"\n          . \"  paper    = $comp_choice{paper} times,\\n\"\n          . \"  scissors = $comp_choice{scissors} times,\\n\"\n          . \"Turns: $turns\\n\"\n          . \"I won: $comp_wins, you won: $human_wins, draws: $draws\\n\";\n        return $report;\n    }\n}\n\nsub main {\n    GetOptions( 'quiet' => \\my $quiet );\n    greet() if !$quiet;\n    while (1) {\n        print_next_line() if !$quiet;\n        my $input = get_input();\n        last unless $input;\n        if ( $input eq 'error' ) {\n            print \"I don't understand!\\n\" if !$quiet;\n            redo;\n        }\n        my $comp_choice = Game::get_comp_choice();\n        Game::save_human_choice($input);\n        my $result = Game::make_turn( $input, $comp_choice );\n        describe_turn_result( $input, $comp_choice, $result )\n          if !$quiet;\n    }\n    print Game::get_final_report();\n}\n\nsub greet {\n    print \"Welcome to the Rock-Paper-Scissors game!\\n\"\n      . \"Choose 'rock', 'paper' or 'scissors'\\n\"\n      . \"Enter empty line or 'quit' to quit\\n\";\n}\n\nsub print_next_line {\n    print 'Your choice: ';\n}\n\nsub get_input {\n    my $input = <>;\n    print \"\\n\" and return if !$input;    \n    chomp $input;\n    return if !$input or $input =~ m/\\A \\s* q/xi;\n    return \n        ( $input =~ m/\\A \\s* r/xi ) ? 'rock'\n      : ( $input =~ m/\\A \\s* p/xi ) ? 'paper'\n      : ( $input =~ m/\\A \\s* s/xi ) ? 'scissors'\n      :                               'error';\n}\n\nsub describe_turn_result {\n    my ( $human_ch, $comp_ch, $result ) = @_;\n    print \"You chose \\u$human_ch, I chose \\u$comp_ch. $result\\n\";\n}\n\nmain();\n", "target": "from random import choice\n\nrules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}\nprevious = ['rock', 'paper', 'scissors']\n\nwhile True:\n    human = input('\\nchoose your weapon: ')\n    computer = rules[choice(previous)]  \n\n    if human in ('quit', 'exit'): break\n\n    elif human in rules:\n        previous.append(human)\n        print('the computer played', computer, end='; ')\n\n        if rules[computer] == human:  \n            print('yay you win!')\n        elif rules[human] == computer:  \n            print('the computer beat you...\u00a0:(')\n        else: print(\"it's a tie!\")\n\n    else: print(\"that's not a valid choice\")\n"}
{"id": 333613, "name": "Benford's law", "source": "Translate Perl to Python: \nuse strict ;\nuse warnings ;\nuse POSIX qw( log10 ) ;\n\nmy @fibonacci = ( 0 , 1  ) ;\nwhile ( @fibonacci != 1000 ) {\n   push @fibonacci , $fibonacci[ -1 ] + $fibonacci[ -2 ] ;\n}\nmy @actuals ;\nmy @expected ;\nfor my $i( 1..9 ) {\n   my $sum = 0 ;\n   map { $sum++ if $_ =~ /\\A$i/ } @fibonacci ;\n   push @actuals , $sum / 1000  ;\n   push @expected , log10( 1 + 1/$i ) ;\n}\nprint \"         Observed         Expected\\n\" ;\nfor my $i( 1..9 ) {\n   print \"$i\u00a0: \" ;\n   my $result = sprintf ( \"%.2f\" , 100 * $actuals[ $i - 1 ] ) ;\n   printf \"%11s\u00a0%%\" , $result ;\n   $result = sprintf ( \"%.2f\" , 100 * $expected[ $i - 1 ] ) ;\n   printf \"%15s\u00a0%%\\n\" , $result ;\n}\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 333614, "name": "Benford's law", "source": "Translate Perl to Python: \nuse strict ;\nuse warnings ;\nuse POSIX qw( log10 ) ;\n\nmy @fibonacci = ( 0 , 1  ) ;\nwhile ( @fibonacci != 1000 ) {\n   push @fibonacci , $fibonacci[ -1 ] + $fibonacci[ -2 ] ;\n}\nmy @actuals ;\nmy @expected ;\nfor my $i( 1..9 ) {\n   my $sum = 0 ;\n   map { $sum++ if $_ =~ /\\A$i/ } @fibonacci ;\n   push @actuals , $sum / 1000  ;\n   push @expected , log10( 1 + 1/$i ) ;\n}\nprint \"         Observed         Expected\\n\" ;\nfor my $i( 1..9 ) {\n   print \"$i\u00a0: \" ;\n   my $result = sprintf ( \"%.2f\" , 100 * $actuals[ $i - 1 ] ) ;\n   printf \"%11s\u00a0%%\" , $result ;\n   $result = sprintf ( \"%.2f\" , 100 * $expected[ $i - 1 ] ) ;\n   printf \"%15s\u00a0%%\\n\" , $result ;\n}\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 333615, "name": "Hickerson series of almost integers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::BigFloat;\n\nmy $iln2 = 1 / Math::BigFloat->new(2)->blog;\nmy $h = $iln2 / 2;\n\nfor my $n ( 1 .. 17 ) {\n\t$h *= $iln2;\n\t$h *= $n;\n\tmy $s = $h->copy->bfround(-3)->bstr;\n\tprintf \"h(%2d) = %22s is%s almost an integer.\\n\",\n\t\t$n, $s, ($s =~ /\\.[09]/ ? \"\" : \" NOT\");\n}\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 333616, "name": "Hickerson series of almost integers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::BigFloat;\n\nmy $iln2 = 1 / Math::BigFloat->new(2)->blog;\nmy $h = $iln2 / 2;\n\nfor my $n ( 1 .. 17 ) {\n\t$h *= $iln2;\n\t$h *= $n;\n\tmy $s = $h->copy->bfround(-3)->bstr;\n\tprintf \"h(%2d) = %22s is%s almost an integer.\\n\",\n\t\t$n, $s, ($s =~ /\\.[09]/ ? \"\" : \" NOT\");\n}\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 333617, "name": "Read a configuration file", "source": "Translate Perl to Python: my $fullname;\nmy $favouritefruit;\nmy $needspeeling;\nmy $seedsremoved;\nmy @otherfamily;\n\n\nmy $conf_definition = {\n    'fullname'          => [ 'string', \\$fullname ],\n    'favouritefruit'    => [ 'string', \\$favouritefruit ],\n    'needspeeling'      => [ 'boolean', \\$needspeeling ],\n    'seedsremoved'      => [ 'boolean', \\$seedsremoved ],\n    'otherfamily'       => [ 'array', \\@otherfamily ],\n};\n\nmy $arg = shift;               \n                               \nmy $file;                      \nopen $file, $arg or die \"Can't open configuration file '$arg': $!\";\n\nread_conf_file($file, $conf_definition); \n\nprint \"fullname = $fullname\\n\";\nprint \"favouritefruit = $favouritefruit\\n\";\nprint \"needspeeling = \", ($needspeeling ? 'true' : 'false'), \"\\n\";\nprint \"seedsremoved = \", ($seedsremoved ? 'true' : 'false'), \"\\n\";\nfor (my $i = 0; $i < @otherfamily; ++$i) {\n    print \"otherfamily(\", $i + 1, \") = \", $otherfamily[$i], \"\\n\";\n}\n\n\n\n\n\n\n\n\n\nsub read_conf_file {\n    my ($fh, $def) = @_;        \n\n    local $_;                   \n    while (<$fh>) {             \n        next if /^\n        next if /^;/;           \n        next if /^$/;           \n        chomp;                  \n\n        $_ =~ /^\\s*(\\w+)\\s*(.*)$/i or die \"Syntax error\";\n        my $key = $1;\n        my $rest = $2;\n        $key =~ tr/[A-Z]/[a-z]/; \n\n        if (!exists $def->{$key}) {\n            die \"Unknown keyword: '$key'\";\n        }\n\n        if ($def->{$key}[0] eq 'boolean') {\n            if ($rest) {\n                die \"Syntax error:  extra data following boolean '$key'\";\n            }\n            ${$def->{$key}[1]} = 1;\n            next;                \n        }\n\n        $rest =~ s/\\s*$//;       \n        $rest =~ s/^=\\s*//;      \n\n        if ($def->{$key}[0] eq 'string') {\n            ${$def->{$key}[1]} = $rest;\n        } elsif ($def->{$key}[0] eq 'array') {\n            @{$def->{$key}[1]} = split /\\s*,\\s*/, $rest;\n        } else {\n            die \"Internal error (unknown type in configuration definition)\";\n        }\n    }\n}\n", "target": "def readconf(fn):\n    ret = {}\n    with file(fn) as fp:\n        for line in fp:\n            \n            line = line.strip()\n            if not line or line.startswith('\n            \n            boolval = True\n            \n            if line.startswith(';'):\n                \n                line = line.lstrip(';')\n                \n                if len(line.split()) != 1: continue\n                boolval = False\n            \n            bits = line.split(None, 1)\n            if len(bits) == 1:\n                \n                k = bits[0]\n                v = boolval\n            else:\n                \n                k, v = bits\n            ret[k.lower()] = v\n    return ret\n\n\nif __name__ == '__main__':\n    import sys\n    conf = readconf(sys.argv[1])\n    for k, v in sorted(conf.items()):\n        print k, '=', v\n"}
{"id": 333618, "name": "Kronecker product based fractals", "source": "Translate Perl to Python: use Imager;\nuse Math::Cartesian::Product;\n\nsub kronecker_product {\n    our @a; local *a = shift;\n    our @b; local *b = shift;\n    my @c;\n    cartesian {\n        my @cc;\n        cartesian {\n            push @cc, $_[0] * $_[1];\n        } [@{$_[0]}], [@{$_[1]}];\n        push @c, [@cc];\n    } [@a], [@b];\n    @c\n}\n\nsub kronecker_fractal {\n    my($order, @pattern) = @_;\n    my @kronecker = @pattern;\n    @kronecker = kronecker_product(\\@kronecker, \\@pattern) for 0..$order-1;\n    @kronecker\n}\n\n@vicsek = ( [0, 1, 0], [1, 1, 1], [0, 1, 0] );\n@carpet = ( [1, 1, 1], [1, 0, 1], [1, 1, 1] );\n@six    = ( [0,1,1,1,0], [1,0,0,0,1], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,1], [1,0,0,0,1], [0,1,1,1,0] );\n\nfor (['vicsek', \\@vicsek, 4],\n     ['carpet', \\@carpet, 4],\n     ['six',    \\@six,    3]) {\n    ($name, $shape, $order) = @$_;\n    @img = kronecker_fractal( $order, @$shape );\n    $png = Imager->new(xsize => 1+@{$img[0]}, ysize => 1+@img);\n    cartesian {\n        $png->setpixel(x => $_[0], y => $_[1], color => $img[$_[1]][$_[0]] ? [255, 255, 32] : [16, 16, 16]);\n    } [0..@{$img[0]}-1], [0..$\n    $png->write(file => \"run/kronecker-$name-perl6.png\");\n}\n", "target": "import os\nfrom PIL import Image\n\n\ndef imgsave(path, arr):\n    w, h = len(arr), len(arr[0])\n    img = Image.new('1', (w, h))\n    for x in range(w):\n        for y in range(h):\n            img.putpixel((x, y), arr[x][y])\n    img.save(path)\n\n\ndef get_shape(mat):\n    return len(mat), len(mat[0])\n\n\ndef kron(matrix1, matrix2):\n    \n    final_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        for i in range(count):\n            sub_list = []\n            for num1 in elem1:\n                for num2 in matrix2[i]:\n                    sub_list.append(num1 * num2)\n            final_list.append(sub_list)\n\n    return final_list\n\n\ndef kronpow(mat):\n    \n    matrix = mat\n    while True:\n        yield matrix\n        matrix = kron(mat, matrix)\n\n\ndef fractal(name, mat, order=6):\n    \n    path = os.path.join('fractals', name)\n    os.makedirs(path, exist_ok=True)\n\n    fgen = kronpow(mat)\n    print(name)\n    for i in range(order):\n        p = os.path.join(path, f'{i}.jpg')\n        print('Calculating n =', i, end='\\t', flush=True)\n\n        mat = next(fgen)\n        imgsave(p, mat)\n\n        x, y = get_shape(mat)\n        print('Saved as', x, 'x', y, 'image', p)\n\n\ntest1 = [\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 1, 0]\n]\n\ntest2 = [\n    [1, 1, 1],\n    [1, 0, 1],\n    [1, 1, 1]\n]\n\ntest3 = [\n    [1, 0, 1],\n    [0, 1, 0],\n    [1, 0, 1]\n]\n\nfractal('test1', test1)\nfractal('test2', test2)\nfractal('test3', test3)\n"}
{"id": 333619, "name": "Additive primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'is_prime';\nuse List::Util <sum max>;\n\nsub pp {\n    my $format = ('%' . (my $cw = 1+length max @_) . 'd') x @_;\n    my $width  = \".{@{[$cw * int 60/$cw]}}\";\n    (sprintf($format, @_)) =~ s/($width)/$1\\n/gr;\n}\n\nmy($limit, @ap) = 500;\nis_prime($_) and is_prime(sum(split '',$_)) and push @ap, $_ for 1..$limit;\n\nprint @ap . \" additive primes < $limit:\\n\" . pp(@ap);\n", "target": "def is_prime(n: int) -> bool:\n    if n <= 3:\n        return n > 1\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i ** 2 <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef digit_sum(n: int) -> int:\n    sum = 0\n    while n > 0:\n        sum += n % 10\n        n //= 10\n    return sum\n\ndef main() -> None:\n    additive_primes = 0\n    for i in range(2, 500):\n        if is_prime(i) and is_prime(digit_sum(i)):\n            additive_primes += 1\n            print(i, end=\" \")\n    print(f\"\\nFound {additive_primes} additive primes less than 500\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"id": 333620, "name": "Case-sensitivity of identifiers", "source": "Translate Perl to Python: \n$dog='Benjamin';\n$Dog='Samba';\n$DOG='Bernie';\nprint \"The three dogs are named $dog, $Dog, and $DOG \\n\"\n", "target": ">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'\n>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)\nThe three dogs are named  Benjamin ,  Samba , and  Bernie\n>>>\n"}
{"id": 333621, "name": "Extra primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(is_prime vecsum todigits forprimes);\n\nmy $str;\nforprimes {\n    is_prime(vecsum(todigits($_))) and /^[2357]+$/ and $str .= sprintf '%-5d', $_;\n} 1e4;\nsay $str =~ s/.{1,80}\\K /\\n/gr;\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 333622, "name": "Extra primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(is_prime vecsum todigits forprimes);\n\nmy $str;\nforprimes {\n    is_prime(vecsum(todigits($_))) and /^[2357]+$/ and $str .= sprintf '%-5d', $_;\n} 1e4;\nsay $str =~ s/.{1,80}\\K /\\n/gr;\n", "target": "from itertools import *\nfrom functools import reduce\n\nclass Sieve(object):\n    \n    def __init__(self):\n        self._primes = []\n        self._comps = {}\n        self._max = 2;\n    \n    def isprime(self, n):\n        \n        if n >= self._max: self._genprimes(n)\n        return n >= 2 and n in self._primes\n    \n    def _genprimes(self, max):\n        while self._max <= max:\n            if self._max not in self._comps:\n                self._primes.append(self._max)\n                self._comps[self._max*self._max] = [self._max]\n            else:\n                for p in self._comps[self._max]:\n                    ps = self._comps.setdefault(self._max+p, [])\n                    ps.append(p)\n                del self._comps[self._max]\n            self._max += 1\n                \ndef extra_primes():\n    \n    d = [2,3,5,7]\n    s = Sieve()\n    for cand in chain.from_iterable(product(d, repeat=r) for r in count(1)):\n        num = reduce(lambda x, y: x*10+y, cand)\n        if s.isprime(num) and s.isprime(sum(cand)): yield num\n        \nfor n in takewhile(lambda n: n < 10000, extra_primes()):\n    print(n)\n"}
{"id": 333623, "name": "Abbreviations, easy", "source": "Translate Perl to Python: @c = (join ' ', qw<\nAdd ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\nCOUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\nNFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\nJoin SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\nMErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\nREAD  RECover REFRESH RENum Replace REPeat  CReplace  RESet  RESTore  RGTLEFT\nRIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n>) =~ /([A-Z]+)([a-z]*)(?:\\s+|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor ($i = 0; $i < @c; $i += 2) {\n    $sl = length($s =    $c[$i]  );\n    $ll = length($l = uc $c[$i+1]);\n    $abr{$s} = $w = $s.$l;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n    $abr{$w} = $w; \n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\"\n", "target": "command_table_text = \\\n\n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    for word in command_table_text.split():\n        abbr_len = sum(1 for c in word if c.isupper())\n        if abbr_len == 0:\n            abbr_len = len(word)\n        command_table[word] = abbr_len\n    return command_table\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 333624, "name": "Abbreviations, easy", "source": "Translate Perl to Python: @c = (join ' ', qw<\nAdd ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\nCOUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\nNFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\nJoin SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\nMErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\nREAD  RECover REFRESH RENum Replace REPeat  CReplace  RESet  RESTore  RGTLEFT\nRIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n>) =~ /([A-Z]+)([a-z]*)(?:\\s+|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor ($i = 0; $i < @c; $i += 2) {\n    $sl = length($s =    $c[$i]  );\n    $ll = length($l = uc $c[$i+1]);\n    $abr{$s} = $w = $s.$l;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n    $abr{$w} = $w; \n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\"\n", "target": "command_table_text = \\\n\n\nuser_words = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\"\n\ndef find_abbreviations_length(command_table_text):\n    \n    command_table = dict()\n    for word in command_table_text.split():\n        abbr_len = sum(1 for c in word if c.isupper())\n        if abbr_len == 0:\n            abbr_len = len(word)\n        command_table[word] = abbr_len\n    return command_table\n\ndef find_abbreviations(command_table):\n    \n    abbreviations = dict()\n    for command, min_abbr_len in command_table.items():\n        for l in range(min_abbr_len, len(command)+1):\n            abbr = command[:l].lower()\n            abbreviations[abbr] = command.upper()\n    return abbreviations\n\ndef parse_user_string(user_string, abbreviations):\n    user_words = [word.lower() for word in user_string.split()]\n    commands = [abbreviations.get(user_word, \"*error*\") for user_word in user_words]\n    return \" \".join(commands)\n\ncommand_table = find_abbreviations_length(command_table_text)\nabbreviations_table = find_abbreviations(command_table)\n\nfull_words = parse_user_string(user_words, abbreviations_table)\n\nprint(\"user words:\", user_words)\nprint(\"full words:\", full_words)\n"}
{"id": 333625, "name": "Common sorted list", "source": "Translate Perl to Python: @c{@$_}++ for [5,1,3,8,9,4,8,7], [3,5,9,8,4], [1,3,7,9];\nprint join ' ', sort keys %c;\n@c{@$_}++ for [qw<not all is integer\u00a0? is not\u00a0! 4.2>];\nprint join ' ', sort keys %c;\n", "target": "\n\nfrom itertools import chain\n\n\n\n\ndef main():\n    \n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n\n\n\n\ndef concat(xs):\n    \n    return list(chain(*xs))\n\n\n\ndef nub(xs):\n    \n    return list(dict.fromkeys(xs))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333626, "name": "Common sorted list", "source": "Translate Perl to Python: @c{@$_}++ for [5,1,3,8,9,4,8,7], [3,5,9,8,4], [1,3,7,9];\nprint join ' ', sort keys %c;\n@c{@$_}++ for [qw<not all is integer\u00a0? is not\u00a0! 4.2>];\nprint join ' ', sort keys %c;\n", "target": "\n\nfrom itertools import chain\n\n\n\n\ndef main():\n    \n\n    print(\n        sorted(nub(concat([\n            [5, 1, 3, 8, 9, 4, 8, 7],\n            [3, 5, 9, 8, 4],\n            [1, 3, 7, 9]\n        ])))\n    )\n\n\n\n\n\n\ndef concat(xs):\n    \n    return list(chain(*xs))\n\n\n\ndef nub(xs):\n    \n    return list(dict.fromkeys(xs))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333627, "name": "Sorting algorithms_Stooge sort", "source": "Translate Perl to Python: sub stooge {\n        use integer;\n        my ($x, $i, $j) = @_;\n\n        $i //= 0;\n        $j //= $\n\n        if ( $x->[$j] < $x->[$i] ) {\n                @$x[$i, $j] = @$x[$j, $i];\n        }\n        if ( $j - $i > 1 ) {\n                my $t = ($j - $i + 1) / 3;\n                stooge( $x, $i,      $j - $t );\n                stooge( $x, $i + $t, $j      ); \n                stooge( $x, $i,      $j - $t );\n        }\n}\n\n\nmy @a = map (int rand(100), 1 .. 10);\nprint \"Before @a\\n\";\nstooge(\\@a);\nprint \"After  @a\\n\";\n", "target": ">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]\n>>> def stoogesort(L, i=0, j=None):\n\tif j is None:\n\t\tj = len(L) - 1\n\tif L[j] < L[i]:\n\t\tL[i], L[j] = L[j], L[i]\n\tif j - i > 1:\n\t\tt = (j - i + 1) // 3\n\t\tstoogesort(L, i  , j-t)\n\t\tstoogesort(L, i+t, j  )\n\t\tstoogesort(L, i  , j-t)\n\treturn L\n\n>>> stoogesort(data)\n[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]\n"}
{"id": 333628, "name": "Truncate a file", "source": "Translate Perl to Python: \nopen FOO, \">>file\" or die;\ntruncate(FOO, 1234);\nclose FOO;\n\n\ntruncate(\"file\", 567);\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 333629, "name": "Truncate a file", "source": "Translate Perl to Python: \nopen FOO, \">>file\" or die;\ntruncate(FOO, 1234);\nclose FOO;\n\n\ntruncate(\"file\", 567);\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 333630, "name": "Sorting algorithms_Shell sort", "source": "Translate Perl to Python: sub shell_sort {\n    my (@a, $h, $i, $j, $k) = @_;\n    for ($h = @a; $h = int $h / 2;) {\n        for $i ($h .. $\n            $k = $a[$i];\n            for ($j = $i; $j >= $h && $k < $a[$j - $h]; $j -= $h) {\n                $a[$j] = $a[$j - $h];\n            }\n            $a[$j] = $k;\n        }\n    }\n    @a;\n}\n\nmy @a = map int rand 100, 1 .. $ARGV[0] || 10;\nsay \"@a\";\n@a = shell_sort @a;\nsay \"@a\";\n", "target": "def shell(seq):\n    inc = len(seq) // 2\n    while inc:\n        for i, el in enumerate(seq[inc:], inc):\n            while i >= inc and seq[i - inc] > el:\n                seq[i] = seq[i - inc]\n                i -= inc\n            seq[i] = el\n        inc = 1 if inc == 2 else inc * 5 // 11\n"}
{"id": 333631, "name": "Formal power series", "source": "Translate Perl to Python: package FPS;\nuse strict;\nuse warnings;\nuse Math::BigRat;\n\nsub new {\n   my $class = shift;\n   return bless {@_}, $class unless @_ == 1;\n   my $arg = shift;\n   return bless { more => $arg }, $class if 'CODE' eq ref $arg;\n   return bless { coeff => $arg }, $class if 'ARRAY' eq ref $arg;\n   bless { coeff => [$arg] }, $class;\n}\n\nsub coeff {\n   my ($self, $i) = @_;\n   my $cache = ($self->{coeff} ||= []);\n   my $more = $self->{more};\n   for my $j ( @$cache .. $i ) {\n      last unless $more;\n      $cache->[$j] = $more->($j, $self);\n   }\n   $cache->[$i] or 0;\n}\n\nsub invert {\n   my $orig = shift;\n   ref($orig)->new( sub {\n      my ($i, $self) = @_;\n      unless( $i ) {\n         my $a0 = $orig->coeff(0);\n         die \"Cannot invert power series with zero constant term.\"\n            unless $a0;\n         (Math::BigRat->new(1) / $a0);\n      } else {\n         my $sum = 0;\n         my $terms = $self->{coeff};\n         for my $j (1 .. $i) {\n            $sum += $orig->coeff($j) * $terms->[$i - $j];\n         }\n         -$terms->[0] * $sum;\n      }\n   } );\n}\n\nsub fixargs {\n   my ($x, $y, $swap) = @_;\n   my $class = ref $x;\n   $y = $class->new($y) unless UNIVERSAL::isa($y, $class);\n   ($x, $y) = ($y, $x) if $swap;\n   ($class, $x, $y);\n}\n\nuse overload '+' => sub {\n   my ($class, $x, $y) = &fixargs;\n   $class->new( sub { $x->coeff($_[0]) + $y->coeff($_[0]) } );\n}, '-' => sub {\n   my ($class, $x, $y) = &fixargs;\n   $class->new( sub { $x->coeff($_[0]) - $y->coeff($_[0]) } );\n}, '*' => sub {\n   my ($class, $x, $y) = &fixargs;\n   $class->new( sub {\n      my $i = shift;\n      my $sum = 0;\n      $sum += $x->coeff($_) * $y->coeff($i-$_) for 0..$i;\n      $sum;\n   } );\n}, '/' => sub {\n   my ($class, $x, $y) = &fixargs;\n   $x * $y->invert;\n}, '\"\"' => sub {\n   my $self = shift;\n   my $str = $self->coeff(0);\n   for my $i (1..10) {\n      my $c = $self->coeff($i);\n      next unless $c;\n      $str .= ($c < 0) ? (\" - \" . (-$c)) : (\" + \".$c);\n      $str .= \"x^$i\";\n   }\n   $str;\n};\n\nsub differentiate {\n   my $orig = shift;\n   ref($orig)->new( sub {\n      my $i = shift;\n      ($i+1) * $orig->coeff($i);\n   } );\n}\n\nsub integrate {\n   my $orig = shift;\n   ref($orig)->new( coeff => [0], more => sub {\n      my $i = shift;\n      $orig->coeff($i-1) / Math::BigRat->new($i);\n   } );\n}\n\nmy $sin = __PACKAGE__->new;\nmy $cos = 1 - $sin->integrate;\n%$sin = %{$cos->integrate};\nmy $tan = $sin / $cos;\nmy $exp = __PACKAGE__->new();\n%$exp = (%{$exp->integrate}, coeff => [1]);\n\nprint \"sin(x) ~= $sin\\n\";\nprint \"cos(x) ~= $cos\\n\";\nprint \"tan(x) ~= $tan\\n\";\nprint \"exp(x) ~= $exp\\n\";\n\nprint \"sin^2 + cos^2 = \", $sin*$sin + $cos*$cos, \"\\n\";\n\n1;\n", "target": "\n\nfrom itertools import islice\nfrom fractions import Fraction\nfrom functools import reduce\ntry:\n    from itertools import izip as zip \nexcept:\n    pass\n\ndef head(n):\n    \n    return lambda seq: islice(seq, n)\n\ndef pipe(gen, *cmds):\n    \n    return reduce(lambda gen, cmd: cmd(gen), cmds, gen)\n\ndef sinepower():\n    n = 0\n    fac = 1\n    sign = +1\n    zero = 0\n    yield zero\n    while True:\n        n +=1\n        fac *= n\n        yield Fraction(1, fac*sign)\n        sign = -sign\n        n +=1\n        fac *= n\n        yield zero\ndef cosinepower():\n    n = 0\n    fac = 1\n    sign = +1\n    yield Fraction(1,fac)\n    zero = 0\n    while True:\n        n +=1\n        fac *= n\n        yield zero\n        sign = -sign\n        n +=1\n        fac *= n\n        yield Fraction(1, fac*sign)\ndef pluspower(*powergenerators):\n    for elements in zip(*powergenerators):\n        yield sum(elements)\ndef minuspower(*powergenerators):\n    for elements in zip(*powergenerators):\n        yield elements[0] - sum(elements[1:])\ndef mulpower(fgen,ggen):\n    'From: http://en.wikipedia.org/wiki/Power_series\n    a,b = [],[]\n    for f,g in zip(fgen, ggen):\n        a.append(f)\n        b.append(g)\n        yield sum(f*g for f,g in zip(a, reversed(b)))\ndef constpower(n):\n    yield n\n    while True:\n        yield 0\ndef diffpower(gen):\n    'differentiatiate power series'\n    next(gen)\n    for n, an in enumerate(gen, start=1):\n        yield an*n\ndef intgpower(k=0):\n    'integrate power series with constant k'\n    def _intgpower(gen):\n        yield k\n        for n, an in enumerate(gen, start=1):\n            yield an * Fraction(1,n)\n    return _intgpower\n\n\nprint(\"cosine\")\nc = list(pipe(cosinepower(), head(10)))\nprint(c)\nprint(\"sine\")\ns = list(pipe(sinepower(), head(10)))\nprint(s)\n\nintegc = list(pipe(cosinepower(),intgpower(0), head(10)))\n\nintegs1 = list(minuspower(pipe(constpower(1), head(10)),\n                          pipe(sinepower(),intgpower(0), head(10))))\n\nassert s == integc, \"The integral of cos should be sin\"\nassert c == integs1, \"1 minus the integral of sin should be cos\"\n"}
{"id": 333632, "name": "Deconvolution_1D", "source": "Translate Perl to Python: use v5.36;\nuse Math::Cartesian::Product;\n\nsub deconvolve($g,$f) {\n    my @g = @{$g};\n    my @f = @{$f};\n    my(@m,@d);\n\n    my $h = 1 + @g - @f;\n    push @m, [(0) x $h, $g[$_]] for 0..$\n    for my $j (0..$h-1) {\n        for my $k (0..$\n            $m[$j + $k][$j] = $f[$k]\n        }\n    }\n    rref(\\@m);\n    push @d, @{ $m[$_] }[$h] for 0..$h-1;\n    @d;\n}\n\nsub convolve($f,$h) {\n    my @f = @{$f};\n    my @h = @{$h};\n    my @i;\n    for my $x (cartesian {@_} [0..$\n        push @i, @$x[0]+@$x[1];\n    }\n    my $cnt = 0;\n    my @g = (0) x (@f + @h - 1);\n    for my $x (cartesian {@_} [@f], [@h]) {\n        $g[$i[$cnt++]] += @$x[0]*@$x[1];\n    }\n    @g;\n}\n\nsub rref($m) {\n  my @m = @{$m};\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  for my $r (0 .. $rows - 1) {\n      $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead]) {\n          ++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;\n      }\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      for my $i (0 .. $rows - 1) {\n          $i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };\n      }\n      ++$lead;\n   }\n}\n\nmy @h = qw<-8 -9 -3 -1 -6 7>;\nmy @f = qw<-3 -6 -1 8 -6 3 -1 -9 -9 3 -2 5 2 -2 -7 -1>;\nprint '  conv(f,h) = g = ' . join(' ', my @g = convolve(\\@f, \\@h)) . \"\\n\";\nprint 'deconv(g,f) = h = ' . join(' ', deconvolve(\\@g, \\@f)) . \"\\n\";\nprint 'deconv(g,h) = f = ' . join(' ', deconvolve(\\@g, \\@h)) . \"\\n\";\n", "target": "def ToReducedRowEchelonForm( M ):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / lv for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n    return M\n \ndef pmtx(mtx):\n    print ('\\n'.join(''.join(' %4s' % col for col in row) for row in mtx))\n \ndef convolve(f, h):\n    g = [0] * (len(f) + len(h) - 1)\n    for hindex, hval in enumerate(h):\n        for findex, fval in enumerate(f):\n            g[hindex + findex] += fval * hval\n    return g\n\ndef deconvolve(g, f):\n    lenh = len(g) - len(f) + 1\n    mtx = [[0 for x in range(lenh+1)] for y in g]\n    for hindex in range(lenh):\n        for findex, fval in enumerate(f):\n            gindex = hindex + findex\n            mtx[gindex][hindex] = fval\n    for gindex, gval in enumerate(g):        \n        mtx[gindex][lenh] = gval\n    ToReducedRowEchelonForm( mtx )\n    return [mtx[i][lenh] for i in range(lenh)]  \n\nif __name__ == '__main__':\n    h = [-8,-9,-3,-1,-6,7]\n    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\n    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\n    assert convolve(f,h) == g\n    assert deconvolve(g, f) == h\n"}
{"id": 333633, "name": "Read a specific line from a file", "source": "Translate Perl to Python: \n\nwhile (<>) { $. == $n and print, exit }\ndie \"file too short\\n\";\n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 333634, "name": "Read a specific line from a file", "source": "Translate Perl to Python: \n\nwhile (<>) { $. == $n and print, exit }\ndie \"file too short\\n\";\n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 333635, "name": "Digit fifth powers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\n\nfor my $power (3..6) {\n    my @matches;\n    for my $n (2 .. 9**$power * $power) {\n        push @matches, $n if $n == sum map { $_**$power } split '', $n;\n    }\n    say \"\\nSum of powers of n**$power: \" . join(' + ', @matches) . ' = ' . sum @matches;\n}\n", "target": "from time import time\n\n\nst = time()\nprint(sum([n for n in range(2, 6*9**5) if sum(int(i)**5 for i in str(n)) == n]), \"  \", (time() - st) * 1000, \"ms\")\n\n\nst = time()\nnums = list(range(10))\nnu = list(range(((6 * 9**5) // 100000) + 1))\nnumbers = []\np5 = []\nfor i in nums: p5.append(i**5)\nfor i in nu:\n    im = i * 100000\n    ip = p5[i]\n    for j in nums:\n        jm = im + 10000 * j\n        jp = ip + p5[j]\n        for k in nums:\n            km = jm + 1000 * k\n            kp = jp + p5[k]\n            for l in nums:\n                lm = km + 100 * l\n                lp = kp + p5[l]\n                for m in nums:\n                    mm = lm + 10 * m\n                    mp = lp + p5[m]\n                    for n in nums:\n                        nm = mm + n\n                        np = mp + p5[n]\n                        if np == nm:\n                            if nm > 1: numbers.append(nm)\nprint(sum(numbers), \"  \", (time() - st) * 1000, \"ms\", end = \"\")\n"}
{"id": 333636, "name": "Digit fifth powers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\n\nfor my $power (3..6) {\n    my @matches;\n    for my $n (2 .. 9**$power * $power) {\n        push @matches, $n if $n == sum map { $_**$power } split '', $n;\n    }\n    say \"\\nSum of powers of n**$power: \" . join(' + ', @matches) . ' = ' . sum @matches;\n}\n", "target": "from time import time\n\n\nst = time()\nprint(sum([n for n in range(2, 6*9**5) if sum(int(i)**5 for i in str(n)) == n]), \"  \", (time() - st) * 1000, \"ms\")\n\n\nst = time()\nnums = list(range(10))\nnu = list(range(((6 * 9**5) // 100000) + 1))\nnumbers = []\np5 = []\nfor i in nums: p5.append(i**5)\nfor i in nu:\n    im = i * 100000\n    ip = p5[i]\n    for j in nums:\n        jm = im + 10000 * j\n        jp = ip + p5[j]\n        for k in nums:\n            km = jm + 1000 * k\n            kp = jp + p5[k]\n            for l in nums:\n                lm = km + 100 * l\n                lp = kp + p5[l]\n                for m in nums:\n                    mm = lm + 10 * m\n                    mp = lp + p5[m]\n                    for n in nums:\n                        nm = mm + n\n                        np = mp + p5[n]\n                        if np == nm:\n                            if nm > 1: numbers.append(nm)\nprint(sum(numbers), \"  \", (time() - st) * 1000, \"ms\", end = \"\")\n"}
{"id": 333637, "name": "Find prime n such that reversed n is also prime", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'max';\nuse ntheory 'is_prime';\n\nsub pp {\n    my $format = ('%' . (my $cw = 1+length max @_) . 'd') x @_;\n    my $width  = \".{@{[$cw * int 60/$cw]}}\";\n    (sprintf($format, @_)) =~ s/($width)/$1\\n/gr;\n}\n\nmy($limit, @rp) = 500;\nis_prime($_) and is_prime(reverse $_) and push @rp, $_ for 1..$limit;\nprint @rp . \" reversible primes < $limit:\\n\" . pp(@rp);\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isBackPrime(n):\n    if not isPrime(n):\n        return False\n    m = 0\n    while n:\n        m *= 10\n        m += n % 10\n        n //= 10\n    return isPrime(m)\n\nif __name__ == '__main__':\n    for n in range(2, 499):\n        if isBackPrime(n):\n            print(n, end=' ');\n"}
{"id": 333638, "name": "Find prime n such that reversed n is also prime", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'max';\nuse ntheory 'is_prime';\n\nsub pp {\n    my $format = ('%' . (my $cw = 1+length max @_) . 'd') x @_;\n    my $width  = \".{@{[$cw * int 60/$cw]}}\";\n    (sprintf($format, @_)) =~ s/($width)/$1\\n/gr;\n}\n\nmy($limit, @rp) = 500;\nis_prime($_) and is_prime(reverse $_) and push @rp, $_ for 1..$limit;\nprint @rp . \" reversible primes < $limit:\\n\" . pp(@rp);\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef isBackPrime(n):\n    if not isPrime(n):\n        return False\n    m = 0\n    while n:\n        m *= 10\n        m += n % 10\n        n //= 10\n    return isPrime(m)\n\nif __name__ == '__main__':\n    for n in range(2, 499):\n        if isBackPrime(n):\n            print(n, end=' ');\n"}
{"id": 333639, "name": "Inverted syntax", "source": "Translate Perl to Python: if ($guess == 6) { print \"Wow! Lucky Guess!\"; };    \nprint 'Wow! Lucky Guess!' if $guess == 6;           \nunless ($guess == 6) { print \"Sorry, your guess was wrong!\"; }   \nprint 'Huh! You Guessed Wrong!' unless $guess == 6;              \n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 333640, "name": "Inverted syntax", "source": "Translate Perl to Python: if ($guess == 6) { print \"Wow! Lucky Guess!\"; };    \nprint 'Wow! Lucky Guess!' if $guess == 6;           \nunless ($guess == 6) { print \"Sorry, your guess was wrong!\"; }   \nprint 'Huh! You Guessed Wrong!' unless $guess == 6;              \n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 333641, "name": "URL encoding", "source": "Translate Perl to Python: sub urlencode {\n    my $s = shift;\n    $s =~ s/([^-A-Za-z0-9_.!~*'() ])/sprintf(\"%%%02X\", ord($1))/eg;\n    $s =~ tr/ /+/;\n    return $s;\n}\n\nprint urlencode('http://foo bar/').\"\\n\";\n", "target": "import urllib\ns = 'http://foo/bar/'\ns = urllib.quote(s)\n"}
{"id": 333642, "name": "URL encoding", "source": "Translate Perl to Python: sub urlencode {\n    my $s = shift;\n    $s =~ s/([^-A-Za-z0-9_.!~*'() ])/sprintf(\"%%%02X\", ord($1))/eg;\n    $s =~ tr/ /+/;\n    return $s;\n}\n\nprint urlencode('http://foo bar/').\"\\n\";\n", "target": "import urllib\ns = 'http://foo/bar/'\ns = urllib.quote(s)\n"}
{"id": 333643, "name": "LU decomposition", "source": "Translate Perl to Python: use List::Util qw(sum);\n\nfor $test (\n    [[1, 3, 5],\n     [2, 4, 7],\n     [1, 1, 0]],\n\n    [[11,  9, 24,  2],\n     [ 1,  5,  2,  6],\n     [ 3, 17, 18,  1],\n     [ 2,  5,  7,  1]]\n) {\n    my($P, $AP, $L, $U) = lu(@$test);\n    say_it('A matrix', @$test);\n    say_it('P matrix',  @$P);\n    say_it('AP matrix', @$AP);\n    say_it('L matrix',  @$L);\n    say_it('U matrix',  @$U);\n\n}\n\nsub lu {\n    my (@a) = @_;\n    my $n = +@a;\n    my @P  = pivotize(@a);\n    my $AP = mmult(\\@P, \\@a);\n    my @L  = matrix_ident($n);\n    my @U  = matrix_zero($n);\n    for $i (0..$n-1) {\n        for $j (0..$n-1) {\n            if ($j >= $i) {\n                $U[$i][$j] =  $$AP[$i][$j] - sum map { $U[$_][$j] * $L[$i][$_] } 0..$i-1;\n            } else {\n                $L[$i][$j] = ($$AP[$i][$j] - sum map { $U[$_][$j] * $L[$i][$_] } 0..$j-1) / $U[$j][$j];\n            }\n        }\n    }\n    return \\@P, $AP, \\@L, \\@U;\n}\n\nsub pivotize {\n    my(@m) = @_;\n    my $size = +@m;\n    my @id = matrix_ident($size);\n    for $i (0..$size-1) {\n        my $max = $m[$i][$i];\n        my $row = $i;\n        for $j ($i .. $size-2) {\n            if ($m[$j][$i] > $max) {\n                $max = $m[$j][$i];\n                $row = $j;\n            }\n        }\n        ($id[$row],$id[$i]) = ($id[$i],$id[$row]) if $row != $i;\n    }\n    @id\n}\n\nsub matrix_zero  { my($n) = @_; map { [ (0) x $n ] } 0..$n-1 }\nsub matrix_ident { my($n) = @_; map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1 }\n\nsub mmult {\n  local *a = shift;\n  local *b = shift;\n  my @p = [];\n  my $rows = @a;\n  my $cols = @{ $b[0] };\n  my $n = @b - 1;\n  for (my $r = 0 ; $r < $rows ; ++$r) {\n      for (my $c = 0 ; $c < $cols ; ++$c) {\n          $p[$r][$c] += $a[$r][$_] * $b[$_][$c] foreach 0 .. $n;\n      }\n  }\n  return [@p];\n}\n\nsub say_it {\n    my($message, @array) = @_;\n    print \"$message\\n\";\n    $line = sprintf join(\"\\n\" => map join(\" \" => map(sprintf(\"%8.5f\", $_), @$_)), @{+\\@array}).\"\\n\";\n    $line =~ s/\\.00000/      /g;\n    $line =~ s/0000\\b/    /g;\n    print \"$line\\n\";\n}\n", "target": "from pprint import pprint\n\ndef matrixMul(A, B):\n    TB = zip(*B)\n    return [[sum(ea*eb for ea,eb in zip(a,b)) for b in TB] for a in A]\n\ndef pivotize(m):\n    \n    n = len(m)\n    ID = [[float(i == j) for i in xrange(n)] for j in xrange(n)]\n    for j in xrange(n):\n        row = max(xrange(j, n), key=lambda i: abs(m[i][j]))\n        if j != row:\n            ID[j], ID[row] = ID[row], ID[j]\n    return ID\n\ndef lu(A):\n    \n    n = len(A)\n    L = [[0.0] * n for i in xrange(n)]\n    U = [[0.0] * n for i in xrange(n)]\n    P = pivotize(A)\n    A2 = matrixMul(P, A)\n    for j in xrange(n):\n        L[j][j] = 1.0\n        for i in xrange(j+1):\n            s1 = sum(U[k][j] * L[i][k] for k in xrange(i))\n            U[i][j] = A2[i][j] - s1\n        for i in xrange(j, n):\n            s2 = sum(U[k][j] * L[i][k] for k in xrange(j))\n            L[i][j] = (A2[i][j] - s2) / U[j][j]\n    return (L, U, P)\n\na = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]\nfor part in lu(a):\n    pprint(part, width=19)\n    print\nprint\nb = [[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]]\nfor part in lu(b):\n    pprint(part)\n    print\n"}
{"id": 333644, "name": "Optional parameters", "source": "Translate Perl to Python: sub sorttable\n {my @table = @{shift()};\n  my %opt =\n     (ordering => sub {$_[0] cmp $_[1]}, column => 0, reverse => 0, @_);\n  my $col = $opt{column};\n  my $func = $opt{ordering};\n  my @result = sort\n      {$func->($a->[$col], $b->[$col])}\n      @table;\n  return ($opt{reverse} ? [reverse @result] : \\@result);}\n", "target": ">>> def printtable(data):\n    for row in data:\n        print ' '.join('%-5s' % ('\"%s\"' % cell) for cell in row)\n\n        \n>>> import operator\n>>> def sorttable(table, ordering=None, column=0, reverse=False):\n    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse)\n\n>>> data = [[\"a\", \"b\", \"c\"], [\"\", \"q\", \"z\"], [\"zap\", \"zip\", \"Zot\"]]\n>>> printtable(data)\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data) )\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=2) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>> printtable( sorttable(data, column=1) )\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=1, reverse=True) )\n\"zap\" \"zip\" \"Zot\"\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n>>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>>\n"}
{"id": 333645, "name": "Numeric error propagation", "source": "Translate Perl to Python: use v5.36;\n\npackage ErrVar;\n\n\nsub zip ($f, $x, $y) {\n    my @out;\n    $y = [(0) x @$x] unless @$y; \n    push @out, $f->($x->[$_], $y->[$_]) for 0 .. $\n    \\@out\n}\n\nuse overload\n    '\"\"'   => \\&_str,\n    '+'    => \\&_add,\n    '-'    => \\&_sub,\n    '*'    => \\&_mul,\n    '/'    => \\&_div,\n    'bool' => \\&_bool,\n    '<=>'  => \\&_ncmp,\n    'neg'  => \\&_neg,\n    'sqrt' => \\&_sqrt,\n    'log'  => \\&_log,\n    'exp'  => \\&_exp,\n    '**'   => \\&_pow,\n;\n\n\n\nsub make ($x, @v) { bless [$x, @v] }\n\n\nsub mean ($x) { ref $x && $x->isa(__PACKAGE__) ? $x->[0] : $x }\n\n\nsub vlist ($x) { ref $x && $x->isa(__PACKAGE__) ? $x->[1] : [] }\n\nsub variance ($x) {\n    return 0 unless ref($x) and $x->isa(__PACKAGE__);\n    my $s;\n    $s += $_ * $_ for @{$x->[1]};\n    $s\n}\n\nsub covariance ($x, $y) {\n    return 0 unless ref($x) && $x->isa(__PACKAGE__);\n    return 0 unless ref($y) && $y->isa(__PACKAGE__);\n    my $s;\n    zip sub ($a,$b) { $s += $a * $b }, vlist($x), vlist($y);\n    $s\n}\n\nsub sigma ($v) { sqrt variance $v }\n\n\nsub _bool ($x, $, $)  {\n    abs(mean $x) > sigma $x\n}\n\nsub _ncmp ($a, $b, $) {\n    return 0 unless my $x = $a - $b;\n    mean($x) > 0 ? 1 : -1\n}\n\nsub _neg ($x, $, $) {\n    bless [ -mean($x), [map(-$_, @{vlist $x}) ] ];\n}\n\nsub _add ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    bless [$x0 + $y0, zip sub ($a,$b) {$a + $b}, $xv, $yv]\n}\n\nsub _sub ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    bless [$x0 - $y0, zip sub ($a,$b) {$a - $b}, $xv, $yv]\n}\n\nsub _mul ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    $xv = [ map($y0 * $_, @$xv) ];\n    $yv = [ map($x0 * $_, @$yv) ];\n    bless [$x0 * $y0, zip sub ($a,$b) {$a + $b}, $xv, $yv]\n}\n\nsub _div ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    $xv = [ map($_/$y0, @$xv) ];\n    $yv = [ map($x0 * $_/$y0/$y0, @$yv) ];\n    bless [$x0 / $y0, zip sub ($a,$b) {$a + $b}, $xv, $yv]\n}\n\nsub _sqrt ($x, $, $) {\n    my ($x0, $xv) =  ( mean($x), vlist($x) );\n    $x0 = sqrt($x0);\n    $xv = [ map($_ / 2 / $x0, @$xv) ];\n    bless [$x0, $xv]\n}\n\nsub _pow ($x, $y, $) {\n    if ($x < 0) {\n        die \"Can't take pow of negative number $x\" if int($y) != $y or $y & 1;\n        $x = -$x;\n    }\n    exp($y * log $x)\n}\n\nsub _exp ($x, $, $) {\n    my ($x0, $xv) =  ( exp(mean($x)), vlist($x) );\n    bless [ $x0, [map($x0 * $_, @$xv) ] ]\n}\n\nsub _log ($x, $, $) {\n    my ($x0, $xv) =  ( mean($x), vlist($x) );\n    bless [ log($x0), [ map($_ / $x0, @$xv) ] ]\n}\n\nsub _str { sprintf '%g\u00b1%.3g', $_[0][0], sigma($_[0]) }\n\npackage main;\n\nsub e { ErrVar::make @_ };\n\n\n\nmy $x1 = e 100, [1.1, 0,   0,   0  ];\nmy $x2 = e 200, [0,   2.2, 0,   0  ];\nmy $y1 = e 50,  [0,   0,   1.2, 0  ];\nmy $y2 = e 100, [0,   0,   0,   2.3];\n\nmy $z1 = sqrt(($x1 - $x2) ** 2 + ($y1 - $y2) ** 2);\nsay \"distance: $z1\";\n\n\nmy $a = $x1 + $x2;\nmy $b = $y1 - 2 * $x2;\nsay \"covariance between $a and $b: \", $a->covariance($b);\n", "target": "from collections import namedtuple\nimport math\n \nclass I(namedtuple('Imprecise', 'value, delta')):\n    'Imprecise type: I(value=0.0, delta=0.0)' \n \n    __slots__ = () \n \n    def __new__(_cls, value=0.0, delta=0.0):\n        'Defaults to 0.0 \u00b1 delta'\n        return super().__new__(_cls, float(value), abs(float(delta)))\n \n    def reciprocal(self):\n        return I(1. / self.value, self.delta / (self.value**2)) \n \n    def __str__(self):\n        'Shorter form of Imprecise as string'\n        return 'I(%g, %g)' % self\n \n    def __neg__(self):\n        return I(-self.value, self.delta)\n \n    def __add__(self, other):\n        if type(other) == I:\n            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value + c, self.delta)\n\n    def __sub__(self, other):\n        return self + (-other)\n \n    def __radd__(self, other):\n        return I.__add__(self, other)\n \n    def __mul__(self, other):\n        if type(other) == I:\n            \n            \n            a1,b1 = self\n            a2,b2 = other\n            f = a1 * a2\n            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value * c, self.delta * c)\n \n    def __pow__(self, other):\n        if type(other) == I:\n            return NotImplemented\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        f = self.value ** c\n        return I(f, f * c * (self.delta / self.value))\n \n    def __rmul__(self, other):\n        return I.__mul__(self, other)\n \n    def __truediv__(self, other):\n        if type(other) == I:\n            return self.__mul__(other.reciprocal())\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value / c, self.delta / c)\n \n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n \n    __div__, __rdiv__ = __truediv__, __rtruediv__\n \nImprecise = I\n\ndef distance(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n \nx1 = I(100, 1.1)\nx2 = I(200, 2.2)\ny1 = I( 50, 1.2)\ny2 = I(100, 2.3)\n\np1, p2 = (x1, y1), (x2, y2)\nprint(\"Distance between points\\n  p1: %s\\n  and p2: %s\\n  = %r\" % (\n      p1, p2, distance(p1, p2)))\n"}
{"id": 333646, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Perl to Python: print \"Enter 11 numbers:\\n\";\nfor ( 1..11 ) {\n   $number = <STDIN>;\n   chomp $number;\n   push @sequence, $number;\n}\n\nfor $n (reverse @sequence) {\n   my $result = sqrt( abs($n) ) + 5 * $n**3;\n   printf \"f( %6.2f ) %s\\n\", $n, $result > 400 ? \"  too large!\" : sprintf \"= %6.2f\", $result\n}\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> def f(x): return abs(x) ** 0.5 + 5 * x**3\n\n>>> print(', '.join('%s:%s' % (x, v if v<=400 else \"TOO LARGE!\")\n\t           for x,v in ((y, f(float(y))) for y in input('\\nnumbers: ').strip().split()[:11][::-1])))\n\n11 numbers: 1 2 3 4 5 6 7 8 9 10 11\n11:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0\n>>>\n"}
{"id": 333647, "name": "Rate counter", "source": "Translate Perl to Python: use Benchmark;\n\ntimethese COUNT,{ 'Job1' => &job1, 'Job2' => &job2 };\n\nsub job1\n{\n\t...job1 code...\n}\nsub job2\n{\n\t...job2 code...\n}\n", "target": "import subprocess\nimport time\n\nclass Tlogger(object):\n    def __init__(self):\n        self.counts = 0\n        self.tottime = 0.0\n        self.laststart = 0.0\n        self.lastreport = time.time()\n\n    def logstart(self):\n        self.laststart = time.time()\n\n    def logend(self):\n        self.counts +=1\n        self.tottime += (time.time()-self.laststart)\n        if (time.time()-self.lastreport)>5.0:   \n           self.report()\n\n    def report(self):\n        if ( self.counts > 4*self.tottime):\n            print \"Subtask execution rate: %f times/second\"% (self.counts/self.tottime);\n        else:\n            print \"Average execution time: %f seconds\"%(self.tottime/self.counts);\n        self.lastreport = time.time()\n\n\ndef taskTimer( n, subproc_args ):\n    logger = Tlogger()\n\n    for x in range(n):\n        logger.logstart()\n        p = subprocess.Popen(subproc_args)\n        p.wait()\n        logger.logend()\n    logger.report()\n\n\nimport timeit\nimport sys\n\ndef main( ):\n\n    \n    s = \n    timer = timeit.Timer(s)\n    rzlts = timer.repeat(5, 5000)\n    for t in rzlts:\n        print \"Time for 5000 executions of statement = \",t\n    \n    \n    print \"\n    print \"Command:\",sys.argv[2:]\n    print \"\"\n    for k in range(3):\n       taskTimer( int(sys.argv[1]), sys.argv[2:])\n\nmain()\n"}
{"id": 333648, "name": "EKG sequence convergence", "source": "Translate Perl to Python: use List::Util qw(none sum);\n\nsub gcd { my ($u,$v) = @_; $v ? gcd($v, $u%$v) : abs($u) }\nsub shares_divisors_with { gcd( $_[0], $_[1]) > 1 }\n\nsub EKG {\n    my($n,$limit) = @_;\n    my @ekg = (1, $n);\n    while (@ekg < $limit) {\n        for my $i (2..1e18) {\n            next unless none { $_ == $i } @ekg and shares_divisors_with($ekg[-1], $i);\n            push(@ekg, $i) and last;\n        }\n    }\n    @ekg;\n}\n\nsub converge_at {\n    my($n1,$n2) = @_;\n    my $max = 100;\n    my @ekg1 = EKG($n1,$max);\n    my @ekg2 = EKG($n2,$max);\n    do { return $_+1 if $ekg1[$_] == $ekg2[$_] && sum(@ekg1[0..$_]) == sum(@ekg2[0..$_])} for 2..$max;\n    return \"(no convergence in $max terms)\";\n}\n\nprint \"EKG($_): \" . join(' ', EKG($_,10)) . \"\\n\" for 2, 5, 7, 9, 10;\nprint \"EKGs of 5 & 7 converge at term \" . converge_at(5, 7) . \"\\n\"\n", "target": "from itertools import count, islice, takewhile\nfrom math import gcd\n\ndef EKG_gen(start=2):\n    \n    c = count(start + 1)\n    last, so_far = start, list(range(2, start))\n    yield 1, []\n    yield last, []\n    while True:\n        for index, sf in enumerate(so_far):\n            if gcd(last, sf) > 1:\n                last = so_far.pop(index)\n                yield last, so_far[::]\n                break\n        else:\n            so_far.append(next(c))\n\ndef find_convergence(ekgs=(5,7)):\n    \"Returns the convergence point or zero if not found within the limit\"\n    ekg = [EKG_gen(n) for n in ekgs]\n    for e in ekg:\n        next(e)    \n    return 2 + len(list(takewhile(lambda state: not all(state[0] == s for  s in state[1:]),\n                                  zip(*ekg))))\n\nif __name__ == '__main__':\n    for start in 2, 5, 7, 9, 10:\n        print(f\"EKG({start}):\", str([n[0] for n in islice(EKG_gen(start), 10)])[1: -1])\n    print(f\"\\nEKG(5) and EKG(7) converge at term {find_convergence(ekgs=(5,7))}!\")\n"}
{"id": 333649, "name": "Dice game probabilities", "source": "Translate Perl to Python: use List::Util qw(sum0 max);\n\nsub comb {\n    my ($s, $n) = @_;\n    $n || return (1);\n    my @r = (0) x ($n - max(@$s) + 1);\n    my @c = comb($s, $n - 1);\n    foreach my $i (0 .. $\n        $c[$i] || next;\n        foreach my $k (@$s) {\n            $r[$i + $k] += $c[$i];\n        }\n    }\n    return @r;\n}\n\nsub winning {\n    my ($s1, $n1, $s2, $n2) = @_;\n\n    my @p1 = comb($s1, $n1);\n    my @p2 = comb($s2, $n2);\n\n    my ($win, $loss, $tie) = (0, 0, 0);\n\n    foreach my $i (0 .. $\n        $win  += $p1[$i] * sum0(@p2[0    .. $i - 1]);\n        $tie  += $p1[$i] * sum0(@p2[$i   .. $i    ]);\n        $loss += $p1[$i] * sum0(@p2[$i+1 .. $\n    }\n    my $total = sum0(@p1) * sum0(@p2);\n    map { $_ / $total } ($win, $tie, $loss);\n}\n\nprint '(', join(', ', winning([1 ..  4], 9, [1 .. 6], 6)), \")\\n\";\nprint '(', join(', ', winning([1 .. 10], 5, [1 .. 7], 6)), \")\\n\";\n", "target": "from itertools import product\n\ndef gen_dict(n_faces, n_dice):\n    counts = [0] * ((n_faces + 1) * n_dice)\n    for t in product(range(1, n_faces + 1), repeat=n_dice):\n        counts[sum(t)] += 1\n    return counts, n_faces ** n_dice\n\ndef beating_probability(n_sides1, n_dice1, n_sides2, n_dice2):\n    c1, p1 = gen_dict(n_sides1, n_dice1)\n    c2, p2 = gen_dict(n_sides2, n_dice2)\n    p12 = float(p1 * p2)\n\n    return sum(p[1] * q[1] / p12\n               for p, q in product(enumerate(c1), enumerate(c2))\n               if p[0] > q[0])\n\nprint beating_probability(4, 9, 6, 6)\nprint beating_probability(10, 5, 7, 6)\n"}
{"id": 333650, "name": "Metronome", "source": "Translate Perl to Python: use Time::HiRes qw(sleep gettimeofday);\n\nlocal $| = 1;    \n\nmy $beats_per_minute = shift || 72;\nmy $beats_per_bar    = shift || 4;\n\nmy $i         = 0;\nmy $duration  = 60 / $beats_per_minute;\nmy $base_time = gettimeofday() + $duration;\n\nfor (my $next_time = $base_time ; ; $next_time += $duration) {\n    if ($i++ % $beats_per_bar == 0) {\n        print \"\\nTICK\";\n    }\n    else {\n        print \" tick\";\n    }\n    sleep($next_time - gettimeofday());\n}\n", "target": "\nimport time\n\ndef main(bpm = 72, bpb = 4):\n    sleep = 60.0 / bpm\n    counter = 0\n    while True:\n        counter += 1\n        if counter % bpb:\n            print 'tick'\n        else:\n            print 'TICK'\n        time.sleep(sleep)\n        \n\n\nmain()\n"}
{"id": 333651, "name": "Sum of elements below main diagonal of matrix", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse List::Util qw( sum );\n\nmy $matrix =\n  [[1,3,7,8,10],\n  [2,4,16,14,4],\n  [3,1,9,18,11],\n  [12,14,17,18,20],\n  [7,1,3,9,5]];\n\nmy $lowersum = sum map @{ $matrix->[$_] }[0 .. $_ - 1], 1 .. $\nprint \"lower sum = $lowersum\\n\";\n", "target": "from numpy import array, tril, sum\n\nA = [[1,3,7,8,10],\n    [2,4,16,14,4],\n    [3,1,9,18,11],\n    [12,14,17,18,20],\n    [7,1,3,9,5]]\n\nprint(sum(tril(A, -1)))   \n"}
{"id": 333652, "name": "Pythagoras tree", "source": "Translate Perl to Python: use Imager;\n\nsub tree {\n    my ($img, $x1, $y1, $x2, $y2, $depth) = @_;\n\n    return () if $depth <= 0;\n\n    my $dx = ($x2 - $x1);\n    my $dy = ($y1 - $y2);\n\n    my $x3 = ($x2 - $dy);\n    my $y3 = ($y2 - $dx);\n    my $x4 = ($x1 - $dy);\n    my $y4 = ($y1 - $dx);\n    my $x5 = ($x4 + 0.5 * ($dx - $dy));\n    my $y5 = ($y4 - 0.5 * ($dx + $dy));\n\n    \n    $img->polygon(\n        points => [\n            [$x1, $y1],\n            [$x2, $y2],\n            [$x3, $y3],\n            [$x4, $y4],\n        ],\n        color => [0, 255 / $depth, 0],\n    );\n\n    \n    $img->polygon(\n        points => [\n            [$x3, $y3],\n            [$x4, $y4],\n            [$x5, $y5],\n        ],\n        color => [0, 255 / $depth, 0],\n    );\n\n    tree($img, $x4, $y4, $x5, $y5, $depth - 1);\n    tree($img, $x5, $y5, $x3, $y3, $depth - 1);\n}\n\nmy ($width, $height) = (1920, 1080);\nmy $img = Imager->new(xsize => $width, ysize => $height);\n$img->box(filled => 1, color => 'white');\ntree($img, $width/2.3, $height, $width/1.8, $height, 10);\n$img->write(file => 'pythagoras_tree.png');\n", "target": "def setup():\n    size(800, 400)\n    background(255)\n    stroke(0, 255, 0)\n    tree(width / 2.3, height, width / 1.8, height, 10)\n\n\ndef tree(x1, y1, x2, y2, depth):\n    if depth <= 0: return\n    dx = (x2 - x1)\n    dy = (y1 - y2)\n\n    x3 = (x2 - dy)\n    y3 = (y2 - dx)\n    x4 = (x1 - dy)\n    y4 = (y1 - dx)\n    x5 = (x4 + 0.5 * (dx - dy))\n    y5 = (y4 - 0.5 * (dx + dy))\n\n    \n    beginShape()\n    fill(0.0, 255.0 / depth, 0.0)\n    vertex(x1, y1)\n    vertex(x2, y2)\n    vertex(x3, y3)\n    vertex(x4, y4)\n    vertex(x1, y1)\n    endShape()\n\n    \n    beginShape()\n    fill(0.0, 255.0 / depth, 0.0)\n    vertex(x3, y3)\n    vertex(x4, y4)\n    vertex(x5, y5)\n    vertex(x3, y3)\n    endShape()\n\n    tree(x4, y4, x5, y5, depth - 1)\n    tree(x5, y5, x3, y3, depth - 1)\n"}
{"id": 333653, "name": "Rep-string", "source": "Translate Perl to Python: foreach (qw(1001110011 1110111011 0010010010 1010101010 1111111111 0100101101 0100100 101 11 00 1)) {\n    print \"$_\\n\";\n    if (/^(.+)\\1+(.*$)(?(?{ substr($1, 0, length $2) eq $2 })|(?!))/) {\n        print ' ' x length $1, \"$1\\n\\n\";\n    } else {\n        print \" (no repeat)\\n\\n\";\n    }\n}\n", "target": "def is_repeated(text):\n    'check if the first part of the string is repeated throughout the string'\n    for x in range(len(text)//2, 0, -1):\n        if text.startswith(text[x:]): return x\n    return 0\n\nmatchstr = \nfor line in matchstr.split():\n    ln = is_repeated(line)\n    print('%r has a repetition length of %i i.e. %s' \n           % (line, ln, repr(line[:ln]) if ln else '*not* a rep-string'))\n"}
{"id": 333654, "name": "File size distribution", "source": "Translate Perl to Python: use File::Find;\nuse List::Util qw(max);\n\nmy %fsize;\n$dir = shift || '.';\nfind(\\&fsize, $dir);\n\n$max = max($max,$fsize{$_}) for keys %fsize;\n$total += $size while (undef,$size) = each %fsize;\n\nprint \"File size distribution in bytes for directory: $dir\\n\";\nfor (0 .. max(keys %fsize)) {\n    printf \"\n       histogram( $max, $fsize{$_} // 0, 80);\n}\nprint \"$total total files.\\n\";\n\nsub histogram {\n    my($max, $value, $width) = @_;\n    my @blocks = qw<| \u258f \u258e \u258d \u258c \u258b \u258a \u2589 \u2588>;\n    my $scaled = int $value * $width / $max;\n    my $end =     $scaled % 8;\n    my $bar = int $scaled / 8;\n    my $B = $blocks[8] x ($bar * 8) . ($end ? $blocks[$end] : '');\n}\n\nsub fsize { $fsize{ log10( (lstat($_))[7] ) }++ }\nsub log10 { my($s) = @_; $s ? int log($s)/log(10) : 0 }\n", "target": "import sys, os\nfrom collections import Counter\n\ndef dodir(path):\n    global h\n\n    for name in os.listdir(path):\n        p = os.path.join(path, name)\n\n        if os.path.islink(p):\n            pass\n        elif os.path.isfile(p):\n            h[os.stat(p).st_size] += 1\n        elif os.path.isdir(p):\n            dodir(p)\n        else:\n            pass\n\ndef main(arg):\n    global h\n    h = Counter()\n    for dir in arg:\n        dodir(dir)\n\n    s = n = 0\n    for k, v in sorted(h.items()):\n        print(\"Size %d -> %d file(s)\" % (k, v))\n        n += v\n        s += k * v\n    print(\"Total %d bytes for %d files\" % (s, n))\n\nmain(sys.argv[1:])\n"}
{"id": 333655, "name": "Topswops", "source": "Translate Perl to Python: sub next_swop {\n  my( $max, $level, $p, $d ) = @_;\n  my $swopped = 0;\n  for( 2..@$p ){ \n    my @now = @$p;\n    if( $_ == $now[$_-1] ) {\n      splice @now, 0, 0, reverse splice @now, 0, $_;\n      $swopped = 1;\n      next_swop( $max, $level+1, \\@now, [ @$d ] );\n    }\n  }\n  for( 1..@$d ) { \n    my @now = @$p;\n    my $next = shift @$d;\n    if( not $now[$next-1] ) {\n      $now[$next-1] = $next;\n      splice @now, 0, 0, reverse splice @now, 0, $next;\n      $swopped = 1;\n      next_swop( $max, $level+1, \\@now, [ @$d ] );\n    }\n    push @$d, $next;\n  }\n  $$max = $level if !$swopped and $level > $$max;\n}\n\nsub topswops {\n  my $n = shift;\n  my @d = 2..$n;\n  my @p = ( 1, (0) x ($n-1) );\n  my $max = 0;\n  next_swop( \\$max, 0, \\@p, \\@d );\n  return $max;\n}\n\nprintf \"Maximum swops for %2d cards: %2d\\n\", $_, topswops $_ for 1..10;\n", "target": ">>> from itertools import permutations\n>>> def f1(p):\n\ti = 0\n\twhile True:\n\t\tp0  = p[0]\n\t\tif p0 == 1: break\n\t\tp[:p0] = p[:p0][::-1]\n\t\ti  += 1\n\treturn i\n\n>>> def fannkuch(n):\n\treturn max(f1(list(p)) for p in permutations(range(1, n+1)))\n\n>>> for n in range(1, 11): print(n,fannkuch(n))\n\n1 0\n2 1\n3 2\n4 4\n5 7\n6 10\n7 16\n8 22\n9 30\n10 38\n>>>\n"}
{"id": 333656, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'divisors';\n\nprint \"First 15 terms of OEIS: A069654\\n\";\nmy $m = 0;\nfor my $n (1..15) {\n    my $l = $m;\n    while (++$l) {\n        print(\"$l \"), $m = $l, last if $n == divisors($l);\n    }\n}\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    previous = 0\n    n = 0\n    while True:\n        n += 1\n        ii = previous\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                previous = ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 333657, "name": "McNuggets problem", "source": "Translate Perl to Python: use ntheory qw/forperm gcd vecmin/;\n\nsub Mcnugget_number {\n    my $counts = shift;\n\n    return 'No maximum' if 1 < gcd @$counts;\n\n    my $min = vecmin @$counts;\n    my @meals;\n    my @min;\n\n    my $a = -1;\n    while (1) {\n        $a++;\n        for my $b (0..$a) {\n            for my $c (0..$b) {\n                my @s = ($a, $b, $c);\n                forperm {\n                    $meals[\n                        $s[$_[0]] * $counts->[0]\n                      + $s[$_[1]] * $counts->[1]\n                      + $s[$_[2]] * $counts->[2]\n                    ] = 1;\n                } @s;\n            }\n        }\n        for my $i (0..$\n            next unless $meals[$i];\n            if ($min[-1] and $i == ($min[-1] + 1)) {\n                push @min, $i;\n                last if $min == @min\n            } else {\n                @min = $i;\n            }\n        }\n        last if $min == @min\n    }\n    $min[0] ? $min[0] - 1 : 0\n}\n\nfor my $counts ([6,9,20], [6,7,20], [1,3,20], [10,5,18], [5,17,44], [2,4,6], [3,6,15]) {\n    print 'Maximum non-Mcnugget number using ' . join(', ', @$counts) . ' is: ' . Mcnugget_number($counts) . \"\\n\"\n}\n", "target": ">>> from itertools import product\n>>> nuggets = set(range(101))\n>>> for s, n, t in product(range(100//6+1), range(100//9+1), range(100//20+1)):\n\tnuggets.discard(6*s + 9*n + 20*t)\n\n\t\n>>> max(nuggets)\n43\n>>>\n"}
{"id": 333658, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate Perl to Python: use v5.12;\nuse utf8;\nbinmode STDOUT, ':utf8';\n\nmy($lower,$upper);\n\nfor my $i (0..2**8-1) {\n    my $c = chr $i;\n    $lower .= $c if $c =~ /[[:lower:]]/;\n    $upper .= $c if $c =~ /[[:upper:]]/;\n}\n\nsay $lower;\nsay $upper;\n", "target": "classes = (str.isupper, str.islower, str.isalnum, str.isalpha, str.isdecimal,\n           str.isdigit, str.isidentifier, str.isnumeric, str.isprintable,\n           str.isspace, str.istitle)\n\nfor stringclass in classes:\n    chars = ''.join(chr(i) for i in range(0x10FFFF+1) if stringclass(chr(i)))\n    print('\\nString class %s has %i characters the first of which are:\\n  %r'\n          % (stringclass.__name__, len(chars), chars[:100]))\n"}
{"id": 333659, "name": "Superellipse", "source": "Translate Perl to Python: use v5.36;\nmy($a, $b, $n, @q) = (200, 200, 2.5);\n\n\nsub y_from_x ($x) { int $b * abs(1 - ($x/$a) ** $n ) ** (1/$n) }\n\n\npush @q, $_, y_from_x($_) for 0..$a;\n\nopen  $fh, '>', 'superellipse.svg';\nprint $fh\n  qq|<svg height=\"@{[2*$b]}\" width=\"@{[2*$a]}\" xmlns=\"http://www.w3.org/2000/svg\">\\n|,\n  pline( 1, 1, @q ),\n  pline( 1,-1, @q ), \n  pline(-1,-1, @q ), \n  pline(-1, 1, @q ), \n  '</svg>';\n\nsub pline ($sx, $sy, @q) {\n  (@q[2*$_] *= $sx, @q[1+2*$_] *= $sy) for 0 .. $\n  qq|<polyline points=\"@q\"\n  style=\"fill:none;stroke:black;stroke-width:3\"\n  transform=\"translate($a, $b)\" />\\n|\n}\n", "target": "\n\n\nimport matplotlib.pyplot as plt\nfrom math import sin, cos, pi\n\ndef sgn(x):\n\treturn ((x>0)-(x<0))*1\n\na,b,n=200,200,2.5 \nna=2/n\nstep=100 \npiece=(pi*2)/step\nxp=[];yp=[]\n\nt=0\nfor t1 in range(step+1):\n\t\n\tx=(abs((cos(t)))**na)*a*sgn(cos(t))\n\ty=(abs((sin(t)))**na)*b*sgn(sin(t))\n\txp.append(x);yp.append(y)\n\tt+=piece\n\nplt.plot(xp,yp) \nplt.title(\"Superellipse with parameter \"+str(n))\nplt.show()\n"}
{"id": 333660, "name": "Mutex", "source": "Translate Perl to Python: use Thread qw'async';\nuse threads::shared;\n\nmy ($lock1, $lock2, $resource1, $resource2) :shared = (0) x 4;\n\nsub use_resource {\n        {       \n                lock $lock1;\n                $resource1 --;          \n                sleep(int rand 3);      \n                $resource1 ++;          \n                print \"In thread \", threads->tid(), \": \";\n                print \"Resource1 is $resource1\\n\";\n        }\n        {\n                lock $lock2;\n                $resource2 --;\n                sleep(int rand 3);\n                $resource2 ++;\n                print \"In thread \", threads->tid(), \": \";\n                print \"Resource2 is $resource2\\n\";\n        }\n}\n\n\nfor ( map async{ use_resource }, 1 .. 9) {\n        $_->join\n}\n", "target": "import threading\nfrom time import sleep\n\n\n\nres = 2\nsema = threading.Semaphore(res)\n\nclass res_thread(threading.Thread):\n    def run(self):\n        global res\n        n = self.getName()\n        for i in range(1, 4):\n            \n            \n            \n            sema.acquire()\n            res = res - 1\n            print n, \"+  res count\", res\n            sleep(2)\n\n                        \n            res = res + 1\n            print n, \"-  res count\", res\n            sema.release()\n\n\nfor i in range(1, 5):\n    t = res_thread()\n    t.start()\n"}
{"id": 333661, "name": "Jaro similarity", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util qw(min max);\n\nsub jaro {\n    my($s, $t) = @_;\n    my(@s_matches, @t_matches, $matches);\n\n    return 1 if $s eq $t;\n\n    my($s_len, @s) = (length $s, split //, $s);\n    my($t_len, @t) = (length $t, split //, $t);\n\n    my $match_distance = int (max($s_len, $t_len) / 2) - 1;\n    for my $i (0 .. $\n        my $start = max(0, $i - $match_distance);\n        my $end   = min($i + $match_distance + 1, $t_len);\n        for my $j ($start .. $end - 1) {\n            next if $t_matches[$j] or $s[$i] ne $t[$j];\n            ($s_matches[$i], $t_matches[$j]) = (1, 1);\n            $matches++ and last;\n        }\n    }\n    return 0 unless $matches;\n\n    my($k, $transpositions) = (0, 0);\n    for my $i (0 .. $\n        next unless $s_matches[$i];\n        $k++ until  $t_matches[$k];\n        $transpositions++ if $s[$i] ne $t[$k];\n        $k++;\n    }\n    ( $matches/$s_len + $matches/$t_len + (($matches - $transpositions/2) / $matches) ) / 3;\n}\n\nprintf \"%.3f\\n\", jaro(@$_[0], @$_[1]) for\n    ['MARTHA', 'MARHTA'], ['DIXON', 'DICKSONX'], ['JELLYFISH', 'SMELLYFISH'],\n    ['I repeat myself', 'I repeat myself'], ['', ''];\n", "target": "\n\nfrom __future__ import division\n\n\ndef jaro(s, t):\n    \n    s_len = len(s)\n    t_len = len(t)\n\n    if s_len == 0 and t_len == 0:\n        return 1\n\n    match_distance = (max(s_len, t_len) // 2) - 1\n\n    s_matches = [False] * s_len\n    t_matches = [False] * t_len\n\n    matches = 0\n    transpositions = 0\n\n    for i in range(s_len):\n        start = max(0, i - match_distance)\n        end = min(i + match_distance + 1, t_len)\n\n        for j in range(start, end):\n            if t_matches[j]:\n                continue\n            if s[i] != t[j]:\n                continue\n            s_matches[i] = True\n            t_matches[j] = True\n            matches += 1\n            break\n\n    if matches == 0:\n        return 0\n\n    k = 0\n    for i in range(s_len):\n        if not s_matches[i]:\n            continue\n        while not t_matches[k]:\n            k += 1\n        if s[i] != t[k]:\n            transpositions += 1\n        k += 1\n\n    return ((matches / s_len) +\n            (matches / t_len) +\n            ((matches - transpositions / 2) / matches)) / 3\n\n\ndef main():\n    \n\n    for s, t in [('MARTHA', 'MARHTA'),\n                 ('DIXON', 'DICKSONX'),\n                 ('JELLYFISH', 'SMELLYFISH')]:\n        print(\"jaro(%r, %r) = %.10f\" % (s, t, jaro(s, t)))\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333662, "name": "Odd word problem", "source": "Translate Perl to Python: sub r\n{\n\tmy ($f, $c) = @_;\n\treturn sub { print $c; $f->(); };\n}\n\n$r = sub {};\n\nwhile (read STDIN, $_, 1) {\n\t$w = /^[a-zA-Z]$/;\n\t$n++ if ($w && !$l);\n\t$l = $w;\n\tif ($n & 1 || !$w) {\n\t\t$r->(); $r = sub{};\n\t\tprint;\n\t} else {\n\t\t$r = r($r, $_);\n\t}\n}\n$r->();\n", "target": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e\n"}
{"id": 333663, "name": "Pseudo-random numbers_PCG32", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse Math::AnyNum qw(:overload);\n\npackage PCG32 {\n\n    use constant {\n        mask32 => 2**32 - 1,\n        mask64 => 2**64 - 1,\n        const  => 6364136223846793005,\n    };\n\n    sub new {\n        my ($class, %opt) = @_;\n        my $seed = $opt{seed} // 1;\n        my $incr = $opt{incr} // 2;\n        $incr = $incr << 1 | 1 & mask64;\n        my $state = (($incr + $seed) * const + $incr) & mask64;\n        bless {incr => $incr, state => $state}, $class;\n    }\n\n    sub next_int {\n        my ($self) = @_;\n        my $state  = $self->{state};\n        my $shift  = ($state >> 18 ^ $state) >> 27 & mask32;\n        my $rotate = $state >> 59 & mask32;\n        $self->{state} = ($state * const + $self->{incr}) & mask64;\n        ($shift >> $rotate) | $shift << (32 - $rotate) & mask32;\n    }\n\n    sub next_float {\n        my ($self) = @_;\n        $self->next_int / 2**32;\n    }\n}\n\nsay \"Seed: 42, Increment: 54, first 5 values:\";\nmy $rng = PCG32->new(seed => 42, incr => 54);\nsay $rng->next_int for 1 .. 5;\n\nsay \"\\nSeed: 987654321, Increment: 1, values histogram:\";\nmy %h;\n$rng = PCG32->new(seed => 987654321, incr => 1);\n$h{int 5 * $rng->next_float}++ for 1 .. 100_000;\nsay \"$_ $h{$_}\" for sort keys %h;\n", "target": "mask64 = (1 << 64) - 1\nmask32 = (1 << 32) - 1\nCONST = 6364136223846793005\n\n\nclass PCG32():\n    \n    def __init__(self, seed_state=None, seed_sequence=None):\n        if all(type(x) == int for x in (seed_state, seed_sequence)):\n            self.seed(seed_state, seed_sequence)\n        else:\n            self.state = self.inc = 0\n    \n    def seed(self, seed_state, seed_sequence):\n        self.state = 0\n        self.inc = ((seed_sequence << 1) | 1) & mask64\n        self.next_int()\n        self.state = (self.state + seed_state)\n        self.next_int()\n        \n    def next_int(self):\n        \"return random 32 bit unsigned int\"\n        old = self.state\n        self.state = ((old * CONST) + self.inc) & mask64\n        xorshifted = (((old >> 18) ^ old) >> 27) & mask32\n        rot = (old >> 59) & mask32\n        answer = (xorshifted >> rot) | (xorshifted << ((-rot) & 31))\n        answer = answer &mask32\n        \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / (1 << 32)\n    \n\nif __name__ == '__main__':\n    random_gen = PCG32()\n    random_gen.seed(42, 54)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321, 1)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 333664, "name": "Memory layout of a data structure", "source": "Translate Perl to Python: use Bit::Vector::Minimal qw();\nmy $vec = Bit::Vector::Minimal->new(size => 24);\n\nmy %rs232 = reverse (\n     1 => 'PG   Protective ground',\n     2 => 'TD   Transmitted data',\n     3 => 'RD   Received data',\n     4 => 'RTS  Request to send',\n     5 => 'CTS  Clear to send',\n     6 => 'DSR  Data set ready',\n     7 => 'SG   Signal ground',\n     8 => 'CD   Carrier detect',\n     9 => '+ voltage (testing)',\n    10 => '- voltage (testing)',\n    12 => 'SCD  Secondary CD',\n    13 => 'SCS  Secondary CTS',\n    14 => 'STD  Secondary TD',\n    15 => 'TC   Transmit clock',\n    16 => 'SRD  Secondary RD',\n    17 => 'RC   Receiver clock',\n    19 => 'SRS  Secondary RTS',\n    20 => 'DTR  Data terminal ready',\n    21 => 'SQD  Signal quality detector',\n    22 => 'RI   Ring indicator',\n    23 => 'DRS  Data rate select',\n    24 => 'XTC  External clock',\n);\n\n$vec->set($rs232{'RD   Received data'}, 1);\n$vec->get($rs232{'TC   Transmit clock'});\n", "target": "from ctypes import Structure, c_int\n\nrs232_9pin  = \"_0 CD RD TD DTR SG DSR RTS CTS RI\".split()\nrs232_25pin = ( \"_0  PG  TD  RD  RTS CTS DSR SG  CD  pos neg\"\n                \"_11 SCD SCS STD TC  SRD RC\"\n                \"_18 SRS DTR SQD RI DRS XTC\" ).split()\n\nclass RS232_9pin(Structure):\n    _fields_ = [(__, c_int, 1) for __ in rs232_9pin]\n\n\t\nclass RS232_25pin(Structure):\n    _fields_ = [(__, c_int, 1) for __ in rs232_25pin]\n"}
{"id": 333665, "name": "Largest proper divisor of n", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory 'divisors';\nuse List::AllUtils <max natatime>;\n\nsub proper_divisors {\n  my $n = shift;\n  return 1 if $n == 0;\n  my @d = divisors($n);\n  pop @d;\n  @d;\n}\n\nmy @range = 1 .. 100;\nprint \"GPD for $range[0] through $range[-1]:\\n\";\nmy $iter = natatime 10, @range;\nwhile( my @batch = $iter->() ) {\n    printf '%3d', $_ == 1 ? 1 : max proper_divisors($_) for @batch; print \"\\n\";\n}\n", "target": "def lpd(n):\n    for i in range(n-1,0,-1):\n        if n%i==0: return i\n    return 1\n\nfor i in range(1,101):\n    print(\"{:3}\".format(lpd(i)), end=i%10==0 and '\\n' or '')\n"}
{"id": 333666, "name": "Summarize and say sequence", "source": "Translate Perl to Python: sub next_num {\n\tmy @a;\n\t$a[$_]++ for split '', shift;\n\tjoin('', map(exists $a[$_] ? $a[$_].$_ : \"\", reverse 0 .. 9));\n}\n\nmy %cache;\nsub seq {\n\tmy $a = shift;\n\tmy (%seen, @s);\n\tuntil ($seen{$a}) {\n\t\t$seen{$a} = 1;\n\t\tpush(@s, $a);\n\t\tlast if !wantarray && $cache{$a};\n\t\t$a = next_num($a);\n\t}\n\treturn (@s) if wantarray;\n\n\tmy $l = $cache{$a};\n\tif ($l) { $cache{$s[$_]} = $\n\telse {\n\t\t$l++ while ($s[-$l] != $a);\n\t\t$cache{pop @s} = $l \tfor (1 .. $l);\n\t\t$cache{pop @s} = ++$l\twhile @s;\n\t}\n\t$cache{$s[0]}\n}\n\nmy (@mlist, $mlen);\nfor (1 .. 100_000) { \n\tmy $l = seq($_);\n\tnext if $l < $mlen;\n\tif ($l > $mlen) { $mlen = $l; @mlist = (); }\n\tpush @mlist, $_;\n}\n\nprint \"longest ($mlen): @mlist\\n\";\nprint join(\"\\n\", seq($_)), \"\\n\\n\" for @mlist;\n", "target": "from itertools import groupby, permutations\n\ndef A036058(number):\n    return ''.join( str(len(list(g))) + k\n                    for k,g in groupby(sorted(str(number), reverse=True)) )\n\ndef A036058_length(numberstring='0', printit=False):\n    iterations, last_three, queue_index = 1, ([None] * 3), 0\n\n    def A036058(number):\n        \n        return ''.join( str(len(list(g))) + k\n                        for k,g in groupby(number) )\n\n    while True:\n        if printit:\n            print(\"  %2i %s\" % (iterations, numberstring))\n        numberstring = ''.join(sorted(numberstring, reverse=True))\n        if numberstring in last_three:\n            break\n        assert iterations < 1000000\n        last_three[queue_index], numberstring = numberstring, A036058(numberstring)\n        iterations += 1\n        queue_index +=1\n        queue_index %=3\n    return iterations\n    \ndef max_A036058_length( start_range=range(11) ):\n    already_done = set()\n    max_len = (-1, [])\n    for n in start_range:\n        sn = str(n)\n        sns = tuple(sorted(sn, reverse=True))\n        if sns not in already_done:\n            already_done.add(sns)\n            size = A036058_length(sns)\n            if size > max_len[0]:\n                max_len = (size, [n])\n            elif size == max_len[0]:\n                max_len[1].append(n)\n    return max_len\n\nlenmax, starts = max_A036058_length( range(1000000) )\n\n\nallstarts = []\nfor n in starts:\n    allstarts += [int(''.join(x))\n                  for x in set(k\n                               for k in permutations(str(n), 4)\n                               if k[0] != '0')]\nallstarts = [x for x in sorted(allstarts) if x < 1000000]\n\nprint (  % (lenmax, allstarts)   )\n\nprint (  )\n\nfor n in starts:\n    print()\n    A036058_length(str(n), printit=True)\n"}
{"id": 333667, "name": "Koch curve", "source": "Translate Perl to Python: use SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\n\nmy $koch = 'F--F--F';\n$koch =~ s/F/F+F--F+F/g for 1..5;\n\n\n($x, $y) = (0, 0);\n$theta   = pi/3;\n$r       = 2;\n\nfor (split //, $koch) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/3; }\n    elsif (/\\-/) { $theta -= pi/3; }\n}\n\n$xrng =  max(@X) - min(@X);\n$yrng =  max(@Y) - min(@Y);\n$xt   = -min(@X)+10;\n$yt   = -min(@Y)+10;\n$svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\n$points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen  $fh, '>', 'koch_curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "l = 300\n\ndef setup():\n    size(400, 400)\n    background(0, 0, 255)\n    stroke(255)\n    \n    translate(width / 2.0, height / 2.0)\n    \n    translate(-l / 2.0, l * sqrt(3) / 6.0)\n    for i in range(4):\n        kcurve(0, l)\n        rotate(radians(120))\n        translate(-l, 0)\n\n\ndef kcurve(x1, x2):\n    s = (x2 - x1) / 3.0\n    if s < 5:\n        pushMatrix()\n        translate(x1, 0)\n        line(0, 0, s, 0)\n        line(2 * s, 0, 3 * s, 0)\n        translate(s, 0)\n        rotate(radians(60))\n        line(0, 0, s, 0)\n        translate(s, 0)\n        rotate(radians(-120))\n        line(0, 0, s, 0)\n        popMatrix()\n        return\n\n    pushMatrix()\n    translate(x1, 0)\n    kcurve(0, s)\n    kcurve(2 * s, 3 * s)\n    translate(s, 0)\n    rotate(radians(60))\n    kcurve(0, s)\n    translate(s, 0)\n    rotate(radians(-120))\n    kcurve(0, s)\n    popMatrix()\n"}
{"id": 333668, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Perl to Python: use strict;\nuse warnings;\nno warnings 'portable';\nuse feature 'say';\nuse Math::AnyNum qw(:overload);\n\npackage Xorshift_star {\n\n    sub new {\n        my ($class, %opt) = @_;\n        bless {state => $opt{seed}}, $class;\n    }\n\n    sub next_int {\n        my ($self) = @_;\n        my $state = $self->{state};\n        $state ^= $state >> 12;\n        $state ^= $state << 25 & (2**64 - 1);\n        $state ^= $state >> 27;\n        $self->{state} = $state;\n        ($state * 0x2545F4914F6CDD1D) >> 32 & (2**32 - 1);\n    }\n\n    sub next_float {\n        my ($self) = @_;\n        $self->next_int / 2**32;\n    }\n}\n\nsay 'Seed: 1234567, first 5 values:';\nmy $rng = Xorshift_star->new(seed => 1234567);\nsay $rng->next_int for 1 .. 5;\n\nmy %h;\nsay \"\\nSeed: 987654321, values histogram:\";\n$rng = Xorshift_star->new(seed => 987654321);\n$h{int 5 * $rng->next_float}++ for 1 .. 100_000;\nsay \"$_ $h{$_}\" for sort keys %h;\n", "target": "mask64 = (1 << 64) - 1\nmask32 = (1 << 32) - 1\nconst = 0x2545F4914F6CDD1D\n\n\n\nclass Xorshift_star():\n    \n    def __init__(self, seed=0):\n        self.state = seed & mask64\n\n    def seed(self, num):\n        self.state =  num & mask64\n    \n    def next_int(self):\n        \"return random int between 0 and 2**32\"\n        x = self.state\n        x = (x ^ (x >> 12)) & mask64\n        x = (x ^ (x << 25)) & mask64\n        x = (x ^ (x >> 27)) & mask64\n        self.state = x\n        answer = (((x * const) & mask64) >> 32) & mask32 \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / (1 << 32)\n    \n\nif __name__ == '__main__':\n    random_gen = Xorshift_star()\n    random_gen.seed(1234567)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 333669, "name": "Numbers with equal rises and falls", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nsub rf\n  {\n  local $_ = shift;\n  my $sum = 0;\n  $sum += $1 <=> $2 while /(.)(?=(.))/g;\n  $sum\n  }\n\nmy $count = 0;\nmy $n = 0;\nmy @numbers;\nwhile( $count < 200 )\n  {\n  rf(++$n) or $count++, push @numbers, $n;\n  }\nprint \"first 200: @numbers\\n\" =~ s/.{1,70}\\K\\s/\\n/gr;\n\n$count = 0;\n$n = 0;\nwhile( $count < 10e6 )\n  {\n  rf(++$n) or $count++;\n  }\nprint \"\\n10,000,000th number: $n\\n\";\n", "target": "import itertools\n\ndef riseEqFall(num):\n    \n    height = 0\n    d1 = num % 10\n    num //= 10\n    while num:\n        d2 = num % 10\n        height += (d1<d2) - (d1>d2)\n        d1 = d2\n        num //= 10\n    return height == 0\n    \ndef sequence(start, fn):\n    \n    num=start-1\n    while True:\n        num += 1\n        while not fn(num): num += 1\n        yield num\n\na296712 = sequence(1, riseEqFall)\n\n\nprint(\"The first 200 numbers are:\")\nprint(*itertools.islice(a296712, 200))\n\n\nprint(\"The 10,000,000th number is:\")\nprint(*itertools.islice(a296712, 10000000-200-1, 10000000-200))\n\n\n"}
{"id": 333670, "name": "Pseudo-random numbers_Combined recursive generator MRG32k3a", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\npackage MRG32k3a {\n\n    use constant {\n        m1 => 2**32 - 209,\n        m2 => 2**32 - 22853\n    };\n\n    use Const::Fast;\n    const my @a1 => <     0 1403580  -810728>;\n    const my @a2 => <527612       0 -1370589>;\n\n    sub new {\n        my ($class,undef,$seed) = @_;\n        my @x1 = my @x2 = ($seed, 0, 0);\n        bless {x1 => \\@x1, x2 => \\@x2}, $class;\n    }\n\n    sub next_int {\n        my ($self) = @_;\n        unshift @{$$self{x1}}, ($a1[0] * $$self{x1}[0] + $a1[1] * $$self{x1}[1] + $a1[2] * $$self{x1}[2]) % m1; pop @{$$self{x1}};\n        unshift @{$$self{x2}}, ($a2[0] * $$self{x2}[0] + $a2[1] * $$self{x2}[1] + $a2[2] * $$self{x2}[2]) % m2; pop @{$$self{x2}};\n        ($$self{x1}[0] - $$self{x2}[0]) % (m1 + 1)\n    }\n\n    sub next_float { $_[0]->next_int / (m1 + 1) }\n}\n\nsay 'Seed: 1234567, first 5 values:';\nmy $rng = MRG32k3a->new( seed => 1234567 );\nsay $rng->next_int for 1..5;\n\nmy %h;\nsay \"\\nSeed: 987654321, values histogram:\";\n$rng = MRG32k3a->new( seed => 987654321 );\n$h{int 5 * $rng->next_float}++ for 1..100_000;\nsay \"$_ $h{$_}\" for sort keys %h;\n", "target": "\na1 = [0, 1403580, -810728]\nm1 = 2**32 - 209\n\na2 = [527612, 0, -1370589]\nm2 = 2**32 - 22853\n\nd = m1 + 1\n\nclass MRG32k3a():\n    \n    def __init__(self, seed_state=123):\n        self.seed(seed_state)\n    \n    def seed(self, seed_state):\n        assert 0 <seed_state < d, f\"Out of Range 0 x < {d}\"\n        self.x1 = [seed_state, 0, 0]\n        self.x2 = [seed_state, 0, 0]\n        \n    def next_int(self):\n        \"return random int in range 0..d\"\n        x1i = sum(aa * xx  for aa, xx in zip(a1, self.x1)) % m1\n        x2i = sum(aa * xx  for aa, xx in zip(a2, self.x2)) % m2\n        self.x1 = [x1i] + self.x1[:2]\n        self.x2 = [x2i] + self.x2[:2]\n\n        z = (x1i - x2i) % m1\n        answer = (z + 1)\n        \n        return answer\n    \n    def  next_float(self):\n        \"return random float between 0 and 1\"\n        return self.next_int() / d\n    \n\nif __name__ == '__main__':\n    random_gen = MRG32k3a()\n    random_gen.seed(1234567)\n    for i in range(5):\n        print(random_gen.next_int())\n        \n    random_gen.seed(987654321)\n    hist = {i:0 for i in range(5)}\n    for i in range(100_000):\n        hist[int(random_gen.next_float() *5)] += 1\n    print(hist)\n"}
{"id": 333671, "name": "Self-describing numbers", "source": "Translate Perl to Python: sub is_selfdesc\n{\n\tlocal $_ = shift;\n\tmy @b = (0) x length;\n\t$b[$_]++ for my @a = split //;\n\treturn \"@a\" eq \"@b\";\n}\n\n\nfor (0 .. 100000, 3211000, 42101000) {\n\tprint \"$_\\n\" if is_selfdesc($_);\n}\n", "target": ">>> def isSelfDescribing(n):\n\ts = str(n)\n\treturn all(s.count(str(i)) == int(ch) for i, ch in enumerate(s))\n\n>>> [x for x in range(4000000) if isSelfDescribing(x)]\n[1210, 2020, 21200, 3211000]\n>>> [(x, isSelfDescribing(x)) for x in (1210, 2020, 21200, 3211000, 42101000, 521001000, 6210001000)]\n[(1210, True), (2020, True), (21200, True), (3211000, True), (42101000, True), (521001000, True), (6210001000, True)]\n"}
{"id": 333672, "name": "Changeable words", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy @words;\n@ARGV = 'unixdict.txt';\nwhile( <> )\n  {\n  chomp;\n  length > 11 or next;\n  for my $prev ( @{ $words[length] } )\n    {\n    ($prev ^ $_) =~ tr/\\0//c == 1 and printf \"%30s <-> %s\\n\", $prev, $_;\n    }\n  push @{ $words[length] }, $_;\n  }\n", "target": "from collections import defaultdict, Counter\n\n\ndef getwords(minlength=11, fname='unixdict.txt'):\n    \"Return set of lowercased words of > given number of characters\"\n    with open(fname) as f:\n        words = f.read().strip().lower().split()\n    return {w for w in words if len(w) > minlength}\n\nwords11 = getwords()\nword_minus_1 = defaultdict(list)    \nminus_1_to_word = defaultdict(list) \n\nfor w in words11:\n    for i in range(len(w)):\n        minus_1 = w[:i] + w[i+1:]\n        word_minus_1[minus_1].append((w, i))   \n        if minus_1 in words11:\n            minus_1_to_word[minus_1].append(w)\n    \ncwords = set()  \nfor _, v in word_minus_1.items():\n    if len(v) >1:\n        change_indices = Counter(i for wrd, i in v)\n        change_words = set(wrd for wrd, i in v)\n        words_changed = None\n        if len(change_words) > 1 and change_indices.most_common(1)[0][1] > 1:\n            words_changed = [wrd for wrd, i in v\n                             if change_indices[i] > 1]\n        if words_changed:\n            cwords.add(tuple(sorted(words_changed)))\n\nprint(f\"{len(minus_1_to_word)} words that are from deleting a char from other words:\")\nfor k, v in sorted(minus_1_to_word.items()):\n    print(f\"  {k:12} From {', '.join(v)}\")\n\nprint(f\"\\n{len(cwords)} words that are from changing a char from other words:\")\nfor v in sorted(cwords):\n    print(f\"  {v[0]:12} From {', '.join(v[1:])}\")\n"}
{"id": 333673, "name": "Exactly three adjacent 3 in lists", "source": "Translate Perl to Python: \n \nuse strict; \nuse warnings;\n \nmy @lists = (\n  [9,3,3,3,2,1,7,8,5],\n  [5,2,9,3,3,7,8,4,1],\n  [1,4,3,6,7,3,8,3,2],\n  [1,2,3,4,5,6,7,8,9],\n  [4,6,8,7,2,3,3,3,1]);\n \nfor my $ref ( @lists )\n  {\n  my @n = grep $ref->[$_] == 3, 0 .. $\n  print \"@$ref => \",\n    @n == 3 && $n[0] == $n[1] - 1 && $n[1] == $n[2] - 1 ? 'true' : 'false',\n    \"\\n\";\n  }\n", "target": "\n\nfrom itertools import dropwhile, takewhile\n\n\n\ndef nnPeers(n):\n    \n    def p(x):\n        return n == x\n\n    def go(xs):\n        fromFirstMatch = list(dropwhile(\n            lambda v: not p(v),\n            xs\n        ))\n        ns = list(takewhile(p, fromFirstMatch))\n        rest = fromFirstMatch[len(ns):]\n\n        return p(len(ns)) and (\n            not any(p(x) for x in rest)\n        )\n\n    return go\n\n\n\n\ndef main():\n    \n    print(\n        '\\n'.join([\n            f'{xs} -> {nnPeers(3)(xs)}' for xs in [\n                [9, 3, 3, 3, 2, 1, 7, 8, 5],\n                [5, 2, 9, 3, 3, 7, 8, 4, 1],\n                [1, 4, 3, 6, 7, 3, 8, 3, 2],\n                [1, 2, 3, 4, 5, 6, 7, 8, 9],\n                [4, 6, 8, 7, 2, 3, 3, 3, 1]\n            ]\n        ])\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333674, "name": "Minimum numbers of three lists", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'min';\n\nmy @lists = ([5,45,23,21,67], [43,22,78,46,38], [9,98,12,98,53]);\n\nfor my $i (0 .. $\n    print ' ' . min map { $lists[$_][$i] } 0..$\n}\n", "target": "numbers1 = [5,45,23,21,67]\nnumbers2 = [43,22,78,46,38]\nnumbers3 = [9,98,12,98,53]\n\nnumbers = [min(numbers1[i],numbers2[i],numbers3[i]) for i in range(0,len(numbers1))]\n\nprint(numbers)\n"}
{"id": 333675, "name": "Longest substrings without repeating characters", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nfor my $string ( qw( xyzyabcybdfd xyzyab zzzzz a thisisastringtest ) )\n  {\n  local $_ = $string;\n  my @sub;\n  length $+ >= $\n  printf \"%20s -> %s\\n\", $string, join ' ', sort keys %{ pop @sub };\n  }\n", "target": "def longest_substring(s = \"xyzyab\"):\n    substr = [s[x:y] for x in range(len(s)) for y in range(x+1, len(s) + 1)]\n    no_reps = []\n    for sub in substr:\n        if len(sub) == len(set(sub)) and sub not in no_reps:\n            no_reps.append(sub)\n    max_len = max(len(sub) for sub in no_reps) if no_reps else 0\n    max_subs = [sub for sub in no_reps if len(sub) == max_len]\n    return max_subs\n\nif __name__ == '__main__':\n    for s in [\"xyzyabcybdfd\", \"xyzyab\", \"zzzzz\", \"a\", \"\u03b1\u2286\u03f6\u03b1\u03f6\", \"\",\n              [1, 2, 3, 4, 1, 2, 5, 6, 1, 7, 8, 1, 0]]:\n        print(f\"{s} => {longest_substring(s)}\")\n"}
{"id": 333676, "name": "Find words with alternating vowels and consonants", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy $alternatingCount = 0;\n\nwhile (<>) {\n   (my $Fld1) = split(' ', $_, -1);\n   if ((length($Fld1) >= 10)) { \n      my $word = $Fld1;\n      my $haveVowel = $word =~ /^[aeiou]/;\n      my $isAlternating = 1;\n      for (my $wPos = 2; $isAlternating && $wPos <= length($word); $wPos++) {\n         my $hadVowel = $haveVowel;\n         $haveVowel = substr($word, ($wPos)-1, 1) =~ /^[aeiou]/;\n         $isAlternating = ($hadVowel && !$haveVowel) || (!$hadVowel && $haveVowel);\n      } \n      if ($isAlternating) {\n          printf ' %16s%s', $word, ($alternatingCount % 6 == 5) ? \"\\n\" : '';\n          $alternatingCount += 1;\n      } \n   }\n}\n\nprintf \"\\n%d words with alternating vowels and consonants found\\n\", $alternatingCount;\n", "target": "\n\n\n\ndef isLongAlternator(s):\n    \n    def p(a, b):\n        return isVowel(a) != isVowel(b)\n    return 9 < len(s) and all(map(p, s, s[1:]))\n\n\ndef isVowel(c):\n    \n    return c in 'aeiou'\n\n\n\n\ndef main():\n    \n    matches = [\n        x for x in readFile('unixdict.txt').splitlines()\n        if isLongAlternator(x)\n    ]\n    w = max(len(x) for x in matches)\n    print(str(len(matches)) + ' matching words:\\n')\n    print(\n        '\\n'.join(\n            ' '.join(s) for s in chunksOf(4)([\n                x.ljust(w, ' ') for x in matches\n            ])\n        )\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef readFile(fp):\n    \n    with open(fp, 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333677, "name": "Input_Output for lines of text", "source": "Translate Perl to Python: $n = scalar <>;\n\ndo_stuff(scalar <>) for 1..$n;\n\nsub do_stuff { print $_[0] }\n", "target": "try: input = raw_input\nexcept: pass\n\ndef do_stuff(words):\n\tprint(words)\n\nlinecount = int(input())\nfor x in range(linecount):\n\tline = input()\n\tdo_stuff(line)\n"}
{"id": 333678, "name": "Numbers divisible by their individual digits, but not by the product of their digits.", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\nmy @numbers = grep\n  {\n  my $n = $_;\n  ! /0/ and $_ % eval s/\\B/*/gr and 0 == grep $n % $_, split //\n  } 1 .. 999;\n\nprint @numbers . \" numbers found\\n\\n@numbers\\n\" =~ s/.{25}\\K /\\n/gr;\n", "target": "\n\nfrom functools import reduce\nfrom operator import mul\n\n\n\ndef p(n):\n    \n    digits = [int(c) for c in str(n)]\n    return not 0 in digits and (\n        0 != (n % reduce(mul, digits, 1))\n    ) and all(0 == n % d for d in digits)\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1000)\n        if p(n)\n    ]\n    w = len(xs[-1])\n    print(f'{len(xs)} matching numbers:\\n')\n    print('\\n'.join(\n        ' '.join(cell.rjust(w, ' ') for cell in row)\n        for row in chunksOf(10)(xs)\n    ))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333679, "name": "Largest five adjacent number", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\n$_ = join '', map int rand 10, 1 .. 1e3;\nmy @n;\n@n[ /(?=(\\d{5}))/g ] = ();\nprint \"$\n", "target": "\n\nfrom random import seed,randint\nfrom datetime import datetime\n\nseed(str(datetime.now()))\n\nlargeNum = [randint(1,9)]\n\nfor i in range(1,1000):\n    largeNum.append(randint(0,9))\n\nmaxNum,minNum = 0,99999\n\nfor i in range(0,994):\n    num = int(\"\".join(map(str,largeNum[i:i+5])))\n    if num > maxNum:\n        maxNum = num\n    elif num < minNum:\n        minNum = num\n\nprint(\"Largest 5-adjacent number found \", maxNum)\nprint(\"Smallest 5-adjacent number found \", minNum)\n"}
{"id": 333680, "name": "Length of an arc between two angles", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse utf8;\nbinmode STDOUT, \":utf8\";\nuse POSIX 'fmod';\n\nuse constant \u03c0 => 2 * atan2(1, 0);\nuse constant \u03c4 => 2 * \u03c0;\n\nsub d2r { $_[0] * \u03c4 / 360 }\n\nsub arc {\n    my($a1, $a2, $r) = (d2r($_[0]), d2r($_[1]), $_[2]);\n    my @a = map { fmod( ($_ + \u03c4), \u03c4) } ($a1, $a2);\n    printf \"Arc length: %8.5f  Parameters: (%9.7f, %10.7f, %10.7f)\\n\",\n       (fmod(($a[0]-$a[1] + \u03c4), \u03c4) * $r), $a2, $a1, $r;\n}\n\narc(@$_) for\n    [ 10, 120,   10],\n    [ 10, 120,    1],\n    [120,  10,    1],\n    [-90, 180, 10/\u03c0],\n    [-90,   0, 10/\u03c0],\n    [ 90,   0, 10/\u03c0];\n", "target": "import math\n\ndef arc_length(r, angleA, angleB):\n    return (360.0 - abs(angleB - angleA)) * math.pi * r / 180.0\n"}
{"id": 333681, "name": "Last list item", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::AllUtils <min firstidx>;\n\nmy @list = <6 81 243 14 25 49 123 69 11>;\nsay \" Original @list\";\npush @list, get(min @list) + get(min @list) and say \"@list\" while @list > 1;\n\nsub get {\n    my($min) = @_;\n    splice @list, (firstidx { $min == $_ } @list), 1;\n    printf \" %3d \", $min;\n    $min;\n}\n", "target": "\n\ndef add_least_reduce(lis):\n    \n    while len(lis) > 1:\n        lis.append(lis.pop(lis.index(min(lis))) + lis.pop(lis.index(min(lis))))\n        print('Interim list:', lis)\n    return lis\n\nLIST = [6, 81, 243, 14, 25, 49, 123, 69, 11]\n\nprint(LIST, ' ==> ', add_least_reduce(LIST.copy()))\n"}
{"id": 333682, "name": "Shift list elements to left by 3", "source": "Translate Perl to Python: // 20210315 Perl programming solution\n\nuse strict;\nuse warnings;\n\nmy $n = 3;\nmy @list = 1..9;\n\npush @list, splice @list, 0, $n;\n\nprint join ' ', @list, \"\\n\"\n", "target": "def rotate(list, n):\n    for _ in range(n):\n        list.append(list.pop(0))\n\n    return list\n\n\n\ndef rotate(list, n):\n    k = (len(list) + n) % len(list)\n    return list[k::] + list[:k:]\n\n\nlist = [1,2,3,4,5,6,7,8,9]\nprint(list, \" => \", rotate(list, 3))\n"}
{"id": 333683, "name": "Numbers with same digit set in base 10 and base 16", "source": "Translate Perl to Python: use strict;\nno warnings;\nuse feature 'say';\n\nsub eqv { (join '', sort split '', $_[0]) eq (join '', sort split '', $_[1]) }\nsay join ' ', grep { eqv $_, sprintf '%x', $_ } 1..100_000;\n", "target": "col = 0\nfor i in range(100000):\n    if set(str(i)) == set(hex(i)[2:]):\n        col += 1\n        print(\"{:7}\".format(i), end='\\n'[:col % 10 == 0])\nprint()\n"}
{"id": 333684, "name": "Air mass", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say signatures>;\nno warnings 'experimental::signatures';\nuse List::Util 'max';\n\nuse constant PI  => 2*atan2(1,0);   \nuse constant DEG => PI/180;         \nuse constant RE  => 6371000;        \nuse constant dd  => 0.001;          \nuse constant FIN => 10000000;       \n\n\nsub rho ( $a ) {\n    exp( -$a / 8500 );\n}\n\nsub height ( $a, $z, $d ) {\n    \n    \n    \n    my $AA = RE + $a;\n    my $HH = sqrt $AA**2 + $d**2 - 2 * $d * $AA * cos( (180-$z)*DEG );\n    $HH - RE;\n}\n\n\nsub column_density ( $a, $z ) {\n    my $sum = 0;\n    my $d   = 0;\n    while ($d < FIN) {\n        my $delta = max(dd, dd * $d);  \n        $sum += rho(height($a, $z, $d + $delta/2))*$delta;\n        $d   += $delta;\n    }\n    $sum;\n}\n\nsub airmass ( $a, $z ) {\n    column_density($a, $z) / column_density($a, 0);\n}\n\nsay 'Angle     0 m              13700 m';\nsay '------------------------------------';\nfor my $z (map{ 5*$_ } 0..18) {\n    printf \"%2d      %11.8f      %11.8f\\n\", $z, airmass(0, $z), airmass(13700, $z);\n}\n", "target": "\n\nfrom math import sqrt, cos, exp\n\nDEG = 0.017453292519943295769236907684886127134  \nRE = 6371000                                     \ndd = 0.001      \nFIN = 10000000  \n \ndef rho(a):\n    \n    return exp(-a / 8500.0)\n \ndef height(a, z, d):\n     \n    return sqrt((RE + a)**2 + d**2 - 2 * d * (RE + a) * cos((180 - z) * DEG)) - RE\n \ndef column_density(a, z):\n    \n    dsum, d = 0.0, 0.0\n    while d < FIN:\n        delta = max(dd, (dd)*d)  \n        dsum += rho(height(a, z, d + 0.5 * delta)) * delta\n        d += delta\n    return dsum\n\ndef airmass(a, z):\n    return column_density(a, z) / column_density(a, 0)\n\nprint('Angle           0 m          13700 m\\n', '-' * 36)\nfor z in range(0, 91, 5):\n    print(f\"{z: 3d}      {airmass(0, z): 12.7f}    {airmass(13700, z): 12.7f}\")\n"}
{"id": 333685, "name": "Draw pixel 2", "source": "Translate Perl to Python: use Gtk3 '-init';\n\nmy $width  = 640;\nmy $height = 480;\n\nmy $window = Gtk3::Window->new();\n$window->set_default_size($width, $height);\n$window->set_border_width(10);\n$window->set_title(\"Draw Pixel 2\");\n$window->set_app_paintable(TRUE);\n\nmy $da = Gtk3::DrawingArea->new();\n$da->signal_connect('draw' => \\&draw_in_drawingarea);\n$window->add($da);\n$window->show_all();\n\nGtk3->main;\n\nsub draw_in_drawingarea\n{\n  my ($widget, $cr, $data) = @_;\n  $cr->set_source_rgb(1, 1, 0);\n  $cr->set_line_width(1);\n  $cr->rectangle( int rand $width , int rand $height, 1, 1);\n  $cr->stroke;\n}\n", "target": "import Tkinter,random\ndef draw_pixel_2 ( sizex=640,sizey=480 ):\n    pos  = random.randint( 0,sizex-1 ),random.randint( 0,sizey-1 )\n    root = Tkinter.Tk()\n    can  = Tkinter.Canvas( root,width=sizex,height=sizey,bg='black' )\n    can.create_rectangle( pos*2,outline='yellow' )\n    can.pack()\n    root.title('press ESCAPE to quit')\n    root.bind('<Escape>',lambda e : root.quit())\n    root.mainloop()\n\ndraw_pixel_2()\n"}
{"id": 333686, "name": "Four sides of square", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy $n = 5;\nsay join ' ', @$_ for ([(1)x$n], (map { [1, (0)x($n-2), 1] } 0..$n-3), [(1)x$n]);\n", "target": "size = 9\nfor row in range(size):\n    for col in range(size):\n        if row == 0 or row == size-1 or col == 0 or col == size-1:\n            print(\"1\", end=\" \")\n        else:\n            print(\"0\", end=\" \")\n    print()\n"}
{"id": 333687, "name": "Longest common suffix", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nsub lcs {\n    for (0..$\n    join '', reverse split '', (join(\"\\0\", @_) =~ /^ ([^\\0]*) [^\\0]* (?:\\0 \\1 [^\\0]*)* $/sx)[0];\n}\n\nfor my $words (\n  [ <Sunday Monday Tuesday Wednesday Thursday Friday Saturday> ],\n  [ <Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag dag> ],\n  [ 2347, 9312347, 'acx5g2347', 12.02347 ],\n  [ <longest common suffix> ],\n  [ ('one, Hey!', 'three, Hey!', 'ale, Hey!', 'me, Hey!') ],\n  [ 'suffix' ],\n  [ '' ]) {\n    say qq{'@$words' ==> '@{[lcs(@$words)]}';\n}\n", "target": "\n\nfrom itertools import takewhile\nfrom functools import reduce\n\n\n\ndef longestCommonSuffix(xs):\n    \n    def allSame(cs):\n        h = cs[0]\n        return all(h == c for c in cs[1:])\n\n    def firstCharPrepended(s, cs):\n        return cs[0] + s\n    return reduce(\n        firstCharPrepended,\n        takewhile(\n            allSame,\n            zip(*(reversed(x) for x in xs))\n        ),\n        ''\n    )\n\n\n\n\ndef main():\n    \n\n    samples = [\n        [\n            \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n            \"Thursday\", \"Friday\", \"Saturday\"\n        ], [\n            \"Sondag\", \"Maandag\", \"Dinsdag\", \"Woensdag\",\n            \"Donderdag\", \"Vrydag\", \"Saterdag\"\n        ]\n    ]\n    for xs in samples:\n        print(\n            longestCommonSuffix(xs)\n        )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333688, "name": "Distinct power numbers", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( uniq );\n\nprint join ', ', sort { $a <=> $b } uniq map { my $e = $_; map $_ ** $e, 2 .. 5} 2 .. 5;\n", "target": "from itertools import product\nprint(sorted(set(a**b for (a,b) in product(range(2,6), range(2,6)))))\n"}
{"id": 333689, "name": "Unique characters", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\nuse utf8;\nuse Unicode::Collate 'sort';\n\nmy %seen;\nbinmode(STDOUT, ':encoding(utf8)');\nmap { s/(\\X)/$seen{$1}++/egr } \n   \"133252abcdeeffd\", \"a6789798st\", \"yxcdfgxcyz\", \"A\u0410\u0391S\u00e4ao\u00f6\u0665\ud83e\udd14\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc67\";\nmy $uca = Unicode::Collate->new();\nprint $uca->sort ( grep { $seen{$_} == 1 } keys %seen )\n", "target": "\n\nfrom itertools import chain, groupby\n\n\n\ndef uniques(xs):\n    \n    return [\n        h for h, (_, *tail) in\n        groupby(sorted(chain(*xs)))\n        if not tail\n    ]\n\n\n\n\ndef main():\n    \n    print(\n        uniques([\n            \"133252abcdeeffd\",\n            \"a6789798st\",\n            \"yxcdfgxcyz\"\n        ])\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333690, "name": "Day of the week of Christmas and New Year", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse Time::Local;\n\nfor (\n  ['Christmas 2021', 25, 11, 2021 ],\n  ['New Years 2022', 1, 0, 2022 ],\n  )\n  {\n  print \"$_->[0] \", qw( Sunday Monday Tuesday Wednesday Thursday Fridat Saturday )\n    [(localtime timelocal(0, 0, 12, @{$_}[1..3]))[6]], \"\\n\";\n  }\n", "target": "import datetime\n\nweekDays = (\"Monday\",\"Tuesday\",\"Wednesday\",\"Thursday\",\"Friday\",\"Saturday\",\"Sunday\")\nthisXMas  = datetime.date(2021,12,25)\nthisXMasDay = thisXMas.weekday()\nthisXMasDayAsString = weekDays[thisXMasDay]\nprint(\"This year's Christmas is on a {}\".format(thisXMasDayAsString))\n\nnextNewYear = datetime.date(2022,1,1)\nnextNewYearDay = nextNewYear.weekday()\nnextNewYearDayAsString = weekDays[nextNewYearDay]\nprint(\"Next new year is on a {}\".format(nextNewYearDayAsString))\n"}
{"id": 333691, "name": "Here document", "source": "Translate Perl to Python: $address = <<END;\n1, High Street,\n$town_name,\nWest Midlands.\nWM4 5HD.\nEND\n", "target": "print()\n"}
{"id": 333692, "name": "Here document", "source": "Translate Perl to Python: $address = <<END;\n1, High Street,\n$town_name,\nWest Midlands.\nWM4 5HD.\nEND\n", "target": "print()\n"}
{"id": 333693, "name": "15 puzzle solver", "source": "Translate Perl to Python: use strict;\nno warnings;\n\nuse enum qw(False True);\nuse constant Nr => <3 0 0 0 0 1 1 1 1 2 2 2 2 3 3 3>;\nuse constant Nc => <3 0 1 2 3 0 1 2 3 0 1 2 3 0 1 2>;\n\nmy ($n, $m) = (0, 0);\nmy(@N0, @N2, @N3, @N4);\n\nsub fY {\n   printf \"Solution found in $n moves: %s\\n\", join('', @N3) and exit if $N2[$n] == 0x123456789abcdef0;\n   $N4[$n] <= $m ? fN() : False;\n}\n\nsub fN {\n   sub common { ++$n; return True if fY(); --$n }\n   if ($N3[$n] ne 'u' and int($N0[$n] / 4) < 3) { fI(); common() }\n   if ($N3[$n] ne 'd' and int($N0[$n] / 4) > 0) { fG(); common() }\n   if ($N3[$n] ne 'l' and    ($N0[$n] % 4) < 3) { fE(); common() }\n   if ($N3[$n] ne 'r' and    ($N0[$n] % 4) > 0) { fL(); common() }\n   return False;\n}\n\nsub fI {\n   my $g = (11-$N0[$n])*4;\n   my $a = $N2[$n] & (15 << $g);\n   $N0[$n+1] = $N0[$n]+4;\n   $N2[$n+1] = $N2[$n]-$a+($a<<16);\n   $N4[$n+1] = $N4[$n]+((Nr)[$a>>$g] <= int($N0[$n] / 4) ? 0 : 1);\n   $N3[$n+1] = 'd';\n}\n\nsub fG {\n   my $g = (19-$N0[$n])*4;\n   my $a = $N2[$n] & (15 << $g);\n   $N0[$n+1] = $N0[$n]-4;\n   $N2[$n+1] = $N2[$n]-$a+($a>>16);\n   $N4[$n+1] = $N4[$n]+((Nr)[$a>>$g] >= int($N0[$n] / 4) ? 0 : 1);\n   $N3[$n+1] = 'u';\n}\n\nsub fE {\n   my $g = (14-$N0[$n])*4;\n   my $a = $N2[$n] & (15 << $g);\n   $N0[$n+1] = $N0[$n]+1;\n   $N2[$n+1] = $N2[$n]-$a+($a<<4);\n   $N4[$n+1] = $N4[$n]+((Nc)[$a>>$g] <= $N0[$n]%4 ? 0 : 1);\n   $N3[$n+1] = 'r';\n}\n\nsub fL {\n   my $g = (16-$N0[$n])*4;\n   my $a = $N2[$n] & (15 << $g);\n   $N0[$n+1] = $N0[$n]-1;\n   $N2[$n+1] = $N2[$n]-$a+($a>>4);\n   $N4[$n+1] = $N4[$n]+((Nc)[$a>>$g] >= $N0[$n]%4 ? 0 : 1);\n   $N3[$n+1] = 'l';\n}\n\n($N0[0], $N2[0]) = (8, 0xfe169b4c0a73d852); \nwhile () { fY() or ++$m }\n", "target": "import random\n\n\nclass IDAStar:\n    def __init__(self, h, neighbours):\n        \n\n        self.h = h\n        self.neighbours = neighbours\n        self.FOUND = object()\n\n\n    def solve(self, root, is_goal, max_cost=None):\n        \n\n        self.is_goal = is_goal\n        self.path = [root]\n        self.is_in_path = {root}\n        self.path_descrs = []\n        self.nodes_evaluated = 0\n\n        bound = self.h(root)\n\n        while True:\n            t = self._search(0, bound)\n            if t is self.FOUND: return self.path, self.path_descrs, bound, self.nodes_evaluated\n            if t is None: return None\n            bound = t\n\n    def _search(self, g, bound):\n        self.nodes_evaluated += 1\n\n        node = self.path[-1]\n        f = g + self.h(node)\n        if f > bound: return f\n        if self.is_goal(node): return self.FOUND\n\n        m = None \n        for cost, n, descr in self.neighbours(node):\n            if n in self.is_in_path: continue\n\n            self.path.append(n)\n            self.is_in_path.add(n)\n            self.path_descrs.append(descr)\n            t = self._search(g + cost, bound)\n\n            if t == self.FOUND: return self.FOUND\n            if m is None or (t is not None and t < m): m = t\n\n            self.path.pop()\n            self.path_descrs.pop()\n            self.is_in_path.remove(n)\n\n        return m\n\n\ndef slide_solved_state(n):\n    return tuple(i % (n*n) for i in range(1, n*n+1))\n\ndef slide_randomize(p, neighbours):\n    for _ in range(len(p) ** 2):\n        _, p, _ = random.choice(list(neighbours(p)))\n    return p\n\ndef slide_neighbours(n):\n    movelist = []\n    for gap in range(n*n):\n        x, y = gap % n, gap // n\n        moves = []\n        if x > 0: moves.append(-1)    \n        if x < n-1: moves.append(+1)  \n        if y > 0: moves.append(-n)    \n        if y < n-1: moves.append(+n)  \n        movelist.append(moves)\n\n    def neighbours(p):\n        gap = p.index(0)\n        l = list(p)\n\n        for m in movelist[gap]:\n            l[gap] = l[gap + m]\n            l[gap + m] = 0\n            yield (1, tuple(l), (l[gap], m))\n            l[gap + m] = l[gap]\n            l[gap] = 0\n\n    return neighbours\n\ndef slide_print(p):\n    n = int(round(len(p) ** 0.5))\n    l = len(str(n*n))\n    for i in range(0, len(p), n):\n        print(\" \".join(\"{:>{}}\".format(x, l) for x in p[i:i+n]))\n\ndef encode_cfg(cfg, n):\n    r = 0\n    b = n.bit_length()\n    for i in range(len(cfg)):\n        r |= cfg[i] << (b*i)\n    return r\n\n\ndef gen_wd_table(n):\n    goal = [[0] * i + [n] + [0] * (n - 1 - i) for i in range(n)]\n    goal[-1][-1] = n - 1\n    goal = tuple(sum(goal, []))\n\n    table = {}\n    to_visit = [(goal, 0, n-1)]\n    while to_visit:\n        cfg, cost, e = to_visit.pop(0)\n        enccfg = encode_cfg(cfg, n)\n        if enccfg in table: continue\n        table[enccfg] = cost\n\n        for d in [-1, 1]:\n            if 0 <= e + d < n:\n                for c in range(n):\n                    if cfg[n*(e+d) + c] > 0:\n                        ncfg = list(cfg)\n                        ncfg[n*(e+d) + c] -= 1\n                        ncfg[n*e + c] += 1\n                        to_visit.append((tuple(ncfg), cost + 1, e+d))\n\n    return table\n\ndef slide_wd(n, goal):\n    wd = gen_wd_table(n)\n    goals = {i : goal.index(i) for i in goal}\n    b = n.bit_length()\n\n    def h(p):\n        ht = 0 \n        vt = 0 \n        d = 0\n        for i, c in enumerate(p):\n            if c == 0: continue\n            g = goals[c]\n            xi, yi = i % n, i // n\n            xg, yg = g % n, g // n\n            ht += 1 << (b*(n*yi+yg))\n            vt += 1 << (b*(n*xi+xg))\n\n            if yg == yi:\n                for k in range(i + 1, i - i%n + n): \n                    if p[k] and goals[p[k]] // n == yi and goals[p[k]] < g:\n                        d += 2\n\n            if xg == xi:\n                for k in range(i + n, n * n, n): \n                    if p[k] and goals[p[k]] % n == xi and goals[p[k]] < g:\n                        d += 2\n\n        d += wd[ht] + wd[vt]\n\n        return d\n    return h\n\n\n\n\nif __name__ == \"__main__\":\n    solved_state = slide_solved_state(4)\n    neighbours = slide_neighbours(4)\n    is_goal = lambda p: p == solved_state\n\n    tests = [\n        (15, 14, 1, 6, 9, 11, 4, 12, 0, 10, 7, 3, 13, 8, 5, 2),\n    ]\n\n    slide_solver = IDAStar(slide_wd(4, solved_state), neighbours)\n\n    for p in tests:\n        path, moves, cost, num_eval = slide_solver.solve(p, is_goal, 80)\n        slide_print(p)\n        print(\", \".join({-1: \"Left\", 1: \"Right\", -4: \"Up\", 4: \"Down\"}[move[1]] for move in moves))\n        print(cost, num_eval)\n"}
{"id": 333694, "name": "Base 16 numbers needing a to f", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nprint join( ' ', grep sprintf(\"%x\", $_) =~ tr/a-z//, 1 .. 500 ) =~\n  s/.{71}\\K /\\n/gr, \"\\n\";\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333695, "name": "Base 16 numbers needing a to f", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nprint join( ' ', grep sprintf(\"%x\", $_) =~ tr/a-z//, 1 .. 500 ) =~\n  s/.{71}\\K /\\n/gr, \"\\n\";\n", "target": "\n\n\n\ndef p(n):\n    \n    return 9 < n and (9 < n % 16 or p(n // 16))\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 1 + 500)\n        if p(n)\n    ]\n    print(f'{len(xs)} matches for the predicate:\\n')\n    print(\n        table(6)(xs)\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333696, "name": "Address of a variable", "source": "Translate Perl to Python: use Scalar::Util qw(refaddr);\nprint refaddr(\\my $v), \"\\n\";  \n", "target": "var num = 12\nvar pointer = ptr(num) \n\nprint pointer \n\n@unsafe \npointer.addr = 0xFFFE \n"}
{"id": 333697, "name": "Juggler sequence", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse Math::BigInt lib => 'GMP';\n\nprint \"       n  l(n) i(n)  h(n) or d(n)\\n\";\nprint \" -------  ---- ----  ------------\\n\";\nfor my $i ( 20 .. 39,\n  113, 173, 193, 2183, 11229, 15065, 15845, 30817,\n  48443, 275485, 1267909, 2264915, 5812827,\n  7110201  \n  )\n  {\n  my $max = my $n = Math::BigInt->new($i);\n  my $at = my $count = 0;\n  while( $n > 1 )\n    {\n    $n = sqrt( $n & 1 ? $n ** 3 : $n );\n    $count++;\n    $n > $max and ($max, $at) = ($n, $count);\n    }\n\n  if( length $max < 27 )\n    {\n    printf \"%8d  %4d  %3d  %s\\n\", $i, $count, $at, $max;\n    }\n  else\n    {\n    printf \"%8d  %4d  %3d  d(n) = %d digits\\n\", $i, $count, $at, length $max;\n    }\n  }\n", "target": "from math import isqrt\n\ndef juggler(k, countdig=True, maxiters=1000):\n    m, maxj, maxjpos = k, k, 0\n    for i in range(1, maxiters):\n        m = isqrt(m) if m % 2 == 0 else isqrt(m * m * m)\n        if m >= maxj:\n            maxj, maxjpos  = m, i\n        if m == 1:\n            print(f\"{k: 9}{i: 6,}{maxjpos: 6}{len(str(maxj)) if countdig else maxj: 20,}{' digits' if countdig else ''}\")\n            return i\n\n    print(\"ERROR: Juggler series starting with $k did not converge in $maxiters iterations\")\n\n\nprint(\"       n    l(n)  i(n)       h(n) or d(n)\\n-------------------------------------------\")\nfor k in range(20, 40):\n    juggler(k, False)\n\nfor k in [113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909]:\n    juggler(k)\n"}
{"id": 333698, "name": "Juggler sequence", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse Math::BigInt lib => 'GMP';\n\nprint \"       n  l(n) i(n)  h(n) or d(n)\\n\";\nprint \" -------  ---- ----  ------------\\n\";\nfor my $i ( 20 .. 39,\n  113, 173, 193, 2183, 11229, 15065, 15845, 30817,\n  48443, 275485, 1267909, 2264915, 5812827,\n  7110201  \n  )\n  {\n  my $max = my $n = Math::BigInt->new($i);\n  my $at = my $count = 0;\n  while( $n > 1 )\n    {\n    $n = sqrt( $n & 1 ? $n ** 3 : $n );\n    $count++;\n    $n > $max and ($max, $at) = ($n, $count);\n    }\n\n  if( length $max < 27 )\n    {\n    printf \"%8d  %4d  %3d  %s\\n\", $i, $count, $at, $max;\n    }\n  else\n    {\n    printf \"%8d  %4d  %3d  d(n) = %d digits\\n\", $i, $count, $at, length $max;\n    }\n  }\n", "target": "from math import isqrt\n\ndef juggler(k, countdig=True, maxiters=1000):\n    m, maxj, maxjpos = k, k, 0\n    for i in range(1, maxiters):\n        m = isqrt(m) if m % 2 == 0 else isqrt(m * m * m)\n        if m >= maxj:\n            maxj, maxjpos  = m, i\n        if m == 1:\n            print(f\"{k: 9}{i: 6,}{maxjpos: 6}{len(str(maxj)) if countdig else maxj: 20,}{' digits' if countdig else ''}\")\n            return i\n\n    print(\"ERROR: Juggler series starting with $k did not converge in $maxiters iterations\")\n\n\nprint(\"       n    l(n)  i(n)       h(n) or d(n)\\n-------------------------------------------\")\nfor k in range(20, 40):\n    juggler(k, False)\n\nfor k in [113, 173, 193, 2183, 11229, 15065, 15845, 30817, 48443, 275485, 1267909]:\n    juggler(k)\n"}
{"id": 333699, "name": "2048", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse Tk;\n\nmy $N = shift // 4;\n$N < 2 and $N = 2;\nmy @squares = 1 .. $N*$N;\nmy %n2ch = (' ' => ' ');\n@n2ch{ map 2**$_, 1..26} = 'a'..'z';\nmy %ch2n = reverse %n2ch;\nmy $winner = '';\nmy @arow = 0 .. $N - 1;\nmy @acol = map $_ * $N, @arow;\n\nmy $mw = MainWindow->new;\n$mw->geometry( '+300+0' );\n$mw->title( 2048 );\n$mw->focus;\n$mw->bind('<KeyPress-Left>' => sub { arrow($N, @arow) } );\n$mw->bind('<KeyPress-Right>' => sub { arrow($N, reverse @arow) } );\n$mw->bind('<KeyPress-Up>' => sub { arrow(1, @acol) } );\n$mw->bind('<KeyPress-Down>' => sub { arrow(1, reverse @acol) } );\nmy $grid = $mw->Frame()->pack;\nfor my $i ( 0 .. $\n  {\n  $grid->Label(-textvariable => \\$squares[$i],\n    -width => 5, -height => 2, -font => 'courierbold 30',\n    -relief => 'ridge', -borderwidth => 5,\n    )->grid(-row => int $i / $N, -column => $i % $N );\n  }\nmy $buttons = $mw->Frame()->pack(-fill => 'x', -expand => 1);\n$buttons->Button(-text => 'Exit', -command => sub {$mw->destroy},\n  -font => 'courierbold 14',\n  )->pack(-side => 'right');\n$buttons->Button(-text => 'New Game', -command => \\&newgame,\n  -font => 'courierbold 14',\n  )->pack(-side => 'left');\n$buttons->Label(-textvariable => \\$winner,\n  -font => 'courierbold 18', -fg => 'red2',\n  )->pack;\n\nnewgame();\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub losecheck\n  {\n  local $_ = join '', @n2ch{ @squares };\n  / / || ($_ ^ substr $_, $N) =~ tr/\\0// and return;\n  /(.)\\1/ and return for /.{$N}/g;\n  $winner = 'You Lost';\n  }\n\nsub arrow\n  {\n  $winner and return;                                   \n  my ($inc, @ix) = @_;\n  my $oldboard = \"@squares\";\n  for ( 1 .. $N )\n    {\n    local $_ = join '', @n2ch{ @squares[@ix] };         \n    tr/ //d;                                            \n    s/(\\w)\\1/ chr 1 + ord $1 /ge;                       \n    @squares[@ix] = @ch2n{ split //, $_ . ' ' x $N };   \n    $_ += $inc for @ix;                                 \n    }\n  $oldboard eq \"@squares\" and return;\n  add2();\n  losecheck();\n  grep $_ eq 2048, @squares and $winner = 'WINNER\u00a0!!';\n  }\n\nsub add2\n  {\n  my @blanks = grep $squares[$_] eq ' ', 0 .. $\n  @blanks and $squares[ $blanks[rand @blanks] ] =\n    $_[0] // (rand() < 0.1 ? 4 : 2);\n  }\n\nsub newgame\n  {\n  $_ = ' ' for @squares;\n  add2(2) for 1, 2;\n  $winner = '';\n  }\n", "target": "\n\nimport curses\nfrom random import randrange, choice \nfrom collections import defaultdict\n\nletter_codes = [ord(ch) for ch in 'WASDRQwasdrq']\nactions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']\nactions_dict = dict(zip(letter_codes, actions * 2))\n\ndef get_user_action(keyboard):    \n\tchar = \"N\"\n\twhile char not in actions_dict:    \n\t\tchar = keyboard.getch()\n\treturn actions_dict[char]\n\ndef transpose(field):\n\treturn [list(row) for row in zip(*field)]\n\ndef invert(field):\n\treturn [row[::-1] for row in field]\n\nclass GameField(object):\n\tdef __init__(self, height=4, width=4, win=2048):\n\t\tself.height = height\n\t\tself.width = width\n\t\tself.win_value = win\n\t\tself.score = 0\n\t\tself.highscore = 0\n\t\tself.reset()\n\n\tdef reset(self):\n\t\tif self.score > self.highscore:\n\t\t\tself.highscore = self.score\n\t\tself.score = 0\n\t\tself.field = [[0 for i in range(self.width)] for j in range(self.height)]\n\t\tself.spawn()\n\t\tself.spawn()\n\n\tdef move(self, direction):\n\t\tdef move_row_left(row):\n\t\t\tdef tighten(row): \n\t\t\t\tnew_row = [i for i in row if i != 0]\n\t\t\t\tnew_row += [0 for i in range(len(row) - len(new_row))]\n\t\t\t\treturn new_row\n\n\t\t\tdef merge(row):\n\t\t\t\tpair = False\n\t\t\t\tnew_row = []\n\t\t\t\tfor i in range(len(row)):\n\t\t\t\t\tif pair:\n\t\t\t\t\t\tnew_row.append(2 * row[i])\n\t\t\t\t\t\tself.score += 2 * row[i]\n\t\t\t\t\t\tpair = False\n\t\t\t\t\telse:\n\t\t\t\t\t\tif i + 1 < len(row) and row[i] == row[i + 1]:\n\t\t\t\t\t\t\tpair = True\n\t\t\t\t\t\t\tnew_row.append(0)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tnew_row.append(row[i])\n\t\t\t\tassert len(new_row) == len(row)\n\t\t\t\treturn new_row\n\t\t\treturn tighten(merge(tighten(row)))\n\n\t\tmoves = {}\n\t\tmoves['Left']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\t[move_row_left(row) for row in field]\n\t\tmoves['Right'] = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tinvert(moves['Left'](invert(field)))\n\t\tmoves['Up']    = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\ttranspose(moves['Left'](transpose(field)))\n\t\tmoves['Down']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\ttranspose(moves['Right'](transpose(field)))\n\n\t\tif direction in moves:\n\t\t\tif self.move_is_possible(direction):\n\t\t\t\tself.field = moves[direction](self.field)\n\t\t\t\tself.spawn()\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\n\tdef is_win(self):\n\t\treturn any(any(i >= self.win_value for i in row) for row in self.field)\n\n\tdef is_gameover(self):\n\t\treturn not any(self.move_is_possible(move) for move in actions)\n\n\tdef draw(self, screen):\n\t\thelp_string1 = '(W)Up (S)Down (A)Left (D)Right'\n\t\thelp_string2 = '     (R)Restart (Q)Exit'\n\t\tgameover_string = '           GAME OVER'\n\t\twin_string = '          YOU WIN!'\n\t\tdef cast(string):\n\t\t\tscreen.addstr(string + '\\n')\n\n\t\tdef draw_hor_separator():\n\t\t\ttop = '\u250c' + ('\u252c\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2510')[1:]\n\t\t\tmid = '\u251c' + ('\u253c\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2524')[1:]\n\t\t\tbot = '\u2514' + ('\u2534\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2518')[1:]\n\t\t\tseparator = defaultdict(lambda: mid)\n\t\t\tseparator[0], separator[self.height] = top, bot\n\t\t\tif not hasattr(draw_hor_separator, \"counter\"):\n\t\t\t\tdraw_hor_separator.counter = 0\n\t\t\tcast(separator[draw_hor_separator.counter])\n\t\t\tdraw_hor_separator.counter += 1\n\n\t\tdef draw_row(row):\n\t\t\tcast(''.join('\u2502{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '\u2502')\n\n\t\tscreen.clear()\n\t\tcast('SCORE: ' + str(self.score))\n\t\tif 0 != self.highscore:\n\t\t\tcast('HIGHSCORE: ' + str(self.highscore))\n\t\tfor row in self.field:\n\t\t\tdraw_hor_separator()\n\t\t\tdraw_row(row)\n\t\tdraw_hor_separator()\n\t\tif self.is_win():\n\t\t\tcast(win_string)\n\t\telse:\n\t\t\tif self.is_gameover():\n\t\t\t\tcast(gameover_string)\n\t\t\telse:\n\t\t\t\tcast(help_string1)\n\t\tcast(help_string2)\n\n\tdef spawn(self):\n\t\tnew_element = 4 if randrange(100) > 89 else 2\n\t\t(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])\n\t\tself.field[i][j] = new_element\n\n\tdef move_is_possible(self, direction):\n\t\tdef row_is_left_movable(row): \n\t\t\tdef change(i): \n\t\t\t\tif row[i] == 0 and row[i + 1] != 0: \n\t\t\t\t\treturn True\n\t\t\t\tif row[i] != 0 and row[i + 1] == row[i]: \n\t\t\t\t\treturn True\n\t\t\t\treturn False\n\t\t\treturn any(change(i) for i in range(len(row) - 1))\n\n\t\tcheck = {}\n\t\tcheck['Left']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tany(row_is_left_movable(row) for row in field)\n\n\t\tcheck['Right'] = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\t check['Left'](invert(field))\n\n\t\tcheck['Up']    = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tcheck['Left'](transpose(field))\n\n\t\tcheck['Down']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tcheck['Right'](transpose(field))\n\n\t\tif direction in check:\n\t\t\treturn check[direction](self.field)\n\t\telse:\n\t\t\treturn False\n\ndef main(stdscr):\n\tcurses.use_default_colors()\n\tgame_field = GameField(win=32)\n\tstate_actions = {} \n\tdef init():\n\t\tgame_field.reset()\n\t\treturn 'Game'\n\n\tstate_actions['Init'] = init\n\n\tdef not_game(state):\n\t\tgame_field.draw(stdscr)\n\t\taction = get_user_action(stdscr)\n\t\tresponses = defaultdict(lambda: state)\n\t\tresponses['Restart'], responses['Exit'] = 'Init', 'Exit'\n\t\treturn responses[action]\n\n\tstate_actions['Win'] = lambda: not_game('Win')\n\tstate_actions['Gameover'] = lambda: not_game('Gameover')\n\n\tdef game():\n\t\tgame_field.draw(stdscr)\n\t\taction = get_user_action(stdscr)\n\t\tif action == 'Restart':\n\t\t\treturn 'Init'\n\t\tif action == 'Exit':\n\t\t\treturn 'Exit'\n\t\tif game_field.move(action): \n\t\t\tif game_field.is_win():\n\t\t\t\treturn 'Win'\n\t\t\tif game_field.is_gameover():\n\t\t\t\treturn 'Gameover'\n\t\treturn 'Game'\n\t\t\n\tstate_actions['Game'] = game\n\n\tstate = 'Init'\n\twhile state != 'Exit':\n\t\tstate = state_actions[state]()\n\ncurses.wrapper(main)\n"}
{"id": 333700, "name": "Pig the dice game_Player", "source": "Translate Perl to Python: my $GOAL = 100;\n\npackage Player;\n\nsub new {\n    my ($class,$strategy) = @_;\n    my $self = {\n        score    => 0,\n        rolls    => 0,\n        ante     => 0,\n        strategy => $strategy || sub { 0 } \n    };\n    return bless($self, $class);\n}\n\nsub turn {\n    my ($P) = @_;\n    $P->{rolls} = 0;\n    $P->{ante}  = 0;\n    my $done    = 0;\n    do {\n        my $v = 1 + int rand 6;\n        $P->{rolls}++;\n        if ($v == 1) {\n            $P->{ante} = 0;\n            $done = 1;\n        } else {\n            $P->{ante} += $v;\n        }\n        $done = 1 if $P->{score} + $P->{ante} >= $GOAL or $P->{strategy}();\n    } until $done;\n    $P->{score} += $P->{ante};\n}\n\npackage Main;\n\n\n$players[0] = Player->new;\n\n\n$players[1] = Player->new( sub { $players[1]->{rolls} >= 5 } );\n\n\n@players[2] = Player->new( sub { $players[2]->{ante} > 20 } );\n\n\n$players[3] = Player->new( sub { rand() < 0.1 } );\n\n\n$players[4] = Player->new( sub { rand() < ( $GOAL - $players[4]->{score} ) * .6 / $GOAL } );\n\nfor (1 .. shift || 100) {\n    my $player = -1;\n    do {\n        $player++;\n        @players[$player % @players]->turn;\n    } until $players[$player % @players]->{score} >= $GOAL;\n\n    $wins[$player % @players]++;\n\n    printf \"%5d\", $players[$_]->{score} for 0..$\n    $players[$_]->{score} = 0 for 0..$\n}\n\nprint ' ----' x @players, \"\\n\";\nprintf \"%5d\", $_ for @wins; print \"\\n\";\n", "target": "\n\n\n\nfrom random import randint\nfrom collections import namedtuple\nimport random\nfrom pprint import pprint as pp\nfrom collections import Counter\n\n\nplayercount = 2\nmaxscore = 100\nmaxgames = 100000\n\n\nGame = namedtuple('Game', 'players, maxscore, rounds')\nRound = namedtuple('Round', 'who, start, scores, safe')\n\n\nclass Player():\n    def __init__(self, player_index):\n        self.player_index = player_index\n\n    def __repr__(self):\n        return '%s(%i)' % (self.__class__.__name__, self.player_index)\n\n    def __call__(self, safescore, scores, game):\n        'Returns boolean True to roll again'\n        pass\n\nclass RandPlay(Player):\n    def __call__(self, safe, scores, game):\n        'Returns random boolean choice of whether to roll again'\n        return bool(random.randint(0, 1))\n\nclass RollTo20(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and(sum(scores) < 20))                                  \n\nclass Desparat(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20 or someone is within 20 of winning'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and( (sum(scores) < 20)                                 \n                     or max(safe) >= (maxscore - 20)))                  \n\n\ndef game__str__(self):\n    'Pretty printer for Game class'\n    return (\"Game(players=%r, maxscore=%i,\\n  rounds=[\\n    %s\\n  ])\"\n            % (self.players, self.maxscore,\n               ',\\n    '.join(repr(round) for round in self.rounds)))\nGame.__str__ = game__str__\n\n\ndef winningorder(players, safescores):\n    'Return (players in winning order, their scores)'\n    return tuple(zip(*sorted(zip(players, safescores),\n                            key=lambda x: x[1], reverse=True)))\n\ndef playpig(game):\n    \n    players, maxscore, rounds = game\n    playercount = len(players)\n    safescore = [0] * playercount   \n    player = 0                      \n    scores=[]                       \n\n    while max(safescore) < maxscore:\n        startscore = safescore[player]\n        rolling = players[player](safescore, scores, game)\n        if rolling:\n            rolled = randint(1, 6)\n            scores.append(rolled)\n            if rolled == 1:\n                \n                round = Round(who=players[player],\n                              start=startscore,\n                              scores=scores,\n                              safe=safescore[player])\n                rounds.append(round)\n                scores, player = [], (player + 1) % playercount\n        else:\n            \n            safescore[player] += sum(scores)\n            round = Round(who=players[player],\n                          start=startscore,\n                          scores=scores,\n                          safe=safescore[player])\n            rounds.append(round)\n            if safescore[player] >= maxscore:\n                break\n            scores, player = [], (player + 1) % playercount\n\n    \n    return winningorder(players, safescore)\n\nif __name__ == '__main__':\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=20,\n                rounds=[])\n    print('ONE GAME')\n    print('Winning order: %r; Respective scores: %r\\n' % playpig(game))\n    print(game)\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=maxscore,\n                rounds=[])\n    algos = (RollTo20, RandPlay, Desparat)\n    print('\\n\\nMULTIPLE STATISTICS using %r\\n  for %i GAMES'\n          % (', '.join(p.__name__ for p in algos), maxgames,))\n    winners = Counter(repr(playpig(game._replace(players=tuple(random.choice(algos)(i)\n                                                               for i in range(playercount)),\n                                                 rounds=[]))[0])\n                      for i in range(maxgames))\n    print('  Players(position) winning on left; occurrences on right:\\n    %s'\n          % ',\\n    '.join(str(w) for w in winners.most_common()))\n"}
{"id": 333701, "name": "Pig the dice game_Player", "source": "Translate Perl to Python: my $GOAL = 100;\n\npackage Player;\n\nsub new {\n    my ($class,$strategy) = @_;\n    my $self = {\n        score    => 0,\n        rolls    => 0,\n        ante     => 0,\n        strategy => $strategy || sub { 0 } \n    };\n    return bless($self, $class);\n}\n\nsub turn {\n    my ($P) = @_;\n    $P->{rolls} = 0;\n    $P->{ante}  = 0;\n    my $done    = 0;\n    do {\n        my $v = 1 + int rand 6;\n        $P->{rolls}++;\n        if ($v == 1) {\n            $P->{ante} = 0;\n            $done = 1;\n        } else {\n            $P->{ante} += $v;\n        }\n        $done = 1 if $P->{score} + $P->{ante} >= $GOAL or $P->{strategy}();\n    } until $done;\n    $P->{score} += $P->{ante};\n}\n\npackage Main;\n\n\n$players[0] = Player->new;\n\n\n$players[1] = Player->new( sub { $players[1]->{rolls} >= 5 } );\n\n\n@players[2] = Player->new( sub { $players[2]->{ante} > 20 } );\n\n\n$players[3] = Player->new( sub { rand() < 0.1 } );\n\n\n$players[4] = Player->new( sub { rand() < ( $GOAL - $players[4]->{score} ) * .6 / $GOAL } );\n\nfor (1 .. shift || 100) {\n    my $player = -1;\n    do {\n        $player++;\n        @players[$player % @players]->turn;\n    } until $players[$player % @players]->{score} >= $GOAL;\n\n    $wins[$player % @players]++;\n\n    printf \"%5d\", $players[$_]->{score} for 0..$\n    $players[$_]->{score} = 0 for 0..$\n}\n\nprint ' ----' x @players, \"\\n\";\nprintf \"%5d\", $_ for @wins; print \"\\n\";\n", "target": "\n\n\n\nfrom random import randint\nfrom collections import namedtuple\nimport random\nfrom pprint import pprint as pp\nfrom collections import Counter\n\n\nplayercount = 2\nmaxscore = 100\nmaxgames = 100000\n\n\nGame = namedtuple('Game', 'players, maxscore, rounds')\nRound = namedtuple('Round', 'who, start, scores, safe')\n\n\nclass Player():\n    def __init__(self, player_index):\n        self.player_index = player_index\n\n    def __repr__(self):\n        return '%s(%i)' % (self.__class__.__name__, self.player_index)\n\n    def __call__(self, safescore, scores, game):\n        'Returns boolean True to roll again'\n        pass\n\nclass RandPlay(Player):\n    def __call__(self, safe, scores, game):\n        'Returns random boolean choice of whether to roll again'\n        return bool(random.randint(0, 1))\n\nclass RollTo20(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and(sum(scores) < 20))                                  \n\nclass Desparat(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20 or someone is within 20 of winning'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and( (sum(scores) < 20)                                 \n                     or max(safe) >= (maxscore - 20)))                  \n\n\ndef game__str__(self):\n    'Pretty printer for Game class'\n    return (\"Game(players=%r, maxscore=%i,\\n  rounds=[\\n    %s\\n  ])\"\n            % (self.players, self.maxscore,\n               ',\\n    '.join(repr(round) for round in self.rounds)))\nGame.__str__ = game__str__\n\n\ndef winningorder(players, safescores):\n    'Return (players in winning order, their scores)'\n    return tuple(zip(*sorted(zip(players, safescores),\n                            key=lambda x: x[1], reverse=True)))\n\ndef playpig(game):\n    \n    players, maxscore, rounds = game\n    playercount = len(players)\n    safescore = [0] * playercount   \n    player = 0                      \n    scores=[]                       \n\n    while max(safescore) < maxscore:\n        startscore = safescore[player]\n        rolling = players[player](safescore, scores, game)\n        if rolling:\n            rolled = randint(1, 6)\n            scores.append(rolled)\n            if rolled == 1:\n                \n                round = Round(who=players[player],\n                              start=startscore,\n                              scores=scores,\n                              safe=safescore[player])\n                rounds.append(round)\n                scores, player = [], (player + 1) % playercount\n        else:\n            \n            safescore[player] += sum(scores)\n            round = Round(who=players[player],\n                          start=startscore,\n                          scores=scores,\n                          safe=safescore[player])\n            rounds.append(round)\n            if safescore[player] >= maxscore:\n                break\n            scores, player = [], (player + 1) % playercount\n\n    \n    return winningorder(players, safescore)\n\nif __name__ == '__main__':\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=20,\n                rounds=[])\n    print('ONE GAME')\n    print('Winning order: %r; Respective scores: %r\\n' % playpig(game))\n    print(game)\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=maxscore,\n                rounds=[])\n    algos = (RollTo20, RandPlay, Desparat)\n    print('\\n\\nMULTIPLE STATISTICS using %r\\n  for %i GAMES'\n          % (', '.join(p.__name__ for p in algos), maxgames,))\n    winners = Counter(repr(playpig(game._replace(players=tuple(random.choice(algos)(i)\n                                                               for i in range(playercount)),\n                                                 rounds=[]))[0])\n                      for i in range(maxgames))\n    print('  Players(position) winning on left; occurrences on right:\\n    %s'\n          % ',\\n    '.join(str(w) for w in winners.most_common()))\n"}
{"id": 333702, "name": "Mastermind", "source": "Translate Perl to Python: use List::Util qw(any);\n\nprint 'Enter pool size, puzzle size, attempts allowed: '; \n($pool,$length,$tries) = split /\\s+/, <>;\n$length =  4 if $length eq '' or $length < 3 or $length > 11;\n$pool   =  6 if $pool   eq '' or $pool   < 2 or $pool   > 21;\n$tries  = 10 if $tries  eq '' or $tries  < 7 or $tries  > 21;\n\n@valid  = sort { -1 + 2*int(rand 2) } ('A' .. 'T')[0..$pool-1];\n@puzzle = @valid[0..$length-1];\n\n$black = '\u25cf';\n$white = '\u25cb';\n\nwhile () {\n    header();\n    print \"$_\\n\" for @guesses;\n    lose() if  @guesses == $tries;\n    @guess = get_guess();\n    next unless is_valid(@guess);\n    $score = score(\\@puzzle, \\@guess);\n    win() if $score eq join ' ', ($black) x $length;\n    push @guesses, join(' ', @guess) . '\u00a0:: ' . $score;\n}\n\nsub score {\n    local *puzzle = shift;\n    local *guess  = shift;\n    my @score;\n    for $i (0..$length-1) {\n        if    (     $puzzle[$i] eq $guess[$i]) { push @score, $black }\n        elsif (any {$puzzle[$i] eq $_} @guess) { push @score, $white }\n        else                                   { push @score, '-'    }\n    }\n    join ' ', reverse sort @score;\n}\n\nsub header {\n    $num = $tries - @guesses;\n    print  \"Valid letter, but wrong position: \u25cb - Correct letter and position: \u25cf\\n\";\n    print  \"Guess the $length element sequence containing the letters \" . join(', ', sort @valid) . \"\\n\";\n    printf \"Repeats are not allowed. You have $num guess%s remaining\\n\", $num > 1 ? 'es' : '';\n}\n\nsub get_guess { print 'Your guess?: '; $g = <>; return split /\\s*/, uc $g }\n\nsub is_valid { $length == @_ }\n\nsub win  { print 'You win! The correct answer is: ' . join(' ',@puzzle) . \"\\n\"; exit }\n\nsub lose { print 'Too bad, you ran out of guesses. The solution was: ' . join(' ',@puzzle) . \"\\n\"; exit }\n", "target": "import random\n\n\ndef encode(correct, guess):\n    output_arr = [''] * len(correct)\n\n    for i, (correct_char, guess_char) in enumerate(zip(correct, guess)):\n        output_arr[i] = 'X' if guess_char == correct_char else 'O' if guess_char in correct else '-'\n\n    return ''.join(output_arr)\n\n\ndef safe_int_input(prompt, min_val, max_val):\n    while True:\n        user_input = input(prompt)\n\n        try:\n            user_input = int(user_input)\n        except ValueError:\n            continue\n\n        if min_val <= user_input <= max_val:\n            return user_input\n\n\ndef play_game():\n    print(\"Welcome to Mastermind.\")\n    print(\"You will need to guess a random code.\")\n    print(\"For each guess, you will receive a hint.\")\n    print(\"In this hint, X denotes a correct letter, and O a letter in the original string but in a different position.\")\n    print()\n\n    number_of_letters = safe_int_input(\"Select a number of possible letters for the code (2-20): \", 2, 20)\n    code_length = safe_int_input(\"Select a length for the code (4-10): \", 4, 10)\n\n    letters = 'ABCDEFGHIJKLMNOPQRST'[:number_of_letters]\n    code = ''.join(random.choices(letters, k=code_length))\n    guesses = []\n\n    while True:\n        print()\n        guess = input(f\"Enter a guess of length {code_length} ({letters}): \").upper().strip()\n\n        if len(guess) != code_length or any([char not in letters for char in guess]):\n            continue\n        elif guess == code:\n            print(f\"\\nYour guess {guess} was correct!\")\n            break\n        else:\n            guesses.append(f\"{len(guesses)+1}: {' '.join(guess)} => {' '.join(encode(code, guess))}\")\n\n        for i_guess in guesses:\n            print(\"------------------------------------\")\n            print(i_guess)\n        print(\"------------------------------------\")\n\n\nif __name__ == '__main__':\n    play_game()\n"}
{"id": 333703, "name": "Fixed length records", "source": "Translate Perl to Python: open $in,  '<', 'flr-infile.dat';\nopen $out, '>', 'flr-outfile.dat';\n\nwhile ($n=sysread($in, $record, 80)) {   \n     syswrite $out, reverse $record;     \n     print reverse($record).\"\\n\"         \n}\nclose $out;\n", "target": "infile = open('infile.dat', 'rb')\noutfile = open('outfile.dat', 'wb')\n\nwhile True:\n    onerecord = infile.read(80)\n    if len(onerecord) < 80:\n        break\n    onerecordreversed = bytes(reversed(onerecord))\n    outfile.write(onerecordreversed)\n\ninfile.close()\noutfile.close()\n"}
{"id": 333704, "name": "Find words whose first and last three letters are equal", "source": "Translate Perl to Python: // 20210212 Perl programming solution\n\nperl -ne '/(?=^(.{3}).*\\1$)^.{6,}$/&&print' unixdict.txt\n\n\n\nperl -ne 's/(?=^(.{3}).*\\1$)^.{6,}$/print/e' unixdict.txt\n", "target": "import urllib.request\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\nfor word in wordList:\n    if len(word)>5 and word[:3].lower()==word[-3:].lower():\n        print(word)\n"}
{"id": 333705, "name": "Find words which contain the most consonants", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @most;\n@ARGV = 'unixdict.txt';\nlength > 11 and !/([^aeiou]).*\\1/ and $most[ tr/aeiou\\n//c ] .= $_ while <>;\n$most[$_] and printf \"%d Unique consonants, word count: %d\\n\\n%s\\n\\n\",\n  $_, $most[ $_ ] =~ tr/\\n//, $most[ $_ ] =~ tr/\\n/ /r =~ s/.{66}\\K /\\n/gr\n  for reverse 0 .. $\n", "target": "print('\\n'.join((f'{x[0]}: {\" \".join(sorted(x[1]))}' if len(x[1]) < 30 else f'{x[0]}: {len(x[1])} words' for x in\n      (x for x in ((n, [x[1] for x in l if x[0] == n]) for n in range(maxlen, -1, -1)) if x[1]))) if (maxlen := max(l := [(len(c), w)\n      for w in [l for l in [l.rstrip() for l in open('unixdict.txt')] if len(l) > 10 and all(c >= 'a' and c <= 'z' for c in l)]\n      if sorted(c := w.replace('a', '').replace('e', '').replace('i', '').replace('o', '').replace('u', '')) == sorted(set(c))])[0]) else None)\n"}
{"id": 333706, "name": "Find words which contains all the vowels", "source": "Translate Perl to Python: \n\nuse strict;\nuse warnings;\n\n@ARGV = 'unixdict.txt';\nlength > 11 and !/([aeiou]).*\\1/ and tr/aeiou// == 5 and print while <>;\n", "target": "import urllib.request\nfrom collections import Counter\n\nurllib.request.urlretrieve(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\", \"unixdict.txt\")\n\ndictionary = open(\"unixdict.txt\",\"r\")\n\nwordList = dictionary.read().split('\\n')\n\ndictionary.close()\n\nfor word in wordList:\n    if len(word)>10:\n        frequency = Counter(word.lower())\n        if frequency['a']==frequency['e']==frequency['i']==frequency['o']==frequency['u']==1:\n            print(word)\n"}
{"id": 333707, "name": "Modified random distribution", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'max';\n\nsub distribution {\n    my %param = ( function => \\&{scalar sub {return 1}}, sample_size => 1e5, @_);\n    my @values;\n    do {\n        my($r1, $r2) = (rand, rand);\n        push @values, $r1 if &{$param{function}}($r1) > $r2;\n    } until @values == $param{sample_size};\n    wantarray ? @values : \\@values;\n}\n\nsub modifier_notch {\n    my($x) = @_;\n    return 2 * ( $x < 1/2\u00a0? ( 1/2 - $x  )\n                          : ( $x  - 1/2 ) );\n}\n\nsub print_histogram {\n    our %param = (n_bins => 10, width => 80, @_);\n    my %counts;\n    $counts{ int($_ * $param{n_bins}) / $param{n_bins} }++ for @{$param{data}};\n    our $max_value = max values %counts;\n    print \"Bin  Counts  Histogram\\n\";\n    printf \"%4.2f %6d: %s\\n\", $_, $counts{$_}, hist($counts{$_}) for sort keys %counts;\n    sub hist { scalar ('\u25a0') x ( $param{width} * $_[0] / $max_value ) }\n}\n\nprint_histogram( data => \\@{ distribution() } );\nprint \"\\n\\n\";\n\nmy @samples = distribution( function => \\&modifier_notch, sample_size => 50_000);\nprint_histogram( data => \\@samples, n_bins => 20, width => 64);\n", "target": "import random\nfrom typing import List, Callable, Optional\n\n\ndef modifier(x: float) -> float:\n    \n    return 2*(.5 - x) if x < 0.5 else 2*(x - .5)\n\n\ndef modified_random_distribution(modifier: Callable[[float], float],\n                                 n: int) -> List[float]:\n    \n    d: List[float] = []\n    while len(d) < n:\n        r1 = prob = random.random()\n        if random.random() < modifier(prob):\n            d.append(r1)\n    return d\n\n\nif __name__ == '__main__':\n    from collections import Counter\n\n    data = modified_random_distribution(modifier, 50_000)\n    bins = 15\n    counts = Counter(d // (1 / bins) for d in data)\n    \n    mx = max(counts.values())\n    print(\"   BIN, COUNTS, DELTA: HISTOGRAM\\n\")\n    last: Optional[float] = None\n    for b, count in sorted(counts.items()):\n        delta = 'N/A' if last is None else str(count - last)\n        print(f\"  {b / bins:5.2f},  {count:4},  {delta:>4}: \"\n              f\"{'\n        last = count\n"}
{"id": 333708, "name": "Modified random distribution", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::Util 'max';\n\nsub distribution {\n    my %param = ( function => \\&{scalar sub {return 1}}, sample_size => 1e5, @_);\n    my @values;\n    do {\n        my($r1, $r2) = (rand, rand);\n        push @values, $r1 if &{$param{function}}($r1) > $r2;\n    } until @values == $param{sample_size};\n    wantarray ? @values : \\@values;\n}\n\nsub modifier_notch {\n    my($x) = @_;\n    return 2 * ( $x < 1/2\u00a0? ( 1/2 - $x  )\n                          : ( $x  - 1/2 ) );\n}\n\nsub print_histogram {\n    our %param = (n_bins => 10, width => 80, @_);\n    my %counts;\n    $counts{ int($_ * $param{n_bins}) / $param{n_bins} }++ for @{$param{data}};\n    our $max_value = max values %counts;\n    print \"Bin  Counts  Histogram\\n\";\n    printf \"%4.2f %6d: %s\\n\", $_, $counts{$_}, hist($counts{$_}) for sort keys %counts;\n    sub hist { scalar ('\u25a0') x ( $param{width} * $_[0] / $max_value ) }\n}\n\nprint_histogram( data => \\@{ distribution() } );\nprint \"\\n\\n\";\n\nmy @samples = distribution( function => \\&modifier_notch, sample_size => 50_000);\nprint_histogram( data => \\@samples, n_bins => 20, width => 64);\n", "target": "import random\nfrom typing import List, Callable, Optional\n\n\ndef modifier(x: float) -> float:\n    \n    return 2*(.5 - x) if x < 0.5 else 2*(x - .5)\n\n\ndef modified_random_distribution(modifier: Callable[[float], float],\n                                 n: int) -> List[float]:\n    \n    d: List[float] = []\n    while len(d) < n:\n        r1 = prob = random.random()\n        if random.random() < modifier(prob):\n            d.append(r1)\n    return d\n\n\nif __name__ == '__main__':\n    from collections import Counter\n\n    data = modified_random_distribution(modifier, 50_000)\n    bins = 15\n    counts = Counter(d // (1 / bins) for d in data)\n    \n    mx = max(counts.values())\n    print(\"   BIN, COUNTS, DELTA: HISTOGRAM\\n\")\n    last: Optional[float] = None\n    for b, count in sorted(counts.items()):\n        delta = 'N/A' if last is None else str(count - last)\n        print(f\"  {b / bins:5.2f},  {count:4},  {delta:>4}: \"\n              f\"{'\n        last = count\n"}
{"id": 333709, "name": "Common list elements", "source": "Translate Perl to Python: @nums = ([2,5,1,3,8,9,4,6], [3,5,6,2,9,8,4], [1,3,7,6,9]);\nmap { print \"$_ \" if @nums == ++$c{$_} } @$_ for @nums;\n", "target": "\n\ndef common_list_elements(*lists):\n    return list(set.intersection(*(set(list_) for list_ in lists)))\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([2, 5, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 9, 8, 4], [1, 3, 7, 6, 9]),\n        ([2, 2, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 2, 2, 4], [2, 3, 7, 6, 2]),\n    ]\n\n    for case in test_cases:\n        result = common_list_elements(*case)\n        print(f\"Intersection of {case} is {result}\")\n"}
{"id": 333710, "name": "Common list elements", "source": "Translate Perl to Python: @nums = ([2,5,1,3,8,9,4,6], [3,5,6,2,9,8,4], [1,3,7,6,9]);\nmap { print \"$_ \" if @nums == ++$c{$_} } @$_ for @nums;\n", "target": "\n\ndef common_list_elements(*lists):\n    return list(set.intersection(*(set(list_) for list_ in lists)))\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([2, 5, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 9, 8, 4], [1, 3, 7, 6, 9]),\n        ([2, 2, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 2, 2, 4], [2, 3, 7, 6, 2]),\n    ]\n\n    for case in test_cases:\n        result = common_list_elements(*case)\n        print(f\"Intersection of {case} is {result}\")\n"}
{"id": 333711, "name": "Maze solving", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\n\nmy ($width, $height) = @ARGV;\n$_ ||= 10 for $width, $height;\n\nmy %visited;\n\nmy $h_barrier = \"+\" . (\"--+\" x $width) . \"\\n\";\nmy $v_barrier = \"|\" . (\"  |\" x $width) . \"\\n\";\nmy @output = ($h_barrier, $v_barrier) x $height;\npush @output, $h_barrier;\nmy @dx = qw(-1 1 0 0);\nmy @dy = qw(0 0 -1 1);\n\nsub visit {\n   my ($x, $y) = @_;\n   $visited{$x, $y} = 1;\n   my $rand = int rand 4;\n   for my $n ( $rand .. 3, 0 .. $rand-1 ) {\n      my ($xx, $yy) = ($x + $dx[$n], $y + $dy[$n]);\n      next if $visited{ $xx, $yy };\n      next if $xx < 0 or $xx >= $width;\n      next if $yy < 0 or $yy >= $height;\n\n      my $row = $y * 2 + 1 + $dy[$n];\n      my $col = $x * 3 + 1 + $dx[$n];\n      substr( $output[$row], $col, 2, '  ' );\n\n      no warnings 'recursion';\n      visit( $xx, $yy );\n   }\n}\n\nvisit( int rand $width, int rand $height );\n\nprint \"Here is the maze:\\n\";\nprint @output;\n\n%visited = ();\n\nmy @d = ('>>', '<<', 'vv', '^^');\nsub solve {\n   my ($x, $y) = @_;\n   return 1 if $x == 0 and $y == 0;\n   $visited{ $x, $y } = 1;\n   my $rand = int rand 4;\n   for my $n ( $rand .. 3, 0 .. $rand-1 ) {\n      my ($xx, $yy) = ($x + $dx[$n], $y + $dy[$n]);\n      next if $visited{ $xx, $yy };\n      next if $xx < 0 or $xx >= $width;\n      next if $yy < 0 or $yy >= $height;\n\n      my $row = $y * 2 + 1 + $dy[$n];\n      my $col = $x * 3 + 1 + $dx[$n];\n\n      my $b = substr( $output[$row], $col, 2 );\n      next if \"  \" ne $b;\n\n      no warnings 'recursion';\n      next if not solve( $xx, $yy );\n\n      substr( $output[$row], $col, 2, $d[$n] );\n      substr( $output[$row-$dy[$n]], $col-$dx[$n], 2, $d[$n] );\n      return 1;\n   }\n   0;\n}\n\nif( solve( $width-1, $height-1 ) ) {\n   print \"Here is the solution:\\n\";\n   substr( $output[1], 1, 2, '**' );\n   print @output;\n} else {\n   print \"Could not solve!\\n\";\n}\n", "target": "\n\ndef Dijkstra(Graph, source):\n    \n    \n    infinity = float('infinity')\n    n = len(graph)\n    dist = [infinity]*n   \n    previous = [infinity]*n \n    dist[source] = 0        \n    Q = list(range(n)) \n    while Q:           \n        u = min(Q, key=lambda n:dist[n])                 \n        Q.remove(u)\n        if dist[u] == infinity:\n            break \n        for v in range(n):               \n            if Graph[u][v] and (v in Q): \n                alt = dist[u] + Graph[u][v]\n                if alt < dist[v]:       \n                    dist[v] = alt\n                    previous[v] = u\n    return dist,previous\n\ndef display_solution(predecessor):\n    cell = len(predecessor)-1\n    while cell:\n        print(cell,end='<')\n        cell = predecessor[cell]\n    print(0)\n"}
{"id": 333712, "name": "Deming's funnel", "source": "Translate Perl to Python: @dx = qw<\n    -0.533  0.270  0.859 -0.043 -0.205 -0.127 -0.071  0.275\n     1.251 -0.231 -0.401  0.269  0.491  0.951  1.150  0.001\n    -0.382  0.161  0.915  2.080 -2.337  0.034 -0.126  0.014\n     0.709  0.129 -1.093 -0.483 -1.193  0.020 -0.051  0.047\n    -0.095  0.695  0.340 -0.182  0.287  0.213 -0.423 -0.021\n    -0.134  1.798  0.021 -1.099 -0.361  1.636 -1.134  1.315\n     0.201  0.034  0.097 -0.170  0.054 -0.553 -0.024 -0.181\n    -0.700 -0.361 -0.789  0.279 -0.174 -0.009 -0.323 -0.658\n     0.348 -0.528  0.881  0.021 -0.853  0.157  0.648  1.774\n    -1.043  0.051  0.021  0.247 -0.310  0.171  0.000  0.106\n     0.024 -0.386  0.962  0.765 -0.125 -0.289  0.521  0.017\n     0.281 -0.749 -0.149 -2.436 -0.909  0.394 -0.113 -0.598\n     0.443 -0.521 -0.799  0.087>;\n\n@dy = qw<\n     0.136  0.717  0.459 -0.225  1.392  0.385  0.121 -0.395\n     0.490 -0.682 -0.065  0.242 -0.288  0.658  0.459  0.000\n     0.426  0.205 -0.765 -2.188 -0.742 -0.010  0.089  0.208\n     0.585  0.633 -0.444 -0.351 -1.087  0.199  0.701  0.096\n    -0.025 -0.868  1.051  0.157  0.216  0.162  0.249 -0.007\n     0.009  0.508 -0.790  0.723  0.881 -0.508  0.393 -0.226\n     0.710  0.038 -0.217  0.831  0.480  0.407  0.447 -0.295\n     1.126  0.380  0.549 -0.445 -0.046  0.428 -0.074  0.217\n    -0.822  0.491  1.347 -0.141  1.230 -0.044  0.079  0.219\n     0.698  0.275  0.056  0.031  0.421  0.064  0.721  0.104\n    -0.729  0.650 -1.103  0.154 -1.720  0.051 -0.385  0.477\n     1.537 -0.901  0.939 -0.411  0.341 -0.411  0.106  0.224\n    -0.947 -1.424 -0.542 -1.032>;\n\nsub mean   { my $s; $s += $_ for @_; $s / @_ }\nsub stddev { sqrt( mean(map { $_**2 } @_) - mean(@_)**2) }\n\n@rules = (\nsub { 0 },\nsub { -$_[1] },\nsub { -$_[0] - $_[1] },\nsub {  $_[0] + $_[1] }\n);\n\nfor (@rules) {\n    print \"Rule \" . ++$cnt . \"\\n\";\n\n    my @ddx; my $tx = 0;\n    for my $x (@dx) { push @ddx, $tx + $x; $tx = &$_($tx, $x) }\n    my @ddy; my $ty = 0;\n    for my $y (@dy) { push @ddy, $ty + $y; $ty = &$_($ty, $y) }\n\n    printf \"Mean    x, y  \u00a0: %7.4f %7.4f\\n\",   mean(@ddx),   mean(@ddy);\n    printf \"Std dev x, y  \u00a0: %7.4f %7.4f\\n\", stddev(@ddx), stddev(@ddy);\n}\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 333713, "name": "Deming's funnel", "source": "Translate Perl to Python: @dx = qw<\n    -0.533  0.270  0.859 -0.043 -0.205 -0.127 -0.071  0.275\n     1.251 -0.231 -0.401  0.269  0.491  0.951  1.150  0.001\n    -0.382  0.161  0.915  2.080 -2.337  0.034 -0.126  0.014\n     0.709  0.129 -1.093 -0.483 -1.193  0.020 -0.051  0.047\n    -0.095  0.695  0.340 -0.182  0.287  0.213 -0.423 -0.021\n    -0.134  1.798  0.021 -1.099 -0.361  1.636 -1.134  1.315\n     0.201  0.034  0.097 -0.170  0.054 -0.553 -0.024 -0.181\n    -0.700 -0.361 -0.789  0.279 -0.174 -0.009 -0.323 -0.658\n     0.348 -0.528  0.881  0.021 -0.853  0.157  0.648  1.774\n    -1.043  0.051  0.021  0.247 -0.310  0.171  0.000  0.106\n     0.024 -0.386  0.962  0.765 -0.125 -0.289  0.521  0.017\n     0.281 -0.749 -0.149 -2.436 -0.909  0.394 -0.113 -0.598\n     0.443 -0.521 -0.799  0.087>;\n\n@dy = qw<\n     0.136  0.717  0.459 -0.225  1.392  0.385  0.121 -0.395\n     0.490 -0.682 -0.065  0.242 -0.288  0.658  0.459  0.000\n     0.426  0.205 -0.765 -2.188 -0.742 -0.010  0.089  0.208\n     0.585  0.633 -0.444 -0.351 -1.087  0.199  0.701  0.096\n    -0.025 -0.868  1.051  0.157  0.216  0.162  0.249 -0.007\n     0.009  0.508 -0.790  0.723  0.881 -0.508  0.393 -0.226\n     0.710  0.038 -0.217  0.831  0.480  0.407  0.447 -0.295\n     1.126  0.380  0.549 -0.445 -0.046  0.428 -0.074  0.217\n    -0.822  0.491  1.347 -0.141  1.230 -0.044  0.079  0.219\n     0.698  0.275  0.056  0.031  0.421  0.064  0.721  0.104\n    -0.729  0.650 -1.103  0.154 -1.720  0.051 -0.385  0.477\n     1.537 -0.901  0.939 -0.411  0.341 -0.411  0.106  0.224\n    -0.947 -1.424 -0.542 -1.032>;\n\nsub mean   { my $s; $s += $_ for @_; $s / @_ }\nsub stddev { sqrt( mean(map { $_**2 } @_) - mean(@_)**2) }\n\n@rules = (\nsub { 0 },\nsub { -$_[1] },\nsub { -$_[0] - $_[1] },\nsub {  $_[0] + $_[1] }\n);\n\nfor (@rules) {\n    print \"Rule \" . ++$cnt . \"\\n\";\n\n    my @ddx; my $tx = 0;\n    for my $x (@dx) { push @ddx, $tx + $x; $tx = &$_($tx, $x) }\n    my @ddy; my $ty = 0;\n    for my $y (@dy) { push @ddy, $ty + $y; $ty = &$_($ty, $y) }\n\n    printf \"Mean    x, y  \u00a0: %7.4f %7.4f\\n\",   mean(@ddx),   mean(@ddy);\n    printf \"Std dev x, y  \u00a0: %7.4f %7.4f\\n\", stddev(@ddx), stddev(@ddy);\n}\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 333714, "name": "Hunt the Wumpus", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse List::Util qw( shuffle );\n$| = 1;\n\nmy %tunnels = qw(A BKT B ACL C BDM D CEN E DFO F EGP G FHQ H GIR I HJS\n  J IKT K AJL L BKM M CLN N DMO O ENP P FOQ Q GPR R HQS S IRT T AJS);\nmy ($you, $wumpus, $bat1, $bat2, $pit1, $pit2) = shuffle keys %tunnels;\nmy $arrows = 5;\nprint \"\\nTo shoot, enter a 's' and upper case letter of the desired tunnel.\nTo move, just enter the upper case letter of the desired tunnel.\\n\";\n\nwhile( 1 )\n  {\n  my @adj = split //, my $adj = $tunnels{$you};\n  print \"\\nYou are in room $you and see three tunnels: @adj\\n\";\n  $adj =~ /$bat1|$bat2/ and print \"You hear a rustling.\\n\";\n  $adj =~ /$pit1|$pit2/ and\n    print \"You feel a cold wind blowing from a nearby cavern.\\n\";\n  $adj =~ $wumpus and print \"You smell something terrible nearby.\\n\";\n  print \"(m)ove or (s)hoot (tunnel)\u00a0: \";\n  defined($_ = <>) or exit;\n  if( /s.*([$adj])/ ) \n    {\n    $1 eq $wumpus and exit !print \"\\nYou killed the Wumpus and won the game.\\n\";\n    $wumpus = substr $wumpus . $tunnels{$wumpus}, rand 4, 1;\n    $wumpus eq $you and die \"\\nYou were eaten by a Wumpus and lost the game.\\n\";\n    --$arrows or die \"\\nYou ran out of arrows and lost the game.\\n\";\n    }\n  elsif( /([$adj])/ ) \n    {\n    $you = $1;\n    $wumpus eq $you and die \"\\nYou were eaten by a Wumpus and lost the game.\\n\";\n    \"$pit1$pit2\" =~ $you and\n      die \"\\nYou fell into a bottomless pit and lost the game.\\n\";\n    \"$bat1$bat2\" =~ $you and (($you) = shuffle\n      grep !/$you|$wumpus|$pit1|$pit2|$bat1|$bat2/, keys %tunnels),\n      print \"\\nA giant bat has carried you to room $you.\\n\";\n    }\n  else { print \"I don't understand\u00a0:(\\n\"; }\n  }\n", "target": "import random\n\nclass WumpusGame(object):\n\n\n\tdef __init__(self, edges=[]):\n\t\t\n\t\t\n\t\tif edges:\n\t\t\tcave = {}\n\t\t\tN = max([edges[i][0] for i in range(len(edges))])\n\t\t\tfor i in range(N):\n\t\t\t\texits = [edge[1] for edge in edges if edge[0] == i]\n\t\t\t\tcave[i] = exits\n\n\t\t\n\t\telse:\n\t\t\tcave = {1: [2,3,4], 2: [1,5,6], 3: [1,7,8], 4: [1,9,10], 5:[2,9,11],\n\t\t\t\t6: [2,7,12], 7: [3,6,13], 8: [3,10,14], 9: [4,5,15], 10: [4,8,16], \n\t\t\t\t11: [5,12,17], 12: [6,11,18], 13: [7,14,18], 14: [8,13,19], \n\t\t\t\t15: [9,16,17], 16: [10,15,19], 17: [11,20,15], 18: [12,13,20], \n\t\t\t\t19: [14,16,20], 20: [17,18,19]}\n\n\t\tself.cave = cave\n\n\t\tself.threats = {}\n\n\t\tself.arrows = 5\n\n\t\tself.arrow_travel_distance = 5\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\tself.player_pos = -1\n\n\n\t\n\n\n\tdef get_safe_rooms(self):\n\t\t\n\t\treturn list(set(self.cave.keys()).difference(self.threats.keys()))\n\n\n\tdef populate_cave(self):\n\t\t\n\t\tfor threat in ['bat', 'bat', 'pit', 'pit', 'wumpus']:\n\t\t\tpos = random.choice(self.get_safe_rooms())\n\t\t\tself.threats[pos] = threat\n\t\tself.player_pos = random.choice(self.get_safe_rooms())\n\n\n\tdef breadth_first_search(self, source, target, max_depth=5):\n\t\t\n\t\t\n\t\tgraph = self.cave\n\t\tdepth = 0\n\n\t\tdef search(stack, visited, target, depth):\n\t\t\tif stack == []:\t\t\t\t\t\n\t\t\t\treturn False, -1\n\t\t\tif target in stack:\n\t\t\t\treturn True, depth\n\t\t\tvisited = visited + stack\n\t\t\tstack = list(set([graph[v][i] for v in stack for i in range(len(graph[v]))]).difference(visited))\n\t\t\tdepth += 1\n\t\t\tif depth > max_depth:\t\t\t\n\t\t\t\treturn False, depth\n\t\t\telse:\t\t\t\t\t\t\t\n\t\t\t\treturn search(stack, visited, target, depth)\n\n\t\treturn search([source], [], target, depth)\n\n\n\t\n\n\n\tdef print_warning(self, threat):\n\t\t\n\t\tif threat == 'bat':\n\t\t\tprint(\"You hear a rustling.\")\n\t\telif threat == 'pit':\n\t\t\tprint(\"You feel a cold wind blowing from a nearby cavern.\")\n\t\telif threat == 'wumpus':\n\t\t\tprint(\"You smell something terrible nearby.\")\n\n\n\tdef get_players_input(self):\n\t\t\n\t\twhile 1:\t\t\t\t\t\t\t\t\n\n\t\t\tinpt = input(\"Shoot or move (S-M)? \")\n\t\t\ttry:\t\t\t\t\t\t\t\t\n\t\t\t\tmode = str(inpt).lower()\n\t\t\t\tassert mode in ['s', 'm', 'q']\n\t\t\t\tbreak\n\t\t\texcept (ValueError, AssertionError):\n\t\t\t\tprint(\"This is not a valid action: pick 'S' to shoot and 'M' to move.\")\n\n\t\tif mode == 'q':\t\t\t\t\t\t\t\n\t\t\treturn 'q', 0\n\n\t\twhile 1:\t\t\t\t\t\t\t\t\n\n\t\t\tinpt = input(\"Where to? \")\n\t\t\ttry:\t\t\t\t\t\t\t\t\n\t\t\t\ttarget = int(inpt)\n\t\t\texcept ValueError:\n\t\t\t\tprint(\"This is not even a real number.\")\n\t\t\t\tcontinue\t\t\t\t\t\t\n\n\t\t\tif mode == 'm':\n\t\t\t\ttry:\t\t\t\t\t\t\t\n\t\t\t\t\tassert target in self.cave[self.player_pos]\n\t\t\t\t\tbreak\n\t\t\t\texcept AssertionError:\n\t\t\t\t\tprint(\"You cannot walk that far. Please use one of the tunnels.\")\n\n\t\t\telif mode == 's':\n\t\t\t\ttry:\t\t\t\t\t\t\t\n\t\t\t\t\tbfs = self.breadth_first_search(self.player_pos, target)\n\t\t\t\t\tassert bfs[0] == True\n\t\t\t\t\tbreak\n\t\t\t\texcept AssertionError:\n\t\t\t\t\tif bfs[1] == -1: \t\t\t\n\t\t\t\t\t\tprint(\"There is no room with this number in the cave. Your arrow travels randomly.\")\n\t\t\t\t\t\ttarget = random.choice(self.cave.keys())\n\t\t\t\t\tif bfs[1] > self.arrow_travel_distance:\t\t\t\t\n\t\t\t\t\t\tprint(\"Arrows aren't that croocked.\")\n\n\t\treturn mode, target\n\n\n\t\n\n\n\tdef enter_room(self, room_number):\n\t\t\t\n\t\tprint(\"Entering room {}...\".format(room_number))\n\t\t\n\t\tif self.threats.get(room_number) == 'bat':\n\t\t\t\n\t\t\tprint(\"You encounter a bat, it transports you to a random empty room.\")\n\t\t\tnew_pos = random.choice(self.get_safe_rooms())\n\t\t\treturn self.enter_room(new_pos)\n\t\telif self.threats.get(room_number) == 'wumpus':\n\t\t\tprint(\"Wumpus eats you.\")\n\t\t\treturn -1\n\t\telif self.threats.get(room_number) == 'pit':\n\t\t\tprint(\"You fall into a pit.\")\n\t\t\treturn -1\n\n\t\t\n\t\tfor i in self.cave[room_number]:\n\t\t\tself.print_warning(self.threats.get(i))\n\n\t\t\n\t\treturn room_number\n\n\n\tdef shoot_room(self, room_number):\n\t\t\n\t\tprint(\"Shooting an arrow into room {}...\".format(room_number))\n\t\t\n\t\tself.arrows -= 1\n\t\tthreat = self.threats.get(room_number)\n\t\tif threat in ['bat', 'wumpus']:\n\t\t\tdel self.threats[room_number]\t\t\n\t\t\tif threat == 'wumpus':\n\t\t\t\tprint(\"Hurra, you killed the wumpus!\")\n\t\t\t\treturn -1\n\t\t\telif threat == 'bat':\n\t\t\t\tprint(\"You killed a bat.\")\n\t\telif threat in ['pit', None]:\n\t\t\tprint(\"This arrow is lost.\")\n\t\t\n\t\t\n\t\tif self.arrows < 1:\t\t\n\t\t\tprint(\"Your quiver is empty.\")\n\t\t\treturn -1\n\n\t\t\n\t\tif random.random() < 0.75:\n\t\t\t\n\t\t\tfor room_number, threat in self.threats.items():\n\t\t\t\tif threat == 'wumpus':\n\t\t\t\t\twumpus_pos = room_number\t\t\t\t\t\n\t\t\tnew_pos = random.choice(list(set(self.cave[wumpus_pos]).difference(self.threats.keys())))\n\t\t\tdel self.threats[room_number]\n\t\t\tself.threats[new_pos] = 'wumpus'\t\t\t\n\t\t\tif new_pos == self.player_pos: \n\t\t\t\tprint(\"Wumpus enters your room and eats you!\")\n\t\t\t\treturn -1\n\n\t\treturn self.player_pos\n\n\t\t\n\tdef gameloop(self):\n\n\t\tprint(\"HUNT THE WUMPUS\")\n\t\tprint(\"===============\")\n\t\tprint()\n\t\tself.populate_cave()\n\t\tself.enter_room(self.player_pos)\n\n\t\twhile 1:\n\n\t\t\t\n\t\t\t\n\t\t\t\n\n\t\t\tprint(\"You are in room {}.\".format(self.player_pos), end=\" \")\n\t\t\tprint(\"Tunnels lead to:  {0}  {1}  {2}\".format(*self.cave[self.player_pos]))\n\t\t\t\n\t\t\t\n\t\t\tinpt = self.get_players_input()\t\t\n\t\t\tprint()\t\t\t\t\t\t\t\t\n\t\t\tif inpt[0] == 'm':\t\t\t\t\t\n\t\t\t\ttarget = inpt[1] \n\t\t\t\tself.player_pos = self.enter_room(target)\n\t\t\telif inpt[0] == 's':\t\t\t\t\n\t\t\t\ttarget = inpt[1]\n\t\t\t\tself.player_pos = self.shoot_room(target)\n\t\t\telif inpt[0] == 'q':\t\t\t\t\n\t\t\t\tself.player_pos = -1\n\n\t\t\tif self.player_pos == -1:\t\t\t\n\t\t\t\tbreak\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\tprint()\n\t\tprint(\"Game over!\")\t\n\t\t\n\nif __name__ == '__main__':\t\t\t\t\t\t\n\t\n\t\n\t\n\t\n\n\t\n\n\tWG = WumpusGame()\n\tWG.gameloop()\n"}
{"id": 333715, "name": "MD5_Implementation", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse integer;\nuse Test::More;\n\nBEGIN { plan tests => 7 }\n\nsub A()   { 0x67_45_23_01 }\nsub B()   { 0xef_cd_ab_89 }\nsub C()   { 0x98_ba_dc_fe }\nsub D()   { 0x10_32_54_76 }\nsub MAX() { 0xFFFFFFFF }\n\nsub padding {\n    my $l = length (my $msg = shift() . chr(128));\n    $msg .= \"\\0\" x (($l%64<=56?56:120)-$l%64);\n    $l = ($l-1)*8;\n    $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);\n}\n\nsub rotate_left {\n    ($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));\n}\n\nsub gen_code {\n  \n  my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';\n  my %f = (\n    FF => \"X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    GG => \"X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    HH => \"X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    II => \"X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n  );\n\n  my %s = (  \n    S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,\n    S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,\n    S43 => 15, S44 => 21\n  );\n\n  my $insert = \"\\n\";\n  while(defined( my $data = <DATA> )) {\n    chomp $data;\n    next unless $data =~ /^[FGHI]/;\n    my ($func,@x) = split /,/, $data;\n    my $c = $f{$func};\n    $c =~ s/X(\\d)/$x[$1]/g;\n    $c =~ s/(S\\d{2})/$s{$1}/;\n    $c =~ s/^(.*)=rotate_left\\((.*),(.*)\\)\\+(.*)$//;\n\n    my $su = 32 - $3;\n    my $sh = (1 << $3) - 1;\n\n    $c = \"$1=(((\\$r=$2)<<$3)|((\\$r>>$su)&$sh))+$4\";\n\n    $insert .= \"\\t$c\\n\";\n  }\n  close DATA;\n\n  my $dump = '\n  sub round {\n    my ($a,$b,$c,$d) = @_[0 .. 3];\n    my $r;' . $insert . '\n    $_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK .\n    ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';\n  }';\n  eval $dump;\n}\n\ngen_code();\n\nsub _encode_hex { unpack 'H*', $_[0] }\n\nsub md5 {\n    my $message = padding(join'',@_);\n    my ($a,$b,$c,$d) = (A,B,C,D);\n    my $i;\n    for $i (0 .. (length $message)/64-1) {\n        my @X = unpack 'V16', substr $message,$i*64,64;\n        ($a,$b,$c,$d) = round($a,$b,$c,$d,@X);\n    }\n    pack 'V4',$a,$b,$c,$d;\n}\n\nmy $strings = {\n    'd41d8cd98f00b204e9800998ecf8427e' => '',\n    '0cc175b9c0f1b6a831c399e269772661' => 'a',\n    '900150983cd24fb0d6963f7d28e17f72' => 'abc',\n    'f96b697d7cb7938d525a2f31aaf161d0' => 'message digest',\n    'c3fcd3d76192e4007dfb496cca67e13b' => 'abcdefghijklmnopqrstuvwxyz',\n    'd174ab98d277d9f5a5611c2c9f419d9f' => 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',\n    '57edf4a22be3c955ac49da2e2107b67a' => '12345678901234567890123456789012345678901234567890123456789012345678901234567890',\n};\n\nfor my $k (keys %$strings) {\n    my $digest = _encode_hex md5($strings->{$k});\n    is($digest, $k, \"$digest is MD5 digest $strings->{$k}\");\n}\n\n", "target": "import math\n\nrotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n                  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n                  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n                  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]\n\nconstants = [int(abs(math.sin(i+1)) * 2**32) & 0xFFFFFFFF for i in range(64)]\n\ninit_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\nfunctions = 16*[lambda b, c, d: (b & c) | (~b & d)] + \\\n            16*[lambda b, c, d: (d & b) | (~d & c)] + \\\n            16*[lambda b, c, d: b ^ c ^ d] + \\\n            16*[lambda b, c, d: c ^ (b | ~d)]\n\nindex_functions = 16*[lambda i: i] + \\\n                  16*[lambda i: (5*i + 1)%16] + \\\n                  16*[lambda i: (3*i + 5)%16] + \\\n                  16*[lambda i: (7*i)%16]\n\ndef left_rotate(x, amount):\n    x &= 0xFFFFFFFF\n    return ((x<<amount) | (x>>(32-amount))) & 0xFFFFFFFF\n\ndef md5(message):\n\n    message = bytearray(message) \n    orig_len_in_bits = (8 * len(message)) & 0xffffffffffffffff\n    message.append(0x80)\n    while len(message)%64 != 56:\n        message.append(0)\n    message += orig_len_in_bits.to_bytes(8, byteorder='little')\n\n    hash_pieces = init_values[:]\n\n    for chunk_ofst in range(0, len(message), 64):\n        a, b, c, d = hash_pieces\n        chunk = message[chunk_ofst:chunk_ofst+64]\n        for i in range(64):\n            f = functions[i](b, c, d)\n            g = index_functions[i](i)\n            to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder='little')\n            new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) & 0xFFFFFFFF\n            a, b, c, d = d, new_b, b, c\n        for i, val in enumerate([a, b, c, d]):\n            hash_pieces[i] += val\n            hash_pieces[i] &= 0xFFFFFFFF\n    \n    return sum(x<<(32*i) for i, x in enumerate(hash_pieces))\n        \ndef md5_to_hex(digest):\n    raw = digest.to_bytes(16, byteorder='little')\n    return '{:032x}'.format(int.from_bytes(raw, byteorder='big'))\n\nif __name__=='__main__':\n    demo = [b\"\", b\"a\", b\"abc\", b\"message digest\", b\"abcdefghijklmnopqrstuvwxyz\",\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"]\n    for message in demo:\n        print(md5_to_hex(md5(message)),' <= \"',message.decode('ascii'),'\"', sep='')\n"}
{"id": 333716, "name": "Exponentiation with infix operators in (or operating on) the base", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Sub::Infix;\n\nBEGIN { *e = infix { $_[0] ** $_[1] } }; \n\nmy @eqns = ('1 + -$xOP$p', '1 + (-$x)OP$p', '1 + (-($x)OP$p)', '(1 + -$x)OP$p', '1 + -($xOP$p)');\n\nfor my $op ('**', '/e/', '|e|') {\n    for ( [-5, 2], [-5, 3], [5, 2], [5, 3] ) {\n        my( $x, $p, $eqn ) = @$_;\n        printf 'x: %2d p: %2d |', $x, $p;\n        $eqn = s/OP/$op/gr and printf '%17s %4d |', $eqn, eval $eqn for @eqns;\n        print \"\\n\";\n    }\n    print \"\\n\";\n}\n", "target": "from itertools import product\n\nxx = '-5 +5'.split()\npp = '2 3'.split()\ntexts = '-x**p -(x)**p (-x)**p -(x**p)'.split()\n\nprint('Integer variable exponentiation')\nfor x, p in product(xx, pp):\n    print(f'  x,p = {x:2},{p}; ', end=' ')\n    x, p = int(x), int(p)\n    print('; '.join(f\"{t} =={eval(t):4}\" for t in texts))\n\nprint('\\nBonus integer literal exponentiation')\nX, P = 'xp'\nxx.insert(0, ' 5')\ntexts.insert(0, 'x**p')\nfor x, p in product(xx, pp):\n    texts2 = [t.replace(X, x).replace(P, p) for t in texts]\n    print(' ', '; '.join(f\"{t2} =={eval(t2):4}\" for t2 in texts2))\n"}
{"id": 333717, "name": "Exponentiation with infix operators in (or operating on) the base", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Sub::Infix;\n\nBEGIN { *e = infix { $_[0] ** $_[1] } }; \n\nmy @eqns = ('1 + -$xOP$p', '1 + (-$x)OP$p', '1 + (-($x)OP$p)', '(1 + -$x)OP$p', '1 + -($xOP$p)');\n\nfor my $op ('**', '/e/', '|e|') {\n    for ( [-5, 2], [-5, 3], [5, 2], [5, 3] ) {\n        my( $x, $p, $eqn ) = @$_;\n        printf 'x: %2d p: %2d |', $x, $p;\n        $eqn = s/OP/$op/gr and printf '%17s %4d |', $eqn, eval $eqn for @eqns;\n        print \"\\n\";\n    }\n    print \"\\n\";\n}\n", "target": "from itertools import product\n\nxx = '-5 +5'.split()\npp = '2 3'.split()\ntexts = '-x**p -(x)**p (-x)**p -(x**p)'.split()\n\nprint('Integer variable exponentiation')\nfor x, p in product(xx, pp):\n    print(f'  x,p = {x:2},{p}; ', end=' ')\n    x, p = int(x), int(p)\n    print('; '.join(f\"{t} =={eval(t):4}\" for t in texts))\n\nprint('\\nBonus integer literal exponentiation')\nX, P = 'xp'\nxx.insert(0, ' 5')\ntexts.insert(0, 'x**p')\nfor x, p in product(xx, pp):\n    texts2 = [t.replace(X, x).replace(P, p) for t in texts]\n    print(' ', '; '.join(f\"{t2} =={eval(t2):4}\" for t2 in texts2))\n"}
{"id": 333718, "name": "Set right-adjacent bits", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'bitwise';\n\nwhile( <DATA> ) {\n    my ($n, $input) = split;\n    my $width = length $input;\n    my $result = '';\n    $result |.= substr 0 x $_ . $input, 0, $width for 0..$n;\n    print \"n = $n  width = $width\\n input $input\\nresult $result\\n\\n\";\n}\n\n", "target": "from operator import or_\nfrom functools import reduce\n\ndef set_right_adjacent_bits(n: int, b: int) -> int:\n    return reduce(or_, (b >> x for x in range(n+1)), 0)\n\n\nif __name__ == \"__main__\":\n    print(\"SAME n & Width.\\n\")\n    n = 2  \n    bits = \"1000 0100 0010 0000\"\n    first = True\n    for b_str in bits.split():\n        b = int(b_str, 2)\n        e = len(b_str)\n        if first:\n            first = False\n            print(f\"n = {n}; Width e = {e}:\\n\")\n        result = set_right_adjacent_bits(n, b)\n        print(f\"     Input b: {b:0{e}b}\")\n        print(f\"      Result: {result:0{e}b}\\n\")\n        \n    print(\"SAME Input & Width.\\n\")\n    \n    bits = '01' + '1'.join('0'*x for x in range(10, 0, -1))\n    for n in range(4):\n        first = True\n        for b_str in bits.split():\n            b = int(b_str, 2)\n            e = len(b_str)\n            if first:\n                first = False\n                print(f\"n = {n}; Width e = {e}:\\n\")\n            result = set_right_adjacent_bits(n, b)\n            print(f\"     Input b: {b:0{e}b}\")\n            print(f\"      Result: {result:0{e}b}\\n\")\n"}
{"id": 333719, "name": "History variables", "source": "Translate Perl to Python: package History;\n\nsub TIESCALAR {\n\tmy $cls = shift;\n\tmy $cur_val = shift;\n\treturn bless [];\n}\n\nsub FETCH {\n\treturn shift->[-1]\n}\n\nsub STORE {\n\tmy ($var, $val) = @_;\n\tpush @$var, $val;\n\treturn $val;\n}\n\nsub get(\\$) { @{tied ${+shift}} }\nsub on(\\$) { tie ${+shift}, __PACKAGE__ } \nsub off(\\$) { untie ${+shift} }\nsub undo(\\$) { pop @{tied ${+shift}} }\n\npackage main;\n\nmy $x = 0;\nHistory::on($x);\n\nfor (\"a\" .. \"d\") { $x = $_ }\n\nprint \"History: @{[History::get($x)]}\\n\";\n\nfor (1 .. 3) {\n\tprint \"undo $_, \";\n\tHistory::undo($x);\n\tprint \"current value: $x\\n\";\n}\n\nHistory::off($x);\nprint \"\\$x is: $x\\n\";\n", "target": "import sys\n\nHIST = {}\n\ndef trace(frame, event, arg):\n    for name,val in frame.f_locals.items():\n        if name not in HIST:\n            HIST[name] = []\n        else:\n            if HIST[name][-1] is val:\n                continue\n        HIST[name].append(val)\n    return trace\n\ndef undo(name):\n    HIST[name].pop(-1)\n    return HIST[name][-1]\n\ndef main():\n    a = 10\n    a = 20\n\n    for i in range(5):\n        c = i\n\n    print \"c:\", c, \"-> undo x3 ->\",\n    c = undo('c')\n    c = undo('c')\n    c = undo('c')\n    print c\n    print 'HIST:', HIST\n\nsys.settrace(trace)\nmain()\n"}
{"id": 333720, "name": "Bioinformatics_Subsequence", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @bases = <A C G T>;\nmy $basecnt = 160;\n\nmy($string,$target);\n$string .= $bases[ int rand @bases ] for 1 .. $basecnt;\n$target .= $bases[ int rand @bases ] for 1 .. 4;\nsay \"Target: $target\";\nsay 'Matches at these positions:';\nsay (($string =~ s/.{1,40}\\K/\\n/gr) =~ s/($target)/ >$1< /gr);\n", "target": " \nfrom random import choice\nimport regex as re \nimport time\n\ndef generate_sequence(n: int ) -> str:\n    return \"\".join([ choice(['A','C','G','T']) for _ in range(n) ])\n\ndef dna_findall(needle: str, haystack: str) -> None:\n\n    if sum(1 for _ in re.finditer(needle, haystack, overlapped=True)) == 0:\n        print(\"No matches found\")\n    else:\n        print(f\"Found {needle} at the following indices: \")\n        for match in re.finditer(needle, haystack, overlapped=True):\n            print(f\"{match.start()}:{match.end()} \")\n\ndna_seq = generate_sequence(200)\nsample_seq = generate_sequence(4)\n\nc = 1\nfor i in dna_seq:\n    print(i, end=\"\") if c % 20 != 0 else print(f\"{i}\")\n    c += 1\nprint(f\"\\nSearch Sample: {sample_seq}\")\n\ndna_findall(sample_seq, dna_seq)\n"}
{"id": 333721, "name": "Reverse the order of lines in a text file while preserving the contents of each line", "source": "Translate Perl to Python: // 20210803 Perl programming solution\n\n< input.txt perl -e 'print reverse <>'\n", "target": "\n\nimport sys\n\nif len(sys.argv)!=2:\n    print(\"Usage\u00a0: python \" + sys.argv[0] + \" <filename>\")\n    exit()\n\ndataFile = open(sys.argv[1],\"r\")\n\nfileData = dataFile.read().split('\\n')\n\ndataFile.close()\n\n[print(i) for i in fileData[::-1]]\n"}
{"id": 333722, "name": "Simple turtle graphics", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\nuse Tk;\nuse List::Util qw( max );\n\nmy $c; \n\n\n\nmy $pen = 1; \nmy @location = (0, 0); \nmy $direction = 0; \nmy @stack;\nmy $radian = 180 / atan2 0, -1;\nsub dsin { sin $_[0] / $radian }\nsub dcos { cos $_[0] / $radian }\nsub save { push @stack, [ $direction, @location ] }\nsub restore { ($direction, @location) = @{ pop @stack } }\nsub turn { $direction += shift }\nsub right { turn shift }\nsub left { turn -shift }\nsub forward\n  {\n  my $x = $location[0] + $_[0] * dcos $direction;\n  my $y = $location[1] + $_[0] * dsin $direction;\n  $pen and $c->createLine( @location, $x, $y, -width => 3 );\n  @location = ($x, $y);\n  }\nsub back { turn 180; forward shift; turn 180 }\nsub penup { $pen = 0 }\nsub pendown { $pen = 1 }\nsub text { $c->createText( @location, -text => shift ) }\n\n\n\nmy $mw = MainWindow->new;\n$c = $mw->Canvas(\n  -width => 900, -height => 900,\n  )->pack;\n$mw->Button(-text => 'Exit', -command => sub {$mw->destroy},\n  )->pack(-fill => 'x');\n$mw->after(0, \\&run);\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub box\n  {\n  my ($w, $h) = @_;\n  for (1 .. 2)\n    {\n    forward $w;\n    left 90;\n    forward $h;\n    left 90;\n    }\n  }\n\nsub house\n  {\n  my $size = shift;\n  box $size, $size;\n  right 90;\n  for ( 1 .. 3 )\n    {\n    right 120;\n    forward $size;\n    }\n  penup;\n  left 90;\n  forward $size;\n  left 90;\n  save;\n  forward $size * 1 / 4;\n  pendown;\n  box $size / 4, $size / 2;\n  penup;\n  forward $size * 3 / 8;\n  left 90;\n  forward $size / 4;\n  right 90;\n  pendown;\n  box $size / 4, $size / 4;\n  penup;\n  restore;\n  save;\n  forward $size / 2;\n  left 90;\n  forward $size + 40;\n  right 90;\n  pendown;\n  for (1 .. 8)\n    {\n    forward 15;\n    left 45;\n    forward 15;\n    }\n  restore;\n  penup;\n  }\n\nsub graph\n  {\n  save;\n  my $size = shift;\n  my $width = $size / @_;\n  my $hscale = $size / max @_;\n  for ( @_ )\n    {\n    box $width, $hscale * $_;\n    save;\n    penup;\n    forward $width / 2;\n    left 90;\n    forward 10;\n    text $_;\n    pendown;\n    restore;\n    forward $width;\n    }\n  restore;\n  }\n\nsub run\n  {\n  penup;\n  forward 50;\n  right 90;\n  forward 400;\n  pendown;\n  house(300);\n  penup;\n  forward 400;\n  pendown;\n  graph( 400, 2,7,4,5,1,8,6 );\n  }\n", "target": "from turtle import *\n\ndef rectangle(width, height):\n    for _ in range(2):\n        forward(height)\n        left(90)\n        forward(width)\n        left(90)\n \ndef square(size):\n    rectangle(size, size)\n\ndef triangle(size):\n    for _ in range(3):\n        forward(size)\n        right(120)\n    \ndef house(size):\n    right(180)\n    square(size)\n    triangle(size)\n    right(180)\n    \ndef barchart(lst, size):\n    scale = size/max(lst)\n    width = size/len(lst)\n    for i in lst:\n        rectangle(i*scale, width)\n        penup()\n        forward(width)\n        pendown()\n    penup()\n    back(size)\n    pendown()\n    \nclearscreen()\nhideturtle()\nhouse(150)\npenup()\nforward(10)\npendown()\nbarchart([0.5, (1/3), 2, 1.3, 0.5], 200)\npenup()\nback(10)\npendown()\n"}
{"id": 333723, "name": "Positive decimal integers with the digit 1 occurring exactly twice", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @twoones = grep tr/1// =~ 2, 1 .. 1000;\nprint \"@twoones\\n\" =~ s/.{60}\\K /\\n/gr;\n", "target": "\n\nfrom itertools import permutations\n\nfor i in range(0,10):\n    if i!=1:\n        baseList = [1,1]\n        baseList.append(i)\n        [print(int(''.join(map(str,j)))) for j in sorted(set(permutations(baseList)))]\n"}
{"id": 333724, "name": "Unique characters in each string", "source": "Translate Perl to Python: \n\nuse strict; \nuse warnings;\n\nmy @strings = (\"1a3c52debeffd\", \"2b6178c97a938stf\", \"3ycxdb1fgxa2yz\");\nmy $chars = join \"\\n\", @strings;\nprint \"@{[ sort grep\n  $chars\u00a0!~ /$_.*$_/ &&           \n  @strings == $chars =~ s/$_//g,  \n  $chars =~ /./g ]}\\n\";\n", "target": "LIST = [\"1a3c52debeffd\", \"2b6178c97a938stf\", \"3ycxdb1fgxa2yz\"]\n\nprint(sorted([ch for ch in set([c for c in ''.join(LIST)]) if all(w.count(ch) == 1 for w in LIST)]))\n"}
{"id": 333725, "name": "Jacobsthal numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say state>;\nuse bigint;\nuse List::Util 'max';\nuse ntheory 'is_prime';\n\nsub table { my $t = 5 * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub jacobsthal       { my($n) = @_; state  @J = (0, 1); do { push  @J,  $J[-1] + 2 *  $J[-2]} until  @J > $n;  $J[$n] }\nsub jacobsthal_lucas { my($n) = @_; state @JL = (2, 1); do { push @JL, $JL[-1] + 2 * $JL[-2]} until @JL > $n; $JL[$n] }\n\nmy(@j,@jp,$c,$n);\npush @j, jacobsthal $_ for 0..29;\ndo { is_prime($n = ( 2**++$c - -1**$c ) / 3) and push @jp, $n } until @jp == 20;\n\nsay \"First 30 Jacobsthal numbers:\\n\",        table @j;\nsay \"First 30 Jacobsthal-Lucas numbers:\\n\",  table map { jacobsthal_lucas $_-1 } 1..30;\nsay \"First 20 Jacobsthal oblong numbers:\\n\", table map { $j[$_-1] * $j[$_]     } 1..20;\nsay \"First 20 Jacobsthal primes:\\n\",         join \"\\n\", @jp;\n", "target": "\nfrom math import floor, pow\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef odd(n):\n    return n and 1 != 0\n    \ndef jacobsthal(n):\n    return floor((pow(2,n)+odd(n))/3)\n\ndef jacobsthal_lucas(n):\n    return int(pow(2,n)+pow(-1,n))\n\ndef jacobsthal_oblong(n):\n    return jacobsthal(n)*jacobsthal(n+1)\n\n\nif __name__ == '__main__':\n    print(\"First 30 Jacobsthal numbers:\")\n    for j in range(0, 30):\n        print(jacobsthal(j), end=\"  \")\n\n    print(\"\\n\\nFirst 30 Jacobsthal-Lucas numbers: \")\n    for j in range(0, 30):\n        print(jacobsthal_lucas(j), end = '\\t')\n\n    print(\"\\n\\nFirst 20 Jacobsthal oblong numbers: \")\n    for j in range(0, 20):\n        print(jacobsthal_oblong(j), end=\"  \")\n\n    print(\"\\n\\nFirst 10 Jacobsthal primes: \")\n    for j in range(3, 33):\n        if isPrime(jacobsthal(j)):\n            print(jacobsthal(j))\n"}
{"id": 333726, "name": "Jacobsthal numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <say state>;\nuse bigint;\nuse List::Util 'max';\nuse ntheory 'is_prime';\n\nsub table { my $t = 5 * (my $c = 1 + length max @_); ( sprintf( ('%'.$c.'d')x@_, @_) ) =~ s/.{1,$t}\\K/\\n/gr }\n\nsub jacobsthal       { my($n) = @_; state  @J = (0, 1); do { push  @J,  $J[-1] + 2 *  $J[-2]} until  @J > $n;  $J[$n] }\nsub jacobsthal_lucas { my($n) = @_; state @JL = (2, 1); do { push @JL, $JL[-1] + 2 * $JL[-2]} until @JL > $n; $JL[$n] }\n\nmy(@j,@jp,$c,$n);\npush @j, jacobsthal $_ for 0..29;\ndo { is_prime($n = ( 2**++$c - -1**$c ) / 3) and push @jp, $n } until @jp == 20;\n\nsay \"First 30 Jacobsthal numbers:\\n\",        table @j;\nsay \"First 30 Jacobsthal-Lucas numbers:\\n\",  table map { jacobsthal_lucas $_-1 } 1..30;\nsay \"First 20 Jacobsthal oblong numbers:\\n\", table map { $j[$_-1] * $j[$_]     } 1..20;\nsay \"First 20 Jacobsthal primes:\\n\",         join \"\\n\", @jp;\n", "target": "\nfrom math import floor, pow\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef odd(n):\n    return n and 1 != 0\n    \ndef jacobsthal(n):\n    return floor((pow(2,n)+odd(n))/3)\n\ndef jacobsthal_lucas(n):\n    return int(pow(2,n)+pow(-1,n))\n\ndef jacobsthal_oblong(n):\n    return jacobsthal(n)*jacobsthal(n+1)\n\n\nif __name__ == '__main__':\n    print(\"First 30 Jacobsthal numbers:\")\n    for j in range(0, 30):\n        print(jacobsthal(j), end=\"  \")\n\n    print(\"\\n\\nFirst 30 Jacobsthal-Lucas numbers: \")\n    for j in range(0, 30):\n        print(jacobsthal_lucas(j), end = '\\t')\n\n    print(\"\\n\\nFirst 20 Jacobsthal oblong numbers: \")\n    for j in range(0, 20):\n        print(jacobsthal_oblong(j), end=\"  \")\n\n    print(\"\\n\\nFirst 10 Jacobsthal primes: \")\n    for j in range(3, 33):\n        if isPrime(jacobsthal(j)):\n            print(jacobsthal(j))\n"}
{"id": 333727, "name": "Successive prime differences", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse List::EachCons;\nuse Array::Compare;\nuse ntheory 'primes';\n\nmy $limit = 1E6;\nmy @primes = (2, @{ primes($limit) });\nmy @intervals = map { $primes[$_] - $primes[$_-1] } 1..$\n\nprint \"Groups of successive primes <= $limit\\n\";\n\nmy $c = Array::Compare->new;\nfor my $diffs ([2], [1], [2,2], [2,4], [4,2], [6,4,2]) {\n    my $n = -1;\n    my @offsets = grep {$_} each_cons @$diffs, @intervals, sub { $n++; $n if $c->compare(\\@_, \\@$diffs) };\n    printf \"%10s has %5d sets: %15s \u2026 %s\\n\", \n       '(' . join(' ',@$diffs) . ')',\n        scalar @offsets,\n        join(' ', @primes[$offsets[ 0]..($offsets[ 0]+@$diffs)]),\n        join(' ', @primes[$offsets[-1]..($offsets[-1]+@$diffs)]);\n}\n", "target": "\nfrom sympy import Sieve\n\ndef nsuccprimes(count, mx):\n    \"return tuple of <count> successive primes <= mx (generator)\"\n    sieve = Sieve()\n    sieve.extend(mx)\n    primes = sieve._list\n    return zip(*(primes[n:] for n in range(count)))\n\ndef check_value_diffs(diffs, values):\n    \"Differences between successive values given by successive items in diffs?\"\n    return all(v[1] - v[0] == d \n               for d, v in zip(diffs, zip(values, values[1:])))\n\ndef successive_primes(offsets=(2, ), primes_max=1_000_000):\n    return (sp for sp in nsuccprimes(len(offsets) + 1, primes_max) \n            if check_value_diffs(offsets, sp))\n\nif __name__ == '__main__':\n    for offsets, mx in [((2,),      1_000_000), \n                        ((1,),      1_000_000),\n                        ((2, 2),    1_000_000),\n                        ((2, 4),    1_000_000),\n                        ((4, 2),    1_000_000),\n                        ((6, 4, 2), 1_000_000),\n                       ]:\n        print(f\"\n              f\"SUCCESSIVE DIFFERENCES OF {str(list(offsets))[1:-1]}\")\n        for count, last in enumerate(successive_primes(offsets, mx), 1):\n            if count == 1:\n                first = last\n        print(\"  First group:\", str(first)[1:-1])\n        print(\"   Last group:\", str(last)[1:-1])\n        print(\"        Count:\", count)\n"}
{"id": 333728, "name": "Numbers whose binary and ternary digit sums are prime", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'sum';\nuse ntheory <is_prime todigitstring>;\n\nsub test_digits { 0 != is_prime sum split '', todigitstring(shift, shift) }\n\nmy @p;\ntest_digits($_,2) and test_digits($_,3) and push @p, $_ for 1..199;\nsay my $result = @p . \" matching numbers:\\n\" .  (sprintf \"@{['%4d' x @p]}\", @p) =~ s/(.{40})/$1\\n/gr;\n", "target": "\n\n\n\ndef digitSumsPrime(n):\n    \n    def go(bases):\n        return all(\n            isPrime(digitSum(b)(n))\n            for b in bases\n        )\n    return go\n\n\n\ndef digitSum(base):\n    \n    def go(n):\n        q, r = divmod(n, base)\n        return go(q) + r if n else 0\n    return go\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 200)\n        if digitSumsPrime(n)([2, 3])\n    ]\n    print(f'{len(xs)} matches in [1..199]\\n')\n    print(table(10)(xs))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333729, "name": "10001th prime", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature 'say';\n\n\nmy($n,$c) = (1,0);\nwhile () {\n    $c++ if (1 x ++$n) !~ /^(11+)\\1+$/;\n    $c == 10_001 and say $n and last;\n}\n\n\nuse ntheory 'nth_prime';\nsay nth_prime(10_001);\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef prime(n: int) -> int:\n    if n == 1:\n        return 2\n    p = 3\n    pn = 1\n    while pn < n:\n        if isPrime(p):\n            pn += 1\n        p += 2\n    return p-2\n\nif __name__ == '__main__':\n    print(prime(10001))\n"}
{"id": 333730, "name": "Summarize primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory <nth_prime is_prime>;\n\nmy($n, $s, $limit, @sums) = (0, 0, 1000);\ndo {\n    push @sums, sprintf '%3d %8d', $n, $s if is_prime($s += nth_prime ++$n)\n} until $n >= $limit;\n\nprint \"Of the first $limit primes: @{[scalar @sums]} cumulative prime sums:\\n\", join \"\\n\", @sums;\n", "target": "\n\n\nfrom itertools import accumulate, chain, takewhile\n\n\n\ndef primeSums():\n    \n    return (\n        x for x in enumerate(\n            accumulate(\n                chain([(0, 0)], primes()),\n                lambda a, p: (p, p + a[1])\n            )\n        ) if isPrime(x[1][1])\n    )\n\n\n\n\ndef main():\n    \n    for x in takewhile(\n            lambda t: 1000 > t[1][0],\n            primeSums()\n    ):\n        print(f'{x[0]} -> {x[1][1]}')\n\n\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333731, "name": "Summarize primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse ntheory <nth_prime is_prime>;\n\nmy($n, $s, $limit, @sums) = (0, 0, 1000);\ndo {\n    push @sums, sprintf '%3d %8d', $n, $s if is_prime($s += nth_prime ++$n)\n} until $n >= $limit;\n\nprint \"Of the first $limit primes: @{[scalar @sums]} cumulative prime sums:\\n\", join \"\\n\", @sums;\n", "target": "\n\n\nfrom itertools import accumulate, chain, takewhile\n\n\n\ndef primeSums():\n    \n    return (\n        x for x in enumerate(\n            accumulate(\n                chain([(0, 0)], primes()),\n                lambda a, p: (p, p + a[1])\n            )\n        ) if isPrime(x[1][1])\n    )\n\n\n\n\ndef main():\n    \n    for x in takewhile(\n            lambda t: 1000 > t[1][0],\n            primeSums()\n    ):\n        print(f'{x[0]} -> {x[1][1]}')\n\n\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333732, "name": "Terminal control_Dimensions", "source": "Translate Perl to Python: use Term::Size;\n\n($cols, $rows) = Term::Size::chars;\nprint \"The terminal has $cols columns and $rows lines\\n\";\n", "target": "import os\n\ndef get_windows_terminal():\n    from ctypes import windll, create_string_buffer\n    h = windll.kernel32.GetStdHandle(-12)\n    csbi = create_string_buffer(22)\n    res = windll.kernel32.GetConsoleScreenBufferInfo(h, csbi)\n\n    \n    if not res: return 80, 25 \n\n    import struct\n    (bufx, bufy, curx, cury, wattr, left, top, right, bottom, maxx, maxy)\\\n    = struct.unpack(\"hhhhHhhhhhh\", csbi.raw)\n    width = right - left + 1\n    height = bottom - top + 1\n\n    return width, height\n\ndef get_linux_terminal():\n    width = os.popen('tput cols', 'r').readline()\n    height = os.popen('tput lines', 'r').readline()\n\n    return int(width), int(height)\n\nprint get_linux_terminal() if os.name == 'posix' else get_windows_terminal()\n"}
{"id": 333733, "name": "Next special primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <state say>;\nuse ntheory 'primes';\n\nmy $limit = 1050;\n\nsub is_special {\n    state $previous = 2;\n    state $gap      = 0;\n    state @primes = @{primes( 2*$limit )};\n\n    shift @primes while $primes[0] <= $previous + $gap;\n    $gap = $primes[0] - $previous;\n    $previous = $primes[0];\n    [$previous, $gap];\n}\n\nmy @specials = [2, 0];\ndo { push @specials, is_special() } until $specials[-1][0] >= $limit;\n\npop @specials;\nprintf \"%4d %4d\\n\", @$_ for @specials;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 3\n    i = 2\n\n    print(\"2 3\", end = \" \");\n    while True:\n        if isPrime(p + i) == 1:\n            p += i\n            print(p, end = \" \");\n        i += 2\n        if p + i >= 1050:\n            break\n"}
{"id": 333734, "name": "Next special primes", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse feature <state say>;\nuse ntheory 'primes';\n\nmy $limit = 1050;\n\nsub is_special {\n    state $previous = 2;\n    state $gap      = 0;\n    state @primes = @{primes( 2*$limit )};\n\n    shift @primes while $primes[0] <= $previous + $gap;\n    $gap = $primes[0] - $previous;\n    $previous = $primes[0];\n    [$previous, $gap];\n}\n\nmy @specials = [2, 0];\ndo { push @specials, is_special() } until $specials[-1][0] >= $limit;\n\npop @specials;\nprintf \"%4d %4d\\n\", @$_ for @specials;\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    p = 3\n    i = 2\n\n    print(\"2 3\", end = \" \");\n    while True:\n        if isPrime(p + i) == 1:\n            p += i\n            print(p, end = \" \");\n        i += 2\n        if p + i >= 1050:\n            break\n"}
{"id": 333735, "name": "Largest number divisible by its digits", "source": "Translate Perl to Python: my $step = 9 * 8 * 7;                               \n\nmy $initial = int(9876432 / $step) * $step;         \n\nfor($test = $initial; $test > 0 ; $test -= $step) { \n    next if $test =~ /[05]/;                        \n    next if $test =~ /(.).*\\1/;                     \n\n    for (split '', $test) {                         \n        next unless ($test / $_) % 1;\n    }\n\n    printf \"Found $test after %d steps\\n\", ($initial-$test)/$step;\n    for (split '', $test) {\n       printf \"%s / %s = %s\\n\", $test, $_, $test / $_;\n    }\n    last\n}\n", "target": "\n\nfrom itertools import (chain, permutations)\nfrom functools import (reduce)\nfrom math import (gcd)\n\n\n\ndef main():\n    \n\n    \n    digits = [1, 2, 3, 4, 6, 7, 8, 9]\n\n    \n    lcmDigits = reduce(lcm, digits)\n\n    \n    \n    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])\n\n    print(\n        max(\n            (\n                intFromDigits(x) for x\n                in concatMap(permutations)(sevenDigits)\n            ),\n            key=lambda n: n if 0 == n % lcmDigits else 0\n        )\n    )\n\n\n\ndef intFromDigits(xs):\n    \n    return reduce(lambda a, x: a * 10 + x, xs, 0)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef delete(xs):\n    \n    def go(x):\n        ys = xs.copy()\n        ys.remove(x)\n        return ys\n    return go\n\n\n\ndef lcm(x, y):\n    \n    return 0 if (0 == x or 0 == y) else abs(\n        y * (x // gcd(x, y))\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333736, "name": "Largest number divisible by its digits", "source": "Translate Perl to Python: my $step = 9 * 8 * 7;                               \n\nmy $initial = int(9876432 / $step) * $step;         \n\nfor($test = $initial; $test > 0 ; $test -= $step) { \n    next if $test =~ /[05]/;                        \n    next if $test =~ /(.).*\\1/;                     \n\n    for (split '', $test) {                         \n        next unless ($test / $_) % 1;\n    }\n\n    printf \"Found $test after %d steps\\n\", ($initial-$test)/$step;\n    for (split '', $test) {\n       printf \"%s / %s = %s\\n\", $test, $_, $test / $_;\n    }\n    last\n}\n", "target": "\n\nfrom itertools import (chain, permutations)\nfrom functools import (reduce)\nfrom math import (gcd)\n\n\n\ndef main():\n    \n\n    \n    digits = [1, 2, 3, 4, 6, 7, 8, 9]\n\n    \n    lcmDigits = reduce(lcm, digits)\n\n    \n    \n    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])\n\n    print(\n        max(\n            (\n                intFromDigits(x) for x\n                in concatMap(permutations)(sevenDigits)\n            ),\n            key=lambda n: n if 0 == n % lcmDigits else 0\n        )\n    )\n\n\n\ndef intFromDigits(xs):\n    \n    return reduce(lambda a, x: a * 10 + x, xs, 0)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef delete(xs):\n    \n    def go(x):\n        ys = xs.copy()\n        ys.remove(x)\n        return ys\n    return go\n\n\n\ndef lcm(x, y):\n    \n    return 0 if (0 == x or 0 == y) else abs(\n        y * (x // gcd(x, y))\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 333737, "name": "Jacobi symbol", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub J {\n    my($k,$n) = @_;\n\n    $k %= $n;\n    my $jacobi = 1;\n    while ($k) {\n        while (0 == $k % 2) {\n            $k = int $k / 2;\n            $jacobi *= -1 if $n%8 == 3 or $n%8 == 5;\n        }\n        ($k, $n) = ($n, $k);\n        $jacobi *= -1 if $n%4 == 3 and $k%4 == 3;\n        $k %= $n;\n    }\n    $n == 1 ? $jacobi : 0\n}\n\nmy $maxa = 1 + (my $maxn = 29);\n\nprint 'n\\k';\nprintf '%4d', $_ for 1..$maxa;\nprint \"\\n\";\nprint '   ' . '-' x (4 * $maxa) . \"\\n\";\n\nfor my $n (1..$maxn) {\n    next if 0 == $n % 2;\n    printf '%3d', $n;\n    printf '%4d', J($_, $n) for 1..$maxa;\n    print \"\\n\"\n}\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 333738, "name": "Jacobi symbol", "source": "Translate Perl to Python: use strict;\nuse warnings;\n\nsub J {\n    my($k,$n) = @_;\n\n    $k %= $n;\n    my $jacobi = 1;\n    while ($k) {\n        while (0 == $k % 2) {\n            $k = int $k / 2;\n            $jacobi *= -1 if $n%8 == 3 or $n%8 == 5;\n        }\n        ($k, $n) = ($n, $k);\n        $jacobi *= -1 if $n%4 == 3 and $k%4 == 3;\n        $k %= $n;\n    }\n    $n == 1 ? $jacobi : 0\n}\n\nmy $maxa = 1 + (my $maxn = 29);\n\nprint 'n\\k';\nprintf '%4d', $_ for 1..$maxa;\nprint \"\\n\";\nprint '   ' . '-' x (4 * $maxa) . \"\\n\";\n\nfor my $n (1..$maxn) {\n    next if 0 == $n % 2;\n    printf '%3d', $n;\n    printf '%4d', J($_, $n) for 1..$maxa;\n    print \"\\n\"\n}\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 333739, "name": "Determinant and permanent", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\nuse PDL;\nuse PDL::NiceSlice;\n\nsub permanent{\n\tmy $mat = shift;\n\tmy $n = shift // $mat->dim(0);\n\treturn undef if $mat->dim(0) != $mat->dim(1);\n\treturn $mat(0,0) if $n == 1;\n\tmy $sum = 0;\n\t--$n;\n\tmy $m = $mat(1:,1:)->copy;\n\tfor(my $i = 0; $i <= $n; ++$i){\n\t\t$sum += $mat($i,0) * permanent($m, $n);\n\t\tlast if $i == $n;\n\t\t$m($i,:) .= $mat($i,1:);\n\t}\n\treturn sclr($sum);\n}\n\nmy $M = pdl([[2,9,4], [7,5,3], [6,1,8]]);\nprint \"M = $M\\n\";\nprint \"det(M) = \" . $M->determinant . \".\\n\";\nprint \"det(M) = \" . $M->det . \".\\n\";\nprint \"perm(M) = \" . permanent($M) . \".\\n\";\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 333740, "name": "Determinant and permanent", "source": "Translate Perl to Python: \nuse strict;\nuse warnings;\nuse PDL;\nuse PDL::NiceSlice;\n\nsub permanent{\n\tmy $mat = shift;\n\tmy $n = shift // $mat->dim(0);\n\treturn undef if $mat->dim(0) != $mat->dim(1);\n\treturn $mat(0,0) if $n == 1;\n\tmy $sum = 0;\n\t--$n;\n\tmy $m = $mat(1:,1:)->copy;\n\tfor(my $i = 0; $i <= $n; ++$i){\n\t\t$sum += $mat($i,0) * permanent($m, $n);\n\t\tlast if $i == $n;\n\t\t$m($i,:) .= $mat($i,1:);\n\t}\n\treturn sclr($sum);\n}\n\nmy $M = pdl([[2,9,4], [7,5,3], [6,1,8]]);\nprint \"M = $M\\n\";\nprint \"det(M) = \" . $M->determinant . \".\\n\";\nprint \"det(M) = \" . $M->det . \".\\n\";\nprint \"perm(M) = \" . permanent($M) . \".\\n\";\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 333741, "name": "Deceptive numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::AnyNum qw(imod is_prime);\n\nmy($x,@D) = 2;\nwhile ($x++) {\n    push @D, $x if 1 == $x%2 and !is_prime $x and 0 == imod(1x($x-1),$x);\n    last if 25 == @D\n}\nprint \"@D\\n\";\n", "target": "from itertools import count, islice\nfrom math import isqrt\n\ndef is_deceptive(n):\n    if n & 1 and n % 3 and n % 5 and pow(10, n - 1, n) == 1:\n        for d in range(7, isqrt(n) + 1, 6):\n            if not (n % d and n % (d + 4)): return True\n    return False\n\nprint(*islice(filter(is_deceptive, count()), 100))\n"}
{"id": 333742, "name": "Deceptive numbers", "source": "Translate Perl to Python: use strict;\nuse warnings;\nuse Math::AnyNum qw(imod is_prime);\n\nmy($x,@D) = 2;\nwhile ($x++) {\n    push @D, $x if 1 == $x%2 and !is_prime $x and 0 == imod(1x($x-1),$x);\n    last if 25 == @D\n}\nprint \"@D\\n\";\n", "target": "from itertools import count, islice\nfrom math import isqrt\n\ndef is_deceptive(n):\n    if n & 1 and n % 3 and n % 5 and pow(10, n - 1, n) == 1:\n        for d in range(7, isqrt(n) + 1, 6):\n            if not (n % d and n % (d + 4)): return True\n    return False\n\nprint(*islice(filter(is_deceptive, count()), 100))\n"}
{"id": 333743, "name": "Sum of the digits of n is substring of n", "source": "Translate Perl to Python: // 20210415 Perl programming solution\n\nperl -e 'for(0..999){my$n;s/(\\d)/$n+=$1/egr;print\"$_ \"if/$n/}'\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 333744, "name": "Sum of the digits of n is substring of n", "source": "Translate Perl to Python: // 20210415 Perl programming solution\n\nperl -e 'for(0..999){my$n;s/(\\d)/$n+=$1/egr;print\"$_ \"if/$n/}'\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 333745, "name": "Sattolo cycle", "source": "Translate Perl to Python: @a = 0..30;\n\nprintf \"%2d \", $_ for @a; print \"\\n\";\nsattolo_cycle(\\@a);\nprintf \"%2d \", $_ for @a; print \"\\n\";\n\nsub sattolo_cycle {\n    my($array) = @_;\n    for $i (reverse 0 .. -1+@$array) {\n        my $j = int rand $i;\n        @$array[$j, $i] = @$array[$i, $j];\n    }\n}\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 333746, "name": "Sattolo cycle", "source": "Translate Perl to Python: @a = 0..30;\n\nprintf \"%2d \", $_ for @a; print \"\\n\";\nsattolo_cycle(\\@a);\nprintf \"%2d \", $_ for @a; print \"\\n\";\n\nsub sattolo_cycle {\n    my($array) = @_;\n    for $i (reverse 0 .. -1+@$array) {\n        my $j = int rand $i;\n        @$array[$j, $i] = @$array[$i, $j];\n    }\n}\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 333747, "name": "FTP", "source": "Translate Perl to Python: use Net::FTP;\n\n\nmy $host     = 'speedtest.tele2.net';\nmy $user     = 'anonymous';\nmy $password = '';\n\n\nmy $f = Net::FTP->new($host) or die \"Can't open $host\\n\";\n$f->login($user, $password)  or die \"Can't login as $user\\n\";\n$f->passive();\n\n\n$f->cwd('upload');\n@files = $f->ls();\nprintf \"Currently %d files in the 'upload' directory.\\n\", @files;\n\n\n$f->cwd('/');\n$f->type('binary');\n$local = $f->get('512KB.zip');\nprint \"Your file was stored as $local in the current directory\\n\";\n", "target": "from ftplib import FTP\nftp = FTP('kernel.org')\nftp.login()\nftp.cwd('/pub/linux/kernel')\nftp.set_pasv(True) \nprint ftp.retrlines('LIST')\nprint ftp.retrbinary('RETR README', open('README', 'wb').write)\nftp.quit()\n"}
{"id": 341970, "name": "Range consolidation", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse List::Util qw(min max);\n\nsub consolidate {\n    our @arr; local *arr = shift;\n    my @sorted = sort { @$a[0] <=> @$b[0] } map { [sort { $a <=> $b } @$_] } @arr;\n    my @merge = shift @sorted;\n    for my $i (@sorted) {\n        if ($merge[-1][1] >= @$i[0]) {\n            $merge[-1][0] = min($merge[-1][0], @$i[0]);\n            $merge[-1][1] = max($merge[-1][1], @$i[1]);\n        } else {\n            push @merge, $i;\n        }\n    }\n    return @merge;\n}\n\nfor my $intervals (\n    [[1.1, 2.2],],\n    [[6.1, 7.2], [7.2, 8.3]],\n    [[4, 3], [2, 1]],\n    [[4, 3], [2, 1], [-1, -2], [3.9, 10]],\n    [[1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]]) {\n        my($in,$out);\n        $in   = join ', ', map { '[' . join(', ', @$_) . ']' } @$intervals;\n        $out .= join('..', @$_). ' ' for consolidate($intervals);\n        printf \"%44s => %s\\n\", $in, $out;\n}\n", "target": "using static System.Math;\nusing System.Linq;\nusing System;\n\npublic static class RangeConsolidation\n{\n    public static void Main() {\n        foreach (var list in new [] {\n            new[] { (1.1, 2.2) }.ToList(),\n            new[] { (6.1, 7.2), (7.2, 8.3) }.ToList(),\n            new[] { (4d, 3d), (2, 1) }.ToList(),\n            new[] { (4d, 3d), (2, 1), (-1, 2), (3.9, 10) }.ToList(),\n            new[] { (1d, 3d), (-6, -1), (-4, -5), (8, 2), (-6, -6) }.ToList()\n        })\n        {\n            for (int z = list.Count-1; z >= 1; z--) {\n                for (int y = z - 1; y >= 0; y--) {\n                    if (Overlap(list[z], list[y])) {\n                        list[y] = Consolidate(list[z], list[y]);\n                        list.RemoveAt(z);\n                        break;\n                    }\n                }\n            }\n            Console.WriteLine(string.Join(\", \", list.Select(Normalize).OrderBy(range => range.s)));\n        }\n    }\n\n    private static bool Overlap((double s, double e) left, (double s, double e) right) =>\n        Max(left.s, left.e) > Max(right.s, right.e)\n        ? Max(right.s, right.e) >= Min(left.s, left.e)\n        : Max(left.s, left.e) >= Min(right.s, right.e);\n\n    private static (double s, double e) Consolidate((double s, double e) left, (double s, double e) right) =>\n        (Min(Min(left.s, left.e), Min(right.s, right.e)), Max(Max(left.s, left.e), Max(right.s, right.e)));\n    \n    private static (double s, double e) Normalize((double s, double e) range) =>\n        (Min(range.s, range.e), Max(range.s, range.e));\n}\n"}
{"id": 341971, "name": "Pascal matrix generation", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\nuse feature qw{ say };\n\n\nsub upper {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = $x > $y          ? 0\n                       : ! $x || $x == $y ? 1\n                                          : $m[$x-1][$y-1] + $m[$x][$y-1];\n        }\n    }\n    return \\@m\n}\n\n\nsub lower {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = $x < $y          ? 0\n                       : ! $x || $x == $y ? 1\n                                          : $m[$x-1][$y-1] + $m[$x-1][$y];\n        }\n    }\n    return \\@m\n}\n\n\nsub symmetric {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = ! $x || ! $y ? 1\n                                      : $m[$x-1][$y] + $m[$x][$y-1];\n        }\n    }\n    return \\@m\n}\n\n\nsub pretty {\n    my $m = shift;\n    for my $row (@$m) {\n        say join ', ', @$row;\n    }\n}\n\n\npretty(upper(5, 5));\nsay '-' x 14;\npretty(lower(5, 5));\nsay '-' x 14;\npretty(symmetric(5, 5));\n", "target": "using System;\n\npublic static class PascalMatrixGeneration\n{\n    public static void Main() {\n        Print(GenerateUpper(5));\n        Console.WriteLine();\n        Print(GenerateLower(5));\n        Console.WriteLine();\n        Print(GenerateSymmetric(5));\n    }\n\n    static int[,] GenerateUpper(int size) {\n        int[,] m = new int[size, size];\n        for (int c = 0; c < size; c++) m[0, c] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = r; c < size; c++) {\n                m[r, c] = m[r-1, c-1] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateLower(int size) {\n        int[,] m = new int[size, size];\n        for (int r = 0; r < size; r++) m[r, 0] = 1;\n        for (int c = 1; c < size; c++) {\n            for (int r = c; r < size; r++) {\n                m[r, c] = m[r-1, c-1] + m[r-1, c];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateSymmetric(int size) {\n        int[,] m = new int[size, size];\n        for (int i = 0; i < size; i++) m[0, i] = m[i, 0] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = 1; c < size; c++) {\n                m[r, c] = m[r-1, c] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static void Print(int[,] matrix) {\n        string[,] m = ToString(matrix);\n        int width = m.Cast<string>().Select(s => s.Length).Max();\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"|\" + string.Join(\" \", Range(0, columns).Select(column => m[row, column].PadLeft(width, ' '))) + \"|\");\n        }\n    }\n\n    static string[,] ToString(int[,] matrix) {\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        string[,] m = new string[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                m[r, c] = matrix[r, c].ToString();\n            }\n        }\n        return m;\n    }\n    \n}\n"}
{"id": 341972, "name": "Mad Libs", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\n\nmy $template = shift;\nopen my $IN, '<', $template or die $!;\nmy $story = do { local $/ ; <$IN> };\n\nmy %blanks;\nundef $blanks{$_} for $story =~ m/<(.*?)>/g;\n\nfor my $blank (sort keys %blanks) {\n    print \"$blank: \";\n    chomp (my $replacement = <>);\n    $blanks{$blank} = $replacement;\n}\n\n$story =~ s/<(.*?)>/$blanks{$1}/g;\nprint $story;\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace MadLibs_RosettaCode\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tstring madLibs = \n@\"Write a program to create a Mad Libs like story.\nThe program should read an arbitrary multiline story from input.\nThe story will be terminated with a blank line.\nThen, find each replacement to be made within the story, \nask the user for a word to replace it with, and make all the replacements.\nStop when there are none left and print the final story.\nThe input should be an arbitrary story in the form:\n<name> went for a walk in the park. <he or she>\nfound a <noun>. <name> decided to take it home.\nGiven this example, it should then ask for a name, \na he or she and a noun (<name> gets replaced both times with the same value).\";\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tRegex pattern = new Regex(@\"\\<(.*?)\\>\");\n\t\t\tstring storyLine;\n\t\t\tstring replacement;\n\n\t\t\tConsole.WriteLine(madLibs + Environment.NewLine + Environment.NewLine);\n\t\t\tConsole.WriteLine(\"Enter a story: \");\n\n\t\t\t\n\t\t\tdo\n\t\t\t{\n\t\t\t\tstoryLine = Console.ReadLine();\n\t\t\t\tsb.Append(storyLine + Environment.NewLine);\n\t\t\t} while (!string.IsNullOrEmpty(storyLine) && !string.IsNullOrWhiteSpace(storyLine));\n\n\t\t\t\n\t\t\tMatch nameMatch = pattern.Matches(sb.ToString()).OfType<Match>().Where(x => x.Value.Equals(\"<name>\")).Select(x => x.Value).Distinct() as Match;\n\t\t\tif(nameMatch != null)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + nameMatch.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\t\t\t\tsb.Replace(nameMatch.Value, replacement);\n\t\t\t}\n\n\t\t\tforeach (Match match in pattern.Matches(sb.ToString()))\n\t\t\t{\n\t\t\t\treplacement = string.Empty;\n\t\t\t\t\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + match.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\n\t\t\t\tint location = sb.ToString().IndexOf(match.Value);\n\t\t\t\tsb.Remove(location, match.Value.Length).Insert(location, replacement);\n\t\t\t}\n\n\t\t\tConsole.WriteLine(Environment.NewLine + Environment.NewLine + \"--[ Here's your story! ]--\");\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t}\n}\n"}
{"id": 341973, "name": "Shortest common supersequence", "source": "Translate Perl to C#: sub lcs { \n    my( $u, $v ) = @_;\n    return '' unless length($u) and length($v);\n    my $longest = '';\n    for my $first ( 0..length($u)-1 ) {\n        my $char = substr $u, $first, 1;\n        my $i = index( $v, $char );\n        next if -1==$i;\n        my $next = $char;\n        $next .= lcs( substr( $u, $first+1), substr( $v, $i+1 ) ) unless $i==length($v)-1;\n        $longest = $next if length($next) > length($longest);\n    }\n    return $longest;\n}\n\nsub scs { \n    my( $u, $v ) = @_;\n    my @lcs = split //, lcs $u, $v;\n    my $pat = \"(.*)\".join(\"(.*)\",@lcs).\"(.*)\"; \n    my @u = $u =~ /$pat/;\n    my @v = $v =~ /$pat/;\n    my $scs = shift(@u).shift(@v);\n    $scs .= $_.shift(@u).shift(@v) for @lcs;\n    return $scs;\n}\n\nmy $u = \"abcbdab\";\nmy $v = \"bdcaba\";\nprintf \"Strings %s %s\\n\", $u, $v;\nprintf \"Longest common subsequence:   %s\\n\", lcs $u, $v;\nprintf \"Shortest common supersquence: %s\\n\", scs $u, $v;\n", "target": "public class ShortestCommonSupersequence\n{\n    Dictionary<(string, string), string> cache = new();\n\n    public string scs(string x, string y)\n    {\n        if (x.Length == 0) return y;\n        if (y.Length == 0) return x;\n\n        if (cache.TryGetValue((x, y), out var result)) return result;\n\n        if (x[0] == y[0])\n        {\n            return cache[(x, y)] = x[0] + scs(x.Substring(1), y.Substring(1));\n        }\n\n        var xr = scs(x.Substring(1), y);\n        var yr = scs(x, y.Substring(1));\n        if (yr.Length <= xr.Length)\n        {\n            return cache[(x, y)] = y[0] + yr;\n        }\n        else\n        {\n            return cache[(x, y)] = x[0] + xr;\n        }\n    }\n\n    public static void Main(string[] args)\n    {\n        var scs = new ShortestCommonSupersequence();\n        Console.WriteLine(scs.scs(\"abcbdab\", \"bdcaba\"));\n    }\n}\n"}
{"id": 341974, "name": "Long year", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse DateTime;\n\nfor my $century (19 .. 21) {\n  for my $year ($century*100 .. ++$century*100 - 1) {\n    print \"$year \" if DateTime->new(year => $year, month => 12, day => 28)->week_number > 52\n  }\n  print \"\\n\";\n}\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        WriteLine(\"Long years in the 21st century:\");\n        WriteLine(string.Join(\" \", 2000.To(2100).Where(y => ISOWeek.GetWeeksInYear(y) == 53)));\n    }\n    \n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i < end; i++) yield return i;\n    }\n    \n}\n"}
{"id": 341975, "name": "Mian-Chowla sequence", "source": "Translate Perl to C#: use strict; \nuse warnings;\nuse feature 'say';\n\nsub generate_mc {\n    my($max)  = @_;\n    my $index = 0;\n    my $test  = 1;\n    my %sums  = (2 => 1);\n    my @mc    = 1;\n    while ($test++) {\n        my %these = %sums;\n        map { next if ++$these{$_ + $test} > 1 } @mc[0..$index], $test;\n        %sums = %these;\n        $index++;\n        return @mc if (push @mc, $test) > $max-1;\n    }\n}\n\nmy @mian_chowla = generate_mc(100);\nsay \"First 30 terms in the Mian\u2013Chowla sequence:\\n\", join(' ', @mian_chowla[ 0..29]),\n    \"\\nTerms 91 through 100:\\n\",                     join(' ', @mian_chowla[90..99]);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\n\nstatic class Program {\n    static int[] MianChowla(int n) {\n        int[] mc = new int[n - 1 + 1];\n        HashSet<int> sums = new HashSet<int>(), ts = new HashSet<int>();\n        int sum; mc[0] = 1; sums.Add(2);\n        for (int i = 1; i <= n - 1; i++) {\n            for (int j = mc[i - 1] + 1; ; j++) {\n                mc[i] = j;\n                for (int k = 0; k <= i; k++) {\n                    sum = mc[k] + j;\n                    if (sums.Contains(sum)) { ts.Clear(); break; }\n                    ts.Add(sum);\n                }\n                if (ts.Count > 0) { sums.UnionWith(ts); break; }\n            }\n        }\n        return mc;\n    }\n\n    static void Main(string[] args)\n    {\n        const int n = 100; Stopwatch sw = new Stopwatch();\n        string str = \" of the Mian-Chowla sequence are:\\n\";\n        sw.Start(); int[] mc = MianChowla(n); sw.Stop();\n        Console.Write(\"The first 30 terms{1}{2}{0}{0}Terms 91 to 100{1}{3}{0}{0}\" +\n            \"Computation time was {4}ms.{0}\", '\\n', str, string.Join(\" \", mc.Take(30)),\n            string.Join(\" \", mc.Skip(n - 10)), sw.ElapsedMilliseconds);\n    }\n}\n"}
{"id": 341976, "name": "Water collected between towers", "source": "Translate Perl to C#: use Modern::Perl;\nuse List::Util qw{ min max sum };\n\nsub water_collected {\n    my @t = map { { TOWER => $_, LEFT => 0, RIGHT => 0, LEVEL => 0 } } @_;\n\n    my ( $l, $r ) = ( 0, 0 );\n    $_->{LEFT}  = ( $l = max( $l, $_->{TOWER} ) ) for @t;\n    $_->{RIGHT} = ( $r = max( $r, $_->{TOWER} ) ) for reverse @t;\n    $_->{LEVEL} = min( $_->{LEFT}, $_->{RIGHT} )  for @t;\n\n    return sum map { $_->{LEVEL} > 0 ? $_->{LEVEL} - $_->{TOWER} : 0 } @t;\n}\n\nsay join ' ', map { water_collected( @{$_} ) } (\n    [ 1, 5,  3, 7, 2 ],\n    [ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ],\n    [ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ],\n    [ 5, 5,  5, 5 ],\n    [ 5, 6,  7, 8 ],\n    [ 8, 7,  7, 6 ],\n    [ 6, 7, 10, 7, 6 ],\n);\n", "target": "class Program\n{\n    static void Main(string[] args)\n    {\n        int[][] wta = {\n            new int[] {1, 5, 3, 7, 2},   new int[] { 5, 3, 7, 2, 6, 4, 5, 9, 1, 2 },\n            new int[] { 2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 },\n            new int[] { 5, 5, 5, 5 },    new int[] { 5, 6, 7, 8 },\n            new int[] { 8, 7, 7, 6 },    new int[] { 6, 7, 10, 7, 6 }};\n        string blk, lf = \"\\n\", tb = \"\u2588\u2588\", wr = \"\u2248\u2248\", mt = \"  \";\n        for (int i = 0; i < wta.Length; i++)\n        {\n            int bpf; blk = \"\"; do\n            {\n                string floor = \"\"; bpf = 0; for (int j = 0; j < wta[i].Length; j++)\n                {\n                    if (wta[i][j] > 0)\n                    {    floor += tb; wta[i][j] -= 1; bpf += 1; }\n                    else floor += (j > 0 && j < wta[i].Length - 1 ? wr : mt);\n                }\n                if (bpf > 0) blk = floor + lf + blk;\n            } while (bpf > 0);\n            while (blk.Contains(mt + wr)) blk = blk.Replace(mt + wr, mt + mt);\n            while (blk.Contains(wr + mt)) blk = blk.Replace(wr + mt, mt + mt);\n            if (args.Length > 0) System.Console.Write(\"\\n{0}\", blk);\n            System.Console.WriteLine(\"Block {0} retains {1,2} water units.\",\n                i + 1, (blk.Length - blk.Replace(wr, \"\").Length) / 2);\n        }\n    }\n}\n"}
{"id": 341977, "name": "FASTA format", "source": "Translate Perl to C#: my $fasta_example = <<'END_FASTA_EXAMPLE';\n>Rosetta_Example_1\nTHERECANBENOSPACE\n>Rosetta_Example_2\nTHERECANBESEVERAL\nLINESBUTTHEYALLMUST\nBECONCATENATED\nEND_FASTA_EXAMPLE\n\nmy $num_newlines = 0;\nwhile ( < $fasta_example > ) {\n\tif (/\\A\\>(.*)/) {\n\t\tprint \"\\n\" x $num_newlines, $1, ': ';\n\t}\n\telse {\n\t\t$num_newlines = 1;\n\t\tprint;\n\t}\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Text;\n\nclass Program\n{\n    public class FastaEntry\n    {\n        public string Name { get; set; }\n        public StringBuilder Sequence { get; set; }\n    }\n\n    static IEnumerable<FastaEntry> ParseFasta(StreamReader fastaFile)\n    {\n        FastaEntry f = null;\n        string line;\n        while ((line = fastaFile.ReadLine()) != null)\n        {\n            \n            if (line.StartsWith(\";\"))\n                continue;\n\n            if (line.StartsWith(\">\"))\n            {\n                if (f != null)\n                    yield return f;\n                f = new FastaEntry { Name = line.Substring(1), Sequence = new StringBuilder() };\n            }\n            else if (f != null)\n                f.Sequence.Append(line);\n        }\n        yield return f;\n    }\n\n    static void Main(string[] args)\n    {\n        try\n        {\n            using (var fastaFile = new StreamReader(\"fasta.txt\"))\n            {\n                foreach (FastaEntry f in ParseFasta(fastaFile))\n                    Console.WriteLine(\"{0}: {1}\", f.Name, f.Sequence);\n            }\n        }\n        catch (FileNotFoundException e)\n        {\n            Console.WriteLine(e);\n        }\n        Console.ReadLine();\n    }\n}\n"}
{"id": 341978, "name": "MAC vendor lookup", "source": "Translate Perl to C#: \nuse v5.18.2;\nuse warnings;\nuse LWP;\nuse Time::HiRes qw(sleep);\n\nour $VERSION = 1.000_000;\n\nmy $ua = LWP::UserAgent->new;\n\nno warnings 'qw';\nmy @macs = qw(\n    FC-A1-3EFC:FB:FB:01:FA:21 00,0d,4b\n    Rhubarb                   00-14-22-01-23-45\n    10:dd:b1                  D4:F4:6F:C9:EF:8D\n    FC-A1-3E                  88:53:2E:67:07:BE\n    23:45:67                  FC:FB:FB:01:FA:21\n    BC:5F:F4\n);\n\nwhile (my $mac = shift @macs) {\n    my $vendor = get_mac_vendor($mac);\n    if ($vendor) {\n        say \"$mac = $vendor\";\n    }\n    sleep 1.5 if @macs;\n}\n\nsub get_mac_vendor {\n    my $s = shift;\n\n    my $req = HTTP::Request->new( GET => \"http://api.macvendors.com/$s\" );\n    my $res = $ua->request($req);\n\n    \n    \n    if ( $res->is_error ) {\n        return;\n    }\n\n    \n    \n    if (  !$res->content\n        or $res->content eq 'Vendor not found' )\n    {\n        return 'N/A';\n    }\n\n    return $res->content;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "target": "using System;\nusing System.Net;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\nclass Program\n{\n    static async Task<string> LookupMac(string MacAddress)\n    {\n        var uri = new Uri(\"http:\n        using (var wc = new HttpClient())\n            return await wc.GetStringAsync(uri);\n    }\n    static void Main(string[] args)\n    {\n        foreach (var mac in new string[] { \"88:53:2E:67:07:BE\", \"FC:FB:FB:01:FA:21\", \"D4:F4:6F:C9:EF:8D\" })\n            Console.WriteLine(mac + \"\\t\" + LookupMac(mac).Result);\n        Console.ReadLine();\n    }\n}\n"}
{"id": 341979, "name": "Magic 8-ball", "source": "Translate Perl to C#: @a = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',\n 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',\n 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',\n 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',\n \"Don't bet on it\", 'My reply is no', 'My sources say no', 'Outlook not so good',\n 'Very doubtful');\n\nwhile () {\n    print 'Enter your question:';\n    last unless <> =~ /\\w/;\n    print @a[int rand @a], \"\\n\";\n}\n", "target": "using System;\n\nnamespace newProg\n{\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] answers =\n            {\n                \"It is certain.\",\n                \"It is decidedly so.\",\n                \"Without a doubt.\",\n                \"Yes \u2013 definitely.\",\n                \"You may rely on it.\",\n                \"As I see it, yes.\",\n                \"Most likely.\",\n                \"Outlook good.\",\n                \"Yes.\",\n                \"Signs point to yes.\",\n                \"Reply hazy, try again.\",\n                \"Ask again later\",\n                \"Better not tell you now.\",\n                \"Cannot predict now.\",\n                \"Concentrate and ask again.\",\n                \"Don't count on it.\",\n                \"My reply is no.\",\n                \"My sources say no.\",\n                \"Outlook not so good.\",\n                \"Very doubtful.\"\n            };\n\n            while (true)\n            {\n                Random rnd = new Random();\n                int result = rnd.Next(0, 19);\n\n                Console.WriteLine(\"Magic 8 Ball! Ask question and hit a key for the answer!\");\n\n                string inp = Console.ReadLine();\n                \n                Console.WriteLine(answers[result]);\n\n            }\n        }\n    }\n}\n"}
{"id": 341980, "name": "Validate International Securities Identification Number", "source": "Translate Perl to C#: use strict;\nuse English;\nuse POSIX;\nuse Test::Simple tests => 7;\n\nok(   validate_isin('US0378331005'),  'Test 1');\t\nok( ! validate_isin('US0373831005'),  'Test 2');\nok( ! validate_isin('U50378331005'),  'Test 3');\nok( ! validate_isin('US03378331005'), 'Test 4');\nok(   validate_isin('AU0000XVGZA3'),  'Test 5');\t\nok(   validate_isin('AU0000VXGZA3'),  'Test 6');\nok(   validate_isin('FR0000988040'),  'Test 7');\t\nexit 0;\n\nsub validate_isin {\n    my $isin = shift;\n    $isin =~ /\\A[A-Z]{2}[A-Z\\d]{9}\\d\\z/s or return 0;\n    my $base10 = join(q{}, map {scalar(POSIX::strtol($ARG, 36))}\n                               split(//s, $isin));\n    return luhn_test($base10);\n}\n", "target": "using System;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace ValidateIsin\n{\n    public static class IsinValidator\n    {\n        public static bool IsValidIsin(string isin) => \n            IsinRegex.IsMatch(isin) && LuhnTest(Digitize(isin));\n\n        private static readonly Regex IsinRegex = \n            new Regex(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\", RegexOptions.Compiled);\n\n        private static string Digitize(string isin) =>\n            string.Join(\"\", isin.Select(c => $\"{DigitValue(c)}\"));\n\n        private static bool LuhnTest(string number) => \n            number.Reverse().Select(DigitValue).Select(Summand).Sum() % 10 == 0;\n\n        private static int Summand(int digit, int i) =>\n            digit + (i % 2) * (digit - digit / 5 * 9);\n\n        private static int DigitValue(char c) =>\n            c >= '0' && c <= '9' \n                ? c - '0' \n                : c - 'A' + 10;\n   }\n\t\n   public class Program\n   {\n        public static void Main() \n        {\n            string[] isins = \n            {\n                \"US0378331005\",\n                \"US0373831005\",\n                \"U50378331005\",\n                \"US03378331005\",\n                \"AU0000XVGZA3\",\n                \"AU0000VXGZA3\",\n                \"FR0000988040\"\n            };\n\n            foreach (string isin in isins) {\n                string validOrNot = IsinValidator.IsValidIsin(isin) ? \"valid\" : \"not valid\";\n                Console.WriteLine($\"{isin} is {validOrNot}\");\n            }\n        }\n    }\n}\n"}
{"id": 341981, "name": "Orbital elements", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse Math::Vector::Real;\n\nsub orbital_state_vectors {\n    my (\n        $semimajor_axis,\n        $eccentricity,\n        $inclination,\n        $longitude_of_ascending_node,\n        $argument_of_periapsis,\n        $true_anomaly\n    ) = @_[0..5];\n\n    my ($i, $j, $k) = (V(1,0,0), V(0,1,0), V(0,0,1));\n    \n    sub rotate {\n        my $alpha = shift;\n        @_[0,1] = (\n            +cos($alpha)*$_[0] + sin($alpha)*$_[1],\n            -sin($alpha)*$_[0] + cos($alpha)*$_[1]\n        );\n    }\n\n    rotate $longitude_of_ascending_node, $i, $j;\n    rotate $inclination,                 $j, $k;\n    rotate $argument_of_periapsis,       $i, $j;\n\n    my $l = $eccentricity == 1 ? \n        2*$semimajor_axis :\n        $semimajor_axis*(1 - $eccentricity**2);\n\n    my ($c, $s) = (cos($true_anomaly), sin($true_anomaly));\n\n    my $r = $l/(1 + $eccentricity*$c);\n    my $rprime = $s*$r**2/$l;\n\n    my $position = $r*($c*$i + $s*$j);\n\n    my $speed = \n    ($rprime*$c - $r*$s)*$i + ($rprime*$s + $r*$c)*$j;\n    $speed /= abs($speed);\n    $speed *= sqrt(2/$r - 1/$semimajor_axis);\n\n    {\n        position => $position,\n        speed    => $speed\n    }\n}\n\nuse Data::Dumper;\n\nprint Dumper orbital_state_vectors\n    1,                             \n    0.1,                           \n    0,                             \n    355/113/6,                     \n    0,                             \n    0                              \n    ;\n", "target": "using System;\n\nnamespace OrbitalElements {\n    class Vector {\n        public Vector(double x, double y, double z) {\n            X = x;\n            Y = y;\n            Z = z;\n        }\n\n        public double X { get; set; }\n        public double Y { get; set; }\n        public double Z { get; set; }\n\n        public double Abs() {\n            return Math.Sqrt(X * X + Y * Y + Z * Z);\n        }\n\n        public static Vector operator +(Vector lhs, Vector rhs) {\n            return new Vector(lhs.X + rhs.X, lhs.Y + rhs.Y, lhs.Z + rhs.Z);\n        }\n\n        public static Vector operator *(Vector self, double m) {\n            return new Vector(self.X * m, self.Y * m, self.Z * m);\n        }\n\n        public static Vector operator /(Vector self, double m) {\n            return new Vector(self.X / m, self.Y / m, self.Z / m);\n        }\n\n        public override string ToString() {\n            return string.Format(\"({0}, {1}, {2})\", X, Y, Z);\n        }\n    }\n\n    class Program {\n        static Tuple<Vector, Vector> OrbitalStateVectors(\n            double semiMajorAxis,\n            double eccentricity,\n            double inclination,\n            double longitudeOfAscendingNode,\n            double argumentOfPeriapsis,\n            double trueAnomaly\n        ) {\n            Vector mulAdd(Vector v1, double x1, Vector v2, double x2) {\n                return v1 * x1 + v2 * x2;\n            }\n\n            Tuple<Vector, Vector> rotate(Vector iv, Vector jv, double alpha) {\n                return new Tuple<Vector, Vector>(\n                    mulAdd(iv, +Math.Cos(alpha), jv, Math.Sin(alpha)),\n                    mulAdd(iv, -Math.Sin(alpha), jv, Math.Cos(alpha))\n                );\n            }\n\n            var i = new Vector(1, 0, 0);\n            var j = new Vector(0, 1, 0);\n            var k = new Vector(0, 0, 1);\n\n            var p = rotate(i, j, longitudeOfAscendingNode);\n            i = p.Item1; j = p.Item2;\n            p = rotate(j, k, inclination);\n            j = p.Item1;\n            p = rotate(i, j, argumentOfPeriapsis);\n            i = p.Item1; j = p.Item2;\n\n            var l = semiMajorAxis * ((eccentricity == 1.0) ? 2.0 : (1.0 - eccentricity * eccentricity));\n            var c = Math.Cos(trueAnomaly);\n            var s = Math.Sin(trueAnomaly);\n            var r = l / (1.0 + eccentricity * c);\n            var rprime = s * r * r / l;\n            var position = mulAdd(i, c, j, s) * r;\n            var speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c);\n            speed /= speed.Abs();\n            speed *= Math.Sqrt(2.0 / r - 1.0 / semiMajorAxis);\n\n            return new Tuple<Vector, Vector>(position, speed);\n        }\n\n        static void Main(string[] args) {\n            var res = OrbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0);\n            Console.WriteLine(\"Position\u00a0: {0}\", res.Item1);\n            Console.WriteLine(\"Speed   \u00a0: {0}\", res.Item2);\n        }\n    }\n}\n"}
{"id": 341982, "name": "Cycle detection", "source": "Translate Perl to C#: use utf8;\n\nsub cyclical_function { ($_[0] * $_[0] + 1) % 255 }\n\nsub brent {\n    my($f, $x0) = @_;\n    my $power = 1;\n    my $\u03bb = 1;\n    my $tortoise = $x0;\n    my $hare = &$f($x0);\n    while ($tortoise != $hare) {\n        if ($power == $\u03bb) {\n            $tortoise = $hare;\n            $power *= 2;\n            $\u03bb = 0;\n        }\n        $hare = &$f($hare);\n        $\u03bb += 1;\n    }\n\n    my $\u03bc = 0;\n    $tortoise = $hare = $x0;\n    $hare = &$f($hare) for 0..$\u03bb-1;\n\n    while ($tortoise != $hare) {\n        $tortoise = &$f($tortoise);\n        $hare = &$f($hare);\n        $\u03bc += 1;\n    }\n    return $\u03bb, $\u03bc;\n}\n\nmy ( $l, $s ) = brent( \\&cyclical_function, 3 );\n\nsub show_range {\n    my($start,$stop) = @_;\n    my $result;\n    my $x = 3;\n    for my $n (0..$stop) {\n        $result .= \"$x \" if $n >= $start;\n        $x = cyclical_function($x);\n    }\n    $result;\n}\n\nprint show_range(0,19) . \"\\n\";\nprint \"Cycle length $l\\n\";\nprint \"Cycle start index $s\\n\";\nprint show_range($s,$s+$l-1) . \"\\n\";\n", "target": "\n\n\nusing System;\n\nnamespace DetectCycles\n{\n  \n  \n  \n  public class Cycles<T> where T : IEquatable<T>\n  {\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public static Tuple<int,int> FindCycle(T x0, Func<T,T> yielder)\n    {\n      int power, lambda;\n      T tortoise, hare;\n      power = lambda = 1;\n      tortoise = x0;\n      hare = yielder(x0);\n\n      \n      while (!tortoise.Equals (hare)) {\n        if (power == lambda) {\n          tortoise = hare;\n          power *= 2;\n          lambda = 0;  \n        }\n        hare = yielder (hare);\n        lambda += 1;\n      }\n\n      \n      var mu = 0;\n      tortoise = hare = x0;\n      for (var times = 0; times < lambda; times++) \n        hare = yielder (hare);\n      \n      while (!tortoise.Equals (hare)) \n      {\n        tortoise = yielder (tortoise);\n        hare = yielder (hare);\n        mu += 1;\n      }\n\n      return new Tuple<int,int> (lambda, mu);\n    }\n  }\n}\n\n\n\nusing System;\n\nnamespace DetectCycles\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\t\n\t\t\tFunc<int,int> sequence = (int _x) => (_x * _x + 1) % 255;\n\n\t\t\t\n\t\t\tvar x = 3;\n\t\t\tConsole.Write(x);\n\t\t\tfor (var times = 0; times < 40; times++) \n\t\t\t{\n\t\t\t\tx = sequence(x);\n\t\t\t\tConsole.Write(String.Format(\",{0}\", x));\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\n\t\t\t\n\t\t\tvar cycle = Cycles<int>.FindCycle(3, sequence);\n\t\t\tvar clength = cycle.Item1;\n\t\t\tvar cstart = cycle.Item2;\n\t\t\tConsole.Write(String.Format(\"Cycle length = {0}\\nStart index = {1}\\n\", clength, cstart));\n\t\t}\n\t}\n}\n"}
{"id": 341983, "name": "Input_Output for pairs of numbers", "source": "Translate Perl to C#: $n = scalar <>;\n\nfor (1..$n) {\n    ($a,$b) = split ' ', <>;\n    print $a + $b . \"\\n\";\n}\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main(string[] args)\n    {\n\tint count = Convert.ToInt32(Console.ReadLine());\n\tfor (int line = 0; line < count; line++) {\n            Console.WriteLine(Console.ReadLine().Split(' ').Sum(i => Convert.ToInt32(i)));\n\t}\n    }\n}\n"}
{"id": 341984, "name": "Kahan summation", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub kahan {\n    my(@nums) = @_;\n    my $summ = my $c = 0e0;\n    for my $num (@nums) {\n        my $y = $num - $c;\n        my $t = $summ + $y;\n        $c = ($t - $summ) - $y;\n        $summ = $t;\n    }\n    $summ\n}\n\nmy $eps = 1;\ndo { $eps /= 2 } until 1e0 == 1e0 + $eps;\n\nsay 'Epsilon:    ' . $eps;\nsay 'Simple sum: ' . sprintf \"%.16f\", ((1e0 + $eps) - $eps);\nsay 'Kahan sum:  ' . sprintf \"%.16f\", kahan(1e0, $eps, -$eps);\n", "target": "using System;\n\nnamespace KahanSummation {\n    class Program {\n        static float KahanSum(params float[] fa) {\n            float sum = 0.0f;\n            float c = 0.0f;\n            foreach (float f in fa) {\n                float y = f - c;\n                float t = sum + y;\n                c = (t - sum) - y;\n                sum = t;\n            }\n\n            return sum;\n        }\n\n        static float Epsilon() {\n            float eps = 1.0f;\n            while (1.0f + eps != 1.0f) eps /= 2.0f;\n            return eps;\n        }\n\n        static void Main(string[] args) {\n            float a = 1.0f;\n            float b = Epsilon();\n            float c = -b;\n            Console.WriteLine(\"Epsilon      = {0}\", b);\n            Console.WriteLine(\"(a + b) + c  = {0}\", (a + b) + c);\n            Console.WriteLine(\"Kahan sum    = {0}\", KahanSum(a, b, c));\n        }\n    }\n}\n"}
{"id": 341985, "name": "ABC words", "source": "Translate Perl to C#: \n\n@ARGV = 'unixdict.txt';\nprint grep /^[^bc]*a[^c]*b.*c/, <>;\n", "target": "class Program {\n    static void Main(string[] args) { int bi, i = 0; string chars = args.Length < 1 ? \"abc\" : args[0];\n        foreach (var item in System.IO.File.ReadAllLines(\"unixdict.txt\")) {\n            int ai = -1; foreach (var ch in chars)\n                if ((bi = item.IndexOf(ch)) > ai) ai = bi; else goto skip;\n            System.Console.Write(\"{0,3} {1,-18} {2}\", ++i, item, i % 5 == 0 ? \"\\n\" : \"\");\n        skip: ; } }\n}\n"}
{"id": 341986, "name": "Text between", "source": "Translate Perl to C#: use feature 'say';\n\nsub text_between {\n    my($text, $start, $end) = @_;\n    return join ',', $text =~ /$start(.*?)$end/g;\n}\n\n$text = 'Hello Rosetta Code world';\n\n\nsay '1> '. text_between($text,  'Hello ', ' world' );\n\n\nsay '2> '. text_between($text,  qr/^/, ' world' );\n\n\nsay '3> '. text_between($text,  'Hello ',  qr/$/ );\n\n\nsay '4> '. text_between('</div><div style=\"chinese\">\u4f60\u597d\u55ce</div>', '<div style=\"chinese\">', '</div>' );\n\n\nsay '5> '. text_between('<text>Hello <span>Rosetta Code</span> world</text><table style=\"myTable\">', '<text>', qr/<table>|$/ );\n\n\nsay '6> '. text_between('<table style=\"myTable\"><tr><td>hello world</td></tr></table>', '<table>', '</table>' );\n\n\nsay '7> '. text_between( 'The quick brown fox jumps over the lazy other fox', 'quick ', ' fox' );\n\n\nsay '8> '. text_between( 'One fish two fish red fish blue fish', 'fish ', ' red' );\n\n\nsay '9> '. text_between('FooBarBazFooBuxQuux', 'Foo', 'Foo' );\n\n\nsay '10> '. text_between( $text, 'e', 'o' );\n\n\n$text = 'Soothe a guilty conscience today, string wrangling is not the best tool to use for this job.';\nsay '11> '.  text_between($text, qr/\\bthe /, qr/ to\\b/);\n", "target": "using System;\n\nnamespace TextBetween {\n    class Program {\n        static string TextBetween(string source, string beg, string end) {\n            int startIndex;\n\n            if (beg == \"start\") {\n                startIndex = 0;\n            }\n            else {\n                startIndex = source.IndexOf(beg);\n                if (startIndex < 0) {\n                    return \"\";\n                }\n                startIndex += beg.Length;\n            }\n\n            int endIndex = source.IndexOf(end, startIndex);\n            if (endIndex < 0 || end == \"end\") {\n                return source.Substring(startIndex);\n            }\n            return source.Substring(startIndex, endIndex - startIndex);\n        }\n\n        static void Print(string s, string b, string e) {\n            Console.WriteLine(\"text: '{0}'\", s);\n            Console.WriteLine(\"start: '{0}'\", b);\n            Console.WriteLine(\"end: '{0}'\", e);\n            Console.WriteLine(\"result: '{0}'\", TextBetween(s, b, e));\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            Print(\"Hello Rosetta Code world\", \"Hello \", \" world\");\n            Print(\"Hello Rosetta Code world\", \"start\", \" world\");\n            Print(\"Hello Rosetta Code world\", \"Hello \", \"end\");\n            Print(\"</div><div style=\\\"chinese\\\">\u4f60\u597d\u55ce</div>\", \"<div style=\\\"chinese\\\">\", \"</div>\");\n            Print(\"<text>Hello <span>Rosetta Code</span> world</text><table style=\\\"myTable\\\">\", \"<text>\", \"<table>\");\n            Print(\"<table style=\\\"myTable\\\"><tr><td>hello world</td></tr></table>\", \"<table>\", \"</table>\");\n            Print(\"The quick brown fox jumps over the lazy other fox\", \"quick \", \" fox\");\n            Print(\"One fish two fish red fish blue fish\", \"fish \", \" red\");\n            Print(\"FooBarBazFooBuxQuux\", \"Foo\", \"Foo\");\n        }\n    }\n}\n"}
{"id": 341987, "name": "Two identical strings", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\n\nwhile( 1 )\n  {\n  my $binary = ( sprintf \"%b\", ++$- ) x 2;\n  (my $decimal = oct \"b$binary\") >= 1000 and last;\n  printf \"%4d  %s\\n\", $decimal, $binary;\n  }\n", "target": "using System; using static System.Console;\nclass Program { static void Main() { int c = 0, lmt = 1000;\n    for (int n = 1, p = 2, k; n <= lmt; n++)\n      if ((k = n + n * (p += n >= p ? p : 0)) > lmt) break;\n      else Console.Write(\"{0,3} ({1,-10})  {2}\", k,\n          Convert.ToString(k, 2), ++c % 5 == 0 ? \"\\n\" : \"\");\n    Write(\"\\nFound {0} numbers whose base 2 representation is the \" +\n      \"concatenation of two identical binary strings.\", c); } }\n"}
{"id": 341988, "name": "Sum of first n cubes", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\n\nmy $sum = 0;\nprintf \"%10d%s\", $sum += $_ ** 3, $_ % 5 == 4 && \"\\n\" for 0 .. 49;\n", "target": "using System; using static System.Console;\nclass Program { static void Main(string[] args) {\n    for (int i=0,j=-6,k=1,c=0,s=0;s<1600000;s+=c+=k+=j+=6)\n      Write(\"{0,-7}{1}\",s, (i+=i==3?-4:1)==0?\"\\n\":\" \"); } }\n"}
{"id": 341989, "name": "Copy a string", "source": "Translate Perl to C#: my $original = 'Hello.';\nmy $new = $original;\n$new = 'Goodbye.';\nprint \"$original\\n\";   \n", "target": "string src = \"Hello\";\nstring dst = src;\n"}
{"id": 341990, "name": "Exceptions", "source": "Translate Perl to C#: \ndie \"Danger, danger, Will Robinson!\";\n\n\neval {\n    die \"this could go wrong mightily\";\n};\nprint $@ if $@;\n\n\ndie $@;\n", "target": "public class MyException : Exception\n{\n  \n};\n"}
{"id": 341991, "name": "2048", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse Tk;\n\nmy $N = shift // 4;\n$N < 2 and $N = 2;\nmy @squares = 1 .. $N*$N;\nmy %n2ch = (' ' => ' ');\n@n2ch{ map 2**$_, 1..26} = 'a'..'z';\nmy %ch2n = reverse %n2ch;\nmy $winner = '';\nmy @arow = 0 .. $N - 1;\nmy @acol = map $_ * $N, @arow;\n\nmy $mw = MainWindow->new;\n$mw->geometry( '+300+0' );\n$mw->title( 2048 );\n$mw->focus;\n$mw->bind('<KeyPress-Left>' => sub { arrow($N, @arow) } );\n$mw->bind('<KeyPress-Right>' => sub { arrow($N, reverse @arow) } );\n$mw->bind('<KeyPress-Up>' => sub { arrow(1, @acol) } );\n$mw->bind('<KeyPress-Down>' => sub { arrow(1, reverse @acol) } );\nmy $grid = $mw->Frame()->pack;\nfor my $i ( 0 .. $\n  {\n  $grid->Label(-textvariable => \\$squares[$i],\n    -width => 5, -height => 2, -font => 'courierbold 30',\n    -relief => 'ridge', -borderwidth => 5,\n    )->grid(-row => int $i / $N, -column => $i % $N );\n  }\nmy $buttons = $mw->Frame()->pack(-fill => 'x', -expand => 1);\n$buttons->Button(-text => 'Exit', -command => sub {$mw->destroy},\n  -font => 'courierbold 14',\n  )->pack(-side => 'right');\n$buttons->Button(-text => 'New Game', -command => \\&newgame,\n  -font => 'courierbold 14',\n  )->pack(-side => 'left');\n$buttons->Label(-textvariable => \\$winner,\n  -font => 'courierbold 18', -fg => 'red2',\n  )->pack;\n\nnewgame();\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub losecheck\n  {\n  local $_ = join '', @n2ch{ @squares };\n  / / || ($_ ^ substr $_, $N) =~ tr/\\0// and return;\n  /(.)\\1/ and return for /.{$N}/g;\n  $winner = 'You Lost';\n  }\n\nsub arrow\n  {\n  $winner and return;                                   \n  my ($inc, @ix) = @_;\n  my $oldboard = \"@squares\";\n  for ( 1 .. $N )\n    {\n    local $_ = join '', @n2ch{ @squares[@ix] };         \n    tr/ //d;                                            \n    s/(\\w)\\1/ chr 1 + ord $1 /ge;                       \n    @squares[@ix] = @ch2n{ split //, $_ . ' ' x $N };   \n    $_ += $inc for @ix;                                 \n    }\n  $oldboard eq \"@squares\" and return;\n  add2();\n  losecheck();\n  grep $_ eq 2048, @squares and $winner = 'WINNER\u00a0!!';\n  }\n\nsub add2\n  {\n  my @blanks = grep $squares[$_] eq ' ', 0 .. $\n  @blanks and $squares[ $blanks[rand @blanks] ] =\n    $_[0] // (rand() < 0.1 ? 4 : 2);\n  }\n\nsub newgame\n  {\n  $_ = ' ' for @squares;\n  add2(2) for 1, 2;\n  $winner = '';\n  }\n", "target": "using System;\n\nnamespace g2048_csharp\n{\n    internal class Tile\n    {\n        public Tile()\n        {\n            Value = 0;\n            IsBlocked = false;\n        }\n\n        public int Value { get; set; }\n        public bool IsBlocked { get; set; }\n    }\n\n    internal enum MoveDirection\n    {\n        Up,\n        Down,\n        Left,\n        Right\n    }\n\n    internal class G2048\n    {\n        public G2048()\n        {\n            _isDone = false;\n            _isWon = false;\n            _isMoved = true;\n            _score = 0;\n            InitializeBoard();\n        }\n\n        private void InitializeBoard()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    _board[x, y] = new Tile();\n                }\n            }\n        }\n\n        private bool _isDone;\n        private bool _isWon;\n        private bool _isMoved;\n        private int _score;\n        private readonly Tile[,] _board = new Tile[4, 4];\n        private readonly Random _rand = new Random();\n\n        public void Loop()\n        {\n            AddTile();\n            while (true)\n            {\n                if (_isMoved)\n                {\n                    AddTile();\n                }\n\n                DrawBoard();\n                if (_isDone)\n                {\n                    break;\n                }\n\n                WaitKey();\n            }\n\n            string endMessage = _isWon ? \"You've made it!\" : \"Game Over!\";\n            Console.WriteLine(endMessage);\n        }\n\n        private void DrawBoard()\n        {\n            Console.Clear();\n            Console.WriteLine(\"Score: \" + _score + \"\\n\");\n            for (int y = 0; y < 4; y++)\n            {\n                Console.WriteLine(\"+------+------+------+------+\");\n                Console.Write(\"| \");\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value == 0)\n                    {\n                        const string empty = \" \";\n                        Console.Write(empty.PadRight(4));\n                    }\n                    else\n                    {\n                        Console.Write(_board[x, y].Value.ToString().PadRight(4));\n                    }\n\n                    Console.Write(\" | \");\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"+------+------+------+------+\\n\\n\");\n        }\n\n        private void WaitKey()\n        {\n            _isMoved = false;\n            Console.WriteLine(\"(W) Up (S) Down (A) Left (D) Right\");\n            char input;\n            char.TryParse(Console.ReadKey().Key.ToString(), out input);\n\n            switch (input)\n            {\n                case 'W':\n                    Move(MoveDirection.Up);\n                    break;\n                case 'A':\n                    Move(MoveDirection.Left);\n                    break;\n                case 'S':\n                    Move(MoveDirection.Down);\n                    break;\n                case 'D':\n                    Move(MoveDirection.Right);\n                    break;\n            }\n\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    _board[x, y].IsBlocked = false;\n                }\n            }\n        }\n\n        private void AddTile()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value != 0) continue;\n                    int a, b;\n                    do\n                    {\n                        a = _rand.Next(0, 4);\n                        b = _rand.Next(0, 4);\n                    } while (_board[a, b].Value != 0);\n\n                    double r = _rand.NextDouble();\n                    _board[a, b].Value = r > 0.89f ? 4 : 2;\n\n                    if (CanMove())\n                    {\n                        return;\n                    }\n                }\n            }\n\n            _isDone = true;\n        }\n\n        private bool CanMove()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value == 0)\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (TestAdd(x + 1, y, _board[x, y].Value)\n                        || TestAdd(x - 1, y, _board[x, y].Value)\n                        || TestAdd(x, y + 1, _board[x, y].Value)\n                        || TestAdd(x, y - 1, _board[x, y].Value))\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private bool TestAdd(int x, int y, int value)\n        {\n            if (x < 0 || x > 3 || y < 0 || y > 3)\n            {\n                return false;\n            }\n\n            return _board[x, y].Value == value;\n        }\n\n        private void MoveVertically(int x, int y, int d)\n        {\n            if (_board[x, y + d].Value != 0\n                && _board[x, y + d].Value == _board[x, y].Value\n                && !_board[x, y].IsBlocked\n                && !_board[x, y + d].IsBlocked)\n            {\n                _board[x, y].Value = 0;\n                _board[x, y + d].Value *= 2;\n                _score += _board[x, y + d].Value;\n                _board[x, y + d].IsBlocked = true;\n                _isMoved = true;\n            }\n            else if (_board[x, y + d].Value == 0\n                     && _board[x, y].Value != 0)\n            {\n                _board[x, y + d].Value = _board[x, y].Value;\n                _board[x, y].Value = 0;\n                _isMoved = true;\n            }\n\n            if (d > 0)\n            {\n                if (y + d < 3)\n                {\n                    MoveVertically(x, y + d, 1);\n                }\n            }\n            else\n            {\n                if (y + d > 0)\n                {\n                    MoveVertically(x, y + d, -1);\n                }\n            }\n        }\n\n        private void MoveHorizontally(int x, int y, int d)\n        {\n            if (_board[x + d, y].Value != 0\n                && _board[x + d, y].Value == _board[x, y].Value\n                && !_board[x + d, y].IsBlocked\n                && !_board[x, y].IsBlocked)\n            {\n                _board[x, y].Value = 0;\n                _board[x + d, y].Value *= 2;\n                _score += _board[x + d, y].Value;\n                _board[x + d, y].IsBlocked = true;\n                _isMoved = true;\n            }\n            else if (_board[x + d, y].Value == 0\n                     && _board[x, y].Value != 0)\n            {\n                _board[x + d, y].Value = _board[x, y].Value;\n                _board[x, y].Value = 0;\n                _isMoved = true;\n            }\n\n            if (d > 0)\n            {\n                if (x + d < 3)\n                {\n                    MoveHorizontally(x + d, y, 1);\n                }\n            }\n            else\n            {\n                if (x + d > 0)\n                {\n                    MoveHorizontally(x + d, y, -1);\n                }\n            }\n        }\n\n        private void Move(MoveDirection direction)\n        {\n            switch (direction)\n            {\n                case MoveDirection.Up:\n                    for (int x = 0; x < 4; x++)\n                    {\n                        int y = 1;\n                        while (y < 4)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveVertically(x, y, -1);\n                            }\n\n                            y++;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Down:\n                    for (int x = 0; x < 4; x++)\n                    {\n                        int y = 2;\n                        while (y >= 0)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveVertically(x, y, 1);\n                            }\n\n                            y--;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Left:\n                    for (int y = 0; y < 4; y++)\n                    {\n                        int x = 1;\n                        while (x < 4)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveHorizontally(x, y, -1);\n                            }\n\n                            x++;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Right:\n                    for (int y = 0; y < 4; y++)\n                    {\n                        int x = 2;\n                        while (x >= 0)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveHorizontally(x, y, 1);\n                            }\n\n                            x--;\n                        }\n                    }\n\n                    break;\n            }\n        }\n    }\n\n    internal static class Program\n    {\n        public static void Main(string[] args)\n        {\n            RunGame();\n        }\n\n        private static void RunGame()\n        {\n            G2048 game = new G2048();\n            game.Loop();\n\n            CheckRestart();\n        }\n\n        private static void CheckRestart()\n        {\n            Console.WriteLine(\"(N) New game (P) Exit\");\n            while (true)\n            {\n                char input;\n                char.TryParse(Console.ReadKey().Key.ToString(), out input);\n                switch (input)\n                {\n                    case 'N':\n                        RunGame();\n                        break;\n                    case 'P':\n                        return;\n                    default:\n                        ClearLastLine();\n                        break;\n                }\n            }\n        }\n\n        private static void ClearLastLine()\n        {\n            Console.SetCursorPosition(0, Console.CursorTop);\n            Console.Write(new string(' ', Console.BufferWidth));\n            Console.SetCursorPosition(0, Console.CursorTop - 1);\n        }\n    }\n}\n"}
{"id": 341992, "name": "Successive prime differences", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse List::EachCons;\nuse Array::Compare;\nuse ntheory 'primes';\n\nmy $limit = 1E6;\nmy @primes = (2, @{ primes($limit) });\nmy @intervals = map { $primes[$_] - $primes[$_-1] } 1..$\n\nprint \"Groups of successive primes <= $limit\\n\";\n\nmy $c = Array::Compare->new;\nfor my $diffs ([2], [1], [2,2], [2,4], [4,2], [6,4,2]) {\n    my $n = -1;\n    my @offsets = grep {$_} each_cons @$diffs, @intervals, sub { $n++; $n if $c->compare(\\@_, \\@$diffs) };\n    printf \"%10s has %5d sets: %15s \u2026 %s\\n\", \n       '(' . join(' ',@$diffs) . ')',\n        scalar @offsets,\n        join(' ', @primes[$offsets[ 0]..($offsets[ 0]+@$diffs)]),\n        join(' ', @primes[$offsets[-1]..($offsets[-1]+@$diffs)]);\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class SuccessivePrimeDifferences {\n\n    public static void Main() {\n        var primes = GeneratePrimes(1_000_000).ToList();\n        foreach (var d in new[] {\n            new [] { 2 },\n            new [] { 1 },\n            new [] { 2, 2 },\n            new [] { 2, 4 },\n            new [] { 4, 2 },\n            new [] { 6, 4, 2 },\n        }) {\n            IEnumerable<int> first = null, last = null;\n            int count = 0;\n            foreach (var grp in FindDifferenceGroups(d)) {\n                if (first == null) first = grp;\n                last = grp;\n                count++;\n            }\n            Console.WriteLine($\"{$\"({string.Join(\", \", first)})\"}, {$\"({string.Join(\", \", last)})\"}, {count}\");\n        }\n\n        IEnumerable<IEnumerable<int>> FindDifferenceGroups(int[] diffs) {\n            for (int pi = diffs.Length; pi < primes.Count; pi++)\n                if (Range(0, diffs.Length).All(di => primes[pi-diffs.Length+di+1] - primes[pi-diffs.Length+di] == diffs[di]))\n                    yield return Range(pi - diffs.Length, diffs.Length + 1).Select(i => primes[i]);\n        }\n\n        IEnumerable<int> GeneratePrimes(int lmt) {\n            bool[] comps = new bool[lmt + 1];\n            comps[0] = comps[1] = true;\n            yield return 2; yield return 3;\n            for (int j = 4; j <= lmt; j += 2) comps[j] = true;\n            for (int j = 9; j <= lmt; j += 6) comps[j] = true;\n            int i = 5, d = 4, rt = (int)Math.Sqrt(lmt);\n            for ( ; i <= rt; i += (d = 6 - d))\n                if (!comps[i]) {\n                    yield return i;\n                    for (int j = i * i, k = i << 1; j <= lmt; j += k)\n                        comps[j] = true;\n                }\n            for ( ; i <= lmt; i += (d = 6 - d)) if (!comps[i]) yield return i;\n        }\n    }\n}\n"}
{"id": 341993, "name": "10001th prime", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\n\nmy($n,$c) = (1,0);\nwhile () {\n    $c++ if (1 x ++$n) !~ /^(11+)\\1+$/;\n    $c == 10_001 and say $n and last;\n}\n\n\nuse ntheory 'nth_prime';\nsay nth_prime(10_001);\n", "target": "using System; class Program {\n\n  static bool isprime(uint p ) { if ((p & 1) == 0) return p == 2;\n    if ((p % 3) == 0) return p == 3;\n    for (uint i = 5, d = 4; i * i <= p; i += (d = 6 - d))\n      if (p % i == 0) return false; return true; }\n \n  static uint prime(uint n) { uint p, d, pn;\n    for (p = 5, d = 4, pn = 2; pn < n; p += (d = 6 - d))\n      if (isprime(p)) pn++; return p - d; }\n\n  static void Main(string[] args) {\n    Console.WriteLine(\"One-at-a-time trial division vs sieve of Eratosthenes\");\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    var t = prime(10001); sw.Stop(); double e1, e2;\n    Console.Write(\"{0:n0} {1} ms\", prime(10001),\n      e1 = sw.Elapsed.TotalMilliseconds);\n    sw.Restart(); uint n = 105000, i, j; var pr = new uint[10100];\n    pr[0] = 2; pr[1] = 3; uint pc = 2, r, d, ii;\n    var pl = new bool[n + 1]; r = (uint)Math.Sqrt(n);\n    for (i = 9; i < n; i += 6) pl[i] = true;\n    for (i = 5, d = 4; i <= r; i += (d = 6 - d)) if (!pl[i]) {\n      pr[pc++] = i; for (j = i * i, ii = i << 1; j <= n; j += ii)\n        pl[j] = true; }\n    for ( ;i <= n; i += (d = 6 - d)) if (!pl[i]) pr[pc++] = i;\n    t = pr[10000]; sw.Stop();\n    Console.Write(\"  {0:n0} {1} \u03bcs  {2:0.000} times faster\", t,\n      (e2 = sw.Elapsed.TotalMilliseconds) * 1000.0, e1 / e2); } }\n"}
{"id": 341994, "name": "10001th prime", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\n\nmy($n,$c) = (1,0);\nwhile () {\n    $c++ if (1 x ++$n) !~ /^(11+)\\1+$/;\n    $c == 10_001 and say $n and last;\n}\n\n\nuse ntheory 'nth_prime';\nsay nth_prime(10_001);\n", "target": "using System; class Program {\n\n  static bool isprime(uint p ) { if ((p & 1) == 0) return p == 2;\n    if ((p % 3) == 0) return p == 3;\n    for (uint i = 5, d = 4; i * i <= p; i += (d = 6 - d))\n      if (p % i == 0) return false; return true; }\n \n  static uint prime(uint n) { uint p, d, pn;\n    for (p = 5, d = 4, pn = 2; pn < n; p += (d = 6 - d))\n      if (isprime(p)) pn++; return p - d; }\n\n  static void Main(string[] args) {\n    Console.WriteLine(\"One-at-a-time trial division vs sieve of Eratosthenes\");\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    var t = prime(10001); sw.Stop(); double e1, e2;\n    Console.Write(\"{0:n0} {1} ms\", prime(10001),\n      e1 = sw.Elapsed.TotalMilliseconds);\n    sw.Restart(); uint n = 105000, i, j; var pr = new uint[10100];\n    pr[0] = 2; pr[1] = 3; uint pc = 2, r, d, ii;\n    var pl = new bool[n + 1]; r = (uint)Math.Sqrt(n);\n    for (i = 9; i < n; i += 6) pl[i] = true;\n    for (i = 5, d = 4; i <= r; i += (d = 6 - d)) if (!pl[i]) {\n      pr[pc++] = i; for (j = i * i, ii = i << 1; j <= n; j += ii)\n        pl[j] = true; }\n    for ( ;i <= n; i += (d = 6 - d)) if (!pl[i]) pr[pc++] = i;\n    t = pr[10000]; sw.Stop();\n    Console.Write(\"  {0:n0} {1} \u03bcs  {2:0.000} times faster\", t,\n      (e2 = sw.Elapsed.TotalMilliseconds) * 1000.0, e1 / e2); } }\n"}
{"id": 341995, "name": "Terminal control_Dimensions", "source": "Translate Perl to C#: use Term::Size;\n\n($cols, $rows) = Term::Size::chars;\nprint \"The terminal has $cols columns and $rows lines\\n\";\n", "target": "static void Main(string[] args)\n{\n    int bufferHeight = Console.BufferHeight;\n    int bufferWidth = Console.BufferWidth;\n    int windowHeight = Console.WindowHeight;\n    int windowWidth = Console.WindowWidth;\n\n    Console.Write(\"Buffer Height: \");\n    Console.WriteLine(bufferHeight);\n    Console.Write(\"Buffer Width: \");\n    Console.WriteLine(bufferWidth);\n    Console.Write(\"Window Height: \");\n    Console.WriteLine(windowHeight);\n    Console.Write(\"Window Width: \");\n    Console.WriteLine(windowWidth);\n    Console.ReadLine();\n}\n"}
{"id": 341996, "name": "Largest number divisible by its digits", "source": "Translate Perl to C#: my $step = 9 * 8 * 7;                               \n\nmy $initial = int(9876432 / $step) * $step;         \n\nfor($test = $initial; $test > 0 ; $test -= $step) { \n    next if $test =~ /[05]/;                        \n    next if $test =~ /(.).*\\1/;                     \n\n    for (split '', $test) {                         \n        next unless ($test / $_) % 1;\n    }\n\n    printf \"Found $test after %d steps\\n\", ($initial-$test)/$step;\n    for (split '', $test) {\n       printf \"%s / %s = %s\\n\", $test, $_, $test / $_;\n    }\n    last\n}\n", "target": "using System;\n\nclass Program {\n    static int gcd(int a, int b) { return b > 0 ? gcd(b, a % b) : a; }\n\n    \n    static int lcmd(long x, int b) {\n      int r = (int)(x % b), a; x /= b; while (x > 0) {\n        r = (r * (a = (int)(x % b))) / gcd(r, a); x /= b; } return r; }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        long mx = 987654321; \n             mx = 98764321; \n             mx /= 10;     \n        long skip = lcmd(mx, 10), i; bool nDup;\n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString().ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k] || s[k] == '5') { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 10 = {0} in {1} \u03bcs\\n\", i,\n          1000 * sw.Elapsed.TotalMilliseconds);\n        sw.Restart();\n        mx = 0xfedcba987654321;    \n        skip = lcmd(mx >> 4, 16); \n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString(\"x\").ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k]) { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 16 = {0} in {1} ms\", i.ToString(\"x\"),\n          sw.Elapsed.TotalMilliseconds); } }\n"}
{"id": 341997, "name": "Largest number divisible by its digits", "source": "Translate Perl to C#: my $step = 9 * 8 * 7;                               \n\nmy $initial = int(9876432 / $step) * $step;         \n\nfor($test = $initial; $test > 0 ; $test -= $step) { \n    next if $test =~ /[05]/;                        \n    next if $test =~ /(.).*\\1/;                     \n\n    for (split '', $test) {                         \n        next unless ($test / $_) % 1;\n    }\n\n    printf \"Found $test after %d steps\\n\", ($initial-$test)/$step;\n    for (split '', $test) {\n       printf \"%s / %s = %s\\n\", $test, $_, $test / $_;\n    }\n    last\n}\n", "target": "using System;\n\nclass Program {\n    static int gcd(int a, int b) { return b > 0 ? gcd(b, a % b) : a; }\n\n    \n    static int lcmd(long x, int b) {\n      int r = (int)(x % b), a; x /= b; while (x > 0) {\n        r = (r * (a = (int)(x % b))) / gcd(r, a); x /= b; } return r; }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        long mx = 987654321; \n             mx = 98764321; \n             mx /= 10;     \n        long skip = lcmd(mx, 10), i; bool nDup;\n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString().ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k] || s[k] == '5') { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 10 = {0} in {1} \u03bcs\\n\", i,\n          1000 * sw.Elapsed.TotalMilliseconds);\n        sw.Restart();\n        mx = 0xfedcba987654321;    \n        skip = lcmd(mx >> 4, 16); \n        for (i = mx - mx % skip; ; i -= skip) {\n            var s = i.ToString(\"x\").ToCharArray(); Array.Sort(s);\n            if (s[0] == '0') continue; \n            nDup = true; \n            for (int j = 0, k = 1; k < s.Length; j = k++)\n                if (s[j] == s[k]) { nDup = false; break; }\n            if (nDup) break; } sw.Stop(); \n        Console.Write(\"base 16 = {0} in {1} ms\", i.ToString(\"x\"),\n          sw.Elapsed.TotalMilliseconds); } }\n"}
{"id": 341998, "name": "Sattolo cycle", "source": "Translate Perl to C#: @a = 0..30;\n\nprintf \"%2d \", $_ for @a; print \"\\n\";\nsattolo_cycle(\\@a);\nprintf \"%2d \", $_ for @a; print \"\\n\";\n\nsub sattolo_cycle {\n    my($array) = @_;\n    for $i (reverse 0 .. -1+@$array) {\n        my $j = int rand $i;\n        @$array[$j, $i] = @$array[$i, $j];\n    }\n}\n", "target": "private static readonly Random Rand = new Random();\n\nvoid sattoloCycle<T>(IList<T> items) {\n    for (var i = items.Count; i-- > 1;) {\n        int j = Rand.Next(i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 341999, "name": "Sattolo cycle", "source": "Translate Perl to C#: @a = 0..30;\n\nprintf \"%2d \", $_ for @a; print \"\\n\";\nsattolo_cycle(\\@a);\nprintf \"%2d \", $_ for @a; print \"\\n\";\n\nsub sattolo_cycle {\n    my($array) = @_;\n    for $i (reverse 0 .. -1+@$array) {\n        my $j = int rand $i;\n        @$array[$j, $i] = @$array[$i, $j];\n    }\n}\n", "target": "private static readonly Random Rand = new Random();\n\nvoid sattoloCycle<T>(IList<T> items) {\n    for (var i = items.Count; i-- > 1;) {\n        int j = Rand.Next(i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 342000, "name": "Twin primes", "source": "Translate Perl to C#: use strict;\nuse warnings;\n\nuse Primesieve;\n\nsub comma { reverse ((reverse shift) =~ s/(.{3})/$1,/gr) =~ s/^,//r }\n\nprintf \"Twin prime pairs less than %14s: %s\\n\", comma(10**$_), comma count_twins(1, 10**$_) for 1..10;\n", "target": "using System;\n\nclass Program {\n\n    static uint[] res = new uint[10];\n    static uint ri = 1, p = 10, count = 0;\n\n    static void TabulateTwinPrimes(uint bound) {\n        if (bound < 5) return; count++;\n        uint cl = (bound - 1) >> 1, i = 1, j,\n             limit = (uint)(Math.Sqrt(bound) - 1) >> 1;\n        var comp = new bool[cl]; bool lp;\n        for (j = 3; j < cl; j += 3) comp[j] = true;\n        while (i < limit) {\n            if (lp = !comp[i]) {\n                uint pr = (i << 1) + 3;\n                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)\n                    comp[j] = true;\n            }\n            if (!comp[++i]) {\n                uint pr = (i << 1) + 3;\n                if (lp) {\n                    if (pr > p) {\n                        res[ri++] = count;\n                        p *= 10;\n                    }\n                    count++;\n                    i++;\n                }\n                for (j = (pr * pr - 2) >> 1; j < cl; j += pr)\n                    comp[j] = true; \n            }\n        }\n        cl--;\n        while (i < cl) {\n            lp = !comp[i++];\n            if (!comp[i] && lp) {\n                if ((i++ << 1) + 3 > p) {\n                    res[ri++] = count;\n                    p *= 10;\n                }\n                count++;\n            }\n        }\n        res[ri] = count;\n    }\n\n    static void Main(string[] args) {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        string fmt = \"{0,9:n0} twin primes below {1,-13:n0}\";\n        TabulateTwinPrimes(1_000_000_000);\n        sw.Stop();\n        p = 1;\n        for (var j = 1; j <= ri; j++)\n            Console.WriteLine(fmt, res[j], p *= 10);\n        Console.Write(\"{0} sec\", sw.Elapsed.TotalSeconds);\n    }\n}\n"}
{"id": 342001, "name": "Brazilian numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse ntheory qw<is_prime>;\nuse constant Inf  => 1e10;\n\nsub is_Brazilian {\n    my($n) = @_;\n    return 1 if $n > 6 && 0 == $n%2;\n    LOOP: for (my $base = 2; $base < $n - 1; ++$base) {\n        my $digit;\n        my $nn = $n;\n        while (1) {\n            my $x = $nn % $base;\n            $digit //= $x;\n            next LOOP if $digit != $x;\n            $nn = int $nn / $base;\n            if ($nn < $base) {\n                return 1 if $digit == $nn;\n                next LOOP;\n            }\n        }\n    }\n}\n\nmy $upto = 20;\n\nprint \"First $upto Brazilian numbers:\\n\";\nmy $n = 0;\nprint do { $n < $upto ? (is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto odd Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!($_%2) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto prime Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!is_prime($_) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 342002, "name": "Brazilian numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse ntheory qw<is_prime>;\nuse constant Inf  => 1e10;\n\nsub is_Brazilian {\n    my($n) = @_;\n    return 1 if $n > 6 && 0 == $n%2;\n    LOOP: for (my $base = 2; $base < $n - 1; ++$base) {\n        my $digit;\n        my $nn = $n;\n        while (1) {\n            my $x = $nn % $base;\n            $digit //= $x;\n            next LOOP if $digit != $x;\n            $nn = int $nn / $base;\n            if ($nn < $base) {\n                return 1 if $digit == $nn;\n                next LOOP;\n            }\n        }\n    }\n}\n\nmy $upto = 20;\n\nprint \"First $upto Brazilian numbers:\\n\";\nmy $n = 0;\nprint do { $n < $upto ? (is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto odd Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!($_%2) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n\nprint \"\\n\\nFirst $upto prime Brazilian numbers:\\n\";\n$n = 0;\nprint do { $n < $upto ? (!!is_prime($_) and is_Brazilian($_) and ++$n and \"$_ \") : last } for 1 .. Inf;\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 342003, "name": "Recaman's sequence", "source": "Translate Perl to C#: use bignum;\n\n$max = 1000;\n$remaining += $_ for 1..$max;\n\nmy @recamans = 0;\nmy $previous = 0;\n\nwhile ($remaining > 0) {\n   $term++;\n   my $this = $previous - $term;\n   $this = $previous + $term unless $this > 0 and !$seen{$this};\n   push @recamans, $this;\n   $dup = $term if !$dup and defined $seen{$this};\n   $remaining -= $this if $this <= $max and ! defined $seen{$this};\n   $seen{$this}++;\n   $previous = $this;\n}\n\nprint \"First fifteen terms of Recaman's sequence: \" . join(' ', @recamans[0..14]) . \"\\n\";\nprint \"First duplicate at term: a[$dup]\\n\";\nprint \"Range 0..1000 covered by terms up to a[$term]\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 342004, "name": "Recaman's sequence", "source": "Translate Perl to C#: use bignum;\n\n$max = 1000;\n$remaining += $_ for 1..$max;\n\nmy @recamans = 0;\nmy $previous = 0;\n\nwhile ($remaining > 0) {\n   $term++;\n   my $this = $previous - $term;\n   $this = $previous + $term unless $this > 0 and !$seen{$this};\n   push @recamans, $this;\n   $dup = $term if !$dup and defined $seen{$this};\n   $remaining -= $this if $this <= $max and ! defined $seen{$this};\n   $seen{$this}++;\n   $previous = $this;\n}\n\nprint \"First fifteen terms of Recaman's sequence: \" . join(' ', @recamans[0..14]) . \"\\n\";\nprint \"First duplicate at term: a[$dup]\\n\";\nprint \"Range 0..1000 covered by terms up to a[$term]\\n\";\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RecamanSequence {\n    class Program {\n        static void Main(string[] args) {\n            List<int> a = new List<int>() { 0 };\n            HashSet<int> used = new HashSet<int>() { 0 };\n            HashSet<int> used1000 = new HashSet<int>() { 0 };\n            bool foundDup = false;\n            int n = 1;\n            while (n <= 15 || !foundDup || used1000.Count < 1001) {\n                int next = a[n - 1] - n;\n                if (next < 1 || used.Contains(next)) {\n                    next += 2 * n;\n                }\n                bool alreadyUsed = used.Contains(next);\n                a.Add(next);\n                if (!alreadyUsed) {\n                    used.Add(next);\n                    if (0 <= next && next <= 1000) {\n                        used1000.Add(next);\n                    }\n                }\n                if (n == 14) {\n                    Console.WriteLine(\"The first 15 terms of the Recaman sequence are: [{0}]\", string.Join(\", \", a));\n                }\n                if (!foundDup && alreadyUsed) {\n                    Console.WriteLine(\"The first duplicated term is a[{0}] = {1}\", n, next);\n                    foundDup = true;\n                }\n                if (used1000.Count == 1001) {\n                    Console.WriteLine(\"Terms up to a[{0}] are needed to generate 0 to 1000\", n);\n                }\n                n++;\n            }\n        }\n    }\n}\n"}
{"id": 342005, "name": "Y combinator", "source": "Translate Perl to C#: sub Y { my $f = shift;                                \n    sub { my $x = shift; $x->($x) }->(                \n\tsub {my $y = shift; $f->(sub {$y->($y)(@_)})} \n    )\n}\nmy $fac = sub {my $f = shift;\n    sub {my $n = shift; $n < 2 ? 1 : $n * $f->($n-1)}\n};\nmy $fib = sub {my $f = shift;\n    sub {my $n = shift; $n == 0 ? 0 : $n == 1 ? 1 : $f->($n-1) + $f->($n-2)}\n};\nfor my $f ($fac, $fib) {\n    print join(' ', map Y($f)->($_), 0..9), \"\\n\";\n}\n", "target": "using System;\n\nstatic class YCombinator<T, TResult>\n{\n    \n    private delegate Func<T, TResult> RecursiveFunc(RecursiveFunc r);\n\n    public static Func<Func<Func<T, TResult>, Func<T, TResult>>, Func<T, TResult>> Fix { get; } =\n        f => ((RecursiveFunc)(g => f(x => g(g)(x))))(g => f(x => g(g)(x)));\n}\n\nstatic class Program\n{\n    static void Main()\n    {\n        var fac = YCombinator<int, int>.Fix(f => x => x < 2 ? 1 : x * f(x - 1));\n        var fib = YCombinator<int, int>.Fix(f => x => x < 2 ? x : f(x - 1) + f(x - 2));\n\n        Console.WriteLine(fac(10));\n        Console.WriteLine(fib(10));\n    }\n}\n"}
{"id": 342006, "name": "Casting out nines", "source": "Translate Perl to C#: sub co9 {  \n  my $n = shift;\n  return $n if $n < 10;\n  my $sum = 0; $sum += $_ for split(//,$n);\n  co9($sum);\n}\n\nsub showadd {\n  my($n,$m) = @_;\n  print \"( $n [\",co9($n),\"] + $m [\",co9($m),\"] ) [\",co9(co9($n)+co9($m)),\"]\", \n        \"   =   \", $n+$m,\" [\",co9($n+$m),\"]\\n\";\n}\n\nsub co9filter {\n  my $base = shift;\n  die unless $base >= 2;\n  my($beg, $end, $basem1) = (1, $base*$base-1, $base-1);\n  my @list = grep { $_ % $basem1 == $_*$_ % $basem1 } $beg .. $end;\n  ($end, scalar(@list), @list);\n}\n\nprint \"Part 1: Create a simple filter and demonstrate using simple example.\\n\";\nshowadd(6395, 1259);\n\nprint \"\\nPart 2: Use this to filter a range with co9(k) == co9(k^2).\\n\";\nprint join(\" \", grep { co9($_) == co9($_*$_) } 1..99), \"\\n\";\n\nprint \"\\nPart 3: Use efficient method on range.\\n\";\nfor my $base (10, 17) {\n  my($N, $n, @l) = co9filter($base);\n  printf \"[@l]\\nIn base %d, trying %d numbers instead of %d saves\u00a0%.4f%%\\n\\n\",\n         $base, $n, $N, 100-($n/$N)*100;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CastingOutNines {\n    public static class Helper {\n        public static string AsString<T>(this IEnumerable<T> e) {\n            var it = e.GetEnumerator();\n\n            StringBuilder builder = new StringBuilder();\n            builder.Append(\"[\");\n\n            if (it.MoveNext()) {\n                builder.Append(it.Current);\n            }\n            while (it.MoveNext()) {\n                builder.Append(\", \");\n                builder.Append(it.Current);\n            }\n\n            builder.Append(\"]\");\n            return builder.ToString();\n        }\n    }\n\n    class Program {\n        static List<int> CastOut(int @base, int start, int end) {\n            int[] ran = Enumerable\n                .Range(0, @base - 1)\n                .Where(a => a % (@base - 1) == (a * a) % (@base - 1))\n                .ToArray();\n            int x = start / (@base - 1);\n\n            List<int> result = new List<int>();\n            while (true) {\n                foreach (int n in ran) {\n                    int k = (@base - 1) * x + n;\n                    if (k < start) {\n                        continue;\n                    }\n                    if (k > end) {\n                        return result;\n                    }\n                    result.Add(k);\n                }\n                x++;\n            }\n        }\n\n        static void Main() {\n            Console.WriteLine(CastOut(16, 1, 255).AsString());\n            Console.WriteLine(CastOut(10, 1, 99).AsString());\n            Console.WriteLine(CastOut(17, 1, 288).AsString());\n        }\n    }\n}\n"}
{"id": 342007, "name": "Casting out nines", "source": "Translate Perl to C#: sub co9 {  \n  my $n = shift;\n  return $n if $n < 10;\n  my $sum = 0; $sum += $_ for split(//,$n);\n  co9($sum);\n}\n\nsub showadd {\n  my($n,$m) = @_;\n  print \"( $n [\",co9($n),\"] + $m [\",co9($m),\"] ) [\",co9(co9($n)+co9($m)),\"]\", \n        \"   =   \", $n+$m,\" [\",co9($n+$m),\"]\\n\";\n}\n\nsub co9filter {\n  my $base = shift;\n  die unless $base >= 2;\n  my($beg, $end, $basem1) = (1, $base*$base-1, $base-1);\n  my @list = grep { $_ % $basem1 == $_*$_ % $basem1 } $beg .. $end;\n  ($end, scalar(@list), @list);\n}\n\nprint \"Part 1: Create a simple filter and demonstrate using simple example.\\n\";\nshowadd(6395, 1259);\n\nprint \"\\nPart 2: Use this to filter a range with co9(k) == co9(k^2).\\n\";\nprint join(\" \", grep { co9($_) == co9($_*$_) } 1..99), \"\\n\";\n\nprint \"\\nPart 3: Use efficient method on range.\\n\";\nfor my $base (10, 17) {\n  my($N, $n, @l) = co9filter($base);\n  printf \"[@l]\\nIn base %d, trying %d numbers instead of %d saves\u00a0%.4f%%\\n\\n\",\n         $base, $n, $N, 100-($n/$N)*100;\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace CastingOutNines {\n    public static class Helper {\n        public static string AsString<T>(this IEnumerable<T> e) {\n            var it = e.GetEnumerator();\n\n            StringBuilder builder = new StringBuilder();\n            builder.Append(\"[\");\n\n            if (it.MoveNext()) {\n                builder.Append(it.Current);\n            }\n            while (it.MoveNext()) {\n                builder.Append(\", \");\n                builder.Append(it.Current);\n            }\n\n            builder.Append(\"]\");\n            return builder.ToString();\n        }\n    }\n\n    class Program {\n        static List<int> CastOut(int @base, int start, int end) {\n            int[] ran = Enumerable\n                .Range(0, @base - 1)\n                .Where(a => a % (@base - 1) == (a * a) % (@base - 1))\n                .ToArray();\n            int x = start / (@base - 1);\n\n            List<int> result = new List<int>();\n            while (true) {\n                foreach (int n in ran) {\n                    int k = (@base - 1) * x + n;\n                    if (k < start) {\n                        continue;\n                    }\n                    if (k > end) {\n                        return result;\n                    }\n                    result.Add(k);\n                }\n                x++;\n            }\n        }\n\n        static void Main() {\n            Console.WriteLine(CastOut(16, 1, 255).AsString());\n            Console.WriteLine(CastOut(10, 1, 99).AsString());\n            Console.WriteLine(CastOut(17, 1, 288).AsString());\n        }\n    }\n}\n"}
{"id": 342008, "name": "Execute HQ9+", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\nuse feature qw(say switch);\n\nmy @programme = <> or die \"No input. Specify a program file or pipe it to the standard input.\\n\";\n\nfor (@programme) {\n    for my $char (split //) {\n        given ($char) {\n            when ('H') { hello()             }\n            when ('Q') { quinne(@programme)  }\n            when ('9') { bottles()           }\n            default    { die \"Unknown instruction $char.\\n\" } \n        }\n    }\n}\n\nsub hello {\n    print 'Hello World';\n}\n\nsub quinne {\n    print @programme;\n}\n\nsub bottles {\n    for my $n (reverse 0 .. 99) {\n        my $before = bottle_count($n);\n        my $after  = bottle_count($n - 1);\n        my $action = bottle_action($n);\n        say \"\\u$before of beer on the wall, $before of beer.\";\n        say \"$action, $after of beer on the wall.\";\n        say q() if $n;\n    }\n}\n\nsub bottle_count {\n    my $n = shift;\n    given ($n) {\n        when    (-1) { return '99 bottles'      }\n        when    (0)  { return 'no more bottles' }\n        when    (1)  { return '1 bottle'        }\n        default      { return \"$n bottles\"      }\n    }\n}\n\nsub bottle_action {\n    my $n = shift;\n    return 'Take one down and pass it around' if $n > 0;\n    return 'Go to the store and buy some more';\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 342009, "name": "Execute HQ9+", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\nuse feature qw(say switch);\n\nmy @programme = <> or die \"No input. Specify a program file or pipe it to the standard input.\\n\";\n\nfor (@programme) {\n    for my $char (split //) {\n        given ($char) {\n            when ('H') { hello()             }\n            when ('Q') { quinne(@programme)  }\n            when ('9') { bottles()           }\n            default    { die \"Unknown instruction $char.\\n\" } \n        }\n    }\n}\n\nsub hello {\n    print 'Hello World';\n}\n\nsub quinne {\n    print @programme;\n}\n\nsub bottles {\n    for my $n (reverse 0 .. 99) {\n        my $before = bottle_count($n);\n        my $after  = bottle_count($n - 1);\n        my $action = bottle_action($n);\n        say \"\\u$before of beer on the wall, $before of beer.\";\n        say \"$action, $after of beer on the wall.\";\n        say q() if $n;\n    }\n}\n\nsub bottle_count {\n    my $n = shift;\n    given ($n) {\n        when    (-1) { return '99 bottles'      }\n        when    (0)  { return 'no more bottles' }\n        when    (1)  { return '1 bottle'        }\n        default      { return \"$n bottles\"      }\n    }\n}\n\nsub bottle_action {\n    my $n = shift;\n    return 'Take one down and pass it around' if $n > 0;\n    return 'Go to the store and buy some more';\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 342010, "name": "Erd\u0151s-primes", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nbinmode(STDOUT, ':utf8');\nuse List::AllUtils 'before';\nuse ntheory qw<is_prime factorial>;\n\nsub is_erdos {\n    my($n) = @_; my $k;\n    return unless is_prime($n);\n    while ($n > factorial($k++)) { return if is_prime $n-factorial($k) }\n    'True'\n}\n\nmy(@Erd\u0151s,$n);\ndo { push @Erd\u0151s, $n if is_erdos(++$n) } until $n >= 1e6;\n\nsay 'Erd\u0151s primes < ' . (my $max = 2500) . ':';\nsay join ' ', before { $_ > 2500 } @Erd\u0151s;\nsay \"\\nErd\u0151s prime \n", "target": "using System; using static System.Console;\nclass Program {\n  const int lmt = (int)1e6, first = 2500; static int[] f = new int[10];\n  static void Main(string[] args) {\n    f[0] = 1; for (int a = 0, b = 1; b < f.Length; a = b++)\n      f[b] = f[a] * (b + 1);\n    int pc = 0, nth = 0, lv = 0;\n    for (int i = 2; i < lmt; i++) if (is_erdos_prime(i)) {\n        if (i < first) Write(\"{0,5:n0}{1}\", i, pc++ % 5 == 4 ? \"\\n\" : \"  \");\n        nth++; lv = i; }\n    Write(\"\\nCount of Erd\u0151s primes between 1 and {0:n0}: {1}\\n{2} Erd\u0151s prime (the last one under {3:n0}): {4:n0}\", first, pc, ord(nth), lmt, lv); }\n\n  static string ord(int n) {\n    return string.Format(\"{0:n0}\", n) + new string[]{\"th\", \"st\", \"nd\", \"rd\", \"th\", \"th\", \"th\", \"th\", \"th\", \"th\"}[n % 10]; }\n\n  static bool is_erdos_prime(int p) {\n    if (!is_pr(p)) return false; int m = 0, t;\n    while ((t = p - f[m++]) > 0) if (is_pr(t)) return false;\n    return true;\n    bool is_pr(int x) {\n      if (x < 4) return x > 1; if ((x & 1) == 0) return false;\n      for (int i = 3; i * i <= x; i += 2) if (x % i == 0) return false;\n    return true; } } }\n"}
{"id": 342011, "name": "Erd\u0151s-primes", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse utf8;\nbinmode(STDOUT, ':utf8');\nuse List::AllUtils 'before';\nuse ntheory qw<is_prime factorial>;\n\nsub is_erdos {\n    my($n) = @_; my $k;\n    return unless is_prime($n);\n    while ($n > factorial($k++)) { return if is_prime $n-factorial($k) }\n    'True'\n}\n\nmy(@Erd\u0151s,$n);\ndo { push @Erd\u0151s, $n if is_erdos(++$n) } until $n >= 1e6;\n\nsay 'Erd\u0151s primes < ' . (my $max = 2500) . ':';\nsay join ' ', before { $_ > 2500 } @Erd\u0151s;\nsay \"\\nErd\u0151s prime \n", "target": "using System; using static System.Console;\nclass Program {\n  const int lmt = (int)1e6, first = 2500; static int[] f = new int[10];\n  static void Main(string[] args) {\n    f[0] = 1; for (int a = 0, b = 1; b < f.Length; a = b++)\n      f[b] = f[a] * (b + 1);\n    int pc = 0, nth = 0, lv = 0;\n    for (int i = 2; i < lmt; i++) if (is_erdos_prime(i)) {\n        if (i < first) Write(\"{0,5:n0}{1}\", i, pc++ % 5 == 4 ? \"\\n\" : \"  \");\n        nth++; lv = i; }\n    Write(\"\\nCount of Erd\u0151s primes between 1 and {0:n0}: {1}\\n{2} Erd\u0151s prime (the last one under {3:n0}): {4:n0}\", first, pc, ord(nth), lmt, lv); }\n\n  static string ord(int n) {\n    return string.Format(\"{0:n0}\", n) + new string[]{\"th\", \"st\", \"nd\", \"rd\", \"th\", \"th\", \"th\", \"th\", \"th\", \"th\"}[n % 10]; }\n\n  static bool is_erdos_prime(int p) {\n    if (!is_pr(p)) return false; int m = 0, t;\n    while ((t = p - f[m++]) > 0) if (is_pr(t)) return false;\n    return true;\n    bool is_pr(int x) {\n      if (x < 4) return x > 1; if ((x & 1) == 0) return false;\n      for (int i = 3; i * i <= x; i += 2) if (x % i == 0) return false;\n    return true; } } }\n"}
{"id": 342012, "name": "Playing cards", "source": "Translate Perl to C#: package Playing_Card_Deck;\n\nuse strict;\nuse warnings;\n\n@Playing_Card_Deck::suits = qw\n   [Diamonds Clubs Hearts Spades];\n@Playing_Card_Deck::pips = qw\n   [Two Three Four Five Six Seven Eight Nine Ten\n    Jack King Queen Ace];\n\n\n\n\n\nsub new\n\n {my $invocant = shift;\n  my $class = ref($invocant) || $invocant;\n  my @cards;\n  foreach my $suit (@Playing_Card_Deck::suits)\n     {foreach my $pip (@Playing_Card_Deck::pips)\n         {push(@cards, {suit => $suit, pip => $pip});}}\n  return bless([@cards], $class);}\n\nsub deal\n\n\n {return %{ shift( @{shift()} ) };}\n\nsub shuffle\n\n\n\n {our @deck; local *deck = shift;\n    \n  for (my $n = $\n     {my $k = int rand($n + 1);\n      @deck[$k, $n] = @deck[$n, $k] if $k != $n;}}\n\nsub print_cards\n\n {print \"$_->{pip} of $_->{suit}\\n\" foreach @{shift()};}\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic struct Card\n{\n    public Card(string rank, string suit) : this()\n    {\n        Rank = rank;\n        Suit = suit;\n    }\n\n    public string Rank { get; }\n    public string Suit { get; }\n\n    public override string ToString() => $\"{Rank} of {Suit}\";\n}\n\npublic class Deck : IEnumerable<Card>\n{\n    static readonly string[] ranks = { \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n        \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\", \"Ace\" };\n    static readonly string[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };\n    readonly List<Card> cards;\n \n    public Deck() {\n        cards = (from suit in suits\n                from rank in ranks\n                select new Card(rank, suit)).ToList();\n    }\n\n    public int Count => cards.Count;\n\n    public void Shuffle() {\n        \n        var random = new Random();\n        for (int i = 0; i < cards.Count; i++) {\n            int r = random.Next(i, cards.Count);\n            var temp = cards[i];\n            cards[i] = cards[r];\n            cards[r] = temp;\n        }\n    }\n\n    public Card Deal() {\n        int last = cards.Count - 1;\n        Card card = cards[last];\n        \n        \n        cards.RemoveAt(last);\n        return card;\n    }\n\n    public IEnumerator<Card> GetEnumerator() {\n        \n        \n        for (int i = cards.Count - 1; i >= 0; i--)\n            yield return cards[i];\n    }\n\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n}\n"}
{"id": 342013, "name": "Lah numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(factorial);\nuse List::Util qw(max);\n\nsub Lah {\n    my($n, $k) = @_;\n    return factorial($n) if $k == 1;\n    return 1 if $k == $n;\n    return 0 if $k > $n;\n    return 0 if $k < 1 or $n < 1;\n    (factorial($n) * factorial($n - 1)) / (factorial($k) * factorial($k - 1)) / factorial($n - $k)\n}\n\nmy $upto = 12;\nmy $mx   = 1 + length max map { Lah(12,$_) } 0..$upto;\n\nsay 'Unsigned Lah numbers:  L(n, k):';\nprint 'n\\k' . sprintf \"%${mx}s\"x(1+$upto).\"\\n\", 0..1+$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    map { printf \"%${mx}d\", Lah($row, $_) } 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the L(100, *) row:\";\nsay max map { Lah(100,$_) } 0..100;\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 342014, "name": "Lah numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(factorial);\nuse List::Util qw(max);\n\nsub Lah {\n    my($n, $k) = @_;\n    return factorial($n) if $k == 1;\n    return 1 if $k == $n;\n    return 0 if $k > $n;\n    return 0 if $k < 1 or $n < 1;\n    (factorial($n) * factorial($n - 1)) / (factorial($k) * factorial($k - 1)) / factorial($n - $k)\n}\n\nmy $upto = 12;\nmy $mx   = 1 + length max map { Lah(12,$_) } 0..$upto;\n\nsay 'Unsigned Lah numbers:  L(n, k):';\nprint 'n\\k' . sprintf \"%${mx}s\"x(1+$upto).\"\\n\", 0..1+$upto;\n\nfor my $row (0..$upto) {\n    printf '%-3d', $row;\n    map { printf \"%${mx}d\", Lah($row, $_) } 0..$row;\n    print \"\\n\";\n}\n\nsay \"\\nMaximum value from the L(100, *) row:\";\nsay max map { Lah(100,$_) } 0..100;\n", "target": "using System;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace LahNumbers {\n    class Program {\n        static BigInteger Factorial(BigInteger n) {\n            if (n == 0) return 1;\n            BigInteger res = 1;\n            while (n > 0) {\n                res *= n--;\n            }\n            return res;\n        }\n\n        static BigInteger Lah(BigInteger n, BigInteger k) {\n            if (k == 1) return Factorial(n);\n            if (k == n) return 1;\n            if (k > n) return 0;\n            if (k < 1 || n < 1) return 0;\n            return (Factorial(n) * Factorial(n - 1)) / (Factorial(k) * Factorial(k - 1)) / Factorial(n - k);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"Unsigned Lah numbers: L(n, k):\");\n            Console.Write(\"n/k \");\n            foreach (var i in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,10} \", i);\n            }\n            Console.WriteLine();\n            foreach (var row in Enumerable.Range(0, 13)) {\n                Console.Write(\"{0,-3}\", row);\n                foreach (var i in Enumerable.Range(0, row + 1)) {\n                    var l = Lah(row, i);\n                    Console.Write(\"{0,11}\", l);\n                }\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMaximum value from the L(100, *) row:\");\n            var maxVal = Enumerable.Range(0, 100).Select(a => Lah(100, a)).Max();\n            Console.WriteLine(maxVal);\n        }\n    }\n}\n"}
{"id": 342015, "name": "Two sum", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub two_sum{\n  my($sum,@numbers) = @_;\n  my $i = 0;\n  my $j = $\n  my @indices;\n  while ($i < $j) {\n    if    ($numbers[$i] + $numbers[$j] == $sum) { push @indices, ($i, $j); $i++; }\n    elsif ($numbers[$i] + $numbers[$j]  < $sum) { $i++ }\n    else                                        { $j-- }\n  }\n  return @indices\n}\n\nmy @numbers = <0 2 11 19 90>;\nmy @indices = two_sum(21, @numbers);\nsay join(', ', @indices) || 'No match';\n\n@indices = two_sum(25, @numbers);\nsay join(', ', @indices) || 'No match';\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 342016, "name": "Two sum", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub two_sum{\n  my($sum,@numbers) = @_;\n  my $i = 0;\n  my $j = $\n  my @indices;\n  while ($i < $j) {\n    if    ($numbers[$i] + $numbers[$j] == $sum) { push @indices, ($i, $j); $i++; }\n    elsif ($numbers[$i] + $numbers[$j]  < $sum) { $i++ }\n    else                                        { $j-- }\n  }\n  return @indices\n}\n\nmy @numbers = <0 2 11 19 90>;\nmy @indices = two_sum(21, @numbers);\nsay join(', ', @indices) || 'No match';\n\n@indices = two_sum(25, @numbers);\nsay join(', ', @indices) || 'No match';\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 342017, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\n\nmy @queue = my @primedigits = ( 2, 3, 5, 7 );\nmy $numbers;\n\nwhile( my $n = shift @queue )\n  {\n  if( eval $n == 13 )\n    {\n    $numbers .= $n =~ tr/+//dr . \" \";\n    }\n  elsif( eval $n < 13 )\n    {\n    push @queue, map \"$n+$_\", @primedigits;\n    }\n  }\nprint $numbers =~ s/.{1,80}\\K /\\n/gr;\n", "target": "using System;\nusing static System.Console; \nusing LI = System.Collections.Generic.SortedSet<int>;\n\nclass Program {\n\n  static LI unl(LI res, LI set, int lft, int mul = 1, int vlu = 0) {\n    if (lft == 0) res.Add(vlu);\n    else if (lft > 0) foreach (int itm in set)\n      res = unl(res, set, lft - itm, mul * 10, vlu + itm * mul);\n    return res; }\n\n  static void Main(string[] args) { WriteLine(string.Join(\" \",\n      unl(new LI {}, new LI { 2, 3, 5, 7 }, 13))); }\n}\n"}
{"id": 342018, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\n\nmy @queue = my @primedigits = ( 2, 3, 5, 7 );\nmy $numbers;\n\nwhile( my $n = shift @queue )\n  {\n  if( eval $n == 13 )\n    {\n    $numbers .= $n =~ tr/+//dr . \" \";\n    }\n  elsif( eval $n < 13 )\n    {\n    push @queue, map \"$n+$_\", @primedigits;\n    }\n  }\nprint $numbers =~ s/.{1,80}\\K /\\n/gr;\n", "target": "using System;\nusing static System.Console; \nusing LI = System.Collections.Generic.SortedSet<int>;\n\nclass Program {\n\n  static LI unl(LI res, LI set, int lft, int mul = 1, int vlu = 0) {\n    if (lft == 0) res.Add(vlu);\n    else if (lft > 0) foreach (int itm in set)\n      res = unl(res, set, lft - itm, mul * 10, vlu + itm * mul);\n    return res; }\n\n  static void Main(string[] args) { WriteLine(string.Join(\" \",\n      unl(new LI {}, new LI { 2, 3, 5, 7 }, 13))); }\n}\n"}
{"id": 342019, "name": "Deepcopy", "source": "Translate Perl to C#: \nuse strict;\nuse warnings;\nuse Storable;\nuse Data::Dumper;\n\nmy $src = { foo => 0, bar => [0, 1] };\n$src->{baz} = $src;\nmy $dst = Storable::dclone($src);\nprint Dumper($src);\nprint Dumper($dst);\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tclass MyClass : ICloneable\n\t\t{\n\t\t\tpublic MyClass() { f = new int[3]{2,3,5}; c = '1'; }\n\t\t\t\n\t\t\tpublic object Clone()\n\t\t\t{\t\t\t\t\n\t\t\t\tMyClass cpy = (MyClass) this.MemberwiseClone();\n\t\t\t\tcpy.f = (int[]) this.f.Clone();\t\t\t\n\t\t\t\treturn cpy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic char c;\n\t\t\tpublic int[] f;\n\t\t}\n\t\t\n\t\tpublic static void Main( string[] args )\n\t\t{\n\t\t\tMyClass c1 = new MyClass();\n\t\t\tMyClass c2 = (MyClass) c1.Clone();\n\t\t}\n\t}\n}\n"}
{"id": 342020, "name": "Deepcopy", "source": "Translate Perl to C#: \nuse strict;\nuse warnings;\nuse Storable;\nuse Data::Dumper;\n\nmy $src = { foo => 0, bar => [0, 1] };\n$src->{baz} = $src;\nmy $dst = Storable::dclone($src);\nprint Dumper($src);\nprint Dumper($dst);\n", "target": "using System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tclass MyClass : ICloneable\n\t\t{\n\t\t\tpublic MyClass() { f = new int[3]{2,3,5}; c = '1'; }\n\t\t\t\n\t\t\tpublic object Clone()\n\t\t\t{\t\t\t\t\n\t\t\t\tMyClass cpy = (MyClass) this.MemberwiseClone();\n\t\t\t\tcpy.f = (int[]) this.f.Clone();\t\t\t\n\t\t\t\treturn cpy;\n\t\t\t}\n\t\t\t\n\t\t\tpublic char c;\n\t\t\tpublic int[] f;\n\t\t}\n\t\t\n\t\tpublic static void Main( string[] args )\n\t\t{\n\t\t\tMyClass c1 = new MyClass();\n\t\t\tMyClass c2 = (MyClass) c1.Clone();\n\t\t}\n\t}\n}\n"}
{"id": 342021, "name": "Frobenius numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <nth_prime primes>;\nuse List::MoreUtils qw(slide);\n\n\nmy(@F,$n);\ndo { ++$n and push @F, nth_prime($n) * nth_prime($n+1) - (nth_prime($n) + nth_prime($n+1)) } until $F[-1] >= 10000;\nsay \"$\n\n\nmy $limit = 10_000;\nsay \"\\n\" . join ' ', grep { $_ < $limit } slide { $a * $b - $a - $b } @{primes($limit)};\n", "target": "using System.Collections.Generic; using System.Linq; using static System.Console; using static System.Math;\n\nclass Program {\n\n    static bool ispr(int x) { int lim = (int)Sqrt((double)x);\n        if (x < 2) return false; if ((x % 3) == 0) return x == 0; bool odd = false;\n        for (int d = 5; d <= lim; d += (odd = !odd) ? 2 : 4) {\n        if (x % d == 0) return false; } return true; }\n\n    static void Main() {\n        int c = 0, d = 0, f, lim = 1000000, l2 = lim / 100; var Frob = PG.Primes((int)Sqrt(lim) + 1).ToArray();\n        for (int n = 0, m = 1; m < Frob.Length; n = m++) {\n            if ((f = Frob[n] * Frob[m] - Frob[n] - Frob[m]) < l2) d++;\n            Write(\"{0,7:n0}{2} {1}\", f , ++c % 10 == 0 ? \"\\n\" : \"\", ispr(f) ? \" \" : \"*\"); }\n        Write(\"\\n\\nCalculated {0} Frobenius numbers of consecutive primes under {1:n0}, \" +\n            \"of which {2} were under {3:n0}\", c, lim, d, l2); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) { \n    var flags = new bool[lim + 1]; int j = 3; yield return 2; \n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 342022, "name": "Frobenius numbers", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory <nth_prime primes>;\nuse List::MoreUtils qw(slide);\n\n\nmy(@F,$n);\ndo { ++$n and push @F, nth_prime($n) * nth_prime($n+1) - (nth_prime($n) + nth_prime($n+1)) } until $F[-1] >= 10000;\nsay \"$\n\n\nmy $limit = 10_000;\nsay \"\\n\" . join ' ', grep { $_ < $limit } slide { $a * $b - $a - $b } @{primes($limit)};\n", "target": "using System.Collections.Generic; using System.Linq; using static System.Console; using static System.Math;\n\nclass Program {\n\n    static bool ispr(int x) { int lim = (int)Sqrt((double)x);\n        if (x < 2) return false; if ((x % 3) == 0) return x == 0; bool odd = false;\n        for (int d = 5; d <= lim; d += (odd = !odd) ? 2 : 4) {\n        if (x % d == 0) return false; } return true; }\n\n    static void Main() {\n        int c = 0, d = 0, f, lim = 1000000, l2 = lim / 100; var Frob = PG.Primes((int)Sqrt(lim) + 1).ToArray();\n        for (int n = 0, m = 1; m < Frob.Length; n = m++) {\n            if ((f = Frob[n] * Frob[m] - Frob[n] - Frob[m]) < l2) d++;\n            Write(\"{0,7:n0}{2} {1}\", f , ++c % 10 == 0 ? \"\\n\" : \"\", ispr(f) ? \" \" : \"*\"); }\n        Write(\"\\n\\nCalculated {0} Frobenius numbers of consecutive primes under {1:n0}, \" +\n            \"of which {2} were under {3:n0}\", c, lim, d, l2); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) { \n    var flags = new bool[lim + 1]; int j = 3; yield return 2; \n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 342023, "name": "Integer roots", "source": "Translate Perl to C#: use bigint;\n\nsub integer_root {\n    our($a,$b) = @_;\n    our $a1 = $a - 1;\n    my $c = 1;\n    my $d = f($c);\n    my $e = f($d);\n    ($c, $d, $e) = ($d, $e, f($e)) until $c==$d || $c==$e;\n    return $d < $e ? $d : $e;\n\n    sub f { ($a1*$_[0]+$b/$_[0]**$a1)/$a }\n}\n\nprint integer_root( 3, 8), \"\\n\";\nprint integer_root( 3, 9), \"\\n\";\nprint integer_root( 2, 2 * 100 ** 2000), \"\\n\";\n", "target": "using System;\nusing System.Numerics;\n\nnamespace IntegerRoots {\n    class Program {\n        static BigInteger IRoot(BigInteger @base, int n) {\n            if (@base < 0 || n <= 0) {\n                throw new ArgumentException();\n            }\n\n            int n1 = n - 1;\n            BigInteger n2 = n;\n            BigInteger n3 = n1;\n            BigInteger c = 1;\n            BigInteger d = (n3 + @base) / n2;\n            BigInteger e = ((n3 * d) + (@base / BigInteger.Pow(d, n1))) / n2;\n            while (c != d && c != e) {\n                c = d;\n                d = e;\n                e = (n3 * e + @base / BigInteger.Pow(e, n1)) / n2;\n            }\n            if (d < e) {\n                return d;\n            }\n            return e;\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"3rd integer root of 8 = {0}\", IRoot(8, 3));\n            Console.WriteLine(\"3rd integer root of 9 = {0}\", IRoot(9, 3));\n\n            BigInteger b = BigInteger.Pow(100, 2000) * 2;\n            Console.WriteLine(\"First 2001 digits of the sqaure root of 2: {0}\", IRoot(b, 2));\n        }\n    }\n}\n"}
{"id": 342024, "name": "Integer roots", "source": "Translate Perl to C#: use bigint;\n\nsub integer_root {\n    our($a,$b) = @_;\n    our $a1 = $a - 1;\n    my $c = 1;\n    my $d = f($c);\n    my $e = f($d);\n    ($c, $d, $e) = ($d, $e, f($e)) until $c==$d || $c==$e;\n    return $d < $e ? $d : $e;\n\n    sub f { ($a1*$_[0]+$b/$_[0]**$a1)/$a }\n}\n\nprint integer_root( 3, 8), \"\\n\";\nprint integer_root( 3, 9), \"\\n\";\nprint integer_root( 2, 2 * 100 ** 2000), \"\\n\";\n", "target": "using System;\nusing System.Numerics;\n\nnamespace IntegerRoots {\n    class Program {\n        static BigInteger IRoot(BigInteger @base, int n) {\n            if (@base < 0 || n <= 0) {\n                throw new ArgumentException();\n            }\n\n            int n1 = n - 1;\n            BigInteger n2 = n;\n            BigInteger n3 = n1;\n            BigInteger c = 1;\n            BigInteger d = (n3 + @base) / n2;\n            BigInteger e = ((n3 * d) + (@base / BigInteger.Pow(d, n1))) / n2;\n            while (c != d && c != e) {\n                c = d;\n                d = e;\n                e = (n3 * e + @base / BigInteger.Pow(e, n1)) / n2;\n            }\n            if (d < e) {\n                return d;\n            }\n            return e;\n        }\n\n        static void Main(string[] args) {\n            Console.WriteLine(\"3rd integer root of 8 = {0}\", IRoot(8, 3));\n            Console.WriteLine(\"3rd integer root of 9 = {0}\", IRoot(9, 3));\n\n            BigInteger b = BigInteger.Pow(100, 2000) * 2;\n            Console.WriteLine(\"First 2001 digits of the sqaure root of 2: {0}\", IRoot(b, 2));\n        }\n    }\n}\n"}
{"id": 342025, "name": "Find the last Sunday of each month", "source": "Translate Perl to C#: \nuse strict ;\nuse warnings ;\nuse DateTime ;\n\nfor my $i( 1..12 ) {\n   my $date = DateTime->last_day_of_month( year => $ARGV[ 0 ] , \n\t month => $i ) ;\n   while ( $date->dow != 7 ) {\n      $date = $date->subtract( days => 1 ) ;\n   }\n   my $ymd = $date->ymd ;\n   print \"$ymd\\n\" ;\n}\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 342026, "name": "Find the last Sunday of each month", "source": "Translate Perl to C#: \nuse strict ;\nuse warnings ;\nuse DateTime ;\n\nfor my $i( 1..12 ) {\n   my $date = DateTime->last_day_of_month( year => $ARGV[ 0 ] , \n\t month => $i ) ;\n   while ( $date->dow != 7 ) {\n      $date = $date->subtract( days => 1 ) ;\n   }\n   my $ymd = $date->ymd ;\n   print \"$ymd\\n\" ;\n}\n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 342027, "name": "Random Latin squares", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\nuse List::Util 'shuffle';\n\nsub random_ls {\n    my($n) = @_;\n    my(@cols,@symbols,@ls_sym);\n\n    \n    my @ls = [0,];\n    for my $i (1..$n-1) {\n        @{$ls[$i]} = @{$ls[0]};\n        splice(@{$ls[$_]}, $_, 0, $i) for 0..$i;\n    }\n\n    \n    @cols = shuffle 0..$n-1;\n    @ls = map [ @{$_}[@cols] ], @ls[shuffle 0..$n-1];\n\n    \n    @symbols = shuffle( ('A'..'Z')[0..$n-1] );\n    push @ls_sym, [@symbols[@$_]] for @ls;\n    @ls_sym\n}\n\nsub display {\n    my $str;\n    $str .= join(' ', @$_) . \"\\n\" for @_;\n    $str\n}\n\nsay display random_ls($_) for 2..5, 5;\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace RandomLatinSquares {\n    using Matrix = List<List<int>>;\n\n    \n    static class Helper {\n        private static readonly Random rng = new Random();\n\n        public static void Shuffle<T>(this IList<T> list) {\n            int n = list.Count;\n            while (n > 1) {\n                n--;\n                int k = rng.Next(n + 1);\n                T value = list[k];\n                list[k] = list[n];\n                list[n] = value;\n            }\n        }\n    }\n\n    class Program {\n        static void PrintSquare(Matrix latin) {\n            foreach (var row in latin) {\n                Console.Write('[');\n\n                var it = row.GetEnumerator();\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", \");\n                    Console.Write(it.Current);\n                }\n\n                Console.WriteLine(']');\n            }\n            Console.WriteLine();\n        }\n\n        static void LatinSquare(int n) {\n            if (n <= 0) {\n                Console.WriteLine(\"[]\");\n                return;\n            }\n\n            var latin = new Matrix();\n            for (int i = 0; i < n; i++) {\n                List<int> temp = new List<int>();\n                for (int j = 0; j < n; j++) {\n                    temp.Add(j);\n                }\n                latin.Add(temp);\n            }\n            \n            latin[0].Shuffle();\n\n            \n            for (int i = 1; i < n - 1; i++) {\n                bool shuffled = false;\n\n                while (!shuffled) {\n                    latin[i].Shuffle();\n                    for (int k = 0; k < i; k++) {\n                        for (int j = 0; j < n; j++) {\n                            if (latin[k][j] == latin[i][j]) {\n                                goto shuffling;\n                            }\n                        }\n                    }\n                    shuffled = true;\n\n                shuffling: { }\n                }\n            }\n\n            \n            for (int j = 0; j < n; j++) {\n                List<bool> used = new List<bool>();\n                for (int i = 0; i < n; i++) {\n                    used.Add(false);\n                }\n\n                for (int i = 0; i < n-1; i++) {\n                    used[latin[i][j]] = true;\n                }\n                for (int k = 0; k < n; k++) {\n                    if (!used[k]) {\n                        latin[n - 1][j] = k;\n                        break;\n                    }\n                }\n            }\n\n            PrintSquare(latin);\n        }\n\n        static void Main() {\n            LatinSquare(5);\n            LatinSquare(5);\n            LatinSquare(10); \n        }\n    }\n}\n"}
{"id": 342028, "name": "Descending primes", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nprint join('', sort map { sprintf \"%9d\", $_ } grep /./ && is_prime($_),\n  glob join '', map \"{$_,}\", reverse 1 .. 9) =~ s/.{45}\\K/\\n/gr;\n", "target": "using System;\n\nclass Program {\n\n  static bool ispr(uint n) {\n    if ((n & 1) == 0 || n < 2) return n == 2;\n    for (uint j = 3; j * j <= n; j += 2)\n      if (n % j == 0) return false; return true; }\n\n  static void Main(string[] args) {\n    uint c = 0; int nc;\n    var ps = new uint[]{ 1, 2, 3, 4, 5, 6, 7, 8, 9 };\n    var nxt = new uint[128];\n    while (true) {\n      nc = 0;\n      foreach (var a in ps) {\n        if (ispr(a))\n          Console.Write(\"{0,8}{1}\", a, ++c % 5 == 0 ? \"\\n\" : \" \");\n        for (uint b = a * 10, l = a % 10 + b++; b < l; b++)\n          nxt[nc++] = b;\n      }\n      if (nc > 1) {\n        Array.Resize (ref ps, nc); Array.Copy(nxt, ps, nc); }\n      else break;\n    }\n    Console.WriteLine(\"\\n{0} descending primes found\", c);\n  }\n}\n"}
{"id": 342029, "name": "RPG attributes generator", "source": "Translate Perl to C#: use strict;\nuse List::Util 'sum';\n\nmy ($min_sum, $hero_attr_min, $hero_count_min) = <75 15 3>;\nmy @attr_names = <Str Int Wis Dex Con Cha>;\n\nsub heroic { scalar grep { $_ >= $hero_attr_min } @_ }\n\nsub roll_skip_lowest {\n    my($dice, $sides) = @_;\n    sum( (sort map { 1 + int rand($sides) } 1..$dice)[1..$dice-1] );\n}\n\nmy @attr;\ndo {\n    @attr = map { roll_skip_lowest(6,4) } @attr_names;\n} until sum(@attr) >= $min_sum and heroic(@attr) >= $hero_count_min;\n\nprintf \"%s = %2d\\n\", $attr_names[$_], $attr[$_] for 0..$\nprintf \"Sum = %d, with %d attributes >= $hero_attr_min\\n\", sum(@attr), heroic(@attr);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Module1\n{\n    static Random r = new Random();\n\n    static List<int> getThree(int n)\n    {\n        List<int> g3 = new List<int>();\n        for (int i = 0; i < 4; i++) g3.Add(r.Next(n) + 1);\n        g3.Sort(); g3.RemoveAt(0); return g3;\n    }\n\n    static List<int> getSix()\n    {\n        List<int> g6 = new List<int>();\n        for (int i = 0; i < 6; i++) g6.Add(getThree(6).Sum());\n        return g6;\n    }\n\n    static void Main(string[] args)\n    {\n        bool good = false; do {\n            List<int> gs = getSix(); int gss = gs.Sum(); int hvc = gs.FindAll(x => x > 14).Count;\n            Console.Write(\"attribs: {0}, sum={1}, ({2} sum, high vals={3})\",\n                          string.Join(\", \", gs), gss, gss >= 75 ? \"good\" : \"low\", hvc);\n            Console.WriteLine(\" - {0}\", (good = gs.Sum() >= 75 && hvc > 1) ? \"success\" : \"failure\");\n        } while (!good);\n    }\n}\n"}
{"id": 342030, "name": "Kolakoski sequence", "source": "Translate Perl to C#: sub kolakoski {\n    my($terms,@seed) = @_;\n    my @k;\n    my $k = $seed[0] == 1 ? 1 : 0;\n    if ($k == 1) { @k = (1, split //, (($seed[1]) x $seed[1])) }\n    else         { @k = ($seed[0]) x $seed[0] }\n    do {\n        $k++;\n        push @k, ($seed[$k % @seed]) x $k[$k];\n    } until $terms <= @k;\n    @k[0..$terms-1]\n}\n\nsub rle {\n    (my $string = join '', @_) =~ s/((.)\\2*)/length $1/eg;\n    split '', $string\n}\n\nfor ([20,1,2], [20,2,1], [30,1,3,1,2], [30,1,3,2,1]) {\n    $terms = shift @$_;\n    print \"\\n$terms members of the series generated from [@$_] is:\\n\";\n    print join(' ', @kolakoski = kolakoski($terms, @$_)) . \"\\n\";\n    $status = join('', @rle = rle(@kolakoski)) eq join('', @kolakoski[0..$\n    print \"Looks like a Kolakoski sequence?: $status\\n\";\n}\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace KolakoskiSequence {\n    class Crutch {\n        public readonly int len;\n        public int[] s;\n        public int i;\n\n        public Crutch(int len) {\n            this.len = len;\n            s = new int[len];\n            i = 0;\n        }\n\n        public void Repeat(int count) {\n            for (int j = 0; j < count; j++) {\n                if (++i == len) return;\n                s[i] = s[i - 1];\n            }\n        }\n    }\n\n    static class Extension {\n        public static int NextInCycle(this int[] self, int index) {\n            return self[index % self.Length];\n        }\n\n        public static int[] Kolakoski(this int[] self, int len) {\n            Crutch c = new Crutch(len);\n\n            int k = 0;\n            while (c.i < len) {\n                c.s[c.i] = self.NextInCycle(k);\n                if (c.s[k] > 1) {\n                    c.Repeat(c.s[k] - 1);\n                }\n                if (++c.i == len) return c.s;\n                k++;\n            }\n            return c.s;\n        }\n\n        public static bool PossibleKolakoski(this int[] self) {\n            int[] rle = new int[self.Length];\n            int prev = self[0];\n            int count = 1;\n            int pos = 0;\n            for (int i = 1; i < self.Length; i++) {\n                if (self[i] == prev) {\n                    count++;\n                }\n                else {\n                    rle[pos++] = count;\n                    count = 1;\n                    prev = self[i];\n                }\n            }\n            \n            for (int i = 0; i < pos; i++) {\n                if (rle[i] != self[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public static string AsString(this int[] self) {\n            StringBuilder sb = new StringBuilder(\"[\");\n            int count = 0;\n            foreach (var item in self) {\n                if (count > 0) {\n                    sb.Append(\", \");\n                }\n                sb.Append(item);\n                count++;\n            }\n            return sb.Append(\"]\").ToString();\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            int[][] ias = {\n                new int[]{1, 2},\n                new int[]{2, 1},\n                new int[]{1, 3, 1, 2},\n                new int[]{1, 3, 2, 1}\n            };\n            int[] lens = { 20, 20, 30, 30 };\n\n            for (int i = 0; i < ias.Length; i++) {\n                int len = lens[i];\n                int[] kol = ias[i].Kolakoski(len);\n\n                Console.WriteLine(\"First {0} members of the sequence by {1}: \", len, ias[i].AsString());\n                Console.WriteLine(kol.AsString());\n                Console.WriteLine(\"Possible Kolakoski sequence? {0}\", kol.PossibleKolakoski());\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 342031, "name": "Longest increasing subsequence", "source": "Translate Perl to C#: use strict;\n\nsub lis {\n    my @l = map [], 1 .. @_;\n    push @{$l[0]}, +$_[0];\n    for my $i (1 .. @_-1) {\n        for my $j (0 .. $i - 1) {\n            if ($_[$j] < $_[$i] and @{$l[$i]} < @{$l[$j]} + 1) {\n                $l[$i] = [ @{$l[$j]} ];\n            }\n        }\n        push @{$l[$i]}, $_[$i];\n    }\n    my ($max, $l) = (0, []);\n    for (@l) {\n        ($max, $l) = (scalar(@$_), $_) if @$_ > $max;\n    }\n    return @$l;\n}\n\nprint join ' ', lis 3, 2, 6, 4, 5, 1;\nprint join ' ', lis 0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15;\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LIS\n{\n    public static IEnumerable<T> FindRec<T>(IList<T> values, IComparer<T> comparer = null) =>\n        values == null ? throw new ArgumentNullException() :\n            FindRecImpl(values, Sequence<T>.Empty, 0, comparer ?? Comparer<T>.Default).Reverse();\n\n    private static Sequence<T> FindRecImpl<T>(IList<T> values, Sequence<T> current, int index, IComparer<T> comparer) {\n        if (index == values.Count) return current;\n        if (current.Length > 0 && comparer.Compare(values[index], current.Value) <= 0)\n            return FindRecImpl(values, current, index + 1, comparer);\n        return Max(\n            FindRecImpl(values, current, index + 1, comparer),\n            FindRecImpl(values, current + values[index], index + 1, comparer)\n        );\n    }\n\n    private static Sequence<T> Max<T>(Sequence<T> a, Sequence<T> b) => a.Length < b.Length ? b : a;\n\n    class Sequence<T> : IEnumerable<T>\n    {\n        public static readonly Sequence<T> Empty = new Sequence<T>(default(T), null);\n\n        public Sequence(T value, Sequence<T> tail)\n        {\n            Value = value;\n            Tail = tail;\n            Length = tail == null ? 0 : tail.Length + 1;\n        }\n\n        public T Value { get; }\n        public Sequence<T> Tail { get; }\n        public int Length { get; }\n\n        public static Sequence<T> operator +(Sequence<T> s, T value) => new Sequence<T>(value, s);\n\n        public IEnumerator<T> GetEnumerator()\n        {\n            for (var s = this; s.Length > 0; s = s.Tail) yield return s.Value;\n        }\n\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n    }\n}\n"}
{"id": 342032, "name": "Dynamic variable names", "source": "Translate Perl to C#: print \"Enter a variable name: \";\n$varname = <STDIN>; \nchomp($varname);\n$$varname = 42; \n                \n                \nprint \"$foo\\n\"; \n", "target": "using System;\nusing System.Dynamic;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        string varname = Console.ReadLine();\n        \n        dynamic expando = new ExpandoObject();\n        var map = expando as IDictionary<string, object>;\n        map.Add(varname, \"Hello world!\");\n \n        Console.WriteLine(expando.foo);\n    }\n}\n"}
{"id": 342033, "name": "Odd squarefree semiprimes", "source": "Translate Perl to C#: \n\nuse strict; \nuse warnings;\n\nmy (@primes, @found) = grep $_ & 1 && (1 x $_) !~ /^(11+)\\1+$/, 3 .. 999 / 3;\n\"@primes\" =~ /\\b(\\d+)\\b.*?\\b(\\d+)\\b(?{ $found[$1 * $2] = $1 * $2 })(*FAIL)/;\nprint \"@{[ grep $_, @found[3 .. 999] ]}\\n\" =~ s/.{75}\\K /\\n/gr;\n", "target": "using System; using static System.Console; using System.Collections;\nusing System.Linq; using System.Collections.Generic;\n\nclass Program { static void Main(string[] args) {\n    int lmt = 1000, amt, c = 0, sr = (int)Math.Sqrt(lmt), lm2; var res = new List<int>();\n    var pr = PG.Primes(lmt / 3 + 5).ToArray(); lm2 = pr.OrderBy(i => Math.Abs(sr - i)).First();\n    lm2 = Array.IndexOf(pr, lm2); for (var p = 0; p < lm2; p++) { amt = 0; for (var q = p + 1; amt < lmt; q++)\n      res.Add(amt = pr[p] * pr[q]); } res.Sort(); foreach(var item in res.TakeWhile(x => x < lmt))\n        Write(\"{0,4} {1}\", item, ++c % 20 == 0 ? \"\\n\" : \"\");\n    Write(\"\\n\\nCounted {0} odd squarefree semiprimes under {1}\", c, lmt); } }\n\nclass PG { public static IEnumerable<int> Primes(int lim) {\n    var flags = new bool[lim + 1]; int j = 3;\n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 342034, "name": "Square root by hand", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub integral   { my($n) = @_; (length($n) % 2 != 0 ? '0' . $n  : $n) =~ /../g }\nsub fractional { my($n) = @_; (length($n) % 2 == 0 ? $n  . '0' : $n) =~ /../g }\n\nsub SpigotSqrt {\n    my($in) = @_;\n\n    my(@dividends, @fractional, $dividend, $quotient, $remainder, $accum);\n    my $d   = 9;\n    my $D   = '';\n    my $dot = 0;\n\n    if ($in == int $in) {\n        @dividends =    integral($in);\n    } else {\n        @dividends  =   integral($in =~ /(.*)\\./);\n        @fractional = fractional($in =~ /\\.(.*)/);\n    }\n    $dividend = shift @dividends;\n\n    while () {\n        until ( ( $remainder = $dividend - ($D.$d) * $d ) >= 0) { $d-- }\n\n        $accum    .= $d;\n        $quotient .= $d;\n        unless (@dividends) {\n            last if $remainder == 0 and $quotient != 0 and !@fractional;\n            unless ($dot) { $accum .= '.' and $dot = 1 }\n            if (@fractional) {\n                push @dividends, @fractional;\n                @fractional = ();\n            } else {\n                push @dividends, '00';\n            }\n        }\n        $dividend = $remainder . shift @dividends;\n        $D = 2 * $quotient;\n        $d = 9\n    }\n    return $accum;\n}\n\nsay \"The square root of $_ is \" . SpigotSqrt $_ for < 25 0.0625 152.2756 >;\n", "target": "using System;\nusing static System.Math;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n    static void Main(string[] args) {\n        BI i, j, k, d; i = 2; int n = -1; int n0 = -1;\n        j = (BI)Floor(Sqrt((double)i)); k = j; d = j;\n        DateTime st = DateTime.Now;\n        if (args.Length > 0) int.TryParse(args[0], out n);\n        if (n > 0) n0 = n; else n = 1;\n        do {\n            Write(d); i = (i - k * d) * 100; k = 20 * j;\n            for (d = 1; d <= 10; d++)\n                if ((k + d) * d > i) { d -= 1; break; }\n            j = j * 10 + d; k += d; if (n0 > 0) n--;\n        } while (n > 0);\n        if (n0 > 0) WriteLine(\"\\nTime taken for {0} digits: {1}\", n0, DateTime.Now - st); }\n\n}\n"}
{"id": 342035, "name": "Square root by hand", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub integral   { my($n) = @_; (length($n) % 2 != 0 ? '0' . $n  : $n) =~ /../g }\nsub fractional { my($n) = @_; (length($n) % 2 == 0 ? $n  . '0' : $n) =~ /../g }\n\nsub SpigotSqrt {\n    my($in) = @_;\n\n    my(@dividends, @fractional, $dividend, $quotient, $remainder, $accum);\n    my $d   = 9;\n    my $D   = '';\n    my $dot = 0;\n\n    if ($in == int $in) {\n        @dividends =    integral($in);\n    } else {\n        @dividends  =   integral($in =~ /(.*)\\./);\n        @fractional = fractional($in =~ /\\.(.*)/);\n    }\n    $dividend = shift @dividends;\n\n    while () {\n        until ( ( $remainder = $dividend - ($D.$d) * $d ) >= 0) { $d-- }\n\n        $accum    .= $d;\n        $quotient .= $d;\n        unless (@dividends) {\n            last if $remainder == 0 and $quotient != 0 and !@fractional;\n            unless ($dot) { $accum .= '.' and $dot = 1 }\n            if (@fractional) {\n                push @dividends, @fractional;\n                @fractional = ();\n            } else {\n                push @dividends, '00';\n            }\n        }\n        $dividend = $remainder . shift @dividends;\n        $D = 2 * $quotient;\n        $d = 9\n    }\n    return $accum;\n}\n\nsay \"The square root of $_ is \" . SpigotSqrt $_ for < 25 0.0625 152.2756 >;\n", "target": "using System;\nusing static System.Math;\nusing static System.Console;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n\n    static void Main(string[] args) {\n        BI i, j, k, d; i = 2; int n = -1; int n0 = -1;\n        j = (BI)Floor(Sqrt((double)i)); k = j; d = j;\n        DateTime st = DateTime.Now;\n        if (args.Length > 0) int.TryParse(args[0], out n);\n        if (n > 0) n0 = n; else n = 1;\n        do {\n            Write(d); i = (i - k * d) * 100; k = 20 * j;\n            for (d = 1; d <= 10; d++)\n                if ((k + d) * d > i) { d -= 1; break; }\n            j = j * 10 + d; k += d; if (n0 > 0) n--;\n        } while (n > 0);\n        if (n0 > 0) WriteLine(\"\\nTime taken for {0} digits: {1}\", n0, DateTime.Now - st); }\n\n}\n"}
{"id": 342036, "name": "Primes with digits in nondecreasing order", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @want = grep ! /(.)(.)(??{$1 > $2\u00a0? ''\u00a0: '(*FAIL)'})/, @{ primes(1000) };\nprint \"@want\" =~ s/.{50}\\K /\\n/gr . \"\\n\\ncount: \" . @want . \"\\n\";\n", "target": "using System.Linq; using System.Collections.Generic; using static System.Console; using static System.Math;\n \nclass Program {\n\n  static int ba; static string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n  \n  static string from10(int b) { string res = \"\"; int re; while (b > 0) {\n    b = DivRem(b, ba, out re); res = chars[(byte)re] + res; } return res; }\n\n  \n  static int to10(string s) { int res = 0; foreach (char i in s)\n    res = res * ba + chars.IndexOf(i); return res; }\n\n  \n  static bool nd(string s) { if (s.Length < 2) return true;\n    char l = s[0]; for (int i = 1; i < s.Length; i++)\n      if (chars.IndexOf(l) > chars.IndexOf(s[i]))\n        return false; else l = s[i] ; return true; }\n\n  static void Main(string[] args) { int c, lim = 1000; string s;\n    foreach (var b in new List<int>{ 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 17, 27, 31, 62 }) {\n      ba = b; c = 0; foreach (var a in PG.Primes(lim))\n        if (nd(s = from10(a))) Write(\"{0,4} {1}\", s, ++c % 20 == 0 ? \"\\n\" : \"\");\n    WriteLine(\"\\nBase {0}: found {1} non-decreasing primes under {2:n0}\\n\", b, c, from10(lim)); } } } \n \nclass PG { public static IEnumerable<int> Primes(int lim) {\n    var flags = new bool[lim + 1]; int j; yield return 2;\n    for (j = 4; j <= lim; j += 2) flags[j] = true; j = 3;\n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 342037, "name": "Primes with digits in nondecreasing order", "source": "Translate Perl to C#: \n\nuse strict;\nuse warnings;\nuse ntheory qw( primes );\n\nmy @want = grep ! /(.)(.)(??{$1 > $2\u00a0? ''\u00a0: '(*FAIL)'})/, @{ primes(1000) };\nprint \"@want\" =~ s/.{50}\\K /\\n/gr . \"\\n\\ncount: \" . @want . \"\\n\";\n", "target": "using System.Linq; using System.Collections.Generic; using static System.Console; using static System.Math;\n \nclass Program {\n\n  static int ba; static string chars = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\";\n\n  \n  static string from10(int b) { string res = \"\"; int re; while (b > 0) {\n    b = DivRem(b, ba, out re); res = chars[(byte)re] + res; } return res; }\n\n  \n  static int to10(string s) { int res = 0; foreach (char i in s)\n    res = res * ba + chars.IndexOf(i); return res; }\n\n  \n  static bool nd(string s) { if (s.Length < 2) return true;\n    char l = s[0]; for (int i = 1; i < s.Length; i++)\n      if (chars.IndexOf(l) > chars.IndexOf(s[i]))\n        return false; else l = s[i] ; return true; }\n\n  static void Main(string[] args) { int c, lim = 1000; string s;\n    foreach (var b in new List<int>{ 2, 3, 4, 5, 6, 7, 8, 9, 10, 16, 17, 27, 31, 62 }) {\n      ba = b; c = 0; foreach (var a in PG.Primes(lim))\n        if (nd(s = from10(a))) Write(\"{0,4} {1}\", s, ++c % 20 == 0 ? \"\\n\" : \"\");\n    WriteLine(\"\\nBase {0}: found {1} non-decreasing primes under {2:n0}\\n\", b, c, from10(lim)); } } } \n \nclass PG { public static IEnumerable<int> Primes(int lim) {\n    var flags = new bool[lim + 1]; int j; yield return 2;\n    for (j = 4; j <= lim; j += 2) flags[j] = true; j = 3;\n    for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n      if (!flags[j]) { yield return j;\n        for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true; }\n    for (; j <= lim; j += 2) if (!flags[j]) yield return j; } }\n"}
{"id": 342038, "name": "Read a file character by character_UTF8", "source": "Translate Perl to C#: binmode STDOUT, ':utf8';  \n\nopen my $fh, \"<:encoding(UTF-8)\", \"input.txt\" or die \"$!\\n\";\n\nwhile (read $fh, my $char, 1) {\n    printf \"got character $char [U+%04x]\\n\", ord $char;\n}\n\nclose $fh;\n", "target": "using System;\nusing System.IO;\nusing System.Text;\n\nnamespace RosettaFileByChar\n{\n    class Program\n    {\n        static char GetNextCharacter(StreamReader streamReader) => (char)streamReader.Read();\n\n        static void Main(string[] args)\n        {\n            Console.OutputEncoding = Encoding.UTF8;\n            char c;\n            using (FileStream fs = File.OpenRead(\"input.txt\"))\n            {\n                using (StreamReader streamReader = new StreamReader(fs, Encoding.UTF8))\n                {\n                    while (!streamReader.EndOfStream)\n                    {\n                        c = GetNextCharacter(streamReader);\n                        Console.Write(c);\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 342039, "name": "Smallest square that begins with n", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse constant Inf => 10e12; \n\nfor my $n (1..49) {\n   do { printf \"%2d: %3d^2 = %5d\\n\", $n, $_, $_**2 and last if $_**2 =~ /^$n/ } for 1..Inf\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 342040, "name": "Smallest square that begins with n", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse constant Inf => 10e12; \n\nfor my $n (1..49) {\n   do { printf \"%2d: %3d^2 = %5d\\n\", $n, $_, $_**2 and last if $_**2 =~ /^$n/ } for 1..Inf\n}\n", "target": "using System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int i, d, s, t, n = 50, c = 1;\n        var sw = new int[n];\n        for (i = d = s = 1; c < n; i++, s += d += 2)\n            for (t = s; t > 0; t /= 10)\n                if (t < n && sw[t] < 1)\n                    Console.Write(\"\", sw[t] = s, c++);\n        Console.Write(string.Join(\" \", sw).Substring(2));\n    }\n}\n"}
{"id": 342041, "name": "Brace expansion", "source": "Translate Perl to C#: sub brace_expand {\n    my $input = shift;\n    my @stack = ([my $current = ['']]);\n    \n    while ($input =~ /\\G ((?:[^\\\\{,}]++ | \\\\(?:.|\\z))++ | . )/gx) {\n        if ($1 eq '{') {\n            push @stack, [$current = ['']];\n        }\n        elsif ($1 eq ',' && @stack > 1) {\n            push @{$stack[-1]}, ($current = ['']);\n        }\n        elsif ($1 eq '}' && @stack > 1) {\n            my $group = pop @stack;\n            $current = $stack[-1][-1];\n            \n            \n            @{$group->[0]} = map { \"{$_}\" } @{$group->[0]} if @$group == 1;\n            \n            @$current = map {\n                my $c = $_;\n                map { map { $c . $_ } @$_ } @$group;\n            } @$current;\n        }\n        else { $_ .= $1 for @$current; }\n    }\n    \n    \n    while (@stack > 1) {\n        my $right = pop @{$stack[-1]};\n        my $sep;\n        if (@{$stack[-1]}) { $sep = ',' }\n        else               { $sep = '{'; pop @stack }\n        $current = $stack[-1][-1];\n        @$current = map {\n            my $c = $_;\n            map { $c . $sep . $_ } @$right;\n        } @$current;\n    }\n    \n    return @$current;\n}\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing static System.Linq.Enumerable;\n\npublic static class BraceExpansion\n{\n    enum TokenType { OpenBrace, CloseBrace, Separator, Text, Alternate, Concat }\n    const char L = '{', R = '}', S = ',';\n    \n    public static void Main() {\n        string[] input = {\n            \"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            @\"{,{,gotta have{ ,\\, again\\, }}more }cowbell!\",\n            @\"{}} some }{,{\\\\{ edge, edge} \\,}{ cases, {here} \\\\\\\\\\}\"\n        };\n        foreach (string text in input) Expand(text);\n    }\n    \n    static void Expand(string input) {\n        Token token = Tokenize(input);\n        foreach (string value in token) Console.WriteLine(value);\n        Console.WriteLine();\n    }\n    \n    static Token Tokenize(string input) {\n        var tokens = new List<Token>();\n        var buffer = new StringBuilder();\n        bool escaping = false;\n        int level = 0;\n        \n        foreach (char c in input) {\n            (escaping, level, tokens, buffer) = c switch {\n                _ when escaping => (false, level, tokens, buffer.Append(c)),\n                '\\\\' => (true, level, tokens, buffer.Append(c)),\n                L => (escaping, level + 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.OpenBrace)), buffer),\n                S when level > 0 => (escaping, level,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.Separator)), buffer),\n                R when level > 0 => (escaping, level - 1,\n                    tokens.With(buffer.Flush()).With(new Token(c.ToString(), TokenType.CloseBrace)).Merge(), buffer),\n                _ => (escaping, level, tokens, buffer.Append(c))\n            };\n        }\n        if (buffer.Length > 0) tokens.Add(buffer.Flush());\n        for (int i = 0; i < tokens.Count; i++) {\n            if (tokens[i].Type == TokenType.OpenBrace || tokens[i].Type == TokenType.Separator) {\n                tokens[i] = tokens[i].Value; \n            }\n        }\n        return new Token(tokens, TokenType.Concat);\n    }\n    \n    static List<Token> Merge(this List<Token> list) {\n        int separators = 0;\n        int last = list.Count - 1;\n        for (int i = list.Count - 3; i >= 0; i--) {\n            if (list[i].Type == TokenType.Separator) {\n                separators++;\n                Concat(list, i + 1, last);\n                list.RemoveAt(i);\n                last = i;\n            } else if (list[i].Type == TokenType.OpenBrace) {\n                Concat(list, i + 1, last);\n                if (separators > 0) {\n                    list[i] = new Token(list.Range((i+1)..^1), TokenType.Alternate);\n                    list.RemoveRange(i+1, list.Count - i - 1);\n                } else {\n                    list[i] = L.ToString();\n                    list[^1] = R.ToString();\n                    Concat(list, i, list.Count);\n                }\n                break;\n            }\n        }\n        return list;\n    }\n    \n    static void Concat(List<Token> list, int s, int e) {\n        for (int i = e - 2; i >= s; i--) {\n            (Token a, Token b) = (list[i], list[i+1]);\n            switch (a.Type, b.Type) {\n                case (TokenType.Text, TokenType.Text):\n                    list[i] = a.Value + b.Value;\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Concat):\n                    a.SubTokens.AddRange(b.SubTokens);\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Concat, TokenType.Text) when b.Value == \"\":\n                    list.RemoveAt(i+1);\n                    break;\n                case (TokenType.Text, TokenType.Concat) when a.Value == \"\":\n                    list.RemoveAt(i);\n                    break;\n                default:\n                    list[i] = new Token(new [] { a, b }, TokenType.Concat);\n                    list.RemoveAt(i+1);\n                    break;\n            }\n        }\n    }\n    \n    private struct Token : IEnumerable<string>\n    {\n        private List<Token>? _subTokens;\n        \n        public string Value { get; }\n        public TokenType Type { get; }\n        public List<Token> SubTokens => _subTokens ??= new List<Token>();\n        \n        public Token(string value, TokenType type) => (Value, Type, _subTokens) = (value, type, null);\n        public Token(IEnumerable<Token> subTokens, TokenType type) => (Value, Type, _subTokens) = (\"\", type, subTokens.ToList());\n        \n        public static implicit operator Token(string value) => new Token(value, TokenType.Text);\n        \n        public IEnumerator<string> GetEnumerator() => (Type switch\n        {\n            TokenType.Concat => SubTokens.Select(t => t.AsEnumerable()).CartesianProduct().Select(p => string.Join(\"\", p)),\n            TokenType.Alternate => from t in SubTokens from s in t select s,\n            _ => Repeat(Value, 1)\n        }).GetEnumerator();\n        \n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();        \n    }\n    \n    \n    static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n                from acc in accumulator\n                from item in sequence\n                select acc.Concat(new [] { item }));\n    }\n    \n    static List<Token> With(this List<Token> list, Token token) {\n        list.Add(token);\n        return list;\n    }\n    \n    static IEnumerable<Token> Range(this List<Token> list, Range range) {\n        int start = range.Start.GetOffset(list.Count);\n        int end = range.End.GetOffset(list.Count);\n        for (int i = start; i < end; i++) yield return list[i];\n    }\n    \n    static string Flush(this StringBuilder builder) {\n        string result = builder.ToString();\n        builder.Clear();\n        return result;\n    }\n}\n"}
{"id": 342042, "name": "Intersecting number wheels", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub get_next {\n    my($w,%wheels) = @_;\n    my $wh = \\@{$wheels{$w}}; \n    my $value = $$wh[0][$$wh[1]];\n    $$wh[1] = ($$wh[1]+1) % @{$$wh[0]};\n    defined $wheels{$value} ? get_next($value,%wheels) : $value;\n}\n\nsub spin_wheels {\n    my(%wheels) = @_;\n    say \"$_: \" . join ', ', @{${$wheels{$_}}[0]} for sort keys %wheels;\n    print get_next('A', %wheels) . ' ' for 1..20; print \"\\n\\n\";\n}\n\nspin_wheels(%$_) for\n(\n {'A' => [['1', '2', '3'], 0]},\n {'A' => [['1', 'B', '2'], 0], 'B' => [['3', '4'], 0]},\n {'A' => [['1', 'D', 'D'], 0], 'D' => [['6', '7', '8'], 0]},\n {'A' => [['1', 'B', 'C'], 0], 'B' => [['3', '4'], 0], 'C' => [['5', 'B'], 0]},\n);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class IntersectingNumberWheels\n{\n    public static void Main() {\n        TurnWheels(('A', \"123\")).Take(20).Print();\n        TurnWheels(('A', \"1B2\"), ('B', \"34\")).Take(20).Print();\n        TurnWheels(('A', \"1DD\"), ('D', \"678\")).Take(20).Print();\n        TurnWheels(('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")).Take(20).Print();\n    }\n\n    static IEnumerable<char> TurnWheels(params (char name, string values)[] wheels) {\n        var data = wheels.ToDictionary(wheel => wheel.name, wheel => wheel.values.Loop().GetEnumerator());\n        var primary = data[wheels[0].name];\n        while (true) {\n            yield return Turn(primary);\n        }\n\n        char Turn(IEnumerator<char> sequence) {\n            sequence.MoveNext();\n            char c = sequence.Current;\n            return char.IsDigit(c) ? c : Turn(data[c]);\n        }\n    }\n\n    static IEnumerable<T> Loop<T>(this IEnumerable<T> seq) {\n        while (true) {\n            foreach (T element in seq) yield return element;\n        }\n    }\n\n    static void Print(this IEnumerable<char> sequence) => Console.WriteLine(string.Join(\" \", sequence));\n}\n"}
{"id": 342043, "name": "Intersecting number wheels", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse feature 'say';\n\nsub get_next {\n    my($w,%wheels) = @_;\n    my $wh = \\@{$wheels{$w}}; \n    my $value = $$wh[0][$$wh[1]];\n    $$wh[1] = ($$wh[1]+1) % @{$$wh[0]};\n    defined $wheels{$value} ? get_next($value,%wheels) : $value;\n}\n\nsub spin_wheels {\n    my(%wheels) = @_;\n    say \"$_: \" . join ', ', @{${$wheels{$_}}[0]} for sort keys %wheels;\n    print get_next('A', %wheels) . ' ' for 1..20; print \"\\n\\n\";\n}\n\nspin_wheels(%$_) for\n(\n {'A' => [['1', '2', '3'], 0]},\n {'A' => [['1', 'B', '2'], 0], 'B' => [['3', '4'], 0]},\n {'A' => [['1', 'D', 'D'], 0], 'D' => [['6', '7', '8'], 0]},\n {'A' => [['1', 'B', 'C'], 0], 'B' => [['3', '4'], 0], 'C' => [['5', 'B'], 0]},\n);\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class IntersectingNumberWheels\n{\n    public static void Main() {\n        TurnWheels(('A', \"123\")).Take(20).Print();\n        TurnWheels(('A', \"1B2\"), ('B', \"34\")).Take(20).Print();\n        TurnWheels(('A', \"1DD\"), ('D', \"678\")).Take(20).Print();\n        TurnWheels(('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")).Take(20).Print();\n    }\n\n    static IEnumerable<char> TurnWheels(params (char name, string values)[] wheels) {\n        var data = wheels.ToDictionary(wheel => wheel.name, wheel => wheel.values.Loop().GetEnumerator());\n        var primary = data[wheels[0].name];\n        while (true) {\n            yield return Turn(primary);\n        }\n\n        char Turn(IEnumerator<char> sequence) {\n            sequence.MoveNext();\n            char c = sequence.Current;\n            return char.IsDigit(c) ? c : Turn(data[c]);\n        }\n    }\n\n    static IEnumerable<T> Loop<T>(this IEnumerable<T> seq) {\n        while (true) {\n            foreach (T element in seq) yield return element;\n        }\n    }\n\n    static void Print(this IEnumerable<char> sequence) => Console.WriteLine(string.Join(\" \", sequence));\n}\n"}
{"id": 342044, "name": "Color of a screen pixel", "source": "Translate Perl to C#: use strict;\nuse warnings;\nuse GD;\n\nmy $file = '/tmp/one-pixel-screen-capture.png';\n\nsystem \"screencapture -R 123,456,1,1 $file\";\n\nmy $image = GD::Image->newFromPng($file);\nmy $index = $image->getPixel(0,0);\nmy($red,$green,$blue) = $image->rgb($index);\nprint \"RGB: $red, $green, $blue\\n\";\n\nunlink $file;\n", "target": "using System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nclass Program\n{\n    static Color GetPixel(Point position)\n    {\n        using (var bitmap = new Bitmap(1, 1))\n        {\n            using (var graphics = Graphics.FromImage(bitmap))\n            {\n                graphics.CopyFromScreen(position, new Point(0, 0), new Size(1, 1));\n            }\n            return bitmap.GetPixel(0, 0);\n        }\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(GetPixel(Cursor.Position));\n    }\n}\n"}
{"id": 342045, "name": "Yahoo! search interface", "source": "Translate Perl to C#: package YahooSearch;\n\nuse Encode;\nuse HTTP::Cookies;  \nuse WWW::Mechanize;\n\n\n\nsub apply (&$)\n {my $f = shift; local $_ = shift; $f->(); return $_;}\n\n\n\nmy $search_prefs = 'v=1&n=100&sm=' .\n    apply {s/([^a-zA-Z0-9])/sprintf '%%%02X', ord $1/ge}\n    join '|',\n    map {'!' . $_}\n    qw(hsb Zq0 XbM sss dDO VFM RQh uZ0 Fxe yCl GP4 FZK yNC mEG niH);\nmy $cookies = HTTP::Cookies->new;\n$cookies->set_cookie(0, 'sB', $search_prefs, '/', 'search.yahoo.com');\n\nmy $mech = new WWW::Mechanize\n   (cookie_jar => $cookies,\n    stack_depth => 0);\n\nsub read_page\n {my ($next, $page, @results) =\n     ($mech->find_link(text => 'Next >')->url,\n      decode 'iso-8859-1', $mech->content);\n  while ($page =~ m\n         {<h3> <a \\s class=\"yschttl \\s spt\" \\s\n          href=\" ([^\"]+) \" \\s* >                \n          (.+?) </a>\n          .+?\n          <div \\s class=\"abstr\">\n          (.+?) </div>}xg)\n     {push @results, {url => $1, title => $2, content => $3};\n      foreach ( @{$results[-1]}{qw(title content)} )\n         {s/<.+?>//g;\n          $_ = encode 'utf8', $_;}}\n  return $next, \\@results;}\n\n\n\nsub new\n {my $invocant = shift;\n  my $class = ref($invocant) || $invocant;\n  $mech->get('http://search.yahoo.com/search?p=' . apply\n     {s/([^a-zA-Z0-9 ])/sprintf '%%%02X', ord $1/ge;\n      s/ /+/g;}\n    shift);\n  my ($next, $results) = read_page();\n  return bless {link_to_next => $next, results => $results}, $class;}\n\nsub results\n {@{shift()->{results}};}\n\nsub next_page\n {my $invocant = shift;\n  my $next = $invocant->{link_to_next};\n  unless ($next)\n     {$invocant->{results} = [];\n      return undef;}\n  $mech->get($next);\n  ($next, my $results) = read_page();\n  $invocant->{link_to_next} = $next;\n  $invocant->{results} = $results;\n  return 1;}\n", "target": "using System;\nusing System.Net;\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nclass YahooSearch {\n    private string query;\n    private string content;\n    private int page;\n\n    const string yahoo = \"http:\n\n    public YahooSearch(string query) : this(query, 0) { }\n\n    public YahooSearch(string query, int page) {\n        this.query = query;\n        this.page = page;\n        this.content = new WebClient()\n            .DownloadString(\n                string.Format(yahoo + \"p={0}&b={1}\", query, this.page * 10 + 1)\n            );\n    }\n\n    public YahooResult[] Results {\n        get {\n            List<YahooResult> results = new List<YahooResult>();\n\n            Func<string, string, string> substringBefore = (str, before) =>\n            {\n                int iHref = str.IndexOf(before);\n                return iHref < 0 ? \"\" : str.Substring(0, iHref);\n            };\n            Func<string, string, string> substringAfter = (str, after) =>\n            {\n                int iHref = str.IndexOf(after);\n                return iHref < 0 ? \"\" : str.Substring(iHref + after.Length);\n            };\n            Converter<string, string> getText = p => \n                Regex.Replace(p, \"<[^>]*>\", x => \"\");\n\n            Regex rx = new Regex(@\"\n                <li>\n                    <div \\s class=\"\"res\"\">\n                        <div>\n                            <h3>\n                                <a \\s (?'LinkAttributes'[^>]+)>\n                                    (?'LinkText' .*?)\n                                (?></a>)\n                            </h3>\n                        </div>\n                        <div \\s class=\"\"abstr\"\">\n                            (?'Abstract' .*?)\n                        (?></div>)\n                        .*?\n                    (?></div>)\n                </li>\",\n                RegexOptions.IgnorePatternWhitespace\n                | RegexOptions.ExplicitCapture\n            );\n            foreach (Match e in rx.Matches(this.content)) {\n                string rurl = getText(substringBefore(substringAfter(\n                    e.Groups[\"LinkAttributes\"].Value, @\"href=\"\"\"), @\"\"\"\"));\n                string rtitle = getText(e.Groups[\"LinkText\"].Value);\n                string rcontent = getText(e.Groups[\"Abstract\"].Value);\n                \n                results.Add(new YahooResult(rurl, rtitle, rcontent));\n            }\n            return results.ToArray();\n        }\n    }\n\n    public YahooSearch NextPage() {\n        return new YahooSearch(this.query, this.page + 1);\n    }\n\n    public YahooSearch GetPage(int page) {\n        return new YahooSearch(this.query, page);\n    }\n}\n\nclass YahooResult {\n    public string URL { get; set; }\n    public string Title { get; set; }\n    public string Content { get; set; }\n\n    public YahooResult(string url, string title, string content) {\n        this.URL = url;\n        this.Title = title;\n        this.Content = content;\n    }\n\n    public override string ToString()\n    {\n        return string.Format(\"\\nTitle: {0}\\nLink:  {1}\\nText:  {2}\",\n            Title, URL, Content);\n    }\n}\n\n\n\nclass Prog {\n    static void Main() {\n        foreach (int page in new[] { 0, 1 })\n        {\n            YahooSearch x = new YahooSearch(\"test\", page);\n\n            foreach (YahooResult result in x.Results)\n            {\n                Console.WriteLine(result);\n            }\n        }\n    }\n}\n"}
{"id": 342046, "name": "Circles of given radius through two points", "source": "Translate Perl to C#: use strict;\n\nsub circles {\n    my ($x1, $y1, $x2, $y2, $r) = @_;\n\n    return \"Radius is zero\" if $r == 0;\n    return \"Coincident points gives infinite number of circles\" if $x1 == $x2 and $y1 == $y2;\n\n    \n    my ($dx, $dy) = ($x2 - $x1, $y2 - $y1);\n    my $q = sqrt($dx**2 + $dy**2);\n    return \"Separation of points greater than diameter\" if $q > 2*$r;\n\n    \n    my ($x3, $y3) = (($x1 + $x2) / 2, ($y1 + $y2) / 2);\n    \n    my $d = sqrt($r**2-($q/2)**2);\n\n    \n    sprintf '(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f)',\n        $x3 - $d*$dy/$q, $y3 + $d*$dx/$q,\n        $x3 + $d*$dy/$q, $y3 - $d*$dx/$q;\n}\n\nmy @arr = (\n    [0.1234, 0.9876, 0.8765, 0.2345, 2.0],\n    [0.0000, 2.0000, 0.0000, 0.0000, 1.0],\n    [0.1234, 0.9876, 0.1234, 0.9876, 2.0],\n    [0.1234, 0.9876, 0.8765, 0.2345, 0.5],\n    [0.1234, 0.9876, 0.1234, 0.9876, 0.0]\n);\n\nprintf \"(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f) with radius\u00a0%.1f: %s\\n\", @$_[0..4], circles @$_ for @arr;\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 342047, "name": "Circles of given radius through two points", "source": "Translate Perl to C#: use strict;\n\nsub circles {\n    my ($x1, $y1, $x2, $y2, $r) = @_;\n\n    return \"Radius is zero\" if $r == 0;\n    return \"Coincident points gives infinite number of circles\" if $x1 == $x2 and $y1 == $y2;\n\n    \n    my ($dx, $dy) = ($x2 - $x1, $y2 - $y1);\n    my $q = sqrt($dx**2 + $dy**2);\n    return \"Separation of points greater than diameter\" if $q > 2*$r;\n\n    \n    my ($x3, $y3) = (($x1 + $x2) / 2, ($y1 + $y2) / 2);\n    \n    my $d = sqrt($r**2-($q/2)**2);\n\n    \n    sprintf '(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f)',\n        $x3 - $d*$dy/$q, $y3 + $d*$dx/$q,\n        $x3 + $d*$dy/$q, $y3 - $d*$dx/$q;\n}\n\nmy @arr = (\n    [0.1234, 0.9876, 0.8765, 0.2345, 2.0],\n    [0.0000, 2.0000, 0.0000, 0.0000, 1.0],\n    [0.1234, 0.9876, 0.1234, 0.9876, 2.0],\n    [0.1234, 0.9876, 0.8765, 0.2345, 0.5],\n    [0.1234, 0.9876, 0.1234, 0.9876, 0.0]\n);\n\nprintf \"(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f) with radius\u00a0%.1f: %s\\n\", @$_[0..4], circles @$_ for @arr;\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 342048, "name": "Vampire number", "source": "Translate Perl to C#: \nuse warnings;\nuse strict;\nuse feature qw(say);\n\nsub fangs {\n    my $vampire = shift;\n    my $length  = length 0 + $vampire;\n    return if $length % 2;\n    my $fang_length = $length / 2;\n    my $from        = '1' . '0' x ($fang_length - 1);\n    my $to          = '9' x $fang_length;\n    my $sorted      = join q(), sort split //, $vampire;\n    my @fangs;\n    for my $f1 ($from .. 1 + sqrt $vampire) {\n        next if $vampire % $f1;\n        my $f2 = $vampire / $f1;\n        next if $sorted ne join q(), sort split //, $f1 . $f2;\n        next if 2 == grep '0' eq substr($_, -1 , 1), $f1, $f2; \n        push @fangs, [$f1, $f2];\n    }\n    return @fangs;\n}\n\nmy $count = 0;\nmy $i     = 9;\nwhile ($count < 25) {\n    $i++;\n    my @f = fangs($i);\n    $count++, say join ' ', \"$count. $i:\", map \"[@$_]\", @f if @f;\n}\n\nsay join ' ', $_, map \"[@$_]\", fangs($_) for 16758243290880, 24959017348650, 14593825548650;\n", "target": "using System;\n\nnamespace RosettaVampireNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int i, j, n;\n            ulong x;\n            var f = new ulong[16];\n            var bigs = new ulong[] { 16758243290880UL, 24959017348650UL, 14593825548650UL, 0 };\n            ulong[] tens = new ulong[20];\n            tens[0] = 1;\n            for (i = 1; i < 20; i++)\n                tens[i] = tens[i - 1] * 10;\n            \n            for (x = 1, n = 0; n < 25; x++)\n            {\n                if ((j = fangs(x, f, tens)) == 0) continue;\n                Console.Write(++n + \": \");\n                show_fangs(x, f, j);\n            }\n\n            Console.WriteLine();\n            for (i = 0; bigs[i] > 0 ; i++)\n            {\n                if ((j = fangs(bigs[i], f, tens)) > 0)\n                    show_fangs(bigs[i], f, j);\n                else\n                    Console.WriteLine(bigs[i] + \" is not vampiric.\");\n            }\n            Console.ReadLine();\n        }\n\n        private static void show_fangs(ulong x, ulong[] f, int cnt)\n        {\n            Console.Write(x); \n            int i;\n            for (i = 0; i < cnt; i++)\n                Console.Write(\" =\u00a0\" + f[i] + \" * \" + (x / f[i]));\n            Console.WriteLine();\n        }\n\n        private static int fangs(ulong x, ulong[] f, ulong[] tens)\n        {\n            int n = 0;\n            int nd = ndigits(x);\n            if ((nd & 1) > 0) return 0;\n            nd /= 2;\n\n            ulong lo, hi;\n            lo = Math.Max(tens[nd - 1], (x + tens[nd] - 2) / (tens[nd] - 1));\n            hi = Math.Min(x / lo, (ulong) Math.Sqrt(x));\n\n            ulong a, b, t = dtally(x);\n            for (a = lo; a <= hi; a++)\n            {\n                b = x / a;\n                if (a * b == x && ((a % 10) > 0 || (b % 10) > 0) && t == dtally(a) + dtally(b))\n                    f[n++] = a;\n            }\n\n            return n;\n        }\n\n        private static ulong dtally(ulong x)\n        {\n            ulong t = 0;\n            while (x > 0)\n            {\n                t += 1UL << (int)((x % 10) * 6);\n                x /= 10;\n            }\n\n            return t;\n        }\n\n        private static int ndigits(ulong x)\n        {\n            int n = 0;\n            while (x > 0)\n            {\n                n++;\n                x /= 10;\n            }\n            return n;\n        }\n    }\n}\n"}
{"id": 342049, "name": "Penney's game", "source": "Translate Perl to C#: \nuse 5.020;\nuse strict;\nuse warnings;\n\n\nbinaryRand() == 0 ? flipCoin(userFirst()) : flipCoin(compFirst());\n\n\nsub binaryRand\n{\n    return int(rand(2));\n}\n\nsub convert\n{\n    my $randNum = binaryRand();\n    if($randNum == 0)\n    {\n        return \"T\"\n    }\n    else\n    {\n        return \"H\";\n    }\n}\n\n\nsub uSeq\n{\n    print(\"Please enter a sequence of 3 of \\\"H\\\" and \\\"T\\\". EG: HHT\\n>\");\n    my $uString = <STDIN>;\n\n    while(1)\n    {\n        \n        chomp($uString);\n        $uString = uc $uString;\n        \n        if(length $uString == 3 && (substr($uString, 0, 1) =~ /[HT]/ &&\n                                    substr($uString, 1, 1) =~ /[HT]/ &&\n                                    substr($uString, 2, 1) =~ /[HT]/))\n        {\n            last;\n        }\n        else\n        {\n            print(\"Error, try again. \\n\");\n            print(\"Please enter a sequence of 3 of \\\"H\\\" and \\\"T\\\". EG: HHT\\n\");\n            $uString = <STDIN>;\n        }\n    }\n    return $uString;\n}\n\n\nsub compFirst\n{\n    my $cSeq;\n    \n    for(my $i = 0; $i < 3; $i++)\n    {\n        $cSeq = $cSeq . convert();\n    }\n\n    print(\"The computer guesses first:\\ncomp- $cSeq\\n\");\n    my $uSeq = uSeq();\n    print(\"user- $uSeq\\n\");\n    my @seqArr = ($uSeq, $cSeq);\n    return @seqArr;\n}\n\n\nsub userFirst\n{\n    print(\"The user quesses first:\\n\");\n    my $uSeq = uSeq();\n    my $cSeq;\n    \n    my $middle = substr($uSeq, 1, 1);\n    $middle eq \"H\" ? $cSeq = \"T\" : $cSeq = \"H\";\n    $cSeq = $cSeq . substr($uSeq, 0, 2); \n\n    print(\"user- $uSeq\\ncomp- $cSeq\\n\");\n    my @seqArr = ($uSeq, $cSeq);\n    return @seqArr; \n}\n\n\nsub flipCoin\n{\n    my ($uSeq, $cSeq) = @_;\n    my $coin;\n    while(1)\n    {\n        $coin = $coin . convert();\n        if($coin =~ m/$uSeq/)\n        {\n            print(\"The sequence of tosses was: $coin\\n\");\n            say(\"The player wins! \");\n            last;\n        }\n        elsif($coin =~ m/$cSeq/)\n        {\n            print(\"The sequence of tosses was: $coin\\n\");\n            say(\"The computer wins! \");\n            last;\n        }\n    }\n}\n", "target": "using static System.Console;\nusing static System.Threading.Thread;\nusing System;\n\npublic static class PenneysGame\n{\n    const int pause = 500;\n    const int N = 3;\n    static Random rng = new Random();\n\n    static int Toss() => rng.Next(2);\n\n    static string AsString(this int sequence) {\n        string s = \"\";\n        for (int b = 0b100; b > 0; b >>= 1) {\n            s += (sequence & b) > 0 ? 'T' : 'H';\n        }\n        return s;\n    }\n\n    static int UserInput() {\n        while (true) {\n            switch (ReadKey().Key) {\n                case ConsoleKey.Escape: return -1;\n                case ConsoleKey.H: return 0;\n                case ConsoleKey.T: return 1;\n            }\n            Console.Write('\\b');\n        }\n    }\n\n    public static void Main2() {\n        int yourScore = 0, myScore = 0;\n        while (true) {\n            WriteLine($\"Your score: {yourScore}, My score: {myScore}\");\n            WriteLine(\"Determining who goes first...\");\n            Sleep(pause);\n            bool youStart = Toss() == 1;\n            WriteLine(youStart ? \"You go first.\" : \"I go first.\");\n            int yourSequence = 0, mySequence = 0;\n            if (youStart) {\n                WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                int userChoice;\n                for (int i = 0; i < N; i++) {\n                    if ((userChoice = UserInput()) < 0) return;\n                    yourSequence = (yourSequence << 1) + userChoice;\n                }\n                mySequence = ((~yourSequence << 1) & 0b100) | (yourSequence >> 1);\n            } else {\n                for (int i = 0; i < N; i++) {\n                    mySequence = (mySequence << 1) + Toss();\n                }\n\n                WriteLine(\"I chose \" + mySequence.AsString());\n                do {\n                    WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                    int choice;\n                    yourSequence = 0;\n                    for (int i = 0; i < N; i++) {\n                        if ((choice = UserInput()) < 0) return;\n                        yourSequence = (yourSequence << 1) + choice;\n                    }\n                    if (yourSequence == mySequence) {\n                        WriteLine();\n                        WriteLine(\"You cannot choose the same sequence.\");\n                    }\n                } while (yourSequence == mySequence);\n            }\n\n            WriteLine();\n            WriteLine($\"Your sequence: {yourSequence.AsString()}, My sequence: {mySequence.AsString()}\");\n            WriteLine(\"Tossing...\");\n            int sequence = 0;\n            for (int i = 0; i < N; i++) {\n                Sleep(pause);\n                int toss = Toss();\n                sequence = (sequence << 1) + toss;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            while (true) {\n                if (sequence == yourSequence) {\n                    WriteLine();\n                    WriteLine(\"You win!\");\n                    yourScore++;\n                    break;\n                } else if (sequence == mySequence) {\n                    WriteLine();\n                    WriteLine(\"I win!\");\n                    myScore++;\n                    break;\n                }\n                Sleep(pause);\n                int toss = Toss();\n                sequence = ((sequence << 1) + toss) & 0b111;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            WriteLine(\"Press a key.\");\n            ReadKey();\n            Clear();\n        }\n    }\n\n}\n"}
{"id": 349447, "name": "Range consolidation", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse List::Util qw(min max);\n\nsub consolidate {\n    our @arr; local *arr = shift;\n    my @sorted = sort { @$a[0] <=> @$b[0] } map { [sort { $a <=> $b } @$_] } @arr;\n    my @merge = shift @sorted;\n    for my $i (@sorted) {\n        if ($merge[-1][1] >= @$i[0]) {\n            $merge[-1][0] = min($merge[-1][0], @$i[0]);\n            $merge[-1][1] = max($merge[-1][1], @$i[1]);\n        } else {\n            push @merge, $i;\n        }\n    }\n    return @merge;\n}\n\nfor my $intervals (\n    [[1.1, 2.2],],\n    [[6.1, 7.2], [7.2, 8.3]],\n    [[4, 3], [2, 1]],\n    [[4, 3], [2, 1], [-1, -2], [3.9, 10]],\n    [[1, 3], [-6, -1], [-4, -5], [8, 2], [-6, -6]]) {\n        my($in,$out);\n        $in   = join ', ', map { '[' . join(', ', @$_) . ']' } @$intervals;\n        $out .= join('..', @$_). ' ' for consolidate($intervals);\n        printf \"%44s => %s\\n\", $in, $out;\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class RangeConsolidation {\n\n    public static void main(String[] args) {\n        displayRanges( Arrays.asList(new Range(1.1, 2.2)));\n        displayRanges( Arrays.asList(new Range(6.1, 7.2), new Range(7.2, 8.3)));\n        displayRanges( Arrays.asList(new Range(4, 3), new Range(2, 1)));\n        displayRanges( Arrays.asList(new Range(4, 3), new Range(2, 1), new Range(-1, -2), new Range(3.9, 10)));\n        displayRanges( Arrays.asList(new Range(1, 3), new Range(-6, -1), new Range(-4, -5), new Range(8, 2), new Range(-6, -6)));\n        displayRanges( Arrays.asList(new Range(1, 1), new Range(1, 1)));\n        displayRanges( Arrays.asList(new Range(1, 1), new Range(1, 2)));\n        displayRanges( Arrays.asList(new Range(1, 2), new Range(3, 4), new Range(1.5, 3.5), new Range(1.2, 2.5)));\n    }\n    \n    private static final void displayRanges(List<Range> ranges) {\n        System.out.printf(\"ranges =\u00a0%-70s, colsolidated = %s%n\", ranges, Range.consolidate(ranges));\n    }\n    \n    private static final class RangeSorter implements Comparator<Range> {\n        @Override\n        public int compare(Range o1, Range o2) {\n            return (int) (o1.left - o2.left);\n        }        \n    }\n\n    private static class Range {\n        double left;\n        double right;\n        \n        public Range(double left, double right) {\n            if ( left <= right ) {\n                this.left = left;\n                this.right = right;\n            }\n            else {\n                this.left = right;\n                this.right = left;\n            }\n        }\n        \n        public Range consolidate(Range range) {\n            \n            if ( this.right < range.left ) {\n                return null;\n            }\n            \n            if ( range.right < this.left ) {\n                return null;\n            }\n            \n            if ( this.left <= range.left && this.right >= range.right ) {\n                return this;\n            }\n            \n            if ( range.left <= this.left && range.right >= this.right ) {\n                return range;\n            }\n            \n            if ( this.left <= range.left && this.right <= range.right ) {\n                return new Range(this.left, range.right);\n            }\n            \n            if ( this.left >= range.left && this.right >= range.right ) {\n                return new Range(range.left, this.right);\n            }\n            throw new RuntimeException(\"ERROR:  Logic invalid.\");\n        }\n        \n        @Override\n        public String toString() {\n            return \"[\" + left + \", \" + right + \"]\";\n        }\n        \n        private static List<Range> consolidate(List<Range> ranges) {\n            List<Range> consolidated = new ArrayList<>();\n            \n            Collections.sort(ranges, new RangeSorter());\n            \n            for ( Range inRange : ranges ) {\n                Range r = null;\n                Range conRange = null;\n                for ( Range conRangeLoop : consolidated ) {\n                    r = inRange.consolidate(conRangeLoop);\n                    if (r != null ) {\n                        conRange = conRangeLoop;\n                        break;\n                    }\n                }\n                if ( r == null ) {\n                    consolidated.add(inRange);\n                }\n                else {\n                    consolidated.remove(conRange);\n                    consolidated.add(r);                    \n                }\n            }\n            \n            Collections.sort(consolidated, new RangeSorter());\n            \n            return consolidated;\n        }\n    }\n\n}\n"}
{"id": 349448, "name": "Pascal matrix generation", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\nuse feature qw{ say };\n\n\nsub upper {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = $x > $y          ? 0\n                       : ! $x || $x == $y ? 1\n                                          : $m[$x-1][$y-1] + $m[$x][$y-1];\n        }\n    }\n    return \\@m\n}\n\n\nsub lower {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = $x < $y          ? 0\n                       : ! $x || $x == $y ? 1\n                                          : $m[$x-1][$y-1] + $m[$x-1][$y];\n        }\n    }\n    return \\@m\n}\n\n\nsub symmetric {\n    my ($i, $j) = @_;\n    my @m;\n    for my $x (0 .. $i - 1) {\n        for my $y (0 .. $j - 1) {\n            $m[$x][$y] = ! $x || ! $y ? 1\n                                      : $m[$x-1][$y] + $m[$x][$y-1];\n        }\n    }\n    return \\@m\n}\n\n\nsub pretty {\n    my $m = shift;\n    for my $row (@$m) {\n        say join ', ', @$row;\n    }\n}\n\n\npretty(upper(5, 5));\nsay '-' x 14;\npretty(lower(5, 5));\nsay '-' x 14;\npretty(symmetric(5, 5));\n", "target": "import static java.lang.System.out;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class PascalMatrix {\n    static int binomialCoef(int n, int k) {\n        int result = 1;\n        for (int i = 1; i <= k; i++)\n            result = result * (n - i + 1) / i;\n        return result;\n    }\n\n    static List<IntStream> pascal(int n, Function<Integer, IntStream> f) {\n        return range(0, n).mapToObj(i -> f.apply(i)).collect(toList());\n    }\n\n    static List<IntStream> pascalUpp(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(j, i)));\n    }\n\n    static List<IntStream> pascalLow(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i, j)));\n    }\n\n    static List<IntStream> pascalSym(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i + j, i)));\n    }\n\n    static void print(String label, List<IntStream> result) {\n        out.println(\"\\n\" + label);\n        for (IntStream row : result) {\n            row.forEach(i -> out.printf(\"%2d \", i));\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] a) {\n        print(\"Upper: \", pascalUpp(5));\n        print(\"Lower: \", pascalLow(5));\n        print(\"Symmetric:\", pascalSym(5));\n    }\n}\n"}
{"id": 349449, "name": "Mad Libs", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\n\nmy $template = shift;\nopen my $IN, '<', $template or die $!;\nmy $story = do { local $/ ; <$IN> };\n\nmy %blanks;\nundef $blanks{$_} for $story =~ m/<(.*?)>/g;\n\nfor my $blank (sort keys %blanks) {\n    print \"$blank: \";\n    chomp (my $replacement = <>);\n    $blanks{$blank} = $replacement;\n}\n\n$story =~ s/<(.*?)>/$blanks{$1}/g;\nprint $story;\n", "target": "import java.util.*;\n\npublic class MadLibs {\n    \n    public static void main(String[] args){\n        Scanner input = new Scanner(System.in);\n        \n        String name, gender, noun;\n        \n        System.out.print(\"Enter a name: \");\n        name = input.next();\n        \n        System.out.print(\"He or she: \");\n        gender = input.next();\n        \n        System.out.print(\"Enter a noun: \");\n        noun = input.next();\n        \n        System.out.println(\"\\f\" + name + \" went for a walk in the park. \" + gender + \"\\nfound a \" + noun + \". \" + name + \" decided to take it home.\");\n        \n    \n    }\n}\n"}
{"id": 349450, "name": "Shortest common supersequence", "source": "Translate Perl to Java: sub lcs { \n    my( $u, $v ) = @_;\n    return '' unless length($u) and length($v);\n    my $longest = '';\n    for my $first ( 0..length($u)-1 ) {\n        my $char = substr $u, $first, 1;\n        my $i = index( $v, $char );\n        next if -1==$i;\n        my $next = $char;\n        $next .= lcs( substr( $u, $first+1), substr( $v, $i+1 ) ) unless $i==length($v)-1;\n        $longest = $next if length($next) > length($longest);\n    }\n    return $longest;\n}\n\nsub scs { \n    my( $u, $v ) = @_;\n    my @lcs = split //, lcs $u, $v;\n    my $pat = \"(.*)\".join(\"(.*)\",@lcs).\"(.*)\"; \n    my @u = $u =~ /$pat/;\n    my @v = $v =~ /$pat/;\n    my $scs = shift(@u).shift(@v);\n    $scs .= $_.shift(@u).shift(@v) for @lcs;\n    return $scs;\n}\n\nmy $u = \"abcbdab\";\nmy $v = \"bdcaba\";\nprintf \"Strings %s %s\\n\", $u, $v;\nprintf \"Longest common subsequence:   %s\\n\", lcs $u, $v;\nprintf \"Shortest common supersquence: %s\\n\", scs $u, $v;\n", "target": "public class ShortestCommonSuperSequence {\n    private static boolean isEmpty(String s) {\n        return null == s || s.isEmpty();\n    }\n\n    private static String scs(String x, String y) {\n        if (isEmpty(x)) {\n            return y;\n        }\n        if (isEmpty(y)) {\n            return x;\n        }\n\n        if (x.charAt(0) == y.charAt(0)) {\n            return x.charAt(0) + scs(x.substring(1), y.substring(1));\n        }\n\n        if (scs(x, y.substring(1)).length() <= scs(x.substring(1), y).length()) {\n            return y.charAt(0) + scs(x, y.substring(1));\n        } else {\n            return x.charAt(0) + scs(x.substring(1), y);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.println(scs(\"abcbdab\", \"bdcaba\"));\n    }\n}\n"}
{"id": 349451, "name": "Long year", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse DateTime;\n\nfor my $century (19 .. 21) {\n  for my $year ($century*100 .. ++$century*100 - 1) {\n    print \"$year \" if DateTime->new(year => $year, month => 12, day => 28)->week_number > 52\n  }\n  print \"\\n\";\n}\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.WeekFields;\n\npublic class LongYear {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Long years this century:%n\");\n        for (int year = 2000 ; year < 2100 ; year++ ) {\n            if ( longYear(year) ) {\n                System.out.print(year + \"  \");\n            }\n        }\n    }\n    \n    private static boolean longYear(int year) {\n        return LocalDate.of(year, 12, 28).get(WeekFields.ISO.weekOfYear()) == 53;\n    }\n\n}\n"}
{"id": 349452, "name": "Mian-Chowla sequence", "source": "Translate Perl to Java: use strict; \nuse warnings;\nuse feature 'say';\n\nsub generate_mc {\n    my($max)  = @_;\n    my $index = 0;\n    my $test  = 1;\n    my %sums  = (2 => 1);\n    my @mc    = 1;\n    while ($test++) {\n        my %these = %sums;\n        map { next if ++$these{$_ + $test} > 1 } @mc[0..$index], $test;\n        %sums = %these;\n        $index++;\n        return @mc if (push @mc, $test) > $max-1;\n    }\n}\n\nmy @mian_chowla = generate_mc(100);\nsay \"First 30 terms in the Mian\u2013Chowla sequence:\\n\", join(' ', @mian_chowla[ 0..29]),\n    \"\\nTerms 91 through 100:\\n\",                     join(' ', @mian_chowla[90..99]);\n", "target": "import java.util.Arrays;\n\npublic class MianChowlaSequence {\n\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        System.out.println(\"First 30 terms of the Mian\u2013Chowla sequence.\");\n        mianChowla(1, 30);\n        System.out.println(\"Terms 91 through 100 of the Mian\u2013Chowla sequence.\");\n        mianChowla(91, 100);\n        long end = System.currentTimeMillis();\n        System.out.printf(\"Elapsed = %d ms%n\", (end-start));\n    }\n\n    private static void mianChowla(int minIndex, int maxIndex) {\n        int [] sums = new int[1];\n        int [] chowla = new int[maxIndex+1];\n        sums[0] = 2;\n        chowla[0] = 0;\n        chowla[1] = 1;\n        if ( minIndex == 1 ) {\n            System.out.printf(\"%d \", 1);\n        }\n        int chowlaLength = 1;\n        for ( int n = 2 ; n <= maxIndex ; n++ ) {\n\n            \n            int test = chowla[n - 1];\n            \n            int[] sumsNew = Arrays.copyOf(sums, sums.length + n);\n            int sumNewLength = sums.length;\n            int savedsSumNewLength = sumNewLength;\n            \n            \n            boolean found = false;\n            while ( ! found ) {\n                test++;\n                found = true;\n                sumNewLength = savedsSumNewLength;\n                \n                for ( int j = 0 ; j <= chowlaLength ; j++ ) {\n                    int testSum = (j == 0 ? test : chowla[j]) + test;\n                    boolean duplicate = false;\n                    \n                    \n                    for ( int k = 0 ; k < sumNewLength ; k++ ) {\n                        if ( sumsNew[k] == testSum ) {\n                            duplicate = true;\n                            break;\n                        }\n                    }\n                    if ( ! duplicate ) {\n                        \n                        sumsNew[sumNewLength] = testSum;\n                        sumNewLength++;\n                    }\n                    else {\n                        \n                        found = false;\n                        break;\n                    }\n                }\n            }\n            \n            \n            chowla[n] = test;\n            chowlaLength++;            \n            sums = sumsNew;\n            if ( n >= minIndex ) {\n                System.out.printf(\"%d %s\", chowla[n], (n==maxIndex ? \"\\n\" : \"\"));\n            }\n        }\n    }\n\n}\n"}
{"id": 349453, "name": "Water collected between towers", "source": "Translate Perl to Java: use Modern::Perl;\nuse List::Util qw{ min max sum };\n\nsub water_collected {\n    my @t = map { { TOWER => $_, LEFT => 0, RIGHT => 0, LEVEL => 0 } } @_;\n\n    my ( $l, $r ) = ( 0, 0 );\n    $_->{LEFT}  = ( $l = max( $l, $_->{TOWER} ) ) for @t;\n    $_->{RIGHT} = ( $r = max( $r, $_->{TOWER} ) ) for reverse @t;\n    $_->{LEVEL} = min( $_->{LEFT}, $_->{RIGHT} )  for @t;\n\n    return sum map { $_->{LEVEL} > 0 ? $_->{LEVEL} - $_->{TOWER} : 0 } @t;\n}\n\nsay join ' ', map { water_collected( @{$_} ) } (\n    [ 1, 5,  3, 7, 2 ],\n    [ 5, 3,  7, 2, 6, 4, 5, 9, 1, 2 ],\n    [ 2, 6,  3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1 ],\n    [ 5, 5,  5, 5 ],\n    [ 5, 6,  7, 8 ],\n    [ 8, 7,  7, 6 ],\n    [ 6, 7, 10, 7, 6 ],\n);\n", "target": "public class WaterBetweenTowers {\n    public static void main(String[] args) {\n        int i = 1;\n        int[][] tba = new int[][]{\n            new int[]{1, 5, 3, 7, 2},\n            new int[]{5, 3, 7, 2, 6, 4, 5, 9, 1, 2},\n            new int[]{2, 6, 3, 5, 2, 8, 1, 4, 2, 2, 5, 3, 5, 7, 4, 1},\n            new int[]{5, 5, 5, 5},\n            new int[]{5, 6, 7, 8},\n            new int[]{8, 7, 7, 6},\n            new int[]{6, 7, 10, 7, 6}\n        };\n\n        for (int[] tea : tba) {\n            int rht, wu = 0, bof;\n            do {\n                for (rht = tea.length - 1; rht >= 0; rht--) {\n                    if (tea[rht] > 0) {\n                        break;\n                    }\n                }\n\n                if (rht < 0) {\n                    break;\n                }\n\n                bof = 0;\n                for (int col = 0; col <= rht; col++) {\n                    if (tea[col] > 0) {\n                        tea[col]--;\n                        bof += 1;\n                    } else if (bof > 0) {\n                        wu++;\n                    }\n                }\n                if (bof < 2) {\n                    break;\n                }\n            } while (true);\n\n            System.out.printf(\"Block %d\", i++);\n            if (wu == 0) {\n                System.out.print(\" does not hold any\");\n            } else {\n                System.out.printf(\" holds %d\", wu);\n            }\n            System.out.println(\" water units.\");\n        }\n    }\n}\n"}
{"id": 349454, "name": "FASTA format", "source": "Translate Perl to Java: my $fasta_example = <<'END_FASTA_EXAMPLE';\n>Rosetta_Example_1\nTHERECANBENOSPACE\n>Rosetta_Example_2\nTHERECANBESEVERAL\nLINESBUTTHEYALLMUST\nBECONCATENATED\nEND_FASTA_EXAMPLE\n\nmy $num_newlines = 0;\nwhile ( < $fasta_example > ) {\n\tif (/\\A\\>(.*)/) {\n\t\tprint \"\\n\" x $num_newlines, $1, ': ';\n\t}\n\telse {\n\t\t$num_newlines = 1;\n\t\tprint;\n\t}\n}\n", "target": "import java.io.*;\nimport java.util.Scanner;\n\npublic class ReadFastaFile {\n\n    public static void main(String[] args) throws FileNotFoundException {\n\n        boolean first = true;\n\n        try (Scanner sc = new Scanner(new File(\"test.fasta\"))) {\n            while (sc.hasNextLine()) {\n                String line = sc.nextLine().trim();\n                if (line.charAt(0) == '>') {\n                    if (first)\n                        first = false;\n                    else\n                        System.out.println();\n                    System.out.printf(\"%s: \", line.substring(1));\n                } else {\n                    System.out.print(line);\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 349455, "name": "MAC vendor lookup", "source": "Translate Perl to Java: \nuse v5.18.2;\nuse warnings;\nuse LWP;\nuse Time::HiRes qw(sleep);\n\nour $VERSION = 1.000_000;\n\nmy $ua = LWP::UserAgent->new;\n\nno warnings 'qw';\nmy @macs = qw(\n    FC-A1-3EFC:FB:FB:01:FA:21 00,0d,4b\n    Rhubarb                   00-14-22-01-23-45\n    10:dd:b1                  D4:F4:6F:C9:EF:8D\n    FC-A1-3E                  88:53:2E:67:07:BE\n    23:45:67                  FC:FB:FB:01:FA:21\n    BC:5F:F4\n);\n\nwhile (my $mac = shift @macs) {\n    my $vendor = get_mac_vendor($mac);\n    if ($vendor) {\n        say \"$mac = $vendor\";\n    }\n    sleep 1.5 if @macs;\n}\n\nsub get_mac_vendor {\n    my $s = shift;\n\n    my $req = HTTP::Request->new( GET => \"http://api.macvendors.com/$s\" );\n    my $res = $ua->request($req);\n\n    \n    \n    if ( $res->is_error ) {\n        return;\n    }\n\n    \n    \n    if (  !$res->content\n        or $res->content eq 'Vendor not found' )\n    {\n        return 'N/A';\n    }\n\n    return $res->content;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "target": "package com.jamesdonnell.MACVendor;\n\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\n\n\npublic class Lookup {\n\t\n\tprivate static final String baseURL = \"http:\n\n\t\n\tpublic static void main(String[] args) {\n\t\tfor (String arguments : args)\n\t\t\tSystem.out.println(arguments + \": \" + get(arguments));\n\t}\n\n\t\n\tprivate static String get(String macAddress) {\n\t\ttry {\n\t\t\tStringBuilder result = new StringBuilder();\n\t\t\tURL url = new URL(baseURL + macAddress);\n\t\t\tHttpURLConnection conn = (HttpURLConnection) url.openConnection();\n\t\t\tconn.setRequestMethod(\"GET\");\n\t\t\tBufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));\n\t\t\tString line;\n\t\t\twhile ((line = rd.readLine()) != null) {\n\t\t\t\tresult.append(line);\n\t\t\t}\n\t\t\trd.close();\n\t\t\treturn result.toString();\n\t\t} catch (FileNotFoundException e) {\n\t\t\t\n\t\t\treturn \"N/A\";\n\t\t} catch (IOException e) {\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t}\n}\n"}
{"id": 349456, "name": "Magic 8-ball", "source": "Translate Perl to Java: @a = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',\n 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',\n 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',\n 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',\n \"Don't bet on it\", 'My reply is no', 'My sources say no', 'Outlook not so good',\n 'Very doubtful');\n\nwhile () {\n    print 'Enter your question:';\n    last unless <> =~ /\\w/;\n    print @a[int rand @a], \"\\n\";\n}\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class MagicEightBall {\n\n    public static void main(String[] args) {\n        new MagicEightBall().run();\n    }\n    \n    private static String[] ANSWERS = new String[] {\"It is certain.\", \"It is decidedly so.\", \"Without a doubt.\", \"Yes - definitely.\",\n            \"You may rely on it.\", \"As I see it, yes.\", \"Most likely.\", \"Outlook good.\", \"Yes.\", \"Signs point to yes.\",\n            \"Reply hazy, try again.\", \"Ask again later.\", \"Better not tell you now.\", \"Cannot predict now.\", \"Concentrate and ask again.\",\n            \"Don't count on it.\", \"My reply is no.\", \"My sources say no.\", \"Outlook not so good.\", \"Very doubtful. \"};\n\n    public void run() {\n        Random random = new Random();\n        System.out.printf(\"Hello.  The Magic 8 Ball knows all.  Type your question.%n%n\");\n        try ( Scanner in = new Scanner(System.in); ) {\n            System.out.printf(\"?  \");\n            while ( (in.nextLine()).length() > 0 ) {\n                System.out.printf(\"8 Ball Response:  %s%n\", ANSWERS[random.nextInt(ANSWERS.length)]);\n                System.out.printf(\"?  \");\n            }\n        }\n        System.out.printf(\"%n8 Ball Done.  Bye.\");\n    }\n}\n"}
{"id": 349457, "name": "Validate International Securities Identification Number", "source": "Translate Perl to Java: use strict;\nuse English;\nuse POSIX;\nuse Test::Simple tests => 7;\n\nok(   validate_isin('US0378331005'),  'Test 1');\t\nok( ! validate_isin('US0373831005'),  'Test 2');\nok( ! validate_isin('U50378331005'),  'Test 3');\nok( ! validate_isin('US03378331005'), 'Test 4');\nok(   validate_isin('AU0000XVGZA3'),  'Test 5');\t\nok(   validate_isin('AU0000VXGZA3'),  'Test 6');\nok(   validate_isin('FR0000988040'),  'Test 7');\t\nexit 0;\n\nsub validate_isin {\n    my $isin = shift;\n    $isin =~ /\\A[A-Z]{2}[A-Z\\d]{9}\\d\\z/s or return 0;\n    my $base10 = join(q{}, map {scalar(POSIX::strtol($ARG, 36))}\n                               split(//s, $isin));\n    return luhn_test($base10);\n}\n", "target": "public class ISIN {\n \n    public static void main(String[] args) {\n        String[] isins = {\n            \"US0378331005\", \n            \"US0373831005\", \n            \"U50378331005\", \n            \"US03378331005\",\n            \"AU0000XVGZA3\", \n            \"AU0000VXGZA3\", \n            \"FR0000988040\"\n        };\n        for (String isin : isins)\n            System.out.printf(\"%s is %s\\n\", isin, ISINtest(isin) ? \"valid\" : \"not valid\");\n    }\n \n    static boolean ISINtest(String isin) {\n        isin = isin.trim().toUpperCase();\n \n        if (!isin.matches(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\"))\n            return false;\n \n        StringBuilder sb = new StringBuilder();\n        for (char c : isin.substring(0, 12).toCharArray())\n            sb.append(Character.digit(c, 36));\n \n        return luhnTest(sb.toString());\n    }\n\n    static boolean luhnTest(String number) {\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for (int i = 0; i < reverse.length(); i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            \n            if (i % 2 == 0){\n                s1 += digit;\n            } else { \n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 349458, "name": "Orbital elements", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::Vector::Real;\n\nsub orbital_state_vectors {\n    my (\n        $semimajor_axis,\n        $eccentricity,\n        $inclination,\n        $longitude_of_ascending_node,\n        $argument_of_periapsis,\n        $true_anomaly\n    ) = @_[0..5];\n\n    my ($i, $j, $k) = (V(1,0,0), V(0,1,0), V(0,0,1));\n    \n    sub rotate {\n        my $alpha = shift;\n        @_[0,1] = (\n            +cos($alpha)*$_[0] + sin($alpha)*$_[1],\n            -sin($alpha)*$_[0] + cos($alpha)*$_[1]\n        );\n    }\n\n    rotate $longitude_of_ascending_node, $i, $j;\n    rotate $inclination,                 $j, $k;\n    rotate $argument_of_periapsis,       $i, $j;\n\n    my $l = $eccentricity == 1 ? \n        2*$semimajor_axis :\n        $semimajor_axis*(1 - $eccentricity**2);\n\n    my ($c, $s) = (cos($true_anomaly), sin($true_anomaly));\n\n    my $r = $l/(1 + $eccentricity*$c);\n    my $rprime = $s*$r**2/$l;\n\n    my $position = $r*($c*$i + $s*$j);\n\n    my $speed = \n    ($rprime*$c - $r*$s)*$i + ($rprime*$s + $r*$c)*$j;\n    $speed /= abs($speed);\n    $speed *= sqrt(2/$r - 1/$semimajor_axis);\n\n    {\n        position => $position,\n        speed    => $speed\n    }\n}\n\nuse Data::Dumper;\n\nprint Dumper orbital_state_vectors\n    1,                             \n    0.1,                           \n    0,                             \n    355/113/6,                     \n    0,                             \n    0                              \n    ;\n", "target": "public class OrbitalElements {\n    private static class Vector {\n        private double x, y, z;\n \n        public Vector(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n \n        public Vector plus(Vector rhs) {\n            return new Vector(x + rhs.x, y + rhs.y, z + rhs.z);\n        }\n \n        public Vector times(double s) {\n            return new Vector(s * x, s * y, s * z);\n        }\n \n        public Vector div(double d) {\n            return new Vector(x / d, y / d, z / d);\n        }\n \n        public double abs() {\n            return Math.sqrt(x * x + y * y + z * z);\n        }\n \n        @Override\n        public String toString() {\n            return String.format(\"(%.16f,\u00a0%.16f,\u00a0%.16f)\", x, y, z);\n        }\n    }\n \n    private static Vector mulAdd(Vector v1, Double x1, Vector v2, Double x2) {\n        return v1.times(x1).plus(v2.times(x2));\n    }\n \n    private static Vector[] rotate(Vector i, Vector j, double alpha) {\n        return new Vector[]{\n            mulAdd(i, Math.cos(alpha), j, Math.sin(alpha)),\n            mulAdd(i, -Math.sin(alpha), j, Math.cos(alpha))\n        };\n    }\n \n    private static Vector[] orbitalStateVectors(\n        double semimajorAxis, double eccentricity, \n        double inclination, double longitudeOfAscendingNode, \n        double argumentOfPeriapsis, double trueAnomaly\n    ) {\n        Vector i = new Vector(1, 0, 0);\n        Vector j = new Vector(0, 1, 0);\n        Vector k = new Vector(0, 0, 1);\n \n        Vector[] p = rotate(i, j, longitudeOfAscendingNode);\n        i = p[0];\n        j = p[1];\n        p = rotate(j, k, inclination);\n        j = p[0];\n        p = rotate(i, j, argumentOfPeriapsis);\n        i = p[0];\n        j = p[1];\n \n        double l = (eccentricity == 1.0) ? 2.0 : 1.0 - eccentricity * eccentricity;\n        l *= semimajorAxis;\n        double c = Math.cos(trueAnomaly);\n        double s = Math.sin(trueAnomaly);\n        double r = l / (1.0 + eccentricity * c);\n        double rprime = s * r * r / l;\n        Vector position = mulAdd(i, c, j, s).times(r);\n        Vector speed = mulAdd(i, rprime * c - r * s, j, rprime * s + r * c);\n        speed = speed.div(speed.abs());\n        speed = speed.times(Math.sqrt(2.0 / r - 1.0 / semimajorAxis));\n \n        return new Vector[]{position, speed};\n    }\n \n    public static void main(String[] args) {\n        Vector[] ps = orbitalStateVectors(1.0, 0.1, 0.0, 355.0 / (113.0 * 6.0), 0.0, 0.0);\n        System.out.printf(\"Position\u00a0: %s\\n\", ps[0]);\n        System.out.printf(\"Speed\u00a0: %s\\n\", ps[1]);\n    }\n}\n"}
{"id": 349459, "name": "Cycle detection", "source": "Translate Perl to Java: use utf8;\n\nsub cyclical_function { ($_[0] * $_[0] + 1) % 255 }\n\nsub brent {\n    my($f, $x0) = @_;\n    my $power = 1;\n    my $\u03bb = 1;\n    my $tortoise = $x0;\n    my $hare = &$f($x0);\n    while ($tortoise != $hare) {\n        if ($power == $\u03bb) {\n            $tortoise = $hare;\n            $power *= 2;\n            $\u03bb = 0;\n        }\n        $hare = &$f($hare);\n        $\u03bb += 1;\n    }\n\n    my $\u03bc = 0;\n    $tortoise = $hare = $x0;\n    $hare = &$f($hare) for 0..$\u03bb-1;\n\n    while ($tortoise != $hare) {\n        $tortoise = &$f($tortoise);\n        $hare = &$f($hare);\n        $\u03bc += 1;\n    }\n    return $\u03bb, $\u03bc;\n}\n\nmy ( $l, $s ) = brent( \\&cyclical_function, 3 );\n\nsub show_range {\n    my($start,$stop) = @_;\n    my $result;\n    my $x = 3;\n    for my $n (0..$stop) {\n        $result .= \"$x \" if $n >= $start;\n        $x = cyclical_function($x);\n    }\n    $result;\n}\n\nprint show_range(0,19) . \"\\n\";\nprint \"Cycle length $l\\n\";\nprint \"Cycle start index $s\\n\";\nprint show_range($s,$s+$l-1) . \"\\n\";\n", "target": "import java.util.function.*;\nimport static java.util.stream.IntStream.*;\n\npublic class CycleDetection {\n\n    public static void main(String[] args) {\n        brent(i -> (i * i + 1) % 255, 3);\n    }\n\n    static void brent(IntUnaryOperator f, int x0) {\n        int cycleLength;\n        int hare = x0;\n        FOUND:\n        for (int power = 1; ; power *= 2) {\n            int tortoise = hare;\n            for (int i = 1; i <= power; i++) {\n                hare = f.applyAsInt(hare);\n                 if (tortoise == hare) {\n                    cycleLength = i;\n                    break FOUND;\n                }\n            }\n        }\n\n        hare = x0;\n        for (int i = 0; i < cycleLength; i++)\n            hare = f.applyAsInt(hare);\n\n        int cycleStart = 0;\n        for (int tortoise = x0; tortoise != hare; cycleStart++) {\n            tortoise = f.applyAsInt(tortoise);\n            hare = f.applyAsInt(hare);\n        }\n\n        printResult(x0, f, cycleLength, cycleStart);\n    }\n\n    static void printResult(int x0, IntUnaryOperator f, int len, int start) {\n        System.out.printf(\"Cycle length: %d%nCycle: \", len);\n        iterate(x0, f).skip(start).limit(len)\n                .forEach(n -> System.out.printf(\"%s \", n));\n    }\n}\n"}
{"id": 349460, "name": "Input_Output for pairs of numbers", "source": "Translate Perl to Java: $n = scalar <>;\n\nfor (1..$n) {\n    ($a,$b) = split ' ', <>;\n    print $a + $b . \"\\n\";\n}\n", "target": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int doStuff(int a, int b){\n\t    int sum = a+b;\n\t    return sum;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint n = in.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b= in.nextInt();\n\t\t\tint result = doStuff(a, b);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}\n"}
{"id": 349461, "name": "Kahan summation", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub kahan {\n    my(@nums) = @_;\n    my $summ = my $c = 0e0;\n    for my $num (@nums) {\n        my $y = $num - $c;\n        my $t = $summ + $y;\n        $c = ($t - $summ) - $y;\n        $summ = $t;\n    }\n    $summ\n}\n\nmy $eps = 1;\ndo { $eps /= 2 } until 1e0 == 1e0 + $eps;\n\nsay 'Epsilon:    ' . $eps;\nsay 'Simple sum: ' . sprintf \"%.16f\", ((1e0 + $eps) - $eps);\nsay 'Kahan sum:  ' . sprintf \"%.16f\", kahan(1e0, $eps, -$eps);\n", "target": "public class KahanSummation {\n    private static float kahanSum(float... fa) {\n        float sum = 0.0f;\n        float c = 0.0f;\n        for (float f : fa) {\n            float y = f - c;\n            float t = sum + y;\n            c = (t - sum) - y;\n            sum = t;\n        }\n        return sum;\n    }\n\n    private static float epsilon() {\n        float eps = 1.0f;\n        while (1.0f + eps != 1.0f) eps /= 2.0f;\n        return eps;\n    }\n\n    public static void main(String[] args) {\n        float a = 1.0f;\n        float b = epsilon();\n        float c = -b;\n        System.out.println(\"Epsilon      = \" + b);\n        System.out.println(\"(a + b) + c  = \" + ((a + b) + c));\n        System.out.println(\"Kahan sum    = \" + kahanSum(a, b, c));\n    }\n}\n"}
{"id": 349462, "name": "ABC words", "source": "Translate Perl to Java: \n\n@ARGV = 'unixdict.txt';\nprint grep /^[^bc]*a[^c]*b.*c/, <>;\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class AbcWords {\n    public static void main(String[] args) {\n        String fileName = \"unixdict.txt\";\n        String chars = \"abc\";\n        for (int i = 0; i + 1 < args.length\n                && args[i].length() > 1\n                && args[i].charAt(0) == '-'; ++i) {\n            switch (args[i].charAt(1)) {\n            case 'f':\n                fileName = args[++i];\n                break;\n            case 'c':\n                chars = args[++i];\n                break;\n            }\n        }\n        \n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String line;\n            int n = 0;\n            while ((line = reader.readLine()) != null) {\n                if (match(line, chars)) {\n                    ++n;\n                    System.out.printf(\"%3d:\u00a0%-20s\", n, line);\n                    if (n % 3 == 0)\n                        System.out.println();\n                }\n            }\n            if (n > 0 && n % 3 != 0)\n                System.out.println();\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    \n    \n    private static boolean match(String word, String chars) {\n        int length = chars.length();\n        boolean[] seen = new boolean[length];\n        int wordLength = word.length();\n        for (int w = 0; w < wordLength; ++w) {\n            char ch = word.charAt(w);\n            int index = -1;\n            for (int c = 0; c < length; ++c) {\n                if (ch == chars.charAt(c) && !seen[c]) {\n                    index = c;\n                    break;\n                }\n            }\n            if (index == -1)\n                continue;\n            if (index + 1 == length)\n                return index == 0 ? true : seen[index - 1];\n            if (index > 0 && !seen[index - 1])\n                return false;\n            seen[index] = true;\n        }\n        return false;\n    }\n}\n"}
{"id": 349463, "name": "Text between", "source": "Translate Perl to Java: use feature 'say';\n\nsub text_between {\n    my($text, $start, $end) = @_;\n    return join ',', $text =~ /$start(.*?)$end/g;\n}\n\n$text = 'Hello Rosetta Code world';\n\n\nsay '1> '. text_between($text,  'Hello ', ' world' );\n\n\nsay '2> '. text_between($text,  qr/^/, ' world' );\n\n\nsay '3> '. text_between($text,  'Hello ',  qr/$/ );\n\n\nsay '4> '. text_between('</div><div style=\"chinese\">\u4f60\u597d\u55ce</div>', '<div style=\"chinese\">', '</div>' );\n\n\nsay '5> '. text_between('<text>Hello <span>Rosetta Code</span> world</text><table style=\"myTable\">', '<text>', qr/<table>|$/ );\n\n\nsay '6> '. text_between('<table style=\"myTable\"><tr><td>hello world</td></tr></table>', '<table>', '</table>' );\n\n\nsay '7> '. text_between( 'The quick brown fox jumps over the lazy other fox', 'quick ', ' fox' );\n\n\nsay '8> '. text_between( 'One fish two fish red fish blue fish', 'fish ', ' red' );\n\n\nsay '9> '. text_between('FooBarBazFooBuxQuux', 'Foo', 'Foo' );\n\n\nsay '10> '. text_between( $text, 'e', 'o' );\n\n\n$text = 'Soothe a guilty conscience today, string wrangling is not the best tool to use for this job.';\nsay '11> '.  text_between($text, qr/\\bthe /, qr/ to\\b/);\n", "target": "public class textBetween\n{\n    \n    static String textBetween(String thisText, String startString, String endString)\n    {\n    \tString returnText = \"\";\n    \tint startIndex = 0;\n    \tint endIndex = 0;\n    \t\n    \tif (startString.equals(\"start\"))\n    \t{\n    \t\tstartIndex = 0;\n    \t} else {\n\t    \tstartIndex = thisText.indexOf(startString);\n\t    \t\n\t    \tif (startIndex < 0) \n\t        {\n\t        \treturn \"\";\t        \t\n\t        } else {\n\t        \tstartIndex = startIndex + startString.length();\n\t        }\n    \t}\n        \n    \tif (endString.equals(\"end\"))\n    \t{\n    \t\tendIndex = thisText.length();\n    \t} else {\n    \t\tendIndex = thisText.indexOf(endString);\n            \n            if (endIndex <= 0) \n            {\n            \treturn \"\";\n            } else {\n\n            }\t\n    \t}\n    \t\n    \treturnText = thisText.substring(startIndex,endIndex);\n    \t\n    \treturn returnText;\n    } \n\n    \n    public static void main(String[] args)\n    {\n    \tString thisText = args[0];\n    \tString startDelimiter = args[1];\n    \tString endDelimiter = args[2];\n    \t\n    \tString returnText = \"\";\n    \treturnText = textBetween(thisText, startDelimiter, endDelimiter);\n    \t\n        System.out.println(returnText);\n\n    } \n    \n} \n"}
{"id": 349464, "name": "Two identical strings", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nwhile( 1 )\n  {\n  my $binary = ( sprintf \"%b\", ++$- ) x 2;\n  (my $decimal = oct \"b$binary\") >= 1000 and last;\n  printf \"%4d  %s\\n\", $decimal, $binary;\n  }\n", "target": "public class TwoIdenticalStrings {\n    public static void main(String[] args) {\n        System.out.println(\"Decimal Binary\");\n        for (int i = 0; i < 1_000; i++) {\n            String binStr = Integer.toBinaryString(i);\n            if (binStr.length() % 2 == 0) {\n                int len = binStr.length() / 2;\n                if (binStr.substring(0, len).equals(binStr.substring(len))) {\n                    System.out.printf(\"%7d %s%n\", i, binStr);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 349465, "name": "Pentagram", "source": "Translate Perl to Java: use SVG;\n\nmy $tau   = 2 * 4*atan2(1, 1);\nmy $dim   = 200;\nmy $sides = 5;\n\nfor $v (0, 2, 4, 1, 3, 0) {\n    push @vx, 0.9 * $dim * cos($tau * $v / $sides);\n    push @vy, 0.9 * $dim * sin($tau * $v / $sides);\n}\n\nmy $svg= SVG->new( width => 2*$dim, height => 2*$dim);\n\nmy $points = $svg->get_path(\n    x     => \\@vx,\n    y     => \\@vy,\n    -type => 'polyline',\n);\n\n$svg->rect (\n    width  => \"100%\",\n    height => \"100%\",\n    style  => {\n        'fill' => 'bisque'\n    }\n);\n\n$svg->polyline (\n    %$points,\n    style => {\n        'fill'         => 'seashell',\n        'stroke'       => 'blue',\n        'stroke-width' => 3,\n    },\n    transform => \"translate($dim,$dim) rotate(-18)\"\n);\n\nopen  $fh, '>', 'pentagram.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class Pentagram extends JPanel {\n\n    final double degrees144 = Math.toRadians(144);\n\n    public Pentagram() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawPentagram(Graphics2D g, int len, int x, int y,\n            Color fill, Color stroke) {\n        double angle = 0;\n\n        Path2D p = new Path2D.Float();\n        p.moveTo(x, y);\n\n        for (int i = 0; i < 5; i++) {\n            int x2 = x + (int) (Math.cos(angle) * len);\n            int y2 = y + (int) (Math.sin(-angle) * len);\n            p.lineTo(x2, y2);\n            x = x2;\n            y = y2;\n            angle -= degrees144;\n        }\n        p.closePath();\n\n        g.setColor(fill);\n        g.fill(p);\n\n        g.setColor(stroke);\n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setStroke(new BasicStroke(5, BasicStroke.CAP_ROUND, 0));\n\n        drawPentagram(g, 500, 70, 250, new Color(0x6495ED), Color.darkGray);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pentagram\");\n            f.setResizable(false);\n            f.add(new Pentagram(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 349466, "name": "Pentagram", "source": "Translate Perl to Java: use SVG;\n\nmy $tau   = 2 * 4*atan2(1, 1);\nmy $dim   = 200;\nmy $sides = 5;\n\nfor $v (0, 2, 4, 1, 3, 0) {\n    push @vx, 0.9 * $dim * cos($tau * $v / $sides);\n    push @vy, 0.9 * $dim * sin($tau * $v / $sides);\n}\n\nmy $svg= SVG->new( width => 2*$dim, height => 2*$dim);\n\nmy $points = $svg->get_path(\n    x     => \\@vx,\n    y     => \\@vy,\n    -type => 'polyline',\n);\n\n$svg->rect (\n    width  => \"100%\",\n    height => \"100%\",\n    style  => {\n        'fill' => 'bisque'\n    }\n);\n\n$svg->polyline (\n    %$points,\n    style => {\n        'fill'         => 'seashell',\n        'stroke'       => 'blue',\n        'stroke-width' => 3,\n    },\n    transform => \"translate($dim,$dim) rotate(-18)\"\n);\n\nopen  $fh, '>', 'pentagram.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class Pentagram extends JPanel {\n\n    final double degrees144 = Math.toRadians(144);\n\n    public Pentagram() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawPentagram(Graphics2D g, int len, int x, int y,\n            Color fill, Color stroke) {\n        double angle = 0;\n\n        Path2D p = new Path2D.Float();\n        p.moveTo(x, y);\n\n        for (int i = 0; i < 5; i++) {\n            int x2 = x + (int) (Math.cos(angle) * len);\n            int y2 = y + (int) (Math.sin(-angle) * len);\n            p.lineTo(x2, y2);\n            x = x2;\n            y = y2;\n            angle -= degrees144;\n        }\n        p.closePath();\n\n        g.setColor(fill);\n        g.fill(p);\n\n        g.setColor(stroke);\n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        g.setStroke(new BasicStroke(5, BasicStroke.CAP_ROUND, 0));\n\n        drawPentagram(g, 500, 70, 250, new Color(0x6495ED), Color.darkGray);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pentagram\");\n            f.setResizable(false);\n            f.add(new Pentagram(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 349467, "name": "Verify distribution uniformity_Chi-squared test", "source": "Translate Perl to Java: use List::Util qw(sum reduce);\nuse constant pi => 3.14159265;\n\nsub incomplete_G_series {\n    my($s, $z) = @_;\n    my $n = 10;\n    push @numers, $z**$_ for 1..$n;\n    my @denoms = $s+1;\n    push @denoms, $denoms[-1]*($s+$_) for 2..$n;\n    my $M = 1;\n    $M += $numers[$_-1]/$denoms[$_-1] for 1..$n;\n    $z**$s / $s * exp(-$z) * $M;\n}\n\nsub G_of_half {\n    my($n) = @_;\n    if ($n % 2) { f(2*$_) / (4**$_ * f($_)) * sqrt(pi) for int ($n-1) / 2 }\n    else        { f(($n/2)-1) }\n}\n\nsub f { reduce { $a * $b } 1, 1 .. $_[0] } \n\nsub chi_squared_cdf {\n    my($k, $x) = @_;\n    my $f = $k < 20 ? 20 : 10;\n    if ($x == 0)                  { 0.0 }\n    elsif ($x < $k + $f*sqrt($k)) { incomplete_G_series($k/2, $x/2) / G_of_half($k) }\n    else                          { 1.0 }\n}\nsub chi_squared_test {\n    my(@bins) = @_;\n    $significance = 0.05;\n    my $n = @bins;\n    my $N = sum @bins;\n    my $expected = $N / $n;\n    my $chi_squared = sum map { ($_ - $expected)**2 / $expected } @bins;\n    my $p_value = 1 - chi_squared_cdf($n-1, $chi_squared);\n    return $chi_squared, $p_value, $p_value > $significance ? 'True' : 'False';\n}\n\nfor $dataset ([199809, 200665, 199607, 200270, 199649], [522573, 244456, 139979, 71531, 21461]) {\n    printf \"C2 = %10.3f, p-value =\u00a0%.3f, uniform = %s\\n\", chi_squared_test(@$dataset);\n}\n", "target": "import static java.lang.Math.pow;\nimport java.util.Arrays;\nimport static java.util.Arrays.stream;\nimport org.apache.commons.math3.special.Gamma;\n\npublic class Test {\n\n    static double x2Dist(double[] data) {\n        double avg = stream(data).sum() / data.length;\n        double sqs = stream(data).reduce(0, (a, b) -> a + pow((b - avg), 2));\n        return sqs / avg;\n    }\n\n    static double x2Prob(double dof, double distance) {\n        return Gamma.regularizedGammaQ(dof / 2, distance / 2);\n    }\n\n    static boolean x2IsUniform(double[] data, double significance) {\n        return x2Prob(data.length - 1.0, x2Dist(data)) > significance;\n    }\n\n    public static void main(String[] a) {\n        double[][] dataSets = {{199809, 200665, 199607, 200270, 199649},\n        {522573, 244456, 139979, 71531, 21461}};\n\n        System.out.printf(\" %4s %12s  %12s %8s   %s%n\",\n                \"dof\", \"distance\", \"probability\", \"Uniform?\", \"dataset\");\n\n        for (double[] ds : dataSets) {\n            int dof = ds.length - 1;\n            double dist = x2Dist(ds);\n            double prob = x2Prob(dof, dist);\n            System.out.printf(\"%4d %12.3f  %12.8f    %5s    %6s%n\",\n                    dof, dist, prob, x2IsUniform(ds, 0.05) ? \"YES\" : \"NO\",\n                    Arrays.toString(ds));\n        }\n    }\n}\n"}
{"id": 349468, "name": "CSV to HTML translation", "source": "Translate Perl to Java: use HTML::Entities;\n\nsub row {\n    my $elem = shift;\n    my @cells = map {\"<$elem>$_</$elem>\"} split ',', shift;\n    print '<tr>', @cells, \"</tr>\\n\";\n}\n\nmy ($first, @rest) = map\n    {my $x = $_; chomp $x; encode_entities $x}\n    <STDIN>;\nprint \"<table>\\n\";\nrow @ARGV ? 'th' : 'td', $first;\nrow 'td', $_ foreach @rest;\nprint \"</table>\\n\";\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 349469, "name": "CSV to HTML translation", "source": "Translate Perl to Java: use HTML::Entities;\n\nsub row {\n    my $elem = shift;\n    my @cells = map {\"<$elem>$_</$elem>\"} split ',', shift;\n    print '<tr>', @cells, \"</tr>\\n\";\n}\n\nmy ($first, @rest) = map\n    {my $x = $_; chomp $x; encode_entities $x}\n    <STDIN>;\nprint \"<table>\\n\";\nrow @ARGV ? 'th' : 'td', $first;\nrow 'td', $_ foreach @rest;\nprint \"</table>\\n\";\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 349470, "name": "Alternade words", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nmy $words = do { local (@ARGV, $/) = 'unixdict.txt'; <> };\nmy %words = map { $_, 1 } $words =~ /^.{3,}$/gm;\nfor ( $words =~ /^.{6,}$/gm )\n  {\n  my $even = s/(.).?/$1/gr;\n  my $odd = s/.(.?)/$1/gr;\n  $words{$even} && $words{$odd} and print \"$_ => [ $even $odd ]\\n\";\n  }\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class AlternadeWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null)\n                    dictionary.add(line);\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < 6)\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; i += 2) {\n                    word1.append(word.charAt(i));\n                    if (i + 1 < length)\n                        word2.append(word.charAt(i + 1));\n                }\n                String w1 = word1.toString();\n                String w2 = word2.toString();\n                if (dictionary.contains(w1) && dictionary.contains(w2))\n                    System.out.printf(\"%-10s%-6s%s\\n\", word, w1, w2);\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 349471, "name": "Alternade words", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nmy $words = do { local (@ARGV, $/) = 'unixdict.txt'; <> };\nmy %words = map { $_, 1 } $words =~ /^.{3,}$/gm;\nfor ( $words =~ /^.{6,}$/gm )\n  {\n  my $even = s/(.).?/$1/gr;\n  my $odd = s/.(.?)/$1/gr;\n  $words{$even} && $words{$odd} and print \"$_ => [ $even $odd ]\\n\";\n  }\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class AlternadeWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(\"unixdict.txt\"))) {\n                String line;\n                while ((line = reader.readLine()) != null)\n                    dictionary.add(line);\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < 6)\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; i += 2) {\n                    word1.append(word.charAt(i));\n                    if (i + 1 < length)\n                        word2.append(word.charAt(i + 1));\n                }\n                String w1 = word1.toString();\n                String w2 = word2.toString();\n                if (dictionary.contains(w1) && dictionary.contains(w2))\n                    System.out.printf(\"%-10s%-6s%s\\n\", word, w1, w2);\n            }\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n}\n"}
{"id": 349472, "name": "Pythagorean triples", "source": "Translate Perl to Java: sub gcd {\n    my ($n, $m) = @_;\n    while($n){\n        my $t = $n;\n        $n = $m % $n;\n        $m = $t;\n    }\n    return $m;\n}\n\nsub tripel {\n    my $pmax  = shift;\n    my $prim  = 0;\n    my $count = 0;\n    my $nmax = sqrt($pmax)/2;\n    for( my $n=1; $n<=$nmax; $n++ ) {\n        for( my $m=$n+1; (my $p = 2*$m*($m+$n)) <= $pmax; $m+=2 ) {\n            next unless 1==gcd($m,$n);\n            $prim++;\n            $count += int $pmax/$p;\n        }\n    }\n    printf \"Max. perimeter: %d, Total: %d, Primitive: %d\\n\", $pmax, $count, $prim;\n}\n\ntripel 10**$_ for 1..8;\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 349473, "name": "Pythagorean triples", "source": "Translate Perl to Java: sub gcd {\n    my ($n, $m) = @_;\n    while($n){\n        my $t = $n;\n        $n = $m % $n;\n        $m = $t;\n    }\n    return $m;\n}\n\nsub tripel {\n    my $pmax  = shift;\n    my $prim  = 0;\n    my $count = 0;\n    my $nmax = sqrt($pmax)/2;\n    for( my $n=1; $n<=$nmax; $n++ ) {\n        for( my $m=$n+1; (my $p = 2*$m*($m+$n)) <= $pmax; $m+=2 ) {\n            next unless 1==gcd($m,$n);\n            $prim++;\n            $count += int $pmax/$p;\n        }\n    }\n    printf \"Max. perimeter: %d, Total: %d, Primitive: %d\\n\", $pmax, $count, $prim;\n}\n\ntripel 10**$_ for 1..8;\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 349474, "name": "Call a foreign-language function", "source": "Translate Perl to Java: use Inline C => q{\n    char *copy;\n    char * c_dup(char *orig) {\n        return copy = strdup(orig);\n    }\n    void c_free() {\n        free(copy);\n    }\n};\nprint c_dup('Hello'), \"\\n\";\nc_free();\n", "target": "public class JNIDemo\n{\n  static\n  {  System.loadLibrary(\"JNIDemo\");  }\n  \n  public static void main(String[] args)\n  {\n    System.out.println(callStrdup(\"Hello World!\"));\n  }\n  \n  private static native String callStrdup(String s);\n}\n"}
{"id": 349475, "name": "Yellowstone sequence", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::Util qw(first);\nuse GD::Graph::bars;\n\nuse constant Inf  => 1e5;\n\nsub gcd {\n  my ($u, $v) = @_;\n  while ($v) {\n    ($u, $v) = ($v, $u % $v);\n  }\n  return abs($u);\n}\n\nsub yellowstone {\n    my($terms) = @_;\n    my @s = (1, 2, 3);\n    my @used = (1) x 4;\n    my $min  = 3;\n    while (1) {\n        my $index = first { not defined $used[$_] and gcd($_,$s[-2]) != 1 and gcd($_,$s[-1]) == 1 } $min .. Inf;\n        $used[$index] = 1;\n        $min = (first { not defined $used[$_] } 0..@used-1) || @used-1;\n        push @s, $index;\n        last if @s == $terms;\n    }\n    @s;\n}\n\nsay \"The first 30 terms in the Yellowstone sequence:\\n\" . join ' ', yellowstone(30);\n\nmy @data = ( [1..500], [yellowstone(500)]);\nmy $graph = GD::Graph::bars->new(800, 600);\n$graph->set(\n    title          => 'Yellowstone sequence',\n    y_max_value    => 1400,\n    x_tick_number  => 5,\n    r_margin       => 10,\n    dclrs          => [ 'blue' ],\n) or die $graph->error;\nmy $gd = $graph->plot(\\@data) or die $graph->error;\n\nopen my $fh, '>', 'yellowstone-sequence.png';\nbinmode $fh;\nprint $fh $gd->png();\nclose $fh;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class YellowstoneSequence {\n\n    public static void main(String[] args) {\n         System.out.printf(\"First 30 values in the yellowstone sequence:%n%s%n\", yellowstoneSequence(30));\n    }\n\n    private static List<Integer> yellowstoneSequence(int sequenceCount) {\n        List<Integer> yellowstoneList = new ArrayList<Integer>();\n        yellowstoneList.add(1);\n        yellowstoneList.add(2);\n        yellowstoneList.add(3);\n        int num = 4;\n        List<Integer> notYellowstoneList = new ArrayList<Integer>();\n        int yellowSize = 3;\n        while ( yellowSize < sequenceCount ) {\n            int found = -1;\n            for ( int index = 0 ; index < notYellowstoneList.size() ; index++ ) {\n                int test = notYellowstoneList.get(index);\n                if ( gcd(yellowstoneList.get(yellowSize-2), test) > 1 && gcd(yellowstoneList.get(yellowSize-1), test) == 1 ) {\n                    found = index;\n                    break;\n                }\n            }\n            if ( found >= 0 ) {\n                yellowstoneList.add(notYellowstoneList.remove(found));\n                yellowSize++;\n            }\n            else {\n                while ( true ) {\n                    if ( gcd(yellowstoneList.get(yellowSize-2), num) > 1 && gcd(yellowstoneList.get(yellowSize-1), num) == 1 ) {\n                        yellowstoneList.add(num);\n                        yellowSize++;\n                        num++;\n                        break;\n                    }\n                    notYellowstoneList.add(num);\n                    num++;\n                }\n            }\n        }\n        return yellowstoneList;\n    }\n        \n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n}\n"}
{"id": 349476, "name": "Yellowstone sequence", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nuse List::Util qw(first);\nuse GD::Graph::bars;\n\nuse constant Inf  => 1e5;\n\nsub gcd {\n  my ($u, $v) = @_;\n  while ($v) {\n    ($u, $v) = ($v, $u % $v);\n  }\n  return abs($u);\n}\n\nsub yellowstone {\n    my($terms) = @_;\n    my @s = (1, 2, 3);\n    my @used = (1) x 4;\n    my $min  = 3;\n    while (1) {\n        my $index = first { not defined $used[$_] and gcd($_,$s[-2]) != 1 and gcd($_,$s[-1]) == 1 } $min .. Inf;\n        $used[$index] = 1;\n        $min = (first { not defined $used[$_] } 0..@used-1) || @used-1;\n        push @s, $index;\n        last if @s == $terms;\n    }\n    @s;\n}\n\nsay \"The first 30 terms in the Yellowstone sequence:\\n\" . join ' ', yellowstone(30);\n\nmy @data = ( [1..500], [yellowstone(500)]);\nmy $graph = GD::Graph::bars->new(800, 600);\n$graph->set(\n    title          => 'Yellowstone sequence',\n    y_max_value    => 1400,\n    x_tick_number  => 5,\n    r_margin       => 10,\n    dclrs          => [ 'blue' ],\n) or die $graph->error;\nmy $gd = $graph->plot(\\@data) or die $graph->error;\n\nopen my $fh, '>', 'yellowstone-sequence.png';\nbinmode $fh;\nprint $fh $gd->png();\nclose $fh;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class YellowstoneSequence {\n\n    public static void main(String[] args) {\n         System.out.printf(\"First 30 values in the yellowstone sequence:%n%s%n\", yellowstoneSequence(30));\n    }\n\n    private static List<Integer> yellowstoneSequence(int sequenceCount) {\n        List<Integer> yellowstoneList = new ArrayList<Integer>();\n        yellowstoneList.add(1);\n        yellowstoneList.add(2);\n        yellowstoneList.add(3);\n        int num = 4;\n        List<Integer> notYellowstoneList = new ArrayList<Integer>();\n        int yellowSize = 3;\n        while ( yellowSize < sequenceCount ) {\n            int found = -1;\n            for ( int index = 0 ; index < notYellowstoneList.size() ; index++ ) {\n                int test = notYellowstoneList.get(index);\n                if ( gcd(yellowstoneList.get(yellowSize-2), test) > 1 && gcd(yellowstoneList.get(yellowSize-1), test) == 1 ) {\n                    found = index;\n                    break;\n                }\n            }\n            if ( found >= 0 ) {\n                yellowstoneList.add(notYellowstoneList.remove(found));\n                yellowSize++;\n            }\n            else {\n                while ( true ) {\n                    if ( gcd(yellowstoneList.get(yellowSize-2), num) > 1 && gcd(yellowstoneList.get(yellowSize-1), num) == 1 ) {\n                        yellowstoneList.add(num);\n                        yellowSize++;\n                        num++;\n                        break;\n                    }\n                    notYellowstoneList.add(num);\n                    num++;\n                }\n            }\n        }\n        return yellowstoneList;\n    }\n        \n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n}\n"}
{"id": 349477, "name": "Sorting algorithms_Patience sort", "source": "Translate Perl to Java: sub patience_sort {\n    my @s = [shift];\n    for my $card (@_) {\n\tmy @t = grep { $_->[-1] > $card } @s;\n\tif (@t) { push @{shift(@t)}, $card }\n\telse { push @s, [$card] }\n    }\n    my @u;\n    while (my @v = grep @$_, @s) {\n\tmy $value = (my $min = shift @v)->[-1];\n\tfor (@v) {\n\t    ($min, $value) =\n\t    ($_, $_->[-1]) if $_->[-1] < $value\n\t}\n\tpush @u, pop @$min;\n    }\n    return @u\n}\n\nprint join ' ', patience_sort qw(4 3 6 2 -1 13 12 9);\n", "target": "import java.util.*;\n\npublic class PatienceSort {\n    public static <E extends Comparable<? super E>> void sort (E[] n) {\n        List<Pile<E>> piles = new ArrayList<Pile<E>>();\n        \n        for (E x : n) {\n            Pile<E> newPile = new Pile<E>();\n            newPile.push(x);\n            int i = Collections.binarySearch(piles, newPile);\n            if (i < 0) i = ~i;\n            if (i != piles.size())\n                piles.get(i).push(x);\n            else\n                piles.add(newPile);\n        }\n \n        \n        PriorityQueue<Pile<E>> heap = new PriorityQueue<Pile<E>>(piles);\n        for (int c = 0; c < n.length; c++) {\n            Pile<E> smallPile = heap.poll();\n            n[c] = smallPile.pop();\n            if (!smallPile.isEmpty())\n                heap.offer(smallPile);\n        }\n        assert(heap.isEmpty());\n    }\n \n    private static class Pile<E extends Comparable<? super E>> extends Stack<E> implements Comparable<Pile<E>> {\n        public int compareTo(Pile<E> y) { return peek().compareTo(y.peek()); }\n    }\n\n    public static void main(String[] args) {\n\tInteger[] a = {4, 65, 2, -31, 0, 99, 83, 782, 1};\n\tsort(a);\n\tSystem.out.println(Arrays.toString(a));\n    }\n}\n"}
{"id": 349478, "name": "Extensible prime generator", "source": "Translate Perl to Java: use Math::Prime::Util qw(nth_prime prime_count primes);\n\n\n\n\nsay \"First 20: \", join(\" \", @{primes(nth_prime(20))});\nsay \"Between 100 and 150: \", join(\" \", @{primes(100,150)});\nsay prime_count(7700,8000), \" primes between 7700 and 8000\";\nsay \"${_}th prime: \", nth_prime($_) for map { 10**$_ } 1..8;\n", "target": "import java.util.*;\n\npublic class PrimeGenerator {\n    private int limit_;\n    private int index_ = 0;\n    private int increment_;\n    private int count_ = 0;\n    private List<Integer> primes_ = new ArrayList<>();\n    private BitSet sieve_ = new BitSet();\n    private int sieveLimit_ = 0;\n\n    public PrimeGenerator(int initialLimit, int increment) {\n        limit_ = nextOddNumber(initialLimit);\n        increment_ = increment;\n        primes_.add(2);\n        findPrimes(3);\n    }\n\n    public int nextPrime() {\n        if (index_ == primes_.size()) {\n            if (Integer.MAX_VALUE - increment_ < limit_)\n                return 0;\n            int start = limit_ + 2;\n            limit_ = nextOddNumber(limit_ + increment_);\n            primes_.clear();\n            findPrimes(start);\n        }\n        ++count_;\n        return primes_.get(index_++);\n    }\n\n    public int count() {\n        return count_;\n    }\n\n    private void findPrimes(int start) {\n        index_ = 0;\n        int newLimit = sqrt(limit_);\n        for (int p = 3; p * p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((sieveLimit_ + p - 1)/p));\n            for (; q <= newLimit; q += 2*p)\n                sieve_.set(q/2 - 1, true);\n        }\n        sieveLimit_ = newLimit;\n        int count = (limit_ - start)/2 + 1;\n        BitSet composite = new BitSet(count);\n        for (int p = 3; p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((start + p - 1)/p)) - start;\n            q /= 2;\n            for (; q >= 0 && q < count; q += p)\n                composite.set(q, true);\n        }\n        for (int p = 0; p < count; ++p) {\n            if (!composite.get(p))\n                primes_.add(p * 2 + start);\n        }\n    }\n\n    private static int sqrt(int n) {\n        return nextOddNumber((int)Math.sqrt(n));\n    }\n\n    private static int nextOddNumber(int n) {\n        return 1 + 2 * (n/2);\n    }\n\n    public static void main(String[] args) {\n        PrimeGenerator pgen = new PrimeGenerator(20, 200000);\n        System.out.println(\"First 20 primes:\");\n        for (int i = 0; i < 20; ++i) {\n            if (i > 0)\n                System.out.print(\", \");\n            System.out.print(pgen.nextPrime());\n        }\n        System.out.println();\n        System.out.println(\"Primes between 100 and 150:\");\n        for (int i = 0; ; ) {\n            int prime = pgen.nextPrime();\n            if (prime > 150)\n                break;\n            if (prime >= 100) {\n                if (i++ != 0)\n                    System.out.print(\", \");\n                System.out.print(prime);\n            }\n        }\n        System.out.println();\n        int count = 0;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime > 8000)\n                break;\n            if (prime >= 7700)\n                ++count;\n        }\n        System.out.println(\"Number of primes between 7700 and 8000: \" + count);\n        int n = 10000;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime == 0) {\n                System.out.println(\"Can't generate any more primes.\");\n                break;\n            }\n            if (pgen.count() == n) {\n                System.out.println(n + \"th prime: \" + prime);\n                n *= 10;\n            }\n        }\n    }\n}\n"}
{"id": 349479, "name": "Flipping bits game", "source": "Translate Perl to Java: use strict;\nuse warnings qw(FATAL all);\nuse feature 'bitwise';\n\nmy $n = shift(@ARGV) || 4;\nif( $n < 2 or $n > 26 ) {\n\tdie \"You can't play a size $n game\\n\";\n}\n\nmy $n2 = $n*$n;\n\nmy (@rows, @cols);\nfor my $i ( 0 .. $n-1 ) {\n\tmy $row = my $col = \"\\x00\" x $n2;\n\tvec($row, $i * $n + $_, 8) ^= 1 for 0 .. $n-1;\n\tvec($col, $i + $_ * $n, 8) ^= 1 for 0 .. $n-1;\n\tpush @rows, $row;\n\tpush @cols, $col;\n}\n\nmy $goal = \"0\" x $n2;\nint(rand(2)) or (vec($goal, $_, 8) ^= 1) for 0 .. $n2-1;\nmy $start = $goal;\n{\n\tfor(@rows, @cols) {\n\t\t$start ^.= $_ if int rand 2;\n\t}\n\tredo if $start eq $goal; \n}\n\nmy @letters = ('a'..'z')[0..$n-1];\nsub to_strings {\n\tmy $board = shift;\n\tmy @result = join(\" \", \"  \", @letters);\n\tfor( 0 .. $n-1 ) {\n\t\tmy $res = sprintf(\"%2d \",$_+1);\n\t\t$res .= join \" \", split //, substr $board, $_*$n, $n;\n\t\tpush @result, $res;\n\t}\n\t\\@result;\n}\n\nmy $fmt;\nmy ($stext, $etext) = (\"Starting board\", \"Ending board\");\nmy $re = join \"|\", reverse 1 .. $n, @letters;\nmy $moves_so_far = 0;\nwhile( 1 ) {\n\tmy ($from, $to) = (to_strings($start), to_strings($goal));\n\tunless( $fmt ) {\n\t\tmy $len = length $from->[0];\n\t\t$len = length($stext) if $len < length $stext;\n\t\t$fmt = join($len, \"%\", \"s%\", \"s\\n\");\n\t}\n\tprintf $fmt, $stext, $etext;\n\tprintf $fmt, $from->[$_], $to->[$_] for 0 .. $n;\n\tlast if $start eq $goal;\n\tINPUT_LOOP: {\n\t\tprintf \"Move \n\t\t\t$moves_so_far+1;\n\t\tmy $input = <>;\n\t\tdie unless defined $input;\n\t\tmy $did_one;\n\t\tfor( $input =~ /($re)/gi ) {\n\t\t\t$did_one = 1;\n\t\t\tif( /\\d/ ) {\n\t\t\t\t$start ^.= $rows[$_-1];\n\t\t\t} else {\n\t\t\t\t$_ = ord(lc) - ord('a');\n\t\t\t\t$start ^.= $cols[$_];\n\t\t\t}\n\t\t\t++$moves_so_far;\n\t\t}\n\t\tredo INPUT_LOOP unless $did_one;\n\t}\n}\nprint \"You won after $moves_so_far moves.\\n\";\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 349480, "name": "Flipping bits game", "source": "Translate Perl to Java: use strict;\nuse warnings qw(FATAL all);\nuse feature 'bitwise';\n\nmy $n = shift(@ARGV) || 4;\nif( $n < 2 or $n > 26 ) {\n\tdie \"You can't play a size $n game\\n\";\n}\n\nmy $n2 = $n*$n;\n\nmy (@rows, @cols);\nfor my $i ( 0 .. $n-1 ) {\n\tmy $row = my $col = \"\\x00\" x $n2;\n\tvec($row, $i * $n + $_, 8) ^= 1 for 0 .. $n-1;\n\tvec($col, $i + $_ * $n, 8) ^= 1 for 0 .. $n-1;\n\tpush @rows, $row;\n\tpush @cols, $col;\n}\n\nmy $goal = \"0\" x $n2;\nint(rand(2)) or (vec($goal, $_, 8) ^= 1) for 0 .. $n2-1;\nmy $start = $goal;\n{\n\tfor(@rows, @cols) {\n\t\t$start ^.= $_ if int rand 2;\n\t}\n\tredo if $start eq $goal; \n}\n\nmy @letters = ('a'..'z')[0..$n-1];\nsub to_strings {\n\tmy $board = shift;\n\tmy @result = join(\" \", \"  \", @letters);\n\tfor( 0 .. $n-1 ) {\n\t\tmy $res = sprintf(\"%2d \",$_+1);\n\t\t$res .= join \" \", split //, substr $board, $_*$n, $n;\n\t\tpush @result, $res;\n\t}\n\t\\@result;\n}\n\nmy $fmt;\nmy ($stext, $etext) = (\"Starting board\", \"Ending board\");\nmy $re = join \"|\", reverse 1 .. $n, @letters;\nmy $moves_so_far = 0;\nwhile( 1 ) {\n\tmy ($from, $to) = (to_strings($start), to_strings($goal));\n\tunless( $fmt ) {\n\t\tmy $len = length $from->[0];\n\t\t$len = length($stext) if $len < length $stext;\n\t\t$fmt = join($len, \"%\", \"s%\", \"s\\n\");\n\t}\n\tprintf $fmt, $stext, $etext;\n\tprintf $fmt, $from->[$_], $to->[$_] for 0 .. $n;\n\tlast if $start eq $goal;\n\tINPUT_LOOP: {\n\t\tprintf \"Move \n\t\t\t$moves_so_far+1;\n\t\tmy $input = <>;\n\t\tdie unless defined $input;\n\t\tmy $did_one;\n\t\tfor( $input =~ /($re)/gi ) {\n\t\t\t$did_one = 1;\n\t\t\tif( /\\d/ ) {\n\t\t\t\t$start ^.= $rows[$_-1];\n\t\t\t} else {\n\t\t\t\t$_ = ord(lc) - ord('a');\n\t\t\t\t$start ^.= $cols[$_];\n\t\t\t}\n\t\t\t++$moves_so_far;\n\t\t}\n\t\tredo INPUT_LOOP unless $did_one;\n\t}\n}\nprint \"You won after $moves_so_far moves.\\n\";\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 349481, "name": "Gray code", "source": "Translate Perl to Java: sub bin2gray\n{\n    return $_[0] ^ ($_[0] >> 1);\n}\n\nsub gray2bin\n{\n    my ($num)= @_;\n    my $bin= $num;\n    while( $num >>= 1 ) {\n        \n        $bin ^= $num;   \n    }                   \n    return $bin;\n}\n\nfor (0..31) {\n    my $gr= bin2gray($_);\n    printf \"%d\\t%b\\t%b\\t%b\\n\", $_, $_, $gr, gray2bin($gr);\n}\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 349482, "name": "Gray code", "source": "Translate Perl to Java: sub bin2gray\n{\n    return $_[0] ^ ($_[0] >> 1);\n}\n\nsub gray2bin\n{\n    my ($num)= @_;\n    my $bin= $num;\n    while( $num >>= 1 ) {\n        \n        $bin ^= $num;   \n    }                   \n    return $bin;\n}\n\nfor (0..31) {\n    my $gr= bin2gray($_);\n    printf \"%d\\t%b\\t%b\\t%b\\n\", $_, $_, $gr, gray2bin($gr);\n}\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 349483, "name": "Vigen\u00e8re cipher_Cryptanalysis", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\n\nmy %English_letter_freq = (\n     E => 12.70,  L => 4.03,  Y => 1.97,  P => 1.93,  T => 9.06,  A => 8.17,  O => 7.51,  I => 6.97,  N => 6.75,\n     S =>  6.33,  H => 6.09,  R => 5.99,  D => 4.25,  C => 2.78,  U => 2.76,  M => 2.41,  W => 2.36,  F => 2.23,\n     G =>  2.02,  B => 1.29,  V => 0.98,  K => 0.77,  J => 0.15,  X => 0.15,  Q => 0.10,  Z => 0.07\n);\nmy @alphabet = sort keys %English_letter_freq;\nmy $max_key_lengths = 5; \n\nsub myguess {\n    my ($text) = (@_);\n    my ($seqtext, @spacing, @factors, @sortedfactors, $pos, %freq, %Keys);\n\n    \n    $seqtext = $text;\n    while ($seqtext =~ /(...).*\\1/) {\n        $seqtext = substr($seqtext, 1+index($seqtext, $1));\n        push @spacing,  1 + index($seqtext, $1);\n    }\n\n    for my $j (@spacing) {\n        push @factors, grep { $j % $_ == 0 } 2..$j;\n    }\n    $freq{$_}++ for @factors;\n    @sortedfactors = grep { $_ >= 4 } sort { $freq{$b} <=> $freq{$a} } keys %freq; \n\n    for my $keylen ( @sortedfactors[0..$max_key_lengths-1] ) {\n        my $keyguess = '';\n        for (my $i = 0; $i < $keylen; $i++) {\n            my($mykey, %chi_values, $bestguess);\n            for (my $j = 0; $j < length($text); $j += $keylen) {\n                $mykey .= substr($text, ($j+$i) % length($text), 1);\n            }\n\n            for my $subkey (@alphabet) {\n                my $decrypted = mycrypt($mykey, $subkey);\n                my $length    = length($decrypted);\n                for my $char (@alphabet) {\n                    my $expected = $English_letter_freq{$char} * $length / 100;\n                    my $observed;\n                    ++$observed while $decrypted =~ /$char/g;\n                    $chi_values{$subkey} += ($observed - $expected)**2 / $expected if $observed;\n                }\n            }\n\n            $Keys{$keylen}{score} = $chi_values{'A'};\n            for my $sk (sort keys %chi_values) {\n                if ($chi_values{$sk} <= $Keys{$keylen}{score}) {\n                    $bestguess = $sk;\n                    $Keys{$keylen}{score} = $chi_values{$sk};\n                }\n            }\n            $keyguess .= $bestguess;\n        }\n        $Keys{$keylen}{key} = $keyguess;\n    }\n    map { $Keys{$_}{key} } sort { $Keys{$a}{score} <=> $Keys{$b}{score}} keys %Keys;\n}\n\nsub mycrypt {\n    my ($text, $key) = @_;\n    my ($new_text, %values_numbers);\n\n    my $keylen = length($key);\n    @values_numbers{@alphabet} = 0..25;\n    my %values_letters = reverse %values_numbers;\n\n    for (my $i = 0; $i < length($text); $i++) {\n        my $val =  -1 * $values_numbers{substr( $key, $i%$keylen, 1)} \n                 +      $values_numbers{substr($text, $i,         1)};\n        $new_text .= $values_letters{ $val % 26 };\n    }\n    return $new_text;\n}\n\nmy $cipher_text = <<~'EOD';\n    MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH\n    VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD\n    ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS\n    FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG\n    ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ\n    ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS\n    JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT\n    LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST\n    MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH\n    QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV\n    RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW\n    TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO\n    SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR\n    ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX\n    BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB\n    BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA\n    FWAML ZZRXJ EKAHV FASMU LVVUT TGK\nEOD\n\nmy $text = uc($cipher_text) =~ s/[^@{[join '', @alphabet]}]//gr;\n\nfor my $key ( myguess($text) ) {\n    say \"Key        $key\\n\" .\n        \"Key length \" . length($key) . \"\\n\" .\n        \"Plaintext  \" . substr(mycrypt($text, $key), 0, 80) . \"...\\n\";\n}\n", "target": "public class Vig{\nstatic String encodedMessage =\n    \"MOMUD EKAPV TQEFM OEVHP AJMII CDCTI FGYAG JSPXY ALUYM NSMYH VUXJE LEPXJ FXGCM JHKDZ RYICU HYPUS PGIGM OIYHF WHTCQ KMLRD ITLXZ LJFVQ GHOLW CUHLO MDSOE KTALU VYLNZ RFGBX PHVGA LWQIS FGRPH JOOFW GUBYI LAPLA LCAFA AMKLG CETDW VOELJ IKGJB XPHVG ALWQC SNWBU BYHCU HKOCE XJEYK BQKVY KIIEH GRLGH XEOLW AWFOJ ILOVV RHPKD WIHKN ATUHN VRYAQ DIVHX FHRZV QWMWV LGSHN NLVZS JLAKI FHXUF XJLXM TBLQV RXXHR FZXGV LRAJI EXPRV OSMNP KEPDT LPRWM JAZPK LQUZA ALGZX GVLKL GJTUI ITDSU REZXJ ERXZS HMPST MTEOE PAPJH SMFNB YVQUZ AALGA YDNMP AQOWT UHDBV TSMUE UIMVH QGVRW AEFSP EMPVE PKXZY WLKJA GWALT VYYOB YIXOK IHPDS EVLEV RVSGB JOGYW FHKBL GLXYA MVKIS KIEHY IMAPX UOISK PVAGN MZHPW TTZPV XFCCD TUHJH WLAPF YULTB UXJLN SIJVV YOVDJ SOLXG TGRVO SFRII CTMKO JFCQF KTINQ BWVHG TENLH HOGCS PSFPV GJOKM SIFPR ZPAAS ATPTZ FTPPD PORRF TAXZP KALQA WMIUD BWNCT LEFKO ZQDLX BUXJL ASIMR PNMBF ZCYLV WAPVF QRHZV ZGZEF KBYIO OFXYE VOWGB BXVCB XBAWG LQKCM ICRRX MACUO IKHQU AJEGL OIJHH XPVZW JEWBA FWAML ZZRXJ EKAHV FASMU LVVUT TGK\";\n \nfinal static double freq[] = {\n    0.08167, 0.01492, 0.02782, 0.04253, 0.12702, 0.02228, 0.02015,\n    0.06094, 0.06966, 0.00153, 0.00772, 0.04025, 0.02406, 0.06749,\n    0.07507, 0.01929, 0.00095, 0.05987, 0.06327, 0.09056, 0.02758,\n    0.00978, 0.02360, 0.00150, 0.01974, 0.00074\n};\n \n\npublic static void main(String[] args) {\n    int lenghtOfEncodedMessage = encodedMessage.length();\n    char[] encoded = new char [lenghtOfEncodedMessage] ;\n    char[] key =  new char [lenghtOfEncodedMessage] ;\n\n    encodedMessage.getChars(0, lenghtOfEncodedMessage, encoded, 0);\n    int txt[] = new int[lenghtOfEncodedMessage];\n    int len = 0, j;\n\n    double fit, best_fit = 1e100;\n \n    for (j = 0; j < lenghtOfEncodedMessage; j++)\n        if (Character.isUpperCase(encoded[j]))\n            txt[len++] = encoded[j] - 'A';\n \n    for (j = 1; j < 30; j++) {\n        fit = freq_every_nth(txt, len, j, key);\n        System.out.printf(\"%f, key length: %2d \", fit, j);\n            System.out.print(key);\n        if (fit < best_fit) {\n            best_fit = fit;\n            System.out.print(\" <--- best so far\");\n        }\n        System.out.print(\"\\n\");\n\n    }\n}\n\n\n    static String decrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c - key.charAt(j) + 26) % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n\nstatic int best_match(final double []a, final double []b) {\n    double sum = 0, fit, d, best_fit = 1e100;\n    int i, rotate, best_rotate = 0;\n    for (i = 0; i < 26; i++)\n        sum += a[i];\n    for (rotate = 0; rotate < 26; rotate++) {\n        fit = 0;\n        for (i = 0; i < 26; i++) {\n            d = a[(i + rotate) % 26] / sum - b[i];\n            fit += d * d / b[i];\n        }\n \n        if (fit < best_fit) {\n            best_fit = fit;\n            best_rotate = rotate;\n        }\n    }\n \n    return best_rotate;\n}\n \nstatic double freq_every_nth(final int []msg, int len, int interval, char[] key) {\n    double sum, d, ret;\n    double  [] accu = new double [26];\n    double  [] out = new double [26];\n    int i, j, rot;\n \n    for (j = 0; j < interval; j++) {\n        for (i = 0; i < 26; i++)\n            out[i] = 0;\n        for (i = j; i < len; i += interval)\n            out[msg[i]]++;\n\trot = best_match(out, freq);\n\ttry{\n            key[j] = (char)(rot + 'A');\n\t} catch (Exception e) {\n\t\tSystem.out.print(e.getMessage());\n\t}\n        for (i = 0; i < 26; i++)\n            accu[i] += out[(i + rot) % 26];\n    }\n \n    for (i = 0, sum = 0; i < 26; i++)\n        sum += accu[i];\n \n    for (i = 0, ret = 0; i < 26; i++) {\n        d = accu[i] / sum - freq[i];\n        ret += d * d / freq[i];\n    }\n \n    key[interval] = '\\0';\n    return ret;\n}\n \n}\n"}
{"id": 349484, "name": "File extension is in extensions list", "source": "Translate Perl to Java: sub check_extension {\n    my ($filename, @extensions) = @_;\n    my $extensions = join '|', map quotemeta, @extensions;\n    scalar $filename =~ / \\. (?: $extensions ) $ /xi\n}\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n"}
{"id": 349485, "name": "File extension is in extensions list", "source": "Translate Perl to Java: sub check_extension {\n    my ($filename, @extensions) = @_;\n    my $extensions = join '|', map quotemeta, @extensions;\n    scalar $filename =~ / \\. (?: $extensions ) $ /xi\n}\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n"}
{"id": 349486, "name": "Extreme floating point values", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\n\nmy $nzero = -0.0;\nmy $nan = 0 + \"nan\";\nmy $pinf = +\"inf\";\nmy $ninf = -\"inf\";\n\nprintf \"\\$nzero =\u00a0%.1f\\n\", $nzero;\nprint \"\\$nan = $nan\\n\";\nprint \"\\$pinf = $pinf\\n\";\nprint \"\\$ninf = $ninf\\n\\n\";\n\nprintf \"atan2(0, 0) = %g\\n\", atan2(0, 0);\nprintf \"atan2(0, \\$nzero) = %g\\n\", atan2(0, $nzero);\nprintf \"sin(\\$pinf) = %g\\n\", sin($pinf);\nprintf \"\\$pinf / -1 = %g\\n\", $pinf / -1;\nprintf \"\\$ninf + 1e100 = %g\\n\\n\", $ninf + 1e100;\n\nprintf \"nan test: %g\\n\", (1 + 2 * 3 - 4) / (-5.6e7 * $nan);\nprintf \"nan == nan? %s\\n\", ($nan == $nan) ? \"yes\" : \"no\";\nprintf \"nan == 42? %s\\n\", ($nan == 42) ? \"yes\" : \"no\";\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 349487, "name": "Extreme floating point values", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\n\nmy $nzero = -0.0;\nmy $nan = 0 + \"nan\";\nmy $pinf = +\"inf\";\nmy $ninf = -\"inf\";\n\nprintf \"\\$nzero =\u00a0%.1f\\n\", $nzero;\nprint \"\\$nan = $nan\\n\";\nprint \"\\$pinf = $pinf\\n\";\nprint \"\\$ninf = $ninf\\n\\n\";\n\nprintf \"atan2(0, 0) = %g\\n\", atan2(0, 0);\nprintf \"atan2(0, \\$nzero) = %g\\n\", atan2(0, $nzero);\nprintf \"sin(\\$pinf) = %g\\n\", sin($pinf);\nprintf \"\\$pinf / -1 = %g\\n\", $pinf / -1;\nprintf \"\\$ninf + 1e100 = %g\\n\\n\", $ninf + 1e100;\n\nprintf \"nan test: %g\\n\", (1 + 2 * 3 - 4) / (-5.6e7 * $nan);\nprintf \"nan == nan? %s\\n\", ($nan == $nan) ? \"yes\" : \"no\";\nprintf \"nan == 42? %s\\n\", ($nan == 42) ? \"yes\" : \"no\";\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 349488, "name": "Soundex", "source": "Translate Perl to Java: use Text::Soundex;\nprint soundex(\"Soundex\"), \"\\n\"; \nprint soundex(\"Example\"), \"\\n\"; \nprint soundex(\"Sownteks\"), \"\\n\"; \nprint soundex(\"Ekzampul\"), \"\\n\"; \n", "target": "public static void main(String[] args){\n    System.out.println(soundex(\"Soundex\"));\n    System.out.println(soundex(\"Example\"));\n    System.out.println(soundex(\"Sownteks\"));\n    System.out.println(soundex(\"Ekzampul\"));\n  }\n\nprivate static String getCode(char c){\n  switch(c){\n    case 'B': case 'F': case 'P': case 'V':\n      return \"1\";\n    case 'C': case 'G': case 'J': case 'K':\n    case 'Q': case 'S': case 'X': case 'Z':\n      return \"2\";\n    case 'D': case 'T':\n      return \"3\";\n    case 'L':\n      return \"4\";\n    case 'M': case 'N':\n      return \"5\";\n    case 'R':\n      return \"6\";\n    default:\n      return \"\";\n  }\n}\n\npublic static String soundex(String s){\n  String code, previous, soundex;\n  code = s.toUpperCase().charAt(0) + \"\";\n\n  \n  previous = getCode(s.toUpperCase().charAt(0));\n\n  for(int i = 1;i < s.length();i++){\n    String current = getCode(s.toUpperCase().charAt(i));\n    if(current.length() > 0 && !current.equals(previous)){\n      code = code + current;\n    }\n    previous = current;\n  }\n  soundex = (code + \"0000\").substring(0, 4);\n  return soundex;\n}\n"}
{"id": 349489, "name": "Knuth's algorithm S", "source": "Translate Perl to Java: use strict;\n\nsub s_of_n_creator {\n    my $n = shift;\n    my @sample;\n    my $i = 0;\n    sub {\n        my $item = shift;\n        $i++;\n        if ($i <= $n) {\n            \n            push @sample, $item;\n        } elsif (rand() < $n / $i) {\n            \n            @sample[rand $n] = $item;\n        }\n        @sample\n    }\n}\n\nmy @items = (0..9);\nmy @bin;\n\nforeach my $trial (1 .. 100000) {\n    my $s_of_n = s_of_n_creator(3);\n    my @sample;\n    foreach my $item (@items) {\n        @sample = $s_of_n->($item);\n    }\n    foreach my $s (@sample) {\n        $bin[$s]++;\n    }\n}\nprint \"@bin\\n\";\n", "target": "import java.util.*;\n \nclass SOfN<T> {\n    private static final Random rand = new Random();\n \n    private List<T> sample;\n    private int i = 0;\n    private int n;\n\n    public SOfN(int _n) {\n        n = _n;\n        sample = new ArrayList<T>(n);\n    }\n\n    public List<T> process(T item) {\n        if (++i <= n) {\n            sample.add(item);\n        } else if (rand.nextInt(i) < n) {\n            sample.set(rand.nextInt(n), item);\n        }\n        return sample;\n    }\n}\n \npublic class AlgorithmS {\n    public static void main(String[] args) {\n        int[] bin = new int[10];\n        for (int trial = 0; trial < 100000; trial++) {\n            SOfN<Integer> s_of_n = new SOfN<Integer>(3);\n            for (int i = 0; i < 9; i++) s_of_n.process(i);\n            for (int s : s_of_n.process(9)) bin[s]++;\n        }\n        System.out.println(Arrays.toString(bin));\n    }\n}\n"}
{"id": 349490, "name": "Knuth's algorithm S", "source": "Translate Perl to Java: use strict;\n\nsub s_of_n_creator {\n    my $n = shift;\n    my @sample;\n    my $i = 0;\n    sub {\n        my $item = shift;\n        $i++;\n        if ($i <= $n) {\n            \n            push @sample, $item;\n        } elsif (rand() < $n / $i) {\n            \n            @sample[rand $n] = $item;\n        }\n        @sample\n    }\n}\n\nmy @items = (0..9);\nmy @bin;\n\nforeach my $trial (1 .. 100000) {\n    my $s_of_n = s_of_n_creator(3);\n    my @sample;\n    foreach my $item (@items) {\n        @sample = $s_of_n->($item);\n    }\n    foreach my $s (@sample) {\n        $bin[$s]++;\n    }\n}\nprint \"@bin\\n\";\n", "target": "import java.util.*;\n \nclass SOfN<T> {\n    private static final Random rand = new Random();\n \n    private List<T> sample;\n    private int i = 0;\n    private int n;\n\n    public SOfN(int _n) {\n        n = _n;\n        sample = new ArrayList<T>(n);\n    }\n\n    public List<T> process(T item) {\n        if (++i <= n) {\n            sample.add(item);\n        } else if (rand.nextInt(i) < n) {\n            sample.set(rand.nextInt(n), item);\n        }\n        return sample;\n    }\n}\n \npublic class AlgorithmS {\n    public static void main(String[] args) {\n        int[] bin = new int[10];\n        for (int trial = 0; trial < 100000; trial++) {\n            SOfN<Integer> s_of_n = new SOfN<Integer>(3);\n            for (int i = 0; i < 9; i++) s_of_n.process(i);\n            for (int s : s_of_n.process(9)) bin[s]++;\n        }\n        System.out.println(Arrays.toString(bin));\n    }\n}\n"}
{"id": 349491, "name": "Disarium numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy ($n,@D) = (0, 0);\nwhile (++$n) {\n    my($m,$sum);\n    map { $sum += $_ ** ++$m } split '', $n;\n    push @D, $n if $n == $sum;\n    last if 19 == @D;\n}\nprint \"@D\\n\";\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 349492, "name": "Disarium numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy ($n,@D) = (0, 0);\nwhile (++$n) {\n    my($m,$sum);\n    map { $sum += $_ ** ++$m } split '', $n;\n    push @D, $n if $n == $sum;\n    last if 19 == @D;\n}\nprint \"@D\\n\";\n", "target": "import java.lang.Math;\n\npublic class DisariumNumbers {\n    public static boolean is_disarium(int num) {\n        int n = num;\n        int len = Integer.toString(n).length();\n        int sum = 0;\n        int i = 1;\n        while (n > 0) {\n            sum += Math.pow(n % 10, len - i + 1);\n            n /= 10;\n            i ++;\n        }\n        return sum  == num;\n    }\n\n    public static void main(String[] args) {\n        int i = 0;\n        int count = 0;\n        while (count <= 18) {\n            if (is_disarium(i)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n            i++;\n        }\n        System.out.printf(\"%s\", \"\\n\");\n    }\n}\n"}
{"id": 349493, "name": "Flow-control structures", "source": "Translate Perl to Java: FORK:\n\ngoto FORK;\n", "target": "switch (xx) {\n  case 1:\n  case 2:\n    \n    ...\n    break;\n  case 4:\n    \n    ...\n    break;\n  case 5:\n    \n    ...\n    break;\n  default:\n    \n    break;\n}\n\nfor (int i = 0; i < 10; ++i) {\n  ...\n  if (some_condition) { break; }\n  ...\n}\n\n_Time_: do {\n  for (int i = 0; i < 10; ++i) {\n    ...\n    if (some_condition) { break _Time_; }\n    ...\n    }\n  ...\n} while (thisCondition);\n"}
{"id": 349494, "name": "Find if a point is within a triangle", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nuse List::AllUtils qw(min max natatime);\nuse constant EPSILON        =>           0.001;\nuse constant EPSILON_SQUARE => EPSILON*EPSILON;\n\nsub side {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   return ($y2 - $y1)*($x - $x1) + (-$x2 + $x1)*($y - $y1);\n}\n\nsub naivePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $checkSide1 = side($x1, $y1, $x2, $y2, $x, $y) >= 0 ;\n   my $checkSide2 = side($x2, $y2, $x3, $y3, $x, $y) >= 0 ;\n   my $checkSide3 = side($x3, $y3, $x1, $y1, $x, $y) >= 0 ;\n   return $checkSide1 && $checkSide2 && $checkSide3  || 0 ;\n}\n\nsub pointInTriangleBoundingBox {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $xMin = min($x1, min($x2, $x3)) - EPSILON;\n   my $xMax = max($x1, max($x2, $x3)) + EPSILON;\n   my $yMin = min($y1, min($y2, $y3)) - EPSILON;\n   my $yMax = max($y1, max($y2, $y3)) + EPSILON;\n   ( $x < $xMin || $xMax < $x || $y < $yMin || $yMax < $y ) ? 0 : 1\n}\n\nsub distanceSquarePointToSegment {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   my $p1_p2_squareLength = ($x2 - $x1)**2 + ($y2 - $y1)**2;\n   my $dotProduct = ($x-$x1)*($x2-$x1)+($y-$y1)*($y2-$y1) ;\n   if ( $dotProduct < 0 ) {\n      return ($x - $x1)**2 + ($y - $y1)**2;\n   } elsif ( $dotProduct <= $p1_p2_squareLength ) {\n      my $p_p1_squareLength = ($x1 - $x)**2 + ($y1 - $y)**2;\n      return $p_p1_squareLength - $dotProduct**2 / $p1_p2_squareLength;\n   } else {\n      return ($x - $x2)**2 + ($y - $y2)**2;\n   }\n}\n\nsub accuratePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   return 0 unless pointInTriangleBoundingBox($x1,$y1,$x2,$y2,$x3,$y3,$x,$y);\n   return 1 if ( naivePointInTriangle($x1, $y1, $x2, $y2, $x3, $y3, $x, $y)\n      or distanceSquarePointToSegment($x1, $y1, $x2, $y2, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x2, $y2, $x3, $y3, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x3, $y3, $x1, $y1, $x, $y) <= EPSILON_SQUARE);\n   return 0\n}\n\nmy @DATA = (1.5, 2.4, 5.1, -3.1, -3.8, 0.5);\n\nfor my $point ( [0,0] , [0,1] ,[3,1] ) {\n   print \"Point (\", join(',',@$point), \") is within triangle \";\n   my $iter = natatime 2, @DATA;\n   while ( my @vertex = $iter->()) { print '(',join(',',@vertex),') ' }\n   print ': ',naivePointInTriangle (@DATA, @$point) ? 'True' : 'False', \"\\n\" ;\n}\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 349495, "name": "Find if a point is within a triangle", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nuse List::AllUtils qw(min max natatime);\nuse constant EPSILON        =>           0.001;\nuse constant EPSILON_SQUARE => EPSILON*EPSILON;\n\nsub side {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   return ($y2 - $y1)*($x - $x1) + (-$x2 + $x1)*($y - $y1);\n}\n\nsub naivePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $checkSide1 = side($x1, $y1, $x2, $y2, $x, $y) >= 0 ;\n   my $checkSide2 = side($x2, $y2, $x3, $y3, $x, $y) >= 0 ;\n   my $checkSide3 = side($x3, $y3, $x1, $y1, $x, $y) >= 0 ;\n   return $checkSide1 && $checkSide2 && $checkSide3  || 0 ;\n}\n\nsub pointInTriangleBoundingBox {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   my $xMin = min($x1, min($x2, $x3)) - EPSILON;\n   my $xMax = max($x1, max($x2, $x3)) + EPSILON;\n   my $yMin = min($y1, min($y2, $y3)) - EPSILON;\n   my $yMax = max($y1, max($y2, $y3)) + EPSILON;\n   ( $x < $xMin || $xMax < $x || $y < $yMin || $yMax < $y ) ? 0 : 1\n}\n\nsub distanceSquarePointToSegment {\n   my ($x1, $y1, $x2, $y2, $x, $y) = @_;\n   my $p1_p2_squareLength = ($x2 - $x1)**2 + ($y2 - $y1)**2;\n   my $dotProduct = ($x-$x1)*($x2-$x1)+($y-$y1)*($y2-$y1) ;\n   if ( $dotProduct < 0 ) {\n      return ($x - $x1)**2 + ($y - $y1)**2;\n   } elsif ( $dotProduct <= $p1_p2_squareLength ) {\n      my $p_p1_squareLength = ($x1 - $x)**2 + ($y1 - $y)**2;\n      return $p_p1_squareLength - $dotProduct**2 / $p1_p2_squareLength;\n   } else {\n      return ($x - $x2)**2 + ($y - $y2)**2;\n   }\n}\n\nsub accuratePointInTriangle {\n   my ($x1, $y1, $x2, $y2, $x3, $y3, $x, $y) = @_;\n   return 0 unless pointInTriangleBoundingBox($x1,$y1,$x2,$y2,$x3,$y3,$x,$y);\n   return 1 if ( naivePointInTriangle($x1, $y1, $x2, $y2, $x3, $y3, $x, $y)\n      or distanceSquarePointToSegment($x1, $y1, $x2, $y2, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x2, $y2, $x3, $y3, $x, $y) <= EPSILON_SQUARE\n      or distanceSquarePointToSegment($x3, $y3, $x1, $y1, $x, $y) <= EPSILON_SQUARE);\n   return 0\n}\n\nmy @DATA = (1.5, 2.4, 5.1, -3.1, -3.8, 0.5);\n\nfor my $point ( [0,0] , [0,1] ,[3,1] ) {\n   print \"Point (\", join(',',@$point), \") is within triangle \";\n   my $iter = natatime 2, @DATA;\n   while ( my @vertex = $iter->()) { print '(',join(',',@vertex),') ' }\n   print ': ',naivePointInTriangle (@DATA, @$point) ? 'True' : 'False', \"\\n\" ;\n}\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 349496, "name": "Return multiple values", "source": "Translate Perl to Java: sub foo {\n    my ($a, $b) = @_;\n    return $a + $b, $a * $b;\n}\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\n\npublic class RReturnMultipleVals {\n  public static final String K_lipsum = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n  public static final Long   K_1024   = 1024L;\n  public static final String L        = \"L\";\n  public static final String R        = \"R\";\n\n  \n  public static void main(String[] args) throws NumberFormatException{\n    Long nv_;\n    String sv_;\n    switch (args.length) {\n      case 0:\n        nv_ = K_1024;\n        sv_ = K_lipsum;\n        break;\n      case 1:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = K_lipsum;\n        break;\n      case 2:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        break;\n      default:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        for (int ix = 2; ix < args.length; ++ix) {\n          sv_ = sv_ + \" \" + args[ix];\n        }\n        break;\n    }\n\n    RReturnMultipleVals lcl = new RReturnMultipleVals();\n\n    Pair<Long, String> rvp = lcl.getPairFromPair(nv_, sv_); \n    System.out.println(\"Results extracted from a composite object:\");\n    System.out.printf(\"%s, %s%n%n\", rvp.getLeftVal(), rvp.getRightVal());\n\n    List<Object> rvl = lcl.getPairFromList(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"List\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvl.get(0), rvl.get(1));\n\n    Map<String, Object> rvm = lcl.getPairFromMap(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"Map\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvm.get(L), rvm.get(R));\n  }\n  \n  \n  \n  public <T, U> Pair<T, U> getPairFromPair(T vl_, U vr_) {\n    return new Pair<T, U>(vl_, vr_);\n  }\n  \n  \n  \n  public List<Object> getPairFromList(Object nv_, Object sv_) {\n    List<Object> rset = new ArrayList<Object>();\n    rset.add(nv_);\n    rset.add(sv_);\n    return rset;\n  }\n  \n  \n  \n  public Map<String, Object> getPairFromMap(Object nv_, Object sv_) {\n    Map<String, Object> rset = new HashMap<String, Object>();\n    rset.put(L, nv_);\n    rset.put(R, sv_);\n    return rset;\n  }\n\n  \n  private static class Pair<L, R> {\n    private L leftVal;\n    private R rightVal;\n\n    public Pair(L nv_, R sv_) {\n      setLeftVal(nv_);\n      setRightVal(sv_);\n    }\n    public void setLeftVal(L nv_) {\n      leftVal = nv_;\n    }\n    public L getLeftVal() {\n      return leftVal;\n    }\n    public void setRightVal(R sv_) {\n      rightVal = sv_;\n    }\n    public R getRightVal() {\n      return rightVal;\n    }\n  }\n}\n"}
{"id": 349497, "name": "Fractran", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::BigRat;\n\nmy ($n, @P) = map Math::BigRat->new($_), qw{\n2 17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\n};\n\n$|=1;\nMAIN: for( 1 .. 5000 ) {\n\tprint \" \" if $_ > 1;\n\tmy ($pow, $rest) = (0, $n->copy);\n\tuntil( $rest->is_odd ) {\n\t\t++$pow;\n\t\t$rest->bdiv(2);\n\t}\n\tif( $rest->is_one ) {\n\t\tprint \"2**$pow\";\n\t} else {\n\t\t\n\t}\n\tfor my $f_i (@P) {\n\t\tmy $nf_i = $n * $f_i;\n\t\tnext unless $nf_i->is_int;\n\t\t$n = $nf_i;\n\t\tnext MAIN;\n\t}\n\tlast;\n}\n\nprint \"\\n\";\n", "target": "import java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Fractran{\n\n   public static void main(String []args){ \n\n       new Fractran(\"17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\", 2);\n   }\n   final int limit = 15;\n   \n\n   Vector<Integer> num = new Vector<>(); \n   Vector<Integer> den = new Vector<>(); \n   public Fractran(String prog, Integer val){\n      compile(prog);\n      dump();\n      exec(2);\n    }\n\n\n   void compile(String prog){\n      Pattern regexp = Pattern.compile(\"\\\\s*(\\\\d*)\\\\s*\\\\/\\\\s*(\\\\d*)\\\\s*(.*)\");\n      Matcher matcher = regexp.matcher(prog);\n      while(matcher.find()){\n         num.add(Integer.parseInt(matcher.group(1)));\n         den.add(Integer.parseInt(matcher.group(2)));\n         matcher = regexp.matcher(matcher.group(3));\n      }\n   }\n\n   void exec(Integer val){\n       int n = 0;\n       while(val != null && n<limit){\n           System.out.println(n+\": \"+val);\n           val = step(val);\n           n++;\n       }\n   }\n   Integer step(int val){\n       int i=0; \n       while(i<den.size() && val%den.get(i) != 0) i++;\n       if(i<den.size())\n           return num.get(i)*val/den.get(i);\n       return null;\n   }\n\n   void dump(){\n       for(int i=0; i<den.size(); i++)\n           System.out.print(num.get(i)+\"/\"+den.get(i)+\" \");\n       System.out.println();\n   }\n}\n"}
{"id": 349498, "name": "Substring_Top and tail", "source": "Translate Perl to Java: print substr(\"knight\",1), \"\\n\";        \nprint substr(\"socks\", 0, -1), \"\\n\";    \nprint substr(\"brooms\", 1, -1), \"\\n\";   \n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 349499, "name": "Substring_Top and tail", "source": "Translate Perl to Java: print substr(\"knight\",1), \"\\n\";        \nprint substr(\"socks\", 0, -1), \"\\n\";    \nprint substr(\"brooms\", 1, -1), \"\\n\";   \n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 349500, "name": "Boolean values", "source": "Translate Perl to Java: my $x = 0.0;\nmy $true_or_false = $x ? 'true' : 'false';     \n", "target": "module GeorgeBoole\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean f = False;\n        assert !f == True;\n\n        \n        \n        assert True.and(False) == True & False == False;\n        assert True.or(False)  == True | False == True;\n        assert True.xor(False) == True ^ False == True;\n        assert True.not() == ~True == False;\n\n        console.print($\"0==1 = {0==1}\");\n        console.print($\"!False = {!False}\");\n        }\n    }\n"}
{"id": 349501, "name": "Plot coordinate pairs", "source": "Translate Perl to Java: use GD::Graph::points;\n\n@data = (\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n  [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0],\n);\n\n$graph = GD::Graph::points->new(400, 300);\nopen my $fh, '>', \"qsort-range-10-9.png\";\nbinmode $fh;\nprint $fh $graph->plot(\\@data)->png;\nclose $fh;\n", "target": "  import java.awt.*;\n  import java.awt.event.*;\n  import java.awt.geom.*;\n  import javax.swing.JApplet;\n  import javax.swing.JFrame;\n  public class Plot2d extends JApplet {\n    double[] xi;\n    double[] yi;\n    public Plot2d(double[] x, double[] y) {\n        this.xi = x;\n        this.yi = y;\n    }\n    public static double max(double[] t) {\n        double maximum = t[0];   \n        for (int i = 1; i < t.length; i++) {\n            if (t[i] > maximum) {\n                maximum = t[i];  \n            }\n        }\n        return maximum;\n    }\n    public static double min(double[] t) {\n        double minimum = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (t[i] < minimum) {\n                minimum = t[i];\n            }\n        }\n        return minimum;\n    }\n    public void init() {\n        setBackground(Color.white);\n        setForeground(Color.white);\n    }\n    public void paint(Graphics g) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setPaint(Color.black);\n        int x0 = 70;\n        int y0 = 10;\n        int xm = 670;\n        int ym = 410;\n        int xspan = xm - x0;\n        int yspan = ym - y0;\n        double xmax = max(xi);\n        double xmin = min(xi);\n        double ymax = max(yi);\n        double ymin = min(yi);\n        g2.draw(new Line2D.Double(x0, ym, xm, ym));\n        g2.draw(new Line2D.Double(x0, ym, x0, y0));\n        for (int j = 0; j < 5; j++) {\n            int interv = 4;\n            g2.drawString(\"\" + (j * (xmax - xmin) / interv + xmin), j * xspan / interv + x0 - 10, ym + 20);\n            g2.drawString(\"\" + (j * (ymax - ymin) / interv + ymin), x0 - 20 - (int) (9 * Math.log10(ymax)),\n ym - j * yspan / interv + y0 - 5);\n            g2.draw(new Line2D.Double(j * xspan / interv + x0, ym, j * xspan / interv + x0, ym + 5));\n            g2.draw(new Line2D.Double(x0 - 5, j * yspan / interv + y0, x0, j * yspan / interv + y0));\n        }\n        for (int i = 0; i < xi.length; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            g2.drawString(\"o\", x0 + f - 3, h + 14);\n        }\n        for (int i = 0; i < xi.length - 1; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int f2 = (int) ((xi[i + 1] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            int h2 = (int) (((ymax - ymin) - (yi[i + 1] - ymin)) * yspan / (ymax - ymin));\n            g2.draw(new Line2D.Double(f + x0, h + y0, f2 + x0, h2 + y0));\n        }\n    }\n    public static void main(String args[]) {\n        JFrame f = new JFrame(\"ShapesDemo2D\");\n        f.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        double[] r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        double[] t = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.09};\n        JApplet applet = new Plot2d(r, t);\n        f.getContentPane().add(\"Center\", applet);\n        applet.init();\n        f.pack();\n        f.setSize(new Dimension(720, 480));\n        f.show();\n    }\n  }\n"}
{"id": 349502, "name": "Plot coordinate pairs", "source": "Translate Perl to Java: use GD::Graph::points;\n\n@data = (\n  [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n  [2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.0],\n);\n\n$graph = GD::Graph::points->new(400, 300);\nopen my $fh, '>', \"qsort-range-10-9.png\";\nbinmode $fh;\nprint $fh $graph->plot(\\@data)->png;\nclose $fh;\n", "target": "  import java.awt.*;\n  import java.awt.event.*;\n  import java.awt.geom.*;\n  import javax.swing.JApplet;\n  import javax.swing.JFrame;\n  public class Plot2d extends JApplet {\n    double[] xi;\n    double[] yi;\n    public Plot2d(double[] x, double[] y) {\n        this.xi = x;\n        this.yi = y;\n    }\n    public static double max(double[] t) {\n        double maximum = t[0];   \n        for (int i = 1; i < t.length; i++) {\n            if (t[i] > maximum) {\n                maximum = t[i];  \n            }\n        }\n        return maximum;\n    }\n    public static double min(double[] t) {\n        double minimum = t[0];\n        for (int i = 1; i < t.length; i++) {\n            if (t[i] < minimum) {\n                minimum = t[i];\n            }\n        }\n        return minimum;\n    }\n    public void init() {\n        setBackground(Color.white);\n        setForeground(Color.white);\n    }\n    public void paint(Graphics g) {\n        Graphics2D g2 = (Graphics2D) g;\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g2.setPaint(Color.black);\n        int x0 = 70;\n        int y0 = 10;\n        int xm = 670;\n        int ym = 410;\n        int xspan = xm - x0;\n        int yspan = ym - y0;\n        double xmax = max(xi);\n        double xmin = min(xi);\n        double ymax = max(yi);\n        double ymin = min(yi);\n        g2.draw(new Line2D.Double(x0, ym, xm, ym));\n        g2.draw(new Line2D.Double(x0, ym, x0, y0));\n        for (int j = 0; j < 5; j++) {\n            int interv = 4;\n            g2.drawString(\"\" + (j * (xmax - xmin) / interv + xmin), j * xspan / interv + x0 - 10, ym + 20);\n            g2.drawString(\"\" + (j * (ymax - ymin) / interv + ymin), x0 - 20 - (int) (9 * Math.log10(ymax)),\n ym - j * yspan / interv + y0 - 5);\n            g2.draw(new Line2D.Double(j * xspan / interv + x0, ym, j * xspan / interv + x0, ym + 5));\n            g2.draw(new Line2D.Double(x0 - 5, j * yspan / interv + y0, x0, j * yspan / interv + y0));\n        }\n        for (int i = 0; i < xi.length; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            g2.drawString(\"o\", x0 + f - 3, h + 14);\n        }\n        for (int i = 0; i < xi.length - 1; i++) {\n            int f = (int) ((xi[i] - xmin) * xspan / (xmax - xmin));\n            int f2 = (int) ((xi[i + 1] - xmin) * xspan / (xmax - xmin));\n            int h = (int) (((ymax - ymin) - (yi[i] - ymin)) * yspan / (ymax - ymin));\n            int h2 = (int) (((ymax - ymin) - (yi[i + 1] - ymin)) * yspan / (ymax - ymin));\n            g2.draw(new Line2D.Double(f + x0, h + y0, f2 + x0, h2 + y0));\n        }\n    }\n    public static void main(String args[]) {\n        JFrame f = new JFrame(\"ShapesDemo2D\");\n        f.addWindowListener(new WindowAdapter() {\n            public void windowClosing(WindowEvent e) {\n                System.exit(0);\n            }\n        });\n        double[] r = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n        double[] t = {2.7, 2.8, 31.4, 38.1, 58.0, 76.2, 100.5, 130.0, 149.3, 180.09};\n        JApplet applet = new Plot2d(r, t);\n        f.getContentPane().add(\"Center\", applet);\n        applet.init();\n        f.pack();\n        f.setSize(new Dimension(720, 480));\n        f.show();\n    }\n  }\n"}
{"id": 349503, "name": "LZW compression", "source": "Translate Perl to Java: \nsub compress {\n    my $uncompressed = shift;\n\n    \n    my $dict_size = 256;\n    my %dictionary = map {chr $_ => chr $_} 0..$dict_size-1;\n\n    my $w = \"\";\n    my @result;\n    foreach my $c (split '', $uncompressed) {\n        my $wc = $w . $c;\n        if (exists $dictionary{$wc}) {\n            $w = $wc;\n        } else {\n            push @result, $dictionary{$w};\n            \n            $dictionary{$wc} = $dict_size;\n            $dict_size++;\n            $w = $c;\n        }\n    }\n\n    \n    if ($w) {\n        push @result, $dictionary{$w};\n    }\n    return @result;\n}\n\n\nsub decompress {\n    my @compressed = @_;\n\n    \n    my $dict_size = 256;\n    my %dictionary = map {chr $_ => chr $_} 0..$dict_size-1;\n\n    my $w = shift @compressed;\n    my $result = $w;\n    foreach my $k (@compressed) {\n        my $entry;\n        if (exists $dictionary{$k}) {\n            $entry = $dictionary{$k};\n        } elsif ($k == $dict_size) {\n            $entry = $w . substr($w,0,1);\n        } else {\n            die \"Bad compressed k: $k\";\n        }\n        $result .= $entry;\n\n        \n        $dictionary{$dict_size} = $w . substr($entry,0,1);\n        $dict_size++;\n\n        $w = $entry;\n    }\n    return $result;\n}\n\n\nmy @compressed = compress('TOBEORNOTTOBEORTOBEORNOT');\nprint \"@compressed\\n\";\nmy $decompressed = decompress(@compressed);\nprint \"$decompressed\\n\";\n", "target": "import java.util.*;\n\npublic class LZW {\n    \n    public static List<Integer> compress(String uncompressed) {\n        \n        int dictSize = 256;\n        Map<String,Integer> dictionary = new HashMap<String,Integer>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(\"\" + (char)i, i);\n        \n        String w = \"\";\n        List<Integer> result = new ArrayList<Integer>();\n        for (char c : uncompressed.toCharArray()) {\n            String wc = w + c;\n            if (dictionary.containsKey(wc))\n                w = wc;\n            else {\n                result.add(dictionary.get(w));\n                \n                dictionary.put(wc, dictSize++);\n                w = \"\" + c;\n            }\n        }\n \n        \n        if (!w.equals(\"\"))\n            result.add(dictionary.get(w));\n        return result;\n    }\n    \n    \n    public static String decompress(List<Integer> compressed) {\n        \n        int dictSize = 256;\n        Map<Integer,String> dictionary = new HashMap<Integer,String>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(i, \"\" + (char)i);\n        \n        String w = \"\" + (char)(int)compressed.remove(0);\n        StringBuffer result = new StringBuffer(w);\n        for (int k : compressed) {\n            String entry;\n            if (dictionary.containsKey(k))\n                entry = dictionary.get(k);\n            else if (k == dictSize)\n                entry = w + w.charAt(0);\n            else\n                throw new IllegalArgumentException(\"Bad compressed k: \" + k);\n            \n            result.append(entry);\n            \n            \n            dictionary.put(dictSize++, w + entry.charAt(0));\n            \n            w = entry;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> compressed = compress(\"TOBEORNOTTOBEORTOBEORNOT\");\n        System.out.println(compressed);\n        String decompressed = decompress(compressed);\n        System.out.println(decompressed);\n    }\n}\n"}
{"id": 349504, "name": "Peano curve", "source": "Translate Perl to Java: use SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\n\nmy %rules = (\n    L => 'LFRFL-F-RFLFR+F+LFRFL',\n    R => 'RFLFR+F+LFRFL-F-RFLFR'\n);\nmy $peano = 'L';\n$peano =~ s/([LR])/$rules{$1}/eg for 1..4;\n\n\n($x, $y) = (0, 0);\n$theta   = pi/2;\n$r       = 4;\n\nfor (split //, $peano) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/2; }\n    elsif (/\\-/) { $theta -= pi/2; }\n}\n\n$max =  max(@X,@Y);\n$xt  = -min(@X)+10;\n$yt  = -min(@Y)+10;\n$svg = SVG->new(width=>$max+20, height=>$max+20);\n$points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen  $fh, '>', 'peano_curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "import java.io.*;\n\npublic class PeanoCurve {\n    public static void main(final String[] args) {\n        try (Writer writer = new BufferedWriter(new FileWriter(\"peano_curve.svg\"))) {\n            PeanoCurve s = new PeanoCurve(writer);\n            final int length = 8;\n            s.currentAngle = 90;\n            s.currentX = length;\n            s.currentY = length;\n            s.lineLength = length;\n            s.begin(656);\n            s.execute(rewrite(4));\n            s.end();\n        } catch (final Exception ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private PeanoCurve(final Writer writer) {\n        this.writer = writer;\n    }\n\n    private void begin(final int size) throws IOException {\n        write(\"<svg xmlns='http:\n        write(\"<rect width='100%%' height='100%%' fill='white'/>\\n\");\n        write(\"<path stroke-width='1' stroke='black' fill='none' d='\");\n    }\n\n    private void end() throws IOException {\n        write(\"'/>\\n</svg>\\n\");\n    }\n\n    private void execute(final String s) throws IOException {\n        write(\"M%g,%g\\n\", currentX, currentY);\n        for (int i = 0, n = s.length(); i < n; ++i) {\n            switch (s.charAt(i)) {\n                case 'F':\n                    line(lineLength);\n                    break;\n                case '+':\n                    turn(ANGLE);\n                    break;\n                case '-':\n                    turn(-ANGLE);\n                    break;\n            }\n        }\n    }\n\n    private void line(final double length) throws IOException {\n        final double theta = (Math.PI * currentAngle) / 180.0;\n        currentX += length * Math.cos(theta);\n        currentY += length * Math.sin(theta);\n        write(\"L%g,%g\\n\", currentX, currentY);\n    }\n\n    private void turn(final int angle) {\n        currentAngle = (currentAngle + angle) % 360;\n    }\n\n    private void write(final String format, final Object... args) throws IOException {\n        writer.write(String.format(format, args));\n    }\n\n    private static String rewrite(final int order) {\n        String s = \"L\";\n        for (int i = 0; i < order; ++i) {\n            final StringBuilder sb = new StringBuilder();\n            for (int j = 0, n = s.length(); j < n; ++j) {\n                final char ch = s.charAt(j);\n                if (ch == 'L')\n                    sb.append(\"LFRFL-F-RFLFR+F+LFRFL\");\n                else if (ch == 'R')\n                    sb.append(\"RFLFR+F+LFRFL-F-RFLFR\");\n                else\n                    sb.append(ch);\n            }\n            s = sb.toString();\n        }\n        return s;\n    }\n\n    private final Writer writer;\n    private double lineLength;\n    private double currentX;\n    private double currentY;\n    private int currentAngle;\n    private static final int ANGLE = 90;\n}\n"}
{"id": 349505, "name": "First 9 prime Fibonacci number", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nmy @first;\nmy $x = my $y = 1;\nwhile( @first < 9 )\n  {\n  ($x, $y) = ($x + $y, $x);\n  is_prime( $x ) and push @first, $x;\n  }\nprint \"@first\\n\";\n", "target": "import java.math.BigInteger;\n\npublic class PrimeFibonacciGenerator {\n    private PrimeGenerator primeGen = new PrimeGenerator(10000, 200000);\n    private BigInteger f0 = BigInteger.ZERO;\n    private BigInteger f1 = BigInteger.ONE;\n    private int index = 0;\n\n    public static void main(String[] args) {\n        PrimeFibonacciGenerator gen = new PrimeFibonacciGenerator();\n        long start = System.currentTimeMillis();\n        for (int i = 1; i <= 26; ++i) {\n            BigInteger f = gen.next();\n            System.out.printf(\"%d: F(%d) = %s\\n\", i, gen.index - 1, toString(f));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"elapsed time: %g seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private PrimeFibonacciGenerator() {\n        for (int i = 0; i < 2; ++i)\n            primeGen.nextPrime();\n    }\n\n    private BigInteger next() {\n        for (;;) {\n            if (index > 4) {\n                int p = primeGen.nextPrime();\n                for (; p > index; ++index)\n                    nextFibonacci();\n            }\n            ++index;\n            BigInteger f = nextFibonacci();\n            if (f.isProbablePrime(30))\n                return f;\n        }\n    }\n\n    private BigInteger nextFibonacci() {\n        BigInteger result = f0;\n        BigInteger f = f0.add(f1);\n        f0 = f1;\n        f1 = f;\n        return result;\n    }\n\n    private static String toString(BigInteger f) {\n        String str = f.toString();\n        if (str.length() > 40) {\n            StringBuilder s = new StringBuilder(str.substring(0, 20));\n            s.append(\"...\");\n            s.append(str.substring(str.length() - 20));\n            s.append(\" (\");\n            s.append(str.length());\n            s.append(\" digits)\");\n            str = s.toString();\n        }\n        return str;\n    }\n}\n"}
{"id": 349506, "name": "First 9 prime Fibonacci number", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse ntheory qw( is_prime );\n\nmy @first;\nmy $x = my $y = 1;\nwhile( @first < 9 )\n  {\n  ($x, $y) = ($x + $y, $x);\n  is_prime( $x ) and push @first, $x;\n  }\nprint \"@first\\n\";\n", "target": "import java.math.BigInteger;\n\npublic class PrimeFibonacciGenerator {\n    private PrimeGenerator primeGen = new PrimeGenerator(10000, 200000);\n    private BigInteger f0 = BigInteger.ZERO;\n    private BigInteger f1 = BigInteger.ONE;\n    private int index = 0;\n\n    public static void main(String[] args) {\n        PrimeFibonacciGenerator gen = new PrimeFibonacciGenerator();\n        long start = System.currentTimeMillis();\n        for (int i = 1; i <= 26; ++i) {\n            BigInteger f = gen.next();\n            System.out.printf(\"%d: F(%d) = %s\\n\", i, gen.index - 1, toString(f));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"elapsed time: %g seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private PrimeFibonacciGenerator() {\n        for (int i = 0; i < 2; ++i)\n            primeGen.nextPrime();\n    }\n\n    private BigInteger next() {\n        for (;;) {\n            if (index > 4) {\n                int p = primeGen.nextPrime();\n                for (; p > index; ++index)\n                    nextFibonacci();\n            }\n            ++index;\n            BigInteger f = nextFibonacci();\n            if (f.isProbablePrime(30))\n                return f;\n        }\n    }\n\n    private BigInteger nextFibonacci() {\n        BigInteger result = f0;\n        BigInteger f = f0.add(f1);\n        f0 = f1;\n        f1 = f;\n        return result;\n    }\n\n    private static String toString(BigInteger f) {\n        String str = f.toString();\n        if (str.length() > 40) {\n            StringBuilder s = new StringBuilder(str.substring(0, 20));\n            s.append(\"...\");\n            s.append(str.substring(str.length() - 20));\n            s.append(\" (\");\n            s.append(str.length());\n            s.append(\" digits)\");\n            str = s.toString();\n        }\n        return str;\n    }\n}\n"}
{"id": 349507, "name": "Bioinformatics_base count", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nmy %cnt;\nmy $total = 0;\n\nwhile ($_ = <DATA>) {\n    chomp;\n    printf \"%4d: %s\\n\", $total+1, s/(.{10})/$1 /gr;\n    $total += length;\n    $cnt{$_}++ for split //\n}\n\nsay \"\\nTotal bases: $total\";\nsay \"$_: \" . ($cnt{$_}//0) for <A C G T>;\n\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 349508, "name": "Bioinformatics_base count", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nmy %cnt;\nmy $total = 0;\n\nwhile ($_ = <DATA>) {\n    chomp;\n    printf \"%4d: %s\\n\", $total+1, s/(.{10})/$1 /gr;\n    $total += length;\n    $cnt{$_}++ for split //\n}\n\nsay \"\\nTotal bases: $total\";\nsay \"$_: \" . ($cnt{$_}//0) for <A C G T>;\n\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class orderedSequence {\n    public static void main(String[] args) {\n        Sequence gene = new Sequence(\"CGTAAAAAATTACAACGTCCTTTGGCTATCTCTTAAACTCCTGCTAAATGCTCGTGCTTTCCAATTATGTAAGCGTTCCGAGACGGGGTGGTCGATTCTGAGGACAAAGGTCAAGATGGAGCGCATCGAACGCAATAAGGATCATTTGATGGGACGTTTCGTCGACAAAGTCTTGTTTCGAGAGTAACGGCTACCGTCTTCGATTCTGCTTATAACACTATGTTCTTATGAAATGGATGTTCTGAGTTGGTCAGTCCCAATGTGCGGGGTTTCTTTTAGTACGTCGGGAGTGGTATTATATTTAATTTTTCTATATAGCGATCTGTATTTAAGCAATTCATTTAGGTTATCGCCGCGATGCTCGGTTCGGACCGCCAAGCATCTGGCTCCACTGCTAGTGTCCTAAATTTGAATGGCAAACACAAATAAGATTTAGCAATTCGTGTAGACGACCGGGGACTTGCATGATGGGAGCAGCTTTGTTAAACTACGAACGTAAT\");\n        gene.runSequence();\n    }\n}\n\n\npublic class Sequence {\n    \n    private final String seq;\n    \n    public Sequence(String sq) {\n        this.seq = sq;\n    }\n    \n    \n    public void prettyPrint() {\n        System.out.println(\"Sequence:\");\n        int i = 0;\n        for ( ; i < seq.length() - 50 ; i += 50) {\n            System.out.printf(\"%5s\u00a0: %s\\n\", i + 50, seq.substring(i, i + 50));\n        }\n        System.out.printf(\"%5s\u00a0: %s\\n\", seq.length(), seq.substring(i));\n    }\n    \n    \n    public void displayCount() {\n        Map<Character, Integer> counter = new HashMap<>();\n        for (int i = 0 ; i < seq.length() ; ++i) {\n            counter.merge(seq.charAt(i), 1, Integer::sum);\n        }\n\n        System.out.println(\"Base vs. Count:\");\n        counter.forEach(\n            key, value -> System.out.printf(\"%5s\u00a0: %s\\n\", key, value));\n        System.out.printf(\"%5s: %s\\n\", \"SUM\", seq.length());\n    }\n    \n    public void runSequence() {\n        this.prettyPrint();\n        this.displayCount();\n    }\n}\n"}
{"id": 349509, "name": "Ulam spiral (for primes)", "source": "Translate Perl to Java: use ntheory qw/is_prime/;\nuse Imager;\n\nmy $n = shift || 512;\nmy $start = shift || 1;\nmy $file = \"ulam.png\";\n\nsub cell {\n  my($n, $x, $y, $start) = @_;\n  $y -= $n>>1;\n  $x -= ($n-1)>>1;\n  my $l = 2*(abs($x) > abs($y) ? abs($x) : abs($y));\n  my $d = ($y > $x)  ?  $l*3 + $x + $y  : $l-$x-$y;\n  ($l-1)**2 + $d + $start - 1;\n}\n\nmy $black = Imager::Color->new('\nmy $white = Imager::Color->new('\nmy $img = Imager->new(xsize => $n, ysize => $n, channels => 1);\n$img->box(filled=>1, color=>$white);\n\nfor my $y (0 .. $n-1) {\n  for my $x (0 .. $n-1) {\n    my $v = cell($n, $x, $y, $start);\n    $img->setpixel(x => $x, y => $y, color => $black) if is_prime($v);\n  }\n}\n\n$img->write(file => $file) or die \"Cannot write $file: \", $img->errstr, \"\\n\";\n", "target": "import java.util.Arrays;\n\npublic class Ulam{\n\tenum Direction{\n\t\tRIGHT, UP, LEFT, DOWN;\n\t}\n\t\n\tprivate static String[][] genUlam(int n){\n\t\treturn genUlam(n, 1);\n\t}\n\n\tprivate static String[][] genUlam(int n, int i){\n\t\tString[][] spiral = new String[n][n];\n\t\tDirection dir = Direction.RIGHT;\n\t\tint j = i;\n\t\tint y = n / 2;\n\t\tint x = (n % 2 == 0) ? y - 1 : y; \n\t\twhile(j <= ((n * n) - 1 + i)){\n\t\t\tspiral[y][x] = isPrime(j) ? String.format(\"%4d\", j) : \" ---\";\n\n\t\t\tswitch(dir){\n\t\t\tcase RIGHT:\n\t\t\t\tif(x <= (n - 1) && spiral[y - 1][x] == null && j > i) dir = Direction.UP; break;\n\t\t\tcase UP:\n\t\t\t\tif(spiral[y][x - 1] == null) dir = Direction.LEFT; break;\n\t\t\tcase LEFT:\n\t\t\t\tif(x == 0 || spiral[y + 1][x] == null) dir = Direction.DOWN; break;\n\t\t\tcase DOWN:\n\t\t\t\tif(spiral[y][x + 1] == null) dir = Direction.RIGHT; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(dir){\n\t\t\t\tcase RIGHT:\tx++; break;\n\t\t\t\tcase UP: \ty--; break;\n\t\t\t\tcase LEFT:\tx--; break;\n\t\t\t\tcase DOWN:\ty++; break;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\treturn spiral;\n\t}\n\t\n\tpublic static boolean isPrime(int a){\n\t\t   if(a == 2) return true;\n\t\t   if(a <= 1 || a % 2 == 0) return false;\n\t\t   long max = (long)Math.sqrt(a);\n\t\t   for(long n = 3; n <= max; n += 2){\n\t\t      if(a % n == 0) return false;\n\t\t   }\n\t\t   return true;\n\t\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[][] ulam = genUlam(9);\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\",\", \"\"));\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\"\\\\[\\\\s+\\\\d+\", \"[  * \").replaceAll(\"\\\\s+\\\\d+\", \"   * \").replaceAll(\",\", \"\"));\n\t\t}\n\t}\n}\n"}
{"id": 349510, "name": "Fibonacci word", "source": "Translate Perl to Java: sub fiboword;\n{\n    my ($a, $b, $count) = (1, 0, 0);\n    sub fiboword {\n        $count++;\n        return $a if $count == 1;\n        return $b if $count == 2;\n        ($a, $b) = ($b, \"$b$a\");\n        return $b;\n    }\n}\nsub entropy {\n    my %c;\n    $c{$_}++ for split //, my $str = shift;\n    my $e = 0;\n    for (values %c) {\n        my $p = $_ / length $str;\n        $e -= $p * log $p;\n    }\n    return $e / log 2;\n}\n\nmy $count;\nwhile ($count++ < 37) {\n    my $word = fiboword;\n    printf \"%5d\\t%10d\\t%.8e\\t%s\\n\",\n    $count,\n    length($word),\n    entropy($word),\n    $count > 9 ? '' : $word\n}\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 349511, "name": "Fibonacci word", "source": "Translate Perl to Java: sub fiboword;\n{\n    my ($a, $b, $count) = (1, 0, 0);\n    sub fiboword {\n        $count++;\n        return $a if $count == 1;\n        return $b if $count == 2;\n        ($a, $b) = ($b, \"$b$a\");\n        return $b;\n    }\n}\nsub entropy {\n    my %c;\n    $c{$_}++ for split //, my $str = shift;\n    my $e = 0;\n    for (values %c) {\n        my $p = $_ / length $str;\n        $e -= $p * log $p;\n    }\n    return $e / log 2;\n}\n\nmy $count;\nwhile ($count++ < 37) {\n    my $word = fiboword;\n    printf \"%5d\\t%10d\\t%.8e\\t%s\\n\",\n    $count,\n    length($word),\n    entropy($word),\n    $count > 9 ? '' : $word\n}\n", "target": "import java.util.*;\n\npublic class FWord {\n    private  String fWord0 = \"\";\n    private  String fWord1 = \"\";\n\n    private String nextFWord () {\n        final String result;\n        \n        if ( \"\".equals ( fWord1 ) )      result = \"1\";\n        else if ( \"\".equals ( fWord0 ) ) result = \"0\";\n        else                             result = fWord1 + fWord0;\n\n        fWord0 = fWord1;\n        fWord1 = result;\n\n        return result;\n    }\n\n    public static double entropy ( final String source ) {\n        final int                        length = source.length ();\n        final Map < Character, Integer > counts = new HashMap < Character, Integer > ();\n         double                     result = 0.0;\n \n        for ( int i = 0; i < length; i++ ) {\n            final char c = source.charAt ( i );\n\n            if ( counts.containsKey ( c ) ) counts.put ( c, counts.get ( c ) + 1 );\n            else                            counts.put ( c, 1 );\n        }\n\n        for ( final int count : counts.values () ) {\n            final double proportion = ( double ) count / length;\n\n            result -= proportion * ( Math.log ( proportion ) / Math.log ( 2 ) );\n        }\n\n        return result;\n    }\n\n    public static void main ( final String [] args ) {\n        final FWord fWord = new FWord ();\n\n        for ( int i = 0; i < 37;  ) {\n            final String word = fWord.nextFWord ();\n\n            System.out.printf ( \"%3d %10d %s %n\", ++i, word.length (), entropy ( word ) );\n        }\n    }\n}\n"}
{"id": 349512, "name": "Text processing_1", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $nodata = 0;               \nmy $nodata_max = -1;          \nmy $nodata_maxline = \"!\";     \n\nmy $infiles = join \", \", @ARGV;\n\nmy $tot_file = 0;\nmy $num_file = 0;\n\nwhile (<>) {\n  chomp;\n  my $tot_line = 0;             \n  my $num_line = 0;             \n  my $rejects  = 0;\n \n  \n  my ($date, @fields) = split;\n  while (@fields and my ($datum, $flag) = splice @fields, 0, 2) {\n    if ($flag+1 < 2) {\n      $nodata++;\n      $rejects++;\n      next;\n    }\n\n    \n    if($nodata_max == $nodata and $nodata > 0){\n      $nodata_maxline = \"$nodata_maxline, $date\";\n    }\n    if($nodata_max < $nodata and $nodata > 0){\n      $nodata_max = $nodata;\n      $nodata_maxline = $date;\n    }\n    \n    $nodata = 0; \n    \n    $tot_line += $datum;\n    $num_line++;\n  }\n \n  \n  $tot_file += $tot_line;\n  $num_file += $num_line;\n \n  printf \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\\n\",\n         $date, $rejects, $num_line, $tot_line, ($num_line>0)? $tot_line/$num_line: 0;\n \n}\n \nprintf \"\\n\";\nprintf \"File(s)  = %s\\n\", $infiles;\nprintf \"Total    = %10.3f\\n\", $tot_file;\nprintf \"Readings = %6i\\n\", $num_file;\nprintf \"Average  = %10.3f\\n\", $tot_file / $num_file;\n \nprintf \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\\n\", \n       $nodata_max, $nodata_maxline;\n", "target": "import java.io.File;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class TextProcessing1 {\n\n    public static void main(String[] args) throws Exception {\n        Locale.setDefault(new Locale(\"en\", \"US\"));\n        Metrics metrics = new Metrics();\n\n        int dataGap = 0;\n        String gapBeginDate = null;\n        try (Scanner lines = new Scanner(new File(\"readings.txt\"))) {\n            while (lines.hasNextLine()) {\n\n                double lineTotal = 0.0;\n                int linePairs = 0;\n                int lineInvalid = 0;\n                String lineDate;\n\n                try (Scanner line = new Scanner(lines.nextLine())) {\n\n                    lineDate = line.next();\n\n                    while (line.hasNext()) {\n                        final double value = line.nextDouble();\n                        if (line.nextInt() <= 0) {\n                            if (dataGap == 0)\n                                gapBeginDate = lineDate;\n                            dataGap++;\n                            lineInvalid++;\n                            continue;\n                        }\n                        lineTotal += value;\n                        linePairs++;\n\n                        metrics.addDataGap(dataGap, gapBeginDate, lineDate);\n                        dataGap = 0;\n                    }\n                }\n                metrics.addLine(lineTotal, linePairs);\n                metrics.lineResult(lineDate, lineInvalid, linePairs, lineTotal);\n            }\n            metrics.report();\n        }\n    }\n\n    private static class Metrics {\n        private List<String[]> gapDates;\n        private int maxDataGap = -1;\n        private double total;\n        private int pairs;\n        private int lineResultCount;\n\n        void addLine(double tot, double prs) {\n            total += tot;\n            pairs += prs;\n        }\n\n        void addDataGap(int gap, String begin, String end) {\n            if (gap > 0 && gap >= maxDataGap) {\n                if (gap > maxDataGap) {\n                    maxDataGap = gap;\n                    gapDates = new ArrayList<>();\n                }\n                gapDates.add(new String[]{begin, end});\n            }\n        }\n\n        void lineResult(String date, int invalid, int prs, double tot) {\n            if (lineResultCount >= 3)\n                return;\n            out.printf(\"%10s  out: %2d  in: %2d  tot: %10.3f  avg: %10.3f%n\",\n                    date, invalid, prs, tot, (prs > 0) ? tot / prs : 0.0);\n            lineResultCount++;\n        }\n\n        void report() {\n            out.printf(\"%ntotal    = %10.3f%n\", total);\n            out.printf(\"readings = %6d%n\", pairs);\n            out.printf(\"average  = %010.3f%n\", total / pairs);\n            out.printf(\"%nmaximum run(s) of %d invalid measurements: %n\",\n                    maxDataGap);\n            for (String[] dates : gapDates)\n                out.printf(\"begins at %s and ends at %s%n\", dates[0], dates[1]);\n\n        }\n    }\n}\n"}
{"id": 349513, "name": "Death Star", "source": "Translate Perl to Java: use strict;\n\nsub sq {\n\tmy $s = 0;\n\t$s += $_ ** 2 for @_;\n\t$s;\n}\n\nsub hit {\n\tmy ($sph, $x, $y) = @_;\n\t$x -= $sph->[0];\n\t$y -= $sph->[1];\n\n\tmy $z = sq($sph->[3]) - sq($x, $y);\n\treturn\tif $z < 0;\n\n\t$z = sqrt $z;\n\treturn $sph->[2] - $z, $sph->[2] + $z;\n}\n\nsub normalize {\n\tmy $v = shift;\n\tmy $n = sqrt sq(@$v);\n\t$_ /= $n for @$v;\n\t$v;\n}\n\nsub dot {\n\tmy ($x, $y) = @_;\n\tmy $s = $x->[0] * $y->[0] + $x->[1] * $y->[1] + $x->[2] * $y->[2];\n\t$s > 0 ? $s : 0;\n}\n\nmy $pos = [ 120, 120, 0, 120 ];\nmy $neg = [ -77, -33, -100, 190 ];\nmy $light = normalize([ -12, 13, -10 ]);\nsub draw {\n\tmy ($k, $amb) = @_;\n\tbinmode STDOUT, \":raw\";\n\tprint \"P5\\n\", $pos->[0] * 2 + 3, \" \", $pos->[1] * 2 + 3, \"\\n255\\n\";\n\tfor my $y (($pos->[1] - $pos->[3] - 1) .. ($pos->[1] + $pos->[3] + 1)) {\n\t\tmy @row = ();\n\t\tfor my $x (($pos->[0] - $pos->[3] - 1) .. ($pos->[0] + $pos->[3] + 1)) {\n\t\t\tmy ($hit, @hs) = 0;\n\t\t\tmy @h = hit($pos, $x, $y);\n\n\t\t\tif (!@h) { $hit = 0 }\n\t\t\telsif (!(@hs = hit($neg, $x, $y))) { $hit = 1 }\n\t\t\telsif ($hs[0] > $h[0]) { $hit = 1 }\n\t\t\telsif ($hs[1] > $h[0]) { $hit = $hs[1] > $h[1] ? 0 : 2 }\n\t\t\telse { $hit = 1 }\n\n\t\t\tmy ($val, $v);\n\t\t\tif ($hit == 0) { $val = 0 }\n\t\t\telsif ($hit == 1) {\n\t\t\t\t$v = [\t$x - $pos->[0],\n\t\t\t\t\t$y - $pos->[1],\n\t\t\t\t\t$h[0] - $pos->[2] ];\n\t\t\t} else {\n\t\t\t\t$v = [\t$neg->[0] - $x,\n\t\t\t\t\t$neg->[1] - $y,\n\t\t\t\t\t$neg->[2] - $hs[1] ];\n\t\t\t}\n\t\t\tif ($v) {\n\t\t\t\tnormalize($v);\n\t\t\t\t$val = int((dot($v, $light) ** $k + $amb) * 255);\n\t\t\t\t$val = ($val > 255) ? 255 : ($val < 0) ? 0 : $val;\n\t\t\t}\n\t\t\tpush @row, $val;\n\t\t}\n\t\tprint pack(\"C*\", @row);\n\t}\n}\n\ndraw(2, 0.2);\n", "target": "import javafx.application.Application;\nimport javafx.event.EventHandler;\nimport javafx.geometry.Point3D;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.input.KeyCode;\nimport javafx.scene.input.KeyEvent;\nimport javafx.scene.shape.MeshView;\nimport javafx.scene.shape.TriangleMesh;\nimport javafx.scene.transform.Rotate;\nimport javafx.stage.Stage;\npublic class DeathStar extends Application {\n\n\tprivate static final int DIVISION = 200;\n\tfloat radius = 300;\n\n\t@Override\n\tpublic void start(Stage primaryStage) throws Exception {\n\t\tPoint3D otherSphere = new Point3D(-radius, 0, -radius * 1.5);\n\t\tfinal TriangleMesh triangleMesh = createMesh(DIVISION, radius, otherSphere);\n\t\tMeshView a = new MeshView(triangleMesh);\n\n\t\ta.setTranslateY(radius);\n\t\ta.setTranslateX(radius);\n\t\ta.setRotationAxis(Rotate.Y_AXIS);\n\t\tScene scene = new Scene(new Group(a));\n\n\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\t\tprimaryStage.setScene(scene);\n\t\tprimaryStage.show();\n\t}\n\n\tstatic TriangleMesh createMesh(final int division, final float radius, final Point3D centerOtherSphere) {\n\t\tRotate rotate = new Rotate(180, centerOtherSphere);\n\t\tfinal int div2 = division / 2;\n\n\t\tfinal int nPoints = division * (div2 - 1) + 2;\n\t\tfinal int nTPoints = (division + 1) * (div2 - 1) + division * 2;\n\t\tfinal int nFaces = division * (div2 - 2) * 2 + division * 2;\n\n\t\tfinal float rDiv = 1.f / division;\n\n\t\tfloat points[] = new float[nPoints * 3];\n\t\tfloat tPoints[] = new float[nTPoints * 2];\n\t\tint faces[] = new int[nFaces * 6];\n\n\t\tint pPos = 0, tPos = 0;\n\n\t\tfor (int y = 0; y < div2 - 1; ++y) {\n\t\t\tfloat va = rDiv * (y + 1 - div2 / 2) * 2 * (float) Math.PI;\n\t\t\tfloat sin_va = (float) Math.sin(va);\n\t\t\tfloat cos_va = (float) Math.cos(va);\n\n\t\t\tfloat ty = 0.5f + sin_va * 0.5f;\n\t\t\tfor (int i = 0; i < division; ++i) {\n\t\t\t\tdouble a = rDiv * i * 2 * (float) Math.PI;\n\t\t\t\tfloat hSin = (float) Math.sin(a);\n\t\t\t\tfloat hCos = (float) Math.cos(a);\n\t\t\t\tpoints[pPos + 0] = hSin * cos_va * radius;\n\t\t\t\tpoints[pPos + 2] = hCos * cos_va * radius;\n\t\t\t\tpoints[pPos + 1] = sin_va * radius;\n\n\t\t\t\tfinal Point3D point3D = new Point3D(points[pPos + 0], points[pPos + 1], points[pPos + 2]);\n\t\t\t\tdouble distance = centerOtherSphere.distance(point3D);\n\t\t\t\tif (distance <= radius) {\n\t\t\t\t\tPoint3D subtract = centerOtherSphere.subtract(point3D);\n\t\t\t\t\tPoint3D transform = rotate.transform(subtract);\n\t\t\t\t\tpoints[pPos + 0] = (float) transform.getX();\n\t\t\t\t\tpoints[pPos + 1] = (float) transform.getY();\n\t\t\t\t\tpoints[pPos + 2] = (float) transform.getZ();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\ttPoints[tPos + 0] = 1 - rDiv * i;\n\t\t\t\ttPoints[tPos + 1] = ty;\n\t\t\t\tpPos += 3;\n\t\t\t\ttPos += 2;\n\t\t\t}\n\t\t\ttPoints[tPos + 0] = 0;\n\t\t\ttPoints[tPos + 1] = ty;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tpoints[pPos + 0] = 0;\n\t\tpoints[pPos + 1] = -radius;\n\t\tpoints[pPos + 2] = 0;\n\t\tpoints[pPos + 3] = 0;\n\t\tpoints[pPos + 4] = radius;\n\t\tpoints[pPos + 5] = 0;\n\t\tpPos += 6;\n\n\t\tint pS = (div2 - 1) * division;\n\n\t\tfloat textureDelta = 1.f / 256;\n\t\tfor (int i = 0; i < division; ++i) {\n\t\t\ttPoints[tPos + 0] = rDiv * (0.5f + i);\n\t\t\ttPoints[tPos + 1] = textureDelta;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tfor (int i = 0; i < division; ++i) {\n\t\t\ttPoints[tPos + 0] = rDiv * (0.5f + i);\n\t\t\ttPoints[tPos + 1] = 1 - textureDelta;\n\t\t\ttPos += 2;\n\t\t}\n\n\t\tint fIndex = 0;\n\t\tfor (int y = 0; y < div2 - 2; ++y) {\n\t\t\tfor (int x = 0; x < division; ++x) {\n\t\t\t\tint p0 = y * division + x;\n\t\t\t\tint p1 = p0 + 1;\n\t\t\t\tint p2 = p0 + division;\n\t\t\t\tint p3 = p1 + division;\n\n\t\t\t\tint t0 = p0 + y;\n\t\t\t\tint t1 = t0 + 1;\n\t\t\t\tint t2 = t0 + division + 1;\n\t\t\t\tint t3 = t1 + division + 1;\n\n\t\t\t\t\n\t\t\t\tfaces[fIndex + 0] = p0;\n\t\t\t\tfaces[fIndex + 1] = t0;\n\t\t\t\tfaces[fIndex + 2] = p1 % division == 0 ? p1 - division : p1;\n\t\t\t\tfaces[fIndex + 3] = t1;\n\t\t\t\tfaces[fIndex + 4] = p2;\n\t\t\t\tfaces[fIndex + 5] = t2;\n\t\t\t\tfIndex += 6;\n\n\t\t\t\t\n\t\t\t\tfaces[fIndex + 0] = p3 % division == 0 ? p3 - division : p3;\n\t\t\t\tfaces[fIndex + 1] = t3;\n\t\t\t\tfaces[fIndex + 2] = p2;\n\t\t\t\tfaces[fIndex + 3] = t2;\n\t\t\t\tfaces[fIndex + 4] = p1 % division == 0 ? p1 - division : p1;\n\t\t\t\tfaces[fIndex + 5] = t1;\n\t\t\t\tfIndex += 6;\n\t\t\t}\n\t\t}\n\n\t\tint p0 = pS;\n\t\tint tB = (div2 - 1) * (division + 1);\n\t\tfor (int x = 0; x < division; ++x) {\n\t\t\tint p2 = x, p1 = x + 1, t0 = tB + x;\n\t\t\tfaces[fIndex + 0] = p0;\n\t\t\tfaces[fIndex + 1] = t0;\n\t\t\tfaces[fIndex + 2] = p1 == division ? 0 : p1;\n\t\t\tfaces[fIndex + 3] = p1;\n\t\t\tfaces[fIndex + 4] = p2;\n\t\t\tfaces[fIndex + 5] = p2;\n\t\t\tfIndex += 6;\n\t\t}\n\n\t\tp0 = p0 + 1;\n\t\ttB = tB + division;\n\t\tint pB = (div2 - 2) * division;\n\n\t\tfor (int x = 0; x < division; ++x) {\n\t\t\tint p1 = pB + x, p2 = pB + x + 1, t0 = tB + x;\n\t\t\tint t1 = (div2 - 2) * (division + 1) + x, t2 = t1 + 1;\n\t\t\tfaces[fIndex + 0] = p0;\n\t\t\tfaces[fIndex + 1] = t0;\n\t\t\tfaces[fIndex + 2] = p1;\n\t\t\tfaces[fIndex + 3] = t1;\n\t\t\tfaces[fIndex + 4] = p2 % division == 0 ? p2 - division : p2;\n\t\t\tfaces[fIndex + 5] = t2;\n\t\t\tfIndex += 6;\n\t\t}\n\n\t\tTriangleMesh m = new TriangleMesh();\n\t\tm.getPoints().setAll(points);\n\t\tm.getTexCoords().setAll(tPoints);\n\t\tm.getFaces().setAll(faces);\n\n\t\treturn m;\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tlaunch(args);\n\t}\n\n}\n"}
{"id": 349514, "name": "Colour pinstripe_Display", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse GD;\n\nmy %colors = (\n\"white\"   => [255,255,255], \"red\"    => [255,  0,  0], \"green\" => [  0,255,  0], \"blue\"  => [  0,  0,255],\n\"magenta\" => [255,  0,255], \"yellow\" => [255,255,  0], \"cyan\"  => [  0,255,255], \"black\" => [  0,  0,  0]);\n\nmy($height, $width) = (240, 320);\nmy $image = GD::Image->new( $width , $height );\n\nmy @paintcolors;\nmy $barheight = $height / 4;\nmy($startx, $starty, $run, $colorindex) = (0) x 4;\n\nfor my $color ( sort keys %colors ) {\n    push @paintcolors, $image->colorAllocate( @{$colors{ $color }} );\n}\n\nwhile ( $run < 4 ) {\n    my $barwidth =  $run + 1;\n    while ( $startx + $barwidth < $width ) {\n        $image->filledRectangle( $startx, $starty,\n                                 $startx + $barwidth,\n                                 $starty + $barheight - 1,\n                                 $paintcolors[ $colorindex % 8 ] );\n        $startx += $barwidth;\n        $colorindex++;\n    }\n    $starty    += $barheight;\n    $startx     = 0;\n    $colorindex = 0;\n    $run++;\n}\n\nopen ( DISPLAY , '>' , 'pinstripes.png' ) or die;\nbinmode DISPLAY;\nprint DISPLAY $image->png;\nclose DISPLAY;\n", "target": "import java.awt.*;\nimport static java.awt.Color.*;\nimport javax.swing.*;\n\npublic class ColourPinstripeDisplay extends JPanel {\n    final static Color[] palette = {black, red, green, blue, magenta,cyan,\n        yellow, white};\n\n    final int bands = 4;\n\n    public ColourPinstripeDisplay() {\n        setPreferredSize(new Dimension(900, 600));\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        int h = getHeight();\n        for (int b = 1; b <= bands; b++) {\n            for (int x = 0, colIndex = 0; x < getWidth(); x += b, colIndex++) {\n                g.setColor(palette[colIndex % palette.length]);\n                g.fillRect(x, (b - 1) * (h / bands), x + b, b * (h / bands));\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"ColourPinstripeDisplay\");\n            f.add(new ColourPinstripeDisplay(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 349515, "name": "Birthday problem", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse List::AllUtils qw(max min uniqnum count_by any);\nuse Math::Random qw(random_uniform_integer);\n\nsub simulation {\n    my($c) = shift;\n    my $max_trials = 1_000_000;\n    my $min_trials =    10_000;\n    my $n = int 47 * ($c-1.5)**1.5; \n    my $N = min $max_trials, max $min_trials, 1000 * sqrt $n;\n\n    while (1) {\n        my $yes = 0;\n        for (1..$N) {\n            my %birthday_freq = count_by { $_ } random_uniform_integer($n, 1, 365);\n            $yes++ if any { $birthday_freq{$_} >= $c } keys %birthday_freq;\n        }\n        my $p = $yes/$N;\n        return($n, $p) if $p > 0.5;\n        $N = min $max_trials, max $min_trials, int 1000/(0.5-$p)**1.75;\n        $n++;\n    }\n}\n\nprintf \"$_ people in a group of %s share a common birthday. (%.4f)\\n\", simulation($_) for 2..5\n", "target": "import static java.util.Arrays.stream;\nimport java.util.Random;\n\npublic class Test {\n\n    static double equalBirthdays(int nSharers, int groupSize, int nRepetitions) {\n        Random rand = new Random(1);\n\n        int eq = 0;\n\n        for (int i = 0; i < nRepetitions; i++) {\n            int[] group = new int[365];\n            for (int j = 0; j < groupSize; j++)\n                group[rand.nextInt(group.length)]++;\n            eq += stream(group).anyMatch(c -> c >= nSharers) ? 1 : 0;\n        }\n\n        return (eq * 100.0) / nRepetitions;\n    }\n\n    public static void main(String[] a) {\n\n        int groupEst = 2;\n\n        for (int sharers = 2; sharers < 6; sharers++) {\n            \n            int groupSize = groupEst + 1;\n            while (equalBirthdays(sharers, groupSize, 100) < 50.0)\n                groupSize++;\n\n            \n            int inf = (int) (groupSize - (groupSize - groupEst) / 4.0);\n            for (int gs = inf; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, groupSize, 250);\n                if (eq > 50.0) {\n                    groupSize = gs;\n                    break;\n                }\n            }\n\n            \n            for (int gs = groupSize - 1; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, gs, 50_000);\n                if (eq > 50.0) {\n                    groupEst = gs;\n                    System.out.printf(\"%d independent people in a group of \"\n                            + \"%s share a common birthday. (%5.1f)%n\",\n                            sharers, gs, eq);\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 349516, "name": "Draw a sphere", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $x = my $y = 255;\n$x |= 1; \nmy $depth = 255;\n\nmy $light = Vector->new(rand, rand, rand)->normalized;\n\nprint \"P2\\n$x $y\\n$depth\\n\";\n\nmy ($r, $ambient) = (($x - 1)/2, 0);\nmy ($r2) = $r ** 2;\n{\n    for my $x (-$r .. $r) {\n\tmy $x2 = $x**2;\n\tfor my $y (-$r .. $r) {\n\t    my $y2 = $y**2;\n\t    my $pixel = 0;\n\t    if ($x2 + $y2 < $r2) {\n\t\tmy $v = Vector->new($x, $y, sqrt($r2 - $x2 - $y2))->normalized;\n\t\tmy $I = $light . $v + $ambient;\n\t\t$I = $I < 0 ? 0 : $I > 1 ? 1 : $I;\n\t\t$pixel = int($I * $depth);\n\t    }\n\t    print $pixel;\n\t    print $y == $r ? \"\\n\" : \" \";\n\t}\n    }\n}\n\npackage Vector {\n    sub new {\n\tmy $class = shift;\n\tbless ref($_[0]) eq 'Array' ? $_[0] : [ @_ ], $class;\n    }\n    sub normalized {\n\tmy $this = shift;\n\tmy $norm = sqrt($this . $this);\n\tref($this)->new( map $_/$norm, @$this );\n    }\n    use overload q{.} => sub {\n\tmy ($a, $b) = @_;\n\tmy $sum = 0;\n\tfor (0 .. @$a - 1) {\n\t    $sum += $a->[$_] * $b->[$_]\n\t}\n\treturn $sum;\n    },\n    q{\"\"} => sub { sprintf \"Vector:[%s]\", join ' ', @{shift()} };\n}\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 349517, "name": "Draw a sphere", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $x = my $y = 255;\n$x |= 1; \nmy $depth = 255;\n\nmy $light = Vector->new(rand, rand, rand)->normalized;\n\nprint \"P2\\n$x $y\\n$depth\\n\";\n\nmy ($r, $ambient) = (($x - 1)/2, 0);\nmy ($r2) = $r ** 2;\n{\n    for my $x (-$r .. $r) {\n\tmy $x2 = $x**2;\n\tfor my $y (-$r .. $r) {\n\t    my $y2 = $y**2;\n\t    my $pixel = 0;\n\t    if ($x2 + $y2 < $r2) {\n\t\tmy $v = Vector->new($x, $y, sqrt($r2 - $x2 - $y2))->normalized;\n\t\tmy $I = $light . $v + $ambient;\n\t\t$I = $I < 0 ? 0 : $I > 1 ? 1 : $I;\n\t\t$pixel = int($I * $depth);\n\t    }\n\t    print $pixel;\n\t    print $y == $r ? \"\\n\" : \" \";\n\t}\n    }\n}\n\npackage Vector {\n    sub new {\n\tmy $class = shift;\n\tbless ref($_[0]) eq 'Array' ? $_[0] : [ @_ ], $class;\n    }\n    sub normalized {\n\tmy $this = shift;\n\tmy $norm = sqrt($this . $this);\n\tref($this)->new( map $_/$norm, @$this );\n    }\n    use overload q{.} => sub {\n\tmy ($a, $b) = @_;\n\tmy $sum = 0;\n\tfor (0 .. @$a - 1) {\n\t    $sum += $a->[$_] * $b->[$_]\n\t}\n\treturn $sum;\n    },\n    q{\"\"} => sub { sprintf \"Vector:[%s]\", join ' ', @{shift()} };\n}\n", "target": "using System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n"}
{"id": 349518, "name": "Thiele's interpolation formula", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Math::Trig;\nuse utf8;\n\nsub thiele {\n    my($x, $y) = @_;\n\n    my @\u03c1;\n    push @\u03c1, [($$y[$_]) x (@$y-$_)] for 0 .. @$y-1;\n    for my $i (0 .. @\u03c1 - 2) {\n        $\u03c1[$i][1] = (($$x[$i] - $$x[$i+1]) / ($\u03c1[$i][0] - $\u03c1[$i+1][0]))\n    }\n    for my $i (2 .. @\u03c1 - 2) {\n        for my $j (0 .. (@\u03c1 - 2) - $i) {\n            $\u03c1[$j][$i] = ((($$x[$j]-$$x[$j+$i]) / ($\u03c1[$j][$i-1]-$\u03c1[$j+1][$i-1])) + $\u03c1[$j+1][$i-2])\n        }\n    }\n    my @\u03c10 = @{$\u03c1[0]};\n\n    return sub {\n        my($xin) = @_;\n\n        my $a = 0;\n        for my $i (reverse 2 .. @\u03c10 - 2) {\n            $a = (($xin - $$x[$i-1]) / ($\u03c10[$i] - $\u03c10[$i-2] + $a))\n        }\n        $$y[0] + (($xin - $$x[0]) / ($\u03c10[1] + $a))\n    }\n}\n\nmy(@x,@sin_table,@cos_table,@tan_table);\npush @x,  .05 * $_ for 0..31;\npush @sin_table, sin($_) for @x;\npush @cos_table, cos($_) for @x;\npush @tan_table, tan($_) for @x;\n\nmy $sin_inverse = thiele(\\@sin_table, \\@x);\nmy $cos_inverse = thiele(\\@cos_table, \\@x);\nmy $tan_inverse = thiele(\\@tan_table, \\@x);\n\nsay 6 * &$sin_inverse(0.5);\nsay 3 * &$cos_inverse(0.5);\nsay 4 * &$tan_inverse(1.0);\n", "target": "import static java.lang.Math.*;\n\npublic class Test {\n    final static int N = 32;\n    final static int N2 = (N * (N - 1) / 2);\n    final static double STEP = 0.05;\n\n    static double[] xval = new double[N];\n    static double[] t_sin = new double[N];\n    static double[] t_cos = new double[N];\n    static double[] t_tan = new double[N];\n\n    static double[] r_sin = new double[N2];\n    static double[] r_cos = new double[N2];\n    static double[] r_tan = new double[N2];\n\n    static double rho(double[] x, double[] y, double[] r, int i, int n) {\n        if (n < 0)\n            return 0;\n\n        if (n == 0)\n            return y[i];\n\n        int idx = (N - 1 - n) * (N - n) / 2 + i;\n        if (r[idx] != r[idx])\n            r[idx] = (x[i] - x[i + n])\n                    / (rho(x, y, r, i, n - 1) - rho(x, y, r, i + 1, n - 1))\n                    + rho(x, y, r, i + 1, n - 2);\n\n        return r[idx];\n    }\n\n    static double thiele(double[] x, double[] y, double[] r, double xin, int n) {\n        if (n > N - 1)\n            return 1;\n        return rho(x, y, r, 0, n) - rho(x, y, r, 0, n - 2)\n                + (xin - x[n]) / thiele(x, y, r, xin, n + 1);\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i < N; i++) {\n            xval[i] = i * STEP;\n            t_sin[i] = sin(xval[i]);\n            t_cos[i] = cos(xval[i]);\n            t_tan[i] = t_sin[i] / t_cos[i];\n        }\n\n        for (int i = 0; i < N2; i++)\n            r_sin[i] = r_cos[i] = r_tan[i] = Double.NaN;\n\n        System.out.printf(\"%16.14f%n\", 6 * thiele(t_sin, xval, r_sin, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 3 * thiele(t_cos, xval, r_cos, 0.5, 0));\n        System.out.printf(\"%16.14f%n\", 4 * thiele(t_tan, xval, r_tan, 1.0, 0));\n    }\n}\n"}
{"id": 349519, "name": "Longest string challenge", "source": "Translate Perl to Java: \nEND{ print $all }\n\nsubstr($_, length($l)) and $all = $l = $_\n\tor substr($l, length) or $all .= $_;\n", "target": "import java.io.File;\nimport java.util.Scanner;\n\npublic class LongestStringChallenge {\n\n    public static void main(String[] args) throws Exception {\n        String lines = \"\", longest = \"\";\n        try (Scanner sc = new Scanner(new File(\"lines.txt\"))) {\n            while(sc.hasNext()) {\n                String line = sc.nextLine();\n                if (longer(longest, line))\n                    lines = longest = line;\n                else if (!longer(line, longest))\n                    lines = lines.concat(\"\\n\").concat(line);\n            }\n        }\n        System.out.println(lines);\n    }\n\n    static boolean longer(String a, String b) {\n        try {\n            String dummy = a.substring(b.length());\n        } catch (StringIndexOutOfBoundsException e) {\n            return true;\n        }\n        return false;\n    }\n}\n"}
{"id": 349520, "name": "Sierpinski arrowhead curve", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse SVG;\nuse List::Util qw(max min);\nuse constant pi => 2 * atan2(1, 0);\n\nmy %rules = (\n    X => 'YF+XF+Y',\n    Y => 'XF-YF-X'\n);\nmy $S = 'Y';\n$S =~ s/([XY])/$rules{$1}/eg for 1..7;\n\nmy (@X, @Y);\nmy ($x, $y) = (0, 0);\nmy $theta   = 0;\nmy $r       = 6;\n\nfor (split //, $S) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/3; }\n    elsif (/\\-/) { $theta -= pi/3; }\n}\n\nmy ($xrng, $yrng) = ( max(@X) - min(@X),  max(@Y) - min(@Y));\nmy ($xt,   $yt)   = (-min(@X) + 10,      -min(@Y) + 10);\n\nmy $svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\nmy $points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen my $fh, '>', 'sierpinski-arrowhead-curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "final PVector t = new PVector(20, 30, 60);\n\nvoid setup() {\n  size(450, 400);\n  noLoop();\n  background(0, 0, 200);\n  stroke(-1);\n  sc(7, 400, -60, t);\n}\n\nPVector sc(int o, float l, final int a, final PVector s) {\n  if (o > 0) {\n    sc(--o, l *= .5, -a, s).z += a;\n    sc(o, l, a, s).z += a;\n    sc(o, l, -a, s);\n  } else line(s.x, s.y, \n    s.x += cos(radians(s.z)) * l, \n    s.y += sin(radians(s.z)) * l);\n  return s;\n}\n"}
{"id": 349521, "name": "Hello world_Line printer", "source": "Translate Perl to Java: open O, \">\", \"/dev/lp0\";\nprint O \"Hello World!\\n\";\nclose O;\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 349522, "name": "Hello world_Line printer", "source": "Translate Perl to Java: open O, \">\", \"/dev/lp0\";\nprint O \"Hello World!\\n\";\nclose O;\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 349523, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nsub intersection {\n    my($L11, $L12, $L21, $L22) = @_;\n    my ($d1x, $d1y) = ($$L11[0] - $$L12[0], $$L11[1] - $$L12[1]);\n    my ($d2x, $d2y) = ($$L21[0] - $$L22[0], $$L21[1] - $$L22[1]);\n    my $n1 = $$L11[0] * $$L12[1] - $$L11[1] * $$L12[0];\n    my $n2 = $$L21[0] * $$L22[1] - $$L21[1] * $$L22[0];\n    my $n3 = 1 / ($d1x * $d2y - $d2x * $d1y);\n    [($n1 * $d2x - $n2 * $d1x) * $n3, ($n1 * $d2y - $n2 * $d1y) * $n3]\n}\n\nsub is_inside {\n    my($p1, $p2, $p3) = @_;\n    ($$p2[0] - $$p1[0]) * ($$p3[1] - $$p1[1]) > ($$p2[1] - $$p1[1]) * ($$p3[0] - $$p1[0])\n}\n\nsub sutherland_hodgman {\n    my($polygon, $clip) = @_;\n    my @output = @$polygon;\n    my $clip_point1 = $$clip[-1];\n    for my $clip_point2 (@$clip) {\n        my @input = @output;\n        @output = ();\n        my $start = $input[-1];\n        for my $end (@input) {\n            if (is_inside($clip_point1, $clip_point2, $end)) {\n                push @output, intersection($clip_point1, $clip_point2, $start, $end)\n                  unless is_inside($clip_point1, $clip_point2, $start);\n                push @output, $end;\n            } elsif (is_inside($clip_point1, $clip_point2, $start)) {\n                push @output, intersection($clip_point1, $clip_point2, $start, $end);\n            }\n            $start = $end;\n        }\n        $clip_point1 = $clip_point2;\n    }\n    @output\n}\n\nmy @polygon = ([50,  150], [200, 50],  [350, 150], [350, 300], [250, 300],\n              [200, 250], [150, 350], [100, 250], [100, 200]);\n\nmy @clip    = ([100, 100], [300, 100], [300, 300], [100, 300]);\n\nmy @clipped = sutherland_hodgman(\\@polygon, \\@clip);\n\nprint \"Clipped polygon:\\n\";\nprint '(' . join(' ', @$_) . ') ' for @clipped;\n", "target": "import java.awt.*;\nimport java.awt.geom.Line2D;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\n\npublic class SutherlandHodgman extends JFrame {\n\n    SutherlandHodgmanPanel panel;\n\n    public static void main(String[] args) {\n        JFrame f = new SutherlandHodgman();\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setVisible(true);\n    }\n\n    public SutherlandHodgman() {\n        Container content = getContentPane();\n        content.setLayout(new BorderLayout());\n        panel = new SutherlandHodgmanPanel();\n        content.add(panel, BorderLayout.CENTER);\n        setTitle(\"SutherlandHodgman\");\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n\nclass SutherlandHodgmanPanel extends JPanel {\n    List<double[]> subject, clipper, result;\n\n    public SutherlandHodgmanPanel() {\n        setPreferredSize(new Dimension(600, 500));\n\n        \n        double[][] subjPoints = {{50, 150}, {200, 50}, {350, 150}, {350, 300},\n        {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}};\n\n        double[][] clipPoints = {{100, 100}, {300, 100}, {300, 300}, {100, 300}};\n\n        subject = new ArrayList<>(Arrays.asList(subjPoints));\n        result  = new ArrayList<>(subject);\n        clipper = new ArrayList<>(Arrays.asList(clipPoints));\n\n        clipPolygon();\n    }\n\n    private void clipPolygon() {\n        int len = clipper.size();\n        for (int i = 0; i < len; i++) {\n\n            int len2 = result.size();\n            List<double[]> input = result;\n            result = new ArrayList<>(len2);\n\n            double[] A = clipper.get((i + len - 1) % len);\n            double[] B = clipper.get(i);\n\n            for (int j = 0; j < len2; j++) {\n\n                double[] P = input.get((j + len2 - 1) % len2);\n                double[] Q = input.get(j);\n\n                if (isInside(A, B, Q)) {\n                    if (!isInside(A, B, P))\n                        result.add(intersection(A, B, P, Q));\n                    result.add(Q);\n                } else if (isInside(A, B, P))\n                    result.add(intersection(A, B, P, Q));\n            }\n        }\n    }\n\n    private boolean isInside(double[] a, double[] b, double[] c) {\n        return (a[0] - c[0]) * (b[1] - c[1]) > (a[1] - c[1]) * (b[0] - c[0]);\n    }\n\n    private double[] intersection(double[] a, double[] b, double[] p, double[] q) {\n        double A1 = b[1] - a[1];\n        double B1 = a[0] - b[0];\n        double C1 = A1 * a[0] + B1 * a[1];\n\n        double A2 = q[1] - p[1];\n        double B2 = p[0] - q[0];\n        double C2 = A2 * p[0] + B2 * p[1];\n\n        double det = A1 * B2 - A2 * B1;\n        double x = (B2 * C1 - B1 * C2) / det;\n        double y = (A1 * C2 - A2 * C1) / det;\n\n        return new double[]{x, y};\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        g2.translate(80, 60);\n        g2.setStroke(new BasicStroke(3));\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPolygon(g2, subject, Color.blue);\n        drawPolygon(g2, clipper, Color.red);\n        drawPolygon(g2, result, Color.green);\n    }\n\n    private void drawPolygon(Graphics2D g2, List<double[]> points, Color color) {\n        g2.setColor(color);\n        int len = points.size();\n        Line2D line = new Line2D.Double();\n        for (int i = 0; i < len; i++) {\n            double[] p1 = points.get(i);\n            double[] p2 = points.get((i + 1) % len);\n            line.setLine(p1[0], p1[1], p2[0], p2[1]);\n            g2.draw(line);\n        }\n    }\n}\n"}
{"id": 349524, "name": "Sorting algorithms_Pancake sort", "source": "Translate Perl to Java: sub pancake {\n        my @x = @_;\n        for my $idx (0 .. $\n                my $min = $idx;\n                $x[$min] > $x[$_] and $min = $_           for $idx + 1 .. $\n\n                next if $x[$min] == $x[$idx];\n\n                @x[$min .. $\n                @x[$idx .. $\n        }\n        @x;\n}\n\nmy @a = map (int rand(100), 1 .. 10);\nprint \"Before @a\\n\";\n@a = pancake(@a);\nprint \"After  @a\\n\";\n", "target": "public class PancakeSort\n{\n   int[] heap;\n\n   public String toString() {\n      String info = \"\";\n      for (int x: heap)\n         info += x + \" \";\n      return info;\n   }\n    \n   public void flip(int n) {\n      for (int i = 0; i < (n+1) / 2; ++i) {\n         int tmp = heap[i];\n         heap[i] = heap[n-i];\n         heap[n-i] = tmp;\n      }      \n      System.out.println(\"flip(0..\" + n + \"): \" + toString());\n   }\n   \n   public int[] minmax(int n) {\n      int xm, xM;\n      xm = xM = heap[0];\n      int posm = 0, posM = 0;\n      \n      for (int i = 1; i < n; ++i) {\n         if (heap[i] < xm) {\n            xm = heap[i];\n            posm = i;\n         }\n         else if (heap[i] > xM) {\n            xM = heap[i];\n            posM = i;\n         }\n      }\n      return new int[] {posm, posM};\n   }\n   \n   public void sort(int n, int dir) {\n      if (n == 0) return;\n         \n      int[] mM = minmax(n);\n      int bestXPos = mM[dir];\n      int altXPos = mM[1-dir];\n      boolean flipped = false;\n      \n      if (bestXPos == n-1) {\n         --n;\n      }\n      else if (bestXPos == 0) {\n         flip(n-1);\n         --n;\n      }\n      else if (altXPos == n-1) {\n         dir = 1-dir;\n         --n;\n         flipped = true;\n      }\n      else {\n         flip(bestXPos);\n      }\n      sort(n, dir);\n\n      if (flipped) {\n         flip(n);\n      }\n   }\n   \n   PancakeSort(int[] numbers) {\n      heap = numbers;\n      sort(numbers.length, 1);\n   } \n \n   public static void main(String[] args) {\n      int[] numbers = new int[args.length];\n      for (int i = 0; i < args.length; ++i)\n         numbers[i] = Integer.valueOf(args[i]);\n\n      PancakeSort pancakes = new PancakeSort(numbers);\n      System.out.println(pancakes);\n   }\n}\n"}
{"id": 349525, "name": "Call a function", "source": "Translate Perl to Java: foo();              \n&foo();             \nfoo($arg1, $arg2);  \n&foo($arg1, $arg2); \n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 349526, "name": "Call a function", "source": "Translate Perl to Java: foo();              \n&foo();             \nfoo($arg1, $arg2);  \n&foo($arg1, $arg2); \n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 349527, "name": "Extract file extension", "source": "Translate Perl to Java: sub extension {\n    my $path = shift;\n    $path =~ / \\. [a-z0-9]+ $ /xi;\n    $& // '';\n}\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 349528, "name": "Extract file extension", "source": "Translate Perl to Java: sub extension {\n    my $path = shift;\n    $path =~ / \\. [a-z0-9]+ $ /xi;\n    $& // '';\n}\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 349529, "name": "Solve the no connection puzzle", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nmy $gap = qr/.{3}/s;\n\nfind( <<terminator );\n-AB-\nCDEF\n-GH-\nterminator\n\nsub find\n  {\n  my $p = shift;\n  $p =~ /(\\d)$gap.{0,2}(\\d)(??{abs $1 - $2 <= 1\u00a0? ''\u00a0: '(*F)'})/ ||\n    $p =~ /^.*\\n.*(\\d)(\\d)(??{abs $1 - $2 <= 1\u00a0? ''\u00a0: '(*F)'})/ and return;\n  if( $p =~ /[A-H]/ )\n    {\n    find( $p =~ s/[A-H]/$_/r ) for grep $p !~ $_, 1 .. 8;\n    }\n  else\n    {\n    print $p =~ tr/-/ /r;\n    exit;\n    }\n  }\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class NoConnection {\n\n    \n    static int[][] links = {\n        {2, 3, 4}, \n        {3, 4, 5}, \n        {2, 4},    \n        {5},       \n        {2, 3, 4}, \n        {3, 4, 5}, \n    };\n\n    static int[] pegs = new int[8];\n\n    public static void main(String[] args) {\n\n        List<Integer> vals = range(1, 9).mapToObj(i -> i).collect(toList());\n        do {\n            Collections.shuffle(vals);\n            for (int i = 0; i < pegs.length; i++)\n                pegs[i] = vals.get(i);\n\n        } while (!solved());\n\n        printResult();\n    }\n\n    static boolean solved() {\n        for (int i = 0; i < links.length; i++)\n            for (int peg : links[i])\n                if (abs(pegs[i] - peg) == 1)\n                    return false;\n        return true;\n    }\n\n    static void printResult() {\n        System.out.printf(\"  %s %s%n\", pegs[0], pegs[1]);\n        System.out.printf(\"%s %s %s %s%n\", pegs[2], pegs[3], pegs[4], pegs[5]);\n        System.out.printf(\"  %s %s%n\", pegs[6], pegs[7]);\n    }\n}\n"}
{"id": 349530, "name": "Permutation test", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\n\nuse List::Util qw{ sum };\n\n\nsub means {\n    my @groups = @_;\n    return map sum(@$_) / @$_, @groups;\n}\n\n\nsub following {\n    my $pattern    = shift;\n    my $orig_count = grep $_, @$pattern;\n    my $count;\n    do {\n        my $i = $\n        until (0 > $i) {\n            $pattern->[$i] = $pattern->[$i] ? 0 : 1;\n            last if $pattern->[$i];\n            --$i;\n        }\n        $count = grep $_, @$pattern;\n    } until $count == $orig_count or not $count;\n    undef @$pattern unless $count;\n}\n\n\nmy @groups;\nmy $i = 0;\nwhile (<DATA>) {\n    chomp;\n    $i++, next if /^$/;\n    push @{ $groups[$i] }, $_;\n}\n\nmy @orig_means = means(@groups);\nmy $orig_cmp   = $orig_means[0] - $orig_means[1];\n\nmy $pattern = [ (0) x @{ $groups[0] },\n                (1) x @{ $groups[1] }\n              ];\n\nmy @cmp = (0) x 3;\nwhile (@$pattern) {\n    my @perms = map { my $g = $_;\n                      [ (@{ $groups[0] }, @{ $groups[1] } ) [ grep $pattern->[$_] == $g, 0 .. $\n                  } 0, 1;\n    my @means = means(@perms);\n    $cmp[ ($means[0] - $means[1]) <=> $orig_cmp ]++;\n} continue {\n    following($pattern);\n}\nmy $all    = sum(@cmp);\nmy $length = length $all;\nfor (0, -1, 1) {\n    printf \"%-7s\u00a0%${length}d %6.3f%%\\n\",\n        (qw(equal greater less))[$_], $cmp[$_], 100 * $cmp[$_] / $all;\n}\n\n\n", "target": "public class PermutationTest {\n    private static final int[] data = new int[]{\n        85, 88, 75, 66, 25, 29, 83, 39, 97,\n        68, 41, 10, 49, 16, 65, 32, 92, 28, 98\n    };\n\n    private static int pick(int at, int remain, int accu, int treat) {\n        if (remain == 0) return (accu > treat) ? 1 : 0;\n        return pick(at - 1, remain - 1, accu + data[at - 1], treat)\n            + ((at > remain) ? pick(at - 1, remain, accu, treat) : 0);\n    }\n\n    public static void main(String[] args) {\n        int treat = 0;\n        double total = 1.0;\n        for (int i = 0; i <= 8; ++i) {\n            treat += data[i];\n        }\n        for (int i = 19; i >= 11; --i) {\n            total *= i;\n        }\n        for (int i = 9; i >= 1; --i) {\n            total /= i;\n        }\n        int gt = pick(19, 9, 0, treat);\n        int le = (int) (total - gt);\n        System.out.printf(\"<=\u00a0: %f%%  %d\\n\", 100.0 * le / total, le);\n        System.out.printf(\" >\u00a0: %f%%  %d\\n\", 100.0 * gt / total, gt);\n    }\n}\n"}
{"id": 349531, "name": "Image convolution", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nuse PDL;\nuse PDL::Image2D;\n\nmy $kernel = pdl [[-2, -1, 0],[-1, 1, 1], [0, 1, 2]]; \n\nmy $image = rpic 'pythagoras_tree.png';\nmy $smoothed = conv2d $image, $kernel, {Boundary => 'Truncate'};\nwpic $smoothed, 'pythagoras_convolution.png';\n", "target": "import java.awt.image.*;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.*;\n\npublic class ImageConvolution\n{\n  public static class ArrayData\n  {\n    public final int[] dataArray;\n    public final int width;\n    public final int height;\n    \n    public ArrayData(int width, int height)\n    {\n      this(new int[width * height], width, height);\n    }\n    \n    public ArrayData(int[] dataArray, int width, int height)\n    {\n      this.dataArray = dataArray;\n      this.width = width;\n      this.height = height;\n    }\n    \n    public int get(int x, int y)\n    {  return dataArray[y * width + x];  }\n    \n    public void set(int x, int y, int value)\n    {  dataArray[y * width + x] = value;  }\n  }\n  \n  private static int bound(int value, int endIndex)\n  {\n    if (value < 0)\n      return 0;\n    if (value < endIndex)\n      return value;\n    return endIndex - 1;\n  }\n  \n  public static ArrayData convolute(ArrayData inputData, ArrayData kernel, int kernelDivisor)\n  {\n    int inputWidth = inputData.width;\n    int inputHeight = inputData.height;\n    int kernelWidth = kernel.width;\n    int kernelHeight = kernel.height;\n    if ((kernelWidth <= 0) || ((kernelWidth & 1) != 1))\n      throw new IllegalArgumentException(\"Kernel must have odd width\");\n    if ((kernelHeight <= 0) || ((kernelHeight & 1) != 1))\n      throw new IllegalArgumentException(\"Kernel must have odd height\");\n    int kernelWidthRadius = kernelWidth >>> 1;\n    int kernelHeightRadius = kernelHeight >>> 1;\n    \n    ArrayData outputData = new ArrayData(inputWidth, inputHeight);\n    for (int i = inputWidth - 1; i >= 0; i--)\n    {\n      for (int j = inputHeight - 1; j >= 0; j--)\n      {\n        double newValue = 0.0;\n        for (int kw = kernelWidth - 1; kw >= 0; kw--)\n          for (int kh = kernelHeight - 1; kh >= 0; kh--)\n            newValue += kernel.get(kw, kh) * inputData.get(\n                          bound(i + kw - kernelWidthRadius, inputWidth),\n                          bound(j + kh - kernelHeightRadius, inputHeight));\n        outputData.set(i, j, (int)Math.round(newValue / kernelDivisor));\n      }\n    }\n    return outputData;\n  }\n  \n  public static ArrayData[] getArrayDatasFromImage(String filename) throws IOException\n  {\n    BufferedImage inputImage = ImageIO.read(new File(filename));\n    int width = inputImage.getWidth();\n    int height = inputImage.getHeight();\n    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);\n    ArrayData reds = new ArrayData(width, height);\n    ArrayData greens = new ArrayData(width, height);\n    ArrayData blues = new ArrayData(width, height);\n    for (int y = 0; y < height; y++)\n    {\n      for (int x = 0; x < width; x++)\n      {\n        int rgbValue = rgbData[y * width + x];\n        reds.set(x, y, (rgbValue >>> 16) & 0xFF);\n        greens.set(x, y, (rgbValue >>> 8) & 0xFF);\n        blues.set(x, y, rgbValue & 0xFF);\n      }\n    }\n    return new ArrayData[] { reds, greens, blues };\n  }\n  \n  public static void writeOutputImage(String filename, ArrayData[] redGreenBlue) throws IOException\n  {\n    ArrayData reds = redGreenBlue[0];\n    ArrayData greens = redGreenBlue[1];\n    ArrayData blues = redGreenBlue[2];\n    BufferedImage outputImage = new BufferedImage(reds.width, reds.height,\n                                                  BufferedImage.TYPE_INT_ARGB);\n    for (int y = 0; y < reds.height; y++)\n    {\n      for (int x = 0; x < reds.width; x++)\n      {\n        int red = bound(reds.get(x, y), 256);\n        int green = bound(greens.get(x, y), 256);\n        int blue = bound(blues.get(x, y), 256);\n        outputImage.setRGB(x, y, (red << 16) | (green << 8) | blue | -0x01000000);\n      }\n    }\n    ImageIO.write(outputImage, \"PNG\", new File(filename));\n    return;\n  }\n  \n  public static void main(String[] args) throws IOException\n  {\n    int kernelWidth = Integer.parseInt(args[2]);\n    int kernelHeight = Integer.parseInt(args[3]);\n    int kernelDivisor = Integer.parseInt(args[4]);\n    System.out.println(\"Kernel size: \" + kernelWidth + \"x\" + kernelHeight +\n                       \", divisor=\" + kernelDivisor);\n    int y = 5;\n    ArrayData kernel = new ArrayData(kernelWidth, kernelHeight);\n    for (int i = 0; i < kernelHeight; i++)\n    {\n      System.out.print(\"[\");\n      for (int j = 0; j < kernelWidth; j++)\n      {\n        kernel.set(j, i, Integer.parseInt(args[y++]));\n        System.out.print(\" \" + kernel.get(j, i) + \" \");\n      }\n      System.out.println(\"]\");\n    }\n    \n    ArrayData[] dataArrays = getArrayDatasFromImage(args[0]);\n    for (int i = 0; i < dataArrays.length; i++)\n      dataArrays[i] = convolute(dataArrays[i], kernel, kernelDivisor);\n    writeOutputImage(args[1], dataArrays);\n    return;\n  }\n}\n"}
{"id": 349532, "name": "Compiler_lexical analyzer", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\nno warnings 'once';\n\n\n\n\nmy @tokens = (\n    \n    \n    ['Op_multiply'    , '*'                  ,             ],\n    ['Op_divide'      , '/'                  ,             ],\n    ['Op_mod'         , '%'                  ,             ],\n    ['Op_add'         , '+'                  ,             ],\n    ['Op_subtract'    , '-'                  ,             ],\n    ['Op_lessequal'   , '<='                 ,             ],\n    ['Op_less'        , '<'                  ,             ],\n    ['Op_greaterequal', '>='                 ,             ],\n    ['Op_greater'     , '>'                  ,             ],\n    ['Op_equal'       , '=='                 ,             ],\n    ['Op_assign'      , '='                  ,             ],\n    ['Op_not'         , '!'                  ,             ],\n    ['Op_notequal'    , '!='                 ,             ],\n    ['Op_and'         , '&&'                 ,             ],\n    ['Op_or'          , '||'                 ,             ],\n    ['Keyword_else'   , qr/else\\b/           ,             ],\n    ['Keyword_if'     , qr/if\\b/             ,             ],\n    ['Keyword_while'  , qr/while\\b/          ,             ],\n    ['Keyword_print'  , qr/print\\b/          ,             ],\n    ['Keyword_putc'   , qr/putc\\b/           ,             ],\n\n    ['LeftParen'      , '('                  ,             ],\n    ['RightParen'     , ')'                  ,             ],\n    ['LeftBrace'      , '{'                  ,             ],\n    ['RightBrace'     , '}'                  ,             ],\n    ['Semicolon'      , ';'                  ,             ],\n    ['Comma'          , ','                  ,             ],\n\n    ['Identifier'     , qr/[_a-z][_a-z0-9]*/i, \\&raw       ],\n    ['Integer'        , qr/[0-9]+\\b/         , \\&raw       ],\n    ['Integer'        , qr/'([^']*)(')?/     , \\&char_val  ],\n    ['String'         , qr/\"([^\"]*)(\")?/     , \\&string_raw],\n\n    ['End_of_input'   , qr/$/                ,             ],\n);\n\nmy $comment = qr/\\/\\* .+? (?: \\*\\/ | $ (?{die \"End-of-file in comment\\n\"}) )/xs;\nmy $whitespace = qr/(?: \\s | $comment)*/x;\nmy $unrecognized = qr/\\w+ | ./x;\n\n\nsub char_val {\n    my $str = string_val();\n    die \"Multiple characters\\n\" if length $str > 1;\n    die \"No character\\n\"        if length $str == 0;\n    ord $str;\n}\n\n\nsub string_val {\n    my ($str, $end) = ($1, $2);\n    die \"End-of-file\\n\" if not defined $end;\n    die \"End-of-line\\n\" if $str =~ /\\n/;\n    $str =~ s/\\\\(.)/\n          $1 eq 'n' \u00a0? \"\\n\"\n       \u00a0: $1 eq '\\\\'\u00a0? $1\n       \u00a0: $1 eq $end\u00a0? $1\n       \u00a0: die \"Unknown escape sequence \\\\$1\\n\"\n    /rge;\n}\n\n\nsub raw { $& }\n\n\nsub string_raw {\n    string_val(); \n    $&;\n}\n\n\n\n\n\n\nmy $tokens =\n    join \"|\",\n    map {\n        my $format = $tokens[$_][1];\n        \"\\n\".(ref $format ? $format : quotemeta $format).\" (*MARK:$_) \";\n    } 0..$\n\nmy $regex = qr/\n    \\G (?| $whitespace  \\K (?| $tokens )\n         | $whitespace? \\K ($unrecognized) (*MARK:!) )\n/x;\n\n\n\n\nmy $input = do { local $/ = undef; <STDIN> };\nmy $pos = 0;\nmy $linecol = linecol_accumulator();\n\nwhile ($input =~ /$regex/g) {\n    \n    my ($line, $col) = $linecol->(substr $input, $pos, $-[0] - $pos);\n    $pos = $-[0];\n\n    \n    my $type = $main::REGMARK;\n    die \"Unrecognized token $1 at line $line, col $col\\n\" if $type eq '!';\n    my ($name, $evaluator) = @{$tokens[$type]}[0, 2];\n\n    \n    my $value;\n    if ($evaluator) {\n        eval { $value = $evaluator->() };\n        if ($@) { chomp $@; die \"$@ in $name at line $line, col $col\\n\" }\n    }\n\n    \n    print \"$line\\t$col\\t$name\".($value ? \"\\t$value\" : '').\"\\n\";\n}\n\n\n\nsub linecol_accumulator {\n    my ($line, $col) = (1, 1);\n    sub {\n        my $str = shift;\n        my @lines = split \"\\n\", $str, -1;\n        my ($l, $c) = @lines ? (@lines - 1, length $lines[-1]) : (0, 0);\n        if ($l) { $line += $l;  $col = 1 + $c }\n        else    { $col += $c }\n        ($line, $col)\n    }\n}\n", "target": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Lexer {\n    private int line;\n    private int pos;\n    private int position;\n    private char chr;\n    private String s;\n    \n    Map<String, TokenType> keywords = new HashMap<>();\n    \n    static class Token {\n        public TokenType tokentype;\n        public String value;\n        public int line;\n        public int pos;\n        Token(TokenType token, String value, int line, int pos) {\n            this.tokentype = token; this.value = value; this.line = line; this.pos = pos;\n        }\n        @Override\n        public String toString() {\n            String result = String.format(\"%5d  %5d\u00a0%-15s\", this.line, this.pos, this.tokentype);\n            switch (this.tokentype) {\n                case Integer:\n                    result += String.format(\"  %4s\", value);\n                    break;\n                case Identifier:\n                    result += String.format(\" %s\", value);\n                    break;\n                case String:\n                    result += String.format(\" \\\"%s\\\"\", value);\n                    break;\n            }\n            return result;\n        }\n    }\n    \n    static enum TokenType {\n        End_of_input, Op_multiply,  Op_divide, Op_mod, Op_add, Op_subtract,\n        Op_negate, Op_not, Op_less, Op_lessequal, Op_greater, Op_greaterequal,\n        Op_equal, Op_notequal, Op_assign, Op_and, Op_or, Keyword_if,\n        Keyword_else, Keyword_while, Keyword_print, Keyword_putc, LeftParen, RightParen,\n        LeftBrace, RightBrace, Semicolon, Comma, Identifier, Integer, String\n    }\n    \n    static void error(int line, int pos, String msg) {\n        if (line > 0 && pos > 0) {\n            System.out.printf(\"%s in line %d, pos %d\\n\", msg, line, pos);\n        } else {\n            System.out.println(msg);\n        }\n        System.exit(1);\n    }\n\n    Lexer(String source) {\n        this.line = 1;\n        this.pos = 0;\n        this.position = 0;\n        this.s = source;\n        this.chr = this.s.charAt(0);\n        this.keywords.put(\"if\", TokenType.Keyword_if);\n        this.keywords.put(\"else\", TokenType.Keyword_else);\n        this.keywords.put(\"print\", TokenType.Keyword_print);\n        this.keywords.put(\"putc\", TokenType.Keyword_putc);\n        this.keywords.put(\"while\", TokenType.Keyword_while);\n        \n    }\n    Token follow(char expect, TokenType ifyes, TokenType ifno, int line, int pos) {\n        if (getNextChar() == expect) {\n            getNextChar();\n            return new Token(ifyes, \"\", line, pos);\n        }\n        if (ifno == TokenType.End_of_input) {\n            error(line, pos, String.format(\"follow: unrecognized character: (%d) '%c'\", (int)this.chr, this.chr));\n        }\n        return new Token(ifno, \"\", line, pos);\n    }\n    Token char_lit(int line, int pos) {\n        char c = getNextChar(); \n        int n = (int)c;\n        if (c == '\\'') {\n            error(line, pos, \"empty character constant\");\n        } else if (c == '\\\\') {\n            c = getNextChar();\n            if (c == 'n') {\n                n = 10;\n            } else if (c == '\\\\') {\n                n = '\\\\';\n            } else {\n                error(line, pos, String.format(\"unknown escape sequence \\\\%c\", c));\n            }\n        }\n        if (getNextChar() != '\\'') {\n            error(line, pos, \"multi-character constant\");\n        }\n        getNextChar();\n        return new Token(TokenType.Integer, \"\" + n, line, pos);\n    }\n    Token string_lit(char start, int line, int pos) {\n        String result = \"\";\n        while (getNextChar() != start) {\n            if (this.chr == '\\u0000') {\n                error(line, pos, \"EOF while scanning string literal\");\n            }\n            if (this.chr == '\\n') {\n                error(line, pos, \"EOL while scanning string literal\");\n            }\n            result += this.chr;\n        }\n        getNextChar();\n        return new Token(TokenType.String, result, line, pos);\n    }\n    Token div_or_comment(int line, int pos) {\n        if (getNextChar() != '*') {\n            return new Token(TokenType.Op_divide, \"\", line, pos);\n        }\n        getNextChar();\n        while (true) { \n            if (this.chr == '\\u0000') {\n                error(line, pos, \"EOF in comment\");\n            } else if (this.chr == '*') {\n                if (getNextChar() == '/') {\n                    getNextChar();\n                    return getToken();\n                }\n            } else {\n                getNextChar();\n            }\n        }\n    }\n    Token identifier_or_integer(int line, int pos) {\n        boolean is_number = true;\n        String text = \"\";\n        \n        while (Character.isAlphabetic(this.chr) || Character.isDigit(this.chr) || this.chr == '_') {\n            text += this.chr;\n            if (!Character.isDigit(this.chr)) {\n                is_number = false;\n            }\n            getNextChar();\n        }\n        \n        if (text.equals(\"\")) {\n            error(line, pos, String.format(\"identifer_or_integer unrecognized character: (%d) %c\", (int)this.chr, this.chr));\n        }\n        \n        if (Character.isDigit(text.charAt(0))) {\n            if (!is_number) {\n                error(line, pos, String.format(\"invalid number: %s\", text));\n            }\n            return new Token(TokenType.Integer, text, line, pos);\n        }\n        \n        if (this.keywords.containsKey(text)) {\n            return new Token(this.keywords.get(text), \"\", line, pos);\n        }\n        return new Token(TokenType.Identifier, text, line, pos);\n    }\n    Token getToken() {\n        int line, pos;\n        while (Character.isWhitespace(this.chr)) {\n            getNextChar();\n        }\n        line = this.line;\n        pos = this.pos;\n        \n        switch (this.chr) {\n            case '\\u0000': return new Token(TokenType.End_of_input, \"\", this.line, this.pos);\n            case '/': return div_or_comment(line, pos);\n            case '\\'': return char_lit(line, pos);\n            case '<': return follow('=', TokenType.Op_lessequal, TokenType.Op_less, line, pos);\n            case '>': return follow('=', TokenType.Op_greaterequal, TokenType.Op_greater, line, pos);\n            case '=': return follow('=', TokenType.Op_equal, TokenType.Op_assign, line, pos);\n            case '!': return follow('=', TokenType.Op_notequal, TokenType.Op_not, line, pos);\n            case '&': return follow('&', TokenType.Op_and, TokenType.End_of_input, line, pos);\n            case '|': return follow('|', TokenType.Op_or, TokenType.End_of_input, line, pos);\n            case '\"': return string_lit(this.chr, line, pos);\n            case '{': getNextChar(); return new Token(TokenType.LeftBrace, \"\", line, pos);\n            case '}': getNextChar(); return new Token(TokenType.RightBrace, \"\", line, pos);\n            case '(': getNextChar(); return new Token(TokenType.LeftParen, \"\", line, pos);\n            case ')': getNextChar(); return new Token(TokenType.RightParen, \"\", line, pos);\n            case '+': getNextChar(); return new Token(TokenType.Op_add, \"\", line, pos);\n            case '-': getNextChar(); return new Token(TokenType.Op_subtract, \"\", line, pos);\n            case '*': getNextChar(); return new Token(TokenType.Op_multiply, \"\", line, pos);\n            case '%': getNextChar(); return new Token(TokenType.Op_mod, \"\", line, pos);\n            case ';': getNextChar(); return new Token(TokenType.Semicolon, \"\", line, pos);\n            case ',': getNextChar(); return new Token(TokenType.Comma, \"\", line, pos);\n            \n            default: return identifier_or_integer(line, pos);\n        }\n    }\n    \n    char getNextChar() {\n        this.pos++;\n        this.position++;\n        if (this.position >= this.s.length()) {\n            this.chr = '\\u0000';\n            return this.chr;\n        }\n        this.chr = this.s.charAt(this.position);\n        if (this.chr == '\\n') {\n            this.line++;\n            this.pos = 0;\n        }\n        return this.chr;\n    }\n\n    void printTokens() {\n        Token t;\n        while ((t = getToken()).tokentype != TokenType.End_of_input) {\n            System.out.println(t);\n        }\n        System.out.println(t);\n    }\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            try {\n                \n                File f = new File(args[0]);\n                Scanner s = new Scanner(f);\n                String source = \" \";\n                while (s.hasNext()) {\n                    source += s.nextLine() + \"\\n\";\n                }\n                Lexer l = new Lexer(source);\n                l.printTokens();\n            } catch(FileNotFoundException e) {\n                error(-1, -1, \"Exception: \" + e.getMessage());\n            }\n        } else {\n            error(-1, -1, \"No args\");\n        }\n    }\n}\n"}
{"id": 349533, "name": "Compiler_lexical analyzer", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\nno warnings 'once';\n\n\n\n\nmy @tokens = (\n    \n    \n    ['Op_multiply'    , '*'                  ,             ],\n    ['Op_divide'      , '/'                  ,             ],\n    ['Op_mod'         , '%'                  ,             ],\n    ['Op_add'         , '+'                  ,             ],\n    ['Op_subtract'    , '-'                  ,             ],\n    ['Op_lessequal'   , '<='                 ,             ],\n    ['Op_less'        , '<'                  ,             ],\n    ['Op_greaterequal', '>='                 ,             ],\n    ['Op_greater'     , '>'                  ,             ],\n    ['Op_equal'       , '=='                 ,             ],\n    ['Op_assign'      , '='                  ,             ],\n    ['Op_not'         , '!'                  ,             ],\n    ['Op_notequal'    , '!='                 ,             ],\n    ['Op_and'         , '&&'                 ,             ],\n    ['Op_or'          , '||'                 ,             ],\n    ['Keyword_else'   , qr/else\\b/           ,             ],\n    ['Keyword_if'     , qr/if\\b/             ,             ],\n    ['Keyword_while'  , qr/while\\b/          ,             ],\n    ['Keyword_print'  , qr/print\\b/          ,             ],\n    ['Keyword_putc'   , qr/putc\\b/           ,             ],\n\n    ['LeftParen'      , '('                  ,             ],\n    ['RightParen'     , ')'                  ,             ],\n    ['LeftBrace'      , '{'                  ,             ],\n    ['RightBrace'     , '}'                  ,             ],\n    ['Semicolon'      , ';'                  ,             ],\n    ['Comma'          , ','                  ,             ],\n\n    ['Identifier'     , qr/[_a-z][_a-z0-9]*/i, \\&raw       ],\n    ['Integer'        , qr/[0-9]+\\b/         , \\&raw       ],\n    ['Integer'        , qr/'([^']*)(')?/     , \\&char_val  ],\n    ['String'         , qr/\"([^\"]*)(\")?/     , \\&string_raw],\n\n    ['End_of_input'   , qr/$/                ,             ],\n);\n\nmy $comment = qr/\\/\\* .+? (?: \\*\\/ | $ (?{die \"End-of-file in comment\\n\"}) )/xs;\nmy $whitespace = qr/(?: \\s | $comment)*/x;\nmy $unrecognized = qr/\\w+ | ./x;\n\n\nsub char_val {\n    my $str = string_val();\n    die \"Multiple characters\\n\" if length $str > 1;\n    die \"No character\\n\"        if length $str == 0;\n    ord $str;\n}\n\n\nsub string_val {\n    my ($str, $end) = ($1, $2);\n    die \"End-of-file\\n\" if not defined $end;\n    die \"End-of-line\\n\" if $str =~ /\\n/;\n    $str =~ s/\\\\(.)/\n          $1 eq 'n' \u00a0? \"\\n\"\n       \u00a0: $1 eq '\\\\'\u00a0? $1\n       \u00a0: $1 eq $end\u00a0? $1\n       \u00a0: die \"Unknown escape sequence \\\\$1\\n\"\n    /rge;\n}\n\n\nsub raw { $& }\n\n\nsub string_raw {\n    string_val(); \n    $&;\n}\n\n\n\n\n\n\nmy $tokens =\n    join \"|\",\n    map {\n        my $format = $tokens[$_][1];\n        \"\\n\".(ref $format ? $format : quotemeta $format).\" (*MARK:$_) \";\n    } 0..$\n\nmy $regex = qr/\n    \\G (?| $whitespace  \\K (?| $tokens )\n         | $whitespace? \\K ($unrecognized) (*MARK:!) )\n/x;\n\n\n\n\nmy $input = do { local $/ = undef; <STDIN> };\nmy $pos = 0;\nmy $linecol = linecol_accumulator();\n\nwhile ($input =~ /$regex/g) {\n    \n    my ($line, $col) = $linecol->(substr $input, $pos, $-[0] - $pos);\n    $pos = $-[0];\n\n    \n    my $type = $main::REGMARK;\n    die \"Unrecognized token $1 at line $line, col $col\\n\" if $type eq '!';\n    my ($name, $evaluator) = @{$tokens[$type]}[0, 2];\n\n    \n    my $value;\n    if ($evaluator) {\n        eval { $value = $evaluator->() };\n        if ($@) { chomp $@; die \"$@ in $name at line $line, col $col\\n\" }\n    }\n\n    \n    print \"$line\\t$col\\t$name\".($value ? \"\\t$value\" : '').\"\\n\";\n}\n\n\n\nsub linecol_accumulator {\n    my ($line, $col) = (1, 1);\n    sub {\n        my $str = shift;\n        my @lines = split \"\\n\", $str, -1;\n        my ($l, $c) = @lines ? (@lines - 1, length $lines[-1]) : (0, 0);\n        if ($l) { $line += $l;  $col = 1 + $c }\n        else    { $col += $c }\n        ($line, $col)\n    }\n}\n", "target": "\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Lexer {\n    private int line;\n    private int pos;\n    private int position;\n    private char chr;\n    private String s;\n    \n    Map<String, TokenType> keywords = new HashMap<>();\n    \n    static class Token {\n        public TokenType tokentype;\n        public String value;\n        public int line;\n        public int pos;\n        Token(TokenType token, String value, int line, int pos) {\n            this.tokentype = token; this.value = value; this.line = line; this.pos = pos;\n        }\n        @Override\n        public String toString() {\n            String result = String.format(\"%5d  %5d\u00a0%-15s\", this.line, this.pos, this.tokentype);\n            switch (this.tokentype) {\n                case Integer:\n                    result += String.format(\"  %4s\", value);\n                    break;\n                case Identifier:\n                    result += String.format(\" %s\", value);\n                    break;\n                case String:\n                    result += String.format(\" \\\"%s\\\"\", value);\n                    break;\n            }\n            return result;\n        }\n    }\n    \n    static enum TokenType {\n        End_of_input, Op_multiply,  Op_divide, Op_mod, Op_add, Op_subtract,\n        Op_negate, Op_not, Op_less, Op_lessequal, Op_greater, Op_greaterequal,\n        Op_equal, Op_notequal, Op_assign, Op_and, Op_or, Keyword_if,\n        Keyword_else, Keyword_while, Keyword_print, Keyword_putc, LeftParen, RightParen,\n        LeftBrace, RightBrace, Semicolon, Comma, Identifier, Integer, String\n    }\n    \n    static void error(int line, int pos, String msg) {\n        if (line > 0 && pos > 0) {\n            System.out.printf(\"%s in line %d, pos %d\\n\", msg, line, pos);\n        } else {\n            System.out.println(msg);\n        }\n        System.exit(1);\n    }\n\n    Lexer(String source) {\n        this.line = 1;\n        this.pos = 0;\n        this.position = 0;\n        this.s = source;\n        this.chr = this.s.charAt(0);\n        this.keywords.put(\"if\", TokenType.Keyword_if);\n        this.keywords.put(\"else\", TokenType.Keyword_else);\n        this.keywords.put(\"print\", TokenType.Keyword_print);\n        this.keywords.put(\"putc\", TokenType.Keyword_putc);\n        this.keywords.put(\"while\", TokenType.Keyword_while);\n        \n    }\n    Token follow(char expect, TokenType ifyes, TokenType ifno, int line, int pos) {\n        if (getNextChar() == expect) {\n            getNextChar();\n            return new Token(ifyes, \"\", line, pos);\n        }\n        if (ifno == TokenType.End_of_input) {\n            error(line, pos, String.format(\"follow: unrecognized character: (%d) '%c'\", (int)this.chr, this.chr));\n        }\n        return new Token(ifno, \"\", line, pos);\n    }\n    Token char_lit(int line, int pos) {\n        char c = getNextChar(); \n        int n = (int)c;\n        if (c == '\\'') {\n            error(line, pos, \"empty character constant\");\n        } else if (c == '\\\\') {\n            c = getNextChar();\n            if (c == 'n') {\n                n = 10;\n            } else if (c == '\\\\') {\n                n = '\\\\';\n            } else {\n                error(line, pos, String.format(\"unknown escape sequence \\\\%c\", c));\n            }\n        }\n        if (getNextChar() != '\\'') {\n            error(line, pos, \"multi-character constant\");\n        }\n        getNextChar();\n        return new Token(TokenType.Integer, \"\" + n, line, pos);\n    }\n    Token string_lit(char start, int line, int pos) {\n        String result = \"\";\n        while (getNextChar() != start) {\n            if (this.chr == '\\u0000') {\n                error(line, pos, \"EOF while scanning string literal\");\n            }\n            if (this.chr == '\\n') {\n                error(line, pos, \"EOL while scanning string literal\");\n            }\n            result += this.chr;\n        }\n        getNextChar();\n        return new Token(TokenType.String, result, line, pos);\n    }\n    Token div_or_comment(int line, int pos) {\n        if (getNextChar() != '*') {\n            return new Token(TokenType.Op_divide, \"\", line, pos);\n        }\n        getNextChar();\n        while (true) { \n            if (this.chr == '\\u0000') {\n                error(line, pos, \"EOF in comment\");\n            } else if (this.chr == '*') {\n                if (getNextChar() == '/') {\n                    getNextChar();\n                    return getToken();\n                }\n            } else {\n                getNextChar();\n            }\n        }\n    }\n    Token identifier_or_integer(int line, int pos) {\n        boolean is_number = true;\n        String text = \"\";\n        \n        while (Character.isAlphabetic(this.chr) || Character.isDigit(this.chr) || this.chr == '_') {\n            text += this.chr;\n            if (!Character.isDigit(this.chr)) {\n                is_number = false;\n            }\n            getNextChar();\n        }\n        \n        if (text.equals(\"\")) {\n            error(line, pos, String.format(\"identifer_or_integer unrecognized character: (%d) %c\", (int)this.chr, this.chr));\n        }\n        \n        if (Character.isDigit(text.charAt(0))) {\n            if (!is_number) {\n                error(line, pos, String.format(\"invalid number: %s\", text));\n            }\n            return new Token(TokenType.Integer, text, line, pos);\n        }\n        \n        if (this.keywords.containsKey(text)) {\n            return new Token(this.keywords.get(text), \"\", line, pos);\n        }\n        return new Token(TokenType.Identifier, text, line, pos);\n    }\n    Token getToken() {\n        int line, pos;\n        while (Character.isWhitespace(this.chr)) {\n            getNextChar();\n        }\n        line = this.line;\n        pos = this.pos;\n        \n        switch (this.chr) {\n            case '\\u0000': return new Token(TokenType.End_of_input, \"\", this.line, this.pos);\n            case '/': return div_or_comment(line, pos);\n            case '\\'': return char_lit(line, pos);\n            case '<': return follow('=', TokenType.Op_lessequal, TokenType.Op_less, line, pos);\n            case '>': return follow('=', TokenType.Op_greaterequal, TokenType.Op_greater, line, pos);\n            case '=': return follow('=', TokenType.Op_equal, TokenType.Op_assign, line, pos);\n            case '!': return follow('=', TokenType.Op_notequal, TokenType.Op_not, line, pos);\n            case '&': return follow('&', TokenType.Op_and, TokenType.End_of_input, line, pos);\n            case '|': return follow('|', TokenType.Op_or, TokenType.End_of_input, line, pos);\n            case '\"': return string_lit(this.chr, line, pos);\n            case '{': getNextChar(); return new Token(TokenType.LeftBrace, \"\", line, pos);\n            case '}': getNextChar(); return new Token(TokenType.RightBrace, \"\", line, pos);\n            case '(': getNextChar(); return new Token(TokenType.LeftParen, \"\", line, pos);\n            case ')': getNextChar(); return new Token(TokenType.RightParen, \"\", line, pos);\n            case '+': getNextChar(); return new Token(TokenType.Op_add, \"\", line, pos);\n            case '-': getNextChar(); return new Token(TokenType.Op_subtract, \"\", line, pos);\n            case '*': getNextChar(); return new Token(TokenType.Op_multiply, \"\", line, pos);\n            case '%': getNextChar(); return new Token(TokenType.Op_mod, \"\", line, pos);\n            case ';': getNextChar(); return new Token(TokenType.Semicolon, \"\", line, pos);\n            case ',': getNextChar(); return new Token(TokenType.Comma, \"\", line, pos);\n            \n            default: return identifier_or_integer(line, pos);\n        }\n    }\n    \n    char getNextChar() {\n        this.pos++;\n        this.position++;\n        if (this.position >= this.s.length()) {\n            this.chr = '\\u0000';\n            return this.chr;\n        }\n        this.chr = this.s.charAt(this.position);\n        if (this.chr == '\\n') {\n            this.line++;\n            this.pos = 0;\n        }\n        return this.chr;\n    }\n\n    void printTokens() {\n        Token t;\n        while ((t = getToken()).tokentype != TokenType.End_of_input) {\n            System.out.println(t);\n        }\n        System.out.println(t);\n    }\n    public static void main(String[] args) {\n        if (args.length > 0) {\n            try {\n                \n                File f = new File(args[0]);\n                Scanner s = new Scanner(f);\n                String source = \" \";\n                while (s.hasNext()) {\n                    source += s.nextLine() + \"\\n\";\n                }\n                Lexer l = new Lexer(source);\n                l.printTokens();\n            } catch(FileNotFoundException e) {\n                error(-1, -1, \"Exception: \" + e.getMessage());\n            }\n        } else {\n            error(-1, -1, \"No args\");\n        }\n    }\n}\n"}
{"id": 349534, "name": "Copy a string", "source": "Translate Perl to Java: my $original = 'Hello.';\nmy $new = $original;\n$new = 'Goodbye.';\nprint \"$original\\n\";   \n", "target": "String src = \"Hello\";\nString newAlias = src;\nString strCopy = new String(src);\n\n\n\n\n"}
{"id": 349535, "name": "Abbreviations, simple", "source": "Translate Perl to Java: @c = (uc join ' ', qw<\nadd 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\ncompress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\nforward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\nlocate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\nmsg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\nrefresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\n>) =~ /([a-zA-Z]+(?:\\s+\\d+)?)(?=\\s+[a-zA-Z]|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor (@c) {\n    ($w,$sl) = split ' ', $_;\n    $ll = length($w);\n    $sl = $ll unless $sl;\n    $abr{substr($w,0,$sl)} = $w;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\";\n", "target": "import java.util.*;\n\npublic class Abbreviations {\n    public static void main(String[] args) {\n        CommandList commands = new CommandList(commandTable);\n        String input = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n        System.out.println(\" input: \" + input);\n        System.out.println(\"output: \" + test(commands, input));\n    }\n\n    private static String test(CommandList commands, String input) {\n        StringBuilder output = new StringBuilder();\n        Scanner scanner = new Scanner(input);\n        while (scanner.hasNext()) {\n            String word = scanner.next();\n            if (output.length() > 0)\n                output.append(' ');\n            Command cmd = commands.findCommand(word);\n            if (cmd != null)\n                output.append(cmd.cmd);\n            else\n                output.append(\"*error*\");\n        }\n        return output.toString();\n    }\n\n    private static String commandTable =\n        \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \" +\n        \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \" +\n        \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \" +\n        \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \" +\n        \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \" +\n        \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \" +\n        \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \" +\n        \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\";\n\n    private static class Command {\n        private Command(String cmd, int minLength) {\n             this.cmd = cmd;\n             this.minLength = minLength;\n        }\n        private boolean match(String str) {\n            int olen = str.length();\n            return olen >= minLength && olen <= cmd.length()\n                && cmd.regionMatches(true, 0, str, 0, olen);\n        }\n        private String cmd;\n        private int minLength;\n    }\n\n    private static Integer parseInteger(String word) {\n        try {\n            return Integer.valueOf(word);\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n    }\n\n    private static class CommandList {\n        private CommandList(String table) {\n            Scanner scanner = new Scanner(table);\n            List<String> words = new ArrayList<>();\n            while (scanner.hasNext()) {\n                String word = scanner.next();\n                words.add(word.toUpperCase());\n            }\n            for (int i = 0, n = words.size(); i < n; ++i) {\n                String word = words.get(i);\n                \n                \n                \n                int len = word.length();\n                if (i + 1 < n) {\n                    Integer number = parseInteger(words.get(i + 1));\n                    if (number != null) {\n                        len = number.intValue();\n                        ++i;\n                    }\n                }\n                commands.add(new Command(word, len));\n            }\n        }\n        private Command findCommand(String word) {\n            for (Command command : commands) {\n                if (command.match(word))\n                    return command;\n            }\n            return null;\n        }\n        private List<Command> commands = new ArrayList<>();\n    }\n}\n"}
{"id": 349536, "name": "Abbreviations, simple", "source": "Translate Perl to Java: @c = (uc join ' ', qw<\nadd 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3\ncompress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate\n3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2\nforward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load\nlocate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2\nmsg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3\nrefresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left\n2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\n>) =~ /([a-zA-Z]+(?:\\s+\\d+)?)(?=\\s+[a-zA-Z]|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor (@c) {\n    ($w,$sl) = split ' ', $_;\n    $ll = length($w);\n    $sl = $ll unless $sl;\n    $abr{substr($w,0,$sl)} = $w;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\";\n", "target": "import java.util.*;\n\npublic class Abbreviations {\n    public static void main(String[] args) {\n        CommandList commands = new CommandList(commandTable);\n        String input = \"riG   rePEAT copies  put mo   rest    types   fup.    6       poweRin\";\n        System.out.println(\" input: \" + input);\n        System.out.println(\"output: \" + test(commands, input));\n    }\n\n    private static String test(CommandList commands, String input) {\n        StringBuilder output = new StringBuilder();\n        Scanner scanner = new Scanner(input);\n        while (scanner.hasNext()) {\n            String word = scanner.next();\n            if (output.length() > 0)\n                output.append(' ');\n            Command cmd = commands.findCommand(word);\n            if (cmd != null)\n                output.append(cmd.cmd);\n            else\n                output.append(\"*error*\");\n        }\n        return output.toString();\n    }\n\n    private static String commandTable =\n        \"add 1  alter 3  backup 2  bottom 1  Cappend 2  change 1  Schange  Cinsert 2  Clast 3 \" +\n        \"compress 4 copy 2 count 3 Coverlay 3 cursor 3  delete 3 Cdelete 2  down 1  duplicate \" +\n        \"3 xEdit 1 expand 3 extract 3  find 1 Nfind 2 Nfindup 6 NfUP 3 Cfind 2 findUP 3 fUP 2 \" +\n        \"forward 2  get  help 1 hexType 4  input 1 powerInput 3  join 1 split 2 spltJOIN load \" +\n        \"locate 1 Clocate 2 lowerCase 3 upperCase 3 Lprefix 2  macro  merge 2 modify 3 move 2 \" +\n        \"msg  next 1 overlay 1 parse preserve 4 purge 3 put putD query 1 quit  read recover 3 \" +\n        \"refresh renum 3 repeat 3 replace 1 Creplace 2 reset 3 restore 4 rgtLEFT right 2 left \" +\n        \"2  save  set  shift 2  si  sort  sos  stack 3 status 4 top  transfer 3  type 1  up 1\";\n\n    private static class Command {\n        private Command(String cmd, int minLength) {\n             this.cmd = cmd;\n             this.minLength = minLength;\n        }\n        private boolean match(String str) {\n            int olen = str.length();\n            return olen >= minLength && olen <= cmd.length()\n                && cmd.regionMatches(true, 0, str, 0, olen);\n        }\n        private String cmd;\n        private int minLength;\n    }\n\n    private static Integer parseInteger(String word) {\n        try {\n            return Integer.valueOf(word);\n        } catch (NumberFormatException ex) {\n            return null;\n        }\n    }\n\n    private static class CommandList {\n        private CommandList(String table) {\n            Scanner scanner = new Scanner(table);\n            List<String> words = new ArrayList<>();\n            while (scanner.hasNext()) {\n                String word = scanner.next();\n                words.add(word.toUpperCase());\n            }\n            for (int i = 0, n = words.size(); i < n; ++i) {\n                String word = words.get(i);\n                \n                \n                \n                int len = word.length();\n                if (i + 1 < n) {\n                    Integer number = parseInteger(words.get(i + 1));\n                    if (number != null) {\n                        len = number.intValue();\n                        ++i;\n                    }\n                }\n                commands.add(new Command(word, len));\n            }\n        }\n        private Command findCommand(String word) {\n            for (Command command : commands) {\n                if (command.match(word))\n                    return command;\n            }\n            return null;\n        }\n        private List<Command> commands = new ArrayList<>();\n    }\n}\n"}
{"id": 349537, "name": "String comparison", "source": "Translate Perl to Java: use v5.16;  \n            \n\nsub compare {\n    my ($a, $b) = @_;\n    my $A = \"'$a'\";\n    my $B = \"'$b'\";\n    \n    print \"$A and $B are lexically equal.\\n\"     if $a eq $b;\n    print \"$A and $B are not lexically equal.\\n\" if $a ne $b;\n    \n    print \"$A is lexically before $B.\\n\"         if $a lt $b;\n    print \"$A is lexically after $B.\\n\"          if $a gt $b;\n    \n    print \"$A is not lexically before $B.\\n\"     if $a ge $b;\n    print \"$A is not lexically after $B.\\n\"      if $a le $b;\n    \n    print \"The lexical relationship is: \", $a cmp $b, \"\\n\";\n    print \"The case-insensitive lexical relationship is: \", fc($a) cmp fc($b), \"\\n\";\n    print \"\\n\";\n}\n\ncompare('Hello', 'Hello');\ncompare('5', '5.0');\ncompare('perl', 'Perl');\n", "target": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}\n"}
{"id": 349538, "name": "Executable library", "source": "Translate Perl to Java: package Hailstone;\n\nsub seq {\n\tmy $x = shift;\n\t$x == 1\t? (1) : ($x & 1)? ($x, seq($x * 3 + 1))\n\t\t\t\t: ($x, seq($x / 2))\n}\n\nmy %cache = (1 => 1);\nsub len {\n\tmy $x = shift;\n\t$cache{$x} //= 1 + (\n\t\t$x & 1\t? len($x * 3 + 1)\n\t\t\t: len($x / 2))\n}\n\nunless (caller) {\n    for (1 .. 100_000) {\n        my $l = len($_);\n        ($m, $len) = ($_, $l) if $l > $len;\n    }\n    print \"seq of 27 - $cache{27} elements: @{[seq(27)]}\\n\";\n    print \"Longest sequence is for $m: $len\\n\";\n}\n\n1;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\n\npublic class HailstoneSequence {\n\n    public static void main(String[] args) {\n        \n        int n = 27;\n        List<Long> sequence27 = hailstoneSequence(n);\n        System.out.printf(\"Hailstone sequence for %d has a length of %d:%nhailstone(%d) = %s%n\", n, sequence27.size(), n, sequence27);\n        \n        \n        int maxN = 0;\n        int maxLength = 0;\n        for ( int i = 1 ; i < 100_000 ; i++ ) {\n            int seqLength = hailstoneSequence(i).size();\n            if ( seqLength > maxLength ) {\n                maxLength = seqLength;\n                maxN = i;\n            }\n        }\n        System.out.printf(\"Longest hailstone sequence less than 100,000: hailstone(%d).length() = %d\", maxN, maxLength);\n    }\n    \n    public static List<Long> hailstoneSequence(long n) {\n        if ( n <= 0 ) {\n            throw new IllegalArgumentException(\"Must be grater than or equal to zero.\");\n        }\n        List<Long> sequence = new ArrayList<>();\n        sequence.add(n);\n        while ( n > 1 ) {\n            if ( (n & 1) == 0 ) {\n                n /= 2;\n            }\n            else {\n                n = 3 * n + 1;\n            }\n            sequence.add(n);\n        }\n        return sequence;\n    }\n    \n}\n"}
{"id": 349539, "name": "Executable library", "source": "Translate Perl to Java: package Hailstone;\n\nsub seq {\n\tmy $x = shift;\n\t$x == 1\t? (1) : ($x & 1)? ($x, seq($x * 3 + 1))\n\t\t\t\t: ($x, seq($x / 2))\n}\n\nmy %cache = (1 => 1);\nsub len {\n\tmy $x = shift;\n\t$cache{$x} //= 1 + (\n\t\t$x & 1\t? len($x * 3 + 1)\n\t\t\t: len($x / 2))\n}\n\nunless (caller) {\n    for (1 .. 100_000) {\n        my $l = len($_);\n        ($m, $len) = ($_, $l) if $l > $len;\n    }\n    print \"seq of 27 - $cache{27} elements: @{[seq(27)]}\\n\";\n    print \"Longest sequence is for $m: $len\\n\";\n}\n\n1;\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\n\npublic class HailstoneSequence {\n\n    public static void main(String[] args) {\n        \n        int n = 27;\n        List<Long> sequence27 = hailstoneSequence(n);\n        System.out.printf(\"Hailstone sequence for %d has a length of %d:%nhailstone(%d) = %s%n\", n, sequence27.size(), n, sequence27);\n        \n        \n        int maxN = 0;\n        int maxLength = 0;\n        for ( int i = 1 ; i < 100_000 ; i++ ) {\n            int seqLength = hailstoneSequence(i).size();\n            if ( seqLength > maxLength ) {\n                maxLength = seqLength;\n                maxN = i;\n            }\n        }\n        System.out.printf(\"Longest hailstone sequence less than 100,000: hailstone(%d).length() = %d\", maxN, maxLength);\n    }\n    \n    public static List<Long> hailstoneSequence(long n) {\n        if ( n <= 0 ) {\n            throw new IllegalArgumentException(\"Must be grater than or equal to zero.\");\n        }\n        List<Long> sequence = new ArrayList<>();\n        sequence.add(n);\n        while ( n > 1 ) {\n            if ( (n & 1) == 0 ) {\n                n /= 2;\n            }\n            else {\n                n = 3 * n + 1;\n            }\n            sequence.add(n);\n        }\n        return sequence;\n    }\n    \n}\n"}
{"id": 349540, "name": "Entropy_Narcissist", "source": "Translate Perl to Java: \nuse strict ;\nuse warnings ;\nuse feature 'say' ;\n\nsub log2 {\n   my $number = shift ;\n   return log( $number ) / log( 2 ) ;\n}\n\nopen my $fh , \"<\" , $ARGV[ 0 ] or die \"Can't open $ARGV[ 0 ]$!\\n\" ;\nmy %frequencies ;\nmy $totallength = 0 ;\nwhile ( my $line = <$fh> ) {\n   chomp $line ;\n   next if $line =~ /^$/ ;\n   map { $frequencies{ $_ }++ } split( // , $line ) ;\n   $totallength += length ( $line ) ;\n}\nclose $fh ;\nmy $infocontent = 0 ;\nfor my $letter ( keys %frequencies ) {\n   my $content = $frequencies{ $letter } / $totallength ;\n   $infocontent += $content * log2( $content ) ;\n}\n$infocontent *= -1 ;\nsay \"The information content of the source file is $infocontent\u00a0!\" ;\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EntropyNarcissist {\n\n    private static final String FILE_NAME = \"src/EntropyNarcissist.java\";\n    \n    public static void main(String[] args) {\n        System.out.printf(\"Entropy of file \\\"%s\\\" =\u00a0%.12f.%n\", FILE_NAME, getEntropy(FILE_NAME));\n    }\n    \n    private static double getEntropy(String fileName) {\n        Map<Character,Integer> characterCount = new HashMap<>();\n        int length = 0;\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));) {        \n            int c = 0;\n            while ( (c = reader.read()) != -1 ) {\n                characterCount.merge((char) c, 1, (v1, v2) -> v1 + v2);\n                length++;\n            }\n        }\n        catch ( IOException e ) {\n            throw new RuntimeException(e);\n        }\n        \n        double entropy = 0;\n        for ( char key : characterCount.keySet() ) {\n            double fraction = (double) characterCount.get(key) / length;\n            entropy -= fraction * Math.log(fraction);\n        }\n\n        return entropy / Math.log(2);\n    }\n\n}\n"}
{"id": 349541, "name": "Entropy_Narcissist", "source": "Translate Perl to Java: \nuse strict ;\nuse warnings ;\nuse feature 'say' ;\n\nsub log2 {\n   my $number = shift ;\n   return log( $number ) / log( 2 ) ;\n}\n\nopen my $fh , \"<\" , $ARGV[ 0 ] or die \"Can't open $ARGV[ 0 ]$!\\n\" ;\nmy %frequencies ;\nmy $totallength = 0 ;\nwhile ( my $line = <$fh> ) {\n   chomp $line ;\n   next if $line =~ /^$/ ;\n   map { $frequencies{ $_ }++ } split( // , $line ) ;\n   $totallength += length ( $line ) ;\n}\nclose $fh ;\nmy $infocontent = 0 ;\nfor my $letter ( keys %frequencies ) {\n   my $content = $frequencies{ $letter } / $totallength ;\n   $infocontent += $content * log2( $content ) ;\n}\n$infocontent *= -1 ;\nsay \"The information content of the source file is $infocontent\u00a0!\" ;\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class EntropyNarcissist {\n\n    private static final String FILE_NAME = \"src/EntropyNarcissist.java\";\n    \n    public static void main(String[] args) {\n        System.out.printf(\"Entropy of file \\\"%s\\\" =\u00a0%.12f.%n\", FILE_NAME, getEntropy(FILE_NAME));\n    }\n    \n    private static double getEntropy(String fileName) {\n        Map<Character,Integer> characterCount = new HashMap<>();\n        int length = 0;\n\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(fileName)));) {        \n            int c = 0;\n            while ( (c = reader.read()) != -1 ) {\n                characterCount.merge((char) c, 1, (v1, v2) -> v1 + v2);\n                length++;\n            }\n        }\n        catch ( IOException e ) {\n            throw new RuntimeException(e);\n        }\n        \n        double entropy = 0;\n        for ( char key : characterCount.keySet() ) {\n            double fraction = (double) characterCount.get(key) / length;\n            entropy -= fraction * Math.log(fraction);\n        }\n\n        return entropy / Math.log(2);\n    }\n\n}\n"}
{"id": 349542, "name": "Draw a pixel", "source": "Translate Perl to Java: use Gtk3 '-init';\n\nmy $window = Gtk3::Window->new();\n$window->set_default_size(320, 240);\n$window->set_border_width(10);\n$window->set_title(\"Draw a Pixel\");\n$window->set_app_paintable(TRUE);\n\nmy $da = Gtk3::DrawingArea->new();\n$da->signal_connect('draw' => \\&draw_in_drawingarea);\n$window->add($da);\n$window->show_all();\n\nGtk3->main;\n\nsub draw_in_drawingarea\n{\n  my ($widget, $cr, $data) = @_;\n  $cr->set_source_rgb(1, 0, 0);\n  $cr->set_line_width(1);\n  $cr->rectangle( 100, 100, 1, 1);\n  $cr->stroke;\n}\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class DrawAPixel extends JFrame{\n\tpublic DrawAPixel() {\n\t\tsuper(\"Red Pixel\");\n\t\tsetSize(320, 240);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}\n"}
{"id": 349543, "name": "Verify distribution uniformity_Naive", "source": "Translate Perl to Java: sub roll7 { 1+int rand(7) }\nsub roll5 { 1+int rand(5) }\nsub roll7_5 {\n  while(1) {\n    my $d7 = (5*&roll5 + &roll5 - 6) % 8;\n    return $d7 if $d7;\n  }\n}\n\nmy $threshold = 5;\n\nprint dist( $_, $threshold,  \\&roll7   ) for <1001 1000006>;\nprint dist( $_, $threshold,  \\&roll7_5 ) for <1001 1000006>;\n\nsub dist {\nmy($n, $threshold, $producer) = @_;\n    my @dist;\n    my $result;\n    my $expect = $n / 7;\n    $result .= sprintf \"%10d expected\\n\", $expect;\n\n    for (1..$n) { @dist[&$producer]++; }\n\n    for my $i (1..7) {\n        my $v = @dist[$i];\n        my $pct = ($v - $expect)/$expect*100;\n        $result .= sprintf \"%d %8d %6.1f%%%s\\n\", $i, $v, $pct, (abs($pct) > $threshold ? ' - skewed' : '');\n    }\n    return $result . \"\\n\";\n}\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport java.util.function.IntSupplier;\n\npublic class Test {\n\n    static void distCheck(IntSupplier f, int nRepeats, double delta) {\n        Map<Integer, Integer> counts = new HashMap<>();\n\n        for (int i = 0; i < nRepeats; i++)\n            counts.compute(f.getAsInt(), (k, v) -> v == null ? 1 : v + 1);\n\n        double target = nRepeats / (double) counts.size();\n        int deltaCount = (int) (delta / 100.0 * target);\n\n        counts.forEach((k, v) -> {\n            if (abs(target - v) >= deltaCount)\n                System.out.printf(\"distribution potentially skewed \"\n                        + \"for '%s': '%d'%n\", k, v);\n        });\n\n        counts.keySet().stream().sorted().forEach(k\n                -> System.out.printf(\"%d %d%n\", k, counts.get(k)));\n    }\n\n    public static void main(String[] a) {\n        distCheck(() -> (int) (Math.random() * 5) + 1, 1_000_000, 1);\n    }\n}\n"}
{"id": 349544, "name": "Find first and last set bit of a long integer", "source": "Translate Perl to Java: sub msb {\n  my ($n, $base) = (shift, 0);\n  $base++ while $n >>= 1;\n  $base;\n}\nsub lsb {\n  my $n = shift;\n  msb($n & -$n);\n}\n", "target": "public class FirstAndLastBits {\n\n    public static long LSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn Long.numberOfTrailingZeros(aNumber);\n\t}\n\t\n\tpublic static long MSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn 63 - Long.numberOfLeadingZeros(aNumber);\n\t}\n\t\n\tpublic static long LSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.getLowestSetBit();\n\t}\n\t\n\tpublic static long MSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.bitLength() - 1;\n\t}\n\t\n\tpublic static void main(String[] aArgs) {\n\t\tLong powerOf42 = 1L;\t\t\n\t\tfor ( int i = 0; i <= 11; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-5s%-3s%s\", \"42 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", Long.toBinaryString(powerOf42)).replace(\" \", \"0\"));\n\t\t\tSystem.out.println(String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf42), \", MSB: \", MSB(powerOf42)));\n\t\t\tpowerOf42 *= 42;\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tBigInteger bigInteger1302 = BigInteger.valueOf(1302);\n\t\tBigInteger powerOf1302 = BigInteger.ONE;\t\t\n\t\tfor ( int i = 0; i <= 6; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-7s%s%s\", \"1302 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", powerOf1302.toString(2)).replace(\" \", \"0\"));\n\t\t\tString line = String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf1302), \", MSB: \", MSB(powerOf1302));\n\t\t\tSystem.out.println(line);\n\t\t\tpowerOf1302 = powerOf1302.multiply(bigInteger1302);\n\t\t}\n\t}\n\n}\n"}
{"id": 349545, "name": "Find first and last set bit of a long integer", "source": "Translate Perl to Java: sub msb {\n  my ($n, $base) = (shift, 0);\n  $base++ while $n >>= 1;\n  $base;\n}\nsub lsb {\n  my $n = shift;\n  msb($n & -$n);\n}\n", "target": "public class FirstAndLastBits {\n\n    public static long LSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn Long.numberOfTrailingZeros(aNumber);\n\t}\n\t\n\tpublic static long MSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn 63 - Long.numberOfLeadingZeros(aNumber);\n\t}\n\t\n\tpublic static long LSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.getLowestSetBit();\n\t}\n\t\n\tpublic static long MSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.bitLength() - 1;\n\t}\n\t\n\tpublic static void main(String[] aArgs) {\n\t\tLong powerOf42 = 1L;\t\t\n\t\tfor ( int i = 0; i <= 11; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-5s%-3s%s\", \"42 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", Long.toBinaryString(powerOf42)).replace(\" \", \"0\"));\n\t\t\tSystem.out.println(String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf42), \", MSB: \", MSB(powerOf42)));\n\t\t\tpowerOf42 *= 42;\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tBigInteger bigInteger1302 = BigInteger.valueOf(1302);\n\t\tBigInteger powerOf1302 = BigInteger.ONE;\t\t\n\t\tfor ( int i = 0; i <= 6; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-7s%s%s\", \"1302 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", powerOf1302.toString(2)).replace(\" \", \"0\"));\n\t\t\tString line = String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf1302), \", MSB: \", MSB(powerOf1302));\n\t\t\tSystem.out.println(line);\n\t\t\tpowerOf1302 = powerOf1302.multiply(bigInteger1302);\n\t\t}\n\t}\n\n}\n"}
{"id": 349546, "name": "Bioinformatics_Sequence mutation", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @bases = <A C G T>;\n\nmy $dna;\n$dna .= $bases[int rand 4] for 1..200;\n\nmy %cnt;\n$cnt{$_}++ for split //, $dna;\n\nsub pretty {\n    my($string) = @_;\n    my $chunk = 10;\n    my $wrap  = 5 * ($chunk+1);\n    ($string =~ s/(.{$chunk})/$1 /gr) =~ s/(.{$wrap})/$1\\n/gr;\n}\n\nsub mutate {\n    my($dna,$count) = @_;\n    my $orig = $dna;\n    substr($dna,rand length $dna,1) = $bases[int rand 4] while $count > diff($orig, $dna) =~ tr/acgt//;\n    $dna\n}\n\nsub diff {\n    my($orig, $repl) = @_;\n    for my $i (0 .. -1+length $orig) {\n        substr($repl,$i,1, lc substr $repl,$i,1) if substr($orig,$i,1) ne substr($repl,$i,1);\n    }\n    $repl;\n}\n\nsay \"Original DNA strand:\\n\" . pretty($dna);\nsay \"Total bases: \". length $dna;\nsay \"$_: $cnt{$_}\" for @bases;\n\nmy $mutate = mutate($dna, 10);\n%cnt = ();\n$cnt{$_}++ for split //, $mutate;\nsay \"\\nMutated DNA strand:\\n\" . pretty diff $dna, $mutate;\nsay \"Total bases: \". length $mutate;\nsay \"$_: $cnt{$_}\" for @bases;\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 349547, "name": "Bioinformatics_Sequence mutation", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nmy @bases = <A C G T>;\n\nmy $dna;\n$dna .= $bases[int rand 4] for 1..200;\n\nmy %cnt;\n$cnt{$_}++ for split //, $dna;\n\nsub pretty {\n    my($string) = @_;\n    my $chunk = 10;\n    my $wrap  = 5 * ($chunk+1);\n    ($string =~ s/(.{$chunk})/$1 /gr) =~ s/(.{$wrap})/$1\\n/gr;\n}\n\nsub mutate {\n    my($dna,$count) = @_;\n    my $orig = $dna;\n    substr($dna,rand length $dna,1) = $bases[int rand 4] while $count > diff($orig, $dna) =~ tr/acgt//;\n    $dna\n}\n\nsub diff {\n    my($orig, $repl) = @_;\n    for my $i (0 .. -1+length $orig) {\n        substr($repl,$i,1, lc substr $repl,$i,1) if substr($orig,$i,1) ne substr($repl,$i,1);\n    }\n    $repl;\n}\n\nsay \"Original DNA strand:\\n\" . pretty($dna);\nsay \"Total bases: \". length $dna;\nsay \"$_: $cnt{$_}\" for @bases;\n\nmy $mutate = mutate($dna, 10);\n%cnt = ();\n$cnt{$_}++ for split //, $mutate;\nsay \"\\nMutated DNA strand:\\n\" . pretty diff $dna, $mutate;\nsay \"Total bases: \". length $mutate;\nsay \"$_: $cnt{$_}\" for @bases;\n", "target": "import java.util.Arrays;\nimport java.util.Random;\n\npublic class SequenceMutation {\n    public static void main(String[] args) {\n        SequenceMutation sm = new SequenceMutation();\n        sm.setWeight(OP_CHANGE, 3);\n        String sequence = sm.generateSequence(250);\n        System.out.println(\"Initial sequence:\");\n        printSequence(sequence);\n        int count = 10;\n        for (int i = 0; i < count; ++i)\n            sequence = sm.mutateSequence(sequence);\n        System.out.println(\"After \" + count + \" mutations:\");\n        printSequence(sequence);\n    }\n\n    public SequenceMutation() {\n        totalWeight_ = OP_COUNT;\n        Arrays.fill(operationWeight_, 1);\n    }\n\n    public String generateSequence(int length) {\n        char[] ch = new char[length];\n        for (int i = 0; i < length; ++i)\n            ch[i] = getRandomBase();\n        return new String(ch);\n    }\n\n    public void setWeight(int operation, int weight) {\n        totalWeight_ -= operationWeight_[operation];\n        operationWeight_[operation] = weight;\n        totalWeight_ += weight;\n    }\n\n    public String mutateSequence(String sequence) {\n        char[] ch = sequence.toCharArray();\n        int pos = random_.nextInt(ch.length);\n        int operation = getRandomOperation();\n        if (operation == OP_CHANGE) {\n            char b = getRandomBase();\n            System.out.println(\"Change base at position \" + pos + \" from \"\n                               + ch[pos] + \" to \" + b);\n            ch[pos] = b;\n        } else if (operation == OP_ERASE) {\n            System.out.println(\"Erase base \" + ch[pos] + \" at position \" + pos);\n            char[] newCh = new char[ch.length - 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos + 1, newCh, pos, ch.length - pos - 1);\n            ch = newCh;\n        } else if (operation == OP_INSERT) {\n            char b = getRandomBase();\n            System.out.println(\"Insert base \" + b + \" at position \" + pos);\n            char[] newCh = new char[ch.length + 1];\n            System.arraycopy(ch, 0, newCh, 0, pos);\n            System.arraycopy(ch, pos, newCh, pos + 1, ch.length - pos);\n            newCh[pos] = b;\n            ch = newCh;\n        }\n        return new String(ch);\n    }\n\n    public static void printSequence(String sequence) {\n        int[] count = new int[BASES.length];\n        for (int i = 0, n = sequence.length(); i < n; ++i) {\n            if (i % 50 == 0) {\n                if (i != 0)\n                    System.out.println();\n                System.out.printf(\"%3d: \", i);\n            }\n            char ch = sequence.charAt(i);\n            System.out.print(ch);\n            for (int j = 0; j < BASES.length; ++j) {\n                if (BASES[j] == ch) {\n                    ++count[j];\n                    break;\n                }\n            }\n        }\n        System.out.println();\n        System.out.println(\"Base counts:\");\n        int total = 0;\n        for (int j = 0; j < BASES.length; ++j) {\n            total += count[j];\n            System.out.print(BASES[j] + \": \" + count[j] + \", \");\n        }\n        System.out.println(\"Total: \" + total);\n    }\n\n    private char getRandomBase() {\n        return BASES[random_.nextInt(BASES.length)];\n    }\n\n    private int getRandomOperation() {\n        int n = random_.nextInt(totalWeight_), op = 0;\n        for (int weight = 0; op < OP_COUNT; ++op) {\n            weight += operationWeight_[op];\n            if (n < weight)\n                break;\n        }\n        return op;\n    }\n\n    private final Random random_ = new Random();\n    private int[] operationWeight_ = new int[OP_COUNT];\n    private int totalWeight_ = 0;\n\n    private static final int OP_CHANGE = 0;\n    private static final int OP_ERASE = 1;\n    private static final int OP_INSERT = 2;\n    private static final int OP_COUNT = 3;\n    private static final char[] BASES = {'A', 'C', 'G', 'T'};\n}\n"}
{"id": 349548, "name": "Colour bars_Display", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse GD;\n\nmy %colors = (\nwhite   => [255,255,255], red    => [255,  0,  0], green => [  0,255,  0], blue  => [  0,  0,255],\nmagenta => [255,  0,255], yellow => [255,255,  0], cyan  => [  0,255,255], black => [  0,  0,  0]);\n\nmy $start    = 0;\nmy $barwidth = 160 / 8;\nmy $image    = GD::Image->new( 160 , 100 );\n\nfor my $rgb ( values %colors ) {\n   $image->filledRectangle( $start * $barwidth , 0 , $start * $barwidth + \n\t                        $barwidth - 1 , 99 , $image->colorAllocate( @$rgb ) );\n   $start++ ;\n}\nopen ( DISPLAY , \">\" , \"bars.png\" ) or die;\nbinmode DISPLAY;\nprint DISPLAY $image->png;\nclose DISPLAY;\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 349549, "name": "Colour bars_Display", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse GD;\n\nmy %colors = (\nwhite   => [255,255,255], red    => [255,  0,  0], green => [  0,255,  0], blue  => [  0,  0,255],\nmagenta => [255,  0,255], yellow => [255,255,  0], cyan  => [  0,255,255], black => [  0,  0,  0]);\n\nmy $start    = 0;\nmy $barwidth = 160 / 8;\nmy $image    = GD::Image->new( 160 , 100 );\n\nfor my $rgb ( values %colors ) {\n   $image->filledRectangle( $start * $barwidth , 0 , $start * $barwidth + \n\t                        $barwidth - 1 , 99 , $image->colorAllocate( @$rgb ) );\n   $start++ ;\n}\nopen ( DISPLAY , \">\" , \"bars.png\" ) or die;\nbinmode DISPLAY;\nprint DISPLAY $image->png;\nclose DISPLAY;\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\n\npublic class ColorFrame extends JFrame {\n\tpublic ColorFrame(int width, int height) {\n\t\tthis.setDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tthis.setSize(width, height);\n\t\tthis.setVisible(true);\n\t}\n\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tColor[] colors = { Color.black, Color.red, Color.green, Color.blue,\n\t\t\t\tColor.pink, Color.CYAN, Color.yellow, Color.white };\n\n\t\tfor (int i = 0; i < colors.length; i++) {\n\t\t\tg.setColor(colors[i]);\n\t\t\tg.fillRect(this.getWidth() / colors.length * i, 0, this.getWidth()\n\t\t\t\t\t/ colors.length, this.getHeight());\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tnew ColorFrame(200, 200);\n\t}\n}\n"}
{"id": 349550, "name": "Ray-casting algorithm", "source": "Translate Perl to Java: use strict;\nuse List::Util qw(max min);\n\nsub point_in_polygon\n{\n    my ( $point, $polygon ) = @_;\n\n    my $count = 0;\n    foreach my $side ( @$polygon ) {\n\t$count++ if ray_intersect_segment($point, $side);\n    }\n    return ($count % 2 == 0) ? 0 : 1;\n}\n\n\nmy $eps = 0.0001;\nmy $inf = 1e600;\n\nsub ray_intersect_segment\n{\n    my ($point, $segment) = @_;\n\n    my ($A, $B) = @$segment;\n\n    my @P = @$point; \n\n    ($A, $B) = ($B, $A) if $A->[1] > $B->[1];\n\n    $P[1] += $eps if ($P[1] == $A->[1]) || ($P[1] == $B->[1]);\n\n    return 0 if ($P[1] < $A->[1]) || ( $P[1] > $B->[1]) || ($P[0] > max($A->[0],$B->[1]) );\n    return 1 if $P[0] < min($A->[0], $B->[0]);\n\n    my $m_red = ($A->[0] != $B->[0]) ? ( $B->[1] - $A->[1] )/($B->[0] - $A->[0]) : $inf;\n    my $m_blue = ($A->[0] != $P[0]) ? ( $P[1] - $A->[1] )/($P[0] - $A->[0]) : $inf;\n\n    return ($m_blue >= $m_red) ? 1 : 0;\n}\n", "target": "import static java.lang.Math.*;\n\npublic class RayCasting {\n\n    static boolean intersects(int[] A, int[] B, double[] P) {\n        if (A[1] > B[1])\n            return intersects(B, A, P);\n\n        if (P[1] == A[1] || P[1] == B[1])\n            P[1] += 0.0001;\n\n        if (P[1] > B[1] || P[1] < A[1] || P[0] >= max(A[0], B[0]))\n            return false;\n\n        if (P[0] < min(A[0], B[0]))\n            return true;\n\n        double red = (P[1] - A[1]) / (double) (P[0] - A[0]);\n        double blue = (B[1] - A[1]) / (double) (B[0] - A[0]);\n        return red >= blue;\n    }\n\n    static boolean contains(int[][] shape, double[] pnt) {\n        boolean inside = false;\n        int len = shape.length;\n        for (int i = 0; i < len; i++) {\n            if (intersects(shape[i], shape[(i + 1) % len], pnt))\n                inside = !inside;\n        }\n        return inside;\n    }\n\n    public static void main(String[] a) {\n        double[][] testPoints = {{10, 10}, {10, 16}, {-20, 10}, {0, 10},\n        {20, 10}, {16, 10}, {20, 20}};\n\n        for (int[][] shape : shapes) {\n            for (double[] pnt : testPoints)\n                System.out.printf(\"%7s \", contains(shape, pnt));\n            System.out.println();\n        }\n    }\n\n    final static int[][] square = {{0, 0}, {20, 0}, {20, 20}, {0, 20}};\n\n    final static int[][] squareHole = {{0, 0}, {20, 0}, {20, 20}, {0, 20},\n    {5, 5}, {15, 5}, {15, 15}, {5, 15}};\n\n    final static int[][] strange = {{0, 0}, {5, 5}, {0, 20}, {5, 15}, {15, 15},\n    {20, 20}, {20, 0}};\n\n    final static int[][] hexagon = {{6, 0}, {14, 0}, {20, 10}, {14, 20},\n    {6, 20}, {0, 10}};\n\n    final static int[][][] shapes = {square, squareHole, strange, hexagon};\n}\n"}
{"id": 349551, "name": "Dining philosophers", "source": "Translate Perl to Java: use threads;\nuse threads::shared;\nmy @names = qw(Aristotle Kant Spinoza Marx Russell);\n\nmy @forks = ('On Table') x @names;\nshare $forks[$_] for 0 .. $\n\nsub pick_up_forks {\n   my $philosopher = shift;\n   my ($first, $second) = ($philosopher, $philosopher-1);\n   ($first, $second) = ($second, $first) if $philosopher % 2;\n   for my $fork ( @forks[ $first, $second ] ) {\n      lock $fork;\n      cond_wait($fork) while $fork ne 'On Table';\n      $fork = 'In Hand';\n   }\n}\n\nsub drop_forks {\n   my $philosopher = shift;\n   for my $fork ( @forks[$philosopher, $philosopher-1] ) {\n      lock $fork;\n      die unless $fork eq 'In Hand';\n      $fork = 'On Table';\n      cond_signal($fork);\n   }\n}\n\nsub philosopher {\n   my $philosopher = shift;\n   my $name = $names[$philosopher];\n   for my $meal ( 1..5 ) {\n      print $name, \" is pondering\\n\";\n      sleep 1 + rand 8;\n      print $name, \" is hungry\\n\";\n      pick_up_forks( $philosopher );\n      print $name, \" is eating\\n\";\n      sleep 1 + rand 8;\n      drop_forks( $philosopher );\n   }\n   print $name, \" is done\\n\";\n}\n\nmy @t = map { threads->new(\\&philosopher, $_) } 0 .. $\nfor my $thread ( @t ) {\n   $thread->join;\n}\n\nprint \"Done\\n\";\n", "target": "package diningphilosophers;\n\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nenum PhilosopherState { Get, Eat, Pon }\n\nclass Fork {\n    public static final int ON_TABLE = -1;\n    static int instances = 0;\n    public int id;\n    public AtomicInteger holder = new AtomicInteger(ON_TABLE);\n\n    Fork() { id = instances++; }\n}\n\nclass Philosopher implements Runnable {\n    static final int maxWaitMs = 100;                          \n    static AtomicInteger token = new AtomicInteger(0);\n    static int instances = 0;\n    static Random rand = new Random();\n    AtomicBoolean end = new AtomicBoolean(false);\n    int id;\n    PhilosopherState state = PhilosopherState.Get;\n    Fork left;\n    Fork right;\n    int timesEaten = 0;\n\n    Philosopher() {\n        id = instances++;\n        left = Main.forks.get(id);\n        right = Main.forks.get((id+1)%Main.philosopherCount);\n    }\n\n    void sleep() { try { Thread.sleep(rand.nextInt(maxWaitMs)); }\n        catch (InterruptedException ex) {} }\n\n    void waitForFork(Fork fork) {\n        do {\n            if (fork.holder.get() == Fork.ON_TABLE) {\n                fork.holder.set(id);                \n                return;\n            } else {                                \n                sleep();                            \n            }\n        } while (true);\n    }\n\n    public void run() {\n        do {\n            if (state == PhilosopherState.Pon) {    \n                state = PhilosopherState.Get;       \n            } else { \n                if (token.get() == id) {            \n                    waitForFork(left);\n                    waitForFork(right);             \n                    token.set((id+2)% Main.philosopherCount);\n                    state = PhilosopherState.Eat;\n                    timesEaten++;\n                    sleep();                        \n                    left.holder.set(Fork.ON_TABLE);\n                    right.holder.set(Fork.ON_TABLE);\n                    state = PhilosopherState.Pon;   \n                    sleep();\n                } else {                    \n                    sleep();\n                }\n            }\n        } while (!end.get());\n    }\n}\n\npublic class Main {\n    static final int philosopherCount = 5; \n    static final int runSeconds = 15;\n    static ArrayList<Fork> forks = new ArrayList<Fork>();\n    static ArrayList<Philosopher> philosophers = new ArrayList<Philosopher>();\n\n    public static void main(String[] args) {\n        for (int i = 0 ; i < philosopherCount ; i++) forks.add(new Fork());\n        for (int i = 0 ; i < philosopherCount ; i++)\n            philosophers.add(new Philosopher());\n        for (Philosopher p : philosophers) new Thread(p).start();\n        long endTime = System.currentTimeMillis() + (runSeconds * 1000);\n\n        do {                                                    \n            StringBuilder sb = new StringBuilder(\"|\");\n\n            for (Philosopher p : philosophers) {\n                sb.append(p.state.toString());\n                sb.append(\"|\");            \n            }                              \n\n            sb.append(\"     |\");\n\n            for (Fork f : forks) {\n                int holder = f.holder.get();\n                sb.append(holder==-1?\"   \":String.format(\"P%02d\",holder));\n                sb.append(\"|\");\n            }\n            \n            System.out.println(sb.toString());\n            try {Thread.sleep(1000);} catch (Exception ex) {}\n        } while (System.currentTimeMillis() < endTime);\n\n        for (Philosopher p : philosophers) p.end.set(true);\n        for (Philosopher p : philosophers)\n            System.out.printf(\"P%02d: ate\u00a0%,d times,\u00a0%,d/sec\\n\",\n                p.id, p.timesEaten, p.timesEaten/runSeconds);\n    }\n}\n"}
{"id": 349552, "name": "Exceptions", "source": "Translate Perl to Java: \ndie \"Danger, danger, Will Robinson!\";\n\n\neval {\n    die \"this could go wrong mightily\";\n};\nprint $@ if $@;\n\n\ndie $@;\n", "target": "\npublic class MyException extends Exception {\n   \n}\n\n\npublic class MyRuntimeException extends RuntimeException {}\n"}
{"id": 349553, "name": "24 game", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q') \n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  \n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  \n      $entry =~ /\\d\\d/ ||                \n      $entry =~ m|[-+*/]{2}| ||          \n      $entry =~ tr|-0-9()+*/||c)         \n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 349554, "name": "24 game", "source": "Translate Perl to Java: \nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q') \n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  \n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  \n      $entry =~ /\\d\\d/ ||                \n      $entry =~ m|[-+*/]{2}| ||          \n      $entry =~ tr|-0-9()+*/||c)         \n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 349555, "name": "Enforced immutability", "source": "Translate Perl to Java: use constant PI => 3.14159;\nuse constant MSG => \"Hello World\";\n", "target": "final int immutableInt = 4;\nint mutableInt = 4;\nmutableInt = 6; \nimmutableInt = 6; \n"}
{"id": 349556, "name": "Strange numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Quantum::Superpositions;\n\nsub is_strange {\n    my @digits = split '', $_;\n    my @deltas = map { abs $digits[$_-1] - $digits[$_] } 1..$\n    all(@deltas) == any(2, 3, 5, 7);\n}\n\nmy($low, $high) = (100, 500);\nmy $cnt = my @strange = grep { is_strange($_) } $low+1 .. $high-1;\nsay \"Between $low and $high there are $cnt strange numbers:\\n\" .\n    (sprintf \"@{['%5d' x $cnt]}\", @strange[0..$cnt-1]) =~ s/(.{80})/$1\\n/gr;\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 349557, "name": "Strange numbers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Quantum::Superpositions;\n\nsub is_strange {\n    my @digits = split '', $_;\n    my @deltas = map { abs $digits[$_-1] - $digits[$_] } 1..$\n    all(@deltas) == any(2, 3, 5, 7);\n}\n\nmy($low, $high) = (100, 500);\nmy $cnt = my @strange = grep { is_strange($_) } $low+1 .. $high-1;\nsay \"Between $low and $high there are $cnt strange numbers:\\n\" .\n    (sprintf \"@{['%5d' x $cnt]}\", @strange[0..$cnt-1]) =~ s/(.{80})/$1\\n/gr;\n", "target": "import java.util.LinkedList;\nimport java.util.List;\nimport java.util.function.BiPredicate;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class StrangeNumbers {\n    private static List<Integer> digits(int n) {\n        var result = new LinkedList<Integer>();\n        while (n > 0) {\n            var rem = n % 10;\n            result.addFirst(rem);\n            n /= 10;\n        }\n        return result;\n    }\n\n    private static boolean isStrange(int n) {\n        BiPredicate<Integer, Integer> test = (a, b) -> {\n            var abs = Math.abs(a - b);\n            return abs == 2 || abs == 3 || abs == 5 || abs == 7;\n        };\n\n        var xs = digits(n);\n        for (int i = 1; i < xs.size(); i++) {\n            if (test.negate().test(xs.get(i - 1), xs.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        var xs = IntStream.rangeClosed(100, 500)\n            .filter(StrangeNumbers::isStrange)\n            .boxed()\n            .collect(Collectors.toList());\n\n        System.out.println(\"Strange numbers in range [100..500]\");\n        System.out.printf(\"(Total: %d)\\n\\n\", xs.size());\n\n        for (int i = 0; i < xs.size(); i++) {\n            Integer x = xs.get(i);\n            System.out.print(x);\n\n            if ((i + 1) % 10 == 0) {\n                System.out.println();\n            } else {\n                System.out.print(' ');\n            }\n        }\n    }\n}\n"}
{"id": 349558, "name": "Hofstadter Q sequence", "source": "Translate Perl to Java: my @Q = (0,1,1);\npush @Q, $Q[-$Q[-1]] + $Q[-$Q[-2]] for 1..100_000;\nsay \"First 10 terms: [@Q[1..10]]\";\nsay \"Term 1000: $Q[1000]\";\nsay \"Terms less than preceding in first 100k: \",scalar(grep { $Q[$_] < $Q[$_-1] } 2..100000);\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 349559, "name": "Hofstadter Q sequence", "source": "Translate Perl to Java: my @Q = (0,1,1);\npush @Q, $Q[-$Q[-1]] + $Q[-$Q[-2]] for 1..100_000;\nsay \"First 10 terms: [@Q[1..10]]\";\nsay \"Term 1000: $Q[1000]\";\nsay \"Terms less than preceding in first 100k: \",scalar(grep { $Q[$_] < $Q[$_-1] } 2..100000);\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 349560, "name": "Count occurrences of a substring", "source": "Translate Perl to Java: sub countSubstring {\n  my $str = shift;\n  my $sub = quotemeta(shift);\n  my $count = () = $str =~ /$sub/g;\n  return $count;\n\n}\n  \nprint countSubstring(\"the three truths\",\"th\"), \"\\n\"; \nprint countSubstring(\"ababababab\",\"abab\"), \"\\n\"; \n", "target": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n"}
{"id": 349561, "name": "Logistic curve fitting in epidemiology", "source": "Translate Perl to Java: use strict;\nuse warnings;\n\nmy $K  = 7_800_000_000; \nmy $n0 = 27;            \n\nmy @y = (\n    27,     27,     27,     44,     44,     59,     59,     59,    59,      59,     59,     59,     59,\n    60,     60,     61,     61,     66,     83,    219,    239,    392,    534,    631,    897,   1350,\n  2023,   2820,   4587,   6067,   7823,   9826,  11946,  14554,  17372,  20615,  24522,  28273,  31491,\n 34933,  37552,  40540,  43105,  45177,  60328,  64543,  67103,  69265,  71332,  73327,  75191,  75723,\n 76719,  77804,  78812,  79339,  80132,  80995,  82101,  83365,  85203,  87024,  89068,  90664,  93077,\n 95316,  98172, 102133, 105824, 109695, 114232, 118610, 125497, 133852, 143227, 151367, 167418, 180096,\n194836, 213150, 242364, 271106, 305117, 338133, 377918, 416845, 468049, 527767, 591704, 656866, 715353,\n777796, 851308, 928436,1000249,1082054,1174652\n);\n\nsub logistic_func {\n    my($r) = @_;\n    my $sq = 0;\n    for my $i (0 .. @y-1) {\n        my $eri = exp($r * $i);\n        my $dst = ($n0 * $eri) / (1 + $n0 * ($eri-1) / $K) - $y[$i];\n        $sq = $sq + $dst**2;\n    }\n    $sq\n}\n\nsub solve {\n    my($fn, $guess, $epsilon) = @_;\n    my($nfm,$nfp);\n    my $f0 = &$fn($guess);\n    my $delta = $guess;\n    my $factor = 2;\n    while ($delta > $epsilon) {\n        ($nfm = &$fn($guess - $delta)) < $f0 ?\n            ($f0 = $nfm, $guess -= $delta, $delta *= $factor)\n        :\n        ($nfp = &$fn($guess + $delta)) < $f0 ?\n            ($f0 = $nfp, $guess += $delta, $delta *= $factor)\n        :\n            $delta /= $factor\n    }\n    $guess\n}\n\nmy $r  = solve(\\&logistic_func, 0.5, 0);\nmy $R0 = exp(12 * $r);\nprintf \"r =\u00a0%%(%.3f), R0 =\u00a0%%(%.3f)\\n\", $r, $R0;\n", "target": "import java.util.List;\nimport java.util.function.Function;\n\npublic class LogisticCurveFitting {\n    private static final double K = 7.8e9;\n    private static final int N0 = 27;\n\n    private static final List<Double> ACTUAL = List.of(\n        27.0, 27.0, 27.0, 44.0, 44.0, 59.0, 59.0, 59.0, 59.0, 59.0, 59.0, 59.0, 59.0, 60.0, 60.0,\n        61.0, 61.0, 66.0, 83.0, 219.0, 239.0, 392.0, 534.0, 631.0, 897.0, 1350.0, 2023.0, 2820.0,\n        4587.0, 6067.0, 7823.0, 9826.0, 11946.0, 14554.0, 17372.0, 20615.0, 24522.0, 28273.0,\n        31491.0, 34933.0, 37552.0, 40540.0, 43105.0, 45177.0, 60328.0, 64543.0, 67103.0,\n        69265.0, 71332.0, 73327.0, 75191.0, 75723.0, 76719.0, 77804.0, 78812.0, 79339.0,\n        80132.0, 80995.0, 82101.0, 83365.0, 85203.0, 87024.0, 89068.0, 90664.0, 93077.0,\n        95316.0, 98172.0, 102133.0, 105824.0, 109695.0, 114232.0, 118610.0, 125497.0,\n        133852.0, 143227.0, 151367.0, 167418.0, 180096.0, 194836.0, 213150.0, 242364.0,\n        271106.0, 305117.0, 338133.0, 377918.0, 416845.0, 468049.0, 527767.0, 591704.0,\n        656866.0, 715353.0, 777796.0, 851308.0, 928436.0, 1000249.0, 1082054.0, 1174652.0\n    );\n\n    private static double f(double r) {\n        var sq = 0.0;\n        var len = ACTUAL.size();\n        for (int i = 0; i < len; i++) {\n            var eri = Math.exp(r * i);\n            var guess = (N0 * eri) / (1.0 + N0 * (eri - 1.0) / K);\n            var diff = guess - ACTUAL.get(i);\n            sq += diff * diff;\n        }\n        return sq;\n    }\n\n    private static double solve(Function<Double, Double> fn) {\n        return solve(fn, 0.5, 0.0);\n    }\n\n    private static double solve(Function<Double, Double> fn, double guess, double epsilon) {\n        double delta;\n        if (guess != 0.0) {\n            delta = guess;\n        } else {\n            delta = 1.0;\n        }\n\n        var f0 = fn.apply(guess);\n        var factor = 2.0;\n\n        while (delta > epsilon && guess != guess - delta) {\n            var nf = fn.apply(guess - delta);\n            if (nf < f0) {\n                f0 = nf;\n                guess -= delta;\n            } else {\n                nf = fn.apply(guess + delta);\n                if (nf < f0) {\n                    f0 = nf;\n                    guess += delta;\n                } else {\n                    factor = 0.5;\n                }\n            }\n\n            delta *= factor;\n        }\n\n        return guess;\n    }\n\n    public static void main(String[] args) {\n        var r = solve(LogisticCurveFitting::f);\n        var r0 = Math.exp(12.0 * r);\n        System.out.printf(\"r =\u00a0%.16f, R0 =\u00a0%.16f\\n\", r, r0);\n    }\n}\n"}
{"id": 349562, "name": "User input_Graphical", "source": "Translate Perl to Java: use Wx;\n\npackage MyApp;\nuse base 'Wx::App';\nuse Wx qw(wxHORIZONTAL wxVERTICAL wxALL wxALIGN_CENTER);\nuse Wx::Event 'EVT_BUTTON';\n\nour ($frame, $text_input, $integer_input);\n\nsub OnInit\n   {$frame = new Wx::Frame\n       (undef, -1, 'Input window', [-1, -1], [250, 150]);\n\n    my $panel = new Wx::Panel($frame, -1);\n    $text_input = new Wx::TextCtrl($panel, -1, '');\n    $integer_input = new Wx::SpinCtrl\n       ($panel, -1, '', [-1, -1], [-1, -1],\n        0, 0, 100_000);\n\n    my $okay_button = new Wx::Button($panel, -1, 'OK');\n    EVT_BUTTON($frame, $okay_button, \\&OnQuit);\n\n    my $sizer = new Wx::BoxSizer(wxVERTICAL);\n    $sizer->Add($_, 0, wxALL | wxALIGN_CENTER, 5)\n        foreach $text_input, $integer_input, $okay_button;\n    $panel->SetSizer($sizer);\n\n    $frame->Show(1);}\n\nsub OnQuit\n   {print 'String: ', $text_input->GetValue, \"\\n\";\n    print 'Integer: ', $integer_input->GetValue, \"\\n\";\n    $frame->Close;}\n\n\n\npackage main;\n\nMyApp->new->MainLoop;\n", "target": "import javax.swing.*;\n\npublic class GetInputSwing {\n    public static void main(String[] args) throws Exception {\n        int number = Integer.parseInt(\n                JOptionPane.showInputDialog (\"Enter an Integer\"));\n        String string = JOptionPane.showInputDialog (\"Enter a String\");\n    }\n}\n"}
{"id": 349563, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Perl to Java: use ntheory qw/forprimes is_prime vecprod/;\n\nforprimes { my $p = $_;\n   for my $h3 (2 .. $p-1) {\n      my $ph3 = $p + $h3;\n      for my $d (1 .. $ph3-1) {               \n         next if ((-$p*$p) % $h3) != ($d % $h3);\n         next if (($p-1)*$ph3) % $d;\n         my $q = 1 + ($p-1)*$ph3 / $d;        \n         next unless is_prime($q);\n         my $r = 1 + ($p*$q-1) / $h3;         \n         next unless is_prime($r);\n         next unless ($q*$r) % ($p-1) == 1;\n         printf \"%2d x %5d x %5d = %s\\n\",$p,$q,$r,vecprod($p,$q,$r);\n      }\n   }\n} 3,61;\n", "target": "public class Test {\n\n    static int mod(int n, int m) {\n        return ((n % m) + m) % m;\n    }\n\n    static boolean isPrime(int n) {\n        if (n == 2 || n == 3)\n            return true;\n        else if (n < 2 || n % 2 == 0 || n % 3 == 0)\n            return false;\n        for (int div = 5, inc = 2; Math.pow(div, 2) <= n;\n                div += inc, inc = 6 - inc)\n            if (n % div == 0)\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        for (int p = 2; p < 62; p++) {\n            if (!isPrime(p))\n                continue;\n            for (int h3 = 2; h3 < p; h3++) {\n                int g = h3 + p;\n                for (int d = 1; d < g; d++) {\n                    if ((g * (p - 1)) % d != 0 || mod(-p * p, h3) != d % h3)\n                        continue;\n                    int q = 1 + (p - 1) * g / d;\n                    if (!isPrime(q))\n                        continue;\n                    int r = 1 + (p * q / h3);\n                    if (!isPrime(r) || (q * r) % (p - 1) != 1)\n                        continue;\n                    System.out.printf(\"%d x %d x %d%n\", p, q, r);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 349564, "name": "Pascal's triangle_Puzzle", "source": "Translate Perl to Java: \nmy $rows = 5;\nmy @tri = map { [ map { {x=>0,z=>0,v=>0,rhs=>undef} } 1..$_ ] } 1..$rows;\n$tri[0][0]{rhs} = 151;\n$tri[2][0]{rhs} = 40;\n$tri[4][0]{x} = 1;\n$tri[4][1]{v} = 11;\n$tri[4][2]{x} = 1;\n$tri[4][2]{z} = 1;\n$tri[4][3]{v} = 4;\n$tri[4][4]{z} = 1;\n\n\nfor my $row ( reverse 0..@tri-2 ) {\n    for my $col ( 0..@{$tri[$row]}-1 ){\n        $tri[$row][$col]{$_} = $tri[$row+1][$col]{$_}+$tri[$row+1][$col+1]{$_} for 'x','z','v';\n    }\n}\n\nmy @eqn;\nfor my $row ( @tri ) {\n    for my $col ( @$row ){\n        push @eqn, [ $$col{x}, $$col{z}, $$col{rhs}-$$col{v} ] if defined $$col{rhs};\n    }\n}\n\nprint \"Equations:\\n\";\nprint \"  x +   z = y\\n\";\nprintf \"%d x + %d z = %d\\n\", @$_ for @eqn;\n\nmy $f = $eqn[0][1] / $eqn[1][1];\n$eqn[0][$_] -=  $f * $eqn[1][$_] for 0..2;\n$f = $eqn[1][0] / $eqn[0][0];\n$eqn[1][$_] -=  $f * $eqn[0][$_] for 0..2;\n\nprint \"Solution:\\n\";\nmy $x = $eqn[0][2]/$eqn[0][0];\nmy $z = $eqn[1][2]/$eqn[1][1];\nmy $y = $x+$z;\nprintf \"x=%d, y=%d, z=%d\\n\", $x, $y, $z;\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PascalsTrianglePuzzle {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d, 0d), \n                                Arrays.asList(0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 1d, -1d),\n                                Arrays.asList(0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d),\n                                Arrays.asList(1d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, -1d, 0d, 1d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 1d, 1d, 0d, 0d, 0d));\n        List<Double> b = Arrays.asList(11d, 11d, 0d, 4d, 4d, 40d, 0d, 0d, 40d, 0d, 151d);\n        List<Double> solution = cramersRule(mat, b);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n        System.out.printf(\"X =\u00a0%.2f%n\", solution.get(8));\n        System.out.printf(\"Y =\u00a0%.2f%n\", solution.get(9));\n        System.out.printf(\"Z =\u00a0%.2f%n\", solution.get(10));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 349565, "name": "Pascal's triangle_Puzzle", "source": "Translate Perl to Java: \nmy $rows = 5;\nmy @tri = map { [ map { {x=>0,z=>0,v=>0,rhs=>undef} } 1..$_ ] } 1..$rows;\n$tri[0][0]{rhs} = 151;\n$tri[2][0]{rhs} = 40;\n$tri[4][0]{x} = 1;\n$tri[4][1]{v} = 11;\n$tri[4][2]{x} = 1;\n$tri[4][2]{z} = 1;\n$tri[4][3]{v} = 4;\n$tri[4][4]{z} = 1;\n\n\nfor my $row ( reverse 0..@tri-2 ) {\n    for my $col ( 0..@{$tri[$row]}-1 ){\n        $tri[$row][$col]{$_} = $tri[$row+1][$col]{$_}+$tri[$row+1][$col+1]{$_} for 'x','z','v';\n    }\n}\n\nmy @eqn;\nfor my $row ( @tri ) {\n    for my $col ( @$row ){\n        push @eqn, [ $$col{x}, $$col{z}, $$col{rhs}-$$col{v} ] if defined $$col{rhs};\n    }\n}\n\nprint \"Equations:\\n\";\nprint \"  x +   z = y\\n\";\nprintf \"%d x + %d z = %d\\n\", @$_ for @eqn;\n\nmy $f = $eqn[0][1] / $eqn[1][1];\n$eqn[0][$_] -=  $f * $eqn[1][$_] for 0..2;\n$f = $eqn[1][0] / $eqn[0][0];\n$eqn[1][$_] -=  $f * $eqn[0][$_] for 0..2;\n\nprint \"Solution:\\n\";\nmy $x = $eqn[0][2]/$eqn[0][0];\nmy $z = $eqn[1][2]/$eqn[1][1];\nmy $y = $x+$z;\nprintf \"x=%d, y=%d, z=%d\\n\", $x, $y, $z;\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PascalsTrianglePuzzle {\n\n    public static void main(String[] args) {\n        Matrix mat = new Matrix(Arrays.asList(1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d, 0d), \n                                Arrays.asList(0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 1d, -1d),\n                                Arrays.asList(0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, -1d),\n                                Arrays.asList(1d, 1d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, -1d, 0d, 1d, 0d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 1d, 1d, 0d, -1d, 0d, 0d, 0d),\n                                Arrays.asList(0d, 0d, 0d, 0d, 0d, 0d, 1d, 1d, 0d, 0d, 0d));\n        List<Double> b = Arrays.asList(11d, 11d, 0d, 4d, 4d, 40d, 0d, 0d, 40d, 0d, 151d);\n        List<Double> solution = cramersRule(mat, b);\n        System.out.println(\"Solution = \" + cramersRule(mat, b));\n        System.out.printf(\"X =\u00a0%.2f%n\", solution.get(8));\n        System.out.printf(\"Y =\u00a0%.2f%n\", solution.get(9));\n        System.out.printf(\"Z =\u00a0%.2f%n\", solution.get(10));\n    }\n    \n    private static List<Double> cramersRule(Matrix matrix, List<Double> b) {\n        double denominator = matrix.determinant();\n        List<Double> result = new ArrayList<>();\n        for ( int i = 0 ; i < b.size() ; i++ ) {\n            result.add(matrix.replaceColumn(b, i).determinant() / denominator);\n        }\n        return result;\n    }\n        \n    private static class Matrix {\n        \n        private List<List<Double>> matrix;\n        \n        @Override\n        public String toString() {\n            return matrix.toString();\n        }\n        \n        @SafeVarargs\n        public Matrix(List<Double> ... lists) {\n            matrix = new ArrayList<>();\n            for ( List<Double> list : lists) {\n                matrix.add(list);\n            }\n        }\n        \n        public Matrix(List<List<Double>> mat) {\n            matrix = mat;\n        }\n        \n        public double determinant() {\n            if ( matrix.size() == 1 ) {\n                return get(0, 0);\n            }\n            if ( matrix.size() == 2 ) {\n                return get(0, 0) * get(1, 1) - get(0, 1) * get(1, 0);\n            }\n            double sum = 0;\n            double sign = 1;\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                sum += sign * get(0, i) * coFactor(0, i).determinant();\n                sign *= -1;\n            }\n            return sum;\n        }\n        \n        private Matrix coFactor(int row, int col) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int i = 0 ; i < matrix.size() ; i++ ) {\n                if ( i == row ) {\n                    continue;\n                }\n                List<Double> list = new ArrayList<>();\n                for ( int j = 0 ; j < matrix.size() ; j++ ) {\n                    if ( j == col ) {\n                        continue;\n                    }\n                    list.add(get(i, j));\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private Matrix replaceColumn(List<Double> b, int column) {\n            List<List<Double>> mat = new ArrayList<>();\n            for ( int row = 0 ; row < matrix.size() ; row++ ) {\n                List<Double> list = new ArrayList<>();\n                for ( int col = 0 ; col < matrix.size() ; col++ ) {\n                    double value = get(row, col);\n                    if ( col == column ) {\n                        value = b.get(row);\n                    }\n                    list.add(value);\n                }\n                mat.add(list);\n            }\n            return new Matrix(mat);\n        }\n\n        private double get(int row, int col) {\n            return matrix.get(row).get(col);\n        }\n        \n    }\n\n}\n"}
{"id": 349566, "name": "Fractal tree", "source": "Translate Perl to Java: use GD::Simple;\n\nmy ($width, $height) = (1000,1000); \nmy $scale = 6/10; \nmy $length = 400; \n\nmy $img = GD::Simple->new($width,$height);\n$img->fgcolor('black');\n$img->penSize(1,1);\n\ntree($width/2, $height, $length, 270);\n\nprint $img->png;\n\n\nsub tree\n{\n        my ($x, $y, $len, $angle) = @_;\n\n        return if $len < 1;\n\n        $img->moveTo($x,$y);\n        $img->angle($angle);\n        $img->line($len);\n\n        ($x, $y) = $img->curPos();\n\n        tree($x, $y, $len*$scale, $angle+35);\n        tree($x, $y, $len*$scale, $angle-35);\n}\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class FractalTree extends JFrame {\n\n    public FractalTree() {\n        super(\"Fractal Tree\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n    }\n\n    private void drawTree(Graphics g, int x1, int y1, double angle, int depth) {\n        if (depth == 0) return;\n        int x2 = x1 + (int) (Math.cos(Math.toRadians(angle)) * depth * 10.0);\n        int y2 = y1 + (int) (Math.sin(Math.toRadians(angle)) * depth * 10.0);\n        g.drawLine(x1, y1, x2, y2);\n        drawTree(g, x2, y2, angle - 20, depth - 1);\n        drawTree(g, x2, y2, angle + 20, depth - 1);\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.BLACK);\n        drawTree(g, 400, 500, -90, 9);\n    }\n\n    public static void main(String[] args) {\n        new FractalTree().setVisible(true);\n    }\n}\n"}
{"id": 349567, "name": "Rock-paper-scissors", "source": "Translate Perl to Java: use 5.012;\nuse warnings;\nuse utf8;\nuse open qw(:encoding(utf-8) :std);\nuse Getopt::Long;\n\npackage Game {\n    use List::Util qw(shuffle first);\n\n    my $turns        = 0;\n    my %human_choice = ( rock => 0, paper => 0, scissors => 0, );\n    my %comp_choice  = ( rock => 0, paper => 0, scissors => 0, );\n    my %what_beats =\n      ( rock => 'paper', paper => 'scissors', scissors => 'rock', );\n    my $comp_wins  = 0;\n    my $human_wins = 0;\n    my $draws      = 0;\n\n    sub save_human_choice {\n        my $ch = lc pop;\n        if ( exists $human_choice{ $ch } ) {\n            ++$human_choice{ $ch };\n        }\n        else {\n            die __PACKAGE__ . \":: wrong choice: '$ch'\";\n        }\n    }\n\n    sub get_comp_choice {\n        my @keys = shuffle keys %human_choice;\n        my $ch;\n        my ( $prob, $rand ) = ( 0, rand );\n        $ch = ( first { $rand <= ( $prob += ( $human_choice{ $_ } / $turns ) ) } @keys )\n            if $turns > 0;\n        $ch //= $keys[0];\n        $ch = $what_beats{ $ch };\n        ++$comp_choice{ $ch };\n        return $ch;\n    }\n\n    sub make_turn {\n        my ( $comp_ch, $human_ch ) = ( pop(), pop() );\n        ++$turns;\n        if ( $what_beats{ $human_ch } eq $comp_ch ) {\n            ++$comp_wins;\n            return 'I win!';\n        }\n        elsif ( $what_beats{ $comp_ch } eq $human_ch ) {\n            ++$human_wins;\n            return 'You win!';\n        }\n        else {\n            ++$draws;\n            return 'Draw!';\n        }\n    }\n\n    sub get_final_report {\n        my $report =\n            \"You chose:\\n\"\n          . \"  rock     = $human_choice{rock} times,\\n\"\n          . \"  paper    = $human_choice{paper} times,\\n\"\n          . \"  scissors = $human_choice{scissors} times,\\n\"\n          . \"I chose:\\n\"\n          . \"  rock     = $comp_choice{rock} times,\\n\"\n          . \"  paper    = $comp_choice{paper} times,\\n\"\n          . \"  scissors = $comp_choice{scissors} times,\\n\"\n          . \"Turns: $turns\\n\"\n          . \"I won: $comp_wins, you won: $human_wins, draws: $draws\\n\";\n        return $report;\n    }\n}\n\nsub main {\n    GetOptions( 'quiet' => \\my $quiet );\n    greet() if !$quiet;\n    while (1) {\n        print_next_line() if !$quiet;\n        my $input = get_input();\n        last unless $input;\n        if ( $input eq 'error' ) {\n            print \"I don't understand!\\n\" if !$quiet;\n            redo;\n        }\n        my $comp_choice = Game::get_comp_choice();\n        Game::save_human_choice($input);\n        my $result = Game::make_turn( $input, $comp_choice );\n        describe_turn_result( $input, $comp_choice, $result )\n          if !$quiet;\n    }\n    print Game::get_final_report();\n}\n\nsub greet {\n    print \"Welcome to the Rock-Paper-Scissors game!\\n\"\n      . \"Choose 'rock', 'paper' or 'scissors'\\n\"\n      . \"Enter empty line or 'quit' to quit\\n\";\n}\n\nsub print_next_line {\n    print 'Your choice: ';\n}\n\nsub get_input {\n    my $input = <>;\n    print \"\\n\" and return if !$input;    \n    chomp $input;\n    return if !$input or $input =~ m/\\A \\s* q/xi;\n    return \n        ( $input =~ m/\\A \\s* r/xi ) ? 'rock'\n      : ( $input =~ m/\\A \\s* p/xi ) ? 'paper'\n      : ( $input =~ m/\\A \\s* s/xi ) ? 'scissors'\n      :                               'error';\n}\n\nsub describe_turn_result {\n    my ( $human_ch, $comp_ch, $result ) = @_;\n    print \"You chose \\u$human_ch, I chose \\u$comp_ch. $result\\n\";\n}\n\nmain();\n", "target": "import java.util.Arrays;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Random;\n\npublic class RPS {\n\tpublic enum Item{\n\t\tROCK, PAPER, SCISSORS, ;\n\t\tpublic List<Item> losesToList;\n\t\tpublic boolean losesTo(Item other) {\n\t\t\treturn losesToList.contains(other);\n\t\t}\n\t\tstatic {\n\t\t\tSCISSORS.losesToList = Arrays.asList(ROCK);\n\t\t\tROCK.losesToList = Arrays.asList(PAPER);\n\t\t\tPAPER.losesToList = Arrays.asList(SCISSORS);\n\t\t\t\n                }\n\t}\n\t\n\tpublic final Map<Item, Integer> counts = new EnumMap<Item, Integer>(Item.class){{\n\t\tfor(Item item:Item.values())\n\t\t\tput(item, 1);\n\t}};\n\n\tprivate int totalThrows = Item.values().length;\n\n\tpublic static void main(String[] args){\n\t\tRPS rps = new RPS();\n\t\trps.run();\n\t}\n\n\tpublic void run() {\n\t\tScanner in = new Scanner(System.in);\n\t\tSystem.out.print(\"Make your choice: \");\n\t\twhile(in.hasNextLine()){\n\t\t\tItem aiChoice = getAIChoice();\n\t\t\tString input = in.nextLine();\n\t\t\tItem choice;\n\t\t\ttry{\n\t\t\t\tchoice = Item.valueOf(input.toUpperCase());\n\t\t\t}catch (IllegalArgumentException ex){\n\t\t\t\tSystem.out.println(\"Invalid choice\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcounts.put(choice, counts.get(choice) + 1);\n\t\t\ttotalThrows++;\n\t\t\tSystem.out.println(\"Computer chose: \" + aiChoice);\n\t\t\tif(aiChoice == choice){\n\t\t\t\tSystem.out.println(\"Tie!\");\n\t\t\t}else if(aiChoice.losesTo(choice)){\n\t\t\t\tSystem.out.println(\"You chose...wisely. You win!\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"You chose...poorly. You lose!\");\n\t\t\t}\n\t\t\tSystem.out.print(\"Make your choice: \");\n\t\t}\n\t}\n\n\tprivate static final Random rng = new Random();\n\tprivate Item getAIChoice() {\n\t\tint rand = rng.nextInt(totalThrows);\n\t\tfor(Map.Entry<Item, Integer> entry:counts.entrySet()){\n\t\t\tItem item = entry.getKey();\n\t\t\tint count = entry.getValue();\n\t\t\tif(rand < count){\n\t\t\t\tList<Item> losesTo = item.losesToList;\n\t\t\t\treturn losesTo.get(rng.nextInt(losesTo.size()));\n\t\t\t}\n\t\t\trand -= count;\n\t\t}\n\t\treturn null;\n\t}\n}\n"}
{"id": 349568, "name": "Benford's law", "source": "Translate Perl to Java: \nuse strict ;\nuse warnings ;\nuse POSIX qw( log10 ) ;\n\nmy @fibonacci = ( 0 , 1  ) ;\nwhile ( @fibonacci != 1000 ) {\n   push @fibonacci , $fibonacci[ -1 ] + $fibonacci[ -2 ] ;\n}\nmy @actuals ;\nmy @expected ;\nfor my $i( 1..9 ) {\n   my $sum = 0 ;\n   map { $sum++ if $_ =~ /\\A$i/ } @fibonacci ;\n   push @actuals , $sum / 1000  ;\n   push @expected , log10( 1 + 1/$i ) ;\n}\nprint \"         Observed         Expected\\n\" ;\nfor my $i( 1..9 ) {\n   print \"$i\u00a0: \" ;\n   my $result = sprintf ( \"%.2f\" , 100 * $actuals[ $i - 1 ] ) ;\n   printf \"%11s\u00a0%%\" , $result ;\n   $result = sprintf ( \"%.2f\" , 100 * $expected[ $i - 1 ] ) ;\n   printf \"%15s\u00a0%%\\n\" , $result ;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 349569, "name": "Benford's law", "source": "Translate Perl to Java: \nuse strict ;\nuse warnings ;\nuse POSIX qw( log10 ) ;\n\nmy @fibonacci = ( 0 , 1  ) ;\nwhile ( @fibonacci != 1000 ) {\n   push @fibonacci , $fibonacci[ -1 ] + $fibonacci[ -2 ] ;\n}\nmy @actuals ;\nmy @expected ;\nfor my $i( 1..9 ) {\n   my $sum = 0 ;\n   map { $sum++ if $_ =~ /\\A$i/ } @fibonacci ;\n   push @actuals , $sum / 1000  ;\n   push @expected , log10( 1 + 1/$i ) ;\n}\nprint \"         Observed         Expected\\n\" ;\nfor my $i( 1..9 ) {\n   print \"$i\u00a0: \" ;\n   my $result = sprintf ( \"%.2f\" , 100 * $actuals[ $i - 1 ] ) ;\n   printf \"%11s\u00a0%%\" , $result ;\n   $result = sprintf ( \"%.2f\" , 100 * $expected[ $i - 1 ] ) ;\n   printf \"%15s\u00a0%%\\n\" , $result ;\n}\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 349570, "name": "Hickerson series of almost integers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::BigFloat;\n\nmy $iln2 = 1 / Math::BigFloat->new(2)->blog;\nmy $h = $iln2 / 2;\n\nfor my $n ( 1 .. 17 ) {\n\t$h *= $iln2;\n\t$h *= $n;\n\tmy $s = $h->copy->bfround(-3)->bstr;\n\tprintf \"h(%2d) = %22s is%s almost an integer.\\n\",\n\t\t$n, $s, ($s =~ /\\.[09]/ ? \"\" : \" NOT\");\n}\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 349571, "name": "Hickerson series of almost integers", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse Math::BigFloat;\n\nmy $iln2 = 1 / Math::BigFloat->new(2)->blog;\nmy $h = $iln2 / 2;\n\nfor my $n ( 1 .. 17 ) {\n\t$h *= $iln2;\n\t$h *= $n;\n\tmy $s = $h->copy->bfround(-3)->bstr;\n\tprintf \"h(%2d) = %22s is%s almost an integer.\\n\",\n\t\t$n, $s, ($s =~ /\\.[09]/ ? \"\" : \" NOT\");\n}\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 349572, "name": "Read a configuration file", "source": "Translate Perl to Java: my $fullname;\nmy $favouritefruit;\nmy $needspeeling;\nmy $seedsremoved;\nmy @otherfamily;\n\n\nmy $conf_definition = {\n    'fullname'          => [ 'string', \\$fullname ],\n    'favouritefruit'    => [ 'string', \\$favouritefruit ],\n    'needspeeling'      => [ 'boolean', \\$needspeeling ],\n    'seedsremoved'      => [ 'boolean', \\$seedsremoved ],\n    'otherfamily'       => [ 'array', \\@otherfamily ],\n};\n\nmy $arg = shift;               \n                               \nmy $file;                      \nopen $file, $arg or die \"Can't open configuration file '$arg': $!\";\n\nread_conf_file($file, $conf_definition); \n\nprint \"fullname = $fullname\\n\";\nprint \"favouritefruit = $favouritefruit\\n\";\nprint \"needspeeling = \", ($needspeeling ? 'true' : 'false'), \"\\n\";\nprint \"seedsremoved = \", ($seedsremoved ? 'true' : 'false'), \"\\n\";\nfor (my $i = 0; $i < @otherfamily; ++$i) {\n    print \"otherfamily(\", $i + 1, \") = \", $otherfamily[$i], \"\\n\";\n}\n\n\n\n\n\n\n\n\n\nsub read_conf_file {\n    my ($fh, $def) = @_;        \n\n    local $_;                   \n    while (<$fh>) {             \n        next if /^\n        next if /^;/;           \n        next if /^$/;           \n        chomp;                  \n\n        $_ =~ /^\\s*(\\w+)\\s*(.*)$/i or die \"Syntax error\";\n        my $key = $1;\n        my $rest = $2;\n        $key =~ tr/[A-Z]/[a-z]/; \n\n        if (!exists $def->{$key}) {\n            die \"Unknown keyword: '$key'\";\n        }\n\n        if ($def->{$key}[0] eq 'boolean') {\n            if ($rest) {\n                die \"Syntax error:  extra data following boolean '$key'\";\n            }\n            ${$def->{$key}[1]} = 1;\n            next;                \n        }\n\n        $rest =~ s/\\s*$//;       \n        $rest =~ s/^=\\s*//;      \n\n        if ($def->{$key}[0] eq 'string') {\n            ${$def->{$key}[1]} = $rest;\n        } elsif ($def->{$key}[0] eq 'array') {\n            @{$def->{$key}[1]} = split /\\s*,\\s*/, $rest;\n        } else {\n            die \"Internal error (unknown type in configuration definition)\";\n        }\n    }\n}\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}\n"}
{"id": 349573, "name": "Kronecker product based fractals", "source": "Translate Perl to Java: use Imager;\nuse Math::Cartesian::Product;\n\nsub kronecker_product {\n    our @a; local *a = shift;\n    our @b; local *b = shift;\n    my @c;\n    cartesian {\n        my @cc;\n        cartesian {\n            push @cc, $_[0] * $_[1];\n        } [@{$_[0]}], [@{$_[1]}];\n        push @c, [@cc];\n    } [@a], [@b];\n    @c\n}\n\nsub kronecker_fractal {\n    my($order, @pattern) = @_;\n    my @kronecker = @pattern;\n    @kronecker = kronecker_product(\\@kronecker, \\@pattern) for 0..$order-1;\n    @kronecker\n}\n\n@vicsek = ( [0, 1, 0], [1, 1, 1], [0, 1, 0] );\n@carpet = ( [1, 1, 1], [1, 0, 1], [1, 1, 1] );\n@six    = ( [0,1,1,1,0], [1,0,0,0,1], [1,0,0,0,0], [1,1,1,1,0], [1,0,0,0,1], [1,0,0,0,1], [0,1,1,1,0] );\n\nfor (['vicsek', \\@vicsek, 4],\n     ['carpet', \\@carpet, 4],\n     ['six',    \\@six,    3]) {\n    ($name, $shape, $order) = @$_;\n    @img = kronecker_fractal( $order, @$shape );\n    $png = Imager->new(xsize => 1+@{$img[0]}, ysize => 1+@img);\n    cartesian {\n        $png->setpixel(x => $_[0], y => $_[1], color => $img[$_[1]][$_[0]] ? [255, 255, 32] : [16, 16, 16]);\n    } [0..@{$img[0]}-1], [0..$\n    $png->write(file => \"run/kronecker-$name-perl6.png\");\n}\n", "target": "package kronecker;\n\n\npublic class ProductFractals {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void show_matrix(final int[][] m, final char nz, final char z) {\n    for (int im = 0; im < m.length; im++) {\n      for (int jm = 0; jm < m[im].length; jm++) {\n        System.out.print(m[im][jm] == 0 ? z : nz);\n      }\n      System.out.println();\n    }\n  }\n\n  \n  public static int[][] power(final int[][] m, final int n) {\n    \n    int[][] m_pow = m;\n    \n    \n    for (int ix = 1; ix < n; ix++) {\n      m_pow = product(m, m_pow);\n    }\n    return m_pow;\n  }\n\n  \n  private static void test(final int[][] m, final int n) {\n    System.out.println(\"Test matrix\");\n    show_matrix(m, '*', ' ');\n    final int[][] m_pow = power(m, n);\n    System.out.println(\"Matrix power \" + n);\n    show_matrix(m_pow, '*', ' ');\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] m = {{0, 1, 0},\n                       {1, 1, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] m = {{1, 1, 1},\n                       {1, 0, 1},\n                       {1, 1, 1}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test3() {\n    \n    final int[][] m = {{1, 0, 1},\n                       {1, 0, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n    test3();\n  }\n\n}\n"}
{"id": 349574, "name": "Additive primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory 'is_prime';\nuse List::Util <sum max>;\n\nsub pp {\n    my $format = ('%' . (my $cw = 1+length max @_) . 'd') x @_;\n    my $width  = \".{@{[$cw * int 60/$cw]}}\";\n    (sprintf($format, @_)) =~ s/($width)/$1\\n/gr;\n}\n\nmy($limit, @ap) = 500;\nis_prime($_) and is_prime(sum(split '',$_)) and push @ap, $_ for 1..$limit;\n\nprint @ap . \" additive primes < $limit:\\n\" . pp(@ap);\n", "target": "public class additivePrimes {\n\n    public static void main(String[] args) {\n        int additive_primes = 0;\n        for (int i = 2; i < 500; i++) {\n            if(isPrime(i) && isPrime(digitSum(i))){\n                additive_primes++;\n                System.out.print(i + \" \");\n            }\n        }\n        System.out.print(\"\\nFound \" + additive_primes + \" additive primes less than 500\");\n    }\n\n    static boolean isPrime(int n) {\n        int counter = 1;\n        if (n < 2 || (n != 2 && n % 2 == 0) || (n != 3 && n % 3 == 0)) {\n            return false;\n        }\n        while (counter * 6 - 1 <= Math.sqrt(n)) {\n            if (n % (counter * 6 - 1) == 0 || n % (counter * 6 + 1) == 0) {\n                return false;\n            } else {\n                counter++;\n            }\n        }\n        return true;\n    }\n\n    static int digitSum(int n) {\n        int sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"}
{"id": 349575, "name": "Case-sensitivity of identifiers", "source": "Translate Perl to Java: \n$dog='Benjamin';\n$Dog='Samba';\n$DOG='Bernie';\nprint \"The three dogs are named $dog, $Dog, and $DOG \\n\"\n", "target": "String dog = \"Benjamin\"; \nString Dog = \"Samba\";    \nString DOG = \"Bernie\";   \n@Inject Console console;\nconsole.print($\"There are three dogs named {dog}, {Dog}, and {DOG}\");\n"}
{"id": 349576, "name": "Extra primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(is_prime vecsum todigits forprimes);\n\nmy $str;\nforprimes {\n    is_prime(vecsum(todigits($_))) and /^[2357]+$/ and $str .= sprintf '%-5d', $_;\n} 1e4;\nsay $str =~ s/.{1,80}\\K /\\n/gr;\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 349577, "name": "Extra primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse ntheory qw(is_prime vecsum todigits forprimes);\n\nmy $str;\nforprimes {\n    is_prime(vecsum(todigits($_))) and /^[2357]+$/ and $str .= sprintf '%-5d', $_;\n} 1e4;\nsay $str =~ s/.{1,80}\\K /\\n/gr;\n", "target": "public class ExtraPrimes {\n    private static int nextPrimeDigitNumber(int n) {\n        if (n == 0) {\n            return 2;\n        }\n        switch (n % 10) {\n            case 2:\n                return n + 1;\n            case 3:\n            case 5:\n                return n + 2;\n            default:\n                return 2 + nextPrimeDigitNumber(n / 10) * 10;\n        }\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n        if ((n & 1) == 0) {\n            return n == 2;\n        }\n        if (n % 3 == 0) {\n            return n == 3;\n        }\n        if (n % 5 == 0) {\n            return n == 5;\n        }\n\n        int[] wheel = new int[]{4, 2, 4, 2, 4, 6, 2, 6};\n        int p = 7;\n        while (true) {\n            for (int w : wheel) {\n                if (p * p > n) {\n                    return true;\n                }\n                if (n % p == 0) {\n                    return false;\n                }\n                p += w;\n            }\n        }\n    }\n\n    private static int digitSum(int n) {\n        int sum = 0;\n        for (; n > 0; n /= 10) {\n            sum += n % 10;\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 10_000;\n        int p = 0, n = 0;\n\n        System.out.printf(\"Extra primes under %d:\\n\", limit);\n        while (p < limit) {\n            p = nextPrimeDigitNumber(p);\n            if (isPrime(p) && isPrime(digitSum(p))) {\n                n++;\n                System.out.printf(\"%2d: %d\\n\", n, p);\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 349578, "name": "Abbreviations, easy", "source": "Translate Perl to Java: @c = (join ' ', qw<\nAdd ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\nCOUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\nNFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\nJoin SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\nMErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\nREAD  RECover REFRESH RENum Replace REPeat  CReplace  RESet  RESTore  RGTLEFT\nRIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n>) =~ /([A-Z]+)([a-z]*)(?:\\s+|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor ($i = 0; $i < @c; $i += 2) {\n    $sl = length($s =    $c[$i]  );\n    $ll = length($l = uc $c[$i+1]);\n    $abr{$s} = $w = $s.$l;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n    $abr{$w} = $w; \n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\"\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class AbbreviationsEasy {\n    private static final Scanner input = new Scanner(System.in);\n    private static final String  COMMAND_TABLE\n            =       \"  Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\\n\" +\n                    \" COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\\n\" +\n                    \" NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\\n\" +\n                    \" Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\\n\" +\n                    \" MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\\n\" +\n                    \" READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\\n\" +\n                    \" RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus TOP TRAnsfer Type Up\";\n\n    public static void main(String[] args) {\n        String[]             cmdTableArr = COMMAND_TABLE.split(\"\\\\s+\");\n        Map<String, Integer> cmd_table   = new HashMap<String, Integer>();\n\n        for (String word : cmdTableArr) {  \n            cmd_table.put(word, countCaps(word));\n        }\n\n        System.out.print(\"Please enter your command to verify: \");\n        String   userInput  = input.nextLine();\n        String[] user_input = userInput.split(\"\\\\s+\");\n\n        for (String s : user_input) {\n            boolean match = false; \n            for (String cmd : cmd_table.keySet()) {\n                if (s.length() >= cmd_table.get(cmd) && s.length() <= cmd.length()) {\n                    String temp = cmd.toUpperCase();\n                    if (temp.startsWith(s.toUpperCase())) {\n                        System.out.print(temp + \" \");\n                        match = true;\n                    }\n                }\n            }\n            if (!match) { \n                System.out.print(\"*error* \");\n            }\n        }\n    }\n\n    private static int countCaps(String word) {\n        int numCaps = 0;\n        for (int i = 0; i < word.length(); i++) {\n            if (Character.isUpperCase(word.charAt(i))) {\n                numCaps++;\n            }\n        }\n        return numCaps;\n    }\n}\n"}
{"id": 349579, "name": "Abbreviations, easy", "source": "Translate Perl to Java: @c = (join ' ', qw<\nAdd ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\nCOUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\nNFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\nJoin SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\nMErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\nREAD  RECover REFRESH RENum Replace REPeat  CReplace  RESet  RESTore  RGTLEFT\nRIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus  TOP TRAnsfer Type Up\n>) =~ /([A-Z]+)([a-z]*)(?:\\s+|$)/g;\n\nmy %abr = ('' => '', ' ' => '');\nfor ($i = 0; $i < @c; $i += 2) {\n    $sl = length($s =    $c[$i]  );\n    $ll = length($l = uc $c[$i+1]);\n    $abr{$s} = $w = $s.$l;\n    map { $abr{substr($w, 0, $_)} = $w } $sl .. $ll;\n    $abr{$w} = $w; \n}\n\n$fmt = \"%-10s\";\n$inp = sprintf $fmt, 'Input:';\n$out = sprintf $fmt, 'Output:';\nfor $str ('', qw<riG rePEAT copies put mo rest types fup. 6 poweRin>) {\n    $inp .= sprintf $fmt, $str;\n    $out .= sprintf $fmt, $abr{uc $str} // '*error*';\n}\n\nprint \"$inp\\n$out\\n\"\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class AbbreviationsEasy {\n    private static final Scanner input = new Scanner(System.in);\n    private static final String  COMMAND_TABLE\n            =       \"  Add ALTer  BAckup Bottom  CAppend Change SCHANGE  CInsert CLAst COMPress COpy\\n\" +\n                    \" COUnt COVerlay CURsor DELete CDelete Down DUPlicate Xedit EXPand EXTract Find\\n\" +\n                    \" NFind NFINDUp NFUp CFind FINdup FUp FOrward GET Help HEXType Input POWerinput\\n\" +\n                    \" Join SPlit SPLTJOIN  LOAD  Locate CLocate  LOWercase UPPercase  LPrefix MACRO\\n\" +\n                    \" MErge MODify MOve MSG Next Overlay PARSE PREServe PURge PUT PUTD  Query  QUIT\\n\" +\n                    \" READ  RECover REFRESH RENum REPeat  Replace CReplace  RESet  RESTore  RGTLEFT\\n\" +\n                    \" RIght LEft  SAVE  SET SHift SI  SORT  SOS  STAck STATus TOP TRAnsfer Type Up\";\n\n    public static void main(String[] args) {\n        String[]             cmdTableArr = COMMAND_TABLE.split(\"\\\\s+\");\n        Map<String, Integer> cmd_table   = new HashMap<String, Integer>();\n\n        for (String word : cmdTableArr) {  \n            cmd_table.put(word, countCaps(word));\n        }\n\n        System.out.print(\"Please enter your command to verify: \");\n        String   userInput  = input.nextLine();\n        String[] user_input = userInput.split(\"\\\\s+\");\n\n        for (String s : user_input) {\n            boolean match = false; \n            for (String cmd : cmd_table.keySet()) {\n                if (s.length() >= cmd_table.get(cmd) && s.length() <= cmd.length()) {\n                    String temp = cmd.toUpperCase();\n                    if (temp.startsWith(s.toUpperCase())) {\n                        System.out.print(temp + \" \");\n                        match = true;\n                    }\n                }\n            }\n            if (!match) { \n                System.out.print(\"*error* \");\n            }\n        }\n    }\n\n    private static int countCaps(String word) {\n        int numCaps = 0;\n        for (int i = 0; i < word.length(); i++) {\n            if (Character.isUpperCase(word.charAt(i))) {\n                numCaps++;\n            }\n        }\n        return numCaps;\n    }\n}\n"}
{"id": 349580, "name": "Sorting algorithms_Stooge sort", "source": "Translate Perl to Java: sub stooge {\n        use integer;\n        my ($x, $i, $j) = @_;\n\n        $i //= 0;\n        $j //= $\n\n        if ( $x->[$j] < $x->[$i] ) {\n                @$x[$i, $j] = @$x[$j, $i];\n        }\n        if ( $j - $i > 1 ) {\n                my $t = ($j - $i + 1) / 3;\n                stooge( $x, $i,      $j - $t );\n                stooge( $x, $i + $t, $j      ); \n                stooge( $x, $i,      $j - $t );\n        }\n}\n\n\nmy @a = map (int rand(100), 1 .. 10);\nprint \"Before @a\\n\";\nstooge(\\@a);\nprint \"After  @a\\n\";\n", "target": "import java.util.Arrays;\n\npublic class Stooge {\n    public static void main(String[] args) {\n        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};\n        stoogeSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void stoogeSort(int[] L) {\n        stoogeSort(L, 0, L.length - 1);\n    }\n\n    public static void stoogeSort(int[] L, int i, int j) {\n        if (L[j] < L[i]) {\n            int tmp = L[i];\n            L[i] = L[j];\n            L[j] = tmp;\n        }\n        if (j - i > 1) {\n            int t = (j - i + 1) / 3;\n            stoogeSort(L, i, j - t);\n            stoogeSort(L, i + t, j);\n            stoogeSort(L, i, j - t);\n        }\n    }\n}\n"}
{"id": 349581, "name": "Truncate a file", "source": "Translate Perl to Java: \nopen FOO, \">>file\" or die;\ntruncate(FOO, 1234);\nclose FOO;\n\n\ntruncate(\"file\", 567);\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\npublic class TruncFile {\n\tpublic static void main(String[] args) throws IOException{\n\t\tif(args.length < 2){\n\t\t\tSystem.out.println(\"Usage: java TruncFile fileName newSize\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tFileChannel outChan = new FileOutputStream(args[0], true).getChannel();\n\t\tlong newSize = Long.parseLong(args[1]);\n\t\toutChan.truncate(newSize);\n\t\toutChan.close();\n\t}\n}\n"}
{"id": 349582, "name": "Truncate a file", "source": "Translate Perl to Java: \nopen FOO, \">>file\" or die;\ntruncate(FOO, 1234);\nclose FOO;\n\n\ntruncate(\"file\", 567);\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\npublic class TruncFile {\n\tpublic static void main(String[] args) throws IOException{\n\t\tif(args.length < 2){\n\t\t\tSystem.out.println(\"Usage: java TruncFile fileName newSize\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tFileChannel outChan = new FileOutputStream(args[0], true).getChannel();\n\t\tlong newSize = Long.parseLong(args[1]);\n\t\toutChan.truncate(newSize);\n\t\toutChan.close();\n\t}\n}\n"}
{"id": 349583, "name": "Sorting algorithms_Shell sort", "source": "Translate Perl to Java: sub shell_sort {\n    my (@a, $h, $i, $j, $k) = @_;\n    for ($h = @a; $h = int $h / 2;) {\n        for $i ($h .. $\n            $k = $a[$i];\n            for ($j = $i; $j >= $h && $k < $a[$j - $h]; $j -= $h) {\n                $a[$j] = $a[$j - $h];\n            }\n            $a[$j] = $k;\n        }\n    }\n    @a;\n}\n\nmy @a = map int rand 100, 1 .. $ARGV[0] || 10;\nsay \"@a\";\n@a = shell_sort @a;\nsay \"@a\";\n", "target": "public static void shell(int[] a) {\n\tint increment = a.length / 2;\n\twhile (increment > 0) {\n\t\tfor (int i = increment; i < a.length; i++) {\n\t\t\tint j = i;\n\t\t\tint temp = a[i];\n\t\t\twhile (j >= increment && a[j - increment] > temp) {\n\t\t\t\ta[j] = a[j - increment];\n\t\t\t\tj = j - increment;\n\t\t\t}\n\t\t\ta[j] = temp;\n\t\t}\n\t\tif (increment == 2) {\n\t\t\tincrement = 1;\n\t\t} else {\n\t\t\tincrement *= (5.0 / 11);\n\t\t}\n\t}\n}\n"}
{"id": 349584, "name": "Deconvolution_1D", "source": "Translate Perl to Java: use v5.36;\nuse Math::Cartesian::Product;\n\nsub deconvolve($g,$f) {\n    my @g = @{$g};\n    my @f = @{$f};\n    my(@m,@d);\n\n    my $h = 1 + @g - @f;\n    push @m, [(0) x $h, $g[$_]] for 0..$\n    for my $j (0..$h-1) {\n        for my $k (0..$\n            $m[$j + $k][$j] = $f[$k]\n        }\n    }\n    rref(\\@m);\n    push @d, @{ $m[$_] }[$h] for 0..$h-1;\n    @d;\n}\n\nsub convolve($f,$h) {\n    my @f = @{$f};\n    my @h = @{$h};\n    my @i;\n    for my $x (cartesian {@_} [0..$\n        push @i, @$x[0]+@$x[1];\n    }\n    my $cnt = 0;\n    my @g = (0) x (@f + @h - 1);\n    for my $x (cartesian {@_} [@f], [@h]) {\n        $g[$i[$cnt++]] += @$x[0]*@$x[1];\n    }\n    @g;\n}\n\nsub rref($m) {\n  my @m = @{$m};\n  @m or return;\n  my ($lead, $rows, $cols) = (0, scalar(@m), scalar(@{$m[0]}));\n\n  for my $r (0 .. $rows - 1) {\n      $lead < $cols or return;\n      my $i = $r;\n\n      until ($m[$i][$lead]) {\n          ++$i == $rows or next;\n          $i = $r;\n          ++$lead == $cols and return;\n      }\n\n      @m[$i, $r] = @m[$r, $i];\n      my $lv = $m[$r][$lead];\n      $_ /= $lv foreach @{ $m[$r] };\n\n      my @mr = @{ $m[$r] };\n      for my $i (0 .. $rows - 1) {\n          $i == $r and next;\n          ($lv, my $n) = ($m[$i][$lead], -1);\n          $_ -= $lv * $mr[++$n] foreach @{ $m[$i] };\n      }\n      ++$lead;\n   }\n}\n\nmy @h = qw<-8 -9 -3 -1 -6 7>;\nmy @f = qw<-3 -6 -1 8 -6 3 -1 -9 -9 3 -2 5 2 -2 -7 -1>;\nprint '  conv(f,h) = g = ' . join(' ', my @g = convolve(\\@f, \\@h)) . \"\\n\";\nprint 'deconv(g,f) = h = ' . join(' ', deconvolve(\\@g, \\@f)) . \"\\n\";\nprint 'deconv(g,h) = f = ' . join(' ', deconvolve(\\@g, \\@h)) . \"\\n\";\n", "target": "import java.util.Arrays;\n\npublic class Deconvolution1D {\n    public static int[] deconv(int[] g, int[] f) {\n        int[] h = new int[g.length - f.length + 1];\n        for (int n = 0; n < h.length; n++) {\n            h[n] = g[n];\n            int lower = Math.max(n - f.length + 1, 0);\n            for (int i = lower; i < n; i++)\n                h[n] -= h[i] * f[n - i];\n            h[n] /= f[0];\n        }\n        return h;\n    }\n\n    public static void main(String[] args) {\n        int[] h = { -8, -9, -3, -1, -6, 7 };\n        int[] f = { -3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1 };\n        int[] g = { 24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96,\n                96, 31, 55, 36, 29, -43, -7 };\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"h = \" + Arrays.toString(h) + \"\\n\");\n        sb.append(\"deconv(g, f) = \" + Arrays.toString(deconv(g, f)) + \"\\n\");\n        sb.append(\"f = \" + Arrays.toString(f) + \"\\n\");\n        sb.append(\"deconv(g, h) = \" + Arrays.toString(deconv(g, h)) + \"\\n\");\n        System.out.println(sb.toString());\n    }\n}\n"}
{"id": 349585, "name": "Read a specific line from a file", "source": "Translate Perl to Java: \n\nwhile (<>) { $. == $n and print, exit }\ndie \"file too short\\n\";\n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 349586, "name": "Read a specific line from a file", "source": "Translate Perl to Java: \n\nwhile (<>) { $. == $n and print, exit }\ndie \"file too short\\n\";\n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 349587, "name": "URL encoding", "source": "Translate Perl to Java: sub urlencode {\n    my $s = shift;\n    $s =~ s/([^-A-Za-z0-9_.!~*'() ])/sprintf(\"%%%02X\", ord($1))/eg;\n    $s =~ tr/ /+/;\n    return $s;\n}\n\nprint urlencode('http://foo bar/').\"\\n\";\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String normal = \"http:\n        String encoded = URLEncoder.encode(normal, \"utf-8\");\n        System.out.println(encoded);\n    }\n}\n"}
{"id": 349588, "name": "URL encoding", "source": "Translate Perl to Java: sub urlencode {\n    my $s = shift;\n    $s =~ s/([^-A-Za-z0-9_.!~*'() ])/sprintf(\"%%%02X\", ord($1))/eg;\n    $s =~ tr/ /+/;\n    return $s;\n}\n\nprint urlencode('http://foo bar/').\"\\n\";\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.net.URLEncoder;\n\npublic class Main\n{\n    public static void main(String[] args) throws UnsupportedEncodingException\n    {\n        String normal = \"http:\n        String encoded = URLEncoder.encode(normal, \"utf-8\");\n        System.out.println(encoded);\n    }\n}\n"}
{"id": 349589, "name": "LU decomposition", "source": "Translate Perl to Java: use List::Util qw(sum);\n\nfor $test (\n    [[1, 3, 5],\n     [2, 4, 7],\n     [1, 1, 0]],\n\n    [[11,  9, 24,  2],\n     [ 1,  5,  2,  6],\n     [ 3, 17, 18,  1],\n     [ 2,  5,  7,  1]]\n) {\n    my($P, $AP, $L, $U) = lu(@$test);\n    say_it('A matrix', @$test);\n    say_it('P matrix',  @$P);\n    say_it('AP matrix', @$AP);\n    say_it('L matrix',  @$L);\n    say_it('U matrix',  @$U);\n\n}\n\nsub lu {\n    my (@a) = @_;\n    my $n = +@a;\n    my @P  = pivotize(@a);\n    my $AP = mmult(\\@P, \\@a);\n    my @L  = matrix_ident($n);\n    my @U  = matrix_zero($n);\n    for $i (0..$n-1) {\n        for $j (0..$n-1) {\n            if ($j >= $i) {\n                $U[$i][$j] =  $$AP[$i][$j] - sum map { $U[$_][$j] * $L[$i][$_] } 0..$i-1;\n            } else {\n                $L[$i][$j] = ($$AP[$i][$j] - sum map { $U[$_][$j] * $L[$i][$_] } 0..$j-1) / $U[$j][$j];\n            }\n        }\n    }\n    return \\@P, $AP, \\@L, \\@U;\n}\n\nsub pivotize {\n    my(@m) = @_;\n    my $size = +@m;\n    my @id = matrix_ident($size);\n    for $i (0..$size-1) {\n        my $max = $m[$i][$i];\n        my $row = $i;\n        for $j ($i .. $size-2) {\n            if ($m[$j][$i] > $max) {\n                $max = $m[$j][$i];\n                $row = $j;\n            }\n        }\n        ($id[$row],$id[$i]) = ($id[$i],$id[$row]) if $row != $i;\n    }\n    @id\n}\n\nsub matrix_zero  { my($n) = @_; map { [ (0) x $n ] } 0..$n-1 }\nsub matrix_ident { my($n) = @_; map { [ (0) x $_, 1, (0) x ($n-1 - $_) ] } 0..$n-1 }\n\nsub mmult {\n  local *a = shift;\n  local *b = shift;\n  my @p = [];\n  my $rows = @a;\n  my $cols = @{ $b[0] };\n  my $n = @b - 1;\n  for (my $r = 0 ; $r < $rows ; ++$r) {\n      for (my $c = 0 ; $c < $cols ; ++$c) {\n          $p[$r][$c] += $a[$r][$_] * $b[$_][$c] foreach 0 .. $n;\n      }\n  }\n  return [@p];\n}\n\nsub say_it {\n    my($message, @array) = @_;\n    print \"$message\\n\";\n    $line = sprintf join(\"\\n\" => map join(\" \" => map(sprintf(\"%8.5f\", $_), @$_)), @{+\\@array}).\"\\n\";\n    $line =~ s/\\.00000/      /g;\n    $line =~ s/0000\\b/    /g;\n    print \"$line\\n\";\n}\n", "target": "import static java.util.Arrays.stream;\nimport java.util.Locale;\nimport static java.util.stream.IntStream.range;\n\npublic class Test {\n\n    static double dotProduct(double[] a, double[] b) {\n        return range(0, a.length).mapToDouble(i -> a[i] * b[i]).sum();\n    }\n\n    static double[][] matrixMul(double[][] A, double[][] B) {\n        double[][] result = new double[A.length][B[0].length];\n        double[] aux = new double[B.length];\n\n        for (int j = 0; j < B[0].length; j++) {\n\n            for (int k = 0; k < B.length; k++)\n                aux[k] = B[k][j];\n\n            for (int i = 0; i < A.length; i++)\n                result[i][j] = dotProduct(A[i], aux);\n        }\n        return result;\n    }\n\n    static double[][] pivotize(double[][] m) {\n        int n = m.length;\n        double[][] id = range(0, n).mapToObj(j -> range(0, n)\n                .mapToDouble(i -> i == j ? 1 : 0).toArray())\n                .toArray(double[][]::new);\n\n        for (int i = 0; i < n; i++) {\n            double maxm = m[i][i];\n            int row = i;\n            for (int j = i; j < n; j++)\n                if (m[j][i] > maxm) {\n                    maxm = m[j][i];\n                    row = j;\n                }\n\n            if (i != row) {\n                double[] tmp = id[i];\n                id[i] = id[row];\n                id[row] = tmp;\n            }\n        }\n        return id;\n    }\n\n    static double[][][] lu(double[][] A) {\n        int n = A.length;\n        double[][] L = new double[n][n];\n        double[][] U = new double[n][n];\n        double[][] P = pivotize(A);\n        double[][] A2 = matrixMul(P, A);\n\n        for (int j = 0; j < n; j++) {\n            L[j][j] = 1;\n            for (int i = 0; i < j + 1; i++) {\n                double s1 = 0;\n                for (int k = 0; k < i; k++)\n                    s1 += U[k][j] * L[i][k];\n                U[i][j] = A2[i][j] - s1;\n            }\n            for (int i = j; i < n; i++) {\n                double s2 = 0;\n                for (int k = 0; k < j; k++)\n                    s2 += U[k][j] * L[i][k];\n                L[i][j] = (A2[i][j] - s2) / U[j][j];\n            }\n        }\n        return new double[][][]{L, U, P};\n    }\n\n    static void print(double[][] m) {\n        stream(m).forEach(a -> {\n            stream(a).forEach(n -> System.out.printf(Locale.US, \"%5.1f \", n));\n            System.out.println();\n        });\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        double[][] a = {{1.0, 3, 5}, {2.0, 4, 7}, {1.0, 1, 0}};\n\n        double[][] b = {{11.0, 9, 24, 2}, {1.0, 5, 2, 6}, {3.0, 17, 18, 1},\n        {2.0, 5, 7, 1}};\n\n        for (double[][] m : lu(a))\n            print(m);\n\n        System.out.println();\n\n        for (double[][] m : lu(b))\n            print(m);\n    }\n}\n"}
{"id": 349590, "name": "Sum data type", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub filter {\n    my($text) = @_;\n    if (length($text)>1 and $text eq reverse $text) {\n        return 1, 'Palindromic';\n    } elsif (0 == length(($text =~ s/\\B..*?\\b\u00a0?//gr) =~ s/^(.)\\1+//r)) {\n        return 1, 'Alliterative';\n    }\n    return 0, 'Does not compute';\n}\n\nfor my $text ('otto', 'ha ha', 'a', 'blue skies', 'tiptoe through the tulips', 12321) {\n    my($status,$message) = analyze $text;\n    printf \"%s $message\\n\", $status ? 'Yes' : 'No ';\n}\n", "target": "import java.util.Arrays;\n\npublic class SumDataType {\n\n    public static void main(String[] args) {\n        for ( ObjectStore<?> e : Arrays.asList(new ObjectStore<String>(\"String\"), new ObjectStore<Integer>(23), new ObjectStore<Float>(new Float(3.14159))) ) {\n            System.out.println(\"Object\u00a0: \" + e);\n        }\n    }\n    \n    public static class ObjectStore<T> {\n        private T object;\n        public ObjectStore(T object) {\n            this.object = object;\n        }\n        @Override\n        public String toString() {\n            return \"value [\" + object.toString() + \"], type = \" + object.getClass();\n        }\n    }\n\n}\n"}
{"id": 349591, "name": "Sum data type", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub filter {\n    my($text) = @_;\n    if (length($text)>1 and $text eq reverse $text) {\n        return 1, 'Palindromic';\n    } elsif (0 == length(($text =~ s/\\B..*?\\b\u00a0?//gr) =~ s/^(.)\\1+//r)) {\n        return 1, 'Alliterative';\n    }\n    return 0, 'Does not compute';\n}\n\nfor my $text ('otto', 'ha ha', 'a', 'blue skies', 'tiptoe through the tulips', 12321) {\n    my($status,$message) = analyze $text;\n    printf \"%s $message\\n\", $status ? 'Yes' : 'No ';\n}\n", "target": "import java.util.Arrays;\n\npublic class SumDataType {\n\n    public static void main(String[] args) {\n        for ( ObjectStore<?> e : Arrays.asList(new ObjectStore<String>(\"String\"), new ObjectStore<Integer>(23), new ObjectStore<Float>(new Float(3.14159))) ) {\n            System.out.println(\"Object\u00a0: \" + e);\n        }\n    }\n    \n    public static class ObjectStore<T> {\n        private T object;\n        public ObjectStore(T object) {\n            this.object = object;\n        }\n        @Override\n        public String toString() {\n            return \"value [\" + object.toString() + \"], type = \" + object.getClass();\n        }\n    }\n\n}\n"}
{"id": 349592, "name": "Optional parameters", "source": "Translate Perl to Java: sub sorttable\n {my @table = @{shift()};\n  my %opt =\n     (ordering => sub {$_[0] cmp $_[1]}, column => 0, reverse => 0, @_);\n  my $col = $opt{column};\n  my $func = $opt{ordering};\n  my @result = sort\n      {$func->($a->[$col], $b->[$col])}\n      @table;\n  return ($opt{reverse} ? [reverse @result] : \\@result);}\n", "target": "module OptionalParameters\n    {\n    typedef Type<String  >.Orderer as ColumnOrderer;\n    typedef Type<String[]>.Orderer as RowOrderer;\n\n    static String[][] sort(String[][]     table,\n                           ColumnOrderer? orderer = Null,\n                           Int            column  = 0,\n                           Boolean        reverse = False,\n                          )\n        {\n        \n        orderer ?:= (s1, s2) -> s1 <=> s2;\n\n        \n        ColumnOrderer byString = reverse\n                ? ((s1, s2) -> orderer(s1, s2).reversed)\n                : orderer;\n\n        \n        RowOrderer byColumn = (row1, row2) -> byString(row1[column], row2[column]);\n\n        return table.sorted(byColumn);\n        }\n\n    void run()\n        {\n        String[][] table =\n            [\n            [\"c\", \"x\", \"i\"],\n            [\"a\", \"y\", \"p\"],\n            [\"b\", \"z\", \"a\"],\n            ];\n\n        show(\"original input\", table);\n        show(\"by default sort on column 0\", sort(table));\n        show(\"by column 2\", sort(table, column=2));\n        show(\"by column 2 reversed\", sort(table, column=2, reverse=True));\n        }\n\n    void show(String title, String[][] table)\n        {\n        @Inject Console console;\n        console.print($\"{title}:\");\n        for (val row : table)\n            {\n            console.print($\"  {row}\");\n            }\n        console.print();\n        }\n    }\n"}
{"id": 349593, "name": "Numeric error propagation", "source": "Translate Perl to Java: use v5.36;\n\npackage ErrVar;\n\n\nsub zip ($f, $x, $y) {\n    my @out;\n    $y = [(0) x @$x] unless @$y; \n    push @out, $f->($x->[$_], $y->[$_]) for 0 .. $\n    \\@out\n}\n\nuse overload\n    '\"\"'   => \\&_str,\n    '+'    => \\&_add,\n    '-'    => \\&_sub,\n    '*'    => \\&_mul,\n    '/'    => \\&_div,\n    'bool' => \\&_bool,\n    '<=>'  => \\&_ncmp,\n    'neg'  => \\&_neg,\n    'sqrt' => \\&_sqrt,\n    'log'  => \\&_log,\n    'exp'  => \\&_exp,\n    '**'   => \\&_pow,\n;\n\n\n\nsub make ($x, @v) { bless [$x, @v] }\n\n\nsub mean ($x) { ref $x && $x->isa(__PACKAGE__) ? $x->[0] : $x }\n\n\nsub vlist ($x) { ref $x && $x->isa(__PACKAGE__) ? $x->[1] : [] }\n\nsub variance ($x) {\n    return 0 unless ref($x) and $x->isa(__PACKAGE__);\n    my $s;\n    $s += $_ * $_ for @{$x->[1]};\n    $s\n}\n\nsub covariance ($x, $y) {\n    return 0 unless ref($x) && $x->isa(__PACKAGE__);\n    return 0 unless ref($y) && $y->isa(__PACKAGE__);\n    my $s;\n    zip sub ($a,$b) { $s += $a * $b }, vlist($x), vlist($y);\n    $s\n}\n\nsub sigma ($v) { sqrt variance $v }\n\n\nsub _bool ($x, $, $)  {\n    abs(mean $x) > sigma $x\n}\n\nsub _ncmp ($a, $b, $) {\n    return 0 unless my $x = $a - $b;\n    mean($x) > 0 ? 1 : -1\n}\n\nsub _neg ($x, $, $) {\n    bless [ -mean($x), [map(-$_, @{vlist $x}) ] ];\n}\n\nsub _add ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    bless [$x0 + $y0, zip sub ($a,$b) {$a + $b}, $xv, $yv]\n}\n\nsub _sub ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    bless [$x0 - $y0, zip sub ($a,$b) {$a - $b}, $xv, $yv]\n}\n\nsub _mul ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    $xv = [ map($y0 * $_, @$xv) ];\n    $yv = [ map($x0 * $_, @$yv) ];\n    bless [$x0 * $y0, zip sub ($a,$b) {$a + $b}, $xv, $yv]\n}\n\nsub _div ($x, $y, $) {\n    my ($x0, $y0) = ( mean($x),  mean($y));\n    my ($xv, $yv) = (vlist($x), vlist($y));\n    $xv = [ map($_/$y0, @$xv) ];\n    $yv = [ map($x0 * $_/$y0/$y0, @$yv) ];\n    bless [$x0 / $y0, zip sub ($a,$b) {$a + $b}, $xv, $yv]\n}\n\nsub _sqrt ($x, $, $) {\n    my ($x0, $xv) =  ( mean($x), vlist($x) );\n    $x0 = sqrt($x0);\n    $xv = [ map($_ / 2 / $x0, @$xv) ];\n    bless [$x0, $xv]\n}\n\nsub _pow ($x, $y, $) {\n    if ($x < 0) {\n        die \"Can't take pow of negative number $x\" if int($y) != $y or $y & 1;\n        $x = -$x;\n    }\n    exp($y * log $x)\n}\n\nsub _exp ($x, $, $) {\n    my ($x0, $xv) =  ( exp(mean($x)), vlist($x) );\n    bless [ $x0, [map($x0 * $_, @$xv) ] ]\n}\n\nsub _log ($x, $, $) {\n    my ($x0, $xv) =  ( mean($x), vlist($x) );\n    bless [ log($x0), [ map($_ / $x0, @$xv) ] ]\n}\n\nsub _str { sprintf '%g\u00b1%.3g', $_[0][0], sigma($_[0]) }\n\npackage main;\n\nsub e { ErrVar::make @_ };\n\n\n\nmy $x1 = e 100, [1.1, 0,   0,   0  ];\nmy $x2 = e 200, [0,   2.2, 0,   0  ];\nmy $y1 = e 50,  [0,   0,   1.2, 0  ];\nmy $y2 = e 100, [0,   0,   0,   2.3];\n\nmy $z1 = sqrt(($x1 - $x2) ** 2 + ($y1 - $y2) ** 2);\nsay \"distance: $z1\";\n\n\nmy $a = $x1 + $x2;\nmy $b = $y1 - 2 * $x2;\nsay \"covariance between $a and $b: \", $a->covariance($b);\n", "target": "public class Approx {\n    private double value;\n    private double error;\n    \n    public Approx(){this.value = this.error = 0;}\n    \n    public Approx(Approx b){\n        this.value = b.value;\n        this.error = b.error;\n    }\n    \n    public Approx(double value, double error){\n        this.value = value;\n        this.error = error;\n    }\n    \n    public Approx add(Approx b){\n        value+= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx add(double b){\n        value+= b;\n        return this;\n    }\n    \n    public Approx sub(Approx b){\n        value-= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx sub(double b){\n        value-= b;\n        return this;\n    }\n    \n    public Approx mult(Approx b){\n        double oldVal = value;\n        value*= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx mult(double b){\n        value*= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx div(Approx b){\n        double oldVal = value;\n        value/= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx div(double b){\n        value/= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx pow(double b){\n        double oldVal = value;\n        value = Math.pow(value, b);\n        error = Math.abs(value * b * (error / oldVal));\n        return this;\n    }\n    \n    @Override\n    public String toString(){return value+\"\u00b1\"+error;}\n    \n    public static void main(String[] args){\n        Approx x1 = new Approx(100, 1.1);\n        Approx y1 = new Approx(50, 1.2);\n        Approx x2 = new Approx(200, 2.2);\n        Approx y2 = new Approx(100, 2.3);\n        \n        x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);\n        \n        System.out.println(x1);\n    }\n}\n"}
{"id": 349594, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Perl to Java: print \"Enter 11 numbers:\\n\";\nfor ( 1..11 ) {\n   $number = <STDIN>;\n   chomp $number;\n   push @sequence, $number;\n}\n\nfor $n (reverse @sequence) {\n   my $result = sqrt( abs($n) ) + 5 * $n**3;\n   printf \"f( %6.2f ) %s\\n\", $n, $result > 400 ? \"  too large!\" : sprintf \"= %6.2f\", $result\n}\n", "target": "\nimport java.util.*;\nimport java.io.*; \n\npublic class TPKA {\n\tpublic static void main(String... args) {\n\t\tdouble[] input = new double[11];\n\t\tdouble userInput = 0.0;\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(int i = 0; i < 11; i++) {\n\t\t\tSystem.out.print(\"Please enter a number: \");\n\t\t\tString s = in.nextLine();\n\t\t\ttry {\n\t\t\t\tuserInput = Double.parseDouble(s);\n\t\t\t} catch (NumberFormatException e) { \n\t\t\t\tSystem.out.println(\"You entered invalid input, exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tinput[i] = userInput;\n\t\t}\n\t\tfor(int j = 10; j >= 0; j--) {\n\t\t\tdouble x = input[j]; double y = f(x);\n\t\t\tif( y < 400.0) {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) =\u00a0%.2f\\n\", x, y);\n\t\t\t} else {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) = %s\\n\", x, \"TOO LARGE\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double f(double x) {\n\t\treturn Math.pow(Math.abs(x), 0.5) + (5*(Math.pow(x, 3)));\n\t}\n}\n"}
{"id": 349595, "name": "Rate counter", "source": "Translate Perl to Java: use Benchmark;\n\ntimethese COUNT,{ 'Job1' => &job1, 'Job2' => &job2 };\n\nsub job1\n{\n\t...job1 code...\n}\nsub job2\n{\n\t...job2 code...\n}\n", "target": "import java.util.function.Consumer;\n\npublic class RateCounter {\n\n    public static void main(String[] args) {\n        for (double d : benchmark(10, x -> System.out.print(\"\"), 10))\n            System.out.println(d);\n    }\n\n    static double[] benchmark(int n, Consumer<Integer> f, int arg) {\n        double[] timings = new double[n];\n        for (int i = 0; i < n; i++) {\n            long time = System.nanoTime();\n            f.accept(arg);\n            timings[i] = System.nanoTime() - time;\n        }\n        return timings;\n    }\n}\n"}
{"id": 349596, "name": "EKG sequence convergence", "source": "Translate Perl to Java: use List::Util qw(none sum);\n\nsub gcd { my ($u,$v) = @_; $v ? gcd($v, $u%$v) : abs($u) }\nsub shares_divisors_with { gcd( $_[0], $_[1]) > 1 }\n\nsub EKG {\n    my($n,$limit) = @_;\n    my @ekg = (1, $n);\n    while (@ekg < $limit) {\n        for my $i (2..1e18) {\n            next unless none { $_ == $i } @ekg and shares_divisors_with($ekg[-1], $i);\n            push(@ekg, $i) and last;\n        }\n    }\n    @ekg;\n}\n\nsub converge_at {\n    my($n1,$n2) = @_;\n    my $max = 100;\n    my @ekg1 = EKG($n1,$max);\n    my @ekg2 = EKG($n2,$max);\n    do { return $_+1 if $ekg1[$_] == $ekg2[$_] && sum(@ekg1[0..$_]) == sum(@ekg2[0..$_])} for 2..$max;\n    return \"(no convergence in $max terms)\";\n}\n\nprint \"EKG($_): \" . join(' ', EKG($_,10)) . \"\\n\" for 2, 5, 7, 9, 10;\nprint \"EKGs of 5 & 7 converge at term \" . converge_at(5, 7) . \"\\n\"\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class EKGSequenceConvergence {\n\n    public static void main(String[] args) {\n        System.out.println(\"Calculate and show here the first 10 members of EKG[2], EKG[5], EKG[7], EKG[9] and EKG[10].\");\n        for ( int i : new int[] {2, 5, 7, 9, 10} ) {\n            System.out.printf(\"EKG[%d] = %s%n\", i, ekg(i, 10));\n        }\n        System.out.println(\"Calculate and show here at which term EKG[5] and EKG[7] converge.\");\n        List<Integer> ekg5 = ekg(5, 100);\n        List<Integer> ekg7 = ekg(7, 100);\n        for ( int i = 1 ; i < ekg5.size() ; i++ ) {\n            if ( ekg5.get(i) == ekg7.get(i) && sameSeq(ekg5, ekg7, i)) {\n                System.out.printf(\"EKG[%d](%d) = EKG[%d](%d) = %d, and are identical from this term on%n\", 5, i+1, 7, i+1, ekg5.get(i));\n                break;\n            }\n        }\n    }\n    \n    \n    private static boolean sameSeq(List<Integer> seq1, List<Integer> seq2, int n) {\n        List<Integer> list1 = new ArrayList<>(seq1.subList(0, n));\n        Collections.sort(list1);\n        List<Integer> list2 = new ArrayList<>(seq2.subList(0, n));\n        Collections.sort(list2);\n        for ( int i = 0 ; i < n ; i++ ) {\n            if ( list1.get(i) != list2.get(i) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    \n    \n    \n    private static List<Integer> ekg(int two, int maxN) {\n        List<Integer> result = new ArrayList<>();\n        result.add(1);\n        result.add(two);\n        Map<Integer,Integer> seen = new HashMap<>();\n        seen.put(1, 1);\n        seen.put(two, 1);\n        int minUnseen = two == 2 ? 3 : 2;\n        int prev = two;\n        for ( int n = 3 ; n <= maxN ; n++ ) {\n            int test = minUnseen - 1;\n            while ( true ) {\n                test++;\n                if ( ! seen.containsKey(test) && gcd(test, prev) > 1 ) {\n                    \n                    result.add(test);\n                    seen.put(test, n);\n                    prev = test;\n                    if ( minUnseen == test ) {\n                        do {\n                            minUnseen++;\n                        } while ( seen.containsKey(minUnseen) );\n                    }\n                    break;\n                }\n            }\n        }\n        return result;\n    }\n\n    private static final int gcd(int a, int b) {\n        if ( b == 0 ) {\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n        \n}\n"}
{"id": 349597, "name": "Dice game probabilities", "source": "Translate Perl to Java: use List::Util qw(sum0 max);\n\nsub comb {\n    my ($s, $n) = @_;\n    $n || return (1);\n    my @r = (0) x ($n - max(@$s) + 1);\n    my @c = comb($s, $n - 1);\n    foreach my $i (0 .. $\n        $c[$i] || next;\n        foreach my $k (@$s) {\n            $r[$i + $k] += $c[$i];\n        }\n    }\n    return @r;\n}\n\nsub winning {\n    my ($s1, $n1, $s2, $n2) = @_;\n\n    my @p1 = comb($s1, $n1);\n    my @p2 = comb($s2, $n2);\n\n    my ($win, $loss, $tie) = (0, 0, 0);\n\n    foreach my $i (0 .. $\n        $win  += $p1[$i] * sum0(@p2[0    .. $i - 1]);\n        $tie  += $p1[$i] * sum0(@p2[$i   .. $i    ]);\n        $loss += $p1[$i] * sum0(@p2[$i+1 .. $\n    }\n    my $total = sum0(@p1) * sum0(@p2);\n    map { $_ / $total } ($win, $tie, $loss);\n}\n\nprint '(', join(', ', winning([1 ..  4], 9, [1 .. 6], 6)), \")\\n\";\nprint '(', join(', ', winning([1 .. 10], 5, [1 .. 7], 6)), \")\\n\";\n", "target": "import java.util.Random;\n\npublic class Dice{\n\tprivate static int roll(int nDice, int nSides){\n\t\tint sum = 0;\n\t\tRandom rand = new Random();\n\t\tfor(int i = 0; i < nDice; i++){\n\t\t\tsum += rand.nextInt(nSides) + 1;\n\t\t}\n\t\treturn sum;\n\t}\n\t\n\tprivate static int diceGame(int p1Dice, int p1Sides, int p2Dice, int p2Sides, int rolls){\n\t\tint p1Wins = 0;\n\t\tfor(int i = 0; i < rolls; i++){\n\t\t\tint p1Roll = roll(p1Dice, p1Sides);\n\t\t\tint p2Roll = roll(p2Dice, p2Sides);\n\t\t\tif(p1Roll > p2Roll) p1Wins++;\n\t\t}\n\t\treturn p1Wins;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tint p1Dice = 9; int p1Sides = 4;\n\t\tint p2Dice = 6; int p2Sides = 6;\n\t\tint rolls = 10000;\n\t\tint p1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 5; p1Sides = 10;\n\t\tp2Dice = 6; p2Sides = 7;\n\t\trolls = 10000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 9; p1Sides = 4;\n\t\tp2Dice = 6; p2Sides = 6;\n\t\trolls = 1000000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t\t\n\t\tSystem.out.println();\n\t\t\n\t\tp1Dice = 5; p1Sides = 10;\n\t\tp2Dice = 6; p2Sides = 7;\n\t\trolls = 1000000;\n\t\tp1Wins = diceGame(p1Dice, p1Sides, p2Dice, p2Sides, rolls);\n\t\tSystem.out.println(rolls + \" rolls, p1 = \" + p1Dice + \"d\" + p1Sides + \", p2 = \" + p2Dice + \"d\" + p2Sides);\n\t\tSystem.out.println(\"p1 wins \" + (100.0 * p1Wins / rolls) + \"% of the time\");\n\t}\n}\n"}
{"id": 349598, "name": "Metronome", "source": "Translate Perl to Java: use Time::HiRes qw(sleep gettimeofday);\n\nlocal $| = 1;    \n\nmy $beats_per_minute = shift || 72;\nmy $beats_per_bar    = shift || 4;\n\nmy $i         = 0;\nmy $duration  = 60 / $beats_per_minute;\nmy $base_time = gettimeofday() + $duration;\n\nfor (my $next_time = $base_time ; ; $next_time += $duration) {\n    if ($i++ % $beats_per_bar == 0) {\n        print \"\\nTICK\";\n    }\n    else {\n        print \" tick\";\n    }\n    sleep($next_time - gettimeofday());\n}\n", "target": "class Metronome{\n\tdouble bpm;\n\tint measure, counter;\n\tpublic Metronome(double bpm, int measure){\n\t\tthis.bpm = bpm;\n\t\tthis.measure = measure;\t\n\t}\n\tpublic void start(){\n\t\twhile(true){\n\t\t\ttry {\n\t\t\t\tThread.sleep((long)(1000*(60.0/bpm)));\n\t\t\t}catch(InterruptedException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tcounter++;\n\t\t\tif (counter%measure==0){\n\t\t\t\t System.out.println(\"TICK\");\n\t\t\t}else{\n\t\t\t\t System.out.println(\"TOCK\");\n\t\t\t}\n\t\t}\n\t}\n}\npublic class test {\n\tpublic static void main(String[] args) {\n\t\tMetronome metronome1 = new Metronome(120,4);\n\t\tmetronome1.start();\n\t}\n}\n"}
{"id": 349599, "name": "Sum of elements below main diagonal of matrix", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\nuse List::Util qw( sum );\n\nmy $matrix =\n  [[1,3,7,8,10],\n  [2,4,16,14,4],\n  [3,1,9,18,11],\n  [12,14,17,18,20],\n  [7,1,3,9,5]];\n\nmy $lowersum = sum map @{ $matrix->[$_] }[0 .. $_ - 1], 1 .. $\nprint \"lower sum = $lowersum\\n\";\n", "target": "public static void main(String[] args) {\n    int[][] matrix = {{1, 3, 7, 8, 10},\n                      {2, 4, 16, 14, 4},\n                      {3, 1, 9, 18, 11},\n                      {12, 14, 17, 18, 20},\n                      {7, 1, 3, 9, 5}};\n    int sum = 0;\n    for (int row = 1; row < matrix.length; row++) {\n        for (int col = 0; col < row; col++) {\n            sum += matrix[row][col];\n        }\n    }\n    System.out.println(sum);\n}\n"}
{"id": 349600, "name": "Pythagoras tree", "source": "Translate Perl to Java: use Imager;\n\nsub tree {\n    my ($img, $x1, $y1, $x2, $y2, $depth) = @_;\n\n    return () if $depth <= 0;\n\n    my $dx = ($x2 - $x1);\n    my $dy = ($y1 - $y2);\n\n    my $x3 = ($x2 - $dy);\n    my $y3 = ($y2 - $dx);\n    my $x4 = ($x1 - $dy);\n    my $y4 = ($y1 - $dx);\n    my $x5 = ($x4 + 0.5 * ($dx - $dy));\n    my $y5 = ($y4 - 0.5 * ($dx + $dy));\n\n    \n    $img->polygon(\n        points => [\n            [$x1, $y1],\n            [$x2, $y2],\n            [$x3, $y3],\n            [$x4, $y4],\n        ],\n        color => [0, 255 / $depth, 0],\n    );\n\n    \n    $img->polygon(\n        points => [\n            [$x3, $y3],\n            [$x4, $y4],\n            [$x5, $y5],\n        ],\n        color => [0, 255 / $depth, 0],\n    );\n\n    tree($img, $x4, $y4, $x5, $y5, $depth - 1);\n    tree($img, $x5, $y5, $x3, $y3, $depth - 1);\n}\n\nmy ($width, $height) = (1920, 1080);\nmy $img = Imager->new(xsize => $width, ysize => $height);\n$img->box(filled => 1, color => 'white');\ntree($img, $width/2.3, $height, $width/1.8, $height, 10);\n$img->write(file => 'pythagoras_tree.png');\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport javax.swing.*;\n\npublic class PythagorasTree extends JPanel {\n    final int depthLimit = 7;\n    float hue = 0.15f;\n\n    public PythagorasTree() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n    }\n\n    private void drawTree(Graphics2D g, float x1, float y1, float x2, float y2,\n            int depth) {\n\n        if (depth == depthLimit)\n            return;\n\n        float dx = x2 - x1;\n        float dy = y1 - y2;\n\n        float x3 = x2 - dy;\n        float y3 = y2 - dx;\n        float x4 = x1 - dy;\n        float y4 = y1 - dx;\n        float x5 = x4 + 0.5F * (dx - dy);\n        float y5 = y4 - 0.5F * (dx + dy);\n\n        Path2D square = new Path2D.Float();\n        square.moveTo(x1, y1);\n        square.lineTo(x2, y2);\n        square.lineTo(x3, y3);\n        square.lineTo(x4, y4);\n        square.closePath();\n\n        g.setColor(Color.getHSBColor(hue + depth * 0.02f, 1, 1));\n        g.fill(square);\n        g.setColor(Color.lightGray);\n        g.draw(square);\n\n        Path2D triangle = new Path2D.Float();\n        triangle.moveTo(x3, y3);\n        triangle.lineTo(x4, y4);\n        triangle.lineTo(x5, y5);\n        triangle.closePath();\n\n        g.setColor(Color.getHSBColor(hue + depth * 0.035f, 1, 1));\n        g.fill(triangle);\n        g.setColor(Color.lightGray);\n        g.draw(triangle);\n\n        drawTree(g, x4, y4, x5, y5, depth + 1);\n        drawTree(g, x5, y5, x3, y3, depth + 1);\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        drawTree((Graphics2D) g, 275, 500, 375, 500, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Pythagoras Tree\");\n            f.setResizable(false);\n            f.add(new PythagorasTree(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 349601, "name": "Rep-string", "source": "Translate Perl to Java: foreach (qw(1001110011 1110111011 0010010010 1010101010 1111111111 0100101101 0100100 101 11 00 1)) {\n    print \"$_\\n\";\n    if (/^(.+)\\1+(.*$)(?(?{ substr($1, 0, length $2) eq $2 })|(?!))/) {\n        print ' ' x length $1, \"$1\\n\\n\";\n    } else {\n        print \" (no repeat)\\n\\n\";\n    }\n}\n", "target": "public class RepString {\n\n    static final String[] input = {\"1001110011\", \"1110111011\", \"0010010010\",\n        \"1010101010\", \"1111111111\", \"0100101101\", \"0100100\", \"101\", \"11\",\n        \"00\", \"1\", \"0100101\"};\n\n    public static void main(String[] args) {\n        for (String s : input)\n            System.out.printf(\"%s\u00a0: %s%n\", s, repString(s));\n    }\n\n    static String repString(String s) {\n        int len = s.length();\n        outer:\n        for (int part = len / 2; part > 0; part--) {\n            int tail = len % part;\n            if (tail > 0 && !s.substring(0, tail).equals(s.substring(len - tail)))\n                continue;\n            for (int j = 0; j < len / part - 1; j++) {\n                int a = j * part;\n                int b = (j + 1) * part;\n                int c = (j + 2) * part;\n                if (!s.substring(a, b).equals(s.substring(b, c)))\n                    continue outer;\n            }\n            return s.substring(0, part);\n        }\n        return \"none\";\n    }\n}\n"}
{"id": 349602, "name": "Topswops", "source": "Translate Perl to Java: sub next_swop {\n  my( $max, $level, $p, $d ) = @_;\n  my $swopped = 0;\n  for( 2..@$p ){ \n    my @now = @$p;\n    if( $_ == $now[$_-1] ) {\n      splice @now, 0, 0, reverse splice @now, 0, $_;\n      $swopped = 1;\n      next_swop( $max, $level+1, \\@now, [ @$d ] );\n    }\n  }\n  for( 1..@$d ) { \n    my @now = @$p;\n    my $next = shift @$d;\n    if( not $now[$next-1] ) {\n      $now[$next-1] = $next;\n      splice @now, 0, 0, reverse splice @now, 0, $next;\n      $swopped = 1;\n      next_swop( $max, $level+1, \\@now, [ @$d ] );\n    }\n    push @$d, $next;\n  }\n  $$max = $level if !$swopped and $level > $$max;\n}\n\nsub topswops {\n  my $n = shift;\n  my @d = 2..$n;\n  my @p = ( 1, (0) x ($n-1) );\n  my $max = 0;\n  next_swop( \\$max, 0, \\@p, \\@d );\n  return $max;\n}\n\nprintf \"Maximum swops for %2d cards: %2d\\n\", $_, topswops $_ for 1..10;\n", "target": "public class Topswops {\n    static final int maxBest = 32;\n    static int[] best;\n\n    static private void trySwaps(int[] deck, int f, int d, int n) {\n        if (d > best[n])\n            best[n] = d;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (deck[i] == -1 || deck[i] == i)\n                break;\n            if (d + best[i] <= best[n])\n                return;\n        }\n\n        int[] deck2 = deck.clone();\n        for (int i = 1; i < n; i++) {\n            final int k = 1 << i;\n            if (deck2[i] == -1) {\n                if ((f & k) != 0)\n                    continue;\n            } else if (deck2[i] != i)\n                continue;\n\n            deck2[0] = i;\n            for (int j = i - 1; j >= 0; j--)\n                deck2[i - j] = deck[j]; \n            trySwaps(deck2, f | k, d + 1, n);\n        }\n    }\n\n    static int topswops(int n) {\n        assert(n > 0 && n < maxBest);\n        best[n] = 0;\n        int[] deck0 = new int[n + 1];\n        for (int i = 1; i < n; i++)\n            deck0[i] = -1;\n        trySwaps(deck0, 1, 0, n);\n        return best[n];\n    }\n\n    public static void main(String[] args) {\n        best = new int[maxBest];\n        for (int i = 1; i < 11; i++)\n            System.out.println(i + \": \" + topswops(i));\n    }\n}\n"}
{"id": 349603, "name": "Sequence_ smallest number greater than previous term with exactly n divisors", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse ntheory 'divisors';\n\nprint \"First 15 terms of OEIS: A069654\\n\";\nmy $m = 0;\nfor my $n (1..15) {\n    my $l = $m;\n    while (++$l) {\n        print(\"$l \"), $m = $l, last if $n == divisors($l);\n    }\n}\n", "target": "public class AntiPrimesPlus {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, next = 1; next <= max; ++i) {\n            if (next == count_divisors(i)) {           \n                System.out.printf(\"%d \", i);\n                next++;\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 349604, "name": "McNuggets problem", "source": "Translate Perl to Java: use ntheory qw/forperm gcd vecmin/;\n\nsub Mcnugget_number {\n    my $counts = shift;\n\n    return 'No maximum' if 1 < gcd @$counts;\n\n    my $min = vecmin @$counts;\n    my @meals;\n    my @min;\n\n    my $a = -1;\n    while (1) {\n        $a++;\n        for my $b (0..$a) {\n            for my $c (0..$b) {\n                my @s = ($a, $b, $c);\n                forperm {\n                    $meals[\n                        $s[$_[0]] * $counts->[0]\n                      + $s[$_[1]] * $counts->[1]\n                      + $s[$_[2]] * $counts->[2]\n                    ] = 1;\n                } @s;\n            }\n        }\n        for my $i (0..$\n            next unless $meals[$i];\n            if ($min[-1] and $i == ($min[-1] + 1)) {\n                push @min, $i;\n                last if $min == @min\n            } else {\n                @min = $i;\n            }\n        }\n        last if $min == @min\n    }\n    $min[0] ? $min[0] - 1 : 0\n}\n\nfor my $counts ([6,9,20], [6,7,20], [1,3,20], [10,5,18], [5,17,44], [2,4,6], [3,6,15]) {\n    print 'Maximum non-Mcnugget number using ' . join(', ', @$counts) . ' is: ' . Mcnugget_number($counts) . \"\\n\"\n}\n", "target": "public class McNuggets {\n\n    public static void main(String... args) {\n        int[] SIZES = new int[] { 6, 9, 20 };\n        int MAX_TOTAL = 100;\n        \n        int numSizes = SIZES.length;\n        int[] counts = new int[numSizes];\n        int maxFound = MAX_TOTAL + 1;\n        boolean[] found = new boolean[maxFound];\n        int numFound = 0;\n        int total = 0;\n        boolean advancedState = false;\n        do {\n            if (!found[total]) {\n                found[total] = true;\n                numFound++;\n            }\n            \n            \n            advancedState = false;\n            for (int i = 0; i < numSizes; i++) {\n                int curSize = SIZES[i];\n                if ((total + curSize) > MAX_TOTAL) {\n                    \n                    total -= counts[i] * curSize;\n                    counts[i] = 0;\n                }\n                else {\n                    \n                    counts[i]++;\n                    total += curSize;\n                    advancedState = true;\n                    break;\n                }\n            }\n            \n        } while ((numFound < maxFound) && advancedState);\n        \n        if (numFound < maxFound) {\n            \n            for (int i = MAX_TOTAL; i >= 0; i--) {\n                if (!found[i]) {\n                    System.out.println(\"Largest non-McNugget number in the search space is \" + i);\n                    break;\n                }\n            }\n        }\n        else {\n            System.out.println(\"All numbers in the search space are McNugget numbers\");\n        }\n        \n        return;\n    }\n}\n"}
{"id": 349605, "name": "Idiomatically determine all the lowercase and uppercase letters", "source": "Translate Perl to Java: use v5.12;\nuse utf8;\nbinmode STDOUT, ':utf8';\n\nmy($lower,$upper);\n\nfor my $i (0..2**8-1) {\n    my $c = chr $i;\n    $lower .= $c if $c =~ /[[:lower:]]/;\n    $upper .= $c if $c =~ /[[:upper:]]/;\n}\n\nsay $lower;\nsay $upper;\n", "target": "import java.util.stream.IntStream;\n\npublic class Letters {\n    public static void main(String[] args) throws Exception {\n        System.out.print(\"Upper case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isUpperCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n\n        System.out.print(\"Lower case: \");\n        IntStream.rangeClosed(0, 0x10FFFF)\n                 .filter(Character::isLowerCase)\n                 .limit(72)\n                 .forEach(n -> System.out.printf(\"%c\", n));\n        System.out.println(\"...\");\n    }\n}\n"}
{"id": 349606, "name": "Superellipse", "source": "Translate Perl to Java: use v5.36;\nmy($a, $b, $n, @q) = (200, 200, 2.5);\n\n\nsub y_from_x ($x) { int $b * abs(1 - ($x/$a) ** $n ) ** (1/$n) }\n\n\npush @q, $_, y_from_x($_) for 0..$a;\n\nopen  $fh, '>', 'superellipse.svg';\nprint $fh\n  qq|<svg height=\"@{[2*$b]}\" width=\"@{[2*$a]}\" xmlns=\"http://www.w3.org/2000/svg\">\\n|,\n  pline( 1, 1, @q ),\n  pline( 1,-1, @q ), \n  pline(-1,-1, @q ), \n  pline(-1, 1, @q ), \n  '</svg>';\n\nsub pline ($sx, $sy, @q) {\n  (@q[2*$_] *= $sx, @q[1+2*$_] *= $sy) for 0 .. $\n  qq|<polyline points=\"@q\"\n  style=\"fill:none;stroke:black;stroke-width:3\"\n  transform=\"translate($a, $b)\" />\\n|\n}\n", "target": "import java.awt.*;\nimport java.awt.geom.Path2D;\nimport static java.lang.Math.pow;\nimport java.util.Hashtable;\nimport javax.swing.*;\nimport javax.swing.event.*;\n\npublic class SuperEllipse extends JPanel implements ChangeListener {\n    private double exp = 2.5;\n\n    public SuperEllipse() {\n        setPreferredSize(new Dimension(650, 650));\n        setBackground(Color.white);\n        setFont(new Font(\"Serif\", Font.PLAIN, 18));\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(new Color(0xEEEEEE));\n\n        int w = getWidth();\n        int h = getHeight();\n        int spacing = 25;\n\n        for (int i = 0; i < w / spacing; i++) {\n            g.drawLine(0, i * spacing, w, i * spacing);\n            g.drawLine(i * spacing, 0, i * spacing, w);\n        }\n        g.drawLine(0, h - 1, w, h - 1);\n\n        g.setColor(new Color(0xAAAAAA));\n        g.drawLine(0, w / 2, w, w / 2);\n        g.drawLine(w / 2, 0, w / 2, w);\n    }\n\n    void drawLegend(Graphics2D g) {\n        g.setColor(Color.black);\n        g.setFont(getFont());\n        g.drawString(\"n = \" + String.valueOf(exp), getWidth() - 150, 45);\n        g.drawString(\"a = b = 200\", getWidth() - 150, 75);\n    }\n\n    void drawEllipse(Graphics2D g) {\n\n        final int a = 200; \n        double[] points = new double[a + 1];\n\n        Path2D p = new Path2D.Double();\n        p.moveTo(a, 0);\n\n        \n        for (int x = a; x >= 0; x--) {\n            points[x] = pow(pow(a, exp) - pow(x, exp), 1 / exp); \n            p.lineTo(x, -points[x]);\n        }\n\n        \n        for (int x = 0; x <= a; x++)\n            p.lineTo(x, points[x]);\n\n        for (int x = a; x >= 0; x--)\n            p.lineTo(-x, points[x]);\n\n        for (int x = 0; x <= a; x++)\n            p.lineTo(-x, -points[x]);\n\n        g.translate(getWidth() / 2, getHeight() / 2);\n        g.setStroke(new BasicStroke(2));\n\n        g.setColor(new Color(0x25B0C4DE, true));\n        g.fill(p);\n\n        g.setColor(new Color(0xB0C4DE)); \n        g.draw(p);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,\n                RenderingHints.VALUE_TEXT_ANTIALIAS_ON);\n\n        drawGrid(g);\n        drawLegend(g);\n        drawEllipse(g);\n    }\n\n    @Override\n    public void stateChanged(ChangeEvent e) {\n        JSlider source = (JSlider) e.getSource();\n        exp = source.getValue() / 2.0;\n        repaint();\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Super Ellipse\");\n            f.setResizable(false);\n            SuperEllipse panel = new SuperEllipse();\n            f.add(panel, BorderLayout.CENTER);\n\n            JSlider exponent = new JSlider(JSlider.HORIZONTAL, 1, 9, 5);\n            exponent.addChangeListener(panel);\n            exponent.setMajorTickSpacing(1);\n            exponent.setPaintLabels(true);\n            exponent.setBackground(Color.white);\n            exponent.setBorder(BorderFactory.createEmptyBorder(20, 20, 20, 20));\n\n            Hashtable<Integer, JLabel> labelTable = new Hashtable<>();\n            for (int i = 1; i < 10; i++)\n                labelTable.put(i, new JLabel(String.valueOf(i * 0.5)));\n            exponent.setLabelTable(labelTable);\n\n            f.add(exponent, BorderLayout.SOUTH);\n\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 349607, "name": "Mutex", "source": "Translate Perl to Java: use Thread qw'async';\nuse threads::shared;\n\nmy ($lock1, $lock2, $resource1, $resource2) :shared = (0) x 4;\n\nsub use_resource {\n        {       \n                lock $lock1;\n                $resource1 --;          \n                sleep(int rand 3);      \n                $resource1 ++;          \n                print \"In thread \", threads->tid(), \": \";\n                print \"Resource1 is $resource1\\n\";\n        }\n        {\n                lock $lock2;\n                $resource2 --;\n                sleep(int rand 3);\n                $resource2 ++;\n                print \"In thread \", threads->tid(), \": \";\n                print \"Resource2 is $resource2\\n\";\n        }\n}\n\n\nfor ( map async{ use_resource }, 1 .. 9) {\n        $_->join\n}\n", "target": "import java.util.concurrent.Semaphore;\n\npublic class VolatileClass{\n   public Semaphore mutex = new Semaphore(1); \n                                              \n   public void needsToBeSynched(){\n      \n   }\n   \n}\n"}
{"id": 349608, "name": "Jaro similarity", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse List::Util qw(min max);\n\nsub jaro {\n    my($s, $t) = @_;\n    my(@s_matches, @t_matches, $matches);\n\n    return 1 if $s eq $t;\n\n    my($s_len, @s) = (length $s, split //, $s);\n    my($t_len, @t) = (length $t, split //, $t);\n\n    my $match_distance = int (max($s_len, $t_len) / 2) - 1;\n    for my $i (0 .. $\n        my $start = max(0, $i - $match_distance);\n        my $end   = min($i + $match_distance + 1, $t_len);\n        for my $j ($start .. $end - 1) {\n            next if $t_matches[$j] or $s[$i] ne $t[$j];\n            ($s_matches[$i], $t_matches[$j]) = (1, 1);\n            $matches++ and last;\n        }\n    }\n    return 0 unless $matches;\n\n    my($k, $transpositions) = (0, 0);\n    for my $i (0 .. $\n        next unless $s_matches[$i];\n        $k++ until  $t_matches[$k];\n        $transpositions++ if $s[$i] ne $t[$k];\n        $k++;\n    }\n    ( $matches/$s_len + $matches/$t_len + (($matches - $transpositions/2) / $matches) ) / 3;\n}\n\nprintf \"%.3f\\n\", jaro(@$_[0], @$_[1]) for\n    ['MARTHA', 'MARHTA'], ['DIXON', 'DICKSONX'], ['JELLYFISH', 'SMELLYFISH'],\n    ['I repeat myself', 'I repeat myself'], ['', ''];\n", "target": "public class JaroDistance {\n    public static double jaro(String s, String t) {\n        int s_len = s.length();\n        int t_len = t.length();\n\n        if (s_len == 0 && t_len == 0) return 1;\n\n        int match_distance = Integer.max(s_len, t_len) / 2 - 1;\n\n        boolean[] s_matches = new boolean[s_len];\n        boolean[] t_matches = new boolean[t_len];\n\n        int matches = 0;\n        int transpositions = 0;\n\n        for (int i = 0; i < s_len; i++) {\n            int start = Integer.max(0, i-match_distance);\n            int end = Integer.min(i+match_distance+1, t_len);\n\n            for (int j = start; j < end; j++) {\n                if (t_matches[j]) continue;\n                if (s.charAt(i) != t.charAt(j)) continue;\n                s_matches[i] = true;\n                t_matches[j] = true;\n                matches++;\n                break;\n            }\n        }\n\n        if (matches == 0) return 0;\n\n        int k = 0;\n        for (int i = 0; i < s_len; i++) {\n            if (!s_matches[i]) continue;\n            while (!t_matches[k]) k++;\n            if (s.charAt(i) != t.charAt(k)) transpositions++;\n            k++;\n        }\n\n        return (((double)matches / s_len) +\n                ((double)matches / t_len) +\n                (((double)matches - transpositions/2.0) / matches)) / 3.0;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(jaro(   \"MARTHA\",      \"MARHTA\"));\n        System.out.println(jaro(    \"DIXON\",    \"DICKSONX\"));\n        System.out.println(jaro(\"JELLYFISH\",  \"SMELLYFISH\"));\n    }\n}\n"}
{"id": 349609, "name": "Odd word problem", "source": "Translate Perl to Java: sub r\n{\n\tmy ($f, $c) = @_;\n\treturn sub { print $c; $f->(); };\n}\n\n$r = sub {};\n\nwhile (read STDIN, $_, 1) {\n\t$w = /^[a-zA-Z]$/;\n\t$n++ if ($w && !$l);\n\t$l = $w;\n\tif ($n & 1 || !$w) {\n\t\t$r->(); $r = sub{};\n\t\tprint;\n\t} else {\n\t\t$r = r($r, $_);\n\t}\n}\n$r->();\n", "target": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}\n"}
{"id": 349610, "name": "Pseudo-random numbers_PCG32", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\nuse Math::AnyNum qw(:overload);\n\npackage PCG32 {\n\n    use constant {\n        mask32 => 2**32 - 1,\n        mask64 => 2**64 - 1,\n        const  => 6364136223846793005,\n    };\n\n    sub new {\n        my ($class, %opt) = @_;\n        my $seed = $opt{seed} // 1;\n        my $incr = $opt{incr} // 2;\n        $incr = $incr << 1 | 1 & mask64;\n        my $state = (($incr + $seed) * const + $incr) & mask64;\n        bless {incr => $incr, state => $state}, $class;\n    }\n\n    sub next_int {\n        my ($self) = @_;\n        my $state  = $self->{state};\n        my $shift  = ($state >> 18 ^ $state) >> 27 & mask32;\n        my $rotate = $state >> 59 & mask32;\n        $self->{state} = ($state * const + $self->{incr}) & mask64;\n        ($shift >> $rotate) | $shift << (32 - $rotate) & mask32;\n    }\n\n    sub next_float {\n        my ($self) = @_;\n        $self->next_int / 2**32;\n    }\n}\n\nsay \"Seed: 42, Increment: 54, first 5 values:\";\nmy $rng = PCG32->new(seed => 42, incr => 54);\nsay $rng->next_int for 1 .. 5;\n\nsay \"\\nSeed: 987654321, Increment: 1, values histogram:\";\nmy %h;\n$rng = PCG32->new(seed => 987654321, incr => 1);\n$h{int 5 * $rng->next_float}++ for 1 .. 100_000;\nsay \"$_ $h{$_}\" for sort keys %h;\n", "target": "public class PCG32 {\n    private static final long N = 6364136223846793005L;\n\n    private long state = 0x853c49e6748fea9bL;\n    private long inc = 0xda3e39cb94b95bdbL;\n\n    public void seed(long seedState, long seedSequence) {\n        state = 0;\n        inc = (seedSequence << 1) | 1;\n        nextInt();\n        state = state + seedState;\n        nextInt();\n    }\n\n    public int nextInt() {\n        long old = state;\n        state = old * N + inc;\n        int shifted = (int) (((old >>> 18) ^ old) >>> 27);\n        int rot = (int) (old >>> 59);\n        return (shifted >>> rot) | (shifted << ((~rot + 1) & 31));\n    }\n\n    public double nextFloat() {\n        var u = Integer.toUnsignedLong(nextInt());\n        return (double) u / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var r = new PCG32();\n\n        r.seed(42, 54);\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println(Integer.toUnsignedString(r.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        r.seed(987654321, 1);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(r.nextFloat() * 5.0);\n            counts[j]++;\n        }\n\n        System.out.println(\"The counts for 100,000 repetitions are:\");\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"  %d\u00a0: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 349611, "name": "Summarize and say sequence", "source": "Translate Perl to Java: sub next_num {\n\tmy @a;\n\t$a[$_]++ for split '', shift;\n\tjoin('', map(exists $a[$_] ? $a[$_].$_ : \"\", reverse 0 .. 9));\n}\n\nmy %cache;\nsub seq {\n\tmy $a = shift;\n\tmy (%seen, @s);\n\tuntil ($seen{$a}) {\n\t\t$seen{$a} = 1;\n\t\tpush(@s, $a);\n\t\tlast if !wantarray && $cache{$a};\n\t\t$a = next_num($a);\n\t}\n\treturn (@s) if wantarray;\n\n\tmy $l = $cache{$a};\n\tif ($l) { $cache{$s[$_]} = $\n\telse {\n\t\t$l++ while ($s[-$l] != $a);\n\t\t$cache{pop @s} = $l \tfor (1 .. $l);\n\t\t$cache{pop @s} = ++$l\twhile @s;\n\t}\n\t$cache{$s[0]}\n}\n\nmy (@mlist, $mlen);\nfor (1 .. 100_000) { \n\tmy $l = seq($_);\n\tnext if $l < $mlen;\n\tif ($l > $mlen) { $mlen = $l; @mlist = (); }\n\tpush @mlist, $_;\n}\n\nprint \"longest ($mlen): @mlist\\n\";\nprint join(\"\\n\", seq($_)), \"\\n\\n\" for @mlist;\n", "target": "import java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.stream.IntStream;\n\npublic class SelfReferentialSequence {\n\n    static Map<String, Integer> cache = new ConcurrentHashMap<>(10_000);\n\n    public static void main(String[] args) {\n        Seeds res = IntStream.range(0, 1000_000)\n                .parallel()\n                .mapToObj(n -> summarize(n, false))\n                .collect(Seeds::new, Seeds::accept, Seeds::combine);\n\n        System.out.println(\"Seeds:\");\n        res.seeds.forEach(e -> System.out.println(Arrays.toString(e)));\n\n        System.out.println(\"\\nSequence:\");\n        summarize(res.seeds.get(0)[0], true);\n    }\n\n    static int[] summarize(int seed, boolean display) {\n        String n = String.valueOf(seed);\n\n        String k = Arrays.toString(n.chars().sorted().toArray());\n        if (!display && cache.get(k) != null)\n            return new int[]{seed, cache.get(k)};\n\n        Set<String> seen = new HashSet<>();\n        StringBuilder sb = new StringBuilder();\n\n        int[] freq = new int[10];\n\n        while (!seen.contains(n)) {\n            seen.add(n);\n\n            int len = n.length();\n            for (int i = 0; i < len; i++)\n                freq[n.charAt(i) - '0']++;\n\n            sb.setLength(0);\n            for (int i = 9; i >= 0; i--) {\n                if (freq[i] != 0) {\n                    sb.append(freq[i]).append(i);\n                    freq[i] = 0;\n                }\n            }\n            if (display)\n                System.out.println(n);\n            n = sb.toString();\n        }\n\n        cache.put(k, seen.size());\n\n        return new int[]{seed, seen.size()};\n    }\n\n    static class Seeds {\n        int largest = Integer.MIN_VALUE;\n        List<int[]> seeds = new ArrayList<>();\n\n        void accept(int[] s) {\n            int size = s[1];\n            if (size >= largest) {\n                if (size > largest) {\n                    largest = size;\n                    seeds.clear();\n                }\n                seeds.add(s);\n            }\n        }\n\n        void combine(Seeds acc) {\n            acc.seeds.forEach(this::accept);\n        }\n    }\n}\n"}
{"id": 349612, "name": "Koch curve", "source": "Translate Perl to Java: use SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\n\nmy $koch = 'F--F--F';\n$koch =~ s/F/F+F--F+F/g for 1..5;\n\n\n($x, $y) = (0, 0);\n$theta   = pi/3;\n$r       = 2;\n\nfor (split //, $koch) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/3; }\n    elsif (/\\-/) { $theta -= pi/3; }\n}\n\n$xrng =  max(@X) - min(@X);\n$yrng =  max(@Y) - min(@Y);\n$xt   = -min(@X)+10;\n$yt   = -min(@Y)+10;\n$svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\n$points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen  $fh, '>', 'koch_curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n", "target": "int l = 300;\n\nvoid setup() {\n  size(400, 400);\n  background(0, 0, 255);\n  stroke(255);\n  \n  translate(width/2.0, height/2.0);\n  \n  translate(-l/2.0, l*sqrt(3)/6.0);\n  for (int i = 1; i <= 3; i++) {\n    kcurve(0, l);\n    rotate(radians(120));\n    translate(-l, 0);\n  }\n}\n\nvoid kcurve(float x1, float x2) {\n  float s = (x2-x1)/3;\n  if (s < 5) {\n    pushMatrix();\n    translate(x1, 0);\n    line(0, 0, s, 0);\n    line(2*s, 0, 3*s, 0);\n    translate(s, 0);\n    rotate(radians(60));\n    line(0, 0, s, 0);\n    translate(s, 0);\n    rotate(radians(-120));\n    line(0, 0, s, 0);\n    popMatrix();\n    return;\n  }\n  pushMatrix();\n  translate(x1, 0);\n  kcurve(0, s);\n  kcurve(2*s, 3*s);\n  translate(s, 0);\n  rotate(radians(60));\n  kcurve(0, s);\n  translate(s, 0);\n  rotate(radians(-120));\n  kcurve(0, s);\n  popMatrix();\n}\n"}
{"id": 349613, "name": "Pseudo-random numbers_Xorshift star", "source": "Translate Perl to Java: use strict;\nuse warnings;\nno warnings 'portable';\nuse feature 'say';\nuse Math::AnyNum qw(:overload);\n\npackage Xorshift_star {\n\n    sub new {\n        my ($class, %opt) = @_;\n        bless {state => $opt{seed}}, $class;\n    }\n\n    sub next_int {\n        my ($self) = @_;\n        my $state = $self->{state};\n        $state ^= $state >> 12;\n        $state ^= $state << 25 & (2**64 - 1);\n        $state ^= $state >> 27;\n        $self->{state} = $state;\n        ($state * 0x2545F4914F6CDD1D) >> 32 & (2**32 - 1);\n    }\n\n    sub next_float {\n        my ($self) = @_;\n        $self->next_int / 2**32;\n    }\n}\n\nsay 'Seed: 1234567, first 5 values:';\nmy $rng = Xorshift_star->new(seed => 1234567);\nsay $rng->next_int for 1 .. 5;\n\nmy %h;\nsay \"\\nSeed: 987654321, values histogram:\";\n$rng = Xorshift_star->new(seed => 987654321);\n$h{int 5 * $rng->next_float}++ for 1 .. 100_000;\nsay \"$_ $h{$_}\" for sort keys %h;\n", "target": "public class XorShiftStar {\n    private static final long MAGIC = Long.parseUnsignedLong(\"2545F4914F6CDD1D\", 16);\n    private long state;\n\n    public void seed(long num) {\n        state = num;\n    }\n\n    public int nextInt() {\n        long x;\n        int answer;\n\n        x = state;\n        x = x ^ (x >>> 12);\n        x = x ^ (x << 25);\n        x = x ^ (x >>> 27);\n        state = x;\n        answer = (int) ((x * MAGIC) >> 32);\n\n        return answer;\n    }\n\n    public float nextFloat() {\n        return (float) Integer.toUnsignedLong(nextInt()) / (1L << 32);\n    }\n\n    public static void main(String[] args) {\n        var rng = new XorShiftStar();\n        rng.seed(1234567);\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println(Integer.toUnsignedString(rng.nextInt()));\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int j = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[j]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d\\n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 349614, "name": "Numbers with equal rises and falls", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nsub rf\n  {\n  local $_ = shift;\n  my $sum = 0;\n  $sum += $1 <=> $2 while /(.)(?=(.))/g;\n  $sum\n  }\n\nmy $count = 0;\nmy $n = 0;\nmy @numbers;\nwhile( $count < 200 )\n  {\n  rf(++$n) or $count++, push @numbers, $n;\n  }\nprint \"first 200: @numbers\\n\" =~ s/.{1,70}\\K\\s/\\n/gr;\n\n$count = 0;\n$n = 0;\nwhile( $count < 10e6 )\n  {\n  rf(++$n) or $count++;\n  }\nprint \"\\n10,000,000th number: $n\\n\";\n", "target": "public class EqualRisesFalls {\n    public static void main(String[] args) {\n        final int limit1 = 200;\n        final int limit2 = 10000000;\n        System.out.printf(\"The first %d numbers in the sequence are:\\n\", limit1);\n        int n = 0;\n        for (int count = 0; count < limit2; ) {\n            if (equalRisesAndFalls(++n)) {\n                ++count;\n                if (count <= limit1)\n                    System.out.printf(\"%3d%c\", n, count % 20 == 0 ? '\\n' : ' ');\n            }\n        }\n        System.out.printf(\"\\nThe %dth number in the sequence is %d.\\n\", limit2, n);\n    }\n\n    private static boolean equalRisesAndFalls(int n) {\n        int total = 0;\n        for (int previousDigit = -1; n > 0; n /= 10) {\n            int digit = n % 10;\n            if (previousDigit > digit)\n                ++total;\n            else if (previousDigit >= 0 && previousDigit < digit)\n                --total;\n            previousDigit = digit;\n        }\n        return total == 0;\n    }\n}\n"}
{"id": 349615, "name": "Pseudo-random numbers_Combined recursive generator MRG32k3a", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\npackage MRG32k3a {\n\n    use constant {\n        m1 => 2**32 - 209,\n        m2 => 2**32 - 22853\n    };\n\n    use Const::Fast;\n    const my @a1 => <     0 1403580  -810728>;\n    const my @a2 => <527612       0 -1370589>;\n\n    sub new {\n        my ($class,undef,$seed) = @_;\n        my @x1 = my @x2 = ($seed, 0, 0);\n        bless {x1 => \\@x1, x2 => \\@x2}, $class;\n    }\n\n    sub next_int {\n        my ($self) = @_;\n        unshift @{$$self{x1}}, ($a1[0] * $$self{x1}[0] + $a1[1] * $$self{x1}[1] + $a1[2] * $$self{x1}[2]) % m1; pop @{$$self{x1}};\n        unshift @{$$self{x2}}, ($a2[0] * $$self{x2}[0] + $a2[1] * $$self{x2}[1] + $a2[2] * $$self{x2}[2]) % m2; pop @{$$self{x2}};\n        ($$self{x1}[0] - $$self{x2}[0]) % (m1 + 1)\n    }\n\n    sub next_float { $_[0]->next_int / (m1 + 1) }\n}\n\nsay 'Seed: 1234567, first 5 values:';\nmy $rng = MRG32k3a->new( seed => 1234567 );\nsay $rng->next_int for 1..5;\n\nmy %h;\nsay \"\\nSeed: 987654321, values histogram:\";\n$rng = MRG32k3a->new( seed => 987654321 );\n$h{int 5 * $rng->next_float}++ for 1..100_000;\nsay \"$_ $h{$_}\" for sort keys %h;\n", "target": "public class App {\n    private static long mod(long x, long y) {\n        long m = x % y;\n        if (m < 0) {\n            if (y < 0) {\n                return m - y;\n            } else {\n                return m + y;\n            }\n        }\n        return m;\n    }\n\n    public static class RNG {\n        \n        private final long[] a1 = {0, 1403580, -810728};\n        private static final long m1 = (1L << 32) - 209;\n        private long[] x1;\n        \n        private final long[] a2 = {527612, 0, -1370589};\n        private static final long m2 = (1L << 32) - 22853;\n        private long[] x2;\n        \n        private static final long d = m1 + 1;\n\n        public void seed(long state) {\n            x1 = new long[]{state, 0, 0};\n            x2 = new long[]{state, 0, 0};\n        }\n\n        public long nextInt() {\n            long x1i = mod(a1[0] * x1[0] + a1[1] * x1[1] + a1[2] * x1[2], m1);\n            long x2i = mod(a2[0] * x2[0] + a2[1] * x2[1] + a2[2] * x2[2], m2);\n            long z = mod(x1i - x2i, m1);\n\n            \n            x1 = new long[]{x1i, x1[0], x1[1]};\n            \n            x2 = new long[]{x2i, x2[0], x2[1]};\n\n            return z + 1;\n        }\n\n        public double nextFloat() {\n            return 1.0 * nextInt() / d;\n        }\n    }\n\n    public static void main(String[] args) {\n        RNG rng = new RNG();\n\n        rng.seed(1234567);\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println(rng.nextInt());\n        System.out.println();\n\n        int[] counts = {0, 0, 0, 0, 0};\n        rng.seed(987654321);\n        for (int i = 0; i < 100_000; i++) {\n            int value = (int) Math.floor(rng.nextFloat() * 5.0);\n            counts[value]++;\n        }\n        for (int i = 0; i < counts.length; i++) {\n            System.out.printf(\"%d: %d%n\", i, counts[i]);\n        }\n    }\n}\n"}
{"id": 349616, "name": "Self-describing numbers", "source": "Translate Perl to Java: sub is_selfdesc\n{\n\tlocal $_ = shift;\n\tmy @b = (0) x length;\n\t$b[$_]++ for my @a = split //;\n\treturn \"@a\" eq \"@b\";\n}\n\n\nfor (0 .. 100000, 3211000, 42101000) {\n\tprint \"$_\\n\" if is_selfdesc($_);\n}\n", "target": "public class SelfDescribingNumbers{\n    public static boolean isSelfDescribing(int a){\n        String s = Integer.toString(a);\n        for(int i = 0; i < s.length(); i++){\n            String s0 = s.charAt(i) + \"\";\n            int b = Integer.parseInt(s0); \n            int count = 0;\n            for(int j = 0; j < s.length(); j++){\n                int temp = Integer.parseInt(s.charAt(j) + \"\");\n                if(temp == i){\n                    count++;\n                }\n                if (count > b) return false;\n            }\n            if(count != b) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args){\n        for(int i = 0; i < 100000000; i++){\n            if(isSelfDescribing(i)){\n                System.out.println(i);\n             }\n        }\n    }\n}\n"}
{"id": 349617, "name": "Changeable words", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\nmy @words;\n@ARGV = 'unixdict.txt';\nwhile( <> )\n  {\n  chomp;\n  length > 11 or next;\n  for my $prev ( @{ $words[length] } )\n    {\n    ($prev ^ $_) =~ tr/\\0//c == 1 and printf \"%30s <-> %s\\n\", $prev, $_;\n    }\n  push @{ $words[length] }, $_;\n  }\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class ChangeableWords {\n    public static void main(String[] args) {\n        try {\n            final String fileName = \"unixdict.txt\";\n            List<String> dictionary = new ArrayList<>();\n            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.length() > 11)\n                        dictionary.add(line);\n                }\n            }\n            System.out.printf(\"Changeable words in %s:\\n\", fileName);\n            int n = 1;\n            for (String word1 : dictionary) {\n                for (String word2 : dictionary) {\n                    if (word1 != word2 && hammingDistance(word1, word2) == 1)\n                        System.out.printf(\"%2d:\u00a0%-14s -> %s\\n\", n++, word1, word2);\n                }\n            }\n        } catch (Exception e)  {\n            e.printStackTtexture();\n        }\n    }\n\n    private static int hammingDistance(String str1, String str2) {\n        int len1 = str1.length();\n        int len2 = str2.length();\n        if (len1 != len2)\n            return 0;\n        int count = 0;\n        for (int i = 0; i < len1; ++i) {\n            if (str1.charAt(i) != str2.charAt(i))\n                ++count;\n            \n            if (count == 2)\n                break;\n        }\n        return count;\n    }\n}\n"}
{"id": 349618, "name": "Mosaic matrix", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nmy $n = 5;\nsay join ' ', @$_ for map { $_%2 ? [map { $_%2 ? 1 : 0 } 1..$n] : [map { $_%2 ? 0 : 1 } 1..$n] } 1..$n;\n", "target": "\n\nsize(1000,1000);\n\ntextSize(50);\n\nfor(int i=0;i<10;i++){\n  for(int j=0;j<10;j++){\n    noFill();\n    square(i*100,j*100,100);\n    fill(#000000);\n    if((i+j)%2==0){\n      text(\"1\",i*100+50,j*100+50);\n    }\n    else{\n      text(\"0\",i*100+50,j*100+50);\n    } \n  }\n}\n"}
{"id": 349619, "name": "Input_Output for lines of text", "source": "Translate Perl to Java: $n = scalar <>;\n\ndo_stuff(scalar <>) for 1..$n;\n\nsub do_stuff { print $_[0] }\n", "target": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void doStuff(String word){\n\t   System.out.println(word);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = Integer.parseInt(in.nextLine());  \n\t\tfor(int i=0; i<n; i++){\t\t\n\t\t\tString word = in.nextLine();\n\t\t\tdoStuff(word);\n\t\t}\n\t}\n}\n"}
{"id": 349620, "name": "Length of an arc between two angles", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse utf8;\nbinmode STDOUT, \":utf8\";\nuse POSIX 'fmod';\n\nuse constant \u03c0 => 2 * atan2(1, 0);\nuse constant \u03c4 => 2 * \u03c0;\n\nsub d2r { $_[0] * \u03c4 / 360 }\n\nsub arc {\n    my($a1, $a2, $r) = (d2r($_[0]), d2r($_[1]), $_[2]);\n    my @a = map { fmod( ($_ + \u03c4), \u03c4) } ($a1, $a2);\n    printf \"Arc length: %8.5f  Parameters: (%9.7f, %10.7f, %10.7f)\\n\",\n       (fmod(($a[0]-$a[1] + \u03c4), \u03c4) * $r), $a2, $a1, $r;\n}\n\narc(@$_) for\n    [ 10, 120,   10],\n    [ 10, 120,    1],\n    [120,  10,    1],\n    [-90, 180, 10/\u03c0],\n    [-90,   0, 10/\u03c0],\n    [ 90,   0, 10/\u03c0];\n", "target": "public static double arcLength(double r, double a1, double a2){\n    return (360.0 - Math.abs(a2-a1))*Math.PI/180.0 * r;\n}\n"}
{"id": 349621, "name": "Shift list elements to left by 3", "source": "Translate Perl to Java: // 20210315 Perl programming solution\n\nuse strict;\nuse warnings;\n\nmy $n = 3;\nmy @list = 1..9;\n\npush @list, splice @list, 0, $n;\n\nprint join ' ', @list, \"\\n\"\n", "target": "import java.util.List;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class RotateLeft {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        System.out.println(\"original: \" + list);\n        Collections.rotate(list, -3);\n        System.out.println(\"rotated: \" + list);\n    }\n}\n"}
{"id": 349622, "name": "Rodrigues\u2019 rotation formula", "source": "Translate Perl to Java: \nuse strict;\nuse Math::Trig; \nuse JSON;\nuse constant PI => 3.14159265358979;\n\n\n\nsub norm {\n  my($v)=@_;\n  return ($v->[0]*$v->[0] + $v->[1]*$v->[1] + $v->[2]*$v->[2]) ** 0.5;\n}\nsub normalize {\n  my($v)=@_;\n  my $length = &norm($v);\n  return [$v->[0]/$length, $v->[1]/$length, $v->[2]/$length];\n}\nsub dotProduct {\n  my($v1, $v2)=@_;\n  return $v1->[0]*$v2->[0] + $v1->[1]*$v2->[1] + $v1->[2]*$v2->[2];\n}\nsub crossProduct {\n  my($v1, $v2)=@_;\n  return [$v1->[1]*$v2->[2] - $v1->[2]*$v2->[1], $v1->[2]*$v2->[0] - $v1->[0]*$v2->[2], $v1->[0]*$v2->[1] - $v1->[1]*$v2->[0]];\n}\nsub getAngle {\n  my($v1, $v2)=@_;\n  return acos(&dotProduct($v1, $v2) / (&norm($v1)*&norm($v2)))*180/PI;  \n}\nsub matrixMultiply {\n  my($matrix, $v)=@_;\n  return [&dotProduct($matrix->[0], $v), &dotProduct($matrix->[1], $v), &dotProduct($matrix->[2], $v)];\n}\nsub aRotate {\n  my($p, $v, $a)=@_;    \n  my $ca = cos($a/180*PI);      \n  my $sa = sin($a/180*PI);\n  my $t=1-$ca;\n  my($x,$y,$z)=($v->[0], $v->[1], $v->[2]);\n  my $r = [\n        [$ca + $x*$x*$t, $x*$y*$t - $z*$sa, $x*$z*$t + $y*$sa],\n        [$x*$y*$t + $z*$sa, $ca + $y*$y*$t, $y*$z*$t - $x*$sa],\n        [$z*$x*$t - $y*$sa, $z*$y*$t + $x*$sa, $ca + $z*$z*$t]\n    ];\n  return &matrixMultiply($r, $p);\n}\n\nmy $v1 = [5,-6,4];\nmy $v2 = [8,5,-30];\nmy $a = &getAngle($v1, $v2);\nmy $cp = &crossProduct($v1, $v2);\nmy $ncp = &normalize($cp);\nmy $np = &aRotate($v1, $ncp, $a);\n\nmy $json=JSON->new->canonical; \n\nprint $json->encode($np) . \"\\n\";\n", "target": "\n\nclass Vector{\n  private double x, y, z;\n\n  public Vector(double x1,double y1,double z1){\n    x = x1;\n    y = y1;\n    z = z1;\n  }\n  \n  void printVector(int x,int y){\n    text(\"( \" + this.x + \" )  \\u00ee + ( \" + this.y + \" ) + \\u0135 ( \" + this.z + \") \\u006b\\u0302\",x,y);\n  }\n\n  public double norm() {\n    return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z);\n  }\n  \n  public Vector normalize(){\n    double length = this.norm();\n    return new Vector(this.x / length, this.y / length, this.z / length);\n  }\n  \n  public double dotProduct(Vector v2) {\n    return this.x*v2.x + this.y*v2.y + this.z*v2.z;\n  }\n  \n  public Vector crossProduct(Vector v2) {\n    return new Vector(this.y*v2.z - this.z*v2.y, this.z*v2.x - this.x*v2.z, this.x*v2.y - this.y*v2.x);\n  }\n  \n  public double getAngle(Vector v2) {\n    return Math.acos(this.dotProduct(v2) / (this.norm()*v2.norm()));\n  }\n  \n  public Vector aRotate(Vector v, double a) {\n    double ca = Math.cos(a), sa = Math.sin(a);\n    double t = 1.0 - ca;\n    double x = v.x, y = v.y, z = v.z;\n    Vector[] r = {\n        new Vector(ca + x*x*t, x*y*t - z*sa, x*z*t + y*sa),\n        new Vector(x*y*t + z*sa, ca + y*y*t, y*z*t - x*sa),\n        new Vector(z*x*t - y*sa, z*y*t + x*sa, ca + z*z*t)\n    };\n    return new Vector(this.dotProduct(r[0]), this.dotProduct(r[1]), this.dotProduct(r[2]));\n  }\n}\n\nvoid setup(){\n  Vector v1 = new Vector(5d, -6d, 4d),v2 = new Vector(8d, 5d, -30d);\n  double a = v1.getAngle(v2);\n  Vector cp = v1.crossProduct(v2);\n  Vector normCP = cp.normalize();\n  Vector np = v1.aRotate(normCP,a);\n  \n  size(1200,600);\n  fill(#000000);\n  textSize(30);\n  \n  text(\"v1 = \",10,100);\n  v1.printVector(60,100);\n  text(\"v2 = \",10,150);\n  v2.printVector(60,150);\n  text(\"rV = \",10,200);\n  np.printVector(60,200);\n}\n"}
{"id": 349623, "name": "Air mass", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature <say signatures>;\nno warnings 'experimental::signatures';\nuse List::Util 'max';\n\nuse constant PI  => 2*atan2(1,0);   \nuse constant DEG => PI/180;         \nuse constant RE  => 6371000;        \nuse constant dd  => 0.001;          \nuse constant FIN => 10000000;       \n\n\nsub rho ( $a ) {\n    exp( -$a / 8500 );\n}\n\nsub height ( $a, $z, $d ) {\n    \n    \n    \n    my $AA = RE + $a;\n    my $HH = sqrt $AA**2 + $d**2 - 2 * $d * $AA * cos( (180-$z)*DEG );\n    $HH - RE;\n}\n\n\nsub column_density ( $a, $z ) {\n    my $sum = 0;\n    my $d   = 0;\n    while ($d < FIN) {\n        my $delta = max(dd, dd * $d);  \n        $sum += rho(height($a, $z, $d + $delta/2))*$delta;\n        $d   += $delta;\n    }\n    $sum;\n}\n\nsub airmass ( $a, $z ) {\n    column_density($a, $z) / column_density($a, 0);\n}\n\nsay 'Angle     0 m              13700 m';\nsay '------------------------------------';\nfor my $z (map{ 5*$_ } 0..18) {\n    printf \"%2d      %11.8f      %11.8f\\n\", $z, airmass(0, $z), airmass(13700, $z);\n}\n", "target": "public class AirMass {\n    public static void main(String[] args) {\n        System.out.println(\"Angle     0 m              13700 m\");\n        System.out.println(\"------------------------------------\");\n        for (double z = 0; z <= 90; z+= 5) {\n            System.out.printf(\"%2.0f      %11.8f      %11.8f\\n\",\n                            z, airmass(0.0, z), airmass(13700.0, z));\n        }\n    }\n\n    private static double rho(double a) {\n        \n        return Math.exp(-a / 8500.0);\n    }\n\n    private static double height(double a, double z, double d) {\n        \n        \n        \n        double aa = RE + a;\n        double hh = Math.sqrt(aa * aa + d * d - 2.0 * d * aa * Math.cos(Math.toRadians(180 - z)));\n        return hh - RE;\n    }\n\n    private static double columnDensity(double a, double z) {\n        \n        double sum = 0.0, d = 0.0;\n        while (d < FIN) {\n            \n            double delta = Math.max(DD * d, DD);\n            sum += rho(height(a, z, d + 0.5 * delta)) * delta;\n            d += delta;\n        }\n        return sum;\n    }\n     \n    private static double airmass(double a, double z) {\n        return columnDensity(a, z) / columnDensity(a, 0.0);\n    }\n\n    private static final double RE = 6371000.0; \n    private static final double DD = 0.001; \n    private static final double FIN = 10000000.0; \n}\n"}
{"id": 349624, "name": "Matrix with two diagonals", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\n\nprint diagonal($_), \"\\n\" for 10, 11;\n\nsub diagonal\n  {\n  my $n =  shift() - 1;\n  local $_ = 1 . 0 x ($n - 1) . 2 . \"\\n\" . (0 . 0 x $n . \"\\n\") x $n;\n  1 while s/(?<=1...{$n})0/1/s or s/(?<=2.{$n})[01]/2/s;\n  return tr/2/1/r =~ s/\\B/ /gr;\n  }\n", "target": "package example.diagdiag;\n\npublic class Program {\n\n    public static void main(String[] args) {\n        DiagonalDiagonalMatrix A = new DiagonalDiagonalMatrix(7);\n        System.out.println(A);\n    }\n\n}\n\nclass DiagonalDiagonalMatrix {\n\n    final int n;\n    private double[][] a = null;\n\n    public Matrix(int n) {\n        this.n = n;\n    }\n\n    public double get(int i, int j) {\n        if (a == null) {\n            return (i == j || i == n - j + 1) ? 1.0 : 0.0;\n        } else {\n            return a[i - 1][j - 1];\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                sb.append('\\t');\n                sb.append(get(i, j));\n            }\n            sb.append('\\n');\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 349625, "name": "Draw pixel 2", "source": "Translate Perl to Java: use Gtk3 '-init';\n\nmy $width  = 640;\nmy $height = 480;\n\nmy $window = Gtk3::Window->new();\n$window->set_default_size($width, $height);\n$window->set_border_width(10);\n$window->set_title(\"Draw Pixel 2\");\n$window->set_app_paintable(TRUE);\n\nmy $da = Gtk3::DrawingArea->new();\n$da->signal_connect('draw' => \\&draw_in_drawingarea);\n$window->add($da);\n$window->show_all();\n\nGtk3->main;\n\nsub draw_in_drawingarea\n{\n  my ($widget, $cr, $data) = @_;\n  $cr->set_source_rgb(1, 1, 0);\n  $cr->set_line_width(1);\n  $cr->rectangle( int rand $width , int rand $height, 1, 1);\n  $cr->stroke;\n}\n", "target": "\n\nsize(640,480);\n\nstroke(#ffff00);\n\nellipse(random(640),random(480),1,1);\n"}
{"id": 349626, "name": "Four sides of square", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nmy $n = 5;\nsay join ' ', @$_ for ([(1)x$n], (map { [1, (0)x($n-2), 1] } 0..$n-3), [(1)x$n]);\n", "target": "\n\nsize(1000,1000);\n\ntextSize(50);\n\nfor(int i=0;i<10;i++){\n  for(int j=0;j<10;j++){\n    noFill();\n    square(i*100,j*100,100);\n    fill(#000000);\n    if(i==0||i==9||j==0||j==9){\n      text(\"1\",i*100+50,j*100+50);\n    }\n    else{\n      text(\"0\",i*100+50,j*100+50);\n    } \n  }\n}\n"}
{"id": 349627, "name": "Longest common suffix", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\nsub lcs {\n    for (0..$\n    join '', reverse split '', (join(\"\\0\", @_) =~ /^ ([^\\0]*) [^\\0]* (?:\\0 \\1 [^\\0]*)* $/sx)[0];\n}\n\nfor my $words (\n  [ <Sunday Monday Tuesday Wednesday Thursday Friday Saturday> ],\n  [ <Sondag Maandag Dinsdag Woensdag Donderdag Vrydag Saterdag dag> ],\n  [ 2347, 9312347, 'acx5g2347', 12.02347 ],\n  [ <longest common suffix> ],\n  [ ('one, Hey!', 'three, Hey!', 'ale, Hey!', 'me, Hey!') ],\n  [ 'suffix' ],\n  [ '' ]) {\n    say qq{'@$words' ==> '@{[lcs(@$words)]}';\n}\n", "target": "import java.util.List;\n\npublic class App {\n    private static String lcs(List<String> a) {\n        var le = a.size();\n        if (le == 0) {\n            return \"\";\n        }\n        if (le == 1) {\n            return a.get(0);\n        }\n        var le0 = a.get(0).length();\n        var minLen = le0;\n        for (int i = 1; i < le; i++) {\n            if (a.get(i).length() < minLen) {\n                minLen = a.get(i).length();\n            }\n        }\n        if (minLen == 0) {\n            return \"\";\n        }\n        var res = \"\";\n        var a1 = a.subList(1, a.size());\n        for (int i = 1; i < minLen; i++) {\n            var suffix = a.get(0).substring(le0 - i);\n            for (String e : a1) {\n                if (!e.endsWith(suffix)) {\n                    return res;\n                }\n            }\n            res = suffix;\n        }\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        var tests = List.of(\n            List.of(\"baabababc\", \"baabc\", \"bbbabc\"),\n            List.of(\"baabababc\", \"baabc\", \"bbbazc\"),\n            List.of(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"),\n            List.of(\"longest\", \"common\", \"suffix\"),\n            List.of(\"suffix\"),\n            List.of(\"\")\n        );\n        for (List<String> test : tests) {\n            System.out.printf(\"%s -> `%s`\\n\", test, lcs(test));\n        }\n    }\n}\n"}
{"id": 349628, "name": "Numeric separator syntax", "source": "Translate Perl to Java: \nprint 1_2_3, \"\\n\";  \n\n\nprint 0b1_0_1_0_1, \"\\n\"; \n\n\nprint 0xa_bc_d, \"\\n\"; \n\n\nprint 1_2_3_4.2_5, \"\\n\"; \n\n\nprint 6.0_22e4, \"\\n\"; \n", "target": "public class NumericSeparatorSyntax {\n\n    public static void main(String[] args) {\n        runTask(\"Underscore allowed as seperator\", 1_000);\n        runTask(\"Multiple consecutive underscores allowed:\", 1__0_0_0);\n        runTask(\"Many multiple consecutive underscores allowed:\", 1________________________00);\n        runTask(\"Underscores allowed in multiple positions\", 1__4__4);\n        runTask(\"Underscores allowed in negative number\", -1__4__4);\n        runTask(\"Underscores allowed in floating point number\", 1__4__4e-5);\n        runTask(\"Underscores allowed in floating point exponent\", 1__4__440000e-1_2);\n        \n        \n        \n        \n    }\n    \n    private static void runTask(String description, long n) {\n        runTask(description, n, \"%d\");\n    }\n\n    private static void runTask(String description, double n) {\n        runTask(description, n, \"%3.7f\");\n    }\n\n    private static void runTask(String description, Number n, String format) {\n        System.out.printf(\"%s:  \" + format + \"%n\", description, n);\n    }\n\n}\n"}
{"id": 349629, "name": "Hello world_Newbie", "source": "Translate Perl to Java: =head1 Obtaining perl\n\nOn the majority of UNIX and UNIX-like operating systems \n(Linux, Solaris, AIX, HPUX, et cetera), perl will already be installed. \nMac OS X also ships with perl. \nNote that \"Perl\" refers to the language \nwhile \"perl\" refers to the interpreter used to run Perl programs.\n\nWindows does not ship with perl. Instead, you will have to install one of\nthe following perl distributions:\n\n=over 4\n\n=item Strawberry Perl\n\nL<Strawberry Perl|http://strawberryperl.com/>: A 100% Open Source Perl for\nWindows that is exactly the same as Perl everywhere else; this includes using\nmodules from CPAN, without the need for binary packages.\n\n=item DWIM Perl for Windows\n\nL<DWIM Perl for Windows|http://dwimperl.com/windows.html>: A 100% Open Source\nPerl for Windows, based on Strawberry Perl. \nIt aims to include as many useful CPAN modules as possible.\n\n=item ActiveState Perl\n\nL<http://www.activestate.com/activeperl/downloads>\n\n=back\n\nLinks and further instructions on installation can be found on\nL<http://www.perl.org/get.html>.\n\nOnce perl is installed, the task of printing \"Hello, World!\" is quite simple.\nFrom the command line, first check if your environment's C<PATH> variable\nknows where to find perl. \nOn most systems, this can be achieved by entering C<which perl>; \nif it spits out something like F</usr/bin/perl>, you're good to go! \nIf it tells you\n\n    which: no perl in (...)\n\nit means you need to add perl to your environment's C<PATH> variable. \nThis is done on most systems by entering\n\n    export PATH=$PATH:[...]\n\nwhere [...] is the full path to your perl installation (usually /usr/bin/perl).\n\nIf you do not have the C<which> command, you can probably just type C<perl>\nto see if it fires up the perl interpreter. \nIf it does, press Ctrl+D to exit it and proceed. \nOtherwise, perform the steps above to add perl to your PATH variable.\n\nOnce perl is installed, one-liners can be executed from the command line \nby invoking perl with the C<-e> switch.\n    $ perl -e 'print \"Hello, World!\\n\";'\nTo create a script file that's more permanent, it can be put in a text file.\nThe name can be anything, but F<.pl> is encouraged. \nThe \nif the operating system supports it, it tells where to find the perl interpreter. \nIf the script is run with C<perl>, this line will be ignored--\nthis is for invoking the file as an executable.\n\n=cut\n\n\nprint \"Hello, World!\\n\";\n", "target": "public class HelloWorld {\n    public static void main(String[] args) {\n        \n        System.out.println(\"Hello world!\");\n    }\n}\n"}
{"id": 349630, "name": "Hello world_Newbie", "source": "Translate Perl to Java: =head1 Obtaining perl\n\nOn the majority of UNIX and UNIX-like operating systems \n(Linux, Solaris, AIX, HPUX, et cetera), perl will already be installed. \nMac OS X also ships with perl. \nNote that \"Perl\" refers to the language \nwhile \"perl\" refers to the interpreter used to run Perl programs.\n\nWindows does not ship with perl. Instead, you will have to install one of\nthe following perl distributions:\n\n=over 4\n\n=item Strawberry Perl\n\nL<Strawberry Perl|http://strawberryperl.com/>: A 100% Open Source Perl for\nWindows that is exactly the same as Perl everywhere else; this includes using\nmodules from CPAN, without the need for binary packages.\n\n=item DWIM Perl for Windows\n\nL<DWIM Perl for Windows|http://dwimperl.com/windows.html>: A 100% Open Source\nPerl for Windows, based on Strawberry Perl. \nIt aims to include as many useful CPAN modules as possible.\n\n=item ActiveState Perl\n\nL<http://www.activestate.com/activeperl/downloads>\n\n=back\n\nLinks and further instructions on installation can be found on\nL<http://www.perl.org/get.html>.\n\nOnce perl is installed, the task of printing \"Hello, World!\" is quite simple.\nFrom the command line, first check if your environment's C<PATH> variable\nknows where to find perl. \nOn most systems, this can be achieved by entering C<which perl>; \nif it spits out something like F</usr/bin/perl>, you're good to go! \nIf it tells you\n\n    which: no perl in (...)\n\nit means you need to add perl to your environment's C<PATH> variable. \nThis is done on most systems by entering\n\n    export PATH=$PATH:[...]\n\nwhere [...] is the full path to your perl installation (usually /usr/bin/perl).\n\nIf you do not have the C<which> command, you can probably just type C<perl>\nto see if it fires up the perl interpreter. \nIf it does, press Ctrl+D to exit it and proceed. \nOtherwise, perform the steps above to add perl to your PATH variable.\n\nOnce perl is installed, one-liners can be executed from the command line \nby invoking perl with the C<-e> switch.\n    $ perl -e 'print \"Hello, World!\\n\";'\nTo create a script file that's more permanent, it can be put in a text file.\nThe name can be anything, but F<.pl> is encouraged. \nThe \nif the operating system supports it, it tells where to find the perl interpreter. \nIf the script is run with C<perl>, this line will be ignored--\nthis is for invoking the file as an executable.\n\n=cut\n\n\nprint \"Hello, World!\\n\";\n", "target": "public class HelloWorld {\n    public static void main(String[] args) {\n        \n        System.out.println(\"Hello world!\");\n    }\n}\n"}
{"id": 349631, "name": "Here document", "source": "Translate Perl to Java: $address = <<END;\n1, High Street,\n$town_name,\nWest Midlands.\nWM4 5HD.\nEND\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 349632, "name": "Here document", "source": "Translate Perl to Java: $address = <<END;\n1, High Street,\n$town_name,\nWest Midlands.\nWM4 5HD.\nEND\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 349633, "name": "2048", "source": "Translate Perl to Java: \n\nuse strict; \nuse warnings;\nuse Tk;\n\nmy $N = shift // 4;\n$N < 2 and $N = 2;\nmy @squares = 1 .. $N*$N;\nmy %n2ch = (' ' => ' ');\n@n2ch{ map 2**$_, 1..26} = 'a'..'z';\nmy %ch2n = reverse %n2ch;\nmy $winner = '';\nmy @arow = 0 .. $N - 1;\nmy @acol = map $_ * $N, @arow;\n\nmy $mw = MainWindow->new;\n$mw->geometry( '+300+0' );\n$mw->title( 2048 );\n$mw->focus;\n$mw->bind('<KeyPress-Left>' => sub { arrow($N, @arow) } );\n$mw->bind('<KeyPress-Right>' => sub { arrow($N, reverse @arow) } );\n$mw->bind('<KeyPress-Up>' => sub { arrow(1, @acol) } );\n$mw->bind('<KeyPress-Down>' => sub { arrow(1, reverse @acol) } );\nmy $grid = $mw->Frame()->pack;\nfor my $i ( 0 .. $\n  {\n  $grid->Label(-textvariable => \\$squares[$i],\n    -width => 5, -height => 2, -font => 'courierbold 30',\n    -relief => 'ridge', -borderwidth => 5,\n    )->grid(-row => int $i / $N, -column => $i % $N );\n  }\nmy $buttons = $mw->Frame()->pack(-fill => 'x', -expand => 1);\n$buttons->Button(-text => 'Exit', -command => sub {$mw->destroy},\n  -font => 'courierbold 14',\n  )->pack(-side => 'right');\n$buttons->Button(-text => 'New Game', -command => \\&newgame,\n  -font => 'courierbold 14',\n  )->pack(-side => 'left');\n$buttons->Label(-textvariable => \\$winner,\n  -font => 'courierbold 18', -fg => 'red2',\n  )->pack;\n\nnewgame();\nMainLoop;\n-M $0 < 0 and exec $0;\n\nsub losecheck\n  {\n  local $_ = join '', @n2ch{ @squares };\n  / / || ($_ ^ substr $_, $N) =~ tr/\\0// and return;\n  /(.)\\1/ and return for /.{$N}/g;\n  $winner = 'You Lost';\n  }\n\nsub arrow\n  {\n  $winner and return;                                   \n  my ($inc, @ix) = @_;\n  my $oldboard = \"@squares\";\n  for ( 1 .. $N )\n    {\n    local $_ = join '', @n2ch{ @squares[@ix] };         \n    tr/ //d;                                            \n    s/(\\w)\\1/ chr 1 + ord $1 /ge;                       \n    @squares[@ix] = @ch2n{ split //, $_ . ' ' x $N };   \n    $_ += $inc for @ix;                                 \n    }\n  $oldboard eq \"@squares\" and return;\n  add2();\n  losecheck();\n  grep $_ eq 2048, @squares and $winner = 'WINNER\u00a0!!';\n  }\n\nsub add2\n  {\n  my @blanks = grep $squares[$_] eq ' ', 0 .. $\n  @blanks and $squares[ $blanks[rand @blanks] ] =\n    $_[0] // (rand() < 0.1 ? 4 : 2);\n  }\n\nsub newgame\n  {\n  $_ = ' ' for @squares;\n  add2(2) for 1, 2;\n  $winner = '';\n  }\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class Game2048 extends JPanel {\n\n    enum State {\n        start, won, running, over\n    }\n\n    final Color[] colorTable = {\n        new Color(0x701710), new Color(0xFFE4C3), new Color(0xfff4d3),\n        new Color(0xffdac3), new Color(0xe7b08e), new Color(0xe7bf8e),\n        new Color(0xffc4c3), new Color(0xE7948e), new Color(0xbe7e56),\n        new Color(0xbe5e56), new Color(0x9c3931), new Color(0x701710)};\n\n    final static int target = 2048;\n\n    static int highest;\n    static int score;\n\n    private Color gridColor = new Color(0xBBADA0);\n    private Color emptyColor = new Color(0xCDC1B4);\n    private Color startColor = new Color(0xFFEBCD);\n\n    private Random rand = new Random();\n\n    private Tile[][] tiles;\n    private int side = 4;\n    private State gamestate = State.start;\n    private boolean checkingAvailableMoves;\n\n    public Game2048() {\n        setPreferredSize(new Dimension(900, 700));\n        setBackground(new Color(0xFAF8EF));\n        setFont(new Font(\"SansSerif\", Font.BOLD, 48));\n        setFocusable(true);\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                startGame();\n                repaint();\n            }\n        });\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                switch (e.getKeyCode()) {\n                    case KeyEvent.VK_UP:\n                        moveUp();\n                        break;\n                    case KeyEvent.VK_DOWN:\n                        moveDown();\n                        break;\n                    case KeyEvent.VK_LEFT:\n                        moveLeft();\n                        break;\n                    case KeyEvent.VK_RIGHT:\n                        moveRight();\n                        break;\n                }\n                repaint();\n            }\n        });\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    void startGame() {\n        if (gamestate != State.running) {\n            score = 0;\n            highest = 0;\n            gamestate = State.running;\n            tiles = new Tile[side][side];\n            addRandomTile();\n            addRandomTile();\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(gridColor);\n        g.fillRoundRect(200, 100, 499, 499, 15, 15);\n\n        if (gamestate == State.running) {\n\n            for (int r = 0; r < side; r++) {\n                for (int c = 0; c < side; c++) {\n                    if (tiles[r][c] == null) {\n                        g.setColor(emptyColor);\n                        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\n                    } else {\n                        drawTile(g, r, c);\n                    }\n                }\n            }\n        } else {\n            g.setColor(startColor);\n            g.fillRoundRect(215, 115, 469, 469, 7, 7);\n\n            g.setColor(gridColor.darker());\n            g.setFont(new Font(\"SansSerif\", Font.BOLD, 128));\n            g.drawString(\"2048\", 310, 270);\n\n            g.setFont(new Font(\"SansSerif\", Font.BOLD, 20));\n\n            if (gamestate == State.won) {\n                g.drawString(\"you made it!\", 390, 350);\n\n            } else if (gamestate == State.over)\n                g.drawString(\"game over\", 400, 350);\n\n            g.setColor(gridColor);\n            g.drawString(\"click to start a new game\", 330, 470);\n            g.drawString(\"(use arrow keys to move tiles)\", 310, 530);\n        }\n    }\n\n    void drawTile(Graphics2D g, int r, int c) {\n        int value = tiles[r][c].getValue();\n\n        g.setColor(colorTable[(int) (Math.log(value) / Math.log(2)) + 1]);\n        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\n        String s = String.valueOf(value);\n\n        g.setColor(value < 128 ? colorTable[0] : colorTable[1]);\n\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int dec = fm.getDescent();\n\n        int x = 215 + c * 121 + (106 - fm.stringWidth(s)) / 2;\n        int y = 115 + r * 121 + (asc + (106 - (asc + dec)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n\n    private void addRandomTile() {\n        int pos = rand.nextInt(side * side);\n        int row, col;\n        do {\n            pos = (pos + 1) % (side * side);\n            row = pos / side;\n            col = pos % side;\n        } while (tiles[row][col] != null);\n\n        int val = rand.nextInt(10) == 0 ? 4 : 2;\n        tiles[row][col] = new Tile(val);\n    }\n\n    private boolean move(int countDownFrom, int yIncr, int xIncr) {\n        boolean moved = false;\n\n        for (int i = 0; i < side * side; i++) {\n            int j = Math.abs(countDownFrom - i);\n\n            int r = j / side;\n            int c = j % side;\n\n            if (tiles[r][c] == null)\n                continue;\n\n            int nextR = r + yIncr;\n            int nextC = c + xIncr;\n\n            while (nextR >= 0 && nextR < side && nextC >= 0 && nextC < side) {\n\n                Tile next = tiles[nextR][nextC];\n                Tile curr = tiles[r][c];\n\n                if (next == null) {\n\n                    if (checkingAvailableMoves)\n                        return true;\n\n                    tiles[nextR][nextC] = curr;\n                    tiles[r][c] = null;\n                    r = nextR;\n                    c = nextC;\n                    nextR += yIncr;\n                    nextC += xIncr;\n                    moved = true;\n\n                } else if (next.canMergeWith(curr)) {\n\n                    if (checkingAvailableMoves)\n                        return true;\n\n                    int value = next.mergeWith(curr);\n                    if (value > highest)\n                        highest = value;\n                    score += value;\n                    tiles[r][c] = null;\n                    moved = true;\n                    break;\n                } else\n                    break;\n            }\n        }\n\n        if (moved) {\n            if (highest < target) {\n                clearMerged();\n                addRandomTile();\n                if (!movesAvailable()) {\n                    gamestate = State.over;\n                }\n            } else if (highest == target)\n                gamestate = State.won;\n        }\n\n        return moved;\n    }\n\n    boolean moveUp() {\n        return move(0, -1, 0);\n    }\n\n    boolean moveDown() {\n        return move(side * side - 1, 1, 0);\n    }\n\n    boolean moveLeft() {\n        return move(0, 0, -1);\n    }\n\n    boolean moveRight() {\n        return move(side * side - 1, 0, 1);\n    }\n\n    void clearMerged() {\n        for (Tile[] row : tiles)\n            for (Tile tile : row)\n                if (tile != null)\n                    tile.setMerged(false);\n    }\n\n    boolean movesAvailable() {\n        checkingAvailableMoves = true;\n        boolean hasMoves = moveUp() || moveDown() || moveLeft() || moveRight();\n        checkingAvailableMoves = false;\n        return hasMoves;\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"2048\");\n            f.setResizable(true);\n            f.add(new Game2048(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n\nclass Tile {\n    private boolean merged;\n    private int value;\n\n    Tile(int val) {\n        value = val;\n    }\n\n    int getValue() {\n        return value;\n    }\n\n    void setMerged(boolean m) {\n        merged = m;\n    }\n\n    boolean canMergeWith(Tile other) {\n        return !merged && other != null && !other.merged && value == other.getValue();\n    }\n\n    int mergeWith(Tile other) {\n        if (canMergeWith(other)) {\n            value *= 2;\n            merged = true;\n            return value;\n        }\n        return -1;\n    }\n}\n"}
{"id": 349634, "name": "Pig the dice game_Player", "source": "Translate Perl to Java: my $GOAL = 100;\n\npackage Player;\n\nsub new {\n    my ($class,$strategy) = @_;\n    my $self = {\n        score    => 0,\n        rolls    => 0,\n        ante     => 0,\n        strategy => $strategy || sub { 0 } \n    };\n    return bless($self, $class);\n}\n\nsub turn {\n    my ($P) = @_;\n    $P->{rolls} = 0;\n    $P->{ante}  = 0;\n    my $done    = 0;\n    do {\n        my $v = 1 + int rand 6;\n        $P->{rolls}++;\n        if ($v == 1) {\n            $P->{ante} = 0;\n            $done = 1;\n        } else {\n            $P->{ante} += $v;\n        }\n        $done = 1 if $P->{score} + $P->{ante} >= $GOAL or $P->{strategy}();\n    } until $done;\n    $P->{score} += $P->{ante};\n}\n\npackage Main;\n\n\n$players[0] = Player->new;\n\n\n$players[1] = Player->new( sub { $players[1]->{rolls} >= 5 } );\n\n\n@players[2] = Player->new( sub { $players[2]->{ante} > 20 } );\n\n\n$players[3] = Player->new( sub { rand() < 0.1 } );\n\n\n$players[4] = Player->new( sub { rand() < ( $GOAL - $players[4]->{score} ) * .6 / $GOAL } );\n\nfor (1 .. shift || 100) {\n    my $player = -1;\n    do {\n        $player++;\n        @players[$player % @players]->turn;\n    } until $players[$player % @players]->{score} >= $GOAL;\n\n    $wins[$player % @players]++;\n\n    printf \"%5d\", $players[$_]->{score} for 0..$\n    $players[$_]->{score} = 0 for 0..$\n}\n\nprint ' ----' x @players, \"\\n\";\nprintf \"%5d\", $_ for @wins; print \"\\n\";\n", "target": "import java.util.Scanner;\n\npublic class Pigdice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint players = 0;\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tSystem.out.println(\"Hello, welcome to Pig Dice the game! How many players? \");\n\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\tif(nextInt > 0) {\n\t\t\t\t\tplayers = nextInt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"That wasn't an integer. Try again. \\n\");\n\t\t\t\tscan.next();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Alright, starting with \" + players + \" players. \\n\");\n\t\t\n\t\t\n\t\tplay(players, scan);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tpublic static void play(int group, Scanner scan) {\n\t\t\n\t\tfinal int STRATEGIES = 5;\n\t\t\n\t\t\n\t\tDice dice = new Dice();\n\t\t\n\t\t\n\t\tPlayer[] players = new Player[group];\n\t\tfor(int count = 0; count < group; count++) {\n\t\t\tplayers[count] = new Player(count);\n\t\t\tSystem.out.println(\"Player \" + players[count].getNumber() + \"  is alive! \");\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(\"Each strategy is numbered 0 - \" + (STRATEGIES - 1) + \". They are as follows: \");\n\t\tSystem.out.println(\">> Enter '0' for a human player. \");\n\t\tSystem.out.println(\">> Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.\");\n\t\tSystem.out.println(\">> Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold. \");\n\t\tSystem.out.println(\">> Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls. \");\n\t\tSystem.out.println(\">> Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll. \");\n\t\t\n\t\t\n\t\tfor(Player player : players) {\n\t\t\tSystem.out.println(\"\\nWhat strategy would you like player \" + player.getNumber() + \" to use? \");\n\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\t\tif (nextInt < Strategy.STRATEGIES.length) {\n\t\t\t\t\t\tplayer.setStrategy(Strategy.STRATEGIES[nextInt]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"That wasn't an option. Try again. \");\n\t\t\t\t\tscan.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint max = 0;\n\t\twhile(max < 100) {\n\t\t\t\n\t\t\t\n\t\t\tfor(Player player : players) {\n\t\t\t\tSystem.out.println(\">> Beginning Player \" + player.getNumber() + \"'s turn. \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setMax(max);\n\t\t\t\twhile(true) {\n\t\t\t\t\tMove choice = player.choose();\n\t\t\t\t\tif(choice == Move.ROLL) {\n\t\t\t\t\t\tint roll = dice.roll();\n\t\t\t\t\t\tSystem.out.println(\"   A \" + roll + \" was rolled. \");\n\t\t\t\t\t\tplayer.setTurnPoints(player.getTurnPoints() + roll);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tplayer.incIter();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(roll == 1) {\n\t\t\t\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"   The player has held. \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.addPoints(player.getTurnPoints());\n\t\t\t\tSystem.out.println(\"   Player \" + player.getNumber() + \"'s turn is now over. Their total is \" + player.getPoints() + \". \\n\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.resetIter();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max < player.getPoints()) {\n\t\t\t\t\tmax = player.getPoints();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max >= 100) {\n\t\t\t\t\tSystem.out.println(\"Player \" + player.getNumber() + \" wins with \" + max + \" points! End scores: \");\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(Player p : players) {\n\t\t\t\t\t\tSystem.out.println(\"Player \" + p.getNumber() + \" had \" + p.getPoints() + \" points. \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"}
{"id": 349635, "name": "Pig the dice game_Player", "source": "Translate Perl to Java: my $GOAL = 100;\n\npackage Player;\n\nsub new {\n    my ($class,$strategy) = @_;\n    my $self = {\n        score    => 0,\n        rolls    => 0,\n        ante     => 0,\n        strategy => $strategy || sub { 0 } \n    };\n    return bless($self, $class);\n}\n\nsub turn {\n    my ($P) = @_;\n    $P->{rolls} = 0;\n    $P->{ante}  = 0;\n    my $done    = 0;\n    do {\n        my $v = 1 + int rand 6;\n        $P->{rolls}++;\n        if ($v == 1) {\n            $P->{ante} = 0;\n            $done = 1;\n        } else {\n            $P->{ante} += $v;\n        }\n        $done = 1 if $P->{score} + $P->{ante} >= $GOAL or $P->{strategy}();\n    } until $done;\n    $P->{score} += $P->{ante};\n}\n\npackage Main;\n\n\n$players[0] = Player->new;\n\n\n$players[1] = Player->new( sub { $players[1]->{rolls} >= 5 } );\n\n\n@players[2] = Player->new( sub { $players[2]->{ante} > 20 } );\n\n\n$players[3] = Player->new( sub { rand() < 0.1 } );\n\n\n$players[4] = Player->new( sub { rand() < ( $GOAL - $players[4]->{score} ) * .6 / $GOAL } );\n\nfor (1 .. shift || 100) {\n    my $player = -1;\n    do {\n        $player++;\n        @players[$player % @players]->turn;\n    } until $players[$player % @players]->{score} >= $GOAL;\n\n    $wins[$player % @players]++;\n\n    printf \"%5d\", $players[$_]->{score} for 0..$\n    $players[$_]->{score} = 0 for 0..$\n}\n\nprint ' ----' x @players, \"\\n\";\nprintf \"%5d\", $_ for @wins; print \"\\n\";\n", "target": "import java.util.Scanner;\n\npublic class Pigdice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint players = 0;\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tSystem.out.println(\"Hello, welcome to Pig Dice the game! How many players? \");\n\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\tif(nextInt > 0) {\n\t\t\t\t\tplayers = nextInt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"That wasn't an integer. Try again. \\n\");\n\t\t\t\tscan.next();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Alright, starting with \" + players + \" players. \\n\");\n\t\t\n\t\t\n\t\tplay(players, scan);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tpublic static void play(int group, Scanner scan) {\n\t\t\n\t\tfinal int STRATEGIES = 5;\n\t\t\n\t\t\n\t\tDice dice = new Dice();\n\t\t\n\t\t\n\t\tPlayer[] players = new Player[group];\n\t\tfor(int count = 0; count < group; count++) {\n\t\t\tplayers[count] = new Player(count);\n\t\t\tSystem.out.println(\"Player \" + players[count].getNumber() + \"  is alive! \");\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(\"Each strategy is numbered 0 - \" + (STRATEGIES - 1) + \". They are as follows: \");\n\t\tSystem.out.println(\">> Enter '0' for a human player. \");\n\t\tSystem.out.println(\">> Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.\");\n\t\tSystem.out.println(\">> Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold. \");\n\t\tSystem.out.println(\">> Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls. \");\n\t\tSystem.out.println(\">> Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll. \");\n\t\t\n\t\t\n\t\tfor(Player player : players) {\n\t\t\tSystem.out.println(\"\\nWhat strategy would you like player \" + player.getNumber() + \" to use? \");\n\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\t\tif (nextInt < Strategy.STRATEGIES.length) {\n\t\t\t\t\t\tplayer.setStrategy(Strategy.STRATEGIES[nextInt]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"That wasn't an option. Try again. \");\n\t\t\t\t\tscan.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint max = 0;\n\t\twhile(max < 100) {\n\t\t\t\n\t\t\t\n\t\t\tfor(Player player : players) {\n\t\t\t\tSystem.out.println(\">> Beginning Player \" + player.getNumber() + \"'s turn. \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setMax(max);\n\t\t\t\twhile(true) {\n\t\t\t\t\tMove choice = player.choose();\n\t\t\t\t\tif(choice == Move.ROLL) {\n\t\t\t\t\t\tint roll = dice.roll();\n\t\t\t\t\t\tSystem.out.println(\"   A \" + roll + \" was rolled. \");\n\t\t\t\t\t\tplayer.setTurnPoints(player.getTurnPoints() + roll);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tplayer.incIter();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(roll == 1) {\n\t\t\t\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"   The player has held. \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.addPoints(player.getTurnPoints());\n\t\t\t\tSystem.out.println(\"   Player \" + player.getNumber() + \"'s turn is now over. Their total is \" + player.getPoints() + \". \\n\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.resetIter();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max < player.getPoints()) {\n\t\t\t\t\tmax = player.getPoints();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max >= 100) {\n\t\t\t\t\tSystem.out.println(\"Player \" + player.getNumber() + \" wins with \" + max + \" points! End scores: \");\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(Player p : players) {\n\t\t\t\t\t\tSystem.out.println(\"Player \" + p.getNumber() + \" had \" + p.getPoints() + \" points. \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"}
{"id": 349636, "name": "Odd words", "source": "Translate Perl to Java: \n\n@ARGV = 'unixdict.txt';\nchomp( my @words = <> );\nmy %dict;\n@dict{ grep length > 4, @words} = ();\nfor ( @words )\n  {\n  my $oddword = s/(.).?/$1/gr;\n  exists $dict{$oddword} and print \" $_ $oddword\\n\";\n  }\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class OddWords {\n    public static void main(String[] args) {\n        try {\n            Set<String> dictionary = new TreeSet<>();\n            final int minLength = 5;\n            String fileName = \"unixdict.txt\";\n            if (args.length != 0)\n                fileName = args[0];\n            try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n                String line;\n                while ((line = reader.readLine()) != null) {\n                    if (line.length() >= minLength)\n                        dictionary.add(line);\n                }\n            }\n            StringBuilder word1 = new StringBuilder();\n            StringBuilder word2 = new StringBuilder();\n            List<StringPair> evenWords = new ArrayList<>();\n            List<StringPair> oddWords = new ArrayList<>();\n            for (String word : dictionary) {\n                int length = word.length();\n                if (length < minLength + 2 * (minLength/2))\n                    continue;\n                word1.setLength(0);\n                word2.setLength(0);\n                for (int i = 0; i < length; ++i) {\n                    if ((i & 1) == 0)\n                        word1.append(word.charAt(i));\n                    else\n                        word2.append(word.charAt(i));\n                }\n                String oddWord = word1.toString();\n                String evenWord = word2.toString();\n                if (dictionary.contains(oddWord))\n                    oddWords.add(new StringPair(word, oddWord));\n                if (dictionary.contains(evenWord))\n                    evenWords.add(new StringPair(word, evenWord));\n            }\n            System.out.println(\"Odd words:\");\n            printWords(oddWords);\n            System.out.println(\"\\nEven words:\");\n            printWords(evenWords);\n        } catch (Exception e)  {\n            e.printStackTrace();\n        }\n    }\n\n    private static void printWords(List<StringPair> strings) {\n        int n = 1;\n        for (StringPair pair : strings) {\n            System.out.printf(\"%2d:\u00a0%-14s%s\\n\", n++,\n                                    pair.string1, pair.string2);\n        }\n    }\n\n    private static class StringPair {\n        private String string1;\n        private String string2;\n        private StringPair(String s1, String s2) {\n            string1 = s1;\n            string2 = s2;\n        }\n    }\n}\n"}
{"id": 349637, "name": "Maze solving", "source": "Translate Perl to Java: \nuse strict;\nuse warnings;\n\nmy ($width, $height) = @ARGV;\n$_ ||= 10 for $width, $height;\n\nmy %visited;\n\nmy $h_barrier = \"+\" . (\"--+\" x $width) . \"\\n\";\nmy $v_barrier = \"|\" . (\"  |\" x $width) . \"\\n\";\nmy @output = ($h_barrier, $v_barrier) x $height;\npush @output, $h_barrier;\nmy @dx = qw(-1 1 0 0);\nmy @dy = qw(0 0 -1 1);\n\nsub visit {\n   my ($x, $y) = @_;\n   $visited{$x, $y} = 1;\n   my $rand = int rand 4;\n   for my $n ( $rand .. 3, 0 .. $rand-1 ) {\n      my ($xx, $yy) = ($x + $dx[$n], $y + $dy[$n]);\n      next if $visited{ $xx, $yy };\n      next if $xx < 0 or $xx >= $width;\n      next if $yy < 0 or $yy >= $height;\n\n      my $row = $y * 2 + 1 + $dy[$n];\n      my $col = $x * 3 + 1 + $dx[$n];\n      substr( $output[$row], $col, 2, '  ' );\n\n      no warnings 'recursion';\n      visit( $xx, $yy );\n   }\n}\n\nvisit( int rand $width, int rand $height );\n\nprint \"Here is the maze:\\n\";\nprint @output;\n\n%visited = ();\n\nmy @d = ('>>', '<<', 'vv', '^^');\nsub solve {\n   my ($x, $y) = @_;\n   return 1 if $x == 0 and $y == 0;\n   $visited{ $x, $y } = 1;\n   my $rand = int rand 4;\n   for my $n ( $rand .. 3, 0 .. $rand-1 ) {\n      my ($xx, $yy) = ($x + $dx[$n], $y + $dy[$n]);\n      next if $visited{ $xx, $yy };\n      next if $xx < 0 or $xx >= $width;\n      next if $yy < 0 or $yy >= $height;\n\n      my $row = $y * 2 + 1 + $dy[$n];\n      my $col = $x * 3 + 1 + $dx[$n];\n\n      my $b = substr( $output[$row], $col, 2 );\n      next if \"  \" ne $b;\n\n      no warnings 'recursion';\n      next if not solve( $xx, $yy );\n\n      substr( $output[$row], $col, 2, $d[$n] );\n      substr( $output[$row-$dy[$n]], $col-$dx[$n], 2, $d[$n] );\n      return 1;\n   }\n   0;\n}\n\nif( solve( $width-1, $height-1 ) ) {\n   print \"Here is the solution:\\n\";\n   substr( $output[1], 1, 2, '**' );\n   print @output;\n} else {\n   print \"Could not solve!\\n\";\n}\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class MazeSolver\n{\n    \n    private static String[] readLines (InputStream f) throws IOException\n    {\n        BufferedReader r =\n            new BufferedReader (new InputStreamReader (f, \"US-ASCII\"));\n        ArrayList<String> lines = new ArrayList<String>();\n        String line;\n        while ((line = r.readLine()) != null)\n            lines.add (line);\n        return lines.toArray(new String[0]);\n    }\n\n    \n    private static char[][] decimateHorizontally (String[] lines)\n    {\n        final int width = (lines[0].length() + 1) / 2;\n        char[][] c = new char[lines.length][width];\n        for (int i = 0  ;  i < lines.length  ;  i++)\n            for (int j = 0  ;  j < width  ;  j++)\n                c[i][j] = lines[i].charAt (j * 2);\n        return c;\n    }\n\n    \n    private static boolean solveMazeRecursively (char[][] maze,\n                                                 int x, int y, int d)\n    {\n        boolean ok = false;\n        for (int i = 0  ;  i < 4  &&  !ok  ;  i++)\n            if (i != d)\n                switch (i)\n                    {\n                        \n                    case 0:\n                        if (maze[y-1][x] == ' ')\n                            ok = solveMazeRecursively (maze, x, y - 2, 2);\n                        break;\n                    case 1:\n                        if (maze[y][x+1] == ' ')\n                            ok = solveMazeRecursively (maze, x + 2, y, 3);\n                        break;\n                    case 2:\n                        if (maze[y+1][x] == ' ')\n                            ok = solveMazeRecursively (maze, x, y + 2, 0);\n                        break;\n                    case 3:\n                        if (maze[y][x-1] == ' ')\n                            ok = solveMazeRecursively (maze, x - 2, y, 1);\n                        break;\n                    }\n        \n        if (x == 1  &&  y == 1)\n            ok = true;\n        \n        if (ok)\n            {\n                maze[y][x] = '*';\n                switch (d)\n                    {\n                    case 0:\n                        maze[y-1][x] = '*';\n                        break;\n                    case 1:\n                        maze[y][x+1] = '*';\n                        break;\n                    case 2:\n                        maze[y+1][x] = '*';\n                        break;\n                    case 3:\n                        maze[y][x-1] = '*';\n                        break;\n                    }\n            }\n        return ok;\n    }\n\n    \n    private static void solveMaze (char[][] maze)\n    {\n        solveMazeRecursively (maze, maze[0].length - 2, maze.length - 2, -1);\n    }\n\n    \n    private static String[] expandHorizontally (char[][] maze)\n    {\n        char[] tmp = new char[3];\n        String[] lines = new String[maze.length];\n        for (int i = 0  ;  i < maze.length  ;  i++)\n            {\n                StringBuilder sb = new StringBuilder(maze[i].length * 2);\n                for (int j = 0  ;  j < maze[i].length  ;  j++)\n                    if (j % 2 == 0)\n                        sb.append (maze[i][j]);\n                    else\n                        {\n                            tmp[0] = tmp[1] = tmp[2] = maze[i][j];\n                            if (tmp[1] == '*')\n                                tmp[0] = tmp[2] = ' ';\n                            sb.append (tmp);\n                        }\n                lines[i] = sb.toString();\n            }\n        return lines;\n    }\n\n    \n    public static void main (String[] args) throws IOException\n    {\n        InputStream f = (args.length > 0\n                         ?  new FileInputStream (args[0])\n                         :  System.in);\n        String[] lines = readLines (f);\n        char[][] maze = decimateHorizontally (lines);\n        solveMaze (maze);\n        String[] solvedLines = expandHorizontally (maze);\n        for (int i = 0  ;  i < solvedLines.length  ;  i++)\n            System.out.println (solvedLines[i]);\n    }\n}\n"}
{"id": 349638, "name": "Deming's funnel", "source": "Translate Perl to Java: @dx = qw<\n    -0.533  0.270  0.859 -0.043 -0.205 -0.127 -0.071  0.275\n     1.251 -0.231 -0.401  0.269  0.491  0.951  1.150  0.001\n    -0.382  0.161  0.915  2.080 -2.337  0.034 -0.126  0.014\n     0.709  0.129 -1.093 -0.483 -1.193  0.020 -0.051  0.047\n    -0.095  0.695  0.340 -0.182  0.287  0.213 -0.423 -0.021\n    -0.134  1.798  0.021 -1.099 -0.361  1.636 -1.134  1.315\n     0.201  0.034  0.097 -0.170  0.054 -0.553 -0.024 -0.181\n    -0.700 -0.361 -0.789  0.279 -0.174 -0.009 -0.323 -0.658\n     0.348 -0.528  0.881  0.021 -0.853  0.157  0.648  1.774\n    -1.043  0.051  0.021  0.247 -0.310  0.171  0.000  0.106\n     0.024 -0.386  0.962  0.765 -0.125 -0.289  0.521  0.017\n     0.281 -0.749 -0.149 -2.436 -0.909  0.394 -0.113 -0.598\n     0.443 -0.521 -0.799  0.087>;\n\n@dy = qw<\n     0.136  0.717  0.459 -0.225  1.392  0.385  0.121 -0.395\n     0.490 -0.682 -0.065  0.242 -0.288  0.658  0.459  0.000\n     0.426  0.205 -0.765 -2.188 -0.742 -0.010  0.089  0.208\n     0.585  0.633 -0.444 -0.351 -1.087  0.199  0.701  0.096\n    -0.025 -0.868  1.051  0.157  0.216  0.162  0.249 -0.007\n     0.009  0.508 -0.790  0.723  0.881 -0.508  0.393 -0.226\n     0.710  0.038 -0.217  0.831  0.480  0.407  0.447 -0.295\n     1.126  0.380  0.549 -0.445 -0.046  0.428 -0.074  0.217\n    -0.822  0.491  1.347 -0.141  1.230 -0.044  0.079  0.219\n     0.698  0.275  0.056  0.031  0.421  0.064  0.721  0.104\n    -0.729  0.650 -1.103  0.154 -1.720  0.051 -0.385  0.477\n     1.537 -0.901  0.939 -0.411  0.341 -0.411  0.106  0.224\n    -0.947 -1.424 -0.542 -1.032>;\n\nsub mean   { my $s; $s += $_ for @_; $s / @_ }\nsub stddev { sqrt( mean(map { $_**2 } @_) - mean(@_)**2) }\n\n@rules = (\nsub { 0 },\nsub { -$_[1] },\nsub { -$_[0] - $_[1] },\nsub {  $_[0] + $_[1] }\n);\n\nfor (@rules) {\n    print \"Rule \" . ++$cnt . \"\\n\";\n\n    my @ddx; my $tx = 0;\n    for my $x (@dx) { push @ddx, $tx + $x; $tx = &$_($tx, $x) }\n    my @ddy; my $ty = 0;\n    for my $y (@dy) { push @ddy, $ty + $y; $ty = &$_($ty, $y) }\n\n    printf \"Mean    x, y  \u00a0: %7.4f %7.4f\\n\",   mean(@ddx),   mean(@ddy);\n    printf \"Std dev x, y  \u00a0: %7.4f %7.4f\\n\", stddev(@ddx), stddev(@ddy);\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 349639, "name": "Deming's funnel", "source": "Translate Perl to Java: @dx = qw<\n    -0.533  0.270  0.859 -0.043 -0.205 -0.127 -0.071  0.275\n     1.251 -0.231 -0.401  0.269  0.491  0.951  1.150  0.001\n    -0.382  0.161  0.915  2.080 -2.337  0.034 -0.126  0.014\n     0.709  0.129 -1.093 -0.483 -1.193  0.020 -0.051  0.047\n    -0.095  0.695  0.340 -0.182  0.287  0.213 -0.423 -0.021\n    -0.134  1.798  0.021 -1.099 -0.361  1.636 -1.134  1.315\n     0.201  0.034  0.097 -0.170  0.054 -0.553 -0.024 -0.181\n    -0.700 -0.361 -0.789  0.279 -0.174 -0.009 -0.323 -0.658\n     0.348 -0.528  0.881  0.021 -0.853  0.157  0.648  1.774\n    -1.043  0.051  0.021  0.247 -0.310  0.171  0.000  0.106\n     0.024 -0.386  0.962  0.765 -0.125 -0.289  0.521  0.017\n     0.281 -0.749 -0.149 -2.436 -0.909  0.394 -0.113 -0.598\n     0.443 -0.521 -0.799  0.087>;\n\n@dy = qw<\n     0.136  0.717  0.459 -0.225  1.392  0.385  0.121 -0.395\n     0.490 -0.682 -0.065  0.242 -0.288  0.658  0.459  0.000\n     0.426  0.205 -0.765 -2.188 -0.742 -0.010  0.089  0.208\n     0.585  0.633 -0.444 -0.351 -1.087  0.199  0.701  0.096\n    -0.025 -0.868  1.051  0.157  0.216  0.162  0.249 -0.007\n     0.009  0.508 -0.790  0.723  0.881 -0.508  0.393 -0.226\n     0.710  0.038 -0.217  0.831  0.480  0.407  0.447 -0.295\n     1.126  0.380  0.549 -0.445 -0.046  0.428 -0.074  0.217\n    -0.822  0.491  1.347 -0.141  1.230 -0.044  0.079  0.219\n     0.698  0.275  0.056  0.031  0.421  0.064  0.721  0.104\n    -0.729  0.650 -1.103  0.154 -1.720  0.051 -0.385  0.477\n     1.537 -0.901  0.939 -0.411  0.341 -0.411  0.106  0.224\n    -0.947 -1.424 -0.542 -1.032>;\n\nsub mean   { my $s; $s += $_ for @_; $s / @_ }\nsub stddev { sqrt( mean(map { $_**2 } @_) - mean(@_)**2) }\n\n@rules = (\nsub { 0 },\nsub { -$_[1] },\nsub { -$_[0] - $_[1] },\nsub {  $_[0] + $_[1] }\n);\n\nfor (@rules) {\n    print \"Rule \" . ++$cnt . \"\\n\";\n\n    my @ddx; my $tx = 0;\n    for my $x (@dx) { push @ddx, $tx + $x; $tx = &$_($tx, $x) }\n    my @ddy; my $ty = 0;\n    for my $y (@dy) { push @ddy, $ty + $y; $ty = &$_($ty, $y) }\n\n    printf \"Mean    x, y  \u00a0: %7.4f %7.4f\\n\",   mean(@ddx),   mean(@ddy);\n    printf \"Std dev x, y  \u00a0: %7.4f %7.4f\\n\", stddev(@ddx), stddev(@ddy);\n}\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 349640, "name": "MD5_Implementation", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse integer;\nuse Test::More;\n\nBEGIN { plan tests => 7 }\n\nsub A()   { 0x67_45_23_01 }\nsub B()   { 0xef_cd_ab_89 }\nsub C()   { 0x98_ba_dc_fe }\nsub D()   { 0x10_32_54_76 }\nsub MAX() { 0xFFFFFFFF }\n\nsub padding {\n    my $l = length (my $msg = shift() . chr(128));\n    $msg .= \"\\0\" x (($l%64<=56?56:120)-$l%64);\n    $l = ($l-1)*8;\n    $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);\n}\n\nsub rotate_left {\n    ($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));\n}\n\nsub gen_code {\n  \n  my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';\n  my %f = (\n    FF => \"X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    GG => \"X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    HH => \"X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    II => \"X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n  );\n\n  my %s = (  \n    S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,\n    S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,\n    S43 => 15, S44 => 21\n  );\n\n  my $insert = \"\\n\";\n  while(defined( my $data = <DATA> )) {\n    chomp $data;\n    next unless $data =~ /^[FGHI]/;\n    my ($func,@x) = split /,/, $data;\n    my $c = $f{$func};\n    $c =~ s/X(\\d)/$x[$1]/g;\n    $c =~ s/(S\\d{2})/$s{$1}/;\n    $c =~ s/^(.*)=rotate_left\\((.*),(.*)\\)\\+(.*)$//;\n\n    my $su = 32 - $3;\n    my $sh = (1 << $3) - 1;\n\n    $c = \"$1=(((\\$r=$2)<<$3)|((\\$r>>$su)&$sh))+$4\";\n\n    $insert .= \"\\t$c\\n\";\n  }\n  close DATA;\n\n  my $dump = '\n  sub round {\n    my ($a,$b,$c,$d) = @_[0 .. 3];\n    my $r;' . $insert . '\n    $_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK .\n    ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';\n  }';\n  eval $dump;\n}\n\ngen_code();\n\nsub _encode_hex { unpack 'H*', $_[0] }\n\nsub md5 {\n    my $message = padding(join'',@_);\n    my ($a,$b,$c,$d) = (A,B,C,D);\n    my $i;\n    for $i (0 .. (length $message)/64-1) {\n        my @X = unpack 'V16', substr $message,$i*64,64;\n        ($a,$b,$c,$d) = round($a,$b,$c,$d,@X);\n    }\n    pack 'V4',$a,$b,$c,$d;\n}\n\nmy $strings = {\n    'd41d8cd98f00b204e9800998ecf8427e' => '',\n    '0cc175b9c0f1b6a831c399e269772661' => 'a',\n    '900150983cd24fb0d6963f7d28e17f72' => 'abc',\n    'f96b697d7cb7938d525a2f31aaf161d0' => 'message digest',\n    'c3fcd3d76192e4007dfb496cca67e13b' => 'abcdefghijklmnopqrstuvwxyz',\n    'd174ab98d277d9f5a5611c2c9f419d9f' => 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',\n    '57edf4a22be3c955ac49da2e2107b67a' => '12345678901234567890123456789012345678901234567890123456789012345678901234567890',\n};\n\nfor my $k (keys %$strings) {\n    my $digest = _encode_hex md5($strings->{$k});\n    is($digest, $k, \"$digest is MD5 digest $strings->{$k}\");\n}\n\n", "target": "class MD5\n{\n\n  private static final int INIT_A = 0x67452301;\n  private static final int INIT_B = (int)0xEFCDAB89L;\n  private static final int INIT_C = (int)0x98BADCFEL;\n  private static final int INIT_D = 0x10325476;\n  \n  private static final int[] SHIFT_AMTS = {\n    7, 12, 17, 22,\n    5,  9, 14, 20,\n    4, 11, 16, 23,\n    6, 10, 15, 21\n  };\n  \n  private static final int[] TABLE_T = new int[64];\n  static\n  {\n    for (int i = 0; i < 64; i++)\n      TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));\n  }\n  \n  public static byte[] computeMD5(byte[] message)\n  {\n    int messageLenBytes = message.length;\n    int numBlocks = ((messageLenBytes + 8) >>> 6) + 1;\n    int totalLen = numBlocks << 6;\n    byte[] paddingBytes = new byte[totalLen - messageLenBytes];\n    paddingBytes[0] = (byte)0x80;\n    \n    long messageLenBits = (long)messageLenBytes << 3;\n    for (int i = 0; i < 8; i++)\n    {\n      paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits;\n      messageLenBits >>>= 8;\n    }\n    \n    int a = INIT_A;\n    int b = INIT_B;\n    int c = INIT_C;\n    int d = INIT_D;\n    int[] buffer = new int[16];\n    for (int i = 0; i < numBlocks; i ++)\n    {\n      int index = i << 6;\n      for (int j = 0; j < 64; j++, index++)\n        buffer[j >>> 2] = ((int)((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8);\n      int originalA = a;\n      int originalB = b;\n      int originalC = c;\n      int originalD = d;\n      for (int j = 0; j < 64; j++)\n      {\n        int div16 = j >>> 4;\n        int f = 0;\n        int bufferIndex = j;\n        switch (div16)\n        {\n          case 0:\n            f = (b & c) | (~b & d);\n            break;\n            \n          case 1:\n            f = (b & d) | (c & ~d);\n            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;\n            break;\n            \n          case 2:\n            f = b ^ c ^ d;\n            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;\n            break;\n            \n          case 3:\n            f = c ^ (b | ~d);\n            bufferIndex = (bufferIndex * 7) & 0x0F;\n            break;\n        }\n        int temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);\n        a = d;\n        d = c;\n        c = b;\n        b = temp;\n      }\n      \n      a += originalA;\n      b += originalB;\n      c += originalC;\n      d += originalD;\n    }\n    \n    byte[] md5 = new byte[16];\n    int count = 0;\n    for (int i = 0; i < 4; i++)\n    {\n      int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d));\n      for (int j = 0; j < 4; j++)\n      {\n        md5[count++] = (byte)n;\n        n >>>= 8;\n      }\n    }\n    return md5;\n  }\n  \n  public static String toHexString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      sb.append(String.format(\"%02X\", b[i] & 0xFF));\n    }\n    return sb.toString();\n  }\n\n  public static void main(String[] args)\n  {\n    String[] testStrings = { \"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };\n    for (String s : testStrings)\n      System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\");\n    return;\n  }\n  \n}\n"}
{"id": 349641, "name": "Assertions in design by contract", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\npackage MessageMultiplier;\n\nuse Class::Contract;\nuse Test::More tests => 2;\nuse Test::Exception;\n\ncontract {\n\n   attr 'multiplier' => 'SCALAR';\n   attr 'message'    => 'SCALAR';\n\n   ctor 'new';\n      impl { ( ${self->multiplier}, ${self->message} ) = @_ };\n\n   method 'execute';\n      pre  { ${self->multiplier} > 1 and length ${self->message} > 0 };\n      impl { print ${self->message} x ${self->multiplier} , \"\\n\" };\n};\n\nMessageMultiplier->new(2,'A')->execute;\ndies_ok { MessageMultiplier->new(1,'B')->execute };\ndies_ok { MessageMultiplier->new(3, '')->execute };\n", "target": "(...)\nint feedForward(double[] inputs) {\n    assert inputs.length == weights.length : \"weights and input length mismatch\";\n\n    double sum = 0;\n    for (int i = 0; i < weights.length; i++) {\n        sum += inputs[i] * weights[i];\n    }\n    return activate(sum);\n}\n(...)\n"}
{"id": 349642, "name": "Assertions in design by contract", "source": "Translate Perl to Java: \n\nuse strict;\nuse warnings;\n\npackage MessageMultiplier;\n\nuse Class::Contract;\nuse Test::More tests => 2;\nuse Test::Exception;\n\ncontract {\n\n   attr 'multiplier' => 'SCALAR';\n   attr 'message'    => 'SCALAR';\n\n   ctor 'new';\n      impl { ( ${self->multiplier}, ${self->message} ) = @_ };\n\n   method 'execute';\n      pre  { ${self->multiplier} > 1 and length ${self->message} > 0 };\n      impl { print ${self->message} x ${self->multiplier} , \"\\n\" };\n};\n\nMessageMultiplier->new(2,'A')->execute;\ndies_ok { MessageMultiplier->new(1,'B')->execute };\ndies_ok { MessageMultiplier->new(3, '')->execute };\n", "target": "(...)\nint feedForward(double[] inputs) {\n    assert inputs.length == weights.length : \"weights and input length mismatch\";\n\n    double sum = 0;\n    for (int i = 0; i < weights.length; i++) {\n        sum += inputs[i] * weights[i];\n    }\n    return activate(sum);\n}\n(...)\n"}
{"id": 349643, "name": "History variables", "source": "Translate Perl to Java: package History;\n\nsub TIESCALAR {\n\tmy $cls = shift;\n\tmy $cur_val = shift;\n\treturn bless [];\n}\n\nsub FETCH {\n\treturn shift->[-1]\n}\n\nsub STORE {\n\tmy ($var, $val) = @_;\n\tpush @$var, $val;\n\treturn $val;\n}\n\nsub get(\\$) { @{tied ${+shift}} }\nsub on(\\$) { tie ${+shift}, __PACKAGE__ } \nsub off(\\$) { untie ${+shift} }\nsub undo(\\$) { pop @{tied ${+shift}} }\n\npackage main;\n\nmy $x = 0;\nHistory::on($x);\n\nfor (\"a\" .. \"d\") { $x = $_ }\n\nprint \"History: @{[History::get($x)]}\\n\";\n\nfor (1 .. 3) {\n\tprint \"undo $_, \";\n\tHistory::undo($x);\n\tprint \"current value: $x\\n\";\n}\n\nHistory::off($x);\nprint \"\\$x is: $x\\n\";\n", "target": "public class HistoryVariable\n{\n    private Object value;\n\n    public HistoryVariable(Object v)\n    {\n        value = v;\n    }\n\n    public void update(Object v)\n    {\n        value = v;\n    }\n\n    public Object undo()\n    {\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return value.toString();\n    }\n\n    public void dispose()\n    {\n    }\n}\n"}
{"id": 349644, "name": "Function definition", "source": "Translate Perl to Java: sub multiply { return $_[0] * $_[1] }\n", "target": "module MultiplyExample\n    {\n    static <Value extends Number> Value multiply(Value n1, Value n2)\n        {\n        return n1 * n2;\n        }\n\n    void run()\n        {\n        (Int i1, Int i2) = (7, 3);\n        Int i3 = multiply(i1, i2);\n        (Double d1, Double d2) = (2.7182818, 3.1415);\n        Double d3 = multiply(d1, d2);\n        @Inject Console console;\n        console.print($\"{i1}*{i2}={i3}, {d1}*{d2}={d3}\");\n        }\n    }\n"}
{"id": 349645, "name": "Successive prime differences", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse List::EachCons;\nuse Array::Compare;\nuse ntheory 'primes';\n\nmy $limit = 1E6;\nmy @primes = (2, @{ primes($limit) });\nmy @intervals = map { $primes[$_] - $primes[$_-1] } 1..$\n\nprint \"Groups of successive primes <= $limit\\n\";\n\nmy $c = Array::Compare->new;\nfor my $diffs ([2], [1], [2,2], [2,4], [4,2], [6,4,2]) {\n    my $n = -1;\n    my @offsets = grep {$_} each_cons @$diffs, @intervals, sub { $n++; $n if $c->compare(\\@_, \\@$diffs) };\n    printf \"%10s has %5d sets: %15s \u2026 %s\\n\", \n       '(' . join(' ',@$diffs) . ')',\n        scalar @offsets,\n        join(' ', @primes[$offsets[ 0]..($offsets[ 0]+@$diffs)]),\n        join(' ', @primes[$offsets[-1]..($offsets[-1]+@$diffs)]);\n}\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SuccessivePrimeDifferences {\n    private static Integer[] sieve(int limit) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        boolean[] c = new boolean[limit + 1];\n        \n        int p = 3;\n        while (true) {\n            int p2 = p * p;\n            if (p2 > limit) {\n                break;\n            }\n            for (int i = p2; i <= limit; i += 2 * p) {\n                c[i] = true;\n            }\n            do {\n                p += 2;\n            } while (c[p]);\n        }\n        for (int i = 3; i <= limit; i += 2) {\n            if (!c[i]) {\n                primes.add(i);\n            }\n        }\n\n        return primes.toArray(new Integer[0]);\n    }\n\n    private static List<List<Integer>> successivePrimes(Integer[] primes, Integer[] diffs) {\n        List<List<Integer>> results = new ArrayList<>();\n        int dl = diffs.length;\n        outer:\n        for (int i = 0; i < primes.length - dl; i++) {\n            Integer[] group = new Integer[dl + 1];\n            group[0] = primes[i];\n            for (int j = i; j < i + dl; ++j) {\n                if (primes[j + 1] - primes[j] != diffs[j - i]) {\n                    continue outer;\n                }\n                group[j - i + 1] = primes[j + 1];\n            }\n            results.add(Arrays.asList(group));\n        }\n        return results;\n    }\n\n    public static void main(String[] args) {\n        Integer[] primes = sieve(999999);\n        Integer[][] diffsList = {{2}, {1}, {2, 2}, {2, 4}, {4, 2}, {6, 4, 2}};\n        System.out.println(\"For primes less than 1,000,000:-\\n\");\n        for (Integer[] diffs : diffsList) {\n            System.out.printf(\"  For differences of %s ->\\n\", Arrays.toString(diffs));\n            List<List<Integer>> sp = successivePrimes(primes, diffs);\n            if (sp.isEmpty()) {\n                System.out.println(\"    No groups found\");\n                continue;\n            }\n            System.out.printf(\"    First group   = %s\\n\", Arrays.toString(sp.get(0).toArray(new Integer[0])));\n            System.out.printf(\"    Last group    = %s\\n\", Arrays.toString(sp.get(sp.size() - 1).toArray(new Integer[0])));\n            System.out.printf(\"    Number found  = %d\\n\", sp.size());\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 349646, "name": "10001th prime", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature 'say';\n\n\nmy($n,$c) = (1,0);\nwhile () {\n    $c++ if (1 x ++$n) !~ /^(11+)\\1+$/;\n    $c == 10_001 and say $n and last;\n}\n\n\nuse ntheory 'nth_prime';\nsay nth_prime(10_001);\n", "target": "public class NthPrime {\n    public static void main(String[] args) {\n        System.out.printf(\"The 10,001st prime is\u00a0%,d.\\n\", nthPrime(10001));\n    }\n\n    private static int nthPrime(int n) {\n        assert n > 0;\n        PrimeGenerator primeGen = new PrimeGenerator(10000, 100000);\n        int prime = primeGen.nextPrime();\n        while (--n > 0)\n            prime = primeGen.nextPrime();\n        return prime;\n    }\n}\n"}
{"id": 349647, "name": "Next special primes", "source": "Translate Perl to Java: use strict;\nuse warnings;\nuse feature <state say>;\nuse ntheory 'primes';\n\nmy $limit = 1050;\n\nsub is_special {\n    state $previous = 2;\n    state $gap      = 0;\n    state @primes = @{primes( 2*$limit )};\n\n    shift @primes while $primes[0] <= $previous + $gap;\n    $gap = $primes[0] - $previous;\n    $previous = $primes[0];\n    [$previous, $gap];\n}\n\nmy @specials = [2, 0];\ndo { push @specials, is_special() } until $specials[-1][0] >= $limit;\n\npop @specials;\nprintf \"%4d %4d\\n\", @$_ for @specials;\n", "target": "class SpecialPrimes {\n    private static boolean isPrime(int n) {\n        if (n < 2)  return false;\n        if (n%2 == 0) return n == 2;\n        if (n%3 == 0) return n == 3;\n        int d = 5;\n        while (d*d <= n) {\n            if (n%d == 0) return false;\n            d += 2;\n            if (n%d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Special primes under 1,050:\");\n        System.out.println(\"Prime1 Prime2 Gap\");\n        int lastSpecial = 3;\n        int lastGap = 1;\n        System.out.printf(\"%6d %6d %3d\\n\", 2, 3, lastGap);\n        for (int i = 5; i < 1050; i += 2) {\n            if (isPrime(i) && (i-lastSpecial) > lastGap) {\n                lastGap = i - lastSpecial;\n                System.out.printf(\"%6d %6d %3d\\n\", lastSpecial, i, lastGap);\n                lastSpecial = i;\n            }\n        }\n    }\n}\n"}

{"id": 404451, "name": "Input_Output for lines of text", "source": "Translate Haskell to Java: import Control.Monad\nmain = do\n        number <- getLine \n        input <- replicateM (read number) getLine\n        mapM_ putStrLn input\n", "target": "import java.util.Scanner;\n\npublic class Main {\n\tpublic static void doStuff(String word){\n\t   System.out.println(word);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = Integer.parseInt(in.nextLine());  \n\t\tfor(int i=0; i<n; i++){\t\t\n\t\t\tString word = in.nextLine();\n\t\t\tdoStuff(word);\n\t\t}\n\t}\n}\n"}
{"id": 404452, "name": "Length of an arc between two angles", "source": "Translate Haskell to Java: arcLength radius angle1 angle2 = (360.0 - (abs $ angle1 - angle2)) * pi * radius / 180.0\n\nmain = putStrLn $ \"arcLength 10.0 10.0 120.0 = \" ++ show (arcLength 10.0 10.0 120.0)\n", "target": "public static double arcLength(double r, double a1, double a2){\n    return (360.0 - Math.abs(a2-a1))*Math.PI/180.0 * r;\n}\n"}
{"id": 404453, "name": "Shift list elements to left by 3", "source": "Translate Haskell to Java: \n\nrotated :: Int -> [a] -> [a]\nrotated n =\n  ( (<*>) take\n      . flip (drop . mod n)\n      . cycle\n  )\n    <*> length\n\n\nmain :: IO ()\nmain =\n  let xs = [1 .. 9]\n   in putStrLn (\"Initial list: \" <> show xs <> \"\\n\")\n        >> putStrLn \"Rotated 3 or 30 positions to the left:\"\n        >> print (rotated 3 xs)\n        >> print (rotated 30 xs)\n        >> putStrLn \"\\nRotated 3 or 30 positions to the right:\"\n        >> print (rotated (-3) xs)\n        >> print (rotated (-30) xs)\n", "target": "import java.util.List;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class RotateLeft {\n    public static void main(String[] args) {\n        List<Integer> list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n        System.out.println(\"original: \" + list);\n        Collections.rotate(list, -3);\n        System.out.println(\"rotated: \" + list);\n    }\n}\n"}
{"id": 404454, "name": "Matrix with two diagonals", "source": "Translate Haskell to Java: \n\ntwoDiagonalMatrix :: Int -> [[Int]]\ntwoDiagonalMatrix n = flip (fmap . go) xs <$> xs\n  where\n    xs = [1 .. n]\n    go x y\n      | y == x = 1\n      | y == succ (subtract x n) = 1\n      | otherwise = 0\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    unlines . fmap (((' ' :) . show) =<<)\n      . twoDiagonalMatrix\n      <$> [7, 8]\n", "target": "package example.diagdiag;\n\npublic class Program {\n\n    public static void main(String[] args) {\n        DiagonalDiagonalMatrix A = new DiagonalDiagonalMatrix(7);\n        System.out.println(A);\n    }\n\n}\n\nclass DiagonalDiagonalMatrix {\n\n    final int n;\n    private double[][] a = null;\n\n    public Matrix(int n) {\n        this.n = n;\n    }\n\n    public double get(int i, int j) {\n        if (a == null) {\n            return (i == j || i == n - j + 1) ? 1.0 : 0.0;\n        } else {\n            return a[i - 1][j - 1];\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                sb.append('\\t');\n                sb.append(get(i, j));\n            }\n            sb.append('\\n');\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 404455, "name": "Longest common suffix", "source": "Translate Haskell to Java: import Data.List (transpose)\n\nlongestCommonSuffix :: [String] -> String\nlongestCommonSuffix =\n  foldr (flip (<>) . return . head) [] .\n  takeWhile (all =<< (==) . head) . transpose . fmap reverse\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . longestCommonSuffix)\n    [ [ \"Sunday\"\n      , \"Monday\"\n      , \"Tuesday\"\n      , \"Wednesday\"\n      , \"Thursday\"\n      , \"Friday\"\n      , \"Saturday\"\n      ]\n    , [ \"Sondag\"\n      , \"Maandag\"\n      , \"Dinsdag\"\n      , \"Woensdag\"\n      , \"Donderdag\"\n      , \"Vrydag\"\n      , \"Saterdag\"\n      , \"dag\"\n      ]\n    ]\n", "target": "import java.util.List;\n\npublic class App {\n    private static String lcs(List<String> a) {\n        var le = a.size();\n        if (le == 0) {\n            return \"\";\n        }\n        if (le == 1) {\n            return a.get(0);\n        }\n        var le0 = a.get(0).length();\n        var minLen = le0;\n        for (int i = 1; i < le; i++) {\n            if (a.get(i).length() < minLen) {\n                minLen = a.get(i).length();\n            }\n        }\n        if (minLen == 0) {\n            return \"\";\n        }\n        var res = \"\";\n        var a1 = a.subList(1, a.size());\n        for (int i = 1; i < minLen; i++) {\n            var suffix = a.get(0).substring(le0 - i);\n            for (String e : a1) {\n                if (!e.endsWith(suffix)) {\n                    return res;\n                }\n            }\n            res = suffix;\n        }\n        return \"\";\n    }\n\n    public static void main(String[] args) {\n        var tests = List.of(\n            List.of(\"baabababc\", \"baabc\", \"bbbabc\"),\n            List.of(\"baabababc\", \"baabc\", \"bbbazc\"),\n            List.of(\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"),\n            List.of(\"longest\", \"common\", \"suffix\"),\n            List.of(\"suffix\"),\n            List.of(\"\")\n        );\n        for (List<String> test : tests) {\n            System.out.printf(\"%s -> `%s`\\n\", test, lcs(test));\n        }\n    }\n}\n"}
{"id": 404456, "name": "AVL tree", "source": "Translate Haskell to Java: data Tree a\n  = Leaf\n  | Node\n      Int\n      (Tree a)\n      a\n      (Tree a)\n  deriving (Show, Eq)\n \nfoldTree :: Ord a => [a] -> Tree a\nfoldTree = foldr insert Leaf\n \nheight :: Tree a -> Int\nheight Leaf = -1\nheight (Node h _ _ _) = h\n \ndepth :: Tree a -> Tree a -> Int\ndepth a b = succ (max (height a) (height b))\n \ninsert :: Ord a => a -> Tree a -> Tree a\ninsert v Leaf = Node 1 Leaf v Leaf\ninsert v t@(Node n left v_ right)\n  | v_ < v = rotate $ Node n left v_ (insert v right)\n  | v_ > v = rotate $ Node n (insert v left) v_ right\n  | otherwise = t\n \nmax_ :: Ord a => Tree a -> Maybe a\nmax_ Leaf = Nothing\nmax_ (Node _ _ v right) =\n  case right of\n    Leaf -> Just v\n    _ -> max_ right\n \ndelete :: Ord a => a -> Tree a -> Tree a\ndelete _ Leaf = Leaf\ndelete x (Node h left v right)\n  | x == v =\n    maybe left (rotate . (Node h left <*> (`delete` right))) (max_ right)\n  | x > v = rotate $ Node h left v (delete x right)\n  | x < v = rotate $ Node h (delete x left) v right\n \nrotate :: Tree a -> Tree a\nrotate Leaf = Leaf\nrotate (Node h (Node lh ll lv lr) v r)\n  \n  | lh - height r > 1 && height ll - height lr > 0 =\n    Node lh ll lv (Node (depth r lr) lr v r)\nrotate (Node h l v (Node rh rl rv rr))\n  \n  | rh - height l > 1 && height rr - height rl > 0 =\n    Node rh (Node (depth l rl) l v rl) rv rr\nrotate (Node h (Node lh ll lv (Node rh rl rv rr)) v r)\n  \n  | lh - height r > 1 =\n    Node h (Node (rh + 1) (Node (lh - 1) ll lv rl) rv rr) v r\nrotate (Node h l v (Node rh (Node lh ll lv lr) rv rr))\n  \n  | rh - height l > 1 =\n    Node h l v (Node (lh + 1) ll lv (Node (rh - 1) lr rv rr))\nrotate (Node h l v r) =\n  \n  let (l_, r_) = (rotate l, rotate r)\n   in Node (depth l_ r_) l_ v r_\n \ndraw :: Show a => Tree a -> String\ndraw t = '\\n' : draw_ t 0 <> \"\\n\"\n  where\n    draw_ Leaf _ = []\n    draw_ (Node h l v r) d = draw_ r (d + 1) <> node <> draw_ l (d + 1)\n      where\n        node = padding d <> show (v, h) <> \"\\n\"\n        padding n = replicate (n * 4) ' '\n \nmain :: IO ()\nmain = putStr $ draw $ foldTree [1 .. 31]\n", "target": "public class AVLtree {\n\n    private Node root;\n\n    private static class Node {\n        private int key;\n        private int balance;\n        private int height;\n        private Node left;\n        private Node right;\n        private Node parent;\n\n        Node(int key, Node parent) {\n            this.key = key;\n            this.parent = parent;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null) {\n            root = new Node(key, null);\n            return true;\n        }\n\n        Node n = root;\n        while (true) {\n            if (n.key == key)\n                return false;\n\n            Node parent = n;\n\n            boolean goLeft = n.key > key;\n            n = goLeft ? n.left : n.right;\n\n            if (n == null) {\n                if (goLeft) {\n                    parent.left = new Node(key, parent);\n                } else {\n                    parent.right = new Node(key, parent);\n                }\n                rebalance(parent);\n                break;\n            }\n        }\n        return true;\n    }\n\n    private void delete(Node node) {\n        if (node.left == null && node.right == null) {\n            if (node.parent == null) {\n                root = null;\n            } else {\n                Node parent = node.parent;\n                if (parent.left == node) {\n                    parent.left = null;\n                } else {\n                    parent.right = null;\n                }\n                rebalance(parent);\n            }\n            return;\n        }\n\n        if (node.left != null) {\n            Node child = node.left;\n            while (child.right != null) child = child.right;\n            node.key = child.key;\n            delete(child);\n        } else {\n            Node child = node.right;\n            while (child.left != null) child = child.left;\n            node.key = child.key;\n            delete(child);\n        }\n    }\n\n    public void delete(int delKey) {\n        if (root == null)\n            return;\n\n        Node child = root;\n        while (child != null) {\n            Node node = child;\n            child = delKey >= node.key ? node.right : node.left;\n            if (delKey == node.key) {\n                delete(node);\n                return;\n            }\n        }\n    }\n\n    private void rebalance(Node n) {\n        setBalance(n);\n\n        if (n.balance == -2) {\n            if (height(n.left.left) >= height(n.left.right))\n                n = rotateRight(n);\n            else\n                n = rotateLeftThenRight(n);\n\n        } else if (n.balance == 2) {\n            if (height(n.right.right) >= height(n.right.left))\n                n = rotateLeft(n);\n            else\n                n = rotateRightThenLeft(n);\n        }\n\n        if (n.parent != null) {\n            rebalance(n.parent);\n        } else {\n            root = n;\n        }\n    }\n\n    private Node rotateLeft(Node a) {\n\n        Node b = a.right;\n        b.parent = a.parent;\n\n        a.right = b.left;\n\n        if (a.right != null)\n            a.right.parent = a;\n\n        b.left = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateRight(Node a) {\n\n        Node b = a.left;\n        b.parent = a.parent;\n\n        a.left = b.right;\n\n        if (a.left != null)\n            a.left.parent = a;\n\n        b.right = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateLeftThenRight(Node n) {\n        n.left = rotateLeft(n.left);\n        return rotateRight(n);\n    }\n\n    private Node rotateRightThenLeft(Node n) {\n        n.right = rotateRight(n.right);\n        return rotateLeft(n);\n    }\n\n    private int height(Node n) {\n        if (n == null)\n            return -1;\n        return n.height;\n    }\n\n    private void setBalance(Node... nodes) {\n        for (Node n : nodes) {\n            reheight(n);\n            n.balance = height(n.right) - height(n.left);\n        }\n    }\n\n    public void printBalance() {\n        printBalance(root);\n    }\n\n    private void printBalance(Node n) {\n        if (n != null) {\n            printBalance(n.left);\n            System.out.printf(\"%s \", n.balance);\n            printBalance(n.right);\n        }\n    }\n\n    private void reheight(Node node) {\n        if (node != null) {\n            node.height = 1 + Math.max(height(node.left), height(node.right));\n        }\n    }\n\n    public static void main(String[] args) {\n        AVLtree tree = new AVLtree();\n\n        System.out.println(\"Inserting values 1 to 10\");\n        for (int i = 1; i < 10; i++)\n            tree.insert(i);\n\n        System.out.print(\"Printing balance: \");\n        tree.printBalance();\n    }\n}\n"}
{"id": 404457, "name": "AVL tree", "source": "Translate Haskell to Java: data Tree a\n  = Leaf\n  | Node\n      Int\n      (Tree a)\n      a\n      (Tree a)\n  deriving (Show, Eq)\n \nfoldTree :: Ord a => [a] -> Tree a\nfoldTree = foldr insert Leaf\n \nheight :: Tree a -> Int\nheight Leaf = -1\nheight (Node h _ _ _) = h\n \ndepth :: Tree a -> Tree a -> Int\ndepth a b = succ (max (height a) (height b))\n \ninsert :: Ord a => a -> Tree a -> Tree a\ninsert v Leaf = Node 1 Leaf v Leaf\ninsert v t@(Node n left v_ right)\n  | v_ < v = rotate $ Node n left v_ (insert v right)\n  | v_ > v = rotate $ Node n (insert v left) v_ right\n  | otherwise = t\n \nmax_ :: Ord a => Tree a -> Maybe a\nmax_ Leaf = Nothing\nmax_ (Node _ _ v right) =\n  case right of\n    Leaf -> Just v\n    _ -> max_ right\n \ndelete :: Ord a => a -> Tree a -> Tree a\ndelete _ Leaf = Leaf\ndelete x (Node h left v right)\n  | x == v =\n    maybe left (rotate . (Node h left <*> (`delete` right))) (max_ right)\n  | x > v = rotate $ Node h left v (delete x right)\n  | x < v = rotate $ Node h (delete x left) v right\n \nrotate :: Tree a -> Tree a\nrotate Leaf = Leaf\nrotate (Node h (Node lh ll lv lr) v r)\n  \n  | lh - height r > 1 && height ll - height lr > 0 =\n    Node lh ll lv (Node (depth r lr) lr v r)\nrotate (Node h l v (Node rh rl rv rr))\n  \n  | rh - height l > 1 && height rr - height rl > 0 =\n    Node rh (Node (depth l rl) l v rl) rv rr\nrotate (Node h (Node lh ll lv (Node rh rl rv rr)) v r)\n  \n  | lh - height r > 1 =\n    Node h (Node (rh + 1) (Node (lh - 1) ll lv rl) rv rr) v r\nrotate (Node h l v (Node rh (Node lh ll lv lr) rv rr))\n  \n  | rh - height l > 1 =\n    Node h l v (Node (lh + 1) ll lv (Node (rh - 1) lr rv rr))\nrotate (Node h l v r) =\n  \n  let (l_, r_) = (rotate l, rotate r)\n   in Node (depth l_ r_) l_ v r_\n \ndraw :: Show a => Tree a -> String\ndraw t = '\\n' : draw_ t 0 <> \"\\n\"\n  where\n    draw_ Leaf _ = []\n    draw_ (Node h l v r) d = draw_ r (d + 1) <> node <> draw_ l (d + 1)\n      where\n        node = padding d <> show (v, h) <> \"\\n\"\n        padding n = replicate (n * 4) ' '\n \nmain :: IO ()\nmain = putStr $ draw $ foldTree [1 .. 31]\n", "target": "public class AVLtree {\n\n    private Node root;\n\n    private static class Node {\n        private int key;\n        private int balance;\n        private int height;\n        private Node left;\n        private Node right;\n        private Node parent;\n\n        Node(int key, Node parent) {\n            this.key = key;\n            this.parent = parent;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null) {\n            root = new Node(key, null);\n            return true;\n        }\n\n        Node n = root;\n        while (true) {\n            if (n.key == key)\n                return false;\n\n            Node parent = n;\n\n            boolean goLeft = n.key > key;\n            n = goLeft ? n.left : n.right;\n\n            if (n == null) {\n                if (goLeft) {\n                    parent.left = new Node(key, parent);\n                } else {\n                    parent.right = new Node(key, parent);\n                }\n                rebalance(parent);\n                break;\n            }\n        }\n        return true;\n    }\n\n    private void delete(Node node) {\n        if (node.left == null && node.right == null) {\n            if (node.parent == null) {\n                root = null;\n            } else {\n                Node parent = node.parent;\n                if (parent.left == node) {\n                    parent.left = null;\n                } else {\n                    parent.right = null;\n                }\n                rebalance(parent);\n            }\n            return;\n        }\n\n        if (node.left != null) {\n            Node child = node.left;\n            while (child.right != null) child = child.right;\n            node.key = child.key;\n            delete(child);\n        } else {\n            Node child = node.right;\n            while (child.left != null) child = child.left;\n            node.key = child.key;\n            delete(child);\n        }\n    }\n\n    public void delete(int delKey) {\n        if (root == null)\n            return;\n\n        Node child = root;\n        while (child != null) {\n            Node node = child;\n            child = delKey >= node.key ? node.right : node.left;\n            if (delKey == node.key) {\n                delete(node);\n                return;\n            }\n        }\n    }\n\n    private void rebalance(Node n) {\n        setBalance(n);\n\n        if (n.balance == -2) {\n            if (height(n.left.left) >= height(n.left.right))\n                n = rotateRight(n);\n            else\n                n = rotateLeftThenRight(n);\n\n        } else if (n.balance == 2) {\n            if (height(n.right.right) >= height(n.right.left))\n                n = rotateLeft(n);\n            else\n                n = rotateRightThenLeft(n);\n        }\n\n        if (n.parent != null) {\n            rebalance(n.parent);\n        } else {\n            root = n;\n        }\n    }\n\n    private Node rotateLeft(Node a) {\n\n        Node b = a.right;\n        b.parent = a.parent;\n\n        a.right = b.left;\n\n        if (a.right != null)\n            a.right.parent = a;\n\n        b.left = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateRight(Node a) {\n\n        Node b = a.left;\n        b.parent = a.parent;\n\n        a.left = b.right;\n\n        if (a.left != null)\n            a.left.parent = a;\n\n        b.right = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateLeftThenRight(Node n) {\n        n.left = rotateLeft(n.left);\n        return rotateRight(n);\n    }\n\n    private Node rotateRightThenLeft(Node n) {\n        n.right = rotateRight(n.right);\n        return rotateLeft(n);\n    }\n\n    private int height(Node n) {\n        if (n == null)\n            return -1;\n        return n.height;\n    }\n\n    private void setBalance(Node... nodes) {\n        for (Node n : nodes) {\n            reheight(n);\n            n.balance = height(n.right) - height(n.left);\n        }\n    }\n\n    public void printBalance() {\n        printBalance(root);\n    }\n\n    private void printBalance(Node n) {\n        if (n != null) {\n            printBalance(n.left);\n            System.out.printf(\"%s \", n.balance);\n            printBalance(n.right);\n        }\n    }\n\n    private void reheight(Node node) {\n        if (node != null) {\n            node.height = 1 + Math.max(height(node.left), height(node.right));\n        }\n    }\n\n    public static void main(String[] args) {\n        AVLtree tree = new AVLtree();\n\n        System.out.println(\"Inserting values 1 to 10\");\n        for (int i = 1; i < 10; i++)\n            tree.insert(i);\n\n        System.out.print(\"Printing balance: \");\n        tree.printBalance();\n    }\n}\n"}
{"id": 404458, "name": "Here document", "source": "Translate Haskell to Java: main :: IO ()\nmain = do\n\n\n  putStrLn \"Hello\\\n            \\ World!\\n\"\n\n\n  putStrLn $ unwords [\"This\", \"is\", \"an\", \"example\", \"text!\\n\"]\n\n\n  putStrLn $ unlines [\n             unwords [\"This\", \"is\", \"the\", \"first\" , \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"second\", \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"third\" , \"line.\"]\n           ]\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 404459, "name": "Here document", "source": "Translate Haskell to Java: main :: IO ()\nmain = do\n\n\n  putStrLn \"Hello\\\n            \\ World!\\n\"\n\n\n  putStrLn $ unwords [\"This\", \"is\", \"an\", \"example\", \"text!\\n\"]\n\n\n  putStrLn $ unlines [\n             unwords [\"This\", \"is\", \"the\", \"first\" , \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"second\", \"line.\"]\n           , unwords [\"This\", \"is\", \"the\", \"third\" , \"line.\"]\n           ]\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 404460, "name": "2048", "source": "Translate Haskell to Java: import System.IO\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Random\nimport Data.Random.Distribution.Categorical\nimport System.Console.ANSI\nimport Control.Lens\n\n\n\n\nprob4 :: Double\nprob4 = 0.1\n\ntype Position = [[Int]]\n\ncombine, shift :: [Int]->[Int]\ncombine (x:y:l) | x==y = (2*x) : combine l\ncombine (x:l) = x : combine l\ncombine [] = []\n\nshift l = take (length l) $ combine (filter (>0) l) ++ [0,0..]\n\nreflect :: [[a]] ->[[a]]\nreflect = map reverse\n\ntype Move = Position -> Position\n\nleft, right, up, down :: Move\nleft = map shift\nright = reflect . left . reflect\nup = transpose . left . transpose\ndown = transpose . right . transpose\n\nprogress :: Eq a => (a -> a) -> a -> Maybe a\nprogress f pos = if pos==next_pos then Nothing else Just next_pos where next_pos= f pos\n\nlost, win:: Position -> Bool\nlost pos = all isNothing [progress move pos| move<-[left,right,up,down] ]\n\nwin = any $ any (>=2048)\n\ngo :: Position -> Maybe Move -> Maybe Position\ngo pos move = move >>= flip progress pos\n\n\n\n\n\nindicesOf :: [a] -> [ReifiedTraversal' [a] a]\nindicesOf l = [ Traversal $ ix i | i <- [0..length l - 1] ]\n\nindices2Of :: [[a]] -> [ReifiedTraversal' [[a]] a]\nindices2Of ls = [ Traversal $ i.j | Traversal i <- indicesOf ls, let Just l = ls ^? i, Traversal j <- indicesOf l]\n\nadd2or4 ::  Position -> RVar Position\nadd2or4 pos = do\n  xy <-  randomElement [ xy | Traversal xy <- indices2Of pos, pos ^? xy == Just 0 ]\n  a <- categorical [(1-prob4, 2), (prob4, 4) ]\n  return $  pos & xy .~ a\n\n\n\nplay :: Position -> IO ()\nplay pos = do\n   c <- getChar\n   case go pos $ lookup c [('D',left),('C',right),('A',up),('B',down)] of\n      Nothing -> play pos\n      Just pos1 -> do\n         pos2 <- sample $ add2or4 pos1\n         draw pos2\n         when (win pos2 && not (win pos)) $ putStrLn $ \"You win! You may keep going.\"\n         if lost pos2 then putStrLn \"You lost!\"\n            else play pos2\n\nmain :: IO ()\nmain = do\n  pos <- sample $ add2or4 $ replicate 4 (replicate 4 0)\n  draw pos\n  play pos\n\n\n\ncolors =\n [(0,\"\\ESC[38;5;234;48;5;250m     \")\n ,(2,\"\\ESC[38;5;234;48;5;255m  2  \")\n ,(4,\"\\ESC[38;5;234;48;5;230m  4  \")\n ,(8,\"\\ESC[38;5;15;48;5;208m  8  \")\n ,(16,\"\\ESC[38;5;15;48;5;209m  16 \")\n ,(32,\"\\ESC[38;5;15;48;5;203m  32 \")\n ,(64,\"\\ESC[38;5;15;48;5;9m  64 \")\n ,(128,\"\\ESC[38;5;15;48;5;228m 128 \")\n ,(256,\"\\ESC[38;5;15;48;5;227m 256 \")\n ,(512,\"\\ESC[38;5;15;48;5;226m 512 \")\n ,(1024,\"\\ESC[38;5;15;48;5;221m 1024\")\n ,(2048,\"\\ESC[38;5;15;48;5;220m 2048\")\n ,(4096,\"\\ESC[38;5;15;48;5;0m 4096\")\n ,(8192,\"\\ESC[38;5;15;48;5;0m 8192\")\n ,(16384,\"\\ESC[38;5;15;48;5;0m16384\")\n ,(32768,\"\\ESC[38;5;15;48;5;0m32768\")\n ,(65536,\"\\ESC[38;5;15;48;5;0m65536\")\n ,(131072,\"\\ESC[38;5;15;48;5;90m131072\")\n ]\n\nshowTile x = fromJust (lookup x colors) ++ \"\\ESC[B\\^H\\^H\\^H\\^H\\^H     \\ESC[A\\ESC[C\"\n\ndraw :: Position -> IO ()\ndraw pos = do\n  setSGR [Reset]\n  clearScreen\n  hideCursor\n  hSetEcho stdin False\n  hSetBuffering stdin NoBuffering\n  setSGR [SetConsoleIntensity BoldIntensity]\n  putStr \"\\ESC[38;5;234;48;5;248m\" \n  setCursorPosition 0 0\n  replicateM_ 13 $ putStrLn $ replicate 26 ' '\n  setCursorPosition 1 1\n  putStrLn $ intercalate \"\\n\\n\\n\\ESC[C\" $ concatMap showTile `map` pos\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class Game2048 extends JPanel {\n\n    enum State {\n        start, won, running, over\n    }\n\n    final Color[] colorTable = {\n        new Color(0x701710), new Color(0xFFE4C3), new Color(0xfff4d3),\n        new Color(0xffdac3), new Color(0xe7b08e), new Color(0xe7bf8e),\n        new Color(0xffc4c3), new Color(0xE7948e), new Color(0xbe7e56),\n        new Color(0xbe5e56), new Color(0x9c3931), new Color(0x701710)};\n\n    final static int target = 2048;\n\n    static int highest;\n    static int score;\n\n    private Color gridColor = new Color(0xBBADA0);\n    private Color emptyColor = new Color(0xCDC1B4);\n    private Color startColor = new Color(0xFFEBCD);\n\n    private Random rand = new Random();\n\n    private Tile[][] tiles;\n    private int side = 4;\n    private State gamestate = State.start;\n    private boolean checkingAvailableMoves;\n\n    public Game2048() {\n        setPreferredSize(new Dimension(900, 700));\n        setBackground(new Color(0xFAF8EF));\n        setFont(new Font(\"SansSerif\", Font.BOLD, 48));\n        setFocusable(true);\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                startGame();\n                repaint();\n            }\n        });\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                switch (e.getKeyCode()) {\n                    case KeyEvent.VK_UP:\n                        moveUp();\n                        break;\n                    case KeyEvent.VK_DOWN:\n                        moveDown();\n                        break;\n                    case KeyEvent.VK_LEFT:\n                        moveLeft();\n                        break;\n                    case KeyEvent.VK_RIGHT:\n                        moveRight();\n                        break;\n                }\n                repaint();\n            }\n        });\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    void startGame() {\n        if (gamestate != State.running) {\n            score = 0;\n            highest = 0;\n            gamestate = State.running;\n            tiles = new Tile[side][side];\n            addRandomTile();\n            addRandomTile();\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(gridColor);\n        g.fillRoundRect(200, 100, 499, 499, 15, 15);\n\n        if (gamestate == State.running) {\n\n            for (int r = 0; r < side; r++) {\n                for (int c = 0; c < side; c++) {\n                    if (tiles[r][c] == null) {\n                        g.setColor(emptyColor);\n                        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\n                    } else {\n                        drawTile(g, r, c);\n                    }\n                }\n            }\n        } else {\n            g.setColor(startColor);\n            g.fillRoundRect(215, 115, 469, 469, 7, 7);\n\n            g.setColor(gridColor.darker());\n            g.setFont(new Font(\"SansSerif\", Font.BOLD, 128));\n            g.drawString(\"2048\", 310, 270);\n\n            g.setFont(new Font(\"SansSerif\", Font.BOLD, 20));\n\n            if (gamestate == State.won) {\n                g.drawString(\"you made it!\", 390, 350);\n\n            } else if (gamestate == State.over)\n                g.drawString(\"game over\", 400, 350);\n\n            g.setColor(gridColor);\n            g.drawString(\"click to start a new game\", 330, 470);\n            g.drawString(\"(use arrow keys to move tiles)\", 310, 530);\n        }\n    }\n\n    void drawTile(Graphics2D g, int r, int c) {\n        int value = tiles[r][c].getValue();\n\n        g.setColor(colorTable[(int) (Math.log(value) / Math.log(2)) + 1]);\n        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\n        String s = String.valueOf(value);\n\n        g.setColor(value < 128 ? colorTable[0] : colorTable[1]);\n\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int dec = fm.getDescent();\n\n        int x = 215 + c * 121 + (106 - fm.stringWidth(s)) / 2;\n        int y = 115 + r * 121 + (asc + (106 - (asc + dec)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n\n    private void addRandomTile() {\n        int pos = rand.nextInt(side * side);\n        int row, col;\n        do {\n            pos = (pos + 1) % (side * side);\n            row = pos / side;\n            col = pos % side;\n        } while (tiles[row][col] != null);\n\n        int val = rand.nextInt(10) == 0 ? 4 : 2;\n        tiles[row][col] = new Tile(val);\n    }\n\n    private boolean move(int countDownFrom, int yIncr, int xIncr) {\n        boolean moved = false;\n\n        for (int i = 0; i < side * side; i++) {\n            int j = Math.abs(countDownFrom - i);\n\n            int r = j / side;\n            int c = j % side;\n\n            if (tiles[r][c] == null)\n                continue;\n\n            int nextR = r + yIncr;\n            int nextC = c + xIncr;\n\n            while (nextR >= 0 && nextR < side && nextC >= 0 && nextC < side) {\n\n                Tile next = tiles[nextR][nextC];\n                Tile curr = tiles[r][c];\n\n                if (next == null) {\n\n                    if (checkingAvailableMoves)\n                        return true;\n\n                    tiles[nextR][nextC] = curr;\n                    tiles[r][c] = null;\n                    r = nextR;\n                    c = nextC;\n                    nextR += yIncr;\n                    nextC += xIncr;\n                    moved = true;\n\n                } else if (next.canMergeWith(curr)) {\n\n                    if (checkingAvailableMoves)\n                        return true;\n\n                    int value = next.mergeWith(curr);\n                    if (value > highest)\n                        highest = value;\n                    score += value;\n                    tiles[r][c] = null;\n                    moved = true;\n                    break;\n                } else\n                    break;\n            }\n        }\n\n        if (moved) {\n            if (highest < target) {\n                clearMerged();\n                addRandomTile();\n                if (!movesAvailable()) {\n                    gamestate = State.over;\n                }\n            } else if (highest == target)\n                gamestate = State.won;\n        }\n\n        return moved;\n    }\n\n    boolean moveUp() {\n        return move(0, -1, 0);\n    }\n\n    boolean moveDown() {\n        return move(side * side - 1, 1, 0);\n    }\n\n    boolean moveLeft() {\n        return move(0, 0, -1);\n    }\n\n    boolean moveRight() {\n        return move(side * side - 1, 0, 1);\n    }\n\n    void clearMerged() {\n        for (Tile[] row : tiles)\n            for (Tile tile : row)\n                if (tile != null)\n                    tile.setMerged(false);\n    }\n\n    boolean movesAvailable() {\n        checkingAvailableMoves = true;\n        boolean hasMoves = moveUp() || moveDown() || moveLeft() || moveRight();\n        checkingAvailableMoves = false;\n        return hasMoves;\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"2048\");\n            f.setResizable(true);\n            f.add(new Game2048(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n\nclass Tile {\n    private boolean merged;\n    private int value;\n\n    Tile(int val) {\n        value = val;\n    }\n\n    int getValue() {\n        return value;\n    }\n\n    void setMerged(boolean m) {\n        merged = m;\n    }\n\n    boolean canMergeWith(Tile other) {\n        return !merged && other != null && !other.merged && value == other.getValue();\n    }\n\n    int mergeWith(Tile other) {\n        if (canMergeWith(other)) {\n            value *= 2;\n            merged = true;\n            return value;\n        }\n        return -1;\n    }\n}\n"}
{"id": 404461, "name": "Pig the dice game_Player", "source": "Translate Haskell to Java: \n\nmodule Main where\n\nimport System.Random (randomRIO)\nimport Text.Printf   (printf)\n\ndata PInfo = PInfo { stack :: Int\n                   , score :: Int\n                   , rolls :: Int\n                   , next  :: Bool\n                   , won   :: Bool\n                   , name  :: String\n                   }\n\ntype Strategy = [PInfo] -> IO ()\n\nroll :: [PInfo] -> IO [PInfo]\nroll (pinfo:xs) = do\n  face <- randomRIO (1, 6)\n  case (face, face + stack pinfo + score pinfo) of\n      (1,_)            -> do\n          printf \"%s rolled 1 - stack is being resetted\\n\\n\" (name pinfo)\n          return $ pinfo { stack = 0, rolls = 0, next = True } : xs\n      (_,x) | x >= 100 -> do\n          printf \"%s rolled %i - stack is now %i + score %i => %i - I won!\\n\" (name pinfo) face (face + stack pinfo) (score pinfo) x\n          return $ pinfo { won = True } : xs\n      (_,_)            -> do\n          printf \"%s rolled %i - stack is now %i\\n\" (name pinfo) face (face + (stack pinfo))\n          return $ pinfo { stack = face + (stack pinfo), rolls = 1 + (rolls pinfo) } : xs\n\nhold :: [PInfo] -> IO [PInfo]\nhold (pinfo:xs) = do\n  let score' = stack pinfo + score pinfo\n  printf \"%s holds - score is now %i\\n\\n\" (name pinfo) score'\n  return $ pinfo { score = score', stack = 0, rolls = 0, next = True } : xs\n\n\nlogic :: Strategy -> Strategy -> Strategy\nlogic _      _      ((won -> True)    : xs) = return ()\nlogic _      strat2 (p@(next -> True) : xs) = strat2 $ xs ++ [p { next = False }]\nlogic strat1 _      (pinfo            : xs) = strat1 (pinfo : xs)\n\nstrat1 :: Strategy\nstrat1 (pinfo:xs)\n  | stack pinfo < 20 = roll (pinfo:xs) >>= logic strat1 strat2\n  | otherwise        = hold (pinfo:xs) >>= logic strat1 strat2\n\nstrat2 :: Strategy\nstrat2 (pinfo:xs)\n  | rolls pinfo < 4 = roll (pinfo:xs) >>= logic strat2 strat3\n  | otherwise       = hold (pinfo:xs) >>= logic strat2 strat3\n\nstrat3 :: Strategy\nstrat3 (pinfo:xs)\n  | rolls pinfo < 3 && score pinfo < 60 = roll (pinfo:xs) >>= logic strat3 strat4\n  | stack pinfo < 20                    = roll (pinfo:xs) >>= logic strat3 strat4\n  | otherwise                           = hold (pinfo:xs) >>= logic strat3 strat4\n\nstrat4 :: Strategy\nstrat4 (pinfo:xs) | score pinfo > 75 = roll (pinfo:xs) >>= logic strat4 strat1\nstrat4 (pinfo:xs) = do\n  chance <- randomRIO (0, 3) :: IO Int\n  case chance of\n      0  -> hold (pinfo:xs) >>= logic strat4 strat1\n      _  -> roll (pinfo:xs) >>= logic strat4 strat1\n\nmain :: IO ()\nmain = do\n  let pInfo = PInfo 0 0 0 False False \"\"\n      p1    = pInfo { name = \"Peter\"   }\n      p2    = pInfo { name = \"Mia\"     }\n      p3    = pInfo { name = \"Liz\"     }\n      p4    = pInfo { name = \"Stephen\" }\n  strat1 [p1, p2, p3, p4]\n", "target": "import java.util.Scanner;\n\npublic class Pigdice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint players = 0;\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tSystem.out.println(\"Hello, welcome to Pig Dice the game! How many players? \");\n\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\tif(nextInt > 0) {\n\t\t\t\t\tplayers = nextInt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"That wasn't an integer. Try again. \\n\");\n\t\t\t\tscan.next();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Alright, starting with \" + players + \" players. \\n\");\n\t\t\n\t\t\n\t\tplay(players, scan);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tpublic static void play(int group, Scanner scan) {\n\t\t\n\t\tfinal int STRATEGIES = 5;\n\t\t\n\t\t\n\t\tDice dice = new Dice();\n\t\t\n\t\t\n\t\tPlayer[] players = new Player[group];\n\t\tfor(int count = 0; count < group; count++) {\n\t\t\tplayers[count] = new Player(count);\n\t\t\tSystem.out.println(\"Player \" + players[count].getNumber() + \"  is alive! \");\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(\"Each strategy is numbered 0 - \" + (STRATEGIES - 1) + \". They are as follows: \");\n\t\tSystem.out.println(\">> Enter '0' for a human player. \");\n\t\tSystem.out.println(\">> Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.\");\n\t\tSystem.out.println(\">> Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold. \");\n\t\tSystem.out.println(\">> Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls. \");\n\t\tSystem.out.println(\">> Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll. \");\n\t\t\n\t\t\n\t\tfor(Player player : players) {\n\t\t\tSystem.out.println(\"\\nWhat strategy would you like player \" + player.getNumber() + \" to use? \");\n\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\t\tif (nextInt < Strategy.STRATEGIES.length) {\n\t\t\t\t\t\tplayer.setStrategy(Strategy.STRATEGIES[nextInt]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"That wasn't an option. Try again. \");\n\t\t\t\t\tscan.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint max = 0;\n\t\twhile(max < 100) {\n\t\t\t\n\t\t\t\n\t\t\tfor(Player player : players) {\n\t\t\t\tSystem.out.println(\">> Beginning Player \" + player.getNumber() + \"'s turn. \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setMax(max);\n\t\t\t\twhile(true) {\n\t\t\t\t\tMove choice = player.choose();\n\t\t\t\t\tif(choice == Move.ROLL) {\n\t\t\t\t\t\tint roll = dice.roll();\n\t\t\t\t\t\tSystem.out.println(\"   A \" + roll + \" was rolled. \");\n\t\t\t\t\t\tplayer.setTurnPoints(player.getTurnPoints() + roll);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tplayer.incIter();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(roll == 1) {\n\t\t\t\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"   The player has held. \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.addPoints(player.getTurnPoints());\n\t\t\t\tSystem.out.println(\"   Player \" + player.getNumber() + \"'s turn is now over. Their total is \" + player.getPoints() + \". \\n\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.resetIter();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max < player.getPoints()) {\n\t\t\t\t\tmax = player.getPoints();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max >= 100) {\n\t\t\t\t\tSystem.out.println(\"Player \" + player.getNumber() + \" wins with \" + max + \" points! End scores: \");\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(Player p : players) {\n\t\t\t\t\t\tSystem.out.println(\"Player \" + p.getNumber() + \" had \" + p.getPoints() + \" points. \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"}
{"id": 404462, "name": "Pig the dice game_Player", "source": "Translate Haskell to Java: \n\nmodule Main where\n\nimport System.Random (randomRIO)\nimport Text.Printf   (printf)\n\ndata PInfo = PInfo { stack :: Int\n                   , score :: Int\n                   , rolls :: Int\n                   , next  :: Bool\n                   , won   :: Bool\n                   , name  :: String\n                   }\n\ntype Strategy = [PInfo] -> IO ()\n\nroll :: [PInfo] -> IO [PInfo]\nroll (pinfo:xs) = do\n  face <- randomRIO (1, 6)\n  case (face, face + stack pinfo + score pinfo) of\n      (1,_)            -> do\n          printf \"%s rolled 1 - stack is being resetted\\n\\n\" (name pinfo)\n          return $ pinfo { stack = 0, rolls = 0, next = True } : xs\n      (_,x) | x >= 100 -> do\n          printf \"%s rolled %i - stack is now %i + score %i => %i - I won!\\n\" (name pinfo) face (face + stack pinfo) (score pinfo) x\n          return $ pinfo { won = True } : xs\n      (_,_)            -> do\n          printf \"%s rolled %i - stack is now %i\\n\" (name pinfo) face (face + (stack pinfo))\n          return $ pinfo { stack = face + (stack pinfo), rolls = 1 + (rolls pinfo) } : xs\n\nhold :: [PInfo] -> IO [PInfo]\nhold (pinfo:xs) = do\n  let score' = stack pinfo + score pinfo\n  printf \"%s holds - score is now %i\\n\\n\" (name pinfo) score'\n  return $ pinfo { score = score', stack = 0, rolls = 0, next = True } : xs\n\n\nlogic :: Strategy -> Strategy -> Strategy\nlogic _      _      ((won -> True)    : xs) = return ()\nlogic _      strat2 (p@(next -> True) : xs) = strat2 $ xs ++ [p { next = False }]\nlogic strat1 _      (pinfo            : xs) = strat1 (pinfo : xs)\n\nstrat1 :: Strategy\nstrat1 (pinfo:xs)\n  | stack pinfo < 20 = roll (pinfo:xs) >>= logic strat1 strat2\n  | otherwise        = hold (pinfo:xs) >>= logic strat1 strat2\n\nstrat2 :: Strategy\nstrat2 (pinfo:xs)\n  | rolls pinfo < 4 = roll (pinfo:xs) >>= logic strat2 strat3\n  | otherwise       = hold (pinfo:xs) >>= logic strat2 strat3\n\nstrat3 :: Strategy\nstrat3 (pinfo:xs)\n  | rolls pinfo < 3 && score pinfo < 60 = roll (pinfo:xs) >>= logic strat3 strat4\n  | stack pinfo < 20                    = roll (pinfo:xs) >>= logic strat3 strat4\n  | otherwise                           = hold (pinfo:xs) >>= logic strat3 strat4\n\nstrat4 :: Strategy\nstrat4 (pinfo:xs) | score pinfo > 75 = roll (pinfo:xs) >>= logic strat4 strat1\nstrat4 (pinfo:xs) = do\n  chance <- randomRIO (0, 3) :: IO Int\n  case chance of\n      0  -> hold (pinfo:xs) >>= logic strat4 strat1\n      _  -> roll (pinfo:xs) >>= logic strat4 strat1\n\nmain :: IO ()\nmain = do\n  let pInfo = PInfo 0 0 0 False False \"\"\n      p1    = pInfo { name = \"Peter\"   }\n      p2    = pInfo { name = \"Mia\"     }\n      p3    = pInfo { name = \"Liz\"     }\n      p4    = pInfo { name = \"Stephen\" }\n  strat1 [p1, p2, p3, p4]\n", "target": "import java.util.Scanner;\n\npublic class Pigdice {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint players = 0;\n\t\t\n\t\t\n\t\twhile(true) {\n\t\t\t\n\t\t\tSystem.out.println(\"Hello, welcome to Pig Dice the game! How many players? \");\n\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\tif(nextInt > 0) {\n\t\t\t\t\tplayers = nextInt;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(\"That wasn't an integer. Try again. \\n\");\n\t\t\t\tscan.next();\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Alright, starting with \" + players + \" players. \\n\");\n\t\t\n\t\t\n\t\tplay(players, scan);\n\t\t\n\t\tscan.close();\n\t}\n\t\n\tpublic static void play(int group, Scanner scan) {\n\t\t\n\t\tfinal int STRATEGIES = 5;\n\t\t\n\t\t\n\t\tDice dice = new Dice();\n\t\t\n\t\t\n\t\tPlayer[] players = new Player[group];\n\t\tfor(int count = 0; count < group; count++) {\n\t\t\tplayers[count] = new Player(count);\n\t\t\tSystem.out.println(\"Player \" + players[count].getNumber() + \"  is alive! \");\n\t\t}\n\t\t\n\t\t\n\t\tSystem.out.println(\"Each strategy is numbered 0 - \" + (STRATEGIES - 1) + \". They are as follows: \");\n\t\tSystem.out.println(\">> Enter '0' for a human player. \");\n\t\tSystem.out.println(\">> Strategy 1 is a basic strategy where the AI rolls until 20+ points and holds unless the current max is 75+.\");\n\t\tSystem.out.println(\">> Strategy 2 is a basic strategy where the AI, after 3 successful rolls, will randomly decide to roll or hold. \");\n\t\tSystem.out.println(\">> Strategy 3 is similar to strategy 2, except it's a little gutsier and will attempt 5 successful rolls. \");\n\t\tSystem.out.println(\">> Strategy 4 is like a mix between strategies 1 and 3. After turn points are >= 20 and while max points are still less than 75, it will randomly hold or roll. \");\n\t\t\n\t\t\n\t\tfor(Player player : players) {\n\t\t\tSystem.out.println(\"\\nWhat strategy would you like player \" + player.getNumber() + \" to use? \");\n\n\t\t\t\n\t\t\twhile(true) {\n\t\t\t\tif(scan.hasNextInt()) {\n\t\t\t\t\tint nextInt = scan.nextInt();\n\t\t\t\t\tif (nextInt < Strategy.STRATEGIES.length) {\n\t\t\t\t\t\tplayer.setStrategy(Strategy.STRATEGIES[nextInt]);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tSystem.out.println(\"That wasn't an option. Try again. \");\n\t\t\t\t\tscan.next();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tint max = 0;\n\t\twhile(max < 100) {\n\t\t\t\n\t\t\t\n\t\t\tfor(Player player : players) {\n\t\t\t\tSystem.out.println(\">> Beginning Player \" + player.getNumber() + \"'s turn. \");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.setMax(max);\n\t\t\t\twhile(true) {\n\t\t\t\t\tMove choice = player.choose();\n\t\t\t\t\tif(choice == Move.ROLL) {\n\t\t\t\t\t\tint roll = dice.roll();\n\t\t\t\t\t\tSystem.out.println(\"   A \" + roll + \" was rolled. \");\n\t\t\t\t\t\tplayer.setTurnPoints(player.getTurnPoints() + roll);\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tplayer.incIter();\n\t\t\t\t\t\t\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(roll == 1) {\n\t\t\t\t\t\t\tplayer.setTurnPoints(0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"   The player has held. \");\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.addPoints(player.getTurnPoints());\n\t\t\t\tSystem.out.println(\"   Player \" + player.getNumber() + \"'s turn is now over. Their total is \" + player.getPoints() + \". \\n\");\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tplayer.resetIter();\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max < player.getPoints()) {\n\t\t\t\t\tmax = player.getPoints();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tif(max >= 100) {\n\t\t\t\t\tSystem.out.println(\"Player \" + player.getNumber() + \" wins with \" + max + \" points! End scores: \");\n\t\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tfor(Player p : players) {\n\t\t\t\t\t\tSystem.out.println(\"Player \" + p.getNumber() + \" had \" + p.getPoints() + \" points. \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\t\n}\n"}
{"id": 404463, "name": "Maze solving", "source": "Translate Haskell to Java: #!/usr/bin/runhaskell\n\nimport Data.Maybe (fromMaybe)\n\n\naverage :: (Int, Int) -> (Int, Int) -> (Int, Int)\naverage (x, y) (x_, y_) = ((x + x_) `div` 2, (y + y_) `div` 2)\n\n\n\nnotBlocked :: [String] -> ((Int, Int), (Int, Int)) -> Bool\nnotBlocked maze (_, (x, y)) = ' ' == (maze !! y) !! x\n\n\n\n\n\nsubstitute :: [a] -> Int -> a -> [a]\nsubstitute orig pos el =\n  let (before, after) = splitAt pos orig\n  in before ++ [el] ++ tail after\n\n\ndraw :: [String] -> (Int, Int) -> [String]\ndraw maze (x, y) =\n  let row = maze !! y\n  in substitute maze y $ substitute row x '*'\n\n\n\n\ntryMoves :: [String]\n         -> (Int, Int)\n         -> [((Int, Int), (Int, Int))]\n         -> Maybe [String]\ntryMoves _ _ [] = Nothing\ntryMoves maze prevPos ((newPos, wallPos):more) =\n  case solve_ maze newPos prevPos of\n    Nothing -> tryMoves maze prevPos more\n    Just maze_ -> Just $ foldl draw maze_ [newPos, wallPos]\n\n\n\n\nsolve_ :: [String] -> (Int, Int) -> (Int, Int) -> Maybe [String]\nsolve_ maze (2, 1) _ = Just maze\nsolve_ maze pos@(x, y) prevPos =\n  let newPositions = [(x, y - 2), (x + 4, y), (x, y + 2), (x - 4, y)]\n      notPrev pos_ = pos_ /= prevPos\n      newPositions_ = filter notPrev newPositions\n      wallPositions = map (average pos) newPositions_\n      zipped = zip newPositions_ wallPositions\n      legalMoves = filter (notBlocked maze) zipped\n  in tryMoves maze pos legalMoves\n\n\n\nsolve :: [String] -> Maybe [String]\nsolve maze = solve_ (draw maze start) start (-1, -1)\n  where\n    startx = length (head maze) - 3\n    starty = length maze - 2\n    start = (startx, starty)\n\n\nmain =\n  let main_ = unlines . fromMaybe [\"can_t solve\"] . solve . lines\n  in interact main_\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class MazeSolver\n{\n    \n    private static String[] readLines (InputStream f) throws IOException\n    {\n        BufferedReader r =\n            new BufferedReader (new InputStreamReader (f, \"US-ASCII\"));\n        ArrayList<String> lines = new ArrayList<String>();\n        String line;\n        while ((line = r.readLine()) != null)\n            lines.add (line);\n        return lines.toArray(new String[0]);\n    }\n\n    \n    private static char[][] decimateHorizontally (String[] lines)\n    {\n        final int width = (lines[0].length() + 1) / 2;\n        char[][] c = new char[lines.length][width];\n        for (int i = 0  ;  i < lines.length  ;  i++)\n            for (int j = 0  ;  j < width  ;  j++)\n                c[i][j] = lines[i].charAt (j * 2);\n        return c;\n    }\n\n    \n    private static boolean solveMazeRecursively (char[][] maze,\n                                                 int x, int y, int d)\n    {\n        boolean ok = false;\n        for (int i = 0  ;  i < 4  &&  !ok  ;  i++)\n            if (i != d)\n                switch (i)\n                    {\n                        \n                    case 0:\n                        if (maze[y-1][x] == ' ')\n                            ok = solveMazeRecursively (maze, x, y - 2, 2);\n                        break;\n                    case 1:\n                        if (maze[y][x+1] == ' ')\n                            ok = solveMazeRecursively (maze, x + 2, y, 3);\n                        break;\n                    case 2:\n                        if (maze[y+1][x] == ' ')\n                            ok = solveMazeRecursively (maze, x, y + 2, 0);\n                        break;\n                    case 3:\n                        if (maze[y][x-1] == ' ')\n                            ok = solveMazeRecursively (maze, x - 2, y, 1);\n                        break;\n                    }\n        \n        if (x == 1  &&  y == 1)\n            ok = true;\n        \n        if (ok)\n            {\n                maze[y][x] = '*';\n                switch (d)\n                    {\n                    case 0:\n                        maze[y-1][x] = '*';\n                        break;\n                    case 1:\n                        maze[y][x+1] = '*';\n                        break;\n                    case 2:\n                        maze[y+1][x] = '*';\n                        break;\n                    case 3:\n                        maze[y][x-1] = '*';\n                        break;\n                    }\n            }\n        return ok;\n    }\n\n    \n    private static void solveMaze (char[][] maze)\n    {\n        solveMazeRecursively (maze, maze[0].length - 2, maze.length - 2, -1);\n    }\n\n    \n    private static String[] expandHorizontally (char[][] maze)\n    {\n        char[] tmp = new char[3];\n        String[] lines = new String[maze.length];\n        for (int i = 0  ;  i < maze.length  ;  i++)\n            {\n                StringBuilder sb = new StringBuilder(maze[i].length * 2);\n                for (int j = 0  ;  j < maze[i].length  ;  j++)\n                    if (j % 2 == 0)\n                        sb.append (maze[i][j]);\n                    else\n                        {\n                            tmp[0] = tmp[1] = tmp[2] = maze[i][j];\n                            if (tmp[1] == '*')\n                                tmp[0] = tmp[2] = ' ';\n                            sb.append (tmp);\n                        }\n                lines[i] = sb.toString();\n            }\n        return lines;\n    }\n\n    \n    public static void main (String[] args) throws IOException\n    {\n        InputStream f = (args.length > 0\n                         ?  new FileInputStream (args[0])\n                         :  System.in);\n        String[] lines = readLines (f);\n        char[][] maze = decimateHorizontally (lines);\n        solveMaze (maze);\n        String[] solvedLines = expandHorizontally (maze);\n        for (int i = 0  ;  i < solvedLines.length  ;  i++)\n            System.out.println (solvedLines[i]);\n    }\n}\n"}
{"id": 404464, "name": "Deming's funnel", "source": "Translate Haskell to Java: import Data.List (mapAccumL, genericLength)\nimport Text.Printf\n\nfunnel :: (Num a) => (a -> a -> a) -> [a] -> [a]\nfunnel rule = snd . mapAccumL (\\x dx -> (rule x dx, x + dx)) 0\n\nmean :: (Fractional a) => [a] -> a \nmean xs = sum xs / genericLength xs\n\nstddev :: (Floating a) => [a] -> a\nstddev xs = sqrt $ sum [(x-m)**2 | x <- xs] / genericLength xs where\n              m = mean xs\n\nexperiment :: String -> [Double] -> [Double] -> (Double -> Double -> Double) -> IO ()\nexperiment label dxs dys rule = do\n  let rxs = funnel rule dxs\n      rys = funnel rule dys\n  putStrLn label\n  printf \"Mean x, y   \u00a0: %7.4f, %7.4f\\n\" (mean rxs) (mean rys)\n  printf \"Std dev x, y\u00a0: %7.4f, %7.4f\\n\" (stddev rxs) (stddev rys)\n  putStrLn \"\"\n\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nmain :: IO ()\nmain = do\n  experiment \"Rule 1:\" dxs dys (\\_ _  -> 0)\n  experiment \"Rule 2:\" dxs dys (\\_ dz -> -dz)\n  experiment \"Rule 3:\" dxs dys (\\z dz -> -(z+dz))\n  experiment \"Rule 4:\" dxs dys (\\z dz -> z+dz)\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 404465, "name": "Deming's funnel", "source": "Translate Haskell to Java: import Data.List (mapAccumL, genericLength)\nimport Text.Printf\n\nfunnel :: (Num a) => (a -> a -> a) -> [a] -> [a]\nfunnel rule = snd . mapAccumL (\\x dx -> (rule x dx, x + dx)) 0\n\nmean :: (Fractional a) => [a] -> a \nmean xs = sum xs / genericLength xs\n\nstddev :: (Floating a) => [a] -> a\nstddev xs = sqrt $ sum [(x-m)**2 | x <- xs] / genericLength xs where\n              m = mean xs\n\nexperiment :: String -> [Double] -> [Double] -> (Double -> Double -> Double) -> IO ()\nexperiment label dxs dys rule = do\n  let rxs = funnel rule dxs\n      rys = funnel rule dys\n  putStrLn label\n  printf \"Mean x, y   \u00a0: %7.4f, %7.4f\\n\" (mean rxs) (mean rys)\n  printf \"Std dev x, y\u00a0: %7.4f, %7.4f\\n\" (stddev rxs) (stddev rys)\n  putStrLn \"\"\n\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nmain :: IO ()\nmain = do\n  experiment \"Rule 1:\" dxs dys (\\_ _  -> 0)\n  experiment \"Rule 2:\" dxs dys (\\_ dz -> -dz)\n  experiment \"Rule 3:\" dxs dys (\\z dz -> -(z+dz))\n  experiment \"Rule 4:\" dxs dys (\\z dz -> z+dz)\n", "target": "import static java.lang.Math.*;\nimport java.util.Arrays;\nimport java.util.function.BiFunction;\n\npublic class DemingsFunnel {\n\n    public static void main(String[] args) {\n        double[] dxs = {\n            -0.533, 0.270, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275,\n            1.251, -0.231, -0.401, 0.269, 0.491, 0.951, 1.150, 0.001,\n            -0.382, 0.161, 0.915, 2.080, -2.337, 0.034, -0.126, 0.014,\n            0.709, 0.129, -1.093, -0.483, -1.193, 0.020, -0.051, 0.047,\n            -0.095, 0.695, 0.340, -0.182, 0.287, 0.213, -0.423, -0.021,\n            -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315,\n            0.201, 0.034, 0.097, -0.170, 0.054, -0.553, -0.024, -0.181,\n            -0.700, -0.361, -0.789, 0.279, -0.174, -0.009, -0.323, -0.658,\n            0.348, -0.528, 0.881, 0.021, -0.853, 0.157, 0.648, 1.774,\n            -1.043, 0.051, 0.021, 0.247, -0.310, 0.171, 0.000, 0.106,\n            0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017,\n            0.281, -0.749, -0.149, -2.436, -0.909, 0.394, -0.113, -0.598,\n            0.443, -0.521, -0.799, 0.087};\n\n        double[] dys = {\n            0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395,\n            0.490, -0.682, -0.065, 0.242, -0.288, 0.658, 0.459, 0.000,\n            0.426, 0.205, -0.765, -2.188, -0.742, -0.010, 0.089, 0.208,\n            0.585, 0.633, -0.444, -0.351, -1.087, 0.199, 0.701, 0.096,\n            -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007,\n            0.009, 0.508, -0.790, 0.723, 0.881, -0.508, 0.393, -0.226,\n            0.710, 0.038, -0.217, 0.831, 0.480, 0.407, 0.447, -0.295,\n            1.126, 0.380, 0.549, -0.445, -0.046, 0.428, -0.074, 0.217,\n            -0.822, 0.491, 1.347, -0.141, 1.230, -0.044, 0.079, 0.219,\n            0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104,\n            -0.729, 0.650, -1.103, 0.154, -1.720, 0.051, -0.385, 0.477,\n            1.537, -0.901, 0.939, -0.411, 0.341, -0.411, 0.106, 0.224,\n            -0.947, -1.424, -0.542, -1.032};\n\n        experiment(\"Rule 1:\", dxs, dys, (z, dz) -> 0.0);\n        experiment(\"Rule 2:\", dxs, dys, (z, dz) -> -dz);\n        experiment(\"Rule 3:\", dxs, dys, (z, dz) -> -(z + dz));\n        experiment(\"Rule 4:\", dxs, dys, (z, dz) -> z + dz);\n    }\n\n    static void experiment(String label, double[] dxs, double[] dys,\n            BiFunction<Double, Double, Double> rule) {\n\n        double[] resx = funnel(dxs, rule);\n        double[] resy = funnel(dys, rule);\n        System.out.println(label);\n        System.out.printf(\"Mean x, y:   \u00a0%.4f,\u00a0%.4f%n\", mean(resx), mean(resy));\n        System.out.printf(\"Std dev x, y:\u00a0%.4f,\u00a0%.4f%n\", stdDev(resx), stdDev(resy));\n        System.out.println();\n    }\n\n    static double[] funnel(double[] input, BiFunction<Double, Double, Double> rule) {\n        double x = 0;\n        double[] result = new double[input.length];\n\n        for (int i = 0; i < input.length; i++) {\n            double rx = x + input[i];\n            x = rule.apply(x, input[i]);\n            result[i] = rx;\n        }\n        return result;\n    }\n\n    static double mean(double[] xs) {\n        return Arrays.stream(xs).sum() / xs.length;\n    }\n\n    static double stdDev(double[] xs) {\n        double m = mean(xs);\n        return sqrt(Arrays.stream(xs).map(x -> pow((x - m), 2)).sum() / xs.length);\n    }\n}\n"}
{"id": 404466, "name": "MD5_Implementation", "source": "Translate Haskell to Java: import Control.Monad (replicateM)\n\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Lazy.Char8 as BLC\nimport Data.Binary.Get\nimport Data.Binary.Put\nimport Data.Bits\n\nimport Data.Array (Array, listArray, (!))\nimport Data.List (foldl)\nimport Data.Word (Word32)\n\nimport Numeric (showHex)\n\n\n\ntype Fun = Word32 -> Word32 -> Word32 -> Word32\n\nfunF, funG, funH, funI :: Fun\nfunF x y z = (x .&. y) .|. (complement x .&. z)\nfunG x y z = (x .&. z) .|. (complement z .&. y)\nfunH x y z = x `xor` y `xor` z\nfunI x y z = y `xor` (complement z .|. x)\n\nidxF, idxG, idxH, idxI :: Int -> Int\nidxF i = i\nidxG i = (5 * i + 1) `mod` 16\nidxH i = (3 * i + 5) `mod` 16\nidxI i = 7 * i `mod` 16\n\n\n\nfunA :: Array Int Fun\nfunA = listArray (1,64) $ replicate 16 =<< [funF, funG, funH, funI]\n\nidxA :: Array Int Int\nidxA = listArray (1,64) $ zipWith ($) (replicate 16 =<< [idxF, idxG, idxH, idxI]) [0..63]\n\nrotA :: Array Int Int\nrotA = listArray (1,64) $ concat . replicate 4 =<<\n       [[7, 12, 17, 22], [5, 9, 14, 20], [4, 11, 16, 23], [6, 10, 15, 21]]\n\nsinA :: Array Int Word32\nsinA = listArray (1,64) $ map (floor . (*mult) . abs . sin) [1..64]\n    where mult = 2 ** 32 :: Double\n\n\n\n\n\nmain :: IO ()\nmain = mapM_ (putStrLn . md5sum . BLC.pack)\n        [ \"\" \n        , \"a\"\n        , \"abc\"\n        , \"message digest\"\n        , \"abcdefghijklmnopqrstuvwxyz\"\n        , \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n        , \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n        ]\n\n\nmd5sum :: BL.ByteString -> String\nmd5sum input =\n    let MD5 a b c d = getMD5 initial `runGet` input\n    in  foldr hex [] . BL.unpack . runPut $ mapM_ putWord32le [a,b,c,d]\n    where\n      initial = MD5 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476\n\n      hex x s | x < 16    = '0' : showHex x s \n              | otherwise =       showHex x s\n\n\ndata MD5 = MD5\n    { a ::  !Word32\n    , b ::  !Word32\n    , c ::  !Word32\n    , d ::  !Word32\n    }\n\n\ngetMD5 :: MD5 -> Get MD5\ngetMD5 md5 = do\n  chunk <- getLazyByteString 64\n  let len = BL.length chunk\n\n  if len == 64\n  then getMD5 $! md5 <+> chunk  \n\n  else do                       \n    bytes <- bytesRead\n    let fin   = runPut . putWord64le $ fromIntegral (bytes - 64 + len) * 8\n        pad n = chunk `BL.append` (0x80 `BL.cons` BL.replicate (n - 1) 0x00)\n\n    return $ if len >= 56\n        then md5 <+> pad (64 - len) <+> BL.replicate 56 0x00 `BL.append` fin\n        else md5 <+> pad (56 - len) `BL.append` fin\n\n\n(<+>) :: MD5 -> BL.ByteString -> MD5\ninfixl 5  <+>\nmd5@(MD5 a b c d) <+> bs =\n    let datA = listArray (0,15) $ replicateM 16 getWord32le `runGet` bs\n        MD5 a' b' c' d' = foldl' (md5round datA) md5 [1..64]\n    in MD5 (a + a') (b + b') (c + c') (d + d')\n\n\nmd5round :: Array Int Word32 -> MD5 -> Int -> MD5\nmd5round datA (MD5 a b c d) i =\n    let f  =  funA ! i\n        w  =  datA ! (idxA ! i)\n        a' =  b + (a + f b c d + w + sinA ! i) `rotateL` rotA ! i\n    in MD5 d a' b c\n", "target": "class MD5\n{\n\n  private static final int INIT_A = 0x67452301;\n  private static final int INIT_B = (int)0xEFCDAB89L;\n  private static final int INIT_C = (int)0x98BADCFEL;\n  private static final int INIT_D = 0x10325476;\n  \n  private static final int[] SHIFT_AMTS = {\n    7, 12, 17, 22,\n    5,  9, 14, 20,\n    4, 11, 16, 23,\n    6, 10, 15, 21\n  };\n  \n  private static final int[] TABLE_T = new int[64];\n  static\n  {\n    for (int i = 0; i < 64; i++)\n      TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));\n  }\n  \n  public static byte[] computeMD5(byte[] message)\n  {\n    int messageLenBytes = message.length;\n    int numBlocks = ((messageLenBytes + 8) >>> 6) + 1;\n    int totalLen = numBlocks << 6;\n    byte[] paddingBytes = new byte[totalLen - messageLenBytes];\n    paddingBytes[0] = (byte)0x80;\n    \n    long messageLenBits = (long)messageLenBytes << 3;\n    for (int i = 0; i < 8; i++)\n    {\n      paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits;\n      messageLenBits >>>= 8;\n    }\n    \n    int a = INIT_A;\n    int b = INIT_B;\n    int c = INIT_C;\n    int d = INIT_D;\n    int[] buffer = new int[16];\n    for (int i = 0; i < numBlocks; i ++)\n    {\n      int index = i << 6;\n      for (int j = 0; j < 64; j++, index++)\n        buffer[j >>> 2] = ((int)((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8);\n      int originalA = a;\n      int originalB = b;\n      int originalC = c;\n      int originalD = d;\n      for (int j = 0; j < 64; j++)\n      {\n        int div16 = j >>> 4;\n        int f = 0;\n        int bufferIndex = j;\n        switch (div16)\n        {\n          case 0:\n            f = (b & c) | (~b & d);\n            break;\n            \n          case 1:\n            f = (b & d) | (c & ~d);\n            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;\n            break;\n            \n          case 2:\n            f = b ^ c ^ d;\n            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;\n            break;\n            \n          case 3:\n            f = c ^ (b | ~d);\n            bufferIndex = (bufferIndex * 7) & 0x0F;\n            break;\n        }\n        int temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);\n        a = d;\n        d = c;\n        c = b;\n        b = temp;\n      }\n      \n      a += originalA;\n      b += originalB;\n      c += originalC;\n      d += originalD;\n    }\n    \n    byte[] md5 = new byte[16];\n    int count = 0;\n    for (int i = 0; i < 4; i++)\n    {\n      int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d));\n      for (int j = 0; j < 4; j++)\n      {\n        md5[count++] = (byte)n;\n        n >>>= 8;\n      }\n    }\n    return md5;\n  }\n  \n  public static String toHexString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      sb.append(String.format(\"%02X\", b[i] & 0xFF));\n    }\n    return sb.toString();\n  }\n\n  public static void main(String[] args)\n  {\n    String[] testStrings = { \"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };\n    for (String s : testStrings)\n      System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\");\n    return;\n  }\n  \n}\n"}
{"id": 404467, "name": "History variables", "source": "Translate Haskell to Java: import Data.IORef\n\nnewtype HVar a = HVar (IORef [a])\n\nnewHVar :: a -> IO (HVar a)\nnewHVar value = fmap HVar (newIORef [value])\n\nreadHVar :: HVar a -> IO a\nreadHVar (HVar ref) = fmap head (readIORef ref)\n\nwriteHVar :: a -> HVar a -> IO ()\nwriteHVar value (HVar ref) = modifyIORef ref (value:)\n\nundoHVar :: HVar a -> IO ()\nundoHVar (HVar ref) = do\n    (_ : history) <- readIORef ref\n    writeIORef ref history\n\ngetHistory :: HVar a -> IO [a]\ngetHistory (HVar ref) = readIORef ref\n\n\nmain :: IO ()\nmain = do\n    var <- newHVar 0\n    writeHVar 1 var\n    writeHVar 2 var\n    writeHVar 3 var\n    getHistory var >>= print\n    undoHVar var\n    undoHVar var\n    undoHVar var\n", "target": "public class HistoryVariable\n{\n    private Object value;\n\n    public HistoryVariable(Object v)\n    {\n        value = v;\n    }\n\n    public void update(Object v)\n    {\n        value = v;\n    }\n\n    public Object undo()\n    {\n        return value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return value.toString();\n    }\n\n    public void dispose()\n    {\n    }\n}\n"}
{"id": 404468, "name": "Function definition", "source": "Translate Haskell to Java: multiply x y = x * y\n", "target": "module MultiplyExample\n    {\n    static <Value extends Number> Value multiply(Value n1, Value n2)\n        {\n        return n1 * n2;\n        }\n\n    void run()\n        {\n        (Int i1, Int i2) = (7, 3);\n        Int i3 = multiply(i1, i2);\n        (Double d1, Double d2) = (2.7182818, 3.1415);\n        Double d3 = multiply(d1, d2);\n        @Inject Console console;\n        console.print($\"{i1}*{i2}={i3}, {d1}*{d2}={d3}\");\n        }\n    }\n"}
{"id": 404469, "name": "Successive prime differences", "source": "Translate Haskell to Java: \nimport Data.Numbers.Primes (primes)\n\ntype Result = [(String, [Int])]\n\noneMillionPrimes :: Integral p => [p]\noneMillionPrimes = takeWhile (<1_000_000) primes\n\ngetGroups :: [Int] -> Result\ngetGroups [] = []\ngetGroups ps@(n:x:y:z:xs) \n  | x-n == 6 && y-x == 4 && z-y == 2 = (\"(6 4 2)\", [n, x, y, z])            : getGroups (tail ps)\n  | x-n == 4 && y-x == 2             = (\"(4 2)\", [n, x, y])                 : getGroups (tail ps)\n  | x-n == 2 && y-x == 4             = (\"(2 4)\", [n, x, y]) : (\"2\", [n, x]) : getGroups (tail ps)\n  | x-n == 2 && y-x == 2             = (\"(2 2)\", [n, x, y]) : (\"2\", [n, x]) : getGroups (tail ps)\n  | x-n == 2                         = (\"2\", [n, x])                        : getGroups (tail ps)\n  | x-n == 1                         = (\"1\", [n, x])                        : getGroups (tail ps)\n  | otherwise                        = getGroups (tail ps)\ngetGroups (x:xs) = getGroups xs\n\ngroups :: Result\ngroups = getGroups oneMillionPrimes\n\nshowGroup :: String -> IO ()\nshowGroup group = do \n  putStrLn $ \"Differences of \" ++ group ++ \": \" ++ show (length r)\n  putStrLn $ \"First: \" ++ show (head r) ++ \"\\nLast:  \" ++ show (last r) ++ \"\\n\"\n  where r = foldr (\\(a, b) c -> if a == group then b : c else c) [] groups\n\nmain :: IO ()\nmain = showGroup \"2\" >> showGroup \"1\" >> showGroup \"(2 2)\" >> showGroup \"(2 4)\" >> showGroup \"(4 2)\" \n  >> showGroup \"(6 4 2)\"\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class SuccessivePrimeDifferences {\n    private static Integer[] sieve(int limit) {\n        List<Integer> primes = new ArrayList<>();\n        primes.add(2);\n        boolean[] c = new boolean[limit + 1];\n        \n        int p = 3;\n        while (true) {\n            int p2 = p * p;\n            if (p2 > limit) {\n                break;\n            }\n            for (int i = p2; i <= limit; i += 2 * p) {\n                c[i] = true;\n            }\n            do {\n                p += 2;\n            } while (c[p]);\n        }\n        for (int i = 3; i <= limit; i += 2) {\n            if (!c[i]) {\n                primes.add(i);\n            }\n        }\n\n        return primes.toArray(new Integer[0]);\n    }\n\n    private static List<List<Integer>> successivePrimes(Integer[] primes, Integer[] diffs) {\n        List<List<Integer>> results = new ArrayList<>();\n        int dl = diffs.length;\n        outer:\n        for (int i = 0; i < primes.length - dl; i++) {\n            Integer[] group = new Integer[dl + 1];\n            group[0] = primes[i];\n            for (int j = i; j < i + dl; ++j) {\n                if (primes[j + 1] - primes[j] != diffs[j - i]) {\n                    continue outer;\n                }\n                group[j - i + 1] = primes[j + 1];\n            }\n            results.add(Arrays.asList(group));\n        }\n        return results;\n    }\n\n    public static void main(String[] args) {\n        Integer[] primes = sieve(999999);\n        Integer[][] diffsList = {{2}, {1}, {2, 2}, {2, 4}, {4, 2}, {6, 4, 2}};\n        System.out.println(\"For primes less than 1,000,000:-\\n\");\n        for (Integer[] diffs : diffsList) {\n            System.out.printf(\"  For differences of %s ->\\n\", Arrays.toString(diffs));\n            List<List<Integer>> sp = successivePrimes(primes, diffs);\n            if (sp.isEmpty()) {\n                System.out.println(\"    No groups found\");\n                continue;\n            }\n            System.out.printf(\"    First group   = %s\\n\", Arrays.toString(sp.get(0).toArray(new Integer[0])));\n            System.out.printf(\"    Last group    = %s\\n\", Arrays.toString(sp.get(sp.size() - 1).toArray(new Integer[0])));\n            System.out.printf(\"    Number found  = %d\\n\", sp.size());\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 404470, "name": "Largest number divisible by its digits", "source": "Translate Haskell to Java: import Data.List (maximumBy, permutations, delete)\nimport Data.Ord (comparing)\nimport Data.Bool (bool)\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\nds :: [Int]\nds = [1, 2, 3, 4, 6, 7, 8, 9] \n\nlcmDigits :: Int\nlcmDigits = foldr1 lcm ds \n\nsevenDigits :: [[Int]]\nsevenDigits = (`delete` ds) <$> [1, 4, 7] \n\nmain :: IO ()\nmain =\n  print $\n  maximumBy\n  \n    (comparing (bool 0 <*> (0 ==) . (`rem` lcmDigits)))\n    (unDigits <$> concat (permutations <$> sevenDigits))\n", "target": "public class LynchBell {\n    \n    static String s = \"\";\n    \n    public static void main(String args[]) {\n        \n        int i = 98764321;\n        boolean isUnique = true;\n        boolean canBeDivided = true;\n        while (i>0) {\n            s = String.valueOf(i);\n            isUnique = uniqueDigits(i);\n            if (isUnique) {\n                \n                canBeDivided = testNumber(i);\n                if(canBeDivided) {\n                    System.out.println(\"Number found: \" + i);\n                    i=0;\n                }\n            }\n            i--;\n        }\n    }\n    \n    public static boolean uniqueDigits(int i) {\n        \n        for (int k = 0; k<s.length();k++) {\n            for(int l=k+1; l<s.length();l++) {\n                if(s.charAt(l)=='0' || s.charAt(l)=='5') {\n                    \n                    return false;\n                }\n                if(s.charAt(k) == s.charAt(l)) {\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    public static boolean testNumber(int i) {\n        \n        int j = 0;\n        boolean divisible = true;\n        \n        for (char ch: s.toCharArray()) {\n            j = Character.getNumericValue(ch);\n            divisible = ((i%j)==0);\n            if (!divisible) {\n                return false;\n            }\n        }       \n        return true;\n    }\n}\n"}
{"id": 404471, "name": "Largest number divisible by its digits", "source": "Translate Haskell to Java: import Data.List (maximumBy, permutations, delete)\nimport Data.Ord (comparing)\nimport Data.Bool (bool)\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\nds :: [Int]\nds = [1, 2, 3, 4, 6, 7, 8, 9] \n\nlcmDigits :: Int\nlcmDigits = foldr1 lcm ds \n\nsevenDigits :: [[Int]]\nsevenDigits = (`delete` ds) <$> [1, 4, 7] \n\nmain :: IO ()\nmain =\n  print $\n  maximumBy\n  \n    (comparing (bool 0 <*> (0 ==) . (`rem` lcmDigits)))\n    (unDigits <$> concat (permutations <$> sevenDigits))\n", "target": "public class LynchBell {\n    \n    static String s = \"\";\n    \n    public static void main(String args[]) {\n        \n        int i = 98764321;\n        boolean isUnique = true;\n        boolean canBeDivided = true;\n        while (i>0) {\n            s = String.valueOf(i);\n            isUnique = uniqueDigits(i);\n            if (isUnique) {\n                \n                canBeDivided = testNumber(i);\n                if(canBeDivided) {\n                    System.out.println(\"Number found: \" + i);\n                    i=0;\n                }\n            }\n            i--;\n        }\n    }\n    \n    public static boolean uniqueDigits(int i) {\n        \n        for (int k = 0; k<s.length();k++) {\n            for(int l=k+1; l<s.length();l++) {\n                if(s.charAt(l)=='0' || s.charAt(l)=='5') {\n                    \n                    return false;\n                }\n                if(s.charAt(k) == s.charAt(l)) {\n                    \n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    public static boolean testNumber(int i) {\n        \n        int j = 0;\n        boolean divisible = true;\n        \n        for (char ch: s.toCharArray()) {\n            j = Character.getNumericValue(ch);\n            divisible = ((i%j)==0);\n            if (!divisible) {\n                return false;\n            }\n        }       \n        return true;\n    }\n}\n"}
{"id": 404472, "name": "Jacobi symbol", "source": "Translate Haskell to Java: jacobi :: Integer -> Integer -> Integer\njacobi 0 1 = 1\njacobi 0 _ = 0\njacobi a n =\n  let a_mod_n = rem a n\n  in if even a_mod_n\n       then case rem n 8 of\n              1 -> jacobi (div a_mod_n 2) n\n              3 -> negate $ jacobi (div a_mod_n 2) n\n              5 -> negate $ jacobi (div a_mod_n 2) n\n              7 -> jacobi (div a_mod_n 2) n\n       else if rem a_mod_n 4 == 3 && rem n 4 == 3\n              then negate $ jacobi n a_mod_n\n              else jacobi n a_mod_n\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 404473, "name": "Jacobi symbol", "source": "Translate Haskell to Java: jacobi :: Integer -> Integer -> Integer\njacobi 0 1 = 1\njacobi 0 _ = 0\njacobi a n =\n  let a_mod_n = rem a n\n  in if even a_mod_n\n       then case rem n 8 of\n              1 -> jacobi (div a_mod_n 2) n\n              3 -> negate $ jacobi (div a_mod_n 2) n\n              5 -> negate $ jacobi (div a_mod_n 2) n\n              7 -> jacobi (div a_mod_n 2) n\n       else if rem a_mod_n 4 == 3 && rem n 4 == 3\n              then negate $ jacobi n a_mod_n\n              else jacobi n a_mod_n\n", "target": "public class JacobiSymbol {\n\n    public static void main(String[] args) {\n        int max = 30;\n        System.out.printf(\"n\\\\k \");\n        for ( int k = 1 ; k <= max ; k++ ) {\n            System.out.printf(\"%2d  \", k);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 1 ; n <= max ; n += 2 ) {\n            System.out.printf(\"%2d  \", n);\n            for ( int k = 1 ; k <= max ; k++ ) {\n                System.out.printf(\"%2d  \", jacobiSymbol(k, n));\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    \n    \n    private static int jacobiSymbol(int k, int n) {\n        if ( k < 0 || n % 2 == 0 ) {\n            throw new IllegalArgumentException(\"Invalid value. k = \" + k + \", n = \" + n);\n        }\n        k %= n;\n        int jacobi = 1;\n        while ( k > 0 ) {\n            while ( k % 2 == 0 ) {\n                k /= 2;\n                int r = n % 8;\n                if ( r == 3 || r == 5 ) {\n                    jacobi = -jacobi;\n                }\n            }\n            int temp = n;\n            n = k;\n            k = temp;\n            if ( k % 4 == 3 && n % 4 == 3 ) {\n                jacobi = -jacobi;\n            }\n            k %= n;\n        }\n        if ( n == 1 ) {\n            return jacobi;\n        }\n        return 0;\n    }\n\n}\n"}
{"id": 404474, "name": "Determinant and permanent", "source": "Translate Haskell to Java: sPermutations :: [a] -> [([a], Int)]\nsPermutations = flip zip (cycle [1, -1]) . foldl aux [[]]\n  where\n    aux items x = do\n      (f, item) <- zip (cycle [reverse, id]) items\n      f (insertEv x item)\n    insertEv x [] = [[x]]\n    insertEv x l@(y:ys) = (x : l) : ((y :) <$>) (insertEv x ys)\n\nelemPos :: [[a]] -> Int -> Int -> a\nelemPos ms i j = (ms !! i) !! j\n\nprod\n  :: Num a\n  => ([[a]] -> Int -> Int -> a) -> [[a]] -> [Int] -> a\nprod f ms = product . zipWith (f ms) [0 ..]\n\nsDeterminant\n  :: Num a\n  => ([[a]] -> Int -> Int -> a) -> [[a]] -> [([Int], Int)] -> a\nsDeterminant f ms = sum . fmap (\\(is, s) -> fromIntegral s * prod f ms is)\n\ndeterminant\n  :: Num a\n  => [[a]] -> a\ndeterminant ms =\n  sDeterminant elemPos ms . sPermutations $ [0 .. pred . length $ ms]\n\npermanent\n  :: Num a\n  => [[a]] -> a\npermanent ms =\n  sum . fmap (prod elemPos ms . fst) . sPermutations $ [0 .. pred . length $ ms]\n\n\nresult\n  :: (Num a, Show a)\n  => [[a]] -> String\nresult ms =\n  unlines\n    [ \"Matrix:\"\n    , unlines (show <$> ms)\n    , \"Determinant:\"\n    , show (determinant ms)\n    , \"Permanent:\"\n    , show (permanent ms)\n    ]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . result)\n    [ [[5]]\n    , [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    , [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    , [[4, 3], [2, 5]]\n    , [[2, 5], [4, 3]]\n    , [[4, 4], [2, 2]]\n    ]\n", "target": "import java.util.Scanner;\n\npublic class MatrixArithmetic {\n\tpublic static double[][] minor(double[][] a, int x, int y){\n\t\tint length = a.length-1;\n\t\tdouble[][] result = new double[length][length];\n\t\tfor(int i=0;i<length;i++) for(int j=0;j<length;j++){\n\t\t\tif(i<x && j<y){\n\t\t\t\tresult[i][j] = a[i][j];\n\t\t\t}else if(i>=x && j<y){\n\t\t\t\tresult[i][j] = a[i+1][j];\n\t\t\t}else if(i<x && j>=y){\n\t\t\t\tresult[i][j] = a[i][j+1];\n\t\t\t}else{ \n\t\t\t\tresult[i][j] = a[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static double det(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tint sign = 1;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += sign * a[0][i] * det(minor(a,0,i));\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static double perm(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += a[0][i] * perm(minor(a,0,i));\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint size = sc.nextInt();\n\t\tdouble[][] a = new double[size][size];\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<size;j++){\n\t\t\ta[i][j] = sc.nextDouble();\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(\"Determinant: \"+det(a));\n\t\tSystem.out.println(\"Permanent: \"+perm(a));\n\t}\n}\n"}
{"id": 404475, "name": "Sattolo cycle", "source": "Translate Haskell to Java: import Control.Monad ((>=>), (>>=), forM_)\nimport Control.Monad.Primitive\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as M\nimport System.Random.MWC\n\ntype MutVec m a = M.MVector (PrimState m) a\n\n\n\n\ncyclicPermM :: PrimMonad m => Gen (PrimState m) -> MutVec m a -> m (MutVec m a)\ncyclicPermM rand vec = forM_ [1..M.length vec-1] upd >> return vec\n  where upd i = uniformR (0, i-1) rand >>= M.swap vec i\n\n\ncyclicPerm :: PrimMonad m => Gen (PrimState m) -> V.Vector a -> m (V.Vector a)\ncyclicPerm rand = V.thaw >=> cyclicPermM rand >=> V.unsafeFreeze\n\n\n\ntest :: Show a => [a] -> IO ()\ntest xs = do\n  let orig = V.fromList xs\n  cyc <- withSystemRandom . asGenIO $ \\rand -> cyclicPerm rand orig\n  putStrLn $ \"original: \" ++ show orig\n  putStrLn $ \"  cycled: \" ++ show cyc\n\nmain :: IO ()\nmain = do\n  test ([] :: [()])\n  test [10 :: Int]\n  test [10, 20 :: Int]\n  test [10, 20, 30 :: Int]\n  test [11..22 :: Int]\n  \n  test \"abcdef\"\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 404476, "name": "Sattolo cycle", "source": "Translate Haskell to Java: import Control.Monad ((>=>), (>>=), forM_)\nimport Control.Monad.Primitive\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as M\nimport System.Random.MWC\n\ntype MutVec m a = M.MVector (PrimState m) a\n\n\n\n\ncyclicPermM :: PrimMonad m => Gen (PrimState m) -> MutVec m a -> m (MutVec m a)\ncyclicPermM rand vec = forM_ [1..M.length vec-1] upd >> return vec\n  where upd i = uniformR (0, i-1) rand >>= M.swap vec i\n\n\ncyclicPerm :: PrimMonad m => Gen (PrimState m) -> V.Vector a -> m (V.Vector a)\ncyclicPerm rand = V.thaw >=> cyclicPermM rand >=> V.unsafeFreeze\n\n\n\ntest :: Show a => [a] -> IO ()\ntest xs = do\n  let orig = V.fromList xs\n  cyc <- withSystemRandom . asGenIO $ \\rand -> cyclicPerm rand orig\n  putStrLn $ \"original: \" ++ show orig\n  putStrLn $ \"  cycled: \" ++ show cyc\n\nmain :: IO ()\nmain = do\n  test ([] :: [()])\n  test [10 :: Int]\n  test [10, 20 :: Int]\n  test [10, 20, 30 :: Int]\n  test [11..22 :: Int]\n  \n  test \"abcdef\"\n", "target": "private static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n"}
{"id": 404477, "name": "FTP", "source": "Translate Haskell to Java: module Main (main) where\n\nimport           Control.Exception (bracket)\nimport           Control.Monad (void)\nimport           Data.Foldable (for_)\nimport           Network.FTP.Client\n                    ( cwd\n                    , easyConnectFTP\n                    , getbinary\n                    , loginAnon\n                    , nlst\n                    , quit\n                    , setPassive\n                    )\n\nmain :: IO ()\nmain = bracket ((flip setPassive) True <$> easyConnectFTP \"ftp.kernel.org\") quit $ \\h -> do\n    \n    void $ loginAnon h\n\n    \n    void $ cwd h \"/pub/linux/kernel/Historic\"\n\n    \n    fileNames <- nlst h Nothing\n    for_ fileNames $ \\fileName ->\n        putStrLn fileName\n\n    \n    (fileData, _) <- getbinary h \"linux-0.01.tar.gz.sign\"\n    print fileData\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport org.apache.commons.net.ftp.FTP;\nimport org.apache.commons.net.ftp.FTPClient;\nimport org.apache.commons.net.ftp.FTPFile;\nimport org.apache.commons.net.ftp.FTPReply;\n\npublic class FTPconn {\n\n    public static void main(String[] args) throws IOException {\n        String server = \"ftp.hq.nasa.gov\";\n        int port = 21;\n        String user = \"anonymous\";\n        String pass = \"ftptest@example.com\";\n\n        OutputStream output = null;\n\n        FTPClient ftpClient = new FTPClient();\n        try {\n            ftpClient.connect(server, port);\n\n            serverReply(ftpClient);\n\n            int replyCode = ftpClient.getReplyCode();\n            if (!FTPReply.isPositiveCompletion(replyCode)) {\n                System.out.println(\"Failure. Server reply code: \" + replyCode);\n                return;\n            }\n\n            serverReply(ftpClient);\n\n            if (!ftpClient.login(user, pass)) {\n                System.out.println(\"Could not login to the server.\");\n                return;\n            }\n\n            String dir = \"pub/issoutreach/Living in Space Stories (MP3 Files)/\";\n            if (!ftpClient.changeWorkingDirectory(dir)) {\n                System.out.println(\"Change directory failed.\");\n                return;\n            }\n\n            ftpClient.enterLocalPassiveMode();\n\n            for (FTPFile file : ftpClient.listFiles())\n                System.out.println(file);\n\n            String filename = \"Can People go to Mars.mp3\";\n            output = new FileOutputStream(filename);\n\n            ftpClient.setFileType(FTP.BINARY_FILE_TYPE);\n            if (!ftpClient.retrieveFile(filename, output)) {\n                System.out.println(\"Retrieving file failed\");\n                return;\n            }\n\n            serverReply(ftpClient);\n\n            ftpClient.logout();\n\n        } finally {\n            if (output != null)\n                output.close();\n        }\n    }\n\n    private static void serverReply(FTPClient ftpClient) {\n        for (String reply : ftpClient.getReplyStrings()) {\n            System.out.println(reply);\n        }\n    }\n}\n"}
{"id": 404478, "name": "Brazilian numbers", "source": "Translate Haskell to Java: import Data.Numbers.Primes (primes)\n\nisBrazil :: Int -> Bool\nisBrazil n = 7 <= n && (even n || any (monoDigit n) [2 .. n - 2])\n\nmonoDigit :: Int -> Int -> Bool\nmonoDigit n b =\n  let (q, d) = quotRem n b\n  in d ==\n     snd\n       (until\n          (uncurry (flip ((||) . (d /=)) . (0 ==)))\n          ((`quotRem` b) . fst)\n          (q, d))\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\(s, xs) ->\n        (putStrLn . concat)\n          [ \"First 20 \"\n          , s\n          , \" Brazilians:\\n\"\n          , show . take 20 $ filter isBrazil xs\n          , \"\\n\"\n          ])\n    [([], [1 ..]), (\"odd\", [1,3 ..]), (\"prime\", primes)]\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 404479, "name": "Brazilian numbers", "source": "Translate Haskell to Java: import Data.Numbers.Primes (primes)\n\nisBrazil :: Int -> Bool\nisBrazil n = 7 <= n && (even n || any (monoDigit n) [2 .. n - 2])\n\nmonoDigit :: Int -> Int -> Bool\nmonoDigit n b =\n  let (q, d) = quotRem n b\n  in d ==\n     snd\n       (until\n          (uncurry (flip ((||) . (d /=)) . (0 ==)))\n          ((`quotRem` b) . fst)\n          (q, d))\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\(s, xs) ->\n        (putStrLn . concat)\n          [ \"First 20 \"\n          , s\n          , \" Brazilians:\\n\"\n          , show . take 20 $ filter isBrazil xs\n          , \"\\n\"\n          ])\n    [([], [1 ..]), (\"odd\", [1,3 ..]), (\"prime\", primes)]\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 404480, "name": "Create a file on magnetic tape", "source": "Translate Haskell to Java: module Main (main) where\n\nmain :: IO ()\nmain = writeFile \"/dev/tape\" \"Hello from Rosetta Code!\"\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Collections;\n\npublic class CreateFile {\n    public static void main(String[] args) throws IOException {\n        String os = System.getProperty(\"os.name\");\n        if (os.contains(\"Windows\")) {\n            Path path = Paths.get(\"tape.file\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        } else {\n            Path path = Paths.get(\"/dev/tape\");\n            Files.write(path, Collections.singletonList(\"Hello World!\"));\n        }\n    }\n}\n"}
{"id": 404481, "name": "Recaman's sequence", "source": "Translate Haskell to Java: recaman :: Int -> [Int]\nrecaman n = fst <$> reverse (go n)\n  where\n    go 0 = []\n    go 1 = [(0, 1)]\n    go x =\n        let xs@((r, i):_) = go (pred x)\n            back = r - i\n        in ( if 0 < back && not (any ((back ==) . fst) xs)\n               then back\n               else r + i\n           , succ i) :\n           xs\n\nmain :: IO ()\nmain = print $ recaman 15\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 404482, "name": "Recaman's sequence", "source": "Translate Haskell to Java: recaman :: Int -> [Int]\nrecaman n = fst <$> reverse (go n)\n  where\n    go 0 = []\n    go 1 = [(0, 1)]\n    go x =\n        let xs@((r, i):_) = go (pred x)\n            back = r - i\n        in ( if 0 < back && not (any ((back ==) . fst) xs)\n               then back\n               else r + i\n           , succ i) :\n           xs\n\nmain :: IO ()\nmain = print $ recaman 15\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\npublic class RecamanSequence {\n    public static void main(String[] args) {\n        List<Integer> a = new ArrayList<>();\n        a.add(0);\n\n        Set<Integer> used = new HashSet<>();\n        used.add(0);\n\n        Set<Integer> used1000 = new HashSet<>();\n        used1000.add(0);\n\n        boolean foundDup = false;\n        int n = 1;\n        while (n <= 15 || !foundDup || used1000.size() < 1001) {\n            int next = a.get(n - 1) - n;\n            if (next < 1 || used.contains(next)) {\n                next += 2 * n;\n            }\n            boolean alreadyUsed = used.contains(next);\n            a.add(next);\n            if (!alreadyUsed) {\n                used.add(next);\n                if (0 <= next && next <= 1000) {\n                    used1000.add(next);\n                }\n            }\n            if (n == 14) {\n                System.out.printf(\"The first 15 terms of the Recaman sequence are\u00a0: %s\\n\", a);\n            }\n            if (!foundDup && alreadyUsed) {\n                System.out.printf(\"The first duplicate term is a[%d] = %d\\n\", n, next);\n                foundDup = true;\n            }\n            if (used1000.size() == 1001) {\n                System.out.printf(\"Terms up to a[%d] are needed to generate 0 to 1000\\n\", n);\n            }\n            n++;\n        }\n    }\n}\n"}
{"id": 404483, "name": "Y combinator", "source": "Translate Haskell to Java: newtype Mu a = Roll\n  { unroll :: Mu a -> a }\n \nfix :: (a -> a) -> a\nfix = g <*> (Roll . g)\n  where\n    g = (. (>>= id) unroll)\n \n- this version is not in tail call position...\n\n\n\n\n\nfac :: Integer -> Integer\nfac =\n  (fix $ \\f n i -> if i <= 0 then n else f (i * n) (i - 1)) 1\n \n\n\n\n\n{\nfibs\u00a0:: () -> [Integer]\nfibs() =\n  fix $\n    (0\u00a0:) . (1\u00a0:) .\n      (fix\n        (\\f (x:xs) (y:ys) ->\n          case x + y of n -> n `seq` n\u00a0: f xs ys) <*> tail)\n\n\n\nfibs :: () -> [Integer]\nfibs() = 0 : 1 : fix fibs_ 0 1\n  where\n    fibs_ fnc f s =\n      case f + s of n -> n `seq` n : fnc s n\n \nmain :: IO ()\nmain =\n  mapM_\n    print\n    [ map fac [1 .. 20]\n    , take 20 $ fibs()\n    ]\n", "target": "import java.util.function.Function;\n\npublic interface YCombinator {\n  interface RecursiveFunction<F> extends Function<RecursiveFunction<F>, F> { }\n  public static <A,B> Function<A,B> Y(Function<Function<A,B>, Function<A,B>> f) {\n    RecursiveFunction<Function<A,B>> r = w -> f.apply(x -> w.apply(w).apply(x));\n    return r.apply(r);\n  }\n\n  public static void main(String... arguments) {\n    Function<Integer,Integer> fib = Y(f -> n ->\n      (n <= 2)\n        ? 1\n        : (f.apply(n - 1) + f.apply(n - 2))\n    );\n    Function<Integer,Integer> fac = Y(f -> n ->\n      (n <= 1)\n        ? 1\n        : (n * f.apply(n - 1))\n    );\n\n    System.out.println(\"fib(10) = \" + fib.apply(10));\n    System.out.println(\"fac(10) = \" + fac.apply(10));\n  }\n}\n"}
{"id": 404484, "name": "Total circles area", "source": "Translate Haskell to Java: data Circle = Circle { cx :: Double, cy :: Double, cr :: Double }\n\nisInside :: Double -> Double -> Circle -> Bool\nisInside x y c = (x - cx c) ^ 2 + (y - cy c) ^ 2 <= (cr c ^ 2)\n\nisInsideAny :: Double -> Double -> [Circle] -> Bool\nisInsideAny x y = any (isInside x y)\n\napproximatedArea :: [Circle] -> Int -> Double\napproximatedArea cs box_side = (fromIntegral count) * dx * dy\n  where\n    \n    x_min = minimum [cx c - cr c | c <- circles]\n    x_max = maximum [cx c + cr c | c <- circles]\n    y_min = minimum [cy c - cr c | c <- circles]\n    y_max = maximum [cy c + cr c | c <- circles]\n    dx = (x_max - x_min) / (fromIntegral box_side)\n    dy = (y_max - y_min) / (fromIntegral box_side)\n    count = length [0 | r <- [0 .. box_side - 1],\n                        c <- [0 .. box_side - 1],\n                        isInsideAny (posx c) (posy r) circles]\n    posy r = y_min + (fromIntegral r) * dy\n    posx c = x_min + (fromIntegral c) * dx\n\ncircles :: [Circle]\ncircles = [Circle ( 1.6417233788) ( 1.6121789534) 0.0848270516,\n           Circle (-1.4944608174) ( 1.2077959613) 1.1039549836,\n           Circle ( 0.6110294452) (-0.6907087527) 0.9089162485,\n           Circle ( 0.3844862411) ( 0.2923344616) 0.2375743054,\n           Circle (-0.2495892950) (-0.3832854473) 1.0845181219,\n           Circle ( 1.7813504266) ( 1.6178237031) 0.8162655711,\n           Circle (-0.1985249206) (-0.8343333301) 0.0538864941,\n           Circle (-1.7011985145) (-0.1263820964) 0.4776976918,\n           Circle (-0.4319462812) ( 1.4104420482) 0.7886291537,\n           Circle ( 0.2178372997) (-0.9499557344) 0.0357871187,\n           Circle (-0.6294854565) (-1.3078893852) 0.7653357688,\n           Circle ( 1.7952608455) ( 0.6281269104) 0.2727652452,\n           Circle ( 1.4168575317) ( 1.0683357171) 1.1016025378,\n           Circle ( 1.4637371396) ( 0.9463877418) 1.1846214562,\n           Circle (-0.5263668798) ( 1.7315156631) 1.4428514068,\n           Circle (-1.2197352481) ( 0.9144146579) 1.0727263474,\n           Circle (-0.1389358881) ( 0.1092805780) 0.7350208828,\n           Circle ( 1.5293954595) ( 0.0030278255) 1.2472867347,\n           Circle (-0.5258728625) ( 1.3782633069) 1.3495508831,\n           Circle (-0.1403562064) ( 0.2437382535) 1.3804956588,\n           Circle ( 0.8055826339) (-0.0482092025) 0.3327165165,\n           Circle (-0.6311979224) ( 0.7184578971) 0.2491045282,\n           Circle ( 1.4685857879) (-0.8347049536) 1.3670667538,\n           Circle (-0.6855727502) ( 1.6465021616) 1.0593087096,\n           Circle ( 0.0152957411) ( 0.0638919221) 0.9771215985]\n\nmain = putStrLn $ \"Approximated area: \" ++\n                  (show $ approximatedArea circles 5000)\n", "target": "public class CirclesTotalArea {\n\n    \n    \n    private static double distSq(double x1, double y1, double x2, double y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n    \n    private static boolean rectangleFullyInsideCircle(double[] rect, double[] circ) {\n        double r2 = circ[2] * circ[2];\n        \n        return distSq(rect[0], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) <= r2;\n    }\n    \n    private static boolean rectangleSurelyOutsideCircle(double[] rect, double[] circ) {\n        \n        if(rect[0] <= circ[0] && circ[0] <= rect[0] + rect[2] &&\n          rect[1] - rect[3] <= circ[1] && circ[1] <= rect[1]) { return false; }\n        \n        double r2 = circ[2] + Math.max(rect[2], rect[3]);\n        r2 = r2 * r2;\n        return distSq(rect[0], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) >= r2;\n    }\n    \n    private static boolean[] surelyOutside;\n    \n    private static double totalArea(double[] rect, double[][] circs, int d) {    \n        \n        int surelyOutsideCount = 0;\n        for(int i = 0; i < circs.length; i++) {\n            if(rectangleFullyInsideCircle(rect, circs[i])) { return rect[2] * rect[3]; }\n            if(rectangleSurelyOutsideCircle(rect, circs[i])) {\n                surelyOutside[i] = true;\n                surelyOutsideCount++;\n            }\n            else { surelyOutside[i] = false; }\n        }\n        \n        if(surelyOutsideCount == circs.length) { return 0; }\n        \n        if(d < 1) { \n            return rect[2] * rect[3] / 3;  \n        }\n        \n        if(surelyOutsideCount > 0) {\n            double[][] newCircs = new double[circs.length - surelyOutsideCount][3];\n            int loc = 0;\n            for(int i = 0; i < circs.length; i++) {\n                if(!surelyOutside[i]) { newCircs[loc++] = circs[i]; }\n            }\n            circs = newCircs;\n        }\n        \n        double w = rect[2] / 2; \n        double h = rect[3] / 2; \n        double[][] pieces = {\n            { rect[0], rect[1], w, h }, \n            { rect[0] + w, rect[1], w, h }, \n            { rect[0], rect[1] - h, w, h }, \n            { rect[0] + w, rect[1] - h, w, h } \n        };\n        double total = 0;\n        for(double[] piece: pieces) { total += totalArea(piece, circs, d - 1); }\n        return total;\n    }\n    \n    public static double totalArea(double[][] circs, int d) {\n        double maxx = Double.NEGATIVE_INFINITY;\n        double minx = Double.POSITIVE_INFINITY;\n        double maxy = Double.NEGATIVE_INFINITY;\n        double miny = Double.POSITIVE_INFINITY;\n        \n        for(double[] circ: circs) {\n            if(circ[0] + circ[2] > maxx) { maxx = circ[0] + circ[2]; }\n            if(circ[0] - circ[2] < minx) { minx = circ[0] - circ[2]; }\n            if(circ[1] + circ[2] > maxy) { maxy = circ[1] + circ[2]; }\n            if(circ[1] - circ[2] < miny) { miny = circ[1] - circ[2]; }\n        }\n        double[] rect = { minx, maxy, maxx - minx, maxy - miny };\n        surelyOutside = new boolean[circs.length];\n        return totalArea(rect, circs, d);\n    }\n    \n    public static void main(String[] args) {\n        double[][] circs = {\n            { 1.6417233788, 1.6121789534, 0.0848270516 },\n            {-1.4944608174, 1.2077959613, 1.1039549836 },\n            { 0.6110294452, -0.6907087527, 0.9089162485 },\n            { 0.3844862411, 0.2923344616, 0.2375743054 },\n            {-0.2495892950, -0.3832854473, 1.0845181219 },\n            {1.7813504266, 1.6178237031, 0.8162655711 },\n            {-0.1985249206, -0.8343333301, 0.0538864941 },\n            {-1.7011985145, -0.1263820964, 0.4776976918 },\n            {-0.4319462812, 1.4104420482, 0.7886291537 },\n            {0.2178372997, -0.9499557344, 0.0357871187 },\n            {-0.6294854565, -1.3078893852, 0.7653357688 },\n            {1.7952608455, 0.6281269104, 0.2727652452 },\n            {1.4168575317, 1.0683357171, 1.1016025378 },\n            {1.4637371396, 0.9463877418, 1.1846214562 },\n            {-0.5263668798, 1.7315156631, 1.4428514068 },\n            {-1.2197352481, 0.9144146579, 1.0727263474 },\n            {-0.1389358881, 0.1092805780, 0.7350208828 },\n            {1.5293954595, 0.0030278255, 1.2472867347 },\n            {-0.5258728625, 1.3782633069, 1.3495508831 },\n            {-0.1403562064, 0.2437382535, 1.3804956588 },\n            {0.8055826339, -0.0482092025, 0.3327165165 },\n            {-0.6311979224, 0.7184578971, 0.2491045282 },\n            {1.4685857879, -0.8347049536, 1.3670667538 },\n            {-0.6855727502, 1.6465021616, 1.0593087096 },\n            {0.0152957411, 0.0638919221, 0.9771215985 }\n        };\n        double ans = totalArea(circs, 24);\n        System.out.println(\"Approx. area is \" + ans);\n        System.out.println(\"Error is \" + Math.abs(21.56503660 - ans));\n    }\n}\n"}
{"id": 404485, "name": "Total circles area", "source": "Translate Haskell to Java: data Circle = Circle { cx :: Double, cy :: Double, cr :: Double }\n\nisInside :: Double -> Double -> Circle -> Bool\nisInside x y c = (x - cx c) ^ 2 + (y - cy c) ^ 2 <= (cr c ^ 2)\n\nisInsideAny :: Double -> Double -> [Circle] -> Bool\nisInsideAny x y = any (isInside x y)\n\napproximatedArea :: [Circle] -> Int -> Double\napproximatedArea cs box_side = (fromIntegral count) * dx * dy\n  where\n    \n    x_min = minimum [cx c - cr c | c <- circles]\n    x_max = maximum [cx c + cr c | c <- circles]\n    y_min = minimum [cy c - cr c | c <- circles]\n    y_max = maximum [cy c + cr c | c <- circles]\n    dx = (x_max - x_min) / (fromIntegral box_side)\n    dy = (y_max - y_min) / (fromIntegral box_side)\n    count = length [0 | r <- [0 .. box_side - 1],\n                        c <- [0 .. box_side - 1],\n                        isInsideAny (posx c) (posy r) circles]\n    posy r = y_min + (fromIntegral r) * dy\n    posx c = x_min + (fromIntegral c) * dx\n\ncircles :: [Circle]\ncircles = [Circle ( 1.6417233788) ( 1.6121789534) 0.0848270516,\n           Circle (-1.4944608174) ( 1.2077959613) 1.1039549836,\n           Circle ( 0.6110294452) (-0.6907087527) 0.9089162485,\n           Circle ( 0.3844862411) ( 0.2923344616) 0.2375743054,\n           Circle (-0.2495892950) (-0.3832854473) 1.0845181219,\n           Circle ( 1.7813504266) ( 1.6178237031) 0.8162655711,\n           Circle (-0.1985249206) (-0.8343333301) 0.0538864941,\n           Circle (-1.7011985145) (-0.1263820964) 0.4776976918,\n           Circle (-0.4319462812) ( 1.4104420482) 0.7886291537,\n           Circle ( 0.2178372997) (-0.9499557344) 0.0357871187,\n           Circle (-0.6294854565) (-1.3078893852) 0.7653357688,\n           Circle ( 1.7952608455) ( 0.6281269104) 0.2727652452,\n           Circle ( 1.4168575317) ( 1.0683357171) 1.1016025378,\n           Circle ( 1.4637371396) ( 0.9463877418) 1.1846214562,\n           Circle (-0.5263668798) ( 1.7315156631) 1.4428514068,\n           Circle (-1.2197352481) ( 0.9144146579) 1.0727263474,\n           Circle (-0.1389358881) ( 0.1092805780) 0.7350208828,\n           Circle ( 1.5293954595) ( 0.0030278255) 1.2472867347,\n           Circle (-0.5258728625) ( 1.3782633069) 1.3495508831,\n           Circle (-0.1403562064) ( 0.2437382535) 1.3804956588,\n           Circle ( 0.8055826339) (-0.0482092025) 0.3327165165,\n           Circle (-0.6311979224) ( 0.7184578971) 0.2491045282,\n           Circle ( 1.4685857879) (-0.8347049536) 1.3670667538,\n           Circle (-0.6855727502) ( 1.6465021616) 1.0593087096,\n           Circle ( 0.0152957411) ( 0.0638919221) 0.9771215985]\n\nmain = putStrLn $ \"Approximated area: \" ++\n                  (show $ approximatedArea circles 5000)\n", "target": "public class CirclesTotalArea {\n\n    \n    \n    private static double distSq(double x1, double y1, double x2, double y2) {\n        return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n    }\n    \n    private static boolean rectangleFullyInsideCircle(double[] rect, double[] circ) {\n        double r2 = circ[2] * circ[2];\n        \n        return distSq(rect[0], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) <= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) <= r2;\n    }\n    \n    private static boolean rectangleSurelyOutsideCircle(double[] rect, double[] circ) {\n        \n        if(rect[0] <= circ[0] && circ[0] <= rect[0] + rect[2] &&\n          rect[1] - rect[3] <= circ[1] && circ[1] <= rect[1]) { return false; }\n        \n        double r2 = circ[2] + Math.max(rect[2], rect[3]);\n        r2 = r2 * r2;\n        return distSq(rect[0], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0], rect[1] - rect[3], circ[0], circ[1]) >= r2 &&\n          distSq(rect[0] + rect[2], rect[1] - rect[3], circ[0], circ[1]) >= r2;\n    }\n    \n    private static boolean[] surelyOutside;\n    \n    private static double totalArea(double[] rect, double[][] circs, int d) {    \n        \n        int surelyOutsideCount = 0;\n        for(int i = 0; i < circs.length; i++) {\n            if(rectangleFullyInsideCircle(rect, circs[i])) { return rect[2] * rect[3]; }\n            if(rectangleSurelyOutsideCircle(rect, circs[i])) {\n                surelyOutside[i] = true;\n                surelyOutsideCount++;\n            }\n            else { surelyOutside[i] = false; }\n        }\n        \n        if(surelyOutsideCount == circs.length) { return 0; }\n        \n        if(d < 1) { \n            return rect[2] * rect[3] / 3;  \n        }\n        \n        if(surelyOutsideCount > 0) {\n            double[][] newCircs = new double[circs.length - surelyOutsideCount][3];\n            int loc = 0;\n            for(int i = 0; i < circs.length; i++) {\n                if(!surelyOutside[i]) { newCircs[loc++] = circs[i]; }\n            }\n            circs = newCircs;\n        }\n        \n        double w = rect[2] / 2; \n        double h = rect[3] / 2; \n        double[][] pieces = {\n            { rect[0], rect[1], w, h }, \n            { rect[0] + w, rect[1], w, h }, \n            { rect[0], rect[1] - h, w, h }, \n            { rect[0] + w, rect[1] - h, w, h } \n        };\n        double total = 0;\n        for(double[] piece: pieces) { total += totalArea(piece, circs, d - 1); }\n        return total;\n    }\n    \n    public static double totalArea(double[][] circs, int d) {\n        double maxx = Double.NEGATIVE_INFINITY;\n        double minx = Double.POSITIVE_INFINITY;\n        double maxy = Double.NEGATIVE_INFINITY;\n        double miny = Double.POSITIVE_INFINITY;\n        \n        for(double[] circ: circs) {\n            if(circ[0] + circ[2] > maxx) { maxx = circ[0] + circ[2]; }\n            if(circ[0] - circ[2] < minx) { minx = circ[0] - circ[2]; }\n            if(circ[1] + circ[2] > maxy) { maxy = circ[1] + circ[2]; }\n            if(circ[1] - circ[2] < miny) { miny = circ[1] - circ[2]; }\n        }\n        double[] rect = { minx, maxy, maxx - minx, maxy - miny };\n        surelyOutside = new boolean[circs.length];\n        return totalArea(rect, circs, d);\n    }\n    \n    public static void main(String[] args) {\n        double[][] circs = {\n            { 1.6417233788, 1.6121789534, 0.0848270516 },\n            {-1.4944608174, 1.2077959613, 1.1039549836 },\n            { 0.6110294452, -0.6907087527, 0.9089162485 },\n            { 0.3844862411, 0.2923344616, 0.2375743054 },\n            {-0.2495892950, -0.3832854473, 1.0845181219 },\n            {1.7813504266, 1.6178237031, 0.8162655711 },\n            {-0.1985249206, -0.8343333301, 0.0538864941 },\n            {-1.7011985145, -0.1263820964, 0.4776976918 },\n            {-0.4319462812, 1.4104420482, 0.7886291537 },\n            {0.2178372997, -0.9499557344, 0.0357871187 },\n            {-0.6294854565, -1.3078893852, 0.7653357688 },\n            {1.7952608455, 0.6281269104, 0.2727652452 },\n            {1.4168575317, 1.0683357171, 1.1016025378 },\n            {1.4637371396, 0.9463877418, 1.1846214562 },\n            {-0.5263668798, 1.7315156631, 1.4428514068 },\n            {-1.2197352481, 0.9144146579, 1.0727263474 },\n            {-0.1389358881, 0.1092805780, 0.7350208828 },\n            {1.5293954595, 0.0030278255, 1.2472867347 },\n            {-0.5258728625, 1.3782633069, 1.3495508831 },\n            {-0.1403562064, 0.2437382535, 1.3804956588 },\n            {0.8055826339, -0.0482092025, 0.3327165165 },\n            {-0.6311979224, 0.7184578971, 0.2491045282 },\n            {1.4685857879, -0.8347049536, 1.3670667538 },\n            {-0.6855727502, 1.6465021616, 1.0593087096 },\n            {0.0152957411, 0.0638919221, 0.9771215985 }\n        };\n        double ans = totalArea(circs, 24);\n        System.out.println(\"Approx. area is \" + ans);\n        System.out.println(\"Error is \" + Math.abs(21.56503660 - ans));\n    }\n}\n"}
{"id": 404486, "name": "Factorions", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.List (unfoldr)\nimport Control.Monad (guard)\n\nfactorion :: Int -> Int -> Bool\nfactorion b n = f b n == n\n where\n  f b = sum . map (product . enumFromTo 1) . unfoldr (\\x -> guard (x > 0) >> pure (x `mod` b, x `div` b))\n\nmain :: IO ()\nmain = mapM_ (uncurry (printf \"Factorions for base %2d: %s\\n\") . (\\(a, b) -> (b, result a b))) \n  [(3,9), (4,10), (5,11), (2,12)]\n where \n  factorions b = filter (factorion b) [1..]\n  result n = show . take n . factorions\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 404487, "name": "Factorions", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.List (unfoldr)\nimport Control.Monad (guard)\n\nfactorion :: Int -> Int -> Bool\nfactorion b n = f b n == n\n where\n  f b = sum . map (product . enumFromTo 1) . unfoldr (\\x -> guard (x > 0) >> pure (x `mod` b, x `div` b))\n\nmain :: IO ()\nmain = mapM_ (uncurry (printf \"Factorions for base %2d: %s\\n\") . (\\(a, b) -> (b, result a b))) \n  [(3,9), (4,10), (5,11), (2,12)]\n where \n  factorions b = filter (factorion b) [1..]\n  result n = show . take n . factorions\n", "target": "public class Factorion {\n    public static void main(String [] args){\n        System.out.println(\"Base 9:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,9);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 10:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,10);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 11:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,11);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n        System.out.println(\"\\nBase 12:\");\n        for(int i = 1; i <= 1499999; i++){\n            String iStri = String.valueOf(i);\n            int multiplied = operate(iStri,12);\n            if(multiplied == i){\n                System.out.print(i + \"\\t\");\n            }\n        }\n    }\n    public static int factorialRec(int n){\n        int result = 1;\n        return n == 0 ? result : result * n * factorialRec(n-1);\n    }\n\n    public static int operate(String s, int base){\n        int sum = 0;\n        String strx = fromDeci(base, Integer.parseInt(s));\n        for(int i = 0; i < strx.length(); i++){\n            if(strx.charAt(i) == 'A'){\n                sum += factorialRec(10);\n            }else if(strx.charAt(i) == 'B') {\n                sum += factorialRec(11);\n            }else if(strx.charAt(i) == 'C') {\n                sum += factorialRec(12);\n            }else {\n                sum += factorialRec(Integer.parseInt(String.valueOf(strx.charAt(i)), base));\n            }\n        }\n        return sum;\n    }\n    \n    static char reVal(int num) {\n        if (num >= 0 && num <= 9)\n            return (char)(num + 48);\n        else\n            return (char)(num - 10 + 65);\n    }\n    static String fromDeci(int base, int num){\n        StringBuilder s = new StringBuilder();\n        while (num > 0) {\n            s.append(reVal(num % base));\n            num /= base;\n        }\n        return new String(new StringBuilder(s).reverse());\n    }\n}\n"}
{"id": 404488, "name": "Sum of divisors", "source": "Translate Haskell to Java: import Data.List.Split (chunksOf)\n\n\ndivisors\n  :: Integral a\n  => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n  filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\"\n    , test sum\n    , \"Products of divisors of [1..100]:\"\n    , test product\n    ]\n\ntest\n  :: (Show a, Integral a)\n  => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n  in unlines $ unwords <$> fmap (fmap (justifyRight w ' ')) (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404489, "name": "Sum of divisors", "source": "Translate Haskell to Java: import Data.List.Split (chunksOf)\n\n\ndivisors\n  :: Integral a\n  => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n  filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\"\n    , test sum\n    , \"Products of divisors of [1..100]:\"\n    , test product\n    ]\n\ntest\n  :: (Show a, Integral a)\n  => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n  in unlines $ unwords <$> fmap (fmap (justifyRight w ' ')) (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404490, "name": "Order by pair comparisons", "source": "Translate Haskell to Java: import Control.Monad\nimport Control.Monad.ListM (sortByM, insertByM, partitionM, minimumByM)\nimport Data.Bool (bool)\nimport Data.Monoid\nimport Data.List\n\n\nisortM, msortM, tsortM :: Monad m => (a -> a -> m Ordering) -> [a] -> m [a]\n\n\nmsortM = sortByM\n\n\nisortM cmp = foldM (flip (insertByM cmp)) []\n\n\ntsortM cmp = go\n  where\n    go [] = pure []\n    go (h:t) = do (l, g) <- partitionM (fmap (LT /=) . cmp h) t\n                  go l <+> pure [h] <+> go g\n    (<+>) = liftM2 (++)\n", "target": "import java.util.*;\n\npublic class SortComp1 {\n    public static void main(String[] args) {\n        List<String> items = Arrays.asList(\"violet\", \"red\", \"green\", \"indigo\", \"blue\", \"yellow\", \"orange\");\n        List<String> sortedItems = new ArrayList<>();\n        Comparator<String> interactiveCompare = new Comparator<String>() {\n                int count = 0;\n                Scanner s = new Scanner(System.in);\n                public int compare(String s1, String s2) {\n                    System.out.printf(\"(%d) Is %s <, =, or > %s. Answer -1, 0, or 1: \", ++count, s1, s2);\n                    return s.nextInt();\n                }\n            };\n        for (String item : items) {\n            System.out.printf(\"Inserting '%s' into %s\\n\", item, sortedItems);\n            int spotToInsert = Collections.binarySearch(sortedItems, item, interactiveCompare);\n            \n            \n            if (spotToInsert < 0) spotToInsert = ~spotToInsert;\n            sortedItems.add(spotToInsert, item);\n        }\n        System.out.println(sortedItems);\n    }\n}\n"}
{"id": 404491, "name": "Fermat numbers", "source": "Translate Haskell to Java: import Data.Numbers.Primes (primeFactors)\nimport Data.Bool (bool)\n\nfermat :: Integer -> Integer\nfermat = succ . (2 ^) . (2 ^)\n\nfermats :: [Integer]\nfermats = fermat <$> [0 ..]\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ fTable \"First 10 Fermats:\" show show fermat [0 .. 9]\n    , fTable\n        \"Factors of first 7:\"\n        show\n        showFactors\n        primeFactors\n        (take 7 fermats)\n    ]\n\n\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  unlines $\n  s : fmap (((++) . rjust w ' ' . xShow) <*> ((\" -> \" ++) . fxShow . f)) xs\n  where\n    rjust n c = drop . length <*> (replicate n c ++)\n    w = maximum (length . xShow <$> xs)\n\nshowFactors :: [Integer] -> String\nshowFactors x\n  | 1 < length x = show x\n  | otherwise = \"(prime)\"\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.Collectors;\n\npublic class FermatNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 10 Fermat numbers:\");\n        for ( int i = 0 ; i < 10 ; i++ ) {\n            System.out.printf(\"F[%d] = %s\\n\", i, fermat(i));\n        }\n        System.out.printf(\"%nFirst 12 Fermat numbers factored:%n\");\n        for ( int i = 0 ; i < 13 ; i++ ) {\n            System.out.printf(\"F[%d] = %s\\n\", i, getString(getFactors(i, fermat(i))));\n        }\n    }\n    \n    private static String getString(List<BigInteger> factors) {\n        if ( factors.size() == 1 ) {\n            return factors.get(0) + \" (PRIME)\";\n        }\n        return factors.stream().map(v -> v.toString()).map(v -> v.startsWith(\"-\") ? \"(C\" + v.replace(\"-\", \"\") + \")\" : v).collect(Collectors.joining(\" * \"));\n    }\n\n    private static Map<Integer, String> COMPOSITE = new HashMap<>();\n    static {\n        COMPOSITE.put(9, \"5529\");\n        COMPOSITE.put(10, \"6078\");\n        COMPOSITE.put(11, \"1037\");\n        COMPOSITE.put(12, \"5488\");\n        COMPOSITE.put(13, \"2884\");\n    }\n\n    private static List<BigInteger> getFactors(int fermatIndex, BigInteger n) {\n        List<BigInteger> factors = new ArrayList<>();\n        BigInteger factor = BigInteger.ONE;\n        while ( true ) {\n            if ( n.isProbablePrime(100) ) {\n                factors.add(n);\n                break;\n            }\n            else {\n                if ( COMPOSITE.containsKey(fermatIndex) ) {\n                    String stop = COMPOSITE.get(fermatIndex);\n                    if ( n.toString().startsWith(stop) ) {\n                        factors.add(new BigInteger(\"-\" + n.toString().length()));\n                        break;\n                    }\n                }\n                factor = pollardRhoFast(n);\n                if ( factor.compareTo(BigInteger.ZERO) == 0 ) {\n                    factors.add(n);\n                    break;\n                }\n                else {\n                    factors.add(factor);\n                    n = n.divide(factor);\n                }\n            }\n        }\n        return factors;\n    }\n    \n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    \n    private static BigInteger fermat(int n) {\n        return TWO.pow((int)Math.pow(2, n)).add(BigInteger.ONE);\n    }\n        \n    \n    @SuppressWarnings(\"unused\")\n    private static BigInteger pollardRho(BigInteger n) {\n        BigInteger x = BigInteger.valueOf(2);\n        BigInteger y = BigInteger.valueOf(2);\n        BigInteger d = BigInteger.ONE;\n        while ( d.compareTo(BigInteger.ONE) == 0 ) {\n            x = pollardRhoG(x, n);\n            y = pollardRhoG(pollardRhoG(y, n), n);\n            d = x.subtract(y).abs().gcd(n);\n        }\n        if ( d.compareTo(n) == 0 ) {\n            return BigInteger.ZERO;\n        }\n        return d;\n    }\n    \n    \n    \n    \n    \n    \n    private static BigInteger pollardRhoFast(BigInteger n) {\n        long start = System.currentTimeMillis();\n        BigInteger x = BigInteger.valueOf(2);\n        BigInteger y = BigInteger.valueOf(2);\n        BigInteger d = BigInteger.ONE;\n        int count = 0;\n        BigInteger z = BigInteger.ONE;\n        while ( true ) {\n            x = pollardRhoG(x, n);\n            y = pollardRhoG(pollardRhoG(y, n), n);\n            d = x.subtract(y).abs();\n            z = z.multiply(d).mod(n);\n            count++;\n            if ( count == 100 ) {\n                d = z.gcd(n);\n                if ( d.compareTo(BigInteger.ONE) != 0 ) {\n                    break;\n                }\n                z = BigInteger.ONE;\n                count = 0;\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"    Pollard rho try factor %s elapsed time = %d ms (factor = %s).%n\", n, (end-start), d);\n        if ( d.compareTo(n) == 0 ) {\n            return BigInteger.ZERO;\n        }\n        return d;\n    }\n\n    private static BigInteger pollardRhoG(BigInteger x, BigInteger n) {\n        return x.multiply(x).add(BigInteger.ONE).mod(n);\n    }\n\n}\n"}
{"id": 404492, "name": "Sorting algorithms_Bead sort", "source": "Translate Haskell to Java: import Data.List\n\nbeadSort :: [Int] -> [Int]\nbeadSort = map sum. transpose. transpose. map (flip replicate 1)\n", "target": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}\n"}
{"id": 404493, "name": "Casting out nines", "source": "Translate Haskell to Java: co9 n\n  | n <= 8 = n\n  | otherwise = co9 $ sum $ filter (/= 9) $ digits 10 n\n\ntask2 = filter (\\n -> co9 n == co9 (n ^ 2)) [1 .. 100]\n\ntask3 k = filter (\\n -> n `mod` k == n ^ 2 `mod` k) [1 .. 100]\n", "target": "import java.util.*;\nimport java.util.stream.IntStream;\n\npublic class CastingOutNines {\n\n    public static void main(String[] args) {\n        System.out.println(castOut(16, 1, 255));\n        System.out.println(castOut(10, 1, 99));\n        System.out.println(castOut(17, 1, 288));\n    }\n\n    static List<Integer> castOut(int base, int start, int end) {\n        int[] ran = IntStream\n                .range(0, base - 1)\n                .filter(x -> x % (base - 1) == (x * x) % (base - 1))\n                .toArray();\n\n        int x = start / (base - 1);\n\n        List<Integer> result = new ArrayList<>();\n        while (true) {\n            for (int n : ran) {\n                int k = (base - 1) * x + n;\n                if (k < start)\n                    continue;\n                if (k > end)\n                    return result;\n                result.add(k);\n            }\n            x++;\n        }\n    }\n}\n"}
{"id": 404494, "name": "Casting out nines", "source": "Translate Haskell to Java: co9 n\n  | n <= 8 = n\n  | otherwise = co9 $ sum $ filter (/= 9) $ digits 10 n\n\ntask2 = filter (\\n -> co9 n == co9 (n ^ 2)) [1 .. 100]\n\ntask3 k = filter (\\n -> n `mod` k == n ^ 2 `mod` k) [1 .. 100]\n", "target": "import java.util.*;\nimport java.util.stream.IntStream;\n\npublic class CastingOutNines {\n\n    public static void main(String[] args) {\n        System.out.println(castOut(16, 1, 255));\n        System.out.println(castOut(10, 1, 99));\n        System.out.println(castOut(17, 1, 288));\n    }\n\n    static List<Integer> castOut(int base, int start, int end) {\n        int[] ran = IntStream\n                .range(0, base - 1)\n                .filter(x -> x % (base - 1) == (x * x) % (base - 1))\n                .toArray();\n\n        int x = start / (base - 1);\n\n        List<Integer> result = new ArrayList<>();\n        while (true) {\n            for (int n : ran) {\n                int k = (base - 1) * x + n;\n                if (k < start)\n                    continue;\n                if (k > end)\n                    return result;\n                result.add(k);\n            }\n            x++;\n        }\n    }\n}\n"}
{"id": 404495, "name": "Simple database", "source": "Translate Haskell to Java: import Control.Monad.State\nimport Data.List (sortBy, nub)\nimport System.Environment (getArgs, getProgName)\nimport System.Directory (doesFileExist)\nimport System.IO (openFile, hGetContents, hClose, IOMode(..),\n    Handle, hPutStrLn)\n\n\ndata Date = Date Integer Int Int deriving (Show, Read, Eq, Ord)\n\n\ndata Item = Item    {description :: String\n                    ,category    :: [String]\n                    ,date        :: Date\n                    ,optional    :: [String]}\n                    deriving (Show, Read)\n\n\n\ntype ItemList a = StateT [Item] IO a\n\n\naddItem :: Item -> ItemList ()\naddItem i = modify (++ [i])\n\n\nlatest :: [Item] -> [Item]\nlatest [] = []\nlatest [x]= [x]\nlatest xs = take 1 $ sortBy newer xs\n\n\nnewer :: Item -> Item -> Ordering\nnewer a b = compare (date b) (date a)\n\n\ncategories :: ItemList [String]\ncategories = liftM (nub . concatMap category) get\n\n\nfilterByCategory :: String -> ItemList [Item]\nfilterByCategory c = liftM (filter (\\i -> c `elem` category i)) get\n\n\nlastOfAll :: ItemList [Item]\nlastOfAll = liftM latest get\n    \n\nlatestByCategory :: ItemList [Item]\nlatestByCategory = do\n    cats <- categories\n    filt <- mapM filterByCategory cats\n    return $ concatMap latest filt\n\n\nsortByDate :: ItemList [Item]\nsortByDate = liftM (sortBy newer) get\n\ntoScreen :: Item -> IO ()\ntoScreen (Item desc cats (Date y m d) opt) = putStrLn $\n    \"Description:\\t\" ++ desc ++ \"\\nCategories:\\t\" ++ show cats ++\n    \"\\nDate:\\t\\t\" ++ show y ++ \"-\" ++ show m ++ \"-\" ++ show d ++\n    \"\\nOther info:\\t\" ++ show opt\n\n\n\n\n\narguments :: ItemList [Item]\narguments = do\n    args <- liftIO getArgs\n    case args of\n        (\"add\":desc:cat:year:month:day:opt) -> do\n            let newItem = parseItem args\n            addItem newItem\n            return [newItem]\n        (\"latest\":[]) -> do\n            item <- lastOfAll\n            lift $ mapM_ toScreen item\n            return []\n        (\"category\":[]) -> do\n            items <- latestByCategory\n            lift $ mapM_ toScreen items\n            return []\n        (\"all\":[]) -> do\n            sorted <- sortByDate\n            lift $ mapM_ toScreen sorted\n            return []\n        _ -> do\n            lift usage\n            return []\n\nparseItem :: [String] -> Item\nparseItem (_:desc:cat:year:month:day:opt) =\n    Item {description = desc, category = words cat,\n        date = Date (read year) (read month) (read day),\n        optional = opt}\n                \nusage :: IO ()\nusage = do\n    progName <- getProgName\n    putStrLn $ \"Usage: \" ++ progName ++ \" add|all|category|latest \\\n        \\OPTIONS\\n\\nadd \\\"description\\\" \\\"category1 category2\\\"... \\\n        \\year month day [\\\"note1\\\" \\\"note2\\\"...]\\n\\tAdds a new record \\\n        \\to the database.\\n\\nall\\n\\tPrints all items in chronological \\\n        \\order.\\n\\ncategory\\n\\tPrints the latest item for each category.\\\n        \\\\n\\nlatest\\n\\tPrints the latest item.\"\n\n\nmain :: IO ()\nmain = do\n    progName <- getProgName\n    let fileName = progName ++ \".db\"\n    e <- doesFileExist fileName\n    if e\n        then do\n            hr <- openFile fileName ReadMode\n            f <- hGetContents hr\n            v <- evalStateT arguments (map read $ lines f)\n            hClose hr \n            hw <- openFile fileName AppendMode\n            mapM_ (hPutStrLn hw . show) v\n            hClose hw\n        else do\n            v <- evalStateT arguments []\n            hw <- openFile fileName WriteMode\n            mapM_ (hPutStrLn hw . show) v\n            hClose hw\n", "target": "import java.io.*;\nimport java.text.*;\nimport java.util.*;\n\npublic class SimpleDatabase {\n\n    final static String filename = \"simdb.csv\";\n\n    public static void main(String[] args) {\n        if (args.length < 1 || args.length > 3) {\n            printUsage();\n            return;\n        }\n\n        switch (args[0].toLowerCase()) {\n            case \"add\":\n                addItem(args);\n                break;\n            case \"latest\":\n                printLatest(args);\n                break;\n            case \"all\":\n                printAll();\n                break;\n            default:\n                printUsage();\n                break;\n        }\n    }\n\n    private static class Item implements Comparable<Item>{\n        final String name;\n        final String date;\n        final String category;\n\n        Item(String n, String d, String c) {\n            name = n;\n            date = d;\n            category = c;\n        }\n\n        @Override\n        public int compareTo(Item item){\n            return date.compareTo(item.date);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s,%s,%s%n\", name, date, category);\n        }\n    }\n\n    private static void addItem(String[] input) {\n        if (input.length < 2) {\n            printUsage();\n            return;\n        }\n        List<Item> db = load();\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");\n        String date = sdf.format(new Date());\n        String cat = (input.length == 3) ? input[2] : \"none\";\n        db.add(new Item(input[1], date, cat));\n        store(db);\n    }\n\n    private static void printLatest(String[] a) {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        if (a.length == 2) {\n            for (Item item : db)\n                if (item.category.equals(a[1]))\n                    System.out.println(item);\n        } else {\n            System.out.println(db.get(0));\n        }\n    }\n\n    private static void printAll() {\n        List<Item> db = load();\n        if (db.isEmpty()) {\n            System.out.println(\"No entries in database.\");\n            return;\n        }\n        Collections.sort(db);\n        for (Item item : db)\n            System.out.println(item);\n    }\n\n    private static List<Item> load() {\n        List<Item> db = new ArrayList<>();\n        try (Scanner sc = new Scanner(new File(filename))) {\n            while (sc.hasNext()) {\n                String[] item = sc.nextLine().split(\",\");\n                db.add(new Item(item[0], item[1], item[2]));\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return db;\n    }\n\n    private static void store(List<Item> db) {\n        try (FileWriter fw = new FileWriter(filename)) {\n            for (Item item : db)\n                fw.write(item.toString());\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n\n    private static void printUsage() {\n         System.out.println(\"Usage:\");\n         System.out.println(\"  simdb cmd [categoryName]\");\n         System.out.println(\"  add     add item, followed by optional category\");\n         System.out.println(\"  latest  print last added item(s), followed by \"\n                 + \"optional category\");\n         System.out.println(\"  all     print all\");\n         System.out.println(\"  For instance: add \\\"some item name\\\" \"\n                 + \"\\\"some category name\\\"\");\n    }\n}\n"}
{"id": 404496, "name": "Tau function", "source": "Translate Haskell to Java: tau :: Integral a => a -> a\ntau n | n <= 0 = error \"Not a positive integer\"\ntau n = go 0 (1, 1)\n    where\n    yo i = (i, i * i)\n    go r (i, ii)\n        | n < ii = r\n        | n == ii = r + 1\n        | 0 == mod n i = go (r + 2) (yo $ i + 1)\n        | otherwise = go r (yo $ i + 1)\n\nmain = print $ map tau [1..100]\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404497, "name": "Tau function", "source": "Translate Haskell to Java: tau :: Integral a => a -> a\ntau n | n <= 0 = error \"Not a positive integer\"\ntau n = go 0 (1, 1)\n    where\n    yo i = (i, i * i)\n    go r (i, ii)\n        | n < ii = r\n        | n == ii = r + 1\n        | 0 == mod n i = go (r + 2) (yo $ i + 1)\n        | otherwise = go r (yo $ i + 1)\n\nmain = print $ map tau [1..100]\n", "target": "public class TauFunction {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final int limit = 100;\n        System.out.printf(\"Count of divisors for the first %d positive integers:\\n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%3d\", divisorCount(n));\n            if (n % 20 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404498, "name": "M\u00f6bius function", "source": "Translate Haskell to Java: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Data.Vector.Unboxed (toList)\nimport Math.NumberTheory.ArithmeticFunctions.Moebius (Moebius(..),\n                                                      sieveBlockMoebius)\nimport System.Environment (getArgs, getProgName)\nimport System.IO (hPutStrLn, stderr)\nimport Text.Read (readMaybe)\n\n\nmoebiusBlock :: Word -> [Moebius]\nmoebiusBlock = toList . sieveBlockMoebius 1\n\nshowMoebiusBlock :: Word -> [Moebius] -> String\nshowMoebiusBlock cols = intercalate \"\\n\" . map (concatMap showMoebius) .\n                        chunksOf (fromIntegral cols)\n  where showMoebius MoebiusN = \" -1\"\n        showMoebius MoebiusZ = \"  0\"\n        showMoebius MoebiusP = \"  1\"\n\nmain :: IO ()\nmain = do\n  prog <- getProgName\n  args <- map readMaybe <$> getArgs\n  case args of\n    [Just cols, Just n] ->\n      putStrLn (\"\u03bc(n) for 1 \u2264 n \u2264 \" ++ show n ++ \":\\n\") >>\n      putStrLn (showMoebiusBlock cols $ moebiusBlock n)\n    _ -> hPutStrLn stderr $ \"Usage: \" ++ prog ++ \" num-columns maximum-number\"\n", "target": "public class M\u00f6biusFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the m\u00f6bius function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", m\u00f6biusFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n    }\n    \n    private static int MU_MAX = 1_000_000;\n    private static int[] MU = null;\n    \n    \n    private static int m\u00f6biusFunction(int n) {\n        if ( MU != null ) {\n            return MU[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n        }\n        return MU[n];\n    }\n\n}\n"}
{"id": 404499, "name": "Mertens function", "source": "Translate Haskell to Java: import           Data.List.Split          (chunksOf)\nimport qualified Data.MemoCombinators  as Memo\nimport           Math.NumberTheory.Primes (unPrime, factorise)\nimport           Text.Printf              (printf)\n\nmoebius :: Integer -> Int\nmoebius = product . fmap m . factorise\n  where\n    m (p, e)\n      | unPrime p == 0 = 0\n      | e == 1 = -1\n      | otherwise = 0\n\nmertens :: Integer -> Int\nmertens = Memo.integral (\\n -> sum $ fmap moebius [1..n])\n\ncountZeros :: [Integer] -> Int\ncountZeros = length . filter ((==0) . mertens)\n\ncrossesZero :: [Integer] -> Int\ncrossesZero = length . go . fmap mertens\n  where\n    go (x:y:xs) \n      | y == 0 && x /= 0 = y : go (y:xs)\n      | otherwise        = go (y:xs)\n    go _ = []\n\nmain :: IO ()\nmain = do\n  printf \"The first 99 terms for M(1..99):\\n\\n   \"\n  mapM_ (printf \"%3d\" . mertens) [1..9] >> printf \"\\n\"\n  mapM_ (\\row -> mapM_ (printf \"%3d\" . mertens) row >> printf \"\\n\") $ chunksOf 10 [10..99]\n  printf \"\\nM(n) is zero %d times for 1 <= n <= 1000.\\n\" $ countZeros [1..1000]\n  printf \"M(n) crosses zero %d times for 1 <= n <= 1000.\\n\" $ crossesZero [1..1000]\n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 404500, "name": "Product of divisors", "source": "Translate Haskell to Java: import Data.List.Split (chunksOf)\n\n\n\ndivisors :: Integral a => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n    filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\",\n      test sum,\n      \"Products of divisors of [1..100]:\",\n      test product\n    ]\n\ntest :: (Show a, Integral a) => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n   in unlines $\n        unwords\n          <$> fmap\n            (fmap (justifyRight w ' '))\n            (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404501, "name": "Product of divisors", "source": "Translate Haskell to Java: import Data.List.Split (chunksOf)\n\n\n\ndivisors :: Integral a => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n    filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\",\n      test sum,\n      \"Products of divisors of [1..100]:\",\n      test product\n    ]\n\ntest :: (Show a, Integral a) => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n   in unlines $\n        unwords\n          <$> fmap\n            (fmap (justifyRight w ' '))\n            (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404502, "name": "Playing cards", "source": "Translate Haskell to Java: import System.Random\n\ndata Pip = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | \n           Jack | Queen | King | Ace \n  deriving (Ord, Enum, Bounded, Eq, Show)\n\ndata Suit = Diamonds | Spades | Hearts | Clubs\n  deriving (Ord, Enum, Bounded, Eq, Show)\n\ntype Card = (Pip, Suit)\n\nfullRange :: (Bounded a, Enum a) => [a]\nfullRange = [minBound..maxBound]\n\nfullDeck :: [Card]\nfullDeck = [(pip, suit) | pip <- fullRange, suit <- fullRange]\n\ninsertAt :: Int -> a -> [a] -> [a]\ninsertAt 0 x ys     = x:ys\ninsertAt n _ []     = error \"insertAt: list too short\"\ninsertAt n x (y:ys) = y : insertAt (n-1) x ys\n\nshuffle :: RandomGen g => g -> [a] -> [a]\nshuffle g xs = shuffle' g xs 0 [] where\n  shuffle' g []     _ ys = ys\n  shuffle' g (x:xs) n ys = shuffle' g' xs (n+1) (insertAt k x ys) where\n    (k,g') = randomR (0,n) g\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 404503, "name": "Perfect totient numbers", "source": "Translate Haskell to Java: perfectTotients :: [Int]\nperfectTotients =\n  filter ((==) <*> (succ . sum . tail . takeWhile (1 /=) . iterate \u03c6)) [2 ..]\n\n\u03c6 :: Int -> Int\n\u03c6 = memoize (\\n -> length (filter ((1 ==) . gcd n) [1 .. n]))\n\nmemoize :: (Int -> a) -> (Int -> a)\nmemoize f = (!!) (f <$> [0 ..])\n\nmain :: IO ()\nmain = print $ take 20 perfectTotients\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 404504, "name": "Perfect totient numbers", "source": "Translate Haskell to Java: perfectTotients :: [Int]\nperfectTotients =\n  filter ((==) <*> (succ . sum . tail . takeWhile (1 /=) . iterate \u03c6)) [2 ..]\n\n\u03c6 :: Int -> Int\n\u03c6 = memoize (\\n -> length (filter ((1 ==) . gcd n) [1 .. n]))\n\nmemoize :: (Int -> a) -> (Int -> a)\nmemoize f = (!!) (f <$> [0 ..])\n\nmain :: IO ()\nmain = print $ take 20 perfectTotients\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PerfectTotientNumbers {\n\n    public static void main(String[] args) {\n        computePhi();\n        int n = 20;\n        System.out.printf(\"The first %d perfect totient numbers:%n%s%n\", n, perfectTotient(n));\n    }\n    \n    private static final List<Integer> perfectTotient(int n) {\n        int test = 2;\n        List<Integer> results = new ArrayList<Integer>();\n        for ( int i = 0 ; i < n ; test++ ) {\n            int phiLoop = test;\n            int sum = 0;\n            do {\n                phiLoop = phi[phiLoop];\n                sum += phiLoop;\n            } while ( phiLoop > 1);\n            if ( sum == test ) {\n                i++;\n                results.add(test);\n            }\n        }\n        return results;\n    }\n\n    private static final int max = 100000;\n    private static final int[] phi = new int[max+1];\n\n    private static final void computePhi() {\n        for ( int i = 1 ; i <= max ; i++ ) {\n            phi[i] = i;\n        }\n        for ( int i = 2 ; i <= max ; i++ ) {\n            if (phi[i] < i) continue;\n            for ( int j = i ; j <= max ; j += i ) {\n                phi[j] -= phi[j] / i;\n            }\n        }\n    }\n\n}\n"}
{"id": 404505, "name": "Lah numbers", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Control.Monad (when)\n \nfactorial :: Integral n => n -> n\nfactorial 0 = 1\nfactorial n = product [1..n]\n \nlah :: Integral n => n -> n -> n\nlah n k\n  | k == 1 = factorial n\n  | k == n = 1\n  | k > n  = 0\n  | k < 1 || n < 1 = 0\n  | otherwise = f n `div` f k `div` factorial (n - k)\n      where\n        f = (*) =<< (^ 2) . factorial . pred  \n \nprintLah :: (Word, Word) -> IO ()\nprintLah (n, k) = do\n  when (k == 0) (printf \"\\n%3d\" n)\n  printf \"%11d\" (lah n k)\n \nmain :: IO ()\nmain = do\n  printf \"Unsigned Lah numbers: L(n, k):\\nn/k\"\n  mapM_ (printf \"%11d\") zeroToTwelve\n  mapM_ printLah $ (,) <$> zeroToTwelve <*> zeroToTwelve\n  printf \"\\nMaximum value from the L(100, *) row:\\n%d\\n\"\n    (maximum $ lah 100 <$> ([0..100] :: [Integer]))\n  where zeroToTwelve = [0..12]\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 404506, "name": "Lah numbers", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Control.Monad (when)\n \nfactorial :: Integral n => n -> n\nfactorial 0 = 1\nfactorial n = product [1..n]\n \nlah :: Integral n => n -> n -> n\nlah n k\n  | k == 1 = factorial n\n  | k == n = 1\n  | k > n  = 0\n  | k < 1 || n < 1 = 0\n  | otherwise = f n `div` f k `div` factorial (n - k)\n      where\n        f = (*) =<< (^ 2) . factorial . pred  \n \nprintLah :: (Word, Word) -> IO ()\nprintLah (n, k) = do\n  when (k == 0) (printf \"\\n%3d\" n)\n  printf \"%11d\" (lah n k)\n \nmain :: IO ()\nmain = do\n  printf \"Unsigned Lah numbers: L(n, k):\\nn/k\"\n  mapM_ (printf \"%11d\") zeroToTwelve\n  mapM_ printLah $ (,) <$> zeroToTwelve <*> zeroToTwelve\n  printf \"\\nMaximum value from the L(100, *) row:\\n%d\\n\"\n    (maximum $ lah 100 <$> ([0..100] :: [Integer]))\n  where zeroToTwelve = [0..12]\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class LahNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"Show the unsigned Lah numbers up to n = 12:\");\n        for ( int n = 0 ; n <= 12 ; n++ ) {\n            System.out.printf(\"%5s\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%12s\", lahNumber(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        \n        System.out.println(\"Show the maximum value of L(100, k):\");\n        int n = 100;\n        BigInteger max = BigInteger.ZERO;\n        for ( int k = 0 ; k <= n ; k++ ) {\n            max = max.max(lahNumber(n, k));\n        }\n        System.out.printf(\"%s\", max);\n    }\n    \n    private static Map<String,BigInteger> CACHE = new HashMap<>();\n    \n    private static BigInteger lahNumber(int n, int k) {\n        String key = n + \",\" + k;\n        if ( CACHE.containsKey(key) ) {\n            return CACHE.get(key);\n        }\n        \n        \n        BigInteger result;\n        if ( n == 0 && k == 0 ) {\n            result = BigInteger.ONE;\n        }\n        else if ( k == 0 ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( k > n ) {\n            result = BigInteger.ZERO;\n        }\n        else if ( n == 1 && k == 1 ) {\n            result = BigInteger.ONE;\n        }\n        else {\n            result = BigInteger.valueOf(n-1+k).multiply(lahNumber(n-1,k)).add(lahNumber(n-1,k-1));\n        }\n        \n        CACHE.put(key, result);\n        \n        return result;\n    }\n\n}\n"}
{"id": 404507, "name": "Two sum", "source": "Translate Haskell to Java: twoSum::(Num a,Ord a) => a -> [a] -> [Int]\ntwoSum num list = sol ls (reverse ls)\n  where\n  ls = zip list [0..]\n  sol [] _ = []\n  sol _ [] = []\n  sol xs@((x,i):us) ys@((y,j):vs) = ans\n    where\n    s = x + y\n    ans | s == num  = [i,j]\n        | j <= i    = []\n        | s < num   = sol (dropWhile ((<num).(+y).fst) us) ys\n        | otherwise = sol xs $ dropWhile ((num <).(+x).fst) vs\n\nmain = print $ twoSum 21 [0, 2, 11, 19, 90]\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 404508, "name": "Two sum", "source": "Translate Haskell to Java: twoSum::(Num a,Ord a) => a -> [a] -> [Int]\ntwoSum num list = sol ls (reverse ls)\n  where\n  ls = zip list [0..]\n  sol [] _ = []\n  sol _ [] = []\n  sol xs@((x,i):us) ys@((y,j):vs) = ans\n    where\n    s = x + y\n    ans | s == num  = [i,j]\n        | j <= i    = []\n        | s < num   = sol (dropWhile ((<num).(+y).fst) us) ys\n        | otherwise = sol xs $ dropWhile ((num <).(+x).fst) vs\n\nmain = print $ twoSum 21 [0, 2, 11, 19, 90]\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 404509, "name": "Unprimeable numbers", "source": "Translate Haskell to Java: import Control.Lens ((.~), ix, (&))\nimport Data.Numbers.Primes (isPrime)\nimport Data.List (find, intercalate)\nimport Data.Char (intToDigit)\nimport Data.Maybe (mapMaybe)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\nisUnprimable :: Int -> Bool\nisUnprimable = all (not . isPrime) . swapdigits\n\nswapdigits :: Int -> [Int]\nswapdigits n = map read $ go $ pred $ length digits\n where\n  digits = show n\n  go (-1) = []\n  go n''  = map (\\x -> digits & (ix n'') .~ intToDigit x) [0..9] <> go (pred n'')\n\nunPrimeable :: [Int]\nunPrimeable = filter isUnprimable [1..]\n\nmain :: IO ()\nmain = do \n  printf \"First 35 unprimeable numbers:\\n%s\\n\\n\" $ show $ take 35 unPrimeable\n  printf \"600th unprimeable number: %d\\n\\n\" $ unPrimeable !! 599\n  mapM_ (uncurry (printf \"Lowest unprimeable number ending with %d: %10s\\n\")) $ mapMaybe lowest [0..9]\n where \n  thousands = reverse . intercalate \",\" . chunksOf 3 . reverse\n  lowest n = do\n    x <- find (\\x -> x `mod` 10 == n) unPrimeable\n    pure (n, thousands $ show x)\n", "target": "public class UnprimeableNumbers {\n\n    private static int MAX = 10_000_000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 35 unprimeable numbers:\");\n        displayUnprimeableNumbers(35);\n        int n = 600;\n        System.out.printf(\"%nThe %dth unprimeable number =\u00a0%,d%n%n\", n, nthUnprimeableNumber(n));\n        int[] lowest = genLowest();\n        System.out.println(\"Least unprimeable number that ends in:\");\n        for ( int i = 0 ; i <= 9 ; i++ ) {\n            System.out.printf(\" %d is\u00a0%,d%n\", i, lowest[i]);\n        }\n    }\n    \n    private static int[] genLowest() {\n        int[] lowest = new int[10];\n        int count = 0;\n        int test = 1;\n        while ( count < 10 ) {\n            test++;\n            if ( unPrimable(test) && lowest[test % 10] == 0 ) {\n                lowest[test % 10] = test;\n                count++;\n            }\n        }\n        return lowest;\n    }\n\n    private static int nthUnprimeableNumber(int maxCount) {\n        int test = 1;\n        int count = 0;\n        int result = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                result = test;\n            }\n        }\n        return result;\n    }\n\n    private static void displayUnprimeableNumbers(int maxCount) {\n        int test = 1;\n        int count = 0;\n        while ( count < maxCount ) {\n            test++;\n            if ( unPrimable(test) ) {\n                count++;\n                System.out.printf(\"%d \", test);\n            }\n        }\n        System.out.println();\n    }\n    \n    private static boolean unPrimable(int test) {\n        if ( primes[test] ) {\n            return false;\n        }\n        String s = test + \"\";\n        for ( int i = 0 ; i < s.length() ; i++ ) {\n            for ( int j = 0 ; j <= 9 ; j++ ) {\n                if ( primes[Integer.parseInt(replace(s, i, j))] ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    private static String replace(String str, int position, int value) {\n        char[] sChar = str.toCharArray();\n        sChar[position] = (char) value;\n        return str.substring(0, position) + value + str.substring(position + 1);\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 404510, "name": "Tau number", "source": "Translate Haskell to Java: tau :: Integral a => a -> a\ntau n | n <= 0 = error \"Not a positive integer\"\ntau n = go 0 (1, 1)\n    where\n    yo i = (i, i * i)\n    go r (i, ii)\n        | n < ii = r\n        | n == ii = r + 1\n        | 0 == mod n i = go (r + 2) (yo $ i + 1)\n        | otherwise = go r (yo $ i + 1)\n\nisTau :: Integral a => a -> Bool\nisTau n = 0 == mod n (tau n)\n\nmain = print . take 100 . filter isTau $ [1..]\n", "target": "public class Tau {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"The first %d tau numbers are:%n\", limit);\n        long count = 0;\n        for (long n = 1; count < limit; ++n) {\n            if (n % divisorCount(n) == 0) {\n                System.out.printf(\"%6d\", n);\n                ++count;\n                if (count % 10 == 0) {\n                    System.out.println();\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404511, "name": "Primes whose sum of digits is 25", "source": "Translate Haskell to Java: import Data.Bifunctor (second)\nimport Data.List (replicate)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primes)\n\n\n\nmatchingPrimes :: [Int]\nmatchingPrimes =\n  takeWhile\n    (< 5000)\n    [n | n <- primes, 25 == decimalDigitSum n]\n\ndecimalDigitSum :: Int -> Int\ndecimalDigitSum n =\n  snd $\n    until\n      ((0 ==) . fst)\n      (\\(n, x) -> second (+ x) $ quotRem n 10)\n      (n, 0)\n\n\nmain :: IO ()\nmain = do\n  let w = length (show (last matchingPrimes))\n  mapM_ putStrLn $\n    ( show (length matchingPrimes)\n        <> \" primes (< 5000) with decimal digits totalling 25:\\n\"\n    ) :\n    ( unwords\n        <$> chunksOf\n          4\n          (justifyRight w ' ' . show <$> matchingPrimes)\n    )\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "import java.math.BigInteger;\n\npublic class PrimeSum {\n    private static int digitSum(BigInteger bi) {\n        int sum = 0;\n        while (bi.compareTo(BigInteger.ZERO) > 0) {\n            BigInteger[] dr = bi.divideAndRemainder(BigInteger.TEN);\n            sum += dr[1].intValue();\n            bi = dr[0];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        BigInteger fiveK = BigInteger.valueOf(5_000);\n        BigInteger bi = BigInteger.valueOf(2);\n        while (bi.compareTo(fiveK) < 0) {\n            if (digitSum(bi) == 25) {\n                System.out.print(bi);\n                System.out.print(\"  \");\n            }\n            bi = bi.nextProbablePrime();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 404512, "name": "Primes whose sum of digits is 25", "source": "Translate Haskell to Java: import Data.Bifunctor (second)\nimport Data.List (replicate)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primes)\n\n\n\nmatchingPrimes :: [Int]\nmatchingPrimes =\n  takeWhile\n    (< 5000)\n    [n | n <- primes, 25 == decimalDigitSum n]\n\ndecimalDigitSum :: Int -> Int\ndecimalDigitSum n =\n  snd $\n    until\n      ((0 ==) . fst)\n      (\\(n, x) -> second (+ x) $ quotRem n 10)\n      (n, 0)\n\n\nmain :: IO ()\nmain = do\n  let w = length (show (last matchingPrimes))\n  mapM_ putStrLn $\n    ( show (length matchingPrimes)\n        <> \" primes (< 5000) with decimal digits totalling 25:\\n\"\n    ) :\n    ( unwords\n        <$> chunksOf\n          4\n          (justifyRight w ' ' . show <$> matchingPrimes)\n    )\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "import java.math.BigInteger;\n\npublic class PrimeSum {\n    private static int digitSum(BigInteger bi) {\n        int sum = 0;\n        while (bi.compareTo(BigInteger.ZERO) > 0) {\n            BigInteger[] dr = bi.divideAndRemainder(BigInteger.TEN);\n            sum += dr[1].intValue();\n            bi = dr[0];\n        }\n        return sum;\n    }\n\n    public static void main(String[] args) {\n        BigInteger fiveK = BigInteger.valueOf(5_000);\n        BigInteger bi = BigInteger.valueOf(2);\n        while (bi.compareTo(fiveK) < 0) {\n            if (digitSum(bi) == 25) {\n                System.out.print(bi);\n                System.out.print(\"  \");\n            }\n            bi = bi.nextProbablePrime();\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 404513, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Haskell to Java: import Data.List.Split (chunksOf)\nimport Data.List (intercalate, transpose, unfoldr)\nimport Text.Printf\n\nprimeDigitsNumsSummingToN :: Int -> [Int]\nprimeDigitsNumsSummingToN n = concat $ unfoldr go (return <$> primeDigits)\n  where\n    primeDigits = [2, 3, 5, 7]\n    \n    go :: [[Int]] -> Maybe ([Int], [[Int]])\n    go xs\n      | null xs = Nothing\n      | otherwise = Just (nextLength xs)\n      \n    nextLength :: [[Int]] -> ([Int], [[Int]])\n    nextLength xs =\n      let harvest nv =\n            [ unDigits $ fst nv\n            | n == snd nv ]\n          prune nv =\n            [ fst nv\n            | pred n > snd nv ]\n      in ((,) . concatMap harvest <*> concatMap prune)\n           (((,) <*> sum) <$> ((<$> xs) . (<>) . return =<< primeDigits))\n\n\nmain :: IO ()\nmain = do\n  let n = 13\n      xs = primeDigitsNumsSummingToN n\n  mapM_\n    putStrLn\n    [ concat\n        [ (show . length) xs\n        , \" numbers with prime digits summing to \"\n        , show n\n        , \":\\n\"\n        ]\n    , table \" \" $ chunksOf 10 (show <$> xs)\n    ]\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ic = intercalate\n      ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip ic [\"%\", \"s\"] . show\n  in unlines $ ic gap . zipWith pw ws <$> rows\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n", "target": "public class PrimeDigits {\n    private static boolean primeDigitsSum13(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int r = n % 10;\n            if (r != 2 && r != 3 && r != 5 && r != 7) {\n                return false;\n            }\n            n /= 10;\n            sum += r;\n        }\n        return sum == 13;\n    }\n\n    public static void main(String[] args) {\n        \n        int c = 0;\n        for (int i = 1; i < 1_000_000; i++) {\n            if (primeDigitsSum13(i)) {\n                System.out.printf(\"%6d \", i);\n                if (c++ == 10) {\n                    c = 0;\n                    System.out.println();\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 404514, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Haskell to Java: import Data.List.Split (chunksOf)\nimport Data.List (intercalate, transpose, unfoldr)\nimport Text.Printf\n\nprimeDigitsNumsSummingToN :: Int -> [Int]\nprimeDigitsNumsSummingToN n = concat $ unfoldr go (return <$> primeDigits)\n  where\n    primeDigits = [2, 3, 5, 7]\n    \n    go :: [[Int]] -> Maybe ([Int], [[Int]])\n    go xs\n      | null xs = Nothing\n      | otherwise = Just (nextLength xs)\n      \n    nextLength :: [[Int]] -> ([Int], [[Int]])\n    nextLength xs =\n      let harvest nv =\n            [ unDigits $ fst nv\n            | n == snd nv ]\n          prune nv =\n            [ fst nv\n            | pred n > snd nv ]\n      in ((,) . concatMap harvest <*> concatMap prune)\n           (((,) <*> sum) <$> ((<$> xs) . (<>) . return =<< primeDigits))\n\n\nmain :: IO ()\nmain = do\n  let n = 13\n      xs = primeDigitsNumsSummingToN n\n  mapM_\n    putStrLn\n    [ concat\n        [ (show . length) xs\n        , \" numbers with prime digits summing to \"\n        , show n\n        , \":\\n\"\n        ]\n    , table \" \" $ chunksOf 10 (show <$> xs)\n    ]\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ic = intercalate\n      ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip ic [\"%\", \"s\"] . show\n  in unlines $ ic gap . zipWith pw ws <$> rows\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n", "target": "public class PrimeDigits {\n    private static boolean primeDigitsSum13(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int r = n % 10;\n            if (r != 2 && r != 3 && r != 5 && r != 7) {\n                return false;\n            }\n            n /= 10;\n            sum += r;\n        }\n        return sum == 13;\n    }\n\n    public static void main(String[] args) {\n        \n        int c = 0;\n        for (int i = 1; i < 1_000_000; i++) {\n            if (primeDigitsSum13(i)) {\n                System.out.printf(\"%6d \", i);\n                if (c++ == 10) {\n                    c = 0;\n                    System.out.println();\n                }\n            }\n        }\n        System.out.println();\n    }\n}\n"}
{"id": 404515, "name": "Circular primes", "source": "Translate Haskell to Java: import Math.NumberTheory.Primes (Prime, unPrime, nextPrime)\nimport Math.NumberTheory.Primes.Testing (isPrime, millerRabinV)\nimport Text.Printf (printf)\n\nrotated :: [Integer] -> [Integer]\nrotated xs \n  | any (< head xs) xs = []\n  | otherwise          = map asNum $ take (pred $ length xs) $ rotate xs\n where\n  rotate [] = []\n  rotate (d:ds) = ds <> [d] : rotate (ds <> [d])\n\nasNum :: [Integer] -> Integer\nasNum [] = 0\nasNum n@(d:ds) \n | all (==1) n = read $ concatMap show n\n | otherwise = (d * (10 ^ length ds)) + asNum ds \n\ndigits :: Integer -> [Integer]\ndigits 0 = []\ndigits n = digits d <> [r]\n where (d, r) = n `quotRem` 10\n\nisCircular :: Bool -> Integer -> Bool\nisCircular repunit n \n  | repunit = millerRabinV 0 n\n  | n < 10 = True\n  | even n = False\n  | null rotations = False\n  | any (<n) rotations = False\n  | otherwise = all isPrime rotations\n where\n  rotations = rotated $ digits n\n\nrepunits :: [Integer]\nrepunits = go 2\n where go n = asNum (replicate n 1) : go (succ n)\n\nasRepunit :: Int -> Integer\nasRepunit n = asNum $ replicate n 1\n\nmain :: IO ()\nmain = do \n  printf \"The first 19 circular primes are:\\n%s\\n\\n\" $ circular primes\n  printf \"The next 4 circular primes, in repunit format are:\\n\" \n  mapM_ (printf \"R(%d) \") $ reps repunits\n  printf \"\\n\\nThe following repunits are probably circular primes:\\n\"\n  mapM_ (uncurry (printf \"R(%d)\u00a0: %s\\n\") . checkReps) [5003, 9887, 15073, 25031, 35317, 49081]\n where\n  primes = map unPrime [nextPrime 1..]\n  circular = show . take 19 . filter (isCircular False)\n  reps = map (sum . digits). tail . take 5 . filter (isCircular True)\n  checkReps = (,) <$> id <*> show . isCircular True . asRepunit\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class CircularPrimes {\n    public static void main(String[] args) {\n        System.out.println(\"First 19 circular primes:\");\n        int p = 2;\n        for (int count = 0; count < 19; ++p) {\n            if (isCircularPrime(p)) {\n                if (count > 0)\n                    System.out.print(\", \");\n                System.out.print(p);\n                ++count;\n            }\n        }\n        System.out.println();\n        System.out.println(\"Next 4 circular primes:\");\n        int repunit = 1, digits = 1;\n        for (; repunit < p; ++digits)\n            repunit = 10 * repunit + 1;\n        BigInteger bignum = BigInteger.valueOf(repunit);\n        for (int count = 0; count < 4; ) {\n            if (bignum.isProbablePrime(15)) {\n                if (count > 0)\n                    System.out.print(\", \");\n                System.out.printf(\"R(%d)\", digits);\n                ++count;\n            }\n            ++digits;\n            bignum = bignum.multiply(BigInteger.TEN);\n            bignum = bignum.add(BigInteger.ONE);\n        }\n        System.out.println();\n        testRepunit(5003);\n        testRepunit(9887);\n        testRepunit(15073);\n        testRepunit(25031);\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n\n    private static int cycle(int n) {\n        int m = n, p = 1;\n        while (m >= 10) {\n            p *= 10;\n            m /= 10;\n        }\n        return m + 10 * (n % p);\n    }\n\n    private static boolean isCircularPrime(int p) {\n        if (!isPrime(p))\n            return false;\n        int p2 = cycle(p);\n        while (p2 != p) {\n            if (p2 < p || !isPrime(p2))\n                return false;\n            p2 = cycle(p2);\n        }\n        return true;\n    }\n\n    private static void testRepunit(int digits) {\n        BigInteger repunit = repunit(digits);\n        if (repunit.isProbablePrime(15))\n            System.out.printf(\"R(%d) is probably prime.\\n\", digits);\n        else\n            System.out.printf(\"R(%d) is not prime.\\n\", digits);\n    }\n\n    private static BigInteger repunit(int digits) {\n        char[] ch = new char[digits];\n        Arrays.fill(ch, '1');\n        return new BigInteger(new String(ch));\n    }\n}\n"}
{"id": 404516, "name": "Frobenius numbers", "source": "Translate Haskell to Java: primes = 2 : sieve [3,5..]\n  where sieve (x:xs) = x : sieve (filter (\\y -> y `mod` x /= 0) xs)\n\nfrobenius = zipWith (\\a b -> a*b - a - b) primes (tail primes)\n", "target": "public class Frobenius {\n    public static void main(String[] args) {\n        final int limit = 1000000;\n        System.out.printf(\"Frobenius numbers less than %d (asterisk marks primes):\\n\", limit);\n        PrimeGenerator primeGen = new PrimeGenerator(1000, 100000);\n        int prime1 = primeGen.nextPrime();\n        for (int count = 1; ; ++count) {\n            int prime2 = primeGen.nextPrime();\n            int frobenius = prime1 * prime2 - prime1 - prime2;\n            if (frobenius >= limit)\n                break;\n            System.out.printf(\"%6d%c%c\", frobenius,\n                    isPrime(frobenius) ? '*' : ' ',\n                    count % 10 == 0 ? '\\n' : ' ');\n            prime1 = prime2;\n        }\n        System.out.println();\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 404517, "name": "Frobenius numbers", "source": "Translate Haskell to Java: primes = 2 : sieve [3,5..]\n  where sieve (x:xs) = x : sieve (filter (\\y -> y `mod` x /= 0) xs)\n\nfrobenius = zipWith (\\a b -> a*b - a - b) primes (tail primes)\n", "target": "public class Frobenius {\n    public static void main(String[] args) {\n        final int limit = 1000000;\n        System.out.printf(\"Frobenius numbers less than %d (asterisk marks primes):\\n\", limit);\n        PrimeGenerator primeGen = new PrimeGenerator(1000, 100000);\n        int prime1 = primeGen.nextPrime();\n        for (int count = 1; ; ++count) {\n            int prime2 = primeGen.nextPrime();\n            int frobenius = prime1 * prime2 - prime1 - prime2;\n            if (frobenius >= limit)\n                break;\n            System.out.printf(\"%6d%c%c\", frobenius,\n                    isPrime(frobenius) ? '*' : ' ',\n                    count % 10 == 0 ? '\\n' : ' ');\n            prime1 = prime2;\n        }\n        System.out.println();\n    }\n\n    private static boolean isPrime(int n) {\n        if (n < 2)\n            return false;\n        if (n % 2 == 0)\n            return n == 2;\n        if (n % 3 == 0)\n            return n == 3;\n        for (int p = 5; p * p <= n; p += 4) {\n            if (n % p == 0)\n                return false;\n            p += 2;\n            if (n % p == 0)\n                return false;\n        }\n        return true;\n    }\n}\n"}
{"id": 404518, "name": "Sorting algorithms_Permutation sort", "source": "Translate Haskell to Java: import Control.Monad\n\npermutationSort l = head [p | p <- permute l, sorted p]\n\nsorted (e1 : e2 : r) = e1 <= e2 && sorted (e2 : r)\nsorted _             = True\n\npermute              = foldM (flip insert) []\n\ninsert e []          = return [e]\ninsert e l@(h : t)   = return (e : l) `mplus`\n                       do { t' <- insert e t ; return (h : t') }\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class PermutationSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tint[] a={3,2,1,8,9,4,6};\n\t\tSystem.out.println(\"Unsorted: \" + Arrays.toString(a));\n\t\ta=pSort(a);\n\t\tSystem.out.println(\"Sorted: \" + Arrays.toString(a));\n\t}\n\tpublic static int[] pSort(int[] a)\n\t{\n\t\tList<int[]> list=new ArrayList<int[]>();\n\t\tpermute(a,a.length,list);\n\t\tfor(int[] x : list)\n\t\t\tif(isSorted(x))\n\t\t\t\treturn x;\n\t\treturn a;\n\t}\n\tprivate static void permute(int[] a, int n, List<int[]> list) \n\t{\n\t\tif (n == 1) \n\t\t{\n\t\t\tint[] b=new int[a.length];\n\t\t\tSystem.arraycopy(a, 0, b, 0, a.length);\n\t\t\tlist.add(b);\n\t\t    return;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) \n\t\t{\n\t\t        swap(a, i, n-1);\n\t\t        permute(a, n-1, list);\n\t\t        swap(a, i, n-1);\n\t\t }\n\t}\n\tprivate static boolean isSorted(int[] a)\n\t{\n\t\tfor(int i=1;i<a.length;i++)\n\t\t\tif(a[i-1]>a[i])\n\t\t\t\treturn false;\n\t\treturn true;\n\t}\n\tprivate static void swap(int[] arr,int i, int j)\n\t{\n\t\tint temp=arr[i];\n\t\tarr[i]=arr[j];\n\t\tarr[j]=temp;\n\t}\n}\n"}
{"id": 404519, "name": "Integer roots", "source": "Translate Haskell to Java: root :: Integer -> Integer -> Integer\nroot a b = findAns $ iterate (\\x -> (a1 * x + b `div` (x ^ a1)) `div` a) 1\n  where\n    a1 = a - 1\n    findAns (x:xs@(y:z:_))\n      | x == y || x == z = min y z\n      | otherwise = findAns xs\n\nmain :: IO ()\nmain = do\n  print $ root 3 8\n  print $ root 3 9\n  print $ root 2 (2 * 100 ^ 2000) \n", "target": "import java.math.BigInteger;\n\npublic class IntegerRoots {\n    private static BigInteger iRoot(BigInteger base, int n) {\n        if (base.compareTo(BigInteger.ZERO) < 0 || n <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        int n1 = n - 1;\n        BigInteger n2 = BigInteger.valueOf(n);\n        BigInteger n3 = BigInteger.valueOf(n1);\n        BigInteger c = BigInteger.ONE;\n        BigInteger d = n3.add(base).divide(n2);\n        BigInteger e = n3.multiply(d).add(base.divide(d.pow(n1))).divide(n2);\n        while (!c.equals(d) && !c.equals(e)) {\n            c = d;\n            d = e;\n            e = n3.multiply(e).add(base.divide(e.pow(n1))).divide(n2);\n        }\n        if (d.compareTo(e) < 0) {\n            return d;\n        }\n        return e;\n    }\n\n    public static void main(String[] args) {\n        BigInteger b = BigInteger.valueOf(8);\n        System.out.print(\"3rd integer root of 8 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(9);\n        System.out.print(\"3rd integer root of 9 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(100).pow(2000).multiply(BigInteger.valueOf(2));\n        System.out.print(\"First 2001 digits of the square root of 2: \");\n        System.out.println(iRoot(b, 2));\n    }\n}\n"}
{"id": 404520, "name": "Integer roots", "source": "Translate Haskell to Java: root :: Integer -> Integer -> Integer\nroot a b = findAns $ iterate (\\x -> (a1 * x + b `div` (x ^ a1)) `div` a) 1\n  where\n    a1 = a - 1\n    findAns (x:xs@(y:z:_))\n      | x == y || x == z = min y z\n      | otherwise = findAns xs\n\nmain :: IO ()\nmain = do\n  print $ root 3 8\n  print $ root 3 9\n  print $ root 2 (2 * 100 ^ 2000) \n", "target": "import java.math.BigInteger;\n\npublic class IntegerRoots {\n    private static BigInteger iRoot(BigInteger base, int n) {\n        if (base.compareTo(BigInteger.ZERO) < 0 || n <= 0) {\n            throw new IllegalArgumentException();\n        }\n\n        int n1 = n - 1;\n        BigInteger n2 = BigInteger.valueOf(n);\n        BigInteger n3 = BigInteger.valueOf(n1);\n        BigInteger c = BigInteger.ONE;\n        BigInteger d = n3.add(base).divide(n2);\n        BigInteger e = n3.multiply(d).add(base.divide(d.pow(n1))).divide(n2);\n        while (!c.equals(d) && !c.equals(e)) {\n            c = d;\n            d = e;\n            e = n3.multiply(e).add(base.divide(e.pow(n1))).divide(n2);\n        }\n        if (d.compareTo(e) < 0) {\n            return d;\n        }\n        return e;\n    }\n\n    public static void main(String[] args) {\n        BigInteger b = BigInteger.valueOf(8);\n        System.out.print(\"3rd integer root of 8 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(9);\n        System.out.print(\"3rd integer root of 9 = \");\n        System.out.println(iRoot(b, 3));\n\n        b = BigInteger.valueOf(100).pow(2000).multiply(BigInteger.valueOf(2));\n        System.out.print(\"First 2001 digits of the square root of 2: \");\n        System.out.println(iRoot(b, 2));\n    }\n}\n"}
{"id": 404521, "name": "Modulinos", "source": "Translate Haskell to Java: #!/usr/bin/env runhaskell\n\n\n\n\n\nmodule ScriptedMain where\n\nmeaningOfLife :: Int\nmeaningOfLife = 42\n\nmain :: IO ()\nmain = putStrLn $ \"Main: The meaning of life is \" ++ show meaningOfLife\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 404522, "name": "Modulinos", "source": "Translate Haskell to Java: #!/usr/bin/env runhaskell\n\n\n\n\n\nmodule ScriptedMain where\n\nmeaningOfLife :: Int\nmeaningOfLife = 42\n\nmain :: IO ()\nmain = putStrLn $ \"Main: The meaning of life is \" ++ show meaningOfLife\n", "target": "public class ScriptedMain {\n\tpublic static int meaningOfLife() {\n\t\treturn 42;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(\"Main: The meaning of life is \" + meaningOfLife());\n\t}\n}\n"}
{"id": 404523, "name": "Nice primes", "source": "Translate Haskell to Java: import Data.Char ( digitToInt ) \n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ndigitsum :: Int -> Int\ndigitsum n = sum $ map digitToInt $ show n\n\nfindSumn :: Int -> Int\nfindSumn n = until ( (== 1) . length . show ) digitsum n\n\nisNicePrime :: Int -> Bool\nisNicePrime n = isPrime n && isPrime ( findSumn n ) \n\nsolution :: [Int]\nsolution = filter isNicePrime [501..999]\n", "target": "public class NicePrimes {\n    private static boolean isPrime(long n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n % 2 == 0L) {\n            return n == 2L;\n        }\n        if (n % 3 == 0L) {\n            return n == 3L;\n        }\n\n        var p = 5L;\n        while (p * p <= n) {\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 2;\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 4;\n        }\n        return true;\n    }\n\n    private static long digitalRoot(long n) {\n        if (n == 0) {\n            return 0;\n        }\n        return 1 + (n - 1) % 9;\n    }\n\n    public static void main(String[] args) {\n        final long from = 500;\n        final long to = 1000;\n        int count = 0;\n\n        System.out.printf(\"Nice primes between %d and %d%n\", from, to);\n        long n = from;\n        while (n < to) {\n            if (isPrime(digitalRoot(n)) && isPrime(n)) {\n                count++;\n                System.out.print(n);\n                if (count % 10 == 0) {\n                    System.out.println();\n                } else {\n                    System.out.print(' ');\n                }\n            }\n\n            n++;\n        }\n        System.out.println();\n        System.out.printf(\"%d nice primes found.%n\", count);\n    }\n}\n"}
{"id": 404524, "name": "Nice primes", "source": "Translate Haskell to Java: import Data.Char ( digitToInt ) \n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ndigitsum :: Int -> Int\ndigitsum n = sum $ map digitToInt $ show n\n\nfindSumn :: Int -> Int\nfindSumn n = until ( (== 1) . length . show ) digitsum n\n\nisNicePrime :: Int -> Bool\nisNicePrime n = isPrime n && isPrime ( findSumn n ) \n\nsolution :: [Int]\nsolution = filter isNicePrime [501..999]\n", "target": "public class NicePrimes {\n    private static boolean isPrime(long n) {\n        if (n < 2) {\n            return false;\n        }\n        if (n % 2 == 0L) {\n            return n == 2L;\n        }\n        if (n % 3 == 0L) {\n            return n == 3L;\n        }\n\n        var p = 5L;\n        while (p * p <= n) {\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 2;\n            if (n % p == 0L) {\n                return false;\n            }\n            p += 4;\n        }\n        return true;\n    }\n\n    private static long digitalRoot(long n) {\n        if (n == 0) {\n            return 0;\n        }\n        return 1 + (n - 1) % 9;\n    }\n\n    public static void main(String[] args) {\n        final long from = 500;\n        final long to = 1000;\n        int count = 0;\n\n        System.out.printf(\"Nice primes between %d and %d%n\", from, to);\n        long n = from;\n        while (n < to) {\n            if (isPrime(digitalRoot(n)) && isPrime(n)) {\n                count++;\n                System.out.print(n);\n                if (count % 10 == 0) {\n                    System.out.println();\n                } else {\n                    System.out.print(' ');\n                }\n            }\n\n            n++;\n        }\n        System.out.println();\n        System.out.printf(\"%d nice primes found.%n\", count);\n    }\n}\n"}
{"id": 404525, "name": "Find the last Sunday of each month", "source": "Translate Haskell to Java: import Data.List (find, intercalate, transpose)\nimport Data.Maybe (fromJust)\nimport Data.Time.Calendar\n  ( Day,\n    addDays,\n    fromGregorian,\n    gregorianMonthLength,\n    showGregorian,\n  )\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\n\n\nlastSundayOfEachMonth = lastWeekDayDates 7\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    ( intercalate \"  \"\n        <$> transpose\n          (lastSundayOfEachMonth <$> [2013 .. 2017])\n    )\n\n\n\nlastWeekDayDates :: Int -> Integer -> [String]\nlastWeekDayDates dayOfWeek year =\n  (showGregorian . mostRecentWeekday dayOfWeek)\n    . (fromGregorian year <*> gregorianMonthLength year)\n    <$> [1 .. 12]\n\nmostRecentWeekday :: Int -> Day -> Day\nmostRecentWeekday dayOfWeek date =\n  fromJust\n    (find p ((`addDays` date) <$> [-6 .. 0]))\n  where\n    p x =\n      let (_, _, day) = toWeekDate x\n       in dayOfWeek == day\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 404526, "name": "Find the last Sunday of each month", "source": "Translate Haskell to Java: import Data.List (find, intercalate, transpose)\nimport Data.Maybe (fromJust)\nimport Data.Time.Calendar\n  ( Day,\n    addDays,\n    fromGregorian,\n    gregorianMonthLength,\n    showGregorian,\n  )\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\n\n\nlastSundayOfEachMonth = lastWeekDayDates 7\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    ( intercalate \"  \"\n        <$> transpose\n          (lastSundayOfEachMonth <$> [2013 .. 2017])\n    )\n\n\n\nlastWeekDayDates :: Int -> Integer -> [String]\nlastWeekDayDates dayOfWeek year =\n  (showGregorian . mostRecentWeekday dayOfWeek)\n    . (fromGregorian year <*> gregorianMonthLength year)\n    <$> [1 .. 12]\n\nmostRecentWeekday :: Int -> Day -> Day\nmostRecentWeekday dayOfWeek date =\n  fromJust\n    (find p ((`addDays` date) <$> [-6 .. 0]))\n  where\n    p x =\n      let (_, _, day) = toWeekDate x\n       in dayOfWeek == day\n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 404527, "name": "Random Latin squares", "source": "Translate Haskell to Java: import Data.List (permutations, (\\\\))\n\nlatinSquare :: Eq a => [a] -> [a] -> [[a]]\nlatinSquare [] [] = []\nlatinSquare c r\n  | head r /= head c = []\n  | otherwise = reverse <$> foldl addRow firstRow perms\n  where\n    \n    perms =\n      tail $\n        fmap\n          (fmap . (:) <*> (permutations . (r \\\\) . return))\n          c\n    firstRow = pure <$> r\n    addRow tbl rows =\n      head\n        [ zipWith (:) row tbl\n          | row <- rows,\n            and $ different (tail row) (tail tbl)\n        ]\n    different = zipWith $ (not .) . elem\n\nprintTable :: Show a => [[a]] -> IO ()\nprintTable tbl =\n  putStrLn $\n    unlines $\n      unwords . map show <$> tbl\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\n\npublic class RandomLatinSquares {\n    private static void printSquare(List<List<Integer>> latin) {\n        for (List<Integer> row : latin) {\n            Iterator<Integer> it = row.iterator();\n\n            System.out.print(\"[\");\n            if (it.hasNext()) {\n                Integer col = it.next();\n                System.out.print(col);\n            }\n            while (it.hasNext()) {\n                Integer col = it.next();\n                System.out.print(\", \");\n                System.out.print(col);\n            }\n            System.out.println(\"]\");\n        }\n        System.out.println();\n    }\n\n    private static void latinSquare(int n) {\n        if (n <= 0) {\n            System.out.println(\"[]\");\n            return;\n        }\n\n        List<List<Integer>> latin = new ArrayList<>(n);\n        for (int i = 0; i < n; ++i) {\n            List<Integer> inner = new ArrayList<>(n);\n            for (int j = 0; j < n; ++j) {\n                inner.add(j);\n            }\n            latin.add(inner);\n        }\n        \n        Collections.shuffle(latin.get(0));\n\n        \n        for (int i = 1; i < n - 1; ++i) {\n            boolean shuffled = false;\n            shuffling:\n            while (!shuffled) {\n                Collections.shuffle(latin.get(i));\n                for (int k = 0; k < i; ++k) {\n                    for (int j = 0; j < n; ++j) {\n                        if (Objects.equals(latin.get(k).get(j), latin.get(i).get(j))) {\n                            continue shuffling;\n                        }\n                    }\n                }\n                shuffled = true;\n            }\n        }\n\n        \n        for (int j = 0; j < n; ++j) {\n            List<Boolean> used = new ArrayList<>(n);\n            for (int i = 0; i < n; ++i) {\n                used.add(false);\n            }\n            for (int i = 0; i < n - 1; ++i) {\n                used.set(latin.get(i).get(j), true);\n            }\n            for (int k = 0; k < n; ++k) {\n                if (!used.get(k)) {\n                    latin.get(n - 1).set(j, k);\n                    break;\n                }\n            }\n        }\n\n        printSquare(latin);\n    }\n\n    public static void main(String[] args) {\n        latinSquare(5);\n        latinSquare(5);\n        latinSquare(10);\n    }\n}\n"}
{"id": 404528, "name": "Teacup rim text", "source": "Translate Haskell to Java: import Data.List (groupBy, intercalate, sort, sortBy)\nimport qualified Data.Set as S\nimport Data.Ord (comparing)\nimport Data.Function (on)\n\nmain :: IO ()\nmain =\n  readFile \"mitWords.txt\" >>= (putStrLn . showGroups . circularWords . lines)\n\ncircularWords :: [String] -> [String]\ncircularWords ws =\n  let lexicon = S.fromList ws\n  in filter (isCircular lexicon) ws\n\nisCircular :: S.Set String -> String -> Bool\nisCircular lex w = 2 < length w && all (`S.member` lex) (rotations w)\n\nrotations :: [a] -> [[a]]\nrotations = fmap <$> rotated <*> (enumFromTo 0 . pred . length)\n\nrotated :: [a] -> Int -> [a]\nrotated [] _ = []\nrotated xs n = zipWith const (drop n (cycle xs)) xs\n\nshowGroups :: [String] -> String\nshowGroups xs =\n  unlines $\n  intercalate \" -> \" . fmap snd <$>\n  filter\n    ((1 <) . length)\n    (groupBy (on (==) fst) (sortBy (comparing fst) (((,) =<< sort) <$> xs)))\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class Teacup {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"usage: java Teacup dictionary\");\n            System.exit(1);\n        }\n        try {\n            findTeacupWords(loadDictionary(args[0]));\n        } catch (Exception ex) {\n            System.err.println(ex.getMessage());\n        }\n    }\n\n    \n    private static Set<String> loadDictionary(String fileName) throws IOException {\n        Set<String> words = new TreeSet<>();\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            String word;\n            while ((word = reader.readLine()) != null)\n                words.add(word);\n            return words;\n        }\n    }\n\n    private static void findTeacupWords(Set<String> words) {\n        List<String> teacupWords = new ArrayList<>();\n        Set<String> found = new HashSet<>();\n        for (String word : words) {\n            int len = word.length();\n            if (len < 3 || found.contains(word))\n                continue;\n            teacupWords.clear();\n            teacupWords.add(word);\n            char[] chars = word.toCharArray();\n            for (int i = 0; i < len - 1; ++i) {\n                String rotated = new String(rotate(chars));\n                if (rotated.equals(word) || !words.contains(rotated))\n                    break;\n                teacupWords.add(rotated);\n            }\n            if (teacupWords.size() == len) {\n                found.addAll(teacupWords);\n                System.out.print(word);\n                for (int i = 1; i < len; ++i)\n                    System.out.print(\" \" + teacupWords.get(i));\n                System.out.println();\n            }\n        }\n    }\n\n    private static char[] rotate(char[] ch) {\n        char c = ch[0];\n        System.arraycopy(ch, 1, ch, 0, ch.length - 1);\n        ch[ch.length - 1] = c;\n        return ch;\n    }\n}\n"}
{"id": 404529, "name": "Fairshare between two and more", "source": "Translate Haskell to Java: import Data.Bool (bool)\nimport Data.List (intercalate, unfoldr)\nimport Data.Tuple (swap)\n\n\n\nthueMorse :: Int -> [Int]\nthueMorse base = baseDigitsSumModBase base <$> [0 ..]\n\nbaseDigitsSumModBase :: Int -> Int -> Int\nbaseDigitsSumModBase base n =\n  mod\n    ( sum $\n        unfoldr\n          ( bool Nothing\n              . Just\n              . swap\n              . flip quotRem base\n              <*> (0 <)\n          )\n          n\n    )\n    base\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    fTable\n      ( \"First 25 fairshare terms \"\n          <> \"for a given number of players:\\n\"\n      )\n      show\n      ( ('[' :) . (<> \"]\") . intercalate \",\"\n          . fmap show\n      )\n      (take 25 . thueMorse)\n      [2, 3, 5, 11]\n\n\nfTable ::\n  String ->\n  (a -> String) ->\n  (b -> String) ->\n  (a -> b) ->\n  [a] ->\n  String\nfTable s xShow fxShow f xs =\n  unlines $\n    s :\n    fmap\n      ( ((<>) . justifyRight w ' ' . xShow)\n          <*> ((\" -> \" <>) . fxShow . f)\n      )\n      xs\n  where\n    w = maximum (length . xShow <$> xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class FairshareBetweenTwoAndMore {\n\n    public static void main(String[] args) {\n        for ( int base : Arrays.asList(2, 3, 5, 11) ) {\n            System.out.printf(\"Base %d = %s%n\", base, thueMorseSequence(25, base));\n        }\n    }\n    \n    private static List<Integer> thueMorseSequence(int terms, int base) {\n        List<Integer> sequence = new ArrayList<Integer>();\n        for ( int i = 0 ; i < terms ; i++ ) {\n            int sum = 0;\n            int n = i;\n            while ( n > 0 ) {\n                \n                sum += n % base;\n                n /= base;\n            }\n            \n            sequence.add(sum % base);\n        }\n        return sequence;\n    }\n\n}\n"}
{"id": 404530, "name": "Esthetic numbers", "source": "Translate Haskell to Java: import Data.List (unfoldr, genericIndex)\nimport Control.Monad (replicateM, foldM, mzero)\n\n\nisEsthetic b = all ((== 1) . abs) . differences . toBase b\n  where\n    differences lst = zipWith (-) lst (tail lst)\n\n\nesthetics_m b =\n  do differences <- (\\n -> replicateM n [-1, 1]) <$> [0..]\n     firstDigit <- [1..b-1]\n     differences >>= fromBase b <$> scanl (+) firstDigit\n\n\n\nesthetics b = tail $ fst <$> iterate step (undefined, q)\n  where\n    q = [(d, d) | d <- [1..b-1]]\n    step (_, queue) =\n      let (num, lsd) = head queue\n          new_lsds = [d | d <- [lsd-1, lsd+1], d < b, d >= 0]\n      in (num, tail queue ++ [(num*b + d, d) | d <- new_lsds])\n\n\nfromBase b = foldM f 0\n  where f r d | d < 0 || d >= b = mzero\n              | otherwise = pure (r*b + d)\n\ntoBase b = reverse . unfoldr f\n  where\n    f 0 = Nothing\n    f n = let (q, r) = divMod n b in Just (r, q)\n\nshowInBase b = foldMap (pure . digit) . toBase b\n  where digit = genericIndex (['0'..'9'] <> ['a'..'z'])\n", "target": "import java.util.ArrayList;\nimport java.util.stream.IntStream;\nimport java.util.stream.LongStream;\n\npublic class EstheticNumbers {\n    interface RecTriConsumer<A, B, C> {\n        void accept(RecTriConsumer<A, B, C> f, A a, B b, C c);\n    }\n\n    private static boolean isEsthetic(long n, long b) {\n        if (n == 0) {\n            return false;\n        }\n        var i = n % b;\n        var n2 = n / b;\n        while (n2 > 0) {\n            var j = n2 % b;\n            if (Math.abs(i - j) != 1) {\n                return false;\n            }\n            n2 /= b;\n            i = j;\n        }\n        return true;\n    }\n\n    private static void listEsths(long n, long n2, long m, long m2, int perLine, boolean all) {\n        var esths = new ArrayList<Long>();\n        var dfs = new RecTriConsumer<Long, Long, Long>() {\n            public void accept(Long n, Long m, Long i) {\n                accept(this, n, m, i);\n            }\n\n            @Override\n            public void accept(RecTriConsumer<Long, Long, Long> f, Long n, Long m, Long i) {\n                if (n <= i && i <= m) {\n                    esths.add(i);\n                }\n                if (i == 0 || i > m) {\n                    return;\n                }\n                var d = i % 10;\n                var i1 = i * 10 + d - 1;\n                var i2 = i1 + 2;\n                if (d == 0) {\n                    f.accept(f, n, m, i2);\n                } else if (d == 9) {\n                    f.accept(f, n, m, i1);\n                } else {\n                    f.accept(f, n, m, i1);\n                    f.accept(f, n, m, i2);\n                }\n            }\n        };\n\n        LongStream.range(0, 10).forEach(i -> dfs.accept(n2, m2, i));\n\n        var le = esths.size();\n        System.out.printf(\"Base 10: %d esthetic numbers between %d and %d:%n\", le, n, m);\n        if (all) {\n            for (int i = 0; i < esths.size(); i++) {\n                System.out.printf(\"%d \", esths.get(i));\n                if ((i + 1) % perLine == 0) {\n                    System.out.println();\n                }\n            }\n        } else {\n            for (int i = 0; i < perLine; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n            System.out.println();\n            System.out.println(\"............\");\n            for (int i = le - perLine; i < le; i++) {\n                System.out.printf(\"%d \", esths.get(i));\n            }\n        }\n        System.out.println();\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        IntStream.rangeClosed(2, 16).forEach(b -> {\n            System.out.printf(\"Base %d: %dth to %dth esthetic numbers:%n\", b, 4 * b, 6 * b);\n            var n = 1L;\n            var c = 0L;\n            while (c < 6 * b) {\n                if (isEsthetic(n, b)) {\n                    c++;\n                    if (c >= 4 * b) {\n                        System.out.printf(\"%s \", Long.toString(n, b));\n                    }\n                }\n                n++;\n            }\n            System.out.println();\n        });\n        System.out.println();\n\n        \n        listEsths(1000, 1010, 9999, 9898, 16, true);\n        listEsths((long) 1e8, 101_010_101, 13 * (long) 1e7, 123_456_789, 9, true);\n        listEsths((long) 1e11, 101_010_101_010L, 13 * (long) 1e10, 123_456_789_898L, 7, false);\n        listEsths((long) 1e14, 101_010_101_010_101L, 13 * (long) 1e13, 123_456_789_898_989L, 5, false);\n        listEsths((long) 1e17, 101_010_101_010_101_010L, 13 * (long) 1e16, 123_456_789_898_989_898L, 4, false);\n    }\n}\n"}
{"id": 404531, "name": "Permutations by swapping", "source": "Translate Haskell to Java: sPermutations :: [a] -> [([a], Int)]\nsPermutations = flip zip (cycle [-1, 1]) . foldr aux [[]]\n  where\n    aux x items = do\n      (f, item) <- zip (repeat id) items\n      f (insertEv x item)\n    insertEv x [] = [[x]]\n    insertEv x l@(y:ys) = (x : l) : ((y :) <$> insertEv x ys)\n\nmain :: IO ()\nmain = do\n  putStrLn \"3 items:\"\n  mapM_ print $ sPermutations [1 .. 3]\n  putStrLn \"\\n4 items:\"\n  mapM_ print $ sPermutations [1 .. 4]\n", "target": "package org.rosettacode.java;\n\nimport java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class HeapsAlgorithm {\n\n\tpublic static void main(String[] args) {\n\t\tObject[] array = IntStream.range(0, 4)\n\t\t\t\t.boxed()\n\t\t\t\t.toArray();\n\t\tHeapsAlgorithm algorithm = new HeapsAlgorithm();\n\t\talgorithm.recursive(array);\n\t\tSystem.out.println();\n\t\talgorithm.loop(array);\n\t}\n\n\tvoid recursive(Object[] array) {\n\t\trecursive(array, array.length, true);\n\t}\n\n\tvoid recursive(Object[] array, int n, boolean plus) {\n\t\tif (n == 1) {\n\t\t\toutput(array, plus);\n\t\t} else {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\trecursive(array, n - 1, i == 0);\n\t\t\t\tswap(array, n % 2 == 0 ? i : 0, n - 1);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid output(Object[] array, boolean plus) {\n\t\tSystem.out.println(Arrays.toString(array) + (plus ? \" +1\" : \" -1\"));\n\t}\n\n\tvoid swap(Object[] array, int a, int b) {\n\t\tObject o = array[a];\n\t\tarray[a] = array[b];\n\t\tarray[b] = o;\n\t}\n\n\tvoid loop(Object[] array) {\n\t\tloop(array, array.length);\n\t}\n\n\tvoid loop(Object[] array, int n) {\n\t\tint[] c = new int[n];\n\t\toutput(array, true);\n\t\tboolean plus = false;\n\t\tfor (int i = 0; i < n; ) {\n\t\t\tif (c[i] < i) {\n\t\t\t\tif (i % 2 == 0) {\n\t\t\t\t\tswap(array, 0, i);\n\t\t\t\t} else {\n\t\t\t\t\tswap(array, c[i], i);\n\t\t\t\t}\n\t\t\t\toutput(array, plus);\n\t\t\t\tplus = !plus;\n\t\t\t\tc[i]++;\n\t\t\t\ti = 0;\n\t\t\t} else {\n\t\t\t\tc[i] = 0;\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n"}
{"id": 404532, "name": "RPG attributes generator", "source": "Translate Haskell to Java: import Control.Monad (replicateM)\nimport System.Random (randomRIO)\nimport Data.Bool (bool)\nimport Data.List (sort)\n\ncharacter :: IO [Int]\ncharacter =\n  discardUntil\n    (((&&) . (75 <) . sum) <*> ((2 <=) . length . filter (15 <=)))\n    (replicateM 6 $ sum . tail . sort <$> replicateM 4 (randomRIO (1, 6 :: Int)))\n\ndiscardUntil :: ([Int] -> Bool) -> IO [Int] -> IO [Int]\ndiscardUntil p throw = go\n  where\n    go = throw >>= (<*>) (bool go . return) p\n\n\nmain :: IO ()\nmain = replicateM 10 character >>= mapM_ (print . (sum >>= (,)))\n", "target": "import java.util.List;\nimport java.util.Random;\nimport java.util.stream.Stream;\n\nimport static java.util.stream.Collectors.toList;\n\npublic class Rpg {\n\n    private static final Random random = new Random();\n \n    public static int genAttribute() {\n        return random.ints(1, 6 + 1) \n            .limit(4) \n            .sorted() \n            .limit(3) \n            .sum();   \n    }\n \n    public static void main(String[] args) {\n        while (true) {\n            List<Integer> stats =\n                Stream.generate(Rpg::genAttribute) \n                    .limit(6) \n                    .collect(toList()); \n            int sum = stats.stream().mapToInt(Integer::intValue).sum();\n            long count = stats.stream().filter(v -> v >= 15).count();\n            if (count >= 2 && sum >= 75) {\n                System.out.printf(\"The 6 random numbers generated are: %s\\n\", stats);\n                System.out.printf(\"Their sum is %s and %s of them are >= 15\\n\", sum, count);\n                return;\n            }      \n        }\n    }\n}\n"}
{"id": 404533, "name": "Kolakoski sequence", "source": "Translate Haskell to Java: import Data.List (group)\nimport Control.Monad (forM_)\n\nreplicateAtLeastOne :: Int -> a -> [a]\nreplicateAtLeastOne n x = x : replicate (n-1) x\n\nzipWithLazy :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWithLazy f ~(x:xs) ~(y:ys) = f x y : zipWithLazy f xs ys\n\nkolakoski :: [Int] -> [Int]\nkolakoski items = s\n  where s = concat $ zipWithLazy replicateAtLeastOne s $ cycle items\n\nrle :: Eq a => [a] -> [Int]\nrle = map length . group\n\nsameAsRleUpTo :: Int -> [Int] -> Bool\nsameAsRleUpTo n s = r == take (length r) prefix\n  where prefix = take n s\n        r = init $ rle prefix\n\nmain :: IO ()\nmain = forM_ [([1, 2], 20),\n              ([2, 1], 20), \n              ([1, 3, 1, 2], 30),\n              ([1, 3, 2, 1], 30)]\n        $ \\(items, n) -> do\n          putStrLn $ \"First \" ++ show n ++ \" members of the sequence generated by \" ++ show items ++ \":\"\n          let s = kolakoski items\n          print $ take n s\n          putStrLn $ \"Possible Kolakoski sequence? \" ++ show (sameAsRleUpTo n s)\n          putStrLn \"\"\n", "target": "import java.util.Arrays;\n\npublic class Kolakoski {\n    private static class Crutch {\n        final int len;\n        int[] s;\n        int i;\n\n        Crutch(int len) {\n            this.len = len;\n            s = new int[len];\n            i = 0;\n        }\n\n        void repeat(int count) {\n            for (int j = 0; j < count; j++) {\n                if (++i == len) return;\n                s[i] = s[i - 1];\n            }\n        }\n    }\n\n    private static int nextInCycle(final int[] self, int index) {\n        return self[index % self.length];\n    }\n\n    private static int[] kolakoski(final int[] self, int len) {\n        Crutch c = new Crutch(len);\n\n        int k = 0;\n        while (c.i < len) {\n            c.s[c.i] = nextInCycle(self, k);\n            if (c.s[k] > 1) {\n                c.repeat(c.s[k] - 1);\n            }\n            if (++c.i == len) return c.s;\n            k++;\n        }\n        return c.s;\n    }\n\n    private static boolean possibleKolakoski(final int[] self) {\n        int[] rle = new int[self.length];\n        int prev = self[0];\n        int count = 1;\n        int pos = 0;\n        for (int i = 1; i < self.length; i++) {\n            if (self[i] == prev) {\n                count++;\n            } else {\n                rle[pos++] = count;\n                count = 1;\n                prev = self[i];\n            }\n        }\n        \n        for (int i = 0; i < pos; i++) {\n            if (rle[i] != self[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int[][] ias = new int[][]{\n            new int[]{1, 2},\n            new int[]{2, 1},\n            new int[]{1, 3, 1, 2},\n            new int[]{1, 3, 2, 1}\n        };\n        int[] lens = new int[]{20, 20, 30, 30};\n\n        for (int i=0; i<ias.length; i++) {\n            int len = lens[i];\n            int[] kol = kolakoski(ias[i], len);\n\n            System.out.printf(\"First %d members of the sequence generated by %s: \\n\", len, Arrays.toString(ias[i]));\n            System.out.printf(\"%s\\n\", Arrays.toString(kol));\n            System.out.printf(\"Possible Kolakoski sequence? %s\\n\\n\", possibleKolakoski(kol));\n        }\n    }\n}\n"}
{"id": 404534, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Haskell to Java: import Data.List (find, group, sort)\nimport Data.Maybe (mapMaybe)\nimport Data.Numbers.Primes (primeFactors)\n\n\n\na005179 :: [Int]\na005179 =\n  mapMaybe\n    ( \\n ->\n        find\n          ((n ==) . succ . length . properDivisors)\n          [1 ..]\n    )\n    [1 ..]\n\n\nmain :: IO ()\nmain = print $ take 15 a005179\n\n\n\nproperDivisors :: Int -> [Int]\nproperDivisors =\n  init\n    . sort\n    . foldr\n      (flip ((<*>) . fmap (*)) . scanl (*) 1)\n      [1]\n    . group\n    . primeFactors\n", "target": "import java.util.Arrays;\n\npublic class OEIS_A005179 {\n\n    static int count_divisors(int n) {\n        int count = 0;\n        for (int i = 1; i * i <= n; ++i) {\n            if (n % i == 0) {\n                if (i == n / i)\n                    count++;\n                else\n                    count += 2;\n            }\n        }\n        return count;\n    }\n\n    public static void main(String[] args) {\n        final int max = 15;\n        int[] seq = new int[max];\n        System.out.printf(\"The first %d terms of the sequence are:\\n\", max);\n        for (int i = 1, n = 0; n < max; ++i) {\n            int k = count_divisors(i);\n            if (k <= max && seq[k - 1] == 0) {        \n                seq[k- 1] = i;\n                n++;\n            }\n        }\n        System.out.println(Arrays.toString(seq));\n    }\n}\n"}
{"id": 404535, "name": "Sparkline in unicode", "source": "Translate Haskell to Java: import Data.List.Split (splitOneOf)\nimport Data.Char (chr)\n\n\ntoSparkLine :: [Double] -> String\ntoSparkLine xs = map cl xs\n  where\n    top = maximum xs\n    bot = minimum xs\n    range = top - bot\n    cl x = chr $ 0x2581 + floor (min 7 ((x - bot) / range * 8))\n\nmakeSparkLine :: String -> (String, Stats)\nmakeSparkLine xs = (toSparkLine parsed, stats parsed)\n  where\n    parsed = map read $ filter (not . null) $ splitOneOf \" ,\" xs\n\ndata Stats = Stats\n  { minValue, maxValue, rangeOfValues :: Double\n  , numberOfValues :: Int\n  }\n\ninstance Show Stats where\n  show (Stats mn mx r n) =\n    \"min: \" ++\n    show mn ++\n    \"; max: \" ++\n    show mx ++ \"; range: \" ++ show r ++ \"; no. of values: \" ++ show n\n\nstats :: [Double] -> Stats\nstats xs =\n  Stats\n  { minValue = mn\n  , maxValue = mx\n  , rangeOfValues = mx - mn\n  , numberOfValues = length xs\n  }\n  where\n    mn = minimum xs\n    mx = maximum xs\n\ndrawSparkLineWithStats :: String -> IO ()\ndrawSparkLineWithStats xs = putStrLn sp >> print st\n  where\n    (sp, st) = makeSparkLine xs\n\nmain :: IO ()\nmain =\n  mapM_\n    drawSparkLineWithStats\n    [ \"0, 1, 19, 20\"\n    , \"0, 999, 4000, 4999, 7000, 7999\"\n    , \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\"\n    , \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\"\n    , \"3 2 1 0 -1 -2 -3 -4 -3 -2 -1 0 1 2 3\"\n    , \"-1000 100 1000 500 200 -400 -700 621 -189 3\"\n    ]\n", "target": "public class Sparkline \n{\n\tString bars=\"\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588\";\n\tpublic static void main(String[] args)\n\t{\n\t\tSparkline now=new Sparkline();\n\t\tfloat[] arr={1, 2, 3, 4, 5, 6, 7, 8, 7, 6, 5, 4, 3, 2, 1};\n\t\tnow.display1D(arr);\n\t\tSystem.out.println(now.getSparkline(arr));\n\t\tfloat[] arr1={1.5f, 0.5f, 3.5f, 2.5f, 5.5f, 4.5f, 7.5f, 6.5f};\n\t\tnow.display1D(arr1);\n\t\tSystem.out.println(now.getSparkline(arr1));\n\t}\n\tpublic void display1D(float[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tpublic String getSparkline(float[] arr)\n\t{\n\t\tfloat min=Integer.MAX_VALUE;\n\t\tfloat max=Integer.MIN_VALUE;\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tif(arr[i]<min)\n\t\t\t\tmin=arr[i];\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t}\n\t\tfloat range=max-min;\n\t\tint num=bars.length()-1;\n\t\tString line=\"\";\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\t\n\t\t\tline+=bars.charAt((int)Math.ceil(((arr[i]-min)/range*num)));\n\t\t}\n\t\treturn line;\n\t}\n}\n"}
{"id": 404536, "name": "Levenshtein distance_Alignment", "source": "Translate Haskell to Java: costs :: String -> String -> [[Int]]\ncosts s1 s2 = reverse $ reverse <$> matrix\n  where\n    matrix = scanl transform [0 .. length s1] s2\n    transform ns@(n:ns1) c = scanl calc (n + 1) $ zip3 s1 ns ns1\n      where\n        calc z (c1, x, y) = minimum [ y + 1, z + 1\n                                    , x + fromEnum (c1 /= c)]\n\nlevenshteinDistance :: String -> String -> Int\nlevenshteinDistance s1 s2 = head.head $ costs s1 s2\n", "target": "public class LevenshteinAlignment {\n\n    public static String[] alignment(String a, String b) {\n        a = a.toLowerCase();\n        b = b.toLowerCase();\n        \n        int[][] costs = new int[a.length()+1][b.length()+1];\n        for (int j = 0; j <= b.length(); j++)\n            costs[0][j] = j;\n        for (int i = 1; i <= a.length(); i++) {\n            costs[i][0] = i;\n            for (int j = 1; j <= b.length(); j++) {\n                costs[i][j] = Math.min(1 + Math.min(costs[i-1][j], costs[i][j-1]), a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1);\n            }\n        }\n\n\t\n\tStringBuilder aPathRev = new StringBuilder();\n\tStringBuilder bPathRev = new StringBuilder();\n\tfor (int i = a.length(), j = b.length(); i != 0 && j != 0; ) {\n\t    if (costs[i][j] == (a.charAt(i - 1) == b.charAt(j - 1) ? costs[i-1][j-1] : costs[i-1][j-1] + 1)) {\n\t\taPathRev.append(a.charAt(--i));\n\t\tbPathRev.append(b.charAt(--j));\n\t    } else if (costs[i][j] == 1 + costs[i-1][j]) {\n\t\taPathRev.append(a.charAt(--i));\n\t\tbPathRev.append('-');\n\t    } else if (costs[i][j] == 1 + costs[i][j-1]) {\n\t\taPathRev.append('-');\n\t\tbPathRev.append(b.charAt(--j));\n\t    }\n\t}\n        return new String[]{aPathRev.reverse().toString(), bPathRev.reverse().toString()};\n    }\n\n    public static void main(String[] args) {\n\tString[] result = alignment(\"rosettacode\", \"raisethysword\");\n\tSystem.out.println(result[0]);\n\tSystem.out.println(result[1]);\n    }\n}\n"}
{"id": 404537, "name": "Longest increasing subsequence", "source": "Translate Haskell to Java: import Data.Ord          ( comparing )\nimport Data.List         ( maximumBy, subsequences )\nimport Data.List.Ordered ( isSorted, nub )\n\nlis :: Ord a => [a] -> [a]\nlis = maximumBy (comparing length) . map nub  . filter isSorted . subsequences                 \n\n\nmain = do\n  print $ lis [3,2,6,4,5,1]\n  print $ lis [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]\n  print $ lis [1,1,1,1]\n", "target": "import java.util.*;\n\npublic class LIS {\n    public static <E extends Comparable<? super E>> List<E> lis(List<E> n) {\n        List<Node<E>> pileTops = new ArrayList<Node<E>>();\n        \n        for (E x : n) {\n\t    Node<E> node = new Node<E>();\n\t    node.value = x;\n            int i = Collections.binarySearch(pileTops, node);\n            if (i < 0) i = ~i;\n\t    if (i != 0)\n\t\tnode.pointer = pileTops.get(i-1);\n            if (i != pileTops.size())\n                pileTops.set(i, node);\n            else\n                pileTops.add(node);\n        }\n\t\n\tList<E> result = new ArrayList<E>();\n\tfor (Node<E> node = pileTops.size() == 0 ? null : pileTops.get(pileTops.size()-1);\n                node != null; node = node.pointer)\n\t    result.add(node.value);\n\tCollections.reverse(result);\n\treturn result;\n    }\n\n    private static class Node<E extends Comparable<? super E>> implements Comparable<Node<E>> {\n\tpublic E value;\n\tpublic Node<E> pointer;\n        public int compareTo(Node<E> y) { return value.compareTo(y.value); }\n    }\n\n    public static void main(String[] args) {\n\tList<Integer> d = Arrays.asList(3,2,6,4,5,1);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n        d = Arrays.asList(0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15);\n\tSystem.out.printf(\"an L.I.S. of %s is %s\\n\", d, lis(d));\n    }\n}\n"}
{"id": 404538, "name": "Dynamic variable names", "source": "Translate Haskell to Java: data Var a = Var String a deriving Show\nmain = do\n    putStrLn \"please enter you variable name\"\n    vName <- getLine\n    let var = Var vName 42\n    putStrLn $ \"this is your variable: \" ++ show var\n", "target": "public static void main(String... args){\n        HashMap<String, Integer> vars = new HashMap<String, Integer>();\n        \n        \n        \n        vars.put(\"Variable name\", 3); \n        vars.put(\"Next variable name\", 5);\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        vars.put(str, sc.nextInt()); \n        \n        System.out.println(vars.get(\"Variable name\")); \n        System.out.println(vars.get(str));\n}\n"}
{"id": 404539, "name": "Brilliant numbers", "source": "Translate Haskell to Java: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf, splitWhen)\nimport Data.Numbers.Primes (primeFactors)\nimport Text.Printf (printf)\n\n\n\nisBrilliant :: (Integral a, Show a) => a -> Bool\nisBrilliant n = case primeFactors n of\n  [a, b] -> length (show a) == length (show b)\n  _ -> False\n\n\nmain :: IO ()\nmain = do\n  let indexedBrilliants =\n        zip\n          [1 ..]\n          (filter isBrilliant [1 ..])\n\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . snd\n          <$> take 100 indexedBrilliants\n\n  putStrLn \"(index, brilliant)\"\n  mapM_ print $\n    take 6 $\n      fmap (fst . head) $\n        splitWhen\n          (uncurry (<) . join bimap (length . show . snd))\n          $ zip indexedBrilliants (tail indexedBrilliants)\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 404540, "name": "Brilliant numbers", "source": "Translate Haskell to Java: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf, splitWhen)\nimport Data.Numbers.Primes (primeFactors)\nimport Text.Printf (printf)\n\n\n\nisBrilliant :: (Integral a, Show a) => a -> Bool\nisBrilliant n = case primeFactors n of\n  [a, b] -> length (show a) == length (show b)\n  _ -> False\n\n\nmain :: IO ()\nmain = do\n  let indexedBrilliants =\n        zip\n          [1 ..]\n          (filter isBrilliant [1 ..])\n\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . snd\n          <$> take 100 indexedBrilliants\n\n  putStrLn \"(index, brilliant)\"\n  mapM_ print $\n    take 6 $\n      fmap (fst . head) $\n        splitWhen\n          (uncurry (<) . join bimap (length . show . snd))\n          $ zip indexedBrilliants (tail indexedBrilliants)\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "import java.util.*;\n\npublic class BrilliantNumbers {\n    public static void main(String[] args) {\n        var primesByDigits = getPrimesByDigits(100000000);\n        System.out.println(\"First 100 brilliant numbers:\");\n        List<Integer> brilliantNumbers = new ArrayList<>();\n        for (var primes : primesByDigits) {\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                int prime1 = primes.get(i);\n                for (int j = i; j < n; ++j) {\n                    int prime2 = primes.get(j);\n                    brilliantNumbers.add(prime1 * prime2);\n                }\n            }\n            if (brilliantNumbers.size() >= 100)\n                break;\n        }\n        Collections.sort(brilliantNumbers);\n        for (int i = 0; i < 100; ++i) {\n            char c = (i + 1) % 10 == 0 ? '\\n' : ' ';\n            System.out.printf(\"%,5d%c\", brilliantNumbers.get(i), c);\n        }\n        System.out.println();\n        long power = 10;\n        long count = 0;\n        for (int p = 1; p < 2 * primesByDigits.size(); ++p) {\n            var primes = primesByDigits.get(p / 2);\n            long position = count + 1;\n            long minProduct = 0;\n            int n = primes.size();\n            for (int i = 0; i < n; ++i) {\n                long prime1 = primes.get(i);\n                var primes2 = primes.subList(i, n);\n                int q = (int)((power + prime1 - 1) / prime1);\n                int j = Collections.binarySearch(primes2, q);\n                if (j == n)\n                    continue;\n                if (j < 0)\n                    j = -(j + 1);\n                long prime2 = primes2.get(j);\n                long product = prime1 * prime2;\n                if (minProduct == 0 || product < minProduct)\n                    minProduct = product;\n                position += j;\n                if (prime1 >= prime2)\n                    break;\n            }\n            System.out.printf(\"First brilliant number >= 10^%d is\u00a0%,d at position\u00a0%,d\\n\",\n                                p, minProduct, position);\n            power *= 10;\n            if (p % 2 == 1) {\n                long size = primes.size();\n                count += size * (size + 1) / 2;\n            }\n        }\n    }\n\n    private static List<List<Integer>> getPrimesByDigits(int limit) {\n        PrimeGenerator primeGen = new PrimeGenerator(100000, 100000);\n        List<List<Integer>> primesByDigits = new ArrayList<>();\n        List<Integer> primes = new ArrayList<>();\n        for (int p = 10; p <= limit; ) {\n            int prime = primeGen.nextPrime();\n            if (prime > p) {\n                primesByDigits.add(primes);\n                primes = new ArrayList<>();\n                p *= 10;\n            }\n            primes.add(prime);\n        }\n        return primesByDigits;\n    }\n}\n"}
{"id": 404541, "name": "Order disjoint list items", "source": "Translate Haskell to Java: import Data.List (mapAccumL, sort)\n\norder\n  :: Ord a\n  => [[a]] -> [a]\norder [ms, ns] = snd . mapAccumL yu ls $ ks\n  where\n    ks = zip ms [(0 :: Int) ..]\n    ls = zip ns . sort . snd . foldl go (sort ns, []) . sort $ ks\n    yu ((u, v):us) (_, y)\n      | v == y = (us, u)\n    yu ys (x, _) = (ys, x)\n    go (u:us, ys) (x, y)\n      | u == x = (us, y : ys)\n    go ts _ = ts\n\ntask :: [String] -> IO ()\ntask ls@[ms, ns] =\n  putStrLn $\n  \"M: \" ++ ms ++ \" | N: \" ++ ns ++ \" |> \" ++ (unwords . order . map words $ ls)\n\nmain :: IO ()\nmain =\n  mapM_\n    task\n    [ [\"the cat sat on the mat\", \"mat cat\"]\n    , [\"the cat sat on the mat\", \"cat mat\"]\n    , [\"A B C A B C A B C\", \"C A C A\"]\n    , [\"A B C A B D A B E\", \"E A D A\"]\n    , [\"A B\", \"B\"]\n    , [\"A B\", \"B A\"]\n    , [\"A B B A\", \"B A\"]\n    ]\n", "target": "import java.util.Arrays;\nimport java.util.BitSet;\nimport org.apache.commons.lang3.ArrayUtils;\n\npublic class OrderDisjointItems {\n\n    public static void main(String[] args) {\n        final String[][] MNs = {{\"the cat sat on the mat\", \"mat cat\"},\n        {\"the cat sat on the mat\", \"cat mat\"},\n        {\"A B C A B C A B C\", \"C A C A\"}, {\"A B C A B D A B E\", \"E A D A\"},\n        {\"A B\", \"B\"}, {\"A B\", \"B A\"}, {\"A B B A\", \"B A\"}, {\"X X Y\", \"X\"}};\n\n        for (String[] a : MNs) {\n            String[] r = orderDisjointItems(a[0].split(\" \"), a[1].split(\" \"));\n            System.out.printf(\"%s | %s -> %s%n\", a[0], a[1], Arrays.toString(r));\n        }\n    }\n\n    \n    static String[] orderDisjointItems(String[] m, String[] n) {\n        for (String e : n) {\n            int idx = ArrayUtils.indexOf(m, e);\n            if (idx != -1)\n                m[idx] = null;\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (m[i] == null)\n                m[i] = n[j++];\n        }\n        return m;\n    }\n\n    \n    static String[] orderDisjointItems2(String[] m, String[] n) {\n        BitSet bitSet = new BitSet(m.length);\n        for (String e : n) {\n            int idx = -1;\n            do {\n                idx = ArrayUtils.indexOf(m, e, idx + 1);\n            } while (idx != -1 && bitSet.get(idx));\n            if (idx != -1)\n                bitSet.set(idx);\n        }\n        for (int i = 0, j = 0; i < m.length; i++) {\n            if (bitSet.get(i))\n                m[i] = n[j++];\n        }\n        return m;\n    }\n}\n"}
{"id": 404542, "name": "Interactive programming (repl)", "source": "Translate Haskell to Java: $ ghci\n   ___         ___ _\n  / _ \\ /\\  /\\/ __(_)\n / /_\\// /_/ / /  | |      GHC Interactive, version 6.4.2, for Haskell 98.\n/ /_\\\\/ __  / /___| |      http://www.haskell.org/ghc/\n\\____/\\/ /_/\\____/|_|      Type :? for help.\n\nLoading package base-1.0 ... linking ... done.\nPrelude> let f as bs sep = as ++ sep ++ sep ++ bs\nPrelude> f \"Rosetta\" \"Code\" \":\"\n\"Rosetta::Code\"\n", "target": "public static void main(String[] args) {\n    System.out.println(concat(\"Rosetta\", \"Code\", \":\"));\n}\n\npublic static String concat(String a, String b, String c) {\n   return a + c + c + b;\n}\n\nRosetta::Code\n"}
{"id": 404543, "name": "Reverse the gender of a string", "source": "Translate Haskell to Java: id\n", "target": "public class ReallyLameTranslationOfJ {\n\n    public static void main(String[] args) {\n        String s = \"She was a soul stripper. She took my heart!\";\n        System.out.println(cheapTrick(s));\n        System.out.println(cheapTrick(cheapTrick(s)));\n    }\n\n    static String cheapTrick(String s) {\n        if (s.contains(\"She\"))\n            return s.replaceAll(\"She\", \"He\");\n        else if(s.contains(\"He\"))\n            return s.replaceAll(\"He\", \"She\");\n        return s;\n    }\n}\n"}
{"id": 404544, "name": "Reverse the gender of a string", "source": "Translate Haskell to Java: id\n", "target": "public class ReallyLameTranslationOfJ {\n\n    public static void main(String[] args) {\n        String s = \"She was a soul stripper. She took my heart!\";\n        System.out.println(cheapTrick(s));\n        System.out.println(cheapTrick(cheapTrick(s)));\n    }\n\n    static String cheapTrick(String s) {\n        if (s.contains(\"She\"))\n            return s.replaceAll(\"She\", \"He\");\n        else if(s.contains(\"He\"))\n            return s.replaceAll(\"He\", \"She\");\n        return s;\n    }\n}\n"}
{"id": 404545, "name": "Index finite lists of positive integers", "source": "Translate Haskell to Java: import Data.List\n\ntoBase :: Int -> Integer -> [Int]\ntoBase b = unfoldr f\n  where\n    f 0 = Nothing\n    f n = let (q, r) = n `divMod` fromIntegral b in Just (fromIntegral r, q)\n\nfromBase :: Int -> [Int] -> Integer\nfromBase n lst = foldr (\\x r -> fromIntegral n*r + fromIntegral x) 0 lst\n\n\n               \nlistToInt :: Int -> [Int] -> Integer\nlistToInt b lst = fromBase (b+1) $ concat seq\n  where\n    seq = [ let (q, r) = divMod n b\n            in replicate q 0 ++ [r+1]\n          | n <- lst ]\n\nintToList :: Int -> Integer -> [Int]\nintToList b lst = go 0 $ toBase (b+1) lst\n  where\n    go 0 [] = []\n    go i (0:xs) = go (i+1) xs\n    go i (x:xs) = (i*b + x - 1) : go 0 xs\n", "target": "import java.math.BigInteger;\nimport static java.util.Arrays.stream;\nimport java.util.*;\nimport static java.util.stream.Collectors.*;\n\npublic class Test3 {\n    static BigInteger rank(int[] x) {\n        String s = stream(x).mapToObj(String::valueOf).collect(joining(\"F\"));\n        return new BigInteger(s, 16);\n    }\n\n    static List<BigInteger> unrank(BigInteger n) {\n        BigInteger sixteen = BigInteger.valueOf(16);\n        String s = \"\";\n        while (!n.equals(BigInteger.ZERO)) {\n            s = \"0123456789ABCDEF\".charAt(n.mod(sixteen).intValue()) + s;\n            n = n.divide(sixteen);\n        }\n        return stream(s.split(\"F\")).map(x -> new BigInteger(x)).collect(toList());\n    }\n\n    public static void main(String[] args) {\n        int[] s = {1, 2, 3, 10, 100, 987654321};\n        System.out.println(Arrays.toString(s));\n        System.out.println(rank(s));\n        System.out.println(unrank(rank(s)));\n    }\n}\n"}
{"id": 404546, "name": "Generate random numbers without repeating a value", "source": "Translate Haskell to Java: import Data.List (sortBy)\nimport Data.Ord (comparing)\nimport System.Random (newStdGen, randomRs)\n\n\n\ninRandomOrder :: [a] -> IO [a]\ninRandomOrder xs =\n  fmap fst . sortBy (comparing snd) . zip xs\n    <$> (randomRs (0, 1) <$> newStdGen :: IO [Double])\n\n\nmain :: IO ()\nmain =\n  inRandomOrder [1 .. 20]\n    >>= print\n", "target": "import java.util.*;\n\npublic class RandomShuffle {\n    public static void main(String[] args) {\n        Random rand = new Random();\n        List<Integer> list = new ArrayList<>();\n        for (int j = 1; j <= 20; ++j)\n            list.add(j);\n        Collections.shuffle(list, rand);\n        System.out.println(list);\n    }\n}\n"}
{"id": 404547, "name": "Comments", "source": "Translate Haskell to Java: i code = True \n\n\n   let u x = x x (this code not compiled)\n   Are you? -}\n\n\ni code = True\n\n\n\ni code = True\n", "target": "\nInt i = 0;     \n"}
{"id": 404548, "name": "Read a file character by character_UTF8", "source": "Translate Haskell to Java: #!/usr/bin/env runhaskell\n\n\n\nimport System.Environment (getArgs)\nimport System.IO (\n        Handle, IOMode (..),\n        hGetChar, hIsEOF, hSetEncoding, stdin, utf8, withFile\n    )\nimport Control.Monad (forM_, unless)\nimport Text.Printf (printf)\nimport Data.Char (ord)\n\nprocessCharacters :: Handle -> IO ()\nprocessCharacters h = do\n  done <- hIsEOF h\n  unless done $ do\n    c <- hGetChar h\n    putStrLn $ printf \"U+%04X\" (ord c)\n    processCharacters h\n\nprocessOneFile :: Handle -> IO ()\nprocessOneFile h = do\n  hSetEncoding h utf8\n  processCharacters h\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    [] -> processOneFile stdin\n    xs -> forM_ xs $ \\name -> do\n      putStrLn name\n      withFile name ReadMode processOneFile\n", "target": "import java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n    \tfinal int endOfFile = -1;\n    \t\n        try ( FileReader reader = new FileReader(\"input.txt\", StandardCharsets.UTF_8) ) {\n\t\t\twhile ( true ) {\n\t\t\t    int ch = reader.read();\n\t\t\t    if ( ch == endOfFile ) {\n\t\t\t    \tbreak;\n\t\t\t    }\n\t\t\t    \n\t\t\t    System.out.print(Character.toChars(ch));\n\t\t\t}\n\t\t}\n    }\n}\n"}
{"id": 404549, "name": "Galton box animation", "source": "Translate Haskell to Java: import Data.Map hiding (map, filter)\nimport Graphics.Gloss\nimport Control.Monad.Random\n\ndata Ball = Ball { position :: (Int, Int), turns :: [Int] }\n\ntype World = ( Int           \n             , [Ball]        \n             , Map Int Int ) \n\nupdateWorld :: World -> World\nupdateWorld (nRows, balls, bins)\n  | y < -nRows-5  = (nRows, map update bs, bins <+> x)\n  | otherwise     = (nRows, map update balls, bins)\n  where\n    (Ball (x,y) _) : bs = balls\n\n    b <+> x = unionWith (+) b (singleton x 1)\n\n    update (Ball (x,y) turns)\n      | -nRows <= y && y < 0 = Ball (x + head turns, y - 1) (tail turns)\n      | otherwise            = Ball (x, y - 1) turns\n        \ndrawWorld :: World -> Picture\ndrawWorld (nRows, balls, bins) = pictures [ color red ballsP\n                                          , color black binsP\n                                          , color blue pinsP ]\n  where ballsP = foldMap (disk 1) $ takeWhile ((3 >).snd) $ map position balls        \n        binsP  = foldMapWithKey drawBin bins\n        pinsP  = foldMap (disk 0.2) $ [1..nRows] >>= \\i ->\n                                          [1..i] >>= \\j -> [(2*j-i-1, -i-1)]\n\n        disk r pos = trans pos $ circleSolid (r*10)\n        drawBin x h = trans (x,-nRows-7)\n                    $ rectangleUpperSolid 20 (-fromIntegral h)\n        trans (x,y) = Translate (20 * fromIntegral x) (20 * fromIntegral y)\n\nstartSimulation :: Int -> [Ball] -> IO ()\nstartSimulation nRows balls = simulate display white 50 world drawWorld update\n  where display = InWindow \"Galton box\" (400, 400) (0, 0)\n        world = (nRows, balls, empty)\n        update _ _ = updateWorld\n\nmain = evalRandIO balls >>= startSimulation 10\n  where balls = mapM makeBall [1..]\n        makeBall y = Ball (0, y) <$> randomTurns\n        randomTurns = filter (/=0) <$> getRandomRs (-1, 1)\n", "target": "import java.util.Random;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class GaltonBox {\n    public static void main( final String[] args ) {\n        new GaltonBox( 8, 200 ).run();\n    }\n\n    private final int        m_pinRows;\n    private final int        m_startRow;\n    private final Position[] m_balls;\n    private final Random     m_random = new Random();\n\n    public GaltonBox( final int pinRows, final int ballCount ) {\n        m_pinRows  = pinRows;\n        m_startRow = pinRows + 1;\n        m_balls    = new Position[ ballCount ];\n\n        for ( int ball = 0; ball < ballCount; ball++ )\n            m_balls[ ball ] = new Position( m_startRow, 0, 'o' );\n    }\n\n    private static class Position {\n        int  m_row;\n        int  m_col;\n        char m_char;\n\n        Position( final int row, final int col, final char ch ) {\n            m_row  = row;\n            m_col  = col;\n            m_char = ch;\n        }\n    }\n\n    public void run() {\n        for ( int ballsInPlay = m_balls.length; ballsInPlay > 0;  ) {\n            ballsInPlay = dropBalls();\n            print();\n        }\n    }\n\n    private int dropBalls() {\n        int ballsInPlay = 0;\n        int ballToStart = -1;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( m_balls[ ball ].m_row == m_startRow )\n                ballToStart = ball;\n\n        \n        for ( int ball = 0; ball < m_balls.length; ball++ )\n            if ( ball == ballToStart ) {\n                m_balls[ ball ].m_row = m_pinRows;\n                ballsInPlay++;\n            }\n            else if ( m_balls[ ball ].m_row > 0 && m_balls[ ball ].m_row != m_startRow ) {\n                m_balls[ ball ].m_row -= 1;\n                m_balls[ ball ].m_col += m_random.nextInt( 2 );\n                if ( 0 != m_balls[ ball ].m_row )\n                    ballsInPlay++;\n            }\n\n        return ballsInPlay;\n    }\n\n    private void print() {\n        for ( int row = m_startRow; row --> 1;  ) {\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == row )\n                    printBall( m_balls[ ball ] );\n            System.out.println();\n            printPins( row );\n        }\n        printCollectors();\n        System.out.println();\n    }\n\n    private static void printBall( final Position pos ) {\n        for ( int col = pos.m_row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = 0; col < pos.m_col; col++ )\n            System.out.print( \"  \" );\n        System.out.print( pos.m_char );\n    }\n\n    private void printPins( final int row ) {\n        for ( int col = row + 1; col --> 0;  )\n            System.out.print( ' ' );\n        for ( int col = m_startRow - row; col --> 0;  )\n            System.out.print( \". \" );\n        System.out.println();\n    }\n\n    private void printCollectors() {\n        final List<List<Position>> collectors = new ArrayList<List<Position>>();\n\n        for ( int col = 0; col < m_startRow; col++ ) {\n            final List<Position> collector = new ArrayList<Position>();\n\n            collectors.add( collector );\n            for ( int ball = 0; ball < m_balls.length; ball++ )\n                if ( m_balls[ ball ].m_row == 0 && m_balls[ ball ].m_col == col )\n                    collector.add( m_balls[ ball ] );\n        }\n\n        for ( int row = 0, rows = longest( collectors ); row < rows; row++ ) {\n            for ( int col = 0; col < m_startRow; col++ ) {\n                final List<Position> collector = collectors.get( col );\n                final int            pos       = row + collector.size() - rows;\n\n                System.out.print( '|' );\n                if ( pos >= 0 )\n                    System.out.print( collector.get( pos ).m_char );\n                else\n                    System.out.print( ' ' );\n            }\n            System.out.println( '|' );\n        }\n    }\n\n    private static final int longest( final List<List<Position>> collectors ) {\n        int result = 0;\n\n        for ( final List<Position> collector : collectors )\n            result = Math.max( collector.size(), result );\n\n        return result;\n    }\n}\n"}
{"id": 404550, "name": "Primes - allocate descendants to their ancestors", "source": "Translate Haskell to Java: \nimport Data.Numbers.Primes (isPrime)\nimport Data.List\n\n\n\n\ntype Memo2 a = Memo (Memo a)\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving Functor\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Integral a => Memo a\nnats = Node 0 ((+1).(*2) <$> nats) ((*2).(+1) <$> nats)\n\nmemoize :: Integral a => (a -> b) -> (a -> b)\nmemoize f = memo (f <$> nats)\n\nmemoize2 :: (Integral a, Integral b) => (a -> b -> c) -> (a -> b -> c)\nmemoize2 f = memoize (memoize . f)\n\n\n\npartProd = memoize2 partProdM\n  where\n    partProdM x p\n      | p == 0 = []\n      | x == 0 = [1]\n      | x < 0 = []\n      | isPrime p = ((p *) <$> partProdM (x - p) p) ++\n                    partProd x (p - 1)\n      | otherwise = partProd x (p - 1)\n\ndescendants = memoize descendantsM\n  where\n    descendantsM x =\n      if x == 4 then [] else sort (partProd x (x - 1))\n\nancestors = memoize ancestorsM\n  where\n    ancestorsM z = concat [ ancestors x ++ [x]\n                          | x <- [z-1,z-2..1]\n                          , z `elem` descendants x ]\n\nmain = do\n  mapM_ (putStrLn . task1) [1..15]\n  putStrLn (task2 46)\n  putStrLn (task2 99)\n  putStrLn task3\n  where\n    task1 n = show n ++\n              \"  ancestors:\" ++ show (ancestors n) ++\n              \"  descendants:\" ++ show (descendants n)\n    task2 n = show n ++ \" has \" ++\n              show (length (ancestors n)) ++ \" ancestors, \" ++\n              show (length (descendants n)) ++ \" descendants.\"\n    task3 = \"Total ancestors up to 99: \" ++\n            show (sum $ length . ancestors <$> [1..99]) ++\n            \"\\nTotal descendants up to 99: \" ++\n            show (sum $ length . descendants <$> [1..99])\n", "target": "import java.io.*;\nimport java.util.*;\n\npublic class PrimeDescendants {\n    public static void main(String[] args) {\n        try (Writer writer = new BufferedWriter(new OutputStreamWriter(System.out))) {\n            printPrimeDesc(writer, 100);\n        } catch (IOException ex) {\n            ex.printStackTrace();\n        }\n    }\n\n    private static void printPrimeDesc(Writer writer, int limit) throws IOException {\n        List<Long> primes = findPrimes(limit);\n\n        List<Long> ancestor = new ArrayList<>(limit);\n        List<List<Long>> descendants = new ArrayList<>(limit);\n        for (int i = 0; i < limit; ++i) {\n            ancestor.add(Long.valueOf(0));\n            descendants.add(new ArrayList<Long>());\n        }\n\n        for (Long prime : primes) {\n            int p = prime.intValue();\n            descendants.get(p).add(prime);\n            for (int i = 0; i + p < limit; ++i) {\n                int s = i + p;\n                for (Long n : descendants.get(i)) {\n                    Long prod = n * p;\n                    descendants.get(s).add(prod);\n                    if (prod < limit)\n                        ancestor.set(prod.intValue(), Long.valueOf(s));\n                }\n            }\n        }\n\n        \n        int totalDescendants = 0;\n        for (int i = 1; i < limit; ++i) {\n            List<Long> ancestors = getAncestors(ancestor, i);\n            writer.write(\"[\" + i + \"] Level: \" + ancestors.size() + \"\\n\");\n            writer.write(\"Ancestors: \");\n            Collections.sort(ancestors);\n            print(writer, ancestors);\n\n            writer.write(\"Descendants: \");\n            List<Long> desc = descendants.get(i);\n            if (!desc.isEmpty()) {\n                Collections.sort(desc);\n                if (desc.get(0) == i)\n                    desc.remove(0);\n            }\n            writer.write(desc.size() + \"\\n\");\n            totalDescendants += desc.size();\n            if (!desc.isEmpty())\n                print(writer, desc);\n            writer.write(\"\\n\");\n        }\n        writer.write(\"Total descendants: \" + totalDescendants + \"\\n\");\n    }\n\n    \n    private static List<Long> findPrimes(int limit) {\n        boolean[] isprime = new boolean[limit];\n        Arrays.fill(isprime, true);\n        isprime[0] = isprime[1] = false;\n        for (int p = 2; p * p < limit; ++p) {\n            if (isprime[p]) {\n                for (int i = p * p; i < limit; i += p)\n                    isprime[i] = false;\n            }\n        }\n        List<Long> primes = new ArrayList<>();\n        for (int p = 2; p < limit; ++p) {\n            if (isprime[p])\n                primes.add(Long.valueOf(p));\n        }\n        return primes;\n    }\n\n    \n    private static List<Long> getAncestors(List<Long> ancestor, int n) {\n        List<Long> result = new ArrayList<>();\n        for (Long a = ancestor.get(n); a != 0 && a != n; ) {\n            n = a.intValue();\n            a = ancestor.get(n);\n            result.add(Long.valueOf(n));\n        }\n        return result;\n    }\n\n    private static void print(Writer writer, List<Long> list) throws IOException {\n        if (list.isEmpty()) {\n            writer.write(\"none\\n\");\n            return;\n        }\n        int i = 0;\n        writer.write(String.valueOf(list.get(i++)));\n        for (; i != list.size(); ++i)\n            writer.write(\", \" + list.get(i));\n        writer.write(\"\\n\");\n    }\n}\n"}
{"id": 404551, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Haskell to Java: import Data.Bool (bool)\n\ncircleSort :: Ord a => [a] -> [a]\ncircleSort xs = if swapped then circleSort ks else ks\n  where\n    (swapped,ks) = go False xs (False,[])\n    \n    go d []  sks = sks\n    go d [x] (s,ks) = (s,x:ks)\n    go d xs  (s,ks) =\n      let (st,_,ls,rs) = halve d s xs xs\n      in go False ls (go True rs (st,ks))\n \n    halve d s (y:ys) (_:_:zs) = swap d y (halve d s ys zs)\n    halve d s ys     []       = (s,ys,[],[])\n    halve d s (y:ys) [_]      = (s,ys,[y | e],[y | not e])\n      where e = y <= head ys\n \n    swap d x (s,y:ys,ls,rs)\n      | bool (<=) (<) d x y = (    d || s,ys,x:ls,y:rs)\n      | otherwise           = (not d || s,ys,y:ls,x:rs)\n", "target": "import java.util.Arrays;\n\npublic class CircleSort {\n\n    public static void main(String[] args) {\n        circleSort(new int[]{2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1});\n    }\n\n    public static void circleSort(int[] arr) {\n        if (arr.length > 0)\n            do {\n                System.out.println(Arrays.toString(arr));\n            } while (circleSortR(arr, 0, arr.length - 1, 0) != 0);\n    }\n\n    private static int circleSortR(int[] arr, int lo, int hi, int numSwaps) {\n        if (lo == hi)\n            return numSwaps;\n\n        int high = hi;\n        int low = lo;\n        int mid = (hi - lo) / 2;\n\n        while (lo < hi) {\n            if (arr[lo] > arr[hi]) {\n                swap(arr, lo, hi);\n                numSwaps++;\n            }\n            lo++;\n            hi--;\n        }\n\n        if (lo == hi && arr[lo] > arr[hi + 1]) {\n            swap(arr, lo, hi + 1);\n            numSwaps++;\n        }\n\n        numSwaps = circleSortR(arr, low, low + mid, numSwaps);\n        numSwaps = circleSortR(arr, low + mid + 1, high, numSwaps);\n\n        return numSwaps;\n    }\n\n    private static void swap(int[] arr, int idx1, int idx2) {\n        int tmp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = tmp;\n    }\n}\n"}
{"id": 404552, "name": "Brace expansion", "source": "Translate Haskell to Java: import qualified Text.Parsec as P\n\nshowExpansion :: String -> String\nshowExpansion =\n  (<>) . (<> \"\\n\n\nparser :: P.Parsec String u [String]\nparser = expansion P.anyChar\n\nexpansion :: P.Parsec String u Char -> P.Parsec String u [String]\nexpansion =\n  fmap expand .\n  P.many .\n  ((P.try alts P.<|> P.try alt1 P.<|> escape) P.<|>) . fmap (pure . pure)\n\nexpand :: [[String]] -> [String]\nexpand = foldr ((<*>) . fmap (<>)) [[]]\n\nalts :: P.Parsec String u [String]\nalts = concat <$> P.between (P.char '{') (P.char '}') (alt `sepBy2` P.char ',')\n\nalt :: P.Parsec String u [String]\nalt = expansion (P.noneOf \",}\")\n\nalt1 :: P.Parsec String u [String]\nalt1 =\n  (\\x -> ['{' : (x <> \"}\")]) <$>\n  P.between (P.char '{') (P.char '}') (P.many $ P.noneOf \",{}\")\n\nsepBy2 :: P.Parsec String u a -> P.Parsec String u b -> P.Parsec String u [a]\np `sepBy2` sep = (:) <$> p <*> P.many1 (sep >> p)\n\nescape :: P.Parsec String u [String]\nescape = pure <$> sequence [P.char '\\\\', P.anyChar]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . showExpansion)\n    [ \"~/{Downloads,Pictures}/*.{jpg,gif,png}\"\n    , \"It{{em,alic}iz,erat}e{d,}, please.\"\n    , \"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\"\n    , \"{}} some }{,{\\\\\\\\{ edge, edge} \\\\,}{ cases, {here} \\\\\\\\\\\\\\\\\\\\}\"\n    ]\n", "target": "public class BraceExpansion {\n\n    public static void main(String[] args) {\n        for (String s : new String[]{\"It{{em,alic}iz,erat}e{d,}, please.\",\n            \"~/{Downloads,Pictures}/*.{jpg,gif,png}\",\n            \"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\",\n            \"{}} some }{,{\\\\\\\\{ edge, edge} \\\\,}{ cases, {here} \\\\\\\\\\\\\\\\\\\\}\"}) {\n            System.out.println();\n            expand(s);\n        }\n    }\n\n    public static void expand(String s) {\n        expandR(\"\", s, \"\");\n    }\n\n    private static void expandR(String pre, String s, String suf) {\n        int i1 = -1, i2 = 0;\n        String noEscape = s.replaceAll(\"([\\\\\\\\]{2}|[\\\\\\\\][,}{])\", \"  \");\n        StringBuilder sb = null;\n\n        outer:\n        while ((i1 = noEscape.indexOf('{', i1 + 1)) != -1) {\n            i2 = i1 + 1;\n            sb = new StringBuilder(s);\n            for (int depth = 1; i2 < s.length() && depth > 0; i2++) {\n                char c = noEscape.charAt(i2);\n                depth = (c == '{') ? ++depth : depth;\n                depth = (c == '}') ? --depth : depth;\n                if (c == ',' && depth == 1) {\n                    sb.setCharAt(i2, '\\u0000');\n                } else if (c == '}' && depth == 0 && sb.indexOf(\"\\u0000\") != -1)\n                    break outer;\n            }\n        }\n        if (i1 == -1) {\n            if (suf.length() > 0)\n                expandR(pre + s, suf, \"\");\n            else\n                System.out.printf(\"%s%s%s%n\", pre, s, suf);\n        } else {\n            for (String m : sb.substring(i1 + 1, i2).split(\"\\u0000\", -1))\n                expandR(pre + s.substring(0, i1), m, s.substring(i2 + 1) + suf);\n        }\n    }\n}\n"}
{"id": 404553, "name": "Intersecting number wheels", "source": "Translate Haskell to Java: import Data.Char (isDigit)\nimport Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nclockWorkTick ::\n  M.Map Char String ->\n  (M.Map Char String, Char)\nclockWorkTick = flip click 'A'\n  where\n    click wheels name\n      | isDigit name = (wheels, name)\n      | otherwise =\n        ( click\n            . flip\n              (M.insert name . leftRotate)\n              wheels\n            <*> head\n        )\n          $ fromMaybe ['?'] $ M.lookup name wheels\n\nleftRotate :: [a] -> [a]\nleftRotate = take . length <*> (tail . cycle)\n\n\nmain :: IO ()\nmain = do\n  let wheelSets =\n        [ [('A', \"123\")],\n          [('A', \"1B2\"), ('B', \"34\")],\n          [('A', \"1DD\"), ('D', \"678\")],\n          [('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")]\n        ]\n  putStrLn \"State of each wheel-set after 20 clicks:\\n\"\n  mapM_ print $\n    fmap\n      ( flip\n          (mapAccumL (const . clockWorkTick))\n          (replicate 20 undefined)\n          . M.fromList\n      )\n      wheelSets\n  putStrLn \"\\nInitial state of the wheel-sets:\\n\"\n  mapM_ print wheelSets\n", "target": "package intersectingNumberWheels;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\npublic class WheelController {\n\tprivate static final String IS_NUMBER = \"[0-9]\";\n\tprivate static final int TWENTY = 20;\n\tprivate static Map<String, WheelModel> wheelMap;\n\n\tpublic static void advance(String wheel) {\n\t\tWheelModel w = wheelMap.get(wheel);\n\t\tif (w.list.get(w.position).matches(IS_NUMBER)) {\n\t\t\tw.printThePosition();\n\t\t\tw.advanceThePosition();\n\t\t} else {\n\t\t\tString wheelName = w.list.get(w.position);\n\t\t\tadvance(wheelName);\n\t\t\tw.advanceThePosition();\n\t\t}\n\t}\n\n\tpublic static void run() {\n\t\tSystem.out.println(wheelMap);\n\t\tIntStream.rangeClosed(1, TWENTY).forEach(i -> advance(\"A\"));\n\t\tSystem.out.println();\n\t\twheelMap.clear();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twheelMap = new HashMap<>();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"2\", \"3\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"2\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"D\", \"D\"));\n\t\twheelMap.put(\"D\", new WheelModel(\"D\", \"6\", \"7\", \"8\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"C\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\twheelMap.put(\"C\", new WheelModel(\"C\", \"5\", \"B\"));\n\t\trun();\n\t}\n\n}\n\nclass WheelModel {\n\tString name;\n\tList<String> list;\n\tint position;\n\tint endPosition;\n\tprivate static final int INITIAL = 0;\n\n\tpublic WheelModel(String name, String... values) {\n\t\tsuper();\n\n\t\tthis.name = name.toUpperCase();\n\t\tthis.list = new ArrayList<>();\n\t\tfor (String value : values) {\n\t\t\tlist.add(value);\n\t\t}\n\t\tthis.position = INITIAL;\n\t\tthis.endPosition = this.list.size() - 1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn list.toString();\n\t}\n\n\tpublic void advanceThePosition() {\n\t\tif (this.position == this.endPosition) {\n\t\t\tthis.position = INITIAL;\n\t\t} else {\n\t\t\tthis.position++;\n\t\t}\n\t}\n\n\tpublic void printThePosition() {\n\t\tSystem.out.print(\" \" + this.list.get(position));\n\t}\n}\n"}
{"id": 404554, "name": "Intersecting number wheels", "source": "Translate Haskell to Java: import Data.Char (isDigit)\nimport Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nclockWorkTick ::\n  M.Map Char String ->\n  (M.Map Char String, Char)\nclockWorkTick = flip click 'A'\n  where\n    click wheels name\n      | isDigit name = (wheels, name)\n      | otherwise =\n        ( click\n            . flip\n              (M.insert name . leftRotate)\n              wheels\n            <*> head\n        )\n          $ fromMaybe ['?'] $ M.lookup name wheels\n\nleftRotate :: [a] -> [a]\nleftRotate = take . length <*> (tail . cycle)\n\n\nmain :: IO ()\nmain = do\n  let wheelSets =\n        [ [('A', \"123\")],\n          [('A', \"1B2\"), ('B', \"34\")],\n          [('A', \"1DD\"), ('D', \"678\")],\n          [('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")]\n        ]\n  putStrLn \"State of each wheel-set after 20 clicks:\\n\"\n  mapM_ print $\n    fmap\n      ( flip\n          (mapAccumL (const . clockWorkTick))\n          (replicate 20 undefined)\n          . M.fromList\n      )\n      wheelSets\n  putStrLn \"\\nInitial state of the wheel-sets:\\n\"\n  mapM_ print wheelSets\n", "target": "package intersectingNumberWheels;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\npublic class WheelController {\n\tprivate static final String IS_NUMBER = \"[0-9]\";\n\tprivate static final int TWENTY = 20;\n\tprivate static Map<String, WheelModel> wheelMap;\n\n\tpublic static void advance(String wheel) {\n\t\tWheelModel w = wheelMap.get(wheel);\n\t\tif (w.list.get(w.position).matches(IS_NUMBER)) {\n\t\t\tw.printThePosition();\n\t\t\tw.advanceThePosition();\n\t\t} else {\n\t\t\tString wheelName = w.list.get(w.position);\n\t\t\tadvance(wheelName);\n\t\t\tw.advanceThePosition();\n\t\t}\n\t}\n\n\tpublic static void run() {\n\t\tSystem.out.println(wheelMap);\n\t\tIntStream.rangeClosed(1, TWENTY).forEach(i -> advance(\"A\"));\n\t\tSystem.out.println();\n\t\twheelMap.clear();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\twheelMap = new HashMap<>();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"2\", \"3\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"2\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"D\", \"D\"));\n\t\twheelMap.put(\"D\", new WheelModel(\"D\", \"6\", \"7\", \"8\"));\n\t\trun();\n\t\twheelMap.put(\"A\", new WheelModel(\"A\", \"1\", \"B\", \"C\"));\n\t\twheelMap.put(\"B\", new WheelModel(\"B\", \"3\", \"4\"));\n\t\twheelMap.put(\"C\", new WheelModel(\"C\", \"5\", \"B\"));\n\t\trun();\n\t}\n\n}\n\nclass WheelModel {\n\tString name;\n\tList<String> list;\n\tint position;\n\tint endPosition;\n\tprivate static final int INITIAL = 0;\n\n\tpublic WheelModel(String name, String... values) {\n\t\tsuper();\n\n\t\tthis.name = name.toUpperCase();\n\t\tthis.list = new ArrayList<>();\n\t\tfor (String value : values) {\n\t\t\tlist.add(value);\n\t\t}\n\t\tthis.position = INITIAL;\n\t\tthis.endPosition = this.list.size() - 1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn list.toString();\n\t}\n\n\tpublic void advanceThePosition() {\n\t\tif (this.position == this.endPosition) {\n\t\t\tthis.position = INITIAL;\n\t\t} else {\n\t\t\tthis.position++;\n\t\t}\n\t}\n\n\tpublic void printThePosition() {\n\t\tSystem.out.print(\" \" + this.list.get(position));\n\t}\n}\n"}
{"id": 404555, "name": "Yahoo! search interface", "source": "Translate Haskell to Java: import Network.HTTP\nimport Text.Parsec\n\ndata YahooSearchItem = YahooSearchItem {\n    itemUrl, itemTitle, itemContent :: String }\n\ndata YahooSearch = YahooSearch {\n    searchQuery :: String,\n    searchPage :: Int,\n    searchItems :: [YahooSearchItem] }\n    \n\nyahooUrl = \"http://search.yahoo.com/search?p=\"\n\n\nyahoo :: String -> IO YahooSearch\nyahoo q = simpleHTTP (getRequest $ yahooUrl ++ q) >>=\n    getResponseBody >>= return . YahooSearch q 1 . items\n\n\nnext :: YahooSearch -> IO YahooSearch\nnext (YahooSearch q p _) =\n    simpleHTTP (getRequest $\n    \n    yahooUrl ++ q ++ \"&b=\" ++ show (p + 1)) >>=\n    getResponseBody >>= return . YahooSearch q (p + 1) . items\n\nprintResults :: YahooSearch -> IO ()\nprintResults (YahooSearch q p items) = do\n    putStrLn $ \"Showing Yahoo! search results for query: \" ++ q\n    putStrLn $ \"Page: \" ++ show p\n    putChar '\\n'\n    mapM_ printOne items\n    where\n        printOne (YahooSearchItem itemUrl itemTitle itemContent) = do\n            putStrLn $ \"URL  \u00a0: \" ++ itemUrl\n            putStrLn $ \"Title\u00a0: \" ++ itemTitle\n            putStrLn $ \"Abstr\u00a0: \" ++ itemContent\n            putChar '\\n'\n\nurlTag, titleTag, contentTag1, contentTag2, ignoreTag,\n    ignoreText :: Parsec String () String\n    \n\nurlTag = do { string \"<a id=\\\"link-\";\n    many digit; string \"\\\" class=\\\"yschttl spt\\\" href=\\\"\";\n    url <- manyTill anyChar (char '\"'); manyTill anyChar (char '>');\n    return url }\n\n\n\ntitleTag = do { urlTag; manyTill anyChar (try (string \"</a>\")) }\n\n\n\ncontentTag1 = do { string \"<div class=\\\"sm-abs\\\">\";\n    manyTill anyChar (try (string \"</div>\")) }\n\ncontentTag2 = do { string \"<div class=\\\"abstr\\\">\";\n    manyTill anyChar (try (string \"</div>\")) }\n\n\nignoreTag = do { char ('<'); manyTill anyChar (char '>');\n    return \"\" }\n\n\nignoreText = do { many1 (noneOf \"<\"); return \"\" }\n\n\nnonempty :: [String] -> Parsec String () [String]\nnonempty xs = return [ x | x <- xs, not (null x) ]\n\n\n\nparseCategory x = do\n    res <- many x\n    eof\n    nonempty res\n    \nurls, titles, contents :: Parsec String () [String]\n\n\nurls = parseCategory url where\n    url = (try urlTag) <|> ignoreTag <|> ignoreText\n\n\ntitles = parseCategory title where\n    title = (try titleTag) <|> ignoreTag <|> ignoreText\n\n\ncontents = parseCategory content where\n    content = (try contentTag1) <|> (try contentTag2) <|>\n        ignoreTag <|> ignoreText\n\n\n\n\nitems :: String -> [YahooSearchItem]\nitems q =\n    let ignoreOrKeep = either (const []) id\n        us = ignoreOrKeep $ parse urls \"\" q\n        ts = ignoreOrKeep $ parse titles \"\" q\n        cs = ignoreOrKeep $ parse contents \"\" q\n    in [ YahooSearchItem { itemUrl = u, itemTitle = t, itemContent = c } |\n        (u, t, c) <- zip3 us ts cs ]\n", "target": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLDecoder;\nimport java.net.URLEncoder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nclass YahooSearch {\n    private String query;\n    \n    private int page = 1;\n    \n    private static final Pattern pattern = Pattern.compile(\n        \"<a class=\\\"yschttl spt\\\" href=\\\"[^*]+?\\\\*\\\\*([^\\\"]+?)\\\">(.+?)</a></h3>.*?<div class=\\\"(?:sm-abs|abstr)\\\">(.+?)</div>\");\n\n    public YahooSearch(String query) {\n        this.query = query;\n    }\n\n    public List<YahooResult> search() throws MalformedURLException, URISyntaxException, IOException {\n        \n        \n        StringBuilder searchUrl = new StringBuilder(\"http:\n        searchUrl.append(\"p=\").append(URLEncoder.encode(query, \"UTF-8\"));\n        if (page > 1) {searchUrl.append(\"&b=\").append((page - 1) * 10 + 1);}\n        \n        URL url = new URL(searchUrl.toString());\n        List<YahooResult> result = new ArrayList<YahooResult>();\n        StringBuilder sb = new StringBuilder();\n        \n        BufferedReader in = null;\n        try {\n            in = new BufferedReader(new InputStreamReader(url.openStream()));\n            \n            String line = in.readLine();\n            while (line != null) {\n                sb.append(line);\n                line = in.readLine();\n            }\n        }\n        catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n        finally {\n            try {in.close();} catch (Exception ignoreMe) {}\n        }\n        String searchResult = sb.toString();\n        \n        Matcher matcher = pattern.matcher(searchResult);\n        while (matcher.find()) {\n            \n            String resultUrl = URLDecoder.decode(matcher.group(1), \"UTF-8\");\n            String resultTitle = matcher.group(2).replaceAll(\"</?b>\", \"\").replaceAll(\"<wbr\u00a0?/?>\", \"\");\n            String resultContent = matcher.group(3).replaceAll(\"</?b>\", \"\").replaceAll(\"<wbr\u00a0?/?>\", \"\");\n            \n            result.add(new YahooResult(resultUrl, resultTitle, resultContent));\n        }\n        return result;\n    }\n\n    public List<YahooResult> search(int page) throws MalformedURLException, URISyntaxException, IOException {\n        \n        this.page = page;\n        return search();\n    }\n\n    public List<YahooResult> nextPage() throws MalformedURLException, URISyntaxException, IOException {\n        \n        page++;\n        return search();\n    }\n\n    public List<YahooResult> previousPage() throws MalformedURLException, URISyntaxException, IOException {\n        \n        if (page > 1) {\n            page--;\n            return search();\n        } else return new ArrayList<YahooResult>();\n    }\n}\n\nclass YahooResult {\n    private URL url;\n    private String title;\n    private String content;\n\n    public URL getUrl() {\n        return url;\n    }\n\n    public void setUrl(URL url) {\n        this.url = url;\n    }\n\n    public void setUrl(String url) throws MalformedURLException {\n        this.url = new URL(url);\n    }\n\n    public String getTitle() {\n        return title;\n    }\n\n    public void setTitle(String title) {\n        this.title = title;\n    }\n\n    public String getContent() {\n        return content;\n    }\n\n    public void setContent(String content) {\n        this.content = content;\n    }\n\n    public YahooResult(URL url, String title, String content) {\n        setUrl(url);\n        setTitle(title);\n        setContent(content);\n    }\n\n    public YahooResult(String url, String title, String content) throws MalformedURLException {\n        setUrl(url);\n        setTitle(title);\n        setContent(content);\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        if (title != null) {\n            sb.append(\",title=\").append(title);\n        }\n        if (url != null) {\n            sb.append(\",url=\").append(url);\n        }\n        return sb.charAt(0) == ',' ? sb.substring(1) : sb.toString();\n    }\n}\n\npublic class TestYahooSearch {\n    public static void main(String[] args) throws MalformedURLException, URISyntaxException, IOException {\n        \n        YahooSearch search = new YahooSearch(\"Rosetta code\");\n        \n        List<YahooResult> results = search.search();\n        \n        for (YahooResult result : results) {\n            System.out.println(result.toString());\n        }\n    }\n}\n"}
{"id": 404556, "name": "Circles of given radius through two points", "source": "Translate Haskell to Java: add (a, b) (x, y) = (a + x, b + y)\nsub (a, b) (x, y) = (a - x, b - y)\nmagSqr (a, b)     = (a ^^ 2) + (b ^^ 2)\nmag a             = sqrt $ magSqr a\nmul (a, b) c      = (a * c, b * c)\ndiv2 (a, b) c     = (a / c, b / c)\nperp (a, b)       = (negate b, a)\nnorm a            = a `div2` mag a\n\ncirclePoints :: (Ord a, Floating a) =>\n                (a, a) -> (a, a) -> a -> Maybe ((a, a), (a, a))\ncirclePoints p q radius\n  | radius == 0      = Nothing\n  | p == q           = Nothing\n  | diameter < magPQ = Nothing\n  | otherwise        = Just (center1, center2)\n  where\n    diameter = radius * 2\n    pq       = p `sub` q\n    magPQ    = mag pq\n    midpoint = (p `add` q) `div2` 2\n    halfPQ   = magPQ / 2\n    magMidC  = sqrt . abs $ (radius ^^ 2) - (halfPQ ^^ 2)\n    midC     = (norm $ perp pq) `mul` magMidC\n    center1  = midpoint `add` midC\n    center2  = midpoint `sub` midC\n\nuncurry3 f (a, b, c) = f a b c\n\nmain :: IO ()\nmain = mapM_ (print . uncurry3 circlePoints)\n  [((0.1234, 0.9876), (0.8765, 0.2345), 2),\n   ((0     , 2     ), (0     , 0     ), 1),\n   ((0.1234, 0.9876), (0.1234, 0.9876), 2),\n   ((0.1234, 0.9876), (0.8765, 0.2345), 0.5),\n   ((0.1234, 0.9876), (0.1234, 0.1234), 0)]\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 404557, "name": "Circles of given radius through two points", "source": "Translate Haskell to Java: add (a, b) (x, y) = (a + x, b + y)\nsub (a, b) (x, y) = (a - x, b - y)\nmagSqr (a, b)     = (a ^^ 2) + (b ^^ 2)\nmag a             = sqrt $ magSqr a\nmul (a, b) c      = (a * c, b * c)\ndiv2 (a, b) c     = (a / c, b / c)\nperp (a, b)       = (negate b, a)\nnorm a            = a `div2` mag a\n\ncirclePoints :: (Ord a, Floating a) =>\n                (a, a) -> (a, a) -> a -> Maybe ((a, a), (a, a))\ncirclePoints p q radius\n  | radius == 0      = Nothing\n  | p == q           = Nothing\n  | diameter < magPQ = Nothing\n  | otherwise        = Just (center1, center2)\n  where\n    diameter = radius * 2\n    pq       = p `sub` q\n    magPQ    = mag pq\n    midpoint = (p `add` q) `div2` 2\n    halfPQ   = magPQ / 2\n    magMidC  = sqrt . abs $ (radius ^^ 2) - (halfPQ ^^ 2)\n    midC     = (norm $ perp pq) `mul` magMidC\n    center1  = midpoint `add` midC\n    center2  = midpoint `sub` midC\n\nuncurry3 f (a, b, c) = f a b c\n\nmain :: IO ()\nmain = mapM_ (print . uncurry3 circlePoints)\n  [((0.1234, 0.9876), (0.8765, 0.2345), 2),\n   ((0     , 2     ), (0     , 0     ), 1),\n   ((0.1234, 0.9876), (0.1234, 0.9876), 2),\n   ((0.1234, 0.9876), (0.8765, 0.2345), 0.5),\n   ((0.1234, 0.9876), (0.1234, 0.1234), 0)]\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 404558, "name": "Vampire number", "source": "Translate Haskell to Java: import Data.List (sort)\nimport Control.Arrow ((&&&))\n\n\nvampires :: [Int]\nvampires = filter (not . null . fangs) [1 ..]\n\nfangs :: Int -> [(Int, Int)]\nfangs n\n  | odd w = []\n  | otherwise = ((,) <*> quot n) <$> filter isfang (integerFactors n)\n  where\n    ndigit :: Int -> Int\n    ndigit 0 = 0\n    ndigit n = 1 + ndigit (quot n 10)\n    w = ndigit n\n    xmin = 10 ^ (quot w 2 - 1)\n    xmax = xmin * 10\n    isfang x =\n      x > xmin &&\n      x < y &&\n      y < xmax && \n      (quot x 10 /= 0 || quot y 10 /= 0) && \n      sort (show n) == sort (show x ++ show y)\n      where\n        y = quot n x\n\n\nintegerFactors :: Int -> [Int]\nintegerFactors n\n  | n < 1 = []\n  | otherwise =\n    lows ++\n    (quot n <$>\n     (if intSquared == n \n        then tail \n        else id)\n       (reverse lows))\n  where\n    (intSquared, lows) =\n      (^ 2) &&& (filter ((0 ==) . rem n) . enumFromTo 1) $\n      floor (sqrt $ fromIntegral n)\n\n\nmain :: IO [()]\nmain =\n  mapM\n    (print . ((,) <*>) fangs)\n    (take 25 vampires ++ [16758243290880, 24959017348650, 14593825548650])\n", "target": "import java.util.Arrays;\nimport java.util.HashSet;\n\npublic class VampireNumbers{\n    private static int numDigits(long num){\n        return Long.toString(Math.abs(num)).length();\n    }\n\n    private static boolean fangCheck(long orig, long fang1, long fang2){\n        if(Long.toString(fang1).endsWith(\"0\") && Long.toString(fang2).endsWith(\"0\")) return false;\n\n        int origLen = numDigits(orig);\n        if(numDigits(fang1) != origLen / 2 || numDigits(fang2) != origLen / 2) return false;\n\n        byte[] origBytes = Long.toString(orig).getBytes();\n        byte[] fangBytes = (Long.toString(fang1) + Long.toString(fang2)).getBytes();\n        Arrays.sort(origBytes);\n        Arrays.sort(fangBytes);\n        return Arrays.equals(origBytes, fangBytes);\n    }\n\n    public static void main(String[] args){\n        HashSet<Long> vamps = new HashSet<Long>();\n        for(long i = 10; vamps.size() <= 25; i++ ){\n            if((numDigits(i) % 2) != 0) {i = i * 10 - 1; continue;}\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        vamps.add(i);\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n        Long[] nums = {16758243290880L, 24959017348650L, 14593825548650L};\n        for(Long i : nums){\n            for(long fang1 = 2; fang1 <= Math.sqrt(i) + 1; fang1++){\n                if(i % fang1 == 0){\n                    long fang2 = i / fang1;\n                    if(fangCheck(i, fang1, fang2) && fang1 <= fang2){\n                        System.out.println(i + \": [\" + fang1 + \", \" + fang2 +\"]\");\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404559, "name": "Poker hand analyser", "source": "Translate Haskell to Java: \n\nimport Data.Function (on)\nimport Data.List     (group, nub, any, sort, sortBy)\nimport Data.Maybe    (mapMaybe)\nimport Text.Read     (readMaybe)\n\ndata Suit = Club | Diamond | Spade | Heart deriving (Show, Eq)\n\ndata Rank = Ace | Two | Three | Four | Five | Six | Seven\n          | Eight | Nine | Ten | Jack | Queen | King\n          deriving (Show, Eq, Enum, Ord, Bounded)\n\ndata Card = Card { suit :: Suit, rank :: Rank } deriving (Show, Eq)\n\ntype Hand = [Card]\n\nconsumed = pure . (, \"\")\n\ninstance Read Suit where\n  readsPrec d s = case s of \"\u2665\" -> consumed Heart\n                            \"\u2666\" -> consumed Diamond\n                            \"\u2663\" -> consumed Spade\n                            \"\u2660\" -> consumed Club\n                            \"h\" -> consumed Heart\n                            _   -> []\n\ninstance Read Rank where\n  readsPrec d s = case s of \"a\"  -> consumed Ace\n                            \"2\"  -> consumed Two\n                            \"3\"  -> consumed Three\n                            \"4\"  -> consumed Four\n                            \"5\"  -> consumed Five\n                            \"6\"  -> consumed Six\n                            \"7\"  -> consumed Seven\n                            \"8\"  -> consumed Eight\n                            \"9\"  -> consumed Nine\n                            \"10\" -> consumed Ten\n                            \"j\"  -> consumed Jack\n                            \"q\"  -> consumed Queen\n                            \"k\"  -> consumed King\n                            _    -> []\n\ninstance Read Card where\n  readsPrec d = fmap (, \"\") . mapMaybe card . lex\n    where \n      card (r, s) = Card <$> (readMaybe s :: Maybe Suit)\n                         <*> (readMaybe r :: Maybe Rank)\n\n\nacesHigh :: [Rank]\nacesHigh = [Ace, Ten, Jack, Queen, King]\n\nisSucc :: (Enum a, Eq a, Bounded a) => [a] -> Bool\nisSucc []  = True\nisSucc [x] = True\nisSucc (x:y:zs) = (x /= maxBound && y == succ x) && isSucc (y:zs)\n\nnameHand :: Hand -> String\nnameHand [] = \"Invalid Input\"\nnameHand cards | invalidHand          = \"Invalid hand\"\n               | straight && flush    = \"Straight flush\"\n               | ofKind 4             = \"Four of a kind\"\n               | ofKind 3 && ofKind 2 = \"Full house\"\n               | flush                = \"Flush\"\n               | straight             = \"Straight\"\n               | ofKind 3             = \"Three of a kind\"\n               | uniqRanks == 3       = \"Two pair\"\n               | uniqRanks == 4       = \"One pair\"\n               | otherwise            = \"High card\"\n where\n  sortedRank  = sort $ rank <$> cards\n  rankCounts  = sortBy (compare `on` snd) $ (,) <$> head <*> length <$> group sortedRank\n  uniqRanks   = length rankCounts\n  ofKind n    = any ((==n) . snd) rankCounts\n  straight    = isSucc sortedRank || sortedRank == acesHigh\n  flush       = length (nub $ suit <$> cards) == 1\n  invalidHand = length (nub cards) /= 5\n\ntestHands :: [(String, Hand)]\ntestHands = (,) <$> id <*> mapMaybe readMaybe . words <$>\n  [ \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\"\n  , \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\"\n  , \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\"\n  , \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\"\n  , \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\"\n  , \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 7\u2663\" \n  , \"Bad input\" ]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . (fst <> const \": \" <> nameHand . snd)) testHands\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\n\npublic class PokerHandAnalyzer {\n\n    final static String faces = \"AKQJT98765432\";\n    final static String suits = \"HDSC\";\n    final static String[] deck = buildDeck();\n\n    public static void main(String[] args) {\n        System.out.println(\"Regular hands:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS QD\",\n            \"2H 5H 7D 8S 9D\",\n            \"AH 2D 3S 4S 5S\",\n            \"2H 3H 2D 3S 3D\",\n            \"2H 7H 2D 3S 3D\",\n            \"2H 7H 7D 7S 7C\",\n            \"TH JH QH KH AH\",\n            \"4H 4C KC 5D TC\",\n            \"QC TC 7C 6C 4C\",\n            \"QC TC 7C 7C TD\"}) {\n            System.out.println(analyzeHand(input.split(\" \")));\n        }\n\n        System.out.println(\"\\nHands with wildcards:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS WW\",\n            \"2H 5H 7D 8S WW\",\n            \"AH 2D 3S 4S WW\",\n            \"2H 3H 2D 3S WW\",\n            \"2H 7H 2D 3S WW\",\n            \"2H 7H 7D WW WW\",\n            \"TH JH QH WW WW\",\n            \"4H 4C KC WW WW\",\n            \"QC TC 7C WW WW\",\n            \"QC TC 7H WW WW\"}) {\n            System.out.println(analyzeHandWithWildcards(input.split(\" \")));\n        }\n    }\n\n    private static Score analyzeHand(final String[] hand) {\n        if (hand.length != 5)\n            return new Score(\"invalid hand: wrong number of cards\", -1, hand);\n\n        if (new HashSet<>(Arrays.asList(hand)).size() != hand.length)\n            return new Score(\"invalid hand: duplicates\", -1, hand);\n\n        int[] faceCount = new int[faces.length()];\n        long straight = 0, flush = 0;\n        for (String card : hand) {\n\n            int face = faces.indexOf(card.charAt(0));\n            if (face == -1)\n                return new Score(\"invalid hand: non existing face\", -1, hand);\n            straight |= (1 << face);\n\n            faceCount[face]++;\n\n            if (suits.indexOf(card.charAt(1)) == -1)\n                return new Score(\"invalid hand: non-existing suit\", -1, hand);\n            flush |= (1 << card.charAt(1));\n        }\n\n        \n        while (straight % 2 == 0)\n            straight >>= 1;\n\n        \n        boolean hasStraight = straight == 0b11111 || straight == 0b1111000000001;\n\n        \n        boolean hasFlush = (flush & (flush - 1)) == 0;\n\n        if (hasStraight && hasFlush)\n            return new Score(\"straight-flush\", 9, hand);\n\n        int total = 0;\n        for (int count : faceCount) {\n            if (count == 4)\n                return new Score(\"four-of-a-kind\", 8, hand);\n            if (count == 3)\n                total += 3;\n            else if (count == 2)\n                total += 2;\n        }\n\n        if (total == 5)\n            return new Score(\"full-house\", 7, hand);\n\n        if (hasFlush)\n            return new Score(\"flush\", 6, hand);\n\n        if (hasStraight)\n            return new Score(\"straight\", 5, hand);\n\n        if (total == 3)\n            return new Score(\"three-of-a-kind\", 4, hand);\n\n        if (total == 4)\n            return new Score(\"two-pair\", 3, hand);\n\n        if (total == 2)\n            return new Score(\"one-pair\", 2, hand);\n\n        return new Score(\"high-card\", 1, hand);\n    }\n\n    private static WildScore analyzeHandWithWildcards(String[] hand) {\n        if (Collections.frequency(Arrays.asList(hand), \"WW\") > 2)\n            throw new IllegalArgumentException(\"too many wildcards\");\n\n        return new WildScore(analyzeHandWithWildcardsR(hand, null), hand.clone());\n    }\n\n    private static Score analyzeHandWithWildcardsR(String[] hand,\n            Score best) {\n\n        for (int i = 0; i < hand.length; i++) {\n            if (hand[i].equals(\"WW\")) {\n                for (String card : deck) {\n                    if (!Arrays.asList(hand).contains(card)) {\n                        hand[i] = card;\n                        best = analyzeHandWithWildcardsR(hand, best);\n                    }\n                }\n                hand[i] = \"WW\";\n                break;\n            }\n        }\n        Score result = analyzeHand(hand);\n        if (best == null || result.weight > best.weight)\n            best = result;\n        return best;\n    }\n\n    private static String[] buildDeck() {\n        String[] dck = new String[suits.length() * faces.length()];\n        int i = 0;\n        for (char s : suits.toCharArray()) {\n            for (char f : faces.toCharArray()) {\n                dck[i] = \"\" + f + s;\n                i++;\n            }\n        }\n        return dck;\n    }\n\n    private static class Score {\n        final int weight;\n        final String name;\n        final String[] hand;\n\n        Score(String n, int w, String[] h) {\n            weight = w;\n            name = n;\n            hand = h != null ? h.clone() : h;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(hand) + \" \" + name;\n        }\n    }\n\n    private static class WildScore {\n        final String[] wild;\n        final Score score;\n\n        WildScore(Score s, String[] w) {\n            score = s;\n            wild = w;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s%n%s%n\", Arrays.toString(wild),\n                    score.toString());\n        }\n    }\n}\n"}
{"id": 404560, "name": "Poker hand analyser", "source": "Translate Haskell to Java: \n\nimport Data.Function (on)\nimport Data.List     (group, nub, any, sort, sortBy)\nimport Data.Maybe    (mapMaybe)\nimport Text.Read     (readMaybe)\n\ndata Suit = Club | Diamond | Spade | Heart deriving (Show, Eq)\n\ndata Rank = Ace | Two | Three | Four | Five | Six | Seven\n          | Eight | Nine | Ten | Jack | Queen | King\n          deriving (Show, Eq, Enum, Ord, Bounded)\n\ndata Card = Card { suit :: Suit, rank :: Rank } deriving (Show, Eq)\n\ntype Hand = [Card]\n\nconsumed = pure . (, \"\")\n\ninstance Read Suit where\n  readsPrec d s = case s of \"\u2665\" -> consumed Heart\n                            \"\u2666\" -> consumed Diamond\n                            \"\u2663\" -> consumed Spade\n                            \"\u2660\" -> consumed Club\n                            \"h\" -> consumed Heart\n                            _   -> []\n\ninstance Read Rank where\n  readsPrec d s = case s of \"a\"  -> consumed Ace\n                            \"2\"  -> consumed Two\n                            \"3\"  -> consumed Three\n                            \"4\"  -> consumed Four\n                            \"5\"  -> consumed Five\n                            \"6\"  -> consumed Six\n                            \"7\"  -> consumed Seven\n                            \"8\"  -> consumed Eight\n                            \"9\"  -> consumed Nine\n                            \"10\" -> consumed Ten\n                            \"j\"  -> consumed Jack\n                            \"q\"  -> consumed Queen\n                            \"k\"  -> consumed King\n                            _    -> []\n\ninstance Read Card where\n  readsPrec d = fmap (, \"\") . mapMaybe card . lex\n    where \n      card (r, s) = Card <$> (readMaybe s :: Maybe Suit)\n                         <*> (readMaybe r :: Maybe Rank)\n\n\nacesHigh :: [Rank]\nacesHigh = [Ace, Ten, Jack, Queen, King]\n\nisSucc :: (Enum a, Eq a, Bounded a) => [a] -> Bool\nisSucc []  = True\nisSucc [x] = True\nisSucc (x:y:zs) = (x /= maxBound && y == succ x) && isSucc (y:zs)\n\nnameHand :: Hand -> String\nnameHand [] = \"Invalid Input\"\nnameHand cards | invalidHand          = \"Invalid hand\"\n               | straight && flush    = \"Straight flush\"\n               | ofKind 4             = \"Four of a kind\"\n               | ofKind 3 && ofKind 2 = \"Full house\"\n               | flush                = \"Flush\"\n               | straight             = \"Straight\"\n               | ofKind 3             = \"Three of a kind\"\n               | uniqRanks == 3       = \"Two pair\"\n               | uniqRanks == 4       = \"One pair\"\n               | otherwise            = \"High card\"\n where\n  sortedRank  = sort $ rank <$> cards\n  rankCounts  = sortBy (compare `on` snd) $ (,) <$> head <*> length <$> group sortedRank\n  uniqRanks   = length rankCounts\n  ofKind n    = any ((==n) . snd) rankCounts\n  straight    = isSucc sortedRank || sortedRank == acesHigh\n  flush       = length (nub $ suit <$> cards) == 1\n  invalidHand = length (nub cards) /= 5\n\ntestHands :: [(String, Hand)]\ntestHands = (,) <$> id <*> mapMaybe readMaybe . words <$>\n  [ \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\"\n  , \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\"\n  , \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\"\n  , \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\"\n  , \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\"\n  , \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 7\u2663\" \n  , \"Bad input\" ]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . (fst <> const \": \" <> nameHand . snd)) testHands\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\n\npublic class PokerHandAnalyzer {\n\n    final static String faces = \"AKQJT98765432\";\n    final static String suits = \"HDSC\";\n    final static String[] deck = buildDeck();\n\n    public static void main(String[] args) {\n        System.out.println(\"Regular hands:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS QD\",\n            \"2H 5H 7D 8S 9D\",\n            \"AH 2D 3S 4S 5S\",\n            \"2H 3H 2D 3S 3D\",\n            \"2H 7H 2D 3S 3D\",\n            \"2H 7H 7D 7S 7C\",\n            \"TH JH QH KH AH\",\n            \"4H 4C KC 5D TC\",\n            \"QC TC 7C 6C 4C\",\n            \"QC TC 7C 7C TD\"}) {\n            System.out.println(analyzeHand(input.split(\" \")));\n        }\n\n        System.out.println(\"\\nHands with wildcards:\\n\");\n        for (String input : new String[]{\"2H 2D 2S KS WW\",\n            \"2H 5H 7D 8S WW\",\n            \"AH 2D 3S 4S WW\",\n            \"2H 3H 2D 3S WW\",\n            \"2H 7H 2D 3S WW\",\n            \"2H 7H 7D WW WW\",\n            \"TH JH QH WW WW\",\n            \"4H 4C KC WW WW\",\n            \"QC TC 7C WW WW\",\n            \"QC TC 7H WW WW\"}) {\n            System.out.println(analyzeHandWithWildcards(input.split(\" \")));\n        }\n    }\n\n    private static Score analyzeHand(final String[] hand) {\n        if (hand.length != 5)\n            return new Score(\"invalid hand: wrong number of cards\", -1, hand);\n\n        if (new HashSet<>(Arrays.asList(hand)).size() != hand.length)\n            return new Score(\"invalid hand: duplicates\", -1, hand);\n\n        int[] faceCount = new int[faces.length()];\n        long straight = 0, flush = 0;\n        for (String card : hand) {\n\n            int face = faces.indexOf(card.charAt(0));\n            if (face == -1)\n                return new Score(\"invalid hand: non existing face\", -1, hand);\n            straight |= (1 << face);\n\n            faceCount[face]++;\n\n            if (suits.indexOf(card.charAt(1)) == -1)\n                return new Score(\"invalid hand: non-existing suit\", -1, hand);\n            flush |= (1 << card.charAt(1));\n        }\n\n        \n        while (straight % 2 == 0)\n            straight >>= 1;\n\n        \n        boolean hasStraight = straight == 0b11111 || straight == 0b1111000000001;\n\n        \n        boolean hasFlush = (flush & (flush - 1)) == 0;\n\n        if (hasStraight && hasFlush)\n            return new Score(\"straight-flush\", 9, hand);\n\n        int total = 0;\n        for (int count : faceCount) {\n            if (count == 4)\n                return new Score(\"four-of-a-kind\", 8, hand);\n            if (count == 3)\n                total += 3;\n            else if (count == 2)\n                total += 2;\n        }\n\n        if (total == 5)\n            return new Score(\"full-house\", 7, hand);\n\n        if (hasFlush)\n            return new Score(\"flush\", 6, hand);\n\n        if (hasStraight)\n            return new Score(\"straight\", 5, hand);\n\n        if (total == 3)\n            return new Score(\"three-of-a-kind\", 4, hand);\n\n        if (total == 4)\n            return new Score(\"two-pair\", 3, hand);\n\n        if (total == 2)\n            return new Score(\"one-pair\", 2, hand);\n\n        return new Score(\"high-card\", 1, hand);\n    }\n\n    private static WildScore analyzeHandWithWildcards(String[] hand) {\n        if (Collections.frequency(Arrays.asList(hand), \"WW\") > 2)\n            throw new IllegalArgumentException(\"too many wildcards\");\n\n        return new WildScore(analyzeHandWithWildcardsR(hand, null), hand.clone());\n    }\n\n    private static Score analyzeHandWithWildcardsR(String[] hand,\n            Score best) {\n\n        for (int i = 0; i < hand.length; i++) {\n            if (hand[i].equals(\"WW\")) {\n                for (String card : deck) {\n                    if (!Arrays.asList(hand).contains(card)) {\n                        hand[i] = card;\n                        best = analyzeHandWithWildcardsR(hand, best);\n                    }\n                }\n                hand[i] = \"WW\";\n                break;\n            }\n        }\n        Score result = analyzeHand(hand);\n        if (best == null || result.weight > best.weight)\n            best = result;\n        return best;\n    }\n\n    private static String[] buildDeck() {\n        String[] dck = new String[suits.length() * faces.length()];\n        int i = 0;\n        for (char s : suits.toCharArray()) {\n            for (char f : faces.toCharArray()) {\n                dck[i] = \"\" + f + s;\n                i++;\n            }\n        }\n        return dck;\n    }\n\n    private static class Score {\n        final int weight;\n        final String name;\n        final String[] hand;\n\n        Score(String n, int w, String[] h) {\n            weight = w;\n            name = n;\n            hand = h != null ? h.clone() : h;\n        }\n\n        @Override\n        public String toString() {\n            return Arrays.toString(hand) + \" \" + name;\n        }\n    }\n\n    private static class WildScore {\n        final String[] wild;\n        final Score score;\n\n        WildScore(Score s, String[] w) {\n            score = s;\n            wild = w;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s%n%s%n\", Arrays.toString(wild),\n                    score.toString());\n        }\n    }\n}\n"}
{"id": 404561, "name": "Fibonacci word_fractal", "source": "Translate Haskell to Java: import Data.List (unfoldr)\nimport Data.Bool (bool)\nimport Data.Semigroup (Sum(..), Min(..), Max(..))\nimport System.IO (writeFile)\n\nfibonacciWord :: a -> a -> [[a]]\nfibonacciWord a b = unfoldr (\\(a,b) -> Just (a, (b, a <> b))) ([a], [b])\n\ntoPath :: [Bool] -> ((Min Int, Max Int, Min Int, Max Int), String)\ntoPath = foldMap (\\p -> (box p, point p)) .\n         scanl (<>) mempty .\n         scanl (\\dir (turn, s) -> bool dir (turn dir) s) (1, 0) .\n         zip (cycle [left, right])\n  where\n    box (Sum x, Sum y) = (Min x, Max x, Min y, Max y)\n    point (Sum x, Sum y) = show x ++ \",\" ++ show y ++ \" \"\n    left (x,y) = (-y, x)\n    right (x,y) = (y, -x)\n\ntoSVG :: [Bool] -> String\ntoSVG w =\n  let ((Min x1, Max x2, Min y1, Max y2), path) = toPath w\n  in unwords\n     [ \"<svg xmlns='http://www.w3.org/2000/svg'\"\n     , \"width='500' height='500'\"\n     , \"stroke='black' fill='none' strokeWidth='2'\" \n     , \"viewBox='\" ++ unwords (show <$> [x1,y1,x2-x1,y2-y1]) ++ \"'>\"\n     , \"<polyline points='\" ++ path ++ \"'/>\"\n     , \"</svg>\"]  \n\nmain = writeFile \"test.html\" $ toSVG $ fibonacciWord True False !! 21\n", "target": "import java.awt.*;\nimport javax.swing.*;\n\npublic class FibonacciWordFractal extends JPanel {\n    String wordFractal;\n\n    FibonacciWordFractal(int n) {\n        setPreferredSize(new Dimension(450, 620));\n        setBackground(Color.white);\n        wordFractal = wordFractal(n);\n    }\n\n    public String wordFractal(int n) {\n        if (n < 2)\n            return n == 1 ? \"1\" : \"\";\n\n        \n        StringBuilder f1 = new StringBuilder(\"1\");\n        StringBuilder f2 = new StringBuilder(\"0\");\n\n        for (n = n - 2; n > 0; n--) {\n            String tmp = f2.toString();\n            f2.append(f1);\n\n            f1.setLength(0);\n            f1.append(tmp);\n        }\n\n        return f2.toString();\n    }\n\n    void drawWordFractal(Graphics2D g, int x, int y, int dx, int dy) {\n        for (int n = 0; n < wordFractal.length(); n++) {\n            g.drawLine(x, y, x + dx, y + dy);\n            x += dx;\n            y += dy;\n            if (wordFractal.charAt(n) == '0') {\n                int tx = dx;\n                dx = (n % 2 == 0) ? -dy : dy;\n                dy = (n % 2 == 0) ? tx : -tx;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawWordFractal(g, 20, 20, 1, 0);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Fibonacci Word Fractal\");\n            f.setResizable(false);\n            f.add(new FibonacciWordFractal(23), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 404562, "name": "Penney's game", "source": "Translate Haskell to Java: import qualified Data.List as L\nimport System.IO\nimport System.Random\n\ndata CoinToss = H | T deriving (Read, Show, Eq)\n\nparseToss :: String -> [CoinToss]\nparseToss [] = []\nparseToss (s:sx)\n  | s == 'h' || s == 'H' = H : parseToss sx\n  | s == 't' || s == 'T' = T : parseToss sx\n  | otherwise = parseToss sx\n\nnotToss :: CoinToss -> CoinToss\nnotToss H = T\nnotToss T = H\n\ninstance Random CoinToss where\n  random g = let (b, gb) = random g in (if b then H else T, gb)\n  randomR = undefined\n\nprompt :: (Read a) => String -> String -> (String -> Maybe a) -> IO a\nprompt msg err parse = do\n  putStrLn msg\n  line <- getLine\n  let ans = parse line\n  case ans of\n    Nothing   -> do\n      putStrLn err\n      prompt msg err parse\n    Just ansB -> return ansB\n\nshowCat :: (Show a) => [a] -> String\nshowCat = concatMap show\n\ndata Winner = Player | CPU\n\n\nrunToss :: (RandomGen g) => [CoinToss] -> [CoinToss] -> g -> ([CoinToss], Winner)\nrunToss player cpu gen =\n  let stream = randoms gen\n      run ss@(s:sx)\n        | L.isPrefixOf player ss = player\n        | L.isPrefixOf cpu ss    = cpu\n        | otherwise              = s : run sx\n      winner = run stream\n  in if L.isSuffixOf player winner\n     then (winner, Player)\n     else (winner, CPU)\n\ngame :: (RandomGen g, Num a, Show a) => Bool -> a -> a -> g -> IO ()\ngame cpuTurn playerScore cpuScore gen = do\n  putStrLn $ \"\\nThe current score is CPU: \" ++ show cpuScore\n    ++ \", You: \" ++ show playerScore\n\n  let (genA, genB) = split gen\n      promptPlayer check =\n        prompt \"Pick 3 coin sides: \" \"Invalid input.\" $ \\s ->\n          let tosses = parseToss s in\n          if check tosses then Just tosses else Nothing\n      promptCpu x  = putStrLn $ \"I have chosen: \" ++ showCat x\n\n  (tosses, winner) <-\n    if cpuTurn\n    then do\n      let cpuChoice = take 3 $ randoms gen\n      promptCpu cpuChoice\n      playerChoice <- promptPlayer $ \\n -> n /= cpuChoice && 3 == length n\n      return $ runToss playerChoice cpuChoice genA\n    else do\n      playerChoice <- promptPlayer $ \\n -> 3 == length n\n      let cpuChoice = case playerChoice of [a,b,_] -> [notToss b, a, b]\n      promptCpu cpuChoice\n      return $ runToss playerChoice cpuChoice genA\n\n  putStrLn $ \"The sequence tossed was: \" ++ showCat tosses\n\n  case winner of\n    Player -> do\n      putStrLn \"You win!\"\n      game (not cpuTurn) (playerScore + 1) cpuScore genB\n    CPU -> do\n      putStrLn \"I win!\"\n      game (not cpuTurn) playerScore (cpuScore + 1) genB\n\nmain :: IO ()\nmain = do\n  hSetBuffering stdin LineBuffering\n  stdgen <- getStdGen\n  let (cpuFirst, genA) = random stdgen\n  game cpuFirst 0 0 genA\n", "target": "import java.util.*;\n\npublic class PenneysGame {\n\n    public static void main(String[] args) {\n        Random rand = new Random();\n\n        String compChoice = \"\", playerChoice;\n        if (rand.nextBoolean()) {\n\n            for (int i = 0; i < 3; i++)\n                compChoice += \"HT\".charAt(rand.nextInt(2));\n            System.out.printf(\"Computer chooses %s%n\", compChoice);\n\n            playerChoice = prompt(compChoice);\n\n        } else {\n\n            playerChoice = prompt(compChoice);\n\n            compChoice = \"T\";\n            if (playerChoice.charAt(1) == 'T')\n                compChoice = \"H\";\n            compChoice += playerChoice.substring(0, 2);\n            System.out.printf(\"Computer chooses %s%n\", compChoice);\n        }\n\n        String tossed = \"\";\n        while (true) {\n            tossed += \"HT\".charAt(rand.nextInt(2));\n            System.out.printf(\"Tossed %s%n\" , tossed);\n            if (tossed.endsWith(playerChoice)) {\n                System.out.println(\"You win!\");\n                break;\n            }\n            if (tossed.endsWith(compChoice)) {\n                System.out.println(\"Computer wins!\");\n                break;\n            }\n        }\n    }\n\n    private static String prompt(String otherChoice) {\n        Scanner sc = new Scanner(System.in);\n        String s;\n        do {\n            System.out.print(\"Choose a sequence: \");\n            s = sc.nextLine().trim().toUpperCase();\n        } while (!s.matches(\"[HT]{3}\") || s.equals(otherChoice));\n        return s;\n    }\n}\n"}
{"id": 404563, "name": "Sierpinski triangle_Graphical", "source": "Translate Haskell to Java: import Diagrams.Prelude\nimport Diagrams.Backend.Cairo.CmdLine\n\ntriangle = eqTriangle # fc black # lw 0\n\nreduce t =     t\n              ===\n           (t ||| t)\n\nsierpinski = iterate reduce triangle\n\nmain = defaultMain $ sierpinski !! 7\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}\n"}
{"id": 404564, "name": "Sierpinski triangle_Graphical", "source": "Translate Haskell to Java: import Diagrams.Prelude\nimport Diagrams.Backend.Cairo.CmdLine\n\ntriangle = eqTriangle # fc black # lw 0\n\nreduce t =     t\n              ===\n           (t ||| t)\n\nsierpinski = iterate reduce triangle\n\nmain = defaultMain $ sierpinski !! 7\n", "target": "import javax.swing.*;\nimport java.awt.*;\n\n \n\nclass SierpinskyTriangle {\n\n\tpublic static void main(String[] args) {\n\t\tint i = 3;\t\t\n\t\tif(args.length >= 1) {\n\t\t\ttry {\n\t\t\t\ti = Integer.parseInt(args[0]);\n\t\t\t}\n\t\t\tcatch(NumberFormatException e) {\n\t\t\t\tSystem.out.println(\"Usage: 'java SierpinskyTriangle [level]'\\nNow setting level to \"+i);\n\t\t\t}\n\t\t}\n\t\tfinal int level = i;\n\n\t\tJFrame frame = new JFrame(\"Sierpinsky Triangle - Java\");\n\t\tframe.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\n\t\tJPanel panel = new JPanel() {\n\t\t\t@Override\n\t\t\tpublic void paintComponent(Graphics g) {\n\t\t\t\tg.setColor(Color.BLACK);\n\t\t\t\tdrawSierpinskyTriangle(level, 20, 20, 360, (Graphics2D)g);\n\t\t\t}\n\t\t};\n\n\t\tpanel.setPreferredSize(new Dimension(400, 400));\n\n\t\tframe.add(panel);\n\t\tframe.pack();\n\t\tframe.setResizable(false);\n\t\tframe.setLocationRelativeTo(null);\n\t\tframe.setVisible(true);\n\t}\n\n\tprivate static void drawSierpinskyTriangle(int level, int x, int y, int size, Graphics2D g) {\n\t\tif(level <= 0) return;\n\n\t\tg.drawLine(x, y, x+size, y);\n\t\tg.drawLine(x, y, x, y+size);\n\t\tg.drawLine(x+size, y, x, y+size);\n\n\t\tdrawSierpinskyTriangle(level-1, x, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x+size/2, y, size/2, g);\n\t\tdrawSierpinskyTriangle(level-1, x, y+size/2, size/2, g);\n\t}\n}\n"}
{"id": 404565, "name": "Eban numbers", "source": "Translate Haskell to Java: \nimport Data.List (intercalate)\nimport Text.Printf (printf)\nimport Data.List.Split (chunksOf)\n\nisEban :: Int -> Bool\nisEban n = all (`elem` [0, 2, 4, 6]) z\n where\n  (b, r1) = n  `quotRem` (10 ^ 9)\n  (m, r2) = r1 `quotRem` (10 ^ 6)\n  (t, r3) = r2 `quotRem` (10 ^ 3)\n  z       = b : map (\\x -> if x >= 30 && x <= 66 then x `mod` 10 else x) [m, t, r3]\n\nebans = map f\n where\n  f x = (thousands x, thousands $ length $ filter isEban [1..x])\n\nthousands:: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  uncurry (printf \"eban numbers up to and including 1000: %2s\\n%s\\n\\n\") $ r [1..1000]\n  uncurry (printf \"eban numbers between 1000 and 4000: %2s\\n%s\\n\\n\") $ r [1000..4000]\n  mapM_ (uncurry (printf \"eban numbers up and including %13s: %5s\\n\")) ebanCounts\n where \n  ebanCounts = ebans [        10_000\n                     ,       100_000\n                     ,     1_000_000\n                     ,    10_000_000\n                     ,   100_000_000\n                     , 1_000_000_000 ]\n  r = ((,) <$> thousands . length <*> show) . filter isEban\n", "target": "import java.util.List;\n\npublic class Main {\n    private static class Range {\n        int start;\n        int end;\n        boolean print;\n\n        public Range(int s, int e, boolean p) {\n            start = s;\n            end = e;\n            print = p;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Range> rgs = List.of(\n            new Range(2, 1000, true),\n            new Range(1000, 4000, true),\n            new Range(2, 10_000, false),\n            new Range(2, 100_000, false),\n            new Range(2, 1_000_000, false),\n            new Range(2, 10_000_000, false),\n            new Range(2, 100_000_000, false),\n            new Range(2, 1_000_000_000, false)\n        );\n        for (Range rg : rgs) {\n            if (rg.start == 2) {\n                System.out.printf(\"eban numbers up to and including %d\\n\", rg.end);\n            } else {\n                System.out.printf(\"eban numbers between %d and %d\\n\", rg.start, rg.end);\n            }\n            int count = 0;\n            for (int i = rg.start; i <= rg.end; ++i) {\n                int b = i / 1_000_000_000;\n                int r = i % 1_000_000_000;\n                int m = r / 1_000_000;\n                r = i % 1_000_000;\n                int t = r / 1_000;\n                r %= 1_000;\n                if (m >= 30 && m <= 66) m %= 10;\n                if (t >= 30 && t <= 66) t %= 10;\n                if (r >= 30 && r <= 66) r %= 10;\n                if (b == 0 || b == 2 || b == 4 || b == 6) {\n                    if (m == 0 || m == 2 || m == 4 || m == 6) {\n                        if (t == 0 || t == 2 || t == 4 || t == 6) {\n                            if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                if (rg.print) System.out.printf(\"%d \", i);\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n            if (rg.print) {\n                System.out.println();\n            }\n            System.out.printf(\"count = %d\\n\\n\", count);\n        }\n    }\n}\n"}
{"id": 404566, "name": "Eban numbers", "source": "Translate Haskell to Java: \nimport Data.List (intercalate)\nimport Text.Printf (printf)\nimport Data.List.Split (chunksOf)\n\nisEban :: Int -> Bool\nisEban n = all (`elem` [0, 2, 4, 6]) z\n where\n  (b, r1) = n  `quotRem` (10 ^ 9)\n  (m, r2) = r1 `quotRem` (10 ^ 6)\n  (t, r3) = r2 `quotRem` (10 ^ 3)\n  z       = b : map (\\x -> if x >= 30 && x <= 66 then x `mod` 10 else x) [m, t, r3]\n\nebans = map f\n where\n  f x = (thousands x, thousands $ length $ filter isEban [1..x])\n\nthousands:: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  uncurry (printf \"eban numbers up to and including 1000: %2s\\n%s\\n\\n\") $ r [1..1000]\n  uncurry (printf \"eban numbers between 1000 and 4000: %2s\\n%s\\n\\n\") $ r [1000..4000]\n  mapM_ (uncurry (printf \"eban numbers up and including %13s: %5s\\n\")) ebanCounts\n where \n  ebanCounts = ebans [        10_000\n                     ,       100_000\n                     ,     1_000_000\n                     ,    10_000_000\n                     ,   100_000_000\n                     , 1_000_000_000 ]\n  r = ((,) <$> thousands . length <*> show) . filter isEban\n", "target": "import java.util.List;\n\npublic class Main {\n    private static class Range {\n        int start;\n        int end;\n        boolean print;\n\n        public Range(int s, int e, boolean p) {\n            start = s;\n            end = e;\n            print = p;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Range> rgs = List.of(\n            new Range(2, 1000, true),\n            new Range(1000, 4000, true),\n            new Range(2, 10_000, false),\n            new Range(2, 100_000, false),\n            new Range(2, 1_000_000, false),\n            new Range(2, 10_000_000, false),\n            new Range(2, 100_000_000, false),\n            new Range(2, 1_000_000_000, false)\n        );\n        for (Range rg : rgs) {\n            if (rg.start == 2) {\n                System.out.printf(\"eban numbers up to and including %d\\n\", rg.end);\n            } else {\n                System.out.printf(\"eban numbers between %d and %d\\n\", rg.start, rg.end);\n            }\n            int count = 0;\n            for (int i = rg.start; i <= rg.end; ++i) {\n                int b = i / 1_000_000_000;\n                int r = i % 1_000_000_000;\n                int m = r / 1_000_000;\n                r = i % 1_000_000;\n                int t = r / 1_000;\n                r %= 1_000;\n                if (m >= 30 && m <= 66) m %= 10;\n                if (t >= 30 && t <= 66) t %= 10;\n                if (r >= 30 && r <= 66) r %= 10;\n                if (b == 0 || b == 2 || b == 4 || b == 6) {\n                    if (m == 0 || m == 2 || m == 4 || m == 6) {\n                        if (t == 0 || t == 2 || t == 4 || t == 6) {\n                            if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                if (rg.print) System.out.printf(\"%d \", i);\n                                count++;\n                            }\n                        }\n                    }\n                }\n            }\n            if (rg.print) {\n                System.out.println();\n            }\n            System.out.printf(\"count = %d\\n\\n\", count);\n        }\n    }\n}\n"}
{"id": 404567, "name": "Mayan numerals", "source": "Translate Haskell to Java: import Data.Bool (bool)\nimport Data.List (intercalate, transpose)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (maybe)\n\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n    mayanFramed\n      <$> [ 4005,\n            8017,\n            326205,\n            886205,\n            1081439556,\n            1000000,\n            1000000000\n          ]\n\n\nmayanGlyph :: Int -> [[String]]\nmayanGlyph =\n  filter (any (not . null))\n    . transpose\n    . leftPadded\n    . flip (showIntAtBaseS 20 mayanDigit) []\n\nmayanDigit :: Int -> [String]\nmayanDigit n\n  | 0 /= n =\n    replicate (rem n 5) mayaOne :\n    concat\n      ( replicate (quot n 5) [mayaFive]\n      )\n  | otherwise = [[mayaZero]]\n\nmayanFramed :: Int -> String\nmayanFramed =\n  (\"Mayan \" <>)\n    . ( (<>) <$> show\n          <*> ( (\":\\n\\n\" <>)\n                  . wikiTable\n                    ( M.fromList\n                        [ ( \"style\",\n                            concat\n                              [ \"text-align:center;\",\n                                \"background-color:#F0EDDE;\",\n                                \"color:#605B4B;\",\n                                \"border:2px solid silver;\"\n                              ]\n                          ),\n                          (\"colwidth\", \"3em;\")\n                        ]\n                    )\n                  . mayanGlyph\n              )\n      )\n\nmayaZero, mayaOne :: Char\nmayaZero = '\\920'\nmayaOne = '\\9679'\n\nmayaFive :: String\nmayaFive = \"\\9473\\9473\"\n\n\n\n\n\n\n\n\n\nshowIntAtBaseS ::\n  Integral a =>\n  a ->\n  (Int -> [String]) ->\n  a ->\n  [[String]] ->\n  [[String]]\nshowIntAtBaseS base toStr n0 r0 =\n  let go (n, d) r =\n        seq s $\n          case n of\n            0 -> r_\n            _ -> go (quotRem n base) r_\n        where\n          s = toStr (fromIntegral d)\n          r_ = s : r\n   in go (quotRem n0 base) r0\n\n\nwikiTable :: M.Map String String -> [[String]] -> String\nwikiTable opts rows\n  | null rows = []\n  | otherwise =\n    \"{| \"\n      <> foldr\n        ( \\k a ->\n            maybe\n              a\n              ( ((a <> k <> \"=\\\"\") <>)\n                  . ( <> \"\\\" \"\n                    )\n              )\n              (M.lookup k opts)\n        )\n        []\n        [\"class\", \"style\"]\n      <> ( '\\n' :\n           intercalate\n             \"|-\\n\"\n             ( zipWith renderedRow rows [0 ..]\n             )\n         )\n      <> \"|}\\n\\n\"\n  where\n    renderedRow row i =\n      unlines\n        ( fmap\n            ( ( bool\n                  []\n                  ( maybe\n                      \"|\"\n                      ((\"|style=\\\"width:\" <>) . (<> \"\\\"\"))\n                      (M.lookup \"colwidth\" opts)\n                  )\n                  (0 == i)\n                  <>\n              )\n                . ('|' :)\n            )\n            row\n        )\n\nleftPadded :: [[String]] -> [[String]]\nleftPadded xs =\n  let w = maximum (length <$> xs)\n   in ((<>) =<< flip replicate [] . (-) w . length) <$> xs\n", "target": "import java.math.BigInteger;\n\npublic class MayanNumerals {\n\n    public static void main(String[] args) {\n        for ( long base10 : new long[] {4005, 8017, 326205, 886205, 1000000000, 1081439556L, 26960840421L, 503491211079L }) {\n            displayMyan(BigInteger.valueOf(base10));\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    private static char[] digits = \"0123456789ABCDEFGHJK\".toCharArray();\n    private static BigInteger TWENTY = BigInteger.valueOf(20);\n    \n    private static void displayMyan(BigInteger numBase10) {\n        System.out.printf(\"As base 10:  %s%n\", numBase10);\n        String numBase20 = \"\";\n        while ( numBase10.compareTo(BigInteger.ZERO) > 0 ) {\n            numBase20 = digits[numBase10.mod(TWENTY).intValue()] + numBase20;\n            numBase10 = numBase10.divide(TWENTY);\n        }\n        System.out.printf(\"As base 20:  %s%nAs Mayan:%n\", numBase20);\n        displayMyanLine1(numBase20);\n        displayMyanLine2(numBase20);\n        displayMyanLine3(numBase20);\n        displayMyanLine4(numBase20);\n        displayMyanLine5(numBase20);\n        displayMyanLine6(numBase20);\n    }\n \n    private static char boxUL = Character.toChars(9556)[0];\n    private static char boxTeeUp = Character.toChars(9574)[0];\n    private static char boxUR = Character.toChars(9559)[0];\n    private static char boxHorz = Character.toChars(9552)[0];\n    private static char boxVert = Character.toChars(9553)[0];\n    private static char theta = Character.toChars(952)[0];\n    private static char boxLL = Character.toChars(9562)[0];\n    private static char boxLR = Character.toChars(9565)[0];\n    private static char boxTeeLow = Character.toChars(9577)[0];\n    private static char bullet = Character.toChars(8729)[0];\n    private static char dash = Character.toChars(9472)[0];\n    \n    private static void displayMyanLine1(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxUL);\n            }\n            for ( int j = 0 ; j < 4 ; j++ ) {\n                sb.append(boxHorz);\n            }\n            sb.append(i < chars.length-1 ? boxTeeUp : boxUR);\n        }\n        System.out.println(sb.toString());\n    }\n    \n    private static String getBullet(int count) {\n        StringBuilder sb = new StringBuilder();\n        switch ( count ) {\n        case 1:  sb.append(\" \" + bullet + \"  \"); break;\n        case 2:  sb.append(\" \" + bullet + bullet + \" \"); break;\n        case 3:  sb.append(\"\" + bullet + bullet + bullet + \" \"); break;\n        case 4:  sb.append(\"\" + bullet + bullet + bullet + bullet); break;\n        default:  throw new IllegalArgumentException(\"Must be 1-4:  \" + count);\n        }\n        return sb.toString();\n    }\n\n    private static void displayMyanLine2(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case 'G':  sb.append(getBullet(1)); break;\n            case 'H':  sb.append(getBullet(2)); break;\n            case 'J':  sb.append(getBullet(3)); break;\n            case 'K':  sb.append(getBullet(4)); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n    \n    private static String DASH = getDash();\n    \n    private static String getDash() {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < 4 ; i++ ) {\n            sb.append(dash);\n        }\n        return sb.toString();\n    }\n\n    private static void displayMyanLine3(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case 'B':  sb.append(getBullet(1)); break;\n            case 'C':  sb.append(getBullet(2)); break;\n            case 'D':  sb.append(getBullet(3)); break;\n            case 'E':  sb.append(getBullet(4)); break;\n            case 'F': case 'G': case 'H': case 'J': case 'K':\n                sb.append(DASH); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n\n    private static void displayMyanLine4(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case '6':  sb.append(getBullet(1)); break;\n            case '7':  sb.append(getBullet(2)); break;\n            case '8':  sb.append(getBullet(3)); break;\n            case '9':  sb.append(getBullet(4)); break;\n            case 'A': case 'B': case 'C': case 'D': case 'E':\n            case 'F': case 'G': case 'H': case 'J': case 'K':\n                sb.append(DASH); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n\n    private static void displayMyanLine5(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxVert);\n            }\n            switch ( chars[i] ) {\n            case '0':  sb.append(\" \" + theta + \"  \"); break;\n            case '1':  sb.append(getBullet(1)); break;\n            case '2':  sb.append(getBullet(2)); break;\n            case '3':  sb.append(getBullet(3)); break;\n            case '4':  sb.append(getBullet(4)); break;\n            case '5': case '6': case '7': case '8': case '9': \n            case 'A': case 'B': case 'C': case 'D': case 'E':\n            case 'F': case 'G': case 'H': case 'J': case 'K':\n                sb.append(DASH); break;\n            default :  sb.append(\"    \");\n            }\n            sb.append(boxVert);\n        }\n        System.out.println(sb.toString());\n    }\n\n    private static void displayMyanLine6(String base20) {\n        char[] chars = base20.toCharArray();\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < chars.length ; i++ ) {\n            if ( i == 0 ) {\n                sb.append(boxLL);\n            }\n            for ( int j = 0 ; j < 4 ; j++ ) {\n                sb.append(boxHorz);\n            }\n            sb.append(i < chars.length-1 ? boxTeeLow : boxLR);\n        }\n        System.out.println(sb.toString());\n    }\n\n}\n"}
{"id": 404568, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Haskell to Java: import Control.Monad ((>=>))\nimport Data.Maybe (mapMaybe)\nimport System.Environment (getArgs)\n\n\n\ntryFor :: Int -> Int -> Maybe Int\ntryFor s = foldr (>=>) pure $ replicate s step\n  where\n    step n\n      | n `mod` (s - 1) == 0 = Just $ n * s `div` (s - 1) + 1\n      | otherwise = Nothing\n\n\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let n =\n        case args of\n          [] -> 5\n          s:_ -> read s\n      a = head . mapMaybe (tryFor n) $ [n,2 * n ..]\n  print a\n", "target": "public class Test {\n\n    static boolean valid(int n, int nuts) {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n            if (nuts % n != 1)\n                return false;\n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    public static void main(String[] args) {\n        int x = 0;\n        for (int n = 2; n < 10; n++) {\n            while (!valid(n, x))\n                x++;\n            System.out.printf(\"%d: %d%n\", n, x);\n        }\n    }\n}\n"}
{"id": 404569, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Haskell to Java: import Control.Monad ((>=>))\nimport Data.Maybe (mapMaybe)\nimport System.Environment (getArgs)\n\n\n\ntryFor :: Int -> Int -> Maybe Int\ntryFor s = foldr (>=>) pure $ replicate s step\n  where\n    step n\n      | n `mod` (s - 1) == 0 = Just $ n * s `div` (s - 1) + 1\n      | otherwise = Nothing\n\n\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let n =\n        case args of\n          [] -> 5\n          s:_ -> read s\n      a = head . mapMaybe (tryFor n) $ [n,2 * n ..]\n  print a\n", "target": "public class Test {\n\n    static boolean valid(int n, int nuts) {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n            if (nuts % n != 1)\n                return false;\n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    public static void main(String[] args) {\n        int x = 0;\n        for (int n = 2; n < 10; n++) {\n            while (!valid(n, x))\n                x++;\n            System.out.printf(\"%d: %d%n\", n, x);\n        }\n    }\n}\n"}
{"id": 404570, "name": "Nautical bell", "source": "Translate Haskell to Java: import Control.Concurrent\nimport Control.Monad\nimport Data.Time\nimport Text.Printf\n\ntype Microsecond = Int\ntype Scheduler = TimeOfDay -> Microsecond\n\n\n\n\ngetTime :: TimeZone -> IO TimeOfDay\ngetTime tz = do\n    t  <- getCurrentTime\n    return $ localTimeOfDay $ utcToLocalTime tz t\n\ngetGMTTime   = getTime utc\ngetLocalTime = getCurrentTimeZone >>= getTime\n\n\nnextInterval x y\n    | x > y = x - y\n    | mod y x > 0 = x - mod y x\n    | otherwise = 0\n\n\nonInterval :: Int -> Scheduler\nonInterval interval time = toNext dMS\n  where\n    toNext = nextInterval (1000000 * interval)\n    tDelta = timeOfDayToTime time\n    dMS    = truncate $ 1000000 * tDelta\n\ndoWithScheduler :: Scheduler -> (Int -> IO ()) -> IO ThreadId\ndoWithScheduler sched task = forkIO $ forM_ [0..] exec\n  where\n    exec n = do\n        t <- getLocalTime\n        threadDelay $ sched t\n        task n\n\n\n\n\nwatchNames = words \"Middle Morning Forenoon Afternoon Dog First\"\ncountWords = words \"One Two Three Four Five Six Seven Eight\"\n\n\npostDelay n fn = fn >> threadDelay n\n\ntermBell        = putStr \"\\a\"\ntermBells n     = replicateM_ n $ postDelay 100000 termBell\ntermBellSeq seq = forM_ seq $ postDelay 500000 . termBells\n\ntoNoteGlyph 1 = \"\u266a\"\ntoNoteGlyph 2 = \"\u266b\"\ntoNoteGlyph _ = \"\"\n\nringBells :: Int -> IO ()\nringBells n = do\n    t <- getLocalTime\n    let numBells    = 1 + (mod n 8)\n        watch       = watchNames!!(mod (div n 8) 8)\n        count       = countWords!!(numBells - 1)\n        (twos,ones) = quotRem numBells 2\n        pattern     = (replicate twos 2) ++ (replicate ones 1)\n        notes       = unwords $ map toNoteGlyph pattern\n        plural       = if numBells > 1 then \"s\" else \"\"\n        strFMT      = show t ++ \": %s watch, %5s bell%s:  \" ++ notes ++ \"\\n\"\n    printf strFMT watch count plural\n    termBellSeq pattern\n\n\n\n\nbellRinger :: IO ThreadId\nbellRinger = doWithScheduler (onInterval (30*60)) ringBells\n", "target": "import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.TimeZone;\n\npublic class NauticalBell extends Thread {\n\n    public static void main(String[] args) {\n        NauticalBell bells = new NauticalBell();\n        bells.setDaemon(true);\n        bells.start();\n        try {\n            bells.join();\n        } catch (InterruptedException e) {\n            System.out.println(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        DateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        int numBells = 0;\n        long time = System.currentTimeMillis();\n        long next = time - (time % (24 * 60 * 60 * 1000)); \n\n        while (next < time) {\n            next += 30 * 60 * 1000; \n            numBells = 1 + (numBells % 8);\n        }\n\n        while (true) {\n            long wait = 100L;\n            time = System.currentTimeMillis();\n            if (time - next >= 0) {\n                String bells = numBells == 1 ? \"bell\" : \"bells\";\n                String timeString = sdf.format(time);\n                System.out.printf(\"%s\u00a0: %d %s\\n\", timeString, numBells, bells);\n                next += 30 * 60 * 1000;\n                wait = next - time;\n                numBells = 1 + (numBells % 8);\n            }\n            try {\n                Thread.sleep(wait);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n}\n"}
{"id": 404571, "name": "Nautical bell", "source": "Translate Haskell to Java: import Control.Concurrent\nimport Control.Monad\nimport Data.Time\nimport Text.Printf\n\ntype Microsecond = Int\ntype Scheduler = TimeOfDay -> Microsecond\n\n\n\n\ngetTime :: TimeZone -> IO TimeOfDay\ngetTime tz = do\n    t  <- getCurrentTime\n    return $ localTimeOfDay $ utcToLocalTime tz t\n\ngetGMTTime   = getTime utc\ngetLocalTime = getCurrentTimeZone >>= getTime\n\n\nnextInterval x y\n    | x > y = x - y\n    | mod y x > 0 = x - mod y x\n    | otherwise = 0\n\n\nonInterval :: Int -> Scheduler\nonInterval interval time = toNext dMS\n  where\n    toNext = nextInterval (1000000 * interval)\n    tDelta = timeOfDayToTime time\n    dMS    = truncate $ 1000000 * tDelta\n\ndoWithScheduler :: Scheduler -> (Int -> IO ()) -> IO ThreadId\ndoWithScheduler sched task = forkIO $ forM_ [0..] exec\n  where\n    exec n = do\n        t <- getLocalTime\n        threadDelay $ sched t\n        task n\n\n\n\n\nwatchNames = words \"Middle Morning Forenoon Afternoon Dog First\"\ncountWords = words \"One Two Three Four Five Six Seven Eight\"\n\n\npostDelay n fn = fn >> threadDelay n\n\ntermBell        = putStr \"\\a\"\ntermBells n     = replicateM_ n $ postDelay 100000 termBell\ntermBellSeq seq = forM_ seq $ postDelay 500000 . termBells\n\ntoNoteGlyph 1 = \"\u266a\"\ntoNoteGlyph 2 = \"\u266b\"\ntoNoteGlyph _ = \"\"\n\nringBells :: Int -> IO ()\nringBells n = do\n    t <- getLocalTime\n    let numBells    = 1 + (mod n 8)\n        watch       = watchNames!!(mod (div n 8) 8)\n        count       = countWords!!(numBells - 1)\n        (twos,ones) = quotRem numBells 2\n        pattern     = (replicate twos 2) ++ (replicate ones 1)\n        notes       = unwords $ map toNoteGlyph pattern\n        plural       = if numBells > 1 then \"s\" else \"\"\n        strFMT      = show t ++ \": %s watch, %5s bell%s:  \" ++ notes ++ \"\\n\"\n    printf strFMT watch count plural\n    termBellSeq pattern\n\n\n\n\nbellRinger :: IO ThreadId\nbellRinger = doWithScheduler (onInterval (30*60)) ringBells\n", "target": "import java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.TimeZone;\n\npublic class NauticalBell extends Thread {\n\n    public static void main(String[] args) {\n        NauticalBell bells = new NauticalBell();\n        bells.setDaemon(true);\n        bells.start();\n        try {\n            bells.join();\n        } catch (InterruptedException e) {\n            System.out.println(e);\n        }\n    }\n\n    @Override\n    public void run() {\n        DateFormat sdf = new SimpleDateFormat(\"HH:mm:ss\");\n        sdf.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\n\n        int numBells = 0;\n        long time = System.currentTimeMillis();\n        long next = time - (time % (24 * 60 * 60 * 1000)); \n\n        while (next < time) {\n            next += 30 * 60 * 1000; \n            numBells = 1 + (numBells % 8);\n        }\n\n        while (true) {\n            long wait = 100L;\n            time = System.currentTimeMillis();\n            if (time - next >= 0) {\n                String bells = numBells == 1 ? \"bell\" : \"bells\";\n                String timeString = sdf.format(time);\n                System.out.printf(\"%s\u00a0: %d %s\\n\", timeString, numBells, bells);\n                next += 30 * 60 * 1000;\n                wait = next - time;\n                numBells = 1 + (numBells % 8);\n            }\n            try {\n                Thread.sleep(wait);\n            } catch (InterruptedException e) {\n                return;\n            }\n        }\n    }\n}\n"}
{"id": 404572, "name": "Polyspiral", "source": "Translate Haskell to Java: \nimport Reflex\nimport Reflex.Dom\nimport Reflex.Dom.Time\nimport Data.Text (Text, pack) \nimport Data.Map (Map, fromList)\nimport Data.Time.Clock (getCurrentTime)\nimport Control.Monad.Trans (liftIO)\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\nmain = mainWidget $ do \n\n  \n  dTick <- tickLossy 0.05 =<< liftIO getCurrentTime \n\n  \n  dCounter <- foldDyn (\\_ c -> c+1) (0::Int) dTick\n\n  let \n      \n      dAngle = fmap (\\c -> fromIntegral c / 800.0) dCounter\n\n      \n      dSpiralMap = fmap toSpiralMap dAngle\n\n      \n      width = 600\n      height = 600\n\n      boardAttrs = \n         fromList [ (\"width\" , pack $ show width)\n                  , (\"height\", pack $ show height)\n                  , (\"viewBox\", pack $ show (-width/2) ++ \" \" ++ show (-height/2) ++ \" \" ++ show width ++ \" \" ++ show height)\n                  ]\n\n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Polyspiral\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Polyspiral#Haskell\") $ text \"Rosetta Code / Polyspiral / Haskell\"\n\n  el \"br\" $ return ()\n  elSvgns \"svg\" (constDyn boardAttrs) (listWithKey dSpiralMap showLine)\n\n  return ()\n\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n  fromList [ ( \"x1\",    pack $ show x1)\n           , ( \"y1\",    pack $ show y1)\n           , ( \"x2\",    pack $ show x2)\n           , ( \"y2\",    pack $ show y2)\n           , ( \"style\", \"stroke:blue\")\n           ]    \n\n\nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n\n\nadvance :: Float -> (Point, Float, Float) -> (Point, Float, Float)\nadvance angle ((x,y), len, rot) = \n  let new_x = x + len * cos rot\n      new_y = y + len * sin rot\n      new_len = len + 3.0 \n      new_rot = rot + angle\n  in ((new_x, new_y), new_len, new_rot)\n\n\ntoSpiralMap :: Float -> Map Int ((Float,Float),(Float,Float))\ntoSpiralMap angle =\n      fromList                       \n  $   zip [0..]                      \n  $   (\\pts -> zip pts $ tail pts)   \n  $   take 80                        \n  $   (\\(pt,_,_) -> pt)              \n  <$> iterate (advance angle) ((0, 0), 0, 0)  \n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport javax.swing.*;\n\npublic class PolySpiral extends JPanel {\n    double inc = 0;\n\n    public PolySpiral() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        new Timer(40, (ActionEvent e) -> {\n            inc = (inc + 0.05) % 360;\n            repaint();\n        }).start();\n    }\n\n    void drawSpiral(Graphics2D g, int len, double angleIncrement) {\n\n        double x1 = getWidth() / 2;\n        double y1 = getHeight() / 2;\n        double angle = angleIncrement;\n\n        for (int i = 0; i < 150; i++) {\n\n            g.setColor(Color.getHSBColor(i / 150f, 1.0f, 1.0f));\n\n            double x2 = x1 + Math.cos(angle) * len;\n            double y2 = y1 - Math.sin(angle) * len;\n            g.drawLine((int) x1, (int) y1, (int) x2, (int) y2);\n            x1 = x2;\n            y1 = y2;\n\n            len += 3;\n\n            angle = (angle + angleIncrement) % (Math.PI * 2);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawSpiral(g, 5, Math.toRadians(inc));\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"PolySpiral\");\n            f.setResizable(true);\n            f.add(new PolySpiral(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 404573, "name": "Polyspiral", "source": "Translate Haskell to Java: \nimport Reflex\nimport Reflex.Dom\nimport Reflex.Dom.Time\nimport Data.Text (Text, pack) \nimport Data.Map (Map, fromList)\nimport Data.Time.Clock (getCurrentTime)\nimport Control.Monad.Trans (liftIO)\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\nmain = mainWidget $ do \n\n  \n  dTick <- tickLossy 0.05 =<< liftIO getCurrentTime \n\n  \n  dCounter <- foldDyn (\\_ c -> c+1) (0::Int) dTick\n\n  let \n      \n      dAngle = fmap (\\c -> fromIntegral c / 800.0) dCounter\n\n      \n      dSpiralMap = fmap toSpiralMap dAngle\n\n      \n      width = 600\n      height = 600\n\n      boardAttrs = \n         fromList [ (\"width\" , pack $ show width)\n                  , (\"height\", pack $ show height)\n                  , (\"viewBox\", pack $ show (-width/2) ++ \" \" ++ show (-height/2) ++ \" \" ++ show width ++ \" \" ++ show height)\n                  ]\n\n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Polyspiral\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Polyspiral#Haskell\") $ text \"Rosetta Code / Polyspiral / Haskell\"\n\n  el \"br\" $ return ()\n  elSvgns \"svg\" (constDyn boardAttrs) (listWithKey dSpiralMap showLine)\n\n  return ()\n\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n  fromList [ ( \"x1\",    pack $ show x1)\n           , ( \"y1\",    pack $ show y1)\n           , ( \"x2\",    pack $ show x2)\n           , ( \"y2\",    pack $ show y2)\n           , ( \"style\", \"stroke:blue\")\n           ]    \n\n\nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n\n\nadvance :: Float -> (Point, Float, Float) -> (Point, Float, Float)\nadvance angle ((x,y), len, rot) = \n  let new_x = x + len * cos rot\n      new_y = y + len * sin rot\n      new_len = len + 3.0 \n      new_rot = rot + angle\n  in ((new_x, new_y), new_len, new_rot)\n\n\ntoSpiralMap :: Float -> Map Int ((Float,Float),(Float,Float))\ntoSpiralMap angle =\n      fromList                       \n  $   zip [0..]                      \n  $   (\\pts -> zip pts $ tail pts)   \n  $   take 80                        \n  $   (\\(pt,_,_) -> pt)              \n  <$> iterate (advance angle) ((0, 0), 0, 0)  \n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport javax.swing.*;\n\npublic class PolySpiral extends JPanel {\n    double inc = 0;\n\n    public PolySpiral() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        new Timer(40, (ActionEvent e) -> {\n            inc = (inc + 0.05) % 360;\n            repaint();\n        }).start();\n    }\n\n    void drawSpiral(Graphics2D g, int len, double angleIncrement) {\n\n        double x1 = getWidth() / 2;\n        double y1 = getHeight() / 2;\n        double angle = angleIncrement;\n\n        for (int i = 0; i < 150; i++) {\n\n            g.setColor(Color.getHSBColor(i / 150f, 1.0f, 1.0f));\n\n            double x2 = x1 + Math.cos(angle) * len;\n            double y2 = y1 - Math.sin(angle) * len;\n            g.drawLine((int) x1, (int) y1, (int) x2, (int) y2);\n            x1 = x2;\n            y1 = y2;\n\n            len += 3;\n\n            angle = (angle + angleIncrement) % (Math.PI * 2);\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawSpiral(g, 5, Math.toRadians(inc));\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"PolySpiral\");\n            f.setResizable(true);\n            f.add(new PolySpiral(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 404574, "name": "Voronoi diagram", "source": "Translate Haskell to Java: \n\nmodule Main where\n\nimport System.Random\n\nimport Data.Word\nimport Data.Array.Repa as Repa\nimport Data.Array.Repa.IO.BMP\n\n    \nsqDistance :: Word32 -> Word32 -> Word32 -> Word32 -> Word32\nsqDistance !x1 !y1 !x2 !y2 = ((x1-x2)^2) + ((y1-y2)^2)\n\ncenters :: Int -> Int -> Array U DIM2 Word32\ncenters nCenters nCells =\n    fromListUnboxed (Z :. nCenters :. 2) $ take (2*nCenters) $ randomRs (0, fromIntegral nCells) (mkStdGen 1)\n\napplyReduce2 arr f = \n    traverse arr (\\(i :. j) -> i) $ \\lookup (Z:.i) ->\n        f (lookup (Z:.i:.0)) (lookup (Z:.i:.1))\n\nminimize1D arr = foldS f h t\n  where\n    indexed arr = traverse arr id (\\src idx@(Z :. i) -> (src idx, (fromIntegral i)))        \n    (Z :. n) = extent arr\n    iarr = indexed arr\n    h = iarr ! (Z :. 0)\n    t = extract (Z :. 1) (Z :. (n-1)) iarr\n\n    f min@(!valMin, !iMin ) x@(!val, !i) | val < valMin = x\n                                         | otherwise = min\n\nvoronoi :: Int -> Int -> Array D DIM2 Word32\nvoronoi nCenters nCells =\n    let\n      \n      cellReducer = applyReduce2 (centers nCenters nCells)\n      \n      nearestCenterIndex = snd . (Repa.! Z) . minimize1D\n    in        \n      Repa.fromFunction (Z :. nCells :. nCells :: DIM2) $ \\ (Z:.i:.j) ->\n          nearestCenterIndex $ cellReducer (sqDistance (fromIntegral i) (fromIntegral j))\n\ngenColorTable :: Int -> Array U DIM1 (Word8, Word8, Word8)\ngenColorTable n = fromListUnboxed (Z :. n) $ zip3 l1 l2 l3\n    where\n      randoms = randomRs (0,255) (mkStdGen 1)\n      (l1, rest1) = splitAt n randoms\n      (l2, rest2) = splitAt n rest1\n      l3 = take n rest2\n\ncolorize :: Array U DIM1 (Word8, Word8, Word8) -> Array D DIM2 Word32 -> Array D DIM2 (Word8, Word8, Word8)\ncolorize ctable = Repa.map $ \\x -> ctable Repa.! (Z:. fromIntegral x)\n\nmain = do\n  let nsites = 150\n  let ctable = genColorTable nsites \n  voro <- computeP $ colorize ctable (voronoi nsites 512) :: IO (Array U DIM2 (Word8, Word8, Word8))\n  writeImageToBMP \"out.bmp\" voro\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Voronoi extends JFrame {\n\tstatic double p = 3;\n\tstatic BufferedImage I;\n\tstatic int px[], py[], color[], cells = 100, size = 1000;\n\n\tpublic Voronoi() {\n\t\tsuper(\"Voronoi Diagram\");\n\t\tsetBounds(0, 0, size, size);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tint n = 0;\n\t\tRandom rand = new Random();\n\t\tI = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n\t\tpx = new int[cells];\n\t\tpy = new int[cells];\n\t\tcolor = new int[cells];\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tpx[i] = rand.nextInt(size);\n\t\t\tpy[i] = rand.nextInt(size);\n\t\t\tcolor[i] = rand.nextInt(16777215);\n\n\t\t}\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tfor (int y = 0; y < size; y++) {\n\t\t\t\tn = 0;\n\t\t\t\tfor (byte i = 0; i < cells; i++) {\n\t\t\t\t\tif (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {\n\t\t\t\t\t\tn = i;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tI.setRGB(x, y, color[n]);\n\n\t\t\t}\n\t\t}\n\n\t\tGraphics2D g = I.createGraphics();\n\t\tg.setColor(Color.BLACK);\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tg.fill(new Ellipse2D .Double(px[i] - 2.5, py[i] - 2.5, 5, 5));\n\t\t}\n\n\t\ttry {\n\t\t\tImageIO.write(I, \"png\", new File(\"voronoi.png\"));\n\t\t} catch (IOException e) {\n\n\t\t}\n\n\t}\n\n\tpublic void paint(Graphics g) {\n\t\tg.drawImage(I, 0, 0, this);\n\t}\n\n\tstatic double distance(int x1, int x2, int y1, int y2) {\n\t\tdouble d;\n\t    d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); \n\t\n\t\n\t  \treturn d;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Voronoi().setVisible(true);\n\t}\n}\n"}
{"id": 404575, "name": "Voronoi diagram", "source": "Translate Haskell to Java: \n\nmodule Main where\n\nimport System.Random\n\nimport Data.Word\nimport Data.Array.Repa as Repa\nimport Data.Array.Repa.IO.BMP\n\n    \nsqDistance :: Word32 -> Word32 -> Word32 -> Word32 -> Word32\nsqDistance !x1 !y1 !x2 !y2 = ((x1-x2)^2) + ((y1-y2)^2)\n\ncenters :: Int -> Int -> Array U DIM2 Word32\ncenters nCenters nCells =\n    fromListUnboxed (Z :. nCenters :. 2) $ take (2*nCenters) $ randomRs (0, fromIntegral nCells) (mkStdGen 1)\n\napplyReduce2 arr f = \n    traverse arr (\\(i :. j) -> i) $ \\lookup (Z:.i) ->\n        f (lookup (Z:.i:.0)) (lookup (Z:.i:.1))\n\nminimize1D arr = foldS f h t\n  where\n    indexed arr = traverse arr id (\\src idx@(Z :. i) -> (src idx, (fromIntegral i)))        \n    (Z :. n) = extent arr\n    iarr = indexed arr\n    h = iarr ! (Z :. 0)\n    t = extract (Z :. 1) (Z :. (n-1)) iarr\n\n    f min@(!valMin, !iMin ) x@(!val, !i) | val < valMin = x\n                                         | otherwise = min\n\nvoronoi :: Int -> Int -> Array D DIM2 Word32\nvoronoi nCenters nCells =\n    let\n      \n      cellReducer = applyReduce2 (centers nCenters nCells)\n      \n      nearestCenterIndex = snd . (Repa.! Z) . minimize1D\n    in        \n      Repa.fromFunction (Z :. nCells :. nCells :: DIM2) $ \\ (Z:.i:.j) ->\n          nearestCenterIndex $ cellReducer (sqDistance (fromIntegral i) (fromIntegral j))\n\ngenColorTable :: Int -> Array U DIM1 (Word8, Word8, Word8)\ngenColorTable n = fromListUnboxed (Z :. n) $ zip3 l1 l2 l3\n    where\n      randoms = randomRs (0,255) (mkStdGen 1)\n      (l1, rest1) = splitAt n randoms\n      (l2, rest2) = splitAt n rest1\n      l3 = take n rest2\n\ncolorize :: Array U DIM1 (Word8, Word8, Word8) -> Array D DIM2 Word32 -> Array D DIM2 (Word8, Word8, Word8)\ncolorize ctable = Repa.map $ \\x -> ctable Repa.! (Z:. fromIntegral x)\n\nmain = do\n  let nsites = 150\n  let ctable = genColorTable nsites \n  voro <- computeP $ colorize ctable (voronoi nsites 512) :: IO (Array U DIM2 (Word8, Word8, Word8))\n  writeImageToBMP \"out.bmp\" voro\n", "target": "import java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.Graphics2D;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Random;\n\nimport javax.imageio.ImageIO;\nimport javax.swing.JFrame;\n\npublic class Voronoi extends JFrame {\n\tstatic double p = 3;\n\tstatic BufferedImage I;\n\tstatic int px[], py[], color[], cells = 100, size = 1000;\n\n\tpublic Voronoi() {\n\t\tsuper(\"Voronoi Diagram\");\n\t\tsetBounds(0, 0, size, size);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tint n = 0;\n\t\tRandom rand = new Random();\n\t\tI = new BufferedImage(size, size, BufferedImage.TYPE_INT_RGB);\n\t\tpx = new int[cells];\n\t\tpy = new int[cells];\n\t\tcolor = new int[cells];\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tpx[i] = rand.nextInt(size);\n\t\t\tpy[i] = rand.nextInt(size);\n\t\t\tcolor[i] = rand.nextInt(16777215);\n\n\t\t}\n\t\tfor (int x = 0; x < size; x++) {\n\t\t\tfor (int y = 0; y < size; y++) {\n\t\t\t\tn = 0;\n\t\t\t\tfor (byte i = 0; i < cells; i++) {\n\t\t\t\t\tif (distance(px[i], x, py[i], y) < distance(px[n], x, py[n], y)) {\n\t\t\t\t\t\tn = i;\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tI.setRGB(x, y, color[n]);\n\n\t\t\t}\n\t\t}\n\n\t\tGraphics2D g = I.createGraphics();\n\t\tg.setColor(Color.BLACK);\n\t\tfor (int i = 0; i < cells; i++) {\n\t\t\tg.fill(new Ellipse2D .Double(px[i] - 2.5, py[i] - 2.5, 5, 5));\n\t\t}\n\n\t\ttry {\n\t\t\tImageIO.write(I, \"png\", new File(\"voronoi.png\"));\n\t\t} catch (IOException e) {\n\n\t\t}\n\n\t}\n\n\tpublic void paint(Graphics g) {\n\t\tg.drawImage(I, 0, 0, this);\n\t}\n\n\tstatic double distance(int x1, int x2, int y1, int y2) {\n\t\tdouble d;\n\t    d = Math.sqrt((x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2)); \n\t\n\t\n\t  \treturn d;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Voronoi().setVisible(true);\n\t}\n}\n"}
{"id": 404576, "name": "Active Directory_Connect", "source": "Translate Haskell to Java: \n\nmodule Main (main) where\n\nimport           Data.Foldable (for_)\nimport qualified Data.Text.Encoding as Text (encodeUtf8)\nimport           Ldap.Client (Attr(..), Filter(..))\nimport qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly)\n\nmain :: IO ()\nmain = do\n    entries <- Ldap.with (Ldap.Plain \"localhost\") 389 $ \\ldap ->\n        Ldap.search ldap (Ldap.Dn \"o=example.com\") (Ldap.typesOnly True) (Attr \"uid\" := Text.encodeUtf8 \"user\") []\n    for_ entries $ \\entry ->\n        print entry\n", "target": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapConnectionDemo {\n\n    public static void main(String[] args) throws LdapException, IOException {\n        try (LdapConnection connection = new LdapNetworkConnection(\"localhost\", 10389)) {\n            connection.bind();\n            connection.unBind();\n        }\n    }\n}\n"}
{"id": 404577, "name": "Knapsack problem_Bounded", "source": "Translate Haskell to Java: inv = \t[(\"map\",9,150,1), (\"compass\",13,35,1), (\"water\",153,200,2), (\"sandwich\",50,60,2),\n\t(\"glucose\",15,60,2), (\"tin\",68,45,3), (\"banana\",27,60,3), (\"apple\",39,40,3),\n\t(\"cheese\",23,30,1), (\"beer\",52,10,3), (\"cream\",11,70,1), (\"camera\",32,30,1),\n\t\n\t(\"tshirt\",24,15,2), (\"trousers\",48,10,2), (\"umbrella\",73,40,1), (\"wtrousers\",42,70,1),\n\t(\"woverclothes\",43,75,1), (\"notecase\",22,80,1), (\"sunglasses\",7,20,1), (\"towel\",18,12,2),\n\t(\"socks\",4,50,1), (\"book\",30,10,2)]\n\nknapsack = foldr addItem (repeat (0,[])) where\n\taddItem (name,w,v,c) old = foldr inc old [1..c] where\n\t\tinc i list = left ++ zipWith max right new where\n\t\t\t(left, right) = splitAt (w * i) list\n\t\t\tnew = map (\\(val,itms)->(val + v * i, (name,i):itms)) old\n\nmain = print $ (knapsack inv) !! 400\n", "target": "package hu.pj.alg.test;\n\nimport hu.pj.alg.BoundedKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class BoundedKnapsackForTourists {\n    public BoundedKnapsackForTourists() {\n        BoundedKnapsack bok = new BoundedKnapsack(400); \n\n        \n        bok.add(\"map\", 9, 150, 1);\n        bok.add(\"compass\", 13, 35, 1);\n        bok.add(\"water\", 153, 200, 3);\n        bok.add(\"sandwich\", 50, 60, 2);\n        bok.add(\"glucose\", 15, 60, 2);\n        bok.add(\"tin\", 68, 45, 3);\n        bok.add(\"banana\", 27, 60, 3);\n        bok.add(\"apple\", 39, 40, 3);\n        bok.add(\"cheese\", 23, 30, 1);\n        bok.add(\"beer\", 52, 10, 3);\n        bok.add(\"suntan cream\", 11, 70, 1);\n        bok.add(\"camera\", 32, 30, 1);\n        bok.add(\"t-shirt\", 24, 15, 2);\n        bok.add(\"trousers\", 48, 10, 2);\n        bok.add(\"umbrella\", 73, 40, 1);\n        bok.add(\"waterproof trousers\", 42, 70, 1);\n        bok.add(\"waterproof overclothes\", 43, 75, 1);\n        bok.add(\"note-case\", 22, 80, 1);\n        bok.add(\"sunglasses\", 7, 20, 1);\n        bok.add(\"towel\", 18, 12, 2);\n        bok.add(\"socks\", 4, 50, 1);\n        bok.add(\"book\", 30, 10, 2);\n\n        \n        List<Item> itemList = bok.calcSolution();\n\n        \n        if (bok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(bok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(bok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                bok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry te following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > 0) {\n                    System.out.format(\n                        \"%1$-10s %2$-23s %3$-3s %4$-5s %5$-15s \\n\",\n                        item.getInKnapsack() + \" unit(s) \",\n                        item.getName(),\n                        item.getInKnapsack() * item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getInKnapsack() * item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new BoundedKnapsackForTourists();\n    }\n} \n"}
{"id": 404578, "name": "Solve a Hidato puzzle", "source": "Translate Haskell to Java: \n\n\nimport qualified Data.IntMap as I\nimport Data.IntMap (IntMap)\nimport Data.List\nimport Data.Maybe\nimport Data.Time.Clock\n\ndata BoardProblem = Board\n  { cells :: IntMap (IntMap Int)\n  , endVal :: Int\n  , onePos :: (Int, Int)\n  , givens :: [Int]\n  } deriving (Show, Eq)\n\ntupIns x y v m = I.insert x (I.insert y v (I.findWithDefault I.empty x m)) m\n\ntupLookup x y m = I.lookup x m >>= I.lookup y\n\nmakeBoard =\n  (\\x ->\n      x\n      { givens = dropWhile (<= 1) $ sort $ givens x\n      }) .\n  foldl' \n    f\n    (Board I.empty 0 (0, 0) []) .\n  concatMap (zip [0 ..]) . zipWith (\\y w -> map (y, ) $ words w) [0 ..]\n  where\n    f bd (x, (y, v)) =\n      if v == \".\"\n        then bd\n        else Board\n               (tupIns x y (read v) (cells bd))\n               (if read v > endVal bd\n                  then read v\n                  else endVal bd)\n               (if v == \"1\"\n                  then (x, y)\n                  else onePos bd)\n               (read v : givens bd)\n\nhidato brd = listToMaybe $ h 2 (cells brd) (onePos brd) (givens brd)\n  where\n    h nval pmap (x, y) gs\n      | nval == endVal brd = [pmap]\n      | nval == head gs =\n        if null nvalAdj\n          then []\n          else h (nval + 1) pmap (fst $ head nvalAdj) (tail gs)\n      | not $ null nvalAdj = h (nval + 1) pmap (fst $ head nvalAdj) gs\n      | otherwise = hEmptyAdj\n      where\n        around =\n          [ (x - 1, y - 1)\n          , (x, y - 1)\n          , (x + 1, y - 1)\n          , (x - 1, y)\n          , (x + 1, y)\n          , (x - 1, y + 1)\n          , (x, y + 1)\n          , (x + 1, y + 1)\n          ]\n        lkdUp = map (\\(x, y) -> ((x, y), tupLookup x y pmap)) around\n        nvalAdj = filter ((== Just nval) . snd) lkdUp\n        hEmptyAdj =\n          concatMap\n            (\\((nx, ny), _) -> h (nval + 1) (tupIns nx ny nval pmap) (nx, ny) gs) $\n          filter ((== Just 0) . snd) lkdUp\n\nprintCellMap cellmap = putStrLn $ concat strings\n  where\n    maxPos = xyBy I.findMax maximum\n    minPos = xyBy I.findMin minimum\n    xyBy :: (forall a. IntMap a -> (Int, a)) -> ([Int] -> Int) -> (Int, Int)\n    xyBy a b = (fst (a cellmap), b $ map (fst . a . snd) $ I.toList cellmap)\n    strings =\n      map\n        f\n        [ (x, y)\n        | y <- [snd minPos .. snd maxPos] \n        , x <- [fst minPos .. fst maxPos] ]\n    f (x, y) =\n      let z =\n            if x == fst maxPos\n              then \"\\n\"\n              else \" \"\n      in case tupLookup x y cellmap of\n           Nothing -> \"  \" ++ z\n           Just n ->\n             (if n < 10\n                then ' ' : show n\n                else show n) ++\n             z\n\nmain = do\n  let sampleBoard = makeBoard sample\n  printCellMap $ cells sampleBoard\n  printCellMap $ fromJust $ hidato sampleBoard\n\nsample =\n  [ \" 0 33 35  0  0\"\n  , \" 0  0 24 22  0\"\n  , \" 0  0  0 21  0  0\"\n  , \" 0 26  0 13 40 11\"\n  , \"27  0  0  0  9  0  1\"\n  , \".  .   0  0 18  0  0\"\n  , \".  .  .  .   0  7  0  0\"\n  , \".  .  .  .  .  .   5  0\"\n  ]\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Hidato {\n\n    private static int[][] board;\n    private static int[] given, start;\n\n    public static void main(String[] args) {\n        String[] input = {\"_ 33 35 _ _ . . .\",\n            \"_ _ 24 22 _ . . .\",\n            \"_ _ _ 21 _ _ . .\",\n            \"_ 26 _ 13 40 11 . .\",\n            \"27 _ _ _ 9 _ 1 .\",\n            \". . _ _ 18 _ _ .\",\n            \". . . . _ 7 _ _\",\n            \". . . . . . 5 _\"};\n\n        setup(input);\n        printBoard();\n        System.out.println(\"\\nFound:\");\n        solve(start[0], start[1], 1, 0);\n        printBoard();\n    }\n\n    private static void setup(String[] input) {\n        \n\n        String[][] puzzle = new String[input.length][];\n        for (int i = 0; i < input.length; i++)\n            puzzle[i] = input[i].split(\" \");\n\n        int nCols = puzzle[0].length;\n        int nRows = puzzle.length;\n\n        List<Integer> list = new ArrayList<>(nRows * nCols);\n\n        board = new int[nRows + 2][nCols + 2];\n        for (int[] row : board)\n            for (int c = 0; c < nCols + 2; c++)\n                row[c] = -1;\n\n        for (int r = 0; r < nRows; r++) {\n            String[] row = puzzle[r];\n            for (int c = 0; c < nCols; c++) {\n                String cell = row[c];\n                switch (cell) {\n                    case \"_\":\n                        board[r + 1][c + 1] = 0;\n                        break;\n                    case \".\":\n                        break;\n                    default:\n                        int val = Integer.parseInt(cell);\n                        board[r + 1][c + 1] = val;\n                        list.add(val);\n                        if (val == 1)\n                            start = new int[]{r + 1, c + 1};\n                }\n            }\n        }\n        Collections.sort(list);\n        given = new int[list.size()];\n        for (int i = 0; i < given.length; i++)\n            given[i] = list.get(i);\n    }\n\n    private static boolean solve(int r, int c, int n, int next) {\n        if (n > given[given.length - 1])\n            return true;\n\n        if (board[r][c] != 0 && board[r][c] != n)\n            return false;\n\n        if (board[r][c] == 0 && given[next] == n)\n            return false;\n\n        int back = board[r][c];\n        if (back == n)\n            next++;\n\n        board[r][c] = n;\n        for (int i = -1; i < 2; i++)\n            for (int j = -1; j < 2; j++)\n                if (solve(r + i, c + j, n + 1, next))\n                    return true;\n\n        board[r][c] = back;\n        return false;\n    }\n\n    private static void printBoard() {\n        for (int[] row : board) {\n            for (int c : row) {\n                if (c == -1)\n                    System.out.print(\" . \");\n                else\n                    System.out.printf(c > 0 ? \"%2d \" : \"__ \", c);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 404579, "name": "Solve a Hidato puzzle", "source": "Translate Haskell to Java: \n\n\nimport qualified Data.IntMap as I\nimport Data.IntMap (IntMap)\nimport Data.List\nimport Data.Maybe\nimport Data.Time.Clock\n\ndata BoardProblem = Board\n  { cells :: IntMap (IntMap Int)\n  , endVal :: Int\n  , onePos :: (Int, Int)\n  , givens :: [Int]\n  } deriving (Show, Eq)\n\ntupIns x y v m = I.insert x (I.insert y v (I.findWithDefault I.empty x m)) m\n\ntupLookup x y m = I.lookup x m >>= I.lookup y\n\nmakeBoard =\n  (\\x ->\n      x\n      { givens = dropWhile (<= 1) $ sort $ givens x\n      }) .\n  foldl' \n    f\n    (Board I.empty 0 (0, 0) []) .\n  concatMap (zip [0 ..]) . zipWith (\\y w -> map (y, ) $ words w) [0 ..]\n  where\n    f bd (x, (y, v)) =\n      if v == \".\"\n        then bd\n        else Board\n               (tupIns x y (read v) (cells bd))\n               (if read v > endVal bd\n                  then read v\n                  else endVal bd)\n               (if v == \"1\"\n                  then (x, y)\n                  else onePos bd)\n               (read v : givens bd)\n\nhidato brd = listToMaybe $ h 2 (cells brd) (onePos brd) (givens brd)\n  where\n    h nval pmap (x, y) gs\n      | nval == endVal brd = [pmap]\n      | nval == head gs =\n        if null nvalAdj\n          then []\n          else h (nval + 1) pmap (fst $ head nvalAdj) (tail gs)\n      | not $ null nvalAdj = h (nval + 1) pmap (fst $ head nvalAdj) gs\n      | otherwise = hEmptyAdj\n      where\n        around =\n          [ (x - 1, y - 1)\n          , (x, y - 1)\n          , (x + 1, y - 1)\n          , (x - 1, y)\n          , (x + 1, y)\n          , (x - 1, y + 1)\n          , (x, y + 1)\n          , (x + 1, y + 1)\n          ]\n        lkdUp = map (\\(x, y) -> ((x, y), tupLookup x y pmap)) around\n        nvalAdj = filter ((== Just nval) . snd) lkdUp\n        hEmptyAdj =\n          concatMap\n            (\\((nx, ny), _) -> h (nval + 1) (tupIns nx ny nval pmap) (nx, ny) gs) $\n          filter ((== Just 0) . snd) lkdUp\n\nprintCellMap cellmap = putStrLn $ concat strings\n  where\n    maxPos = xyBy I.findMax maximum\n    minPos = xyBy I.findMin minimum\n    xyBy :: (forall a. IntMap a -> (Int, a)) -> ([Int] -> Int) -> (Int, Int)\n    xyBy a b = (fst (a cellmap), b $ map (fst . a . snd) $ I.toList cellmap)\n    strings =\n      map\n        f\n        [ (x, y)\n        | y <- [snd minPos .. snd maxPos] \n        , x <- [fst minPos .. fst maxPos] ]\n    f (x, y) =\n      let z =\n            if x == fst maxPos\n              then \"\\n\"\n              else \" \"\n      in case tupLookup x y cellmap of\n           Nothing -> \"  \" ++ z\n           Just n ->\n             (if n < 10\n                then ' ' : show n\n                else show n) ++\n             z\n\nmain = do\n  let sampleBoard = makeBoard sample\n  printCellMap $ cells sampleBoard\n  printCellMap $ fromJust $ hidato sampleBoard\n\nsample =\n  [ \" 0 33 35  0  0\"\n  , \" 0  0 24 22  0\"\n  , \" 0  0  0 21  0  0\"\n  , \" 0 26  0 13 40 11\"\n  , \"27  0  0  0  9  0  1\"\n  , \".  .   0  0 18  0  0\"\n  , \".  .  .  .   0  7  0  0\"\n  , \".  .  .  .  .  .   5  0\"\n  ]\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Hidato {\n\n    private static int[][] board;\n    private static int[] given, start;\n\n    public static void main(String[] args) {\n        String[] input = {\"_ 33 35 _ _ . . .\",\n            \"_ _ 24 22 _ . . .\",\n            \"_ _ _ 21 _ _ . .\",\n            \"_ 26 _ 13 40 11 . .\",\n            \"27 _ _ _ 9 _ 1 .\",\n            \". . _ _ 18 _ _ .\",\n            \". . . . _ 7 _ _\",\n            \". . . . . . 5 _\"};\n\n        setup(input);\n        printBoard();\n        System.out.println(\"\\nFound:\");\n        solve(start[0], start[1], 1, 0);\n        printBoard();\n    }\n\n    private static void setup(String[] input) {\n        \n\n        String[][] puzzle = new String[input.length][];\n        for (int i = 0; i < input.length; i++)\n            puzzle[i] = input[i].split(\" \");\n\n        int nCols = puzzle[0].length;\n        int nRows = puzzle.length;\n\n        List<Integer> list = new ArrayList<>(nRows * nCols);\n\n        board = new int[nRows + 2][nCols + 2];\n        for (int[] row : board)\n            for (int c = 0; c < nCols + 2; c++)\n                row[c] = -1;\n\n        for (int r = 0; r < nRows; r++) {\n            String[] row = puzzle[r];\n            for (int c = 0; c < nCols; c++) {\n                String cell = row[c];\n                switch (cell) {\n                    case \"_\":\n                        board[r + 1][c + 1] = 0;\n                        break;\n                    case \".\":\n                        break;\n                    default:\n                        int val = Integer.parseInt(cell);\n                        board[r + 1][c + 1] = val;\n                        list.add(val);\n                        if (val == 1)\n                            start = new int[]{r + 1, c + 1};\n                }\n            }\n        }\n        Collections.sort(list);\n        given = new int[list.size()];\n        for (int i = 0; i < given.length; i++)\n            given[i] = list.get(i);\n    }\n\n    private static boolean solve(int r, int c, int n, int next) {\n        if (n > given[given.length - 1])\n            return true;\n\n        if (board[r][c] != 0 && board[r][c] != n)\n            return false;\n\n        if (board[r][c] == 0 && given[next] == n)\n            return false;\n\n        int back = board[r][c];\n        if (back == n)\n            next++;\n\n        board[r][c] = n;\n        for (int i = -1; i < 2; i++)\n            for (int j = -1; j < 2; j++)\n                if (solve(r + i, c + j, n + 1, next))\n                    return true;\n\n        board[r][c] = back;\n        return false;\n    }\n\n    private static void printBoard() {\n        for (int[] row : board) {\n            for (int c : row) {\n                if (c == -1)\n                    System.out.print(\" . \");\n                else\n                    System.out.printf(c > 0 ? \"%2d \" : \"__ \", c);\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 404580, "name": "Sorting algorithms_Strand sort", "source": "Translate Haskell to Java: \nmerge :: (Ord a) => [a] -> [a] -> [a]\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x : xs) (y : ys)\n\t| x <= y = x : merge xs (y : ys)\n\t| otherwise = y : merge (x : xs) ys\n\nstrandSort :: (Ord a) => [a] -> [a]\nstrandSort [] = []\nstrandSort (x : xs) = merge strand (strandSort rest) where\n\t(strand, rest) = extractStrand x xs\n\textractStrand x [] = ([x], [])\n\textractStrand x (x1 : xs)\n\t\t| x <= x1 = let (strand, rest) = extractStrand x1 xs in (x : strand, rest)\n\t\t| otherwise = let (strand, rest) = extractStrand x xs in (strand, x1 : rest)\n", "target": "import java.util.Arrays;\nimport java.util.LinkedList;\n\npublic class Strand{\n\t\n\tpublic static <E extends Comparable<? super E>> \n\tLinkedList<E> strandSort(LinkedList<E> list){\n\t\tif(list.size() <= 1) return list;\n\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(list.size() > 0){\n\t\t\tLinkedList<E> sorted = new LinkedList<E>();\n\t\t\tsorted.add(list.removeFirst()); \n\t\t\tfor(Iterator<E> it = list.iterator(); it.hasNext(); ){\n\t\t\t\tE elem = it.next();\n\t\t\t\tif(sorted.peekLast().compareTo(elem) <= 0){\n\t\t\t\t\tsorted.addLast(elem); \n\t\t\t\t\tit.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tresult = merge(sorted, result);\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate static <E extends Comparable<? super E>>\n\tLinkedList<E> merge(LinkedList<E> left, LinkedList<E> right){\n\t\tLinkedList<E> result = new LinkedList<E>();\n\t\twhile(!left.isEmpty() && !right.isEmpty()){\n\t\t\t\n\t\t\tif(left.peek().compareTo(right.peek()) <= 0)\n\t\t\t\tresult.add(left.remove());\n\t\t\telse\n\t\t\t\tresult.add(right.remove());\n\t\t}\n\t\tresult.addAll(left);\n\t\tresult.addAll(right);\n\t\treturn result;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,1,2,4,5))));\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,3,1,2,4,5))));\n\t\tSystem.out.println(strandSort(new LinkedList<Integer>(Arrays.asList(3,3,1,2,4,3,5,6))));\n\t}\n}\n"}
{"id": 404581, "name": "Angles (geometric), normalization and conversion", "source": "Translate Haskell to Java: \n\n\n  \nimport Text.Printf\n \nclass (Num a, Fractional a, RealFrac a) => Angle a where\n  fullTurn :: a \n  mkAngle :: Double -> a\n  value :: a -> Double\n  fromTurn :: Double -> a\n  toTurn :: a -> Double\n  normalize :: a -> a\n\n  \n  fromTurn t = angle t * fullTurn\n  toTurn a = value $ a / fullTurn\n\n  \n  normalize a = a `modulo` fullTurn\n    where\n      modulo x r | x == r = r\n                 | x < 0 = signum x * abs x `modulo` r\n                 | x >= 0 = x - fromInteger (floor (x / r)) * r \n\n\nangle :: Angle a => Double -> a\nangle = normalize . mkAngle\n\n\nfrom :: forall a b. (Angle a, Angle b) => a -> b\nfrom = fromTurn . toTurn\n\nto :: forall b a. (Angle a, Angle b) => a -> b\nto = fromTurn . toTurn\n", "target": "import java.text.DecimalFormat;\n\n\n\npublic class AnglesNormalizationAndConversion {\n\n    public static void main(String[] args) {\n        DecimalFormat formatAngle = new DecimalFormat(\"######0.000000\");\n        DecimalFormat formatConv = new DecimalFormat(\"###0.0000\");\n        System.out.printf(\"                               degrees    gradiens        mils     radians%n\");\n        for ( double angle : new double[] {-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 399, 6399, 1000000} ) {\n            for ( String units : new String[] {\"degrees\", \"gradiens\", \"mils\", \"radians\"}) {\n                double d = 0, g = 0, m = 0, r = 0;\n                switch (units) {\n                case \"degrees\":\n                    d = d2d(angle);\n                    g = d2g(d);\n                    m = d2m(d);\n                    r = d2r(d);\n                    break;\n                case \"gradiens\":\n                    g = g2g(angle);\n                    d = g2d(g);\n                    m = g2m(g);\n                    r = g2r(g);\n                    break;\n                case \"mils\":\n                    m = m2m(angle);\n                    d = m2d(m);\n                    g = m2g(m);\n                    r = m2r(m);\n                    break;\n                case \"radians\":\n                    r = r2r(angle);\n                    d = r2d(r);\n                    g = r2g(r);\n                    m = r2m(r);\n                    break;\n                }\n                System.out.printf(\"%15s  %8s = %10s  %10s  %10s  %10s%n\", formatAngle.format(angle), units, formatConv.format(d), formatConv.format(g), formatConv.format(m), formatConv.format(r));\n            }\n        }\n    }\n\n    private static final double DEGREE = 360D;\n    private static final double GRADIAN = 400D;\n    private static final double MIL = 6400D;\n    private static final double RADIAN = (2 * Math.PI);\n    \n    private static double d2d(double a) {\n        return a % DEGREE;\n    }\n    private static double d2g(double a) {\n        return a * (GRADIAN / DEGREE);\n    }\n    private static double d2m(double a) {\n        return a * (MIL / DEGREE);\n    }\n    private static double d2r(double a) {\n        return a * (RADIAN / 360);\n    }\n\n    private static double g2d(double a) {\n        return a * (DEGREE / GRADIAN);\n    }\n    private static double g2g(double a) {\n        return a % GRADIAN;\n    }\n    private static double g2m(double a) {\n        return a * (MIL / GRADIAN);\n    }\n    private static double g2r(double a) {\n        return a * (RADIAN / GRADIAN);\n    }\n    \n    private static double m2d(double a) {\n        return a * (DEGREE / MIL);\n    }\n    private static double m2g(double a) {\n        return a * (GRADIAN / MIL);\n    }\n    private static double m2m(double a) {\n        return a % MIL;\n    }\n    private static double m2r(double a) {\n        return a * (RADIAN / MIL);\n    }\n    \n    private static double r2d(double a) {\n        return a * (DEGREE / RADIAN);\n    }\n    private static double r2g(double a) {\n        return a * (GRADIAN / RADIAN);\n    }\n    private static double r2m(double a) {\n        return a * (MIL / RADIAN);\n    }\n    private static double r2r(double a) {\n        return a % RADIAN;\n    }\n    \n}\n"}
{"id": 404582, "name": "XML_XPath", "source": "Translate Haskell to Java: import Data.List\nimport Control.Arrow\nimport Control.Monad\n\ntakeWhileIncl           :: (a -> Bool) -> [a] -> [a]\ntakeWhileIncl _ []      =  []\ntakeWhileIncl p (x:xs)\n            | p x       =  x : takeWhileIncl p xs\n            | otherwise =  [x] \n\ngetmultiLineItem n = takeWhileIncl(not.isInfixOf (\"</\" ++ n)). dropWhile(not.isInfixOf ('<': n))\ngetsingleLineItems n = map (takeWhile(/='<'). drop 1. dropWhile(/='>')). filter (isInfixOf ('<': n))\n\nmain = do\n  xml <- readFile \"./Rosetta/xmlpath.xml\"\n  let xmlText = lines xml\n      \n  putStrLn \"\\n== First item ==\\n\"\n  mapM_ putStrLn $ head $ unfoldr (Just. liftM2 (id &&&) (\\\\) (getmultiLineItem \"item\")) xmlText\n  \n  putStrLn \"\\n== Prices ==\\n\"\n  mapM_ putStrLn $ getsingleLineItems \"price\" xmlText\n  \n  putStrLn \"\\n== Names ==\\n\"\n  print $ getsingleLineItems \"name\" xmlText\n", "target": "import java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\npublic class XMLParser {\n\tfinal static String xmlStr = \n\t\t\t  \"<inventory title=\\\"OmniCorp Store #45x10^3\\\">\"\n\t\t\t+ \"  <section name=\\\"health\\\">\"\n\t\t\t+ \"    <item upc=\\\"123456789\\\" stock=\\\"12\\\">\"\n\t\t\t+ \"      <name>Invisibility Cream</name>\"\n\t\t\t+ \"      <price>14.50</price>\"\n\t\t\t+ \"      <description>Makes you invisible</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"445322344\\\" stock=\\\"18\\\">\"\n\t\t\t+ \"      <name>Levitation Salve</name>\"\n\t\t\t+ \"      <price>23.99</price>\"\n\t\t\t+ \"      <description>Levitate yourself for up to 3 hours per application</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\"\n\t\t\t+ \"  <section name=\\\"food\\\">\"\n\t\t\t+ \"    <item upc=\\\"485672034\\\" stock=\\\"653\\\">\"\n\t\t\t+ \"      <name>Blork and Freen Instameal</name>\"\n\t\t\t+ \"      <price>4.95</price>\"\n\t\t\t+ \"      <description>A tasty meal in a tablet; just add water</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"132957764\\\" stock=\\\"44\\\">\"\n\t\t\t+ \"      <name>Grob winglets</name>\"\n\t\t\t+ \"      <price>3.56</price>\"\n\t\t\t+ \"      <description>Tender winglets of Grob. Just add priwater</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\" \n\t\t\t+ \"</inventory>\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tDocument doc = DocumentBuilderFactory.newInstance()\n\t\t\t\t\t.newDocumentBuilder()\n\t\t\t\t\t.parse(new InputSource(new StringReader(xmlStr)));\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\t\n\t\t\tSystem.out.println(((Node) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item[1]\", doc, XPathConstants.NODE))\n\t\t\t\t\t.getAttributes().getNamedItem(\"upc\"));\n\t\t\t\n\t\t\tNodeList nodes = (NodeList) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item/price\", doc,\n\t\t\t\t\tXPathConstants.NODESET);\n\t\t\tfor (int i = 0; i < nodes.getLength(); i++)\n\t\t\t\tSystem.out.println(nodes.item(i).getTextContent());\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"Error ocurred while parsing XML.\");\n\t\t}\n\t}\n}\n"}
{"id": 404583, "name": "Ranking methods", "source": "Translate Haskell to Java: import Data.List (groupBy, sortBy, intercalate)\n\ntype Item = (Int, String)\n\ntype ItemList = [Item]\n\ntype ItemGroups = [ItemList]\n\ntype RankItem a = (a, Int, String)\n\ntype RankItemList a = [RankItem a]\n\n\nprepare :: ItemList -> ItemGroups\nprepare = groupBy gf . sortBy (flip compare)\n  where\n    gf (a, _) (b, _) = a == b\n\n\nrank\n  :: Num a\n  => a -> Item -> RankItem a\nrank n (a, b) = (n, a, b)\n\n\nstandard, modified, dense, ordinal :: ItemGroups -> RankItemList Int\nstandard = ms 1\n  where\n    ms _ [] = []\n    ms n (x:xs) = (rank n <$> x) ++ ms (n + length x) xs\n\nmodified = md 1\n  where\n    md _ [] = []\n    md n (x:xs) =\n      let l = length x\n          nl = n + l\n          nl1 = nl - 1\n      in (rank nl1 <$> x) ++ md (n + l) xs\n\ndense = md 1\n  where\n    md _ [] = []\n    md n (x:xs) = map (rank n) x ++ md (n + 1) xs\n\nordinal = zipWith rank [1 ..] . concat\n\nfractional :: ItemGroups -> RankItemList Double\nfractional = mf 1.0\n  where\n    mf _ [] = []\n    mf n (x:xs) =\n      let l = length x\n          o = take l [n ..]\n          ld = fromIntegral l\n          a = sum o / ld\n      in map (rank a) x ++ mf (n + ld) xs\n\n\ntest :: ItemGroups\ntest =\n  prepare\n    [ (44, \"Solomon\")\n    , (42, \"Jason\")\n    , (42, \"Errol\")\n    , (41, \"Garry\")\n    , (41, \"Bernard\")\n    , (41, \"Barry\")\n    , (39, \"Stephen\")\n    ]\n\n\nnicePrint\n  :: Show a\n  => String -> RankItemList a -> IO ()\nnicePrint xs items = do\n  putStrLn xs\n  mapM_ np items\n  putStr \"\\n\"\n  where\n    np (a, b, c) = putStrLn $ intercalate \"\\t\" [show a, show b, c]\n\nmain :: IO ()\nmain = do\n  nicePrint \"Standard:\" $ standard test\n  nicePrint \"Modified:\" $ modified test\n  nicePrint \"Dense:\" $ dense test\n  nicePrint \"Ordinal:\" $ ordinal test\n  nicePrint \"Fractional:\" $ fractional test\n", "target": "import java.util.*;\n\npublic class RankingMethods {\n\n    final static String[] input = {\"44 Solomon\", \"42 Jason\", \"42 Errol\",\n        \"41 Garry\", \"41 Bernard\", \"41 Barry\", \"39 Stephen\"};\n\n    public static void main(String[] args) {\n        int len = input.length;\n\n        Map<String, int[]> map = new TreeMap<>((a, b) -> b.compareTo(a));\n        for (int i = 0; i < len; i++) {\n            String key = input[i].split(\"\\\\s+\")[0];\n            int[] arr;\n            if ((arr = map.get(key)) == null)\n                arr = new int[]{i, 0};\n            arr[1]++;\n            map.put(key, arr);\n        }\n        int[][] groups = map.values().toArray(new int[map.size()][]);\n\n        standardRanking(len, groups);\n        modifiedRanking(len, groups);\n        denseRanking(len, groups);\n        ordinalRanking(len);\n        fractionalRanking(len, groups);\n    }\n\n    private static void standardRanking(int len, int[][] groups) {\n        System.out.println(\"\\nStandard ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                rank = i + 1;\n                group++;\n            }\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void modifiedRanking(int len, int[][] groups) {\n        System.out.println(\"\\nModified ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0])\n                rank += groups[group++][1];\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void denseRanking(int len, int[][] groups) {\n        System.out.println(\"\\nDense ranking\");\n        for (int i = 0, rank = 0; i < len; i++) {\n            if (rank < groups.length && i == groups[rank][0])\n                rank++;\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void ordinalRanking(int len) {\n        System.out.println(\"\\nOrdinal ranking\");\n        for (int i = 0; i < len; i++)\n            System.out.printf(\"%d %s%n\", i + 1, input[i]);\n    }\n\n    private static void fractionalRanking(int len, int[][] groups) {\n        System.out.println(\"\\nFractional ranking\");\n        float rank = 0;\n        for (int i = 0, tmp = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                tmp += groups[group++][1];\n                rank = (i + 1 + tmp) / 2.0F;\n            }\n            System.out.printf(\"%2.1f %s%n\", rank, input[i]);\n        }\n    }\n}\n"}
{"id": 404584, "name": "Update a configuration file", "source": "Translate Haskell to Java: import Data.Char (toUpper)\nimport qualified System.IO.Strict  as S\n", "target": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class UpdateConfig {\n\n    public static void main(String[] args) {\n        if (args[0] == null) {\n            System.out.println(\"filename required\");\n\n        } else if (readConfig(args[0])) {\n            enableOption(\"seedsremoved\");\n            disableOption(\"needspeeling\");\n            setOption(\"numberofbananas\", \"1024\");\n            addOption(\"numberofstrawberries\", \"62000\");\n            store();\n        }\n    }\n\n    private enum EntryType {\n        EMPTY, ENABLED, DISABLED, COMMENT\n    }\n\n    private static class Entry {\n        EntryType type;\n        String name, value;\n\n        Entry(EntryType t, String n, String v) {\n            type = t;\n            name = n;\n            value = v;\n        }\n    }\n\n    private static Map<String, Entry> entries = new LinkedHashMap<>();\n    private static String path;\n\n    private static boolean readConfig(String p) {\n        path = p;\n\n        File f = new File(path);\n        if (!f.exists() || f.isDirectory())\n            return false;\n\n        String regexString = \"^(;*)\\\\s*([A-Za-z0-9]+)\\\\s*([A-Za-z0-9]*)\";\n        Pattern regex = Pattern.compile(regexString);\n\n        try (Scanner sc = new Scanner(new FileReader(f))){\n            int emptyLines = 0;\n            String line;\n            while (sc.hasNext()) {\n                line = sc.nextLine().trim();\n\n                if (line.isEmpty()) {\n                    addOption(\"\" + emptyLines++, null, EntryType.EMPTY);\n\n                } else if (line.charAt(0) == '#') {\n                    entries.put(line, new Entry(EntryType.COMMENT, line, null));\n\n                } else {\n                    line = line.replaceAll(\"[^a-zA-Z0-9\\\\x20;]\", \"\");\n                    Matcher m = regex.matcher(line);\n\n                    if (m.find() && !m.group(2).isEmpty()) {\n\n                        EntryType t = EntryType.ENABLED;\n                        if (!m.group(1).isEmpty())\n                            t = EntryType.DISABLED;\n\n                        addOption(m.group(2), m.group(3), t);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return true;\n    }\n\n    private static void addOption(String name, String value) {\n        addOption(name, value, EntryType.ENABLED);\n    }\n\n    private static void addOption(String name, String value, EntryType t) {\n        name = name.toUpperCase();\n        entries.put(name, new Entry(t, name, value));\n    }\n\n    private static void enableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.ENABLED;\n    }\n\n    private static void disableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.DISABLED;\n    }\n\n    private static void setOption(String name, String value) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.value = value;\n    }\n\n    private static void store() {\n        try (PrintWriter pw = new PrintWriter(path)) {\n            for (Entry e : entries.values()) {\n                switch (e.type) {\n                    case EMPTY:\n                        pw.println();\n                        break;\n                    case ENABLED:\n                        pw.format(\"%s %s%n\", e.name, e.value);\n                        break;\n                    case DISABLED:\n                        pw.format(\"; %s %s%n\", e.name, e.value);\n                        break;\n                    case COMMENT:\n                        pw.println(e.name);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (pw.checkError()) {\n                throw new IOException(\"writing to file failed\");\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n}\n"}
{"id": 404585, "name": "Straddling checkerboard", "source": "Translate Haskell to Java: import Data.Char\nimport Data.Map\n\ncharToInt :: Char -> Int\ncharToInt c = ord c - ord '0'\n\n\n\ndecodeChar :: String -> (Char,String)\ndecodeChar ('7':'9':r:rs) = (r,rs)\ndecodeChar ('7':r:rs)     = (\"PQUVWXYZ. \" !! charToInt r, rs)\ndecodeChar ('3':r:rs)     = (\"ABCDFGIJKN\" !! charToInt r, rs)\ndecodeChar (r:rs)         = (\"HOL MES RT\" !! charToInt r, rs)\n\n\ndecode :: String -> String\ndecode [] = []\ndecode st = let (c, s) = decodeChar st in c:decode s\n\n\n\n\nrevEnc :: String -> (Char, String)\nrevEnc enc = let (dec, rm) = decodeChar enc in (dec, take (length enc - length rm) enc)\n\nds :: String\nds = ['0'..'9']\n\n\n\nencodeMap :: Map Char String\nencodeMap = fromList [ revEnc [d2,d1,d0] | d2 <- ds, d1 <- ds, d0 <- ds ]\n\n\nencodeChar :: Char -> String\nencodeChar c = findWithDefault \"\" c encodeMap \n\n\nencode :: String -> String\nencode st = concatMap encodeChar $ fmap toUpper st\n\n\nmain = let orig = \"One night-it was on the twentieth of March, 1888-I was returning\"\n           enc = encode orig\n           dec = decode enc\n       in mapM_ putStrLn [ \"Original: \" ++ orig\n                         , \"Encoded: \" ++ enc \n                         , \"Decoded: \" ++ dec ]\n", "target": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.*;\n\npublic class StraddlingCheckerboard {\n\n    final static String[] keyvals = {\"H:0\", \"O:1\", \"L:2\", \"M:4\", \"E:5\", \"S:6\",\n        \"R:8\", \"T:9\", \"A:30\", \"B:31\", \"C:32\", \"D:33\", \"F:34\", \"G:35\", \"I:36\",\n        \"J:37\", \"K:38\", \"N:39\", \"P:70\", \"Q:71\", \"U:72\", \"V:73\", \"W:74\", \"X:75\",\n        \"Y:76\", \"Z:77\", \".:78\", \"/:79\", \"0:790\", \"1:791\", \"2:792\", \"3:793\",\n        \"4:794\", \"5:795\", \"6:796\", \"7:797\", \"8:798\", \"9:799\"};\n\n    final static Map<String, String> val2key = new HashMap<>();\n    final static Map<String, String> key2val = new HashMap<>();\n\n    public static void main(String[] args) {\n        for (String keyval : keyvals) {\n            String[] kv = keyval.split(\":\");\n            val2key.put(kv[0], kv[1]);\n            key2val.put(kv[1], kv[0]);\n        }\n        String enc = encode(\"One night-it was on the twentieth of March, \"\n                + \"1888-I was returning\");\n        System.out.println(enc);\n        System.out.println(decode(enc));\n    }\n\n    static String encode(String s) {\n        StringBuilder sb = new StringBuilder();\n        for (String c : s.toUpperCase().split(\"\")) {\n            c = val2key.get(c);\n            if (c != null)\n                sb.append(c);\n        }\n        return sb.toString();\n    }\n\n    static String decode(String s) {\n        Matcher m = Pattern.compile(\"(79.|3.|7.|.)\").matcher(s);\n        StringBuilder sb = new StringBuilder();\n        while (m.find()) {\n            String v = key2val.get(m.group(1));\n            if (v != null)\n                sb.append(v);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 404586, "name": "I before E except after C", "source": "Translate Haskell to Java: import Network.HTTP\nimport Text.Regex.TDFA\nimport Text.Printf\n\ngetWordList :: IO String\ngetWordList  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n\nmain = do\n    words <- getWordList\n    putStrLn \"Checking Rule 1: \\\"I before E when not preceded by C\\\"...\"\n    let numTrueRule1   =  matchCount (makeRegex \"[^c]ie\" :: Regex) words\n        numFalseRule1  =  matchCount (makeRegex \"[^c]ei\" :: Regex) words\n        rule1Plausible  =  numTrueRule1 > (2*numFalseRule1)\n    printf \"Rule 1 is correct for %d\\n        incorrect for %d\\n\" numTrueRule1 numFalseRule1\n    printf \"*** Rule 1 is %splausible.\\n\" (if rule1Plausible then \"\" else \"im\")\n    \n    putStrLn \"Checking Rule 2: \\\"E before I when preceded by C\\\"...\"\n    let numTrueRule2   =  matchCount (makeRegex \"cei\" :: Regex) words\n        numFalseRule2  =  matchCount (makeRegex \"cie\" :: Regex) words\n        rule2Plausible  =  numTrueRule2 > (2*numFalseRule2)\n    printf \"Rule 2 is correct for %d\\n        incorrect for %d\\n\" numTrueRule2 numFalseRule2\n    printf \"*** Rule 2 is %splausible.\\n\" (if rule2Plausible then \"\" else \"im\")\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 404587, "name": "I before E except after C", "source": "Translate Haskell to Java: import Network.HTTP\nimport Text.Regex.TDFA\nimport Text.Printf\n\ngetWordList :: IO String\ngetWordList  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n\nmain = do\n    words <- getWordList\n    putStrLn \"Checking Rule 1: \\\"I before E when not preceded by C\\\"...\"\n    let numTrueRule1   =  matchCount (makeRegex \"[^c]ie\" :: Regex) words\n        numFalseRule1  =  matchCount (makeRegex \"[^c]ei\" :: Regex) words\n        rule1Plausible  =  numTrueRule1 > (2*numFalseRule1)\n    printf \"Rule 1 is correct for %d\\n        incorrect for %d\\n\" numTrueRule1 numFalseRule1\n    printf \"*** Rule 1 is %splausible.\\n\" (if rule1Plausible then \"\" else \"im\")\n    \n    putStrLn \"Checking Rule 2: \\\"E before I when preceded by C\\\"...\"\n    let numTrueRule2   =  matchCount (makeRegex \"cei\" :: Regex) words\n        numFalseRule2  =  matchCount (makeRegex \"cie\" :: Regex) words\n        rule2Plausible  =  numTrueRule2 > (2*numFalseRule2)\n    printf \"Rule 2 is correct for %d\\n        incorrect for %d\\n\" numTrueRule2 numFalseRule2\n    printf \"*** Rule 2 is %splausible.\\n\" (if rule2Plausible then \"\" else \"im\")\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 404588, "name": "Abelian sandpile model", "source": "Translate Haskell to Java: \n\n\n\nmodule Rosetta.AbelianSandpileModel.ST \n    ( simulate\n    , test\n    , toPGM\n    ) where\n\nimport Control.Monad.Reader (asks, MonadReader (..), ReaderT, runReaderT)\nimport Control.Monad.ST (runST, ST)\nimport Control.Monad.State (evalStateT, forM_, lift, MonadState (..), StateT, modify, when)\nimport Data.Array.ST (freeze, readArray, STUArray, thaw, writeArray)\nimport Data.Array.Unboxed (array, assocs, bounds, UArray, (!))\nimport Data.Word (Word32)\nimport System.IO (hPutStr, hPutStrLn, IOMode (WriteMode), withFile)\nimport Text.Printf (printf)\n\ntype Point     = (Int, Int)\ntype ArrayST s = STUArray s Point Word32\ntype ArrayU    = UArray Point Word32\n\nnewtype M s a = M (ReaderT (S s) (StateT [Point] (ST s)) a)\n    deriving (Functor, Applicative, Monad, MonadReader (S s), MonadState [Point])\n\ndata S s = S \n    { bMin :: !Point\n    , bMax :: !Point\n    , arr  :: !(ArrayST s)\n    }\n\nrunM :: M s a -> S s -> [Point]-> ST s a\nrunM (M m) = evalStateT . runReaderT m\n\nliftST :: ST s a -> M s a\nliftST = M . lift . lift\n\nsimulate :: ArrayU -> ArrayU\nsimulate a = runST $ simulateST a\n\nsimulateST :: forall s. ArrayU -> ST s ArrayU\nsimulateST a = do\n    let (p1, p2) = bounds a\n        s = [p | (p, c) <- assocs a, c >= 4]\n    b <- thaw a :: ST s (ArrayST s)\n    let st = S { bMin = p1\n               , bMax = p2\n               , arr  = b\n               }\n    runM simulateM st s\n\nsimulateM :: forall s. M s ArrayU\nsimulateM = do\n    ps <- get\n    case ps of\n        []      -> asks arr >>= liftST . freeze\n        p : ps' -> do\n            c <- changeArr p $ \\x -> x - 4\n            when (c < 4) $ put ps'\n            forM_ [north, east, south, west] $ inc . ($ p)\n            simulateM\n\nchangeArr :: Point -> (Word32 -> Word32) -> M s Word32\nchangeArr p f = do\n    a    <- asks arr\n    oldC <- liftST $ readArray a p\n    let newC = f oldC\n    liftST $ writeArray a p newC\n    return newC\n\ninc :: Point -> M s ()\ninc p = do\n    b <- inBounds p\n    when b $ do\n        c <- changeArr p succ\n        when (c == 4) $ modify $ (p :)\n\ninBounds :: Point -> M s Bool\ninBounds p = do\n    st <- ask\n    return $ p >= bMin st && p <= bMax st\n\nnorth, east, south, west :: Point -> Point\nnorth (x, y) = (x, y + 1)\neast  (x, y) = (x + 1, y)\nsouth (x, y) = (x, y - 1)\nwest  (x, y) = (x - 1, y)\n\ntoPGM :: ArrayU -> FilePath -> IO ()\ntoPGM a fp = withFile fp WriteMode $ \\h -> do\n    let ((x1, y1), (x2, y2)) = bounds a\n        width  = x2 - x1 + 1\n        height = y2 - y1 + 1\n    hPutStrLn h \"P2\"\n    hPutStrLn h $ show width ++ \" \" ++ show height\n    hPutStrLn h \"3\"\n    forM_ [y1 .. y2] $ \\y -> do\n        forM_ [x1 .. x2] $ \\x -> do\n            let c = min 3 $ a ! (x, y)\n            hPutStr h $ show c ++ \" \"\n        hPutStrLn h \"\"\n\ninitArray :: Int -> Word32 -> ArrayU\ninitArray size height = array \n    ((-size, -size), (size, size))\n    [((x, y), if x == 0 && y == 0 then height else 0) | x <- [-size .. size], y <- [-size .. size]]\n\ntest :: Int -> Word32 -> IO ()\ntest size height = do\n    printf \"size = %d, height = %d\\n\" size height\n    let a  = initArray size height\n        b  = simulate a\n        fp = printf \"sandpile_%d_%d.pgm\" size height\n    toPGM b fp\n    putStrLn $ \"wrote image to \" ++ fp\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AbelianSandpile {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                Frame frame = new Frame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class Frame extends JFrame {\n        private Frame() {\n            super(\"Abelian Sandpile Model\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            Container contentPane = getContentPane();\n            JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n            JButton start = new JButton(\"Restart Simulation\");\n            start.addActionListener(e -> restartSimulation());\n            JButton stop = new JButton(\"Stop Simulation\");\n            stop.addActionListener(e -> stopSimulation());\n            controlPanel.add(start);\n            controlPanel.add(stop);\n            contentPane.add(controlPanel, BorderLayout.NORTH);\n            contentPane.add(canvas = new Canvas(), BorderLayout.CENTER);\n            timer = new Timer(100, e -> canvas.runAndDraw());\n            timer.start();\n            pack();\n        }\n\n        private void restartSimulation() {\n            timer.stop();\n            canvas.initGrid();\n            timer.start();\n        }\n\n        private void stopSimulation() {\n            timer.stop();\n        }\n\n        private Timer timer;\n        private Canvas canvas;\n    }\n\n    private static class Canvas extends JComponent {\n        private Canvas() {\n            setBorder(BorderFactory.createEtchedBorder());\n            setPreferredSize(new Dimension(600, 600));\n        }\n\n        public void paintComponent(Graphics g) {\n            int width = getWidth();\n            int height = getHeight();\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, width, height);\n            int cellWidth = width/GRID_LENGTH;\n            int cellHeight = height/GRID_LENGTH;\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    if (grid[i][j] > 0) {\n                        g.setColor(COLORS[grid[i][j]]);\n                        g.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);\n                    }\n                }\n            }\n        }\n\n        private void initGrid() {\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    grid[i][j] = 0;\n                }\n            }\n        }\n\n        private void runAndDraw() {\n            for (int i = 0; i < 100; ++i)\n                addSand(GRID_LENGTH/2, GRID_LENGTH/2);\n            repaint();\n        }\n\n        private void addSand(int i, int j) {\n            int grains = grid[i][j];\n            if (grains < 3) {\n                grid[i][j]++;\n            }\n            else {\n                grid[i][j] = grains - 3;\n                if (i > 0)\n                    addSand(i - 1, j);\n                if (i < GRID_LENGTH - 1)\n                    addSand(i + 1, j);\n                if (j > 0)\n                    addSand(i, j - 1);\n                if (j < GRID_LENGTH - 1)\n                    addSand(i, j + 1);\n            }\n        }\n\n        private int[][] grid = new int[GRID_LENGTH][GRID_LENGTH];\n    }\n\n    private static final Color[] COLORS = {\n        Color.WHITE,\n        new Color(0x00, 0xbf, 0xff),\n        new Color(0xff, 0xd7, 0x00),\n        new Color(0xb0, 0x30, 0x60)\n    };\n    private static final int GRID_LENGTH = 300;\n}\n"}
{"id": 404589, "name": "Abelian sandpile model", "source": "Translate Haskell to Java: \n\n\n\nmodule Rosetta.AbelianSandpileModel.ST \n    ( simulate\n    , test\n    , toPGM\n    ) where\n\nimport Control.Monad.Reader (asks, MonadReader (..), ReaderT, runReaderT)\nimport Control.Monad.ST (runST, ST)\nimport Control.Monad.State (evalStateT, forM_, lift, MonadState (..), StateT, modify, when)\nimport Data.Array.ST (freeze, readArray, STUArray, thaw, writeArray)\nimport Data.Array.Unboxed (array, assocs, bounds, UArray, (!))\nimport Data.Word (Word32)\nimport System.IO (hPutStr, hPutStrLn, IOMode (WriteMode), withFile)\nimport Text.Printf (printf)\n\ntype Point     = (Int, Int)\ntype ArrayST s = STUArray s Point Word32\ntype ArrayU    = UArray Point Word32\n\nnewtype M s a = M (ReaderT (S s) (StateT [Point] (ST s)) a)\n    deriving (Functor, Applicative, Monad, MonadReader (S s), MonadState [Point])\n\ndata S s = S \n    { bMin :: !Point\n    , bMax :: !Point\n    , arr  :: !(ArrayST s)\n    }\n\nrunM :: M s a -> S s -> [Point]-> ST s a\nrunM (M m) = evalStateT . runReaderT m\n\nliftST :: ST s a -> M s a\nliftST = M . lift . lift\n\nsimulate :: ArrayU -> ArrayU\nsimulate a = runST $ simulateST a\n\nsimulateST :: forall s. ArrayU -> ST s ArrayU\nsimulateST a = do\n    let (p1, p2) = bounds a\n        s = [p | (p, c) <- assocs a, c >= 4]\n    b <- thaw a :: ST s (ArrayST s)\n    let st = S { bMin = p1\n               , bMax = p2\n               , arr  = b\n               }\n    runM simulateM st s\n\nsimulateM :: forall s. M s ArrayU\nsimulateM = do\n    ps <- get\n    case ps of\n        []      -> asks arr >>= liftST . freeze\n        p : ps' -> do\n            c <- changeArr p $ \\x -> x - 4\n            when (c < 4) $ put ps'\n            forM_ [north, east, south, west] $ inc . ($ p)\n            simulateM\n\nchangeArr :: Point -> (Word32 -> Word32) -> M s Word32\nchangeArr p f = do\n    a    <- asks arr\n    oldC <- liftST $ readArray a p\n    let newC = f oldC\n    liftST $ writeArray a p newC\n    return newC\n\ninc :: Point -> M s ()\ninc p = do\n    b <- inBounds p\n    when b $ do\n        c <- changeArr p succ\n        when (c == 4) $ modify $ (p :)\n\ninBounds :: Point -> M s Bool\ninBounds p = do\n    st <- ask\n    return $ p >= bMin st && p <= bMax st\n\nnorth, east, south, west :: Point -> Point\nnorth (x, y) = (x, y + 1)\neast  (x, y) = (x + 1, y)\nsouth (x, y) = (x, y - 1)\nwest  (x, y) = (x - 1, y)\n\ntoPGM :: ArrayU -> FilePath -> IO ()\ntoPGM a fp = withFile fp WriteMode $ \\h -> do\n    let ((x1, y1), (x2, y2)) = bounds a\n        width  = x2 - x1 + 1\n        height = y2 - y1 + 1\n    hPutStrLn h \"P2\"\n    hPutStrLn h $ show width ++ \" \" ++ show height\n    hPutStrLn h \"3\"\n    forM_ [y1 .. y2] $ \\y -> do\n        forM_ [x1 .. x2] $ \\x -> do\n            let c = min 3 $ a ! (x, y)\n            hPutStr h $ show c ++ \" \"\n        hPutStrLn h \"\"\n\ninitArray :: Int -> Word32 -> ArrayU\ninitArray size height = array \n    ((-size, -size), (size, size))\n    [((x, y), if x == 0 && y == 0 then height else 0) | x <- [-size .. size], y <- [-size .. size]]\n\ntest :: Int -> Word32 -> IO ()\ntest size height = do\n    printf \"size = %d, height = %d\\n\" size height\n    let a  = initArray size height\n        b  = simulate a\n        fp = printf \"sandpile_%d_%d.pgm\" size height\n    toPGM b fp\n    putStrLn $ \"wrote image to \" ++ fp\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AbelianSandpile {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                Frame frame = new Frame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class Frame extends JFrame {\n        private Frame() {\n            super(\"Abelian Sandpile Model\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            Container contentPane = getContentPane();\n            JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n            JButton start = new JButton(\"Restart Simulation\");\n            start.addActionListener(e -> restartSimulation());\n            JButton stop = new JButton(\"Stop Simulation\");\n            stop.addActionListener(e -> stopSimulation());\n            controlPanel.add(start);\n            controlPanel.add(stop);\n            contentPane.add(controlPanel, BorderLayout.NORTH);\n            contentPane.add(canvas = new Canvas(), BorderLayout.CENTER);\n            timer = new Timer(100, e -> canvas.runAndDraw());\n            timer.start();\n            pack();\n        }\n\n        private void restartSimulation() {\n            timer.stop();\n            canvas.initGrid();\n            timer.start();\n        }\n\n        private void stopSimulation() {\n            timer.stop();\n        }\n\n        private Timer timer;\n        private Canvas canvas;\n    }\n\n    private static class Canvas extends JComponent {\n        private Canvas() {\n            setBorder(BorderFactory.createEtchedBorder());\n            setPreferredSize(new Dimension(600, 600));\n        }\n\n        public void paintComponent(Graphics g) {\n            int width = getWidth();\n            int height = getHeight();\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, width, height);\n            int cellWidth = width/GRID_LENGTH;\n            int cellHeight = height/GRID_LENGTH;\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    if (grid[i][j] > 0) {\n                        g.setColor(COLORS[grid[i][j]]);\n                        g.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);\n                    }\n                }\n            }\n        }\n\n        private void initGrid() {\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    grid[i][j] = 0;\n                }\n            }\n        }\n\n        private void runAndDraw() {\n            for (int i = 0; i < 100; ++i)\n                addSand(GRID_LENGTH/2, GRID_LENGTH/2);\n            repaint();\n        }\n\n        private void addSand(int i, int j) {\n            int grains = grid[i][j];\n            if (grains < 3) {\n                grid[i][j]++;\n            }\n            else {\n                grid[i][j] = grains - 3;\n                if (i > 0)\n                    addSand(i - 1, j);\n                if (i < GRID_LENGTH - 1)\n                    addSand(i + 1, j);\n                if (j > 0)\n                    addSand(i, j - 1);\n                if (j < GRID_LENGTH - 1)\n                    addSand(i, j + 1);\n            }\n        }\n\n        private int[][] grid = new int[GRID_LENGTH][GRID_LENGTH];\n    }\n\n    private static final Color[] COLORS = {\n        Color.WHITE,\n        new Color(0x00, 0xbf, 0xff),\n        new Color(0xff, 0xd7, 0x00),\n        new Color(0xb0, 0x30, 0x60)\n    };\n    private static final int GRID_LENGTH = 300;\n}\n"}
{"id": 404590, "name": "Xiaolin Wu's line algorithm", "source": "Translate Haskell to Java: \n\nmodule Main (main) where\n\nimport Codec.Picture (writePng)\nimport Codec.Picture.Types (Image, MutableImage(..), Pixel, PixelRGB8(..), createMutableImage, unsafeFreezeImage, writePixel)\nimport Control.Monad (void)\nimport Control.Monad.Primitive (PrimMonad, PrimState)\nimport Data.Foldable (foldlM)\n\ntype MImage m px = MutableImage (PrimState m) px\n\n\nwithMutableImage\n    :: (Pixel px, PrimMonad m)\n    => Int                      \n    -> Int                      \n    -> px                       \n    -> (MImage m px -> m ())    \n    -> m (Image px)             \nwithMutableImage w h px f = createMutableImage w h px >>= \\m -> f m >> unsafeFreezeImage m\n\n\nplot\n    :: (Pixel px, PrimMonad m)\n    => MImage m px  \n    -> Int          \n    -> Int          \n    -> px           \n    -> m ()         \nplot = writePixel\n\n\ndrawAntialiasedLine\n    :: forall px m . (Pixel px, PrimMonad m)\n    => MImage m px      \n    -> Int              \n    -> Int              \n    -> Int              \n    -> Int              \n    -> (Double -> px)   \n    -> m ()             \ndrawAntialiasedLine m p1x p1y p2x p2y colour = do\n    let steep = abs (p2y - p1y) > abs (p2x - p1x)\n        ((p3x, p4x), (p3y, p4y)) = swapIf steep ((p1x, p2x), (p1y, p2y))\n        ((ax, ay), (bx, by)) = swapIf (p3x > p4x) ((p3x, p3y), (p4x, p4y))\n        dx = bx - ax\n        dy = by - ay\n        gradient = if dx == 0 then 1.0 else fromIntegral dy / fromIntegral dx\n\n    \n    let xpxl1 = ax \n        yend1 = fromIntegral ay + gradient * fromIntegral (xpxl1 - ax)\n        xgap1 = rfpart (fromIntegral ax + 0.5)\n    endpoint steep xpxl1 yend1 xgap1\n\n    \n    let xpxl2 = bx \n        yend2 = fromIntegral by + gradient * fromIntegral (xpxl2 - bx)\n        xgap2 = fpart (fromIntegral bx + 0.5)\n    endpoint steep xpxl2 yend2 xgap2\n\n    \n    let intery = yend1 + gradient\n    void $ if steep\n        then foldlM (\\i x -> do\n            plot m (ipart i) x (colour (rfpart i))\n            plot m (ipart i + 1) x (colour (fpart i))\n            pure $ i + gradient) intery [xpxl1 + 1..xpxl2 - 1]\n        else foldlM (\\i x -> do\n            plot m x (ipart i) (colour (rfpart i))\n            plot m x (ipart i + 1) (colour (fpart i))\n            pure $ i + gradient) intery [xpxl1 + 1..xpxl2 - 1]\n\n    where\n        endpoint :: Bool -> Int -> Double -> Double -> m ()\n        endpoint True xpxl yend xgap = do\n            plot m ypxl xpxl (colour (rfpart yend * xgap))\n            plot m (ypxl + 1) xpxl (colour (fpart yend * xgap))\n            where ypxl = ipart yend\n        endpoint False xpxl yend xgap = do\n            plot m xpxl ypxl (colour (rfpart yend * xgap))\n            plot m xpxl (ypxl + 1) (colour (fpart yend * xgap))\n            where ypxl = ipart yend\n\nswapIf :: Bool -> (a, a) -> (a, a)\nswapIf False p = p\nswapIf True (x, y) = (y, x)\n\nipart :: Double -> Int\nipart = truncate\n\nfpart :: Double -> Double\nfpart x\n    | x > 0 = x - temp\n    | otherwise = x - (temp + 1)\n    where temp = fromIntegral (ipart x)\n\nrfpart :: Double -> Double\nrfpart x = 1 - fpart x\n\nmain :: IO ()\nmain = do\n    \n    \n    img <- withMutableImage 640 480 (PixelRGB8 0 0 0) $ \\m@(MutableImage w h _) ->\n            drawAntialiasedLine m 2 2 (w - 2) (h - 2)\n            (\\brightness -> let level = round (brightness * 255) in PixelRGB8 level level level)\n\n    \n    writePng \"xiaolin-wu-algorithm.png\" img\n", "target": "import java.awt.*;\nimport static java.lang.Math.*;\nimport javax.swing.*;\n\npublic class XiaolinWu extends JPanel {\n\n    public XiaolinWu() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n    }\n\n    void plot(Graphics2D g, double x, double y, double c) {\n        g.setColor(new Color(0f, 0f, 0f, (float)c));\n        g.fillOval((int) x, (int) y, 2, 2);\n    }\n\n    int ipart(double x) {\n        return (int) x;\n    }\n\n    double fpart(double x) {\n        return x - floor(x);\n    }\n\n    double rfpart(double x) {\n        return 1.0 - fpart(x);\n    }\n\n    void drawLine(Graphics2D g, double x0, double y0, double x1, double y1) {\n\n        boolean steep = abs(y1 - y0) > abs(x1 - x0);\n        if (steep)\n            drawLine(g, y0, x0, y1, x1);\n\n        if (x0 > x1)\n            drawLine(g, x1, y1, x0, y0);\n\n        double dx = x1 - x0;\n        double dy = y1 - y0;\n        double gradient = dy / dx;\n\n        \n        double xend = round(x0);\n        double yend = y0 + gradient * (xend - x0);\n        double xgap = rfpart(x0 + 0.5);\n        double xpxl1 = xend; \n        double ypxl1 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl1, xpxl1, rfpart(yend) * xgap);\n            plot(g, ypxl1 + 1, xpxl1, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl1, ypxl1, rfpart(yend) * xgap);\n            plot(g, xpxl1, ypxl1 + 1, fpart(yend) * xgap);\n        }\n\n        \n        double intery = yend + gradient;\n\n        \n        xend = round(x1);\n        yend = y1 + gradient * (xend - x1);\n        xgap = fpart(x1 + 0.5);\n        double xpxl2 = xend; \n        double ypxl2 = ipart(yend);\n\n        if (steep) {\n            plot(g, ypxl2, xpxl2, rfpart(yend) * xgap);\n            plot(g, ypxl2 + 1, xpxl2, fpart(yend) * xgap);\n        } else {\n            plot(g, xpxl2, ypxl2, rfpart(yend) * xgap);\n            plot(g, xpxl2, ypxl2 + 1, fpart(yend) * xgap);\n        }\n\n        \n        for (double x = xpxl1 + 1; x <= xpxl2 - 1; x++) {\n            if (steep) {\n                plot(g, ipart(intery), x, rfpart(intery));\n                plot(g, ipart(intery) + 1, x, fpart(intery));\n            } else {\n                plot(g, x, ipart(intery), rfpart(intery));\n                plot(g, x, ipart(intery) + 1, fpart(intery));\n            }\n            intery = intery + gradient;\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n\n        drawLine(g, 550, 170, 50, 435);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Xiaolin Wu's line algorithm\");\n            f.setResizable(false);\n            f.add(new XiaolinWu(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 404591, "name": "Next highest int from digits", "source": "Translate Haskell to Java: import Data.List (nub, permutations, sort)\n\ndigitShuffleSuccessors :: Integer -> [Integer]\ndigitShuffleSuccessors n =\n  (fmap . (+) <*> (nub . sort . concatMap go . permutations . show)) n\n  where\n    go ds\n      | 0 >= delta = []\n      | otherwise = [delta]\n      where\n        delta = (read ds :: Integer) - n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n  fTable\n    \"Taking up to 5 digit-shuffle successors of a positive integer:\\n\"\n    show\n    (\\xs ->\n        let harvest = take 5 xs\n        in rjust\n             12\n             ' '\n             (show (length harvest) <> \" of \" <> show (length xs) <> \": \") <>\n           show harvest)\n    digitShuffleSuccessors\n    [0, 9, 12, 21, 12453, 738440, 45072010, 95322020]\n\n\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  unlines $\n  s : fmap (((<>) . rjust w ' ' . xShow) <*> ((\" -> \" <>) . fxShow . f)) xs\n  where\n    w = maximum (length . xShow <$> xs)\n\nrjust :: Int -> Char -> String -> String\nrjust n c = drop . length <*> (replicate n c <>)\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NextHighestIntFromDigits {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"0\", \"9\", \"12\", \"21\", \"12453\", \"738440\", \"45072010\", \"95322020\", \"9589776899767587796600\", \"3345333\"} ) {\n            System.out.printf(\"%s -> %s%n\", format(s), format(next(s)));\n        }\n        testAll(\"12345\");\n        testAll(\"11122\");\n    }\n\n    private static NumberFormat FORMAT = NumberFormat.getNumberInstance();\n    \n    private static String format(String s) {\n        return FORMAT.format(new BigInteger(s));\n    }\n\n    private static void testAll(String s) {\n        System.out.printf(\"Test all permutations of:  %s%n\", s);\n        String sOrig = s;\n        String sPrev = s;\n        int count = 1;\n        \n        \n        boolean orderOk = true;\n        Map <String,Integer> uniqueMap = new HashMap<>();\n        uniqueMap.put(s, 1);\n        while ( (s = next(s)).compareTo(\"0\") != 0 ) {\n            count++;\n            if ( Long.parseLong(s) < Long.parseLong(sPrev) ) {\n                orderOk = false;\n            }\n            uniqueMap.merge(s, 1, (v1, v2) -> v1 + v2);\n            sPrev = s;\n        }\n        System.out.printf(\"    Order:  OK =  %b%n\", orderOk);\n\n        \n        String reverse = new StringBuilder(sOrig).reverse().toString();\n        System.out.printf(\"    Last permutation:  Actual = %s, Expected = %s, OK = %b%n\", sPrev, reverse, sPrev.compareTo(reverse) == 0);\n\n        \n        boolean unique = true;\n        for ( String key : uniqueMap.keySet() ) {\n            if ( uniqueMap.get(key) > 1 ) {\n                unique = false;\n            }\n        }\n        System.out.printf(\"    Permutations unique:  OK =  %b%n\", unique);\n        \n        \n        Map<Character,Integer> charMap = new HashMap<>();\n        for ( char c : sOrig.toCharArray() ) {\n            charMap.merge(c, 1, (v1, v2) -> v1 + v2);\n        }\n        long permCount = factorial(sOrig.length());\n        for ( char c : charMap.keySet() ) {\n            permCount /= factorial(charMap.get(c));\n        }\n        System.out.printf(\"    Permutation count:  Actual = %d, Expected = %d, OK = %b%n\", count, permCount, count == permCount);\n        \n\n    }\n    \n    private static long factorial(long n) {\n        long fact = 1;\n        for (long num = 2 ; num <= n ; num++ ) {\n            fact *= num;\n        }\n        return fact;\n    }\n    \n    private static String next(String s) {\n        StringBuilder sb = new StringBuilder();\n        int index = s.length()-1;\n        \n        while ( index > 0 && s.charAt(index-1) >= s.charAt(index)) {\n            index--;\n        }\n        \n        if ( index == 0 ) {\n            return \"0\";\n        }\n\n        \n        int index2 = index;\n        for ( int i = index + 1 ; i < s.length() ; i++ ) {\n            if ( s.charAt(i) < s.charAt(index2) && s.charAt(i) > s.charAt(index-1) ) {\n                index2 = i;\n            }\n        }\n        \n        \n        \n        if ( index > 1 ) {\n            sb.append(s.subSequence(0, index-1));\n        }\n\n        \n        sb.append(s.charAt(index2));\n        \n        \n        List<Character> chars = new ArrayList<>();\n        chars.add(s.charAt(index-1));\n        for ( int i = index ; i < s.length() ; i++ ) {\n            if ( i != index2 ) {\n                chars.add(s.charAt(i));\n            }\n        }\n        \n        \n        Collections.sort(chars);\n        for ( char c : chars ) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 404592, "name": "Next highest int from digits", "source": "Translate Haskell to Java: import Data.List (nub, permutations, sort)\n\ndigitShuffleSuccessors :: Integer -> [Integer]\ndigitShuffleSuccessors n =\n  (fmap . (+) <*> (nub . sort . concatMap go . permutations . show)) n\n  where\n    go ds\n      | 0 >= delta = []\n      | otherwise = [delta]\n      where\n        delta = (read ds :: Integer) - n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n  fTable\n    \"Taking up to 5 digit-shuffle successors of a positive integer:\\n\"\n    show\n    (\\xs ->\n        let harvest = take 5 xs\n        in rjust\n             12\n             ' '\n             (show (length harvest) <> \" of \" <> show (length xs) <> \": \") <>\n           show harvest)\n    digitShuffleSuccessors\n    [0, 9, 12, 21, 12453, 738440, 45072010, 95322020]\n\n\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  unlines $\n  s : fmap (((<>) . rjust w ' ' . xShow) <*> ((\" -> \" <>) . fxShow . f)) xs\n  where\n    w = maximum (length . xShow <$> xs)\n\nrjust :: Int -> Char -> String -> String\nrjust n c = drop . length <*> (replicate n c <>)\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class NextHighestIntFromDigits {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"0\", \"9\", \"12\", \"21\", \"12453\", \"738440\", \"45072010\", \"95322020\", \"9589776899767587796600\", \"3345333\"} ) {\n            System.out.printf(\"%s -> %s%n\", format(s), format(next(s)));\n        }\n        testAll(\"12345\");\n        testAll(\"11122\");\n    }\n\n    private static NumberFormat FORMAT = NumberFormat.getNumberInstance();\n    \n    private static String format(String s) {\n        return FORMAT.format(new BigInteger(s));\n    }\n\n    private static void testAll(String s) {\n        System.out.printf(\"Test all permutations of:  %s%n\", s);\n        String sOrig = s;\n        String sPrev = s;\n        int count = 1;\n        \n        \n        boolean orderOk = true;\n        Map <String,Integer> uniqueMap = new HashMap<>();\n        uniqueMap.put(s, 1);\n        while ( (s = next(s)).compareTo(\"0\") != 0 ) {\n            count++;\n            if ( Long.parseLong(s) < Long.parseLong(sPrev) ) {\n                orderOk = false;\n            }\n            uniqueMap.merge(s, 1, (v1, v2) -> v1 + v2);\n            sPrev = s;\n        }\n        System.out.printf(\"    Order:  OK =  %b%n\", orderOk);\n\n        \n        String reverse = new StringBuilder(sOrig).reverse().toString();\n        System.out.printf(\"    Last permutation:  Actual = %s, Expected = %s, OK = %b%n\", sPrev, reverse, sPrev.compareTo(reverse) == 0);\n\n        \n        boolean unique = true;\n        for ( String key : uniqueMap.keySet() ) {\n            if ( uniqueMap.get(key) > 1 ) {\n                unique = false;\n            }\n        }\n        System.out.printf(\"    Permutations unique:  OK =  %b%n\", unique);\n        \n        \n        Map<Character,Integer> charMap = new HashMap<>();\n        for ( char c : sOrig.toCharArray() ) {\n            charMap.merge(c, 1, (v1, v2) -> v1 + v2);\n        }\n        long permCount = factorial(sOrig.length());\n        for ( char c : charMap.keySet() ) {\n            permCount /= factorial(charMap.get(c));\n        }\n        System.out.printf(\"    Permutation count:  Actual = %d, Expected = %d, OK = %b%n\", count, permCount, count == permCount);\n        \n\n    }\n    \n    private static long factorial(long n) {\n        long fact = 1;\n        for (long num = 2 ; num <= n ; num++ ) {\n            fact *= num;\n        }\n        return fact;\n    }\n    \n    private static String next(String s) {\n        StringBuilder sb = new StringBuilder();\n        int index = s.length()-1;\n        \n        while ( index > 0 && s.charAt(index-1) >= s.charAt(index)) {\n            index--;\n        }\n        \n        if ( index == 0 ) {\n            return \"0\";\n        }\n\n        \n        int index2 = index;\n        for ( int i = index + 1 ; i < s.length() ; i++ ) {\n            if ( s.charAt(i) < s.charAt(index2) && s.charAt(i) > s.charAt(index-1) ) {\n                index2 = i;\n            }\n        }\n        \n        \n        \n        if ( index > 1 ) {\n            sb.append(s.subSequence(0, index-1));\n        }\n\n        \n        sb.append(s.charAt(index2));\n        \n        \n        List<Character> chars = new ArrayList<>();\n        chars.add(s.charAt(index-1));\n        for ( int i = index ; i < s.length() ; i++ ) {\n            if ( i != index2 ) {\n                chars.add(s.charAt(i));\n            }\n        }\n        \n        \n        Collections.sort(chars);\n        for ( char c : chars ) {\n            sb.append(c);\n        }\n        return sb.toString();\n    }\n}\n"}
{"id": 404593, "name": "Four is magic", "source": "Translate Haskell to Java: module Main where\n\nimport Data.List (find)\nimport Data.Char (toUpper)\n\nfirstNums :: [String]\nfirstNums =\n  [ \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n    \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n  ]\n\ntens :: [String]\ntens = [\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\nbiggerNumbers :: [(Int, String)]\nbiggerNumbers =\n  [(100, \"hundred\"), (1000, \"thousand\"), (1000000, \"million\"), (1000000000, \"billion\"), (1000000000000, \"trillion\")]\n\ncardinal :: Int -> String\ncardinal n\n  | n' < 20 =\n    negText ++ firstNums !! n'\n  | n' < 100 =\n    negText ++ tens !! (n' `div` 10 - 2) ++ if n' `mod` 10 /= 0 then \"-\" ++ firstNums !! (n' `mod` 10) else \"\"\n  | otherwise =\n    let (num, name) =\n          maybe\n            (last biggerNumbers)\n            fst\n            (find (\\((num_, _), (num_', _)) -> n' < num_') (zip biggerNumbers (tail biggerNumbers)))\n        smallerNum = cardinal (n' `div` num)\n     in negText ++ smallerNum ++ \" \" ++ name ++ if n' `mod` num /= 0 then \" \" ++ cardinal (n' `mod` num) else \"\"\n  where\n    n' = abs n\n    negText = if n < 0 then \"negative \" else \"\"\n\ncapitalized :: String -> String\ncapitalized (x : xs) = toUpper x : xs\ncapitalized [] = []\n\nmagic :: Int -> String\nmagic =\n  go True\n  where\n    go first num =\n      let cardiNum = cardinal num\n       in (if first then capitalized else id) cardiNum ++ \" is \"\n            ++ if num == 4\n              then \"magic.\"\n              else cardinal (length cardiNum) ++ \", \" ++ go False (length cardiNum)\n\nmain :: IO ()\nmain = do\n  putStrLn $ magic 3\n  putStrLn $ magic 15\n  putStrLn $ magic 4\n  putStrLn $ magic 10\n  putStrLn $ magic 20\n  putStrLn $ magic (-13)\n  putStrLn $ magic 999999\n", "target": "public class FourIsMagic {\n\n    public static void main(String[] args) {\n        for ( long n : new long[] {6, 60, 89, 300, 670, 2000, 2467, 20000, 24500,200000, 230000, 246571, 2300000, 2465712, 20000000, 24657123, 230000000, 245000000, -246570000, 123456789712345l, 8777777777777777777L, Long.MAX_VALUE}) {\n            String magic = fourIsMagic(n);\n            System.out.printf(\"%d = %s%n\", n, toSentence(magic));\n        }\n    }\n    \n    private static final String toSentence(String s) {\n        return s.substring(0,1).toUpperCase() + s.substring(1) + \".\";\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String fourIsMagic(long n) {\n        if ( n == 4 ) {\n            return numToString(n) + \" is magic\";\n        }\n        String result = numToString(n);\n        return result + \" is \" + numToString(result.length()) + \", \" + fourIsMagic(result.length());\n    }\n    \n    private static final String numToString(long n) {\n        if ( n < 0 ) { \n            return \"negative \" + numToString(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \" \" + numToString(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToString(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToString(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 404594, "name": "Sierpinski pentagon", "source": "Translate Haskell to Java: import Graphics.Gloss \n\npentaflake :: Int -> Picture\npentaflake order = iterate transformation pentagon !! order\n  where\n    transformation = Scale s s . foldMap copy [0,72..288]\n    copy a = Rotate a . Translate 0 x\n    pentagon = Polygon [ (sin a, cos a) | a <- [0,2*pi/5..2*pi] ]\n    x = 2*cos(pi/5)\n    s = 1/(1+x)\n\nmain = display dc white (Color blue $ Scale 300 300 $ pentaflake 5)\n  where dc = InWindow \"Pentaflake\" (400, 400) (0, 0)\n", "target": "import java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.geom.Path2D;\nimport static java.lang.Math.*;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class SierpinskiPentagon extends JPanel {\n    \n    final double degrees072 = toRadians(72);\n\n    \n    final double scaleFactor = 1 / (2 + cos(degrees072) * 2);\n\n    final int margin = 20;\n    int limit = 0;\n    Random r = new Random();\n\n    public SierpinskiPentagon() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n\n        new Timer(3000, (ActionEvent e) -> {\n            limit++;\n            if (limit >= 5)\n                limit = 0;\n            repaint();\n        }).start();\n    }\n\n    void drawPentagon(Graphics2D g, double x, double y, double side, int depth) {\n        double angle = 3 * degrees072; \n\n        if (depth == 0) {\n\n            Path2D p = new Path2D.Double();\n            p.moveTo(x, y);\n\n            \n            for (int i = 0; i < 5; i++) {\n                x = x + cos(angle) * side;\n                y = y - sin(angle) * side;\n                p.lineTo(x, y);\n                angle += degrees072;\n            }\n\n            g.setColor(RandomHue.next());\n            g.fill(p);\n\n        } else {\n\n            side *= scaleFactor;\n\n            \n            double distance = side + side * cos(degrees072) * 2;\n\n            \n            for (int i = 0; i < 5; i++) {\n                x = x + cos(angle) * distance;\n                y = y - sin(angle) * distance;\n                drawPentagon(g, x, y, side, depth - 1);\n                angle += degrees072;\n            }\n        }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        int w = getWidth();\n        double radius = w / 2 - 2 * margin;\n        double side = radius * sin(PI / 5) * 2;\n\n        drawPentagon(g, w / 2, 3 * margin, side, limit);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Sierpinski Pentagon\");\n            f.setResizable(true);\n            f.add(new SierpinskiPentagon(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n\nclass RandomHue {\n    \n    final static double goldenRatioConjugate = (sqrt(5) - 1) / 2;\n    private static double hue = Math.random();\n\n    static Color next() {\n        hue = (hue + goldenRatioConjugate) % 1;\n        return Color.getHSBColor((float) hue, 1, 1);\n    }\n}\n"}
{"id": 404595, "name": "Zhang-Suen thinning algorithm", "source": "Translate Haskell to Java: import Data.Array\nimport qualified Data.List as List\n\ndata BW = Black | White\n        deriving (Eq, Show)\n\ntype Index = (Int, Int)\ntype BWArray = Array Index BW\n\ntoBW :: Char -> BW\ntoBW '0' = White\ntoBW '1' = Black\ntoBW ' ' = White\ntoBW '#' = Black\ntoBW _   = error \"toBW: illegal char\"\n\ntoBWArray :: [String] -> BWArray\ntoBWArray strings = arr\n  where\n    height = length strings\n    width  = minimum $ map length strings\n    arr    = listArray ((0, 0), (width - 1, height - 1))\n             . map toBW . concat . List.transpose $ map (take width) strings\n\ntoChar :: BW -> Char\ntoChar White = ' '\ntoChar Black = '#'\n\nchunksOf :: Int -> [a] -> [[a]]\nchunksOf _ [] = []\nchunksOf n xs = take n xs : (chunksOf n $ drop n xs)\n\nshowBWArray :: BWArray -> String\nshowBWArray arr =\n  List.intercalate \"\\n\" . List.transpose\n  . chunksOf (height + 1) . map toChar $ elems arr\n  where\n    (_, (_, height)) = bounds arr\n\nadd :: Num a => (a, a) -> (a, a) -> (a, a)\nadd (a, b) (x, y) = (a + x, b + y)\n\nwithin :: Ord a => ((a, a), (a, a)) -> (a, a) -> Bool\nwithin ((a, b), (c, d)) (x, y) =\n  a <= x && x <= c &&\n  b <= y && y <= d\n\np2, p3, p4, p5, p6, p7, p8, p9 :: Index\np2 = ( 0, -1)\np3 = ( 1, -1)\np4 = ( 1,  0)\np5 = ( 1,  1)\np6 = ( 0,  1)\np7 = (-1,  1)\np8 = (-1,  0)\np9 = (-1, -1)\n\nixamap :: Ix i => ((i, a) -> b) -> Array i a -> Array i b\nixamap f a = listArray (bounds a) $ map f $ assocs a\n\nthin :: BWArray -> BWArray\nthin arr =\n  if pass2 == arr then pass2 else thin pass2\n  where\n    (low, high)     = bounds arr\n    lowB            = low `add` (1, 1)\n    highB           = high `add` (-1, -1)\n    isInner         = within (lowB, highB)\n    offs p          = map (add p) [p2, p3, p4, p5, p6, p7, p8, p9]\n    trans c (a, b)  = if a == White && b == Black then c + 1 else c\n    zipshift xs     = zip xs (drop 1 xs ++ xs)\n    transitions a   = (== (1 :: Int)) . foldl trans 0 . zipshift . map (a !) . offs\n    within2to6 n    = 2 <= n && n <= 6\n    blacks a p      = within2to6 . length . filter ((== Black) . (a !)) $ offs p\n    oneWhite xs a p = any ((== White) . (a !) . add p) xs\n    oneRight        = oneWhite [p2, p4, p6]\n    oneDown         = oneWhite [p4, p6, p8]\n    oneUp           = oneWhite [p2, p4, p8]\n    oneLeft         = oneWhite [p2, p6, p8]\n    precond a p     = (a ! p == Black) && isInner p && blacks a p && transitions a p\n    stage1 a p      = precond a p && oneRight a p && oneDown a p\n    stage2 a p      = precond a p && oneUp a p && oneLeft a p\n    stager f (p, d) = if f p then White else d\n    pass1           = ixamap (stager $ stage1 arr) arr\n    pass2           = ixamap (stager $ stage2 pass1) pass1\n\nsampleExA :: [String]\nsampleExA =\n  [\"00000000000000000000000000000000\"\n  ,\"01111111110000000111111110000000\"\n  ,\"01110001111000001111001111000000\"\n  ,\"01110000111000001110000111000000\"\n  ,\"01110001111000001110000000000000\"\n  ,\"01111111110000001110000000000000\"\n  ,\"01110111100000001110000111000000\"\n  ,\"01110011110011101111001111011100\"\n  ,\"01110001111011100111111110011100\"\n  ,\"00000000000000000000000000000000\"]\n\nsampleExB :: [String]\nsampleExB =\n  [\"                                                          \"\n  ,\" #################                   #############        \"\n  ,\" ##################               ################        \"\n  ,\" ###################            ##################        \"\n  ,\" ########     #######          ###################        \"\n  ,\"   ######     #######         #######       ######        \"\n  ,\"   ######     #######        #######                      \"\n  ,\"   #################         #######                      \"\n  ,\"   ################          #######                      \"\n  ,\"   #################         #######                      \"\n  ,\"   ######     #######        #######                      \"\n  ,\"   ######     #######        #######                      \"\n  ,\"   ######     #######         #######       ######        \"\n  ,\" ########     #######          ###################        \"\n  ,\" ########     ####### ######    ################## ###### \"\n  ,\" ########     ####### ######      ################ ###### \"\n  ,\" ########     ####### ######         ############# ###### \"\n  ,\"                                                          \"]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . showBWArray . thin . toBWArray) [sampleExA, sampleExB]\n", "target": "import java.awt.Point;\nimport java.util.*;\n\npublic class ZhangSuen {\n\n    final static String[] image = {\n        \"                                                          \",\n        \" #################                   #############        \",\n        \" ##################               ################        \",\n        \" ###################            ##################        \",\n        \" ########     #######          ###################        \",\n        \"   ######     #######         #######       ######        \",\n        \"   ######     #######        #######                      \",\n        \"   #################         #######                      \",\n        \"   ################          #######                      \",\n        \"   #################         #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######         #######       ######        \",\n        \" ########     #######          ###################        \",\n        \" ########     ####### ######    ################## ###### \",\n        \" ########     ####### ######      ################ ###### \",\n        \" ########     ####### ######         ############# ###### \",\n        \"                                                          \"};\n\n    final static int[][] nbrs = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1},\n        {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\n    final static int[][][] nbrGroups = {{{0, 2, 4}, {2, 4, 6}}, {{0, 2, 6},\n        {0, 4, 6}}};\n\n    static List<Point> toWhite = new ArrayList<>();\n    static char[][] grid;\n\n    public static void main(String[] args) {\n        grid = new char[image.length][];\n        for (int r = 0; r < image.length; r++)\n            grid[r] = image[r].toCharArray();\n\n        thinImage();\n    }\n\n    static void thinImage() {\n        boolean firstStep = false;\n        boolean hasChanged;\n\n        do {\n            hasChanged = false;\n            firstStep = !firstStep;\n\n            for (int r = 1; r < grid.length - 1; r++) {\n                for (int c = 1; c < grid[0].length - 1; c++) {\n\n                    if (grid[r][c] != '#')\n                        continue;\n\n                    int nn = numNeighbors(r, c);\n                    if (nn < 2 || nn > 6)\n                        continue;\n\n                    if (numTransitions(r, c) != 1)\n                        continue;\n\n                    if (!atLeastOneIsWhite(r, c, firstStep ? 0 : 1))\n                        continue;\n\n                    toWhite.add(new Point(c, r));\n                    hasChanged = true;\n                }\n            }\n\n            for (Point p : toWhite)\n                grid[p.y][p.x] = ' ';\n            toWhite.clear();\n\n        } while (firstStep || hasChanged);\n\n        printResult();\n    }\n\n    static int numNeighbors(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == '#')\n                count++;\n        return count;\n    }\n\n    static int numTransitions(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == ' ') {\n                if (grid[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == '#')\n                    count++;\n            }\n        return count;\n    }\n\n    static boolean atLeastOneIsWhite(int r, int c, int step) {\n        int count = 0;\n        int[][] group = nbrGroups[step];\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < group[i].length; j++) {\n                int[] nbr = nbrs[group[i][j]];\n                if (grid[r + nbr[1]][c + nbr[0]] == ' ') {\n                    count++;\n                    break;\n                }\n            }\n        return count > 1;\n    }\n\n    static void printResult() {\n        for (char[] row : grid)\n            System.out.println(row);\n    }\n}\n"}
{"id": 404596, "name": "Generate Chess960 starting position", "source": "Translate Haskell to Java: import Data.List\nimport qualified Data.Set as Set\n\ndata Piece = K | Q | R | B | N deriving (Eq, Ord, Show)\n\nisChess960 :: [Piece] -> Bool\nisChess960 rank =\n  (odd . sum $ findIndices (== B) rank) && king > rookA && king < rookB\n  where\n    Just king      = findIndex (== K) rank\n    [rookA, rookB] = findIndices (== R) rank\n\nmain :: IO ()\nmain = mapM_ (putStrLn . concatMap show) . Set.toList . Set.fromList\n       . filter isChess960 $ permutations [R,N,B,Q,K,B,N,R]\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Chess960{\n\tprivate static List<Character> pieces = Arrays.asList('R','B','N','Q','K','N','B','R');\n\n\tpublic static List<Character> generateFirstRank(){\n\t\tdo{\n\t\t\tCollections.shuffle(pieces);\n\t\t}while(!check(pieces.toString().replaceAll(\"[^\\\\p{Upper}]\", \"\"))); \n\t\t\n\t\treturn pieces;\n\t}\n\n\tprivate static boolean check(String rank){\n\t\tif(!rank.matches(\".*R.*K.*R.*\")) return false;\t\t\t\n\t\tif(!rank.matches(\".*B(..|....|......|)B.*\")) return false;\t\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(generateFirstRank());\n\t\t}\n\t}\n}\n"}
{"id": 404597, "name": "Spelling of ordinal numbers", "source": "Translate Haskell to Java: spellOrdinal :: Integer -> String\nspellOrdinal n\n | n <=   0  = \"not ordinal\"\n | n <   20  = small n\n | n < 100   = case divMod n 10 of\n     (k, 0) -> spellInteger (10*k) ++ \"th\"\n     (k, m) -> spellInteger (10*k) ++ \"-\" ++ spellOrdinal m\n | n < 1000 = case divMod n 100 of\n     (k, 0) -> spellInteger (100*k) ++ \"th\"\n     (k, m) -> spellInteger (100*k) ++ \" and \" ++ spellOrdinal m\n | otherwise = case divMod n 1000 of\n     (k, 0) -> spellInteger (1000*k) ++ \"th\"\n     (k, m) -> spellInteger (k*1000) ++ s ++ spellOrdinal m\n       where s = if m < 100 then \" and \" else \", \"   \n  where \n   small = ([ undefined, \"first\", \"second\", \"third\", \"fourth\", \"fifth\"\n            , \"sixth\", \"seventh\", \"eighth\", \"nineth\", \"tenth\", \"eleventh\"\n            , \"twelveth\", \"thirteenth\", \"fourteenth\", \"fifteenth\", \"sixteenth\"\n            , \"seventeenth\", \"eighteenth\", \"nineteenth\"] !!) . fromEnum\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class SpellingOfOrdinalNumbers {\n\n    public static void main(String[] args) {\n        for ( long test : new long[] {1,  2,  3,  4,  5,  11,  65,  100,  101,  272,  23456,  8007006005004003L} ) {\n            System.out.printf(\"%d = %s%n\", test, toOrdinal(test));\n        }\n    }\n\n    private static Map<String,String> ordinalMap = new HashMap<>();\n    static {\n        ordinalMap.put(\"one\", \"first\");\n        ordinalMap.put(\"two\", \"second\");\n        ordinalMap.put(\"three\", \"third\");\n        ordinalMap.put(\"five\", \"fifth\");\n        ordinalMap.put(\"eight\", \"eighth\");\n        ordinalMap.put(\"nine\", \"ninth\");\n        ordinalMap.put(\"twelve\", \"twelfth\");\n    }\n    \n    private static String toOrdinal(long n) {\n        String spelling = numToString(n);\n        String[] split = spelling.split(\" \");\n        String last = split[split.length - 1];\n        String replace = \"\";\n        if ( last.contains(\"-\") ) {\n            String[] lastSplit = last.split(\"-\");\n            String lastWithDash = lastSplit[1];\n            String lastReplace = \"\";\n            if ( ordinalMap.containsKey(lastWithDash) ) {\n                lastReplace = ordinalMap.get(lastWithDash);\n            }\n            else if ( lastWithDash.endsWith(\"y\") ) {\n                lastReplace = lastWithDash.substring(0, lastWithDash.length() - 1) + \"ieth\";\n            }\n            else {\n                lastReplace = lastWithDash + \"th\";\n            }\n            replace = lastSplit[0] + \"-\" + lastReplace;\n        }\n        else {\n            if ( ordinalMap.containsKey(last) ) {\n                replace = ordinalMap.get(last);\n            }\n            else if ( last.endsWith(\"y\") ) {\n                replace = last.substring(0, last.length() - 1) + \"ieth\";\n            }\n            else {\n                replace = last + \"th\";\n            }\n        }\n        split[split.length - 1] = replace;\n        return String.join(\" \", split);\n    }\n\n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String numToString(long n) {\n        return numToStringHelper(n);\n    }\n    \n    private static final String numToStringHelper(long n) {\n        if ( n < 0 ) {\n            return \"negative \" + numToStringHelper(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \"-\" + numToStringHelper(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToStringHelper(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToStringHelper(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 404598, "name": "Parse an IP Address", "source": "Translate Haskell to Java: import Data.List (isInfixOf)\nimport Numeric (showHex)\nimport Data.Char (isDigit)\n\ndata IPChunk = IPv6Chunk String | IPv4Chunk (String, String) |\n    IPv6WithPort [IPChunk] String | IPv6NoPort [IPChunk] |\n    IPv4WithPort IPChunk String | IPv4NoPort IPChunk |\n    IPInvalid | IPZeroSection | IPUndefinedWithPort String |\n    IPUndefinedNoPort\n\ninstance Show IPChunk where\n    show (IPv6Chunk a) = a\n    show (IPv4Chunk (a,b)) = a ++ b\n    show (IPv6WithPort a p) = \"IPv6 \" ++ concatMap show a ++ \" port \" ++ p\n    show (IPv6NoPort a) = \"IPv6 \" ++ concatMap show a ++ \" no port\"\n    show (IPv4WithPort a p) = \"IPv4 \" ++ show a ++ \" port \" ++ p\n    show (IPv4NoPort a) = \"IPv4 \" ++ show a\n    show IPInvalid = \"Invalid IP address\"\n    \nisIPInvalid IPInvalid = True\nisIPInvalid _ = False\n\nisIPZeroSection IPZeroSection = True\nisIPZeroSection _ = False\n\nsplitOn _ [] = []\nsplitOn x xs = let (a, b) = break (== x) xs in a : splitOn x (drop 1 b)\n\ncount x = length . filter (== x)\n\nbetween a b x = x >= a && x <= b\n\nnone f = all (not . f)\n\nparse1 [] = IPInvalid\nparse1 \"::\" = IPUndefinedNoPort\nparse1 ('[':':':':':']':':':ps) = if portIsValid ps then IPUndefinedWithPort ps else IPInvalid\nparse1 ('[':xs) = if \"]:\" `isInfixOf` xs\n    then let (a, b) = break (== ']') xs in\n            if tail b == \":\" then IPInvalid else IPv6WithPort (map chunk (splitOn ':' a)) (drop 2 b)\n    else IPInvalid\nparse1 xs\n    | count ':' xs <= 1 && count '.' xs == 3 =\n        let (a, b) = break (== ':') xs in case b of\n                \"\" -> IPv4NoPort (chunk a)\n                (':':ps) -> IPv4WithPort (chunk a) ps\n                _ -> IPInvalid\n    | count ':' xs > 1 && count '.' xs <= 3 =\n        IPv6NoPort (map chunk (splitOn ':' xs))\n            \nchunk [] = IPZeroSection\nchunk xs\n    | '.' `elem` xs = case splitOn '.' xs of\n        [a,b,c,d] -> let [e,f,g,h] = map read [a,b,c,d]\n                     in if all (between 0 255) [e,f,g,h]\n                            then let [i,j,k,l] = map (\\n -> fill 2 $ showHex n \"\") [e,f,g,h]\n                                 in IPv4Chunk (i ++ j, k ++ l)\n                            else IPInvalid\n    | ':' `notElem` xs && between 1 4 (length xs) && all (`elem` \"0123456789abcdef\") xs = IPv6Chunk (fill 4 xs)\n    | otherwise = IPInvalid \n\nfill n xs = replicate (n - length xs) '0' ++ xs\n\nparse2 IPInvalid = IPInvalid\nparse2 (IPUndefinedWithPort p) = IPv6WithPort (replicate 8 zeroChunk) p\nparse2 IPUndefinedNoPort = IPv6NoPort (replicate 8 zeroChunk)\nparse2 a = case a of\n    IPv6WithPort xs p -> if none isIPInvalid xs && portIsValid p\n        then let ys = complete xs\n             in  if countChunks ys == 8\n                     then IPv6WithPort ys p\n                     else IPInvalid\n        else IPInvalid\n    IPv6NoPort xs -> if none isIPInvalid xs\n        then let ys = complete xs\n             in  if countChunks ys == 8\n                     then IPv6NoPort ys\n                     else IPInvalid\n        else IPInvalid\n    IPv4WithPort (IPv4Chunk a) p -> if portIsValid p\n        then IPv4WithPort (IPv4Chunk a) p\n        else IPInvalid\n    IPv4NoPort (IPv4Chunk a) -> IPv4NoPort (IPv4Chunk a)\n    _ -> IPInvalid\n\nzeroChunk = IPv6Chunk \"0000\"\n\nportIsValid a = all isDigit a && between 0 65535 (read a)\n\ncomplete xs = case break isIPZeroSection xs of\n    (_, [IPZeroSection]) -> []\n    (ys, []) -> ys\n    ([], (IPZeroSection:IPZeroSection:ys)) -> if any isIPZeroSection ys || countChunks ys > 7\n        then []\n        else replicate (8 - countChunks ys) zeroChunk ++ ys\n    (ys, (IPZeroSection:zs)) -> if any isIPZeroSection zs || countChunks ys + countChunks zs > 7\n        then []\n        else ys ++ replicate (8 - countChunks ys - countChunks zs) zeroChunk ++ zs\n    _ -> []\n\ncountChunks xs = foldl f 0 xs\n    where f n (IPv4Chunk _) = n + 2\n          f n (IPv6Chunk _) = n + 1\n    \nip = parse2 . parse1\n\nmain = mapM_ (putStrLn . show . ip)\n    [\"127.0.0.1\",                                  \n     \"127.0.0.1:80\",                               \n     \"::1\",                                        \n     \"[::1]:80\",                                   \n     \"2605:2700:0:3::4713:93e3\",                   \n     \"[2605:2700:0:3::4713:93e3]:80\"]              \n", "target": "import java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ParseIPAddress {\n\n    public static void main(String[] args) {\n        String [] tests = new String[] {\"192.168.0.1\", \"127.0.0.1\", \"256.0.0.1\", \"127.0.0.1:80\", \"::1\", \"[::1]:80\", \"[32e::12f]:80\", \"2605:2700:0:3::4713:93e3\", \"[2605:2700:0:3::4713:93e3]:80\", \"2001:db8:85a3:0:0:8a2e:370:7334\"};\n        System.out.printf(\"%-40s\u00a0%-32s   %s%n\", \"Test Case\", \"Hex Address\", \"Port\");\n        for ( String ip : tests ) {\n            try {\n                String [] parsed = parseIP(ip);\n                System.out.printf(\"%-40s\u00a0%-32s   %s%n\", ip, parsed[0], parsed[1]);\n            }\n            catch (IllegalArgumentException e) {\n                System.out.printf(\"%-40s Invalid address:  %s%n\", ip, e.getMessage());\n            }\n        }\n    }\n    \n    private static final Pattern IPV4_PAT = Pattern.compile(\"^(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)(?::(\\\\d+)){0,1}$\");\n    private static final Pattern IPV6_DOUBL_COL_PAT = Pattern.compile(\"^\\\\[{0,1}([0-9a-f:]*)::([0-9a-f:]*)(?:\\\\]:(\\\\d+)){0,1}$\");\n    private static String ipv6Pattern;\n    static {\n        ipv6Pattern = \"^\\\\[{0,1}\";\n        for ( int i = 1 ; i <= 7 ; i ++ ) {\n            ipv6Pattern += \"([0-9a-f]+):\";\n        }\n        ipv6Pattern += \"([0-9a-f]+)(?:\\\\]:(\\\\d+)){0,1}$\";\n    }\n    private static final Pattern IPV6_PAT = Pattern.compile(ipv6Pattern);\n    \n    private static String[] parseIP(String ip) {\n        String hex = \"\";\n        String port = \"\";\n        \n        \n        Matcher ipv4Matcher = IPV4_PAT.matcher(ip);\n        if ( ipv4Matcher.matches() ) {\n            for ( int i = 1 ; i <= 4 ; i++ ) {\n                hex += toHex4(ipv4Matcher.group(i));\n            }\n            if ( ipv4Matcher.group(5) != null ) {\n                port = ipv4Matcher.group(5);\n            }\n            return new String[] {hex, port};\n        }\n        \n        \n        Matcher ipv6DoubleColonMatcher = IPV6_DOUBL_COL_PAT.matcher(ip);\n        if ( ipv6DoubleColonMatcher.matches() ) {\n            String p1 = ipv6DoubleColonMatcher.group(1);\n            if ( p1.isEmpty() ) {\n                p1 = \"0\";\n            }\n            String p2 = ipv6DoubleColonMatcher.group(2);\n            if ( p2.isEmpty() ) {\n                p2 = \"0\";\n            }\n            ip =  p1 + getZero(8 - numCount(p1) - numCount(p2)) + p2;\n            if ( ipv6DoubleColonMatcher.group(3) != null ) {\n                ip = \"[\" + ip + \"]:\" + ipv6DoubleColonMatcher.group(3);\n            }\n        }\n        \n        \n        Matcher ipv6Matcher = IPV6_PAT.matcher(ip);\n        if ( ipv6Matcher.matches() ) {\n            for ( int i = 1 ; i <= 8 ; i++ ) {\n                hex += String.format(\"%4s\", toHex6(ipv6Matcher.group(i))).replace(\" \", \"0\");\n            }\n            if ( ipv6Matcher.group(9) != null ) {\n                port = ipv6Matcher.group(9);\n            }\n            return new String[] {hex, port};\n        }\n        \n        throw new IllegalArgumentException(\"ERROR 103: Unknown address: \" + ip);\n    }\n    \n    private static int numCount(String s) {\n        return s.split(\":\").length;\n    }\n    \n    private static String getZero(int count) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(\":\");\n        while ( count > 0 ) {\n            sb.append(\"0:\");\n            count--;\n        }\n        return sb.toString();\n    }\n\n    private static String toHex4(String s) {\n        int val = Integer.parseInt(s);\n        if ( val < 0 || val > 255 ) {\n            throw new IllegalArgumentException(\"ERROR 101:  Invalid value\u00a0: \" + s);\n        }\n        return String.format(\"%2s\", Integer.toHexString(val)).replace(\" \", \"0\");\n    }\n\n    private static String toHex6(String s) {\n        int val = Integer.parseInt(s, 16);\n        if ( val < 0 || val > 65536 ) {\n            throw new IllegalArgumentException(\"ERROR 102:  Invalid hex value\u00a0: \" + s);\n        }\n        return s;\n    }\n\n}\n"}
{"id": 404599, "name": "Line circle intersection", "source": "Translate Haskell to Java: import Data.Tuple.Curry\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  concatMap\n    ((\"\" :) . uncurryN task)\n    [ ((-10, 11), (10, -9), ((3, -5), 3))\n    , ((-10, 11), (-11, 12), ((3, -5), 3))\n    , ((3, -2), (7, -2), ((3, -5), 3))\n    , ((3, -2), (7, -2), ((0, 0), 4))\n    , ((0, -3), (0, 6), ((0, 0), 4))\n    , ((6, 3), (10, 7), ((4, 2), 5))\n    , ((7, 4), (11, 18), ((4, 2), 5))\n    ]\n\ntask :: (Double, Double)\n     -> (Double, Double)\n     -> ((Double, Double), Double)\n     -> [String]\ntask pt1 pt2 circle@(pt3@(a3, b3), r) = [line, segment]\n  where\n    xs = map fun $ lineCircleIntersection pt1 pt2 circle\n    ys = map fun $ segmentCircleIntersection pt1 pt2 circle\n    to x = (fromIntegral . round $ 100 * x) / 100\n    fun (x, y) = (to x, to y)\n    yo = show . fun\n    start = \"Intersection: Circle \" ++ yo pt3 ++ \" \" ++ show (to r) ++ \" and \"\n    end = yo pt1 ++ \" \" ++ yo pt2 ++ \": \"\n    line = start ++ \"Line \" ++ end ++ show xs\n    segment = start ++ \"Segment \" ++ end ++ show ys\n\nsegmentCircleIntersection\n  :: (Double, Double)\n  -> (Double, Double)\n  -> ((Double, Double), Double)\n  -> [(Double, Double)]\nsegmentCircleIntersection pt1 pt2 circle =\n  filter (go p1 p2) $ lineCircleIntersection pt1 pt2 circle\n  where\n    [p1, p2]\n      | pt1 < pt2 = [pt1, pt2]\n      | otherwise = [pt2, pt1]\n    go (x, y) (u, v) (i, j)\n      | x == u = y <= j && j <= v\n      | otherwise = x <= i && i <= u\n\nlineCircleIntersection\n  :: (Double, Double)\n  -> (Double, Double)\n  -> ((Double, Double), Double)\n  -> [(Double, Double)]\nlineCircleIntersection (a1, b1) (a2, b2) ((a3, b3), r) = go delta\n  where\n    (x1, x2) = (a1 - a3, a2 - a3)\n    (y1, y2) = (b1 - b3, b2 - b3)\n    (dx, dy) = (x2 - x1, y2 - y1)\n    drdr = dx * dx + dy * dy\n    d = x1 * y2 - x2 * y1\n    delta = r * r * drdr - d * d\n    sqrtDelta = sqrt delta\n    (sgnDy, absDy) = (sgn dy, abs dy)\n    u1 = (d * dy + sgnDy * dx * sqrtDelta) / drdr\n    u2 = (d * dy - sgnDy * dx * sqrtDelta) / drdr\n    v1 = (-d * dx + absDy * sqrtDelta) / drdr\n    v2 = (-d * dx - absDy * sqrtDelta) / drdr\n    go x\n      | 0 > x = []\n      | 0 == x = [(u1 + a3, v1 + b3)]\n      | otherwise = [(u1 + a3, v1 + b3), (u2 + a3, v2 + b3)]\n\nsgn :: Double -> Double\nsgn x\n  | 0 > x = -1\n  | otherwise = 1\n", "target": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class LineCircleIntersection {\n    public static void main(String[] args) {\n        try {\n            demo();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void demo() throws NoninvertibleTransformException {\n        Point2D center = makePoint(3, -5);\n        double radius = 3.0;\n        System.out.println(\"The intersection points (if any) between:\");\n        System.out.println(\"\\n  A circle, center (3, -5) with radius 3, and:\");\n        System.out.println(\"\\n    a line containing the points (-10, 11) and (10, -9) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(10, -9),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (-10, 11) and ending at (-11, 12) is/are\");\n        System.out.println(\"     \" + toString(intersection(makePoint(-10, 11), makePoint(-11, 12),\n                            center, radius, true)));\n        System.out.println(\"\\n    a horizontal line containing the points (3, -2) and (7, -2) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(3, -2), makePoint(7, -2), center, radius, false)));\n        center.setLocation(0, 0);\n        radius = 4.0;\n        System.out.println(\"\\n  A circle, center (0, 0) with radius 4, and:\");\n        System.out.println(\"\\n    a vertical line containing the points (0, -3) and (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, false)));\n        System.out.println(\"\\n    a vertical segment starting at (0, -3) and ending at (0, 6) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(0, -3), makePoint(0, 6),\n                            center, radius, true)));\n        center.setLocation(4, 2);\n        radius = 5.0;\n        System.out.println(\"\\n  A circle, center (4, 2) with radius 5, and:\");\n        System.out.println(\"\\n    a line containing the points (6, 3) and (10, 7) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(6, 3), makePoint(10, 7),\n                            center, radius, false)));\n        System.out.println(\"\\n    a segment starting at (7, 4) and ending at (11, 8) is/are:\");\n        System.out.println(\"     \" + toString(intersection(makePoint(7, 4), makePoint(11, 8),\n                            center, radius, true)));\n    }\n\n    private static Point2D makePoint(double x, double y) {\n        return new Point2D.Double(x, y);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static List<Point2D> intersection(Point2D p1, Point2D p2, Point2D center,\n            double radius, boolean isSegment) throws NoninvertibleTransformException {\n        List<Point2D> result = new ArrayList<>();\n        double dx = p2.getX() - p1.getX();\n        double dy = p2.getY() - p1.getY();\n        AffineTransform trans = AffineTransform.getRotateInstance(dx, dy);\n        trans.invert();\n        trans.translate(-center.getX(), -center.getY());\n        Point2D p1a = trans.transform(p1, null);\n        Point2D p2a = trans.transform(p2, null);\n        double y = p1a.getY();\n        double minX = Math.min(p1a.getX(), p2a.getX());\n        double maxX = Math.max(p1a.getX(), p2a.getX());\n        if (y == radius || y == -radius) {\n            if (!isSegment || (0 <= maxX && 0 >= minX)) {\n                p1a.setLocation(0, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n        } else if (y < radius && y > -radius) {\n            double x = Math.sqrt(radius * radius - y * y);\n            if (!isSegment || (-x <= maxX && -x >= minX)) {\n                p1a.setLocation(-x, y);\n                trans.inverseTransform(p1a, p1a);\n                result.add(p1a);\n            }\n            if (!isSegment || (x <= maxX && x >= minX)) {\n                p2a.setLocation(x, y);\n                trans.inverseTransform(p2a, p2a);\n                result.add(p2a);\n            }\n        }\n        return result;\n    }\n\n    public static String toString(Point2D point) {\n        return String.format(\"(%g, %g)\", point.getX(), point.getY());\n    }\n\n    public static String toString(List<Point2D> points) {\n        StringBuilder str = new StringBuilder(\"[\");\n        for (int i = 0, n = points.size(); i < n; ++i) {\n            if (i > 0)\n                str.append(\", \");\n            str.append(toString(points.get(i)));\n        }\n        str.append(\"]\");\n        return str.toString();\n    }\n}\n"}
{"id": 404600, "name": "Getting the number of decimal places", "source": "Translate Haskell to Java: decimal :: String -> Int\ndecimal [] = 0\ndecimal ('.':xs) = length xs\ndecimal (_:xs) = decimal xs\n\nnumDecimal :: Double -> Int\nnumDecimal = decimal . show\n\nmain = print . map numDecimal $ [12.0, 12.345, 12.3450, 12.345555555555, 12.34555555555555555555, 1.2345e+54]\n", "target": "public static int findNumOfDec(double x){\n    String str = String.valueOf(x);\n    if(str.endsWith(\".0\")) return 0;\n    else return (str.substring(str.indexOf('.')).length() - 1);\n}\n"}
{"id": 404601, "name": "Chemical calculator", "source": "Translate Haskell to Java: import Control.Monad (forM_)\nimport Control.Monad.Reader (Reader, ask, runReader)\nimport Data.Bifunctor (first)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Void (Void)\nimport System.Environment (getArgs)\nimport System.IO (IOMode(ReadMode), withFile)\nimport System.IO.Strict (hGetContents)\nimport Text.Megaparsec (ParsecT, (<|>), between, errorBundlePretty, getOffset,\n                        many, option, runParserT, some, setOffset)\nimport Text.Megaparsec.Char (char, lowerChar, upperChar)\nimport Text.Megaparsec.Char.Lexer (decimal)\nimport Text.Printf (printf)\n\ntype Masses     = Map String Double\ntype ChemParser = ParsecT Void String (Reader Masses) Double\n\n\nmolecule :: ChemParser\nmolecule = sum <$> some (atomGroup <|> atom)\n\n\n\natomGroup :: ChemParser\natomGroup = mul <$> between (char '(') (char ')') molecule <*> option 1 decimal\n\n\natom :: ChemParser\natom = mul <$> atomMass <*> option 1 decimal\n\n\natomMass :: ChemParser\natomMass = do\n  off <- getOffset\n  masses <- ask\n  atomName <- (:) <$> upperChar <*> many lowerChar\n  case M.lookup atomName masses of\n    Nothing -> setOffset off >> fail \"invalid atom name starting here\"\n    Just mass -> return mass\n\n\n\nmolarMass :: String -> String -> Masses -> Either String Double\nmolarMass file formula = first errorBundlePretty . runChemParser\n  where runChemParser = runReader (runParserT molecule file formula)\n\n\ngetMasses :: FilePath -> IO Masses\ngetMasses path = withFile path ReadMode (fmap read . hGetContents)\n\nmul :: Double -> Int -> Double\nmul s n = s * fromIntegral n\n\nmain :: IO ()\nmain = do\n  masses <- getMasses \"chemcalc_masses.in\"\n  molecs <- getArgs\n  forM_ molecs $ \\molec -> do\n    printf \"%-20s\" molec\n    case molarMass \"<stdin>\" molec masses of\n      Left err   -> printf \"\\n%s\" err\n      Right mass -> printf \"\u00a0%.4f\\n\" mass\n", "target": "import java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\n\npublic class ChemicalCalculator {\n    private static final Map<String, Double> atomicMass = new HashMap<>();\n\n    static {\n        atomicMass.put(\"H\", 1.008);\n        atomicMass.put(\"He\", 4.002602);\n        atomicMass.put(\"Li\", 6.94);\n        atomicMass.put(\"Be\", 9.0121831);\n        atomicMass.put(\"B\", 10.81);\n        atomicMass.put(\"C\", 12.011);\n        atomicMass.put(\"N\", 14.007);\n        atomicMass.put(\"O\", 15.999);\n        atomicMass.put(\"F\", 18.998403163);\n        atomicMass.put(\"Ne\", 20.1797);\n        atomicMass.put(\"Na\", 22.98976928);\n        atomicMass.put(\"Mg\", 24.305);\n        atomicMass.put(\"Al\", 26.9815385);\n        atomicMass.put(\"Si\", 28.085);\n        atomicMass.put(\"P\", 30.973761998);\n        atomicMass.put(\"S\", 32.06);\n        atomicMass.put(\"Cl\", 35.45);\n        atomicMass.put(\"Ar\", 39.948);\n        atomicMass.put(\"K\", 39.0983);\n        atomicMass.put(\"Ca\", 40.078);\n        atomicMass.put(\"Sc\", 44.955908);\n        atomicMass.put(\"Ti\", 47.867);\n        atomicMass.put(\"V\", 50.9415);\n        atomicMass.put(\"Cr\", 51.9961);\n        atomicMass.put(\"Mn\", 54.938044);\n        atomicMass.put(\"Fe\", 55.845);\n        atomicMass.put(\"Co\", 58.933194);\n        atomicMass.put(\"Ni\", 58.6934);\n        atomicMass.put(\"Cu\", 63.546);\n        atomicMass.put(\"Zn\", 65.38);\n        atomicMass.put(\"Ga\", 69.723);\n        atomicMass.put(\"Ge\", 72.630);\n        atomicMass.put(\"As\", 74.921595);\n        atomicMass.put(\"Se\", 78.971);\n        atomicMass.put(\"Br\", 79.904);\n        atomicMass.put(\"Kr\", 83.798);\n        atomicMass.put(\"Rb\", 85.4678);\n        atomicMass.put(\"Sr\", 87.62);\n        atomicMass.put(\"Y\", 88.90584);\n        atomicMass.put(\"Zr\", 91.224);\n        atomicMass.put(\"Nb\", 92.90637);\n        atomicMass.put(\"Mo\", 95.95);\n        atomicMass.put(\"Ru\", 101.07);\n        atomicMass.put(\"Rh\", 102.90550);\n        atomicMass.put(\"Pd\", 106.42);\n        atomicMass.put(\"Ag\", 107.8682);\n        atomicMass.put(\"Cd\", 112.414);\n        atomicMass.put(\"In\", 114.818);\n        atomicMass.put(\"Sn\", 118.710);\n        atomicMass.put(\"Sb\", 121.760);\n        atomicMass.put(\"Te\", 127.60);\n        atomicMass.put(\"I\", 126.90447);\n        atomicMass.put(\"Xe\", 131.293);\n        atomicMass.put(\"Cs\", 132.90545196);\n        atomicMass.put(\"Ba\", 137.327);\n        atomicMass.put(\"La\", 138.90547);\n        atomicMass.put(\"Ce\", 140.116);\n        atomicMass.put(\"Pr\", 140.90766);\n        atomicMass.put(\"Nd\", 144.242);\n        atomicMass.put(\"Pm\", 145.0);\n        atomicMass.put(\"Sm\", 150.36);\n        atomicMass.put(\"Eu\", 151.964);\n        atomicMass.put(\"Gd\", 157.25);\n        atomicMass.put(\"Tb\", 158.92535);\n        atomicMass.put(\"Dy\", 162.500);\n        atomicMass.put(\"Ho\", 164.93033);\n        atomicMass.put(\"Er\", 167.259);\n        atomicMass.put(\"Tm\", 168.93422);\n        atomicMass.put(\"Yb\", 173.054);\n        atomicMass.put(\"Lu\", 174.9668);\n        atomicMass.put(\"Hf\", 178.49);\n        atomicMass.put(\"Ta\", 180.94788);\n        atomicMass.put(\"W\", 183.84);\n        atomicMass.put(\"Re\", 186.207);\n        atomicMass.put(\"Os\", 190.23);\n        atomicMass.put(\"Ir\", 192.217);\n        atomicMass.put(\"Pt\", 195.084);\n        atomicMass.put(\"Au\", 196.966569);\n        atomicMass.put(\"Hg\", 200.592);\n        atomicMass.put(\"Tl\", 204.38);\n        atomicMass.put(\"Pb\", 207.2);\n        atomicMass.put(\"Bi\", 208.98040);\n        atomicMass.put(\"Po\", 209.0);\n        atomicMass.put(\"At\", 210.0);\n        atomicMass.put(\"Rn\", 222.0);\n        atomicMass.put(\"Fr\", 223.0);\n        atomicMass.put(\"Ra\", 226.0);\n        atomicMass.put(\"Ac\", 227.0);\n        atomicMass.put(\"Th\", 232.0377);\n        atomicMass.put(\"Pa\", 231.03588);\n        atomicMass.put(\"U\", 238.02891);\n        atomicMass.put(\"Np\", 237.0);\n        atomicMass.put(\"Pu\", 244.0);\n        atomicMass.put(\"Am\", 243.0);\n        atomicMass.put(\"Cm\", 247.0);\n        atomicMass.put(\"Bk\", 247.0);\n        atomicMass.put(\"Cf\", 251.0);\n        atomicMass.put(\"Es\", 252.0);\n        atomicMass.put(\"Fm\", 257.0);\n        atomicMass.put(\"Uue\", 315.0);\n        atomicMass.put(\"Ubn\", 299.0);\n    }\n\n    private static double evaluate(String s) {\n        String sym = s + \"[\";\n        double sum = 0.0;\n        StringBuilder symbol = new StringBuilder();\n        String number = \"\";\n        for (int i = 0; i < sym.length(); ++i) {\n            char c = sym.charAt(i);\n            if ('@' <= c && c <= '[') {\n                \n                int n = 1;\n                if (!number.isEmpty()) {\n                    n = Integer.parseInt(number);\n                }\n                if (symbol.length() > 0) {\n                    sum += atomicMass.getOrDefault(symbol.toString(), 0.0) * n;\n                }\n                if (c == '[') {\n                    break;\n                }\n                symbol = new StringBuilder(String.valueOf(c));\n                number = \"\";\n            } else if ('a' <= c && c <= 'z') {\n                symbol.append(c);\n            } else if ('0' <= c && c <= '9') {\n                number += c;\n            } else {\n                throw new RuntimeException(\"Unexpected symbol \" + c + \" in molecule\");\n            }\n        }\n        return sum;\n    }\n\n    private static String replaceParens(String s) {\n        char letter = 'a';\n        String si = s;\n        while (true) {\n            int start = si.indexOf('(');\n            if (start == -1) {\n                break;\n            }\n\n            for (int i = start + 1; i < si.length(); ++i) {\n                if (si.charAt(i) == ')') {\n                    String expr = si.substring(start + 1, i);\n                    String symbol = \"@\" + letter;\n                    String pattern = Pattern.quote(si.substring(start, i + 1));\n                    si = si.replaceFirst(pattern, symbol);\n                    atomicMass.put(symbol, evaluate(expr));\n                    letter++;\n                    break;\n                }\n                if (si.charAt(i) == '(') {\n                    start = i;\n                }\n            }\n        }\n        return si;\n    }\n\n    public static void main(String[] args) {\n        List<String> molecules = List.of(\n            \"H\", \"H2\", \"H2O\", \"H2O2\", \"(HO)2\", \"Na2SO4\", \"C6H12\",\n            \"COOH(C(CH3)2)3CH3\", \"C6H4O2(OH)4\", \"C27H46O\", \"Uue\"\n        );\n        for (String molecule : molecules) {\n            double mass = evaluate(replaceParens(molecule));\n            System.out.printf(\"%17s -> %7.3f\\n\", molecule, mass);\n        }\n    }\n}\n"}
{"id": 404602, "name": "Arithmetic evaluation", "source": "Translate Haskell to Java: \n\nimport Text.Parsec\nimport Text.Parsec.Expr\nimport Text.Parsec.Combinator\nimport Data.Functor\nimport Data.Function (on)\n\ndata Exp\n  = Num Int\n  | Add Exp\n        Exp\n  | Sub Exp\n        Exp\n  | Mul Exp\n        Exp\n  | Div Exp\n        Exp\n\nexpr\n  :: Stream s m Char\n  => ParsecT s u m Exp\nexpr = buildExpressionParser table factor\n  where\n    table =\n      [ [op \"*\" Mul AssocLeft, op \"/\" Div AssocLeft]\n      , [op \"+\" Add AssocLeft, op \"-\" Sub AssocLeft]\n      ]\n    op s f = Infix (f <$ string s)\n    factor = (between `on` char) '(' ')' expr <|> (Num . read <$> many1 digit)\n\neval\n  :: Integral a\n  => Exp -> a\neval (Num x) = fromIntegral x\neval (Add a b) = eval a + eval b\neval (Sub a b) = eval a - eval b\neval (Mul a b) = eval a * eval b\neval (Div a b) = eval a `div` eval b\n\nsolution\n  :: Integral a\n  => String -> a\nsolution = either (const (error \"Did not parse\")) eval . parse expr \"\"\n\nmain :: IO ()\nmain = print $ solution \"(1+3)*7\"\n", "target": "import java.util.Stack;\n\npublic class ArithmeticEvaluation {\n\n    public interface Expression {\n        BigRational eval();\n    }\n\n    public enum Parentheses {LEFT}\n\n    public enum BinaryOperator {\n        ADD('+', 1),\n        SUB('-', 1),\n        MUL('*', 2),\n        DIV('/', 2);\n\n        public final char symbol;\n        public final int precedence;\n\n        BinaryOperator(char symbol, int precedence) {\n            this.symbol = symbol;\n            this.precedence = precedence;\n        }\n\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\n            switch (this) {\n                case ADD:\n                    return leftValue.add(rightValue);\n                case SUB:\n                    return leftValue.subtract(rightValue);\n                case MUL:\n                    return leftValue.multiply(rightValue);\n                case DIV:\n                    return leftValue.divide(rightValue);\n            }\n            throw new IllegalStateException();\n        }\n\n        public static BinaryOperator forSymbol(char symbol) {\n            for (BinaryOperator operator : values()) {\n                if (operator.symbol == symbol) {\n                    return operator;\n                }\n            }\n            throw new IllegalArgumentException(String.valueOf(symbol));\n        }\n    }\n\n    public static class Number implements Expression {\n        private final BigRational number;\n\n        public Number(BigRational number) {\n            this.number = number;\n        }\n\n        @Override\n        public BigRational eval() {\n            return number;\n        }\n\n        @Override\n        public String toString() {\n            return number.toString();\n        }\n    }\n\n    public static class BinaryExpression implements Expression {\n        public final Expression leftOperand;\n        public final BinaryOperator operator;\n        public final Expression rightOperand;\n\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\n            this.leftOperand = leftOperand;\n            this.operator = operator;\n            this.rightOperand = rightOperand;\n        }\n\n        @Override\n        public BigRational eval() {\n            BigRational leftValue = leftOperand.eval();\n            BigRational rightValue = rightOperand.eval();\n            return operator.eval(leftValue, rightValue);\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";\n        }\n    }\n\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\n        Expression rightOperand = operands.pop();\n        Expression leftOperand = operands.pop();\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\n    }\n\n    public static Expression parse(String input) {\n        int curIndex = 0;\n        boolean afterOperand = false;\n        Stack<Expression> operands = new Stack<>();\n        Stack<Object> operators = new Stack<>();\n        while (curIndex < input.length()) {\n            int startIndex = curIndex;\n            char c = input.charAt(curIndex++);\n\n            if (Character.isWhitespace(c))\n                continue;\n\n            if (afterOperand) {\n                if (c == ')') {\n                    Object operator;\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n                        createNewOperand((BinaryOperator) operator, operands);\n                    continue;\n                }\n                afterOperand = false;\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\n                operators.push(operator);\n                continue;\n            }\n\n            if (c == '(') {\n                operators.push(Parentheses.LEFT);\n                continue;\n            }\n\n            afterOperand = true;\n            while (curIndex < input.length()) {\n                c = input.charAt(curIndex);\n                if (((c < '0') || (c > '9')) && (c != '.'))\n                    break;\n                curIndex++;\n            }\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\n        }\n\n        while (!operators.isEmpty()) {\n            Object operator = operators.pop();\n            if (operator == Parentheses.LEFT)\n                throw new IllegalArgumentException();\n            createNewOperand((BinaryOperator) operator, operands);\n        }\n\n        Expression expression = operands.pop();\n        if (!operands.isEmpty())\n            throw new IllegalArgumentException();\n        return expression;\n    }\n\n    public static void main(String[] args) {\n        String[] testExpressions = {\n                \"2+3\",\n                \"2+3/4\",\n                \"2*3-4\",\n                \"2*(3+4)+5/6\",\n                \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n                \"2*-3--4+-.25\"};\n        for (String testExpression : testExpressions) {\n            Expression expression = parse(testExpression);\n            System.out.printf(\"Input: \\\"%s\\\", AST: \\\"%s\\\", value=%s%n\", testExpression, expression, expression.eval());\n        }\n    }\n}\n"}
{"id": 404603, "name": "Arithmetic evaluation", "source": "Translate Haskell to Java: \n\nimport Text.Parsec\nimport Text.Parsec.Expr\nimport Text.Parsec.Combinator\nimport Data.Functor\nimport Data.Function (on)\n\ndata Exp\n  = Num Int\n  | Add Exp\n        Exp\n  | Sub Exp\n        Exp\n  | Mul Exp\n        Exp\n  | Div Exp\n        Exp\n\nexpr\n  :: Stream s m Char\n  => ParsecT s u m Exp\nexpr = buildExpressionParser table factor\n  where\n    table =\n      [ [op \"*\" Mul AssocLeft, op \"/\" Div AssocLeft]\n      , [op \"+\" Add AssocLeft, op \"-\" Sub AssocLeft]\n      ]\n    op s f = Infix (f <$ string s)\n    factor = (between `on` char) '(' ')' expr <|> (Num . read <$> many1 digit)\n\neval\n  :: Integral a\n  => Exp -> a\neval (Num x) = fromIntegral x\neval (Add a b) = eval a + eval b\neval (Sub a b) = eval a - eval b\neval (Mul a b) = eval a * eval b\neval (Div a b) = eval a `div` eval b\n\nsolution\n  :: Integral a\n  => String -> a\nsolution = either (const (error \"Did not parse\")) eval . parse expr \"\"\n\nmain :: IO ()\nmain = print $ solution \"(1+3)*7\"\n", "target": "import java.util.Stack;\n\npublic class ArithmeticEvaluation {\n\n    public interface Expression {\n        BigRational eval();\n    }\n\n    public enum Parentheses {LEFT}\n\n    public enum BinaryOperator {\n        ADD('+', 1),\n        SUB('-', 1),\n        MUL('*', 2),\n        DIV('/', 2);\n\n        public final char symbol;\n        public final int precedence;\n\n        BinaryOperator(char symbol, int precedence) {\n            this.symbol = symbol;\n            this.precedence = precedence;\n        }\n\n        public BigRational eval(BigRational leftValue, BigRational rightValue) {\n            switch (this) {\n                case ADD:\n                    return leftValue.add(rightValue);\n                case SUB:\n                    return leftValue.subtract(rightValue);\n                case MUL:\n                    return leftValue.multiply(rightValue);\n                case DIV:\n                    return leftValue.divide(rightValue);\n            }\n            throw new IllegalStateException();\n        }\n\n        public static BinaryOperator forSymbol(char symbol) {\n            for (BinaryOperator operator : values()) {\n                if (operator.symbol == symbol) {\n                    return operator;\n                }\n            }\n            throw new IllegalArgumentException(String.valueOf(symbol));\n        }\n    }\n\n    public static class Number implements Expression {\n        private final BigRational number;\n\n        public Number(BigRational number) {\n            this.number = number;\n        }\n\n        @Override\n        public BigRational eval() {\n            return number;\n        }\n\n        @Override\n        public String toString() {\n            return number.toString();\n        }\n    }\n\n    public static class BinaryExpression implements Expression {\n        public final Expression leftOperand;\n        public final BinaryOperator operator;\n        public final Expression rightOperand;\n\n        public BinaryExpression(Expression leftOperand, BinaryOperator operator, Expression rightOperand) {\n            this.leftOperand = leftOperand;\n            this.operator = operator;\n            this.rightOperand = rightOperand;\n        }\n\n        @Override\n        public BigRational eval() {\n            BigRational leftValue = leftOperand.eval();\n            BigRational rightValue = rightOperand.eval();\n            return operator.eval(leftValue, rightValue);\n        }\n\n        @Override\n        public String toString() {\n            return \"(\" + leftOperand + \" \" + operator.symbol + \" \" + rightOperand + \")\";\n        }\n    }\n\n    private static void createNewOperand(BinaryOperator operator, Stack<Expression> operands) {\n        Expression rightOperand = operands.pop();\n        Expression leftOperand = operands.pop();\n        operands.push(new BinaryExpression(leftOperand, operator, rightOperand));\n    }\n\n    public static Expression parse(String input) {\n        int curIndex = 0;\n        boolean afterOperand = false;\n        Stack<Expression> operands = new Stack<>();\n        Stack<Object> operators = new Stack<>();\n        while (curIndex < input.length()) {\n            int startIndex = curIndex;\n            char c = input.charAt(curIndex++);\n\n            if (Character.isWhitespace(c))\n                continue;\n\n            if (afterOperand) {\n                if (c == ')') {\n                    Object operator;\n                    while (!operators.isEmpty() && ((operator = operators.pop()) != Parentheses.LEFT))\n                        createNewOperand((BinaryOperator) operator, operands);\n                    continue;\n                }\n                afterOperand = false;\n                BinaryOperator operator = BinaryOperator.forSymbol(c);\n                while (!operators.isEmpty() && (operators.peek() != Parentheses.LEFT) && (((BinaryOperator) operators.peek()).precedence >= operator.precedence))\n                    createNewOperand((BinaryOperator) operators.pop(), operands);\n                operators.push(operator);\n                continue;\n            }\n\n            if (c == '(') {\n                operators.push(Parentheses.LEFT);\n                continue;\n            }\n\n            afterOperand = true;\n            while (curIndex < input.length()) {\n                c = input.charAt(curIndex);\n                if (((c < '0') || (c > '9')) && (c != '.'))\n                    break;\n                curIndex++;\n            }\n            operands.push(new Number(BigRational.valueOf(input.substring(startIndex, curIndex))));\n        }\n\n        while (!operators.isEmpty()) {\n            Object operator = operators.pop();\n            if (operator == Parentheses.LEFT)\n                throw new IllegalArgumentException();\n            createNewOperand((BinaryOperator) operator, operands);\n        }\n\n        Expression expression = operands.pop();\n        if (!operands.isEmpty())\n            throw new IllegalArgumentException();\n        return expression;\n    }\n\n    public static void main(String[] args) {\n        String[] testExpressions = {\n                \"2+3\",\n                \"2+3/4\",\n                \"2*3-4\",\n                \"2*(3+4)+5/6\",\n                \"2 * (3 + (4 * 5 + (6 * 7) * 8) - 9) * 10\",\n                \"2*-3--4+-.25\"};\n        for (String testExpression : testExpressions) {\n            Expression expression = parse(testExpression);\n            System.out.printf(\"Input: \\\"%s\\\", AST: \\\"%s\\\", value=%s%n\", testExpression, expression, expression.eval());\n        }\n    }\n}\n"}
{"id": 404604, "name": "Farey sequence", "source": "Translate Haskell to Java: import Data.List (unfoldr, mapAccumR)\nimport Data.Ratio ((%), denominator, numerator)\nimport Text.Printf (PrintfArg, printf)\n\n\nfarey :: Integer -> [Rational]\nfarey n = 0 : unfoldr step (0, 1, 1, n)\n  where\n    step (a, b, c, d)\n      | c > n = Nothing\n      | otherwise =\n        let k = (n + b) `quot` d\n        in Just (c %d, (c, d, k * c - a, k * d - b))\n\n\n\n\n\nfareys :: ([Rational] -> a) -> [Integer] -> [(Integer, a)]\nfareys fn ns = snd $ mapAccumR prune (farey $ last ns) ns\n  where\n    prune rs n =\n      let rs'' = filter ((<= n) . denominator) rs\n      in (rs'', (n, fn rs''))\n\nfprint\n  :: (PrintfArg b)\n  => String -> [(Integer, b)] -> IO ()\nfprint fmt = mapM_ (uncurry $ printf fmt)\n\nshowFracs :: [Rational] -> String\nshowFracs =\n  unwords .\n  map (concat . (<*>) [show . numerator, const \"/\", show . denominator] . pure)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Farey Sequences\\n\"\n  fprint \"%2d %s\\n\" $ fareys showFracs [1 .. 11]\n  putStrLn \"\\nSequence Lengths\\n\"\n  fprint \"%4d %d\\n\" $ fareys length [100,200 .. 1000]\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 404605, "name": "Farey sequence", "source": "Translate Haskell to Java: import Data.List (unfoldr, mapAccumR)\nimport Data.Ratio ((%), denominator, numerator)\nimport Text.Printf (PrintfArg, printf)\n\n\nfarey :: Integer -> [Rational]\nfarey n = 0 : unfoldr step (0, 1, 1, n)\n  where\n    step (a, b, c, d)\n      | c > n = Nothing\n      | otherwise =\n        let k = (n + b) `quot` d\n        in Just (c %d, (c, d, k * c - a, k * d - b))\n\n\n\n\n\nfareys :: ([Rational] -> a) -> [Integer] -> [(Integer, a)]\nfareys fn ns = snd $ mapAccumR prune (farey $ last ns) ns\n  where\n    prune rs n =\n      let rs'' = filter ((<= n) . denominator) rs\n      in (rs'', (n, fn rs''))\n\nfprint\n  :: (PrintfArg b)\n  => String -> [(Integer, b)] -> IO ()\nfprint fmt = mapM_ (uncurry $ printf fmt)\n\nshowFracs :: [Rational] -> String\nshowFracs =\n  unwords .\n  map (concat . (<*>) [show . numerator, const \"/\", show . denominator] . pure)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Farey Sequences\\n\"\n  fprint \"%2d %s\\n\" $ fareys showFracs [1 .. 11]\n  putStrLn \"\\nSequence Lengths\\n\"\n  fprint \"%4d %d\\n\" $ fareys length [100,200 .. 1000]\n", "target": "import java.util.TreeSet;\n\npublic class Farey{\n\tprivate static class Frac implements Comparable<Frac>{\n\t\tint num;\n\t\tint den;\n\t\t\n\t\tpublic Frac(int num, int den){\n\t\t\tthis.num = num;\n\t\t\tthis.den = den;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString(){\n\t\t\treturn num + \"/\" + den;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Frac o){\n\t\t\treturn Double.compare((double)num / den, (double)o.num / o.den);\n\t\t}\n\t}\n\t\n\tpublic static TreeSet<Frac> genFarey(int i){\n\t\tTreeSet<Frac> farey = new TreeSet<Frac>();\n\t\tfor(int den = 1; den <= i; den++){\n\t\t\tfor(int num = 0; num <= den; num++){\n\t\t\t\tfarey.add(new Frac(num, den));\n\t\t\t}\n\t\t}\n\t\treturn farey;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 11; i++){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i));\n\t\t}\n\t\t\n\t\tfor(int i = 100; i <= 1000; i += 100){\n\t\t\tSystem.out.println(\"F\" + i + \": \" + genFarey(i).size() + \" members\");\n\t\t}\n\t}\n}\n"}
{"id": 404606, "name": "Aliquot sequence classifications", "source": "Translate Haskell to Java: divisors :: (Integral a) => a -> [a]\ndivisors n = filter ((0 ==) . (n `mod`)) [1 .. (n `div` 2)]\n\ndata Class\n  = Terminating\n  | Perfect\n  | Amicable\n  | Sociable\n  | Aspiring\n  | Cyclic\n  | Nonterminating\n  deriving (Show)\n\naliquot :: (Integral a) => a -> [a]\naliquot 0 = [0]\naliquot n = n : (aliquot $ sum $ divisors n)\n\nclassify :: (Num a, Eq a) => [a] -> Class\nclassify []             = Nonterminating\nclassify [0]            = Terminating\nclassify [_]            = Nonterminating\nclassify [a,b]\n  | a == b              = Perfect\n  | b == 0              = Terminating\n  | otherwise           = Nonterminating\nclassify x@(a:b:c:_)\n  | a == b              = Perfect\n  | a == c              = Amicable\n  | a `elem` (drop 1 x) = Sociable\n  | otherwise           =\n    case classify (drop 1 x) of\n      Perfect  -> Aspiring\n      Amicable -> Cyclic\n      Sociable -> Cyclic\n      d        -> d\n\nmain :: IO ()\nmain = do\n  let cls n = let ali = take 16 $ aliquot n in (classify ali, ali)\n  mapM_ (print . cls) $ [1..10] ++\n    [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 404607, "name": "Aliquot sequence classifications", "source": "Translate Haskell to Java: divisors :: (Integral a) => a -> [a]\ndivisors n = filter ((0 ==) . (n `mod`)) [1 .. (n `div` 2)]\n\ndata Class\n  = Terminating\n  | Perfect\n  | Amicable\n  | Sociable\n  | Aspiring\n  | Cyclic\n  | Nonterminating\n  deriving (Show)\n\naliquot :: (Integral a) => a -> [a]\naliquot 0 = [0]\naliquot n = n : (aliquot $ sum $ divisors n)\n\nclassify :: (Num a, Eq a) => [a] -> Class\nclassify []             = Nonterminating\nclassify [0]            = Terminating\nclassify [_]            = Nonterminating\nclassify [a,b]\n  | a == b              = Perfect\n  | b == 0              = Terminating\n  | otherwise           = Nonterminating\nclassify x@(a:b:c:_)\n  | a == b              = Perfect\n  | a == c              = Amicable\n  | a `elem` (drop 1 x) = Sociable\n  | otherwise           =\n    case classify (drop 1 x) of\n      Perfect  -> Aspiring\n      Amicable -> Cyclic\n      Sociable -> Cyclic\n      d        -> d\n\nmain :: IO ()\nmain = do\n  let cls n = let ali = take 16 $ aliquot n in (classify ali, ali)\n  mapM_ (print . cls) $ [1..10] ++\n    [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 404608, "name": "Magnanimous numbers", "source": "Translate Haskell to Java: import Data.List.Split ( chunksOf )\nimport Data.List ( (!!) )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n   \nisMagnanimous :: Int -> Bool\nisMagnanimous n = all isPrime $ map (\\p -> fst p + snd p ) numberPairs\n where\n  str:: String\n  str = show n\n  splitStrings :: [(String , String)]\n  splitStrings = map (\\i -> splitAt i str) [1 .. length str - 1] \n  numberPairs :: [(Int , Int)]\n  numberPairs = map (\\p -> ( read $ fst p , read $ snd p )) splitStrings\n\nprintInWidth :: Int -> Int -> String\nprintInWidth number width = replicate ( width - l ) ' ' ++ str\n where \n  str :: String\n  str = show number\n  l :: Int\n  l = length str\n\nsolution :: [Int]\nsolution = take 400 $ filter isMagnanimous [0 , 1 ..]\n\nmain :: IO ( ) \nmain = do\n   let numbers = solution\n       numberlines = chunksOf 10 $ take 45 numbers\n   putStrLn \"First 45 magnanimous numbers:\" \n   mapM_ (\\li -> putStrLn (foldl1 ( ++ ) $ map (\\n -> printInWidth n 6 ) \n    li )) numberlines \n   putStrLn \"241'st to 250th magnanimous numbers:\"\n   putStr $ show ( numbers !! 240 )\n   putStrLn ( foldl1 ( ++ ) $ map(\\n -> printInWidth n 8 ) $ take 9 $ \n    drop 241 numbers )   \n   putStrLn \"391'st to 400th magnanimous numbers:\"\n   putStr $ show ( numbers !! 390 )\n   putStrLn ( foldl1 ( ++ ) $ map(\\n -> printInWidth n 8 ) $ drop 391 numbers)\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class MagnanimousNumbers {\n\n    public static void main(String[] args) {\n        runTask(\"Find and display the first 45 magnanimous numbers.\", 1, 45);\n        runTask(\"241st through 250th magnanimous numbers.\", 241, 250);\n        runTask(\"391st through 400th magnanimous numbers.\", 391, 400);\n    }\n    \n    private static void runTask(String message, int startN, int endN) {\n        int count = 0;\n        List<Integer> nums = new ArrayList<>();\n        for ( int n = 0 ; count < endN ; n++ ) {\n            if ( isMagnanimous(n) ) {\n                nums.add(n);\n                count++;\n            }\n        }\n        System.out.printf(\"%s%n\", message);\n        System.out.printf(\"%s%n%n\", nums.subList(startN-1, endN));\n    }\n    \n    private static boolean isMagnanimous(long n) {\n        if ( n >= 0 && n <= 9 ) {\n            return true;\n        }\n        long q = 11;\n        for ( long div = 10 ; q >= 10 ; div *= 10 ) {\n            q = n / div;\n            long r = n % div;\n            if ( ! isPrime(q+r) ) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    private static final int MAX = 100_000;\n    private static final boolean[] primes = new boolean[MAX];\n    private static boolean SIEVE_COMPLETE = false;\n    \n    private static final boolean isPrimeTrivial(long test) {\n        if ( ! SIEVE_COMPLETE ) {\n            sieve();\n            SIEVE_COMPLETE = true;\n        }\n        return primes[(int) test];\n    }\n    \n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n    \n    public static final boolean isPrime(long testValue) {\n        if ( testValue == 2 ) return true;\n        if ( testValue % 2 == 0 ) return false;\n        if ( testValue <= MAX ) return isPrimeTrivial(testValue);\n        long d = testValue-1;\n        int s = 0;\n        while ( d % 2 == 0 ) {\n            s += 1;\n            d /= 2;\n        }\n        if ( testValue < 1373565L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 4759123141L ) {\n            if ( ! aSrp(2, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(7, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(61, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        if ( testValue < 10000000000000000L ) {\n            if ( ! aSrp(3, s, d, testValue) ) {\n                return false;\n            }\n            if ( ! aSrp(24251, s, d, testValue) ) {\n                return false;\n            }\n            return true;\n        }\n        \n        if ( ! aSrp(37, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(47, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(61, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(73, s, d, testValue) ) {\n            return false;\n        }\n        if ( ! aSrp(83, s, d, testValue) ) {\n            return false;\n        }\n        \n        return true;\n    }\n\n    private static final boolean aSrp(int a, int s, long d, long n) {\n        long modPow = modPow(a, d, n);\n        \n        if ( modPow == 1 ) {\n            return true;\n        }\n        int twoExpR = 1;\n        for ( int r = 0 ; r < s ; r++ ) {\n            if ( modPow(modPow, twoExpR, n) == n-1 ) {\n                return true;\n            }\n            twoExpR *= 2;\n        }\n        return false;\n    }\n    \n    private static final long SQRT = (long) Math.sqrt(Long.MAX_VALUE);\n    \n    public static final long modPow(long base, long exponent, long modulus) {\n        long result = 1;\n        while ( exponent > 0 ) {\n            if ( exponent % 2 == 1 ) {\n                if ( result > SQRT || base > SQRT ) {\n                    result = multiply(result, base, modulus);\n                }\n                else {\n                    result = (result * base) % modulus;\n                }\n            }\n            exponent >>= 1;\n            if ( base > SQRT ) {\n                base = multiply(base, base, modulus);\n            }\n            else {\n                base = (base * base) % modulus;\n            }\n        }\n        return result;\n    }\n\n\n    \n    public static final long multiply(long a, long b, long modulus) {\n        long x = 0;\n        long y = a % modulus;\n        long t;\n        while ( b > 0 ) {\n            if ( b % 2 == 1 ) {\n                t = x + y;\n                x = (t > modulus ? t-modulus : t);\n            }\n            t = y << 1;\n            y = (t > modulus ? t-modulus : t);\n            b >>= 1;\n        }\n        return x % modulus;\n    }\n\n}\n"}
{"id": 404609, "name": "Mersenne primes", "source": "Translate Haskell to Java: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\nlucasLehmer :: Int -> Bool\nlucasLehmer p = iterate f 4 !! p-2 == 0\n where\n  f b = (b^2 - 2) `mod` m\n  m = 2^p - 1\n\nmain = mapM_ (printf \"M %d\\n\") $ take 20 mersenne\n where\n  mersenne = filter lucasLehmer primes\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 404610, "name": "Mersenne primes", "source": "Translate Haskell to Java: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\nlucasLehmer :: Int -> Bool\nlucasLehmer p = iterate f 4 !! p-2 == 0\n where\n  f b = (b^2 - 2) `mod` m\n  m = 2^p - 1\n\nmain = mapM_ (printf \"M %d\\n\") $ take 20 mersenne\n where\n  mersenne = filter lucasLehmer primes\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 404611, "name": "Sexy primes", "source": "Translate Haskell to Java: import Text.Printf         (printf)\nimport Data.Numbers.Primes (isPrime, primes)\n\ntype Pair = (Int, Int)\ntype Triplet = (Int, Int, Int)\ntype Quad = (Int, Int, Int, Int)\ntype Quin = (Int, Int, Int, Int, Int)\n\ntype Result = ([Pair], [Triplet], [Quad], [Quin], [Int])\n\ngroups :: Int -> Result -> Result\ngroups n r@(p, t, q, qn, u)\n  | isPrime n4 && isPrime n3 && isPrime n2 && isPrime n1 = (addPair, addTriplet, addQuad, addQuin, u)\n  | isPrime n3 && isPrime n2 && isPrime n1               = (addPair, addTriplet, addQuad, qn, u)\n  | isPrime n2 && isPrime n1                             = (addPair, addTriplet, q, qn, u)\n  | isPrime n1                                           = (addPair, t, q, qn, u)\n  | not (isPrime (n+6)) && not (isPrime n1)              = (p, t, q, qn, n : u)\n  | otherwise                                            = r\n  where addPair    = (n1, n) : p\n        addTriplet = (n2, n1, n) : t\n        addQuad    = (n3, n2, n1, n) : q\n        addQuin    = (n4, n3, n2, n1, n) : qn\n        n1         = n - 6\n        n2         = n - 12\n        n3         = n - 18\n        n4         = n - 24\n\nmain :: IO ()\nmain = do\n  printf (\"Number of sexy prime pairs: %d\\n\" <> lastFiveText) (length pairs) (lastFive pairs)\n  printf (\"Number of sexy prime triplets: %d\\n\" <> lastFiveText) (length triplets) (lastFive triplets)\n  printf (\"Number of sexy prime quadruplets: %d\\n\" <> lastFiveText) (length quads) (lastFive quads)\n  printf \"Number of sexy prime quintuplets: %d\\n  Last 1\u00a0: %s\\n\\n\" (length quins) (show $ last quins)\n  printf \"Number of unsexy primes: %d\\n  Last 10: %s\\n\\n\" (length unsexy) (show $ drop (length unsexy - 10) unsexy)\n  where (pairs, triplets, quads, quins, unsexy) = foldr groups ([], [], [], [], []) $ takeWhile (< 1000035) primes\n        lastFive xs = show $ drop (length xs - 5) xs\n        lastFiveText = \"  Last 5\u00a0: %s\\n\\n\"\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SexyPrimes {\n\n    public static void main(String[] args) {\n        sieve();\n        int pairs = 0;\n        List<String> pairList = new ArrayList<>();\n        int triples = 0;\n        List<String> tripleList = new ArrayList<>();\n        int quadruplets = 0;\n        List<String> quadrupletList = new ArrayList<>();\n        int unsexyCount = 1;  \n        List<String> unsexyList = new ArrayList<>();\n        for ( int i = 3 ; i < MAX ; i++ ) {\n            if ( i-6 >= 3 && primes[i-6] && primes[i] ) {\n                pairs++;\n                pairList.add((i-6) + \" \" + i);\n                if ( pairList.size() > 5 ) {\n                    pairList.remove(0);\n                }\n            }\n            else if ( i < MAX-2 && primes[i] && ! (i+6<MAX && primes[i] && primes[i+6])) {\n                unsexyCount++;\n                unsexyList.add(\"\" + i);\n                if ( unsexyList.size() > 10 ) {\n                    unsexyList.remove(0);\n                }\n            }\n            if ( i-12 >= 3 && primes[i-12] && primes[i-6] && primes[i] ) {\n                triples++;\n                tripleList.add((i-12) + \" \" + (i-6) + \" \" + i);\n                if ( tripleList.size() > 5 ) {\n                    tripleList.remove(0);\n                }\n            }\n            if ( i-16 >= 3 && primes[i-18] && primes[i-12] && primes[i-6] && primes[i] ) {\n                quadruplets++;\n                quadrupletList.add((i-18) + \" \" + (i-12) + \" \" + (i-6) + \" \" + i);\n                if ( quadrupletList.size() > 5 ) {\n                    quadrupletList.remove(0);\n                }\n            }\n        }\n        System.out.printf(\"Count of sexy triples less than\u00a0%,d =\u00a0%,d%n\", MAX, pairs);\n        System.out.printf(\"The last 5 sexy pairs:%n  %s%n%n\", pairList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of sexy triples less than\u00a0%,d =\u00a0%,d%n\", MAX, triples);\n        System.out.printf(\"The last 5 sexy triples:%n  %s%n%n\", tripleList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of sexy quadruplets less than\u00a0%,d =\u00a0%,d%n\", MAX, quadruplets);\n        System.out.printf(\"The last 5 sexy quadruplets:%n  %s%n%n\", quadrupletList.toString().replaceAll(\", \", \"], [\"));\n        System.out.printf(\"Count of unsexy primes less than\u00a0%,d =\u00a0%,d%n\", MAX, unsexyCount);\n        System.out.printf(\"The last 10 unsexy primes:%n  %s%n%n\", unsexyList.toString().replaceAll(\", \", \"], [\"));\n    }\n\n    private static int MAX = 1_000_035;\n    private static boolean[] primes = new boolean[MAX];\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 404612, "name": "Taxicab numbers", "source": "Translate Haskell to Java: import Data.List (groupBy, sortOn, tails, transpose)\nimport Data.Function (on)\n\n\n\ntaxis :: Int -> [[(Int, ((Int, Int), (Int, Int)))]]\ntaxis nCubes =\n  filter ((> 1) . length) $\n  groupBy (on (==) fst) $\n  sortOn fst\n    [ (fst x + fst y, (x, y))\n    | (x:t) <- tails $ ((^ 3) >>= (,)) <$> [1 .. nCubes] \n    , y <- t ]\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  concat <$>\n  transpose\n    (((<$>) =<< flip justifyRight ' ' . maximum . (length <$>)) <$>\n     transpose (taxiRow <$> (take 25 xs <> take 7 (drop 1999 xs))))\n  where\n    xs = zip [1 ..] (taxis 1200)\n    justifyRight n c = (drop . length) <*> (replicate n c <>)\n\n\ntaxiRow :: (Int, [(Int, ((Int, Int), (Int, Int)))]) -> [String]\ntaxiRow (n, [(a, ((axc, axr), (ayc, ayr))), (b, ((bxc, bxr), (byc, byr)))]) =\n  concat\n    [ [show n, \". \", show a, \" = \"]\n    , term axr axc \" + \"\n    , term ayr ayc \"  or  \"\n    , term bxr bxc \" + \"\n    , term byr byc []\n    ]\n  where\n    term r c l = [\"(\", show r, \"^3=\", show c, \")\", l]\n", "target": "import java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Iterator;\n\nclass CubeSum implements Comparable<CubeSum> {\n\tpublic long x, y, value;\n\n\tpublic CubeSum(long x, long y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.value = x*x*x + y*y*y;\n\t}\n\n\tpublic String toString() {\n\t\treturn String.format(\"%4d^3 + %4d^3\", x, y);\n\t}\n\n\tpublic int compareTo(CubeSum that) {\n\t\treturn value < that.value ? -1 : value > that.value ? 1 : 0;\n\t}\n}\n\nclass SumIterator implements Iterator<CubeSum> {\n\tPriorityQueue<CubeSum> pq = new PriorityQueue<CubeSum>();\n\tlong n = 0;\n\n\tpublic boolean hasNext() { return true; }\n\tpublic CubeSum next() {\n\t\twhile (pq.size() == 0 || pq.peek().value >= n*n*n)\n\t\t\tpq.add(new CubeSum(++n, 1));\n\n\t\tCubeSum s = pq.remove();\n\t\tif (s.x > s.y + 1) pq.add(new CubeSum(s.x, s.y+1));\n\n\t\treturn s;\n\t}\n}\n\nclass TaxiIterator implements Iterator<List<CubeSum>> {\n\tIterator<CubeSum> sumIterator = new SumIterator();\n\tCubeSum last = sumIterator.next();\n\n\tpublic boolean hasNext() { return true; }\n\tpublic List<CubeSum> next() {\n\t\tCubeSum s;\n\t\tList<CubeSum> train = new ArrayList<CubeSum>();\n\n\t\twhile ((s = sumIterator.next()).value != last.value)\n\t\t\tlast = s;\n\n\t\ttrain.add(last);\n\n\t\tdo { train.add(s); } while ((s = sumIterator.next()).value == last.value);\n\t\tlast = s;\n\n\t\treturn train;\n\t}\n}\n\t\npublic class Taxi {\n\tpublic static final void main(String[] args) {\n\t\tIterator<List<CubeSum>> taxi = new TaxiIterator();\n\n\t\tfor (int i = 1; i <= 2006; i++) {\n\t\t\tList<CubeSum> t = taxi.next();\n\t\t\tif (i > 25 && i < 2000) continue;\n\n\t\t\tSystem.out.printf(\"%4d: %10d\", i, t.get(0).value);\n\t\t\tfor (CubeSum s: t)\n\t\t\t\tSystem.out.print(\" = \" + s);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 404613, "name": "Strong and weak primes", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.Numbers.Primes (primes)\n\nxPrimes :: (Real a, Fractional b) => (b -> b -> Bool) -> [a] -> [a]\nxPrimes op ps@(p1:p2:p3:xs)\n  | realToFrac p2 `op` (realToFrac (p1 + p3) / 2) = p2 : xPrimes op (tail ps)\n  | otherwise = xPrimes op (tail ps)\n\nmain :: IO ()\nmain = do \n  printf \"First 36 strong primes: %s\\n\" . show . take 36 $ strongPrimes\n  printf \"Strong primes below 1,000,000: %d\\n\" . length . takeWhile (<1000000) $ strongPrimes\n  printf \"Strong primes below 10,000,000: %d\\n\\n\" . length . takeWhile (<10000000) $ strongPrimes\n\n  printf \"First 37 weak primes: %s\\n\" . show . take 37 $ weakPrimes \n  printf \"Weak primes below 1,000,000: %d\\n\" . length . takeWhile (<1000000) $ weakPrimes\n  printf \"Weak primes below 10,000,000: %d\\n\\n\" . length . takeWhile (<10000000) $ weakPrimes\n  where strongPrimes = xPrimes (>) primes\n        weakPrimes   = xPrimes (<) primes\n", "target": "public class StrongAndWeakPrimes {\n\n    private static int MAX = 10_000_000 + 1000;\n    private static boolean[] primes = new boolean[MAX];\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"First 36 strong primes:\");        \n        displayStrongPrimes(36);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of strong primes below\u00a0%,d =\u00a0%,d%n\", n, strongPrimesBelow(n));\n        }\n        System.out.println(\"First 37 weak primes:\");        \n        displayWeakPrimes(37);\n        for ( int n : new int[] {1_000_000, 10_000_000}) {\n            System.out.printf(\"Number of weak primes below\u00a0%,d =\u00a0%,d%n\", n, weakPrimesBelow(n));\n        }\n    }\n\n    private static int weakPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n\n    private static void displayWeakPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 < priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static int getNextPrime(int currentPrime) {\n        int nextPrime = currentPrime + 2;\n        while ( ! primes[nextPrime] ) {\n            nextPrime += 2;\n        }\n        return nextPrime;\n    }\n    \n    private static int strongPrimesBelow(int maxPrime) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( currentPrime < maxPrime ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime ) {\n                count++;\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        return count;\n    }\n    \n    private static void displayStrongPrimes(int maxCount) {\n        int priorPrime = 2;\n        int currentPrime = 3;\n        int count = 0;\n        while ( count < maxCount ) {\n            int nextPrime = getNextPrime(currentPrime);\n            if ( currentPrime * 2 > priorPrime + nextPrime) {\n                count++;\n                System.out.printf(\"%d \", currentPrime);\n            }\n            priorPrime = currentPrime;\n            currentPrime = nextPrime;\n        }\n        System.out.println();\n    }\n\n    private static final void sieve() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 404614, "name": "Left factorials", "source": "Translate Haskell to Java: leftFact :: [Integer]\nleftFact = scanl (+) 0 fact\n\nfact :: [Integer]\nfact = scanl (*) 1 [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"0 ~ 10:\"\n    , show $ (leftFact !!) <$> [0 .. 10]\n    , \"\"\n    , \"20 ~ 110 by tens:\"\n    , unlines $ show . (leftFact !!) <$> [20,30 .. 110]\n    , \"\"\n    , \"length of 1,000 ~ 10,000 by thousands:\"\n    , show $ length . show . (leftFact !!) <$> [1000,2000 .. 10000]\n    , \"\"\n    ]\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 404615, "name": "Left factorials", "source": "Translate Haskell to Java: leftFact :: [Integer]\nleftFact = scanl (+) 0 fact\n\nfact :: [Integer]\nfact = scanl (*) 1 [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"0 ~ 10:\"\n    , show $ (leftFact !!) <$> [0 .. 10]\n    , \"\"\n    , \"20 ~ 110 by tens:\"\n    , unlines $ show . (leftFact !!) <$> [20,30 .. 110]\n    , \"\"\n    , \"length of 1,000 ~ 10,000 by thousands:\"\n    , show $ length . show . (leftFact !!) <$> [1000,2000 .. 10000]\n    , \"\"\n    ]\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 404616, "name": "Strange plus numbers", "source": "Translate Haskell to Java: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrangePlus :: Int -> Bool\nisStrangePlus n =\n  all\n    (\\(a, b) -> (a + b) `elem` [2, 3, 5, 7, 11, 13, 17])\n    $ (zip <*> tail) (digits n)\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrangePlus [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"\\\"Strange Plus\\\" numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 404617, "name": "Strange plus numbers", "source": "Translate Haskell to Java: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrangePlus :: Int -> Bool\nisStrangePlus n =\n  all\n    (\\(a, b) -> (a + b) `elem` [2, 3, 5, 7, 11, 13, 17])\n    $ (zip <*> tail) (digits n)\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrangePlus [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"\\\"Strange Plus\\\" numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "public class Strange {\n    private static final boolean[] p = {\n        false, false, true,  true,  false,\n        true,  false, true,  false, false,\n        false, true,  false, true,  false,\n        false, false, true,  false\n    };\n\n    public static boolean isstrange(long n) {\n        if (n < 10) return false;\n        for (; n >= 10; n /= 10) {\n            if (!p[(int)(n%10 + (n/10)%10)]) return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        long nMin = Long.parseLong(args[0]);\n        long nMax = Long.parseLong(args[1]);\n        int k = 0;\n     \n        for (long n = nMin; n <= nMax; n++) {\n            if (isstrange(n)) {\n                System.out.print(n + (++k%10 != 0 ? \" \" : \"\\n\"));\n            }\n        }\n    }\n}\n"}
{"id": 404618, "name": "Smarandache prime-digital sequence", "source": "Translate Haskell to Java: \nimport Control.Monad (guard)\nimport Math.NumberTheory.Primes.Testing (isPrime)\nimport Data.List.Split (chunksOf)\nimport Data.List (intercalate)\nimport Text.Printf (printf)\n\nsmarandache :: [Integer]\nsmarandache = [2,3,5,7] <> s [2,3,5,7] >>= \\x -> guard (isPrime x) >> [x]\n where s xs = r <> s r where r = xs >>= \\x -> [x*10+2, x*10+3, x*10+5, x*10+7]\n\nnextSPDSTerms :: [Int] -> [(String, String)]\nnextSPDSTerms = go 1 smarandache\n where\n  go _ _ [] = []\n  go c (x:xs) terms\n   | c `elem` terms = (commas c, commas x) : go nextCount xs (tail terms)\n   | otherwise      = go nextCount xs terms\n   where nextCount = succ c\n\ncommas :: Show a => a -> String\ncommas = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  printf \"The first 25 SPDS:\\n%s\\n\\n\" $ f smarandache\n  mapM_ (uncurry (printf \"The %9sth SPDS: %15s\\n\")) $ \n    nextSPDSTerms [100, 1_000, 10_000, 100_000, 1_000_000]\n where f = show . take 25\n", "target": "public class SmarandachePrimeDigitalSequence {\n\n    public static void main(String[] args) {\n        long s = getNextSmarandache(7);\n        System.out.printf(\"First 25 Smarandache prime-digital sequence numbers:%n2 3 5 7 \");\n        for ( int count = 1 ; count <= 21 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                System.out.printf(\"%d \", s);\n                count++;\n            }\n        }\n        System.out.printf(\"%n%n\");\n        for (int i = 2 ; i <=5 ; i++ ) {\n            long n = (long) Math.pow(10, i);\n            System.out.printf(\"%,dth Smarandache prime-digital sequence number = %d%n\", n, getSmarandachePrime(n));\n        }\n    }\n    \n    private static final long getSmarandachePrime(long n) {\n        if ( n < 10 ) {\n            switch ((int) n) {\n            case 1:  return 2;\n            case 2:  return 3;\n            case 3:  return 5;\n            case 4:  return 7;\n            }\n        }\n        long s = getNextSmarandache(7);\n        long result = 0;\n        for ( int count = 1 ; count <= n-4 ; s = getNextSmarandache(s) ) {\n            if ( isPrime(s) ) {\n                count++;\n                result = s;\n            }\n        }\n        return result;\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static long getNextSmarandache(long n) {\n        \n        if ( n % 10 == 3 ) {\n            return n+4;\n        }\n        long retVal = n-4;\n        \n        \n        int k = 0;\n        while ( n % 10 == 7 ) {\n            k++;\n            n /= 10;\n        }\n        \n        \n        long digit = n % 10;\n\n        \n        long coeff = (digit == 2 ? 1 : 2);\n        \n        \n        retVal += coeff * Math.pow(10, k);\n        \n        \n        while ( k > 1 ) {\n            retVal -= 5 * Math.pow(10, k-1);\n            k--;\n        }\n        \n        \n        return retVal;\n    }\n\n}\n"}
{"id": 404619, "name": "Magic squares of doubly even order", "source": "Translate Haskell to Java: import Data.List (transpose, unfoldr, intercalate)\nimport Data.List.Split (chunksOf)\nimport Data.Bool (bool)\nimport Control.Monad (forM_)\n\nmagicSquare :: Int -> [[Int]]\nmagicSquare n\n  | rem n 4 > 0 = []\n  | otherwise =\n    chunksOf n $ zipWith (flip (bool =<< (-) limit)) series [1 .. sqr]\n  where\n    sqr = n * n\n    limit = sqr + 1\n    series\n      | isPowerOf 2 n = magicSeries $ floor (logBase 2 (fromIntegral sqr))\n      | otherwise =\n        concat . concat . concat . scale $ scale <$> chunksOf 4 (magicSeries 4)\n      where\n        scale = replicate $ quot n 4\n\nmagicSeries :: Int -> [Bool]\nmagicSeries = (iterate ((++) <*> fmap not) [True] !!)\n\nisPowerOf :: Int -> Int -> Bool\nisPowerOf k n = until ((0 /=) . flip rem k) (`quot` k) n == 1\n\n\nchecked :: [[Int]] -> (Int, Bool)\nchecked square =\n  let diagonals =\n        fmap (flip (zipWith (!!)) [0 ..]) . ((:) <*> (return . reverse))\n      h:t =\n        sum <$>\n        square ++ \n        transpose square ++ \n        diagonals square \n  in (h, all (h ==) t)\n\ntable :: String -> [[String]] -> [String]\ntable delim rows =\n  let justifyRight c n s = drop (length s) (replicate n c ++ s)\n  in intercalate delim <$>\n     transpose\n       ((fmap =<< justifyRight ' ' . maximum . fmap length) <$> transpose rows)\n\nmain :: IO ()\nmain =\n  forM_ [4, 8, 16] $\n  \\n -> do\n    let test = magicSquare n\n    putStrLn $ unlines (table \" \" (fmap show <$> test))\n    print $ checked test\n    putStrLn []\n", "target": "public class MagicSquareDoublyEven {\n\n    public static void main(String[] args) {\n        int n = 8;\n        for (int[] row : magicSquareDoublyEven(n)) {\n            for (int x : row)\n                System.out.printf(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    static int[][] magicSquareDoublyEven(final int n) {\n        if (n < 4 || n % 4 != 0)\n            throw new IllegalArgumentException(\"base must be a positive \"\n                    + \"multiple of 4\");\n\n        \n        int bits = 0b1001_0110_0110_1001;\n        int size = n * n;\n        int mult = n / 4;  \n\n        int[][] result = new int[n][n];\n\n        for (int r = 0, i = 0; r < n; r++) {\n            for (int c = 0; c < n; c++, i++) {\n                int bitPos = c / mult + (r / mult) * 4;\n                result[r][c] = (bits & (1 << bitPos)) != 0 ? i + 1 : size - i;\n            }\n        }\n        return result;\n    }\n}\n"}
{"id": 404620, "name": "Square-free integers", "source": "Translate Haskell to Java: import Data.List.Split (chunksOf)\nimport Math.NumberTheory.Primes (factorise)\nimport Text.Printf (printf)\n\n\nisSquareFree :: Integer -> Bool\nisSquareFree = all ((== 1) . snd) . factorise\n\n\nsquareFrees :: Integer -> Integer -> [Integer]\nsquareFrees lo hi = filter isSquareFree [lo..hi]\n\n\n\n\ncounts :: (Ord a, Num b) => [a] -> [a] -> [b]\ncounts = go 0\n  where go c lims@(l:ls) (v:vs) | v > l     = c : go (c+1) ls vs\n                                | otherwise = go (c+1) lims vs\n        go _ [] _  = []\n        go c ls [] = replicate (length ls) c\n\nprintSquareFrees :: Int -> Integer -> Integer -> IO ()\nprintSquareFrees cols lo hi =\n  let ns = squareFrees lo hi\n      title = printf \"Square free numbers from %d to %d\\n\" lo hi\n      body = unlines $ map concat $ chunksOf cols $ map (printf \" %3d\") ns\n  in putStrLn $ title ++ body\n\nprintSquareFreeCounts :: [Integer] -> Integer -> Integer -> IO ()\nprintSquareFreeCounts lims lo hi =\n  let cs = counts lims $ squareFrees lo hi :: [Integer]\n      title = printf \"Counts of square-free numbers\\n\"\n      body = unlines $ zipWith (printf \"  from 1 to %d: %d\") lims cs\n  in putStrLn $ title ++ body\n\nmain :: IO ()\nmain = do\n  printSquareFrees 20 1 145\n  printSquareFrees 5 1000000000000 1000000000145\n  printSquareFreeCounts [100, 1000, 10000, 100000, 1000000] 1 1000000\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class SquareFree\n{\n    private static List<Long> sieve(long limit) {\n        List<Long> primes = new ArrayList<Long>();\n        primes.add(2L);\n        boolean[] c = new boolean[(int)limit + 1]; \n        \n        long p = 3;\n        for (;;) {\n            long p2 = p * p;\n            if (p2 > limit) break;\n            for (long i = p2; i <= limit; i += 2 * p) c[(int)i] = true;\n            for (;;) {\n                p += 2;\n                if (!c[(int)p]) break;\n            }\n        }\n        for (long i = 3; i <= limit; i += 2) {\n            if (!c[(int)i]) primes.add(i);\n        }\n        return primes;\n    }\n\n    private static List<Long> squareFree(long from, long to) {\n        long limit = (long)Math.sqrt((double)to);\n        List<Long> primes = sieve(limit);\n        List<Long> results = new ArrayList<Long>();\n\n        outer: for (long i = from; i <= to; i++) {\n            for (long p : primes) {\n                long p2 = p * p;\n                if (p2 > i) break;\n                if (i % p2 == 0) continue outer;\n            }\n            results.add(i);\n        }\n        return results;\n    }\n\n    private final static long TRILLION = 1000000000000L;\n\n    public static void main(String[] args) {\n        System.out.println(\"Square-free integers from 1 to 145:\");\n        List<Long> sf = squareFree(1, 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 20 == 0) {\n                System.out.println();\n            }\n            System.out.printf(\"%4d\", sf.get(i));\n        }\n\n        System.out.print(\"\\n\\nSquare-free integers\");\n        System.out.printf(\" from %d to %d:\\n\", TRILLION, TRILLION + 145);\n        sf = squareFree(TRILLION, TRILLION + 145);\n        for (int i = 0; i < sf.size(); i++) {\n            if (i > 0 && i % 5 == 0) System.out.println();\n            System.out.printf(\"%14d\", sf.get(i));\n        }\n\n        System.out.println(\"\\n\\nNumber of square-free integers:\\n\");\n        long[] tos = {100, 1000, 10000, 100000, 1000000};\n        for (long to : tos) {\n            System.out.printf(\"  from %d to %d = %d\\n\", 1, to, squareFree(1, to).size());\n        }\n    }\n}\n"}
{"id": 404621, "name": "Self numbers", "source": "Translate Haskell to Java: import Control.Monad (forM_)\nimport Text.Printf\n\nselfs :: [Integer]\nselfs = sieve (sumFs [0..]) [0..]\n  where\n    sumFs = zipWith (+) [ a+b+c+d+e+f+g+h+i+j\n                        | a <- [0..9] , b <- [0..9]\n                        , c <- [0..9] , d <- [0..9]\n                        , e <- [0..9] , f <- [0..9]\n                        , g <- [0..9] , h <- [0..9]\n                        , i <- [0..9] , j <- [0..9] ]\n\n    \n    \n\n    sieve (f:fs) (n:ns)\n      | n > f = sieve fs (n:ns)\n      | n `notElem` take 81 (f:fs) = n : sieve (f:fs) ns\n      | otherwise = sieve (f:fs) ns\n\nmain = do\n  print $ take 50 selfs\n  forM_ [1..8] $ \\i -> \n    printf \"1e%v\\t%v\\n\" (i :: Int) (selfs !! (10^i-1))\n", "target": "public class SelfNumbers {\n    private static final int MC = 103 * 1000 * 10000 + 11 * 9 + 1;\n    private static final boolean[] SV = new boolean[MC + 1];\n\n    private static void sieve() {\n        int[] dS = new int[10_000];\n        for (int a = 9, i = 9999; a >= 0; a--) {\n            for (int b = 9; b >= 0; b--) {\n                for (int c = 9, s = a + b; c >= 0; c--) {\n                    for (int d = 9, t = s + c; d >= 0; d--) {\n                        dS[i--] = t + d;\n                    }\n                }\n            }\n        }\n        for (int a = 0, n = 0; a < 103; a++) {\n            for (int b = 0, d = dS[a]; b < 1000; b++, n += 10000) {\n                for (int c = 0, s = d + dS[b] + n; c < 10000; c++) {\n                    SV[dS[c] + s++] = true;\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        sieve();\n        System.out.println(\"The first 50 self numbers are:\");\n        for (int i = 0, count = 0; count <= 50; i++) {\n            if (!SV[i]) {\n                count++;\n                if (count <= 50) {\n                    System.out.printf(\"%d \", i);\n                } else {\n                    System.out.printf(\"%n%n       Index     Self number%n\");\n                }\n            }\n        }\n        for (int i = 0, limit = 1, count = 0; i < MC; i++) {\n            if (!SV[i]) {\n                if (++count == limit) {\n                    System.out.printf(\"%,12d  \u00a0%,13d%n\", count, i);\n                    limit *= 10;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404622, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Haskell to Java: \nimport Control.Monad (guard)\nimport Text.Printf (printf)\nimport Data.List (intercalate, unfoldr)\nimport Data.List.Split (chunksOf)\nimport Data.Tuple (swap)\n\nnivens :: [Int]\nnivens = [1..] >>= \\n -> guard (n `rem` digitSum n == 0) >> [n]\n where\n  digitSum = sum . unfoldr (\\x -> guard (x > 0) >> pure (swap $ x `quotRem` 10))\n\nfindGaps :: [(Int, Int, Int)]\nfindGaps = go (zip [1..] nivens) 0\n where\n  go [] n = []\n  go r@((c, currentNiven):(_, nextNiven):xs) lastGap\n   | gap > lastGap = (gap, c, currentNiven) : go (tail r) gap\n   | otherwise     = go (tail r) lastGap\n   where\n    gap = nextNiven - currentNiven\n  go (x:xs) _ = []\n\nthousands :: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do \n  printf row \"Gap\" \"Index of Gap\" \"Starting Niven\"\n  mapM_ (\\(gap, gapIndex, niven) -> printf row (show gap) (thousands gapIndex) (thousands niven)) \n    $ takeWhile (\\(_, gapIndex, _) -> gapIndex < 10_000_000) findGaps\n where\n  row = \"%5s%15s%15s\\n\"\n", "target": "public class NivenNumberGaps {\n\n    \n    \n    public static void main(String[] args) {\n        long prevGap = 0;\n        long prevN = 1;\n        long index = 0;\n        System.out.println(\"Gap      Gap Index   Starting Niven\");\n        for ( long n = 2 ; n < 20_000_000_000l ; n++ ) {\n            if ( isNiven(n) ) {\n                index++;\n                long curGap = n - prevN;\n                if ( curGap > prevGap ) {\n                    System.out.printf(\"%3d \u00a0%,13d \u00a0%,15d%n\", curGap, index, prevN);\n                    prevGap = curGap;\n                }\n                prevN = n;\n            }\n        }\n    }\n    \n    public static boolean isNiven(long n) {\n        long sum = 0;\n        long nSave = n;\n        while ( n > 0 ) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return nSave % sum == 0;\n    }\n\n}\n"}
{"id": 404623, "name": "Old Russian measure of length", "source": "Translate Haskell to Java: module Main where\n\nimport Text.Printf (printf)\nimport System.Environment (getArgs, getProgName)\n\ntochka     = (\"tochka\"    , 0.000254)\nliniya     = (\"liniya\"    , 0.00254)\ncentimeter = (\"centimeter\", 0.01)\ndiuym      = (\"diuym\"     , 0.0254)\nvershok    = (\"vershok\"   , 0.04445)\npiad       = (\"piad\"      , 0.1778)\nfut        = (\"fut\"       , 0.3048)\narshin     = (\"arshin\"    , 0.7112)\nmeter      = (\"meter\"     , 1.0)\nsazhen     = (\"sazhen\"    , 2.1336)\nkilometer  = (\"kilometer\" , 1000.0)\nversta     = (\"versta\"    , 1066.8)\nmilia      = (\"milia\"     , 7467.6)\n\nunits :: [(String, Double)]\nunits = [tochka, liniya, centimeter, diuym, vershok, piad, fut, arshin, meter, sazhen, kilometer, versta, milia]\n\n\nconvert :: Double -> Double -> IO ()\nconvert num factor = mapM_ (\\(unit, fac) -> printf \"|\u00a0%-10s |\u00a0%-22f|\\n\" unit  (num * factor / fac)) units\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    [x,y] | [(num, \"\")]   <- reads x :: [(Double, String)]\n          , (Just factor) <- lookup y units -> convert num factor\n    (_) -> do\n      name <- getProgName\n      printf \"Arguments were wrong - please use ./%s <number> <unit>\\n\" name\n", "target": "public class OldRussianMeasures {\n\n    final static String[] keys = {\"tochka\", \"liniya\", \"centimeter\", \"diuym\",\n        \"vershok\", \"piad\", \"fut\", \"arshin\", \"meter\", \"sazhen\", \"kilometer\",\n        \"versta\", \"milia\"};\n\n    final static double[] values = {0.000254, 0.00254, 0.01,0.0254,\n        0.04445, 0.1778, 0.3048, 0.7112, 1.0, 2.1336, 1000.0,\n        1066.8, 7467.6};\n\n    public static void main(String[] a) {\n        if (a.length == 2 && a[0].matches(\"[+-]?\\\\d*(\\\\.\\\\d+)?\")) {\n            double inputVal = lookup(a[1]);\n            if (!Double.isNaN(inputVal)) {\n                double magnitude = Double.parseDouble(a[0]);\n                double meters = magnitude * inputVal;\n                System.out.printf(\"%s %s to: %n%n\", a[0], a[1]);\n                for (String k: keys)\n                    System.out.printf(\"%10s: %g%n\", k, meters / lookup(k));\n                return;\n            }\n        }\n        System.out.println(\"Please provide a number and unit\");\n\n    }\n\n    public static double lookup(String key) {\n        for (int i = 0; i < keys.length; i++)\n            if (keys[i].equals(key))\n                return values[i];\n        return Double.NaN;\n    }\n}\n"}
{"id": 404624, "name": "Pythagorean quadruples", "source": "Translate Haskell to Java: powersOfTwo :: [Int]\npowersOfTwo = iterate (2 *) 1\n\nunrepresentable :: [Int]\nunrepresentable = merge powersOfTwo ((5 *) <$> powersOfTwo)\n\nmerge :: [Int] -> [Int] -> [Int]\nmerge xxs@(x:xs) yys@(y:ys)\n  | x < y = x : merge xs yys\n  | otherwise = y : merge xxs ys\n\nmain :: IO ()\nmain = do\n  putStrLn \"The values of d <= 2200 which can't be represented.\"\n  print $ takeWhile (<= 2200) unrepresentable\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class PythagoreanQuadruples {\n\n    public static void main(String[] args) {\n        long d = 2200;\n        System.out.printf(\"Values of d < %d where a, b, and c are non-zero and a^2 + b^2 + c^2 = d^2 has no solutions:%n%s%n\", d, getPythagoreanQuadruples(d));\n    }\n\n    \n    private static List<Long> getPythagoreanQuadruples(long max) {\n        List<Long> list = new ArrayList<>();\n        long n = -1;\n        long m = -1;\n        while ( true ) {\n            long nTest = (long) Math.pow(2, n+1);\n            long mTest = (long) (5L * Math.pow(2, m+1));\n            long test = 0;\n            if ( nTest > mTest ) {\n                test = mTest;\n                m++;\n            }\n            else {\n                test = nTest;\n                n++;\n            }\n            if ( test < max ) {\n                list.add(test);\n            }\n            else {\n                break;\n            }\n        }\n        return list;\n    }\n\n}\n"}
{"id": 404625, "name": "Sum and product puzzle", "source": "Translate Haskell to Java: import Data.List (intersect)\n\ns1, s2, s3, s4 :: [(Int, Int)]\ns1 = [(x, y) | x <- [1 .. 100], y <- [1 .. 100], 1 < x && x < y && x + y < 100]\n\nadd, mul :: (Int, Int) -> Int\nadd (x, y) = x + y\nmul (x, y) = x * y\n\nsumEq, mulEq :: (Int, Int) -> [(Int, Int)]\nsumEq p = filter (\\q -> add q == add p) s1\nmulEq p = filter (\\q -> mul q == mul p) s1\n\ns2 = filter (\\p -> all (\\q -> (length $ mulEq q) /= 1) (sumEq p)) s1\ns3 = filter (\\p -> length (mulEq p `intersect` s2) == 1) s2\ns4 = filter (\\p -> length (sumEq p `intersect` s3) == 1) s3\n\nmain = print s4\n", "target": "package org.rosettacode;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class SumAndProductPuzzle {\n    private final long beginning;\n    private final int maxSum;\n    private static final int MIN_VALUE = 2;\n    private List<int[]> firstConditionExcludes = new ArrayList<>();\n    private List<int[]> secondConditionExcludes = new ArrayList<>();\n    \n    public static void main(String... args){\n        \n        if (args.length == 0){\n            new SumAndProductPuzzle(100).run();\n            new SumAndProductPuzzle(1684).run();\n            new SumAndProductPuzzle(1685).run();\n        } else {\n            for (String arg : args){\n                try{\n                    new SumAndProductPuzzle(Integer.valueOf(arg)).run();\n                } catch (NumberFormatException e){\n                    System.out.println(\"Please provide only integer arguments. \" +\n                            \"Provided argument \" + arg + \" was not an integer. \" +\n                            \"Alternatively, calling the program with no arguments \" +\n                            \"will run the puzzle where maximum sum equals 100, 1684, and 1865.\");\n                }\n            }\n        }\n    }\n    \n    public SumAndProductPuzzle(int maxSum){\n        this.beginning = System.currentTimeMillis();\n        this.maxSum = maxSum;\n        System.out.println(\"Run with maximum sum of \" + String.valueOf(maxSum) + \n                \" started at \" + String.valueOf(beginning) + \".\");\n    }\n    \n    public void run(){\n        for (int x = MIN_VALUE; x < maxSum - MIN_VALUE; x++){\n            for (int y = x + 1; y < maxSum - MIN_VALUE; y++){\n                \n                if (isSumNoGreaterThanMax(x,y) &&\n                    isSKnowsPCannotKnow(x,y) &&\n                    isPKnowsNow(x,y) &&\n                    isSKnowsNow(x,y)\n                    ){\n                    System.out.println(\"Found solution x is \" + String.valueOf(x) + \" y is \" + String.valueOf(y) + \n                            \" in \" + String.valueOf(System.currentTimeMillis() - beginning) + \"ms.\");\n                }\n            }\n        }\n        System.out.println(\"Run with maximum sum of \" + String.valueOf(maxSum) + \n                \" ended in \" + String.valueOf(System.currentTimeMillis() - beginning) + \"ms.\");\n    }\n    \n    public boolean isSumNoGreaterThanMax(int x, int y){\n        return x + y <= maxSum;\n    }\n    \n    public boolean isSKnowsPCannotKnow(int x, int y){\n        \n        if (firstConditionExcludes.contains(new int[] {x, y})){\n            return false;\n        }\n        \n        for (int[] addends : sumAddends(x, y)){\n            if ( !(productFactors(addends[0], addends[1]).size() > 1) ) {\n                firstConditionExcludes.add(new int[] {x, y});\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    public boolean isPKnowsNow(int x, int y){\n        \n        if (secondConditionExcludes.contains(new int[] {x, y})){\n            return false;\n        }\n        \n        int countSolutions = 0;\n        for (int[] factors : productFactors(x, y)){\n            if (isSKnowsPCannotKnow(factors[0], factors[1])){\n                countSolutions++;\n            }\n        }\n        \n        if (countSolutions == 1){\n            return true;\n        } else {\n            secondConditionExcludes.add(new int[] {x, y});\n            return false;\n        }\n    }\n    \n    public boolean isSKnowsNow(int x, int y){\n        \n        int countSolutions = 0;\n        for (int[] addends : sumAddends(x, y)){\n            if (isPKnowsNow(addends[0], addends[1])){\n                countSolutions++;\n            }\n        }\n        return countSolutions == 1;\n    }\n    \n    public List<int[]> sumAddends(int x, int y){\n        \n        List<int[]> list = new ArrayList<>();\n        int sum = x + y;\n        \n        for (int addend = MIN_VALUE; addend < sum - addend; addend++){\n            if (isSumNoGreaterThanMax(addend, sum - addend)){\n                list.add(new int[]{addend, sum - addend});\n            }\n        }\n        return list;\n    }\n    \n    public List<int[]> productFactors(int x, int y){\n        \n        List<int[]> list = new ArrayList<>();\n        int product = x * y;\n        \n        for (int factor = MIN_VALUE; factor < product / factor; factor++){\n            if (product % factor == 0){\n                if (isSumNoGreaterThanMax(factor, product / factor)){\n                    list.add(new int[]{factor, product / factor});\n                }\n            }\n        }\n        return list;\n    }\n}\n"}
{"id": 404626, "name": "Test integerness", "source": "Translate Haskell to Java: import Data.Decimal\nimport Data.Ratio\nimport Data.Complex\n", "target": "import java.math.BigDecimal;\nimport java.util.List;\n\npublic class TestIntegerness {\n    private static boolean isLong(double d) {\n        return isLong(d, 0.0);\n    }\n\n    private static boolean isLong(double d, double tolerance) {\n        return (d - Math.floor(d)) <= tolerance || (Math.ceil(d) - d) <= tolerance;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static boolean isBigInteger(BigDecimal bd) {\n        try {\n            bd.toBigIntegerExact();\n            return true;\n        } catch (ArithmeticException ex) {\n            return false;\n        }\n    }\n\n    private static class Rational {\n        long num;\n        long denom;\n\n        Rational(int num, int denom) {\n            this.num = num;\n            this.denom = denom;\n        }\n\n        boolean isLong() {\n            return num % denom == 0;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s/%s\", num, denom);\n        }\n    }\n\n    private static class Complex {\n        double real;\n        double imag;\n\n        Complex(double real, double imag) {\n            this.real = real;\n            this.imag = imag;\n        }\n\n        boolean isLong() {\n            return TestIntegerness.isLong(real) && imag == 0.0;\n        }\n\n        @Override\n        public String toString() {\n            if (imag >= 0.0) {\n                return String.format(\"%s + %si\", real, imag);\n            }\n            return String.format(\"%s - %si\", real, imag);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Double> da = List.of(25.000000, 24.999999, 25.000100);\n        for (Double d : da) {\n            boolean exact = isLong(d);\n            System.out.printf(\"%.6f is %s integer%n\", d, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        double tolerance = 0.00001;\n        System.out.printf(\"With a tolerance of\u00a0%.5f:%n\", tolerance);\n        for (Double d : da) {\n            boolean fuzzy = isLong(d, tolerance);\n            System.out.printf(\"%.6f is %s integer%n\", d, fuzzy ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Double> fa = List.of(-2.1e120, -5e-2, Double.NaN, Double.POSITIVE_INFINITY);\n        for (Double f : fa) {\n            boolean exact = !f.isNaN() && !f.isInfinite() && isBigInteger(new BigDecimal(f.toString()));\n            System.out.printf(\"%s is %s integer%n\", f, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Complex> ca = List.of(new Complex(5.0, 0.0), new Complex(5.0, -5.0));\n        for (Complex c : ca) {\n            boolean exact = c.isLong();\n            System.out.printf(\"%s is %s integer%n\", c, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Rational> ra = List.of(new Rational(24, 8), new Rational(-5, 1), new Rational(17, 2));\n        for (Rational r : ra) {\n            boolean exact = r.isLong();\n            System.out.printf(\"%s is %s integer%n\", r, exact ? \"an\" : \"not an\");\n        }\n    }\n}\n"}
{"id": 404627, "name": "Linux CPU utilization", "source": "Translate Haskell to Java: import Data.List ( (!!) ) \n\nsplitString :: Char -> String -> [String]\nsplitString c [] = []\nsplitString c s = let ( item , rest ) = break ( == c ) s\n                      ( _ , next ) = break ( /= c ) rest\n\t\t  in item : splitString c next    \n\t\t  \ncomputeUsage :: String -> Double\ncomputeUsage s = (1.0 - ((lineElements !! 3 ) /  sum times)) * 100\n   where\n      lineElements = map (fromInteger . read ) $ tail $ splitString ' ' s\n      times = tail lineElements\n\nmain :: IO ( )      \nmain = do \n   theTimes <- fmap lines $ readFile \"/proc/stat\" \n   putStr $ show $ computeUsage $ head theTimes\n   putStrLn \"\u00a0%\"\n", "target": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.text.NumberFormat;\nimport java.time.Duration;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws FileNotFoundException {\n        \n        final var period = Duration.ofSeconds(1);\n        new Timer().schedule(new CpuUtilizationTask(), 0, period.toMillis());\n    }\n\n    \n    static class CpuUtilizationTask extends TimerTask {\n\n        private final String STAT_FILE_HEADER = \"cpu  \";\n        private final NumberFormat percentFormatter;\n        private final RandomAccessFile statPointer;\n        long previousIdleTime = 0, previousTotalTime = 0;\n\n        public CpuUtilizationTask() throws FileNotFoundException {\n            this.percentFormatter = NumberFormat.getPercentInstance();\n            percentFormatter.setMaximumFractionDigits(2);\n            var statFile = new File(\"/proc/stat\");\n            \n            this.statPointer = new RandomAccessFile(statFile, \"r\");\n        }\n\n        @Override\n        public void run() {\n\n            try {\n                var values = statPointer.readLine()\n                        .substring(STAT_FILE_HEADER.length())\n                        .split(\" \");\n\n                \n                var idleTime = Long.parseUnsignedLong(values[3]);\n                var totalTime = 0L;\n                for (String value : values) {\n                    totalTime += Long.parseUnsignedLong(value);\n                }\n\n                var idleTimeDelta = idleTime - previousIdleTime;\n                var totalTimeDelta = totalTime - previousTotalTime;\n                var utilization = 1 - ((double) idleTimeDelta) / totalTimeDelta;\n\n                \n                System.out.println(percentFormatter.format(utilization));\n\n                previousIdleTime = idleTime;\n                previousTotalTime = totalTime;\n\n                \n                statPointer.seek(0);\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n        }\n\n    }\n}\n"}
{"id": 404628, "name": "Ulam numbers", "source": "Translate Haskell to Java: import Data.List\n\nulam \n  :: Integral i =>\n     Int -> i\nulam 1 = 1\nulam 2 = 2\nulam n\n  | n > 2 = ulams !! (n-1)\n\nulams\n  :: Integral n =>\n     [n]\nulams = 1:2:(nexts [2,1])\nnexts us = u: (nexts (u:us))\n  where\n    n = length us\n    [u] = head . filter isSingleton . group . sort  $ \n            [v | i <- [0 .. n-2], j <- [i+1 .. n-1] \n               , let s = us !! i\n               , let t = us !! j\n               , let v = s+t\n               , v > head us\n               ]\n\nisSingleton :: [a] -> Bool\nisSingleton as\n  | length as == 1 = True\n  | otherwise      = False\n", "target": "public class UlamNumbers {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        for (int n = 1; n <= 100000; n *= 10) {\n            System.out.printf(\"Ulam(%d) = %d\\n\", n, ulam(n));\n        }\n        long finish = System.currentTimeMillis();\n        System.out.printf(\"Elapsed time:\u00a0%.3f seconds\\n\", (finish - start)/1000.0);\n    }\n\n    private static int ulam(int n) {\n        int[] ulams = new int[Math.max(n, 2)];\n        ulams[0] = 1;\n        ulams[1] = 2;\n        int sieveLength = 2;\n        int[] sieve = new int[sieveLength];\n        sieve[0] = sieve[1] = 1;\n        for (int u = 2, ulen = 2; ulen < n; ) {\n            sieveLength = u + ulams[ulen - 2];\n            sieve = extend(sieve, sieveLength);\n            for (int i = 0; i < ulen - 1; ++i)\n                ++sieve[u + ulams[i] - 1];\n            for (int i = u; i < sieveLength; ++i) {\n                if (sieve[i] == 1) {\n                    u = i + 1;\n                    ulams[ulen++] = u;\n                    break;\n                }\n            }\n        }\n        return ulams[n - 1];\n    }\n\n    private static int[] extend(int[] array, int minLength) {\n        if (minLength <= array.length)\n            return array;\n        int newLength = 2 * array.length;\n        while (newLength < minLength)\n            newLength *= 2;\n        int[] newArray = new int[newLength];\n        System.arraycopy(array, 0, newArray, 0, array.length);\n        return newArray;\n    }\n}\n"}
{"id": 404629, "name": "Safe primes and unsafe primes", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.Numbers.Primes (isPrime, primes)\n\nmain = do \n  printf \"First 35 safe primes: %s\\n\" (show $ take 35 safe)\n  printf \"There are %d safe primes below 100,000.\\n\" (length $ takeWhile (<1000000) safe)\n  printf \"There are %d safe primes below 10,000,000.\\n\\n\" (length $ takeWhile (<10000000) safe)\n\n  printf \"First 40 unsafe primes: %s\\n\" (show $ take 40 unsafe)\n  printf \"There are %d unsafe primes below 100,000.\\n\" (length $ takeWhile (<1000000) unsafe)\n  printf \"There are %d unsafe primes below 10,000,000.\\n\\n\" (length $ takeWhile (<10000000) unsafe)\n\n  where safe = filter (\\n -> isPrime ((n-1) `div` 2)) primes\n        unsafe = filter (\\n -> not (isPrime((n-1) `div` 2))) primes\n", "target": "public class SafePrimes {\n    public static void main(String... args) {\n        \n        int SIEVE_SIZE = 10_000_000;\n        boolean[] isComposite = new boolean[SIEVE_SIZE];\n        \n        isComposite[0] = true;\n        isComposite[1] = true;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (isComposite[n]) {\n                continue;\n            }\n            for (int i = n * 2; i < SIEVE_SIZE; i += n) {\n                isComposite[i] = true;\n            }\n        }\n        \n        int oldSafePrimeCount = 0;\n        int oldUnsafePrimeCount = 0;\n        int safePrimeCount = 0;\n        int unsafePrimeCount = 0;\n        StringBuilder safePrimes = new StringBuilder();\n        StringBuilder unsafePrimes = new StringBuilder();\n        int safePrimesStrCount = 0;\n        int unsafePrimesStrCount = 0;\n        for (int n = 2; n < SIEVE_SIZE; n++) {\n            if (n == 1_000_000) {\n                oldSafePrimeCount = safePrimeCount;\n                oldUnsafePrimeCount = unsafePrimeCount;\n            }\n            if (isComposite[n]) {\n                continue;\n            }\n            boolean isUnsafe = isComposite[(n - 1) >>> 1];\n            if (isUnsafe) {\n                if (unsafePrimeCount < 40) {\n                    if (unsafePrimeCount > 0) {\n                        unsafePrimes.append(\", \");\n                    }\n                    unsafePrimes.append(n);\n                    unsafePrimesStrCount++;\n                }\n                unsafePrimeCount++;\n            }\n            else {\n                if (safePrimeCount < 35) {\n                    if (safePrimeCount > 0) {\n                        safePrimes.append(\", \");\n                    }\n                    safePrimes.append(n);\n                    safePrimesStrCount++;\n                }\n                safePrimeCount++;\n            }\n        }\n        \n        System.out.println(\"First \" + safePrimesStrCount + \" safe primes: \" + safePrimes.toString());\n        System.out.println(\"Number of safe primes below 1,000,000: \" + oldSafePrimeCount);\n        System.out.println(\"Number of safe primes below 10,000,000: \" + safePrimeCount);\n        System.out.println(\"First \" + unsafePrimesStrCount + \" unsafe primes: \" + unsafePrimes.toString());\n        System.out.println(\"Number of unsafe primes below 1,000,000: \" + oldUnsafePrimeCount);\n        System.out.println(\"Number of unsafe primes below 10,000,000: \" + unsafePrimeCount);\n        \n        return;\n    }\n}\n"}
{"id": 404630, "name": "Hash join", "source": "Translate Haskell to Java: \nimport qualified Data.HashTable.ST.Basic as H\nimport Data.Hashable\nimport Control.Monad.ST\nimport Control.Monad\nimport Data.STRef\n\nhashJoin :: (Eq k, Hashable k) =>\n            [t] -> (t -> k) -> [a] -> (a -> k) -> [(t, a)]\nhashJoin xs fx ys fy = runST $ do\n  l <- newSTRef []\n  ht <- H.new\n  forM_ ys $ \\y -> H.insert ht (fy y) =<< \n    (H.lookup ht (fy y) >>= \\case\n      Nothing -> return [y]\n      Just v -> return (y:v))\n  forM_ xs $ \\x -> do\n    H.lookup ht (fx x) >>= \\case\n      Nothing -> return ()\n      Just v -> modifySTRef' l ((map (x,)  v) ++) \n  readSTRef l\n\nmain = mapM_ print $ hashJoin \n    [(1, \"Jonah\"), (2, \"Alan\"), (3, \"Glory\"), (4, \"Popeye\")]\n        snd\n    [(\"Jonah\", \"Whales\"), (\"Jonah\", \"Spiders\"), \n      (\"Alan\", \"Ghosts\"), (\"Alan\", \"Zombies\"), (\"Glory\", \"Buffy\")]\n        fst\n", "target": "import java.util.*;\n\npublic class HashJoin {\n\n    public static void main(String[] args) {\n        String[][] table1 = {{\"27\", \"Jonah\"}, {\"18\", \"Alan\"}, {\"28\", \"Glory\"},\n        {\"18\", \"Popeye\"}, {\"28\", \"Alan\"}};\n\n        String[][] table2 = {{\"Jonah\", \"Whales\"}, {\"Jonah\", \"Spiders\"},\n        {\"Alan\", \"Ghosts\"}, {\"Alan\", \"Zombies\"}, {\"Glory\", \"Buffy\"},\n        {\"Bob\", \"foo\"}};\n\n        hashJoin(table1, 1, table2, 0).stream()\n                .forEach(r -> System.out.println(Arrays.deepToString(r)));\n    }\n\n    static List<String[][]> hashJoin(String[][] records1, int idx1,\n            String[][] records2, int idx2) {\n\n        List<String[][]> result = new ArrayList<>();\n        Map<String, List<String[]>> map = new HashMap<>();\n\n        for (String[] record : records1) {\n            List<String[]> v = map.getOrDefault(record[idx1], new ArrayList<>());\n            v.add(record);\n            map.put(record[idx1], v);\n        }\n\n        for (String[] record : records2) {\n            List<String[]> lst = map.get(record[idx2]);\n            if (lst != null) {\n                lst.stream().forEach(r -> {\n                    result.add(new String[][]{r, record});\n                });\n            }\n        }\n\n        return result;\n    }\n}\n"}
{"id": 404631, "name": "Permutations with repetitions", "source": "Translate Haskell to Java: import Control.Monad (replicateM)\n\nmain = mapM_ print (replicateM 2 [1,2,3])\n", "target": "import java.util.function.Predicate;\n\npublic class PermutationsWithRepetitions {\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'b', 'c', 'd'};\n        \n        permute(chars, 3, i -> i[0] == 1 && i[1] == 1 && i[2] == 0);\n    }\n\n    static void permute(char[] a, int k, Predicate<int[]> decider) {\n        int n = a.length;\n        if (k < 1 || k > n)\n            throw new IllegalArgumentException(\"Illegal number of positions.\");\n\n        int[] indexes = new int[n];\n        int total = (int) Math.pow(n, k);\n\n        while (total-- > 0) {\n            for (int i = 0; i < n - (n - k); i++)\n                System.out.print(a[indexes[i]]);\n            System.out.println();\n\n            if (decider.test(indexes))\n                break;\n\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] >= n - 1) {\n                    indexes[i] = 0;\n                } else {\n                    indexes[i]++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404632, "name": "Permutations with repetitions", "source": "Translate Haskell to Java: import Control.Monad (replicateM)\n\nmain = mapM_ print (replicateM 2 [1,2,3])\n", "target": "import java.util.function.Predicate;\n\npublic class PermutationsWithRepetitions {\n\n    public static void main(String[] args) {\n        char[] chars = {'a', 'b', 'c', 'd'};\n        \n        permute(chars, 3, i -> i[0] == 1 && i[1] == 1 && i[2] == 0);\n    }\n\n    static void permute(char[] a, int k, Predicate<int[]> decider) {\n        int n = a.length;\n        if (k < 1 || k > n)\n            throw new IllegalArgumentException(\"Illegal number of positions.\");\n\n        int[] indexes = new int[n];\n        int total = (int) Math.pow(n, k);\n\n        while (total-- > 0) {\n            for (int i = 0; i < n - (n - k); i++)\n                System.out.print(a[indexes[i]]);\n            System.out.println();\n\n            if (decider.test(indexes))\n                break;\n\n            for (int i = 0; i < n; i++) {\n                if (indexes[i] >= n - 1) {\n                    indexes[i] = 0;\n                } else {\n                    indexes[i]++;\n                    break;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404633, "name": "Idiomatically determine all the characters that can be used for symbols", "source": "Translate Haskell to Java: import Data.Char\n\n\nisSymbolic ch = isAlphaNum ch || ch `elem` \"_'\"\n\n\nisConId s = and [ not (null s)\n                , isUpper (head s)\n                , all isSymbolic (tail s) ]\n\n\nisVarId s = and [ not (null s)\n                , isLower (head s)\n                , all isSymbolic (tail s)\n                , not (isReserved s) ]\n\n\nisReserved s = elem s [\"case\", \"class\", \"data\", \"default\", \"deriving\", \"do \"\n                      , \"else\", \"foreign\", \"if\", \"import\", \"in\", \"infix \"\n                      , \"infixl\", \"infixr\", \"instance\", \"let\", \"module \"\n                      , \"newtype\", \"of\", \"then\", \"type\", \"where\", \"_\"\n", "target": "import java.util.function.IntPredicate;\nimport java.util.stream.IntStream;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        print(\"Java Identifier start:     \", 0, 0x10FFFF, 72,\n                Character::isJavaIdentifierStart, \"%c\");\n\n        print(\"Java Identifier part:      \", 0, 0x10FFFF, 25,\n                Character::isJavaIdentifierPart, \"[%d]\");\n\n        print(\"Identifier ignorable:      \", 0, 0x10FFFF, 25,\n                Character::isIdentifierIgnorable, \"[%d]\");\n\n        print(\"Unicode Identifier start:  \", 0, 0x10FFFF, 72,\n                Character::isUnicodeIdentifierStart, \"%c\");\n\n        print(\"Unicode Identifier part\u00a0:  \", 0, 0x10FFFF, 25,\n                Character::isUnicodeIdentifierPart, \"[%d]\");\n    }\n\n    static void print(String msg, int start, int end, int limit, \n        IntPredicate p, String fmt) {\n\n        System.out.print(msg);\n        IntStream.rangeClosed(start, end)\n                .filter(p)\n                .limit(limit)\n                .forEach(cp -> System.out.printf(fmt, cp));\n        System.out.println(\"...\");\n    }\n}\n"}
{"id": 404634, "name": "Find largest left truncatable prime in a given base", "source": "Translate Haskell to Java: primesTo100 = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]\n\n\nfind2km :: Integral a => a -> (Int,a)\nfind2km n = f 0 n\n\twhere f k m\n            | r == 1 = (k,m)\n            | otherwise = f (k+1) q\n            where (q,r) = quotRem m 2\n\n\nmillerRabinPrimality :: Integer -> Integer -> Bool\nmillerRabinPrimality n a\n    | a >= n_ = True\n    | b0 == 1 || b0 == n_ = True\n    | otherwise = iter (tail b)\n    where\n        n_ = n-1\n        (k,m) = find2km n_\n        b0 = powMod n a m\n        b = take k $ iterate (squareMod n) b0\n        iter [] = False\n        iter (x:xs)\n            | x == 1 = False\n            | x == n_ = True\n            | otherwise = iter xs\n\n\npow_ :: (Num a, Integral b) => (a->a->a) -> (a->a) -> a -> b -> a\npow_ _ _ _ 0 = 1\npow_ mul sq x_ n_ = f x_ n_ 1\n    where\n        f x n y\n            | n == 1 = x `mul` y\n            | r == 0 = f x2 q y\n            | otherwise = f x2 q (x `mul` y)\n            where\n                (q,r) = quotRem n 2\n                x2 = sq x\n\nmulMod :: Integral a => a -> a -> a -> a\nmulMod a b c = (b * c) `mod` a\nsquareMod :: Integral a => a -> a -> a\nsquareMod a b = (b * b) `rem` a\n\n\npowMod :: Integral a => a -> a -> a -> a\npowMod m = pow_ (mulMod m) (squareMod m)\n\n\n\n\nis_prime w n\n\t| n < 100 = n `elem` primesTo100\n\t| any ((==0).(n`mod`)) primesTo100 = False\n\t| otherwise = all (millerRabinPrimality n) w\n\n\nleft_trunc base = head $ filter (is_prime primesTo100) (reverse hopeful) where\n\thopeful = extend base $ takeWhile (<base) primesTo100 where\n\textend b x = if null d then x else extend (b*base) d where\n\t\td = concatMap addDigit [1..base-1]\n\t\t\n\t\taddDigit a = filter (is_prime [3]) $ map (a*b+) x\n\nmain = mapM_ print $ map (\\x->(x, left_trunc x)) [3..21]\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass LeftTruncatablePrime\n{\n  private static List<BigInteger> getNextLeftTruncatablePrimes(BigInteger n, int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> probablePrimes = new ArrayList<BigInteger>();\n    String baseString = n.equals(BigInteger.ZERO) ? \"\" : n.toString(radix);\n    for (int i = 1; i < radix; i++)\n    {\n      BigInteger p = new BigInteger(Integer.toString(i, radix) + baseString, radix);\n      if (p.isProbablePrime(millerRabinCertainty))\n        probablePrimes.add(p);\n    }\n    return probablePrimes;\n  }\n  \n  public static BigInteger getLargestLeftTruncatablePrime(int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> lastList = null;\n    List<BigInteger> list = getNextLeftTruncatablePrimes(BigInteger.ZERO, radix, millerRabinCertainty);\n    while (!list.isEmpty())\n    {\n      lastList = list;\n      list = new ArrayList<BigInteger>();\n      for (BigInteger n : lastList)\n        list.addAll(getNextLeftTruncatablePrimes(n, radix, millerRabinCertainty));\n    }\n    if (lastList == null)\n      return null;\n    Collections.sort(lastList);\n    return lastList.get(lastList.size() - 1);\n  }\n  \n  public static void main(String[] args)\n  {\n    if (args.length != 2) {\n      System.err.println(\"There must be exactly two command line arguments.\");\n      return;\n    }\n    int maxRadix;\n    try {\n      maxRadix = Integer.parseInt(args[0]);\n      if (maxRadix < 3) throw new NumberFormatException(); \n    } catch (NumberFormatException e) {\n      System.err.println(\"Radix must be an integer greater than 2.\");\n      return;\n    }\n    int millerRabinCertainty;\n    try {\n      millerRabinCertainty = Integer.parseInt(args[1]);\n    } catch (NumberFormatException e) {\n      System.err.println(\"Miiller-Rabin Certainty must be an integer.\");\n      return;\n    }  \n    for (int radix = 3; radix <= maxRadix; radix++)\n    {\n      BigInteger largest = getLargestLeftTruncatablePrime(radix, millerRabinCertainty);\n      System.out.print(\"n=\" + radix + \": \");\n      if (largest == null)\n        System.out.println(\"No left-truncatable prime\");\n      else\n        System.out.println(largest + \" (in base \" + radix + \"): \" + largest.toString(radix));\n    }\n  }\n  \n}\n"}
{"id": 404635, "name": "24 game_Solve", "source": "Translate Haskell to Java: import Data.List\nimport Data.Ratio\nimport Control.Monad\nimport System.Environment (getArgs)\n\ndata Expr = Constant Rational |\n    Expr :+ Expr | Expr :- Expr |\n    Expr :* Expr | Expr :/ Expr\n    deriving (Eq)\n\nops = [(:+), (:-), (:*), (:/)]\n\ninstance Show Expr where\n    show (Constant x) = show $ numerator x\n      \n    show (a :+ b)     = strexp \"+\" a b\n    show (a :- b)     = strexp \"-\" a b\n    show (a :* b)     = strexp \"*\" a b\n    show (a :/ b)     = strexp \"/\" a b\n\nstrexp :: String -> Expr -> Expr -> String\nstrexp op a b = \"(\" ++ show a ++ \" \" ++ op ++ \" \" ++ show b ++ \")\"\n\ntemplates :: [[Expr] -> Expr]\ntemplates = do\n    op1 <- ops\n    op2 <- ops\n    op3 <- ops\n    [\\[a, b, c, d] -> op1 a $ op2 b $ op3 c d,\n     \\[a, b, c, d] -> op1 (op2 a b) $ op3 c d,\n     \\[a, b, c, d] -> op1 a $ op2 (op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 a $ op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 (op3 a b) c) d]\n\neval :: Expr -> Maybe Rational\neval (Constant c) = Just c\neval (a :+ b)     = liftM2 (+) (eval a) (eval b)\neval (a :- b)     = liftM2 (-) (eval a) (eval b)\neval (a :* b)     = liftM2 (*) (eval a) (eval b)\neval (a :/ b)     = do\n    denom <- eval b\n    guard $ denom /= 0\n    liftM (/ denom) $ eval a\n\nsolve :: Rational -> [Rational] -> [Expr]\nsolve target r4 = filter (maybe False (== target) . eval) $\n    liftM2 ($) templates $\n    nub $ permutations $ map Constant r4 \n\nmain = getArgs >>= mapM_ print . solve 24 . map (toEnum . read)\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 404636, "name": "24 game_Solve", "source": "Translate Haskell to Java: import Data.List\nimport Data.Ratio\nimport Control.Monad\nimport System.Environment (getArgs)\n\ndata Expr = Constant Rational |\n    Expr :+ Expr | Expr :- Expr |\n    Expr :* Expr | Expr :/ Expr\n    deriving (Eq)\n\nops = [(:+), (:-), (:*), (:/)]\n\ninstance Show Expr where\n    show (Constant x) = show $ numerator x\n      \n    show (a :+ b)     = strexp \"+\" a b\n    show (a :- b)     = strexp \"-\" a b\n    show (a :* b)     = strexp \"*\" a b\n    show (a :/ b)     = strexp \"/\" a b\n\nstrexp :: String -> Expr -> Expr -> String\nstrexp op a b = \"(\" ++ show a ++ \" \" ++ op ++ \" \" ++ show b ++ \")\"\n\ntemplates :: [[Expr] -> Expr]\ntemplates = do\n    op1 <- ops\n    op2 <- ops\n    op3 <- ops\n    [\\[a, b, c, d] -> op1 a $ op2 b $ op3 c d,\n     \\[a, b, c, d] -> op1 (op2 a b) $ op3 c d,\n     \\[a, b, c, d] -> op1 a $ op2 (op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 a $ op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 (op3 a b) c) d]\n\neval :: Expr -> Maybe Rational\neval (Constant c) = Just c\neval (a :+ b)     = liftM2 (+) (eval a) (eval b)\neval (a :- b)     = liftM2 (-) (eval a) (eval b)\neval (a :* b)     = liftM2 (*) (eval a) (eval b)\neval (a :/ b)     = do\n    denom <- eval b\n    guard $ denom /= 0\n    liftM (/ denom) $ eval a\n\nsolve :: Rational -> [Rational] -> [Expr]\nsolve target r4 = filter (maybe False (== target) . eval) $\n    liftM2 ($) templates $\n    nub $ permutations $ map Constant r4 \n\nmain = getArgs >>= mapM_ print . solve 24 . map (toEnum . read)\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 404637, "name": "Hough transform", "source": "Translate Haskell to Java: import Control.Monad (forM_, when)\nimport Data.Array ((!))\nimport Data.Array.ST (newArray, writeArray, readArray, runSTArray)\nimport qualified Data.Foldable as F (maximum)\nimport System.Environment (getArgs, getProgName)\n\n\nimport Codec.Picture\n       (DynamicImage(ImageRGB8, ImageRGBA8), Image, PixelRGB8(PixelRGB8),\n        PixelRGBA8(PixelRGBA8), imageWidth, imageHeight, pixelAt,\n        generateImage, readImage, pixelMap, savePngImage)\nimport Codec.Picture.Types (extractLumaPlane, dropTransparency)\n\ndot\n  :: Num a\n  => (a, a) -> (a, a) -> a\ndot (x1, y1) (x2, y2) = x1 * x2 + y1 * y2\n\nmag\n  :: Floating a\n  => (a, a) -> a\nmag a = sqrt $ dot a a\n\nsub\n  :: Num a\n  => (a, a) -> (a, a) -> (a, a)\nsub (x1, y1) (x2, y2) = (x1 - x2, y1 - y2)\n\nfromIntegralP\n  :: (Integral a, Num b)\n  => (a, a) -> (b, b)\nfromIntegralP (x, y) = (fromIntegral x, fromIntegral y)\n\n\nhough :: Image PixelRGB8 -> Int -> Int -> Image PixelRGB8\nhough image thetaSize distSize = hImage\n  where\n    width = imageWidth image\n    height = imageHeight image\n    wMax = width - 1\n    hMax = height - 1\n    xCenter = wMax `div` 2\n    yCenter = hMax `div` 2\n    lumaMap = extractLumaPlane image\n    gradient x y =\n      let orig = pixelAt lumaMap x y\n          x_ = pixelAt lumaMap (min (x + 1) wMax) y\n          y_ = pixelAt lumaMap x (min (y + 1) hMax)\n      in fromIntegralP (orig - x_, orig - y_)\n    gradMap =\n      [ ((x, y), gradient x y)\n      | x <- [0 .. wMax] \n      , y <- [0 .. hMax] ]\n    \n    distMax :: Double\n    distMax = (sqrt . fromIntegral $ height ^ 2 + width ^ 2) / 2\n    \n    accBin =\n      runSTArray $\n      do arr <- newArray ((0, 0), (thetaSize, distSize)) 0\n         forM_ gradMap $\n           \\((x, y), grad) -> do\n             let (x_, y_) = fromIntegralP $ (xCenter, yCenter) `sub` (x, y)\n             when (mag grad > 127) $\n               forM_ [0 .. thetaSize] $\n               \\theta -> do\n                 let theta_ =\n                       fromIntegral theta * 360 / fromIntegral thetaSize / 180 *\n                       pi :: Double\n                     dist = cos theta_ * x_ + sin theta_ * y_\n                     dist_ = truncate $ dist * fromIntegral distSize / distMax\n                     idx = (theta, dist_)\n                 when (dist_ >= 0 && dist_ < distSize) $\n                   do old <- readArray arr idx\n                      writeArray arr idx $ old + 1\n         return arr\n    maxAcc = F.maximum accBin\n    \n    hTransform x y =\n      let l = 255 - truncate ((accBin ! (x, y)) / maxAcc * 255)\n      in PixelRGB8 l l l\n    hImage = generateImage hTransform thetaSize distSize\n\nhoughIO :: FilePath -> FilePath -> Int -> Int -> IO ()\nhoughIO path outpath thetaSize distSize = do\n  image <- readImage path\n  case image of\n    Left err -> putStrLn err\n    Right (ImageRGB8 image_) -> doImage image_\n    Right (ImageRGBA8 image_) -> doImage $ pixelMap dropTransparency image_\n    _ -> putStrLn \"Expecting RGB8 or RGBA8 image\"\n  where\n    doImage image = do\n      let houghImage = hough image thetaSize distSize\n      savePngImage outpath $ ImageRGB8 houghImage\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  prog <- getProgName\n  case args of\n    [path, outpath, thetaSize, distSize] ->\n      houghIO path outpath (read thetaSize) (read distSize)\n    _ ->\n      putStrLn $\n      \"Usage: \" ++ prog ++ \" <image-file> <out-file.png> <width> <height>\"\n", "target": "import java.awt.image.*;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.*;\n\npublic class HoughTransform\n{\n  public static ArrayData houghTransform(ArrayData inputData, int thetaAxisSize, int rAxisSize, int minContrast)\n  {\n    int width = inputData.width;\n    int height = inputData.height;\n    int maxRadius = (int)Math.ceil(Math.hypot(width, height));\n    int halfRAxisSize = rAxisSize >>> 1;\n    ArrayData outputData = new ArrayData(thetaAxisSize, rAxisSize);\n    \n    \n    double[] sinTable = new double[thetaAxisSize];\n    double[] cosTable = new double[thetaAxisSize];\n    for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n    {\n      double thetaRadians = theta * Math.PI / thetaAxisSize;\n      sinTable[theta] = Math.sin(thetaRadians);\n      cosTable[theta] = Math.cos(thetaRadians);\n    }\n    \n    for (int y = height - 1; y >= 0; y--)\n    {\n      for (int x = width - 1; x >= 0; x--)\n      {\n        if (inputData.contrast(x, y, minContrast))\n        {\n          for (int theta = thetaAxisSize - 1; theta >= 0; theta--)\n          {\n            double r = cosTable[theta] * x + sinTable[theta] * y;\n            int rScaled = (int)Math.round(r * halfRAxisSize / maxRadius) + halfRAxisSize;\n            outputData.accumulate(theta, rScaled, 1);\n          }\n        }\n      }\n    }\n    return outputData;\n  }\n  \n  public static class ArrayData\n  {\n    public final int[] dataArray;\n    public final int width;\n    public final int height;\n    \n    public ArrayData(int width, int height)\n    {\n      this(new int[width * height], width, height);\n    }\n    \n    public ArrayData(int[] dataArray, int width, int height)\n    {\n      this.dataArray = dataArray;\n      this.width = width;\n      this.height = height;\n    }\n    \n    public int get(int x, int y)\n    {  return dataArray[y * width + x];  }\n    \n    public void set(int x, int y, int value)\n    {  dataArray[y * width + x] = value;  }\n    \n    public void accumulate(int x, int y, int delta)\n    {  set(x, y, get(x, y) + delta);  }\n    \n    public boolean contrast(int x, int y, int minContrast)\n    {\n      int centerValue = get(x, y);\n      for (int i = 8; i >= 0; i--)\n      {\n        if (i == 4)\n          continue;\n        int newx = x + (i % 3) - 1;\n        int newy = y + (i / 3) - 1;\n        if ((newx < 0) || (newx >= width) || (newy < 0) || (newy >= height))\n          continue;\n        if (Math.abs(get(newx, newy) - centerValue) >= minContrast)\n          return true;\n      }\n      return false;\n    }\n    \n    public int getMax()\n    {\n      int max = dataArray[0];\n      for (int i = width * height - 1; i > 0; i--)\n        if (dataArray[i] > max)\n          max = dataArray[i];\n      return max;\n    }\n  }\n  \n  public static ArrayData getArrayDataFromImage(String filename) throws IOException\n  {\n    BufferedImage inputImage = ImageIO.read(new File(filename));\n    int width = inputImage.getWidth();\n    int height = inputImage.getHeight();\n    int[] rgbData = inputImage.getRGB(0, 0, width, height, null, 0, width);\n    ArrayData arrayData = new ArrayData(width, height);\n    \n    for (int y = 0; y < height; y++)\n    {\n      for (int x = 0; x < width; x++)\n      {\n        int rgbValue = rgbData[y * width + x];\n        rgbValue = (int)(((rgbValue & 0xFF0000) >>> 16) * 0.30 + ((rgbValue & 0xFF00) >>> 8) * 0.59 + (rgbValue & 0xFF) * 0.11);\n        arrayData.set(x, height - 1 - y, rgbValue);\n      }\n    }\n    return arrayData;\n  }\n  \n  public static void writeOutputImage(String filename, ArrayData arrayData) throws IOException\n  {\n    int max = arrayData.getMax();\n    BufferedImage outputImage = new BufferedImage(arrayData.width, arrayData.height, BufferedImage.TYPE_INT_ARGB);\n    for (int y = 0; y < arrayData.height; y++)\n    {\n      for (int x = 0; x < arrayData.width; x++)\n      {\n        int n = Math.min((int)Math.round(arrayData.get(x, y) * 255.0 / max), 255);\n        outputImage.setRGB(x, arrayData.height - 1 - y, (n << 16) | (n << 8) | 0x90 | -0x01000000);\n      }\n    }\n    ImageIO.write(outputImage, \"PNG\", new File(filename));\n    return;\n  }\n  \n  public static void main(String[] args) throws IOException\n  {\n    ArrayData inputData = getArrayDataFromImage(args[0]);\n    int minContrast = (args.length >= 4) ? 64 : Integer.parseInt(args[4]);\n    ArrayData outputData = houghTransform(inputData, Integer.parseInt(args[2]), Integer.parseInt(args[3]), minContrast);\n    writeOutputImage(args[1], outputData);\n    return;\n  }\n}\n"}
{"id": 404638, "name": "Tonelli-Shanks algorithm", "source": "Translate Haskell to Java: import Data.List (genericTake, genericLength)\nimport Data.Bits (shiftR)\n\npowMod :: Integer -> Integer -> Integer -> Integer\npowMod m b e = go b e 1\n  where\n    go b e r\n      | e == 0 = r\n      | odd e  = go ((b*b) `mod` m) (e `div` 2) ((r*b) `mod` m)\n      | even e = go ((b*b) `mod` m) (e `div` 2) r \n\nlegendre :: Integer -> Integer -> Integer\nlegendre a p = powMod p a ((p - 1) `div` 2) \n\ntonelli :: Integer -> Integer -> Maybe (Integer, Integer)\ntonelli n p | legendre n p /= 1 = Nothing\ntonelli n p =\n  let s = length $ takeWhile even $ iterate (`div` 2) (p-1)\n      q = shiftR (p-1) s\n  in if s == 1\n    then let r = powMod p n ((p+1) `div` 4)\n         in Just (r, p - r)\n    else let z = (2 +) . genericLength\n               $ takeWhile (\\i -> p - 1 /= legendre i p)\n               $ [2..p-1]\n         in loop s\n            ( powMod p z q )\n            ( powMod p n $ (q+1) `div` 2 )\n            ( powMod p n q )\n  where\n    loop m c r t\n      | (t - 1) `mod` p == 0 = Just (r, p - r)\n      | otherwise =\n        let i = (1 +) . genericLength . genericTake (m - 2)\n              $ takeWhile (\\t2 -> (t2 - 1) `mod` p /= 0)\n              $ iterate (\\t2 -> (t2*t2) `mod` p)\n              $ (t*t) `mod` p\n            b = powMod p c (2^(m - i - 1))\n            r' = (r*b)  `mod` p\n            c' = (b*b)  `mod` p\n            t' = (t*c') `mod` p\n        in loop i c' r' t'\n", "target": "import java.math.BigInteger;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class TonelliShanks {\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TEN = BigInteger.TEN;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\n\n    private static class Solution {\n        private BigInteger root1;\n        private BigInteger root2;\n        private boolean exists;\n\n        Solution(BigInteger root1, BigInteger root2, boolean exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n    }\n\n    private static Solution ts(Long n, Long p) {\n        return ts(BigInteger.valueOf(n), BigInteger.valueOf(p));\n    }\n\n    private static Solution ts(BigInteger n, BigInteger p) {\n        BiFunction<BigInteger, BigInteger, BigInteger> powModP = (BigInteger a, BigInteger e) -> a.modPow(e, p);\n        Function<BigInteger, BigInteger> ls = (BigInteger a) -> powModP.apply(a, p.subtract(ONE).divide(TWO));\n\n        if (!ls.apply(n).equals(ONE)) return new Solution(ZERO, ZERO, false);\n\n        BigInteger q = p.subtract(ONE);\n        BigInteger ss = ZERO;\n        while (q.and(ONE).equals(ZERO)) {\n            ss = ss.add(ONE);\n            q = q.shiftRight(1);\n        }\n\n        if (ss.equals(ONE)) {\n            BigInteger r1 = powModP.apply(n, p.add(ONE).divide(FOUR));\n            return new Solution(r1, p.subtract(r1), true);\n        }\n\n        BigInteger z = TWO;\n        while (!ls.apply(z).equals(p.subtract(ONE))) z = z.add(ONE);\n        BigInteger c = powModP.apply(z, q);\n        BigInteger r = powModP.apply(n, q.add(ONE).divide(TWO));\n        BigInteger t = powModP.apply(n, q);\n        BigInteger m = ss;\n\n        while (true) {\n            if (t.equals(ONE)) return new Solution(r, p.subtract(r), true);\n            BigInteger i = ZERO;\n            BigInteger zz = t;\n            while (!zz.equals(BigInteger.ONE) && i.compareTo(m.subtract(ONE)) < 0) {\n                zz = zz.multiply(zz).mod(p);\n                i = i.add(ONE);\n            }\n            BigInteger b = c;\n            BigInteger e = m.subtract(i).subtract(ONE);\n            while (e.compareTo(ZERO) > 0) {\n                b = b.multiply(b).mod(p);\n                e = e.subtract(ONE);\n            }\n            r = r.multiply(b).mod(p);\n            c = b.multiply(b).mod(p);\n            t = t.multiply(c).mod(p);\n            m = i;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Long, Long>> pairs = List.of(\n            Map.entry(10L, 13L),\n            Map.entry(56L, 101L),\n            Map.entry(1030L, 10009L),\n            Map.entry(1032L, 10009L),\n            Map.entry(44402L, 100049L),\n            Map.entry(665820697L, 1000000009L),\n            Map.entry(881398088036L, 1000000000039L)\n        );\n\n        for (Map.Entry<Long, Long> pair : pairs) {\n            Solution sol = ts(pair.getKey(), pair.getValue());\n            System.out.printf(\"n = %s\\n\", pair.getKey());\n            System.out.printf(\"p = %s\\n\", pair.getValue());\n            if (sol.exists) {\n                System.out.printf(\"root1 = %s\\n\", sol.root1);\n                System.out.printf(\"root2 = %s\\n\", sol.root2);\n            } else {\n                System.out.println(\"No solution exists\");\n            }\n            System.out.println();\n        }\n\n        BigInteger bn = new BigInteger(\"41660815127637347468140745042827704103445750172002\");\n        BigInteger bp = TEN.pow(50).add(BigInteger.valueOf(577));\n        Solution sol = ts(bn, bp);\n        System.out.printf(\"n = %s\\n\", bn);\n        System.out.printf(\"p = %s\\n\", bp);\n        if (sol.exists) {\n            System.out.printf(\"root1 = %s\\n\", sol.root1);\n            System.out.printf(\"root2 = %s\\n\", sol.root2);\n        } else {\n            System.out.println(\"No solution exists\");\n        }\n    }\n}\n"}
{"id": 404639, "name": "Tonelli-Shanks algorithm", "source": "Translate Haskell to Java: import Data.List (genericTake, genericLength)\nimport Data.Bits (shiftR)\n\npowMod :: Integer -> Integer -> Integer -> Integer\npowMod m b e = go b e 1\n  where\n    go b e r\n      | e == 0 = r\n      | odd e  = go ((b*b) `mod` m) (e `div` 2) ((r*b) `mod` m)\n      | even e = go ((b*b) `mod` m) (e `div` 2) r \n\nlegendre :: Integer -> Integer -> Integer\nlegendre a p = powMod p a ((p - 1) `div` 2) \n\ntonelli :: Integer -> Integer -> Maybe (Integer, Integer)\ntonelli n p | legendre n p /= 1 = Nothing\ntonelli n p =\n  let s = length $ takeWhile even $ iterate (`div` 2) (p-1)\n      q = shiftR (p-1) s\n  in if s == 1\n    then let r = powMod p n ((p+1) `div` 4)\n         in Just (r, p - r)\n    else let z = (2 +) . genericLength\n               $ takeWhile (\\i -> p - 1 /= legendre i p)\n               $ [2..p-1]\n         in loop s\n            ( powMod p z q )\n            ( powMod p n $ (q+1) `div` 2 )\n            ( powMod p n q )\n  where\n    loop m c r t\n      | (t - 1) `mod` p == 0 = Just (r, p - r)\n      | otherwise =\n        let i = (1 +) . genericLength . genericTake (m - 2)\n              $ takeWhile (\\t2 -> (t2 - 1) `mod` p /= 0)\n              $ iterate (\\t2 -> (t2*t2) `mod` p)\n              $ (t*t) `mod` p\n            b = powMod p c (2^(m - i - 1))\n            r' = (r*b)  `mod` p\n            c' = (b*b)  `mod` p\n            t' = (t*c') `mod` p\n        in loop i c' r' t'\n", "target": "import java.math.BigInteger;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\n\npublic class TonelliShanks {\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TEN = BigInteger.TEN;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\n\n    private static class Solution {\n        private BigInteger root1;\n        private BigInteger root2;\n        private boolean exists;\n\n        Solution(BigInteger root1, BigInteger root2, boolean exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n    }\n\n    private static Solution ts(Long n, Long p) {\n        return ts(BigInteger.valueOf(n), BigInteger.valueOf(p));\n    }\n\n    private static Solution ts(BigInteger n, BigInteger p) {\n        BiFunction<BigInteger, BigInteger, BigInteger> powModP = (BigInteger a, BigInteger e) -> a.modPow(e, p);\n        Function<BigInteger, BigInteger> ls = (BigInteger a) -> powModP.apply(a, p.subtract(ONE).divide(TWO));\n\n        if (!ls.apply(n).equals(ONE)) return new Solution(ZERO, ZERO, false);\n\n        BigInteger q = p.subtract(ONE);\n        BigInteger ss = ZERO;\n        while (q.and(ONE).equals(ZERO)) {\n            ss = ss.add(ONE);\n            q = q.shiftRight(1);\n        }\n\n        if (ss.equals(ONE)) {\n            BigInteger r1 = powModP.apply(n, p.add(ONE).divide(FOUR));\n            return new Solution(r1, p.subtract(r1), true);\n        }\n\n        BigInteger z = TWO;\n        while (!ls.apply(z).equals(p.subtract(ONE))) z = z.add(ONE);\n        BigInteger c = powModP.apply(z, q);\n        BigInteger r = powModP.apply(n, q.add(ONE).divide(TWO));\n        BigInteger t = powModP.apply(n, q);\n        BigInteger m = ss;\n\n        while (true) {\n            if (t.equals(ONE)) return new Solution(r, p.subtract(r), true);\n            BigInteger i = ZERO;\n            BigInteger zz = t;\n            while (!zz.equals(BigInteger.ONE) && i.compareTo(m.subtract(ONE)) < 0) {\n                zz = zz.multiply(zz).mod(p);\n                i = i.add(ONE);\n            }\n            BigInteger b = c;\n            BigInteger e = m.subtract(i).subtract(ONE);\n            while (e.compareTo(ZERO) > 0) {\n                b = b.multiply(b).mod(p);\n                e = e.subtract(ONE);\n            }\n            r = r.multiply(b).mod(p);\n            c = b.multiply(b).mod(p);\n            t = t.multiply(c).mod(p);\n            m = i;\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Map.Entry<Long, Long>> pairs = List.of(\n            Map.entry(10L, 13L),\n            Map.entry(56L, 101L),\n            Map.entry(1030L, 10009L),\n            Map.entry(1032L, 10009L),\n            Map.entry(44402L, 100049L),\n            Map.entry(665820697L, 1000000009L),\n            Map.entry(881398088036L, 1000000000039L)\n        );\n\n        for (Map.Entry<Long, Long> pair : pairs) {\n            Solution sol = ts(pair.getKey(), pair.getValue());\n            System.out.printf(\"n = %s\\n\", pair.getKey());\n            System.out.printf(\"p = %s\\n\", pair.getValue());\n            if (sol.exists) {\n                System.out.printf(\"root1 = %s\\n\", sol.root1);\n                System.out.printf(\"root2 = %s\\n\", sol.root2);\n            } else {\n                System.out.println(\"No solution exists\");\n            }\n            System.out.println();\n        }\n\n        BigInteger bn = new BigInteger(\"41660815127637347468140745042827704103445750172002\");\n        BigInteger bp = TEN.pow(50).add(BigInteger.valueOf(577));\n        Solution sol = ts(bn, bp);\n        System.out.printf(\"n = %s\\n\", bn);\n        System.out.printf(\"p = %s\\n\", bp);\n        if (sol.exists) {\n            System.out.printf(\"root1 = %s\\n\", sol.root1);\n            System.out.printf(\"root2 = %s\\n\", sol.root2);\n        } else {\n            System.out.println(\"No solution exists\");\n        }\n    }\n}\n"}
{"id": 404640, "name": "Doubly-linked list_Definition", "source": "Translate Haskell to Java: import qualified Data.Map as M\n\ntype NodeID = Maybe Rational\ndata Node a = Node\n   {vNode :: a,\n    pNode, nNode :: NodeID}\ntype DLList a = M.Map Rational (Node a)\n\nempty = M.empty\n\nsingleton a = M.singleton 0 $ Node a Nothing Nothing\n\nfcons :: a -> DLList a -> DLList a\nfcons a list | M.null list = singleton a\n             | otherwise   = M.insert newid new $\n                             M.insert firstid changed list\n  where (firstid, Node firstval _ secondid) = M.findMin list\n        newid = firstid - 1\n        new     = Node a        Nothing      (Just firstid)\n        changed = Node firstval (Just newid) secondid\n\nrcons :: a -> DLList a -> DLList a\nrcons a list | M.null list = singleton a\n             | otherwise   = M.insert lastid changed $\n                             M.insert newid new list\n  where (lastid, Node lastval penultimateid _) = M.findMax list\n        newid = lastid + 1\n        changed = Node lastval penultimateid (Just newid)\n        new     = Node a       (Just lastid) Nothing\n\nmcons :: a -> Node a -> Node a -> DLList a -> DLList a\nmcons a n1 n2 = M.insert n1id left .\n    M.insert midid mid . M.insert n2id right\n  where Node n1val farleftid   (Just n2id) = n1\n        Node n2val (Just n1id) farrightid  = n2\n        midid = (n1id + n2id) / 2   \n        mid = Node a (Just n1id) (Just n2id)\n        left  = Node n1val farleftid    (Just midid)\n        right = Node n2val (Just midid) farrightid\n\nfirstNode :: DLList a -> Node a\nfirstNode = snd . M.findMin\n\nlastNode :: DLList a -> Node a\nlastNode = snd . M.findMax\n\nnextNode :: DLList a -> Node a -> Maybe (Node a)\nnextNode l n = nNode n >>= flip M.lookup l\n\nprevNode :: DLList a -> Node a -> Maybe (Node a)\nprevNode l n = pNode n >>= flip M.lookup l\n\nfromList = foldr fcons empty\n\ntoList = map vNode . M.elems\n", "target": "import java.util.LinkedList;\n\npublic class DoublyLinkedList {\n   \n    public static void main(String[] args) {\n        LinkedList<String> list = new LinkedList<String>();\n        list.addFirst(\"Add First\");\n        list.addLast(\"Add Last 1\");\n        list.addLast(\"Add Last 2\");\n        list.addLast(\"Add Last 1\");\n        traverseList(list);\n        \n        list.removeFirstOccurrence(\"Add Last 1\");\n        traverseList(list);\n    }\n    \n    private static void traverseList(LinkedList<String> list) {\n        System.out.println(\"Traverse List:\");\n        for ( int i = 0 ; i < list.size() ; i++ ) {\n            System.out.printf(\"Element number %d - Element value = '%s'%n\", i, list.get(i));\n        }\n        System.out.println();\n    }\n    \n}\n"}
{"id": 404641, "name": "Truth table", "source": "Translate Haskell to Java: import Control.Monad (mapM, foldM, forever)\nimport Data.List (unwords, unlines, nub)\nimport Data.Maybe (fromJust)\n\ntruthTable expr = let\n    tokens = words expr\n    operators = [\"&\", \"|\", \"!\", \"^\", \"=>\"]\n    variables = nub $ filter (not . (`elem` operators)) tokens\n    table = zip variables <$> mapM (const [True,False]) variables\n    results = map (\\r -> (map snd r) ++ (calculate tokens) r) table\n    header = variables ++ [\"result\"]\n    in\n      showTable $ header : map (map show) results\n\n\n\n\ncalculate :: [String] -> [(String, Bool)] -> [Bool]\ncalculate = foldM interprete []\n  where\n    interprete (x:y:s) \"&\"  = (: s) <$> pure (x && y)\n    interprete (x:y:s) \"|\"  = (: s) <$> pure (x || y)\n    interprete (x:y:s) \"^\"  = (: s) <$> pure (x /= y)\n    interprete (x:y:s) \"=>\" = (: s) <$> pure (not y || x)\n    interprete (x:s)   \"!\"  = (: s) <$> pure (not x)\n    interprete s var        = (: s) <$> fromJust . lookup var\n \n\nshowTable tbl = unlines $ map (unwords . map align) tbl\n  where\n    align txt = take colWidth $ txt ++ repeat ' '\n    colWidth = max 6 $ maximum $ map length (head tbl)\n \nmain = forever $ getLine >>= putStrLn . truthTable\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Stack;\n\npublic class TruthTable {\n    public static void main( final String... args ) {\n        System.out.println( new TruthTable( args ) );\n    }\n\n    private interface Operator {\n        boolean evaluate( Stack<Boolean> s );\n    }\n\n    \n    private static final Map<String,Operator> operators = new HashMap<String,Operator>() {{\n        \n        put( \"&\", stack -> Boolean.logicalAnd( stack.pop(), stack.pop() ) );\n        put( \"|\", stack -> Boolean.logicalOr( stack.pop(), stack.pop() ) );\n        put( \"!\", stack -> ! stack.pop() );\n        put( \"^\", stack -> ! stack.pop().equals ( stack.pop() ) );\n    }};\n\n    private final List<String> variables;\n    private final String[]     symbols;\n\n    \n    public TruthTable( final String... symbols ) {\n        final Set<String> variables = new LinkedHashSet<>();\n\n        for ( final String symbol : symbols ) {\n            if ( ! operators.containsKey( symbol ) ) {\n                variables.add( symbol );\n            }\n        }\n        this.variables = new ArrayList<>( variables );\n        this.symbols = symbols;\n    }\n\n    @Override\n    public String toString () {\n        final StringBuilder result = new StringBuilder();\n\n        for ( final String variable : variables ) {\n            result.append( variable ).append( ' ' );\n        }\n        result.append( ' ' );\n        for ( final String symbol : symbols ) {\n            result.append( symbol ).append ( ' ' );\n        }\n        result.append( '\\n' );\n        for ( final List<Boolean> values : enumerate( variables.size () ) ) {\n            final Iterator<String> i = variables.iterator();\n\n            for ( final Boolean value : values ) {\n                result.append(\n                    String.format(\n                        \"%-\" + i.next().length() + \"c \",\n                        value ? 'T' : 'F'\n                    )\n                );\n            }\n            result.append( ' ' )\n                .append( evaluate( values ) ? 'T' : 'F' )\n                .append( '\\n' );\n        }\n\n        return result.toString ();\n    }\n\n    \n    private static List<List<Boolean>> enumerate( final int size ) {\n        if ( 1 == size )\n            return new ArrayList<List<Boolean>>() {{\n                add( new ArrayList<Boolean>() {{ add(false); }} );\n                add( new ArrayList<Boolean>() {{ add(true);  }} );\n            }};\n\n        return new ArrayList<List<Boolean>>() {{\n            for ( final List<Boolean> head : enumerate( size - 1 ) ) {\n                add( new ArrayList<Boolean>( head ) {{ add(false); }} );\n                add( new ArrayList<Boolean>( head ) {{ add(true);  }} );\n            }\n        }};\n    }\n\n    \n    private boolean evaluate( final List<Boolean> enumeration ) {\n        final Iterator<Boolean>   i      = enumeration.iterator();\n        final Map<String,Boolean> values = new HashMap<>();\n        final Stack<Boolean>      stack  = new Stack<>();\n\n        variables.forEach ( v -> values.put( v, i.next() ) );\n        for ( final String symbol : symbols ) {\n            final Operator op = operators.get ( symbol );\n\n            \n            stack.push(\n                null == op\n                    ? values.get ( symbol )\n                    : op.evaluate ( stack )\n            );\n        }\n        return stack.pop();\n    }\n}\n"}
{"id": 404642, "name": "Truth table", "source": "Translate Haskell to Java: import Control.Monad (mapM, foldM, forever)\nimport Data.List (unwords, unlines, nub)\nimport Data.Maybe (fromJust)\n\ntruthTable expr = let\n    tokens = words expr\n    operators = [\"&\", \"|\", \"!\", \"^\", \"=>\"]\n    variables = nub $ filter (not . (`elem` operators)) tokens\n    table = zip variables <$> mapM (const [True,False]) variables\n    results = map (\\r -> (map snd r) ++ (calculate tokens) r) table\n    header = variables ++ [\"result\"]\n    in\n      showTable $ header : map (map show) results\n\n\n\n\ncalculate :: [String] -> [(String, Bool)] -> [Bool]\ncalculate = foldM interprete []\n  where\n    interprete (x:y:s) \"&\"  = (: s) <$> pure (x && y)\n    interprete (x:y:s) \"|\"  = (: s) <$> pure (x || y)\n    interprete (x:y:s) \"^\"  = (: s) <$> pure (x /= y)\n    interprete (x:y:s) \"=>\" = (: s) <$> pure (not y || x)\n    interprete (x:s)   \"!\"  = (: s) <$> pure (not x)\n    interprete s var        = (: s) <$> fromJust . lookup var\n \n\nshowTable tbl = unlines $ map (unwords . map align) tbl\n  where\n    align txt = take colWidth $ txt ++ repeat ' '\n    colWidth = max 6 $ maximum $ map length (head tbl)\n \nmain = forever $ getLine >>= putStrLn . truthTable\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.Stack;\n\npublic class TruthTable {\n    public static void main( final String... args ) {\n        System.out.println( new TruthTable( args ) );\n    }\n\n    private interface Operator {\n        boolean evaluate( Stack<Boolean> s );\n    }\n\n    \n    private static final Map<String,Operator> operators = new HashMap<String,Operator>() {{\n        \n        put( \"&\", stack -> Boolean.logicalAnd( stack.pop(), stack.pop() ) );\n        put( \"|\", stack -> Boolean.logicalOr( stack.pop(), stack.pop() ) );\n        put( \"!\", stack -> ! stack.pop() );\n        put( \"^\", stack -> ! stack.pop().equals ( stack.pop() ) );\n    }};\n\n    private final List<String> variables;\n    private final String[]     symbols;\n\n    \n    public TruthTable( final String... symbols ) {\n        final Set<String> variables = new LinkedHashSet<>();\n\n        for ( final String symbol : symbols ) {\n            if ( ! operators.containsKey( symbol ) ) {\n                variables.add( symbol );\n            }\n        }\n        this.variables = new ArrayList<>( variables );\n        this.symbols = symbols;\n    }\n\n    @Override\n    public String toString () {\n        final StringBuilder result = new StringBuilder();\n\n        for ( final String variable : variables ) {\n            result.append( variable ).append( ' ' );\n        }\n        result.append( ' ' );\n        for ( final String symbol : symbols ) {\n            result.append( symbol ).append ( ' ' );\n        }\n        result.append( '\\n' );\n        for ( final List<Boolean> values : enumerate( variables.size () ) ) {\n            final Iterator<String> i = variables.iterator();\n\n            for ( final Boolean value : values ) {\n                result.append(\n                    String.format(\n                        \"%-\" + i.next().length() + \"c \",\n                        value ? 'T' : 'F'\n                    )\n                );\n            }\n            result.append( ' ' )\n                .append( evaluate( values ) ? 'T' : 'F' )\n                .append( '\\n' );\n        }\n\n        return result.toString ();\n    }\n\n    \n    private static List<List<Boolean>> enumerate( final int size ) {\n        if ( 1 == size )\n            return new ArrayList<List<Boolean>>() {{\n                add( new ArrayList<Boolean>() {{ add(false); }} );\n                add( new ArrayList<Boolean>() {{ add(true);  }} );\n            }};\n\n        return new ArrayList<List<Boolean>>() {{\n            for ( final List<Boolean> head : enumerate( size - 1 ) ) {\n                add( new ArrayList<Boolean>( head ) {{ add(false); }} );\n                add( new ArrayList<Boolean>( head ) {{ add(true);  }} );\n            }\n        }};\n    }\n\n    \n    private boolean evaluate( final List<Boolean> enumeration ) {\n        final Iterator<Boolean>   i      = enumeration.iterator();\n        final Map<String,Boolean> values = new HashMap<>();\n        final Stack<Boolean>      stack  = new Stack<>();\n\n        variables.forEach ( v -> values.put( v, i.next() ) );\n        for ( final String symbol : symbols ) {\n            final Operator op = operators.get ( symbol );\n\n            \n            stack.push(\n                null == op\n                    ? values.get ( symbol )\n                    : op.evaluate ( stack )\n            );\n        }\n        return stack.pop();\n    }\n}\n"}
{"id": 404643, "name": "Set of real numbers", "source": "Translate Haskell to Java: \n\nimport Data.List\nimport Data.Maybe\n\ndata BracketType = OpenSub | ClosedSub\n    deriving (Show, Enum, Eq, Ord)\n\ndata RealInterval = RealInterval {left :: BracketType, right :: BracketType, \n    lowerBound :: Double, upperBound :: Double}\n    deriving (Eq)\n\ntype RealSet = [RealInterval]\nposInf = 1.0/0.0 :: Double \nnegInf = (-1.0/0.0) :: Double\nset_R = RealInterval ClosedSub ClosedSub negInf posInf :: RealInterval\n\nemptySet = [] :: [RealInterval]\n\ninstance Show RealInterval where\n    show x@(RealInterval _ _ y y')\n        | y == y' && (left x == right x) && (left x == ClosedSub) = \"{\" ++ (show y) ++ \"}\"\n        | otherwise = [['(', '[']!!(fromEnum $ left x)] ++ (show $ lowerBound x) ++\n         \",\" ++ (show $ upperBound x) ++ [[')', ']']!!(fromEnum $ right x)]\n    showList [x] = shows x\n    showList (h:t) = shows h . (\" U \" ++) . showList t\n    showList [] =  (++ \"(/)\") \n\nconstruct_interval :: Char -> Double -> Double -> Char -> RealInterval\nconstruct_interval '(' x y ')' = RealInterval OpenSub OpenSub x y \nconstruct_interval '(' x y ']' = RealInterval OpenSub ClosedSub x y \nconstruct_interval '[' x y ')' = RealInterval ClosedSub OpenSub x y \nconstruct_interval _ x y _ = RealInterval ClosedSub ClosedSub x y \n\nset_is_empty :: RealSet -> Bool\nset_is_empty rs = (rs == emptySet)\n\nset_in :: Double -> RealSet -> Bool\nset_in x [] = False\nset_in x rs =\n    isJust (find (\\s ->\n        ((lowerBound s < x) && (x < upperBound s)) ||\n        (x == lowerBound s && left s == ClosedSub) ||\n        (x == upperBound s && right s == ClosedSub))\n        rs)\n\n\nmax_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmin_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmax_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, max y y') \n    | x < x'  = p2\n    | otherwise = p1\n\nmin_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, min y y')\n    | x < x'  = p1\n    | otherwise = p2\n\nsimple_intersection :: RealInterval -> RealInterval -> [RealInterval]\nsimple_intersection ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = emptySet\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = emptySet\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = emptySet\n    | otherwise = let lb = if x1 == x2 then (x1, min l_ri1 l_ri2) else max_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = min_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_union :: RealInterval -> RealInterval -> [RealInterval]\nsimple_union ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = [ri2, ri1]\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = [ri1, ri2]\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = [ri1, ri2]\n    | otherwise = let lb = if x1 == x2 then (x1, max l_ri1 l_ri2) else min_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = max_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_complement :: RealInterval -> [RealInterval]\nsimple_complement ri1@(RealInterval l_ri1 r_ri1 x1 y1) =\n    [(RealInterval ClosedSub (inv l_ri1) negInf x1), (RealInterval (inv r_ri1) ClosedSub y1 posInf)]\n    where\n        inv OpenSub = ClosedSub\n        inv ClosedSub = OpenSub\n\nset_sort :: RealSet -> RealSet \nset_sort rs =\n    sortBy\n        (\\s1 s2 ->\n            let (lp, rp) = ((lowerBound s1, left s1), (lowerBound s2, left s2)) in\n                if max_p lp rp == lp then GT else LT)\n        rs\n\nset_simplify :: RealSet -> RealSet\nset_simplify [] = emptySet\nset_simplify rs =\n    concat (map make_empty (set_sort (foldl\n        (\\acc ri1 -> (simple_union (head acc) ri1) ++ (tail acc))\n        [head sorted_rs]\n        sorted_rs)))\n    where\n        sorted_rs = set_sort rs\n        make_empty ri@(RealInterval lb rb x y)\n            | x >= y && (lb /= rb || rb /= ClosedSub) = emptySet\n            | otherwise = [ri]\n\n\nset_complement :: RealSet -> RealSet\nset_union :: RealSet -> RealSet -> RealSet\nset_intersection :: RealSet -> RealSet -> RealSet\nset_difference :: RealSet -> RealSet -> RealSet\nset_measure :: RealSet -> Double\n\nset_complement rs =\n    foldl set_intersection [set_R] (map simple_complement rs)\nset_union rs1 rs2 =\n    set_simplify (rs1 ++ rs2)\nset_intersection rs1 rs2 =\n    set_simplify $ concat [simple_intersection s1 s2 | s1 <- rs1, s2 <- rs2]\nset_difference rs1 rs2 =\n    set_intersection (set_complement rs2) rs1\nset_measure rs =\n    foldl (\\acc x -> acc + (upperBound x) - (lowerBound x)) 0.0 rs\n\n\ntest = map (\\x -> [x]) [construct_interval '(' 0 1 ']', construct_interval '[' 0 2 ')',\n    construct_interval '[' 0 2 ')', construct_interval '(' 1 2 ']',\n    construct_interval '[' 0 3 ')', construct_interval '(' 0 1 ')',\n    construct_interval '[' 0 3 ')', construct_interval '[' 0 1 ']']\nrestest = [set_union (test!!0) (test!!1), set_intersection (test!!2) (test!!3),\n    set_difference (test!!4) (test!!5), set_difference (test!!6) (test!!7)]\nisintest s = \n    mapM_\n        (\\x -> putStrLn ((show x) ++ \" is in \" ++ (show s) ++ \"\u00a0: \" ++ (show (set_in x s))))\n        [0, 1, 2]\n\ntestA = [construct_interval '(' (sqrt (n + (1.0/6))) (sqrt (n + (5.0/6))) ')' | n <- [0..99]]\ntestB = [construct_interval '(' (n + (1.0/6)) (n + (5.0/6)) ')' | n <- [0..9]]\n\nmain =\n    putStrLn (\"union \" ++ (show (test!!0)) ++ \" \" ++ (show (test!!1)) ++ \" = \" ++ (show (restest!!0))) >>\n    putStrLn (\"inter \" ++ (show (test!!2)) ++ \" \" ++ (show (test!!3)) ++ \" = \" ++ (show (restest!!1))) >>\n    putStrLn (\"diff \" ++ (show (test!!4)) ++ \" \" ++ (show (test!!5)) ++ \" = \" ++ (show (restest!!2))) >>\n    putStrLn (\"diff \" ++ (show (test!!6)) ++ \" \" ++ (show (test!!7)) ++ \" = \" ++ (show (restest!!3))) >>\n    mapM_ isintest restest >>\n    putStrLn (\"measure: \" ++ (show (set_measure (set_difference testA testB))))\n", "target": "import java.util.Objects;\nimport java.util.function.Predicate;\n\npublic class RealNumberSet {\n    public enum RangeType {\n        CLOSED,\n        BOTH_OPEN,\n        LEFT_OPEN,\n        RIGHT_OPEN,\n    }\n\n    public static class RealSet {\n        private Double low;\n        private Double high;\n        private Predicate<Double> predicate;\n        private double interval = 0.00001;\n\n        public RealSet(Double low, Double high, Predicate<Double> predicate) {\n            this.low = low;\n            this.high = high;\n            this.predicate = predicate;\n        }\n\n        public RealSet(Double start, Double end, RangeType rangeType) {\n            this(start, end, d -> {\n                switch (rangeType) {\n                    case CLOSED:\n                        return start <= d && d <= end;\n                    case BOTH_OPEN:\n                        return start < d && d < end;\n                    case LEFT_OPEN:\n                        return start < d && d <= end;\n                    case RIGHT_OPEN:\n                        return start <= d && d < end;\n                    default:\n                        throw new IllegalStateException(\"Unhandled range type encountered.\");\n                }\n            });\n        }\n\n        public boolean contains(Double d) {\n            return predicate.test(d);\n        }\n\n        public RealSet union(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.or(other.predicate).test(d));\n        }\n\n        public RealSet intersect(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.and(other.predicate).test(d));\n        }\n\n        public RealSet subtract(RealSet other) {\n            return new RealSet(low, high, d -> predicate.and(other.predicate.negate()).test(d));\n        }\n\n        public double length() {\n            if (low.isInfinite() || high.isInfinite()) return -1.0; \n            if (high <= low) return 0.0;\n            Double p = low;\n            int count = 0;\n            do {\n                if (predicate.test(p)) count++;\n                p += interval;\n            } while (p < high);\n            return count * interval;\n        }\n\n        public boolean isEmpty() {\n            if (Objects.equals(high, low)) {\n                return predicate.negate().test(low);\n            }\n            return length() == 0.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        RealSet a = new RealSet(0.0, 1.0, RangeType.LEFT_OPEN);\n        RealSet b = new RealSet(0.0, 2.0, RangeType.RIGHT_OPEN);\n        RealSet c = new RealSet(1.0, 2.0, RangeType.LEFT_OPEN);\n        RealSet d = new RealSet(0.0, 3.0, RangeType.RIGHT_OPEN);\n        RealSet e = new RealSet(0.0, 1.0, RangeType.BOTH_OPEN);\n        RealSet f = new RealSet(0.0, 1.0, RangeType.CLOSED);\n        RealSet g = new RealSet(0.0, 0.0, RangeType.CLOSED);\n\n        for (int i = 0; i <= 2; i++) {\n            Double dd = (double) i;\n            System.out.printf(\"(0, 1] \u222a [0, 2) contains %d is %s\\n\", i, a.union(b).contains(dd));\n            System.out.printf(\"[0, 2) \u2229 (1, 2] contains %d is %s\\n\", i, b.intersect(c).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 (0, 1) contains %d is %s\\n\", i, d.subtract(e).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 [0, 1] contains %d is %s\\n\", i, d.subtract(f).contains(dd));\n            System.out.println();\n        }\n\n        System.out.printf(\"[0, 0] is empty is %s\\n\", g.isEmpty());\n        System.out.println();\n\n        RealSet aa = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x * x)) > 0.5\n        );\n        RealSet bb = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x)) > 0.5\n        );\n        RealSet cc = aa.subtract(bb);\n        System.out.printf(\"Approx length of A - B is %f\\n\", cc.length());\n    }\n}\n"}
{"id": 404644, "name": "Set of real numbers", "source": "Translate Haskell to Java: \n\nimport Data.List\nimport Data.Maybe\n\ndata BracketType = OpenSub | ClosedSub\n    deriving (Show, Enum, Eq, Ord)\n\ndata RealInterval = RealInterval {left :: BracketType, right :: BracketType, \n    lowerBound :: Double, upperBound :: Double}\n    deriving (Eq)\n\ntype RealSet = [RealInterval]\nposInf = 1.0/0.0 :: Double \nnegInf = (-1.0/0.0) :: Double\nset_R = RealInterval ClosedSub ClosedSub negInf posInf :: RealInterval\n\nemptySet = [] :: [RealInterval]\n\ninstance Show RealInterval where\n    show x@(RealInterval _ _ y y')\n        | y == y' && (left x == right x) && (left x == ClosedSub) = \"{\" ++ (show y) ++ \"}\"\n        | otherwise = [['(', '[']!!(fromEnum $ left x)] ++ (show $ lowerBound x) ++\n         \",\" ++ (show $ upperBound x) ++ [[')', ']']!!(fromEnum $ right x)]\n    showList [x] = shows x\n    showList (h:t) = shows h . (\" U \" ++) . showList t\n    showList [] =  (++ \"(/)\") \n\nconstruct_interval :: Char -> Double -> Double -> Char -> RealInterval\nconstruct_interval '(' x y ')' = RealInterval OpenSub OpenSub x y \nconstruct_interval '(' x y ']' = RealInterval OpenSub ClosedSub x y \nconstruct_interval '[' x y ')' = RealInterval ClosedSub OpenSub x y \nconstruct_interval _ x y _ = RealInterval ClosedSub ClosedSub x y \n\nset_is_empty :: RealSet -> Bool\nset_is_empty rs = (rs == emptySet)\n\nset_in :: Double -> RealSet -> Bool\nset_in x [] = False\nset_in x rs =\n    isJust (find (\\s ->\n        ((lowerBound s < x) && (x < upperBound s)) ||\n        (x == lowerBound s && left s == ClosedSub) ||\n        (x == upperBound s && right s == ClosedSub))\n        rs)\n\n\nmax_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmin_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmax_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, max y y') \n    | x < x'  = p2\n    | otherwise = p1\n\nmin_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, min y y')\n    | x < x'  = p1\n    | otherwise = p2\n\nsimple_intersection :: RealInterval -> RealInterval -> [RealInterval]\nsimple_intersection ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = emptySet\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = emptySet\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = emptySet\n    | otherwise = let lb = if x1 == x2 then (x1, min l_ri1 l_ri2) else max_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = min_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_union :: RealInterval -> RealInterval -> [RealInterval]\nsimple_union ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = [ri2, ri1]\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = [ri1, ri2]\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = [ri1, ri2]\n    | otherwise = let lb = if x1 == x2 then (x1, max l_ri1 l_ri2) else min_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = max_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_complement :: RealInterval -> [RealInterval]\nsimple_complement ri1@(RealInterval l_ri1 r_ri1 x1 y1) =\n    [(RealInterval ClosedSub (inv l_ri1) negInf x1), (RealInterval (inv r_ri1) ClosedSub y1 posInf)]\n    where\n        inv OpenSub = ClosedSub\n        inv ClosedSub = OpenSub\n\nset_sort :: RealSet -> RealSet \nset_sort rs =\n    sortBy\n        (\\s1 s2 ->\n            let (lp, rp) = ((lowerBound s1, left s1), (lowerBound s2, left s2)) in\n                if max_p lp rp == lp then GT else LT)\n        rs\n\nset_simplify :: RealSet -> RealSet\nset_simplify [] = emptySet\nset_simplify rs =\n    concat (map make_empty (set_sort (foldl\n        (\\acc ri1 -> (simple_union (head acc) ri1) ++ (tail acc))\n        [head sorted_rs]\n        sorted_rs)))\n    where\n        sorted_rs = set_sort rs\n        make_empty ri@(RealInterval lb rb x y)\n            | x >= y && (lb /= rb || rb /= ClosedSub) = emptySet\n            | otherwise = [ri]\n\n\nset_complement :: RealSet -> RealSet\nset_union :: RealSet -> RealSet -> RealSet\nset_intersection :: RealSet -> RealSet -> RealSet\nset_difference :: RealSet -> RealSet -> RealSet\nset_measure :: RealSet -> Double\n\nset_complement rs =\n    foldl set_intersection [set_R] (map simple_complement rs)\nset_union rs1 rs2 =\n    set_simplify (rs1 ++ rs2)\nset_intersection rs1 rs2 =\n    set_simplify $ concat [simple_intersection s1 s2 | s1 <- rs1, s2 <- rs2]\nset_difference rs1 rs2 =\n    set_intersection (set_complement rs2) rs1\nset_measure rs =\n    foldl (\\acc x -> acc + (upperBound x) - (lowerBound x)) 0.0 rs\n\n\ntest = map (\\x -> [x]) [construct_interval '(' 0 1 ']', construct_interval '[' 0 2 ')',\n    construct_interval '[' 0 2 ')', construct_interval '(' 1 2 ']',\n    construct_interval '[' 0 3 ')', construct_interval '(' 0 1 ')',\n    construct_interval '[' 0 3 ')', construct_interval '[' 0 1 ']']\nrestest = [set_union (test!!0) (test!!1), set_intersection (test!!2) (test!!3),\n    set_difference (test!!4) (test!!5), set_difference (test!!6) (test!!7)]\nisintest s = \n    mapM_\n        (\\x -> putStrLn ((show x) ++ \" is in \" ++ (show s) ++ \"\u00a0: \" ++ (show (set_in x s))))\n        [0, 1, 2]\n\ntestA = [construct_interval '(' (sqrt (n + (1.0/6))) (sqrt (n + (5.0/6))) ')' | n <- [0..99]]\ntestB = [construct_interval '(' (n + (1.0/6)) (n + (5.0/6)) ')' | n <- [0..9]]\n\nmain =\n    putStrLn (\"union \" ++ (show (test!!0)) ++ \" \" ++ (show (test!!1)) ++ \" = \" ++ (show (restest!!0))) >>\n    putStrLn (\"inter \" ++ (show (test!!2)) ++ \" \" ++ (show (test!!3)) ++ \" = \" ++ (show (restest!!1))) >>\n    putStrLn (\"diff \" ++ (show (test!!4)) ++ \" \" ++ (show (test!!5)) ++ \" = \" ++ (show (restest!!2))) >>\n    putStrLn (\"diff \" ++ (show (test!!6)) ++ \" \" ++ (show (test!!7)) ++ \" = \" ++ (show (restest!!3))) >>\n    mapM_ isintest restest >>\n    putStrLn (\"measure: \" ++ (show (set_measure (set_difference testA testB))))\n", "target": "import java.util.Objects;\nimport java.util.function.Predicate;\n\npublic class RealNumberSet {\n    public enum RangeType {\n        CLOSED,\n        BOTH_OPEN,\n        LEFT_OPEN,\n        RIGHT_OPEN,\n    }\n\n    public static class RealSet {\n        private Double low;\n        private Double high;\n        private Predicate<Double> predicate;\n        private double interval = 0.00001;\n\n        public RealSet(Double low, Double high, Predicate<Double> predicate) {\n            this.low = low;\n            this.high = high;\n            this.predicate = predicate;\n        }\n\n        public RealSet(Double start, Double end, RangeType rangeType) {\n            this(start, end, d -> {\n                switch (rangeType) {\n                    case CLOSED:\n                        return start <= d && d <= end;\n                    case BOTH_OPEN:\n                        return start < d && d < end;\n                    case LEFT_OPEN:\n                        return start < d && d <= end;\n                    case RIGHT_OPEN:\n                        return start <= d && d < end;\n                    default:\n                        throw new IllegalStateException(\"Unhandled range type encountered.\");\n                }\n            });\n        }\n\n        public boolean contains(Double d) {\n            return predicate.test(d);\n        }\n\n        public RealSet union(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.or(other.predicate).test(d));\n        }\n\n        public RealSet intersect(RealSet other) {\n            double low2 = Math.min(low, other.low);\n            double high2 = Math.max(high, other.high);\n            return new RealSet(low2, high2, d -> predicate.and(other.predicate).test(d));\n        }\n\n        public RealSet subtract(RealSet other) {\n            return new RealSet(low, high, d -> predicate.and(other.predicate.negate()).test(d));\n        }\n\n        public double length() {\n            if (low.isInfinite() || high.isInfinite()) return -1.0; \n            if (high <= low) return 0.0;\n            Double p = low;\n            int count = 0;\n            do {\n                if (predicate.test(p)) count++;\n                p += interval;\n            } while (p < high);\n            return count * interval;\n        }\n\n        public boolean isEmpty() {\n            if (Objects.equals(high, low)) {\n                return predicate.negate().test(low);\n            }\n            return length() == 0.0;\n        }\n    }\n\n    public static void main(String[] args) {\n        RealSet a = new RealSet(0.0, 1.0, RangeType.LEFT_OPEN);\n        RealSet b = new RealSet(0.0, 2.0, RangeType.RIGHT_OPEN);\n        RealSet c = new RealSet(1.0, 2.0, RangeType.LEFT_OPEN);\n        RealSet d = new RealSet(0.0, 3.0, RangeType.RIGHT_OPEN);\n        RealSet e = new RealSet(0.0, 1.0, RangeType.BOTH_OPEN);\n        RealSet f = new RealSet(0.0, 1.0, RangeType.CLOSED);\n        RealSet g = new RealSet(0.0, 0.0, RangeType.CLOSED);\n\n        for (int i = 0; i <= 2; i++) {\n            Double dd = (double) i;\n            System.out.printf(\"(0, 1] \u222a [0, 2) contains %d is %s\\n\", i, a.union(b).contains(dd));\n            System.out.printf(\"[0, 2) \u2229 (1, 2] contains %d is %s\\n\", i, b.intersect(c).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 (0, 1) contains %d is %s\\n\", i, d.subtract(e).contains(dd));\n            System.out.printf(\"[0, 3) \u2212 [0, 1] contains %d is %s\\n\", i, d.subtract(f).contains(dd));\n            System.out.println();\n        }\n\n        System.out.printf(\"[0, 0] is empty is %s\\n\", g.isEmpty());\n        System.out.println();\n\n        RealSet aa = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x * x)) > 0.5\n        );\n        RealSet bb = new RealSet(\n            0.0, 10.0,\n            x -> (0.0 < x && x < 10.0) && Math.abs(Math.sin(Math.PI * x)) > 0.5\n        );\n        RealSet cc = aa.subtract(bb);\n        System.out.printf(\"Approx length of A - B is %f\\n\", cc.length());\n    }\n}\n"}
{"id": 404645, "name": "State name puzzle", "source": "Translate Haskell to Java: \n\nimport Data.Char (isLetter, toLower)\nimport Data.Function (on)\nimport Data.List (groupBy, nub, sort, sortBy)\n\n\n\npuzzle :: [String] -> [((String, String), (String, String))]\npuzzle states =\n  concatMap\n    ((filter isValid . pairs) . map snd)\n    ( filter ((> 1) . length) $\n        groupBy ((==) `on` fst) $\n          sortBy\n            (compare `on` fst)\n            [ (pkey (a <> b), (a, b))\n              | (a, b) <- pairs (nub $ sort states)\n            ]\n    )\n  where\n    pkey = sort . filter isLetter . map toLower\n    isValid ((a0, a1), (b0, b1)) =\n      (a0 /= b0)\n        && (a0 /= b1)\n        && (a1 /= b0)\n        && (a1 /= b1)\n\npairs :: [a] -> [(a, a)]\npairs [] = []\npairs (y : ys) = map (y,) ys <> pairs ys\n\n\nmain :: IO ()\nmain = do\n  putStrLn $\n    \"Matching pairs generated from \"\n      <> show (length stateNames)\n      <> \" state names and \"\n      <> show (length fakeStateNames)\n      <> \" fake state names:\"\n  mapM_ print $ puzzle $ stateNames <> fakeStateNames\n\nstateNames :: [String]\nstateNames =\n  [ \"Alabama\",\n    \"Alaska\",\n    \"Arizona\",\n    \"Arkansas\",\n    \"California\",\n    \"Colorado\",\n    \"Connecticut\",\n    \"Delaware\",\n    \"Florida\",\n    \"Georgia\",\n    \"Hawaii\",\n    \"Idaho\",\n    \"Illinois\",\n    \"Indiana\",\n    \"Iowa\",\n    \"Kansas\",\n    \"Kentucky\",\n    \"Louisiana\",\n    \"Maine\",\n    \"Maryland\",\n    \"Massachusetts\",\n    \"Michigan\",\n    \"Minnesota\",\n    \"Mississippi\",\n    \"Missouri\",\n    \"Montana\",\n    \"Nebraska\",\n    \"Nevada\",\n    \"New Hampshire\",\n    \"New Jersey\",\n    \"New Mexico\",\n    \"New York\",\n    \"North Carolina\",\n    \"North Dakota\",\n    \"Ohio\",\n    \"Oklahoma\",\n    \"Oregon\",\n    \"Pennsylvania\",\n    \"Rhode Island\",\n    \"South Carolina\",\n    \"South Dakota\",\n    \"Tennessee\",\n    \"Texas\",\n    \"Utah\",\n    \"Vermont\",\n    \"Virginia\",\n    \"Washington\",\n    \"West Virginia\",\n    \"Wisconsin\",\n    \"Wyoming\"\n  ]\n\nfakeStateNames :: [String]\nfakeStateNames =\n  [ \"New Kory\",\n    \"Wen Kory\",\n    \"York New\",\n    \"Kory New\",\n    \"New Kory\"\n  ]\n", "target": "import java.util.*;\nimport java.util.stream.*;\n\npublic class StateNamePuzzle {\n\n    static String[] states = {\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\",\n        \"California\", \"Colorado\", \"Connecticut\", \"Delaware\", \"Florida\",\n        \"Georgia\", \"hawaii\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\", \"Iowa\",\n        \"Kansas\", \"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\", \"Massachusetts\",\n        \"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\", \"Montana\",\n        \"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\", \"New Mexico\",\n        \"New York\", \"North Carolina \", \"North Dakota\", \"Ohio\", \"Oklahoma\",\n        \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n        \"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n        \"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\",\n        \"New Kory\", \"Wen Kory\", \"York New\", \"Kory New\", \"New Kory\",};\n\n    public static void main(String[] args) {\n        solve(Arrays.asList(states));\n    }\n\n    static void solve(List<String> input) {\n        Map<String, String> orig = input.stream().collect(Collectors.toMap(\n                s -> s.replaceAll(\"\\\\s\", \"\").toLowerCase(), s -> s, (s, a) -> s));\n\n        input = new ArrayList<>(orig.keySet());\n\n        Map<String, List<String[]>> map = new HashMap<>();\n        for (int i = 0; i < input.size() - 1; i++) {\n            String pair0 = input.get(i);\n            for (int j = i + 1; j < input.size(); j++) {\n\n                String[] pair = {pair0, input.get(j)};\n                String s = pair0 + pair[1];\n                String key = Arrays.toString(s.chars().sorted().toArray());\n\n                List<String[]> val = map.getOrDefault(key, new ArrayList<>());\n                val.add(pair);\n                map.put(key, val);\n            }\n        }\n\n        map.forEach((key, list) -> {\n            for (int i = 0; i < list.size() - 1; i++) {\n                String[] a = list.get(i);\n                for (int j = i + 1; j < list.size(); j++) {\n                    String[] b = list.get(j);\n\n                    if (Stream.of(a[0], a[1], b[0], b[1]).distinct().count() < 4)\n                        continue;\n\n                    System.out.printf(\"%s + %s = %s + %s %n\", orig.get(a[0]),\n                            orig.get(a[1]), orig.get(b[0]), orig.get(b[1]));\n                }\n            }\n        });\n    }\n}\n"}
{"id": 404646, "name": "Super-d numbers", "source": "Translate Haskell to Java: import Data.List (isInfixOf)\nimport Data.Char (intToDigit)\n\nisSuperd :: (Show a, Integral a) => a -> a -> Bool\nisSuperd p n =\n  (replicate <*> intToDigit) (fromIntegral p) `isInfixOf` show (p * n ^ p)\n\nfindSuperd :: (Show a, Integral a) => a -> [a]\nfindSuperd p = filter (isSuperd p) [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn .\n     (\"First 10 super-\" ++) .\n     ((++) . show <*> ((\"\u00a0: \" ++) . show . take 10 . findSuperd)))\n    [2 .. 6]\n", "target": "import java.math.BigInteger;\n\npublic class SuperDNumbers {\n\n    public static void main(String[] args) {\n        for ( int i = 2 ; i <= 9 ; i++ ) {\n            superD(i, 10);\n        }\n    }\n    \n    private static final void superD(int d, int max) {\n        long start = System.currentTimeMillis();\n        String test = \"\";\n        for ( int i = 0 ; i < d ; i++ ) {\n            test += (\"\"+d);\n        }\n        \n        int n = 0;\n        int i = 0;\n        System.out.printf(\"First %d super-%d numbers: %n\", max, d);\n        while ( n < max ) {\n            i++;\n            BigInteger val = BigInteger.valueOf(d).multiply(BigInteger.valueOf(i).pow(d));\n            if ( val.toString().contains(test) ) {\n                n++;\n                System.out.printf(\"%d \", i);\n            }\n        }\n        long end = System.currentTimeMillis();\n        System.out.printf(\"%nRun time %d ms%n%n\", end-start);\n        \n    }\n\n}\n"}
{"id": 404647, "name": "Textonyms", "source": "Translate Haskell to Java: import Data.Char (toUpper)\nimport Data.Function (on)\nimport Data.List (groupBy, sortBy)\nimport Data.Maybe (fromMaybe, isJust, isNothing)\n\ntoKey :: Char -> Maybe Char\ntoKey ch\n  | ch < 'A' = Nothing\n  | ch < 'D' = Just '2'\n  | ch < 'G' = Just '3'\n  | ch < 'J' = Just '4'\n  | ch < 'M' = Just '5'\n  | ch < 'P' = Just '6'\n  | ch < 'T' = Just '7'\n  | ch < 'W' = Just '8'\n  | ch <= 'Z' = Just '9'\n  | otherwise = Nothing\n\ntoKeyString :: String -> Maybe String\ntoKeyString st\n  | any isNothing mch = Nothing\n  | otherwise = Just $ map (fromMaybe '!') mch\n  where\n    mch = map (toKey . toUpper) st\n\nshowTextonym :: [(String, String)] -> String\nshowTextonym ts =\n  fst (head ts)\n    ++ \" => \"\n    ++ concat\n      [ w ++ \" \"\n        | (_, w) <- ts\n      ]\n\nmain :: IO ()\nmain = do\n  let src = \"unixdict.txt\"\n  contents <- readFile src\n  let wordList = lines contents\n      keyedList =\n        [ (key, word)\n          | (Just key, word) <-\n              filter (isJust . fst) $\n                zip (map toKeyString wordList) wordList\n        ]\n      groupedList =\n        groupBy ((==) `on` fst) $\n          sortBy (compare `on` fst) keyedList\n      textonymList = filter ((> 1) . length) groupedList\n  mapM_ putStrLn $\n    [ \"There are \"\n        ++ show (length keyedList)\n        ++ \" words in \"\n        ++ src\n        ++ \" which can be represented by the digit key mapping.\",\n      \"They require \"\n        ++ show (length groupedList)\n        ++ \" digit combinations to represent them.\",\n      show (length textonymList) ++ \" digit combinations represent Textonyms.\",\n      \"\",\n      \"Top 5 in ambiguity:\"\n    ]\n      ++ fmap\n        showTextonym\n        ( take 5 $\n            sortBy (flip compare `on` length) textonymList\n        )\n      ++ [\"\", \"Top 5 in length:\"]\n      ++ fmap\n        showTextonym\n        (take 5 $ sortBy (flip compare `on` (length . fst . head)) textonymList)\n", "target": "import java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Vector;\n\npublic class RTextonyms {\n\n  private static final Map<Character, Character> mapping;\n  private int total, elements, textonyms, max_found;\n  private String filename, mappingResult;\n  private Vector<String> max_strings;\n  private Map<String, Vector<String>> values;\n\n  static {\n    mapping = new HashMap<Character, Character>();\n    mapping.put('A', '2'); mapping.put('B', '2'); mapping.put('C', '2');\n    mapping.put('D', '3'); mapping.put('E', '3'); mapping.put('F', '3');\n    mapping.put('G', '4'); mapping.put('H', '4'); mapping.put('I', '4');\n    mapping.put('J', '5'); mapping.put('K', '5'); mapping.put('L', '5');\n    mapping.put('M', '6'); mapping.put('N', '6'); mapping.put('O', '6');\n    mapping.put('P', '7'); mapping.put('Q', '7'); mapping.put('R', '7'); mapping.put('S', '7');\n    mapping.put('T', '8'); mapping.put('U', '8'); mapping.put('V', '8');\n    mapping.put('W', '9'); mapping.put('X', '9'); mapping.put('Y', '9'); mapping.put('Z', '9');\n  }\n\n  public RTextonyms(String filename) {\n\n    this.filename = filename;\n    this.total = this.elements = this.textonyms = this.max_found = 0;\n    this.values = new HashMap<String, Vector<String>>();\n    this.max_strings = new Vector<String>();\n\n    return;\n  }\n\n  public void add(String line) {\n\n    String mapping = \"\";\n    total++;\n    if (!get_mapping(line)) {\n      return;\n    }\n    mapping = mappingResult;\n\n    if (values.get(mapping) == null) {\n      values.put(mapping, new Vector<String>());\n    }\n\n    int num_strings;\n    num_strings = values.get(mapping).size();\n    textonyms += num_strings == 1 ? 1 : 0;\n    elements++;\n\n    if (num_strings > max_found) {\n      max_strings.clear();\n      max_strings.add(mapping);\n      max_found = num_strings;\n    }\n    else if (num_strings == max_found) {\n      max_strings.add(mapping);\n    }\n\n    values.get(mapping).add(line);\n\n    return;\n  }\n\n  public void results() {\n\n    System.out.printf(\"Read\u00a0%,d words from %s%n%n\", total, filename);\n    System.out.printf(\"There are\u00a0%,d words in %s which can be represented by the digit key mapping.%n\", elements,\n        filename);\n    System.out.printf(\"They require\u00a0%,d digit combinations to represent them.%n\", values.size());\n    System.out.printf(\"%,d digit combinations represent Textonyms.%n\", textonyms);\n    System.out.printf(\"The numbers mapping to the most words map to\u00a0%,d words each:%n\", max_found + 1);\n    for (String key : max_strings) {\n      System.out.printf(\"%16s maps to: %s%n\", key, values.get(key).toString());\n    }\n    System.out.println();\n\n    return;\n  }\n\n  public void match(String key) {\n\n    Vector<String> match;\n    match = values.get(key);\n    if (match == null) {\n      System.out.printf(\"Key %s not found%n\", key);\n    }\n    else {\n      System.out.printf(\"Key %s matches: %s%n\", key, match.toString());\n    }\n\n    return;\n  }\n\n  private boolean get_mapping(String line) {\n\n    mappingResult = line;\n    StringBuilder mappingBuilder = new StringBuilder();\n    for (char cc : line.toCharArray()) {\n      if (Character.isAlphabetic(cc)) {\n        mappingBuilder.append(mapping.get(Character.toUpperCase(cc)));\n      }\n      else if (Character.isDigit(cc)) {\n        mappingBuilder.append(cc);\n      }\n      else {\n        return false;\n      }\n    }\n    mappingResult = mappingBuilder.toString();\n\n    return true;\n  }\n\n  public static void main(String[] args) {\n\n    String filename;\n    if (args.length > 0) {\n      filename = args[0];\n    }\n    else {\n      filename = \"./unixdict.txt\";\n    }\n    RTextonyms tc;\n    tc = new RTextonyms(filename);\n    Path fp = Paths.get(filename);\n    try (Scanner fs = new Scanner(fp, StandardCharsets.UTF_8.name())) {\n      while (fs.hasNextLine()) {\n        tc.add(fs.nextLine());\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n\n    List<String> numbers = Arrays.asList(\n        \"001\", \"228\", \"27484247\", \"7244967473642\",\n        \".\"\n        );\n\n    tc.results();\n    for (String number : numbers) {\n      if (number.equals(\".\")) {\n        System.out.println();\n      }\n      else {\n        tc.match(number);\n      }\n    }\n\n    return;\n  }\n}\n"}
{"id": 404648, "name": "Church numerals", "source": "Translate Haskell to Java: import Unsafe.Coerce ( unsafeCoerce )\n\ntype Church a = (a -> a) -> a -> a\n\nchurchZero :: Church  a\nchurchZero = const id\n\nchurchOne :: Church a\nchurchOne = id\n\nsuccChurch :: Church a -> Church a\nsuccChurch = (<*>) (.) \n\naddChurch :: Church a -> Church a -> Church a\naddChurch = (<*>). fmap (.) \n\nmultChurch :: Church a -> Church a -> Church a\nmultChurch = (.) \n\nexpChurch :: Church a -> Church a -> Church a\nexpChurch basech expch = unsafeCoerce expch basech\n\nisChurchZero :: Church a -> Church a\nisChurchZero ch = unsafeCoerce ch (const churchZero) churchOne\n\npredChurch :: Church a -> Church a\npredChurch ch f x = unsafeCoerce ch (\\ g h -> h (g f)) (const x) id\n\nminusChurch :: Church a -> Church a -> Church a\nminusChurch ach bch = unsafeCoerce bch predChurch ach\n\n\ndivChurch :: Church a -> Church a -> Church a\ndivChurch dvdnd dvsr =\n  let divr n d =\n        (\\ v -> v (const $ succChurch $ divr v d) \n                  churchZero \n        ) (minusChurch n d)\n  in divr (unsafeCoerce succChurch dvdnd) $ unsafeCoerce dvsr\n\nchurchFromInt :: Int -> Church a\nchurchFromInt 0 = churchZero\nchurchFromInt n = succChurch $ churchFromInt (n - 1)\n\n\n\n\n\n\n\nintFromChurch :: Church Int -> Int\nintFromChurch ch = ch succ 0\n\n\nmain :: IO ()\nmain = do\n  let [cThree, cFour, cEleven, cTwelve] = churchFromInt <$> [3, 4, 11, 12]\n  print $ fmap intFromChurch  [ addChurch cThree cFour\n                              , multChurch cThree cFour\n                              , expChurch cFour cThree\n                              , expChurch cThree cFour\n                              , isChurchZero churchZero\n                              , predChurch cFour\n                              , minusChurch cEleven cThree\n                              , divChurch cEleven cThree\n                              , divChurch cTwelve cThree\n                              ]\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 404649, "name": "Church numerals", "source": "Translate Haskell to Java: import Unsafe.Coerce ( unsafeCoerce )\n\ntype Church a = (a -> a) -> a -> a\n\nchurchZero :: Church  a\nchurchZero = const id\n\nchurchOne :: Church a\nchurchOne = id\n\nsuccChurch :: Church a -> Church a\nsuccChurch = (<*>) (.) \n\naddChurch :: Church a -> Church a -> Church a\naddChurch = (<*>). fmap (.) \n\nmultChurch :: Church a -> Church a -> Church a\nmultChurch = (.) \n\nexpChurch :: Church a -> Church a -> Church a\nexpChurch basech expch = unsafeCoerce expch basech\n\nisChurchZero :: Church a -> Church a\nisChurchZero ch = unsafeCoerce ch (const churchZero) churchOne\n\npredChurch :: Church a -> Church a\npredChurch ch f x = unsafeCoerce ch (\\ g h -> h (g f)) (const x) id\n\nminusChurch :: Church a -> Church a -> Church a\nminusChurch ach bch = unsafeCoerce bch predChurch ach\n\n\ndivChurch :: Church a -> Church a -> Church a\ndivChurch dvdnd dvsr =\n  let divr n d =\n        (\\ v -> v (const $ succChurch $ divr v d) \n                  churchZero \n        ) (minusChurch n d)\n  in divr (unsafeCoerce succChurch dvdnd) $ unsafeCoerce dvsr\n\nchurchFromInt :: Int -> Church a\nchurchFromInt 0 = churchZero\nchurchFromInt n = succChurch $ churchFromInt (n - 1)\n\n\n\n\n\n\n\nintFromChurch :: Church Int -> Int\nintFromChurch ch = ch succ 0\n\n\nmain :: IO ()\nmain = do\n  let [cThree, cFour, cEleven, cTwelve] = churchFromInt <$> [3, 4, 11, 12]\n  print $ fmap intFromChurch  [ addChurch cThree cFour\n                              , multChurch cThree cFour\n                              , expChurch cFour cThree\n                              , expChurch cThree cFour\n                              , isChurchZero churchZero\n                              , predChurch cFour\n                              , minusChurch cEleven cThree\n                              , divChurch cEleven cThree\n                              , divChurch cTwelve cThree\n                              ]\n", "target": "package lvijay;\n\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.function.Function;\n\npublic class Church {\n    public static interface ChurchNum extends Function<ChurchNum, ChurchNum> {\n    }\n\n    public static ChurchNum zero() {\n        return f -> x -> x;\n    }\n\n    public static ChurchNum next(ChurchNum n) {\n        return f -> x -> f.apply(n.apply(f).apply(x));\n    }\n\n    public static ChurchNum plus(ChurchNum a) {\n        return b -> f -> x -> b.apply(f).apply(a.apply(f).apply(x));\n    }\n\n    public static ChurchNum pow(ChurchNum m) {\n        return n -> m.apply(n);\n    }\n\n    public static ChurchNum mult(ChurchNum a) {\n        return b -> f -> x -> b.apply(a.apply(f)).apply(x);\n    }\n\n    public static ChurchNum toChurchNum(int n) {\n        if (n <= 0) {\n            return zero();\n        }\n        return next(toChurchNum(n - 1));\n    }\n\n    public static int toInt(ChurchNum c) {\n        AtomicInteger counter = new AtomicInteger(0);\n        ChurchNum funCounter = f -> {\n            counter.incrementAndGet();\n            return f;\n        };\n\n        plus(zero()).apply(c).apply(funCounter).apply(x -> x);\n\n        return counter.get();\n    }\n\n    public static void main(String[] args) {\n        ChurchNum zero  = zero();\n        ChurchNum three = next(next(next(zero)));\n        ChurchNum four  = next(next(next(next(zero))));\n\n        System.out.println(\"3+4=\" + toInt(plus(three).apply(four))); \n        System.out.println(\"4+3=\" + toInt(plus(four).apply(three))); \n\n        System.out.println(\"3*4=\" + toInt(mult(three).apply(four))); \n        System.out.println(\"4*3=\" + toInt(mult(four).apply(three))); \n\n        \n        System.out.println(\"3^4=\" + toInt(pow(four).apply(three))); \n        System.out.println(\"4^3=\" + toInt(pow(three).apply(four))); \n\n        System.out.println(\"  8=\" + toInt(toChurchNum(8))); \n    }\n}\n"}
{"id": 404650, "name": "Canonicalize CIDR", "source": "Translate Haskell to Java: import Control.Monad (guard)\nimport Data.Bits ((.|.), (.&.), complement, shiftL, shiftR, zeroBits)\nimport Data.Maybe (listToMaybe)\nimport Data.Word (Word32, Word8)\nimport Text.ParserCombinators.ReadP (ReadP, char, readP_to_S)\nimport Text.Printf (printf)\nimport Text.Read.Lex (readDecP)\n\n\n\ndata CIDR = CIDR Word32 Word8\n\n\ncidrRead :: String -> Maybe CIDR\ncidrRead = listToMaybe . map fst . readP_to_S cidrP\n\n\ncidrShow :: CIDR -> String\ncidrShow (CIDR addr n) = let (a, b, c, d) = octetsFrom addr\n                         in printf \"%u.%u.%u.%u/%u\" a b c d n\n\n\n\n\ncidrP :: ReadP CIDR\ncidrP = do a <- octetP <* char '.'\n           b <- octetP <* char '.'\n           c <- octetP <* char '.'\n           d <- octetP <* char '/'\n           n <- netBitsP\n           return $ CIDR (addrFrom a b c d .&. netmask n) n\n  where octetP   = wordP 255\n        netBitsP = wordP  32\n\n\n\n\n\nwordP :: Integral a => Integer -> ReadP a\nwordP lim = do n <- readDecP\n               guard $ n <= lim\n               return $ fi n\n\n\noctetsFrom :: Word32 -> (Word8, Word8, Word8, Word8)\noctetsFrom addr = (oct addr 3, oct addr 2, oct addr 1, oct addr 0)\n  where oct w n = fi $ w `shiftR` (8*n) .&. 0xff\n\n\naddrFrom :: Word8 -> Word8 -> Word8 -> Word8 -> Word32\naddrFrom a b c d = 0 <<+ a <<+ b <<+ c <<+ d\n  where w <<+ o = w `shiftL` 8 .|. fi o\n\n\n\nnetmask :: Word8 -> Word32\nnetmask n = complement $ complement zeroBits `shiftR` fi n\n\nfi :: (Integral a, Num b) => a -> b\nfi = fromIntegral\n\ntest :: String -> IO ()\ntest str = do\n  let cidrStr = maybe \"invalid CIDR string\" cidrShow (cidrRead str)\n  printf \"%-18s -> %s\\n\" str cidrStr\n\nmain :: IO ()\nmain = do\n  test \"87.70.141.1/22\"\n  test \"36.18.154.103/12\"\n  test \"62.62.197.11/29\"\n  test \"67.137.119.181/4\"\n  test \"161.214.74.21/24\"\n  test \"184.232.176.184/18\"\n  \n  test \"184.256.176.184/12\" \n  test \"184.232.176.184/33\" \n  test \"184.232.184/18\"     \n", "target": "import java.text.MessageFormat;\nimport java.text.ParseException;\n\npublic class CanonicalizeCIDR {\n    public static void main(String[] args) {\n        for (String test : TESTS) {\n            try {\n                CIDR cidr = new CIDR(test);\n                System.out.printf(\"%-18s -> %s\\n\", test, cidr.toString());\n            } catch (Exception ex) {\n                System.err.printf(\"Error parsing '%s': %s\\n\", test, ex.getLocalizedMessage());\n            }\n        }\n    }\n\n    private static class CIDR {\n        private CIDR(int address, int maskLength) {\n            this.address = address;\n            this.maskLength = maskLength;\n        }\n\n        private CIDR(String str) throws Exception {\n            Object[] args = new MessageFormat(FORMAT).parse(str);\n            int address = 0;\n            for (int i = 0; i < 4; ++i) {\n                int a = ((Number)args[i]).intValue();\n                if (a < 0 || a > 255)\n                    throw new Exception(\"Invalid IP address\");\n                address <<= 8;\n                address += a;\n            }\n            int maskLength = ((Number)args[4]).intValue();\n            if (maskLength < 1 || maskLength > 32)\n                throw new Exception(\"Invalid mask length\");\n            int mask = ~((1 << (32 - maskLength)) - 1);\n            this.address = address & mask;\n            this.maskLength = maskLength;\n        }\n\n        public String toString() {\n            int address = this.address;\n            int d = address & 0xFF;\n            address >>= 8;\n            int c = address & 0xFF;\n            address >>= 8;\n            int b = address & 0xFF;\n            address >>= 8;\n            int a = address & 0xFF;\n            Object[] args = { a, b, c, d, maskLength };\n            return new MessageFormat(FORMAT).format(args);\n        }\n\n        private int address;\n        private int maskLength;\n        private static final String FORMAT = \"{0,number,integer}.{1,number,integer}.{2,number,integer}.{3,number,integer}/{4,number,integer}\";\n    };\n\n    private static final String[] TESTS = {\n        \"87.70.141.1/22\",\n        \"36.18.154.103/12\",\n        \"62.62.197.11/29\",\n        \"67.137.119.181/4\",\n        \"161.214.74.21/24\",\n        \"184.232.176.184/18\"\n    };\n}\n"}
{"id": 404651, "name": "Canonicalize CIDR", "source": "Translate Haskell to Java: import Control.Monad (guard)\nimport Data.Bits ((.|.), (.&.), complement, shiftL, shiftR, zeroBits)\nimport Data.Maybe (listToMaybe)\nimport Data.Word (Word32, Word8)\nimport Text.ParserCombinators.ReadP (ReadP, char, readP_to_S)\nimport Text.Printf (printf)\nimport Text.Read.Lex (readDecP)\n\n\n\ndata CIDR = CIDR Word32 Word8\n\n\ncidrRead :: String -> Maybe CIDR\ncidrRead = listToMaybe . map fst . readP_to_S cidrP\n\n\ncidrShow :: CIDR -> String\ncidrShow (CIDR addr n) = let (a, b, c, d) = octetsFrom addr\n                         in printf \"%u.%u.%u.%u/%u\" a b c d n\n\n\n\n\ncidrP :: ReadP CIDR\ncidrP = do a <- octetP <* char '.'\n           b <- octetP <* char '.'\n           c <- octetP <* char '.'\n           d <- octetP <* char '/'\n           n <- netBitsP\n           return $ CIDR (addrFrom a b c d .&. netmask n) n\n  where octetP   = wordP 255\n        netBitsP = wordP  32\n\n\n\n\n\nwordP :: Integral a => Integer -> ReadP a\nwordP lim = do n <- readDecP\n               guard $ n <= lim\n               return $ fi n\n\n\noctetsFrom :: Word32 -> (Word8, Word8, Word8, Word8)\noctetsFrom addr = (oct addr 3, oct addr 2, oct addr 1, oct addr 0)\n  where oct w n = fi $ w `shiftR` (8*n) .&. 0xff\n\n\naddrFrom :: Word8 -> Word8 -> Word8 -> Word8 -> Word32\naddrFrom a b c d = 0 <<+ a <<+ b <<+ c <<+ d\n  where w <<+ o = w `shiftL` 8 .|. fi o\n\n\n\nnetmask :: Word8 -> Word32\nnetmask n = complement $ complement zeroBits `shiftR` fi n\n\nfi :: (Integral a, Num b) => a -> b\nfi = fromIntegral\n\ntest :: String -> IO ()\ntest str = do\n  let cidrStr = maybe \"invalid CIDR string\" cidrShow (cidrRead str)\n  printf \"%-18s -> %s\\n\" str cidrStr\n\nmain :: IO ()\nmain = do\n  test \"87.70.141.1/22\"\n  test \"36.18.154.103/12\"\n  test \"62.62.197.11/29\"\n  test \"67.137.119.181/4\"\n  test \"161.214.74.21/24\"\n  test \"184.232.176.184/18\"\n  \n  test \"184.256.176.184/12\" \n  test \"184.232.176.184/33\" \n  test \"184.232.184/18\"     \n", "target": "import java.text.MessageFormat;\nimport java.text.ParseException;\n\npublic class CanonicalizeCIDR {\n    public static void main(String[] args) {\n        for (String test : TESTS) {\n            try {\n                CIDR cidr = new CIDR(test);\n                System.out.printf(\"%-18s -> %s\\n\", test, cidr.toString());\n            } catch (Exception ex) {\n                System.err.printf(\"Error parsing '%s': %s\\n\", test, ex.getLocalizedMessage());\n            }\n        }\n    }\n\n    private static class CIDR {\n        private CIDR(int address, int maskLength) {\n            this.address = address;\n            this.maskLength = maskLength;\n        }\n\n        private CIDR(String str) throws Exception {\n            Object[] args = new MessageFormat(FORMAT).parse(str);\n            int address = 0;\n            for (int i = 0; i < 4; ++i) {\n                int a = ((Number)args[i]).intValue();\n                if (a < 0 || a > 255)\n                    throw new Exception(\"Invalid IP address\");\n                address <<= 8;\n                address += a;\n            }\n            int maskLength = ((Number)args[4]).intValue();\n            if (maskLength < 1 || maskLength > 32)\n                throw new Exception(\"Invalid mask length\");\n            int mask = ~((1 << (32 - maskLength)) - 1);\n            this.address = address & mask;\n            this.maskLength = maskLength;\n        }\n\n        public String toString() {\n            int address = this.address;\n            int d = address & 0xFF;\n            address >>= 8;\n            int c = address & 0xFF;\n            address >>= 8;\n            int b = address & 0xFF;\n            address >>= 8;\n            int a = address & 0xFF;\n            Object[] args = { a, b, c, d, maskLength };\n            return new MessageFormat(FORMAT).format(args);\n        }\n\n        private int address;\n        private int maskLength;\n        private static final String FORMAT = \"{0,number,integer}.{1,number,integer}.{2,number,integer}.{3,number,integer}/{4,number,integer}\";\n    };\n\n    private static final String[] TESTS = {\n        \"87.70.141.1/22\",\n        \"36.18.154.103/12\",\n        \"62.62.197.11/29\",\n        \"67.137.119.181/4\",\n        \"161.214.74.21/24\",\n        \"184.232.176.184/18\"\n    };\n}\n"}
{"id": 404652, "name": "Sequence of primorial primes", "source": "Translate Haskell to Java: import Data.List (scanl1, elemIndices, nub)\n\nprimes :: [Integer]\nprimes = 2 : filter isPrime [3,5 ..]\n\nisPrime :: Integer -> Bool\nisPrime = isPrime_ primes\n  where\n    isPrime_ :: [Integer] -> Integer -> Bool\n    isPrime_ (p:ps) n\n      | p * p > n = True\n      | n `mod` p == 0 = False\n      | otherwise = isPrime_ ps n\n\nprimorials :: [Integer]\nprimorials = 1 : scanl1 (*) primes\n\nprimorialsPlusMinusOne :: [Integer]\nprimorialsPlusMinusOne = concatMap (((:) . pred) <*> (return . succ)) primorials\n\nsequenceOfPrimorialPrimes :: [Int]\nsequenceOfPrimorialPrimes = (tail . nub) $ (`div` 2) <$> elemIndices True bools\n  where\n    bools = isPrime <$> primorialsPlusMinusOne\n\nmain :: IO ()\nmain = mapM_ print $ take 10 sequenceOfPrimorialPrimes\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialPrimes {\n\n    final static int sieveLimit = 1550_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n\n        int count = 0;\n        for (int i = 1; i < 1000_000 && count < 20; i++) {\n            BigInteger b = primorial(i);\n            if (b.add(BigInteger.ONE).isProbablePrime(1)\n                    || b.subtract(BigInteger.ONE).isProbablePrime(1)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 404653, "name": "Combinations and permutations", "source": "Translate Haskell to Java: perm :: Integer -> Integer -> Integer\nperm n k = product [n-k+1..n]\n\ncomb :: Integer -> Integer -> Integer\ncomb n k = perm n k `div` product [1..k]\n\nmain :: IO ()\nmain = do\n        let showBig maxlen b =\n                let st = show b\n                    stlen = length st\n                in if stlen < maxlen then st else take maxlen st ++ \"... (\"  ++ show (stlen-maxlen) ++  \" more digits)\"\n\n        let showPerm pr = \n                putStrLn $ \"perm(\" ++ show n ++ \",\" ++ show k ++ \") = \"  ++ showBig 40 (perm n k)\n                where n = fst pr\n                      k = snd pr\n\n        let showComb pr = \n                putStrLn $ \"comb(\" ++ show n ++ \",\" ++ show k ++ \") = \"  ++ showBig 40 (comb n k)\n                where n = fst pr\n                      k = snd pr\n\n        putStrLn \"A sample of permutations from 1 to 12:\"\n        mapM_  showPerm [(n, n `div` 3) | n <- [1..12] ]\n\n        putStrLn \"\"\n        putStrLn \"A sample of combinations from 10 to 60:\"\n        mapM_  showComb [(n, n `div` 3) | n <- [10,20..60] ]\n\n        putStrLn \"\"\n        putStrLn \"A sample of permutations from 5 to 15000:\"\n        mapM_  showPerm [(n, n `div` 3) | n <- [5,50,500,1000,5000,15000] ]\n\n        putStrLn \"\"\n        putStrLn \"A sample of combinations from 100 to 1000:\"\n        mapM_  showComb [(n, n `div` 3) | n <- [100,200..1000] ]\n", "target": "import java.math.BigInteger;\n\npublic class CombinationsAndPermutations {\n\n    public static void main(String[] args) {\n        System.out.println(Double.MAX_VALUE);\n        System.out.println(\"A sample of permutations from 1 to 12 with exact Integer arithmetic:\");\n        for ( int n = 1 ; n <= 12 ; n++ ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, permutation(n, k));\n        }\n\n        System.out.println();\n        System.out.println(\"A sample of combinations from 10 to 60 with exact Integer arithmetic:\");\n        for ( int n = 10 ; n <= 60 ; n += 5 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, combination(n, k));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of permutations from 5 to 15000 displayed in floating point arithmetic:\");\n        System.out.printf(\"%d P %d = %s%n\", 5, 2, display(permutation(5, 2), 50));\n        for ( int n = 1000 ; n <= 15000 ; n += 1000 ) {\n            int k = n / 2;\n            System.out.printf(\"%d P %d = %s%n\", n, k, display(permutation(n, k), 50));\n        }\n        \n        System.out.println();\n        System.out.println(\"A sample of combinations from 100 to 1000 displayed in floating point arithmetic:\");\n        for ( int n = 100 ; n <= 1000 ; n += 100 ) {\n            int k = n / 2;\n            System.out.printf(\"%d C %d = %s%n\", n, k, display(combination(n, k), 50));\n        }\n\n    }\n    \n    private static String display(BigInteger val, int precision) {\n        String s = val.toString();\n        precision = Math.min(precision, s.length());\n        StringBuilder sb = new StringBuilder();\n        sb.append(s.substring(0, 1));\n        sb.append(\".\");\n        sb.append(s.substring(1, precision));\n        sb.append(\" * 10^\");\n        sb.append(s.length()-1);\n        return sb.toString();\n    }\n    \n    public static BigInteger combination(int n, int k) {\n        \n        \n        if ( n-k < k ) {\n            k = n-k;\n        }\n        BigInteger result = permutation(n, k);\n        while ( k > 0 ) {\n            result = result.divide(BigInteger.valueOf(k));\n            k--;\n        }\n        return result;\n    }\n    \n    public static BigInteger permutation(int n, int k) {\n        BigInteger result = BigInteger.ONE;\n        for ( int i = n ; i >= n-k+1 ; i-- ) {\n            result = result.multiply(BigInteger.valueOf(i));\n        }\n        return result;\n    }\n    \n}\n"}
{"id": 404654, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Haskell to Java: import Prelude hiding (pi)\nimport Data.Number.MPFR hiding (sqrt, pi, div)\nimport Data.Number.MPFR.Instances.Near ()\n\n\n\ndigitBits :: (Integral a, Num a) => a -> a\ndigitBits n = (n + 1) `div` 2 * 8\n\n\npi :: Integer -> MPFR\npi digits =\n  let eps = fromString (\"1e-\" ++ show digits)\n            (fromInteger $ digitBits digits) 0\n      two = fromInt Near (getPrec eps) 2\n      twoi = 2 :: Int\n      twoI = 2 :: Integer\n      pis a g s n =\n        let aB = (a + g) / two\n            gB = sqrt (a * g)\n            aB2 = aB ^^ twoi\n            sB = s + (two ^^ n) * (aB2 - gB ^^ twoi)\n            num = 4 * aB2\n            den = 1 - sB\n        in (num / den) : pis aB gB sB (n + 1)\n      puntil f (a:b:xs) = if f a b then b else puntil f (b:xs)\n  in puntil (\\a b -> abs (a - b) < eps)\n     $ pis one (one / sqrt two) zero twoI\n\nmain :: IO ()\nmain = do\n  \n  putStrLn $ toString 1000 $ pi 1000\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 404655, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Haskell to Java: import Prelude hiding (pi)\nimport Data.Number.MPFR hiding (sqrt, pi, div)\nimport Data.Number.MPFR.Instances.Near ()\n\n\n\ndigitBits :: (Integral a, Num a) => a -> a\ndigitBits n = (n + 1) `div` 2 * 8\n\n\npi :: Integer -> MPFR\npi digits =\n  let eps = fromString (\"1e-\" ++ show digits)\n            (fromInteger $ digitBits digits) 0\n      two = fromInt Near (getPrec eps) 2\n      twoi = 2 :: Int\n      twoI = 2 :: Integer\n      pis a g s n =\n        let aB = (a + g) / two\n            gB = sqrt (a * g)\n            aB2 = aB ^^ twoi\n            sB = s + (two ^^ n) * (aB2 - gB ^^ twoi)\n            num = 4 * aB2\n            den = 1 - sB\n        in (num / den) : pis aB gB sB (n + 1)\n      puntil f (a:b:xs) = if f a b then b else puntil f (b:xs)\n  in puntil (\\a b -> abs (a - b) < eps)\n     $ pis one (one / sqrt two) zero twoI\n\nmain :: IO ()\nmain = do\n  \n  putStrLn $ toString 1000 $ pi 1000\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 404656, "name": "Window creation_X11", "source": "Translate Haskell to Java: import Graphics.X11.Xlib\nimport Control.Concurrent (threadDelay)\n\nmain = do\n  display <- openDisplay \"\"\n  let defScr = defaultScreen display\n  rw <- rootWindow display defScr\n\n  xwin <- createSimpleWindow display rw\n      0 0 400 200 1\n      (blackPixel display defScr)\n      (whitePixel display defScr)\n\n  setTextProperty display xwin \"Rosetta Code: X11 simple window\" wM_NAME\n\n  mapWindow display xwin\n\n  sync display False\n  threadDelay (5000000)\n\n  destroyWindow display xwin\n  closeDisplay display\n", "target": "import javax.swing.JFrame;\nimport javax.swing.SwingUtilities;\n\npublic class WindowExample {\n\n  public static void main(String[] args) {\n    Runnable runnable = new Runnable() {\n      public void run() {\n\tcreateAndShow();\n      }\n    };\n    SwingUtilities.invokeLater(runnable);\n  }\n\t\n  static void createAndShow() {\n    JFrame frame = new JFrame(\"Hello World\");\n    frame.setSize(640,480);\n    frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n    frame.setVisible(true);\n  }\n}\n"}
{"id": 404657, "name": "Long primes", "source": "Translate Haskell to Java: import Data.List (elemIndex)\n\nlongPrimesUpTo :: Int -> [Int]\nlongPrimesUpTo n =\n  filter isLongPrime $\n    takeWhile (< n) primes\n  where\n    sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p /= 0]\n    primes = sieve [2 ..]\n    isLongPrime n = found\n      where\n        cycles = take n (iterate ((`mod` n) . (10 *)) 1)\n        index = elemIndex (head cycles) $ tail cycles\n        found = case index of\n          (Just i) -> n - i == 2\n          _ -> False\n\ndisplay :: Int -> IO ()\ndisplay n =\n  if n <= 64000\n    then do\n      putStrLn\n        ( show n <> \" is \"\n            <> show (length $ longPrimesUpTo n)\n        )\n      display (n * 2)\n    else pure ()\n\nmain :: IO ()\nmain = do\n  let fiveHundred = longPrimesUpTo 500\n  putStrLn\n    ( \"The long primes up to 35 are:\\n\"\n        <> show fiveHundred\n        <> \"\\n\"\n    )\n  putStrLn (\"500 is \" <> show (length fiveHundred))\n  display 1000\n", "target": "import java.util.LinkedList;\nimport java.util.List;\n\npublic class LongPrimes\n{\n    private static void sieve(int limit, List<Integer> primes)\n    {\n        boolean[] c = new boolean[limit];\n        for (int i = 0; i < limit; i++)\n            c[i] = false;\n        \n        int p = 3, n = 0;\n        int p2 = p * p;\n        while (p2 <= limit)\n        {\n            for (int i = p2; i <= limit; i += 2 * p)\n                c[i] = true;\n            do\n                p += 2;\n            while (c[p]);\n            p2 = p * p;\n        }\n        for (int i = 3; i <= limit; i += 2)\n            if (!c[i])\n                primes.add(i);\n    }\n\n    \n    private static int findPeriod(int n)\n    {\n        int r = 1, period = 0;\n        for (int i = 1; i < n; i++)\n            r = (10 * r) % n;\n        int rr = r;\n        do\n        {\n            r = (10 * r) % n;\n            ++period;\n        }\n        while (r != rr);\n        return period;\n    }\n    \n    public static void main(String[] args)\n    {\n        int[] numbers = new int[]{500, 1000, 2000, 4000, 8000, 16000, 32000, 64000};\n        int[] totals = new int[numbers.length]; \n        List<Integer> primes = new LinkedList<Integer>();\n        List<Integer> longPrimes = new LinkedList<Integer>();\n        sieve(64000, primes);\n        for (int prime : primes)\n            if (findPeriod(prime) == prime - 1)\n                longPrimes.add(prime);\n        int count = 0, index = 0;\n        for (int longPrime : longPrimes)\n        {\n            if (longPrime > numbers[index])\n                totals[index++] = count;\n            ++count;\n        }\n        totals[numbers.length - 1] = count;\n        System.out.println(\"The long primes up to \" + numbers[0] + \" are:\");\n        System.out.println(longPrimes.subList(0, totals[0]));\n        System.out.println();\n        System.out.println(\"The number of long primes up to:\");\n        for (int i = 0; i <= 7; i++)\n            System.out.printf(\"  %5d is %d\\n\", numbers[i], totals[i]);\n    }\n}\n"}
{"id": 404658, "name": "Primorial numbers", "source": "Translate Haskell to Java: import Control.Arrow ((&&&))\nimport Data.List (scanl1, foldl1')\n\ngetNthPrimorial :: Int -> Integer\ngetNthPrimorial n = foldl1' (*) (take n primes)\n\nprimes :: [Integer]\nprimes = 2 : filter isPrime [3,5..]\n\nisPrime :: Integer -> Bool\nisPrime = isPrime_ primes\n  where isPrime_ :: [Integer] -> Integer -> Bool\n        isPrime_ (p:ps) n\n          | p * p > n      = True\n          | n `mod` p == 0 = False\n          | otherwise      = isPrime_ ps n\n\nprimorials :: [Integer]\nprimorials = 1 : scanl1 (*) primes\n\nmain :: IO ()\nmain = do\n  \n  let firstTen = take 10 primorials\n  putStrLn $ \"The first 10 primorial numbers are: \" ++ show firstTen\n\n  \n  let powersOfTen = [1..6]\n      primorialTens = map (id &&& (length . show . getNthPrimorial . (10^))) powersOfTen\n      calculate = mapM_ (\\(a,b) -> putStrLn $ \"Primorial(10^\"++show a++\") has \"++show b++\" digits\")\n  calculate primorialTens\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialNumbers {\n    final static int sieveLimit = 1300_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++)\n            System.out.printf(\"primorial(%d): %d%n\", i, primorial(i));\n\n        for (int i = 1; i < 6; i++) {\n            int len = primorial((int) Math.pow(10, i)).toString().length();\n            System.out.printf(\"primorial(10^%d) has length %d%n\", i, len);\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 404659, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Haskell to Java: import Data.Ratio (Ratio, (%), denominator, numerator)\n\negyptianFraction :: Integral a => Ratio a -> [Ratio a]\negyptianFraction n\n  | n < 0 = map negate (egyptianFraction (-n))\n  | n == 0 = []\n  | x == 1 = [n]\n  | x > y = (x `div` y % 1) : egyptianFraction (x `mod` y % y)\n  | otherwise = (1 % r) : egyptianFraction ((-y) `mod` x % (y * r))\n  where\n    x = numerator n\n    y = denominator n\n    r = y `div` x + 1\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class EgyptianFractions {\n    private static BigInteger gcd(BigInteger a, BigInteger b) {\n        if (b.equals(BigInteger.ZERO)) {\n            return a;\n        }\n        return gcd(b, a.mod(b));\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private BigInteger num, denom;\n\n        public Frac(BigInteger n, BigInteger d) {\n            if (d.equals(BigInteger.ZERO)) {\n                throw new IllegalArgumentException(\"Parameter d may not be zero.\");\n            }\n\n            BigInteger nn = n;\n            BigInteger dd = d;\n            if (nn.equals(BigInteger.ZERO)) {\n                dd = BigInteger.ONE;\n            } else if (dd.compareTo(BigInteger.ZERO) < 0) {\n                nn = nn.negate();\n                dd = dd.negate();\n            }\n            BigInteger g = gcd(nn, dd).abs();\n            if (g.compareTo(BigInteger.ZERO) > 0) {\n                nn = nn.divide(g);\n                dd = dd.divide(g);\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac(int n, int d) {\n            this(BigInteger.valueOf(n), BigInteger.valueOf(d));\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(\n                num.multiply(rhs.denom).add(denom.multiply(rhs.num)),\n                rhs.denom.multiply(denom)\n            );\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(num.negate(), denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return plus(rhs.unaryMinus());\n        }\n\n        @Override\n        public int compareTo(Frac rhs) {\n            BigDecimal diff = this.toBigDecimal().subtract(rhs.toBigDecimal());\n            if (diff.compareTo(BigDecimal.ZERO) < 0) {\n                return -1;\n            }\n            if (BigDecimal.ZERO.compareTo(diff) < 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (null == obj || !(obj instanceof Frac)) {\n                return false;\n            }\n            Frac rhs = (Frac) obj;\n            return compareTo(rhs) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom.equals(BigInteger.ONE)) {\n                return num.toString();\n            }\n            return String.format(\"%s/%s\", num, denom);\n        }\n\n        public BigDecimal toBigDecimal() {\n            BigDecimal bdn = new BigDecimal(num);\n            BigDecimal bdd = new BigDecimal(denom);\n            return bdn.divide(bdd, MathContext.DECIMAL128);\n        }\n\n        public List<Frac> toEgyptian() {\n            if (num.equals(BigInteger.ZERO)) {\n                return Collections.singletonList(this);\n            }\n            List<Frac> fracs = new ArrayList<>();\n            if (num.abs().compareTo(denom.abs()) >= 0) {\n                Frac div = new Frac(num.divide(denom), BigInteger.ONE);\n                Frac rem = this.minus(div);\n                fracs.add(div);\n                toEgyptian(rem.num, rem.denom, fracs);\n            } else {\n                toEgyptian(num, denom, fracs);\n            }\n            return fracs;\n        }\n\n        public void toEgyptian(BigInteger n, BigInteger d, List<Frac> fracs) {\n            if (n.equals(BigInteger.ZERO)) {\n                return;\n            }\n            BigDecimal n2 = new BigDecimal(n);\n            BigDecimal d2 = new BigDecimal(d);\n            BigDecimal[] divRem = d2.divideAndRemainder(n2, MathContext.UNLIMITED);\n            BigInteger div = divRem[0].toBigInteger();\n            if (divRem[1].compareTo(BigDecimal.ZERO) > 0) {\n                div = div.add(BigInteger.ONE);\n            }\n            fracs.add(new Frac(BigInteger.ONE, div));\n            BigInteger n3 = d.negate().mod(n);\n            if (n3.compareTo(BigInteger.ZERO) < 0) {\n                n3 = n3.add(n);\n            }\n            BigInteger d3 = d.multiply(div);\n            Frac f = new Frac(n3, d3);\n            if (f.num.equals(BigInteger.ONE)) {\n                fracs.add(f);\n                return;\n            }\n            toEgyptian(f.num, f.denom, fracs);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Frac> fracs = List.of(\n            new Frac(43, 48),\n            new Frac(5, 121),\n            new Frac(2014, 59)\n        );\n        for (Frac frac : fracs) {\n            List<Frac> list = frac.toEgyptian();\n            Frac first = list.get(0);\n            if (first.denom.equals(BigInteger.ONE)) {\n                System.out.printf(\"%s -> [%s] + \", frac, first);\n            } else {\n                System.out.printf(\"%s -> %s\", frac, first);\n            }\n            for (int i = 1; i < list.size(); ++i) {\n                System.out.printf(\" + %s\", list.get(i));\n            }\n            System.out.println();\n        }\n\n        for (Integer r : List.of(98, 998)) {\n            if (r == 98) {\n                System.out.println(\"\\nFor proper fractions with 1 or 2 digits:\");\n            } else {\n                System.out.println(\"\\nFor proper fractions with 1, 2 or 3 digits:\");\n            }\n\n            int maxSize = 0;\n            List<Frac> maxSizeFracs = new ArrayList<>();\n            BigInteger maxDen = BigInteger.ZERO;\n            List<Frac> maxDenFracs = new ArrayList<>();\n            boolean[][] sieve = new boolean[r + 1][];\n            for (int i = 0; i < r + 1; ++i) {\n                sieve[i] = new boolean[r + 2];\n            }\n            for (int i = 1; i < r; ++i) {\n                for (int j = i + 1; j < r + 1; ++j) {\n                    if (sieve[i][j]) continue;\n                    Frac f = new Frac(i, j);\n                    List<Frac> list = f.toEgyptian();\n                    int listSize = list.size();\n                    if (listSize > maxSize) {\n                        maxSize = listSize;\n                        maxSizeFracs.clear();\n                        maxSizeFracs.add(f);\n                    } else if (listSize == maxSize) {\n                        maxSizeFracs.add(f);\n                    }\n                    BigInteger listDen = list.get(list.size() - 1).denom;\n                    if (listDen.compareTo(maxDen) > 0) {\n                        maxDen = listDen;\n                        maxDenFracs.clear();\n                        maxDenFracs.add(f);\n                    } else if (listDen.equals(maxDen)) {\n                        maxDenFracs.add(f);\n                    }\n                    if (i < r / 2) {\n                        int k = 2;\n                        while (true) {\n                            if (j * k > r + 1) break;\n                            sieve[i * k][j * k] = true;\n                            k++;\n                        }\n                    }\n                }\n            }\n            System.out.printf(\"  largest number of items = %s\\n\", maxSize);\n            System.out.printf(\"fraction(s) with this number\u00a0: %s\\n\", maxSizeFracs);\n            String md = maxDen.toString();\n            System.out.printf(\"  largest denominator = %s digits, \", md.length());\n            System.out.printf(\"%s...%s\\n\", md.substring(0, 20), md.substring(md.length() - 20, md.length()));\n            System.out.printf(\"fraction(s) with this denominator\u00a0: %s\\n\", maxDenFracs);\n        }\n    }\n}\n"}
{"id": 404660, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Haskell to Java: import Data.Ratio (Ratio, (%), denominator, numerator)\n\negyptianFraction :: Integral a => Ratio a -> [Ratio a]\negyptianFraction n\n  | n < 0 = map negate (egyptianFraction (-n))\n  | n == 0 = []\n  | x == 1 = [n]\n  | x > y = (x `div` y % 1) : egyptianFraction (x `mod` y % y)\n  | otherwise = (1 % r) : egyptianFraction ((-y) `mod` x % (y * r))\n  where\n    x = numerator n\n    y = denominator n\n    r = y `div` x + 1\n", "target": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.math.MathContext;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class EgyptianFractions {\n    private static BigInteger gcd(BigInteger a, BigInteger b) {\n        if (b.equals(BigInteger.ZERO)) {\n            return a;\n        }\n        return gcd(b, a.mod(b));\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private BigInteger num, denom;\n\n        public Frac(BigInteger n, BigInteger d) {\n            if (d.equals(BigInteger.ZERO)) {\n                throw new IllegalArgumentException(\"Parameter d may not be zero.\");\n            }\n\n            BigInteger nn = n;\n            BigInteger dd = d;\n            if (nn.equals(BigInteger.ZERO)) {\n                dd = BigInteger.ONE;\n            } else if (dd.compareTo(BigInteger.ZERO) < 0) {\n                nn = nn.negate();\n                dd = dd.negate();\n            }\n            BigInteger g = gcd(nn, dd).abs();\n            if (g.compareTo(BigInteger.ZERO) > 0) {\n                nn = nn.divide(g);\n                dd = dd.divide(g);\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac(int n, int d) {\n            this(BigInteger.valueOf(n), BigInteger.valueOf(d));\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(\n                num.multiply(rhs.denom).add(denom.multiply(rhs.num)),\n                rhs.denom.multiply(denom)\n            );\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(num.negate(), denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return plus(rhs.unaryMinus());\n        }\n\n        @Override\n        public int compareTo(Frac rhs) {\n            BigDecimal diff = this.toBigDecimal().subtract(rhs.toBigDecimal());\n            if (diff.compareTo(BigDecimal.ZERO) < 0) {\n                return -1;\n            }\n            if (BigDecimal.ZERO.compareTo(diff) < 0) {\n                return 1;\n            }\n            return 0;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (null == obj || !(obj instanceof Frac)) {\n                return false;\n            }\n            Frac rhs = (Frac) obj;\n            return compareTo(rhs) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom.equals(BigInteger.ONE)) {\n                return num.toString();\n            }\n            return String.format(\"%s/%s\", num, denom);\n        }\n\n        public BigDecimal toBigDecimal() {\n            BigDecimal bdn = new BigDecimal(num);\n            BigDecimal bdd = new BigDecimal(denom);\n            return bdn.divide(bdd, MathContext.DECIMAL128);\n        }\n\n        public List<Frac> toEgyptian() {\n            if (num.equals(BigInteger.ZERO)) {\n                return Collections.singletonList(this);\n            }\n            List<Frac> fracs = new ArrayList<>();\n            if (num.abs().compareTo(denom.abs()) >= 0) {\n                Frac div = new Frac(num.divide(denom), BigInteger.ONE);\n                Frac rem = this.minus(div);\n                fracs.add(div);\n                toEgyptian(rem.num, rem.denom, fracs);\n            } else {\n                toEgyptian(num, denom, fracs);\n            }\n            return fracs;\n        }\n\n        public void toEgyptian(BigInteger n, BigInteger d, List<Frac> fracs) {\n            if (n.equals(BigInteger.ZERO)) {\n                return;\n            }\n            BigDecimal n2 = new BigDecimal(n);\n            BigDecimal d2 = new BigDecimal(d);\n            BigDecimal[] divRem = d2.divideAndRemainder(n2, MathContext.UNLIMITED);\n            BigInteger div = divRem[0].toBigInteger();\n            if (divRem[1].compareTo(BigDecimal.ZERO) > 0) {\n                div = div.add(BigInteger.ONE);\n            }\n            fracs.add(new Frac(BigInteger.ONE, div));\n            BigInteger n3 = d.negate().mod(n);\n            if (n3.compareTo(BigInteger.ZERO) < 0) {\n                n3 = n3.add(n);\n            }\n            BigInteger d3 = d.multiply(div);\n            Frac f = new Frac(n3, d3);\n            if (f.num.equals(BigInteger.ONE)) {\n                fracs.add(f);\n                return;\n            }\n            toEgyptian(f.num, f.denom, fracs);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Frac> fracs = List.of(\n            new Frac(43, 48),\n            new Frac(5, 121),\n            new Frac(2014, 59)\n        );\n        for (Frac frac : fracs) {\n            List<Frac> list = frac.toEgyptian();\n            Frac first = list.get(0);\n            if (first.denom.equals(BigInteger.ONE)) {\n                System.out.printf(\"%s -> [%s] + \", frac, first);\n            } else {\n                System.out.printf(\"%s -> %s\", frac, first);\n            }\n            for (int i = 1; i < list.size(); ++i) {\n                System.out.printf(\" + %s\", list.get(i));\n            }\n            System.out.println();\n        }\n\n        for (Integer r : List.of(98, 998)) {\n            if (r == 98) {\n                System.out.println(\"\\nFor proper fractions with 1 or 2 digits:\");\n            } else {\n                System.out.println(\"\\nFor proper fractions with 1, 2 or 3 digits:\");\n            }\n\n            int maxSize = 0;\n            List<Frac> maxSizeFracs = new ArrayList<>();\n            BigInteger maxDen = BigInteger.ZERO;\n            List<Frac> maxDenFracs = new ArrayList<>();\n            boolean[][] sieve = new boolean[r + 1][];\n            for (int i = 0; i < r + 1; ++i) {\n                sieve[i] = new boolean[r + 2];\n            }\n            for (int i = 1; i < r; ++i) {\n                for (int j = i + 1; j < r + 1; ++j) {\n                    if (sieve[i][j]) continue;\n                    Frac f = new Frac(i, j);\n                    List<Frac> list = f.toEgyptian();\n                    int listSize = list.size();\n                    if (listSize > maxSize) {\n                        maxSize = listSize;\n                        maxSizeFracs.clear();\n                        maxSizeFracs.add(f);\n                    } else if (listSize == maxSize) {\n                        maxSizeFracs.add(f);\n                    }\n                    BigInteger listDen = list.get(list.size() - 1).denom;\n                    if (listDen.compareTo(maxDen) > 0) {\n                        maxDen = listDen;\n                        maxDenFracs.clear();\n                        maxDenFracs.add(f);\n                    } else if (listDen.equals(maxDen)) {\n                        maxDenFracs.add(f);\n                    }\n                    if (i < r / 2) {\n                        int k = 2;\n                        while (true) {\n                            if (j * k > r + 1) break;\n                            sieve[i * k][j * k] = true;\n                            k++;\n                        }\n                    }\n                }\n            }\n            System.out.printf(\"  largest number of items = %s\\n\", maxSize);\n            System.out.printf(\"fraction(s) with this number\u00a0: %s\\n\", maxSizeFracs);\n            String md = maxDen.toString();\n            System.out.printf(\"  largest denominator = %s digits, \", md.length());\n            System.out.printf(\"%s...%s\\n\", md.substring(0, 20), md.substring(md.length() - 20, md.length()));\n            System.out.printf(\"fraction(s) with this denominator\u00a0: %s\\n\", maxDenFracs);\n        }\n    }\n}\n"}
{"id": 404661, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Haskell to Java: gaussLegendre n f a b = d*sum [ w x*f(m + d*x) | x <- roots ]\n  where d = (b - a)/2\n        m = (b + a)/2\n        w x = 2/(1-x^2)/(legendreP' n x)^2\n        roots = map (findRoot (legendreP n) (legendreP' n) . x0) [1..n]\n        x0 i = cos (pi*(i-1/4)/(n+1/2))\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class Test {\n    final static int N = 5;\n\n    static double[] lroots = new double[N];\n    static double[] weight = new double[N];\n    static double[][] lcoef = new double[N + 1][N + 1];\n\n    static void legeCoef() {\n        lcoef[0][0] = lcoef[1][1] = 1;\n\n        for (int n = 2; n <= N; n++) {\n\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n\n            for (int i = 1; i <= n; i++) {\n                lcoef[n][i] = ((2 * n - 1) * lcoef[n - 1][i - 1]\n                        - (n - 1) * lcoef[n - 2][i]) / n;\n            }\n        }\n    }\n\n    static double legeEval(int n, double x) {\n        double s = lcoef[n][n];\n        for (int i = n; i > 0; i--)\n            s = s * x + lcoef[n][i - 1];\n        return s;\n    }\n\n    static double legeDiff(int n, double x) {\n        return n * (x * legeEval(n, x) - legeEval(n - 1, x)) / (x * x - 1);\n    }\n\n    static void legeRoots() {\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = cos(PI * (i - 0.25) / (N + 0.5));\n            do {\n                x1 = x;\n                x -= legeEval(N, x) / legeDiff(N, x);\n            } while (x != x1);\n\n            lroots[i - 1] = x;\n\n            x1 = legeDiff(N, x);\n            weight[i - 1] = 2 / ((1 - x * x) * x1 * x1);\n        }\n    }\n\n    static double legeInte(Function<Double, Double> f, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weight[i] * f.apply(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n\n    public static void main(String[] args) {\n        legeCoef();\n        legeRoots();\n\n        System.out.print(\"Roots: \");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", lroots[i]);\n\n        System.out.print(\"\\nWeight:\");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", weight[i]);\n\n        System.out.printf(\"%nintegrating Exp(x) over [-3, 3]:%n\\t%10.8f,%n\"\n                + \"compared to actual%n\\t%10.8f%n\",\n                legeInte(x -> exp(x), -3, 3), exp(3) - exp(-3));\n    }\n}\n"}
{"id": 404662, "name": "K-d tree", "source": "Translate Haskell to Java: import System.Random\nimport Data.List (sortBy, genericLength, minimumBy)\nimport Data.Ord (comparing)\n\n\n\ntype DimensionalAccessors a b = [a -> b]\n\n\ndata Tree a = Node a (Tree a) (Tree a)\n            | Empty\n\ninstance Show a => Show (Tree a) where\n  show Empty = \"Empty\"\n  show (Node value left right) =\n    \"(\" ++ show value ++ \" \" ++ show left ++ \" \" ++ show right ++ \")\" \n\n\ndata KDTree a b = KDTree (DimensionalAccessors a b) (Tree a)\n\ninstance Show a => Show (KDTree a b) where\n  show (KDTree _ tree) = \"KDTree \" ++ show tree\n\n\nsqrDist :: Num b => DimensionalAccessors a b -> a -> a -> b\nsqrDist dims a b = sum $ map square $ zipWith (-) a' b'\n  where\n    a' = map ($ a) dims\n    b' = map ($ b) dims\n\nsquare :: Num a => a -> a\nsquare = (^ 2)\n\n\ninsert :: Ord b => KDTree a b -> a -> KDTree a b\ninsert (KDTree dims tree) value = KDTree dims $ ins (cycle dims) tree\n  where\n    ins _      Empty                   = Node value Empty Empty\n    ins (d:ds) (Node split left right) =\n      if d value < d split\n      then Node split (ins ds left) right\n      else Node split left (ins ds right)\n\n\nempty :: DimensionalAccessors a b -> KDTree a b\nempty dims = KDTree dims Empty\n\n\nsingleton :: Ord b => DimensionalAccessors a b -> a -> KDTree a b\nsingleton dims value = insert (empty dims) value\n\n\nfromList :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromList dims values = KDTree dims $ fList (cycle dims) values\n  where\n    fList _      []     = Empty\n    fList (d:ds) values =\n      let sorted          = sortBy (comparing d) values\n          (lower, higher) = splitAt (genericLength sorted `div` 2) sorted\n      in case higher of\n        []          -> Empty\n        median:rest -> Node median (fList ds lower) (fList ds rest)\n\n\n\nfromListLinear :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromListLinear dims values = foldl insert (empty dims) values\n\n\n\nnearest :: (Ord b, Num b, Integral c) => KDTree a b -> a -> (Maybe a, c)\nnearest (KDTree dims tree) value = near (cycle dims) tree\n  where\n    dist = sqrDist dims\n    \n    near _      Empty                    = (Nothing, 1)\n    \n    near _      (Node split Empty Empty) = (Just split, 1)\n    near (d:ds) (Node split left right)  =\n      \n      let dimdist x y    = square (d x - d y)\n          splitDist      = dist value split\n          hyperPlaneDist = dimdist value split\n          bestLeft       = near ds left\n          bestRight      = near ds right\n          \n          \n          ((maybeThisBest, thisCount), (maybeOtherBest, otherCount)) =\n            if d value < d split\n            then (bestLeft, bestRight)\n            else (bestRight, bestLeft)\n      in case maybeThisBest of\n        Nothing    ->\n          \n          \n          \n          let count = 1 + thisCount + otherCount\n          in case maybeOtherBest of\n            \n            \n            \n            Nothing         -> (Just split, count)\n            \n            \n            Just otherBest ->\n              if dist value otherBest < splitDist\n              then (maybeOtherBest, count)\n              else (Just split, count)\n        \n        Just thisBest ->\n          let thisBestDist = dist value thisBest\n              best         =\n                \n                if splitDist < thisBestDist\n                then split\n                else thisBest\n              bestDist     = dist value best\n          in\n            if bestDist < hyperPlaneDist\n            \n            \n            \n            then (Just best, 1 + thisCount)\n            \n            \n            else\n              let count = 1 + thisCount + otherCount\n              in case maybeOtherBest of\n                Nothing        -> (Just best, count)\n                Just otherBest ->\n                  if bestDist < dist value otherBest\n                  then (Just best, count)\n                  else (maybeOtherBest, count)\n\n\ntuple2D :: [(a, a) -> a]\ntuple2D = [fst, snd]\n\n\ntuple3D :: [(a, a, a) -> a]\ntuple3D = [d1, d2, d3]\n  where\n    d1 (a, _, _) = a\n    d2 (_, b, _) = b\n    d3 (_, _, c) = c\n\n\ninstance (Random a, Random b, Random c) => Random (a, b, c) where\n  random gen =\n    let (vA, genA) = random gen\n        (vB, genB) = random genA\n        (vC, genC) = random genB\n    in ((vA, vB, vC), genC)\n\n  randomR ((lA, lB, lC), (hA, hB, hC)) gen =\n    let (vA, genA) = randomR (lA, hA) gen\n        (vB, genB) = randomR (lB, hB) genA\n        (vC, genC) = randomR (lC, hC) genB\n    in ((vA, vB, vC), genC)\n\nprintResults :: (Show a, Show b, Show c, Floating c) =>\n                a -> (Maybe a, b) -> DimensionalAccessors a c -> IO ()\nprintResults point result dims = do\n  let (nearest, visited) = result\n  case nearest of\n    Nothing    -> putStrLn \"Could not find nearest.\"\n    Just value -> do\n      let dist = sqrt $ sqrDist dims point value\n      putStrLn $ \"Point:    \" ++ show point\n      putStrLn $ \"Nearest:  \" ++ show value\n      putStrLn $ \"Distance: \" ++ show dist\n      putStrLn $ \"Visited:  \" ++ show visited\n      putStrLn \"\"\n\n\nlinearNearest :: (Ord b, Num b) => DimensionalAccessors a b -> a -> [a] -> Maybe a\nlinearNearest _    _     [] = Nothing\nlinearNearest dims value xs = Just $ minimumBy (comparing $ sqrDist dims value) xs\n\nmain :: IO ()\nmain = do\n  let wikiValues :: [(Double, Double)]\n      wikiValues  = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)]\n      wikiTree    = fromList tuple2D wikiValues\n      wikiSearch  = (9, 2)\n      wikiNearest = nearest wikiTree wikiSearch\n  putStrLn \"Wikipedia example:\"\n  printResults wikiSearch wikiNearest tuple2D\n\n  let stdGen                = mkStdGen 0\n      randRange :: ((Double, Double, Double), (Double, Double, Double))\n      randRange             = ((0, 0, 0), (1000, 1000, 1000))\n      (randSearch, stdGenB) = randomR randRange stdGen\n      randValues            = take 1000 $ randomRs randRange stdGenB\n      randTree              = fromList tuple3D randValues\n      randNearest           = nearest randTree randSearch\n      randNearestLinear     = linearNearest tuple3D randSearch randValues\n  putStrLn \"1000 random 3D points on the range of [0, 1000):\"\n  printResults randSearch randNearest tuple3D\n  putStrLn \"Confirm naive nearest:\"\n  print randNearestLinear\n", "target": "import java.util.*;\n\npublic class KdTree {\n    private int dimensions_;\n    private Node root_ = null;\n    private Node best_ = null;\n    private double bestDistance_ = 0;\n    private int visited_ = 0;\n    \n    public KdTree(int dimensions, List<Node> nodes) {\n        dimensions_ = dimensions;\n        root_ = makeTree(nodes, 0, nodes.size(), 0);\n    }\n    \n    public Node findNearest(Node target) {\n        if (root_ == null)\n            throw new IllegalStateException(\"Tree is empty!\");\n        best_ = null;\n        visited_ = 0;\n        bestDistance_ = 0;\n        nearest(root_, target, 0);\n        return best_;\n    }\n    \n    public int visited() {\n        return visited_;\n    }\n    \n    public double distance() {\n        return Math.sqrt(bestDistance_);\n    }\n    \n    private void nearest(Node root, Node target, int index) {\n        if (root == null)\n            return;\n        ++visited_;\n        double d = root.distance(target);\n        if (best_ == null || d < bestDistance_) {\n            bestDistance_ = d;\n            best_ = root;\n        }\n        if (bestDistance_ == 0)\n            return;\n        double dx = root.get(index) - target.get(index);\n        index = (index + 1) % dimensions_;\n        nearest(dx > 0 ? root.left_ : root.right_, target, index);\n        if (dx * dx >= bestDistance_)\n            return;\n        nearest(dx > 0 ? root.right_ : root.left_, target, index);\n    }\n    \n    private Node makeTree(List<Node> nodes, int begin, int end, int index) {\n        if (end <= begin)\n            return null;\n        int n = begin + (end - begin)/2;\n        Node node = QuickSelect.select(nodes, begin, end - 1, n, new NodeComparator(index));\n        index = (index + 1) % dimensions_;\n        node.left_ = makeTree(nodes, begin, n, index);\n        node.right_ = makeTree(nodes, n + 1, end, index);\n        return node;\n    }\n    \n    private static class NodeComparator implements Comparator<Node> {\n        private int index_;\n\n        private NodeComparator(int index) {\n            index_ = index;\n        }\n        public int compare(Node n1, Node n2) {\n            return Double.compare(n1.get(index_), n2.get(index_));\n        }\n    }\n    \n    public static class Node {\n        private double[] coords_;\n        private Node left_ = null;\n        private Node right_ = null;\n\n        public Node(double[] coords) {\n            coords_ = coords;\n        }\n        public Node(double x, double y) {\n            this(new double[]{x, y});\n        }\n        public Node(double x, double y, double z) {\n            this(new double[]{x, y, z});\n        }\n        double get(int index) {\n            return coords_[index];\n        }\n        double distance(Node node) {\n            double dist = 0;\n            for (int i = 0; i < coords_.length; ++i) {\n                double d = coords_[i] - node.coords_[i];\n                dist += d * d;\n            }\n            return dist;\n        }\n        public String toString() {\n            StringBuilder s = new StringBuilder(\"(\");\n            for (int i = 0; i < coords_.length; ++i) {\n                if (i > 0)\n                    s.append(\", \");\n                s.append(coords_[i]);\n            }\n            s.append(')');\n            return s.toString();\n        }\n    }\n}\n"}
{"id": 404663, "name": "K-d tree", "source": "Translate Haskell to Java: import System.Random\nimport Data.List (sortBy, genericLength, minimumBy)\nimport Data.Ord (comparing)\n\n\n\ntype DimensionalAccessors a b = [a -> b]\n\n\ndata Tree a = Node a (Tree a) (Tree a)\n            | Empty\n\ninstance Show a => Show (Tree a) where\n  show Empty = \"Empty\"\n  show (Node value left right) =\n    \"(\" ++ show value ++ \" \" ++ show left ++ \" \" ++ show right ++ \")\" \n\n\ndata KDTree a b = KDTree (DimensionalAccessors a b) (Tree a)\n\ninstance Show a => Show (KDTree a b) where\n  show (KDTree _ tree) = \"KDTree \" ++ show tree\n\n\nsqrDist :: Num b => DimensionalAccessors a b -> a -> a -> b\nsqrDist dims a b = sum $ map square $ zipWith (-) a' b'\n  where\n    a' = map ($ a) dims\n    b' = map ($ b) dims\n\nsquare :: Num a => a -> a\nsquare = (^ 2)\n\n\ninsert :: Ord b => KDTree a b -> a -> KDTree a b\ninsert (KDTree dims tree) value = KDTree dims $ ins (cycle dims) tree\n  where\n    ins _      Empty                   = Node value Empty Empty\n    ins (d:ds) (Node split left right) =\n      if d value < d split\n      then Node split (ins ds left) right\n      else Node split left (ins ds right)\n\n\nempty :: DimensionalAccessors a b -> KDTree a b\nempty dims = KDTree dims Empty\n\n\nsingleton :: Ord b => DimensionalAccessors a b -> a -> KDTree a b\nsingleton dims value = insert (empty dims) value\n\n\nfromList :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromList dims values = KDTree dims $ fList (cycle dims) values\n  where\n    fList _      []     = Empty\n    fList (d:ds) values =\n      let sorted          = sortBy (comparing d) values\n          (lower, higher) = splitAt (genericLength sorted `div` 2) sorted\n      in case higher of\n        []          -> Empty\n        median:rest -> Node median (fList ds lower) (fList ds rest)\n\n\n\nfromListLinear :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromListLinear dims values = foldl insert (empty dims) values\n\n\n\nnearest :: (Ord b, Num b, Integral c) => KDTree a b -> a -> (Maybe a, c)\nnearest (KDTree dims tree) value = near (cycle dims) tree\n  where\n    dist = sqrDist dims\n    \n    near _      Empty                    = (Nothing, 1)\n    \n    near _      (Node split Empty Empty) = (Just split, 1)\n    near (d:ds) (Node split left right)  =\n      \n      let dimdist x y    = square (d x - d y)\n          splitDist      = dist value split\n          hyperPlaneDist = dimdist value split\n          bestLeft       = near ds left\n          bestRight      = near ds right\n          \n          \n          ((maybeThisBest, thisCount), (maybeOtherBest, otherCount)) =\n            if d value < d split\n            then (bestLeft, bestRight)\n            else (bestRight, bestLeft)\n      in case maybeThisBest of\n        Nothing    ->\n          \n          \n          \n          let count = 1 + thisCount + otherCount\n          in case maybeOtherBest of\n            \n            \n            \n            Nothing         -> (Just split, count)\n            \n            \n            Just otherBest ->\n              if dist value otherBest < splitDist\n              then (maybeOtherBest, count)\n              else (Just split, count)\n        \n        Just thisBest ->\n          let thisBestDist = dist value thisBest\n              best         =\n                \n                if splitDist < thisBestDist\n                then split\n                else thisBest\n              bestDist     = dist value best\n          in\n            if bestDist < hyperPlaneDist\n            \n            \n            \n            then (Just best, 1 + thisCount)\n            \n            \n            else\n              let count = 1 + thisCount + otherCount\n              in case maybeOtherBest of\n                Nothing        -> (Just best, count)\n                Just otherBest ->\n                  if bestDist < dist value otherBest\n                  then (Just best, count)\n                  else (maybeOtherBest, count)\n\n\ntuple2D :: [(a, a) -> a]\ntuple2D = [fst, snd]\n\n\ntuple3D :: [(a, a, a) -> a]\ntuple3D = [d1, d2, d3]\n  where\n    d1 (a, _, _) = a\n    d2 (_, b, _) = b\n    d3 (_, _, c) = c\n\n\ninstance (Random a, Random b, Random c) => Random (a, b, c) where\n  random gen =\n    let (vA, genA) = random gen\n        (vB, genB) = random genA\n        (vC, genC) = random genB\n    in ((vA, vB, vC), genC)\n\n  randomR ((lA, lB, lC), (hA, hB, hC)) gen =\n    let (vA, genA) = randomR (lA, hA) gen\n        (vB, genB) = randomR (lB, hB) genA\n        (vC, genC) = randomR (lC, hC) genB\n    in ((vA, vB, vC), genC)\n\nprintResults :: (Show a, Show b, Show c, Floating c) =>\n                a -> (Maybe a, b) -> DimensionalAccessors a c -> IO ()\nprintResults point result dims = do\n  let (nearest, visited) = result\n  case nearest of\n    Nothing    -> putStrLn \"Could not find nearest.\"\n    Just value -> do\n      let dist = sqrt $ sqrDist dims point value\n      putStrLn $ \"Point:    \" ++ show point\n      putStrLn $ \"Nearest:  \" ++ show value\n      putStrLn $ \"Distance: \" ++ show dist\n      putStrLn $ \"Visited:  \" ++ show visited\n      putStrLn \"\"\n\n\nlinearNearest :: (Ord b, Num b) => DimensionalAccessors a b -> a -> [a] -> Maybe a\nlinearNearest _    _     [] = Nothing\nlinearNearest dims value xs = Just $ minimumBy (comparing $ sqrDist dims value) xs\n\nmain :: IO ()\nmain = do\n  let wikiValues :: [(Double, Double)]\n      wikiValues  = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)]\n      wikiTree    = fromList tuple2D wikiValues\n      wikiSearch  = (9, 2)\n      wikiNearest = nearest wikiTree wikiSearch\n  putStrLn \"Wikipedia example:\"\n  printResults wikiSearch wikiNearest tuple2D\n\n  let stdGen                = mkStdGen 0\n      randRange :: ((Double, Double, Double), (Double, Double, Double))\n      randRange             = ((0, 0, 0), (1000, 1000, 1000))\n      (randSearch, stdGenB) = randomR randRange stdGen\n      randValues            = take 1000 $ randomRs randRange stdGenB\n      randTree              = fromList tuple3D randValues\n      randNearest           = nearest randTree randSearch\n      randNearestLinear     = linearNearest tuple3D randSearch randValues\n  putStrLn \"1000 random 3D points on the range of [0, 1000):\"\n  printResults randSearch randNearest tuple3D\n  putStrLn \"Confirm naive nearest:\"\n  print randNearestLinear\n", "target": "import java.util.*;\n\npublic class KdTree {\n    private int dimensions_;\n    private Node root_ = null;\n    private Node best_ = null;\n    private double bestDistance_ = 0;\n    private int visited_ = 0;\n    \n    public KdTree(int dimensions, List<Node> nodes) {\n        dimensions_ = dimensions;\n        root_ = makeTree(nodes, 0, nodes.size(), 0);\n    }\n    \n    public Node findNearest(Node target) {\n        if (root_ == null)\n            throw new IllegalStateException(\"Tree is empty!\");\n        best_ = null;\n        visited_ = 0;\n        bestDistance_ = 0;\n        nearest(root_, target, 0);\n        return best_;\n    }\n    \n    public int visited() {\n        return visited_;\n    }\n    \n    public double distance() {\n        return Math.sqrt(bestDistance_);\n    }\n    \n    private void nearest(Node root, Node target, int index) {\n        if (root == null)\n            return;\n        ++visited_;\n        double d = root.distance(target);\n        if (best_ == null || d < bestDistance_) {\n            bestDistance_ = d;\n            best_ = root;\n        }\n        if (bestDistance_ == 0)\n            return;\n        double dx = root.get(index) - target.get(index);\n        index = (index + 1) % dimensions_;\n        nearest(dx > 0 ? root.left_ : root.right_, target, index);\n        if (dx * dx >= bestDistance_)\n            return;\n        nearest(dx > 0 ? root.right_ : root.left_, target, index);\n    }\n    \n    private Node makeTree(List<Node> nodes, int begin, int end, int index) {\n        if (end <= begin)\n            return null;\n        int n = begin + (end - begin)/2;\n        Node node = QuickSelect.select(nodes, begin, end - 1, n, new NodeComparator(index));\n        index = (index + 1) % dimensions_;\n        node.left_ = makeTree(nodes, begin, n, index);\n        node.right_ = makeTree(nodes, n + 1, end, index);\n        return node;\n    }\n    \n    private static class NodeComparator implements Comparator<Node> {\n        private int index_;\n\n        private NodeComparator(int index) {\n            index_ = index;\n        }\n        public int compare(Node n1, Node n2) {\n            return Double.compare(n1.get(index_), n2.get(index_));\n        }\n    }\n    \n    public static class Node {\n        private double[] coords_;\n        private Node left_ = null;\n        private Node right_ = null;\n\n        public Node(double[] coords) {\n            coords_ = coords;\n        }\n        public Node(double x, double y) {\n            this(new double[]{x, y});\n        }\n        public Node(double x, double y, double z) {\n            this(new double[]{x, y, z});\n        }\n        double get(int index) {\n            return coords_[index];\n        }\n        double distance(Node node) {\n            double dist = 0;\n            for (int i = 0; i < coords_.length; ++i) {\n                double d = coords_[i] - node.coords_[i];\n                dist += d * d;\n            }\n            return dist;\n        }\n        public String toString() {\n            StringBuilder s = new StringBuilder(\"(\");\n            for (int i = 0; i < coords_.length; ++i) {\n                if (i > 0)\n                    s.append(\", \");\n                s.append(coords_[i]);\n            }\n            s.append(')');\n            return s.toString();\n        }\n    }\n}\n"}
{"id": 404664, "name": "Cut a rectangle", "source": "Translate Haskell to Java: import qualified Data.Vector.Unboxed.Mutable as V\nimport Data.STRef\nimport Control.Monad (forM_, when)\nimport Control.Monad.ST\n\ndir :: [(Int, Int)]\ndir = [(1, 0), (-1, 0), (0, -1), (0, 1)]\n\ndata Env = Env { w, h, len, count, ret :: !Int, next :: ![Int] }\n\ncutIt :: STRef s Env -> ST s ()\ncutIt env = do\n    e <- readSTRef env\n    when (odd $ h e) $ modifySTRef env $ \\en -> en { h = w e,\n        w = h e }\n    e <- readSTRef env\n    if odd (h e)\n        then modifySTRef env $ \\en -> en { ret = 0 }\n        else\n            if w e == 1\n            then modifySTRef env $ \\en -> en { ret = 1 }\n            else do\n                let blen = (h e + 1) * (w e + 1) - 1\n                    t = (h e `div` 2) * (w e + 1) + (w e `div` 2)\n                modifySTRef env $ \\en -> en { len = blen,\n                    count = 0,\n                    next = [ w e + 1, (negate $ w e) - 1, -1, 1] }\n                grid <- V.replicate (blen + 1) False\n                case odd (w e) of\n                    True -> do\n                        V.write grid t True\n                        V.write grid (t + 1) True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e1 <- readSTRef env\n                        let res1 = count e1\n                        modifySTRef env $ \\en -> en { count = 0 }\n                        walk grid (h e `div` 2 - 1) (w e `div` 2)\n                        modifySTRef env $ \\en -> en { ret = res1 +\n                            (count en * 2) }\n                    False -> do\n                        V.write grid t True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e2 <- readSTRef env\n                        let count2 = count e2\n                        if h e == w e\n                            then modifySTRef env $ \\en -> en { ret =\n                                count2 * 2 }\n                            else do\n                                walk grid (h e `div` 2 - 1)\n                                    (w e `div` 2)\n                                modifySTRef env $ \\en -> en { ret =\n                                    count en }\n    where\n        walk grid y x = do\n            e <- readSTRef env\n            if y <= 0 || y >= h e || x <= 0 || x >= w e\n                then modifySTRef env $ \\en -> en { count = count en + 1 }\n                else do\n                    let t = y * (w e + 1) + x\n                    V.write grid t True\n                    V.write grid (len e - t) True\n                    forM_ (zip (next e) [0..3]) $ \\(n, d) -> do\n                        g <- V.read grid (t + n)\n                        when (not g) $\n                            walk grid (y + fst (dir !! d)) (x + snd (dir !! d))\n                    V.write grid t False\n                    V.write grid (len e - t) False\n\ncut :: (Int, Int) -> Int\ncut (x, y) = runST $ do\n    env <- newSTRef $ Env { w = y, h = x, len = 0, count = 0, ret = 0, next = [] }\n    cutIt env\n    result <- readSTRef env\n    return $ ret result\n\nmain :: IO ()\nmain = do\n    mapM_ (\\(x, y) -> when (even (x * y)) (putStrLn $ \n        show x ++ \" x \" ++ show y ++ \": \" ++ show (cut (x, y))))\n        [ (x, y) | x <- [1..10], y <- [1..x] ]\n", "target": "import java.util.*;\n\npublic class CutRectangle {\n\n    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n\n    public static void main(String[] args) {\n        cutRectangle(2, 2);\n        cutRectangle(4, 3);\n    }\n\n    static void cutRectangle(int w, int h) {\n        if (w % 2 == 1 && h % 2 == 1)\n            return;\n\n        int[][] grid = new int[h][w];\n        Stack<Integer> stack = new Stack<>();\n\n        int half = (w * h) / 2;\n        long bits = (long) Math.pow(2, half) - 1;\n\n        for (; bits > 0; bits -= 2) {\n\n            for (int i = 0; i < half; i++) {\n                int r = i / w;\n                int c = i % w;\n                grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n            }\n\n            stack.push(0);\n            grid[0][0] = 2;\n            int count = 1;\n            while (!stack.empty()) {\n\n                int pos = stack.pop();\n                int r = pos / w;\n                int c = pos % w;\n\n                for (int[] dir : dirs) {\n\n                    int nextR = r + dir[0];\n                    int nextC = c + dir[1];\n\n                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n\n                        if (grid[nextR][nextC] == 1) {\n                            stack.push(nextR * w + nextC);\n                            grid[nextR][nextC] = 2;\n                            count++;\n                        }\n                    }\n                }\n            }\n            if (count == half) {\n                printResult(grid);\n            }\n        }\n    }\n\n    static void printResult(int[][] arr) {\n        for (int[] a : arr)\n            System.out.println(Arrays.toString(a));\n        System.out.println();\n    }\n}\n"}
{"id": 404665, "name": "Cut a rectangle", "source": "Translate Haskell to Java: import qualified Data.Vector.Unboxed.Mutable as V\nimport Data.STRef\nimport Control.Monad (forM_, when)\nimport Control.Monad.ST\n\ndir :: [(Int, Int)]\ndir = [(1, 0), (-1, 0), (0, -1), (0, 1)]\n\ndata Env = Env { w, h, len, count, ret :: !Int, next :: ![Int] }\n\ncutIt :: STRef s Env -> ST s ()\ncutIt env = do\n    e <- readSTRef env\n    when (odd $ h e) $ modifySTRef env $ \\en -> en { h = w e,\n        w = h e }\n    e <- readSTRef env\n    if odd (h e)\n        then modifySTRef env $ \\en -> en { ret = 0 }\n        else\n            if w e == 1\n            then modifySTRef env $ \\en -> en { ret = 1 }\n            else do\n                let blen = (h e + 1) * (w e + 1) - 1\n                    t = (h e `div` 2) * (w e + 1) + (w e `div` 2)\n                modifySTRef env $ \\en -> en { len = blen,\n                    count = 0,\n                    next = [ w e + 1, (negate $ w e) - 1, -1, 1] }\n                grid <- V.replicate (blen + 1) False\n                case odd (w e) of\n                    True -> do\n                        V.write grid t True\n                        V.write grid (t + 1) True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e1 <- readSTRef env\n                        let res1 = count e1\n                        modifySTRef env $ \\en -> en { count = 0 }\n                        walk grid (h e `div` 2 - 1) (w e `div` 2)\n                        modifySTRef env $ \\en -> en { ret = res1 +\n                            (count en * 2) }\n                    False -> do\n                        V.write grid t True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e2 <- readSTRef env\n                        let count2 = count e2\n                        if h e == w e\n                            then modifySTRef env $ \\en -> en { ret =\n                                count2 * 2 }\n                            else do\n                                walk grid (h e `div` 2 - 1)\n                                    (w e `div` 2)\n                                modifySTRef env $ \\en -> en { ret =\n                                    count en }\n    where\n        walk grid y x = do\n            e <- readSTRef env\n            if y <= 0 || y >= h e || x <= 0 || x >= w e\n                then modifySTRef env $ \\en -> en { count = count en + 1 }\n                else do\n                    let t = y * (w e + 1) + x\n                    V.write grid t True\n                    V.write grid (len e - t) True\n                    forM_ (zip (next e) [0..3]) $ \\(n, d) -> do\n                        g <- V.read grid (t + n)\n                        when (not g) $\n                            walk grid (y + fst (dir !! d)) (x + snd (dir !! d))\n                    V.write grid t False\n                    V.write grid (len e - t) False\n\ncut :: (Int, Int) -> Int\ncut (x, y) = runST $ do\n    env <- newSTRef $ Env { w = y, h = x, len = 0, count = 0, ret = 0, next = [] }\n    cutIt env\n    result <- readSTRef env\n    return $ ret result\n\nmain :: IO ()\nmain = do\n    mapM_ (\\(x, y) -> when (even (x * y)) (putStrLn $ \n        show x ++ \" x \" ++ show y ++ \": \" ++ show (cut (x, y))))\n        [ (x, y) | x <- [1..10], y <- [1..x] ]\n", "target": "import java.util.*;\n\npublic class CutRectangle {\n\n    private static int[][] dirs = {{0, -1}, {-1, 0}, {0, 1}, {1, 0}};\n\n    public static void main(String[] args) {\n        cutRectangle(2, 2);\n        cutRectangle(4, 3);\n    }\n\n    static void cutRectangle(int w, int h) {\n        if (w % 2 == 1 && h % 2 == 1)\n            return;\n\n        int[][] grid = new int[h][w];\n        Stack<Integer> stack = new Stack<>();\n\n        int half = (w * h) / 2;\n        long bits = (long) Math.pow(2, half) - 1;\n\n        for (; bits > 0; bits -= 2) {\n\n            for (int i = 0; i < half; i++) {\n                int r = i / w;\n                int c = i % w;\n                grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n                grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n            }\n\n            stack.push(0);\n            grid[0][0] = 2;\n            int count = 1;\n            while (!stack.empty()) {\n\n                int pos = stack.pop();\n                int r = pos / w;\n                int c = pos % w;\n\n                for (int[] dir : dirs) {\n\n                    int nextR = r + dir[0];\n                    int nextC = c + dir[1];\n\n                    if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n\n                        if (grid[nextR][nextC] == 1) {\n                            stack.push(nextR * w + nextC);\n                            grid[nextR][nextC] = 2;\n                            count++;\n                        }\n                    }\n                }\n            }\n            if (count == half) {\n                printResult(grid);\n            }\n        }\n    }\n\n    static void printResult(int[][] arr) {\n        for (int[] a : arr)\n            System.out.println(Arrays.toString(a));\n        System.out.println();\n    }\n}\n"}
{"id": 404666, "name": "Cuban primes", "source": "Translate Haskell to Java: import Data.Numbers.Primes (isPrime)\nimport Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\ncubans :: [Int]\ncubans = filter isPrime . map (\\x -> (succ x ^ 3) - (x ^ 3)) $ [1 ..]\n\nmain :: IO ()\nmain = do\n  mapM_ (\\row -> mapM_ (printf \"%10s\" . thousands) row >> printf \"\\n\") $ rows cubans\n  printf \"\\nThe 100,000th cuban prime is: %10s\\n\" $ thousands $ cubans !! 99999\n  where\n    rows = chunksOf 10 . take 200\n    thousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n", "target": "public class CubanPrimes {\n\n    private static int MAX = 1_400_000;\n    private static boolean[] primes = new boolean[MAX];\n    \n    public static void main(String[] args) {\n        preCompute();\n        cubanPrime(200, true);\n        for ( int i = 1 ; i <= 5 ; i++ ) {\n            int max = (int) Math.pow(10, i);\n            System.out.printf(\"%,d-th cuban prime =\u00a0%,d%n\", max, cubanPrime(max, false));\n        }\n    }\n    \n    private static long cubanPrime(int n, boolean display) {\n        int count = 0;\n        long result = 0;\n        for ( long i = 0 ; count < n ; i++ ) {\n            long test = 1l + 3 * i * (i+1);\n            if ( isPrime(test) ) {\n                count++;\n                result = test;\n                if ( display ) {\n                    System.out.printf(\"%10s%s\", String.format(\"%,d\", test), count % 10 == 0 ? \"\\n\" : \"\");\n                }\n            }\n        }\n        return result;\n    }\n    \n    private static boolean isPrime(long n) {\n        if ( n < MAX ) {\n            return primes[(int)n];\n        }\n        int max = (int) Math.sqrt(n);\n        for ( int i = 3 ; i <= max ; i++ ) {\n            if ( primes[i] && n % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static final void preCompute() {\n        \n        for ( int i = 2 ; i < MAX ; i++ ) {\n            primes[i] = true;            \n        }\n        for ( int i = 2 ; i < MAX ; i++ ) {\n            if ( primes[i] ) {\n                for ( int j = 2*i ; j < MAX ; j += i ) {\n                    primes[j] = false;\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404667, "name": "Chaos game", "source": "Translate Haskell to Java: import Control.Monad (replicateM)\nimport Control.Monad.Random (fromList)\n\ntype Point = (Float,Float)\ntype Transformations = [(Point -> Point, Float)] \n\n\ngameOfChaos :: MonadRandom m => Int -> Transformations -> Point -> m [Point]\ngameOfChaos n transformations x = iterateA (fromList transformations) x\n  where iterateA f x = scanr ($) x <$> replicateM n f\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 404668, "name": "Chaos game", "source": "Translate Haskell to Java: import Control.Monad (replicateM)\nimport Control.Monad.Random (fromList)\n\ntype Point = (Float,Float)\ntype Transformations = [(Point -> Point, Float)] \n\n\ngameOfChaos :: MonadRandom m => Int -> Transformations -> Point -> m [Point]\ngameOfChaos n transformations x = iterateA (fromList transformations) x\n  where iterateA f x = scanr ($) x <$> replicateM n f\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 404669, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Haskell to Java: import Text.Printf\n\nprec :: String -> Int\nprec \"^\" = 4\nprec \"*\" = 3\nprec \"/\" = 3\nprec \"+\" = 2\nprec \"-\" = 2\n\nleftAssoc :: String -> Bool\nleftAssoc \"^\" = False\nleftAssoc _ = True\n\nisOp :: String -> Bool\nisOp [t] = t `elem` \"-+/*^\"\nisOp _ = False\n\nsimSYA :: [String] -> [([String], [String], String)]\nsimSYA xs = final <> [lastStep]\n  where\n    final = scanl f ([], [], \"\") xs\n    lastStep =\n      ( \\(x, y, _) ->\n          (reverse y <> x, [], \"\")\n      )\n        $ last final\n    f (out, st, _) t\n      | isOp t =\n        ( reverse (takeWhile testOp st) <> out,\n          (t :) (dropWhile testOp st),\n          t\n        )\n      | t == \"(\" = (out, \"(\" : st, t)\n      | t == \")\" =\n        ( reverse (takeWhile (/= \"(\") st) <> out,\n          tail $ dropWhile (/= \"(\") st,\n          t\n        )\n      | otherwise = (t : out, st, t)\n      where\n        testOp x =\n          isOp x\n            && ( leftAssoc t && prec t == prec x\n                   || prec t < prec x\n               )\n\nmain :: IO ()\nmain = do\n  a <- getLine\n  printf \"%30s%20s%7s\" \"Output\" \"Stack\" \"Token\"\n  mapM_\n    ( \\(x, y, z) ->\n        printf\n          \"%30s%20s%7s\\n\"\n          (unwords $ reverse x)\n          (unwords y)\n          z\n    )\n    $ simSYA $ words a\n", "target": "import java.util.Stack;\n\npublic class ShuntingYard {\n\n    public static void main(String[] args) {\n        String infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        System.out.printf(\"infix:   %s%n\", infix);\n        System.out.printf(\"postfix: %s%n\", infixToPostfix(infix));\n    }\n\n    static String infixToPostfix(String infix) {\n        \n        final String ops = \"-+/*^\";\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n\n        for (String token : infix.split(\"\\\\s\")) {\n            if (token.isEmpty())\n                continue;\n            char c = token.charAt(0);\n            int idx = ops.indexOf(c);\n\n            \n            if (idx != -1) {\n                if (s.isEmpty())\n                    s.push(idx);\n          \n                else {\n                    while (!s.isEmpty()) {\n                        int prec2 = s.peek() / 2;\n                        int prec1 = idx / 2;\n                        if (prec2 > prec1 || (prec2 == prec1 && c != '^'))\n                            sb.append(ops.charAt(s.pop())).append(' ');\n                        else break;\n                    }\n                    s.push(idx);\n                }\n            } \n            else if (c == '(') {\n                s.push(-2); \n            } \n            else if (c == ')') {\n                \n                while (s.peek() != -2)\n                    sb.append(ops.charAt(s.pop())).append(' ');\n                s.pop();\n            }\n            else {\n                sb.append(token).append(' ');\n            }\n        }\n        while (!s.isEmpty())\n            sb.append(ops.charAt(s.pop())).append(' ');\n        return sb.toString();\n    }\n}\n"}
{"id": 404670, "name": "A_ search algorithm", "source": "Translate Haskell to Java: \n\nmodule PQueue where\n\ndata PQueue a = EmptyQueue\n              | Node (Int, a) (PQueue a) (PQueue a)\n  deriving (Show, Foldable)\n\ninstance Ord a => Semigroup (PQueue a) where\n  h1@(Node (w1, x1) l1 r1) <> h2@(Node (w2, x2) l2 r2)\n    | w1 < w2   = Node (w1, x1) (h2 <> r1) l1\n    | otherwise = Node (w2, x2) (h1 <> r2) l2\n  EmptyQueue <> h = h\n  h <> EmptyQueue = h\n\nentry :: Ord a => a -> Int -> PQueue a\nentry x w = Node (w, x) EmptyQueue EmptyQueue\n\nenque :: Ord a => PQueue a -> a -> Int -> PQueue a\nenque q x w = if x `notElem` q\n              then entry x w <> q\n              else q\n\ndeque :: Ord a => PQueue a -> Maybe (a, PQueue a)\ndeque q = case q of\n            EmptyQueue -> Nothing\n            Node (_, x) l r -> Just (x, l <> r)\n", "target": "package astar;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\nclass AStar {\n    private final List<Node> open;\n    private final List<Node> closed;\n    private final List<Node> path;\n    private final int[][] maze;\n    private Node now;\n    private final int xstart;\n    private final int ystart;\n    private int xend, yend;\n    private final boolean diag;\n\n    \n    static class Node implements Comparable {\n        public Node parent;\n        public int x, y;\n        public double g;\n        public double h;\n        Node(Node parent, int xpos, int ypos, double g, double h) {\n            this.parent = parent;\n            this.x = xpos;\n            this.y = ypos;\n            this.g = g;\n            this.h = h;\n       }\n       \n       @Override\n       public int compareTo(Object o) {\n           Node that = (Node) o;\n           return (int)((this.g + this.h) - (that.g + that.h));\n       }\n   }\n\n    AStar(int[][] maze, int xstart, int ystart, boolean diag) {\n        this.open = new ArrayList<>();\n        this.closed = new ArrayList<>();\n        this.path = new ArrayList<>();\n        this.maze = maze;\n        this.now = new Node(null, xstart, ystart, 0, 0);\n        this.xstart = xstart;\n        this.ystart = ystart;\n        this.diag = diag;\n    }\n    \n    public List<Node> findPathTo(int xend, int yend) {\n        this.xend = xend;\n        this.yend = yend;\n        this.closed.add(this.now);\n        addNeigborsToOpenList();\n        while (this.now.x != this.xend || this.now.y != this.yend) {\n            if (this.open.isEmpty()) { \n                return null;\n            }\n            this.now = this.open.get(0); \n            this.open.remove(0); \n            this.closed.add(this.now); \n            addNeigborsToOpenList();\n        }\n        this.path.add(0, this.now);\n        while (this.now.x != this.xstart || this.now.y != this.ystart) {\n            this.now = this.now.parent;\n            this.path.add(0, this.now);\n        }\n        return this.path;\n    }\n     \n    public void expandAStar(int[][] maze, int xstart, int ystart, boolean diag){\n        Queue<Mazecoord> exploreNodes = new LinkedList<Mazecoord>();\n        if(maze[stateNode.getR()][stateNode.getC()] == 2){\n            if(isNodeILegal(stateNode, stateNode.expandDirection())){     \n                exploreNodes.add(stateNode.expandDirection());\n         }\n     }\n    \n    public void AStarSearch(){\n        this.start.setCostToGoal(this.start.calculateCost(this.goal));\n        this.start.setPathCost(0);\n        this.start.setAStartCost(this.start.getPathCost() + this.start.getCostToGoal());\n        Mazecoord intialNode = this.start;\n        Mazecoord stateNode = intialNode;\n        frontier.add(intialNode);\n        \n        while (true){\n            if(frontier.isEmpty()){\n                System.out.println(\"fail\");\n                System.out.println(explored.size());\n                System.exit(-1);\n            }\n     }\n    \n    \n    public int calculateCost(Mazecoord goal){\n        int rState = this.getR();\n        int rGoal = goal.getR();\n        int diffR = rState - rGoal;\n        int diffC = this.getC() - goal.getC();\n        if(diffR * diffC > 0) {     \n            return Math.abs(diffR) + Math.abs(diffC);\n        } else {\n            return Math.max(Math.abs(diffR), Math.abs(diffC));\n        }\n    }\n\n    public Coord getFather(){\n        return this.father;\n    }\n\n    public void setFather(Mazecoord node){\n        this.father = node;\n    }\n\n   public int getAStartCost() {\n        return AStartCost;\n    }\n\n    public void setAStartCost(int aStartCost) {\n        AStartCost = aStartCost;\n    }\n\n    public int getCostToGoal() {\n        return costToGoal;\n    }\n\n    public void setCostToGoal(int costToGoal) {\n        this.costToGoal = costToGoal;\n    }\n    \n    private double distance(int dx, int dy) {\n        if (this.diag) { \n            return Math.hypot(this.now.x + dx - this.xend, this.now.y + dy - this.yend); \n        } else {\n            return Math.abs(this.now.x + dx - this.xend) + Math.abs(this.now.y + dy - this.yend); \n        }\n    }\n    private void addNeigborsToOpenList() {\n        Node node;\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                if (!this.diag && x != 0 && y != 0) {\n                    continue; \n                }\n                node = new Node(this.now, this.now.x + x, this.now.y + y, this.now.g, this.distance(x, y));\n                if ((x != 0 || y != 0) \n                    && this.now.x + x >= 0 && this.now.x + x < this.maze[0].length \n                    && this.now.y + y >= 0 && this.now.y + y < this.maze.length\n                    && this.maze[this.now.y + y][this.now.x + x] != -1 \n                    && !findNeighborInList(this.open, node) && !findNeighborInList(this.closed, node)) { \n                        node.g = node.parent.g + 1.; \n                        node.g += maze[this.now.y + y][this.now.x + x]; \n\n                        \n                        \n                        \n                        this.open.add(node);\n                }\n            }\n        }\n        Collections.sort(this.open);\n    }\n\n    public static void main(String[] args) {\n        \n        \n        int[][] maze = {\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n        };\n        AStar as = new AStar(maze, 0, 0, true);\n        List<Node> path = as.findPathTo(7, 7);\n        if (path != null) {\n            path.forEach((n) -> {\n                System.out.print(\"[\" + n.x + \", \" + n.y + \"] \");\n                maze[n.y][n.x] = -1;\n            });\n            System.out.printf(\"\\nTotal cost:\u00a0%.02f\\n\", path.get(path.size() - 1).g);\n\n            for (int[] maze_row : maze) {\n                for (int maze_entry : maze_row) {\n                    switch (maze_entry) {\n                        case 0:\n                            System.out.print(\"_\");\n                            break;\n                        case -1:\n                            System.out.print(\"*\");\n                            break;\n                        default:\n                            System.out.print(\"#\");\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404671, "name": "A_ search algorithm", "source": "Translate Haskell to Java: \n\nmodule PQueue where\n\ndata PQueue a = EmptyQueue\n              | Node (Int, a) (PQueue a) (PQueue a)\n  deriving (Show, Foldable)\n\ninstance Ord a => Semigroup (PQueue a) where\n  h1@(Node (w1, x1) l1 r1) <> h2@(Node (w2, x2) l2 r2)\n    | w1 < w2   = Node (w1, x1) (h2 <> r1) l1\n    | otherwise = Node (w2, x2) (h1 <> r2) l2\n  EmptyQueue <> h = h\n  h <> EmptyQueue = h\n\nentry :: Ord a => a -> Int -> PQueue a\nentry x w = Node (w, x) EmptyQueue EmptyQueue\n\nenque :: Ord a => PQueue a -> a -> Int -> PQueue a\nenque q x w = if x `notElem` q\n              then entry x w <> q\n              else q\n\ndeque :: Ord a => PQueue a -> Maybe (a, PQueue a)\ndeque q = case q of\n            EmptyQueue -> Nothing\n            Node (_, x) l r -> Just (x, l <> r)\n", "target": "package astar;\n\nimport java.util.List;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.PriorityQueue;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\nclass AStar {\n    private final List<Node> open;\n    private final List<Node> closed;\n    private final List<Node> path;\n    private final int[][] maze;\n    private Node now;\n    private final int xstart;\n    private final int ystart;\n    private int xend, yend;\n    private final boolean diag;\n\n    \n    static class Node implements Comparable {\n        public Node parent;\n        public int x, y;\n        public double g;\n        public double h;\n        Node(Node parent, int xpos, int ypos, double g, double h) {\n            this.parent = parent;\n            this.x = xpos;\n            this.y = ypos;\n            this.g = g;\n            this.h = h;\n       }\n       \n       @Override\n       public int compareTo(Object o) {\n           Node that = (Node) o;\n           return (int)((this.g + this.h) - (that.g + that.h));\n       }\n   }\n\n    AStar(int[][] maze, int xstart, int ystart, boolean diag) {\n        this.open = new ArrayList<>();\n        this.closed = new ArrayList<>();\n        this.path = new ArrayList<>();\n        this.maze = maze;\n        this.now = new Node(null, xstart, ystart, 0, 0);\n        this.xstart = xstart;\n        this.ystart = ystart;\n        this.diag = diag;\n    }\n    \n    public List<Node> findPathTo(int xend, int yend) {\n        this.xend = xend;\n        this.yend = yend;\n        this.closed.add(this.now);\n        addNeigborsToOpenList();\n        while (this.now.x != this.xend || this.now.y != this.yend) {\n            if (this.open.isEmpty()) { \n                return null;\n            }\n            this.now = this.open.get(0); \n            this.open.remove(0); \n            this.closed.add(this.now); \n            addNeigborsToOpenList();\n        }\n        this.path.add(0, this.now);\n        while (this.now.x != this.xstart || this.now.y != this.ystart) {\n            this.now = this.now.parent;\n            this.path.add(0, this.now);\n        }\n        return this.path;\n    }\n     \n    public void expandAStar(int[][] maze, int xstart, int ystart, boolean diag){\n        Queue<Mazecoord> exploreNodes = new LinkedList<Mazecoord>();\n        if(maze[stateNode.getR()][stateNode.getC()] == 2){\n            if(isNodeILegal(stateNode, stateNode.expandDirection())){     \n                exploreNodes.add(stateNode.expandDirection());\n         }\n     }\n    \n    public void AStarSearch(){\n        this.start.setCostToGoal(this.start.calculateCost(this.goal));\n        this.start.setPathCost(0);\n        this.start.setAStartCost(this.start.getPathCost() + this.start.getCostToGoal());\n        Mazecoord intialNode = this.start;\n        Mazecoord stateNode = intialNode;\n        frontier.add(intialNode);\n        \n        while (true){\n            if(frontier.isEmpty()){\n                System.out.println(\"fail\");\n                System.out.println(explored.size());\n                System.exit(-1);\n            }\n     }\n    \n    \n    public int calculateCost(Mazecoord goal){\n        int rState = this.getR();\n        int rGoal = goal.getR();\n        int diffR = rState - rGoal;\n        int diffC = this.getC() - goal.getC();\n        if(diffR * diffC > 0) {     \n            return Math.abs(diffR) + Math.abs(diffC);\n        } else {\n            return Math.max(Math.abs(diffR), Math.abs(diffC));\n        }\n    }\n\n    public Coord getFather(){\n        return this.father;\n    }\n\n    public void setFather(Mazecoord node){\n        this.father = node;\n    }\n\n   public int getAStartCost() {\n        return AStartCost;\n    }\n\n    public void setAStartCost(int aStartCost) {\n        AStartCost = aStartCost;\n    }\n\n    public int getCostToGoal() {\n        return costToGoal;\n    }\n\n    public void setCostToGoal(int costToGoal) {\n        this.costToGoal = costToGoal;\n    }\n    \n    private double distance(int dx, int dy) {\n        if (this.diag) { \n            return Math.hypot(this.now.x + dx - this.xend, this.now.y + dy - this.yend); \n        } else {\n            return Math.abs(this.now.x + dx - this.xend) + Math.abs(this.now.y + dy - this.yend); \n        }\n    }\n    private void addNeigborsToOpenList() {\n        Node node;\n        for (int x = -1; x <= 1; x++) {\n            for (int y = -1; y <= 1; y++) {\n                if (!this.diag && x != 0 && y != 0) {\n                    continue; \n                }\n                node = new Node(this.now, this.now.x + x, this.now.y + y, this.now.g, this.distance(x, y));\n                if ((x != 0 || y != 0) \n                    && this.now.x + x >= 0 && this.now.x + x < this.maze[0].length \n                    && this.now.y + y >= 0 && this.now.y + y < this.maze.length\n                    && this.maze[this.now.y + y][this.now.x + x] != -1 \n                    && !findNeighborInList(this.open, node) && !findNeighborInList(this.closed, node)) { \n                        node.g = node.parent.g + 1.; \n                        node.g += maze[this.now.y + y][this.now.x + x]; \n\n                        \n                        \n                        \n                        this.open.add(node);\n                }\n            }\n        }\n        Collections.sort(this.open);\n    }\n\n    public static void main(String[] args) {\n        \n        \n        int[][] maze = {\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n            {  0,  0,  0,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,  0,  0,100,  0,  0},\n            {  0,  0,100,100,100,100,  0,  0},\n            {  0,  0,  0,  0,  0,  0,  0,  0},\n        };\n        AStar as = new AStar(maze, 0, 0, true);\n        List<Node> path = as.findPathTo(7, 7);\n        if (path != null) {\n            path.forEach((n) -> {\n                System.out.print(\"[\" + n.x + \", \" + n.y + \"] \");\n                maze[n.y][n.x] = -1;\n            });\n            System.out.printf(\"\\nTotal cost:\u00a0%.02f\\n\", path.get(path.size() - 1).g);\n\n            for (int[] maze_row : maze) {\n                for (int maze_entry : maze_row) {\n                    switch (maze_entry) {\n                        case 0:\n                            System.out.print(\"_\");\n                            break;\n                        case -1:\n                            System.out.print(\"*\");\n                            break;\n                        default:\n                            System.out.print(\"#\");\n                    }\n                }\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 404672, "name": "Nonogram solver", "source": "Translate Haskell to Java: import           Control.Applicative          ((<|>))\nimport           Control.Monad\nimport           Control.Monad.CSP\nimport           Data.List                    (transpose)\nimport           System.Environment           (getArgs)\nimport           Text.ParserCombinators.ReadP (ReadP)\nimport qualified Text.ParserCombinators.ReadP as P\nimport           Text.Printf                  (printf)\n\nmain :: IO ()\nmain = do\n    file <- parseArgs\n    printf \"reading problem file from %s\\n\" file\n    ps <- parseProblems file\n    forM_ ps $ \\p -> do\n        print p\n        putStrLn \"\"\n        printSolution $ solve p\n        putStrLn \"\"\n\n\n\n\n\nparseArgs :: IO FilePath\nparseArgs = do\n    args <- getArgs\n    case args of\n        [file] -> return file\n        _      -> ioError $ userError \"expected exactly one command line argument, the name of the problem file\"\n\ndata Problem = Problem\n    { rows :: [[Int]]\n    , cols :: [[Int]]\n    } deriving (Show, Read, Eq, Ord)\n\nentryP :: ReadP Int\nentryP = do\n    n <- fromEnum <$> P.get\n    if n < 65 || n > 90\n        then P.pfail\n        else return $ n - 64\n\nblankP, eolP :: ReadP Char\nblankP = P.char ' '\neolP   = P.char '\\n'\n\nentriesP :: ReadP [Int]\nentriesP = ([] <$ blankP) <|> P.many1 entryP\n\nlineP :: ReadP [[Int]]\nlineP = P.sepBy1 entriesP blankP <* eolP\n\nproblemP :: ReadP Problem\nproblemP = Problem <$> lineP <*> lineP\n\nproblemsP :: ReadP [Problem]\nproblemsP = P.sepBy1 problemP (P.many blankP <* eolP) <* P.eof\n\nparseProblems :: FilePath -> IO [Problem]\nparseProblems file = do\n    s <- readFile file\n    case P.readP_to_S problemsP s of\n        [(ps, \"\")] -> return ps\n        _          -> ioError $ userError $ \"error parsing file \" <> file\n\n\n\n\n\nsolve :: Problem -> [[Bool]]\nsolve = oneCSPSolution . problemCSP\n\nproblemCSP :: Problem -> CSP r [[DV r Bool]]\nproblemCSP p = do\n    let rowCount = length $ rows p\n        colCount = length $ cols p\n    cells <- replicateM rowCount\n           $ replicateM colCount\n           $ mkDV [False, True]\n\n    forM_ (zip cells             $ rows p) $ uncurry rowOrColCSP\n    forM_ (zip (transpose cells) $ cols p) $ uncurry rowOrColCSP\n\n    return cells\n\nrowOrColCSP :: [DV r Bool] -> [Int] -> CSP r ()\nrowOrColCSP ws [] = forM_ ws $ constraint1 not\nrowOrColCSP ws xs = do\n    let vs = zip [0 ..] ws\n        n  = length ws\n\n    blocks <- forM xs $ \\x ->\n        mkDV [(i, i + x - 1) | i <- [0 .. n - x]] \n\n    \n    f blocks\n\n    \n    forM_ blocks $ \\x ->\n        forM_ vs $ \\(i, y) ->\n            constraint2 (\\(x1, x2) b -> i < x1 || i > x2 || b) x y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(y', _) b -> i >= y' || not b) (head blocks) y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(_, y') b -> i <= y' || not b) (last blocks) y\n\n    \n    forM_ (zip blocks $ tail blocks) $ \\(x, y) ->\n        forM_ vs $ \\(i, z) ->\n            constraint3 (\\(_, x') (y', _) b -> i <= x' || i >= y' || not b) x y z\n  where\n    f :: [DV r (Int, Int)] -> CSP r ()\n    f (u : v : bs) = do\n        constraint2 (\\(_, u') (v', _) -> v' >= u' + 2)  u v\n        f $ v : bs\n    f _            = return ()\n\n\n\n\n\nprintSolution :: [[Bool]] -> IO ()\nprintSolution bss =\n    forM_ bss $ \\bs -> do\n        forM_ bs $ \\b ->\n            putChar $ if b then '#' else '.'\n        putChar '\\n'\n", "target": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.stream.Collectors.toList;\n\npublic class NonogramSolver {\n\n    static String[] p1 = {\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"};\n\n    static String[] p2 = {\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\", \"D D AE \"\n        + \"CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"};\n\n    static String[] p3 = {\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH \"\n        + \"BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n        \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF \"\n        + \"AAAAD BDG CEF CBDB BBB FC\"};\n\n    static String[] p4 = {\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q \"\n        + \"R AN AAN EI H G\", \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ \"\n        + \"ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\"};\n\n    public static void main(String[] args) {\n        for (String[] puzzleData : new String[][]{p1, p2, p3, p4})\n            newPuzzle(puzzleData);\n    }\n\n    static void newPuzzle(String[] data) {\n        String[] rowData = data[0].split(\"\\\\s\");\n        String[] colData = data[1].split(\"\\\\s\");\n\n        List<List<BitSet>> cols, rows;\n        rows = getCandidates(rowData, colData.length);\n        cols = getCandidates(colData, rowData.length);\n\n        int numChanged;\n        do {\n            numChanged = reduceMutual(cols, rows);\n            if (numChanged == -1) {\n                System.out.println(\"No solution\");\n                return;\n            }\n        } while (numChanged > 0);\n\n        for (List<BitSet> row : rows) {\n            for (int i = 0; i < cols.size(); i++)\n                System.out.print(row.get(0).get(i) ? \"# \" : \". \");\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    \n    static List<List<BitSet>> getCandidates(String[] data, int len) {\n        List<List<BitSet>> result = new ArrayList<>();\n\n        for (String s : data) {\n            List<BitSet> lst = new LinkedList<>();\n\n            int sumChars = s.chars().map(c -> c - 'A' + 1).sum();\n            List<String> prep = stream(s.split(\"\"))\n                    .map(x -> repeat(x.charAt(0) - 'A' + 1, \"1\")).collect(toList());\n\n            for (String r : genSequence(prep, len - sumChars + 1)) {\n                char[] bits = r.substring(1).toCharArray();\n                BitSet bitset = new BitSet(bits.length);\n                for (int i = 0; i < bits.length; i++)\n                    bitset.set(i, bits[i] == '1');\n                lst.add(bitset);\n            }\n            result.add(lst);\n        }\n        return result;\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n\n    \n\n    static int reduceMutual(List<List<BitSet>> cols, List<List<BitSet>> rows) {\n        int countRemoved1 = reduce(cols, rows);\n        if (countRemoved1 == -1)\n            return -1;\n\n        int countRemoved2 = reduce(rows, cols);\n        if (countRemoved2 == -1)\n            return -1;\n\n        return countRemoved1 + countRemoved2;\n    }\n\n    static int reduce(List<List<BitSet>> a, List<List<BitSet>> b) {\n        int countRemoved = 0;\n\n        for (int i = 0; i < a.size(); i++) {\n\n            BitSet commonOn = new BitSet();\n            commonOn.set(0, b.size());\n            BitSet commonOff = new BitSet();\n\n            \n            for (BitSet candidate : a.get(i)) {\n                commonOn.and(candidate);\n                commonOff.or(candidate);\n            }\n\n            \n            for (int j = 0; j < b.size(); j++) {\n                final int fi = i, fj = j;\n\n                if (b.get(j).removeIf(cnd -> (commonOn.get(fj) && !cnd.get(fi))\n                        || (!commonOff.get(fj) && cnd.get(fi))))\n                    countRemoved++;\n\n                if (b.get(j).isEmpty())\n                    return -1;\n            }\n        }\n        return countRemoved;\n    }\n}\n"}
{"id": 404673, "name": "Nonogram solver", "source": "Translate Haskell to Java: import           Control.Applicative          ((<|>))\nimport           Control.Monad\nimport           Control.Monad.CSP\nimport           Data.List                    (transpose)\nimport           System.Environment           (getArgs)\nimport           Text.ParserCombinators.ReadP (ReadP)\nimport qualified Text.ParserCombinators.ReadP as P\nimport           Text.Printf                  (printf)\n\nmain :: IO ()\nmain = do\n    file <- parseArgs\n    printf \"reading problem file from %s\\n\" file\n    ps <- parseProblems file\n    forM_ ps $ \\p -> do\n        print p\n        putStrLn \"\"\n        printSolution $ solve p\n        putStrLn \"\"\n\n\n\n\n\nparseArgs :: IO FilePath\nparseArgs = do\n    args <- getArgs\n    case args of\n        [file] -> return file\n        _      -> ioError $ userError \"expected exactly one command line argument, the name of the problem file\"\n\ndata Problem = Problem\n    { rows :: [[Int]]\n    , cols :: [[Int]]\n    } deriving (Show, Read, Eq, Ord)\n\nentryP :: ReadP Int\nentryP = do\n    n <- fromEnum <$> P.get\n    if n < 65 || n > 90\n        then P.pfail\n        else return $ n - 64\n\nblankP, eolP :: ReadP Char\nblankP = P.char ' '\neolP   = P.char '\\n'\n\nentriesP :: ReadP [Int]\nentriesP = ([] <$ blankP) <|> P.many1 entryP\n\nlineP :: ReadP [[Int]]\nlineP = P.sepBy1 entriesP blankP <* eolP\n\nproblemP :: ReadP Problem\nproblemP = Problem <$> lineP <*> lineP\n\nproblemsP :: ReadP [Problem]\nproblemsP = P.sepBy1 problemP (P.many blankP <* eolP) <* P.eof\n\nparseProblems :: FilePath -> IO [Problem]\nparseProblems file = do\n    s <- readFile file\n    case P.readP_to_S problemsP s of\n        [(ps, \"\")] -> return ps\n        _          -> ioError $ userError $ \"error parsing file \" <> file\n\n\n\n\n\nsolve :: Problem -> [[Bool]]\nsolve = oneCSPSolution . problemCSP\n\nproblemCSP :: Problem -> CSP r [[DV r Bool]]\nproblemCSP p = do\n    let rowCount = length $ rows p\n        colCount = length $ cols p\n    cells <- replicateM rowCount\n           $ replicateM colCount\n           $ mkDV [False, True]\n\n    forM_ (zip cells             $ rows p) $ uncurry rowOrColCSP\n    forM_ (zip (transpose cells) $ cols p) $ uncurry rowOrColCSP\n\n    return cells\n\nrowOrColCSP :: [DV r Bool] -> [Int] -> CSP r ()\nrowOrColCSP ws [] = forM_ ws $ constraint1 not\nrowOrColCSP ws xs = do\n    let vs = zip [0 ..] ws\n        n  = length ws\n\n    blocks <- forM xs $ \\x ->\n        mkDV [(i, i + x - 1) | i <- [0 .. n - x]] \n\n    \n    f blocks\n\n    \n    forM_ blocks $ \\x ->\n        forM_ vs $ \\(i, y) ->\n            constraint2 (\\(x1, x2) b -> i < x1 || i > x2 || b) x y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(y', _) b -> i >= y' || not b) (head blocks) y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(_, y') b -> i <= y' || not b) (last blocks) y\n\n    \n    forM_ (zip blocks $ tail blocks) $ \\(x, y) ->\n        forM_ vs $ \\(i, z) ->\n            constraint3 (\\(_, x') (y', _) b -> i <= x' || i >= y' || not b) x y z\n  where\n    f :: [DV r (Int, Int)] -> CSP r ()\n    f (u : v : bs) = do\n        constraint2 (\\(_, u') (v', _) -> v' >= u' + 2)  u v\n        f $ v : bs\n    f _            = return ()\n\n\n\n\n\nprintSolution :: [[Bool]] -> IO ()\nprintSolution bss =\n    forM_ bss $ \\bs -> do\n        forM_ bs $ \\b ->\n            putChar $ if b then '#' else '.'\n        putChar '\\n'\n", "target": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.util.stream.Collectors.toList;\n\npublic class NonogramSolver {\n\n    static String[] p1 = {\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"};\n\n    static String[] p2 = {\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\", \"D D AE \"\n        + \"CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"};\n\n    static String[] p3 = {\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH \"\n        + \"BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n        \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF \"\n        + \"AAAAD BDG CEF CBDB BBB FC\"};\n\n    static String[] p4 = {\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q \"\n        + \"R AN AAN EI H G\", \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ \"\n        + \"ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\"};\n\n    public static void main(String[] args) {\n        for (String[] puzzleData : new String[][]{p1, p2, p3, p4})\n            newPuzzle(puzzleData);\n    }\n\n    static void newPuzzle(String[] data) {\n        String[] rowData = data[0].split(\"\\\\s\");\n        String[] colData = data[1].split(\"\\\\s\");\n\n        List<List<BitSet>> cols, rows;\n        rows = getCandidates(rowData, colData.length);\n        cols = getCandidates(colData, rowData.length);\n\n        int numChanged;\n        do {\n            numChanged = reduceMutual(cols, rows);\n            if (numChanged == -1) {\n                System.out.println(\"No solution\");\n                return;\n            }\n        } while (numChanged > 0);\n\n        for (List<BitSet> row : rows) {\n            for (int i = 0; i < cols.size(); i++)\n                System.out.print(row.get(0).get(i) ? \"# \" : \". \");\n            System.out.println();\n        }\n        System.out.println();\n    }\n\n    \n    static List<List<BitSet>> getCandidates(String[] data, int len) {\n        List<List<BitSet>> result = new ArrayList<>();\n\n        for (String s : data) {\n            List<BitSet> lst = new LinkedList<>();\n\n            int sumChars = s.chars().map(c -> c - 'A' + 1).sum();\n            List<String> prep = stream(s.split(\"\"))\n                    .map(x -> repeat(x.charAt(0) - 'A' + 1, \"1\")).collect(toList());\n\n            for (String r : genSequence(prep, len - sumChars + 1)) {\n                char[] bits = r.substring(1).toCharArray();\n                BitSet bitset = new BitSet(bits.length);\n                for (int i = 0; i < bits.length; i++)\n                    bitset.set(i, bits[i] == '1');\n                lst.add(bitset);\n            }\n            result.add(lst);\n        }\n        return result;\n    }\n\n    \n    static List<String> genSequence(List<String> ones, int numZeros) {\n        if (ones.isEmpty())\n            return asList(repeat(numZeros, \"0\"));\n\n        List<String> result = new ArrayList<>();\n        for (int x = 1; x < numZeros - ones.size() + 2; x++) {\n            List<String> skipOne = ones.stream().skip(1).collect(toList());\n            for (String tail : genSequence(skipOne, numZeros - x))\n                result.add(repeat(x, \"0\") + ones.get(0) + tail);\n        }\n        return result;\n    }\n\n    static String repeat(int n, String s) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < n; i++)\n            sb.append(s);\n        return sb.toString();\n    }\n\n    \n\n    static int reduceMutual(List<List<BitSet>> cols, List<List<BitSet>> rows) {\n        int countRemoved1 = reduce(cols, rows);\n        if (countRemoved1 == -1)\n            return -1;\n\n        int countRemoved2 = reduce(rows, cols);\n        if (countRemoved2 == -1)\n            return -1;\n\n        return countRemoved1 + countRemoved2;\n    }\n\n    static int reduce(List<List<BitSet>> a, List<List<BitSet>> b) {\n        int countRemoved = 0;\n\n        for (int i = 0; i < a.size(); i++) {\n\n            BitSet commonOn = new BitSet();\n            commonOn.set(0, b.size());\n            BitSet commonOff = new BitSet();\n\n            \n            for (BitSet candidate : a.get(i)) {\n                commonOn.and(candidate);\n                commonOff.or(candidate);\n            }\n\n            \n            for (int j = 0; j < b.size(); j++) {\n                final int fi = i, fj = j;\n\n                if (b.get(j).removeIf(cnd -> (commonOn.get(fj) && !cnd.get(fi))\n                        || (!commonOff.get(fj) && cnd.get(fi))))\n                    countRemoved++;\n\n                if (b.get(j).isEmpty())\n                    return -1;\n            }\n        }\n        return countRemoved;\n    }\n}\n"}
{"id": 404674, "name": "Lychrel numbers", "source": "Translate Haskell to Java: module Main where\n\nimport Data.List\n\nprocLychrel :: Integer -> [Integer]\nprocLychrel a = a : pl a\n  where\n    pl n =\n        let s = n + reverseInteger n\n             in if isPalindrome s\n                  then [s]\n                  else s : pl s\n\nisPalindrome :: Integer -> Bool\nisPalindrome n =\n  let s = show n\n  in (s == reverse s)\n\nisLychrel :: Integer -> Bool\nisLychrel = not . null . drop 500 . procLychrel\n\nreverseInteger :: Integer -> Integer\nreverseInteger = read . reverse . show\n\nseedAndRelated :: (Int, [Integer], [Integer], Int)\nseedAndRelated =\n  let (seed, related, _) = foldl sar ([], [], []) [1 .. 10000]\n      lseed = length seed\n      lrelated = length related\n      totalCount = lseed + lrelated\n      pal = filter isPalindrome $ seed ++ related\n  in (totalCount, pal, seed, lrelated)\n  where\n    sar (seed, related, lych) x =\n      let s = procLychrel x\n          sIsLychrel = not . null . drop 500 $ s\n          (isIn, isOut) = partition (`elem` lych) . take 501 $ s\n          newLych = lych ++ isOut\n      in if sIsLychrel\n           then if null isIn \n                  then (x : seed, related, newLych)\n                  else (seed, x : related, newLych) \n           else (seed, related, lych)\n\nmain = do\n  let (totalCount, palindromicLychrel, lychrelSeeds, relatedCount) = seedAndRelated\n  putStrLn $ \"[1..10,000] contains \" ++ show totalCount ++ \" Lychrel numbers.\"\n  putStrLn $ show palindromicLychrel ++ \" are palindromic Lychrel numbers.\"\n  putStrLn $ show lychrelSeeds ++ \" are Lychrel seeds.\"\n  putStrLn $ \"There are \" ++ show relatedCount ++ \" related Lychrel numbers.\"\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 404675, "name": "Lychrel numbers", "source": "Translate Haskell to Java: module Main where\n\nimport Data.List\n\nprocLychrel :: Integer -> [Integer]\nprocLychrel a = a : pl a\n  where\n    pl n =\n        let s = n + reverseInteger n\n             in if isPalindrome s\n                  then [s]\n                  else s : pl s\n\nisPalindrome :: Integer -> Bool\nisPalindrome n =\n  let s = show n\n  in (s == reverse s)\n\nisLychrel :: Integer -> Bool\nisLychrel = not . null . drop 500 . procLychrel\n\nreverseInteger :: Integer -> Integer\nreverseInteger = read . reverse . show\n\nseedAndRelated :: (Int, [Integer], [Integer], Int)\nseedAndRelated =\n  let (seed, related, _) = foldl sar ([], [], []) [1 .. 10000]\n      lseed = length seed\n      lrelated = length related\n      totalCount = lseed + lrelated\n      pal = filter isPalindrome $ seed ++ related\n  in (totalCount, pal, seed, lrelated)\n  where\n    sar (seed, related, lych) x =\n      let s = procLychrel x\n          sIsLychrel = not . null . drop 500 $ s\n          (isIn, isOut) = partition (`elem` lych) . take 501 $ s\n          newLych = lych ++ isOut\n      in if sIsLychrel\n           then if null isIn \n                  then (x : seed, related, newLych)\n                  else (seed, x : related, newLych) \n           else (seed, related, lych)\n\nmain = do\n  let (totalCount, palindromicLychrel, lychrelSeeds, relatedCount) = seedAndRelated\n  putStrLn $ \"[1..10,000] contains \" ++ show totalCount ++ \" Lychrel numbers.\"\n  putStrLn $ show palindromicLychrel ++ \" are palindromic Lychrel numbers.\"\n  putStrLn $ show lychrelSeeds ++ \" are Lychrel seeds.\"\n  putStrLn $ \"There are \" ++ show relatedCount ++ \" related Lychrel numbers.\"\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class Lychrel {\n\n    static Map<BigInteger, Tuple> cache = new HashMap<>();\n\n    static class Tuple {\n        final Boolean flag;\n        final BigInteger bi;\n\n        Tuple(boolean f, BigInteger b) {\n            flag = f;\n            bi = b;\n        }\n    }\n\n    static BigInteger rev(BigInteger bi) {\n        String s = new StringBuilder(bi.toString()).reverse().toString();\n        return new BigInteger(s);\n    }\n\n    static Tuple lychrel(BigInteger n) {\n        Tuple res;\n        if ((res = cache.get(n)) != null)\n            return res;\n\n        BigInteger r = rev(n);\n        res = new Tuple(true, n);\n        List<BigInteger> seen = new ArrayList<>();\n\n        for (int i = 0; i < 500; i++) {\n            n = n.add(r);\n            r = rev(n);\n\n            if (n.equals(r)) {\n                res = new Tuple(false, BigInteger.ZERO);\n                break;\n            }\n\n            if (cache.containsKey(n)) {\n                res = cache.get(n);\n                break;\n            }\n\n            seen.add(n);\n        }\n\n        for (BigInteger bi : seen)\n            cache.put(bi, res);\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n\n        List<BigInteger> seeds = new ArrayList<>();\n        List<BigInteger> related = new ArrayList<>();\n        List<BigInteger> palin = new ArrayList<>();\n\n        for (int i = 1; i <= 10_000; i++) {\n            BigInteger n = BigInteger.valueOf(i);\n\n            Tuple t = lychrel(n);\n\n            if (!t.flag)\n                continue;\n\n            if (n.equals(t.bi))\n                seeds.add(t.bi);\n            else\n                related.add(t.bi);\n\n            if (n.equals(t.bi))\n                palin.add(t.bi);\n        }\n\n        System.out.printf(\"%d Lychrel seeds: %s%n\", seeds.size(), seeds);\n        System.out.printf(\"%d Lychrel related%n\", related.size());\n        System.out.printf(\"%d Lychrel palindromes: %s%n\", palin.size(), palin);\n    }\n}\n"}
{"id": 404676, "name": "Check Machin-like formulas", "source": "Translate Haskell to Java: import Data.Ratio\nimport Data.List (foldl')\n\ntanPlus :: Fractional a => a -> a -> a\ntanPlus a b = (a + b) / (1 - a * b)\n\ntanEval :: (Integral a, Fractional b) => (a, b) -> b\ntanEval (0,_) = 0\ntanEval (coef,f)\n\t| coef < 0 = -tanEval (-coef, f)\n\t| odd coef = tanPlus f $ tanEval (coef - 1, f)\n\t| otherwise = tanPlus a a\n\t\twhere a = tanEval (coef `div` 2, f)\n\ntans :: (Integral a, Fractional b) => [(a, b)] -> b\ntans = foldl' tanPlus 0 . map tanEval\n\nmachins = [\n\t[(1, 1%2), (1, 1%3)],\n\t[(2, 1%3), (1, 1%7)],\n\t[(12, 1%18), (8, 1%57), (-5, 1%239)],\n\t[(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12943)]]\n\nnot_machin = [(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12944)]\n\nmain = do\n\tputStrLn \"Machins:\"\n\tmapM_ (\\x -> putStrLn $ show (tans x) ++ \" <\n\n\tputStr \"\\nnot Machin: \"; print not_machin\n\tprint (tans not_machin)\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CheckMachinFormula {\n    \n    private static String FILE_NAME = \"MachinFormula.txt\";\n    \n    public static void main(String[] args) {\n        try {\n            runPrivate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runPrivate() throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(FILE_NAME)));) {        \n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"=\");\n                System.out.println(tanLeft(split[0].trim()) + \" = \" + split[1].trim().replaceAll(\"\\\\s+\", \" \") + \" = \" + tanRight(split[1].trim()));\n            }\n        }\n    }\n    \n    private static String tanLeft(String formula) {\n        if ( formula.compareTo(\"pi/4\") == 0 ) {\n            return \"1\";\n        }\n        throw new RuntimeException(\"ERROR 104:  Unknown left side: \" + formula);\n    }\n    \n    private static final Pattern ARCTAN_PATTERN = Pattern.compile(\"(-{0,1}\\\\d+)\\\\*arctan\\\\((\\\\d+)/(\\\\d+)\\\\)\");\n    \n    private static Fraction tanRight(String formula) {\n        Matcher matcher = ARCTAN_PATTERN.matcher(formula);\n        List<Term> terms = new ArrayList<>();\n        while ( matcher.find() ) {\n            terms.add(new Term(Integer.parseInt(matcher.group(1)), new Fraction(matcher.group(2), matcher.group(3))));\n        }\n        return evaluateArctan(terms);\n    }\n    \n    private static Fraction evaluateArctan(List<Term> terms) {\n        if ( terms.size() == 1 ) {\n            Term term = terms.get(0);\n            return evaluateArctan(term.coefficient, term.fraction);\n        }\n        int size = terms.size();\n        List<Term> left = terms.subList(0, (size+1) / 2);\n        List<Term> right = terms.subList((size+1) / 2, size);\n        return arctanFormula(evaluateArctan(left), evaluateArctan(right));\n    }\n    \n    private static Fraction evaluateArctan(int coefficient, Fraction fraction) {\n        \n        if ( coefficient == 1 ) {\n            return fraction;\n        }\n        else if ( coefficient < 0 ) {\n            return evaluateArctan(-coefficient, fraction).negate();\n        }\n        if ( coefficient % 2 == 0 ) {\n            Fraction f = evaluateArctan(coefficient/2, fraction);\n            return arctanFormula(f, f);\n        }\n        Fraction a = evaluateArctan(coefficient/2, fraction);\n        Fraction b = evaluateArctan(coefficient - (coefficient/2), fraction);\n        return arctanFormula(a, b);\n    }\n    \n    private static Fraction arctanFormula(Fraction f1, Fraction f2) {\n        return f1.add(f2).divide(Fraction.ONE.subtract(f1.multiply(f2)));\n    }\n    \n    private static class Fraction {\n        \n        public static final Fraction ONE = new Fraction(\"1\", \"1\");\n        \n        private BigInteger numerator;\n        private BigInteger denominator;\n        \n        public Fraction(String num, String den) {\n            numerator = new BigInteger(num);\n            denominator = new BigInteger(den);\n        }\n\n        public Fraction(BigInteger num, BigInteger den) {\n            numerator = num;\n            denominator = den;\n        }\n\n        public Fraction negate() {\n            return new Fraction(numerator.negate(), denominator);\n        }\n        \n        public Fraction add(Fraction f) {\n            BigInteger gcd = denominator.gcd(f.denominator);\n            BigInteger first = numerator.multiply(f.denominator.divide(gcd));\n            BigInteger second = f.numerator.multiply(denominator.divide(gcd));\n            return new Fraction(first.add(second), denominator.multiply(f.denominator).divide(gcd));\n        }\n        \n        public Fraction subtract(Fraction f) {\n            return add(f.negate());\n        }\n        \n        public Fraction multiply(Fraction f) {\n            BigInteger num = numerator.multiply(f.numerator);\n            BigInteger den = denominator.multiply(f.denominator);\n            BigInteger gcd = num.gcd(den);\n            return new Fraction(num.divide(gcd), den.divide(gcd));\n        }\n\n        public Fraction divide(Fraction f) {\n            return multiply(new Fraction(f.denominator, f.numerator));\n        }\n        \n        @Override\n        public String toString() {\n            if ( denominator.compareTo(BigInteger.ONE) == 0 ) {\n                return numerator.toString();\n            }\n            return numerator + \" / \" + denominator;\n        }\n    }\n    \n    private static class Term {\n        \n        private int coefficient;\n        private Fraction fraction;\n        \n        public Term(int c, Fraction f) {\n            coefficient = c;\n            fraction = f;\n        }\n    }\n    \n}\n"}
{"id": 404677, "name": "Check Machin-like formulas", "source": "Translate Haskell to Java: import Data.Ratio\nimport Data.List (foldl')\n\ntanPlus :: Fractional a => a -> a -> a\ntanPlus a b = (a + b) / (1 - a * b)\n\ntanEval :: (Integral a, Fractional b) => (a, b) -> b\ntanEval (0,_) = 0\ntanEval (coef,f)\n\t| coef < 0 = -tanEval (-coef, f)\n\t| odd coef = tanPlus f $ tanEval (coef - 1, f)\n\t| otherwise = tanPlus a a\n\t\twhere a = tanEval (coef `div` 2, f)\n\ntans :: (Integral a, Fractional b) => [(a, b)] -> b\ntans = foldl' tanPlus 0 . map tanEval\n\nmachins = [\n\t[(1, 1%2), (1, 1%3)],\n\t[(2, 1%3), (1, 1%7)],\n\t[(12, 1%18), (8, 1%57), (-5, 1%239)],\n\t[(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12943)]]\n\nnot_machin = [(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12944)]\n\nmain = do\n\tputStrLn \"Machins:\"\n\tmapM_ (\\x -> putStrLn $ show (tans x) ++ \" <\n\n\tputStr \"\\nnot Machin: \"; print not_machin\n\tprint (tans not_machin)\n", "target": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class CheckMachinFormula {\n    \n    private static String FILE_NAME = \"MachinFormula.txt\";\n    \n    public static void main(String[] args) {\n        try {\n            runPrivate();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void runPrivate() throws IOException {\n        try (BufferedReader reader = new BufferedReader(new FileReader(new File(FILE_NAME)));) {        \n            String inLine = null;\n            while ( (inLine = reader.readLine()) != null ) {\n                String[] split = inLine.split(\"=\");\n                System.out.println(tanLeft(split[0].trim()) + \" = \" + split[1].trim().replaceAll(\"\\\\s+\", \" \") + \" = \" + tanRight(split[1].trim()));\n            }\n        }\n    }\n    \n    private static String tanLeft(String formula) {\n        if ( formula.compareTo(\"pi/4\") == 0 ) {\n            return \"1\";\n        }\n        throw new RuntimeException(\"ERROR 104:  Unknown left side: \" + formula);\n    }\n    \n    private static final Pattern ARCTAN_PATTERN = Pattern.compile(\"(-{0,1}\\\\d+)\\\\*arctan\\\\((\\\\d+)/(\\\\d+)\\\\)\");\n    \n    private static Fraction tanRight(String formula) {\n        Matcher matcher = ARCTAN_PATTERN.matcher(formula);\n        List<Term> terms = new ArrayList<>();\n        while ( matcher.find() ) {\n            terms.add(new Term(Integer.parseInt(matcher.group(1)), new Fraction(matcher.group(2), matcher.group(3))));\n        }\n        return evaluateArctan(terms);\n    }\n    \n    private static Fraction evaluateArctan(List<Term> terms) {\n        if ( terms.size() == 1 ) {\n            Term term = terms.get(0);\n            return evaluateArctan(term.coefficient, term.fraction);\n        }\n        int size = terms.size();\n        List<Term> left = terms.subList(0, (size+1) / 2);\n        List<Term> right = terms.subList((size+1) / 2, size);\n        return arctanFormula(evaluateArctan(left), evaluateArctan(right));\n    }\n    \n    private static Fraction evaluateArctan(int coefficient, Fraction fraction) {\n        \n        if ( coefficient == 1 ) {\n            return fraction;\n        }\n        else if ( coefficient < 0 ) {\n            return evaluateArctan(-coefficient, fraction).negate();\n        }\n        if ( coefficient % 2 == 0 ) {\n            Fraction f = evaluateArctan(coefficient/2, fraction);\n            return arctanFormula(f, f);\n        }\n        Fraction a = evaluateArctan(coefficient/2, fraction);\n        Fraction b = evaluateArctan(coefficient - (coefficient/2), fraction);\n        return arctanFormula(a, b);\n    }\n    \n    private static Fraction arctanFormula(Fraction f1, Fraction f2) {\n        return f1.add(f2).divide(Fraction.ONE.subtract(f1.multiply(f2)));\n    }\n    \n    private static class Fraction {\n        \n        public static final Fraction ONE = new Fraction(\"1\", \"1\");\n        \n        private BigInteger numerator;\n        private BigInteger denominator;\n        \n        public Fraction(String num, String den) {\n            numerator = new BigInteger(num);\n            denominator = new BigInteger(den);\n        }\n\n        public Fraction(BigInteger num, BigInteger den) {\n            numerator = num;\n            denominator = den;\n        }\n\n        public Fraction negate() {\n            return new Fraction(numerator.negate(), denominator);\n        }\n        \n        public Fraction add(Fraction f) {\n            BigInteger gcd = denominator.gcd(f.denominator);\n            BigInteger first = numerator.multiply(f.denominator.divide(gcd));\n            BigInteger second = f.numerator.multiply(denominator.divide(gcd));\n            return new Fraction(first.add(second), denominator.multiply(f.denominator).divide(gcd));\n        }\n        \n        public Fraction subtract(Fraction f) {\n            return add(f.negate());\n        }\n        \n        public Fraction multiply(Fraction f) {\n            BigInteger num = numerator.multiply(f.numerator);\n            BigInteger den = denominator.multiply(f.denominator);\n            BigInteger gcd = num.gcd(den);\n            return new Fraction(num.divide(gcd), den.divide(gcd));\n        }\n\n        public Fraction divide(Fraction f) {\n            return multiply(new Fraction(f.denominator, f.numerator));\n        }\n        \n        @Override\n        public String toString() {\n            if ( denominator.compareTo(BigInteger.ONE) == 0 ) {\n                return numerator.toString();\n            }\n            return numerator + \" / \" + denominator;\n        }\n    }\n    \n    private static class Term {\n        \n        private int coefficient;\n        private Fraction fraction;\n        \n        public Term(int c, Fraction f) {\n            coefficient = c;\n            fraction = f;\n        }\n    }\n    \n}\n"}
{"id": 404678, "name": "The ISAAC cipher", "source": "Translate Haskell to Java: import Data.Array (Array, (!), (//), array, elems)\nimport Data.Word (Word, Word32)\nimport Data.Bits (shift, xor)\nimport Data.Char (toUpper)\nimport Data.List (unfoldr)\nimport Numeric (showHex)\n\ntype IArray = Array Word32 Word32\n\ndata IsaacState = IState\n  { randrsl :: IArray\n  , randcnt :: Word32\n  , mm :: IArray\n  , aa :: Word32\n  , bb :: Word32\n  , cc :: Word32\n  }\n\ninstance Show IsaacState where\n  show (IState _ cnt _ a b c) =\n    show cnt ++ \" \" ++ show a ++ \" \" ++ show b ++ \" \" ++ show c\n\ntoHex :: Char -> String\ntoHex c = showHex (fromEnum c) \"\"\n\nhexify :: String -> String\nhexify = map toUpper . concatMap toHex\n\ntoNum :: Char -> Word32\ntoNum = fromIntegral . fromEnum\n\ntoChar :: Word32 -> Char\ntoChar = toEnum . fromIntegral\n\ngolden :: Word32\ngolden = 0x9e3779b9\n\n\nmix :: [Word32] -> [Word32]\nmix set = foldl aux set [11, -2, 8, -16, 10, -4, 8, -9]\n  where\n    aux [a, b, c, d, e, f, g, h] x = [b + c, c, d + a_, e, f, g, h, a_]\n      where\n        a_ = a `xor` (b `shift` x)\n\n\nisaac :: IsaacState -> IsaacState\nisaac (IState rsl _ m a b c) = IState rsl_ 0 m_ a_ b_ c_\n  where\n    c_ = c + 1\n    (rsl_, m_, a_, b_) =\n      foldl aux (rsl, m, a, b) $ zip [0 .. 255] $ cycle [13, -6, 2, -16]\n    aux (rsl, m, a, b) (i, s) = (rsl_, m_, a_, b_)\n      where\n        x = m ! i\n        a_ = (a `xor` (a `shift` s)) + m ! ((i + 128) `mod` 256)\n        y = a_ + b + m ! ((x `shift` (-2)) `mod` 256)\n        m_ = m // [(i, y)]\n        b_ = x + m_ ! ((y `shift` (-10)) `mod` 256)\n        rsl_ = rsl // [(i, b_)]\n\n\nrandinit :: IsaacState -> Bool -> IsaacState\nrandinit state flag = isaac (IState randrsl_ 0 m 0 0 0)\n  where\n    firstSet = iterate mix (replicate 8 golden) !! 4\n    iter _ _ [] = []\n    iter flag set rsl =\n      let (rslH, rslT) = splitAt 8 rsl\n          set_ =\n            mix $\n            if flag\n              then zipWith (+) set rslH\n              else set\n      in set_ ++ iter flag set_ rslT\n    randrsl_ = randrsl state\n    firstPass = iter flag firstSet $ elems randrsl_\n    set_ = drop (256 - 8) firstPass\n    secondPass =\n      if flag\n        then iter True set_ firstPass\n        else firstPass\n    m = array (0, 255) $ zip [0 ..] secondPass\n\n\nseed :: String -> Bool -> IsaacState\nseed key flag =\n  let m = array (0, 255) $ zip [0 .. 255] $ repeat 0\n      rsl = m // zip [0 ..] (map toNum key)\n      state = IState rsl 0 m 0 0 0\n  in randinit state flag\n\n\nrandom :: IsaacState -> (Word32, IsaacState)\nrandom state@(IState rsl cnt m a b c) =\n  let r = rsl ! cnt\n      state_ =\n        if cnt + 1 > 255\n          then isaac $ IState rsl 0 m a b c\n          else IState rsl (cnt + 1) m a b c\n  in (r, state_)\n\n\nrandoms :: IsaacState -> [Word32]\nrandoms = unfoldr $ Just . random\n\n\n\nrandA :: IsaacState -> (Char, IsaacState)\nrandA state =\n  let (r, state_) = random state\n  in (toEnum $ fromIntegral $ (r `mod` 95) + 32, state_)\n\n\nrandAs :: IsaacState -> String\nrandAs = unfoldr $ Just . randA\n\n\nvernam :: IsaacState -> String -> String\nvernam state msg = map toChar $ zipWith xor msg_ randAs_\n  where\n    msg_ = map toNum msg\n    randAs_ = map toNum $ randAs state\n\nmain :: IO ()\nmain = do\n  let msg = \"a Top Secret secret\"\n      key = \"this is my secret key\"\n      st = seed key True\n      ver = vernam st msg\n      unver = vernam st ver\n  putStrLn $ \"Message: \" ++ msg\n  putStrLn $ \"Key   \u00a0: \" ++ key\n  putStrLn $ \"XOR   \u00a0: \" ++ hexify ver\n  putStrLn $ \"XOR dcr: \" ++ unver\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Random;\n\n\npublic class IsaacRandom extends Random {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate final int[] randResult = new int[256];    \n\tprivate int valuesUsed;                           \n\t\n\t\n\tprivate final int[] mm = new int[256];\n\tprivate int aa, bb, cc;\n\t\n\tpublic IsaacRandom() {\n\t\tsuper(0);\n\t\tinit(null);\n\t}\n\t\n\tpublic IsaacRandom(int[] seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tpublic IsaacRandom(String seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tprivate void generateMoreResults() {\n\t\tcc++;\n\t\tbb += cc;\n\t\t\n\t\tfor (int i=0; i<256; i++) {\n\t\t\tint x = mm[i];\n\t\t\tswitch (i&3) {\n\t\t\tcase 0:\n\t\t\t\taa = aa^(aa<<13);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taa = aa^(aa>>>6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taa = aa^(aa<<2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\taa = aa^(aa>>>16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taa = mm[i^128] + aa;\n\t\t\tint y = mm[i] = mm[(x>>>2) & 0xFF] + aa + bb;\n\t\t\trandResult[i] = bb = mm[(y>>>10) & 0xFF] + x;\n\t\t}\n\t\t\n\t\tvaluesUsed = 0;\n\t}\n\t\n\tprivate static void mix(int[] s) {\n\t\t   s[0]^=s[1]<<11;  s[3]+=s[0]; s[1]+=s[2];\n\t\t   s[1]^=s[2]>>>2;  s[4]+=s[1]; s[2]+=s[3];\n\t\t   s[2]^=s[3]<<8;   s[5]+=s[2]; s[3]+=s[4];\n\t\t   s[3]^=s[4]>>>16; s[6]+=s[3]; s[4]+=s[5];\n\t\t   s[4]^=s[5]<<10;  s[7]+=s[4]; s[5]+=s[6];\n\t\t   s[5]^=s[6]>>>4;  s[0]+=s[5]; s[6]+=s[7];\n\t\t   s[6]^=s[7]<<8;   s[1]+=s[6]; s[7]+=s[0];\n\t\t   s[7]^=s[0]>>>9;  s[2]+=s[7]; s[0]+=s[1];\n\t}\n\t\n\tprivate void init(int[] seed) {\n\t\tif (seed != null && seed.length != 256) {\n\t\t\tseed = Arrays.copyOf(seed, 256);\n\t\t}\n\t\taa = bb = cc = 0;\n\t\tint[] initState = new int[8];\n\t\tArrays.fill(initState, 0x9e3779b9);\t\n\t\t\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tmix(initState);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<256; i+=8) {\n\t\t\tif (seed != null) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += seed[i+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmix(initState);\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tmm[i+j] = initState[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (seed != null) {\n\t\t\tfor (int i=0; i<256; i+=8) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += mm[i+j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmix(initState);\n\t\t\t\t\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tmm[i+j] = initState[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvaluesUsed = 256;\t\n\t}\n\t\n\t@Override\n\tprotected int next(int bits) {\n\t\tif (valuesUsed == 256) {\n\t\t\tgenerateMoreResults();\n\t\t\tassert(valuesUsed == 0);\n\t\t}\n\t\tint value = randResult[valuesUsed];\n\t\tvaluesUsed++;\n\t\treturn value >>> (32-bits);\n\t}\n\t\n\t@Override\n\tpublic synchronized void setSeed(long seed) {\n\t\tsuper.setSeed(0);\n\t\tif (mm == null) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tint[] arraySeed = new int[256];\n\t\tarraySeed[0] = (int) (seed & 0xFFFFFFFF);\n\t\tarraySeed[1] = (int) (seed >>> 32);\n\t\tinit(arraySeed);\n\t}\n\t\n\tpublic synchronized void setSeed(int[] seed) {\n\t\tsuper.setSeed(0);\n\t\tinit(seed);\n\t}\n\t\n\tpublic synchronized void setSeed(String seed) {\n\t\tsuper.setSeed(0);\n\t\tchar[] charSeed = seed.toCharArray();\n\t\tint[] intSeed = new int[charSeed.length];\n\t\tfor (int i=0; i<charSeed.length; i++) {\n\t\t\tintSeed[i] = charSeed[i];\n\t\t}\n\t\tinit(intSeed);\n\t}\n\t\n\tpublic int randomChar() {\n\t\tlong unsignedNext = nextInt() & 0xFFFFFFFFL;\t\n\t\treturn (int) (unsignedNext % 95 + 32);\t\t    \n\t}\n\t\n\tpublic enum CipherMode { ENCIPHER, DECIPHER, NONE };\n\t\n\tpublic byte[] vernamCipher(byte[] input) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = (byte) (randomChar() ^ input[i]);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static byte caesarShift(CipherMode mode, byte ch, int shift, byte modulo, byte start) {\n\t\tif (mode == CipherMode.DECIPHER) {\n\t\t\tshift = -shift;\n\t\t}\n\t\tint n = (ch-start) + shift;\n\t\tn %= modulo;\n\t\tif (n<0) {\n\t\t\tn += modulo;\n\t\t}\n\t\treturn (byte) (start + n);\n\t}\n\t\n\tpublic byte[] caesarCipher(CipherMode mode, byte[] input, byte modulo, byte start) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = caesarShift(mode, input[i], randomChar(), modulo, start);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static String toHexString(byte[] input) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder(input.length*2);\n\t\tfor (byte b : input) {\n\t\t\tsb.append(String.format(\"%02X\", b));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal byte MOD = 95;\n\t\tfinal byte START = 32;\n\t\t\n\t\tString secret = \"a Top Secret secret\";\n\t\tString key = \"this is my secret key\";\n\t\t\n\t\tIsaacRandom random = new IsaacRandom(key);\n\t\tbyte[] vernamResult;\n\t\tbyte[] caesarResult;\n\t\tString vernamDecrypted;\n\t\tString caesarDecrypted;\n\t\ttry {\n\t\t\tvernamResult = random.vernamCipher(secret.getBytes(\"ASCII\"));\n\t\t\tcaesarResult = random.caesarCipher(CipherMode.ENCIPHER, secret.getBytes(\"ASCII\"), MOD, START);\n\t\t\trandom.setSeed(key);\n\t\t\tvernamDecrypted = new String(random.vernamCipher(vernamResult), \"ASCII\");\n\t\t\tcaesarDecrypted = new String(random.caesarCipher(CipherMode.DECIPHER, caesarResult, MOD, START), \"ASCII\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new InternalError(\"JVM isn't conforming - ASCII encoding isn't available\");\n\t\t}\n\t\tSystem.out.printf(\"Message: %s\\n\", secret);\n\t\tSystem.out.printf(\"Key   \u00a0: %s\\n\", key);\n\t\tSystem.out.printf(\"XOR   \u00a0: %s\\n\", toHexString(vernamResult));\n\t\tSystem.out.printf(\"XOR dcr: %s\\n\", vernamDecrypted);\n\t\tSystem.out.printf(\"MOD   \u00a0: %s\\n\", toHexString(caesarResult));\n\t\tSystem.out.printf(\"MOD dcr: %s\\n\", caesarDecrypted);\n\t}\n}\n"}
{"id": 404679, "name": "The ISAAC cipher", "source": "Translate Haskell to Java: import Data.Array (Array, (!), (//), array, elems)\nimport Data.Word (Word, Word32)\nimport Data.Bits (shift, xor)\nimport Data.Char (toUpper)\nimport Data.List (unfoldr)\nimport Numeric (showHex)\n\ntype IArray = Array Word32 Word32\n\ndata IsaacState = IState\n  { randrsl :: IArray\n  , randcnt :: Word32\n  , mm :: IArray\n  , aa :: Word32\n  , bb :: Word32\n  , cc :: Word32\n  }\n\ninstance Show IsaacState where\n  show (IState _ cnt _ a b c) =\n    show cnt ++ \" \" ++ show a ++ \" \" ++ show b ++ \" \" ++ show c\n\ntoHex :: Char -> String\ntoHex c = showHex (fromEnum c) \"\"\n\nhexify :: String -> String\nhexify = map toUpper . concatMap toHex\n\ntoNum :: Char -> Word32\ntoNum = fromIntegral . fromEnum\n\ntoChar :: Word32 -> Char\ntoChar = toEnum . fromIntegral\n\ngolden :: Word32\ngolden = 0x9e3779b9\n\n\nmix :: [Word32] -> [Word32]\nmix set = foldl aux set [11, -2, 8, -16, 10, -4, 8, -9]\n  where\n    aux [a, b, c, d, e, f, g, h] x = [b + c, c, d + a_, e, f, g, h, a_]\n      where\n        a_ = a `xor` (b `shift` x)\n\n\nisaac :: IsaacState -> IsaacState\nisaac (IState rsl _ m a b c) = IState rsl_ 0 m_ a_ b_ c_\n  where\n    c_ = c + 1\n    (rsl_, m_, a_, b_) =\n      foldl aux (rsl, m, a, b) $ zip [0 .. 255] $ cycle [13, -6, 2, -16]\n    aux (rsl, m, a, b) (i, s) = (rsl_, m_, a_, b_)\n      where\n        x = m ! i\n        a_ = (a `xor` (a `shift` s)) + m ! ((i + 128) `mod` 256)\n        y = a_ + b + m ! ((x `shift` (-2)) `mod` 256)\n        m_ = m // [(i, y)]\n        b_ = x + m_ ! ((y `shift` (-10)) `mod` 256)\n        rsl_ = rsl // [(i, b_)]\n\n\nrandinit :: IsaacState -> Bool -> IsaacState\nrandinit state flag = isaac (IState randrsl_ 0 m 0 0 0)\n  where\n    firstSet = iterate mix (replicate 8 golden) !! 4\n    iter _ _ [] = []\n    iter flag set rsl =\n      let (rslH, rslT) = splitAt 8 rsl\n          set_ =\n            mix $\n            if flag\n              then zipWith (+) set rslH\n              else set\n      in set_ ++ iter flag set_ rslT\n    randrsl_ = randrsl state\n    firstPass = iter flag firstSet $ elems randrsl_\n    set_ = drop (256 - 8) firstPass\n    secondPass =\n      if flag\n        then iter True set_ firstPass\n        else firstPass\n    m = array (0, 255) $ zip [0 ..] secondPass\n\n\nseed :: String -> Bool -> IsaacState\nseed key flag =\n  let m = array (0, 255) $ zip [0 .. 255] $ repeat 0\n      rsl = m // zip [0 ..] (map toNum key)\n      state = IState rsl 0 m 0 0 0\n  in randinit state flag\n\n\nrandom :: IsaacState -> (Word32, IsaacState)\nrandom state@(IState rsl cnt m a b c) =\n  let r = rsl ! cnt\n      state_ =\n        if cnt + 1 > 255\n          then isaac $ IState rsl 0 m a b c\n          else IState rsl (cnt + 1) m a b c\n  in (r, state_)\n\n\nrandoms :: IsaacState -> [Word32]\nrandoms = unfoldr $ Just . random\n\n\n\nrandA :: IsaacState -> (Char, IsaacState)\nrandA state =\n  let (r, state_) = random state\n  in (toEnum $ fromIntegral $ (r `mod` 95) + 32, state_)\n\n\nrandAs :: IsaacState -> String\nrandAs = unfoldr $ Just . randA\n\n\nvernam :: IsaacState -> String -> String\nvernam state msg = map toChar $ zipWith xor msg_ randAs_\n  where\n    msg_ = map toNum msg\n    randAs_ = map toNum $ randAs state\n\nmain :: IO ()\nmain = do\n  let msg = \"a Top Secret secret\"\n      key = \"this is my secret key\"\n      st = seed key True\n      ver = vernam st msg\n      unver = vernam st ver\n  putStrLn $ \"Message: \" ++ msg\n  putStrLn $ \"Key   \u00a0: \" ++ key\n  putStrLn $ \"XOR   \u00a0: \" ++ hexify ver\n  putStrLn $ \"XOR dcr: \" ++ unver\n", "target": "import java.io.UnsupportedEncodingException;\nimport java.util.Arrays;\nimport java.util.Random;\n\n\npublic class IsaacRandom extends Random {\n\t\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate final int[] randResult = new int[256];    \n\tprivate int valuesUsed;                           \n\t\n\t\n\tprivate final int[] mm = new int[256];\n\tprivate int aa, bb, cc;\n\t\n\tpublic IsaacRandom() {\n\t\tsuper(0);\n\t\tinit(null);\n\t}\n\t\n\tpublic IsaacRandom(int[] seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tpublic IsaacRandom(String seed) {\n\t\tsuper(0);\n\t\tsetSeed(seed);\n\t}\n\t\n\tprivate void generateMoreResults() {\n\t\tcc++;\n\t\tbb += cc;\n\t\t\n\t\tfor (int i=0; i<256; i++) {\n\t\t\tint x = mm[i];\n\t\t\tswitch (i&3) {\n\t\t\tcase 0:\n\t\t\t\taa = aa^(aa<<13);\n\t\t\t\tbreak;\n\t\t\tcase 1:\n\t\t\t\taa = aa^(aa>>>6);\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\taa = aa^(aa<<2);\n\t\t\t\tbreak;\n\t\t\tcase 3:\n\t\t\t\taa = aa^(aa>>>16);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\taa = mm[i^128] + aa;\n\t\t\tint y = mm[i] = mm[(x>>>2) & 0xFF] + aa + bb;\n\t\t\trandResult[i] = bb = mm[(y>>>10) & 0xFF] + x;\n\t\t}\n\t\t\n\t\tvaluesUsed = 0;\n\t}\n\t\n\tprivate static void mix(int[] s) {\n\t\t   s[0]^=s[1]<<11;  s[3]+=s[0]; s[1]+=s[2];\n\t\t   s[1]^=s[2]>>>2;  s[4]+=s[1]; s[2]+=s[3];\n\t\t   s[2]^=s[3]<<8;   s[5]+=s[2]; s[3]+=s[4];\n\t\t   s[3]^=s[4]>>>16; s[6]+=s[3]; s[4]+=s[5];\n\t\t   s[4]^=s[5]<<10;  s[7]+=s[4]; s[5]+=s[6];\n\t\t   s[5]^=s[6]>>>4;  s[0]+=s[5]; s[6]+=s[7];\n\t\t   s[6]^=s[7]<<8;   s[1]+=s[6]; s[7]+=s[0];\n\t\t   s[7]^=s[0]>>>9;  s[2]+=s[7]; s[0]+=s[1];\n\t}\n\t\n\tprivate void init(int[] seed) {\n\t\tif (seed != null && seed.length != 256) {\n\t\t\tseed = Arrays.copyOf(seed, 256);\n\t\t}\n\t\taa = bb = cc = 0;\n\t\tint[] initState = new int[8];\n\t\tArrays.fill(initState, 0x9e3779b9);\t\n\t\t\n\t\tfor (int i=0; i<4; i++) {\n\t\t\tmix(initState);\n\t\t}\n\t\t\n\t\tfor (int i=0; i<256; i+=8) {\n\t\t\tif (seed != null) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += seed[i+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tmix(initState);\n\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\tmm[i+j] = initState[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (seed != null) {\n\t\t\tfor (int i=0; i<256; i+=8) {\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tinitState[j] += mm[i+j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tmix(initState);\n\t\t\t\t\n\t\t\t\tfor (int j=0; j<8; j++) {\n\t\t\t\t\tmm[i+j] = initState[j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tvaluesUsed = 256;\t\n\t}\n\t\n\t@Override\n\tprotected int next(int bits) {\n\t\tif (valuesUsed == 256) {\n\t\t\tgenerateMoreResults();\n\t\t\tassert(valuesUsed == 0);\n\t\t}\n\t\tint value = randResult[valuesUsed];\n\t\tvaluesUsed++;\n\t\treturn value >>> (32-bits);\n\t}\n\t\n\t@Override\n\tpublic synchronized void setSeed(long seed) {\n\t\tsuper.setSeed(0);\n\t\tif (mm == null) {\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\treturn;\n\t\t}\n\t\tint[] arraySeed = new int[256];\n\t\tarraySeed[0] = (int) (seed & 0xFFFFFFFF);\n\t\tarraySeed[1] = (int) (seed >>> 32);\n\t\tinit(arraySeed);\n\t}\n\t\n\tpublic synchronized void setSeed(int[] seed) {\n\t\tsuper.setSeed(0);\n\t\tinit(seed);\n\t}\n\t\n\tpublic synchronized void setSeed(String seed) {\n\t\tsuper.setSeed(0);\n\t\tchar[] charSeed = seed.toCharArray();\n\t\tint[] intSeed = new int[charSeed.length];\n\t\tfor (int i=0; i<charSeed.length; i++) {\n\t\t\tintSeed[i] = charSeed[i];\n\t\t}\n\t\tinit(intSeed);\n\t}\n\t\n\tpublic int randomChar() {\n\t\tlong unsignedNext = nextInt() & 0xFFFFFFFFL;\t\n\t\treturn (int) (unsignedNext % 95 + 32);\t\t    \n\t}\n\t\n\tpublic enum CipherMode { ENCIPHER, DECIPHER, NONE };\n\t\n\tpublic byte[] vernamCipher(byte[] input) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = (byte) (randomChar() ^ input[i]);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static byte caesarShift(CipherMode mode, byte ch, int shift, byte modulo, byte start) {\n\t\tif (mode == CipherMode.DECIPHER) {\n\t\t\tshift = -shift;\n\t\t}\n\t\tint n = (ch-start) + shift;\n\t\tn %= modulo;\n\t\tif (n<0) {\n\t\t\tn += modulo;\n\t\t}\n\t\treturn (byte) (start + n);\n\t}\n\t\n\tpublic byte[] caesarCipher(CipherMode mode, byte[] input, byte modulo, byte start) {\n\t\tbyte[] result = new byte[input.length];\n\t\tfor (int i=0; i<input.length; i++) {\n\t\t\tresult[i] = caesarShift(mode, input[i], randomChar(), modulo, start);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static String toHexString(byte[] input) {\n\t\t\n\t\tStringBuilder sb = new StringBuilder(input.length*2);\n\t\tfor (byte b : input) {\n\t\t\tsb.append(String.format(\"%02X\", b));\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal byte MOD = 95;\n\t\tfinal byte START = 32;\n\t\t\n\t\tString secret = \"a Top Secret secret\";\n\t\tString key = \"this is my secret key\";\n\t\t\n\t\tIsaacRandom random = new IsaacRandom(key);\n\t\tbyte[] vernamResult;\n\t\tbyte[] caesarResult;\n\t\tString vernamDecrypted;\n\t\tString caesarDecrypted;\n\t\ttry {\n\t\t\tvernamResult = random.vernamCipher(secret.getBytes(\"ASCII\"));\n\t\t\tcaesarResult = random.caesarCipher(CipherMode.ENCIPHER, secret.getBytes(\"ASCII\"), MOD, START);\n\t\t\trandom.setSeed(key);\n\t\t\tvernamDecrypted = new String(random.vernamCipher(vernamResult), \"ASCII\");\n\t\t\tcaesarDecrypted = new String(random.caesarCipher(CipherMode.DECIPHER, caesarResult, MOD, START), \"ASCII\");\n\t\t} catch (UnsupportedEncodingException e) {\n\t\t\tthrow new InternalError(\"JVM isn't conforming - ASCII encoding isn't available\");\n\t\t}\n\t\tSystem.out.printf(\"Message: %s\\n\", secret);\n\t\tSystem.out.printf(\"Key   \u00a0: %s\\n\", key);\n\t\tSystem.out.printf(\"XOR   \u00a0: %s\\n\", toHexString(vernamResult));\n\t\tSystem.out.printf(\"XOR dcr: %s\\n\", vernamDecrypted);\n\t\tSystem.out.printf(\"MOD   \u00a0: %s\\n\", toHexString(caesarResult));\n\t\tSystem.out.printf(\"MOD dcr: %s\\n\", caesarDecrypted);\n\t}\n}\n"}
{"id": 404680, "name": "Permutations_Rank of a permutation", "source": "Translate Haskell to Java: fact :: Int -> Int\nfact n = product [1 .. n]\n\n\n\nrankPerm [] _ = []\nrankPerm list n = c : rankPerm (a ++ b) r\n  where\n    (q, r) = n `divMod` fact (length list - 1)\n    (a, c:b) = splitAt q list\n\npermRank [] = 0\npermRank (x:xs) = length (filter (< x) xs) * fact (length xs) + permRank xs\n\nmain :: IO ()\nmain = mapM_ f [0 .. 23]\n  where\n    f n = print (n, p, permRank p)\n      where\n        p = rankPerm [0 .. 3] n\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass RankPermutation\n{\n  public static BigInteger getRank(int[] permutation)\n  {\n    int n = permutation.length;\n    BitSet usedDigits = new BitSet();\n    BigInteger rank = BigInteger.ZERO;\n    for (int i = 0; i < n; i++)\n    {\n      rank = rank.multiply(BigInteger.valueOf(n - i));\n      int digit = 0;\n      int v = -1;\n      while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])\n        digit++;\n      usedDigits.set(v);\n      rank = rank.add(BigInteger.valueOf(digit));\n    }\n    return rank;\n  }\n  \n  public static int[] getPermutation(int n, BigInteger rank)\n  {\n    int[] digits = new int[n];\n    for (int digit = 2; digit <= n; digit++)\n    {\n      BigInteger divisor = BigInteger.valueOf(digit);\n      digits[n - digit] = rank.mod(divisor).intValue();\n      if (digit < n)\n        rank = rank.divide(divisor);\n    }\n    BitSet usedDigits = new BitSet();\n    int[] permutation = new int[n];\n    for (int i = 0; i < n; i++)\n    {\n      int v = usedDigits.nextClearBit(0);\n      for (int j = 0; j < digits[i]; j++)\n        v = usedDigits.nextClearBit(v + 1);\n      permutation[i] = v;\n      usedDigits.set(v);\n    }\n    return permutation;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i < 6; i++)\n    {\n      int[] permutation = getPermutation(3, BigInteger.valueOf(i));\n      System.out.println(String.valueOf(i) + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n    }\n    Random rnd = new Random();\n    for (int n : new int[] { 12, 144 })\n    {\n      BigInteger factorial = BigInteger.ONE;\n      for (int i = 2; i <= n; i++)\n        factorial = factorial.multiply(BigInteger.valueOf(i));\n      \n      System.out.println(\"n = \" + n);\n      for (int i = 0; i < 5; i++)\n      {\n        BigInteger rank = new BigInteger((factorial.bitLength() + 1) << 1, rnd);\n        rank = rank.mod(factorial);\n        int[] permutation = getPermutation(n, rank);\n        System.out.println(\"  \" + rank + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n      }\n    }\n  }\n  \n}\n"}
{"id": 404681, "name": "Permutations_Rank of a permutation", "source": "Translate Haskell to Java: fact :: Int -> Int\nfact n = product [1 .. n]\n\n\n\nrankPerm [] _ = []\nrankPerm list n = c : rankPerm (a ++ b) r\n  where\n    (q, r) = n `divMod` fact (length list - 1)\n    (a, c:b) = splitAt q list\n\npermRank [] = 0\npermRank (x:xs) = length (filter (< x) xs) * fact (length xs) + permRank xs\n\nmain :: IO ()\nmain = mapM_ f [0 .. 23]\n  where\n    f n = print (n, p, permRank p)\n      where\n        p = rankPerm [0 .. 3] n\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass RankPermutation\n{\n  public static BigInteger getRank(int[] permutation)\n  {\n    int n = permutation.length;\n    BitSet usedDigits = new BitSet();\n    BigInteger rank = BigInteger.ZERO;\n    for (int i = 0; i < n; i++)\n    {\n      rank = rank.multiply(BigInteger.valueOf(n - i));\n      int digit = 0;\n      int v = -1;\n      while ((v = usedDigits.nextClearBit(v + 1)) < permutation[i])\n        digit++;\n      usedDigits.set(v);\n      rank = rank.add(BigInteger.valueOf(digit));\n    }\n    return rank;\n  }\n  \n  public static int[] getPermutation(int n, BigInteger rank)\n  {\n    int[] digits = new int[n];\n    for (int digit = 2; digit <= n; digit++)\n    {\n      BigInteger divisor = BigInteger.valueOf(digit);\n      digits[n - digit] = rank.mod(divisor).intValue();\n      if (digit < n)\n        rank = rank.divide(divisor);\n    }\n    BitSet usedDigits = new BitSet();\n    int[] permutation = new int[n];\n    for (int i = 0; i < n; i++)\n    {\n      int v = usedDigits.nextClearBit(0);\n      for (int j = 0; j < digits[i]; j++)\n        v = usedDigits.nextClearBit(v + 1);\n      permutation[i] = v;\n      usedDigits.set(v);\n    }\n    return permutation;\n  }\n  \n  public static void main(String[] args)\n  {\n    for (int i = 0; i < 6; i++)\n    {\n      int[] permutation = getPermutation(3, BigInteger.valueOf(i));\n      System.out.println(String.valueOf(i) + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n    }\n    Random rnd = new Random();\n    for (int n : new int[] { 12, 144 })\n    {\n      BigInteger factorial = BigInteger.ONE;\n      for (int i = 2; i <= n; i++)\n        factorial = factorial.multiply(BigInteger.valueOf(i));\n      \n      System.out.println(\"n = \" + n);\n      for (int i = 0; i < 5; i++)\n      {\n        BigInteger rank = new BigInteger((factorial.bitLength() + 1) << 1, rnd);\n        rank = rank.mod(factorial);\n        int[] permutation = getPermutation(n, rank);\n        System.out.println(\"  \" + rank + \" --> \" + Arrays.toString(permutation) + \" --> \" + getRank(permutation));\n      }\n    }\n  }\n  \n}\n"}
{"id": 404682, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Haskell to Java: import           Control.Monad (guard)\nimport           Text.Printf   (printf)\n\np :: Int -> Int -> Int\np l n = calc !! pred n\n  where\n    digitCount = floor $ logBase 10 (fromIntegral l :: Float)\n    log10pwr   = logBase 10 2\n    calc = do\n      raised <- [-1 ..]\n      let firstDigits = floor $ 10 ** (snd (properFraction $ log10pwr * realToFrac raised) \n                        + realToFrac digitCount)\n      guard (firstDigits == l)\n      [raised]\n\nmain :: IO ()\nmain = mapM_ (\\(l, n) -> printf \"p(%d, %d) = %d\\n\" l n (p l n))\n  [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 404683, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Haskell to Java: import           Control.Monad (guard)\nimport           Text.Printf   (printf)\n\np :: Int -> Int -> Int\np l n = calc !! pred n\n  where\n    digitCount = floor $ logBase 10 (fromIntegral l :: Float)\n    log10pwr   = logBase 10 2\n    calc = do\n      raised <- [-1 ..]\n      let firstDigits = floor $ 10 ** (snd (properFraction $ log10pwr * realToFrac raised) \n                        + realToFrac digitCount)\n      guard (firstDigits == l)\n      [raised]\n\nmain :: IO ()\nmain = mapM_ (\\(l, n) -> printf \"p(%d, %d) = %d\\n\" l n (p l n))\n  [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]\n", "target": "public class FirstPowerOfTwo {\n\n    public static void main(String[] args) {\n        runTest(12, 1);\n        runTest(12, 2);\n        runTest(123, 45);\n        runTest(123, 12345);\n        runTest(123, 678910);\n    }\n    \n    private static void runTest(int l, int n) {\n        System.out.printf(\"p(%d, %d) =\u00a0%,d%n\", l, n, p(l, n));\n    }\n    \n    public static int p(int l, int n) {\n        int test = 0;\n        double log = Math.log(2) / Math.log(10);\n        int factor = 1;\n        int loop = l;\n        while ( loop > 10 ) {\n            factor *= 10;\n            loop /= 10;\n        }\n        while ( n > 0) {\n            test++;\n            int val = (int) (factor * Math.pow(10, test * log % 1));\n            if ( val == l ) {\n                n--;\n            }\n        }\n        return test;\n    }\n    \n}\n"}
{"id": 404684, "name": "Stirling numbers of the second kind", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling2 :: Integral a => (a, a) -> a\nstirling2 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      | (n > 0 && k == 0) || (n == 0 && k > 0) = 0\n      | n == k = 1\n      | k > n = 0\n      | otherwise = k * stirling2 (pred n, k) + stirling2 (pred n, pred k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >> \n    mapM_ (printf \"%10d\" . stirling2) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S2(100, k):\\n%d\\n\" $\n    maximum ([stirling2 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersSecondKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Stirling numbers of the second kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling2(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S2(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling2(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling2(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( (n > 0 && k == 0) || (n == 0 && k > 0) ) {\n            return BigInteger.ZERO; \n        }\n        if ( n == k ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = BigInteger.valueOf(k).multiply(sterling2(n-1, k)).add(sterling2(n-1, k-1));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 404685, "name": "Stirling numbers of the second kind", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling2 :: Integral a => (a, a) -> a\nstirling2 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      | (n > 0 && k == 0) || (n == 0 && k > 0) = 0\n      | n == k = 1\n      | k > n = 0\n      | otherwise = k * stirling2 (pred n, k) + stirling2 (pred n, pred k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >> \n    mapM_ (printf \"%10d\" . stirling2) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S2(100, k):\\n%d\\n\" $\n    maximum ([stirling2 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersSecondKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Stirling numbers of the second kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling2(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S2(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling2(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling2(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( (n > 0 && k == 0) || (n == 0 && k > 0) ) {\n            return BigInteger.ZERO; \n        }\n        if ( n == k ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = BigInteger.valueOf(k).multiply(sterling2(n-1, k)).add(sterling2(n-1, k-1));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 404686, "name": "Pierpont primes", "source": "Translate Haskell to Java: import Control.Monad (guard)\nimport Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Math.NumberTheory.Primes (Prime, unPrime, nextPrime)\nimport Math.NumberTheory.Primes.Testing (isPrime)\nimport Text.Printf (printf)\n\ndata PierPointKind = First | Second\n\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] b = b\nmerge a@(x:xs) b@(y:ys) | x < y     = x : merge xs b\n                        | otherwise = y : merge a ys\n\nnSmooth :: Integer -> [Integer]\nnSmooth p = 1 : foldr u [] factors\n where\n  factors = takeWhile (<=p) primes\n  primes = map unPrime [nextPrime 1..]\n  u n s = r\n   where \n    r = merge s (map (n*) (1:r))\n\npierpoints :: PierPointKind -> [Integer]\npierpoints k = do \n  n <- nSmooth 3\n  let x = case k of First  -> succ n\n                    Second -> pred n\n  guard (isPrime x) >> [x]\n\nmain :: IO ()\nmain = do \n  printf \"\\nFirst 50 Pierpont primes of the first kind:\\n\"\n  mapM_ (\\row -> mapM_ (printf \"%12s\" . commas) row >> printf \"\\n\") (rows $ pierpoints First)\n  printf \"\\nFirst 50 Pierpont primes of the second kind:\\n\"\n  mapM_ (\\row -> mapM_ (printf \"%12s\" . commas) row >> printf \"\\n\") (rows $ pierpoints Second)\n  printf \"\\n250th Pierpont prime of the first kind: %s\\n\" (commas $ pierpoints First !! 249)\n  printf \"\\n250th Pierpont prime of the second kind: %s\\n\\n\" (commas $ pierpoints Second !! 249)\n where\n  rows = chunksOf 10 . take 50\n  commas = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n", "target": "import java.math.BigInteger;\nimport java.text.NumberFormat;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class PierpontPrimes {\n\n    public static void main(String[] args) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        display(\"First 50 Pierpont primes of the first kind:\", pierpontPrimes(50, true));\n        display(\"First 50 Pierpont primes of the second kind:\", pierpontPrimes(50, false));\n        System.out.printf(\"250th Pierpont prime of the first kind:     %s%n%n\", nf.format(pierpontPrimes(250, true).get(249)));\n        System.out.printf(\"250th Pierpont prime of the second kind: %s%n%n\", nf.format(pierpontPrimes(250, false).get(249)));\n    }\n    \n    private static void display(String message, List<BigInteger> primes) {\n        NumberFormat nf = NumberFormat.getNumberInstance();\n        System.out.printf(\"%s%n\", message);\n        for ( int i = 1 ; i <= primes.size() ; i++ ) {\n            System.out.printf(\"%10s  \", nf.format(primes.get(i-1)));\n            if ( i % 10 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        System.out.printf(\"%n\");\n    }\n\n    public static List<BigInteger> pierpontPrimes(int n, boolean first) {\n        List<BigInteger> primes = new ArrayList<BigInteger>();\n        if ( first ) {\n            primes.add(BigInteger.valueOf(2));\n            n -= 1;\n        }\n\n        BigInteger two = BigInteger.valueOf(2);\n        BigInteger twoTest = two;\n        BigInteger three = BigInteger.valueOf(3);\n        BigInteger threeTest = three;\n        int twoIndex = 0, threeIndex = 0;\n        List<BigInteger> twoSmooth = new ArrayList<BigInteger>();\n\n        BigInteger one = BigInteger.ONE;\n        BigInteger mOne = BigInteger.valueOf(-1);\n        int count = 0;\n        while ( count < n ) {\n            BigInteger min = twoTest.min(threeTest);\n            twoSmooth.add(min);\n            if ( min.compareTo(twoTest) == 0 ) {\n                twoTest = two.multiply(twoSmooth.get(twoIndex));\n                twoIndex++;\n            }\n            if ( min.compareTo(threeTest) == 0 ) {\n                threeTest = three.multiply(twoSmooth.get(threeIndex));\n                threeIndex++;\n            }\n            BigInteger test = min.add(first ? one : mOne);\n            if ( test.isProbablePrime(10) ) {\n                primes.add(test);\n                count++;\n            }\n        }\n        return primes;\n    }\n    \n}\n"}
{"id": 404687, "name": "N-smooth numbers", "source": "Translate Haskell to Java: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\n \nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] b = b\nmerge a@(x:xs) b@(y:ys) | x < y     = x : merge xs b\n                        | otherwise = y : merge a ys\n \nnSmooth :: Integer -> [Integer]\nnSmooth p = 1 : foldr u [] factors\n where\n   factors = takeWhile (<=p) primes\n   u n s = r\n    where r = merge s (map (n*) (1:r))\n\nmain :: IO ()\nmain = do\n  mapM_ (printf \"First 25 %d-smooth:\\n%s\\n\\n\" <*> showTwentyFive) firstTenPrimes\n  mapM_\n    (printf \"The 3,000 to 3,202 %d-smooth numbers are:\\n%s\\n\\n\" <*> showRange1)\n    firstTenPrimes\n  mapM_\n    (printf \"The 30,000 to 30,019 %d-smooth numbers are:\\n%s\\n\\n\" <*> showRange2)\n    [503, 509, 521]\n  where\n    firstTenPrimes = take 10 primes\n    showTwentyFive = show . take 25 . nSmooth\n    showRange1 = show . ((<$> [2999 .. 3001]) . (!!) . nSmooth)\n    showRange2 = show . ((<$> [29999 .. 30018]) . (!!) . nSmooth)\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class NSmoothNumbers {\n\n    public static void main(String[] args) {\n        System.out.printf(\"show the first 25 n-smooth numbers for n = 2 through n = 29%n\");\n        int max = 25;\n        List<BigInteger> primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The first %d %d-smooth numbers:%n\", max, n);\n                BigInteger[] humble = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = 0 ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", humble[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"show three numbers starting with 3,000 for n-smooth numbers for n = 3 through n = 29%n\");\n        int count = 3;\n        max = 3000 + count - 1;\n        primes = new ArrayList<>();\n        primes.add(BigInteger.valueOf(2));\n        for ( int n = 3 ; n <= 29 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                for ( int i = max-count ; i < max ; i++ ) {\n                    System.out.printf(\"%s \", nSmooth[i]);\n                }\n                System.out.printf(\"%n%n\");\n            }\n        }\n        \n        System.out.printf(\"Show twenty numbers starting with 30,000 n-smooth numbers for n=503 through n=521%n\");\n        count = 20;\n        max = 30000 + count - 1;\n        primes = new ArrayList<>();\n        for ( int n = 2 ; n <= 521 ; n++ ) {\n            if ( isPrime(n) ) {\n                primes.add(BigInteger.valueOf(n));\n                if ( n >= 503 && n <= 521 ) {\n                    System.out.printf(\"The %d through %d %d-smooth numbers:%n\", max-count+1, max, n);\n                    BigInteger[] nSmooth = nSmooth(max, primes.toArray(new BigInteger[0]));\n                    for ( int i = max-count ; i < max ; i++ ) {\n                        System.out.printf(\"%s \", nSmooth[i]);\n                    }\n                    System.out.printf(\"%n%n\");\n                }\n            }\n        }\n\n    }\n\n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) return false;\n        for ( long i = 3 ; i <= Math.sqrt(test) ; i += 2 ) {\n            if ( test % i == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static BigInteger[] nSmooth(int n, BigInteger[] primes) {\n        int size = primes.length;\n        BigInteger[] test = new BigInteger[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            test[i] = primes[i];\n        }\n        BigInteger[] results = new BigInteger[n];\n        results[0] = BigInteger.ONE;\n        \n        int[] indexes = new int[size];\n        for ( int i = 0 ; i < size ; i++ ) {\n            indexes[i] = 0;\n        }\n        \n        for ( int index = 1 ; index < n ; index++ ) {\n            BigInteger min = test[0];\n            for ( int i = 1 ; i < size ; i++ ) {\n                min = min.min(test[i]);\n            }\n            results[index] = min;\n            \n            for ( int i = 0 ; i < size ; i++ ) {\n                if ( results[index].compareTo(test[i]) == 0 ) {\n                    indexes[i] = indexes[i] + 1;\n                    test[i] = primes[i].multiply(results[indexes[i]]);\n                }\n            }\n        }\n        return results;\n    }\n\n}\n"}
{"id": 404688, "name": "Partition an integer x into n primes", "source": "Translate Haskell to Java: import Data.List (delete, intercalate)\nimport Data.Numbers.Primes (primes)\nimport Data.Bool (bool)\n\n\npartitions :: Int -> Int -> [Int]\npartitions x n\n  | n <= 1 =\n    [ x\n    | x == last ps ]\n  | otherwise = go ps x n\n  where\n    ps = takeWhile (<= x) primes\n    go ps_ x 1 =\n      [ x\n      | x `elem` ps_ ]\n    go ps_ x n = ((flip bool [] . head) <*> null) (ps_ >>= found)\n      where\n        found p =\n          ((flip bool [] . return . (p :)) <*> null)\n            ((go =<< delete p . flip takeWhile ps_ . (>=)) (x - p) (pred n))\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  (\\(x, n) ->\n      intercalate\n        \" -> \"\n        [ justifyLeft 9 ' ' (show (x, n))\n        , let xs = partitions x n\n          in bool\n               (tail $ concatMap (('+' :) . show) xs)\n               \"(no solution)\"\n               (null xs)\n        ]) <$>\n  concat\n    [ [(99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24)]\n    , (,) 22699 <$> [1 .. 4]\n    , [(40355, 3)]\n    ]\n\n\njustifyLeft :: Int -> Char -> String -> String\njustifyLeft n c s = take n (s ++ replicate n c)\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class PartitionInteger {\n    private static final int[] primes = IntStream.concat(IntStream.of(2), IntStream.iterate(3, n -> n + 2))\n        .filter(PartitionInteger::isPrime)\n        .limit(50_000)\n        .toArray();\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    private static boolean findCombo(int k, int x, int m, int n, int[] combo) {\n        boolean foundCombo = false;\n        if (k >= m) {\n            if (Arrays.stream(combo).map(i -> primes[i]).sum() == x) {\n                String s = m > 1 ? \"s\" : \"\";\n                System.out.printf(\"Partitioned %5d with %2d prime%s: \", x, m, s);\n                for (int i = 0; i < m; ++i) {\n                    System.out.print(primes[combo[i]]);\n                    if (i < m - 1) System.out.print('+');\n                    else System.out.println();\n                }\n                foundCombo = true;\n            }\n        } else {\n            for (int j = 0; j < n; ++j) {\n                if (k == 0 || j > combo[k - 1]) {\n                    combo[k] = j;\n                    if (!foundCombo) {\n                        foundCombo = findCombo(k + 1, x, m, n, combo);\n                    }\n                }\n            }\n        }\n        return foundCombo;\n    }\n\n    private static void partition(int x, int m) {\n        if (x < 2 || m < 1 || m >= x) {\n            throw new IllegalArgumentException();\n        }\n        int[] filteredPrimes = Arrays.stream(primes).filter(it -> it <= x).toArray();\n        int n = filteredPrimes.length;\n        if (n < m) throw new IllegalArgumentException(\"Not enough primes\");\n        int[] combo = new int[m];\n        boolean foundCombo = findCombo(0, x, m, n, combo);\n        if (!foundCombo) {\n            String s = m > 1 ? \"s\" : \" \";\n            System.out.printf(\"Partitioned %5d with %2d prime%s: (not possible)\\n\", x, m, s);\n        }\n    }\n\n    public static void main(String[] args) {\n        partition(99809, 1);\n        partition(18, 2);\n        partition(19, 3);\n        partition(20, 4);\n        partition(2017, 24);\n        partition(22699, 1);\n        partition(22699, 2);\n        partition(22699, 3);\n        partition(22699, 4);\n        partition(40355, 3);\n    }\n}\n"}
{"id": 404689, "name": "Zeckendorf arithmetic", "source": "Translate Haskell to Java: \nimport Data.List (find, mapAccumL)\nimport Control.Arrow (first, second)\n\n\n\nfibs :: Num a => a -> a -> [a]\nfibs a b = res\n  where\n    res = a : b : zipWith (+) res (tail res)\n\ndata Fib = Fib { sign :: Int, digits :: [Int]}\n\n\nmkFib s ds =\n  case dropWhile (==0) ds of\n    [] -> 0\n    ds -> Fib s (reverse ds)\n\n\ninstance Show Fib where\n  show (Fib s ds) = sig s ++ foldMap show (reverse ds)\n    where sig = \\case { -1 -> \"-\"; s -> \"\" }\n\n\ninstance Eq Fib where\n  Fib sa a == Fib sb b = sa == sb && a == b\n\n\ninstance Ord Fib where\n  a `compare` b =\n    sign a `compare` sign b <>\n    case find (/= 0) $ alignWith (-) (digits a) (digits b) of\n      Nothing -> EQ\n      Just 1 -> if sign a > 0 then GT else LT\n      Just (-1) -> if sign a > 0 then LT else GT\n\n\ninstance Num Fib where\n  negate (Fib s ds) = Fib (negate s) ds\n  abs (Fib s ds) = Fib 1 ds\n  signum (Fib s _) = fromIntegral s\n\n  fromInteger n =\n    case compare n 0 of\n      LT -> negate $ fromInteger (- n)\n      EQ -> Fib 0 [0]\n      GT -> Fib 1 . reverse . fst $ divModFib n 1\n\n  0 + a = a\n  a + 0 = a\n  a + b =\n    case (sign a, sign b) of\n      ( 1, 1) -> res\n      (-1, 1) -> b - (-a)\n      ( 1,-1) -> a - (-b)\n      (-1,-1) -> - ((- a) + (- b))\n    where\n      res = mkFib 1 . process $ 0:0:c\n      c = alignWith (+) (digits a) (digits b)\n       \n      process =\n        runRight 3 r2 . runLeftR 3 r2 . runRightR 4 r1\n\n  0 - a = -a\n  a - 0 = a\n  a - b =\n    case (sign a, sign b) of\n      ( 1, 1) -> res\n      (-1, 1) -> - ((-a) + b)\n      ( 1,-1) -> a + (-b)\n      (-1,-1) -> - ((-a) - (-b))  \n    where\n      res = case find (/= 0) c of\n        Just 1  -> mkFib 1 . process $ c\n        Just (-1) -> - (b - a)\n        Nothing -> 0\n      c = alignWith (-) (digits a) (digits b)\n      \n      process =\n        runRight 3 r2 . runLeftR 3 r2 . runRightR 4 r1 . runRight 3 r3\n\n  0 * a = 0\n  a * 0 = 0\n  1 * a = a\n  a * 1 = a\n  a * b =\n    case (sign a, sign b) of\n      (1, 1) -> res\n      (-1, 1) -> - ((-a) * b)\n      ( 1,-1) -> - (a * (-b))\n      (-1,-1) -> ((-a) * (-b))  \n    where\n      \n      table = fibs a (a + a)\n      res = sum $ onlyOnes $ zip (digits b) table\n      onlyOnes = map snd . filter ((==1) . fst)\n\n\ninstance Enum Fib where\n  toEnum = fromInteger . fromIntegral\n  fromEnum = fromIntegral . toInteger\n  \ninstance Real Fib where\n  toRational = fromInteger . toInteger\n  \n\ninstance Integral Fib where\n  toInteger (Fib s ds) = signum (fromIntegral s) * res\n    where\n      res = sum (zipWith (*) (fibs 1 2) (fromIntegral <$> ds))\n\n  quotRem 0 _ = (0, 0)\n  quotRem a 0 = error \"divide by zero\"\n  quotRem a b = case (sign a, sign b) of\n      (1, 1) -> first (mkFib 1) $ divModFib a b\n      (-1, 1) -> second negate . first negate $ quotRem (-a) b\n      ( 1,-1) -> first negate $ quotRem a (-b)\n      (-1,-1) -> second negate $ quotRem (-a) (-b) \n\n\n\n\n\ndivModFib :: (Ord a, Num c, Num a) => a -> a -> ([c], a)\ndivModFib a b = (q, r)\n  where\n    (r, q) = mapAccumL f a $ reverse $ takeWhile (<= a) table\n    table = fibs b (b+b)\n    f n x = if  n < x then (n, 0) else (n - x, 1)\n\n\n\nrunRight n f = go\n  where\n    go []  = []\n    go lst = let (w, r) = splitAt n lst \n                 (h: t) = f w\n             in h : go (t ++ r)\n                    \n\nrunRightR n f = go []\n  where\n    go res []  = res\n    go res lst = let (w, r) = splitAt n lst \n                     (h: t) = f w\n                 in go (h : res) (t ++ r)\n\n\nrunLeftR n f = runRightR n (reverse . f . reverse) \n\n\nr1 = \\case [0,3,0]   -> [1,1,1]\n           [0,2,0]   -> [1,0,1]\n           [0,1,2]   -> [1,0,1]\n           [0,2,1]   -> [1,1,0]\n           [x,0,2]   -> [x,1,0]\n           [x,0,3]   -> [x,1,1]\n           [0,1,2,0] -> [1,0,1,0]\n           [0,2,0,x] -> [1,0,0,x+1]\n           [0,3,0,x] -> [1,1,0,x+1]\n           [0,2,1,x] -> [1,1,0,x  ]\n           [0,1,2,x] -> [1,0,1,x  ]\n           l -> l\n\nr2 = \\case [0,1,1] -> [1,0,0]\n           l -> l\n\nr3 = \\case [1,-1]    -> [0,1]\n           [2,-1]    -> [1,1]\n           [1, 0, 0] -> [0,1,1]\n           [1,-1, 0] -> [0,0,1]\n           [1,-1, 1] -> [0,0,2]\n           [1, 0,-1] -> [0,1,0]\n           [2, 0, 0] -> [1,1,1]\n           [2,-1, 0] -> [1,0,1]\n           [2,-1, 1] -> [1,0,2]\n           [2, 0,-1] -> [1,1,0]\n           l -> l\n\nalignWith :: (Int -> Int -> a) -> [Int] -> [Int] -> [a]\nalignWith f a b = go [] a b\n  where\n    go res as [] = ((`f` 0) <$> reverse as) ++ res\n    go res [] bs = ((0 `f`) <$> reverse bs) ++ res\n    go res (a:as) (b:bs) = go (f a b : res) as bs\n", "target": "import java.util.List;\n\npublic class Zeckendorf implements Comparable<Zeckendorf> {\n    private static List<String> dig = List.of(\"00\", \"01\", \"10\");\n    private static List<String> dig1 = List.of(\"\", \"1\", \"10\");\n\n    private String x;\n    private int dVal = 0;\n    private int dLen = 0;\n\n    public Zeckendorf() {\n        this(\"0\");\n    }\n\n    public Zeckendorf(String x) {\n        this.x = x;\n\n        int q = 1;\n        int i = x.length() - 1;\n        dLen = i / 2;\n        while (i >= 0) {\n            dVal += (x.charAt(i) - '0') * q;\n            q *= 2;\n            i--;\n        }\n    }\n\n    private void a(int n) {\n        int i = n;\n        while (true) {\n            if (dLen < i) dLen = i;\n            int j = (dVal >> (i * 2)) & 3;\n            switch (j) {\n                case 0:\n                case 1:\n                    return;\n                case 2:\n                    if (((dVal >> ((i + 1) * 2)) & 1) != 1) return;\n                    dVal += 1 << (i * 2 + 1);\n                    return;\n                case 3:\n                    int temp = 3 << (i * 2);\n                    temp ^= -1;\n                    dVal = dVal & temp;\n                    b((i + 1) * 2);\n                    break;\n            }\n            i++;\n        }\n    }\n\n    private void b(int pos) {\n        if (pos == 0) {\n            Zeckendorf thiz = this;\n            thiz.inc();\n            return;\n        }\n        if (((dVal >> pos) & 1) == 0) {\n            dVal += 1 << pos;\n            a(pos / 2);\n            if (pos > 1) a(pos / 2 - 1);\n        } else {\n            int temp = 1 << pos;\n            temp ^= -1;\n            dVal = dVal & temp;\n            b(pos + 1);\n            b(pos - (pos > 1 ? 2 : 1));\n        }\n    }\n\n    private void c(int pos) {\n        if (((dVal >> pos) & 1) == 1) {\n            int temp = 1 << pos;\n            temp ^= -1;\n            dVal = dVal & temp;\n            return;\n        }\n        c(pos + 1);\n        if (pos > 0) {\n            b(pos - 1);\n        } else {\n            Zeckendorf thiz = this;\n            thiz.inc();\n        }\n    }\n\n    public Zeckendorf inc() {\n        dVal++;\n        a(0);\n        return this;\n    }\n\n    public void plusAssign(Zeckendorf other) {\n        for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n            if (((other.dVal >> gn) & 1) == 1) {\n                b(gn);\n            }\n        }\n    }\n\n    public void minusAssign(Zeckendorf other) {\n        for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n            if (((other.dVal >> gn) & 1) == 1) {\n                c(gn);\n            }\n        }\n        while ((((dVal >> dLen * 2) & 3) == 0) || (dLen == 0)) {\n            dLen--;\n        }\n    }\n\n    public void timesAssign(Zeckendorf other) {\n        Zeckendorf na = other.copy();\n        Zeckendorf nb = other.copy();\n        Zeckendorf nt;\n        Zeckendorf nr = new Zeckendorf();\n        for (int i = 0; i < (dLen + 1) * 2; i++) {\n            if (((dVal >> i) & 1) > 0) {\n                nr.plusAssign(nb);\n            }\n            nt = nb.copy();\n            nb.plusAssign(na);\n            na = nt.copy();\n        }\n        dVal = nr.dVal;\n        dLen = nr.dLen;\n    }\n\n    private Zeckendorf copy() {\n        Zeckendorf z = new Zeckendorf();\n        z.dVal = dVal;\n        z.dLen = dLen;\n        return z;\n    }\n\n    @Override\n    public int compareTo(Zeckendorf other) {\n        return ((Integer) dVal).compareTo(other.dVal);\n    }\n\n    @Override\n    public String toString() {\n        if (dVal == 0) {\n            return \"0\";\n        }\n\n        int idx = (dVal >> (dLen * 2)) & 3;\n        StringBuilder stringBuilder = new StringBuilder(dig1.get(idx));\n        for (int i = dLen - 1; i >= 0; i--) {\n            idx = (dVal >> (i * 2)) & 3;\n            stringBuilder.append(dig.get(idx));\n        }\n        return stringBuilder.toString();\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"Addition:\");\n        Zeckendorf g = new Zeckendorf(\"10\");\n        g.plusAssign(new Zeckendorf(\"10\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"10\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"1001\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"1000\"));\n        System.out.println(g);\n        g.plusAssign(new Zeckendorf(\"10101\"));\n        System.out.println(g);\n\n        System.out.println(\"\\nSubtraction:\");\n        g = new Zeckendorf(\"1000\");\n        g.minusAssign(new Zeckendorf(\"101\"));\n        System.out.println(g);\n        g = new Zeckendorf(\"10101010\");\n        g.minusAssign(new Zeckendorf(\"1010101\"));\n        System.out.println(g);\n\n        System.out.println(\"\\nMultiplication:\");\n        g = new Zeckendorf(\"1001\");\n        g.timesAssign(new Zeckendorf(\"101\"));\n        System.out.println(g);\n        g = new Zeckendorf(\"101010\");\n        g.plusAssign(new Zeckendorf(\"101\"));\n        System.out.println(g);\n    }\n}\n"}
{"id": 404690, "name": "Stirling numbers of the first kind", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling1 :: Integral a => (a, a) -> a\nstirling1 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      |  n > 0 && k == 0 = 0\n      | k > n            = 0\n      | otherwise = stirling1 (pred n, pred k) + pred n * stirling1 (pred n, k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >>\n    mapM_ (printf \"%10d\" . stirling1) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S1(100, k):\\n%d\\n\" $\n    maximum ([stirling1 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersFirstKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Unsigned Stirling numbers of the first kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling1(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S1(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling1(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling1(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( n > 0 && k == 0 ) {\n            return BigInteger.ZERO; \n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = sterling1(n-1, k-1).add(BigInteger.valueOf(n-1).multiply(sterling1(n-1, k)));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 404691, "name": "Stirling numbers of the first kind", "source": "Translate Haskell to Java: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling1 :: Integral a => (a, a) -> a\nstirling1 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      |  n > 0 && k == 0 = 0\n      | k > n            = 0\n      | otherwise = stirling1 (pred n, pred k) + pred n * stirling1 (pred n, k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >>\n    mapM_ (printf \"%10d\" . stirling1) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S1(100, k):\\n%d\\n\" $\n    maximum ([stirling1 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class SterlingNumbersFirstKind {\n\n    public static void main(String[] args) {\n        System.out.println(\"Unsigned Stirling numbers of the first kind:\");\n        int max = 12;\n        System.out.printf(\"n/k\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%10d\", n);\n        }\n        System.out.printf(\"%n\");\n        for ( int n = 0 ; n <= max ; n++ ) {\n            System.out.printf(\"%-3d\", n);\n            for ( int k = 0 ; k <= n ; k++ ) {\n                System.out.printf(\"%10s\", sterling1(n, k));\n            }\n            System.out.printf(\"%n\");\n        }\n        System.out.println(\"The maximum value of S1(100, k) = \");\n        BigInteger previous = BigInteger.ZERO;\n        for ( int k = 1 ; k <= 100 ; k++ ) {\n            BigInteger current = sterling1(100, k);\n            if ( current.compareTo(previous) > 0 ) {\n                previous = current;\n            }\n            else {\n                System.out.printf(\"%s%n(%d digits, k = %d)%n\", previous, previous.toString().length(), k-1);\n                break;\n            }\n        }\n    }\n    \n    private static Map<String,BigInteger> COMPUTED = new HashMap<>();\n    \n    private static final BigInteger sterling1(int n, int k) {\n        String key = n + \",\" + k;\n        if ( COMPUTED.containsKey(key) ) {\n            return COMPUTED.get(key);\n        }\n        if ( n == 0 && k == 0 ) {\n            return BigInteger.valueOf(1);\n        }\n        if ( n > 0 && k == 0 ) {\n            return BigInteger.ZERO; \n        }\n        if ( k > n ) {\n            return BigInteger.ZERO;\n        }\n        BigInteger result = sterling1(n-1, k-1).add(BigInteger.valueOf(n-1).multiply(sterling1(n-1, k)));\n        COMPUTED.put(key, result);\n        return result;\n    }\n\n}\n"}
{"id": 404692, "name": "Vector", "source": "Translate Haskell to Java: add (u,v) (x,y)      = (u+x,v+y)\nminus (u,v) (x,y)    = (u-x,v-y)\nmultByScalar k (x,y) = (k*x,k*y)\ndivByScalar (x,y) k  = (x/k,y/k)\n\nmain = do\n  let vecA = (3.0,8.0) \n  let (r,theta) = (3,pi/12) :: (Double,Double)\n  let vecB = (r*(cos theta),r*(sin theta)) \n  putStrLn $ \"vecA = \" ++ (show vecA)\n  putStrLn $ \"vecB = \" ++ (show vecB)\n  putStrLn $ \"vecA + vecB = \" ++ (show.add vecA $ vecB)\n  putStrLn $ \"vecA - vecB = \" ++ (show.minus vecA $ vecB)\n  putStrLn $ \"2 * vecB = \" ++ (show.multByScalar 2 $ vecB)\n  putStrLn $ \"vecA / 3 = \" ++ (show.divByScalar vecA $ 3)\n", "target": "import java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(new Vec2(5, 7).add(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).sub(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).mult(11));\n        System.out.println(new Vec2(5, 7).div(2));\n    }\n}\n\nclass Vec2 {\n    final double x, y;\n\n    Vec2(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Vec2 add(Vec2 v) {\n        return new Vec2(x + v.x, y + v.y);\n    }\n\n    Vec2 sub(Vec2 v) {\n        return new Vec2(x - v.x, y - v.y);\n    }\n\n    Vec2 div(double val) {\n        return new Vec2(x / val, y / val);\n    }\n\n    Vec2 mult(double val) {\n        return new Vec2(x * val, y * val);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(Locale.US, \"[%s, %s]\", x, y);\n    }\n}\n"}
{"id": 404693, "name": "Elliptic curve arithmetic", "source": "Translate Haskell to Java: import Data.Monoid\nimport Control.Monad (guard)\nimport Test.QuickCheck (quickCheck)\n", "target": "import static java.lang.Math.*;\nimport java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Pt a = Pt.fromY(1);\n        Pt b = Pt.fromY(2);\n        System.out.printf(\"a = %s%n\", a);\n        System.out.printf(\"b = %s%n\", b);\n        Pt c = a.plus(b);\n        System.out.printf(\"c = a + b = %s%n\", c);\n        Pt d = c.neg();\n        System.out.printf(\"d = -c = %s%n\", d);\n        System.out.printf(\"c + d = %s%n\", c.plus(d));\n        System.out.printf(\"a + b + d = %s%n\", a.plus(b).plus(d));\n        System.out.printf(\"a * 12345 = %s%n\", a.mult(12345));\n    }\n}\n\nclass Pt {\n    final static int bCoeff = 7;\n\n    double x, y;\n\n    Pt(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    static Pt zero() {\n        return new Pt(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    boolean isZero() {\n        return this.x > 1e20 || this.x < -1e20;\n    }\n\n    static Pt fromY(double y) {\n        return new Pt(cbrt(pow(y, 2) - bCoeff), y);\n    }\n\n    Pt dbl() {\n        if (isZero())\n            return this;\n        double L = (3 * this.x * this.x) / (2 * this.y);\n        double x2 = pow(L, 2) - 2 * this.x;\n        return new Pt(x2, L * (this.x - x2) - this.y);\n    }\n\n    Pt neg() {\n        return new Pt(this.x, -this.y);\n    }\n\n    Pt plus(Pt q) {\n        if (this.x == q.x && this.y == q.y)\n            return dbl();\n\n        if (isZero())\n            return q;\n\n        if (q.isZero())\n            return this;\n\n        double L = (q.y - this.y) / (q.x - this.x);\n        double xx = pow(L, 2) - this.x - q.x;\n        return new Pt(xx, L * (this.x - xx) - this.y);\n    }\n\n    Pt mult(int n) {\n        Pt r = Pt.zero();\n        Pt p = this;\n        for (int i = 1; i <= n; i <<= 1) {\n            if ((i & n) != 0)\n                r = r.plus(p);\n            p = p.dbl();\n        }\n        return r;\n    }\n\n    @Override\n    public String toString() {\n        if (isZero())\n            return \"Zero\";\n        return String.format(Locale.US, \"(%.3f,%.3f)\", this.x, this.y);\n    }\n}\n"}
{"id": 404694, "name": "Elliptic curve arithmetic", "source": "Translate Haskell to Java: import Data.Monoid\nimport Control.Monad (guard)\nimport Test.QuickCheck (quickCheck)\n", "target": "import static java.lang.Math.*;\nimport java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Pt a = Pt.fromY(1);\n        Pt b = Pt.fromY(2);\n        System.out.printf(\"a = %s%n\", a);\n        System.out.printf(\"b = %s%n\", b);\n        Pt c = a.plus(b);\n        System.out.printf(\"c = a + b = %s%n\", c);\n        Pt d = c.neg();\n        System.out.printf(\"d = -c = %s%n\", d);\n        System.out.printf(\"c + d = %s%n\", c.plus(d));\n        System.out.printf(\"a + b + d = %s%n\", a.plus(b).plus(d));\n        System.out.printf(\"a * 12345 = %s%n\", a.mult(12345));\n    }\n}\n\nclass Pt {\n    final static int bCoeff = 7;\n\n    double x, y;\n\n    Pt(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    static Pt zero() {\n        return new Pt(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY);\n    }\n\n    boolean isZero() {\n        return this.x > 1e20 || this.x < -1e20;\n    }\n\n    static Pt fromY(double y) {\n        return new Pt(cbrt(pow(y, 2) - bCoeff), y);\n    }\n\n    Pt dbl() {\n        if (isZero())\n            return this;\n        double L = (3 * this.x * this.x) / (2 * this.y);\n        double x2 = pow(L, 2) - 2 * this.x;\n        return new Pt(x2, L * (this.x - x2) - this.y);\n    }\n\n    Pt neg() {\n        return new Pt(this.x, -this.y);\n    }\n\n    Pt plus(Pt q) {\n        if (this.x == q.x && this.y == q.y)\n            return dbl();\n\n        if (isZero())\n            return q;\n\n        if (q.isZero())\n            return this;\n\n        double L = (q.y - this.y) / (q.x - this.x);\n        double xx = pow(L, 2) - this.x - q.x;\n        return new Pt(xx, L * (this.x - xx) - this.y);\n    }\n\n    Pt mult(int n) {\n        Pt r = Pt.zero();\n        Pt p = this;\n        for (int i = 1; i <= n; i <<= 1) {\n            if ((i & n) != 0)\n                r = r.plus(p);\n            p = p.dbl();\n        }\n        return r;\n    }\n\n    @Override\n    public String toString() {\n        if (isZero())\n            return \"Zero\";\n        return String.format(Locale.US, \"(%.3f,%.3f)\", this.x, this.y);\n    }\n}\n"}
{"id": 404695, "name": "Burrows\u2013Wheeler transform", "source": "Translate Haskell to Java: \n\n\n\n\n\nimport Data.List ((!!), find, sort, tails, transpose)\nimport Data.Maybe (fromJust)\nimport Text.Printf (printf)\n\nnewtype BWT a = BWT [Val a]\n\nbwt :: Ord a => [a] -> BWT a\nbwt xs = let n  = length xs + 2\n             ys = transpose $ sort $ take n $ tails $ cycle $ pos xs\n         in BWT $ ys !! (n-1)\n\ninvBwt :: Ord a => BWT a -> [a]\ninvBwt (BWT xs) = let ys = iterate step (map (const []) xs) !! length xs\n                  in unpos $ fromJust $ find ((== Post) . last) ys\n  where step = sort . zipWith (:) xs\n\n\ndata Val a = In a | Pre | Post deriving (Eq, Ord)\n\npos :: [a] -> [Val a]\npos xs = Pre : map In xs ++ [Post]\n\nunpos :: [Val a] -> [a]\nunpos xs = [x | In x <- xs]\n\n\nmain :: IO ()\nmain = mapM_ testBWT [ \"\", \"a\", \"BANANA\", \"dogwood\",\n                       \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                       \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\" ]\n\ntestBWT :: String -> IO ()\ntestBWT xs = let fwd = bwt xs\n                 inv = invBwt fwd\n             in printf \"%s\\n\\t%s\\n\\t%s\\n\" xs (pretty fwd) inv\n  where pretty (BWT ps) = map prettyVal ps\n        prettyVal (In c) = c\n        prettyVal Pre    = '^'\n        prettyVal Post   = '|'\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 404696, "name": "Burrows\u2013Wheeler transform", "source": "Translate Haskell to Java: \n\n\n\n\n\nimport Data.List ((!!), find, sort, tails, transpose)\nimport Data.Maybe (fromJust)\nimport Text.Printf (printf)\n\nnewtype BWT a = BWT [Val a]\n\nbwt :: Ord a => [a] -> BWT a\nbwt xs = let n  = length xs + 2\n             ys = transpose $ sort $ take n $ tails $ cycle $ pos xs\n         in BWT $ ys !! (n-1)\n\ninvBwt :: Ord a => BWT a -> [a]\ninvBwt (BWT xs) = let ys = iterate step (map (const []) xs) !! length xs\n                  in unpos $ fromJust $ find ((== Post) . last) ys\n  where step = sort . zipWith (:) xs\n\n\ndata Val a = In a | Pre | Post deriving (Eq, Ord)\n\npos :: [a] -> [Val a]\npos xs = Pre : map In xs ++ [Post]\n\nunpos :: [Val a] -> [a]\nunpos xs = [x | In x <- xs]\n\n\nmain :: IO ()\nmain = mapM_ testBWT [ \"\", \"a\", \"BANANA\", \"dogwood\",\n                       \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                       \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\" ]\n\ntestBWT :: String -> IO ()\ntestBWT xs = let fwd = bwt xs\n                 inv = invBwt fwd\n             in printf \"%s\\n\\t%s\\n\\t%s\\n\" xs (pretty fwd) inv\n  where pretty (BWT ps) = map prettyVal ps\n        prettyVal (In c) = c\n        prettyVal Pre    = '^'\n        prettyVal Post   = '|'\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class BWT {\n    private static final String STX = \"\\u0002\";\n    private static final String ETX = \"\\u0003\";\n\n    private static String bwt(String s) {\n        if (s.contains(STX) || s.contains(ETX)) {\n            throw new IllegalArgumentException(\"String cannot contain STX or ETX\");\n        }\n\n        String ss = STX + s + ETX;\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < ss.length(); i++) {\n            String before = ss.substring(i);\n            String after = ss.substring(0, i);\n            table.add(before + after);\n        }\n        table.sort(String::compareTo);\n\n        StringBuilder sb = new StringBuilder();\n        for (String str : table) {\n            sb.append(str.charAt(str.length() - 1));\n        }\n        return sb.toString();\n    }\n\n    private static String ibwt(String r) {\n        int len = r.length();\n        List<String> table = new ArrayList<>();\n        for (int i = 0; i < len; ++i) {\n            table.add(\"\");\n        }\n        for (int j = 0; j < len; ++j) {\n            for (int i = 0; i < len; ++i) {\n                table.set(i, r.charAt(i) + table.get(i));\n            }\n            table.sort(String::compareTo);\n        }\n        for (String row : table) {\n            if (row.endsWith(ETX)) {\n                return row.substring(1, len - 1);\n            }\n        }\n        return \"\";\n    }\n\n    private static String makePrintable(String s) {\n        \n        return s.replace(STX, \"^\").replace(ETX, \"|\");\n    }\n\n    public static void main(String[] args) {\n        List<String> tests = List.of(\n            \"banana\",\n            \"appellee\",\n            \"dogwood\",\n            \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n            \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n            \"\\u0002ABC\\u0003\"\n        );\n        for (String test : tests) {\n            System.out.println(makePrintable(test));\n            System.out.print(\" --> \");\n            String t = \"\";\n            try {\n                t = bwt(test);\n                System.out.println(makePrintable(t));\n            } catch (IllegalArgumentException e) {\n                System.out.println(\"ERROR: \" + e.getMessage());\n            }\n            String r = ibwt(t);\n            System.out.printf(\" --> %s\\n\\n\", r);\n        }\n    }\n}\n"}
{"id": 404697, "name": "Faulhaber's triangle", "source": "Translate Haskell to Java: import Data.Ratio (Ratio, denominator, numerator, (%))\n\n\n\nfaulhaber :: Int -> Rational -> Rational\nfaulhaber p n =\n  sum $\n    zipWith ((*) . (n ^)) [1 ..] (faulhaberTriangle !! p)\n\n\nfaulhaberTriangle :: [[Rational]]\nfaulhaberTriangle =\n  tail $\n    scanl\n      ( \\rs n ->\n          let xs = zipWith ((*) . (n %)) [2 ..] rs\n           in 1 - sum xs : xs\n      )\n      []\n      [0 ..]\n\n\n\nmain :: IO ()\nmain = do\n  let triangle = take 10 faulhaberTriangle\n      widths = maxWidths triangle\n  mapM_\n    putStrLn\n    [ unlines\n        ( (justifyRatio widths 8 ' ' =<<)\n            <$> triangle\n        ),\n      (show . numerator) (faulhaber 17 1000)\n    ]\n\n\n\njustifyRatio ::\n  (Int, Int) -> Int -> Char -> Rational -> String\njustifyRatio (wn, wd) n c nd =\n  go $\n    [numerator, denominator] <*> [nd]\n  where\n    \n    w = max n (wn + wd + 2)\n    go [num, den]\n      | 1 == den = center w c (show num)\n      | otherwise =\n        let (q, r) = quotRem (w - 1) 2\n         in concat\n              [ justifyRight q c (show num),\n                \"/\",\n                justifyLeft (q + r) c (show den)\n              ]\n\njustifyLeft :: Int -> a -> [a] -> [a]\njustifyLeft n c s = take n (s <> replicate n c)\n\njustifyRight :: Int -> a -> [a] -> [a]\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n\ncenter :: Int -> a -> [a] -> [a]\ncenter n c s =\n  let (q, r) = quotRem (n - length s) 2\n      pad = replicate q c\n   in concat [pad, s, pad, replicate r c]\n\nmaxWidths :: [[Rational]] -> (Int, Int)\nmaxWidths xss =\n  let widest f xs = maximum $ fmap (length . show . f) xs\n   in ((,) . widest numerator <*> widest denominator) $\n        concat xss\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.stream.LongStream;\n\npublic class FaulhabersTriangle {\n    private static final MathContext MC = new MathContext(256);\n\n    private static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private long num;\n        private long denom;\n\n        public static final Frac ZERO = new Frac(0, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) throw new IllegalArgumentException(\"d must not be zero\");\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            } else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.abs(gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(num * rhs.denom + denom * rhs.num, rhs.denom * denom);\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(-num, denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return this.plus(rhs.unaryMinus());\n        }\n\n        public Frac times(Frac rhs) {\n            return new Frac(this.num * rhs.num, this.denom * rhs.denom);\n        }\n\n        @Override\n        public int compareTo(Frac o) {\n            double diff = toDouble() - o.toDouble();\n            return Double.compare(diff, 0.0);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return null != obj && obj instanceof Frac && this.compareTo((Frac) obj) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom == 1) {\n                return Long.toString(num);\n            }\n            return String.format(\"%d/%d\", num, denom);\n        }\n\n        public double toDouble() {\n            return (double) num / denom;\n        }\n\n        public BigDecimal toBigDecimal() {\n            return BigDecimal.valueOf(num).divide(BigDecimal.valueOf(denom), MC);\n        }\n    }\n\n    private static Frac bernoulli(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n may not be negative or zero\");\n        Frac[] a = new Frac[n + 1];\n        Arrays.fill(a, Frac.ZERO);\n        for (int m = 0; m <= n; ++m) {\n            a[m] = new Frac(1, m + 1);\n            for (int j = m; j >= 1; --j) {\n                a[j - 1] = a[j - 1].minus(a[j]).times(new Frac(j, 1));\n            }\n        }\n        \n        if (n != 1) return a[0];\n        return a[0].unaryMinus();\n    }\n\n    private static long binomial(int n, int k) {\n        if (n < 0 || k < 0 || n < k) throw new IllegalArgumentException();\n        if (n == 0 || k == 0) return 1;\n        long num = LongStream.rangeClosed(k + 1, n).reduce(1, (a, b) -> a * b);\n        long den = LongStream.rangeClosed(2, n - k).reduce(1, (acc, i) -> acc * i);\n        return num / den;\n    }\n\n    private static Frac[] faulhaberTriangle(int p) {\n        Frac[] coeffs = new Frac[p + 1];\n        Arrays.fill(coeffs, Frac.ZERO);\n        Frac q = new Frac(1, p + 1);\n        int sign = -1;\n        for (int j = 0; j <= p; ++j) {\n            sign *= -1;\n            coeffs[p - j] = q.times(new Frac(sign, 1)).times(new Frac(binomial(p + 1, j), 1)).times(bernoulli(j));\n        }\n        return coeffs;\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i <= 9; ++i) {\n            Frac[] coeffs = faulhaberTriangle(i);\n            for (Frac coeff : coeffs) {\n                System.out.printf(\"%5s  \", coeff);\n            }\n            System.out.println();\n        }\n        System.out.println();\n        \n        int k = 17;\n        Frac[] cc = faulhaberTriangle(k);\n        int n = 1000;\n        BigDecimal nn = BigDecimal.valueOf(n);\n        BigDecimal np = BigDecimal.ONE;\n        BigDecimal sum = BigDecimal.ZERO;\n        for (Frac c : cc) {\n            np = np.multiply(nn);\n            sum = sum.add(np.multiply(c.toBigDecimal()));\n        }\n        System.out.println(sum.toBigInteger());\n    }\n}\n"}
{"id": 404698, "name": "Paraffins", "source": "Translate Haskell to Java: \na `nmul` n = map (*n) a\na `ndiv` n = map (`div` n) a\n\ninstance (Integral a) => Num [a] where\n  (+) = zipWith (+)\n  negate = map negate\n  a * b = foldr f undefined b where\n    f x z = (a `nmul` x) + (0 : z)\n  abs _ = undefined\n  signum _ = undefined\n  fromInteger n = fromInteger n : repeat 0\n\n\nrepl a n = concatMap (: replicate (n-1) 0) a\n\n\ncycleIndexS2 a b = (a*a + b)`ndiv` 2\n\n\ncycleIndexS4 a b c d =\t((a ^ 4) +\n\t\t\t (a ^ 2 * b) `nmul` 6 +\n\t\t\t (a * c) `nmul` 8 +\n\t\t\t (b ^ 2) `nmul` 3 +\n\t\t\t d `nmul` 6) `ndiv` 24\n\n\na598 = x1\n\nx1 = 1 : ((x1^3) + ((x2*x1)`nmul` 3) + (x3`nmul`2)) `ndiv` 6\nx2 = x1`repl`2\nx3 = x1`repl`3\nx4 = x1`repl`4\n\n\na678 = 0 : cycleIndexS4 x1 x2 x3 x4\n\n\na599 = cycleIndexS2 (0 : tail x1) (0 : tail x2)\n\n\na602 = a678 - a599 + x2\n\nmain = mapM_ print $ take 200 $ zip [0 ..] a602\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}\n"}
{"id": 404699, "name": "Paraffins", "source": "Translate Haskell to Java: \na `nmul` n = map (*n) a\na `ndiv` n = map (`div` n) a\n\ninstance (Integral a) => Num [a] where\n  (+) = zipWith (+)\n  negate = map negate\n  a * b = foldr f undefined b where\n    f x z = (a `nmul` x) + (0 : z)\n  abs _ = undefined\n  signum _ = undefined\n  fromInteger n = fromInteger n : repeat 0\n\n\nrepl a n = concatMap (: replicate (n-1) 0) a\n\n\ncycleIndexS2 a b = (a*a + b)`ndiv` 2\n\n\ncycleIndexS4 a b c d =\t((a ^ 4) +\n\t\t\t (a ^ 2 * b) `nmul` 6 +\n\t\t\t (a * c) `nmul` 8 +\n\t\t\t (b ^ 2) `nmul` 3 +\n\t\t\t d `nmul` 6) `ndiv` 24\n\n\na598 = x1\n\nx1 = 1 : ((x1^3) + ((x2*x1)`nmul` 3) + (x3`nmul`2)) `ndiv` 6\nx2 = x1`repl`2\nx3 = x1`repl`3\nx4 = x1`repl`4\n\n\na678 = 0 : cycleIndexS4 x1 x2 x3 x4\n\n\na599 = cycleIndexS2 (0 : tail x1) (0 : tail x2)\n\n\na602 = a678 - a599 + x2\n\nmain = mapM_ print $ take 200 $ zip [0 ..] a602\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\nclass Test {\n    final static int nMax = 250;\n    final static int nBranches = 4;\n\n    static BigInteger[] rooted = new BigInteger[nMax + 1];\n    static BigInteger[] unrooted = new BigInteger[nMax + 1];\n    static BigInteger[] c = new BigInteger[nBranches];\n\n    static void tree(int br, int n, int l, int inSum, BigInteger cnt) {\n        int sum = inSum;\n        for (int b = br + 1; b <= nBranches; b++) {\n            sum += n;\n\n            if (sum > nMax || (l * 2 >= sum && b >= nBranches))\n                return;\n\n            BigInteger tmp = rooted[n];\n            if (b == br + 1) {\n                c[br] = tmp.multiply(cnt);\n            } else {\n                c[br] = c[br].multiply(tmp.add(BigInteger.valueOf(b - br - 1)));\n                c[br] = c[br].divide(BigInteger.valueOf(b - br));\n            }\n\n            if (l * 2 < sum)\n                unrooted[sum] = unrooted[sum].add(c[br]);\n\n            if (b < nBranches)\n                rooted[sum] = rooted[sum].add(c[br]);\n\n            for (int m = n - 1; m > 0; m--)\n                tree(b, m, l, sum, c[br]);\n        }\n    }\n\n    static void bicenter(int s) {\n        if ((s & 1) == 0) {\n            BigInteger tmp = rooted[s / 2];\n            tmp = tmp.add(BigInteger.ONE).multiply(rooted[s / 2]);\n            unrooted[s] = unrooted[s].add(tmp.shiftRight(1));\n        }\n    }\n\n    public static void main(String[] args) {\n        Arrays.fill(rooted, BigInteger.ZERO);\n        Arrays.fill(unrooted, BigInteger.ZERO);\n        rooted[0] = rooted[1] = BigInteger.ONE;\n        unrooted[0] = unrooted[1] = BigInteger.ONE;\n\n        for (int n = 1; n <= nMax; n++) {\n            tree(0, n, n, 1, BigInteger.ONE);\n            bicenter(n);\n            System.out.printf(\"%d: %s%n\", n, unrooted[n]);\n        }\n    }\n}\n"}
{"id": 404700, "name": "Faulhaber's formula", "source": "Translate Haskell to Java: import Data.Ratio ((%), numerator, denominator)\nimport Data.List (intercalate, transpose)\nimport Data.Bifunctor (bimap)\nimport Data.Char (isSpace)\nimport Data.Monoid ((<>))\nimport Data.Bool (bool)\n \n\nfaulhaber :: [[Rational]]\nfaulhaber =\n  tail $\n  scanl\n    (\\rs n ->\n        let xs = zipWith ((*) . (n %)) [2 ..] rs\n        in 1 - sum xs : xs)\n    []\n    [0 ..]\n    \npolynomials :: [[(String, String)]]\npolynomials = fmap ((ratioPower =<<) . reverse . flip zip [1 ..]) faulhaber\n    \n\n\nmain :: IO ()\nmain = (putStrLn . unlines . expressionTable . take 10) polynomials\n\n \n\n\n\nexpressionTable :: [[(String, String)]] -> [String]\nexpressionTable ps =\n  let cols = transpose (fullTable ps)\n  in expressionRow <$>\n     zip\n       [0 ..]\n       (transpose $\n        zipWith\n          (\\(lw, rw) col ->\n              fmap (bimap (justifyLeft lw ' ') (justifyLeft rw ' ')) col)\n          (colWidths cols)\n          cols)\n          \n\nratioPower :: (Rational, Integer) -> [(String, String)]\nratioPower (nd, j) =\n  let (num, den) = ((,) . numerator <*> denominator) nd\n      sn\n        | num == 0 = []\n        | (j /= 1) = (\"n^\" <> show j)\n        | otherwise = \"n\"\n      sr\n        | num == 0 = []\n        | den == 1 && num == 1 = []\n        | den == 1 = show num <> \"n\"\n        | otherwise = intercalate \"/\" [show num, show den]\n      s = sr <> sn\n  in bool [(sn, sr)] [] (null s)\n \n\nfullTable :: [[(String, String)]] -> [[(String, String)]]\nfullTable xs =\n  let lng = maximum $ length <$> xs\n  in (<>) <*> (flip replicate ([], []) . (-) lng . length) <$> xs\n \njustifyLeft :: Int -> Char -> String -> String\njustifyLeft n c s = take n (s <> replicate n c)\n \n\nexpressionRow :: (Int, [(String, String)]) -> String\nexpressionRow (i, row) =\n  concat\n    [ show i\n    , \" ->  \"\n    , foldr\n        (\\s a -> concat [s, bool \" + \" \" \" (blank a || head a == '-'), a])\n        []\n        (polyTerm <$> row)\n    ]\n \n\npolyTerm :: (String, String) -> String\npolyTerm (l, r)\n  | blank l || blank r = l <> r\n  | head r == '-' = concat [\"- \", l, \" * \", tail r]\n  | otherwise = intercalate \" * \" [l, r]\n \nblank :: String -> Bool\nblank = all isSpace\n \n\ncolWidths :: [[(String, String)]] -> [(Int, Int)]\ncolWidths =\n  fmap\n    (foldr\n       (\\(ls, rs) (lMax, rMax) -> (max (length ls) lMax, max (length rs) rMax))\n       (0, 0))\n \n\nunsignedLength :: String -> Int\nunsignedLength xs =\n  let l = length xs\n  in bool (bool l (l - 1) ('-' == head xs)) 0 (0 == l)\n", "target": "import java.util.Arrays;\nimport java.util.stream.IntStream;\n\npublic class FaulhabersFormula {\n    private static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    private static class Frac implements Comparable<Frac> {\n        private long num;\n        private long denom;\n\n        public static final Frac ZERO = new Frac(0, 1);\n        public static final Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) throw new IllegalArgumentException(\"d must not be zero\");\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            } else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.abs(gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        public Frac plus(Frac rhs) {\n            return new Frac(num * rhs.denom + denom * rhs.num, rhs.denom * denom);\n        }\n\n        public Frac unaryMinus() {\n            return new Frac(-num, denom);\n        }\n\n        public Frac minus(Frac rhs) {\n            return this.plus(rhs.unaryMinus());\n        }\n\n        public Frac times(Frac rhs) {\n            return new Frac(this.num * rhs.num, this.denom * rhs.denom);\n        }\n\n        @Override\n        public int compareTo(Frac o) {\n            double diff = toDouble() - o.toDouble();\n            return Double.compare(diff, 0.0);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            return null != obj && obj instanceof Frac && this.compareTo((Frac) obj) == 0;\n        }\n\n        @Override\n        public String toString() {\n            if (denom == 1) {\n                return Long.toString(num);\n            }\n            return String.format(\"%d/%d\", num, denom);\n        }\n\n        private double toDouble() {\n            return (double) num / denom;\n        }\n    }\n\n    private static Frac bernoulli(int n) {\n        if (n < 0) throw new IllegalArgumentException(\"n may not be negative or zero\");\n        Frac[] a = new Frac[n + 1];\n        Arrays.fill(a, Frac.ZERO);\n        for (int m = 0; m <= n; ++m) {\n            a[m] = new Frac(1, m + 1);\n            for (int j = m; j >= 1; --j) {\n                a[j - 1] = a[j - 1].minus(a[j]).times(new Frac(j, 1));\n            }\n        }\n        \n        if (n != 1) return a[0];\n        return a[0].unaryMinus();\n    }\n\n    private static int binomial(int n, int k) {\n        if (n < 0 || k < 0 || n < k) throw new IllegalArgumentException();\n        if (n == 0 || k == 0) return 1;\n        int num = IntStream.rangeClosed(k + 1, n).reduce(1, (a, b) -> a * b);\n        int den = IntStream.rangeClosed(2, n - k).reduce(1, (acc, i) -> acc * i);\n        return num / den;\n    }\n\n    private static void faulhaber(int p) {\n        System.out.printf(\"%d\u00a0: \", p);\n        Frac q = new Frac(1, p + 1);\n        int sign = -1;\n        for (int j = 0; j <= p; ++j) {\n            sign *= -1;\n            Frac coeff = q.times(new Frac(sign, 1)).times(new Frac(binomial(p + 1, j), 1)).times(bernoulli(j));\n            if (Frac.ZERO.equals(coeff)) continue;\n            if (j == 0) {\n                if (!Frac.ONE.equals(coeff)) {\n                    if (Frac.ONE.unaryMinus().equals(coeff)) {\n                        System.out.print(\"-\");\n                    } else {\n                        System.out.print(coeff);\n                    }\n                }\n            } else {\n                if (Frac.ONE.equals(coeff)) {\n                    System.out.print(\" + \");\n                } else if (Frac.ONE.unaryMinus().equals(coeff)) {\n                    System.out.print(\" - \");\n                } else if (coeff.compareTo(Frac.ZERO) > 0) {\n                    System.out.printf(\" + %s\", coeff);\n                } else {\n                    System.out.printf(\" - %s\", coeff.unaryMinus());\n                }\n            }\n            int pwr = p + 1 - j;\n            if (pwr > 1)\n                System.out.printf(\"n^%d\", pwr);\n            else\n                System.out.print(\"n\");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        for (int i = 0; i <= 9; ++i) {\n            faulhaber(i);\n        }\n    }\n}\n"}
{"id": 404701, "name": "Active Directory_Search for a user", "source": "Translate Haskell to Java: \n\nmodule Main (main) where\n\nimport           Data.Foldable (for_)\nimport qualified Data.Text.Encoding as Text (encodeUtf8)\nimport           Ldap.Client (Attr(..), Filter(..))\nimport qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly)\n\nmain :: IO ()\nmain = do\n    entries <- Ldap.with (Ldap.Plain \"localhost\") 389 $ \\ldap ->\n        Ldap.search ldap (Ldap.Dn \"o=example.com\") (Ldap.typesOnly True) (Attr \"uid\" := Text.encodeUtf8 \"user\") []\n    for_ entries $ \\entry ->\n        print entry\n", "target": "import java.io.IOException;\nimport org.apache.directory.api.ldap.model.cursor.CursorException;\nimport org.apache.directory.api.ldap.model.cursor.EntryCursor;\nimport org.apache.directory.api.ldap.model.entry.Entry;\nimport org.apache.directory.api.ldap.model.exception.LdapException;\nimport org.apache.directory.api.ldap.model.message.SearchScope;\nimport org.apache.directory.ldap.client.api.LdapConnection;\nimport org.apache.directory.ldap.client.api.LdapNetworkConnection;\n\npublic class LdapSearchDemo {\n\n    public static void main(String[] args) throws IOException, LdapException, CursorException {\n        new LdapSearchDemo().demonstrateSearch();\n    }\n\n    private void demonstrateSearch() throws IOException, LdapException, CursorException {\n        try (LdapConnection conn = new LdapNetworkConnection(\"localhost\", 11389)) {\n            conn.bind(\"uid=admin,ou=system\", \"********\");\n            search(conn, \"*mil*\");\n            conn.unBind();\n        }\n    }\n\n    private void search(LdapConnection connection, String uid) throws LdapException, CursorException {\n        String baseDn = \"ou=users,o=mojo\";\n        String filter = \"(&(objectClass=person)(&(uid=\" + uid + \")))\";\n        SearchScope scope = SearchScope.SUBTREE;\n        String[] attributes = {\"dn\", \"cn\", \"sn\", \"uid\"};\n        int ksearch = 0;\n\n        EntryCursor cursor = connection.search(baseDn, filter, scope, attributes);\n        while (cursor.next()) {\n            ksearch++;\n            Entry entry = cursor.get();\n            System.out.printf(\"Search entry %d = %s%n\", ksearch, entry);\n        }\n    }\n}\n"}
{"id": 404702, "name": "Prime conspiracy", "source": "Translate Haskell to Java: import Data.List (group, sort)\nimport Text.Printf (printf)\nimport Data.Numbers.Primes (primes)\n\nfreq :: [(Int, Int)] -> Float\nfreq xs = realToFrac (length xs) / 100\n\nline :: [(Int, Int)] -> IO ()\nline t@((n1, n2):xs) = printf \"%d -> %d count: %5d frequency: %2.2f\u00a0%%\\n\" n1 n2 (length t) (freq t) \n\nmain :: IO ()\nmain = mapM_ line $ groups primes\n  where groups = tail . group . sort . (\\n -> zip (0: n) n) . fmap (`mod` 10) . take 10000\n", "target": "public class PrimeConspiracy {\n\n    public static void main(String[] args) {\n        final int limit = 1000_000;\n        final int sieveLimit = 15_500_000;\n\n        int[][] buckets = new int[10][10];\n        int prevDigit = 2;\n        boolean[] notPrime = sieve(sieveLimit);\n\n        for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n            if (notPrime[n])\n                continue;\n\n            int digit = n % 10;\n            buckets[prevDigit][digit]++;\n            prevDigit = digit;\n            primeCount++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (buckets[i][j] != 0) {\n                    System.out.printf(\"%d -> %d\u00a0: %2f%n\", i,\n                            j, buckets[i][j] / (limit / 100.0));\n                }\n            }\n        }\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 404703, "name": "List rooted trees", "source": "Translate Haskell to Java: \nparts :: Int -> [[(Int, Int)]]\nparts n = f n 1\n  where\n    f n x\n      | n == 0 = [[]]\n      | x > n = []\n      | otherwise =\n        f n (x + 1) ++\n        concatMap\n          (\\c -> map ((c, x) :) (f (n - c * x) (x + 1)))\n          [1 .. n `div` x]\n\n\npick :: Int -> [String] -> [String]\npick _ [] = []\npick 0 _ = [\"\"]\npick n aa@(a:as) = map (a ++) (pick (n - 1) aa) ++ pick n as\n\n\n\ntrees :: Int -> [String]\ntrees n =\n  map (\\x -> \"(\" ++ x ++ \")\") $\n  concatMap (foldr (prod . build) [\"\"]) (parts (n - 1))\n  where\n    build (c, x) = pick c $ trees x\n    prod aa bb =\n      [ a ++ b\n      | a <- aa \n      , b <- bb ]\n\nmain :: IO ()\nmain = mapM_ putStrLn $ trees 5\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class ListRootedTrees {\n    private static final List<Long> TREE_LIST = new ArrayList<>();\n\n    private static final List<Integer> OFFSET = new ArrayList<>();\n\n    static {\n        for (int i = 0; i < 32; i++) {\n            if (i == 1) {\n                OFFSET.add(1);\n            } else {\n                OFFSET.add(0);\n            }\n        }\n    }\n\n    private static void append(long t) {\n        TREE_LIST.add(1 | (t << 1));\n    }\n\n    private static void show(long t, int l) {\n        while (l-- > 0) {\n            if (t % 2 == 1) {\n                System.out.print('(');\n            } else {\n                System.out.print(')');\n            }\n            t = t >> 1;\n        }\n    }\n\n    private static void listTrees(int n) {\n        for (int i = OFFSET.get(n); i < OFFSET.get(n + 1); i++) {\n            show(TREE_LIST.get(i), n * 2);\n            System.out.println();\n        }\n    }\n\n    private static void assemble(int n, long t, int sl, int pos, int rem) {\n        if (rem == 0) {\n            append(t);\n            return;\n        }\n\n        var pp = pos;\n        var ss = sl;\n\n        if (sl > rem) {\n            ss = rem;\n            pp = OFFSET.get(ss);\n        } else if (pp >= OFFSET.get(ss + 1)) {\n            ss--;\n            if (ss == 0) {\n                return;\n            }\n            pp = OFFSET.get(ss);\n        }\n\n        assemble(n, t << (2 * ss) | TREE_LIST.get(pp), ss, pp, rem - ss);\n        assemble(n, t, ss, pp + 1, rem);\n    }\n\n    private static void makeTrees(int n) {\n        if (OFFSET.get(n + 1) != 0) {\n            return;\n        }\n        if (n > 0) {\n            makeTrees(n - 1);\n        }\n        assemble(n, 0, n - 1, OFFSET.get(n - 1), n - 1);\n        OFFSET.set(n + 1, TREE_LIST.size());\n    }\n\n    private static void test(int n) {\n        if (n < 1 || n > 12) {\n            throw new IllegalArgumentException(\"Argument must be between 1 and 12\");\n        }\n\n        append(0);\n\n        makeTrees(n);\n        System.out.printf(\"Number of %d-trees: %d\\n\", n, OFFSET.get(n + 1) - OFFSET.get(n));\n        listTrees(n);\n    }\n\n    public static void main(String[] args) {\n        test(5);\n    }\n}\n"}
{"id": 404704, "name": "Lucky and even lucky numbers", "source": "Translate Haskell to Java: import System.Environment\nimport Text.Regex.Posix\n\ndata Lucky = Lucky | EvenLucky \n\nhelpMessage :: IO ()\nhelpMessage = do\n  putStrLn \"                           what is displayed  (on a single line)\"\n  putStrLn \"     argument(s)              (optional verbiage is encouraged)\"\n  putStrLn \"======================|===================================================\"\n  putStrLn \" j                    | Jth       lucky number                            \"\n  putStrLn \" j  ,          lucky  | Jth       lucky number                            \"\n  putStrLn \" j  ,      evenLucky  | Jth  even lucky number                            \"\n  putStrLn \"                                                                          \"\n  putStrLn \" j  k                 | Jth  through  Kth (inclusive)       lucky numbers \"\n  putStrLn \" j  k          lucky  | Jth  through  Kth (inclusive)       lucky numbers \"\n  putStrLn \" j  k      evenlucky  | Jth  through  Kth (inclusive)  even lucky numbers \"\n  putStrLn \"                                                                          \"\n  putStrLn \" j -k                 | all       lucky numbers in the range  j -> |k|    \"\n  putStrLn \" j -k          lucky  | all       lucky numbers in the range  j -> |k|    \"\n  putStrLn \" j -k      evenlucky  | all  even lucky numbers in the range  j -> |k|    \"\n  putStrLn \"======================|===================================================\"\n\noddNumbers :: [Int]\noddNumbers = filter odd [1..]\n\nevenNumbers :: [Int]\nevenNumbers = filter even [1..]\n\nluckyNumbers :: [Int] -> [Int]\nluckyNumbers xs = \n  let i = 3 in\n  sieve i xs\n    where\n      sieve i (ln:s:xs) =\n        ln : sieve (i + 1) (s : [x | (n, x) <- zip [i..] xs, rem n s /= 0])\n\nnth :: Int -> Lucky -> Int\nnth j Lucky     = luckyNumbers oddNumbers !! (j-1)\nnth j EvenLucky = luckyNumbers evenNumbers !! (j-1)\n\nrange :: Int -> Int -> Lucky -> [Int]\nrange x x2 Lucky     = drop (x-1) (take x2 (luckyNumbers oddNumbers))\nrange x x2 EvenLucky = drop (x-1) (take x2 (luckyNumbers evenNumbers))\n\ninterval :: Int -> Int -> Lucky -> [Int]\ninterval x x2 Lucky     = dropWhile (<x) (takeWhile (<=x2) (luckyNumbers oddNumbers))\ninterval x x2 EvenLucky = dropWhile (<x) (takeWhile (<=x2) (luckyNumbers evenNumbers))\n\nlucky :: [String] -> Lucky\nlucky xs = \n  if \"evenLucky\" `elem` xs\n   then EvenLucky\n   else Lucky\n\nreadn :: String -> Int\nreadn s = read s :: Int\n\nisInt :: String -> Bool\nisInt s = not (null (s =~ \"-?[0-9]{0,10}\" :: String))\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  if head args == \"\n    then\n      helpMessage\n    else\n      let l = lucky args in\n      case map readn (filter isInt args) of\n        [] -> do\n          putStrLn \"Invalid input, missing arguments\"\n          putStrLn \"Type \n        [x] -> print (nth x l)\n        [x, x2] -> if x2 > 0\n          then print (range x x2 l)\n          else print (interval x (-x2) l)\n        _ -> do \n          putStrLn \"Invalid input, wrong number of arguments\"\n          putStrLn \"Type \n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class LuckyNumbers {\n\n    private static int MAX = 200000;\n    private static List<Integer> luckyEven = luckyNumbers(MAX, true);\n    private static List<Integer> luckyOdd = luckyNumbers(MAX, false);\n    \n    public static void main(String[] args) {\n        \n        if ( args.length == 1 || ( args.length == 2 && args[1].compareTo(\"lucky\") == 0 ) ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"LuckyNumber(%d) = %d%n\", n, luckyOdd.get(n-1));\n        }\n        \n        else if ( args.length == 2 && args[1].compareTo(\"evenLucky\") == 0 ) {\n            int n = Integer.parseInt(args[0]);\n            System.out.printf(\"EvenLuckyNumber(%d) = %d%n\", n, luckyEven.get(n-1));            \n        }\n        \n        else if ( args.length == 2 || args.length == 3 ) {\n            int j = Integer.parseInt(args[0]);\n            int k = Integer.parseInt(args[1]);\n            \n            if ( ( args.length == 2 && k > 0 ) || (args.length == 3 && k > 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                System.out.printf(\"LuckyNumber(%d) through LuckyNumber(%d) = %s%n\", j, k, luckyOdd.subList(j-1, k));\n            }\n            \n            else if ( args.length == 3 && k > 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                System.out.printf(\"EvenLuckyNumber(%d) through EvenLuckyNumber(%d) = %s%n\", j, k, luckyEven.subList(j-1, k));\n            }\n            \n            else if ( ( args.length == 2 && k < 0 ) || (args.length == 3 && k < 0 && args[2].compareTo(\"lucky\") == 0 ) ) {\n                int n = Collections.binarySearch(luckyOdd, j);\n                int m = Collections.binarySearch(luckyOdd, -k);\n                System.out.printf(\"Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyOdd.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n            \n            else if ( args.length == 3 && k < 0 && args[2].compareTo(\"evenLucky\") == 0 ) {\n                int n = Collections.binarySearch(luckyEven, j);\n                int m = Collections.binarySearch(luckyEven, -k);\n                System.out.printf(\"Even Lucky Numbers in the range %d to %d inclusive = %s%n\", j, -k, luckyEven.subList(n < 0 ? -n-1 : n, m < 0 ? -m-1 : m+1));\n            }\n        }\n    }\n    \n    private static List<Integer> luckyNumbers(int max, boolean even) {\n        List<Integer> luckyList = new ArrayList<>();\n        for ( int i = even ? 2 : 1 ; i <= max ; i += 2 ) {\n            luckyList.add(i);\n        }\n        int start = 1;\n        boolean removed = true;\n        while ( removed ) {\n            removed = false;\n            int increment = luckyList.get(start);\n            List<Integer> remove = new ArrayList<>();\n            for ( int i = increment-1 ; i < luckyList.size() ; i += increment ) {\n                remove.add(0, i);\n                removed = true;\n            }\n            for ( int i : remove ) {\n                luckyList.remove(i);\n            }\n            start++;\n        }\n        return luckyList;\n    }\n\n}\n"}
{"id": 404705, "name": "Imaginary base numbers", "source": "Translate Haskell to Java: import Data.Char (chr, digitToInt, intToDigit, isDigit, ord)\nimport Data.Complex (Complex (..), imagPart, realPart)\nimport Data.List (delete, elemIndex)\nimport Data.Maybe (fromMaybe)\n\nbase :: Complex Float\nbase = 0 :+ 2\n\nquotRemPositive :: Int -> Int -> (Int, Int)\nquotRemPositive a b\n  | r < 0 = (1 + q, floor (realPart (-base ^^ 2)) + r)\n  | otherwise = (q, r)\n  where\n    (q, r) = quotRem a b\n\ndigitToIntQI :: Char -> Int\ndigitToIntQI c\n  | isDigit c = digitToInt c\n  | otherwise = ord c - ord 'a' + 10\n\nshiftRight :: String -> String\nshiftRight n\n  | l == '0' = h\n  | otherwise = h <> ('.' : [l])\n  where\n    (l, h) = (last n, init n)\n\nintToDigitQI :: Int -> Char\nintToDigitQI i\n  | i `elem` [0 .. 9] = intToDigit i\n  | otherwise = chr (i - 10 + ord 'a')\n\nfromQItoComplex :: String -> Complex Float -> Complex Float\nfromQItoComplex num b =\n  let dot = fromMaybe (length num) (elemIndex '.' num)\n   in fst $\n        foldl\n          ( \\(a, indx) x ->\n              ( a + fromIntegral (digitToIntQI x)\n                  * (b ^^ (dot - indx)),\n                indx + 1\n              )\n          )\n          (0, 1)\n          (delete '.' num)\n\neuclidEr :: Int -> Int -> [Int] -> [Int]\neuclidEr a b l\n  | a == 0 = l\n  | otherwise =\n      let (q, r) = quotRemPositive a b\n       in euclidEr q b (0 : r : l)\n\nfromIntToQI :: Int -> [Int]\nfromIntToQI 0 = [0]\nfromIntToQI x =\n  tail\n    ( euclidEr\n        x\n        (floor $ realPart (base ^^ 2))\n        []\n    )\n\ngetCuid :: Complex Int -> Int\ngetCuid c = imagPart c * floor (imagPart (-base))\n\nqizip :: Complex Int -> [Int]\nqizip c =\n  let (r, i) =\n        ( fromIntToQI (realPart c) <> [0],\n          fromIntToQI (getCuid c)\n        )\n   in let m = min (length r) (length i)\n       in take (length r - m) r\n            <> take (length i - m) i\n            <> reverse\n              ( zipWith\n                  (+)\n                  (take m (reverse r))\n                  (take m (reverse i))\n              )\n\nfromComplexToQI :: Complex Int -> String\nfromComplexToQI = shiftRight . fmap intToDigitQI . qizip\n\nmain :: IO ()\nmain =\n  putStrLn (fromComplexToQI (35 :+ 23))\n    >> print (fromQItoComplex \"10.2\" base)\n", "target": "public class ImaginaryBaseNumber {\n    private static class Complex {\n        private Double real, imag;\n\n        public Complex(double r, double i) {\n            this.real = r;\n            this.imag = i;\n        }\n\n        public Complex(int r, int i) {\n            this.real = (double) r;\n            this.imag = (double) i;\n        }\n\n        public Complex add(Complex rhs) {\n            return new Complex(\n                real + rhs.real,\n                imag + rhs.imag\n            );\n        }\n\n        public Complex times(Complex rhs) {\n            return new Complex(\n                real * rhs.real - imag * rhs.imag,\n                real * rhs.imag + imag * rhs.real\n            );\n        }\n\n        public Complex times(double rhs) {\n            return new Complex(\n                real * rhs,\n                imag * rhs\n            );\n        }\n\n        public Complex inv() {\n            double denom = real * real + imag * imag;\n            return new Complex(\n                real / denom,\n                -imag / denom\n            );\n        }\n\n        public Complex unaryMinus() {\n            return new Complex(-real, -imag);\n        }\n\n        public Complex divide(Complex rhs) {\n            return this.times(rhs.inv());\n        }\n\n        \n        public QuaterImaginary toQuaterImaginary() {\n            if (real == 0.0 && imag == 0.0) return new QuaterImaginary(\"0\");\n            int re = real.intValue();\n            int im = imag.intValue();\n            int fi = -1;\n            StringBuilder sb = new StringBuilder();\n            while (re != 0) {\n                int rem = re % -4;\n                re /= -4;\n                if (rem < 0) {\n                    rem += 4;\n                    re++;\n                }\n                sb.append(rem);\n                sb.append(0);\n            }\n            if (im != 0) {\n                Double f = new Complex(0.0, imag).divide(new Complex(0.0, 2.0)).real;\n                im = ((Double) Math.ceil(f)).intValue();\n                f = -4.0 * (f - im);\n                int index = 1;\n                while (im != 0) {\n                    int rem = im % -4;\n                    im /= -4;\n                    if (rem < 0) {\n                        rem += 4;\n                        im++;\n                    }\n                    if (index < sb.length()) {\n                        sb.setCharAt(index, (char) (rem + 48));\n                    } else {\n                        sb.append(0);\n                        sb.append(rem);\n                    }\n                    index += 2;\n                }\n                fi = f.intValue();\n            }\n            sb.reverse();\n            if (fi != -1) sb.append(\".\").append(fi);\n            while (sb.charAt(0) == '0') sb.deleteCharAt(0);\n            if (sb.charAt(0) == '.') sb.insert(0, '0');\n            return new QuaterImaginary(sb.toString());\n        }\n\n        @Override\n        public String toString() {\n            double real2 = real == -0.0 ? 0.0 : real;  \n            double imag2 = imag == -0.0 ? 0.0 : imag;  \n            String result = imag2 >= 0.0 ? String.format(\"%.0f +\u00a0%.0fi\", real2, imag2) : String.format(\"%.0f -\u00a0%.0fi\", real2, -imag2);\n            result = result.replace(\".0 \", \" \").replace(\".0i\", \"i\").replace(\" + 0i\", \"\");\n            if (result.startsWith(\"0 + \")) result = result.substring(4);\n            if (result.startsWith(\"0 - \")) result = result.substring(4);\n            return result;\n        }\n    }\n\n    private static class QuaterImaginary {\n        private static final Complex TWOI = new Complex(0.0, 2.0);\n        private static final Complex INVTWOI = TWOI.inv();\n\n        private String b2i;\n\n        public QuaterImaginary(String b2i) {\n            if (b2i.equals(\"\") || !b2i.chars().allMatch(c -> \"0123.\".indexOf(c) > -1) || b2i.chars().filter(c -> c == '.').count() > 1) {\n                throw new RuntimeException(\"Invalid Base 2i number\");\n            }\n            this.b2i = b2i;\n        }\n\n        public Complex toComplex() {\n            int pointPos = b2i.indexOf(\".\");\n            int posLen = pointPos != -1 ? pointPos : b2i.length();\n            Complex sum = new Complex(0, 0);\n            Complex prod = new Complex(1, 0);\n\n            for (int j = 0; j < posLen; ++j) {\n                double k = b2i.charAt(posLen - 1 - j) - '0';\n                if (k > 0.0) sum = sum.add(prod.times(k));\n                prod = prod.times(TWOI);\n            }\n            if (pointPos != -1) {\n                prod = INVTWOI;\n                for (int j = posLen + 1; j < b2i.length(); ++j) {\n                    double k = b2i.charAt(j) - '0';\n                    if (k > 0.0) sum = sum.add(prod.times(k));\n                    prod = prod.times(INVTWOI);\n                }\n            }\n\n            return sum;\n        }\n\n        @Override\n        public String toString() {\n            return b2i;\n        }\n    }\n\n    public static void main(String[] args) {\n        String fmt = \"%4s -> %8s -> %4s\";\n        for (int i = 1; i <= 16; ++i) {\n            Complex c1 = new Complex(i, 0);\n            QuaterImaginary qi = c1.toQuaterImaginary();\n            Complex c2 = qi.toComplex();\n            System.out.printf(fmt + \"     \", c1, qi, c2);\n            c1 = c2.unaryMinus();\n            qi = c1.toQuaterImaginary();\n            c2 = qi.toComplex();\n            System.out.printf(fmt, c1, qi, c2);\n            System.out.println();\n        }\n        System.out.println();\n        for (int i = 1; i <= 16; ++i) {\n            Complex c1 = new Complex(0, i);\n            QuaterImaginary qi = c1.toQuaterImaginary();\n            Complex c2 = qi.toComplex();\n            System.out.printf(fmt + \"     \", c1, qi, c2);\n            c1 = c2.unaryMinus();\n            qi = c1.toQuaterImaginary();\n            c2 = qi.toComplex();\n            System.out.printf(fmt, c1, qi, c2);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 404706, "name": "Statistics_Normal distribution", "source": "Translate Haskell to Java: import Data.Map (Map, empty, insert, findWithDefault, toList)\nimport Data.Maybe (fromMaybe)\nimport Text.Printf (printf)\nimport Data.Function (on)\nimport Data.List (sort, maximumBy, minimumBy)\nimport Control.Monad.Random (RandomGen, Rand, evalRandIO, getRandomR)\nimport Control.Monad (replicateM)\n\n\ngetNorm :: RandomGen g => Rand g Double\ngetNorm = do\n    u0 <- getRandomR (0.0, 1.0) \n    u1 <- getRandomR (0.0, 1.0) \n    let r = sqrt $ (-2.0) * log u0\n        theta = 2.0 * pi * u1\n    return $ r * sin theta\n\nputInBin :: Double -> Map Int Int -> Double -> Map Int Int\nputInBin binWidth t v = \n    let bin = round (v / binWidth)\n        count = findWithDefault 0 bin t \n    in insert bin (count+1) t\n\nrunTest :: Int -> IO ()\nrunTest n = do\n    rs <- evalRandIO $ replicateM n getNorm \n    let binWidth = 0.1\n\n        tally v (sv, sv2, t) = (sv+v, sv2 + v*v, putInBin binWidth t v)\n\n        (sum, sum2, tallies) = foldr tally (0.0, 0.0, empty) rs\n\n        tallyList = sort $ toList tallies\n\n        printStars tallies binWidth maxCount selection = \n            let count = findWithDefault 0 selection tallies \n                bin = binWidth * fromIntegral selection\n                maxStars = 100\n                starCount = if maxCount <= maxStars\n                            then count \n                            else maxStars * count `div` maxCount\n                stars = replicate  starCount '*'\n            in printf \"%5.2f: %s  %d\\n\" bin stars count\n\n        mean = sum / fromIntegral n\n        stddev = sqrt (sum2/fromIntegral n - mean*mean)\n\n    printf \"\\n\"\n    printf \"sample count: %d\\n\" n\n    printf \"mean:         %9.7f\\n\" mean\n    printf \"stddev:       %9.7f\\n\" stddev\n\n    let maxCount = snd $ maximumBy (compare `on` snd) tallyList\n        maxBin = fst $ maximumBy (compare `on` fst) tallyList\n        minBin = fst $ minimumBy (compare `on` fst) tallyList\n\n    mapM_ (printStars tallies binWidth maxCount) [minBin..maxBin]\n\nmain = do\n    runTest 1000\n    runTest 2000000\n", "target": "import static java.lang.Math.*;\nimport static java.util.Arrays.stream;\nimport java.util.Locale;\nimport java.util.function.DoubleSupplier;\nimport static java.util.stream.Collectors.joining;\nimport java.util.stream.DoubleStream;\nimport static java.util.stream.IntStream.range;\n\npublic class Test implements DoubleSupplier {\n\n    private double mu, sigma;\n    private double[] state = new double[2];\n    private int index = state.length;\n\n    Test(double m, double s) {\n        mu = m;\n        sigma = s;\n    }\n\n    static double[] meanStdDev(double[] numbers) {\n        if (numbers.length == 0)\n            return new double[]{0.0, 0.0};\n\n        double sx = 0.0, sxx = 0.0;\n        long n = 0;\n        for (double x : numbers) {\n            sx += x;\n            sxx += pow(x, 2);\n            n++;\n        }\n\n        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};\n    }\n\n    static String replicate(int n, String s) {\n        return range(0, n + 1).mapToObj(i -> s).collect(joining());\n    }\n\n    static void showHistogram01(double[] numbers) {\n        final int maxWidth = 50;\n        long[] bins = new long[10];\n\n        for (double x : numbers)\n            bins[(int) (x * bins.length)]++;\n\n        double maxFreq = stream(bins).max().getAsLong();\n\n        for (int i = 0; i < bins.length; i++)\n            System.out.printf(\" %3.1f: %s%n\", i / (double) bins.length,\n                    replicate((int) (bins[i] / maxFreq * maxWidth), \"*\"));\n        System.out.println();\n    }\n\n    @Override\n    public double getAsDouble() {\n        index++;\n        if (index >= state.length) {\n            double r = sqrt(-2 * log(random())) * sigma;\n            double x = 2 * PI * random();\n            state = new double[]{mu + r * sin(x), mu + r * cos(x)};\n            index = 0;\n        }\n        return state[index];\n\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.US);\n        double[] data = DoubleStream.generate(new Test(0.0, 0.5)).limit(100_000)\n                .toArray();\n\n        double[] res = meanStdDev(data);\n        System.out.printf(\"Mean: %8.6f, SD: %8.6f%n\", res[0], res[1]);\n\n        showHistogram01(stream(data).map(a -> max(0.0, min(0.9999, a / 3 + 0.5)))\n                .toArray());\n    }\n}\n"}
{"id": 404707, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Haskell to Java: import Data.Bifunctor (bimap)\nimport Data.List (find)\nimport Data.Maybe (isJust)\n\n\n\nb10 :: Integral a => a -> Integer\nb10 n = read (digitMatch rems sums) :: Integer\n  where\n    (_, rems, _, Just (_, sums)) =\n      until\n        (\\(_, _, _, mb) -> isJust mb)\n        ( \\(e, rems, ms, _) ->\n            let m = rem (10 ^ e) n\n                newSums =\n                  (m, [m]) :\n                  fmap (bimap (m +) (m :)) ms\n             in ( succ e,\n                  m : rems,\n                  ms <> newSums,\n                  find\n                    ( (0 ==) . flip rem n . fst\n                    )\n                    newSums\n                )\n        )\n        (0, [], [], Nothing)\n\ndigitMatch :: Eq a => [a] -> [a] -> String\ndigitMatch [] _ = []\ndigitMatch xs [] = '0' <$ xs\ndigitMatch (x : xs) yys@(y : ys)\n  | x /= y = '0' : digitMatch xs yys\n  | otherwise = '1' : digitMatch xs ys\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( putStrLn\n        . ( \\x ->\n              let b = b10 x\n               in justifyRight 5 ' ' (show x)\n                    <> \" * \"\n                    <> justifyLeft 25 ' ' (show $ div b x)\n                    <> \" -> \"\n                    <> show b\n          )\n    )\n    ( [1 .. 10]\n        <> [95 .. 105]\n        <> [297, 576, 594, 891, 909, 999]\n    )\n\njustifyLeft, justifyRight :: Int -> a -> [a] -> [a]\njustifyLeft n c s = take n (s <> replicate n c)\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\n\npublic class MinimumNumberOnlyZeroAndOne {\n\n    public static void main(String[] args) {\n        for ( int n : getTestCases() ) {\n            BigInteger result = getA004290(n);\n            System.out.printf(\"A004290(%d) = %s = %s * %s%n\", n, result, n, result.divide(BigInteger.valueOf(n)));\n        }\n    }\n    \n    private static List<Integer> getTestCases() {\n        List<Integer> testCases = new ArrayList<>();\n        for ( int i = 1 ; i <= 10 ; i++ ) {\n            testCases.add(i);\n        }\n        for ( int i = 95 ; i <= 105 ; i++ ) {\n            testCases.add(i);\n        }\n        for (int i : new int[] {297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878} ) {\n            testCases.add(i);\n        }\n        return testCases;\n    }\n    \n    private static BigInteger getA004290(int n) {\n        if ( n == 1 ) {\n            return BigInteger.valueOf(1);\n        }\n        int[][] L = new int[n][n];\n        for ( int i = 2 ; i < n ; i++ ) {\n            L[0][i] = 0;\n        }\n        L[0][0] = 1;\n        L[0][1] = 1;\n        int m = 0;\n        BigInteger ten = BigInteger.valueOf(10);\n        BigInteger nBi = BigInteger.valueOf(n);\n        while ( true ) {\n            m++;\n            \n            if ( L[m-1][mod(ten.pow(m).negate(), nBi).intValue()] == 1 ) {\n                break;\n            }\n            L[m][0] = 1;\n            for ( int k = 1 ; k < n ; k++ ) {\n                \n                L[m][k] = Math.max(L[m-1][k], L[m-1][mod(BigInteger.valueOf(k).subtract(ten.pow(m)), nBi).intValue()]);\n            }\n            \n        }\n        \n        \n        BigInteger r = ten.pow(m);\n        BigInteger k = mod(r.negate(), nBi);\n        for ( int j = m-1 ; j >= 1 ; j-- ) {\n            if ( L[j-1][k.intValue()] == 0 ) {\n                \n                \n                r = r.add(ten.pow(j));\n                k = mod(k.subtract(ten.pow(j)), nBi);\n            }\n        }\n        if ( k.compareTo(BigInteger.ONE) == 0 ) {\n            r = r.add(BigInteger.ONE);\n        }\n        return r;\n    }\n\n    private static BigInteger mod(BigInteger m, BigInteger n) {\n        BigInteger result = m.mod(n);\n        if ( result.compareTo(BigInteger.ZERO) < 0 ) {\n            result = result.add(n);\n        }\n        return result;\n    }\n\n    @SuppressWarnings(\"unused\")\n    private static int mod(int m, int n) {\n        int result = m % n;\n        if ( result < 0 ) {\n            result += n;\n        }\n        return result;\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static int pow(int base, int exp) {\n        return (int) Math.pow(base, exp);\n    }\n}\n"}
{"id": 404708, "name": "Magic squares of singly even order", "source": "Translate Haskell to Java: import qualified Data.Map.Strict as M\nimport Data.List (transpose, intercalate)\nimport Data.Maybe (fromJust, isJust)\nimport Control.Monad (forM_)\nimport Data.Monoid ((<>))\n\nmagic :: Int -> [[Int]]\nmagic n = mapAsTable ((4 * n) + 2) (hiResMap n)\n\n\nhiResMap :: Int -> M.Map (Int, Int) Int\nhiResMap n =\n  let mapLux = luxMap n\n      mapSiam = siamMap n\n  in M.fromList $\n     foldMap\n       (\\(xy, n) ->\n           luxNums xy (fromJust (M.lookup xy mapLux)) ((4 * (n - 1)) + 1))\n       (M.toList mapSiam)\n\n\nluxNums :: (Int, Int) -> Char -> Int -> [((Int, Int), Int)]\nluxNums xy lux n =\n  zipWith (\\x d -> (x, n + d)) (hiRes xy) $\n  case lux of\n    'L' -> [3, 0, 1, 2]\n    'U' -> [0, 3, 1, 2]\n    'X' -> [0, 3, 2, 1]\n    _ -> [0, 0, 0, 0]\n\n\nmapAsTable :: Int -> M.Map (Int, Int) Int -> [[Int]]\nmapAsTable nCols xyMap =\n  let axis = [0 .. nCols - 1]\n  in fmap (fromJust . flip M.lookup xyMap) <$>\n     (axis >>= \\y -> [axis >>= \\x -> [(x, y)]])\n\n\nluxMap :: Int -> M.Map (Int, Int) Char\nluxMap n =\n  (M.fromList . concat) $\n  zipWith\n    (\\y xs -> (zipWith (\\x c -> ((x, y), c)) [0 ..] xs))\n    [0 ..]\n    (luxPattern n)\n\n\nluxPattern :: Int -> [String]\nluxPattern n =\n  let d = (2 * n) + 1\n      [ls, us] = replicate n <$> \"LU\"\n      [lRow, xRow] = replicate d <$> \"LX\"\n  in replicate n lRow <> [ls <> ('U' : ls)] <> [us <> ('L' : us)] <>\n     replicate (n - 1) xRow\n\n\nsiamMap :: Int -> M.Map (Int, Int) Int\nsiamMap n =\n  let uBound = (2 * n)\n      sPath uBound sMap (x, y) n =\n        let newMap = M.insert (x, y) n sMap\n        in if y == uBound && x == quot uBound 2\n             then newMap\n             else sPath uBound newMap (nextSiam uBound sMap (x, y)) (n + 1)\n  in sPath uBound (M.fromList []) (n, 0) 1\n\n\nnextSiam :: Int -> M.Map (Int, Int) Int -> (Int, Int) -> (Int, Int)\nnextSiam uBound sMap (x, y) =\n  let alt (a, b)\n        | a > uBound && b < 0 = (uBound, 1) \n        | a > uBound = (0, b) \n        | b < 0 = (a, uBound) \n        | isJust (M.lookup (a, b) sMap) = (a - 1, b + 2) \n        | otherwise = (a, b) \n  in alt (x + 1, y - 1)\n\n\nhiRes :: (Int, Int) -> [(Int, Int)]\nhiRes (x, y) =\n  let [col, row] = (* 2) <$> [x, y]\n      [col1, row1] = succ <$> [col, row]\n  in [(col, row), (col1, row), (col, row1), (col1, row1)]\n\n\nchecked :: [[Int]] -> (Int, Bool)\nchecked square = (h, all (h ==) t)\n  where\n    diagonals = fmap (flip (zipWith (!!)) [0 ..]) . ((:) <*> (return . reverse))\n    h:t = sum <$> square <> transpose square <> diagonals square\n\ntable :: String -> [[String]] -> [String]\ntable delim rows =\n  let justifyRight c n s = drop (length s) (replicate n c <> s)\n  in intercalate delim <$>\n     transpose\n       ((fmap =<< justifyRight ' ' . maximum . fmap length) <$> transpose rows)\n\nmain :: IO ()\nmain =\n  forM_ [1, 2, 3] $\n  \\n -> do\n    let test = magic n\n    putStrLn $ unlines (table \" \" (fmap show <$> test))\n    print $ checked test\n    putStrLn \"\"\n", "target": "public class MagicSquareSinglyEven {\n\n    public static void main(String[] args) {\n        int n = 6;\n        for (int[] row : magicSquareSinglyEven(n)) {\n            for (int x : row)\n                System.out.printf(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int n) {\n        if (n < 3 || n % 2 == 0)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int value = 0;\n        int gridSize = n * n;\n        int c = n / 2, r = 0;\n\n        int[][] result = new int[n][n];\n\n        while (++value <= gridSize) {\n            result[r][c] = value;\n            if (r == 0) {\n                if (c == n - 1) {\n                    r++;\n                } else {\n                    r = n - 1;\n                    c++;\n                }\n            } else if (c == n - 1) {\n                r--;\n                c = 0;\n            } else if (result[r - 1][c + 1] == 0) {\n                r--;\n                c++;\n            } else {\n                r++;\n            }\n        }\n        return result;\n    }\n\n    static int[][] magicSquareSinglyEven(final int n) {\n        if (n < 6 || (n - 2) % 4 != 0)\n            throw new IllegalArgumentException(\"base must be a positive \"\n                    + \"multiple of 4 plus 2\");\n\n        int size = n * n;\n        int halfN = n / 2;\n        int subSquareSize = size / 4;\n\n        int[][] subSquare = magicSquareOdd(halfN);\n        int[] quadrantFactors = {0, 2, 3, 1};\n        int[][] result = new int[n][n];\n\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                int quadrant = (r / halfN) * 2 + (c / halfN);\n                result[r][c] = subSquare[r % halfN][c % halfN];\n                result[r][c] += quadrantFactors[quadrant] * subSquareSize;\n            }\n        }\n\n        int nColsLeft = halfN / 2;\n        int nColsRight = nColsLeft - 1;\n\n        for (int r = 0; r < halfN; r++)\n            for (int c = 0; c < n; c++) {\n                if (c < nColsLeft || c >= n - nColsRight\n                        || (c == nColsLeft && r == nColsLeft)) {\n\n                    if (c == 0 && r == nColsLeft)\n                        continue;\n\n                    int tmp = result[r][c];\n                    result[r][c] = result[r + halfN][c];\n                    result[r + halfN][c] = tmp;\n                }\n            }\n\n        return result;\n    }\n}\n"}
{"id": 404709, "name": "Weird numbers", "source": "Translate Haskell to Java: weirds :: [Int]\nweirds = filter abundantNotSemiperfect [1 ..]\n\nabundantNotSemiperfect :: Int -> Bool\nabundantNotSemiperfect n =\n  let ds = descProperDivisors n\n      d = sum ds - n\n  in 0 < d && not (hasSum d ds)\n\nhasSum :: Int -> [Int] -> Bool\nhasSum _ [] = False\nhasSum n (x:xs)\n  | n < x = hasSum n xs\n  | otherwise = (n == x) || hasSum (n - x) xs || hasSum n xs\n\ndescProperDivisors\n  :: Integral a\n  => a -> [a]\ndescProperDivisors n =\n  let root = (floor . sqrt) (fromIntegral n :: Double)\n      lows = filter ((0 ==) . rem n) [root,root - 1 .. 1]\n      factors\n        | n == root ^ 2 = tail lows \n        | otherwise = lows\n  in tail $ reverse (quot n <$> lows) ++ factors\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n  zipWith (\\i x -> show i ++ (\" -> \" ++ show x)) [1 ..] (take 25 weirds)\n", "target": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class WeirdNumbers {\n\n    public static void main(String[] args) {\n        int n = 2;\n        \n        for ( int count = 1 ; count <= 25 ; n += 2 ) {\n            if ( isWeird(n) ) {\n                System.out.printf(\"w(%d) = %d%n\", count, n);\n                count++;\n            }\n        }\n    }\n    \n    private static boolean isWeird(int n) {\n        List<Integer> properDivisors = getProperDivisors(n);\n        return isAbundant(properDivisors, n) && ! isSemiPerfect(properDivisors, n);\n    }\n    \n    private static boolean isAbundant(List<Integer> divisors, int n) {\n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        return divisorSum > n;\n    }\n    \n    \n    private static boolean isSemiPerfect(List<Integer> divisors, int sum) {\n        int size = divisors.size();\n        \n        \n        boolean subset[][] = new boolean[sum+1][size+1];\n\n        \n        for (int i = 0; i <= size; i++) {\n            subset[0][i] = true; \n        }\n        \n        \n        for (int i = 1; i <= sum; i++) {\n            subset[i][0] = false; \n        }\n        \n        \n        for ( int i = 1 ; i <= sum ; i++ ) {\n            for ( int j = 1 ; j <= size ; j++ ) {\n                subset[i][j] = subset[i][j-1];\n                int test = divisors.get(j-1);\n                if ( i >= test ) {\n                    subset[i][j] = subset[i][j] || subset[i - test][j-1]; \n                }\n            } \n        } \n\n        return subset[sum][size];\n    }\n\n    private static final List<Integer> getProperDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i && div != number ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 404710, "name": "ASCII art diagram converter", "source": "Translate Haskell to Java: import Text.ParserCombinators.ReadP\nimport Control.Monad (guard)\n\ndata Field a = Field { fieldName :: String\n                     , fieldSize :: Int\n                     , fieldValue :: Maybe a}\n\ninstance Show a => Show (Field a) where\n  show (Field n s a) = case a of\n    Nothing -> n ++ \"\\t\" ++ show s\n    Just x -> n ++ \"\\t\" ++ show s ++ \"\\t\" ++ show x\n\nnewtype Data a = Data { fields :: [Field a] }\n\ninstance Show a => Show (Data a) where\n  show (Data fs) = \"NAME\\tSIZE\\tVALUE\\n\" ++ unlines (show <$> fs)\n\ninstance Read (Data a) where\n  readsPrec _ = readP_to_S parseData \n\nparseData = do n <- parseHeader               \n               guard (n `elem` [8,16,32,64]) \n               Data . concat <$> many1 (parseRow n)\n  where\n    parseRow n = do\n      fs <- char '|' *> many parseField <* char '\\n'\n      guard $ sum (fieldSize <$> fs) == n \n      m <- parseHeader\n      guard $ m == n \n      return fs\n \n    parseHeader = do\n      char '+'\n      n <- length <$> many1 (string \"\n      char '\\n'\n      return n\n  \n    parseField = do\n      s1 <- many (char ' ')\n      f <- munch1 $ not . (`elem` \" |\")\n      s2 <- many (char ' ')\n      char '|'\n      let n = (length (s1 ++ f ++ s2) + 1) `div` 3\n      return $ Field f n Nothing\n    \n\nreadData :: Data a -> [b] -> Data [b]\nreadData d = Data . go (fields d)\n  where\n    go fs [] = (\\f -> f {fieldValue = Nothing}) <$> fs\n    go (f:fs) s =\n      let (x, xs) = splitAt (fieldSize f) s\n      in f {fieldValue = Just x} : go fs xs\n  \n\ndiagram = unlines\n  [\"+\n  ,\"|                      ID                       |\"\n  ,\"+\n  ,\"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\"\n  ,\"+\n  ,\"|                    QDCOUNT                    |\"\n  ,\"+\n  ,\"|                    ANCOUNT                    |\"\n  ,\"+\n  ,\"|                    NSCOUNT                    |\"\n  ,\"+\n  ,\"|                    ARCOUNT                    |\"\n  ,\"+\n  \ndataSample = concat\n  [\"011110000100011101111011101111110101010010010110\",\n   \"111000010010111000011011111100010110100110100100\"]\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AsciiArtDiagramConverter {\n\n    private static final String TEST = \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                      ID                       |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    QDCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ANCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    NSCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\\r\\n\" +\n            \"|                    ARCOUNT                    |\\r\\n\" +\n            \"+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\";\n\n    public static void main(String[] args) {\n        validate(TEST);\n        display(TEST);\n        Map<String,List<Integer>> asciiMap = decode(TEST);\n        displayMap(asciiMap);\n        displayCode(asciiMap, \"78477bbf5496e12e1bf169a4\");\n    }\n\n    private static void displayCode(Map<String,List<Integer>> asciiMap, String hex) {\n        System.out.printf(\"%nTest string in hex:%n%s%n%n\", hex);\n\n        String bin = new BigInteger(hex,16).toString(2);\n\n        \n        int length = 0;\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            length += pos.get(1) - pos.get(0) + 1;\n        }\n        while ( length > bin.length() ) {\n            bin = \"0\" + bin;\n        }\n        System.out.printf(\"Test string in binary:%n%s%n%n\", bin);\n\n        System.out.printf(\"Name      Size  Bit Pattern%n\");\n        System.out.printf(\"-------- -----  -----------%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            int start = pos.get(0);\n            int end   = pos.get(1);\n            System.out.printf(\"%-8s    %2d  %s%n\", code, end-start+1, bin.substring(start, end+1));\n        }\n\n    }\n\n\n    private static void display(String ascii) {\n        System.out.printf(\"%nDiagram:%n%n\");\n        for ( String s : TEST.split(\"\\\\r\\\\n\") ) {\n            System.out.println(s);\n        }\n    }\n\n    private static void displayMap(Map<String,List<Integer>> asciiMap) {\n        System.out.printf(\"%nDecode:%n%n\");\n\n\n        System.out.printf(\"Name      Size  Start    End%n\");\n        System.out.printf(\"-------- -----  -----  -----%n\");\n        for ( String code : asciiMap.keySet() ) {\n            List<Integer> pos = asciiMap.get(code);\n            System.out.printf(\"%-8s    %2d     %2d     %2d%n\", code, pos.get(1)-pos.get(0)+1, pos.get(0), pos.get(1));\n        }\n\n    }\n\n    private static Map<String,List<Integer>> decode(String ascii) {\n        Map<String,List<Integer>> map = new LinkedHashMap<>();\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        int size = split[0].indexOf(\"+\", 1) - split[0].indexOf(\"+\");\n        int length = split[0].length() - 1;\n        for ( int i = 1 ; i < split.length ; i += 2 ) {\n            int barIndex = 1;\n            String test = split[i];\n            int next;\n            while ( barIndex < length && (next = test.indexOf(\"|\", barIndex)) > 0 ) {\n                \n                List<Integer> startEnd = new ArrayList<>();\n                startEnd.add((barIndex/size) + (i/2)*(length/size));\n                startEnd.add(((next-1)/size) + (i/2)*(length/size));\n                String code = test.substring(barIndex, next).replace(\" \", \"\");\n                map.put(code, startEnd);\n                \n                barIndex = next + 1;\n            }\n        }\n\n        return map;\n    }\n\n    private static void validate(String ascii) {\n        String[] split = TEST.split(\"\\\\r\\\\n\");\n        if ( split.length % 2 != 1 ) {\n            throw new RuntimeException(\"ERROR 1:  Invalid number of input lines.  Line count = \" + split.length);\n        }\n        int size = 0;\n        for ( int i = 0 ; i < split.length ; i++ ) {\n            String test = split[i];\n            if ( i % 2 == 0 ) {\n                \n                if ( ! test.matches(\"^\\\\+([-]+\\\\+)+$\") ) {\n                    throw new RuntimeException(\"ERROR 2:  Improper line format.  Line = \" + test);\n                }\n                if ( size == 0 ) {\n                    int firstPlus = test.indexOf(\"+\");\n                    int secondPlus = test.indexOf(\"+\", 1);\n                    size = secondPlus - firstPlus;\n                }\n                if ( ((test.length()-1) % size) != 0 ) {\n                    throw new RuntimeException(\"ERROR 3:  Improper line format.  Line = \" + test);\n                }\n                \n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    if ( test.charAt(j) != '+' ) {\n                        throw new RuntimeException(\"ERROR 4:  Improper line format.  Line = \" + test);\n                    }\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        if ( test.charAt(k) != '-' ) {\n                            throw new RuntimeException(\"ERROR 5:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n            }\n            else {\n                \n                if ( ! test.matches(\"^\\\\|(\\\\s*[A-Za-z]+\\\\s*\\\\|)+$\") ) {\n                    throw new RuntimeException(\"ERROR 6:  Improper line format.  Line = \" + test);\n                }\n                for ( int j = 0 ; j < test.length()-1 ; j += size ) {\n                    for ( int k = j+1 ; k < j + size ; k++ ) {\n                        \n                        if ( test.charAt(k) == '|' ) {\n                            throw new RuntimeException(\"ERROR 7:  Improper line format.  Line = \" + test);\n                        }\n                    }\n                }\n\n            }\n        }\n    }\n\n}\n"}
{"id": 404711, "name": "Sequence_ nth number with exactly n divisors", "source": "Translate Haskell to Java: import           Control.Monad                         (guard)\nimport           Math.NumberTheory.ArithmeticFunctions (divisorCount)\nimport           Math.NumberTheory.Primes              (Prime, unPrime)\nimport           Math.NumberTheory.Primes.Testing      (isPrime)\n\ncalc :: Integer -> [(Integer, Integer)]\ncalc n = do\n  x <- [1..]\n  guard (even n || odd n && f x == x)\n  [(x, divisorCount x)]\n where f n = floor (sqrt $ realToFrac n) ^ 2\n\nhavingNthDivisors :: Integer -> [(Integer, Integer)]\nhavingNthDivisors n = filter ((==n) . snd) $ calc n\n\nnths :: [(Integer, Integer)]\nnths = do\n  n <- [1..35] :: [Integer]\n  if isPrime n then\n    pure (n, nthPrime (fromIntegral n) ^ pred n)\n  else\n    pure (n, f n)\n where\n  f n = fst (havingNthDivisors n !! pred (fromIntegral n))\n  nthPrime n = unPrime (toEnum n :: Prime Integer)\n\nmain :: IO ()\nmain = mapM_ print nths\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class SequenceNthNumberWithExactlyNDivisors {\n\n    public static void main(String[] args) {\n        int max = 45;\n        smallPrimes(max);\n        for ( int n = 1; n <= max ; n++ ) {\n            System.out.printf(\"A073916(%d) = %s%n\", n, OEISA073916(n));\n        }\n    }\n    \n    private static List<Integer> smallPrimes = new ArrayList<>();\n    \n    private static void smallPrimes(int numPrimes) {\n        smallPrimes.add(2);\n        for ( int n = 3, count = 0 ; count < numPrimes ; n += 2 ) {\n            if ( isPrime(n) ) {\n                smallPrimes.add(n);\n                count++;\n            }\n        }\n    }\n    \n    private static final boolean isPrime(long test) {\n        if ( test == 2 ) {\n            return true;\n        }\n        if ( test % 2 == 0 ) {\n            return false;\n        }\n        for ( long d = 3 ; d*d <= test ; d += 2 ) {\n            if ( test % d == 0 ) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int getDivisorCount(long n) {\n        int count = 1;\n        while ( n % 2 == 0 ) {\n            n /= 2;\n            count += 1;\n        }\n        for ( long d = 3 ; d*d <= n ; d += 2 ) {\n            long q = n / d;\n            long r = n % d;\n            int dc = 0;\n            while ( r == 0 ) {\n                dc += count;\n                n = q;\n                q = n / d;\n                r = n % d;\n            }\n            count += dc;\n        }\n        if ( n != 1 ) {\n            count *= 2;\n        }\n        return count;\n    }\n    \n    private static BigInteger OEISA073916(int n) {\n        if ( isPrime(n) ) {\n            return BigInteger.valueOf(smallPrimes.get(n-1)).pow(n - 1);\n        }\n        int count = 0;\n        int result = 0;\n        for ( int i = 1 ; count < n ; i++ ) {\n            if ( n % 2 == 1 ) {\n                \n                int sqrt = (int) Math.sqrt(i);\n                if ( sqrt*sqrt != i ) {\n                    continue;\n                }\n            }\n            if ( getDivisorCount(i) == n ) {\n                count++;\n                result = i;\n            }\n        }\n        return BigInteger.valueOf(result);\n    }\n\n}\n"}
{"id": 404712, "name": "Finite state machine", "source": "Translate Haskell to Java: import System.Exit\nimport Data.Maybe\nimport Control.Monad\nimport Data.List\nimport System.IO\n\ntype Name = String\ntype Sequence = String\ntype State = String\n\ndata Trigger = Trigger { name :: Name\n                       , tseq :: Sequence } deriving (Eq)\n\ninstance Show Trigger where\n  show (Trigger name tseq) = name ++ \"(\" ++ tseq ++ \")\"\n\ndata Transition = Implicit { start :: State\n                            , end :: State }\n                | Explicit { start :: State\n                           , trigger :: Trigger\n                           , end :: State }\n\nfindEndState :: Sequence -> [(Trigger, State)] -> Maybe State\nfindEndState sequence lst = if (isJust pair)\n                               then snd <$> pair\n                               else Nothing\n  where \n    pair = find (\\t -> (tseq . fst) t == sequence) lst\n\nfindRelevantTransitions :: State -> [Transition] -> [Transition]\nfindRelevantTransitions state transitions = filter (\\t -> state == start t) transitions\n\nfindImplicitTransition :: [Transition] -> Maybe Transition\nfindImplicitTransition [] = Nothing\nfindImplicitTransition (transition@(Implicit _ _):xs) = Just transition\nfindImplicitTransition (x:xs) = findImplicitTransition xs\n\nrunFSM :: State -> [Transition] -> [State] -> IO ()\nrunFSM state transitions finishStates = do\n  putStrLn $ \"State: \" ++ state\n  when (state `elem` finishStates) $ do\n    putStrLn \"Exiting..\"\n    exitWith ExitSuccess\n  let relTransitions = findRelevantTransitions state transitions\n  let implTransition = findImplicitTransition relTransitions\n  when (isJust implTransition) $ do\n    putStrLn \"Implicit transition\"\n    runFSM (end $ fromJust implTransition) transitions finishStates\n  let triggers = map (\\t -> (trigger t, end t)) relTransitions\n  handleExplicitTransition triggers\n    where handleExplicitTransition triggers = do\n          let prompt = (intercalate \" or \" (map (show . fst) triggers)) ++ \":\"\n          putStr prompt\n          resp <- getLine\n          let endState = findEndState resp triggers\n          case endState of\n            (Just e) -> runFSM e transitions finishStates\n            Nothing -> putStrLn \"invalid input\" >> handleExplicitTransition triggers\n\nmain = do\n  hSetBuffering stdout $ BlockBuffering $ Just 1\n  runFSM initialState transitions finishStates\n\ninitialState = \"Ready\"\ntransitions = [ Explicit \"Ready\" (Trigger \"Deposit\" \"d\") \"Waiting\"\n              , Explicit \"Ready\" (Trigger \"Quit\" \"q\") \"Exit\"\n              , Explicit \"Waiting\" (Trigger \"Select\" \"s\") \"Dispense\"\n              , Explicit \"Waiting\" (Trigger \"Refund\" \"r\") \"Refunding\"\n              , Explicit \"Dispense\" (Trigger \"Remove\" \"rm\") \"Ready\"\n              , Implicit \"Refunding\" \"Ready\" ]\nfinishStates = [\"Exit\"]\n", "target": "import java.util.*;\n\npublic class FiniteStateMachine {\n\n    private enum State {\n        Ready(true, \"Deposit\", \"Quit\"),\n        Waiting(true, \"Select\", \"Refund\"),\n        Dispensing(true, \"Remove\"),\n        Refunding(false, \"Refunding\"),\n        Exiting(false, \"Quiting\");\n\n        State(boolean exp, String... in) {\n            inputs = Arrays.asList(in);\n            explicit = exp;\n        }\n\n        State nextState(String input, State current) {\n            if (inputs.contains(input)) {\n                return map.getOrDefault(input, current);\n            }\n            return current;\n        }\n\n        final List<String> inputs;\n        final static Map<String, State> map = new HashMap<>();\n        final boolean explicit;\n\n        static {\n            map.put(\"Deposit\", State.Waiting);\n            map.put(\"Quit\", State.Exiting);\n            map.put(\"Select\", State.Dispensing);\n            map.put(\"Refund\", State.Refunding);\n            map.put(\"Remove\", State.Ready);\n            map.put(\"Refunding\", State.Ready);\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        State state = State.Ready;\n\n        while (state != State.Exiting) {\n            System.out.println(state.inputs);\n            if (state.explicit){\n                System.out.print(\"> \");\n                state = state.nextState(sc.nextLine().trim(), state);\n            } else {\n                state = state.nextState(state.inputs.get(0), state);\n            }\n        }\n    }\n}\n"}
{"id": 404713, "name": "Sokoban", "source": "Translate Haskell to Java: import Control.Monad (liftM)\nimport Data.Array\nimport Data.List (transpose)\nimport Data.Maybe (mapMaybe)\nimport qualified Data.Sequence as Seq\nimport qualified Data.Set as Set\nimport Prelude hiding (Left, Right)\n\ndata Field = Space | Wall | Goal\n           deriving (Eq)\n\ndata Action = Up | Down | Left | Right | PushUp | PushDown | PushLeft | PushRight\n\ninstance Show Action where\n  show Up        = \"u\"\n  show Down      = \"d\"\n  show Left      = \"l\"\n  show Right     = \"r\"\n  show PushUp    = \"U\"\n  show PushDown  = \"D\"\n  show PushLeft  = \"L\"\n  show PushRight = \"R\"\n\ntype Index = (Int, Int)\ntype FieldArray = Array Index Field\ntype BoxArray = Array Index Bool\ntype PlayerPos = Index\ntype GameState = (BoxArray, PlayerPos)\ntype Game = (FieldArray, GameState)\n\ntoField :: Char -> Field\ntoField '#' = Wall\ntoField ' ' = Space\ntoField '@' = Space\ntoField '$' = Space\ntoField '.' = Goal\ntoField '+' = Goal\ntoField '*' = Goal\n\ntoPush :: Action -> Action\ntoPush Up    = PushUp\ntoPush Down  = PushDown\ntoPush Left  = PushLeft\ntoPush Right = PushRight\ntoPush n     = n\n\ntoMove :: Action -> Index\ntoMove PushUp    = ( 0, -1)\ntoMove PushDown  = ( 0,  1)\ntoMove PushLeft  = (-1,  0)\ntoMove PushRight = ( 1,  0)\ntoMove n = toMove $ toPush n\n\n\n\nparseGame :: [String] -> Game\nparseGame fieldStrs = (field, (boxes, player))\n  where\n    width     = length $ head fieldStrs\n    height    = length fieldStrs\n    bound     = ((0, 0), (width - 1, height - 1))\n    flatField = concat $ transpose fieldStrs\n    charField = listArray bound flatField\n    field     = fmap toField charField\n    boxes     = fmap (`elem` \"$*\") charField\n    player    = fst $ head $ filter (flip elem \"@+\" . snd) $ assocs charField\n\nadd :: (Num a, Num b) => (a, b) -> (a, b) -> (a, b)\nadd (a, b) (x, y) = (a + x, b + y)\n\n\n\ntryAction :: Game -> Action -> Maybe (Game, Action)\ntryAction (field, (boxes, player)) action\n  | field ! vec == Wall = Nothing\n  | boxes ! vec =\n     if boxes ! vecB || field ! vecB == Wall\n     then Nothing\n     else Just ((field, (boxes // [(vec, False), (vecB, True)], vec)),\n               toPush action)\n  | otherwise = Just ((field, (boxes, vec)), action)\n  where\n    actionVec = toMove action\n    vec       = player `add` actionVec\n    vecB      = vec `add` actionVec\n\n\nsolveGame :: Game -> Maybe [Action]\nsolveGame (field, initState) =\n  liftM reverse $ bfs (Seq.singleton (initState, [])) (Set.singleton initState)\n  where\n    goals           = map fst $ filter ((== Goal) . snd) $ assocs field\n    isSolved st     = all (st !) goals\n    possibleActions = [Up, Down, Left, Right]\n    \n    \n    bfs :: Seq.Seq (GameState, [Action]) -> Set.Set GameState -> Maybe [Action]\n    bfs queue visited =\n      case Seq.viewl queue of\n        Seq.EmptyL -> Nothing\n        (game@(boxes, _), actions) Seq.:< queueB ->\n          if isSolved boxes\n          then Just actions\n          else\n            let newMoves = filter (flip Set.notMember visited . fst) $\n                           map (\\((_, g), a) -> (g, a)) $\n                           mapMaybe (tryAction (field, game)) possibleActions\n                visitedB = foldl (flip Set.insert) visited $\n                           map fst newMoves\n                queueC   = foldl (Seq.|>) queueB $\n                           map (\\(g, a) -> (g, a:actions)) newMoves\n            in bfs queueC visitedB\n\nexampleA :: [String]\nexampleA =\n  [\"#######\"\n  ,\"#     #\"\n  ,\"#     #\"\n  ,\"#. #  #\"\n  ,\"#. $$ #\"\n  ,\"#.$$  #\"\n  ,\"#.#  @#\"\n  ,\"#######\"]\n\nmain :: IO ()\nmain =\n  case solveGame $ parseGame exampleA of\n    Nothing       -> putStrLn \"Unsolvable\"\n    Just solution -> do\n      mapM_ putStrLn exampleA\n      putStrLn \"\"\n      putStrLn $ concatMap show solution\n", "target": "import java.util.*;\n\npublic class Sokoban {\n    String destBoard, currBoard;\n    int playerX, playerY, nCols;\n\n    Sokoban(String[] board) {\n        nCols = board[0].length();\n        StringBuilder destBuf = new StringBuilder();\n        StringBuilder currBuf = new StringBuilder();\n\n        for (int r = 0; r < board.length; r++) {\n            for (int c = 0; c < nCols; c++) {\n\n                char ch = board[r].charAt(c);\n\n                destBuf.append(ch != '$' && ch != '@' ? ch : ' ');\n                currBuf.append(ch != '.' ? ch : ' ');\n\n                if (ch == '@') {\n                    this.playerX = c;\n                    this.playerY = r;\n                }\n            }\n        }\n        destBoard = destBuf.toString();\n        currBoard = currBuf.toString();\n    }\n\n    String move(int x, int y, int dx, int dy, String trialBoard) {\n\n        int newPlayerPos = (y + dy) * nCols + x + dx;\n\n        if (trialBoard.charAt(newPlayerPos) != ' ')\n            return null;\n\n        char[] trial = trialBoard.toCharArray();\n        trial[y * nCols + x] = ' ';\n        trial[newPlayerPos] = '@';\n\n        return new String(trial);\n    }\n\n    String push(int x, int y, int dx, int dy, String trialBoard) {\n\n        int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;\n\n        if (trialBoard.charAt(newBoxPos) != ' ')\n            return null;\n\n        char[] trial = trialBoard.toCharArray();\n        trial[y * nCols + x] = ' ';\n        trial[(y + dy) * nCols + x + dx] = '@';\n        trial[newBoxPos] = '$';\n\n        return new String(trial);\n    }\n\n    boolean isSolved(String trialBoard) {\n        for (int i = 0; i < trialBoard.length(); i++)\n            if ((destBoard.charAt(i) == '.')\n                    != (trialBoard.charAt(i) == '$'))\n                return false;\n        return true;\n    }\n\n    String solve() {\n        class Board {\n            String cur, sol;\n            int x, y;\n\n            Board(String s1, String s2, int px, int py) {\n                cur = s1;\n                sol = s2;\n                x = px;\n                y = py;\n            }\n        }\n        char[][] dirLabels = {{'u', 'U'}, {'r', 'R'}, {'d', 'D'}, {'l', 'L'}};\n        int[][] dirs = {{0, -1}, {1, 0}, {0, 1}, {-1, 0}};\n\n        Set<String> history = new HashSet<>();\n        LinkedList<Board> open = new LinkedList<>();\n\n        history.add(currBoard);\n        open.add(new Board(currBoard, \"\", playerX, playerY));\n\n        while (!open.isEmpty()) {\n            Board item = open.poll();\n            String cur = item.cur;\n            String sol = item.sol;\n            int x = item.x;\n            int y = item.y;\n\n            for (int i = 0; i < dirs.length; i++) {\n                String trial = cur;\n                int dx = dirs[i][0];\n                int dy = dirs[i][1];\n\n                \n                if (trial.charAt((y + dy) * nCols + x + dx) == '$') {\n\n                    \n                    if ((trial = push(x, y, dx, dy, trial)) != null) {\n\n                        \n                        if (!history.contains(trial)) {\n\n                            String newSol = sol + dirLabels[i][1];\n\n                            if (isSolved(trial))\n                                return newSol;\n\n                            open.add(new Board(trial, newSol, x + dx, y + dy));\n                            history.add(trial);\n                        }\n                    }\n\n                \n                } else if ((trial = move(x, y, dx, dy, trial)) != null) {\n\n                    if (!history.contains(trial)) {\n                        String newSol = sol + dirLabels[i][0];\n                        open.add(new Board(trial, newSol, x + dx, y + dy));\n                        history.add(trial);\n                    }\n                }\n            }\n        }\n        return \"No solution\";\n    }\n\n    public static void main(String[] a) {\n        String level = \"#######,#     #,#     #,#. #  #,#. $$ #,\"\n                + \"#.$$  #,#.#  @#,#######\";\n        System.out.println(new Sokoban(level.split(\",\")).solve());\n    }\n}\n"}
{"id": 404714, "name": "Zumkeller numbers", "source": "Translate Haskell to Java: import Data.List (group, sort)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primeFactors)\n\n\n\nisZumkeller :: Int -> Bool\nisZumkeller n =\n  let ds = divisors n\n      m = sum ds\n   in ( even m\n          && let half = div m 2\n              in elem half ds\n                   || ( all (half >=) ds\n                          && summable half ds\n                      )\n      )\n\nsummable :: Int -> [Int] -> Bool\nsummable _ [] = False\nsummable x xs@(h : t) =\n  elem x xs\n    || summable (x - h) t\n    || summable x t\n\ndivisors :: Int -> [Int]\ndivisors x =\n  sort\n    ( foldr\n        ( flip ((<*>) . fmap (*))\n            . scanl (*) 1\n        )\n        [1]\n        (group (primeFactors x))\n    )\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( \\(s, n, xs) ->\n        putStrLn $\n          s\n            <> ( '\\n' :\n                 tabulated\n                   10\n                   (take n (filter isZumkeller xs))\n               )\n    )\n    [ (\"First 220 Zumkeller numbers:\", 220, [1 ..]),\n      (\"First 40 odd Zumkeller numbers:\", 40, [1, 3 ..])\n    ]\n\n\ntabulated ::\n  Show a =>\n  Int ->\n  [a] ->\n  String\ntabulated nCols = go\n  where\n    go xs =\n      let ts = show <$> xs\n          w = succ (maximum (length <$> ts))\n       in unlines\n            ( concat\n                <$> chunksOf\n                  nCols\n                  (justifyRight w ' ' <$> ts)\n            )\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ZumkellerNumbers {\n\n    public static void main(String[] args) {\n        int n = 1;\n        System.out.printf(\"First 220 Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 220 ; n += 1 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%3d  \", n);\n                if ( count % 20 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( isZumkeller(n) ) {\n                System.out.printf(\"%6d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n        \n        n = 1;\n        System.out.printf(\"%nFirst 40 odd Zumkeller numbers that do not end in a 5:%n\");\n        for ( int count = 1 ; count <= 40 ; n += 2 ) {\n            if ( n % 5 != 0 && isZumkeller(n) ) {\n                System.out.printf(\"%8d\", n);\n                if ( count % 10 == 0 ) {\n                    System.out.printf(\"%n\");\n                }\n                count++;\n            }\n        }\n\n    }\n    \n    private static boolean isZumkeller(int n) {\n        \n        if ( n % 18 == 6 || n % 18 == 12 ) {\n            return true;\n        }\n        \n        List<Integer> divisors = getDivisors(n);        \n        int divisorSum = divisors.stream().mapToInt(i -> i.intValue()).sum();\n        \n        \n        if ( divisorSum % 2 == 1 ) {\n            return false;\n        }\n        \n        \n        int abundance = divisorSum - 2 * n;\n        if ( n % 2 == 1 && abundance > 0 && abundance % 2 == 0 ) {\n            return true;\n        }\n        \n        Collections.sort(divisors);\n        int j = divisors.size() - 1;\n        int sum = divisorSum/2;\n        \n        \n        if ( divisors.get(j) > sum ) {\n            return false;\n        }\n        \n        return canPartition(j, divisors, sum, new int[2]);\n    }\n    \n    private static boolean canPartition(int j, List<Integer> divisors, int sum, int[] buckets) {\n        if ( j < 0 ) {\n            return true;\n        }\n        for ( int i = 0 ; i < 2 ; i++ ) {\n            if ( buckets[i] + divisors.get(j) <= sum ) {\n                buckets[i] += divisors.get(j);\n                if ( canPartition(j-1, divisors, sum, buckets) ) {\n                    return true;\n                }\n                buckets[i] -= divisors.get(j);\n            }\n            if( buckets[i] == 0 ) {\n                break;\n            }\n        }\n        return false;\n    }\n    \n    private static final List<Integer> getDivisors(int number) {\n        List<Integer> divisors = new ArrayList<Integer>();\n        long sqrt = (long) Math.sqrt(number);\n        for ( int i = 1 ; i <= sqrt ; i++ ) {\n            if ( number % i == 0 ) {\n                divisors.add(i);\n                int div = number / i;\n                if ( div != i ) {\n                    divisors.add(div);\n                }\n            }\n        }\n        return divisors;\n    }\n\n}\n"}
{"id": 404715, "name": "Commatizing numbers", "source": "Translate Haskell to Java: #!/usr/bin/env runhaskell\n\nimport Control.Monad (forM_)\nimport Data.Char (isDigit)\nimport Data.List (intercalate)\nimport Data.Maybe (fromMaybe)\n\n\n\nisDigitOrPeriod :: Char -> Bool\nisDigitOrPeriod '.' = True\nisDigitOrPeriod c = isDigit c\n\nchopUp :: Int -> String -> [String]\nchopUp _ [] = []\nchopUp by str\n  | by < 1 = [str]              \n  | otherwise = let (pfx, sfx) = splitAt by str\n                in pfx : chopUp by sfx\n\naddSeps :: String -> Char -> Int -> (String -> String) -> String\naddSeps str sep by rev =\n  let (leading, number) = span (== '0') str\n      number2 = rev $ intercalate [sep] $ chopUp by $ rev number\n  in leading ++ number2\n\nprocessNumber :: String -> Char -> Int -> String\nprocessNumber str sep by =\n  let (beforeDecimal, rest) = span isDigit str\n      (decimal, afterDecimal) = splitAt 1 rest\n      beforeDecimal2 = addSeps beforeDecimal sep by reverse\n      afterDecimal2 = addSeps afterDecimal sep by id\n  in beforeDecimal2 ++ decimal ++ afterDecimal2\n\ncommatize2 :: String -> Char -> Int -> String\ncommatize2 [] _ _ = []\ncommatize2 str sep by =\n  let (pfx, sfx) = break isDigitOrPeriod str\n      (number, sfx2) = span isDigitOrPeriod sfx\n  in pfx ++ processNumber number sep by ++ sfx2\n\ncommatize :: String -> Maybe Char -> Maybe Int -> String\ncommatize str sep by = commatize2 str (fromMaybe ',' sep) (fromMaybe 3 by)\n\ninput :: [(String, Maybe Char, Maybe Int)]\ninput =\n  [ (\"pi=3.14159265358979323846264338327950288419716939937510582097494459231\", Just ' ', Just 5)\n  , (\"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\", Just '.', Nothing)\n  , (\"\\\"-in Aus$+1411.8millions\\\"\", Nothing, Nothing)\n  , (\"===US$0017440 millions=== (in 2000 dollars)\", Nothing, Nothing)\n  , (\"123.e8000 is pretty big.\", Nothing, Nothing)\n  , (\"The land area of the earth is 57268900(29% of the surface) square miles.\", Nothing, Nothing)\n  , (\"Ain't no numbers in this here words, nohow, no way, Jose.\", Nothing, Nothing)\n  , (\"James was never known as 0000000007\", Nothing, Nothing)\n  , (\"Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.\", Nothing, Nothing)\n  , (\"   $-140000\u00b1100 millions.\", Nothing, Nothing)\n  , (\"6/9/1946 was a good year for some.\", Nothing, Nothing)\n  ]\n\nmain :: IO ()\nmain =\n  forM_ input $ \\(str, by, sep) -> do\n    putStrLn str\n    putStrLn $ commatize str by sep\n    putStrLn \"\"\n", "target": "import java.io.File;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class CommatizingNumbers {\n\n    public static void main(String[] args) throws Exception {\n        commatize(\"pi=3.14159265358979323846264338327950288419716939937510582\"\n                + \"097494459231\", 6, 5, \" \");\n\n        commatize(\"The author has two Z$100000000000000 Zimbabwe notes (100 \"\n                + \"trillion).\", 0, 3, \".\");\n\n        try (Scanner sc = new Scanner(new File(\"input.txt\"))) {\n            while(sc.hasNext())\n                commatize(sc.nextLine());\n        }\n    }\n\n    static void commatize(String s) {\n        commatize(s, 0, 3, \",\");\n    }\n\n    static void commatize(String s, int start, int step, String ins) {\n        if (start < 0 || start > s.length() || step < 1 || step > s.length())\n            return;\n\n        Matcher m = Pattern.compile(\"([1-9][0-9]*)\").matcher(s.substring(start));\n        StringBuffer result = new StringBuffer(s.substring(0, start));\n\n        if (m.find()) {\n            StringBuilder sb = new StringBuilder(m.group(1)).reverse();\n            for (int i = step; i < sb.length(); i += step)\n                sb.insert(i++, ins);\n            m.appendReplacement(result, sb.reverse().toString());\n        }\n\n        System.out.println(m.appendTail(result));\n    }\n}\n"}
{"id": 404716, "name": "Base58Check encoding", "source": "Translate Haskell to Java: import Numeric (showIntAtBase)\n\nchars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58Encode :: Integer -> String\nbase58Encode n = showIntAtBase 58 (chars !!) n \"\"\n\nmain :: IO ()\nmain = mapM_ (putStrLn . base58Encode)\n        [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Base58CheckEncoding {\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    private static final BigInteger BIG0 = BigInteger.ZERO;\n    private static final BigInteger BIG58 = BigInteger.valueOf(58);\n\n    private static String convertToBase58(String hash) {\n        return convertToBase58(hash, 16);\n    }\n\n    private static String convertToBase58(String hash, int base) {\n        BigInteger x;\n        if (base == 16 && hash.substring(0, 2).equals(\"0x\")) {\n            x = new BigInteger(hash.substring(2), 16);\n        } else {\n            x = new BigInteger(hash, base);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (x.compareTo(BIG0) > 0) {\n            int r = x.mod(BIG58).intValue();\n            sb.append(ALPHABET.charAt(r));\n            x = x.divide(BIG58);\n        }\n\n        return sb.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"25420294593250030202636073700053352635053786165627414518\";\n        String b = convertToBase58(s, 10);\n        System.out.printf(\"%s -> %s\\n\", s, b);\n\n        List<String> hashes = List.of(\n            \"0x61\",\n            \"0x626262\",\n            \"0x636363\",\n            \"0x73696d706c792061206c6f6e6720737472696e67\",\n            \"0x516b6fcd0f\",\n            \"0xbf4f89001e670274dd\",\n            \"0x572e4794\",\n            \"0xecac89cad93923c02321\",\n            \"0x10c8511e\"\n        );\n        for (String hash : hashes) {\n            String b58 = convertToBase58(hash);\n            System.out.printf(\"%-56s -> %s\\n\", hash, b58);\n        }\n    }\n}\n"}
{"id": 404717, "name": "Base58Check encoding", "source": "Translate Haskell to Java: import Numeric (showIntAtBase)\n\nchars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58Encode :: Integer -> String\nbase58Encode n = showIntAtBase 58 (chars !!) n \"\"\n\nmain :: IO ()\nmain = mapM_ (putStrLn . base58Encode)\n        [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Base58CheckEncoding {\n    private static final String ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n    private static final BigInteger BIG0 = BigInteger.ZERO;\n    private static final BigInteger BIG58 = BigInteger.valueOf(58);\n\n    private static String convertToBase58(String hash) {\n        return convertToBase58(hash, 16);\n    }\n\n    private static String convertToBase58(String hash, int base) {\n        BigInteger x;\n        if (base == 16 && hash.substring(0, 2).equals(\"0x\")) {\n            x = new BigInteger(hash.substring(2), 16);\n        } else {\n            x = new BigInteger(hash, base);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (x.compareTo(BIG0) > 0) {\n            int r = x.mod(BIG58).intValue();\n            sb.append(ALPHABET.charAt(r));\n            x = x.divide(BIG58);\n        }\n\n        return sb.reverse().toString();\n    }\n\n    public static void main(String[] args) {\n        String s = \"25420294593250030202636073700053352635053786165627414518\";\n        String b = convertToBase58(s, 10);\n        System.out.printf(\"%s -> %s\\n\", s, b);\n\n        List<String> hashes = List.of(\n            \"0x61\",\n            \"0x626262\",\n            \"0x636363\",\n            \"0x73696d706c792061206c6f6e6720737472696e67\",\n            \"0x516b6fcd0f\",\n            \"0xbf4f89001e670274dd\",\n            \"0x572e4794\",\n            \"0xecac89cad93923c02321\",\n            \"0x10c8511e\"\n        );\n        for (String hash : hashes) {\n            String b58 = convertToBase58(hash);\n            System.out.printf(\"%-56s -> %s\\n\", hash, b58);\n        }\n    }\n}\n"}
{"id": 404718, "name": "Latin Squares in reduced form", "source": "Translate Haskell to Java: import Data.List (permutations, (\\\\))\nimport Control.Monad (foldM, forM_)\n\nlatinSquares :: Eq a => [a] -> [[[a]]]\nlatinSquares [] = []\nlatinSquares set = map reverse <$> squares\n  where\n    squares = foldM addRow firstRow perm\n    perm = tail (groupedPermutations set)\n    firstRow = pure <$> set\n    addRow tbl rows = [ zipWith (:) row tbl\n                      | row <- rows                      \n                      , and $ different (tail row) (tail tbl) ]\n    different = zipWith $ (not .) . elem\n       \ngroupedPermutations :: Eq a => [a] -> [[[a]]]\ngroupedPermutations lst = map (\\x -> (x :) <$> permutations (lst \\\\ [x])) lst\n\nprintTable :: Show a => [[a]] -> IO () \nprintTable tbl = putStrLn $ unlines $ unwords . map show <$> tbl\n", "target": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class LatinSquaresInReducedForm {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Reduced latin squares of order 4:%n\");\n        for ( LatinSquare square : getReducedLatinSquares(4) ) {\n            System.out.printf(\"%s%n\", square);\n        }\n        \n        System.out.printf(\"Compute the number of latin squares from count of reduced latin squares:%n(Reduced Latin Square Count) * n! * (n-1)! = Latin Square Count%n\");\n        for ( int n = 1 ; n <= 6 ; n++ ) {\n            List<LatinSquare> list = getReducedLatinSquares(n);\n            System.out.printf(\"Size = %d, %d * %d * %d =\u00a0%,d%n\", n, list.size(), fact(n), fact(n-1), list.size()*fact(n)*fact(n-1));\n        }\n    }\n    \n    private static long fact(int n) {\n        if ( n == 0 ) {\n            return 1;\n        }\n        int prod = 1;\n        for ( int i = 1 ; i <= n ; i++ ) {\n            prod *= i;\n        }\n        return prod;\n    }\n    \n    private static List<LatinSquare> getReducedLatinSquares(int n) {\n        List<LatinSquare> squares = new ArrayList<>();\n        \n        squares.add(new LatinSquare(n));\n        PermutationGenerator permGen = new PermutationGenerator(n);\n        for ( int fillRow = 1 ; fillRow < n ; fillRow++ ) {\n            List<LatinSquare> squaresNext = new ArrayList<>();\n            for ( LatinSquare square : squares ) {\n                while ( permGen.hasMore() ) {\n                    int[] perm = permGen.getNext();\n                    \n                    \n                    if ( (perm[0]+1) != (fillRow+1) ) {\n                        continue;\n                    }\n                    \n                    \n                    boolean permOk = true;\n                    done:\n                    for ( int row = 0 ; row < fillRow ; row++ ) {\n                        for ( int col = 0 ; col < n ; col++ ) {\n                            if ( square.get(row, col) == (perm[col]+1) ) {\n                                permOk = false;\n                                break done;\n                            }\n                        }\n                    }\n                    if ( permOk ) {\n                        LatinSquare newSquare = new LatinSquare(square);\n                        for ( int col = 0 ; col < n ; col++ ) {\n                            newSquare.set(fillRow, col, perm[col]+1);\n                        }\n                        squaresNext.add(newSquare);\n                    }\n                }\n                permGen.reset();\n            }\n            squares = squaresNext;\n        }\n        \n        return squares;\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static int[] display(int[] in) {\n        int [] out = new int[in.length];\n        for ( int i = 0 ; i < in.length ; i++ ) {\n            out[i] = in[i] + 1;\n        }\n        return out;\n    }\n    \n    private static class LatinSquare {\n        \n        int[][] square;\n        int size;\n        \n        public LatinSquare(int n) {\n            square = new int[n][n];\n            size = n;\n            for ( int col = 0 ; col < n ; col++ ) {\n                set(0, col, col + 1);\n            }\n        }\n        \n        public LatinSquare(LatinSquare ls) {\n            int n = ls.size;\n            square = new int[n][n];\n            size = n;\n            for ( int row = 0 ; row < n ; row++ ) {\n                for ( int col = 0 ; col < n ; col++ ) {\n                    set(row, col, ls.get(row, col));\n                }\n            }\n        }\n        \n        public void set(int row, int col, int value) {\n            square[row][col] = value;\n        }\n\n        public int get(int row, int col) {\n            return square[row][col];\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            for ( int row = 0 ; row < size ; row++ ) {\n                sb.append(Arrays.toString(square[row]));\n                sb.append(\"\\n\");\n            }\n            return sb.toString();\n        }\n        \n        \n    }\n\n    private static class PermutationGenerator {\n\n        private int[] a;\n        private BigInteger numLeft;\n        private BigInteger total;\n\n        public PermutationGenerator (int n) {\n            if (n < 1) {\n                throw new IllegalArgumentException (\"Min 1\");\n            }\n            a = new int[n];\n            total = getFactorial(n);\n            reset();\n        }\n\n        private void reset () {\n            for ( int i = 0 ; i < a.length ; i++ ) {\n                a[i] = i;\n            }\n            numLeft = new BigInteger(total.toString());\n        }\n\n        public boolean hasMore() {\n            return numLeft.compareTo(BigInteger.ZERO) == 1;\n        }\n\n        private static BigInteger getFactorial (int n) {\n            BigInteger fact = BigInteger.ONE;\n            for ( int i = n ; i > 1 ; i-- ) {\n                fact = fact.multiply(new BigInteger(Integer.toString(i)));\n            }\n            return fact;\n        }\n\n        \n        public int[] getNext() {\n            if ( numLeft.equals(total) ) {\n                numLeft = numLeft.subtract (BigInteger.ONE);\n                return a;\n            }\n\n            \n            int j = a.length - 2;\n            while ( a[j] > a[j+1] ) {\n                j--;\n            }\n\n            \n            int k = a.length - 1;\n            while ( a[j] > a[k] ) {\n                k--;\n            }\n\n            \n            int temp = a[k];\n            a[k] = a[j];\n            a[j] = temp;\n\n            \n            int r = a.length - 1;\n            int s = j + 1;\n            while (r > s) {\n                int temp2 = a[s];\n                a[s] = a[r];\n                a[r] = temp2;\n                r--;\n                s++;\n            }\n\n            numLeft = numLeft.subtract(BigInteger.ONE);\n            return a;\n        }\n    }\n\n}\n"}
{"id": 404719, "name": "Playfair cipher", "source": "Translate Haskell to Java: import Control.Monad     (guard)\nimport Data.Array        (Array, assocs, elems, listArray, (!))\nimport Data.Char         (toUpper)\nimport Data.List         (nub, (\\\\))\nimport Data.List.Split   (chunksOf)\nimport Data.Maybe        (listToMaybe)\nimport Data.String.Utils (replace)\n\ntype Square a = Array (Int, Int) a\n\n\narray2D ::\n       (Int, Int) \n    -> [e] -> Square e\narray2D maxCoord = listArray ((1, 1), maxCoord)\n\n\n\n\n\nmakeTable :: String -> String\nmakeTable k = nub key ++ (alpha \\\\ key)\n    where\n      alpha = ['A' .. 'Z'] \\\\ \"J\"\n      key = map toUpper =<< words k\n\n\nmakeSquare :: [a] -> Square a\nmakeSquare = array2D (5, 5)\n\n\nshowSquare :: Square Char -> String\nshowSquare d = unlines $ chunksOf 5 (elems d)\n\n\ngetIndex' :: (Eq a) => a -> [((Int, Int), a)] -> Maybe (Int, Int)\ngetIndex' el = fmap fst . listToMaybe . filter ((== el) . snd)\n\nencodePair, decodePair :: Eq a => Square a -> (a, a) -> Maybe (a, a)\nencodePair = pairHelper (\\x -> if x == 5 then 1 else x + 1)\ndecodePair = pairHelper (\\x -> if x == 1 then 5 else x - 1)\n\npairHelper :: (Eq t)\n    => (Int -> Int) \n    -> Square t \n    -> (t, t) \n    -> Maybe (t, t) \npairHelper adjust sqr (c1, c2) =\n    do let ps = assocs sqr\n       \n       (x1, y1) <- getIndex' c1 ps\n       (x2, y2) <- getIndex' c2 ps\n       \n       \n       guard $ c1 /= c2\n       \n       let get x = sqr ! x\n       \n       Just $\n           \n           case () of\n             () | y1 == y2 ->\n                    (get (adjust x1, y1), get (adjust x2, y2))\n                | x1 == x2 ->\n                    (get (x1, adjust y1), get (x2, adjust y2))\n                | otherwise ->\n                    (get (x1, y2), get (x2, y1))\n\n\nparsePair :: String -> [(Char, Char)]\nparsePair = fmap (\\[x, y] -> (x, y)) . words . fmap toUpper\n\n\nunparsePair :: [(Char, Char)] -> String\nunparsePair = unwords . fmap (\\(x, y) -> [x, y])\n\ncodeHelper :: (Square Char -> (Char, Char) -> Maybe (Char, Char))\n    -> String -> String -> Maybe String\ncodeHelper subs key =\n    fmap unparsePair .\n    mapM (subs (makeSquare $ makeTable key)) .\n    parsePair\n\nplayfair, unplayfair :: String -> String -> Maybe String\nplayfair key = codeHelper encodePair key . formatEncode\nunplayfair = codeHelper decodePair\n\nformatEncode :: String -> String\nformatEncode =\n    map toUpper .\n    unwords .\n    map (\\[x, y] -> if x == y then [x, 'x'] else [x, y]) .\n    chunksOf 2 .\n    replace \"j\" \"i\" .\n    concatMap adjustLength .\n    words .\n    filter (\\n -> n `elem` (['A'..'Z'] ++ ['a'..'z']))\n    where\n      adjustLength str\n          | odd (length str) = str ++ \"x\"\n          | otherwise = str\n", "target": "import java.awt.Point;\nimport java.util.Scanner;\n\npublic class PlayfairCipher {\n    private static char[][] charTable;\n    private static Point[] positions;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String key = prompt(\"Enter an encryption key (min length 6): \", sc, 6);\n        String txt = prompt(\"Enter the message: \", sc, 1);\n        String jti = prompt(\"Replace J with I? y/n: \", sc, 1);\n\n        boolean changeJtoI = jti.equalsIgnoreCase(\"y\");\n\n        createTable(key, changeJtoI);\n\n        String enc = encode(prepareText(txt, changeJtoI));\n\n        System.out.printf(\"%nEncoded message: %n%s%n\", enc);\n        System.out.printf(\"%nDecoded message: %n%s%n\", decode(enc));\n    }\n\n    private static String prompt(String promptText, Scanner sc, int minLen) {\n        String s;\n        do {\n            System.out.print(promptText);\n            s = sc.nextLine().trim();\n        } while (s.length() < minLen);\n        return s;\n    }\n\n    private static String prepareText(String s, boolean changeJtoI) {\n        s = s.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n        return changeJtoI ? s.replace(\"J\", \"I\") : s.replace(\"Q\", \"\");\n    }\n\n    private static void createTable(String key, boolean changeJtoI) {\n        charTable = new char[5][5];\n        positions = new Point[26];\n\n        String s = prepareText(key + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", changeJtoI);\n\n        int len = s.length();\n        for (int i = 0, k = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (positions[c - 'A'] == null) {\n                charTable[k / 5][k % 5] = c;\n                positions[c - 'A'] = new Point(k % 5, k / 5);\n                k++;\n            }\n        }\n    }\n\n    private static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s);\n\n        for (int i = 0; i < sb.length(); i += 2) {\n\n            if (i == sb.length() - 1)\n                sb.append(sb.length() % 2 == 1 ? 'X' : \"\");\n\n            else if (sb.charAt(i) == sb.charAt(i + 1))\n                sb.insert(i + 1, 'X');\n        }\n        return codec(sb, 1);\n    }\n\n    private static String decode(String s) {\n        return codec(new StringBuilder(s), 4);\n    }\n\n    private static String codec(StringBuilder text, int direction) {\n        int len = text.length();\n        for (int i = 0; i < len; i += 2) {\n            char a = text.charAt(i);\n            char b = text.charAt(i + 1);\n\n            int row1 = positions[a - 'A'].y;\n            int row2 = positions[b - 'A'].y;\n            int col1 = positions[a - 'A'].x;\n            int col2 = positions[b - 'A'].x;\n\n            if (row1 == row2) {\n                col1 = (col1 + direction) % 5;\n                col2 = (col2 + direction) % 5;\n\n            } else if (col1 == col2) {\n                row1 = (row1 + direction) % 5;\n                row2 = (row2 + direction) % 5;\n\n            } else {\n                int tmp = col1;\n                col1 = col2;\n                col2 = tmp;\n            }\n\n            text.setCharAt(i, charTable[row1][col1]);\n            text.setCharAt(i + 1, charTable[row2][col2]);\n        }\n        return text.toString();\n    }\n}\n"}
{"id": 404720, "name": "Playfair cipher", "source": "Translate Haskell to Java: import Control.Monad     (guard)\nimport Data.Array        (Array, assocs, elems, listArray, (!))\nimport Data.Char         (toUpper)\nimport Data.List         (nub, (\\\\))\nimport Data.List.Split   (chunksOf)\nimport Data.Maybe        (listToMaybe)\nimport Data.String.Utils (replace)\n\ntype Square a = Array (Int, Int) a\n\n\narray2D ::\n       (Int, Int) \n    -> [e] -> Square e\narray2D maxCoord = listArray ((1, 1), maxCoord)\n\n\n\n\n\nmakeTable :: String -> String\nmakeTable k = nub key ++ (alpha \\\\ key)\n    where\n      alpha = ['A' .. 'Z'] \\\\ \"J\"\n      key = map toUpper =<< words k\n\n\nmakeSquare :: [a] -> Square a\nmakeSquare = array2D (5, 5)\n\n\nshowSquare :: Square Char -> String\nshowSquare d = unlines $ chunksOf 5 (elems d)\n\n\ngetIndex' :: (Eq a) => a -> [((Int, Int), a)] -> Maybe (Int, Int)\ngetIndex' el = fmap fst . listToMaybe . filter ((== el) . snd)\n\nencodePair, decodePair :: Eq a => Square a -> (a, a) -> Maybe (a, a)\nencodePair = pairHelper (\\x -> if x == 5 then 1 else x + 1)\ndecodePair = pairHelper (\\x -> if x == 1 then 5 else x - 1)\n\npairHelper :: (Eq t)\n    => (Int -> Int) \n    -> Square t \n    -> (t, t) \n    -> Maybe (t, t) \npairHelper adjust sqr (c1, c2) =\n    do let ps = assocs sqr\n       \n       (x1, y1) <- getIndex' c1 ps\n       (x2, y2) <- getIndex' c2 ps\n       \n       \n       guard $ c1 /= c2\n       \n       let get x = sqr ! x\n       \n       Just $\n           \n           case () of\n             () | y1 == y2 ->\n                    (get (adjust x1, y1), get (adjust x2, y2))\n                | x1 == x2 ->\n                    (get (x1, adjust y1), get (x2, adjust y2))\n                | otherwise ->\n                    (get (x1, y2), get (x2, y1))\n\n\nparsePair :: String -> [(Char, Char)]\nparsePair = fmap (\\[x, y] -> (x, y)) . words . fmap toUpper\n\n\nunparsePair :: [(Char, Char)] -> String\nunparsePair = unwords . fmap (\\(x, y) -> [x, y])\n\ncodeHelper :: (Square Char -> (Char, Char) -> Maybe (Char, Char))\n    -> String -> String -> Maybe String\ncodeHelper subs key =\n    fmap unparsePair .\n    mapM (subs (makeSquare $ makeTable key)) .\n    parsePair\n\nplayfair, unplayfair :: String -> String -> Maybe String\nplayfair key = codeHelper encodePair key . formatEncode\nunplayfair = codeHelper decodePair\n\nformatEncode :: String -> String\nformatEncode =\n    map toUpper .\n    unwords .\n    map (\\[x, y] -> if x == y then [x, 'x'] else [x, y]) .\n    chunksOf 2 .\n    replace \"j\" \"i\" .\n    concatMap adjustLength .\n    words .\n    filter (\\n -> n `elem` (['A'..'Z'] ++ ['a'..'z']))\n    where\n      adjustLength str\n          | odd (length str) = str ++ \"x\"\n          | otherwise = str\n", "target": "import java.awt.Point;\nimport java.util.Scanner;\n\npublic class PlayfairCipher {\n    private static char[][] charTable;\n    private static Point[] positions;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String key = prompt(\"Enter an encryption key (min length 6): \", sc, 6);\n        String txt = prompt(\"Enter the message: \", sc, 1);\n        String jti = prompt(\"Replace J with I? y/n: \", sc, 1);\n\n        boolean changeJtoI = jti.equalsIgnoreCase(\"y\");\n\n        createTable(key, changeJtoI);\n\n        String enc = encode(prepareText(txt, changeJtoI));\n\n        System.out.printf(\"%nEncoded message: %n%s%n\", enc);\n        System.out.printf(\"%nDecoded message: %n%s%n\", decode(enc));\n    }\n\n    private static String prompt(String promptText, Scanner sc, int minLen) {\n        String s;\n        do {\n            System.out.print(promptText);\n            s = sc.nextLine().trim();\n        } while (s.length() < minLen);\n        return s;\n    }\n\n    private static String prepareText(String s, boolean changeJtoI) {\n        s = s.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n        return changeJtoI ? s.replace(\"J\", \"I\") : s.replace(\"Q\", \"\");\n    }\n\n    private static void createTable(String key, boolean changeJtoI) {\n        charTable = new char[5][5];\n        positions = new Point[26];\n\n        String s = prepareText(key + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", changeJtoI);\n\n        int len = s.length();\n        for (int i = 0, k = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (positions[c - 'A'] == null) {\n                charTable[k / 5][k % 5] = c;\n                positions[c - 'A'] = new Point(k % 5, k / 5);\n                k++;\n            }\n        }\n    }\n\n    private static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s);\n\n        for (int i = 0; i < sb.length(); i += 2) {\n\n            if (i == sb.length() - 1)\n                sb.append(sb.length() % 2 == 1 ? 'X' : \"\");\n\n            else if (sb.charAt(i) == sb.charAt(i + 1))\n                sb.insert(i + 1, 'X');\n        }\n        return codec(sb, 1);\n    }\n\n    private static String decode(String s) {\n        return codec(new StringBuilder(s), 4);\n    }\n\n    private static String codec(StringBuilder text, int direction) {\n        int len = text.length();\n        for (int i = 0; i < len; i += 2) {\n            char a = text.charAt(i);\n            char b = text.charAt(i + 1);\n\n            int row1 = positions[a - 'A'].y;\n            int row2 = positions[b - 'A'].y;\n            int col1 = positions[a - 'A'].x;\n            int col2 = positions[b - 'A'].x;\n\n            if (row1 == row2) {\n                col1 = (col1 + direction) % 5;\n                col2 = (col2 + direction) % 5;\n\n            } else if (col1 == col2) {\n                row1 = (row1 + direction) % 5;\n                row2 = (row2 + direction) % 5;\n\n            } else {\n                int tmp = col1;\n                col1 = col2;\n                col2 = tmp;\n            }\n\n            text.setCharAt(i, charTable[row1][col1]);\n            text.setCharAt(i + 1, charTable[row2][col2]);\n        }\n        return text.toString();\n    }\n}\n"}
{"id": 404721, "name": "Word break problem", "source": "Translate Haskell to Java: import Data.List (isPrefixOf, intercalate)\nimport Data.Tree (Tree(..))\n\nwordBreaks :: [String] -> String -> String\nwordBreaks ws = (++) <*> (\":\\n\" ++) . report . fmap go . tokenTrees ws\n  where\n    go t\n      | null (subForest t) = [rootLabel t]\n      | otherwise = subForest t >>= ((:) (rootLabel t) . go)\n    report xs\n      | null xs = \"\\tNot parseable with these words\"\n      | otherwise = unlines $ ('\\t' :) . intercalate \" -> \" <$> xs\n\ntokenTrees :: [String] -> String -> [Tree String]\ntokenTrees ws = go\n  where\n    go s\n      | s `elem` ws = [Node s []]\n      | otherwise = ws >>= next s\n    next s w\n      | w `isPrefixOf` s = parse w (go (drop (length w) s))\n      | otherwise = []\n    parse w xs\n      | null xs = []\n      | otherwise = [Node w xs]\n\n\nws, texts :: [String]\nws = words \"a bc abc cd b\"\n\ntexts = words \"abcd abbc abcbcd acdbc abcdd\"\n\nmain :: IO ()\nmain = (putStrLn . unlines) $ wordBreaks ws <$> texts\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\n\npublic class WordBreak {\n\n    public static void main(String[] args) {\n        List<String> dict = Arrays.asList(\"a\", \"aa\", \"b\", \"ab\", \"aab\");\n        for ( String testString : Arrays.asList(\"aab\", \"aa b\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n        dict = Arrays.asList(\"abc\", \"a\", \"ac\", \"b\", \"c\", \"cb\", \"d\");\n        for ( String testString : Arrays.asList(\"abcd\", \"abbc\", \"abcbcd\", \"acdbc\", \"abcdd\") ) {\n            List<List<String>> matches = wordBreak(testString, dict);\n            System.out.printf(\"String = %s, Dictionary = %s.  Solutions = %d:%n\", testString, dict, matches.size());\n            for ( List<String> match : matches ) {\n                System.out.printf(\" Word Break = %s%n\", match);\n            }\n            System.out.printf(\"%n\");\n        }\n    }\n    \n    private static List<List<String>> wordBreak(String s, List<String> dictionary) {\n        List<List<String>> matches = new ArrayList<>();\n        Queue<Node> queue = new LinkedList<>();\n        queue.add(new Node(s));\n        while ( ! queue.isEmpty() ) {\n            Node node = queue.remove();\n            \n            if ( node.val.length() == 0 ) {\n                matches.add(node.parsed);\n            }\n            else {\n                for ( String word : dictionary ) {\n                    \n                    if ( node.val.startsWith(word) ) {\n                        String valNew = node.val.substring(word.length(), node.val.length());\n                        List<String> parsedNew = new ArrayList<>();\n                        parsedNew.addAll(node.parsed);\n                        parsedNew.add(word);\n                        queue.add(new Node(valNew, parsedNew));\n                    }\n                }\n            }\n        }\n        return matches;\n    }\n    \n    private static class Node {\n        private String val;  \n        private List<String> parsed;  \n        public Node(String initial) {\n            val = initial;\n            parsed = new ArrayList<>();\n        }\n        public Node(String s, List<String> p) {\n            val = s;\n            parsed = p;\n        }\n    }\n\n}\n"}
{"id": 404722, "name": "K-means++ clustering", "source": "Translate Haskell to Java: \nmodule KMeans where\n \nimport Control.Applicative\nimport Control.Monad.Random\nimport Data.List (minimumBy, genericLength, transpose)\nimport Data.Ord (comparing)\nimport qualified Data.Map.Strict as M\n\n \ntype Vec = [Float]\ntype Cluster = [Vec]\n \nkMeansIteration :: [Vec] -> [Vec] -> [Cluster]\nkMeansIteration pts = clusterize . fixPoint iteration\n  where\n    iteration = map centroid . clusterize\n \n    clusterize centroids = M.elems $ foldr add m0 pts\n      where add x = M.insertWith (++) (centroids `nearestTo` x) [x]\n            m0 = M.unions $ map (`M.singleton` []) centroids\n \nnearestTo :: [Vec] -> Vec -> Vec\nnearestTo pts x =  minimumBy (comparing (distance x)) pts\n \ndistance :: Vec -> Vec -> Float\ndistance a b = sum $ map (^2) $ zipWith (-) a b\n \ncentroid :: [Vec] -> Vec\ncentroid = map mean . transpose\n  where  mean pts = sum pts / genericLength pts\n \nfixPoint :: Eq a => (a -> a) -> a -> a\nfixPoint f x = if x == fx then x else fixPoint f fx where fx = f x\n \n\n \nkMeans :: MonadRandom m => Int -> [Vec] -> m [Cluster]\nkMeans n pts = kMeansIteration pts <$> take n <$> randomElements pts\n \nkMeansPP :: MonadRandom m => Int -> [Vec] -> m [Cluster]\nkMeansPP n pts = kMeansIteration pts <$> centroids\n  where centroids = iterate (>>= nextCentroid) x0 !! (n-1)\n        x0 = take 1 <$> randomElements pts\n        nextCentroid cs = (: cs) <$> fromList (map (weight cs) pts)\n        weight cs x = (x, toRational $ distance x (cs `nearestTo` x))\n \nrandomElements :: MonadRandom m => [a] -> m [a]\nrandomElements pts = map (pts !!) <$> getRandomRs (0, length pts)\n\n\n\ninstance (RandomGen g, Monoid m) => Monoid (Rand g m) where\n   mempty = pure mempty\n   mappend = liftA2 mappend\n\nmkCluster n s m = take n . transpose <$> mapM randomsAround m\n  where randomsAround x0 = map (\\x -> x0+s*atanh x) <$> getRandomRs (-1,1)\n", "target": "import java.util.Random;\n\npublic class KMeansWithKpp{\n\t\t\n\t\tpublic Point[] points;\n\t\tpublic Point[] centroids;\n\t\tRandom rand;\n\t\tpublic int n;\n\t\tpublic int k;\n\n\t\t\n\t\tprivate KMeansWithKpp(){\n\t\t}\n\n\t\tKMeansWithKpp(Point[] p, int clusters){\n\t\t\t\tpoints = p;\n\t\t\t\tn = p.length;\n\t\t\t\tk = Math.max(1, clusters);\n\t\t\t\tcentroids = new Point[k];\n\t\t\t\trand = new Random();\n\t\t}\n\n\n\t\tprivate static double distance(Point a, Point b){\n\t\t\t\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n\t\t}\n\n\t\tprivate static int nearest(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tint index = pt.group;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn index;\n\t\t}\n\n\t\tprivate static double nearestDistance(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn minD;\n\t\t}\n\n\t\tprivate void kpp(){\n\t\t\t\tcentroids[0] = points[rand.nextInt(n)];\n\t\t\t\tdouble[] dist = new double[n];\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tdist[j] = nearestDistance(points[j], centroids, i);\n\t\t\t\t\t\t\t\tsum += dist[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum = (sum * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tif ((sum -= dist[j]) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tcentroids[i].x = points[j].x;\n\t\t\t\t\t\t\t\tcentroids[i].y = points[j].y;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tpoints[i].group = nearest(points[i], centroids, k);\n\t\t\t\t}\n\t\t}\n\n\t\tpublic void kMeans(int maxTimes){\n\t\t\t\tif (k == 1 || n <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(k >= n){\n\t\t\t\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\t\t\t\t\tpoints[i].group = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxTimes = Math.max(1, maxTimes);\n\t\t\t\tint changed;\n\t\t\t\tint bestPercent = n/1000;\n\t\t\t\tint minIndex;\n\t\t\t\tkpp();\n\t\t\t\tdo {\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x = 0.0;\n\t\t\t\t\t\t\t\tc.y = 0.0;\n\t\t\t\t\t\t\t\tc.group = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tif(pt.group < 0 || pt.group > centroids.length){\n\t\t\t\t\t\t\t\t\t\tpt.group = rand.nextInt(centroids.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcentroids[pt.group].x += pt.x;\n\t\t\t\t\t\t\t\tcentroids[pt.group].y = pt.y;\n\t\t\t\t\t\t\t\tcentroids[pt.group].group++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x /= c.group;\n\t\t\t\t\t\t\t\tc.y /= c.group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged = 0;\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tminIndex = nearest(pt, centroids, k);\n\t\t\t\t\t\t\t\tif (k != pt.group) {\n\t\t\t\t\t\t\t\t\t\tchanged++;\n\t\t\t\t\t\t\t\t\t\tpt.group = minIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxTimes--;\n\t\t\t\t} while (changed > bestPercent && maxTimes > 0);\n\t\t}\n}\n\n\n\n\nclass Point{\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic int group;\n\n\t\tPoint(){\n\t\t\t\tx = y = 0.0;\n\t\t\t\tgroup = 0;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPlaneData(double minX, double maxX, double minY, double maxY, int size){\n\t\t\t\tif (size <= 0)\n\t\t\t\t\t\treturn null;\n\t\t\t\tdouble xdiff, ydiff;\n\t\t\t\txdiff = maxX - minX;\n\t\t\t\tydiff = maxY - minY;\n\t\t\t\tif (minX > maxX) {\n\t\t\t\t\t\txdiff = minX - maxX;\n\t\t\t\t\t\tminX = maxX;\n\t\t\t\t}\n\t\t\t\tif (maxY < minY) {\n\t\t\t\t\t\tydiff = minY - maxY;\n\t\t\t\t\t\tminY = maxY;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tdata[i].x = minX + (xdiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].y = minY + (ydiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPolarData(double radius, int size){\n\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tdouble radi, arg;\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tradi = (radius * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\targ = (2 * Math.PI * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].x = radi * Math.cos(arg);\n\t\t\t\t\t\tdata[i].y = radi * Math.sin(arg);\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\t\t\n}\n"}
{"id": 404723, "name": "Decimal floating point number to binary", "source": "Translate Haskell to Java: import Data.Char (intToDigit)\nimport Numeric (floatToDigits, showIntAtBase)\n\ndec2bin :: RealFloat a => a -> String\ndec2bin f = \"0.\" ++ map intToDigit digits ++ \"p+\" ++ showIntAtBase 2 intToDigit ex \"\"\n  where (digits, ex) = floatToDigits 2 f\n\nmain :: IO ()\nmain = putStrLn $ dec2bin 23.34375\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 404724, "name": "Decimal floating point number to binary", "source": "Translate Haskell to Java: import Data.Char (intToDigit)\nimport Numeric (floatToDigits, showIntAtBase)\n\ndec2bin :: RealFloat a => a -> String\ndec2bin f = \"0.\" ++ map intToDigit digits ++ \"p+\" ++ showIntAtBase 2 intToDigit ex \"\"\n  where (digits, ex) = floatToDigits 2 f\n\nmain :: IO ()\nmain = putStrLn $ dec2bin 23.34375\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 404725, "name": "Free polyominoes enumeration", "source": "Translate Haskell to Java: import System.Environment (getArgs)\nimport Control.Arrow ((***), first)\nimport Data.Set (toList, fromList)\nimport Data.List (sort)\nimport Data.Bool (bool)\n\ntype Coord = Int\n\ntype Point = (Coord, Coord)\n\ntype Polyomino = [Point]\n\n\nminima :: Polyomino -> Point\nminima (p:ps) = foldr (\\(x, y) (mx, my) -> (min x mx, min y my)) p ps\n\ntranslateToOrigin :: Polyomino -> Polyomino\ntranslateToOrigin p =\n  let (minx, miny) = minima p\n  in (subtract minx *** subtract miny) <$> p\n\nrotate90, rotate180, rotate270, reflect :: Point -> Point\nrotate90 = uncurry (flip (,) . negate)\n\nrotate180 = negate *** negate\n\nrotate270 = uncurry (flip ((,) . negate))\n\nreflect = first negate\n\n\nrotationsAndReflections :: Polyomino -> [Polyomino]\nrotationsAndReflections =\n  (<*>)\n    (fmap <$>\n     [ id\n     , rotate90\n     , rotate180\n     , rotate270\n     , reflect\n     , rotate90 . reflect\n     , rotate180 . reflect\n     , rotate270 . reflect\n     ]) .\n  return\n\ncanonical :: Polyomino -> Polyomino\ncanonical = minimum . map (sort . translateToOrigin) . rotationsAndReflections\n\nunique\n  :: (Ord a)\n  => [a] -> [a]\nunique = toList . fromList\n\n\ncontiguous :: Point -> [Point]\ncontiguous (x, y) = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\n\nnewPoints :: Polyomino -> [Point]\nnewPoints p =\n  let notInP = filter (not . flip elem p)\n  in unique . notInP . concatMap contiguous $ p\n\nnewPolys :: Polyomino -> [Polyomino]\nnewPolys p = unique . map (canonical . flip (:) p) $ newPoints p\n\nmonomino = [(0, 0)]\n\nmonominoes = [monomino]\n\n\nrank :: Int -> [Polyomino]\nrank 0 = []\nrank 1 = monominoes\nrank n = unique . concatMap newPolys $ rank (n - 1)\n\n\ntextRepresentation :: Polyomino -> String\ntextRepresentation p =\n  unlines\n    [ [ bool ' ' '#' ((x, y) `elem` p)\n      | x <- [0 .. maxx - minx] ]\n    | y <- [0 .. maxy - miny] ]\n  where\n    maxima :: Polyomino -> Point\n    maxima (p:ps) = foldr (\\(x, y) (mx, my) -> (max x mx, max y my)) p ps\n    (minx, miny) = minima p\n    (maxx, maxy) = maxima p\n\nmain :: IO ()\nmain = do\n  print $ map (length . rank) [1 .. 10]\n  args <- getArgs\n  let n = bool (read $ head args :: Int) 5 (null args)\n  putStrLn (\"\\nAll free polyominoes of rank \" ++ show n ++ \":\")\n  mapM_ (putStrLn . textRepresentation) (rank n)\n", "target": "import java.awt.Point;\nimport java.util.*;\nimport static java.util.Arrays.asList;\nimport java.util.function.Function;\nimport static java.util.Comparator.comparing;\nimport static java.util.stream.Collectors.toList;\n\npublic class FreePolyominoesEnum {\n    static final List<Function<Point, Point>> transforms = new ArrayList<>();\n\n    static {\n        transforms.add(p -> new Point(p.y, -p.x));\n        transforms.add(p -> new Point(-p.x, -p.y));\n        transforms.add(p -> new Point(-p.y, p.x));\n        transforms.add(p -> new Point(-p.x, p.y));\n        transforms.add(p -> new Point(-p.y, -p.x));\n        transforms.add(p -> new Point(p.x, -p.y));\n        transforms.add(p -> new Point(p.y, p.x));\n    }\n\n    static Point findMinima(List<Point> poly) {\n        return new Point(\n                poly.stream().mapToInt(a -> a.x).min().getAsInt(),\n                poly.stream().mapToInt(a -> a.y).min().getAsInt());\n    }\n\n    static List<Point> translateToOrigin(List<Point> poly) {\n        final Point min = findMinima(poly);\n        poly.replaceAll(p -> new Point(p.x - min.x, p.y - min.y));\n        return poly;\n    }\n\n    static List<List<Point>> rotationsAndReflections(List<Point> poly) {\n        List<List<Point>> lst = new ArrayList<>();\n        lst.add(poly);\n        for (Function<Point, Point> t : transforms)\n            lst.add(poly.stream().map(t).collect(toList()));\n        return lst;\n    }\n\n    static Comparator<Point> byCoords = Comparator.<Point>comparingInt(p -> p.x)\n            .thenComparingInt(p -> p.y);\n\n    static List<Point> normalize(List<Point> poly) {\n        return rotationsAndReflections(poly).stream()\n                .map(lst -> translateToOrigin(lst))\n                .map(lst -> lst.stream().sorted(byCoords).collect(toList()))\n                .min(comparing(Object::toString)) \n                .get();\n    }\n\n    static List<Point> neighborhoods(Point p) {\n        return asList(new Point(p.x - 1, p.y), new Point(p.x + 1, p.y),\n                new Point(p.x, p.y - 1), new Point(p.x, p.y + 1));\n    }\n\n    static List<Point> concat(List<Point> lst, Point pt) {\n        List<Point> r = new ArrayList<>();\n        r.addAll(lst);\n        r.add(pt);\n        return r;\n    }\n\n    static List<Point> newPoints(List<Point> poly) {\n        return poly.stream()\n                .flatMap(p -> neighborhoods(p).stream())\n                .filter(p -> !poly.contains(p))\n                .distinct()\n                .collect(toList());\n    }\n\n    static List<List<Point>> constructNextRank(List<Point> poly) {\n        return newPoints(poly).stream()\n                .map(p -> normalize(concat(poly, p)))\n                .distinct()\n                .collect(toList());\n    }\n\n    static List<List<Point>> rank(int n) {\n        if (n < 0)\n            throw new IllegalArgumentException(\"n cannot be negative\");\n\n        if (n < 2) {\n            List<List<Point>> r = new ArrayList<>();\n            if (n == 1)\n                r.add(asList(new Point(0, 0)));\n            return r;\n        }\n\n        return rank(n - 1).stream()\n                .parallel()\n                .flatMap(lst -> constructNextRank(lst).stream())\n                .distinct()\n                .collect(toList());\n    }\n\n    public static void main(String[] args) {\n        for (List<Point> poly : rank(5)) {\n            for (Point p : poly)\n                System.out.printf(\"(%d,%d) \", p.x, p.y);\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 404726, "name": "SHA-256 Merkle tree", "source": "Translate Haskell to Java: \n\nimport Control.Monad (mfilter)\nimport Crypto.Hash.SHA256 (hash)\nimport qualified Data.ByteString as B\nimport Data.ByteString.Builder (byteStringHex, char7, hPutBuilder)\nimport Data.Functor ((<&>))\nimport Data.Maybe (listToMaybe)\nimport Data.Strict.Tuple (Pair(..))\nimport qualified Data.Strict.Tuple as T\nimport System.Environment (getArgs)\nimport System.IO (Handle, stdin, stdout)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as S\nimport Text.Read (readMaybe)\n\ntype Node a    = Pair Int a\ntype LevelPred = Int -> Int -> Bool\ntype Combine a = a -> a -> a\n\n\n\n\n\n\nbuild :: Combine a -> [Node a] -> InputStream (Node a) -> IO (Maybe (Node a))\nbuild combine !stack is = S.read is >>= \\case\n  Nothing -> return $ listToMaybe $ reduce always combine stack\n  Just h  -> build combine (reduce (==) combine (h:stack)) is\n\n\n\n\nreduce :: LevelPred -> Combine a -> [Node a] -> [Node a]\nreduce prd combine (x@(i :!: _):y@(j :!: _):zs)\n  | prd i j = reduce prd combine (nodeLift combine y x : zs)\nreduce _ _ zs = zs\n\n\n\nnodeLift :: Combine a -> Node a -> Node a -> Node a\nnodeLift f (i :!: x) (j :!: y) = max i j + 1 :!: f x y\n\nalways :: a -> b -> Bool\nalways _ _ = True\n\n\n\nmerkleTreeSha256 :: Int -> Handle -> IO (Maybe B.ByteString)\nmerkleTreeSha256 sz h = mkHash <&> fmap T.snd\n  where mkHash = S.makeInputStream getBuf >>=\n                 S.map (\\bs -> 0 :!: hash bs) >>=\n                 build (\\x y -> hash (x `B.append` y)) []\n        getBuf = B.hGet h sz <&> (mfilter (/= B.empty) . Just)\n\n\nprintByteStringHex :: B.ByteString -> IO ()\nprintByteStringHex = hPutBuilder stdout . (<> char7 '\\n') . byteStringHex\n\nmain :: IO ()\nmain = getArgs <&> map readMaybe >>= \\case\n  [Just sz] -> merkleTreeSha256 sz stdin >>= \\case\n                 Nothing -> putStrLn \"No input to hash\"\n                 Just h  -> printByteStringHex h\n  _         -> putStrLn \"Argument usage: chunk-size\"\n", "target": "import java.io.*;\nimport java.security.*;\nimport java.util.*;\n\npublic class SHA256MerkleTree {\n    public static void main(String[] args) {\n        if (args.length != 1) {\n            System.err.println(\"missing file argument\");\n            System.exit(1);\n        }\n        try (InputStream in = new BufferedInputStream(new FileInputStream(args[0]))) {\n            byte[] digest = sha256MerkleTree(in, 1024);\n            if (digest != null)\n                System.out.println(digestToString(digest));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static String digestToString(byte[] digest) {\n        StringBuilder result = new StringBuilder();\n        for (int i = 0; i < digest.length; ++i)\n            result.append(String.format(\"%02x\", digest[i]));\n        return result.toString();\n    }\n\n    private static byte[] sha256MerkleTree(InputStream in, int blockSize) throws Exception {\n        byte[] buffer = new byte[blockSize];\n        int bytes;\n        MessageDigest md = MessageDigest.getInstance(\"SHA-256\");\n        List<byte[]> digests = new ArrayList<>();\n        while ((bytes = in.read(buffer)) > 0) {\n            md.reset();\n            md.update(buffer, 0, bytes);\n            digests.add(md.digest());\n        }\n        int length = digests.size();\n        if (length == 0)\n            return null;\n        while (length > 1) {\n            int j = 0;\n            for (int i = 0; i < length; i += 2, ++j) {\n                byte[] digest1 = digests.get(i);\n                if (i + 1 < length) {\n                    byte[] digest2 = digests.get(i + 1);\n                    md.reset();\n                    md.update(digest1);\n                    md.update(digest2);\n                    digests.set(j, md.digest());\n                } else {\n                    digests.set(j, digest1);\n                }\n            }\n            length = j;\n        }\n        return digests.get(0);\n    }\n}\n"}
{"id": 404727, "name": "Partition function P", "source": "Translate Haskell to Java: \n\n\n\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving (Functor)\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Memo Int\nnats =\n  Node\n    0\n    ((+ 1) . (* 2) <$> nats)\n    ((* 2) . (+ 1) <$> nats)\n\n\n\n\npartitions :: Memo Integer\npartitions = partitionP <$> nats\n\npartitionP :: Int -> Integer\npartitionP n\n  | n < 2 = 1\n  | otherwise = sum $ zipWith (*) signs terms\n  where\n    terms =\n      [ memo partitions (n - i)\n        | i <- takeWhile (<= n) ofsets\n      ]\n    signs = cycle [1, 1, -1, -1]\n\nofsets :: [Int]\nofsets = scanl1 (+) $ mix [1, 3 ..] [1, 2 ..]\n  where\n    mix a b = concat $ zipWith (\\x y -> [x, y]) a b\n\nmain :: IO ()\nmain = print $ partitionP 6666\n", "target": "import java.math.BigInteger;\n\npublic class PartitionFunction {\n    public static void main(String[] args) {\n        long start = System.currentTimeMillis();\n        BigInteger result = partitions(6666);\n        long end = System.currentTimeMillis();\n        System.out.println(\"P(6666) = \" + result);\n        System.out.printf(\"elapsed time: %d milliseconds\\n\", end - start);\n    }\n\n    private static BigInteger partitions(int n) {\n        BigInteger[] p = new BigInteger[n + 1];\n        p[0] = BigInteger.ONE;\n        for (int i = 1; i <= n; ++i) {\n            p[i] = BigInteger.ZERO;\n            for (int k = 1; ; ++k) {\n                int j = (k * (3 * k - 1))/2;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n                j += k;\n                if (j > i)\n                    break;\n                if ((k & 1) != 0)\n                    p[i] = p[i].add(p[i - j]);\n                else\n                    p[i] = p[i].subtract(p[i - j]);\n            }\n        }\n        return p[n];\n    }\n}\n"}
{"id": 404728, "name": "Polynomial synthetic division", "source": "Translate Haskell to Java: import Data.List\n\nnormalized :: (Eq a, Num a) => [a] -> [a]\nnormalized = dropWhile (== 0)\n\nisZero :: (Eq a, Num a) => [a] -> Bool\nisZero = null . normalized\n\nshortDiv :: (Eq a, Fractional a) => [a] -> [a] -> ([a], [a])\nshortDiv p1 p2\n  | isZero p2 = error \"zero divisor\"\n  | otherwise =\n      let go 0 p = p \n          go i (h:t) = (h/a) : go (i-1) (zipWith (+) (map ((h/a) *) ker) t)\n      in splitAt k $ go k p1\n  where\n    k = length p1 - length as\n    a:as = normalized p2\n    ker = negate <$> (as ++ repeat 0)\n", "target": "import java.util.Arrays;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] N = {1, -12, 0, -42};\n        int[] D = {1, -3};\n\n        System.out.printf(\"%s / %s = %s\",\n                Arrays.toString(N),\n                Arrays.toString(D),\n                Arrays.deepToString(extendedSyntheticDivision(N, D)));\n    }\n\n    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {\n        int[] out = dividend.clone();\n        int normalizer = divisor[0];\n\n        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {\n            out[i] /= normalizer;\n\n            int coef = out[i];\n            if (coef != 0) {\n                for (int j = 1; j < divisor.length; j++)\n                    out[i + j] += -divisor[j] * coef;\n            }\n        }\n\n        int separator = out.length - (divisor.length - 1);\n\n        return new int[][]{\n            Arrays.copyOfRange(out, 0, separator),\n            Arrays.copyOfRange(out, separator, out.length)\n        };\n    }\n}\n"}
{"id": 404729, "name": "Polynomial synthetic division", "source": "Translate Haskell to Java: import Data.List\n\nnormalized :: (Eq a, Num a) => [a] -> [a]\nnormalized = dropWhile (== 0)\n\nisZero :: (Eq a, Num a) => [a] -> Bool\nisZero = null . normalized\n\nshortDiv :: (Eq a, Fractional a) => [a] -> [a] -> ([a], [a])\nshortDiv p1 p2\n  | isZero p2 = error \"zero divisor\"\n  | otherwise =\n      let go 0 p = p \n          go i (h:t) = (h/a) : go (i-1) (zipWith (+) (map ((h/a) *) ker) t)\n      in splitAt k $ go k p1\n  where\n    k = length p1 - length as\n    a:as = normalized p2\n    ker = negate <$> (as ++ repeat 0)\n", "target": "import java.util.Arrays;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        int[] N = {1, -12, 0, -42};\n        int[] D = {1, -3};\n\n        System.out.printf(\"%s / %s = %s\",\n                Arrays.toString(N),\n                Arrays.toString(D),\n                Arrays.deepToString(extendedSyntheticDivision(N, D)));\n    }\n\n    static int[][] extendedSyntheticDivision(int[] dividend, int[] divisor) {\n        int[] out = dividend.clone();\n        int normalizer = divisor[0];\n\n        for (int i = 0; i < dividend.length - (divisor.length - 1); i++) {\n            out[i] /= normalizer;\n\n            int coef = out[i];\n            if (coef != 0) {\n                for (int j = 1; j < divisor.length; j++)\n                    out[i + j] += -divisor[j] * coef;\n            }\n        }\n\n        int separator = out.length - (divisor.length - 1);\n\n        return new int[][]{\n            Arrays.copyOfRange(out, 0, separator),\n            Arrays.copyOfRange(out, separator, out.length)\n        };\n    }\n}\n"}
{"id": 404730, "name": "Find duplicate files", "source": "Translate Haskell to Java: import Crypto.Hash.MD5        (hash)\nimport Data.ByteString as BS  (readFile, ByteString())\nimport System.Environment     (getArgs, getProgName)\nimport System.Directory       (doesDirectoryExist, getDirectoryContents)\nimport System.FilePath.Posix  ((</>))\nimport Control.Monad          (forM)\nimport Text.Printf            (printf)\nimport System.IO              (withFile, IOMode(ReadMode), hFileSize)\n\n\ntype File = (BS.ByteString, \n             FilePath)      \n\ntype FileSize = Integer\n\ngetRecursiveContents :: FilePath -> FileSize -> IO [File]\ngetRecursiveContents curDir maxsize = do\n  names <- getDirectoryContents curDir\n  let dirs = filter (`notElem` [\".\", \"..\"]) names\n  files <- forM dirs $ \\path -> do\n             let path' = curDir </> path\n             exists <- doesDirectoryExist path'\n             if exists\n                then getRecursiveContents path' maxsize\n                else genFileHash path' maxsize\n  return $ concat files\n\n\ngenFileHash :: FilePath -> FileSize -> IO [File]\ngenFileHash path maxsize = do\n  size <- withFile path ReadMode hFileSize\n  if size <= maxsize\n    then BS.readFile path >>= \\bs -> return [(hash bs, path)]\n    else return []\n\nfindDuplicates :: FilePath -> FileSize -> IO ()\nfindDuplicates dir bytes = do\n  exists <- doesDirectoryExist dir\n  if exists\n    then getRecursiveContents dir bytes >>= findSameHashes\n    else printf \"Sorry, the directory \\\"%s\\\" does not exist...\\n\" dir\n\nfindSameHashes :: [File] -> IO ()\nfindSameHashes []     = return ()\nfindSameHashes ((hash, fp):xs) = do\n  case lookup hash xs of\n    (Just dupFile) -> printf \"===========================\\n\\\n                            \\Found duplicate:\\n\\\n                            \\=> %s \\n\\\n                            \\=> %s \\n\\n\" fp dupFile\n                      >> findSameHashes xs\n    (_)            -> findSameHashes xs\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    [dir, mbytes] | [(bytes ,\"\")] <- reads mbytes\n                   , bytes >= 1 -> findDuplicates dir bytes\n    (_) -> do\n      name <- getProgName\n      printf \"Something went wrong - please use ./%s <dir> <bytes>\\n\" name\n", "target": "import java.io.*;\nimport java.nio.*;\nimport java.nio.file.*;\nimport java.nio.file.attribute.*;\nimport java.security.*;\nimport java.util.*;\n\npublic class DuplicateFiles {\n    public static void main(String[] args) {\n        if (args.length != 2) {\n            System.err.println(\"Directory name and minimum file size are required.\");\n            System.exit(1);\n        }\n        try {\n            findDuplicateFiles(args[0], Long.parseLong(args[1]));\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void findDuplicateFiles(String directory, long minimumSize)\n        throws IOException, NoSuchAlgorithmException {\n        System.out.println(\"Directory: '\" + directory + \"', minimum size: \" + minimumSize + \" bytes.\");\n        Path path = FileSystems.getDefault().getPath(directory);\n        FileVisitor visitor = new FileVisitor(path, minimumSize);\n        Files.walkFileTree(path, visitor);\n        System.out.println(\"The following sets of files have the same size and checksum:\");\n        for (Map.Entry<FileKey, Map<Object, List<String>>> e : visitor.fileMap_.entrySet()) {\n            Map<Object, List<String>> map = e.getValue();\n            if (!containsDuplicates(map))\n                continue;\n            List<List<String>> fileSets = new ArrayList<>(map.values());\n            for (List<String> files : fileSets)\n                Collections.sort(files);\n            Collections.sort(fileSets, new StringListComparator());\n            FileKey key = e.getKey();\n            System.out.println();\n            System.out.println(\"Size: \" + key.size_ + \" bytes\");\n            for (List<String> files : fileSets) {\n                for (int i = 0, n = files.size(); i < n; ++i) {\n                    if (i > 0)\n                        System.out.print(\" = \");\n                    System.out.print(files.get(i));\n                }\n                System.out.println();\n            }\n        }\n    }\n\n    private static class StringListComparator implements Comparator<List<String>> {\n        public int compare(List<String> a, List<String> b) {\n            int len1 = a.size(), len2 = b.size();\n            for (int i = 0; i < len1 && i < len2; ++i) {\n                int c = a.get(i).compareTo(b.get(i));\n                if (c != 0)\n                    return c;\n            }\n            return Integer.compare(len1, len2);\n        }\n    }\n\n    private static boolean containsDuplicates(Map<Object, List<String>> map) {\n        if (map.size() > 1)\n            return true;\n        for (List<String> files : map.values()) {\n            if (files.size() > 1)\n                return true;\n        }\n        return false;\n    }\n\n    private static class FileVisitor extends SimpleFileVisitor<Path> {\n        private MessageDigest digest_;\n        private Path directory_;\n        private long minimumSize_;\n        private Map<FileKey, Map<Object, List<String>>> fileMap_ = new TreeMap<>();\n\n        private FileVisitor(Path directory, long minimumSize) throws NoSuchAlgorithmException {\n            directory_ = directory;\n            minimumSize_ = minimumSize;\n            digest_ = MessageDigest.getInstance(\"MD5\");\n        }\n\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\n            if (attrs.size() >= minimumSize_) {\n                FileKey key = new FileKey(file, attrs, getMD5Sum(file));\n                Map<Object, List<String>> map = fileMap_.get(key);\n                if (map == null)\n                    fileMap_.put(key, map = new HashMap<>());\n                List<String> files = map.get(attrs.fileKey());\n                if (files == null)\n                    map.put(attrs.fileKey(), files = new ArrayList<>());\n                Path relative = directory_.relativize(file);\n                files.add(relative.toString());\n            }\n            return FileVisitResult.CONTINUE;\n        }\n\n        private byte[] getMD5Sum(Path file) throws IOException {\n            digest_.reset();\n            try (InputStream in = new FileInputStream(file.toString())) {\n                byte[] buffer = new byte[8192];\n                int bytes;\n                while ((bytes = in.read(buffer)) != -1) {\n                    digest_.update(buffer, 0, bytes);\n                }\n            }\n            return digest_.digest();\n        }\n    }\n\n    private static class FileKey implements Comparable<FileKey> {\n        private byte[] hash_;\n        private long size_;\n\n        private FileKey(Path file, BasicFileAttributes attrs, byte[] hash) throws IOException {\n            size_ = attrs.size();\n            hash_ = hash;\n        }\n\n        public int compareTo(FileKey other) {\n            int c = Long.compare(other.size_, size_);\n            if (c == 0)\n                c = hashCompare(hash_, other.hash_);\n            return c;\n        }\n    }\n\n    private static int hashCompare(byte[] a, byte[] b) {\n        int len1 = a.length, len2 = b.length;\n        for (int i = 0; i < len1 && i < len2; ++i) {\n            int c = Byte.compare(a[i], b[i]);\n            if (c != 0)\n                return c;\n        }\n        return Integer.compare(len1, len2);\n    }\n}\n"}
{"id": 404731, "name": "Legendre prime counting function", "source": "Translate Haskell to Java: \n\n\nimport Data.Time.Clock.POSIX ( getPOSIXTime ) \n\nimport Data.Int ( Int64 )\nimport Data.Bits ( Bits( shiftL, shiftR ) )\n\ndata Memo a = EmptyNode | Node a (Memo a) (Memo a)\n  deriving Functor\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Integral a => Memo a\nnats = Node 0 ((+1).(*2) <$> nats) ((*2).(+1) <$> nats)\n\nmemoize :: Integral a => (a -> b) -> a -> b\nmemoize f = memo (f <$> nats)\n\nmemoize2 :: (Integral a, Integral b) => (a -> b -> c) -> a -> b -> c\nmemoize2 f = memoize (memoize . f)\n\nmemoList :: [b] -> Integer -> b\nmemoList = memo . mkList\n  where\n    mkList []     = EmptyNode \n    mkList (x:xs) = Node x (mkList l) (mkList r)\n      where (l,r) = split xs\n            split [] = ([],[])\n            split [x] = ([x],[])\n            split (x:y:xs) = let (l,r) = split xs in (x:l, y:r)\n\nisqrt :: Integer -> Integer\nisqrt n = go n 0 (q `shiftR` 2)\n where\n   q = head $ dropWhile (< n) $ iterate (`shiftL` 2) 1\n   go z r 0 = r\n   go z r q = let t = z - r - q\n              in if t >= 0\n                 then go t (r `shiftR` 1 + q) (q `shiftR` 2)\n                 else go z (r `shiftR` 1) (q `shiftR` 2)\n\nprimes :: [Integer]\nprimes = 2 : _Y ((3:) . gaps 5 . _U . map(\\p-> [p*p, p*p+2*p..])) where\n  _Y g = g (_Y g)  \n  gaps k s@(c:cs) | k < c     = k : gaps (k+2) s  \n                  | otherwise =     gaps (k+2) cs \n  _U ((x:xs):t) = x : (merge xs . _U . pairs) t   \n  pairs (xs:ys:t) = merge xs ys : pairs t\n  merge xs@(x:xt) ys@(y:yt) | x < y     = x : merge xt ys\n                            | y < x     = y : merge xs yt\n                            | otherwise = x : merge xt yt\n\nphi :: Integer -> Integer -> Integer\nphi = memoize2 phiM\n  where\n    phiM x 0 = x\n    phiM x a = phi x (a-1) - phi (x `div` p a) (a - 1)\n\n    p = memoList (undefined : primes)\n\nlegendrePi :: Integer -> Integer\nlegendrePi n\n  | n < 2 = 0\n  | otherwise = phi n a + a - 1\n    where a = legendrePi (floor (sqrt (fromInteger n)))\n\nmain :: IO ()\nmain = do\n  strt <- getPOSIXTime\n  mapM_ (\\n -> putStrLn $ show n ++ \"\\t\" ++ show (legendrePi (10^n))) [0..9]\n  stop <- getPOSIXTime\n  let elpsd = round $ 1e3 * (stop - strt) :: Int64\n  putStrLn $ \"This last took \" ++ show elpsd ++ \" milliseconds.\"\n", "target": "import java.util.*;\n\npublic class LegendrePrimeCounter {\n    public static void main(String[] args) {\n        LegendrePrimeCounter counter = new LegendrePrimeCounter(1000000000);\n        for (int i = 0, n = 1; i < 10; ++i, n *= 10)\n            System.out.printf(\"10^%d\\t%d\\n\", i, counter.primeCount((n)));\n    }\n\n    private List<Integer> primes;\n\n    public LegendrePrimeCounter(int limit) {\n        primes = generatePrimes((int)Math.sqrt((double)limit));\n    }\n\n    public int primeCount(int n) {\n        if (n < 2)\n            return 0;\n        int a = primeCount((int)Math.sqrt((double)n));\n        return phi(n, a) + a - 1;\n    }\n\n    private int phi(int x, int a) {\n        if (a == 0)\n            return x;\n        if (a == 1)\n            return x - (x >> 1);\n        int pa = primes.get(a - 1);\n        if (x <= pa)\n            return 1;\n        return phi(x, a - 1) - phi(x / pa, a - 1);\n    }\n\n    private static List<Integer> generatePrimes(int limit) {\n        boolean[] sieve = new boolean[limit >> 1];\n        Arrays.fill(sieve, true);\n        for (int p = 3, s = 9; s < limit; p += 2) {\n            if (sieve[p >> 1]) {\n                for (int q = s; q < limit; q += p << 1)\n                    sieve[q >> 1] = false;\n            }\n            s += (p + 1) << 2;\n        }\n        List<Integer> primes = new ArrayList<>();\n        if (limit > 2)\n            primes.add(2);\n        for (int i = 1; i < sieve.length; ++i) {\n            if (sieve[i])\n                primes.add((i << 1) + 1);\n        } \n        return primes;\n    }\n}\n"}
{"id": 404732, "name": "Rosetta Code_Find bare lang tags", "source": "Translate Haskell to Java: import System.Environment\nimport Network.HTTP\nimport Text.Printf\nimport Text.Regex.TDFA\nimport Data.List\nimport Data.Array\nimport qualified Data.Map as Map\n\n\nsplitByMatches :: String -> [MatchText String] -> [String]\nsplitByMatches str matches  =  foldr splitHead [str] matches\n    where splitHead match acc  =  before:after:(tail acc)\n            where before  =  take (matchOffset).head$ acc\n                  after  =  drop (matchOffset + matchLen).head$ acc\n                  matchOffset  =  fst.snd.(!0)$ match\n                  matchLen  =  snd.snd.(!0)$ match\n\n\ncountBareLangTags :: String -> Int\ncountBareLangTags  =  matchCount (makeRegex \"<lang[[:space:]]*>\" :: Regex)\n\n\ncountByLanguage :: String -> Map.Map String Int\ncountByLanguage str  =  Map.fromList.filter ((>0).snd)$ zip langs counts\n    where counts  =  map countBareLangTags.splitByMatches str$ allMatches\n          langs  =  \"\":(map (fst.(!1)) allMatches)\n          allMatches  =  matchAllText (makeRegex headerRegex :: Regex) str\n          headerRegex  =  \"==[[:space:]]*{{[[:space:]]*header[[:space:]]*\\\\|[[:space:]]*([^ }]*)[[:space:]]*}}[^=]*==\"\n\nmain = do\n    args <- getArgs\n    (contents, files) <- if length args == 0 then do\n        \n            content  <-  getContents\n            return ([content],[\"\"])\n        else if length args == 1 then do\n        \n        \n            content  <-  readFile (head args)\n            return ([content],[\"\"])\n        else if (args !! 0) == \"-w\" then do\n        \n        \n            contents  <-  mapM getPageContent.tail$ args\n            return (contents, if length args > 2 then tail args else [\"\"])\n        else do\n        \n            contents  <-  mapM readFile args\n            return (contents, args)\n    let tagsPerLang  =  map countByLanguage contents\n    let tagsWithFiles  =  zipWith addFileToTags files tagsPerLang\n    let combinedFiles  =  Map.unionsWith combine tagsWithFiles\n    printBareTags combinedFiles\n        where addFileToTags file  =  Map.map (flip (,) [file])\n              combine cur next  =  (fst cur + fst next, snd cur ++ snd next)\n        \nprintBareTags :: Map.Map String (Int,[String]) -> IO ()\nprintBareTags tags  =  do\n    let numBare  =  Map.foldr ((+).fst) 0 tags\n    printf \"%d bare language tags:\\n\\n\" numBare\n    mapM_ (\\(lang,(count,files)) ->\n        printf \"%d in %s%s\\n\" count\n                              (if lang == \"\" then \"no language\" else lang)\n                              (filesString files)\n        ) (Map.toAscList tags)\n\nfilesString :: [String] -> String\nfilesString []  =  \"\"\nfilesString (\"\":rest)  =  filesString rest\nfilesString files  =  \" (\"++listString files++\")\"\n    where listString [file]  =  \"[[\"++file++\"]]\"\n          listString (file:files)  =  \"[[\"++file++\"]], \"++listString files\n\ngetPageContent :: String -> IO String\ngetPageContent title  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url  =  \"http://rosettacode.org/mw/index.php?action=raw&title=\"++title\n", "target": "import java.net.URI;\nimport java.net.http.HttpClient;\nimport java.net.http.HttpRequest;\nimport java.net.http.HttpResponse;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Predicate;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class FindBareTags {\n    private static final String BASE = \"http:\n\n    private static final Pattern TITLE_PATTERN = Pattern.compile(\"\\\"title\\\": \\\"([^\\\"]+)\\\"\");\n    private static final Pattern HEADER_PATTERN = Pattern.compile(\"==\\\\{\\\\{header\\\\|([^}]+)}}==\");\n    private static final Predicate<String> BARE_PREDICATE = Pattern.compile(\"<lang>\").asPredicate();\n\n    public static void main(String[] args) throws Exception {\n        var client = HttpClient.newBuilder().build();\n\n        URI titleUri = URI.create(BASE + \"/mw/api.php?action=query&list=categorymembers&cmtitle=Category:Programming_Tasks\");\n        var titleRequest = HttpRequest.newBuilder(titleUri).GET().build();\n\n        var titleResponse = client.send(titleRequest, HttpResponse.BodyHandlers.ofString());\n        if (titleResponse.statusCode() == 200) {\n            var titleBody = titleResponse.body();\n\n            var titleMatcher = TITLE_PATTERN.matcher(titleBody);\n            var titleList = titleMatcher.results().map(mr -> mr.group(1)).collect(Collectors.toList());\n\n            var countMap = new HashMap<String, Integer>();\n            for (String title : titleList) {\n                var pageUri = new URI(\"http\", null, \"\n                var pageRequest = HttpRequest.newBuilder(pageUri).GET().build();\n                var pageResponse = client.send(pageRequest, HttpResponse.BodyHandlers.ofString());\n                if (pageResponse.statusCode() == 200) {\n                    var pageBody = pageResponse.body();\n\n                    AtomicReference<String> language = new AtomicReference<>(\"no language\");\n                    pageBody.lines().forEach(line -> {\n                        var headerMatcher = HEADER_PATTERN.matcher(line);\n                        if (headerMatcher.matches()) {\n                            language.set(headerMatcher.group(1));\n                        } else if (BARE_PREDICATE.test(line)) {\n                            int count = countMap.getOrDefault(language.get(), 0) + 1;\n                            countMap.put(language.get(), count);\n                        }\n                    });\n                } else {\n                    System.out.printf(\"Got a %d status code%n\", pageResponse.statusCode());\n                }\n            }\n\n            for (Map.Entry<String, Integer> entry : countMap.entrySet()) {\n                System.out.printf(\"%d in %s%n\", entry.getValue(), entry.getKey());\n            }\n        } else {\n            System.out.printf(\"Got a %d status code%n\", titleResponse.statusCode());\n        }\n    }\n}\n"}
{"id": 404733, "name": "Palindromic gapful numbers", "source": "Translate Haskell to Java: import Control.Monad (guard)\n\npalindromic :: Int -> Bool\npalindromic n = d == reverse d\n where\n  d = show n\n\ngapful :: Int -> Bool\ngapful n = n `rem` firstLastDigit == 0\n where\n  firstLastDigit = read [head asDigits, last asDigits]\n  asDigits = show n\n\nresult :: Int -> [Int]\nresult d = do \n  x <- [(d+100),(d+110)..]\n  guard $ palindromic x && gapful x\n  pure x\n \nshowSets :: (Int -> String) -> IO ()\nshowSets r = go 1 \n where\n  go n = if n <= 9 then do\n    putStrLn (show n ++ \": \" ++ r n)\n    go (succ n)\n    else pure ()\n\nmain :: IO ()\nmain = do \n  putStrLn \"\\nFirst 20 palindromic gapful numbers ending in:\"\n  showSets (show . take 20 . result)\n  putStrLn \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n  showSets (show . drop 85 . take 100 . result)\n  putStrLn \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n  showSets (show . drop 990 . take 1000 . result)\n  putStrLn \"\\ndone.\"\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PalindromicGapfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 20 palindromic gapful numbers ending in:\");\n        displayMap(getPalindromicGapfulEnding(20, 20));\n\n        System.out.printf(\"%nLast 15 of first 100 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(15, 100));\n\n        System.out.printf(\"%nLast 10 of first 1000 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(10, 1000));\n    }\n    \n    private static void displayMap(Map<Integer,List<Long>> map) {\n        for ( int key = 1 ; key <= 9 ; key++ ) {\n            System.out.println(key + \"\u00a0: \" + map.get(key));\n        }\n    }\n    \n    public static Map<Integer,List<Long>> getPalindromicGapfulEnding(int countReturned, int firstHowMany) {\n        Map<Integer,List<Long>> map = new HashMap<>();\n        Map<Integer,Integer> mapCount = new HashMap<>();\n        for ( int i = 1 ; i <= 9 ; i++ ) {\n            map.put(i, new ArrayList<>());\n            mapCount.put(i, 0);\n        }\n        boolean notPopulated = true;\n        for ( long n = 101 ; notPopulated ; n = nextPalindrome(n) ) {\n            if ( isGapful(n) ) {\n                int index = (int) (n % 10);\n                if ( mapCount.get(index) < firstHowMany ) {\n                    map.get(index).add(n);\n                    mapCount.put(index, mapCount.get(index) + 1);\n                    if ( map.get(index).size() > countReturned ) {\n                        map.get(index).remove(0);\n                    }\n                }\n                boolean finished = true;\n                for ( int i = 1 ; i <= 9 ; i++ ) {\n                    if ( mapCount.get(i) < firstHowMany ) {\n                        finished = false;\n                        break;\n                    }\n                }\n                if ( finished ) {\n                    notPopulated = false;\n                }\n            }\n        }\n        return map;\n    }\n    \n    public static boolean isGapful(long n) {\n        String s = Long.toString(n);\n        return n % Long.parseLong(\"\" + s.charAt(0) + s.charAt(s.length()-1)) == 0;\n    }\n    \n    public static int length(long n) {\n        int length = 0;\n        while ( n > 0 ) {\n            length += 1;\n            n /= 10;\n        }\n        return length;\n    }\n    \n    public static long nextPalindrome(long n) {\n        int length = length(n);\n        if ( length % 2 == 0 ) {\n            length /= 2;\n            while ( length > 0 ) {\n                n /= 10;\n                length--;\n            }\n            n += 1;\n            if ( powerTen(n) ) {\n                return Long.parseLong(n + reverse(n/10));\n            }\n            return Long.parseLong(n + reverse(n));\n        }\n        length = (length - 1) / 2;\n        while ( length > 0 ) {\n            n /= 10;\n            length--;\n        }\n        n += 1;\n        if ( powerTen(n) ) {\n            return Long.parseLong(n + reverse(n/100));\n        }\n        return Long.parseLong(n + reverse(n/10));\n    }\n    \n    private static boolean powerTen(long n) {\n        while ( n > 9 && n % 10 == 0 ) {\n            n /= 10;\n        }\n        return n == 1;\n    }\n        \n    private static String reverse(long n) {\n        return (new StringBuilder(n + \"\")).reverse().toString();\n    }\n\n}\n"}
{"id": 404734, "name": "Palindromic gapful numbers", "source": "Translate Haskell to Java: import Control.Monad (guard)\n\npalindromic :: Int -> Bool\npalindromic n = d == reverse d\n where\n  d = show n\n\ngapful :: Int -> Bool\ngapful n = n `rem` firstLastDigit == 0\n where\n  firstLastDigit = read [head asDigits, last asDigits]\n  asDigits = show n\n\nresult :: Int -> [Int]\nresult d = do \n  x <- [(d+100),(d+110)..]\n  guard $ palindromic x && gapful x\n  pure x\n \nshowSets :: (Int -> String) -> IO ()\nshowSets r = go 1 \n where\n  go n = if n <= 9 then do\n    putStrLn (show n ++ \": \" ++ r n)\n    go (succ n)\n    else pure ()\n\nmain :: IO ()\nmain = do \n  putStrLn \"\\nFirst 20 palindromic gapful numbers ending in:\"\n  showSets (show . take 20 . result)\n  putStrLn \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n  showSets (show . drop 85 . take 100 . result)\n  putStrLn \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n  showSets (show . drop 990 . take 1000 . result)\n  putStrLn \"\\ndone.\"\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class PalindromicGapfulNumbers {\n\n    public static void main(String[] args) {\n        System.out.println(\"First 20 palindromic gapful numbers ending in:\");\n        displayMap(getPalindromicGapfulEnding(20, 20));\n\n        System.out.printf(\"%nLast 15 of first 100 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(15, 100));\n\n        System.out.printf(\"%nLast 10 of first 1000 palindromic gapful numbers ending in:%n\");\n        displayMap(getPalindromicGapfulEnding(10, 1000));\n    }\n    \n    private static void displayMap(Map<Integer,List<Long>> map) {\n        for ( int key = 1 ; key <= 9 ; key++ ) {\n            System.out.println(key + \"\u00a0: \" + map.get(key));\n        }\n    }\n    \n    public static Map<Integer,List<Long>> getPalindromicGapfulEnding(int countReturned, int firstHowMany) {\n        Map<Integer,List<Long>> map = new HashMap<>();\n        Map<Integer,Integer> mapCount = new HashMap<>();\n        for ( int i = 1 ; i <= 9 ; i++ ) {\n            map.put(i, new ArrayList<>());\n            mapCount.put(i, 0);\n        }\n        boolean notPopulated = true;\n        for ( long n = 101 ; notPopulated ; n = nextPalindrome(n) ) {\n            if ( isGapful(n) ) {\n                int index = (int) (n % 10);\n                if ( mapCount.get(index) < firstHowMany ) {\n                    map.get(index).add(n);\n                    mapCount.put(index, mapCount.get(index) + 1);\n                    if ( map.get(index).size() > countReturned ) {\n                        map.get(index).remove(0);\n                    }\n                }\n                boolean finished = true;\n                for ( int i = 1 ; i <= 9 ; i++ ) {\n                    if ( mapCount.get(i) < firstHowMany ) {\n                        finished = false;\n                        break;\n                    }\n                }\n                if ( finished ) {\n                    notPopulated = false;\n                }\n            }\n        }\n        return map;\n    }\n    \n    public static boolean isGapful(long n) {\n        String s = Long.toString(n);\n        return n % Long.parseLong(\"\" + s.charAt(0) + s.charAt(s.length()-1)) == 0;\n    }\n    \n    public static int length(long n) {\n        int length = 0;\n        while ( n > 0 ) {\n            length += 1;\n            n /= 10;\n        }\n        return length;\n    }\n    \n    public static long nextPalindrome(long n) {\n        int length = length(n);\n        if ( length % 2 == 0 ) {\n            length /= 2;\n            while ( length > 0 ) {\n                n /= 10;\n                length--;\n            }\n            n += 1;\n            if ( powerTen(n) ) {\n                return Long.parseLong(n + reverse(n/10));\n            }\n            return Long.parseLong(n + reverse(n));\n        }\n        length = (length - 1) / 2;\n        while ( length > 0 ) {\n            n /= 10;\n            length--;\n        }\n        n += 1;\n        if ( powerTen(n) ) {\n            return Long.parseLong(n + reverse(n/100));\n        }\n        return Long.parseLong(n + reverse(n/10));\n    }\n    \n    private static boolean powerTen(long n) {\n        while ( n > 9 && n % 10 == 0 ) {\n            n /= 10;\n        }\n        return n == 1;\n    }\n        \n    private static String reverse(long n) {\n        return (new StringBuilder(n + \"\")).reverse().toString();\n    }\n\n}\n"}
{"id": 404735, "name": "Word ladder", "source": "Translate Haskell to Java: import System.IO (readFile)\nimport Control.Monad (foldM)\nimport Data.List (intercalate)\nimport qualified Data.Set as S\n\ndistance :: String -> String -> Int\ndistance s1 s2 = length $ filter not $ zipWith (==) s1 s2\n\nwordLadders :: [String] -> String -> String -> [[String]]\nwordLadders dict start end\n  | length start /= length end = []\n  | otherwise = [wordSpace] >>= expandFrom start >>= shrinkFrom end\n  where\n \n    wordSpace = S.fromList $ filter ((length start ==) . length) dict\n\n    expandFrom s = go [[s]]\n      where\n        go (h:t) d\n          | S.null d || S.null f = []\n          | end `S.member` f = [h:t]\n          | otherwise = go (S.elems f:h:t) (d S.\\\\ f)\n          where\n            f = foldr (\\w -> S.union (S.filter (oneStepAway w) d)) mempty h\n\n    shrinkFrom = scanM (filter . oneStepAway)\n\n    oneStepAway x = (1 ==) . distance x\n    \n    scanM f x = fmap snd . foldM g (x,[x])\n      where g (b, r) a = (\\x -> (x, x:r)) <$> f b a\n\nwordLadder :: [String] -> String -> String -> [String]\nwordLadder d s e = case wordLadders d s e of\n                     [] -> []\n                     h:_ -> h\n\nshowChain [] = putStrLn \"No chain\"\nshowChain ch = putStrLn $ intercalate \" -> \" ch\n\nmain = do\n  dict <- lines <$> readFile \"unixdict.txt\"\n  showChain $ wordLadder dict \"boy\" \"man\"\n  showChain $ wordLadder dict \"girl\" \"lady\"\n  showChain $ wordLadder dict \"john\" \"jane\"\n  showChain $ wordLadder dict \"alien\" \"drool\"\n  showChain $ wordLadder dict \"child\" \"adult\"\n", "target": "import java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.stream.IntStream;\n\npublic class WordLadder {\n    private static int distance(String s1, String s2) {\n        assert s1.length() == s2.length();\n        return (int) IntStream.range(0, s1.length())\n            .filter(i -> s1.charAt(i) != s2.charAt(i))\n            .count();\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw) {\n        wordLadder(words, fw, tw, 8);\n    }\n\n    private static void wordLadder(Map<Integer, Set<String>> words, String fw, String tw, int limit) {\n        if (fw.length() != tw.length()) {\n            throw new IllegalArgumentException(\"From word and to word must have the same length\");\n        }\n\n        Set<String> ws = words.get(fw.length());\n        if (ws.contains(fw)) {\n            List<String> primeList = new ArrayList<>();\n            primeList.add(fw);\n\n            PriorityQueue<List<String>> queue = new PriorityQueue<>((chain1, chain2) -> {\n                int cmp1 = Integer.compare(chain1.size(), chain2.size());\n                if (cmp1 == 0) {\n                    String last1 = chain1.get(chain1.size() - 1);\n                    int d1 = distance(last1, tw);\n\n                    String last2 = chain2.get(chain2.size() - 1);\n                    int d2 = distance(last2, tw);\n\n                    return Integer.compare(d1, d2);\n                }\n                return cmp1;\n            });\n            queue.add(primeList);\n\n            while (queue.size() > 0) {\n                List<String> curr = queue.remove();\n                if (curr.size() > limit) {\n                    continue;\n                }\n\n                String last = curr.get(curr.size() - 1);\n                for (String word : ws) {\n                    if (distance(last, word) == 1) {\n                        if (word.equals(tw)) {\n                            curr.add(word);\n                            System.out.println(String.join(\" -> \", curr));\n                            return;\n                        }\n\n                        if (!curr.contains(word)) {\n                            List<String> cp = new ArrayList<>(curr);\n                            cp.add(word);\n                            queue.add(cp);\n                        }\n                    }\n                }\n            }\n        }\n\n        System.err.printf(\"Cannot turn `%s` into `%s`%n\", fw, tw);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Map<Integer, Set<String>> words = new HashMap<>();\n        for (String line : Files.readAllLines(Path.of(\"unixdict.txt\"))) {\n            Set<String> wl = words.computeIfAbsent(line.length(), HashSet::new);\n            wl.add(line);\n        }\n\n        wordLadder(words, \"boy\", \"man\");\n        wordLadder(words, \"girl\", \"lady\");\n        wordLadder(words, \"john\", \"jane\");\n        wordLadder(words, \"child\", \"adult\");\n        wordLadder(words, \"cat\", \"dog\");\n        wordLadder(words, \"lead\", \"gold\");\n        wordLadder(words, \"white\", \"black\");\n        wordLadder(words, \"bubble\", \"tickle\", 12);\n    }\n}\n"}
{"id": 404736, "name": "Non-transitive dice", "source": "Translate Haskell to Java: \nimport Data.List\nimport Control.Monad\n\nnewtype Dice = Dice [Int] \n\ninstance Show Dice where\n  show (Dice s) = \"(\" ++ unwords (show <$> s) ++ \")\"\n\ninstance Eq Dice where\n  d1 == d2 = d1 `compare` d2 == EQ\n  \ninstance Ord Dice where\n  Dice d1 `compare` Dice d2 = (add $ compare <$> d1 <*> d2) `compare` 0\n    where\n      add = sum . map (\\case {LT -> -1; EQ -> 0; GT -> 1})\n\ndices n = Dice <$> (nub $ sort <$> replicateM n [1..n]) \n\nnonTrans dice = filter (\\x -> last x < head x) . go\n  where\n    go 0 = []\n    go 1 = sequence [dice]\n    go n = do\n      (a:as) <- go (n-1)\n      b <- filter (< a) dice\n      return (b:a:as)\n", "target": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    private static List<List<Integer>> fourFaceCombos() {\n        List<List<Integer>> res = new ArrayList<>();\n        Set<Integer> found = new HashSet<>();\n\n        for (int i = 1; i <= 4; i++) {\n            for (int j = 1; j <= 4; j++) {\n                for (int k = 1; k <= 4; k++) {\n                    for (int l = 1; l <= 4; l++) {\n                        List<Integer> c = IntStream.of(i, j, k, l).sorted().boxed().collect(Collectors.toList());\n\n                        int key = 64 * (c.get(0) - 1) + 16 * (c.get(1) - 1) + 4 * (c.get(2) - 1) + (c.get(3) - 1);\n                        if (found.add(key)) {\n                            res.add(c);\n                        }\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    private static int cmp(List<Integer> x, List<Integer> y) {\n        int xw = 0;\n        int yw = 0;\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < 4; j++) {\n                if (x.get(i) > y.get(j)) {\n                    xw++;\n                } else if (x.get(i) < y.get(j)) {\n                    yw++;\n                }\n            }\n        }\n        return Integer.compare(xw, yw);\n    }\n\n    private static List<List<List<Integer>>> findIntransitive3(List<List<Integer>> cs) {\n        int c = cs.size();\n        List<List<List<Integer>>> res = new ArrayList<>();\n\n        for (int i = 0; i < c; i++) {\n            for (int j = 0; j < c; j++) {\n                if (cmp(cs.get(i), cs.get(j)) == -1) {\n                    for (List<Integer> kl : cs) {\n                        if (cmp(cs.get(j), kl) == -1 && cmp(kl, cs.get(i)) == -1) {\n                            res.add(List.of(cs.get(i), cs.get(j), kl));\n                        }\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    private static List<List<List<Integer>>> findIntransitive4(List<List<Integer>> cs) {\n        int c = cs.size();\n        List<List<List<Integer>>> res = new ArrayList<>();\n\n        for (int i = 0; i < c; i++) {\n            for (int j = 0; j < c; j++) {\n                if (cmp(cs.get(i), cs.get(j)) == -1) {\n                    for (int k = 0; k < cs.size(); k++) {\n                        if (cmp(cs.get(j), cs.get(k)) == -1) {\n                            for (List<Integer> ll : cs) {\n                                if (cmp(cs.get(k), ll) == -1 && cmp(ll, cs.get(i)) == -1) {\n                                    res.add(List.of(cs.get(i), cs.get(j), cs.get(k), ll));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        List<List<Integer>> combos = fourFaceCombos();\n        System.out.printf(\"Number of eligible 4-faced dice: %d%n\", combos.size());\n        System.out.println();\n\n        List<List<List<Integer>>> it3 = findIntransitive3(combos);\n        System.out.printf(\"%d ordered lists of 3 non-transitive dice found, namely:%n\", it3.size());\n        for (List<List<Integer>> a : it3) {\n            System.out.println(a);\n        }\n        System.out.println();\n\n        List<List<List<Integer>>> it4 = findIntransitive4(combos);\n        System.out.printf(\"%d ordered lists of 4 non-transitive dice found, namely:%n\", it4.size());\n        for (List<List<Integer>> a : it4) {\n            System.out.println(a);\n        }\n    }\n}\n"}
{"id": 404737, "name": "Doomsday rule", "source": "Translate Haskell to Java: import Text.Printf\n\ndata Date = Date {year :: Int, month :: Int, day :: Int}\n\ninstance Show Date where\n  show Date {year = y, month = m, day = d} =\n    printf \"%4d-%02d-%02d\" y m d\n\nleap :: Int -> Bool\nleap year =\n  year `mod` 4 == 0\n    && (year `mod` 100 /= 0 || year `mod` 400 == 0)\n\nweekday :: Date -> Int\nweekday Date {year = y, month = m, day = d} =\n  let doom = (s + t + (t `div` 4) + c_anchor) `mod` 7\n      anchor = dooms !! pred m\n      c_anchor = (5 * mod c 4 + 2) `mod` 7\n      dooms =\n        (if leap y then [4, 1] else [3, 7])\n          <> [7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n      (c, r) = y `divMod` 100\n      (s, t) = r `divMod` 12\n   in (doom + d - anchor + 7) `mod` 7\n\ndays :: [String]\ndays = words \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\"\n\ndates :: [Date]\ndates =\n  [ Date {year = 1800, month = 1, day = 6},\n    Date {year = 1875, month = 3, day = 29},\n    Date {year = 1915, month = 12, day = 7},\n    Date {year = 1970, month = 12, day = 23},\n    Date {year = 2043, month = 5, day = 14},\n    Date {year = 2077, month = 2, day = 12},\n    Date {year = 2101, month = 4, day = 2}\n  ]\n\ndateAndDay :: Date -> String\ndateAndDay d = printf \"%s: %s\" (show d) (days !! weekday d)\n\nmain :: IO ()\nmain = putStr $ unlines $ map dateAndDay dates\n", "target": "class Doom {\n    public static void main(String[] args) {\n        final Date[] dates = {\n            new Date(1800,1,6),\n            new Date(1875,3,29),\n            new Date(1915,12,7),\n            new Date(1970,12,23),\n            new Date(2043,5,14),\n            new Date(2077,2,12),\n            new Date(2101,4,2)\n        };\n        \n        for (Date d : dates)\n            System.out.println(\n                String.format(\"%s: %s\", d.format(), d.weekday()));\n    }\n}\n\nclass Date {\n    private int year, month, day;\n    \n    private static final int[] leapdoom = {4,1,7,4,2,6,4,1,5,3,7,5};\n    private static final int[] normdoom = {3,7,7,4,2,6,4,1,5,3,7,5};\n    public static final String[] weekdays = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n        \"Thursday\", \"Friday\", \"Saturday\"\n    };\n    \n    public Date(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n    \n    public boolean isLeapYear() {\n        return year%4 == 0 && (year%100 != 0 || year%400 == 0);\n    }\n    \n    public String format() {\n        return String.format(\"%02d/%02d/%04d\", month, day, year);\n    }\n    \n    public String weekday() {\n        final int c = year/100;\n        final int r = year%100;\n        final int s = r/12;\n        final int t = r%12;\n        \n        final int c_anchor = (5 * (c%4) + 2) % 7;\n        final int doom = (s + t + t/4 + c_anchor) % 7;\n        final int anchor = \n            isLeapYear() ? leapdoom[month-1] : normdoom[month-1];\n        \n        return weekdays[(doom + day - anchor + 7) % 7];\n    }\n}\n"}
{"id": 404738, "name": "Doomsday rule", "source": "Translate Haskell to Java: import Text.Printf\n\ndata Date = Date {year :: Int, month :: Int, day :: Int}\n\ninstance Show Date where\n  show Date {year = y, month = m, day = d} =\n    printf \"%4d-%02d-%02d\" y m d\n\nleap :: Int -> Bool\nleap year =\n  year `mod` 4 == 0\n    && (year `mod` 100 /= 0 || year `mod` 400 == 0)\n\nweekday :: Date -> Int\nweekday Date {year = y, month = m, day = d} =\n  let doom = (s + t + (t `div` 4) + c_anchor) `mod` 7\n      anchor = dooms !! pred m\n      c_anchor = (5 * mod c 4 + 2) `mod` 7\n      dooms =\n        (if leap y then [4, 1] else [3, 7])\n          <> [7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n      (c, r) = y `divMod` 100\n      (s, t) = r `divMod` 12\n   in (doom + d - anchor + 7) `mod` 7\n\ndays :: [String]\ndays = words \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\"\n\ndates :: [Date]\ndates =\n  [ Date {year = 1800, month = 1, day = 6},\n    Date {year = 1875, month = 3, day = 29},\n    Date {year = 1915, month = 12, day = 7},\n    Date {year = 1970, month = 12, day = 23},\n    Date {year = 2043, month = 5, day = 14},\n    Date {year = 2077, month = 2, day = 12},\n    Date {year = 2101, month = 4, day = 2}\n  ]\n\ndateAndDay :: Date -> String\ndateAndDay d = printf \"%s: %s\" (show d) (days !! weekday d)\n\nmain :: IO ()\nmain = putStr $ unlines $ map dateAndDay dates\n", "target": "class Doom {\n    public static void main(String[] args) {\n        final Date[] dates = {\n            new Date(1800,1,6),\n            new Date(1875,3,29),\n            new Date(1915,12,7),\n            new Date(1970,12,23),\n            new Date(2043,5,14),\n            new Date(2077,2,12),\n            new Date(2101,4,2)\n        };\n        \n        for (Date d : dates)\n            System.out.println(\n                String.format(\"%s: %s\", d.format(), d.weekday()));\n    }\n}\n\nclass Date {\n    private int year, month, day;\n    \n    private static final int[] leapdoom = {4,1,7,4,2,6,4,1,5,3,7,5};\n    private static final int[] normdoom = {3,7,7,4,2,6,4,1,5,3,7,5};\n    public static final String[] weekdays = {\n        \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\",\n        \"Thursday\", \"Friday\", \"Saturday\"\n    };\n    \n    public Date(int year, int month, int day) {\n        this.year = year;\n        this.month = month;\n        this.day = day;\n    }\n    \n    public boolean isLeapYear() {\n        return year%4 == 0 && (year%100 != 0 || year%400 == 0);\n    }\n    \n    public String format() {\n        return String.format(\"%02d/%02d/%04d\", month, day, year);\n    }\n    \n    public String weekday() {\n        final int c = year/100;\n        final int r = year%100;\n        final int s = r/12;\n        final int t = r%12;\n        \n        final int c_anchor = (5 * (c%4) + 2) % 7;\n        final int doom = (s + t + t/4 + c_anchor) % 7;\n        final int anchor = \n            isLeapYear() ? leapdoom[month-1] : normdoom[month-1];\n        \n        return weekdays[(doom + day - anchor + 7) % 7];\n    }\n}\n"}
{"id": 404739, "name": "Gauss-Jordan matrix inversion", "source": "Translate Haskell to Java: isMatrix xs = null xs || all ((== (length.head $ xs)).length) xs\n\nisSquareMatrix xs = null xs || all ((== (length xs)).length) xs\n\nmult:: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs). zipWith (\\vs u -> map (u*) vs) vss) uss\n\nmatI::(Num a) => Int -> [[a]]\nmatI n = [ [fromIntegral.fromEnum $ i == j | j <- [1..n]] | i <- [1..n]]\n\ninversion xs = gauss xs (matI $ length xs)\n\ngauss::[[Double]] -> [[Double]] -> [[Double]]\ngauss xs bs = map (map fromRational) $ solveGauss (toR xs) (toR bs)\n    where toR = map $ map toRational\n\nsolveGauss:: (Fractional a, Ord a) => [[a]] -> [[a]] -> [[a]]\nsolveGauss xs bs | null xs || null bs || length xs /= length bs || (not $ isSquareMatrix xs) || (not $ isMatrix bs) = []\n                 | otherwise = uncurry solveTriangle $ triangle xs bs\n\nsolveTriangle::(Fractional a,Eq a) => [[a]] -> [[a]] -> [[a]]\nsolveTriangle us _ | not.null.dropWhile ((/= 0).head) $ us = []\nsolveTriangle ([c]:as) (b:bs) = go as bs [map (/c) b]\n  where\n  val us vs ws = let u = head us in map (/u) $ zipWith (-) vs (head $ mult [tail us] ws)\n  go [] _ zs          = zs\n  go _ [] zs          = zs\n  go (x:xs) (y:ys) zs = go xs ys $ (val x y zs):zs\n\ntriangle::(Num a, Ord a) => [[a]] -> [[a]] -> ([[a]],[[a]])\ntriangle xs bs = triang ([],[]) (xs,bs)\n    where\n    triang ts (_,[]) = ts\n    triang ts ([],_) = ts\n    triang (os,ps) zs = triang (us:os,cs:ps).unzip $ [(fun tus vs, fun cs es) | (v:vs,es) <- zip uss css,let fun = zipWith (\\x y -> v*x - u*y)]\n        where ((us@(u:tus)):uss,cs:css) = bubble zs\n\nbubble::(Num a, Ord a) => ([[a]],[[a]]) -> ([[a]],[[a]])\nbubble (xs,bs) = (go xs, go bs)\n    where\n    idmax = snd.maximum.flip zip [0..].map (abs.head) $ xs\n    go ys = let (us,vs) = splitAt idmax ys in vs ++ us\n \nmain = do\n  let a = [[1, 2, 3], [4, 1, 6], [7, 8, 9]]\n  let b = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]\n  putStrLn \"inversion a =\"\n  mapM_ print $ inversion a\n  putStrLn \"\\ninversion b =\"\n  mapM_ print $ inversion b\n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 404740, "name": "Gauss-Jordan matrix inversion", "source": "Translate Haskell to Java: isMatrix xs = null xs || all ((== (length.head $ xs)).length) xs\n\nisSquareMatrix xs = null xs || all ((== (length xs)).length) xs\n\nmult:: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs). zipWith (\\vs u -> map (u*) vs) vss) uss\n\nmatI::(Num a) => Int -> [[a]]\nmatI n = [ [fromIntegral.fromEnum $ i == j | j <- [1..n]] | i <- [1..n]]\n\ninversion xs = gauss xs (matI $ length xs)\n\ngauss::[[Double]] -> [[Double]] -> [[Double]]\ngauss xs bs = map (map fromRational) $ solveGauss (toR xs) (toR bs)\n    where toR = map $ map toRational\n\nsolveGauss:: (Fractional a, Ord a) => [[a]] -> [[a]] -> [[a]]\nsolveGauss xs bs | null xs || null bs || length xs /= length bs || (not $ isSquareMatrix xs) || (not $ isMatrix bs) = []\n                 | otherwise = uncurry solveTriangle $ triangle xs bs\n\nsolveTriangle::(Fractional a,Eq a) => [[a]] -> [[a]] -> [[a]]\nsolveTriangle us _ | not.null.dropWhile ((/= 0).head) $ us = []\nsolveTriangle ([c]:as) (b:bs) = go as bs [map (/c) b]\n  where\n  val us vs ws = let u = head us in map (/u) $ zipWith (-) vs (head $ mult [tail us] ws)\n  go [] _ zs          = zs\n  go _ [] zs          = zs\n  go (x:xs) (y:ys) zs = go xs ys $ (val x y zs):zs\n\ntriangle::(Num a, Ord a) => [[a]] -> [[a]] -> ([[a]],[[a]])\ntriangle xs bs = triang ([],[]) (xs,bs)\n    where\n    triang ts (_,[]) = ts\n    triang ts ([],_) = ts\n    triang (os,ps) zs = triang (us:os,cs:ps).unzip $ [(fun tus vs, fun cs es) | (v:vs,es) <- zip uss css,let fun = zipWith (\\x y -> v*x - u*y)]\n        where ((us@(u:tus)):uss,cs:css) = bubble zs\n\nbubble::(Num a, Ord a) => ([[a]],[[a]]) -> ([[a]],[[a]])\nbubble (xs,bs) = (go xs, go bs)\n    where\n    idmax = snd.maximum.flip zip [0..].map (abs.head) $ xs\n    go ys = let (us,vs) = splitAt idmax ys in vs ++ us\n \nmain = do\n  let a = [[1, 2, 3], [4, 1, 6], [7, 8, 9]]\n  let b = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]\n  putStrLn \"inversion a =\"\n  mapM_ print $ inversion a\n  putStrLn \"\\ninversion b =\"\n  mapM_ print $ inversion b\n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 404741, "name": "Colorful numbers", "source": "Translate Haskell to Java: import Data.List ( nub ) \nimport Data.List.Split ( divvy ) \nimport Data.Char ( digitToInt ) \n\nisColourful :: Integer -> Bool\nisColourful n \n   |n >= 0 && n <= 10 = True\n   |n > 10 && n < 100 = ((length s) == (length $ nub s)) &&\n    (not $ any (\\c -> elem c \"01\") s)\n   |n >= 100 = ((length s) == (length $ nub s)) && (not $ any (\\c -> elem c \"01\") s)\n     && ((length products) == (length $ nub products))\n    where\n     s :: String\n     s = show n\n     products :: [Int]\n     products = map (\\p -> (digitToInt $ head p) * (digitToInt $ last p))\n      $ divvy 2 1 s\n\nsolution1 :: [Integer]\nsolution1 = filter isColourful [0 .. 100]\n\nsolution2 :: Integer\nsolution2 = head $ filter isColourful [98765432, 98765431 ..]\n", "target": "public class ColorfulNumbers {\n    private int count[] = new int[8];\n    private boolean used[] = new boolean[10];\n    private int largest = 0;\n\n    public static void main(String[] args) {\n        System.out.printf(\"Colorful numbers less than 100:\\n\");\n        for (int n = 0, count = 0; n < 100; ++n) {\n            if (isColorful(n))\n                System.out.printf(\"%2d%c\", n, ++count % 10 == 0 ? '\\n' : ' ');\n        }\n\n        ColorfulNumbers c = new ColorfulNumbers();\n\n        System.out.printf(\"\\n\\nLargest colorful number:\u00a0%,d\\n\", c.largest);\n\n        System.out.printf(\"\\nCount of colorful numbers by number of digits:\\n\");\n        int total = 0;\n        for (int d = 0; d < 8; ++d) {\n            System.out.printf(\"%d  \u00a0%,d\\n\", d + 1, c.count[d]);\n            total += c.count[d];\n        }\n        System.out.printf(\"\\nTotal:\u00a0%,d\\n\", total);\n    }\n\n    private ColorfulNumbers() {\n        countColorful(0, 0, 0);\n    }\n\n    public static boolean isColorful(int n) {\n        \n        if (n < 0 || n > 98765432)\n            return false;\n        int digit_count[] = new int[10];\n        int digits[] = new int[8];\n        int num_digits = 0;\n        for (int m = n; m > 0; m /= 10) {\n            int d = m % 10;\n            if (n > 9 && (d == 0 || d == 1))\n                return false;\n            if (++digit_count[d] > 1)\n                return false;\n            digits[num_digits++] = d;\n        }\n        \n        int products[] = new int[36];\n        for (int i = 0, product_count = 0; i < num_digits; ++i) {\n            for (int j = i, p = 1; j < num_digits; ++j) {\n                p *= digits[j];\n                for (int k = 0; k < product_count; ++k) {\n                    if (products[k] == p)\n                        return false;\n                }\n                products[product_count++] = p;\n            }\n        }\n        return true;\n    }\n\n    private void countColorful(int taken, int n, int digits) {\n        if (taken == 0) {\n            for (int d = 0; d < 10; ++d) {\n                used[d] = true;\n                countColorful(d < 2 ? 9 : 1, d, 1);\n                used[d] = false;\n            }\n        } else {\n            if (isColorful(n)) {\n                ++count[digits - 1];\n                if (n > largest)\n                    largest = n;\n            }\n            if (taken < 9) {\n                for (int d = 2; d < 10; ++d) {\n                    if (!used[d]) {\n                        used[d] = true;\n                        countColorful(taken + 1, n * 10 + d, digits + 1);\n                        used[d] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404742, "name": "Colorful numbers", "source": "Translate Haskell to Java: import Data.List ( nub ) \nimport Data.List.Split ( divvy ) \nimport Data.Char ( digitToInt ) \n\nisColourful :: Integer -> Bool\nisColourful n \n   |n >= 0 && n <= 10 = True\n   |n > 10 && n < 100 = ((length s) == (length $ nub s)) &&\n    (not $ any (\\c -> elem c \"01\") s)\n   |n >= 100 = ((length s) == (length $ nub s)) && (not $ any (\\c -> elem c \"01\") s)\n     && ((length products) == (length $ nub products))\n    where\n     s :: String\n     s = show n\n     products :: [Int]\n     products = map (\\p -> (digitToInt $ head p) * (digitToInt $ last p))\n      $ divvy 2 1 s\n\nsolution1 :: [Integer]\nsolution1 = filter isColourful [0 .. 100]\n\nsolution2 :: Integer\nsolution2 = head $ filter isColourful [98765432, 98765431 ..]\n", "target": "public class ColorfulNumbers {\n    private int count[] = new int[8];\n    private boolean used[] = new boolean[10];\n    private int largest = 0;\n\n    public static void main(String[] args) {\n        System.out.printf(\"Colorful numbers less than 100:\\n\");\n        for (int n = 0, count = 0; n < 100; ++n) {\n            if (isColorful(n))\n                System.out.printf(\"%2d%c\", n, ++count % 10 == 0 ? '\\n' : ' ');\n        }\n\n        ColorfulNumbers c = new ColorfulNumbers();\n\n        System.out.printf(\"\\n\\nLargest colorful number:\u00a0%,d\\n\", c.largest);\n\n        System.out.printf(\"\\nCount of colorful numbers by number of digits:\\n\");\n        int total = 0;\n        for (int d = 0; d < 8; ++d) {\n            System.out.printf(\"%d  \u00a0%,d\\n\", d + 1, c.count[d]);\n            total += c.count[d];\n        }\n        System.out.printf(\"\\nTotal:\u00a0%,d\\n\", total);\n    }\n\n    private ColorfulNumbers() {\n        countColorful(0, 0, 0);\n    }\n\n    public static boolean isColorful(int n) {\n        \n        if (n < 0 || n > 98765432)\n            return false;\n        int digit_count[] = new int[10];\n        int digits[] = new int[8];\n        int num_digits = 0;\n        for (int m = n; m > 0; m /= 10) {\n            int d = m % 10;\n            if (n > 9 && (d == 0 || d == 1))\n                return false;\n            if (++digit_count[d] > 1)\n                return false;\n            digits[num_digits++] = d;\n        }\n        \n        int products[] = new int[36];\n        for (int i = 0, product_count = 0; i < num_digits; ++i) {\n            for (int j = i, p = 1; j < num_digits; ++j) {\n                p *= digits[j];\n                for (int k = 0; k < product_count; ++k) {\n                    if (products[k] == p)\n                        return false;\n                }\n                products[product_count++] = p;\n            }\n        }\n        return true;\n    }\n\n    private void countColorful(int taken, int n, int digits) {\n        if (taken == 0) {\n            for (int d = 0; d < 10; ++d) {\n                used[d] = true;\n                countColorful(d < 2 ? 9 : 1, d, 1);\n                used[d] = false;\n            }\n        } else {\n            if (isColorful(n)) {\n                ++count[digits - 1];\n                if (n > largest)\n                    largest = n;\n            }\n            if (taken < 9) {\n                for (int d = 2; d < 10; ++d) {\n                    if (!used[d]) {\n                        used[d] = true;\n                        countColorful(taken + 1, n * 10 + d, digits + 1);\n                        used[d] = false;\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 404743, "name": "Generate random chess position", "source": "Translate Haskell to Java: \n\nmodule RandomChess\n( placeKings\n, placePawns\n, placeRemaining\n, emptyBoard\n, toFen\n, ChessBoard\n, Square (..)\n, BoardState (..)\n, getBoard\n)\nwhere\n\nimport Control.Monad.State (State, get, gets, put)\nimport Data.List (find, sortBy)\nimport System.Random (Random, RandomGen, StdGen, random, randomR)\n\ntype Pos = (Char, Int)\n\ntype ChessBoard = [(Square, Pos)]\n\ndata PieceRank  = King | Queen | Rook | Bishop | Knight | Pawn\n  deriving (Enum, Bounded, Show, Eq, Ord)\ndata PieceColor = Black | White\n  deriving (Enum, Bounded, Show, Eq, Ord)\n\ndata Square = ChessPiece PieceRank PieceColor | EmptySquare\n  deriving (Eq, Ord)\n\ntype PieceCount = [(Square, Int)]\n\ndata BoardState = BoardState { board :: ChessBoard , generator :: StdGen }\n\ninstance Show Square where\n  show (ChessPiece King   Black) = \"\u265a\"\n  show (ChessPiece Queen  Black) = \"\u265b\"\n  show (ChessPiece Rook   Black) = \"\u265c\"\n  show (ChessPiece Bishop Black) = \"\u265d\"\n  show (ChessPiece Knight Black) = \"\u265e\"\n  show (ChessPiece Pawn   Black) = \"\u265f\"\n  show (ChessPiece King   White) = \"\u2654\"\n  show (ChessPiece Queen  White) = \"\u2655\"\n  show (ChessPiece Rook   White) = \"\u2656\"\n  show (ChessPiece Bishop White) = \"\u2657\"\n  show (ChessPiece Knight White) = \"\u2658\"\n  show (ChessPiece Pawn   White) = \"\u2659\"\n  show EmptySquare               = \" \"\n\ninstance Random PieceRank where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of\n    (x, g'') -> (toEnum x, g'')\n  random = randomR (minBound, maxBound)\n\ninstance Random PieceColor where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of\n    (x, g'') -> (toEnum x, g'')\n  random = randomR (minBound, maxBound)\n\nfullBoard :: PieceCount\nfullBoard =\n  [ (ChessPiece King Black  , 1)\n  , (ChessPiece Queen Black , 1)\n  , (ChessPiece Rook Black  , 2)\n  , (ChessPiece Bishop Black, 2)\n  , (ChessPiece Knight Black, 2)\n  , (ChessPiece Pawn Black  , 8)\n  , (ChessPiece King White  , 1)\n  , (ChessPiece Queen White , 1)\n  , (ChessPiece Rook White  , 2)\n  , (ChessPiece Bishop White, 2)\n  , (ChessPiece Knight White, 2)\n  , (ChessPiece Pawn White  , 8)\n  , (EmptySquare            , 32)\n  ]\n\nemptyBoard :: ChessBoard\nemptyBoard = fmap (EmptySquare,) . (,) <$> ['a'..'h'] <*> [1..8]\n\nreplaceSquareByPos :: (Square, Pos) -> ChessBoard -> ChessBoard\nreplaceSquareByPos e@(_, p) = fmap (\\x -> if p == snd x then e else x)\n\nisPosOccupied :: Pos -> ChessBoard -> Bool\nisPosOccupied p = occupied . find (\\x -> p == snd x)\n where\n  occupied (Just (EmptySquare, _)) = False\n  occupied _                       = True\n\nisAdjacent :: Pos -> Pos -> Bool\nisAdjacent (x1, y1) (x2, y2) =\n  let upOrDown    = (pred y1 == y2 || succ y1 == y2)\n      leftOrRight = (pred x1 == x2 || succ x1 == x2)\n  in  (x2 == x1 && upOrDown)\n        || (pred x1 == x2 && upOrDown)\n        || (succ x1 == x2 && upOrDown)\n        || (leftOrRight && y1 == y2)\n\nfen :: Square -> String\nfen (ChessPiece King   Black) = \"k\"\nfen (ChessPiece Queen  Black) = \"q\"\nfen (ChessPiece Rook   Black) = \"r\"\nfen (ChessPiece Bishop Black) = \"b\"\nfen (ChessPiece Knight Black) = \"n\"\nfen (ChessPiece Pawn   Black) = \"p\"\nfen (ChessPiece King   White) = \"K\"\nfen (ChessPiece Queen  White) = \"Q\"\nfen (ChessPiece Rook   White) = \"R\"\nfen (ChessPiece Bishop White) = \"B\"\nfen (ChessPiece Knight White) = \"N\"\nfen (ChessPiece Pawn   White) = \"P\"\n\nboardSort :: (Square, Pos) -> (Square, Pos) -> Ordering\nboardSort (_, (x1, y1)) (_, (x2, y2)) | y1 < y2  = GT\n                                      | y1 > y2  = LT\n                                      | y1 == y2 = compare x1 x2\n\ntoFen :: ChessBoard -> String\ntoFen [] = \" w - - 0 1\" <> []\ntoFen b = scanRow (fst <$> take 8 b) 0\n  where\n    scanRow [] 0               = nextRow\n    scanRow [] n               = show n <> nextRow\n    scanRow (EmptySquare:xs) n = scanRow xs (succ n)\n    scanRow (x:xs) 0           = nextPiece x xs\n    scanRow (x:xs) n           = show n <> nextPiece x xs\n    nextRow = \"/\" <> toFen (drop 8 b)\n    nextPiece x xs = fen x <> scanRow xs 0\n\n\nwithStateGen :: (StdGen -> (a, StdGen)) -> State BoardState a\nwithStateGen f = do\n  currentState <- get\n  let gen1 = generator currentState\n  let (x, gen2) = f gen1\n  put (currentState {generator = gen2})\n  pure x\n\nrandomPos :: State BoardState Pos\nrandomPos = do\n  boardState <- gets board\n  chr <- withStateGen (randomR ('a', 'h'))\n  num <- withStateGen (randomR (1, 8))\n  let pos = (chr, num)\n  if isPosOccupied pos boardState then\n    randomPos\n  else\n    pure pos\n\nrandomPiece :: State BoardState Square\nrandomPiece = ChessPiece <$> withStateGen random <*> withStateGen random\n\nplaceKings :: State BoardState ()\nplaceKings = do\n  currentState <- get\n  p1 <- randomPos\n  p2 <- randomPos\n  if p1 `isAdjacent` p2 || p1 == p2\n    then placeKings\n    else do\n      let updatedBoard = replaceSquareByPos (ChessPiece King White, p1) $\n            replaceSquareByPos (ChessPiece King Black, p2) (board currentState)\n      put currentState { board = updatedBoard }\n\nplacePawns :: State BoardState ()\nplacePawns = withStateGen (randomR (1, 16)) >>= go\n  where\n    go :: Int -> State BoardState ()\n    go 0 = pure ()\n    go n = do\n      currentState <- get\n      pos <- randomPos\n      color <- withStateGen random\n      let pawn = ChessPiece Pawn color\n      let currentBoard = board currentState\n      if promoted color == snd pos || isPosOccupied pos currentBoard ||\n                           enpassant color == snd pos || firstPos color == snd pos\n        then go n\n        else do\n          put currentState { board = replaceSquareByPos (pawn, pos) currentBoard }\n          go $ pred n\n    promoted White = 8\n    promoted Black = 1\n    enpassant White = 5\n    enpassant Black = 4\n    firstPos White = 1\n    firstPos Black = 8\n\nplaceRemaining :: State BoardState ()\nplaceRemaining =\n  withStateGen (randomR (5, sum $ fmap snd remaining)) >>= go remaining\n  where\n    remaining = filter (\\case\n                         (ChessPiece King _, _) -> False\n                         (ChessPiece Pawn _, _) -> False\n                         (EmptySquare, _) -> False\n                         _ -> True)\n                        fullBoard\n\n    go :: PieceCount -> Int -> State BoardState ()\n    go _ 0 = pure ()\n    go remaining n = do\n      currentState <- get\n      let currentBoard = board currentState\n      position <- randomPos\n      piece <- randomPiece\n      if not (isPermitted piece) || isPosOccupied position currentBoard\n        then go remaining n\n        else do\n          let updatedBoard = replaceSquareByPos (piece, position) currentBoard\n          put currentState { board = updatedBoard }\n          go (consume piece remaining) (pred n)\n      where\n        isPermitted p =\n          case find ((==p) . fst) remaining of\n            Just (_, count) -> count > 0\n            Nothing         -> False\n        consume p'' = fmap (\\(p, c) -> if p == p'' then (p, pred c) else (p, c))\n\ngetBoard :: State BoardState ChessBoard\ngetBoard = gets (sortBy boardSort . board)\n", "target": "import static java.lang.Math.abs;\nimport java.util.Random;\n\npublic class Fen {\n    static Random rand = new Random();\n\n    public static void main(String[] args) {\n        System.out.println(createFen());\n    }\n\n    static String createFen() {\n        char[][] grid = new char[8][8];\n\n        placeKings(grid);\n        placePieces(grid, \"PPPPPPPP\", true);\n        placePieces(grid, \"pppppppp\", true);\n        placePieces(grid, \"RNBQBNR\", false);\n        placePieces(grid, \"rnbqbnr\", false);\n\n        return toFen(grid);\n    }\n\n    static void placeKings(char[][] grid) {\n        int r1, c1, r2, c2;\n        while (true) {\n            r1 = rand.nextInt(8);\n            c1 = rand.nextInt(8);\n            r2 = rand.nextInt(8);\n            c2 = rand.nextInt(8);\n            if (r1 != r2 && abs(r1 - r2) > 1 && abs(c1 - c2) > 1)\n                break;\n        }\n        grid[r1][c1] = 'K';\n        grid[r2][c2] = 'k';\n    }\n\n    static void placePieces(char[][] grid, String pieces, boolean isPawn) {\n        int numToPlace = rand.nextInt(pieces.length());\n        for (int n = 0; n < numToPlace; n++) {\n            int r, c;\n            do {\n                r = rand.nextInt(8);\n                c = rand.nextInt(8);\n\n            } while (grid[r][c] != 0 || (isPawn && (r == 7 || r == 0)));\n\n            grid[r][c] = pieces.charAt(n);\n        }\n    }\n\n    static String toFen(char[][] grid) {\n        StringBuilder fen = new StringBuilder();\n        int countEmpty = 0;\n        for (int r = 0; r < 8; r++) {\n            for (int c = 0; c < 8; c++) {\n                char ch = grid[r][c];\n                System.out.printf(\"%2c \", ch == 0 ? '.' : ch);\n                if (ch == 0) {\n                    countEmpty++;\n                } else {\n                    if (countEmpty > 0) {\n                        fen.append(countEmpty);\n                        countEmpty = 0;\n                    }\n                    fen.append(ch);\n                }\n            }\n            if (countEmpty > 0) {\n                fen.append(countEmpty);\n                countEmpty = 0;\n            }\n            fen.append(\"/\");\n            System.out.println();\n        }\n        return fen.append(\" w - - 0 1\").toString();\n    }\n}\n"}
{"id": 404744, "name": "Sorting algorithms_Tree sort on a linked list", "source": "Translate Haskell to Java: \nimport Data.Foldable\n\n\ndata DList a = End | Elem { prev :: DList a\n                           , elt :: a\n                           , next :: DList a }\n\nmkDList :: Foldable t => t a -> DList a\nmkDList = go End . toList\n  where go _    []     = End\n        go prev (x:xs) = current\n          where current = Elem prev x next\n                next    = go current xs\n\ninstance Foldable DList where\n  foldMap f End = mempty\n  foldMap f dl = f (elt dl) <> foldMap f (next dl)\n\nsortDL :: Ord a => DList a -> DList a\nsortDL = mkDList . mkTree\n\n\ndata BTree a = Empty | Node { left  :: BTree a\n                            , node  :: a\n                            , right :: BTree a }\n  deriving (Show, Foldable)\n\naddTree Empty x = Node Empty x Empty\naddTree (Node l a g) x =\n  case compare x a of\n    LT -> Node (addTree l x) a g\n    _  -> Node l a (addTree g x)\n\nmkTree :: (Foldable t, Ord a) => t a -> BTree a\nmkTree = foldl addTree Empty\n\ntreeSort :: (Foldable t, Ord a) => t a -> [a]\ntreeSort = toList . mkTree\n", "target": "\nimport java.util.*;\n\npublic class TreeSortTest {\n    public static void main(String[] args) {\n        test1();\n        System.out.println();\n        test2();\n    }\n\n    \n    private static void test1() {\n        LinkedList<Integer> list = new LinkedList<>();\n        Random r = new Random();\n        for (int i = 0; i < 16; ++i)\n            list.add(Integer.valueOf(r.nextInt(100)));\n        System.out.println(\"before sort: \" + list);\n        list.treeSort();\n        System.out.println(\" after sort: \" + list);\n    }\n\n    \n    private static void test2() {\n        LinkedList<String> list = new LinkedList<>();\n        String[] strings = { \"one\", \"two\", \"three\", \"four\", \"five\",\n            \"six\", \"seven\", \"eight\", \"nine\", \"ten\"};\n        for (String str : strings)\n            list.add(str);\n        System.out.println(\"before sort: \" + list);\n        list.treeSort();\n        System.out.println(\" after sort: \" + list);\n    }\n}\n"}
{"id": 404745, "name": "Sorting algorithms_Tree sort on a linked list", "source": "Translate Haskell to Java: \nimport Data.Foldable\n\n\ndata DList a = End | Elem { prev :: DList a\n                           , elt :: a\n                           , next :: DList a }\n\nmkDList :: Foldable t => t a -> DList a\nmkDList = go End . toList\n  where go _    []     = End\n        go prev (x:xs) = current\n          where current = Elem prev x next\n                next    = go current xs\n\ninstance Foldable DList where\n  foldMap f End = mempty\n  foldMap f dl = f (elt dl) <> foldMap f (next dl)\n\nsortDL :: Ord a => DList a -> DList a\nsortDL = mkDList . mkTree\n\n\ndata BTree a = Empty | Node { left  :: BTree a\n                            , node  :: a\n                            , right :: BTree a }\n  deriving (Show, Foldable)\n\naddTree Empty x = Node Empty x Empty\naddTree (Node l a g) x =\n  case compare x a of\n    LT -> Node (addTree l x) a g\n    _  -> Node l a (addTree g x)\n\nmkTree :: (Foldable t, Ord a) => t a -> BTree a\nmkTree = foldl addTree Empty\n\ntreeSort :: (Foldable t, Ord a) => t a -> [a]\ntreeSort = toList . mkTree\n", "target": "\nimport java.util.*;\n\npublic class TreeSortTest {\n    public static void main(String[] args) {\n        test1();\n        System.out.println();\n        test2();\n    }\n\n    \n    private static void test1() {\n        LinkedList<Integer> list = new LinkedList<>();\n        Random r = new Random();\n        for (int i = 0; i < 16; ++i)\n            list.add(Integer.valueOf(r.nextInt(100)));\n        System.out.println(\"before sort: \" + list);\n        list.treeSort();\n        System.out.println(\" after sort: \" + list);\n    }\n\n    \n    private static void test2() {\n        LinkedList<String> list = new LinkedList<>();\n        String[] strings = { \"one\", \"two\", \"three\", \"four\", \"five\",\n            \"six\", \"seven\", \"eight\", \"nine\", \"ten\"};\n        for (String str : strings)\n            list.add(str);\n        System.out.println(\"before sort: \" + list);\n        list.treeSort();\n        System.out.println(\" after sort: \" + list);\n    }\n}\n"}
{"id": 404746, "name": "Four is the number of letters in the ...", "source": "Translate Haskell to Java: import Data.Char\n\nsentence = start ++ foldMap add (zip [2..] $ tail $ words sentence)\n  where\n    start = \"Four is the number of letters in the first word of this sentence, \"\n    add (i, w) = unwords [spellInteger (alphaLength w), \"in the\", spellOrdinal i ++ \", \"]\n\nalphaLength w = fromIntegral $ length $ filter isAlpha w\n\nmain = mapM_ (putStrLn . say) [1000,10000,100000,1000000]\n  where\n    ws = words sentence\n    say n =\n      let (a, w:_) = splitAt (n-1) ws\n      in \"The \" ++ spellOrdinal n ++ \" word is \\\"\" ++ w ++ \"\\\" which has \" ++\n         spellInteger (alphaLength  w) ++ \" letters. The sentence length is \" ++\n         show (length $ unwords a) ++ \" chars.\"\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class FourIsTheNumberOfLetters {\n\n    public static void main(String[] args) {\n        String [] words = neverEndingSentence(201);\n        System.out.printf(\"Display the first 201 numbers in the sequence:%n%3d: \", 1);\n        for ( int i = 0 ; i < words.length ; i++ ) {\n            System.out.printf(\"%2d \", numberOfLetters(words[i]));\n            if ( (i+1) % 25 == 0 ) {\n                System.out.printf(\"%n%3d: \", i+2);\n            }\n        }\n        System.out.printf(\"%nTotal number of characters in the sentence is %d%n\", characterCount(words));\n        for ( int i = 3 ; i <= 7 ; i++ ) {\n            int index = (int) Math.pow(10, i);\n            words = neverEndingSentence(index);\n            String last = words[words.length-1].replace(\",\", \"\");\n            System.out.printf(\"Number of letters of the %s word is %d. The word is \\\"%s\\\".  The sentence length is\u00a0%,d characters.%n\", toOrdinal(index), numberOfLetters(last), last, characterCount(words));\n        }\n    }\n    \n    @SuppressWarnings(\"unused\")\n    private static void displaySentence(String[] words, int lineLength) {\n        int currentLength = 0;\n        for ( String word : words ) {\n            if ( word.length() + currentLength > lineLength ) {\n                String first = word.substring(0, lineLength-currentLength);\n                String second = word.substring(lineLength-currentLength);\n                System.out.println(first);\n                System.out.print(second);\n                currentLength = second.length();\n            }\n            else {\n                System.out.print(word);\n                currentLength += word.length();\n            }\n            if ( currentLength == lineLength ) {\n                System.out.println();\n                currentLength = 0;\n            }\n            System.out.print(\" \");\n            currentLength++;\n            if ( currentLength == lineLength ) {\n                System.out.println();\n                currentLength = 0;\n            }\n        }\n        System.out.println();\n    }\n    \n    private static int numberOfLetters(String word) {\n        return word.replace(\",\",\"\").replace(\"-\",\"\").length();\n    }\n    \n    private static long characterCount(String[] words) {\n        int characterCount = 0;\n        for ( int i = 0 ; i < words.length ; i++ ) {\n            characterCount += words[i].length() + 1;\n        }        \n        \n        characterCount--;\n        return characterCount;\n    }\n    \n    private static String[] startSentence = new String[] {\"Four\", \"is\", \"the\", \"number\", \"of\", \"letters\", \"in\", \"the\", \"first\", \"word\", \"of\", \"this\", \"sentence,\"};\n    \n    private static String[] neverEndingSentence(int wordCount) {\n        String[] words = new String[wordCount];\n        int index;\n        for ( index = 0 ; index < startSentence.length && index < wordCount ; index++ ) {\n            words[index] = startSentence[index];\n        }\n        int sentencePosition = 1;\n        while ( index < wordCount ) {\n            \n            \n            sentencePosition++;\n            String word = words[sentencePosition-1];\n            for ( String wordLoop : numToString(numberOfLetters(word)).split(\" \") ) {\n                words[index] = wordLoop;\n                index++;\n                if ( index == wordCount ) {\n                    break;\n                }\n            }\n            \n            words[index] = \"in\";\n            index++;\n            if ( index == wordCount ) {\n                break;\n            }\n            \n            words[index] = \"the\";\n            index++;\n            if ( index == wordCount ) {\n                break;\n            }\n            \n            for ( String wordLoop : (toOrdinal(sentencePosition) + \",\").split(\" \") ) {\n                words[index] = wordLoop;\n                index++;\n                if ( index == wordCount ) {\n                    break;\n                }\n            }\n        }\n        return words;\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String numToString(long n) {\n        return numToStringHelper(n);\n    }\n    \n    private static final String numToStringHelper(long n) {\n        if ( n < 0 ) {\n            return \"negative \" + numToStringHelper(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \"-\" + numToStringHelper(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToStringHelper(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToStringHelper(n % factor ) : \"\");\n    }\n\n    private static Map<String,String> ordinalMap = new HashMap<>();\n    static {\n        ordinalMap.put(\"one\", \"first\");\n        ordinalMap.put(\"two\", \"second\");\n        ordinalMap.put(\"three\", \"third\");\n        ordinalMap.put(\"five\", \"fifth\");\n        ordinalMap.put(\"eight\", \"eighth\");\n        ordinalMap.put(\"nine\", \"ninth\");\n        ordinalMap.put(\"twelve\", \"twelfth\");\n    }\n    \n    private static String toOrdinal(long n) {\n        String spelling = numToString(n);\n        String[] split = spelling.split(\" \");\n        String last = split[split.length - 1];\n        String replace = \"\";\n        if ( last.contains(\"-\") ) {\n            String[] lastSplit = last.split(\"-\");\n            String lastWithDash = lastSplit[1];\n            String lastReplace = \"\";\n            if ( ordinalMap.containsKey(lastWithDash) ) {\n                lastReplace = ordinalMap.get(lastWithDash);\n            }\n            else if ( lastWithDash.endsWith(\"y\") ) {\n                lastReplace = lastWithDash.substring(0, lastWithDash.length() - 1) + \"ieth\";\n            }\n            else {\n                lastReplace = lastWithDash + \"th\";\n            }\n            replace = lastSplit[0] + \"-\" + lastReplace;\n        }\n        else {\n            if ( ordinalMap.containsKey(last) ) {\n                replace = ordinalMap.get(last);\n            }\n            else if ( last.endsWith(\"y\") ) {\n                replace = last.substring(0, last.length() - 1) + \"ieth\";\n            }\n            else {\n                replace = last + \"th\";\n            }\n        }\n        split[split.length - 1] = replace;\n        return String.join(\" \", split);\n    }\n    \n}\n"}
{"id": 404747, "name": "Fibonacci matrix-exponentiation", "source": "Translate Haskell to Java: import System.CPUTime (getCPUTime)\nimport Data.List\n\nmain = do\n    startTime <- getCPUTime\n    mapM_ (putStrLn.formatAns).take 7.iterate (*10) $ 10\n    mapM_ (putStrLn.seeFib) [16,32]\n    finishTime <- getCPUTime\n    putStrLn $ \"Took \" ++ (took startTime finishTime)\n\ntook t = fromChrono.chrono t\n\nfromChrono :: (Integer,Integer,Integer) -> String\nfromChrono (m,s,ms) = show m ++ \"m\" ++ show s ++ \".\" ++ show ms ++ \"s\"\n\nchrono :: Integer -> Integer -> (Integer,Integer,Integer)\nchrono start end = (m,s,ms)\n    where\n    tera = 1000000000000\n    fdt = fromIntegral (end - start) / tera\n    dt = floor fdt\n    (m,s) = quotRem dt 60 \n    ms = round $ fromIntegral (round (fdt - (fromIntegral dt))*1000) / 1000\n\nbagOf :: Int -> [a] -> [[a]]\nbagOf _ [] = []\nbagOf n xs = let (us,vs) = splitAt n xs in us : bagOf n vs\n\nformatIntegral :: Show a => String -> a -> String\nformatIntegral sep = reverse.intercalate sep.bagOf 3.reverse.show\n \nformatAns :: Integer -> String\nformatAns p = start ++ go x\n    where\n    start = \"Fibonacci(\"++ (formatIntegral \"_\" p) ++ \") = \"\n    x = fib p\n    tenPow20 = 10^20\n    tenPow40 = tenPow20^2\n    go u | u <= tenPow20 = show u\n    go u | u <= tenPow40 = let (us,vs) = splitAt 20 $ show u in us ++ \" ... \" ++ vs\n    go u = (take 20 $ show u) ++ \" ... \" ++ (show . rem u $ 10^20)\n\nseeFib :: Integer -> String\nseeFib n = start ++ xs ++ \" ... \" ++ (show . rem x $ 10^20)\n    where\n    start = \"Fibonacci(2^\" ++ (show n) ++\") = \"\n    x = fib (2^n)\n    xs = take 20 $ show x\n \nfib :: Integer -> Integer\nfib 0 = 0 \n\nfib n = (last . head . unMat) (Mat [[1, 1], [1, 0]] ^ n)\n \nmult :: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs) . zipWith (flip (map . (*))) vss) uss\n \nnewtype Mat a = Mat\n  { unMat :: [[a]]\n  } deriving (Eq,Show)\n \ninstance Num a =>  Num (Mat a) where\n  negate xm = Mat $ map (map negate) $ unMat xm\n  xm + ym = Mat $ zipWith (zipWith (+)) (unMat xm) (unMat ym)\n  xm * ym =  Mat $ mult (unMat xm) (unMat ym)\n  fromInteger n = Mat [[fromInteger n]]\n  abs = undefined\n  signum = undefined\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class FibonacciMatrixExponentiation {\n\n    public static void main(String[] args) {\n        BigInteger mod = BigInteger.TEN.pow(20);\n        for ( int exp : Arrays.asList(32, 64) ) {\n            System.out.printf(\"Last 20 digits of fib(2^%d) = %s%n\", exp, fibMod(BigInteger.valueOf(2).pow(exp), mod));\n        }\n        \n        for ( int i = 1 ; i <= 7 ; i++ ) {\n            BigInteger n = BigInteger.TEN.pow(i);\n            System.out.printf(\"fib(%,d) = %s%n\", n, displayFib(fib(n)));\n        }\n    }\n    \n    private static String displayFib(BigInteger fib) {\n        String s = fib.toString();\n        if ( s.length() <= 40 ) {\n            return s;\n        }\n        return s.substring(0, 20) + \" ... \" + s.subSequence(s.length()-20, s.length());\n    }\n\n    \n    private static BigInteger fib(BigInteger k) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase));\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes));\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes));\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase));\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase));\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase));\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes;\n    }\n\n    \n    private static BigInteger fibMod(BigInteger k, BigInteger mod) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase)).mod(mod);\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes)).mod(mod);\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes)).mod(mod);\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase)).mod(mod);\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase)).mod(mod);\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase)).mod(mod);\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes.mod(mod);\n    }\n\n}\n"}
{"id": 404748, "name": "Fibonacci matrix-exponentiation", "source": "Translate Haskell to Java: import System.CPUTime (getCPUTime)\nimport Data.List\n\nmain = do\n    startTime <- getCPUTime\n    mapM_ (putStrLn.formatAns).take 7.iterate (*10) $ 10\n    mapM_ (putStrLn.seeFib) [16,32]\n    finishTime <- getCPUTime\n    putStrLn $ \"Took \" ++ (took startTime finishTime)\n\ntook t = fromChrono.chrono t\n\nfromChrono :: (Integer,Integer,Integer) -> String\nfromChrono (m,s,ms) = show m ++ \"m\" ++ show s ++ \".\" ++ show ms ++ \"s\"\n\nchrono :: Integer -> Integer -> (Integer,Integer,Integer)\nchrono start end = (m,s,ms)\n    where\n    tera = 1000000000000\n    fdt = fromIntegral (end - start) / tera\n    dt = floor fdt\n    (m,s) = quotRem dt 60 \n    ms = round $ fromIntegral (round (fdt - (fromIntegral dt))*1000) / 1000\n\nbagOf :: Int -> [a] -> [[a]]\nbagOf _ [] = []\nbagOf n xs = let (us,vs) = splitAt n xs in us : bagOf n vs\n\nformatIntegral :: Show a => String -> a -> String\nformatIntegral sep = reverse.intercalate sep.bagOf 3.reverse.show\n \nformatAns :: Integer -> String\nformatAns p = start ++ go x\n    where\n    start = \"Fibonacci(\"++ (formatIntegral \"_\" p) ++ \") = \"\n    x = fib p\n    tenPow20 = 10^20\n    tenPow40 = tenPow20^2\n    go u | u <= tenPow20 = show u\n    go u | u <= tenPow40 = let (us,vs) = splitAt 20 $ show u in us ++ \" ... \" ++ vs\n    go u = (take 20 $ show u) ++ \" ... \" ++ (show . rem u $ 10^20)\n\nseeFib :: Integer -> String\nseeFib n = start ++ xs ++ \" ... \" ++ (show . rem x $ 10^20)\n    where\n    start = \"Fibonacci(2^\" ++ (show n) ++\") = \"\n    x = fib (2^n)\n    xs = take 20 $ show x\n \nfib :: Integer -> Integer\nfib 0 = 0 \n\nfib n = (last . head . unMat) (Mat [[1, 1], [1, 0]] ^ n)\n \nmult :: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs) . zipWith (flip (map . (*))) vss) uss\n \nnewtype Mat a = Mat\n  { unMat :: [[a]]\n  } deriving (Eq,Show)\n \ninstance Num a =>  Num (Mat a) where\n  negate xm = Mat $ map (map negate) $ unMat xm\n  xm + ym = Mat $ zipWith (zipWith (+)) (unMat xm) (unMat ym)\n  xm * ym =  Mat $ mult (unMat xm) (unMat ym)\n  fromInteger n = Mat [[fromInteger n]]\n  abs = undefined\n  signum = undefined\n", "target": "import java.math.BigInteger;\nimport java.util.Arrays;\n\npublic class FibonacciMatrixExponentiation {\n\n    public static void main(String[] args) {\n        BigInteger mod = BigInteger.TEN.pow(20);\n        for ( int exp : Arrays.asList(32, 64) ) {\n            System.out.printf(\"Last 20 digits of fib(2^%d) = %s%n\", exp, fibMod(BigInteger.valueOf(2).pow(exp), mod));\n        }\n        \n        for ( int i = 1 ; i <= 7 ; i++ ) {\n            BigInteger n = BigInteger.TEN.pow(i);\n            System.out.printf(\"fib(%,d) = %s%n\", n, displayFib(fib(n)));\n        }\n    }\n    \n    private static String displayFib(BigInteger fib) {\n        String s = fib.toString();\n        if ( s.length() <= 40 ) {\n            return s;\n        }\n        return s.substring(0, 20) + \" ... \" + s.subSequence(s.length()-20, s.length());\n    }\n\n    \n    private static BigInteger fib(BigInteger k) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase));\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes));\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes));\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase));\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase));\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase));\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes;\n    }\n\n    \n    private static BigInteger fibMod(BigInteger k, BigInteger mod) {\n        BigInteger aRes = BigInteger.ZERO;\n        BigInteger bRes = BigInteger.ONE;\n        BigInteger cRes = BigInteger.ONE;\n        BigInteger aBase = BigInteger.ZERO;\n        BigInteger bBase = BigInteger.ONE;\n        BigInteger cBase = BigInteger.ONE;\n        while ( k.compareTo(BigInteger.ZERO) > 0 ) {\n            if ( k.mod(BigInteger.valueOf(2)).compareTo(BigInteger.ONE) == 0 ) {\n                BigInteger temp1 = aRes.multiply(aBase).add(bRes.multiply(bBase)).mod(mod);\n                BigInteger temp2 = aBase.multiply(bRes).add(bBase.multiply(cRes)).mod(mod);\n                BigInteger temp3 = bBase.multiply(bRes).add(cBase.multiply(cRes)).mod(mod);\n                aRes = temp1;\n                bRes = temp2;\n                cRes = temp3;\n            }\n            k = k.shiftRight(1);\n            BigInteger temp1 = aBase.multiply(aBase).add(bBase.multiply(bBase)).mod(mod);\n            BigInteger temp2 = aBase.multiply(bBase).add(bBase.multiply(cBase)).mod(mod);\n            BigInteger temp3 = bBase.multiply(bBase).add(cBase.multiply(cBase)).mod(mod);\n            aBase = temp1;\n            bBase = temp2;\n            cBase = temp3;\n        }\n        return aRes.mod(mod);\n    }\n\n}\n"}
{"id": 404749, "name": "Minimal steps down to 1", "source": "Translate Haskell to Java: \nimport Data.List\nimport Data.Ord\nimport Data.Function (on)\n\n\n\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving Functor\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Integral a => Memo a\nnats = Node 0 ((+1).(*2) <$> nats) ((*2).(+1) <$> nats)\n\nmemoize :: Integral a => (a -> b) -> (a -> b)\nmemoize f = memo (f <$> nats)\n\n\n\ndata Step = Div Int | Sub Int\n  deriving Show\n\nrun :: Int -> Step -> [(Step, Int)]\nrun n s = case s of\n  Sub i | n > i -> [(s, n - i)]\n  Div d | n `mod` d == 0 -> [(s, n `div` d)]\n  _ -> []\n\nminSteps :: [Step] -> Int -> (Int, [Step])\nminSteps steps = go\n  where\n    go = memoize goM\n    \n    goM 1 = (0, [])\n    goM n = minimumBy (comparing fst) $ do\n      (s, k) <- steps >>= run n\n      let (m, ss) = go k\n      return (m+1, s:ss)\n", "target": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class MinimalStepsDownToOne {\n\n    public static void main(String[] args) {\n        runTasks(getFunctions1());\n        runTasks(getFunctions2());\n        runTasks(getFunctions3());\n    }\n    \n    private static void runTasks(List<Function> functions) {\n        Map<Integer,List<String>> minPath = getInitialMap(functions, 5);\n\n        \n        int max = 10;\n        populateMap(minPath, functions, max);\n        System.out.printf(\"%nWith functions:  %s%n\", functions);\n        System.out.printf(\"  Minimum steps to 1:%n\");\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int steps = minPath.get(n).size();\n            System.out.printf(\"    %2d: %d step%1s: %s%n\", n, steps, steps == 1 ? \"\" : \"s\", minPath.get(n));\n        }\n        \n        \n        displayMaxMin(minPath, functions, 2000);\n\n        \n        displayMaxMin(minPath, functions, 20000);\n\n        \n        displayMaxMin(minPath, functions, 100000);\n    }\n    \n    private static void displayMaxMin(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        populateMap(minPath, functions, max);\n        List<Integer> maxIntegers = getMaxMin(minPath, max);\n        int maxSteps = maxIntegers.remove(0);\n        int numCount = maxIntegers.size();\n        System.out.printf(\"  There %s %d number%s in the range 1-%d that have maximum 'minimal steps' of %d:%n    %s%n\", numCount == 1 ? \"is\" : \"are\", numCount, numCount == 1 ? \"\" : \"s\", max, maxSteps, maxIntegers);\n        \n    }\n    \n    private static List<Integer> getMaxMin(Map<Integer,List<String>> minPath, int max) {\n        int maxSteps = Integer.MIN_VALUE;\n        List<Integer> maxIntegers = new ArrayList<Integer>();\n        for ( int n = 2 ; n <= max ; n++ ) {\n            int len = minPath.get(n).size();\n            if ( len > maxSteps ) {\n                maxSteps = len;\n                maxIntegers.clear();\n                maxIntegers.add(n);\n            }\n            else if ( len == maxSteps ) {\n                maxIntegers.add(n);\n            }\n        }\n        maxIntegers.add(0, maxSteps);\n        return maxIntegers;\n    }\n\n    private static void populateMap(Map<Integer,List<String>> minPath, List<Function> functions, int max) {\n        for ( int n = 2 ; n <= max ; n++ ) {\n            if ( minPath.containsKey(n) ) {\n                continue;\n            }\n            Function minFunction = null;\n            int minSteps = Integer.MAX_VALUE;\n            for ( Function f : functions ) {\n                if ( f.actionOk(n) ) {\n                    int result = f.action(n);\n                    int steps = 1 + minPath.get(result).size();\n                    if ( steps < minSteps ) {\n                        minFunction = f;\n                        minSteps = steps;\n                    }\n                }\n            }\n            int result = minFunction.action(n);\n            List<String> path = new ArrayList<String>();\n            path.add(minFunction.toString(n));\n            path.addAll(minPath.get(result));\n            minPath.put(n, path);\n        }\n        \n    }\n\n    private static Map<Integer,List<String>> getInitialMap(List<Function> functions, int max) {\n        Map<Integer,List<String>> minPath = new HashMap<>();\n        for ( int i = 2 ; i <= max ; i++ ) {\n            for ( Function f : functions ) {\n                if ( f.actionOk(i) ) {\n                    int result = f.action(i);\n                    if ( result == 1 ) {\n                        List<String> path = new ArrayList<String>();\n                        path.add(f.toString(i));\n                        minPath.put(i, path);\n                    }\n                }\n            }\n        }\n        return minPath;\n    }\n\n    private static List<Function> getFunctions3() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide2Function());\n        functions.add(new Divide3Function());\n        functions.add(new Subtract2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions2() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract2Function());\n        return functions;\n    }\n\n    private static List<Function> getFunctions1() {\n        List<Function> functions = new ArrayList<>();\n        functions.add(new Divide3Function());\n        functions.add(new Divide2Function());\n        functions.add(new Subtract1Function());\n        return functions;\n    }\n    \n    public abstract static class Function {\n        abstract public int action(int n);\n        abstract public boolean actionOk(int n);\n        abstract public String toString(int n);\n    }\n    \n    public static class Divide2Function extends Function {\n        @Override public int action(int n) {\n            return n/2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 2 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/2 -> \" + n/2;\n        }\n        \n        @Override public String toString() {\n            return \"Divisor 2\";\n        }\n        \n    }\n\n    public static class Divide3Function extends Function {\n        @Override public int action(int n) {\n            return n/3;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n % 3 == 0;\n        }\n\n        @Override public String toString(int n) {\n            return \"/3 -> \" + n/3;\n        }\n\n        @Override public String toString() {\n            return \"Divisor 3\";\n        }\n\n    }\n\n    public static class Subtract1Function extends Function {\n        @Override public int action(int n) {\n            return n-1;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return true;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-1 -> \" + (n-1);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 1\";\n        }\n\n    }\n\n    public static class Subtract2Function extends Function {\n        @Override public int action(int n) {\n            return n-2;\n        }\n\n        @Override public boolean actionOk(int n) {\n            return n > 2;\n        }\n    \n        @Override public String toString(int n) {\n            return \"-2 -> \" + (n-2);\n        }\n\n        @Override public String toString() {\n            return \"Subtractor 2\";\n        }\n\n    }\n\n}\n"}
{"id": 404750, "name": "Ramanujan's constant", "source": "Translate Haskell to Java: import Control.Monad (forM_)\nimport Data.Number.CReal (CReal, showCReal)\nimport Text.Printf (printf)\n\nramfun :: CReal -> CReal\nramfun x = exp (pi * sqrt x)\n\n\nramanujan :: CReal\nramanujan = ramfun 163\n\n\nheegners :: [Int]\nheegners = [19, 43, 67, 163]\n\n\nintDist :: CReal -> CReal\nintDist x = abs (x - fromIntegral (round x))\n\nmain :: IO ()\nmain = do\n  let n = 35\n  printf \"Ramanujan's constant: %s\\n\\n\" (showCReal n ramanujan)\n  printf \"%3s %34s%20s%s\\n\\n\" \" h \" \"e^(pi*sqrt(h))\" \"\" \" Dist. to integer\"\n  forM_ heegners $ \\h ->\n    let r = ramfun (fromIntegral h)\n        d = intDist r\n    in printf \"%3d %54s %s\\n\" h (showCReal n r) (showCReal 15 d)\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}\n"}
{"id": 404751, "name": "Ramanujan's constant", "source": "Translate Haskell to Java: import Control.Monad (forM_)\nimport Data.Number.CReal (CReal, showCReal)\nimport Text.Printf (printf)\n\nramfun :: CReal -> CReal\nramfun x = exp (pi * sqrt x)\n\n\nramanujan :: CReal\nramanujan = ramfun 163\n\n\nheegners :: [Int]\nheegners = [19, 43, 67, 163]\n\n\nintDist :: CReal -> CReal\nintDist x = abs (x - fromIntegral (round x))\n\nmain :: IO ()\nmain = do\n  let n = 35\n  printf \"Ramanujan's constant: %s\\n\\n\" (showCReal n ramanujan)\n  printf \"%3s %34s%20s%s\\n\\n\" \" h \" \"e^(pi*sqrt(h))\" \"\" \" Dist. to integer\"\n  forM_ heegners $ \\h ->\n    let r = ramfun (fromIntegral h)\n        d = intDist r\n    in printf \"%3d %54s %s\\n\" h (showCReal n r) (showCReal 15 d)\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RamanujanConstant {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Ramanujan's Constant to 100 digits = %s%n%n\", ramanujanConstant(163, 100));\n        System.out.printf(\"Heegner numbers yielding 'almost' integers:%n\");\n        List<Integer> heegnerNumbers = Arrays.asList(19, 43, 67, 163);\n        List<Integer> heegnerVals = Arrays.asList(96, 960, 5280, 640320);\n        for ( int i = 0 ; i < heegnerNumbers.size() ; i++ ) {\n            int heegnerNumber = heegnerNumbers.get(i);\n            int heegnerVal = heegnerVals.get(i);\n            BigDecimal integer = BigDecimal.valueOf(heegnerVal).pow(3).add(BigDecimal.valueOf(744));\n            BigDecimal compute = ramanujanConstant(heegnerNumber, 50);\n            System.out.printf(\"%3d\u00a0: %50s ~ %18s (diff ~ %s)%n\", heegnerNumber, compute, integer, integer.subtract(compute, new MathContext(30)).toPlainString());\n        }\n    }\n    \n    public static BigDecimal ramanujanConstant(int sqrt, int digits) {\n        \n        MathContext mc = new MathContext(digits + 5);  \n        return bigE(bigPi(mc).multiply(bigSquareRoot(BigDecimal.valueOf(sqrt), mc), mc), mc).round(new MathContext(digits));\n    }\n\n    \n    public static BigDecimal bigE(BigDecimal exponent, MathContext mc) {\n        BigDecimal e = BigDecimal.ONE;\n        BigDecimal ak = e;\n        int k = 0;\n        BigDecimal min = BigDecimal.ONE.divide(BigDecimal.TEN.pow(mc.getPrecision()));\n        while ( true ) {\n            k++;\n            ak = ak.multiply(exponent).divide(BigDecimal.valueOf(k), mc);\n            e = e.add(ak, mc);\n            if ( ak.compareTo(min) < 0 ) {\n                break;\n            }\n        }\n        return e;\n        \n    }\n    \n    \n    public static BigDecimal bigPi(MathContext mc) {\n        int k = 0;\n        BigDecimal ak = BigDecimal.ONE;\n        BigDecimal a = ak;\n        BigDecimal b = BigDecimal.ZERO;\n        BigDecimal c = BigDecimal.valueOf(640320);\n        BigDecimal c3 = c.pow(3);\n        double digitePerTerm = Math.log10(c.pow(3).divide(BigDecimal.valueOf(24), mc).doubleValue()) - Math.log10(72);\n        double digits = 0;\n        while ( digits < mc.getPrecision() ) {\n            k++;\n            digits += digitePerTerm;\n            BigDecimal top = BigDecimal.valueOf(-24).multiply(BigDecimal.valueOf(6*k-5)).multiply(BigDecimal.valueOf(2*k-1)).multiply(BigDecimal.valueOf(6*k-1));\n            BigDecimal term = top.divide(BigDecimal.valueOf(k*k*k).multiply(c3), mc);\n            ak = ak.multiply(term, mc);\n            a = a.add(ak, mc);\n            b = b.add(BigDecimal.valueOf(k).multiply(ak, mc), mc);\n        }\n        BigDecimal total = BigDecimal.valueOf(13591409).multiply(a, mc).add(BigDecimal.valueOf(545140134).multiply(b, mc), mc);\n        return BigDecimal.valueOf(426880).multiply(bigSquareRoot(BigDecimal.valueOf(10005), mc), mc).divide(total, mc);\n    }\n\n    \n    public static BigDecimal bigSquareRoot(BigDecimal squareDecimal, MathContext mc) {\n        \n        double sqrt = Math.sqrt(squareDecimal.doubleValue());\n        BigDecimal x0 = new BigDecimal(sqrt, mc);\n        BigDecimal two = BigDecimal.valueOf(2);\n        while ( true ) {\n            BigDecimal x1 = x0.subtract(x0.multiply(x0, mc).subtract(squareDecimal).divide(two.multiply(x0, mc), mc), mc);\n            String x1String = x1.toPlainString();\n            String x0String = x0.toPlainString();\n            if ( x1String.substring(0, x1String.length()-1).compareTo(x0String.substring(0, x0String.length()-1)) == 0 ) {\n                break;\n            }\n            x0 = x1;\n        }\n        return x0;\n    }\n    \n}\n"}
{"id": 404752, "name": "Most frequent k chars distance", "source": "Translate Haskell to Java: module MostFrequentK \n   where\nimport Data.List ( nub , sortBy )\nimport qualified Data.Set as S \n\ncount :: Eq a => [a] -> a -> Int\ncount [] x = 0 \ncount ( x:xs ) k \n   |x == k = 1 + count xs k\n   |otherwise = count xs k\n\norderedStatistics :: String -> [(Char , Int)]\norderedStatistics s = sortBy myCriterion $ nub $ zip s ( map (\\c -> count s c ) s )\n   where\n      myCriterion :: (Char , Int) -> (Char , Int) -> Ordering\n      myCriterion (c1 , n1) (c2, n2) \n\t |n1 > n2 = LT\n\t |n1 < n2 = GT\n\t |n1 == n2 = compare ( found c1 s ) ( found c2 s )\n      found :: Char -> String -> Int\n      found e s = length $ takeWhile (/= e ) s\n\nmostFreqKHashing :: String -> Int -> String\nmostFreqKHashing s n = foldl ((++)) [] $ map toString $ take n $ orderedStatistics s\n   where\n      toString :: (Char , Int) -> String\n      toString ( c , i ) = c : show i\n\nmostFreqKSimilarity :: String -> String -> Int\nmostFreqKSimilarity s t = snd $ head $ S.toList $ S.fromList ( doublets s ) `S.intersection`\n                           S.fromList ( doublets t )\n   where\n      toPair :: String -> (Char , Int)\n      toPair s = ( head s , fromEnum ( head $ tail s ) - 48 )\n      doublets :: String -> [(Char , Int)]\n      doublets str = map toPair [take 2 $ drop start str | start <- [0 , 2 ..length str - 2]]\n                           \nmostFreqKSDF :: String -> String -> Int ->Int\nmostFreqKSDF s t n = mostFreqKSimilarity ( mostFreqKHashing s n ) (mostFreqKHashing t n )\n", "target": "import java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\n\npublic class SDF {\n\n    \n    public static HashMap<Character, Integer> countElementOcurrences(char[] array) {\n\n        HashMap<Character, Integer> countMap = new HashMap<Character, Integer>();\n\n        for (char element : array) {\n            Integer count = countMap.get(element);\n            count = (count == null) ? 1 : count + 1;\n            countMap.put(element, count);\n        }\n\n        return countMap;\n    }\n    \n    \n    private static <K, V extends Comparable<? super V>>\n            HashMap<K, V> descendingSortByValues(HashMap<K, V> map) { \n\tList<Map.Entry<K, V>> list = new ArrayList<Map.Entry<K, V>>(map.entrySet());\n\t\n\tCollections.sort(list, new Comparator<Map.Entry<K, V>>() {\n\t\tpublic int compare(Map.Entry<K, V> o1, Map.Entry<K, V> o2) {\n\t\t    return o2.getValue().compareTo(o1.getValue());\n\t\t}\n\t    });\n\n\t\n\t\n\tHashMap<K, V> sortedHashMap = new LinkedHashMap<K, V>();\n\tfor (Map.Entry<K, V> entry : list) {\n\t    sortedHashMap.put(entry.getKey(), entry.getValue());\n\t} \n\treturn sortedHashMap;\n    }\n    \n    public static String mostOcurrencesElement(char[] array, int k) {\n        HashMap<Character, Integer> countMap = countElementOcurrences(array);\n        System.out.println(countMap);\n        Map<Character, Integer> map = descendingSortByValues(countMap); \n        System.out.println(map);\n        int i = 0;\n        String output = \"\";\n        for (Map.Entry<Character, Integer> pairs : map.entrySet()) {\n\t    if (i++ >= k)\n\t\tbreak;\n            output += \"\" + pairs.getKey() + pairs.getValue();\n        }\n        return output;\n    }\n    \n    public static int getDiff(String str1, String str2, int limit) {\n        int similarity = 0;\n\tint k = 0;\n\tfor (int i = 0; i < str1.length() ; i = k) {\n\t    k ++;\n\t    if (Character.isLetter(str1.charAt(i))) {\n\t\tint pos = str2.indexOf(str1.charAt(i));\n\t\t\t\t\n\t\tif (pos >= 0) {\t\n\t\t    String digitStr1 = \"\";\n\t\t    while ( k < str1.length() && !Character.isLetter(str1.charAt(k))) {\n\t\t\tdigitStr1 += str1.charAt(k);\n\t\t\tk++;\n\t\t    }\n\t\t\t\t\t\n\t\t    int k2 = pos+1;\n\t\t    String digitStr2 = \"\";\n\t\t    while (k2 < str2.length() && !Character.isLetter(str2.charAt(k2)) ) {\n\t\t\tdigitStr2 += str2.charAt(k2);\n\t\t\tk2++;\n\t\t    }\n\t\t\t\t\t\n\t\t    similarity += Integer.parseInt(digitStr2)\n\t\t\t+ Integer.parseInt(digitStr1);\n\t\t\t\t\t\n\t\t} \n\t    }\n\t}\n\treturn Math.abs(limit - similarity);\n    }\n    \n    public static int SDFfunc(String str1, String str2, int limit) {\n        return getDiff(mostOcurrencesElement(str1.toCharArray(), 2), mostOcurrencesElement(str2.toCharArray(), 2), limit);\n    }\n\n    public static void main(String[] args) {\n        String input1 = \"LCLYTHIGRNIYYGSYLYSETWNTGIMLLLITMATAFMGYVLPWGQMSFWGATVITNLFSAIPYIGTNLV\";\n        String input2 = \"EWIWGGFSVDKATLNRFFAFHFILPFTMVALAGVHLTFLHETGSNNPLGLTSDSDKIPFHPYYTIKDFLG\";\n        System.out.println(SDF.SDFfunc(input1,input2,100));\n\n    }\n\n}\n"}
{"id": 404753, "name": "One-time pad", "source": "Translate Haskell to Java: \n\n\n\n\nmodule OneTimePad (main) where\n\nimport           Control.Monad\nimport           Data.Char\nimport           Data.Function         (on)\nimport qualified Data.Text             as T\nimport qualified Data.Text.IO          as TI\nimport           Data.Time\nimport           System.Console.GetOpt\nimport           System.Environment\nimport           System.Exit\nimport           System.IO\n\n\ndata Options = Options  { optCommand :: String\n                        , optInput   :: IO T.Text\n                        , optOutput  :: T.Text -> IO ()\n                        , optPad     :: (IO T.Text, T.Text -> IO ())\n                        , optLines   :: Int\n                        }\n\nstartOptions :: Options\nstartOptions = Options  { optCommand    = \"decrypt\"\n                        , optInput      = TI.getContents\n                        , optOutput     = TI.putStr\n                        , optPad        = (TI.getContents, TI.putStr)\n                        , optLines      = 0\n                        }\n\noptions :: [ OptDescr (Options -> IO Options) ]\noptions =\n    [ Option \"e\" [\"encrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"encrypt\" }))\n        \"Encrypt file\"\n    , Option \"d\" [\"decrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"decrypt\" }))\n        \"Decrypt file (default)\"\n    , Option \"g\" [\"generate\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"generate\" }))\n        \"Generate a one-time pad\"\n    , Option \"i\" [\"input\"]\n        (ReqArg\n            (\\arg opt -> return opt { optInput = TI.readFile arg })\n            \"FILE\")\n        \"Input file (for decryption and encryption)\"\n    , Option \"o\" [\"output\"]\n        (ReqArg\n            (\\arg opt -> return opt { optOutput = TI.writeFile arg })\n            \"FILE\")\n        \"Output file (for generation, decryption, and encryption)\"\n    , Option \"p\" [\"pad\"]\n        (ReqArg\n            (\\arg opt -> return opt { optPad = (TI.readFile arg,\n                                                TI.writeFile arg) })\n            \"FILE\")\n        \"One-time pad to use (for decryption and encryption)\"\n    , Option \"l\" [\"lines\"]\n        (ReqArg\n            (\\arg opt -> return opt { optLines = read arg :: Int })\n            \"LINES\")\n        \"New one-time pad's length (in lines of 48 characters) (for generation)\"\n    , Option \"V\" [\"version\"]\n        (NoArg\n            (\\_ -> do\n                hPutStrLn stderr \"Version 0.01\"\n                exitWith ExitSuccess))\n        \"Print version\"\n    , Option \"h\" [\"help\"]\n        (NoArg\n            (\\_ -> do\n                prg <- getProgName\n                putStrLn \"usage: OneTimePad [-h] [-V] [\n                hPutStrLn stderr (usageInfo prg options)\n                exitWith ExitSuccess))\n        \"Show this help message and exit\"\n    ]\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let (actions, nonOptions, errors) = getOpt RequireOrder options args\n  opts <- Prelude.foldl (>>=) (return startOptions) actions\n  let Options { optCommand = command\n              , optInput   = input\n              , optOutput  = output\n              , optPad     = (inPad, outPad)\n              , optLines   = linecnt } = opts\n\n  case command of\n    \"generate\" -> generate linecnt output\n    \"encrypt\"  -> do\n      inputContents <- clean <$> input\n      padContents <- inPad\n      output $ format $ encrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n    \"decrypt\"  -> do\n      inputContents <- unformat <$> input\n      padContents <- inPad\n      output $ decrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n      let discardLines = ceiling\n            $ ((/) `on` fromIntegral) (T.length inputContents) 48\n      outPad $ discard discardLines $ T.lines padContents\n\n\ndiscard :: Int -> [T.Text] -> T.Text\ndiscard 0 ts = T.unlines ts\ndiscard x (t:ts) = if (T.head t == '-' || T.head t == '#')\n  then T.unlines [t, (discard x ts)]\n  else T.unlines [(T.append (T.pack \"- \") t), (discard (x-1) ts)]\n\n\nclean :: T.Text -> T.Text\nclean = T.map toUpper . T.filter (\\c -> let oc = ord c\n                                   in oc >= 65 && oc <= 122\n                                   && (not $ oc >=91 && oc <= 96))\n\n\nformat :: T.Text -> T.Text\nformat = T.unlines . map (T.intercalate (T.pack \" \") . T.chunksOf 6)\n  . T.chunksOf 48\n\n\nunformat :: T.Text -> T.Text\nunformat = T.filter (\\c -> c/='\\n' && c/=' ')\n\n\ngenerate :: Int -> (T.Text -> IO ()) -> IO ()\ngenerate lines output = do\n  withBinaryFile \"/dev/random\" ReadMode\n    (\\handle -> do\n        contents <- replicateM (48 * lines) $ hGetChar handle\n        time <- getCurrentTime\n        output\n          $ T.unlines [ T.pack\n                        $ \"# OTP pad, generated by https://github.com/kssytsrk/one-time-pad on \"\n                        ++ show time\n                      , format $ T.pack\n                        $ map (chr . (65 +) . flip mod 26 . ord) contents\n                      ])\n\n\ncrypt :: (Int -> Int -> Int) -> T.Text -> T.Text -> T.Text\ncrypt f = T.zipWith ((chr .) . f `on` ord)\n\n\nencrypt :: T.Text -> T.Text -> T.Text\nencrypt = crypt ((((+65) . flip mod 26 . subtract 130) .) . (+))\n\n\ndecrypt :: T.Text -> T.Text -> T.Text\ndecrypt = crypt ((((+65) . flip mod 26) .) . (-))\n", "target": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class OneTimePad {\n\n    public static void main(String[] args) {\n        String controlName = \"AtomicBlonde\";\n        generatePad(controlName, 5, 60, 65, 90);\n        String text = \"IT WAS THE BEST OF TIMES IT WAS THE WORST OF TIMES\";\n        String encrypted = parse(true, controlName, text.replaceAll(\" \", \"\"));\n        String decrypted = parse(false, controlName, encrypted);\n        System.out.println(\"Input  text    = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n\n        controlName = \"AtomicBlondeCaseSensitive\";\n        generatePad(controlName, 5, 60, 32, 126);\n        text = \"It was the best of times, it was the worst of times.\";\n        encrypted = parse(true, controlName, text);\n        decrypted = parse(false, controlName, encrypted);\n        System.out.println();\n        System.out.println(\"Input text     = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n    }\n    \n    private static String parse(boolean encryptText, String controlName, String text) {\n        StringBuilder sb = new StringBuilder();\n        int minCh = 0;\n        int maxCh = 0;\n        Pattern minChPattern = Pattern.compile(\"^#  MIN_CH = ([\\\\d]+)$\");\n        Pattern maxChPattern = Pattern.compile(\"^#  MAX_CH = ([\\\\d]+)$\");\n        boolean validated = false;\n        try (BufferedReader in = new BufferedReader(new FileReader(getFileName(controlName))); ) {\n            String inLine = null;\n            while ( (inLine = in.readLine()) != null ) {\n                Matcher minMatcher = minChPattern.matcher(inLine);\n                if ( minMatcher.matches() ) {\n                    minCh = Integer.parseInt(minMatcher.group(1));\n                    continue;\n                }\n                Matcher maxMatcher = maxChPattern.matcher(inLine);\n                if ( maxMatcher.matches() ) {\n                    maxCh = Integer.parseInt(maxMatcher.group(1));\n                    continue;\n                }\n                if ( ! validated && minCh > 0 && maxCh > 0 ) {\n                    validateText(text, minCh, maxCh);\n                    validated = true;\n                }\n                \n                if ( inLine.startsWith(\"#\") || inLine.startsWith(\"-\") ) {\n                    continue;\n                }\n                \n                String key = inLine;\n                if ( encryptText ) {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        sb.append((char) (((text.charAt(i) - minCh + key.charAt(i) - minCh) % (maxCh - minCh + 1)) + minCh));\n                    }\n                }\n                else {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        int decrypt = text.charAt(i) - key.charAt(i);\n                        if ( decrypt < 0 ) {\n                            decrypt += maxCh - minCh + 1;\n                        }\n                        decrypt += minCh;\n                        sb.append((char) decrypt);\n                    }\n                }\n                break;\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString();\n    }\n\n    private static void validateText(String text, int minCh, int maxCh) {\n        \n        for ( char ch : text.toCharArray() ) {\n            if ( ch != ' ' && (ch < minCh || ch > maxCh) ) {\n                throw new IllegalArgumentException(\"ERROR 103:  Invalid text.\");\n            }\n        }\n        \n    }\n    \n    private static String getFileName(String controlName) {\n        return controlName + \".1tp\";\n    }\n    \n    private static void generatePad(String controlName, int keys, int keyLength, int minCh, int maxCh) {\n        Random random = new Random();\n        try ( BufferedWriter writer = new BufferedWriter(new FileWriter(getFileName(controlName), false)); ) {\n            writer.write(\"#  Lines starting with '#' are ignored.\");\n            writer.newLine();\n            writer.write(\"#  Lines starting with '-' are previously used.\");\n            writer.newLine();\n            writer.write(\"#  MIN_CH = \" + minCh);\n            writer.newLine();\n            writer.write(\"#  MAX_CH = \" + maxCh);\n            writer.newLine();\n            for ( int line = 0 ; line < keys ; line++ ) {\n                StringBuilder sb = new StringBuilder();\n                for ( int ch = 0 ; ch < keyLength ; ch++ ) {\n                    sb.append((char) (random.nextInt(maxCh - minCh + 1) + minCh));\n                }\n                writer.write(sb.toString());\n                writer.newLine();\n            }\n            writer.write(\"#  EOF\");\n            writer.newLine();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n"}
{"id": 404754, "name": "One-time pad", "source": "Translate Haskell to Java: \n\n\n\n\nmodule OneTimePad (main) where\n\nimport           Control.Monad\nimport           Data.Char\nimport           Data.Function         (on)\nimport qualified Data.Text             as T\nimport qualified Data.Text.IO          as TI\nimport           Data.Time\nimport           System.Console.GetOpt\nimport           System.Environment\nimport           System.Exit\nimport           System.IO\n\n\ndata Options = Options  { optCommand :: String\n                        , optInput   :: IO T.Text\n                        , optOutput  :: T.Text -> IO ()\n                        , optPad     :: (IO T.Text, T.Text -> IO ())\n                        , optLines   :: Int\n                        }\n\nstartOptions :: Options\nstartOptions = Options  { optCommand    = \"decrypt\"\n                        , optInput      = TI.getContents\n                        , optOutput     = TI.putStr\n                        , optPad        = (TI.getContents, TI.putStr)\n                        , optLines      = 0\n                        }\n\noptions :: [ OptDescr (Options -> IO Options) ]\noptions =\n    [ Option \"e\" [\"encrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"encrypt\" }))\n        \"Encrypt file\"\n    , Option \"d\" [\"decrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"decrypt\" }))\n        \"Decrypt file (default)\"\n    , Option \"g\" [\"generate\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"generate\" }))\n        \"Generate a one-time pad\"\n    , Option \"i\" [\"input\"]\n        (ReqArg\n            (\\arg opt -> return opt { optInput = TI.readFile arg })\n            \"FILE\")\n        \"Input file (for decryption and encryption)\"\n    , Option \"o\" [\"output\"]\n        (ReqArg\n            (\\arg opt -> return opt { optOutput = TI.writeFile arg })\n            \"FILE\")\n        \"Output file (for generation, decryption, and encryption)\"\n    , Option \"p\" [\"pad\"]\n        (ReqArg\n            (\\arg opt -> return opt { optPad = (TI.readFile arg,\n                                                TI.writeFile arg) })\n            \"FILE\")\n        \"One-time pad to use (for decryption and encryption)\"\n    , Option \"l\" [\"lines\"]\n        (ReqArg\n            (\\arg opt -> return opt { optLines = read arg :: Int })\n            \"LINES\")\n        \"New one-time pad's length (in lines of 48 characters) (for generation)\"\n    , Option \"V\" [\"version\"]\n        (NoArg\n            (\\_ -> do\n                hPutStrLn stderr \"Version 0.01\"\n                exitWith ExitSuccess))\n        \"Print version\"\n    , Option \"h\" [\"help\"]\n        (NoArg\n            (\\_ -> do\n                prg <- getProgName\n                putStrLn \"usage: OneTimePad [-h] [-V] [\n                hPutStrLn stderr (usageInfo prg options)\n                exitWith ExitSuccess))\n        \"Show this help message and exit\"\n    ]\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let (actions, nonOptions, errors) = getOpt RequireOrder options args\n  opts <- Prelude.foldl (>>=) (return startOptions) actions\n  let Options { optCommand = command\n              , optInput   = input\n              , optOutput  = output\n              , optPad     = (inPad, outPad)\n              , optLines   = linecnt } = opts\n\n  case command of\n    \"generate\" -> generate linecnt output\n    \"encrypt\"  -> do\n      inputContents <- clean <$> input\n      padContents <- inPad\n      output $ format $ encrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n    \"decrypt\"  -> do\n      inputContents <- unformat <$> input\n      padContents <- inPad\n      output $ decrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n      let discardLines = ceiling\n            $ ((/) `on` fromIntegral) (T.length inputContents) 48\n      outPad $ discard discardLines $ T.lines padContents\n\n\ndiscard :: Int -> [T.Text] -> T.Text\ndiscard 0 ts = T.unlines ts\ndiscard x (t:ts) = if (T.head t == '-' || T.head t == '#')\n  then T.unlines [t, (discard x ts)]\n  else T.unlines [(T.append (T.pack \"- \") t), (discard (x-1) ts)]\n\n\nclean :: T.Text -> T.Text\nclean = T.map toUpper . T.filter (\\c -> let oc = ord c\n                                   in oc >= 65 && oc <= 122\n                                   && (not $ oc >=91 && oc <= 96))\n\n\nformat :: T.Text -> T.Text\nformat = T.unlines . map (T.intercalate (T.pack \" \") . T.chunksOf 6)\n  . T.chunksOf 48\n\n\nunformat :: T.Text -> T.Text\nunformat = T.filter (\\c -> c/='\\n' && c/=' ')\n\n\ngenerate :: Int -> (T.Text -> IO ()) -> IO ()\ngenerate lines output = do\n  withBinaryFile \"/dev/random\" ReadMode\n    (\\handle -> do\n        contents <- replicateM (48 * lines) $ hGetChar handle\n        time <- getCurrentTime\n        output\n          $ T.unlines [ T.pack\n                        $ \"# OTP pad, generated by https://github.com/kssytsrk/one-time-pad on \"\n                        ++ show time\n                      , format $ T.pack\n                        $ map (chr . (65 +) . flip mod 26 . ord) contents\n                      ])\n\n\ncrypt :: (Int -> Int -> Int) -> T.Text -> T.Text -> T.Text\ncrypt f = T.zipWith ((chr .) . f `on` ord)\n\n\nencrypt :: T.Text -> T.Text -> T.Text\nencrypt = crypt ((((+65) . flip mod 26 . subtract 130) .) . (+))\n\n\ndecrypt :: T.Text -> T.Text -> T.Text\ndecrypt = crypt ((((+65) . flip mod 26) .) . (-))\n", "target": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class OneTimePad {\n\n    public static void main(String[] args) {\n        String controlName = \"AtomicBlonde\";\n        generatePad(controlName, 5, 60, 65, 90);\n        String text = \"IT WAS THE BEST OF TIMES IT WAS THE WORST OF TIMES\";\n        String encrypted = parse(true, controlName, text.replaceAll(\" \", \"\"));\n        String decrypted = parse(false, controlName, encrypted);\n        System.out.println(\"Input  text    = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n\n        controlName = \"AtomicBlondeCaseSensitive\";\n        generatePad(controlName, 5, 60, 32, 126);\n        text = \"It was the best of times, it was the worst of times.\";\n        encrypted = parse(true, controlName, text);\n        decrypted = parse(false, controlName, encrypted);\n        System.out.println();\n        System.out.println(\"Input text     = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n    }\n    \n    private static String parse(boolean encryptText, String controlName, String text) {\n        StringBuilder sb = new StringBuilder();\n        int minCh = 0;\n        int maxCh = 0;\n        Pattern minChPattern = Pattern.compile(\"^#  MIN_CH = ([\\\\d]+)$\");\n        Pattern maxChPattern = Pattern.compile(\"^#  MAX_CH = ([\\\\d]+)$\");\n        boolean validated = false;\n        try (BufferedReader in = new BufferedReader(new FileReader(getFileName(controlName))); ) {\n            String inLine = null;\n            while ( (inLine = in.readLine()) != null ) {\n                Matcher minMatcher = minChPattern.matcher(inLine);\n                if ( minMatcher.matches() ) {\n                    minCh = Integer.parseInt(minMatcher.group(1));\n                    continue;\n                }\n                Matcher maxMatcher = maxChPattern.matcher(inLine);\n                if ( maxMatcher.matches() ) {\n                    maxCh = Integer.parseInt(maxMatcher.group(1));\n                    continue;\n                }\n                if ( ! validated && minCh > 0 && maxCh > 0 ) {\n                    validateText(text, minCh, maxCh);\n                    validated = true;\n                }\n                \n                if ( inLine.startsWith(\"#\") || inLine.startsWith(\"-\") ) {\n                    continue;\n                }\n                \n                String key = inLine;\n                if ( encryptText ) {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        sb.append((char) (((text.charAt(i) - minCh + key.charAt(i) - minCh) % (maxCh - minCh + 1)) + minCh));\n                    }\n                }\n                else {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        int decrypt = text.charAt(i) - key.charAt(i);\n                        if ( decrypt < 0 ) {\n                            decrypt += maxCh - minCh + 1;\n                        }\n                        decrypt += minCh;\n                        sb.append((char) decrypt);\n                    }\n                }\n                break;\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString();\n    }\n\n    private static void validateText(String text, int minCh, int maxCh) {\n        \n        for ( char ch : text.toCharArray() ) {\n            if ( ch != ' ' && (ch < minCh || ch > maxCh) ) {\n                throw new IllegalArgumentException(\"ERROR 103:  Invalid text.\");\n            }\n        }\n        \n    }\n    \n    private static String getFileName(String controlName) {\n        return controlName + \".1tp\";\n    }\n    \n    private static void generatePad(String controlName, int keys, int keyLength, int minCh, int maxCh) {\n        Random random = new Random();\n        try ( BufferedWriter writer = new BufferedWriter(new FileWriter(getFileName(controlName), false)); ) {\n            writer.write(\"#  Lines starting with '#' are ignored.\");\n            writer.newLine();\n            writer.write(\"#  Lines starting with '-' are previously used.\");\n            writer.newLine();\n            writer.write(\"#  MIN_CH = \" + minCh);\n            writer.newLine();\n            writer.write(\"#  MAX_CH = \" + maxCh);\n            writer.newLine();\n            for ( int line = 0 ; line < keys ; line++ ) {\n                StringBuilder sb = new StringBuilder();\n                for ( int ch = 0 ; ch < keyLength ; ch++ ) {\n                    sb.append((char) (random.nextInt(maxCh - minCh + 1) + minCh));\n                }\n                writer.write(sb.toString());\n                writer.newLine();\n            }\n            writer.write(\"#  EOF\");\n            writer.newLine();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n"}
{"id": 410167, "name": "Circles of given radius through two points", "source": "Translate Haskell to C#: add (a, b) (x, y) = (a + x, b + y)\nsub (a, b) (x, y) = (a - x, b - y)\nmagSqr (a, b)     = (a ^^ 2) + (b ^^ 2)\nmag a             = sqrt $ magSqr a\nmul (a, b) c      = (a * c, b * c)\ndiv2 (a, b) c     = (a / c, b / c)\nperp (a, b)       = (negate b, a)\nnorm a            = a `div2` mag a\n\ncirclePoints :: (Ord a, Floating a) =>\n                (a, a) -> (a, a) -> a -> Maybe ((a, a), (a, a))\ncirclePoints p q radius\n  | radius == 0      = Nothing\n  | p == q           = Nothing\n  | diameter < magPQ = Nothing\n  | otherwise        = Just (center1, center2)\n  where\n    diameter = radius * 2\n    pq       = p `sub` q\n    magPQ    = mag pq\n    midpoint = (p `add` q) `div2` 2\n    halfPQ   = magPQ / 2\n    magMidC  = sqrt . abs $ (radius ^^ 2) - (halfPQ ^^ 2)\n    midC     = (norm $ perp pq) `mul` magMidC\n    center1  = midpoint `add` midC\n    center2  = midpoint `sub` midC\n\nuncurry3 f (a, b, c) = f a b c\n\nmain :: IO ()\nmain = mapM_ (print . uncurry3 circlePoints)\n  [((0.1234, 0.9876), (0.8765, 0.2345), 2),\n   ((0     , 2     ), (0     , 0     ), 1),\n   ((0.1234, 0.9876), (0.1234, 0.9876), 2),\n   ((0.1234, 0.9876), (0.8765, 0.2345), 0.5),\n   ((0.1234, 0.9876), (0.1234, 0.1234), 0)]\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 410168, "name": "Circles of given radius through two points", "source": "Translate Haskell to C#: add (a, b) (x, y) = (a + x, b + y)\nsub (a, b) (x, y) = (a - x, b - y)\nmagSqr (a, b)     = (a ^^ 2) + (b ^^ 2)\nmag a             = sqrt $ magSqr a\nmul (a, b) c      = (a * c, b * c)\ndiv2 (a, b) c     = (a / c, b / c)\nperp (a, b)       = (negate b, a)\nnorm a            = a `div2` mag a\n\ncirclePoints :: (Ord a, Floating a) =>\n                (a, a) -> (a, a) -> a -> Maybe ((a, a), (a, a))\ncirclePoints p q radius\n  | radius == 0      = Nothing\n  | p == q           = Nothing\n  | diameter < magPQ = Nothing\n  | otherwise        = Just (center1, center2)\n  where\n    diameter = radius * 2\n    pq       = p `sub` q\n    magPQ    = mag pq\n    midpoint = (p `add` q) `div2` 2\n    halfPQ   = magPQ / 2\n    magMidC  = sqrt . abs $ (radius ^^ 2) - (halfPQ ^^ 2)\n    midC     = (norm $ perp pq) `mul` magMidC\n    center1  = midpoint `add` midC\n    center2  = midpoint `sub` midC\n\nuncurry3 f (a, b, c) = f a b c\n\nmain :: IO ()\nmain = mapM_ (print . uncurry3 circlePoints)\n  [((0.1234, 0.9876), (0.8765, 0.2345), 2),\n   ((0     , 2     ), (0     , 0     ), 1),\n   ((0.1234, 0.9876), (0.1234, 0.9876), 2),\n   ((0.1234, 0.9876), (0.8765, 0.2345), 0.5),\n   ((0.1234, 0.9876), (0.1234, 0.1234), 0)]\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 410169, "name": "Vampire number", "source": "Translate Haskell to C#: import Data.List (sort)\nimport Control.Arrow ((&&&))\n\n\nvampires :: [Int]\nvampires = filter (not . null . fangs) [1 ..]\n\nfangs :: Int -> [(Int, Int)]\nfangs n\n  | odd w = []\n  | otherwise = ((,) <*> quot n) <$> filter isfang (integerFactors n)\n  where\n    ndigit :: Int -> Int\n    ndigit 0 = 0\n    ndigit n = 1 + ndigit (quot n 10)\n    w = ndigit n\n    xmin = 10 ^ (quot w 2 - 1)\n    xmax = xmin * 10\n    isfang x =\n      x > xmin &&\n      x < y &&\n      y < xmax && \n      (quot x 10 /= 0 || quot y 10 /= 0) && \n      sort (show n) == sort (show x ++ show y)\n      where\n        y = quot n x\n\n\nintegerFactors :: Int -> [Int]\nintegerFactors n\n  | n < 1 = []\n  | otherwise =\n    lows ++\n    (quot n <$>\n     (if intSquared == n \n        then tail \n        else id)\n       (reverse lows))\n  where\n    (intSquared, lows) =\n      (^ 2) &&& (filter ((0 ==) . rem n) . enumFromTo 1) $\n      floor (sqrt $ fromIntegral n)\n\n\nmain :: IO [()]\nmain =\n  mapM\n    (print . ((,) <*>) fangs)\n    (take 25 vampires ++ [16758243290880, 24959017348650, 14593825548650])\n", "target": "using System;\n\nnamespace RosettaVampireNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int i, j, n;\n            ulong x;\n            var f = new ulong[16];\n            var bigs = new ulong[] { 16758243290880UL, 24959017348650UL, 14593825548650UL, 0 };\n            ulong[] tens = new ulong[20];\n            tens[0] = 1;\n            for (i = 1; i < 20; i++)\n                tens[i] = tens[i - 1] * 10;\n            \n            for (x = 1, n = 0; n < 25; x++)\n            {\n                if ((j = fangs(x, f, tens)) == 0) continue;\n                Console.Write(++n + \": \");\n                show_fangs(x, f, j);\n            }\n\n            Console.WriteLine();\n            for (i = 0; bigs[i] > 0 ; i++)\n            {\n                if ((j = fangs(bigs[i], f, tens)) > 0)\n                    show_fangs(bigs[i], f, j);\n                else\n                    Console.WriteLine(bigs[i] + \" is not vampiric.\");\n            }\n            Console.ReadLine();\n        }\n\n        private static void show_fangs(ulong x, ulong[] f, int cnt)\n        {\n            Console.Write(x); \n            int i;\n            for (i = 0; i < cnt; i++)\n                Console.Write(\" =\u00a0\" + f[i] + \" * \" + (x / f[i]));\n            Console.WriteLine();\n        }\n\n        private static int fangs(ulong x, ulong[] f, ulong[] tens)\n        {\n            int n = 0;\n            int nd = ndigits(x);\n            if ((nd & 1) > 0) return 0;\n            nd /= 2;\n\n            ulong lo, hi;\n            lo = Math.Max(tens[nd - 1], (x + tens[nd] - 2) / (tens[nd] - 1));\n            hi = Math.Min(x / lo, (ulong) Math.Sqrt(x));\n\n            ulong a, b, t = dtally(x);\n            for (a = lo; a <= hi; a++)\n            {\n                b = x / a;\n                if (a * b == x && ((a % 10) > 0 || (b % 10) > 0) && t == dtally(a) + dtally(b))\n                    f[n++] = a;\n            }\n\n            return n;\n        }\n\n        private static ulong dtally(ulong x)\n        {\n            ulong t = 0;\n            while (x > 0)\n            {\n                t += 1UL << (int)((x % 10) * 6);\n                x /= 10;\n            }\n\n            return t;\n        }\n\n        private static int ndigits(ulong x)\n        {\n            int n = 0;\n            while (x > 0)\n            {\n                n++;\n                x /= 10;\n            }\n            return n;\n        }\n    }\n}\n"}
{"id": 410170, "name": "Poker hand analyser", "source": "Translate Haskell to C#: \n\nimport Data.Function (on)\nimport Data.List     (group, nub, any, sort, sortBy)\nimport Data.Maybe    (mapMaybe)\nimport Text.Read     (readMaybe)\n\ndata Suit = Club | Diamond | Spade | Heart deriving (Show, Eq)\n\ndata Rank = Ace | Two | Three | Four | Five | Six | Seven\n          | Eight | Nine | Ten | Jack | Queen | King\n          deriving (Show, Eq, Enum, Ord, Bounded)\n\ndata Card = Card { suit :: Suit, rank :: Rank } deriving (Show, Eq)\n\ntype Hand = [Card]\n\nconsumed = pure . (, \"\")\n\ninstance Read Suit where\n  readsPrec d s = case s of \"\u2665\" -> consumed Heart\n                            \"\u2666\" -> consumed Diamond\n                            \"\u2663\" -> consumed Spade\n                            \"\u2660\" -> consumed Club\n                            \"h\" -> consumed Heart\n                            _   -> []\n\ninstance Read Rank where\n  readsPrec d s = case s of \"a\"  -> consumed Ace\n                            \"2\"  -> consumed Two\n                            \"3\"  -> consumed Three\n                            \"4\"  -> consumed Four\n                            \"5\"  -> consumed Five\n                            \"6\"  -> consumed Six\n                            \"7\"  -> consumed Seven\n                            \"8\"  -> consumed Eight\n                            \"9\"  -> consumed Nine\n                            \"10\" -> consumed Ten\n                            \"j\"  -> consumed Jack\n                            \"q\"  -> consumed Queen\n                            \"k\"  -> consumed King\n                            _    -> []\n\ninstance Read Card where\n  readsPrec d = fmap (, \"\") . mapMaybe card . lex\n    where \n      card (r, s) = Card <$> (readMaybe s :: Maybe Suit)\n                         <*> (readMaybe r :: Maybe Rank)\n\n\nacesHigh :: [Rank]\nacesHigh = [Ace, Ten, Jack, Queen, King]\n\nisSucc :: (Enum a, Eq a, Bounded a) => [a] -> Bool\nisSucc []  = True\nisSucc [x] = True\nisSucc (x:y:zs) = (x /= maxBound && y == succ x) && isSucc (y:zs)\n\nnameHand :: Hand -> String\nnameHand [] = \"Invalid Input\"\nnameHand cards | invalidHand          = \"Invalid hand\"\n               | straight && flush    = \"Straight flush\"\n               | ofKind 4             = \"Four of a kind\"\n               | ofKind 3 && ofKind 2 = \"Full house\"\n               | flush                = \"Flush\"\n               | straight             = \"Straight\"\n               | ofKind 3             = \"Three of a kind\"\n               | uniqRanks == 3       = \"Two pair\"\n               | uniqRanks == 4       = \"One pair\"\n               | otherwise            = \"High card\"\n where\n  sortedRank  = sort $ rank <$> cards\n  rankCounts  = sortBy (compare `on` snd) $ (,) <$> head <*> length <$> group sortedRank\n  uniqRanks   = length rankCounts\n  ofKind n    = any ((==n) . snd) rankCounts\n  straight    = isSucc sortedRank || sortedRank == acesHigh\n  flush       = length (nub $ suit <$> cards) == 1\n  invalidHand = length (nub cards) /= 5\n\ntestHands :: [(String, Hand)]\ntestHands = (,) <$> id <*> mapMaybe readMaybe . words <$>\n  [ \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\"\n  , \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\"\n  , \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\"\n  , \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\"\n  , \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\"\n  , \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 7\u2663\" \n  , \"Bad input\" ]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . (fst <> const \": \" <> nameHand . snd)) testHands\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class PokerHandAnalyzer\n{\n    private enum Hand {\n        Invalid, High_Card, One_Pair, Two_Pair, Three_Of_A_Kind, Straight,\n        Flush, Full_House, Four_Of_A_Kind, Straight_Flush, Five_Of_A_Kind\n    }\n\n    private const bool Y = true;\n    private const char C = '\u2663', D = '\u2666', H = '\u2665', S = '\u2660';\n    private const int rankMask = 0b11_1111_1111_1111;\n    private const int suitMask = 0b1111 << 14;\n    private static readonly string[] ranks = { \"a\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"j\", \"q\", \"k\" };\n    private static readonly string[] suits = { C + \"\", D + \"\", H + \"\", S + \"\" };\n    private static readonly Card[] deck = (from suit in Range(1, 4) from rank in Range(1, 13) select new Card(rank, suit)).ToArray();\n\n    public static void Main() {\n        string[] hands = {\n            \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\",\n            \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\",\n            \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\",\n            \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\",\n            \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\",\n            \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\",\n            \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\",\n            \"4\u2665 4\u2663 4\u2665 4\u2660 4\u2666\", \n            \"joker 2\u2666 2\u2660 k\u2660 q\u2666\",\n            \"joker 5\u2665 7\u2666 8\u2660 9\u2666\",\n            \"joker 2\u2666 3\u2660 4\u2660 5\u2660\",\n            \"joker 3\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 7\u2666 7\u2660 7\u2663\",\n            \"joker j\u2665 q\u2665 k\u2665 A\u2665\",\n            \"joker 4\u2663 k\u2663 5\u2666 10\u2660\",\n            \"joker k\u2663 7\u2663 6\u2663 4\u2663\",\n            \"joker 2\u2666 joker 4\u2660 5\u2660\",\n            \"joker Q\u2666 joker A\u2660 10\u2660\",\n            \"joker Q\u2666 joker A\u2666 10\u2666\",\n            \"joker 2\u2666 2\u2660 joker q\u2666\"\n        };\n        foreach (var h in hands) {\n            Console.WriteLine($\"{h}: {Analyze(h).Name()}\");\n        }\n    }\n\n    static string Name(this Hand hand) => string.Join('-', hand.ToString().Split('_')).ToLower();\n\n    static List<T> With<T>(this List<T> list, int index, T item) {\n        list[index] = item;\n        return list;\n    }\n\n    struct Card : IEquatable<Card>, IComparable<Card>\n    {\n        public static readonly Card Invalid = new Card(-1, -1);\n        public static readonly Card Joker = new Card(0, 0);\n\n        public Card(int rank, int suit) {\n            (Rank, Suit, Code) = (rank, suit) switch {\n                (_, -1) => (-1, -1, -1),\n                (-1, _) => (-1, -1, -1),\n                (0, _) => (0, 0, 0),\n                (1, _) => (rank, suit, (1 << (13 + suit)) | ((1 << 13) | 1)),\n                (_, _) => (rank, suit, (1 << (13 + suit)) | (1 << (rank - 1)))\n            };\n        }\n\n        public static implicit operator Card((int rank, int suit) tuple) => new Card(tuple.rank, tuple.suit);\n        public int Rank { get; }\n        public int Suit { get; }\n        public int Code { get; }\n\n        public override string ToString() => Rank switch {\n            -1 => \"invalid\",\n            0 => \"joker\",\n            _ => $\"{ranks[Rank-1]}{suits[Suit-1]}\"\n        };\n        \n        public override int GetHashCode() => Rank << 16 | Suit;\n        public bool Equals(Card other) => Rank == other.Rank && Suit == other.Suit;\n\n        public int CompareTo(Card other) {\n            int c = Rank.CompareTo(other.Rank);\n            if (c != 0) return c;\n            return Suit.CompareTo(other.Suit);\n        }\n    }\n\n    static Hand Analyze(string hand) {\n        var cards = ParseHand(hand);\n        if (cards.Count != 5) return Hand.Invalid; \n        cards.Sort();\n        if (cards[0].Equals(Card.Invalid)) return Hand.Invalid;\n        int jokers = cards.LastIndexOf(Card.Joker) + 1;\n        if (jokers > 2) return Hand.Invalid; \n        if (cards.Skip(jokers).Distinct().Count() + jokers != 5) return Hand.Invalid; \n\n        if (jokers == 2) return (from c0 in deck from c1 in deck select Evaluate(cards.With(0, c0).With(1, c1))).Max();\n        if (jokers == 1) return (from c0 in deck select Evaluate(cards.With(0, c0))).Max();\n        return Evaluate(cards);\n    }\n\n    static List<Card> ParseHand(string hand) =>\n        hand.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)\n        .Select(card => ParseCard(card.ToLower())).ToList();\n\n    static Card ParseCard(string card) => (card.Length, card) switch {\n        (5, \"joker\") => Card.Joker,\n        (3, _) when card[..2] == \"10\" => (10, ParseSuit(card[2])),\n        (2, _) => (ParseRank(card[0]), ParseSuit(card[1])),\n        (_, _) => Card.Invalid\n    };\n\n    static int ParseRank(char rank) => rank switch {\n        'a' => 1,\n        'j' => 11,\n        'q' => 12,\n        'k' => 13,\n        _ when rank >= '2' && rank <= '9' => rank - '0',\n        _ => -1\n    };\n\n    static int ParseSuit(char suit) => suit switch {\n        C => 1, 'c' => 1,\n        D => 2, 'd' => 2,\n        H => 3, 'h' => 3,\n        S => 4, 's' => 4,\n        _ => -1\n    };\n\n    static Hand Evaluate(List<Card> hand) {\n        var frequencies = hand.GroupBy(c => c.Rank).Select(g => g.Count()).OrderByDescending(c => c).ToArray();\n        (int f0, int f1) = (frequencies[0], frequencies.Length > 1 ? frequencies[1] : 0);\n\n        return (IsFlush(), IsStraight(), f0, f1) switch {\n            (_, _, 5, _) => Hand.Five_Of_A_Kind,\n            (Y, Y, _, _) => Hand.Straight_Flush,\n            (_, _, 4, _) => Hand.Four_Of_A_Kind,\n            (_, _, 3, 2) => Hand.Full_House,\n            (Y, _, _, _) => Hand.Flush,\n            (_, Y, _, _) => Hand.Straight,\n            (_, _, 3, _) => Hand.Three_Of_A_Kind,\n            (_, _, 2, 2) => Hand.Two_Pair,\n            (_, _, 2, _) => Hand.One_Pair,\n                        _ => Hand.High_Card\n        };\n\n        bool IsFlush() => hand.Aggregate(suitMask, (r, c) => r & c.Code) > 0;\n\n        bool IsStraight() {\n            int r = hand.Aggregate(0, (r, c) => r | c.Code) & rankMask;\n            for (int i = 0; i < 4; i++) r &= r << 1;\n            return r > 0;\n        }\n    }\n    \n}\n"}
{"id": 410171, "name": "Poker hand analyser", "source": "Translate Haskell to C#: \n\nimport Data.Function (on)\nimport Data.List     (group, nub, any, sort, sortBy)\nimport Data.Maybe    (mapMaybe)\nimport Text.Read     (readMaybe)\n\ndata Suit = Club | Diamond | Spade | Heart deriving (Show, Eq)\n\ndata Rank = Ace | Two | Three | Four | Five | Six | Seven\n          | Eight | Nine | Ten | Jack | Queen | King\n          deriving (Show, Eq, Enum, Ord, Bounded)\n\ndata Card = Card { suit :: Suit, rank :: Rank } deriving (Show, Eq)\n\ntype Hand = [Card]\n\nconsumed = pure . (, \"\")\n\ninstance Read Suit where\n  readsPrec d s = case s of \"\u2665\" -> consumed Heart\n                            \"\u2666\" -> consumed Diamond\n                            \"\u2663\" -> consumed Spade\n                            \"\u2660\" -> consumed Club\n                            \"h\" -> consumed Heart\n                            _   -> []\n\ninstance Read Rank where\n  readsPrec d s = case s of \"a\"  -> consumed Ace\n                            \"2\"  -> consumed Two\n                            \"3\"  -> consumed Three\n                            \"4\"  -> consumed Four\n                            \"5\"  -> consumed Five\n                            \"6\"  -> consumed Six\n                            \"7\"  -> consumed Seven\n                            \"8\"  -> consumed Eight\n                            \"9\"  -> consumed Nine\n                            \"10\" -> consumed Ten\n                            \"j\"  -> consumed Jack\n                            \"q\"  -> consumed Queen\n                            \"k\"  -> consumed King\n                            _    -> []\n\ninstance Read Card where\n  readsPrec d = fmap (, \"\") . mapMaybe card . lex\n    where \n      card (r, s) = Card <$> (readMaybe s :: Maybe Suit)\n                         <*> (readMaybe r :: Maybe Rank)\n\n\nacesHigh :: [Rank]\nacesHigh = [Ace, Ten, Jack, Queen, King]\n\nisSucc :: (Enum a, Eq a, Bounded a) => [a] -> Bool\nisSucc []  = True\nisSucc [x] = True\nisSucc (x:y:zs) = (x /= maxBound && y == succ x) && isSucc (y:zs)\n\nnameHand :: Hand -> String\nnameHand [] = \"Invalid Input\"\nnameHand cards | invalidHand          = \"Invalid hand\"\n               | straight && flush    = \"Straight flush\"\n               | ofKind 4             = \"Four of a kind\"\n               | ofKind 3 && ofKind 2 = \"Full house\"\n               | flush                = \"Flush\"\n               | straight             = \"Straight\"\n               | ofKind 3             = \"Three of a kind\"\n               | uniqRanks == 3       = \"Two pair\"\n               | uniqRanks == 4       = \"One pair\"\n               | otherwise            = \"High card\"\n where\n  sortedRank  = sort $ rank <$> cards\n  rankCounts  = sortBy (compare `on` snd) $ (,) <$> head <*> length <$> group sortedRank\n  uniqRanks   = length rankCounts\n  ofKind n    = any ((==n) . snd) rankCounts\n  straight    = isSucc sortedRank || sortedRank == acesHigh\n  flush       = length (nub $ suit <$> cards) == 1\n  invalidHand = length (nub cards) /= 5\n\ntestHands :: [(String, Hand)]\ntestHands = (,) <$> id <*> mapMaybe readMaybe . words <$>\n  [ \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\"\n  , \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\"\n  , \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\"\n  , \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\"\n  , \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\"\n  , \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 7\u2663\" \n  , \"Bad input\" ]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . (fst <> const \": \" <> nameHand . snd)) testHands\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class PokerHandAnalyzer\n{\n    private enum Hand {\n        Invalid, High_Card, One_Pair, Two_Pair, Three_Of_A_Kind, Straight,\n        Flush, Full_House, Four_Of_A_Kind, Straight_Flush, Five_Of_A_Kind\n    }\n\n    private const bool Y = true;\n    private const char C = '\u2663', D = '\u2666', H = '\u2665', S = '\u2660';\n    private const int rankMask = 0b11_1111_1111_1111;\n    private const int suitMask = 0b1111 << 14;\n    private static readonly string[] ranks = { \"a\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"j\", \"q\", \"k\" };\n    private static readonly string[] suits = { C + \"\", D + \"\", H + \"\", S + \"\" };\n    private static readonly Card[] deck = (from suit in Range(1, 4) from rank in Range(1, 13) select new Card(rank, suit)).ToArray();\n\n    public static void Main() {\n        string[] hands = {\n            \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\",\n            \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\",\n            \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\",\n            \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\",\n            \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\",\n            \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\",\n            \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\",\n            \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\",\n            \"4\u2665 4\u2663 4\u2665 4\u2660 4\u2666\", \n            \"joker 2\u2666 2\u2660 k\u2660 q\u2666\",\n            \"joker 5\u2665 7\u2666 8\u2660 9\u2666\",\n            \"joker 2\u2666 3\u2660 4\u2660 5\u2660\",\n            \"joker 3\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 2\u2666 3\u2660 3\u2666\",\n            \"joker 7\u2665 7\u2666 7\u2660 7\u2663\",\n            \"joker j\u2665 q\u2665 k\u2665 A\u2665\",\n            \"joker 4\u2663 k\u2663 5\u2666 10\u2660\",\n            \"joker k\u2663 7\u2663 6\u2663 4\u2663\",\n            \"joker 2\u2666 joker 4\u2660 5\u2660\",\n            \"joker Q\u2666 joker A\u2660 10\u2660\",\n            \"joker Q\u2666 joker A\u2666 10\u2666\",\n            \"joker 2\u2666 2\u2660 joker q\u2666\"\n        };\n        foreach (var h in hands) {\n            Console.WriteLine($\"{h}: {Analyze(h).Name()}\");\n        }\n    }\n\n    static string Name(this Hand hand) => string.Join('-', hand.ToString().Split('_')).ToLower();\n\n    static List<T> With<T>(this List<T> list, int index, T item) {\n        list[index] = item;\n        return list;\n    }\n\n    struct Card : IEquatable<Card>, IComparable<Card>\n    {\n        public static readonly Card Invalid = new Card(-1, -1);\n        public static readonly Card Joker = new Card(0, 0);\n\n        public Card(int rank, int suit) {\n            (Rank, Suit, Code) = (rank, suit) switch {\n                (_, -1) => (-1, -1, -1),\n                (-1, _) => (-1, -1, -1),\n                (0, _) => (0, 0, 0),\n                (1, _) => (rank, suit, (1 << (13 + suit)) | ((1 << 13) | 1)),\n                (_, _) => (rank, suit, (1 << (13 + suit)) | (1 << (rank - 1)))\n            };\n        }\n\n        public static implicit operator Card((int rank, int suit) tuple) => new Card(tuple.rank, tuple.suit);\n        public int Rank { get; }\n        public int Suit { get; }\n        public int Code { get; }\n\n        public override string ToString() => Rank switch {\n            -1 => \"invalid\",\n            0 => \"joker\",\n            _ => $\"{ranks[Rank-1]}{suits[Suit-1]}\"\n        };\n        \n        public override int GetHashCode() => Rank << 16 | Suit;\n        public bool Equals(Card other) => Rank == other.Rank && Suit == other.Suit;\n\n        public int CompareTo(Card other) {\n            int c = Rank.CompareTo(other.Rank);\n            if (c != 0) return c;\n            return Suit.CompareTo(other.Suit);\n        }\n    }\n\n    static Hand Analyze(string hand) {\n        var cards = ParseHand(hand);\n        if (cards.Count != 5) return Hand.Invalid; \n        cards.Sort();\n        if (cards[0].Equals(Card.Invalid)) return Hand.Invalid;\n        int jokers = cards.LastIndexOf(Card.Joker) + 1;\n        if (jokers > 2) return Hand.Invalid; \n        if (cards.Skip(jokers).Distinct().Count() + jokers != 5) return Hand.Invalid; \n\n        if (jokers == 2) return (from c0 in deck from c1 in deck select Evaluate(cards.With(0, c0).With(1, c1))).Max();\n        if (jokers == 1) return (from c0 in deck select Evaluate(cards.With(0, c0))).Max();\n        return Evaluate(cards);\n    }\n\n    static List<Card> ParseHand(string hand) =>\n        hand.Split(default(char[]), StringSplitOptions.RemoveEmptyEntries)\n        .Select(card => ParseCard(card.ToLower())).ToList();\n\n    static Card ParseCard(string card) => (card.Length, card) switch {\n        (5, \"joker\") => Card.Joker,\n        (3, _) when card[..2] == \"10\" => (10, ParseSuit(card[2])),\n        (2, _) => (ParseRank(card[0]), ParseSuit(card[1])),\n        (_, _) => Card.Invalid\n    };\n\n    static int ParseRank(char rank) => rank switch {\n        'a' => 1,\n        'j' => 11,\n        'q' => 12,\n        'k' => 13,\n        _ when rank >= '2' && rank <= '9' => rank - '0',\n        _ => -1\n    };\n\n    static int ParseSuit(char suit) => suit switch {\n        C => 1, 'c' => 1,\n        D => 2, 'd' => 2,\n        H => 3, 'h' => 3,\n        S => 4, 's' => 4,\n        _ => -1\n    };\n\n    static Hand Evaluate(List<Card> hand) {\n        var frequencies = hand.GroupBy(c => c.Rank).Select(g => g.Count()).OrderByDescending(c => c).ToArray();\n        (int f0, int f1) = (frequencies[0], frequencies.Length > 1 ? frequencies[1] : 0);\n\n        return (IsFlush(), IsStraight(), f0, f1) switch {\n            (_, _, 5, _) => Hand.Five_Of_A_Kind,\n            (Y, Y, _, _) => Hand.Straight_Flush,\n            (_, _, 4, _) => Hand.Four_Of_A_Kind,\n            (_, _, 3, 2) => Hand.Full_House,\n            (Y, _, _, _) => Hand.Flush,\n            (_, Y, _, _) => Hand.Straight,\n            (_, _, 3, _) => Hand.Three_Of_A_Kind,\n            (_, _, 2, 2) => Hand.Two_Pair,\n            (_, _, 2, _) => Hand.One_Pair,\n                        _ => Hand.High_Card\n        };\n\n        bool IsFlush() => hand.Aggregate(suitMask, (r, c) => r & c.Code) > 0;\n\n        bool IsStraight() {\n            int r = hand.Aggregate(0, (r, c) => r | c.Code) & rankMask;\n            for (int i = 0; i < 4; i++) r &= r << 1;\n            return r > 0;\n        }\n    }\n    \n}\n"}
{"id": 410172, "name": "Penney's game", "source": "Translate Haskell to C#: import qualified Data.List as L\nimport System.IO\nimport System.Random\n\ndata CoinToss = H | T deriving (Read, Show, Eq)\n\nparseToss :: String -> [CoinToss]\nparseToss [] = []\nparseToss (s:sx)\n  | s == 'h' || s == 'H' = H : parseToss sx\n  | s == 't' || s == 'T' = T : parseToss sx\n  | otherwise = parseToss sx\n\nnotToss :: CoinToss -> CoinToss\nnotToss H = T\nnotToss T = H\n\ninstance Random CoinToss where\n  random g = let (b, gb) = random g in (if b then H else T, gb)\n  randomR = undefined\n\nprompt :: (Read a) => String -> String -> (String -> Maybe a) -> IO a\nprompt msg err parse = do\n  putStrLn msg\n  line <- getLine\n  let ans = parse line\n  case ans of\n    Nothing   -> do\n      putStrLn err\n      prompt msg err parse\n    Just ansB -> return ansB\n\nshowCat :: (Show a) => [a] -> String\nshowCat = concatMap show\n\ndata Winner = Player | CPU\n\n\nrunToss :: (RandomGen g) => [CoinToss] -> [CoinToss] -> g -> ([CoinToss], Winner)\nrunToss player cpu gen =\n  let stream = randoms gen\n      run ss@(s:sx)\n        | L.isPrefixOf player ss = player\n        | L.isPrefixOf cpu ss    = cpu\n        | otherwise              = s : run sx\n      winner = run stream\n  in if L.isSuffixOf player winner\n     then (winner, Player)\n     else (winner, CPU)\n\ngame :: (RandomGen g, Num a, Show a) => Bool -> a -> a -> g -> IO ()\ngame cpuTurn playerScore cpuScore gen = do\n  putStrLn $ \"\\nThe current score is CPU: \" ++ show cpuScore\n    ++ \", You: \" ++ show playerScore\n\n  let (genA, genB) = split gen\n      promptPlayer check =\n        prompt \"Pick 3 coin sides: \" \"Invalid input.\" $ \\s ->\n          let tosses = parseToss s in\n          if check tosses then Just tosses else Nothing\n      promptCpu x  = putStrLn $ \"I have chosen: \" ++ showCat x\n\n  (tosses, winner) <-\n    if cpuTurn\n    then do\n      let cpuChoice = take 3 $ randoms gen\n      promptCpu cpuChoice\n      playerChoice <- promptPlayer $ \\n -> n /= cpuChoice && 3 == length n\n      return $ runToss playerChoice cpuChoice genA\n    else do\n      playerChoice <- promptPlayer $ \\n -> 3 == length n\n      let cpuChoice = case playerChoice of [a,b,_] -> [notToss b, a, b]\n      promptCpu cpuChoice\n      return $ runToss playerChoice cpuChoice genA\n\n  putStrLn $ \"The sequence tossed was: \" ++ showCat tosses\n\n  case winner of\n    Player -> do\n      putStrLn \"You win!\"\n      game (not cpuTurn) (playerScore + 1) cpuScore genB\n    CPU -> do\n      putStrLn \"I win!\"\n      game (not cpuTurn) playerScore (cpuScore + 1) genB\n\nmain :: IO ()\nmain = do\n  hSetBuffering stdin LineBuffering\n  stdgen <- getStdGen\n  let (cpuFirst, genA) = random stdgen\n  game cpuFirst 0 0 genA\n", "target": "using static System.Console;\nusing static System.Threading.Thread;\nusing System;\n\npublic static class PenneysGame\n{\n    const int pause = 500;\n    const int N = 3;\n    static Random rng = new Random();\n\n    static int Toss() => rng.Next(2);\n\n    static string AsString(this int sequence) {\n        string s = \"\";\n        for (int b = 0b100; b > 0; b >>= 1) {\n            s += (sequence & b) > 0 ? 'T' : 'H';\n        }\n        return s;\n    }\n\n    static int UserInput() {\n        while (true) {\n            switch (ReadKey().Key) {\n                case ConsoleKey.Escape: return -1;\n                case ConsoleKey.H: return 0;\n                case ConsoleKey.T: return 1;\n            }\n            Console.Write('\\b');\n        }\n    }\n\n    public static void Main2() {\n        int yourScore = 0, myScore = 0;\n        while (true) {\n            WriteLine($\"Your score: {yourScore}, My score: {myScore}\");\n            WriteLine(\"Determining who goes first...\");\n            Sleep(pause);\n            bool youStart = Toss() == 1;\n            WriteLine(youStart ? \"You go first.\" : \"I go first.\");\n            int yourSequence = 0, mySequence = 0;\n            if (youStart) {\n                WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                int userChoice;\n                for (int i = 0; i < N; i++) {\n                    if ((userChoice = UserInput()) < 0) return;\n                    yourSequence = (yourSequence << 1) + userChoice;\n                }\n                mySequence = ((~yourSequence << 1) & 0b100) | (yourSequence >> 1);\n            } else {\n                for (int i = 0; i < N; i++) {\n                    mySequence = (mySequence << 1) + Toss();\n                }\n\n                WriteLine(\"I chose \" + mySequence.AsString());\n                do {\n                    WriteLine(\"Choose your sequence of (H)eads and (T)ails (or press Esc to exit)\");\n                    int choice;\n                    yourSequence = 0;\n                    for (int i = 0; i < N; i++) {\n                        if ((choice = UserInput()) < 0) return;\n                        yourSequence = (yourSequence << 1) + choice;\n                    }\n                    if (yourSequence == mySequence) {\n                        WriteLine();\n                        WriteLine(\"You cannot choose the same sequence.\");\n                    }\n                } while (yourSequence == mySequence);\n            }\n\n            WriteLine();\n            WriteLine($\"Your sequence: {yourSequence.AsString()}, My sequence: {mySequence.AsString()}\");\n            WriteLine(\"Tossing...\");\n            int sequence = 0;\n            for (int i = 0; i < N; i++) {\n                Sleep(pause);\n                int toss = Toss();\n                sequence = (sequence << 1) + toss;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            while (true) {\n                if (sequence == yourSequence) {\n                    WriteLine();\n                    WriteLine(\"You win!\");\n                    yourScore++;\n                    break;\n                } else if (sequence == mySequence) {\n                    WriteLine();\n                    WriteLine(\"I win!\");\n                    myScore++;\n                    break;\n                }\n                Sleep(pause);\n                int toss = Toss();\n                sequence = ((sequence << 1) + toss) & 0b111;\n                Write(toss > 0 ? 'T' : 'H');\n            }\n            WriteLine(\"Press a key.\");\n            ReadKey();\n            Clear();\n        }\n    }\n\n}\n"}
{"id": 410173, "name": "Eban numbers", "source": "Translate Haskell to C#: \nimport Data.List (intercalate)\nimport Text.Printf (printf)\nimport Data.List.Split (chunksOf)\n\nisEban :: Int -> Bool\nisEban n = all (`elem` [0, 2, 4, 6]) z\n where\n  (b, r1) = n  `quotRem` (10 ^ 9)\n  (m, r2) = r1 `quotRem` (10 ^ 6)\n  (t, r3) = r2 `quotRem` (10 ^ 3)\n  z       = b : map (\\x -> if x >= 30 && x <= 66 then x `mod` 10 else x) [m, t, r3]\n\nebans = map f\n where\n  f x = (thousands x, thousands $ length $ filter isEban [1..x])\n\nthousands:: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  uncurry (printf \"eban numbers up to and including 1000: %2s\\n%s\\n\\n\") $ r [1..1000]\n  uncurry (printf \"eban numbers between 1000 and 4000: %2s\\n%s\\n\\n\") $ r [1000..4000]\n  mapM_ (uncurry (printf \"eban numbers up and including %13s: %5s\\n\")) ebanCounts\n where \n  ebanCounts = ebans [        10_000\n                     ,       100_000\n                     ,     1_000_000\n                     ,    10_000_000\n                     ,   100_000_000\n                     , 1_000_000_000 ]\n  r = ((,) <$> thousands . length <*> show) . filter isEban\n", "target": "using System;\n\nnamespace EbanNumbers {\n    struct Interval {\n        public int start, end;\n        public bool print;\n\n        public Interval(int start, int end, bool print) {\n            this.start = start;\n            this.end = end;\n            this.print = print;\n        }\n    }\n\n    class Program {\n        static void Main() {\n            Interval[] intervals = {\n                new Interval(2, 1_000, true),\n                new Interval(1_000, 4_000, true),\n                new Interval(2, 10_000, false),\n                new Interval(2, 100_000, false),\n                new Interval(2, 1_000_000, false),\n                new Interval(2, 10_000_000, false),\n                new Interval(2, 100_000_000, false),\n                new Interval(2, 1_000_000_000, false),\n            };\n            foreach (var intv in intervals) {\n                if (intv.start == 2) {\n                    Console.WriteLine(\"eban numbers up to and including {0}:\", intv.end);\n                } else {\n                    Console.WriteLine(\"eban numbers between {0} and {1} (inclusive):\", intv.start, intv.end);\n                }\n\n                int count = 0;\n                for (int i = intv.start; i <= intv.end; i += 2) {\n                    int b = i / 1_000_000_000;\n                    int r = i % 1_000_000_000;\n                    int m = r / 1_000_000;\n                    r = i % 1_000_000;\n                    int t = r / 1_000;\n                    r %= 1_000;\n                    if (m >= 30 && m <= 66) m %= 10;\n                    if (t >= 30 && t <= 66) t %= 10;\n                    if (r >= 30 && r <= 66) r %= 10;\n                    if (b == 0 || b == 2 || b == 4 || b == 6) {\n                        if (m == 0 || m == 2 || m == 4 || m == 6) {\n                            if (t == 0 || t == 2 || t == 4 || t == 6) {\n                                if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                    if (intv.print) Console.Write(\"{0} \", i);\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (intv.print) {\n                    Console.WriteLine();\n                }\n                Console.WriteLine(\"count = {0}\\n\", count);\n            }\n        }\n    }\n}\n"}
{"id": 410174, "name": "Eban numbers", "source": "Translate Haskell to C#: \nimport Data.List (intercalate)\nimport Text.Printf (printf)\nimport Data.List.Split (chunksOf)\n\nisEban :: Int -> Bool\nisEban n = all (`elem` [0, 2, 4, 6]) z\n where\n  (b, r1) = n  `quotRem` (10 ^ 9)\n  (m, r2) = r1 `quotRem` (10 ^ 6)\n  (t, r3) = r2 `quotRem` (10 ^ 3)\n  z       = b : map (\\x -> if x >= 30 && x <= 66 then x `mod` 10 else x) [m, t, r3]\n\nebans = map f\n where\n  f x = (thousands x, thousands $ length $ filter isEban [1..x])\n\nthousands:: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  uncurry (printf \"eban numbers up to and including 1000: %2s\\n%s\\n\\n\") $ r [1..1000]\n  uncurry (printf \"eban numbers between 1000 and 4000: %2s\\n%s\\n\\n\") $ r [1000..4000]\n  mapM_ (uncurry (printf \"eban numbers up and including %13s: %5s\\n\")) ebanCounts\n where \n  ebanCounts = ebans [        10_000\n                     ,       100_000\n                     ,     1_000_000\n                     ,    10_000_000\n                     ,   100_000_000\n                     , 1_000_000_000 ]\n  r = ((,) <$> thousands . length <*> show) . filter isEban\n", "target": "using System;\n\nnamespace EbanNumbers {\n    struct Interval {\n        public int start, end;\n        public bool print;\n\n        public Interval(int start, int end, bool print) {\n            this.start = start;\n            this.end = end;\n            this.print = print;\n        }\n    }\n\n    class Program {\n        static void Main() {\n            Interval[] intervals = {\n                new Interval(2, 1_000, true),\n                new Interval(1_000, 4_000, true),\n                new Interval(2, 10_000, false),\n                new Interval(2, 100_000, false),\n                new Interval(2, 1_000_000, false),\n                new Interval(2, 10_000_000, false),\n                new Interval(2, 100_000_000, false),\n                new Interval(2, 1_000_000_000, false),\n            };\n            foreach (var intv in intervals) {\n                if (intv.start == 2) {\n                    Console.WriteLine(\"eban numbers up to and including {0}:\", intv.end);\n                } else {\n                    Console.WriteLine(\"eban numbers between {0} and {1} (inclusive):\", intv.start, intv.end);\n                }\n\n                int count = 0;\n                for (int i = intv.start; i <= intv.end; i += 2) {\n                    int b = i / 1_000_000_000;\n                    int r = i % 1_000_000_000;\n                    int m = r / 1_000_000;\n                    r = i % 1_000_000;\n                    int t = r / 1_000;\n                    r %= 1_000;\n                    if (m >= 30 && m <= 66) m %= 10;\n                    if (t >= 30 && t <= 66) t %= 10;\n                    if (r >= 30 && r <= 66) r %= 10;\n                    if (b == 0 || b == 2 || b == 4 || b == 6) {\n                        if (m == 0 || m == 2 || m == 4 || m == 6) {\n                            if (t == 0 || t == 2 || t == 4 || t == 6) {\n                                if (r == 0 || r == 2 || r == 4 || r == 6) {\n                                    if (intv.print) Console.Write(\"{0} \", i);\n                                    count++;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (intv.print) {\n                    Console.WriteLine();\n                }\n                Console.WriteLine(\"count = {0}\\n\", count);\n            }\n        }\n    }\n}\n"}
{"id": 410175, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Haskell to C#: import Control.Monad ((>=>))\nimport Data.Maybe (mapMaybe)\nimport System.Environment (getArgs)\n\n\n\ntryFor :: Int -> Int -> Maybe Int\ntryFor s = foldr (>=>) pure $ replicate s step\n  where\n    step n\n      | n `mod` (s - 1) == 0 = Just $ n * s `div` (s - 1) + 1\n      | otherwise = Nothing\n\n\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let n =\n        case args of\n          [] -> 5\n          s:_ -> read s\n      a = head . mapMaybe (tryFor n) $ [n,2 * n ..]\n  print a\n", "target": "class Test\n{\n    static bool valid(int n, int nuts)\n    {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n        {\n            if (nuts % n != 1)\n            {\n                return false;\n            }                \n        }\n            \n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    static void Main(string[] args)\n    {\n        int x = 0;\n        for (int n = 2; n < 10; n++)\n        {\n            while (!valid(n, x))\n                x++;\n            System.Console.WriteLine(n + \": \" + x);\n        }\n    }\n}\n"}
{"id": 410176, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Haskell to C#: import Control.Monad ((>=>))\nimport Data.Maybe (mapMaybe)\nimport System.Environment (getArgs)\n\n\n\ntryFor :: Int -> Int -> Maybe Int\ntryFor s = foldr (>=>) pure $ replicate s step\n  where\n    step n\n      | n `mod` (s - 1) == 0 = Just $ n * s `div` (s - 1) + 1\n      | otherwise = Nothing\n\n\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let n =\n        case args of\n          [] -> 5\n          s:_ -> read s\n      a = head . mapMaybe (tryFor n) $ [n,2 * n ..]\n  print a\n", "target": "class Test\n{\n    static bool valid(int n, int nuts)\n    {\n        for (int k = n; k != 0; k--, nuts -= 1 + nuts / n)\n        {\n            if (nuts % n != 1)\n            {\n                return false;\n            }                \n        }\n            \n        return nuts != 0 && (nuts % n == 0);\n    }\n\n    static void Main(string[] args)\n    {\n        int x = 0;\n        for (int n = 2; n < 10; n++)\n        {\n            while (!valid(n, x))\n                x++;\n            System.Console.WriteLine(n + \": \" + x);\n        }\n    }\n}\n"}
{"id": 410177, "name": "Polyspiral", "source": "Translate Haskell to C#: \nimport Reflex\nimport Reflex.Dom\nimport Reflex.Dom.Time\nimport Data.Text (Text, pack) \nimport Data.Map (Map, fromList)\nimport Data.Time.Clock (getCurrentTime)\nimport Control.Monad.Trans (liftIO)\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\nmain = mainWidget $ do \n\n  \n  dTick <- tickLossy 0.05 =<< liftIO getCurrentTime \n\n  \n  dCounter <- foldDyn (\\_ c -> c+1) (0::Int) dTick\n\n  let \n      \n      dAngle = fmap (\\c -> fromIntegral c / 800.0) dCounter\n\n      \n      dSpiralMap = fmap toSpiralMap dAngle\n\n      \n      width = 600\n      height = 600\n\n      boardAttrs = \n         fromList [ (\"width\" , pack $ show width)\n                  , (\"height\", pack $ show height)\n                  , (\"viewBox\", pack $ show (-width/2) ++ \" \" ++ show (-height/2) ++ \" \" ++ show width ++ \" \" ++ show height)\n                  ]\n\n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Polyspiral\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Polyspiral#Haskell\") $ text \"Rosetta Code / Polyspiral / Haskell\"\n\n  el \"br\" $ return ()\n  elSvgns \"svg\" (constDyn boardAttrs) (listWithKey dSpiralMap showLine)\n\n  return ()\n\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n  fromList [ ( \"x1\",    pack $ show x1)\n           , ( \"y1\",    pack $ show y1)\n           , ( \"x2\",    pack $ show x2)\n           , ( \"y2\",    pack $ show y2)\n           , ( \"style\", \"stroke:blue\")\n           ]    \n\n\nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n\n\nadvance :: Float -> (Point, Float, Float) -> (Point, Float, Float)\nadvance angle ((x,y), len, rot) = \n  let new_x = x + len * cos rot\n      new_y = y + len * sin rot\n      new_len = len + 3.0 \n      new_rot = rot + angle\n  in ((new_x, new_y), new_len, new_rot)\n\n\ntoSpiralMap :: Float -> Map Int ((Float,Float),(Float,Float))\ntoSpiralMap angle =\n      fromList                       \n  $   zip [0..]                      \n  $   (\\pts -> zip pts $ tail pts)   \n  $   take 80                        \n  $   (\\(pt,_,_) -> pt)              \n  <$> iterate (advance angle) ((0, 0), 0, 0)  \n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\nusing System.Windows.Threading;\n\nnamespace Polyspiral\n{\n    public partial class Form1 : Form\n    {\n        private double inc;\n\n        public Form1()\n        {\n            Width = Height = 640;\n            StartPosition = FormStartPosition.CenterScreen;\n            SetStyle(\n                ControlStyles.AllPaintingInWmPaint |\n                ControlStyles.UserPaint |\n                ControlStyles.DoubleBuffer,\n                true);\n\n            var timer = new DispatcherTimer();\n            timer.Tick += (s, e) => { inc = (inc + 0.05) % 360; Refresh(); };\n            timer.Interval = new TimeSpan(0, 0, 0, 0, 40);\n            timer.Start();\n        }\n\n        private void DrawSpiral(Graphics g, int len, double angleIncrement)\n        {\n            double x1 = Width / 2;\n            double y1 = Height / 2;\n            double angle = angleIncrement;\n\n            for (int i = 0; i < 150; i++)\n            {\n                double x2 = x1 + Math.Cos(angle) * len;\n                double y2 = y1 - Math.Sin(angle) * len;\n                g.DrawLine(Pens.Blue, (int)x1, (int)y1, (int)x2, (int)y2);\n                x1 = x2;\n                y1 = y2;\n\n                len += 3;\n\n                angle = (angle + angleIncrement) % (Math.PI * 2);\n            }\n        }\n\n        protected override void OnPaint(PaintEventArgs args)\n        {\n            var g = args.Graphics;\n            g.SmoothingMode = SmoothingMode.AntiAlias;\n            g.Clear(Color.White);\n\n            DrawSpiral(g, 5, ToRadians(inc));\n        }\n\n        private double ToRadians(double angle)\n        {\n            return Math.PI * angle / 180.0;\n        }\n    }\n}\n"}
{"id": 410178, "name": "Polyspiral", "source": "Translate Haskell to C#: \nimport Reflex\nimport Reflex.Dom\nimport Reflex.Dom.Time\nimport Data.Text (Text, pack) \nimport Data.Map (Map, fromList)\nimport Data.Time.Clock (getCurrentTime)\nimport Control.Monad.Trans (liftIO)\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\nmain = mainWidget $ do \n\n  \n  dTick <- tickLossy 0.05 =<< liftIO getCurrentTime \n\n  \n  dCounter <- foldDyn (\\_ c -> c+1) (0::Int) dTick\n\n  let \n      \n      dAngle = fmap (\\c -> fromIntegral c / 800.0) dCounter\n\n      \n      dSpiralMap = fmap toSpiralMap dAngle\n\n      \n      width = 600\n      height = 600\n\n      boardAttrs = \n         fromList [ (\"width\" , pack $ show width)\n                  , (\"height\", pack $ show height)\n                  , (\"viewBox\", pack $ show (-width/2) ++ \" \" ++ show (-height/2) ++ \" \" ++ show width ++ \" \" ++ show height)\n                  ]\n\n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Polyspiral\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Polyspiral#Haskell\") $ text \"Rosetta Code / Polyspiral / Haskell\"\n\n  el \"br\" $ return ()\n  elSvgns \"svg\" (constDyn boardAttrs) (listWithKey dSpiralMap showLine)\n\n  return ()\n\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n  fromList [ ( \"x1\",    pack $ show x1)\n           , ( \"y1\",    pack $ show y1)\n           , ( \"x2\",    pack $ show x2)\n           , ( \"y2\",    pack $ show y2)\n           , ( \"style\", \"stroke:blue\")\n           ]    \n\n\nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n\n\nadvance :: Float -> (Point, Float, Float) -> (Point, Float, Float)\nadvance angle ((x,y), len, rot) = \n  let new_x = x + len * cos rot\n      new_y = y + len * sin rot\n      new_len = len + 3.0 \n      new_rot = rot + angle\n  in ((new_x, new_y), new_len, new_rot)\n\n\ntoSpiralMap :: Float -> Map Int ((Float,Float),(Float,Float))\ntoSpiralMap angle =\n      fromList                       \n  $   zip [0..]                      \n  $   (\\pts -> zip pts $ tail pts)   \n  $   take 80                        \n  $   (\\(pt,_,_) -> pt)              \n  <$> iterate (advance angle) ((0, 0), 0, 0)  \n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "using System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\nusing System.Windows.Threading;\n\nnamespace Polyspiral\n{\n    public partial class Form1 : Form\n    {\n        private double inc;\n\n        public Form1()\n        {\n            Width = Height = 640;\n            StartPosition = FormStartPosition.CenterScreen;\n            SetStyle(\n                ControlStyles.AllPaintingInWmPaint |\n                ControlStyles.UserPaint |\n                ControlStyles.DoubleBuffer,\n                true);\n\n            var timer = new DispatcherTimer();\n            timer.Tick += (s, e) => { inc = (inc + 0.05) % 360; Refresh(); };\n            timer.Interval = new TimeSpan(0, 0, 0, 0, 40);\n            timer.Start();\n        }\n\n        private void DrawSpiral(Graphics g, int len, double angleIncrement)\n        {\n            double x1 = Width / 2;\n            double y1 = Height / 2;\n            double angle = angleIncrement;\n\n            for (int i = 0; i < 150; i++)\n            {\n                double x2 = x1 + Math.Cos(angle) * len;\n                double y2 = y1 - Math.Sin(angle) * len;\n                g.DrawLine(Pens.Blue, (int)x1, (int)y1, (int)x2, (int)y2);\n                x1 = x2;\n                y1 = y2;\n\n                len += 3;\n\n                angle = (angle + angleIncrement) % (Math.PI * 2);\n            }\n        }\n\n        protected override void OnPaint(PaintEventArgs args)\n        {\n            var g = args.Graphics;\n            g.SmoothingMode = SmoothingMode.AntiAlias;\n            g.Clear(Color.White);\n\n            DrawSpiral(g, 5, ToRadians(inc));\n        }\n\n        private double ToRadians(double angle)\n        {\n            return Math.PI * angle / 180.0;\n        }\n    }\n}\n"}
{"id": 410179, "name": "Merge and aggregate datasets", "source": "Translate Haskell to C#: import Data.List\nimport Data.Maybe\nimport System.IO (readFile)\nimport Text.Read (readMaybe)\nimport Control.Applicative ((<|>))\n\n\n\nnewtype DB = DB { entries :: [Patient] }\n  deriving Show\n\ninstance Semigroup DB where\n  DB a <> DB b = normalize $ a <> b\n\ninstance Monoid DB where\n  mempty = DB []\n\nnormalize :: [Patient] -> DB\nnormalize = DB\n            . map mconcat \n            . groupBy (\\x y -> pid x == pid y)\n            . sortOn pid\n \n\n\ndata Patient = Patient { pid :: String\n                       , name :: Maybe String\n                       , visits :: [String]\n                       , scores :: [Float] }\n  deriving Show\n\ninstance Semigroup Patient where\n  Patient p1 n1 v1 s1 <> Patient p2 n2 v2 s2 =\n    Patient (fromJust $ Just p1 <|> Just p2)\n            (n1 <|> n2)\n            (v1 <|> v2)\n            (s1 <|> s2)\n\ninstance Monoid Patient where\n  mempty = Patient mempty mempty mempty mempty\n    \n\n\nreadDB :: String  -> DB\nreadDB = normalize\n         . mapMaybe readPatient\n         . readCSV\n\nreadPatient r = do\n  i <- lookup \"PATIENT_ID\" r\n  let n = lookup \"LASTNAME\" r\n  let d = lookup \"VISIT_DATE\" r >>= readDate\n  let s = lookup \"SCORE\" r >>= readMaybe\n  return $ Patient i n (maybeToList d) (maybeToList s)\n  where\n    readDate [] = Nothing\n    readDate d = Just d\n\nreadCSV :: String -> [(String, String)]\nreadCSV txt = zip header <$> body\n  where\n    header:body = splitBy ',' <$> lines txt\n    splitBy ch = unfoldr go\n      where\n        go [] = Nothing\n        go s  = Just $ drop 1 <$> span (/= ch) s\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing System.Runtime.Serialization;\n\npublic static class MergeAndAggregateDatasets\n{\n    public static void Main()\n    {\n        string patientsCsv = @\"\nPATIENT_ID,LASTNAME\n1001,Hopper\n4004,Wirth\n3003,Kemeny\n2002,Gosling\n5005,Kurtz\";\n\n        string visitsCsv = @\"\nPATIENT_ID,VISIT_DATE,SCORE\n2002,2020-09-10,6.8\n1001,2020-09-17,5.5\n4004,2020-09-24,8.4\n2002,2020-10-08,\n1001,,6.6\n3003,2020-11-12,\n4004,2020-11-05,7.0\n1001,2020-11-19,5.3\";\n\n        string format = \"yyyy-MM-dd\";\n        var formatProvider = new DateTimeFormat(format).FormatProvider;\n\n        var patients = ParseCsv(\n            patientsCsv.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries),\n            line => (PatientId: int.Parse(line[0]), LastName: line[1]));\n\n        var visits = ParseCsv(\n            visitsCsv.Split(Environment.NewLine, StringSplitOptions.RemoveEmptyEntries),\n            line => (\n                PatientId: int.Parse(line[0]),\n                VisitDate: DateTime.TryParse(line[1], formatProvider, DateTimeStyles.None, out var date) ? date : default(DateTime?),\n                Score: double.TryParse(line[2], out double score) ? score : default(double?)\n            )\n        );\n\n        var results =\n            patients.GroupJoin(visits,\n                p => p.PatientId,\n                v => v.PatientId,\n                (p, vs) => (\n                    p.PatientId,\n                    p.LastName,\n                    LastVisit: vs.Max(v => v.VisitDate),\n                    ScoreSum: vs.Sum(v => v.Score),\n                    ScoreAvg: vs.Average(v => v.Score)\n                )\n            ).OrderBy(r => r.PatientId);\n\n        Console.WriteLine(\"| PATIENT_ID | LASTNAME | LAST_VISIT | SCORE_SUM | SCORE_AVG |\");\n        foreach (var r in results) {\n            Console.WriteLine($\"| {r.PatientId,-10} | {r.LastName,-8} | {r.LastVisit?.ToString(format)\u00a0?? \"\",-10} | {r.ScoreSum,9} | {r.ScoreAvg,9} |\");\n        }\n    }\n\n    private static IEnumerable<T> ParseCsv<T>(string[] contents, Func<string[], T> constructor)\n    {\n        for (int i = 1; i < contents.Length; i++) {\n            var line = contents[i].Split(',');\n            yield return constructor(line);\n        }\n    }\n\n}\n"}
{"id": 410180, "name": "Active Directory_Connect", "source": "Translate Haskell to C#: \n\nmodule Main (main) where\n\nimport           Data.Foldable (for_)\nimport qualified Data.Text.Encoding as Text (encodeUtf8)\nimport           Ldap.Client (Attr(..), Filter(..))\nimport qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly)\n\nmain :: IO ()\nmain = do\n    entries <- Ldap.with (Ldap.Plain \"localhost\") 389 $ \\ldap ->\n        Ldap.search ldap (Ldap.Dn \"o=example.com\") (Ldap.typesOnly True) (Attr \"uid\" := Text.encodeUtf8 \"user\") []\n    for_ entries $ \\entry ->\n        print entry\n", "target": "\nvar objDE = new System.DirectoryServices.DirectoryEntry(\"LDAP:\n"}
{"id": 410181, "name": "Knapsack problem_Bounded", "source": "Translate Haskell to C#: inv = \t[(\"map\",9,150,1), (\"compass\",13,35,1), (\"water\",153,200,2), (\"sandwich\",50,60,2),\n\t(\"glucose\",15,60,2), (\"tin\",68,45,3), (\"banana\",27,60,3), (\"apple\",39,40,3),\n\t(\"cheese\",23,30,1), (\"beer\",52,10,3), (\"cream\",11,70,1), (\"camera\",32,30,1),\n\t\n\t(\"tshirt\",24,15,2), (\"trousers\",48,10,2), (\"umbrella\",73,40,1), (\"wtrousers\",42,70,1),\n\t(\"woverclothes\",43,75,1), (\"notecase\",22,80,1), (\"sunglasses\",7,20,1), (\"towel\",18,12,2),\n\t(\"socks\",4,50,1), (\"book\",30,10,2)]\n\nknapsack = foldr addItem (repeat (0,[])) where\n\taddItem (name,w,v,c) old = foldr inc old [1..c] where\n\t\tinc i list = left ++ zipWith max right new where\n\t\t\t(left, right) = splitAt (w * i) list\n\t\t\tnew = map (\\(val,itms)->(val + v * i, (name,i):itms)) old\n\nmain = print $ (knapsack inv) !! 400\n", "target": "using System;  \nclass program\n{\n    static void Main()\n    {\n        knapSack(40);\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        Console.Write(knapSack(400) + \"\\n\" + sw.Elapsed);  \n        Console.Read();\n    }\n\n    static string knapSack(uint w1)\n    {\n        init(); change();\n        uint n = (uint)w.Length; var K = new uint[n + 1, w1 + 1];\n        for (uint vi, wi, w0, x, i = 0; i < n; i++)\n            for (vi = v[i], wi = w[i], w0 = 1; w0 <= w1; w0++)\n            {\n                x = K[i, w0];\n                if (wi <= w0) x = max(vi + K[i, w0 - wi], x);\n                K[i + 1, w0] = x;\n            }\n        string str = \"\";\n        for (uint v1 = K[n, w1]; v1 > 0; n--)\n            if (v1 != K[n - 1, w1])\n            {\n                v1 -= v[n - 1]; w1 -= w[n - 1]; str += items[n - 1] + \"\\n\";\n            }\n        return str;\n    }\n\n    static uint max(uint a, uint b) { return a > b ? a : b; }\n\n    static byte[] w, v; static string[] items;\n\n    static byte[] p = { 1, 1, 2, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2 };\n\n    static void init()\n    {\n        w = new byte[] { 9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11,\n                          32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30 };\n\n        v = new byte[] { 150, 35, 200, 60, 60, 45, 60, 40, 30, 10, 70,\n                          30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10 };\n\n        items = new string[] {\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"tin\",\n                              \"banana\",\"apple\",\"cheese\",\"beer\",\"suntan cream\",\n                              \"camera\",\"T-shirt\",\"trousers\",\"umbrella\",\n                              \"waterproof trousers\",\"waterproof overclothes\",\n                              \"note-case\",\"sunglasses\",\"towel\",\"socks\",\"book\"};\n    }\n\n    static void change()\n    {\n        int n = w.Length, s = 0, i, j, k; byte xi;\n        for (i = 0; i < n; i++) s += p[i];\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = w[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            w = x;\n        }\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = v[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            v = x;\n        }\n        string[] pItems = new string[s]; string itemI;\n        for (k = i = 0; i < n; i++)\n            for (itemI = items[i], j = p[i]; j > 0; j--) pItems[k++] = itemI;\n        items = pItems;\n    }\n}\n"}
{"id": 410182, "name": "Solve a Hidato puzzle", "source": "Translate Haskell to C#: \n\n\nimport qualified Data.IntMap as I\nimport Data.IntMap (IntMap)\nimport Data.List\nimport Data.Maybe\nimport Data.Time.Clock\n\ndata BoardProblem = Board\n  { cells :: IntMap (IntMap Int)\n  , endVal :: Int\n  , onePos :: (Int, Int)\n  , givens :: [Int]\n  } deriving (Show, Eq)\n\ntupIns x y v m = I.insert x (I.insert y v (I.findWithDefault I.empty x m)) m\n\ntupLookup x y m = I.lookup x m >>= I.lookup y\n\nmakeBoard =\n  (\\x ->\n      x\n      { givens = dropWhile (<= 1) $ sort $ givens x\n      }) .\n  foldl' \n    f\n    (Board I.empty 0 (0, 0) []) .\n  concatMap (zip [0 ..]) . zipWith (\\y w -> map (y, ) $ words w) [0 ..]\n  where\n    f bd (x, (y, v)) =\n      if v == \".\"\n        then bd\n        else Board\n               (tupIns x y (read v) (cells bd))\n               (if read v > endVal bd\n                  then read v\n                  else endVal bd)\n               (if v == \"1\"\n                  then (x, y)\n                  else onePos bd)\n               (read v : givens bd)\n\nhidato brd = listToMaybe $ h 2 (cells brd) (onePos brd) (givens brd)\n  where\n    h nval pmap (x, y) gs\n      | nval == endVal brd = [pmap]\n      | nval == head gs =\n        if null nvalAdj\n          then []\n          else h (nval + 1) pmap (fst $ head nvalAdj) (tail gs)\n      | not $ null nvalAdj = h (nval + 1) pmap (fst $ head nvalAdj) gs\n      | otherwise = hEmptyAdj\n      where\n        around =\n          [ (x - 1, y - 1)\n          , (x, y - 1)\n          , (x + 1, y - 1)\n          , (x - 1, y)\n          , (x + 1, y)\n          , (x - 1, y + 1)\n          , (x, y + 1)\n          , (x + 1, y + 1)\n          ]\n        lkdUp = map (\\(x, y) -> ((x, y), tupLookup x y pmap)) around\n        nvalAdj = filter ((== Just nval) . snd) lkdUp\n        hEmptyAdj =\n          concatMap\n            (\\((nx, ny), _) -> h (nval + 1) (tupIns nx ny nval pmap) (nx, ny) gs) $\n          filter ((== Just 0) . snd) lkdUp\n\nprintCellMap cellmap = putStrLn $ concat strings\n  where\n    maxPos = xyBy I.findMax maximum\n    minPos = xyBy I.findMin minimum\n    xyBy :: (forall a. IntMap a -> (Int, a)) -> ([Int] -> Int) -> (Int, Int)\n    xyBy a b = (fst (a cellmap), b $ map (fst . a . snd) $ I.toList cellmap)\n    strings =\n      map\n        f\n        [ (x, y)\n        | y <- [snd minPos .. snd maxPos] \n        , x <- [fst minPos .. fst maxPos] ]\n    f (x, y) =\n      let z =\n            if x == fst maxPos\n              then \"\\n\"\n              else \" \"\n      in case tupLookup x y cellmap of\n           Nothing -> \"  \" ++ z\n           Just n ->\n             (if n < 10\n                then ' ' : show n\n                else show n) ++\n             z\n\nmain = do\n  let sampleBoard = makeBoard sample\n  printCellMap $ cells sampleBoard\n  printCellMap $ fromJust $ hidato sampleBoard\n\nsample =\n  [ \" 0 33 35  0  0\"\n  , \" 0  0 24 22  0\"\n  , \" 0  0  0 21  0  0\"\n  , \" 0 26  0 13 40 11\"\n  , \"27  0  0  0  9  0  1\"\n  , \".  .   0  0 18  0  0\"\n  , \".  .  .  .   0  7  0  0\"\n  , \".  .  .  .  .  .   5  0\"\n  ]\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hidatoMoves).Solve(false, new [,] {\n            {  0, 33, 35,  0,  0, -1, -1, -1 },\n            {  0,  0, 24, 22,  0, -1, -1, -1 },\n            {  0,  0,  0, 21,  0,  0, -1, -1 },\n            {  0, 26,  0, 13, 40, 11, -1, -1 },\n            { 27,  0,  0,  0,  9,  0,  1, -1 },\n            { -1, -1,  0,  0, 18,  0,  0, -1 },\n            { -1, -1, -1, -1,  0,  7,  0,  0 },\n            { -1, -1, -1, -1, -1, -1,  5,  0 }\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 410183, "name": "Solve a Hidato puzzle", "source": "Translate Haskell to C#: \n\n\nimport qualified Data.IntMap as I\nimport Data.IntMap (IntMap)\nimport Data.List\nimport Data.Maybe\nimport Data.Time.Clock\n\ndata BoardProblem = Board\n  { cells :: IntMap (IntMap Int)\n  , endVal :: Int\n  , onePos :: (Int, Int)\n  , givens :: [Int]\n  } deriving (Show, Eq)\n\ntupIns x y v m = I.insert x (I.insert y v (I.findWithDefault I.empty x m)) m\n\ntupLookup x y m = I.lookup x m >>= I.lookup y\n\nmakeBoard =\n  (\\x ->\n      x\n      { givens = dropWhile (<= 1) $ sort $ givens x\n      }) .\n  foldl' \n    f\n    (Board I.empty 0 (0, 0) []) .\n  concatMap (zip [0 ..]) . zipWith (\\y w -> map (y, ) $ words w) [0 ..]\n  where\n    f bd (x, (y, v)) =\n      if v == \".\"\n        then bd\n        else Board\n               (tupIns x y (read v) (cells bd))\n               (if read v > endVal bd\n                  then read v\n                  else endVal bd)\n               (if v == \"1\"\n                  then (x, y)\n                  else onePos bd)\n               (read v : givens bd)\n\nhidato brd = listToMaybe $ h 2 (cells brd) (onePos brd) (givens brd)\n  where\n    h nval pmap (x, y) gs\n      | nval == endVal brd = [pmap]\n      | nval == head gs =\n        if null nvalAdj\n          then []\n          else h (nval + 1) pmap (fst $ head nvalAdj) (tail gs)\n      | not $ null nvalAdj = h (nval + 1) pmap (fst $ head nvalAdj) gs\n      | otherwise = hEmptyAdj\n      where\n        around =\n          [ (x - 1, y - 1)\n          , (x, y - 1)\n          , (x + 1, y - 1)\n          , (x - 1, y)\n          , (x + 1, y)\n          , (x - 1, y + 1)\n          , (x, y + 1)\n          , (x + 1, y + 1)\n          ]\n        lkdUp = map (\\(x, y) -> ((x, y), tupLookup x y pmap)) around\n        nvalAdj = filter ((== Just nval) . snd) lkdUp\n        hEmptyAdj =\n          concatMap\n            (\\((nx, ny), _) -> h (nval + 1) (tupIns nx ny nval pmap) (nx, ny) gs) $\n          filter ((== Just 0) . snd) lkdUp\n\nprintCellMap cellmap = putStrLn $ concat strings\n  where\n    maxPos = xyBy I.findMax maximum\n    minPos = xyBy I.findMin minimum\n    xyBy :: (forall a. IntMap a -> (Int, a)) -> ([Int] -> Int) -> (Int, Int)\n    xyBy a b = (fst (a cellmap), b $ map (fst . a . snd) $ I.toList cellmap)\n    strings =\n      map\n        f\n        [ (x, y)\n        | y <- [snd minPos .. snd maxPos] \n        , x <- [fst minPos .. fst maxPos] ]\n    f (x, y) =\n      let z =\n            if x == fst maxPos\n              then \"\\n\"\n              else \" \"\n      in case tupLookup x y cellmap of\n           Nothing -> \"  \" ++ z\n           Just n ->\n             (if n < 10\n                then ' ' : show n\n                else show n) ++\n             z\n\nmain = do\n  let sampleBoard = makeBoard sample\n  printCellMap $ cells sampleBoard\n  printCellMap $ fromJust $ hidato sampleBoard\n\nsample =\n  [ \" 0 33 35  0  0\"\n  , \" 0  0 24 22  0\"\n  , \" 0  0  0 21  0  0\"\n  , \" 0 26  0 13 40 11\"\n  , \"27  0  0  0  9  0  1\"\n  , \".  .   0  0 18  0  0\"\n  , \".  .  .  .   0  7  0  0\"\n  , \".  .  .  .  .  .   5  0\"\n  ]\n", "target": "using System.Collections;\nusing System.Collections.Generic;\nusing static System.Console;\nusing static System.Math;\nusing static System.Linq.Enumerable;\n\npublic class Solver\n{\n    private static readonly (int dx, int dy)[]\n        \n        hidatoMoves = {(1,0),(1,1),(0,1),(-1,1),(-1,0),(-1,-1),(0,-1),(1,-1)};\n\n    private (int dx, int dy)[] moves;\n        \n    public static void Main()\n    {\n        Print(new Solver(hidatoMoves).Solve(false, new [,] {\n            {  0, 33, 35,  0,  0, -1, -1, -1 },\n            {  0,  0, 24, 22,  0, -1, -1, -1 },\n            {  0,  0,  0, 21,  0,  0, -1, -1 },\n            {  0, 26,  0, 13, 40, 11, -1, -1 },\n            { 27,  0,  0,  0,  9,  0,  1, -1 },\n            { -1, -1,  0,  0, 18,  0,  0, -1 },\n            { -1, -1, -1, -1,  0,  7,  0,  0 },\n            { -1, -1, -1, -1, -1, -1,  5,  0 }\n        }));\n    }\n\n    public Solver(params (int dx, int dy)[] moves) => this.moves = moves;\n\n    public int[,] Solve(bool circular, params string[] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    public int[,] Solve(bool circular, int[,] puzzle)\n    {\n        var (board, given, count) = Parse(puzzle);\n        return Solve(board, given, count, circular);\n    }\n\n    private int[,] Solve(int[,] board, BitArray given, int count, bool circular)\n    {\n        var (height, width) = (board.GetLength(0), board.GetLength(1));\n        bool solved = false;\n        for (int x = 0; x < height && !solved; x++) {\n            solved = Range(0, width).Any(y => Solve(board, given, circular, (height, width), (x, y), count, (x, y), 1));\n            if (solved) return board;\n        }\n        return null;\n    }\n\n    private bool Solve(int[,] board, BitArray given, bool circular,\n        (int h, int w) size, (int x, int y) start, int last, (int x, int y) current, int n)\n    {\n        var (x, y) = current;\n        if (x < 0 || x >= size.h || y < 0 || y >= size.w) return false;\n        if (board[x, y] < 0) return false;\n        if (given[n - 1]) {\n            if (board[x, y] != n) return false;\n        } else if (board[x, y] > 0) return false;\n        board[x, y] = n;\n        if (n == last) {\n            if (!circular || AreNeighbors(start, current)) return true;\n        }\n        for (int i = 0; i < moves.Length; i++) {\n            var move = moves[i];\n            if (Solve(board, given, circular, size, start, last, (x + move.dx, y + move.dy), n + 1)) return true;\n        }\n        if (!given[n - 1]) board[x, y] = 0;\n        return false;\n\n        bool AreNeighbors((int x, int y) p1, (int x, int y) p2) => moves.Any(m => (p2.x + m.dx, p2.y + m.dy).Equals(p1));\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(string[] input)\n    {\n        (int height, int width) = (input.Length, input[0].Length);\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++) {\n            string line = input[x];\n            for (int y = 0; y < width; y++) {\n                board[x, y] = y < line.Length && char.IsDigit(line[y]) ? line[y] - '0' : -1;\n                if (board[x, y] >= 0) count++;\n            }\n        }\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static (int[,] board, BitArray given, int count) Parse(int[,] input)\n    {\n        (int height, int width) = (input.GetLength(0), input.GetLength(1));\n        int[,] board = new int[height, width];\n        int count = 0;\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if ((board[x, y] = input[x, y]) >= 0) count++;\n        BitArray given = Scan(board, count, height, width);\n        return (board, given, count);\n    }\n\n    private static BitArray Scan(int[,] board, int count, int height, int width)\n    {\n        var given = new BitArray(count + 1);\n        for (int x = 0; x < height; x++)\n            for (int y = 0; y < width; y++)\n                if (board[x, y] > 0) given[board[x, y] - 1] = true;\n        return given;\n    }\n\n    private static void Print(int[,] board)\n    {\n        if (board == null) {\n            WriteLine(\"No solution\");\n        } else {\n            int w = board.Cast<int>().Where(i => i > 0).Max(i => (int?)Ceiling(Log10(i+1))) ?? 1;\n            string e = new string('-', w);\n            foreach (int x in Range(0, board.GetLength(0)))\n                WriteLine(string.Join(\" \", Range(0, board.GetLength(1))\n                    .Select(y => board[x, y] < 0 ? e : board[x, y].ToString().PadLeft(w, ' '))));\n        }\n        WriteLine();\n    }\n\n}\n"}
{"id": 410184, "name": "Angles (geometric), normalization and conversion", "source": "Translate Haskell to C#: \n\n\n  \nimport Text.Printf\n \nclass (Num a, Fractional a, RealFrac a) => Angle a where\n  fullTurn :: a \n  mkAngle :: Double -> a\n  value :: a -> Double\n  fromTurn :: Double -> a\n  toTurn :: a -> Double\n  normalize :: a -> a\n\n  \n  fromTurn t = angle t * fullTurn\n  toTurn a = value $ a / fullTurn\n\n  \n  normalize a = a `modulo` fullTurn\n    where\n      modulo x r | x == r = r\n                 | x < 0 = signum x * abs x `modulo` r\n                 | x >= 0 = x - fromInteger (floor (x / r)) * r \n\n\nangle :: Angle a => Double -> a\nangle = normalize . mkAngle\n\n\nfrom :: forall a b. (Angle a, Angle b) => a -> b\nfrom = fromTurn . toTurn\n\nto :: forall b a. (Angle a, Angle b) => a -> b\nto = fromTurn . toTurn\n", "target": "using System;\n\npublic static class Angles\n{\n    public static void Main() => Print(-2, -1, 0, 1, 2, 6.2831853, 16, 57.2957795, 359, 6399, 1_000_000);\n\n    public static void Print(params double[] angles) {\n        string[] names = { \"Degrees\", \"Gradians\", \"Mils\", \"Radians\" };\n        Func<double, double> rnd = a => Math.Round(a, 4);\n        Func<double, double>[] normal = { NormalizeDeg, NormalizeGrad, NormalizeMil, NormalizeRad };\n\n        Func<double, double>[,] convert = {\n            { a => a, DegToGrad, DegToMil, DegToRad },\n            { GradToDeg, a => a, GradToMil, GradToRad },\n            { MilToDeg, MilToGrad, a => a, MilToRad },\n            { RadToDeg, RadToGrad, RadToMil, a => a }\n        };\n\n        Console.WriteLine($@\"{\"Angle\",-12}{\"Normalized\",-12}{\"Unit\",-12}{\n            \"Degrees\",-12}{\"Gradians\",-12}{\"Mils\",-12}{\"Radians\",-12}\");\n\n        foreach (double angle in angles) {\n            for (int i = 0; i < 4; i++) {\n                double nAngle = normal[i](angle);\n\n                Console.WriteLine($@\"{\n                    rnd(angle),-12}{\n                    rnd(nAngle),-12}{\n                    names[i],-12}{\n                    rnd(convert[i, 0](nAngle)),-12}{\n                    rnd(convert[i, 1](nAngle)),-12}{\n                    rnd(convert[i, 2](nAngle)),-12}{\n                    rnd(convert[i, 3](nAngle)),-12}\");\n            }\n        }\n    }\n\n    public static double NormalizeDeg(double angle) => Normalize(angle, 360);\n    public static double NormalizeGrad(double angle) => Normalize(angle, 400);\n    public static double NormalizeMil(double angle) => Normalize(angle, 6400);\n    public static double NormalizeRad(double angle) => Normalize(angle, 2 * Math.PI);\n\n    private static double Normalize(double angle, double N) {\n        while (angle <= -N) angle += N;\n        while (angle >= N) angle -= N;\n        return angle;\n    }\n\n    public static double DegToGrad(double angle) => angle * 10 / 9;\n    public static double DegToMil(double angle) => angle * 160 / 9;\n    public static double DegToRad(double angle) => angle * Math.PI / 180;\n    \n    public static double GradToDeg(double angle) => angle * 9 / 10;\n    public static double GradToMil(double angle) => angle * 16;\n    public static double GradToRad(double angle) => angle * Math.PI / 200;\n    \n    public static double MilToDeg(double angle) => angle * 9 / 160;\n    public static double MilToGrad(double angle) => angle / 16;\n    public static double MilToRad(double angle) => angle * Math.PI / 3200;\n    \n    public static double RadToDeg(double angle) => angle * 180 / Math.PI;\n    public static double RadToGrad(double angle) => angle * 200 / Math.PI;\n    public static double RadToMil(double angle) => angle * 3200 / Math.PI;\n}\n"}
{"id": 410185, "name": "XML_XPath", "source": "Translate Haskell to C#: import Data.List\nimport Control.Arrow\nimport Control.Monad\n\ntakeWhileIncl           :: (a -> Bool) -> [a] -> [a]\ntakeWhileIncl _ []      =  []\ntakeWhileIncl p (x:xs)\n            | p x       =  x : takeWhileIncl p xs\n            | otherwise =  [x] \n\ngetmultiLineItem n = takeWhileIncl(not.isInfixOf (\"</\" ++ n)). dropWhile(not.isInfixOf ('<': n))\ngetsingleLineItems n = map (takeWhile(/='<'). drop 1. dropWhile(/='>')). filter (isInfixOf ('<': n))\n\nmain = do\n  xml <- readFile \"./Rosetta/xmlpath.xml\"\n  let xmlText = lines xml\n      \n  putStrLn \"\\n== First item ==\\n\"\n  mapM_ putStrLn $ head $ unfoldr (Just. liftM2 (id &&&) (\\\\) (getmultiLineItem \"item\")) xmlText\n  \n  putStrLn \"\\n== Prices ==\\n\"\n  mapM_ putStrLn $ getsingleLineItems \"price\" xmlText\n  \n  putStrLn \"\\n== Names ==\\n\"\n  print $ getsingleLineItems \"name\" xmlText\n", "target": "XmlReader XReader;\n \n\nXReader = XmlReader.Create(new StringReader(\"<inventory title=... </inventory>\"));\n \n\nXReader = XmlReader.Create(\"xmlfile.xml\");\n \n\n\nIXPathNavigable XDocument = new XPathDocument(XReader);\n \n\nXPathNavigator Nav = XDocument.CreateNavigator();\nNav = Nav.SelectSingleNode(\"\n \n\nif(Nav.MoveToFirst())\n{\n  Console.WriteLine(Nav.OuterXml); \n}\n \n\nXPathNodeIterator Iterator = XDocument.CreateNavigator().Select(\"\n \nwhile (Iterator.MoveNext())\n{\n  Console.WriteLine(Iterator.Current.Value);\n}\n \nIterator = XDocument.CreateNavigator().Select(\"\n \n\nList<string> NodesValues = new List<string>();\n \nwhile (Iterator.MoveNext())\n{\n  NodesValues.Add(Iterator.Current.Value);\n}\n \n\nConsole.WriteLine(NodesValues.ToArray().Length);\n"}
{"id": 410186, "name": "HTTPS_Authenticated", "source": "Translate Haskell to C#: \n\nmodule Main (main) where\n\nimport           Data.Aeson (Value)\nimport           Data.Default.Class (def)\nimport           Network.HTTP.Req\n                    ( (/:)\n                    , GET(..)\n                    , NoReqBody(..)\n                    , basicAuth\n                    , https\n                    , jsonResponse\n                    , req\n                    , responseBody\n                    , runReq\n                    )\n\nmain :: IO ()\nmain = do\n    response <- runReq def $ req\n            GET\n            (https \"httpbin.org\" /: \"basic-auth\" /: \"someuser\" /: \"somepassword\")\n            NoReqBody\n            jsonResponse\n            (basicAuth \"someuser\" \"somepassword\")\n    print (responseBody response :: Value)\n", "target": "using System;\nusing System.Net;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        var client = new WebClient();\n\n        \n        client.Credentials = CredentialCache.DefaultCredentials;\n        \n        client.Credentials = new NetworkCredential(\"User\", \"Password\");\n\n        var data = client.DownloadString(\"https:\n\n        Console.WriteLine(data);\n    }\n}\n"}
{"id": 410187, "name": "Ranking methods", "source": "Translate Haskell to C#: import Data.List (groupBy, sortBy, intercalate)\n\ntype Item = (Int, String)\n\ntype ItemList = [Item]\n\ntype ItemGroups = [ItemList]\n\ntype RankItem a = (a, Int, String)\n\ntype RankItemList a = [RankItem a]\n\n\nprepare :: ItemList -> ItemGroups\nprepare = groupBy gf . sortBy (flip compare)\n  where\n    gf (a, _) (b, _) = a == b\n\n\nrank\n  :: Num a\n  => a -> Item -> RankItem a\nrank n (a, b) = (n, a, b)\n\n\nstandard, modified, dense, ordinal :: ItemGroups -> RankItemList Int\nstandard = ms 1\n  where\n    ms _ [] = []\n    ms n (x:xs) = (rank n <$> x) ++ ms (n + length x) xs\n\nmodified = md 1\n  where\n    md _ [] = []\n    md n (x:xs) =\n      let l = length x\n          nl = n + l\n          nl1 = nl - 1\n      in (rank nl1 <$> x) ++ md (n + l) xs\n\ndense = md 1\n  where\n    md _ [] = []\n    md n (x:xs) = map (rank n) x ++ md (n + 1) xs\n\nordinal = zipWith rank [1 ..] . concat\n\nfractional :: ItemGroups -> RankItemList Double\nfractional = mf 1.0\n  where\n    mf _ [] = []\n    mf n (x:xs) =\n      let l = length x\n          o = take l [n ..]\n          ld = fromIntegral l\n          a = sum o / ld\n      in map (rank a) x ++ mf (n + ld) xs\n\n\ntest :: ItemGroups\ntest =\n  prepare\n    [ (44, \"Solomon\")\n    , (42, \"Jason\")\n    , (42, \"Errol\")\n    , (41, \"Garry\")\n    , (41, \"Bernard\")\n    , (41, \"Barry\")\n    , (39, \"Stephen\")\n    ]\n\n\nnicePrint\n  :: Show a\n  => String -> RankItemList a -> IO ()\nnicePrint xs items = do\n  putStrLn xs\n  mapM_ np items\n  putStr \"\\n\"\n  where\n    np (a, b, c) = putStrLn $ intercalate \"\\t\" [show a, show b, c]\n\nmain :: IO ()\nmain = do\n  nicePrint \"Standard:\" $ standard test\n  nicePrint \"Modified:\" $ modified test\n  nicePrint \"Dense:\" $ dense test\n  nicePrint \"Ordinal:\" $ ordinal test\n  nicePrint \"Fractional:\" $ fractional test\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RankingMethods {\n    class Program {\n        static void Main(string[] args) {\n            Dictionary<string, int> scores = new Dictionary<string, int> {\n                [\"Solomon\"] = 44,\n                [\"Jason\"] = 42,\n                [\"Errol\"] = 42,\n                [\"Gary\"] = 41,\n                [\"Bernard\"] = 41,\n                [\"Barry\"] = 41,\n                [\"Stephen\"] = 39,\n            };\n\n            StandardRank(scores);\n            ModifiedRank(scores);\n            DenseRank(scores);\n            OrdinalRank(scores);\n            FractionalRank(scores);\n        }\n\n        static void StandardRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Standard Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                int temp = rank;\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", temp, value, k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void ModifiedRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Modified Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                    }\n                }\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void DenseRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Dense Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n                rank++;\n            }\n\n            Console.WriteLine();\n        }\n\n        static void OrdinalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Ordinal Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void FractionalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Fractional Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                double avg = 0;\n                int cnt = 0;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                        cnt++;\n                        avg += rank;\n                    }\n                }\n                avg /= cnt;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0:F1} {1} {2}\", avg, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 410188, "name": "Straddling checkerboard", "source": "Translate Haskell to C#: import Data.Char\nimport Data.Map\n\ncharToInt :: Char -> Int\ncharToInt c = ord c - ord '0'\n\n\n\ndecodeChar :: String -> (Char,String)\ndecodeChar ('7':'9':r:rs) = (r,rs)\ndecodeChar ('7':r:rs)     = (\"PQUVWXYZ. \" !! charToInt r, rs)\ndecodeChar ('3':r:rs)     = (\"ABCDFGIJKN\" !! charToInt r, rs)\ndecodeChar (r:rs)         = (\"HOL MES RT\" !! charToInt r, rs)\n\n\ndecode :: String -> String\ndecode [] = []\ndecode st = let (c, s) = decodeChar st in c:decode s\n\n\n\n\nrevEnc :: String -> (Char, String)\nrevEnc enc = let (dec, rm) = decodeChar enc in (dec, take (length enc - length rm) enc)\n\nds :: String\nds = ['0'..'9']\n\n\n\nencodeMap :: Map Char String\nencodeMap = fromList [ revEnc [d2,d1,d0] | d2 <- ds, d1 <- ds, d0 <- ds ]\n\n\nencodeChar :: Char -> String\nencodeChar c = findWithDefault \"\" c encodeMap \n\n\nencode :: String -> String\nencode st = concatMap encodeChar $ fmap toUpper st\n\n\nmain = let orig = \"One night-it was on the twentieth of March, 1888-I was returning\"\n           enc = encode orig\n           dec = decode enc\n       in mapM_ putStrLn [ \"Original: \" ++ orig\n                         , \"Encoded: \" ++ enc \n                         , \"Decoded: \" ++ dec ]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace StraddlingCheckerboard\n{\n    class Program\n    {\n        public readonly static IReadOnlyDictionary<char, string> val2Key;\n        public readonly static IReadOnlyDictionary<string, char> key2Val;\n\n        static Program()\n        {\n            val2Key = new Dictionary<char, string> {\n                {'A',\"30\"},  {'B',\"31\"}, {'C',\"32\"},  {'D',\"33\"},  {'E',\"5\"},   {'F',\"34\"},  {'G',\"35\"},\n                {'H',\"0\"},   {'I',\"36\"}, {'J',\"37\"},  {'K',\"38\"},  {'L',\"2\"},   {'M',\"4\"},   {'.',\"78\"},\n                {'N',\"39\"},  {'/',\"79\"}, {'O',\"1\"},   {'0',\"790\"}, {'P',\"70\"},  {'1',\"791\"}, {'Q',\"71\"},\n                {'2',\"792\"}, {'R',\"8\"},  {'3',\"793\"}, {'S',\"6\"},   {'4',\"794\"}, {'T',\"9\"},   {'5',\"795\"},\n                {'U',\"72\"},  {'6',\"796\"},{'V',\"73\"},  {'7',\"797\"}, {'W',\"74\"},  {'8',\"798\"}, {'X',\"75\"},\n                {'9',\"799\"}, {'Y',\"76\"}, {'Z',\"77\"}};\n\n            key2Val = val2Key.ToDictionary(kv => kv.Value, kv => kv.Key);\n        }\n\n        public static string Encode(string s)\n        {\n            return string.Concat(s.ToUpper().ToCharArray()\n                .Where(c => val2Key.ContainsKey(c)).Select(c => val2Key[c]));\n        }\n\n        public static string Decode(string s)\n        {\n            return string.Concat(Regex.Matches(s, \"79.|7.|3.|.\").Cast<Match>()\n                .Where(m => key2Val.ContainsKey(m.Value)).Select(m => key2Val[m.Value]));\n        }\n\n        static void Main(string[] args)\n        {\n            var enc = Encode(\"One night-it was on the twentieth of March, 1888-I was returning\");\n            Console.WriteLine(enc);\n            Console.WriteLine(Decode(enc));\n\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 410189, "name": "I before E except after C", "source": "Translate Haskell to C#: import Network.HTTP\nimport Text.Regex.TDFA\nimport Text.Printf\n\ngetWordList :: IO String\ngetWordList  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n\nmain = do\n    words <- getWordList\n    putStrLn \"Checking Rule 1: \\\"I before E when not preceded by C\\\"...\"\n    let numTrueRule1   =  matchCount (makeRegex \"[^c]ie\" :: Regex) words\n        numFalseRule1  =  matchCount (makeRegex \"[^c]ei\" :: Regex) words\n        rule1Plausible  =  numTrueRule1 > (2*numFalseRule1)\n    printf \"Rule 1 is correct for %d\\n        incorrect for %d\\n\" numTrueRule1 numFalseRule1\n    printf \"*** Rule 1 is %splausible.\\n\" (if rule1Plausible then \"\" else \"im\")\n    \n    putStrLn \"Checking Rule 2: \\\"E before I when preceded by C\\\"...\"\n    let numTrueRule2   =  matchCount (makeRegex \"cei\" :: Regex) words\n        numFalseRule2  =  matchCount (makeRegex \"cie\" :: Regex) words\n        rule2Plausible  =  numTrueRule2 > (2*numFalseRule2)\n    printf \"Rule 2 is correct for %d\\n        incorrect for %d\\n\" numTrueRule2 numFalseRule2\n    printf \"*** Rule 2 is %splausible.\\n\" (if rule2Plausible then \"\" else \"im\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 410190, "name": "I before E except after C", "source": "Translate Haskell to C#: import Network.HTTP\nimport Text.Regex.TDFA\nimport Text.Printf\n\ngetWordList :: IO String\ngetWordList  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n\nmain = do\n    words <- getWordList\n    putStrLn \"Checking Rule 1: \\\"I before E when not preceded by C\\\"...\"\n    let numTrueRule1   =  matchCount (makeRegex \"[^c]ie\" :: Regex) words\n        numFalseRule1  =  matchCount (makeRegex \"[^c]ei\" :: Regex) words\n        rule1Plausible  =  numTrueRule1 > (2*numFalseRule1)\n    printf \"Rule 1 is correct for %d\\n        incorrect for %d\\n\" numTrueRule1 numFalseRule1\n    printf \"*** Rule 1 is %splausible.\\n\" (if rule1Plausible then \"\" else \"im\")\n    \n    putStrLn \"Checking Rule 2: \\\"E before I when preceded by C\\\"...\"\n    let numTrueRule2   =  matchCount (makeRegex \"cei\" :: Regex) words\n        numFalseRule2  =  matchCount (makeRegex \"cie\" :: Regex) words\n        rule2Plausible  =  numTrueRule2 > (2*numFalseRule2)\n    printf \"Rule 2 is correct for %d\\n        incorrect for %d\\n\" numTrueRule2 numFalseRule2\n    printf \"*** Rule 2 is %splausible.\\n\" (if rule2Plausible then \"\" else \"im\")\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 410191, "name": "Chemical calculator", "source": "Translate Haskell to C#: import Control.Monad (forM_)\nimport Control.Monad.Reader (Reader, ask, runReader)\nimport Data.Bifunctor (first)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Void (Void)\nimport System.Environment (getArgs)\nimport System.IO (IOMode(ReadMode), withFile)\nimport System.IO.Strict (hGetContents)\nimport Text.Megaparsec (ParsecT, (<|>), between, errorBundlePretty, getOffset,\n                        many, option, runParserT, some, setOffset)\nimport Text.Megaparsec.Char (char, lowerChar, upperChar)\nimport Text.Megaparsec.Char.Lexer (decimal)\nimport Text.Printf (printf)\n\ntype Masses     = Map String Double\ntype ChemParser = ParsecT Void String (Reader Masses) Double\n\n\nmolecule :: ChemParser\nmolecule = sum <$> some (atomGroup <|> atom)\n\n\n\natomGroup :: ChemParser\natomGroup = mul <$> between (char '(') (char ')') molecule <*> option 1 decimal\n\n\natom :: ChemParser\natom = mul <$> atomMass <*> option 1 decimal\n\n\natomMass :: ChemParser\natomMass = do\n  off <- getOffset\n  masses <- ask\n  atomName <- (:) <$> upperChar <*> many lowerChar\n  case M.lookup atomName masses of\n    Nothing -> setOffset off >> fail \"invalid atom name starting here\"\n    Just mass -> return mass\n\n\n\nmolarMass :: String -> String -> Masses -> Either String Double\nmolarMass file formula = first errorBundlePretty . runChemParser\n  where runChemParser = runReader (runParserT molecule file formula)\n\n\ngetMasses :: FilePath -> IO Masses\ngetMasses path = withFile path ReadMode (fmap read . hGetContents)\n\nmul :: Double -> Int -> Double\nmul s n = s * fromIntegral n\n\nmain :: IO ()\nmain = do\n  masses <- getMasses \"chemcalc_masses.in\"\n  molecs <- getArgs\n  forM_ molecs $ \\molec -> do\n    printf \"%-20s\" molec\n    case molarMass \"<stdin>\" molec masses of\n      Left err   -> printf \"\\n%s\" err\n      Right mass -> printf \"\u00a0%.4f\\n\" mass\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace ChemicalCalculator {\n    class Program {\n        static Dictionary<string, double> atomicMass = new Dictionary<string, double>() {\n            {\"H\",     1.008 },\n            {\"He\",    4.002602},\n            {\"Li\",    6.94},\n            {\"Be\",    9.0121831},\n            {\"B\",    10.81},\n            {\"C\",    12.011},\n            {\"N\",    14.007},\n            {\"O\",    15.999},\n            {\"F\",    18.998403163},\n            {\"Ne\",   20.1797},\n            {\"Na\",   22.98976928},\n            {\"Mg\",   24.305},\n            {\"Al\",   26.9815385},\n            {\"Si\",   28.085},\n            {\"P\",    30.973761998},\n            {\"S\",    32.06},\n            {\"Cl\",   35.45},\n            {\"Ar\",   39.948},\n            {\"K\",    39.0983},\n            {\"Ca\",   40.078},\n            {\"Sc\",   44.955908},\n            {\"Ti\",   47.867},\n            {\"V\",    50.9415},\n            {\"Cr\",   51.9961},\n            {\"Mn\",   54.938044},\n            {\"Fe\",   55.845},\n            {\"Co\",   58.933194},\n            {\"Ni\",   58.6934},\n            {\"Cu\",   63.546},\n            {\"Zn\",   65.38},\n            {\"Ga\",   69.723},\n            {\"Ge\",   72.630},\n            {\"As\",   74.921595},\n            {\"Se\",   78.971},\n            {\"Br\",   79.904},\n            {\"Kr\",   83.798},\n            {\"Rb\",   85.4678},\n            {\"Sr\",   87.62},\n            {\"Y\",    88.90584},\n            {\"Zr\",   91.224},\n            {\"Nb\",   92.90637},\n            {\"Mo\",   95.95},\n            {\"Ru\",  101.07},\n            {\"Rh\",  102.90550},\n            {\"Pd\",  106.42},\n            {\"Ag\",  107.8682},\n            {\"Cd\",  112.414},\n            {\"In\",  114.818},\n            {\"Sn\",  118.710},\n            {\"Sb\",  121.760},\n            {\"Te\",  127.60},\n            {\"I\",   126.90447},\n            {\"Xe\",  131.293},\n            {\"Cs\",  132.90545196},\n            {\"Ba\",  137.327},\n            {\"La\",  138.90547},\n            {\"Ce\",  140.116},\n            {\"Pr\",  140.90766},\n            {\"Nd\",  144.242},\n            {\"Pm\",  145},\n            {\"Sm\",  150.36},\n            {\"Eu\",  151.964},\n            {\"Gd\",  157.25},\n            {\"Tb\",  158.92535},\n            {\"Dy\",  162.500},\n            {\"Ho\",  164.93033},\n            {\"Er\",  167.259},\n            {\"Tm\",  168.93422},\n            {\"Yb\",  173.054},\n            {\"Lu\",  174.9668},\n            {\"Hf\",  178.49},\n            {\"Ta\",  180.94788},\n            {\"W\",   183.84},\n            {\"Re\",  186.207},\n            {\"Os\",  190.23},\n            {\"Ir\",  192.217},\n            {\"Pt\",  195.084},\n            {\"Au\",  196.966569},\n            {\"Hg\",  200.592},\n            {\"Tl\",  204.38},\n            {\"Pb\",  207.2},\n            {\"Bi\",  208.98040},\n            {\"Po\",  209},\n            {\"At\",  210},\n            {\"Rn\",  222},\n            {\"Fr\",  223},\n            {\"Ra\",  226},\n            {\"Ac\",  227},\n            {\"Th\",  232.0377},\n            {\"Pa\",  231.03588},\n            {\"U\",   238.02891},\n            {\"Np\",  237},\n            {\"Pu\",  244},\n            {\"Am\",  243},\n            {\"Cm\",  247},\n            {\"Bk\",  247},\n            {\"Cf\",  251},\n            {\"Es\",  252},\n            {\"Fm\",  257},\n            {\"Uue\", 315},\n            {\"Ubn\", 299},\n        };\n\n        static double Evaluate(string s) {\n            s += \"[\";\n            double sum = 0.0;\n            string symbol = \"\";\n            string number = \"\";\n            for (int i = 0; i < s.Length; ++i) {\n                var c = s[i];\n                if ('@' <= c && c <= '[') {\n                    \n                    int n = 1;\n                    if (number != \"\") {\n                        n = int.Parse(number);\n                    }\n                    if (symbol != \"\") {\n                        sum += atomicMass[symbol] * n;\n                    }\n                    if (c == '[') {\n                        break;\n                    }\n                    symbol = c.ToString();\n                    number = \"\";\n                } else if ('a' <= c && c <= 'z') {\n                    symbol += c;\n                } else if ('0' <= c && c <= '9') {\n                    number += c;\n                } else {\n                    throw new Exception(string.Format(\"Unexpected symbol {0} in molecule\", c));\n                }\n            }\n            return sum;\n        }\n\n        \n        static string ReplaceFirst(string text, string search, string replace) {\n            int pos = text.IndexOf(search);\n            if (pos < 0) {\n                return text;\n            }\n            return text.Substring(0, pos) + replace + text.Substring(pos + search.Length);\n        }\n\n        static string ReplaceParens(string s) {\n            char letter = 's';\n            while (true) {\n                var start = s.IndexOf('(');\n                if (start == -1) {\n                    break;\n                }\n\n                for (int i = start + 1; i < s.Length; ++i) {\n                    if (s[i] == ')') {\n                        var expr = s.Substring(start + 1, i - start - 1);\n                        var symbol = string.Format(\"@{0}\", letter);\n                        s = ReplaceFirst(s, s.Substring(start, i + 1 - start), symbol);\n                        atomicMass[symbol] = Evaluate(expr);\n                        letter++;\n                        break;\n                    }\n                    if (s[i] == '(') {\n                        start = i;\n                        continue;\n                    }\n                }\n            }\n            return s;\n        }\n\n        static void Main() {\n            var molecules = new string[]{\n                \"H\", \"H2\", \"H2O\", \"H2O2\", \"(HO)2\", \"Na2SO4\", \"C6H12\",\n                \"COOH(C(CH3)2)3CH3\", \"C6H4O2(OH)4\", \"C27H46O\", \"Uue\"\n            };\n            foreach (var molecule in molecules) {\n                var mass = Evaluate(ReplaceParens(molecule));\n                Console.WriteLine(\"{0,17} -> {1,7:0.000}\", molecule, mass);\n            }\n        }\n    }\n}\n"}
{"id": 410192, "name": "Farey sequence", "source": "Translate Haskell to C#: import Data.List (unfoldr, mapAccumR)\nimport Data.Ratio ((%), denominator, numerator)\nimport Text.Printf (PrintfArg, printf)\n\n\nfarey :: Integer -> [Rational]\nfarey n = 0 : unfoldr step (0, 1, 1, n)\n  where\n    step (a, b, c, d)\n      | c > n = Nothing\n      | otherwise =\n        let k = (n + b) `quot` d\n        in Just (c %d, (c, d, k * c - a, k * d - b))\n\n\n\n\n\nfareys :: ([Rational] -> a) -> [Integer] -> [(Integer, a)]\nfareys fn ns = snd $ mapAccumR prune (farey $ last ns) ns\n  where\n    prune rs n =\n      let rs'' = filter ((<= n) . denominator) rs\n      in (rs'', (n, fn rs''))\n\nfprint\n  :: (PrintfArg b)\n  => String -> [(Integer, b)] -> IO ()\nfprint fmt = mapM_ (uncurry $ printf fmt)\n\nshowFracs :: [Rational] -> String\nshowFracs =\n  unwords .\n  map (concat . (<*>) [show . numerator, const \"/\", show . denominator] . pure)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Farey Sequences\\n\"\n  fprint \"%2d %s\\n\" $ fareys showFracs [1 .. 11]\n  putStrLn \"\\nSequence Lengths\\n\"\n  fprint \"%4d %d\\n\" $ fareys length [100,200 .. 1000]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 410193, "name": "Farey sequence", "source": "Translate Haskell to C#: import Data.List (unfoldr, mapAccumR)\nimport Data.Ratio ((%), denominator, numerator)\nimport Text.Printf (PrintfArg, printf)\n\n\nfarey :: Integer -> [Rational]\nfarey n = 0 : unfoldr step (0, 1, 1, n)\n  where\n    step (a, b, c, d)\n      | c > n = Nothing\n      | otherwise =\n        let k = (n + b) `quot` d\n        in Just (c %d, (c, d, k * c - a, k * d - b))\n\n\n\n\n\nfareys :: ([Rational] -> a) -> [Integer] -> [(Integer, a)]\nfareys fn ns = snd $ mapAccumR prune (farey $ last ns) ns\n  where\n    prune rs n =\n      let rs'' = filter ((<= n) . denominator) rs\n      in (rs'', (n, fn rs''))\n\nfprint\n  :: (PrintfArg b)\n  => String -> [(Integer, b)] -> IO ()\nfprint fmt = mapM_ (uncurry $ printf fmt)\n\nshowFracs :: [Rational] -> String\nshowFracs =\n  unwords .\n  map (concat . (<*>) [show . numerator, const \"/\", show . denominator] . pure)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Farey Sequences\\n\"\n  fprint \"%2d %s\\n\" $ fareys showFracs [1 .. 11]\n  putStrLn \"\\nSequence Lengths\\n\"\n  fprint \"%4d %d\\n\" $ fareys length [100,200 .. 1000]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class FareySequence\n{\n    public static void Main() {\n        for (int i = 1; i <= 11; i++) {\n            Console.WriteLine($\"F{i}: \" + string.Join(\", \", Generate(i).Select(f => $\"{f.num}/{f.den}\")));\n        }\n        for (int i = 100; i <= 1000; i+=100) {\n            Console.WriteLine($\"F{i} has {Generate(i).Count()} terms.\");\n        }\n    }\n\n    public static IEnumerable<(int num, int den)> Generate(int i) {\n        var comparer = Comparer<(int n, int d)>.Create((a, b) => (a.n * b.d).CompareTo(a.d * b.n));\n        var seq = new SortedSet<(int n, int d)>(comparer);\n        for (int d = 1; d <= i; d++) {\n            for (int n = 0; n <= d; n++) {\n                seq.Add((n, d));\n            }\n        }\n        return seq;\n    }\n}\n"}
{"id": 410194, "name": "Magnanimous numbers", "source": "Translate Haskell to C#: import Data.List.Split ( chunksOf )\nimport Data.List ( (!!) )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n   \nisMagnanimous :: Int -> Bool\nisMagnanimous n = all isPrime $ map (\\p -> fst p + snd p ) numberPairs\n where\n  str:: String\n  str = show n\n  splitStrings :: [(String , String)]\n  splitStrings = map (\\i -> splitAt i str) [1 .. length str - 1] \n  numberPairs :: [(Int , Int)]\n  numberPairs = map (\\p -> ( read $ fst p , read $ snd p )) splitStrings\n\nprintInWidth :: Int -> Int -> String\nprintInWidth number width = replicate ( width - l ) ' ' ++ str\n where \n  str :: String\n  str = show number\n  l :: Int\n  l = length str\n\nsolution :: [Int]\nsolution = take 400 $ filter isMagnanimous [0 , 1 ..]\n\nmain :: IO ( ) \nmain = do\n   let numbers = solution\n       numberlines = chunksOf 10 $ take 45 numbers\n   putStrLn \"First 45 magnanimous numbers:\" \n   mapM_ (\\li -> putStrLn (foldl1 ( ++ ) $ map (\\n -> printInWidth n 6 ) \n    li )) numberlines \n   putStrLn \"241'st to 250th magnanimous numbers:\"\n   putStr $ show ( numbers !! 240 )\n   putStrLn ( foldl1 ( ++ ) $ map(\\n -> printInWidth n 8 ) $ take 9 $ \n    drop 241 numbers )   \n   putStrLn \"391'st to 400th magnanimous numbers:\"\n   putStr $ show ( numbers !! 390 )\n   putStrLn ( foldl1 ( ++ ) $ map(\\n -> printInWidth n 8 ) $ drop 391 numbers)\n", "target": "using System; using static System.Console;\n\nclass Program {\n\n  static bool[] np; \n\n  static void ms(long lmt) { \n    np = new bool[lmt]; np[0] = np[1] = true;\n    for (long n = 2, j = 1; n < lmt; n += j, j = 2) if (!np[n])\n        for (long k = n * n; k < lmt; k += n) np[k] = true; }\n\n  static bool is_Mag(long n) { long res, rem;\n    for (long p = 10; n >= p; p *= 10) {\n      res = Math.DivRem (n, p, out rem);\n      if (np[res + rem]) return false; } return true; }\n\n  static void Main(string[] args) { ms(100_009); string mn;\n    WriteLine(\"First 45{0}\", mn = \" magnanimous numbers:\");\n    for (long l = 0, c = 0; c < 400; l++) if (is_Mag(l)) {\n      if (c++ < 45 || (c > 240 && c <= 250) || c > 390)\n        Write(c <= 45 ? \"{0,4} \" : \"{0,8:n0} \", l);\n      if (c < 45 && c % 15 == 0) WriteLine();\n      if (c == 240) WriteLine (\"\\n\\n241st through 250th{0}\", mn);\n      if (c == 390) WriteLine (\"\\n\\n391st through 400th{0}\", mn); } }\n}\n"}
{"id": 410195, "name": "Mersenne primes", "source": "Translate Haskell to C#: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\nlucasLehmer :: Int -> Bool\nlucasLehmer p = iterate f 4 !! p-2 == 0\n where\n  f b = (b^2 - 2) `mod` m\n  m = 2^p - 1\n\nmain = mapM_ (printf \"M %d\\n\") $ take 20 mersenne\n where\n  mersenne = filter lucasLehmer primes\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 410196, "name": "Mersenne primes", "source": "Translate Haskell to C#: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\nlucasLehmer :: Int -> Bool\nlucasLehmer p = iterate f 4 !! p-2 == 0\n where\n  f b = (b^2 - 2) `mod` m\n  m = 2^p - 1\n\nmain = mapM_ (printf \"M %d\\n\") $ take 20 mersenne\n where\n  mersenne = filter lucasLehmer primes\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 410197, "name": "Strong and weak primes", "source": "Translate Haskell to C#: import Text.Printf (printf)\nimport Data.Numbers.Primes (primes)\n\nxPrimes :: (Real a, Fractional b) => (b -> b -> Bool) -> [a] -> [a]\nxPrimes op ps@(p1:p2:p3:xs)\n  | realToFrac p2 `op` (realToFrac (p1 + p3) / 2) = p2 : xPrimes op (tail ps)\n  | otherwise = xPrimes op (tail ps)\n\nmain :: IO ()\nmain = do \n  printf \"First 36 strong primes: %s\\n\" . show . take 36 $ strongPrimes\n  printf \"Strong primes below 1,000,000: %d\\n\" . length . takeWhile (<1000000) $ strongPrimes\n  printf \"Strong primes below 10,000,000: %d\\n\\n\" . length . takeWhile (<10000000) $ strongPrimes\n\n  printf \"First 37 weak primes: %s\\n\" . show . take 37 $ weakPrimes \n  printf \"Weak primes below 1,000,000: %d\\n\" . length . takeWhile (<1000000) $ weakPrimes\n  printf \"Weak primes below 10,000,000: %d\\n\\n\" . length . takeWhile (<10000000) $ weakPrimes\n  where strongPrimes = xPrimes (>) primes\n        weakPrimes   = xPrimes (<) primes\n", "target": "using static System.Console;\nusing static System.Linq.Enumerable;\nusing System;\n\npublic static class StrongAndWeakPrimes\n{\n    public static void Main() {\n        var primes = PrimeGenerator(10_000_100).ToList();\n        var strongPrimes = from i in Range(1, primes.Count - 2) where primes[i] > (primes[i-1] + primes[i+1]) / 2 select primes[i];\n        var weakPrimes = from i in Range(1, primes.Count - 2) where primes[i] < (primes[i-1] + primes[i+1]) / 2.0 select primes[i];\n        WriteLine($\"First 36 strong primes: {string.Join(\", \", strongPrimes.Take(36))}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 1_000_000).Count():N0} strong primes below {1_000_000:N0}\");\n        WriteLine($\"There are {strongPrimes.TakeWhile(p => p < 10_000_000).Count():N0} strong primes below {10_000_000:N0}\");\n        WriteLine($\"First 37 weak primes: {string.Join(\", \", weakPrimes.Take(37))}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 1_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n        WriteLine($\"There are {weakPrimes.TakeWhile(p => p < 10_000_000).Count():N0} weak primes below {1_000_000:N0}\");\n    }\n   \n}\n"}
{"id": 410198, "name": "Left factorials", "source": "Translate Haskell to C#: leftFact :: [Integer]\nleftFact = scanl (+) 0 fact\n\nfact :: [Integer]\nfact = scanl (*) 1 [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"0 ~ 10:\"\n    , show $ (leftFact !!) <$> [0 .. 10]\n    , \"\"\n    , \"20 ~ 110 by tens:\"\n    , unlines $ show . (leftFact !!) <$> [20,30 .. 110]\n    , \"\"\n    , \"length of 1,000 ~ 10,000 by thousands:\"\n    , show $ length . show . (leftFact !!) <$> [1000,2000 .. 10000]\n    , \"\"\n    ]\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 410199, "name": "Left factorials", "source": "Translate Haskell to C#: leftFact :: [Integer]\nleftFact = scanl (+) 0 fact\n\nfact :: [Integer]\nfact = scanl (*) 1 [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"0 ~ 10:\"\n    , show $ (leftFact !!) <$> [0 .. 10]\n    , \"\"\n    , \"20 ~ 110 by tens:\"\n    , unlines $ show . (leftFact !!) <$> [20,30 .. 110]\n    , \"\"\n    , \"length of 1,000 ~ 10,000 by thousands:\"\n    , show $ length . show . (leftFact !!) <$> [1000,2000 .. 10000]\n    , \"\"\n    ]\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 410200, "name": "Motzkin numbers", "source": "Translate Haskell to C#: import Control.Monad.Memo (Memo, memo, startEvalMemo)\nimport Math.NumberTheory.Primes.Testing (isPrime)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\ntype I = Integer\n\n\n\nmotzkin :: I -> Memo I I I\nmotzkin 0 = return 1\nmotzkin 1 = return 1\nmotzkin n = do\n  m1 <- memo motzkin (n-1)\n  m2 <- memo motzkin (n-2)\n  return $ ((2*n+1)*m1 + (3*n-3)*m2) `div` (n+2)\n\n\nmotzkins :: I -> [I]\nmotzkins = startEvalMemo . mapM motzkin . enumFromTo 0\n\n\nprintMotzkins :: I -> IO ()\nprintMotzkins n = mapM_ prnt $ zip [0 :: I ..] (motzkins n)\n  where prnt (i, m) = printf \"%2d %20d %s\\n\" i m $ prime m\n        prime m = if isPrime m then \"prime\" else \"\"\n\nmain :: IO ()\nmain = do\n  [n] <- map read <$> getArgs\n  printMotzkins n\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\n \nclass Program {\n \n  \n  static bool hmf(BI x) {\n    if (x < 4) return x == 1;\n    if ((x & 1) == 0 || x % 3 == 0) return true;\n    int l = (int)Math.Sqrt((double)x); \n    for (int j = 5, d = 4; j <= l; j += d = 6 - d)\n      if (x % j == 0) return x > j;\n    return false;\n  }\n \n  static void Main(string[] args) {\n    BI a = 0, b = 1, t;\n    int n = 1, s = 0, d = 1, c = 0, f = 1;\n    while (n <= 80)\n      Console.WriteLine(\"{0,46:n0} {1}\",\n        t = b / n++,\n        hmf(t) ? \"\" : \"is prime.\",\n        t = b,\n        b = ((c += d * 3 + 3) * a +\n             (f += d * 2 + 3) * b) /\n             (s += d += 2),\n        a = t);\n  }\n}\n"}
{"id": 410201, "name": "Magic squares of doubly even order", "source": "Translate Haskell to C#: import Data.List (transpose, unfoldr, intercalate)\nimport Data.List.Split (chunksOf)\nimport Data.Bool (bool)\nimport Control.Monad (forM_)\n\nmagicSquare :: Int -> [[Int]]\nmagicSquare n\n  | rem n 4 > 0 = []\n  | otherwise =\n    chunksOf n $ zipWith (flip (bool =<< (-) limit)) series [1 .. sqr]\n  where\n    sqr = n * n\n    limit = sqr + 1\n    series\n      | isPowerOf 2 n = magicSeries $ floor (logBase 2 (fromIntegral sqr))\n      | otherwise =\n        concat . concat . concat . scale $ scale <$> chunksOf 4 (magicSeries 4)\n      where\n        scale = replicate $ quot n 4\n\nmagicSeries :: Int -> [Bool]\nmagicSeries = (iterate ((++) <*> fmap not) [True] !!)\n\nisPowerOf :: Int -> Int -> Bool\nisPowerOf k n = until ((0 /=) . flip rem k) (`quot` k) n == 1\n\n\nchecked :: [[Int]] -> (Int, Bool)\nchecked square =\n  let diagonals =\n        fmap (flip (zipWith (!!)) [0 ..]) . ((:) <*> (return . reverse))\n      h:t =\n        sum <$>\n        square ++ \n        transpose square ++ \n        diagonals square \n  in (h, all (h ==) t)\n\ntable :: String -> [[String]] -> [String]\ntable delim rows =\n  let justifyRight c n s = drop (length s) (replicate n c ++ s)\n  in intercalate delim <$>\n     transpose\n       ((fmap =<< justifyRight ' ' . maximum . fmap length) <$> transpose rows)\n\nmain :: IO ()\nmain =\n  forM_ [4, 8, 16] $\n  \\n -> do\n    let test = magicSquare n\n    putStrLn $ unlines (table \" \" (fmap show <$> test))\n    print $ checked test\n    putStrLn []\n", "target": "using System;\n\nnamespace MagicSquareDoublyEven\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int n = 8;\n            var result = MagicSquareDoublyEven(n);\n            for (int i = 0; i < result.GetLength(0); i++)\n            {\n                for (int j = 0; j < result.GetLength(1); j++)\n                    Console.Write(\"{0,2} \", result[i, j]);\n                Console.WriteLine();\n            }\n            Console.WriteLine(\"\\nMagic constant: {0} \", (n * n + 1) * n / 2);\n            Console.ReadLine();\n        }\n\n        private static int[,] MagicSquareDoublyEven(int n)\n        {\n            if (n < 4 || n % 4 != 0)\n                throw new ArgumentException(\"base must be a positive \"\n                        + \"multiple of 4\");\n\n            \n            int bits = 0b1001_0110_0110_1001;\n            int size = n * n;\n            int mult = n / 4;  \n\n            int[,] result = new int[n, n];\n\n            for (int r = 0, i = 0; r < n; r++)\n            {\n                for (int c = 0; c < n; c++, i++)\n                {\n                    int bitPos = c / mult + (r / mult) * 4;\n                    result[r, c] = (bits & (1 << bitPos)) != 0 ? i + 1 : size - i;\n                }\n            }\n            return result;\n        }\n    }\n}\n"}
{"id": 410202, "name": "Self numbers", "source": "Translate Haskell to C#: import Control.Monad (forM_)\nimport Text.Printf\n\nselfs :: [Integer]\nselfs = sieve (sumFs [0..]) [0..]\n  where\n    sumFs = zipWith (+) [ a+b+c+d+e+f+g+h+i+j\n                        | a <- [0..9] , b <- [0..9]\n                        , c <- [0..9] , d <- [0..9]\n                        , e <- [0..9] , f <- [0..9]\n                        , g <- [0..9] , h <- [0..9]\n                        , i <- [0..9] , j <- [0..9] ]\n\n    \n    \n\n    sieve (f:fs) (n:ns)\n      | n > f = sieve fs (n:ns)\n      | n `notElem` take 81 (f:fs) = n : sieve (f:fs) ns\n      | otherwise = sieve (f:fs) ns\n\nmain = do\n  print $ take 50 selfs\n  forM_ [1..8] $ \\i -> \n    printf \"1e%v\\t%v\\n\" (i :: Int) (selfs !! (10^i-1))\n", "target": "using System;\nusing static System.Console;\n\nclass Program {\n\n  const int mc = 103 * 1000 * 10000 + 11 * 9 + 1;\n\n  static bool[] sv = new bool[mc + 1];\n\n  static void sieve() { int[] dS = new int[10000];\n    for (int a = 9, i = 9999; a >= 0; a--)\n      for (int b = 9; b >= 0; b--)\n        for (int c = 9, s = a + b; c >= 0; c--)\n          for (int d = 9, t = s + c; d >= 0; d--)\n            dS[i--] = t + d;\n    for (int a = 0, n = 0; a < 103; a++)\n      for (int b = 0, d = dS[a]; b < 1000; b++, n += 10000)\n        for (int c = 0, s = d + dS[b] + n; c < 10000; c++)\n          sv[dS[c] + s++] = true; }\n\n  static void Main() { DateTime st = DateTime.Now; sieve();\n    WriteLine(\"Sieving took {0}s\", (DateTime.Now - st).TotalSeconds); \n    WriteLine(\"\\nThe first 50 self numbers are:\");\n    for (int i = 0, count = 0; count <= 50; i++) if (!sv[i]) {\n        count++; if (count <= 50) Write(\"{0} \", i);\n        else WriteLine(\"\\n\\n       Index     Self number\"); }\n    for (int i = 0, limit = 1, count = 0; i < mc; i++)\n      if (!sv[i]) if (++count == limit) {\n          WriteLine(\"{0,12:n0} \u00a0 {1,13:n0}\", count, i);\n          if (limit == 1e9) break; limit *= 10; }\n    WriteLine(\"\\nOverall took {0}s\", (DateTime.Now - st). TotalSeconds);\n  }\n}\n"}
{"id": 410203, "name": "Pythagorean quadruples", "source": "Translate Haskell to C#: powersOfTwo :: [Int]\npowersOfTwo = iterate (2 *) 1\n\nunrepresentable :: [Int]\nunrepresentable = merge powersOfTwo ((5 *) <$> powersOfTwo)\n\nmerge :: [Int] -> [Int] -> [Int]\nmerge xxs@(x:xs) yys@(y:ys)\n  | x < y = x : merge xs yys\n  | otherwise = y : merge xxs ys\n\nmain :: IO ()\nmain = do\n  putStrLn \"The values of d <= 2200 which can't be represented.\"\n  print $ takeWhile (<= 2200) unrepresentable\n", "target": "using System;\n\nnamespace PythagoreanQuadruples {\n    class Program {\n        const int MAX = 2200;\n        const int MAX2 = MAX * MAX * 2;\n\n        static void Main(string[] args) {\n            bool[] found = new bool[MAX + 1]; \n            bool[] a2b2 = new bool[MAX2 + 1]; \n            int s = 3;\n\n            for(int a = 1; a <= MAX; a++) {\n                int a2 = a * a;\n                for (int b=a; b<=MAX; b++) {\n                    a2b2[a2 + b * b] = true;\n                }\n            }\n\n            for (int c = 1; c <= MAX; c++) {\n                int s1 = s;\n                s += 2;\n                int s2 = s;\n                for (int d = c + 1; d <= MAX; d++) {\n                    if (a2b2[s1]) found[d] = true;\n                    s1 += s2;\n                    s2 += 2;\n                }\n            }\n\n            Console.WriteLine(\"The values of d <= {0} which can't be represented:\", MAX);\n            for (int d = 1; d < MAX; d++) {\n                if (!found[d]) Console.Write(\"{0}  \", d);\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 410204, "name": "Sum and product puzzle", "source": "Translate Haskell to C#: import Data.List (intersect)\n\ns1, s2, s3, s4 :: [(Int, Int)]\ns1 = [(x, y) | x <- [1 .. 100], y <- [1 .. 100], 1 < x && x < y && x + y < 100]\n\nadd, mul :: (Int, Int) -> Int\nadd (x, y) = x + y\nmul (x, y) = x * y\n\nsumEq, mulEq :: (Int, Int) -> [(Int, Int)]\nsumEq p = filter (\\q -> add q == add p) s1\nmulEq p = filter (\\q -> mul q == mul p) s1\n\ns2 = filter (\\p -> all (\\q -> (length $ mulEq q) /= 1) (sumEq p)) s1\ns3 = filter (\\p -> length (mulEq p `intersect` s2) == 1) s2\ns4 = filter (\\p -> length (sumEq p `intersect` s3) == 1) s3\n\nmain = print s4\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main()\n    {\n        const int maxSum = 100;\n        var pairs = (\n            from X in 2.To(maxSum / 2 - 1)\n            from Y in (X + 1).To(maxSum - 2).TakeWhile(y => X + y <= maxSum)\n            select new { X, Y, S = X + Y, P = X * Y }\n            ).ToHashSet();\n\n        Console.WriteLine(pairs.Count);\n        \n        var uniqueP = pairs.GroupBy(pair => pair.P).Where(g => g.Count() == 1).Select(g => g.Key).ToHashSet();\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Any(pair => uniqueP.Contains(pair.P))).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.P).Where(g => g.Count() > 1).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        pairs.ExceptWith(pairs.GroupBy(pair => pair.S).Where(g => g.Count() > 1).SelectMany(g => g));\n        Console.WriteLine(pairs.Count);\n        \n        foreach (var pair in pairs) Console.WriteLine(pair);\n    }\n}\n\npublic static class Extensions\n{\n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i <= end; i++) yield return i;\n    }\n    \n    public static HashSet<T> ToHashSet<T>(this IEnumerable<T> source) => new HashSet<T>(source);\n}\n"}
{"id": 410205, "name": "Linux CPU utilization", "source": "Translate Haskell to C#: import Data.List ( (!!) ) \n\nsplitString :: Char -> String -> [String]\nsplitString c [] = []\nsplitString c s = let ( item , rest ) = break ( == c ) s\n                      ( _ , next ) = break ( /= c ) rest\n\t\t  in item : splitString c next    \n\t\t  \ncomputeUsage :: String -> Double\ncomputeUsage s = (1.0 - ((lineElements !! 3 ) /  sum times)) * 100\n   where\n      lineElements = map (fromInteger . read ) $ tail $ splitString ' ' s\n      times = tail lineElements\n\nmain :: IO ( )      \nmain = do \n   theTimes <- fmap lines $ readFile \"/proc/stat\" \n   putStr $ show $ computeUsage $ head theTimes\n   putStrLn \"\u00a0%\"\n", "target": "var prevIdle = 0f;\nvar prevTotal = 0f;\n\nwhile (true)\n{\n    var cpuLine = File\n        .ReadAllLines(\"/proc/stat\")\n        .First()\n        .Split(' ', StringSplitOptions.RemoveEmptyEntries)\n        .Skip(1)\n        .Select(float.Parse)\n        .ToArray();\n\n    var idle = cpuLine[3];\n    var total = cpuLine.Sum();\n\n    var percent = 100.0 * (1.0 - (idle - prevIdle) / (total - prevTotal));\n    Console.WriteLine($\"{percent:0.00}%\");\n\n    prevIdle = idle;\n    prevTotal = total;\n\n    Thread.Sleep(1000);\n}\n"}
{"id": 410206, "name": "Primes which contain only one odd digit", "source": "Translate Haskell to C#: import Data.List (intercalate, maximum, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\n\n\n\noneOddDecimalDigit :: Int -> Bool\noneOddDecimalDigit =\n  (1 ==) . length . filter odd . digits\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"Below 1000:\"\n  (putStrLn . table \" \" . chunksOf 10 . fmap show) $\n    sampleBelow 1000\n\n  putStrLn \"Count of matches below 10E6:\"\n  (print . length) $\n    sampleBelow 1000000\n\nsampleBelow :: Int -> [Int]\nsampleBelow =\n  filter oneOddDecimalDigit\n    . flip takeWhile primes\n    . (>)\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    \n    \n    static List<uint> sieve(uint max, bool ordinary = false)\n    {\n        uint k = ((max - 3) >> 1) + 1,\n           lmt = ((uint)(Math.Sqrt(max++) - 3) >> 1) + 1;\n        var pl = new List<uint> { };\n        var ic = new bool[k];\n        for (uint i = 0, p = 3; i < lmt; i++, p += 2) if (!ic[i])\n                for (uint j = (p * p - 3) >> 1; j < k; j += p) ic[j] = true;\n        if (ordinary)\n        {\n            pl.Add(2);\n            for (uint i = 0, j = 3; i < k; i++, j += 2)\n                if (!ic[i]) pl.Add(j);\n        }\n        else\n            for (uint i = 0, j = 3, t = j; i < k; i++, t = j += 2)\n                if (!ic[i])\n                {\n                    while ((t /= 10) > 0)\n                        if (((t % 10) & 1) == 1) goto skip;\n                    pl.Add(j);\n                skip:;\n                }\n        return pl;\n    }\n\n    static void Main(string[] args)\n    {\n        var pl = sieve((uint)1e9);\n        uint c = 0, l = 10, p = 1;\n        Console.WriteLine(\"List of one-odd-digit primes < 1,000:\");\n        for (int i = 0; pl[i] < 1000; i++)\n            Console.Write(\"{0,3}{1}\", pl[i], i % 9 == 8 ? \"\\n\" : \"  \");\n        string fmt = \"\\nFound {0:n0} one-odd-digit primes < 10^{1} ({2:n0})\";\n        foreach (var itm in pl)\n            if (itm < l) c++;\n            else Console.Write(fmt, c++, p++, l, l *= 10);\n        Console.Write(fmt, c++, p++, l);\n    }\n}\n"}
{"id": 410207, "name": "Safe primes and unsafe primes", "source": "Translate Haskell to C#: import Text.Printf (printf)\nimport Data.Numbers.Primes (isPrime, primes)\n\nmain = do \n  printf \"First 35 safe primes: %s\\n\" (show $ take 35 safe)\n  printf \"There are %d safe primes below 100,000.\\n\" (length $ takeWhile (<1000000) safe)\n  printf \"There are %d safe primes below 10,000,000.\\n\\n\" (length $ takeWhile (<10000000) safe)\n\n  printf \"First 40 unsafe primes: %s\\n\" (show $ take 40 unsafe)\n  printf \"There are %d unsafe primes below 100,000.\\n\" (length $ takeWhile (<1000000) unsafe)\n  printf \"There are %d unsafe primes below 10,000,000.\\n\\n\" (length $ takeWhile (<10000000) unsafe)\n\n  where safe = filter (\\n -> isPrime ((n-1) `div` 2)) primes\n        unsafe = filter (\\n -> not (isPrime((n-1) `div` 2))) primes\n", "target": "using static System.Console;\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class SafePrimes\n{\n    public static void Main() {\n        HashSet<int> primes = Primes(10_000_000).ToHashSet();\n        WriteLine(\"First 35 safe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsSafe).Take(35)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsSafe):n0} safe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsSafe):n0} safe primes below {10_000_000:n0}\");\n        WriteLine(\"First 40 unsafe primes:\");\n        WriteLine(string.Join(\" \", primes.Where(IsUnsafe).Take(40)));\n        WriteLine($\"There are {primes.TakeWhile(p => p < 1_000_000).Count(IsUnsafe):n0} unsafe primes below {1_000_000:n0}\");\n        WriteLine($\"There are {primes.TakeWhile(p => p < 10_000_000).Count(IsUnsafe):n0} unsafe primes below {10_000_000:n0}\");\n\n        bool IsSafe(int prime) => primes.Contains(prime / 2);\n        bool IsUnsafe(int prime) => !primes.Contains(prime / 2);\n    }\n\n    \n    static IEnumerable<int> Primes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n}\n"}
{"id": 410208, "name": "Hash join", "source": "Translate Haskell to C#: \nimport qualified Data.HashTable.ST.Basic as H\nimport Data.Hashable\nimport Control.Monad.ST\nimport Control.Monad\nimport Data.STRef\n\nhashJoin :: (Eq k, Hashable k) =>\n            [t] -> (t -> k) -> [a] -> (a -> k) -> [(t, a)]\nhashJoin xs fx ys fy = runST $ do\n  l <- newSTRef []\n  ht <- H.new\n  forM_ ys $ \\y -> H.insert ht (fy y) =<< \n    (H.lookup ht (fy y) >>= \\case\n      Nothing -> return [y]\n      Just v -> return (y:v))\n  forM_ xs $ \\x -> do\n    H.lookup ht (fx x) >>= \\case\n      Nothing -> return ()\n      Just v -> modifySTRef' l ((map (x,)  v) ++) \n  readSTRef l\n\nmain = mapM_ print $ hashJoin \n    [(1, \"Jonah\"), (2, \"Alan\"), (3, \"Glory\"), (4, \"Popeye\")]\n        snd\n    [(\"Jonah\", \"Whales\"), (\"Jonah\", \"Spiders\"), \n      (\"Alan\", \"Ghosts\"), (\"Alan\", \"Zombies\"), (\"Glory\", \"Buffy\")]\n        fst\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace HashJoin\n{\n    public class AgeName\n    {\n        public AgeName(byte age, string name)\n        {\n            Age = age;\n            Name = name;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n    }\n\n    public class NameNemesis\n    {\n        public NameNemesis(string name, string nemesis)\n        {\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    public class DataContext\n    {\n        public DataContext()\n        {\n            AgeName = new List<AgeName>();\n            NameNemesis = new List<NameNemesis>();\n        }\n        public List<AgeName> AgeName { get; set; }\n        public List<NameNemesis> NameNemesis { get; set; }\n    }\n\n    public class AgeNameNemesis\n    {\n        public AgeNameNemesis(byte age, string name, string nemesis)\n        {\n            Age = age;\n            Name = name;\n            Nemesis = nemesis;\n        }\n        public byte Age { get; private set; }\n        public string Name { get; private set; }\n        public string Nemesis { get; private set; }\n    }\n\n    class Program\n    {\n        public static void Main()\n        {\n            var data = GetData();\n            var result = ExecuteHashJoin(data);\n            WriteResultToConsole(result);\n        }\n\n        private static void WriteResultToConsole(List<AgeNameNemesis> result)\n        {\n            result.ForEach(ageNameNemesis => Console.WriteLine(\"Age: {0}, Name: {1}, Nemesis: {2}\",\n                ageNameNemesis.Age, ageNameNemesis.Name, ageNameNemesis.Nemesis));\n        }\n\n        private static List<AgeNameNemesis> ExecuteHashJoin(DataContext data)\n        {\n            return (data.AgeName.Join(data.NameNemesis, \n                ageName => ageName.Name, nameNemesis => nameNemesis.Name,\n                (ageName, nameNemesis) => new AgeNameNemesis(ageName.Age, ageName.Name, nameNemesis.Nemesis)))\n                .ToList();\n        }\n\n        private static DataContext GetData()\n        {\n            var context = new DataContext();\n\n            context.AgeName.AddRange(new [] {\n                    new AgeName(27, \"Jonah\"), \n                    new AgeName(18, \"Alan\"), \n                    new AgeName(28, \"Glory\"), \n                    new AgeName(18, \"Popeye\"), \n                    new AgeName(28, \"Alan\")\n                });\n\n            context.NameNemesis.AddRange(new[]\n            {\n                new NameNemesis(\"Jonah\", \"Whales\"),\n                new NameNemesis(\"Jonah\", \"Spiders\"),\n                new NameNemesis(\"Alan\", \"Ghosts\"),\n                new NameNemesis(\"Alan\", \"Zombies\"),\n                new NameNemesis(\"Glory\", \"Buffy\")\n            });\n\n            return context;\n        }\n    }\n}\n"}
{"id": 410209, "name": "Find largest left truncatable prime in a given base", "source": "Translate Haskell to C#: primesTo100 = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]\n\n\nfind2km :: Integral a => a -> (Int,a)\nfind2km n = f 0 n\n\twhere f k m\n            | r == 1 = (k,m)\n            | otherwise = f (k+1) q\n            where (q,r) = quotRem m 2\n\n\nmillerRabinPrimality :: Integer -> Integer -> Bool\nmillerRabinPrimality n a\n    | a >= n_ = True\n    | b0 == 1 || b0 == n_ = True\n    | otherwise = iter (tail b)\n    where\n        n_ = n-1\n        (k,m) = find2km n_\n        b0 = powMod n a m\n        b = take k $ iterate (squareMod n) b0\n        iter [] = False\n        iter (x:xs)\n            | x == 1 = False\n            | x == n_ = True\n            | otherwise = iter xs\n\n\npow_ :: (Num a, Integral b) => (a->a->a) -> (a->a) -> a -> b -> a\npow_ _ _ _ 0 = 1\npow_ mul sq x_ n_ = f x_ n_ 1\n    where\n        f x n y\n            | n == 1 = x `mul` y\n            | r == 0 = f x2 q y\n            | otherwise = f x2 q (x `mul` y)\n            where\n                (q,r) = quotRem n 2\n                x2 = sq x\n\nmulMod :: Integral a => a -> a -> a -> a\nmulMod a b c = (b * c) `mod` a\nsquareMod :: Integral a => a -> a -> a\nsquareMod a b = (b * b) `rem` a\n\n\npowMod :: Integral a => a -> a -> a -> a\npowMod m = pow_ (mulMod m) (squareMod m)\n\n\n\n\nis_prime w n\n\t| n < 100 = n `elem` primesTo100\n\t| any ((==0).(n`mod`)) primesTo100 = False\n\t| otherwise = all (millerRabinPrimality n) w\n\n\nleft_trunc base = head $ filter (is_prime primesTo100) (reverse hopeful) where\n\thopeful = extend base $ takeWhile (<base) primesTo100 where\n\textend b x = if null d then x else extend (b*base) d where\n\t\td = concatMap addDigit [1..base-1]\n\t\t\n\t\taddDigit a = filter (is_prime [3]) $ map (a*b+) x\n\nmain = mapM_ print $ map (\\x->(x, left_trunc x)) [3..21]\n", "target": "using Mpir.NET;  \nusing System;   \nusing System.Collections.Generic;\nclass MaxLftTrP_B   \n{\n    static void Main()\n    {\n        mpz_t p; var sw = System.Diagnostics.Stopwatch.StartNew(); L(3);\n        for (uint b = 3; b < 13; b++)\n        {\n            sw.Restart(); p = L(b);\n            Console.WriteLine(\"{0} {1,2} {2}\", sw.Elapsed, b, p);\n        }\n        Console.Read();\n    }\n\n    static mpz_t L(uint b)\n    {\n        var p = new List<mpz_t>(); mpz_t np = 0;\n        while ((np = nxtP(np)) < b) p.Add(np);\n        int i0 = 0, i = 0, i1 = p.Count - 1; mpz_t n0 = b, n, n1 = b * (b - 1);\n        for (; i < p.Count; n0 *= b, n1 *= b, i0 = i1 + 1, i1 = p.Count - 1)\n            for (n = n0; n <= n1; n += n0)\n                for (i = i0; i <= i1; i++)\n                    if (mpir.mpz_probab_prime_p(np = n + p[i], 15) > 0) p.Add(np);\n        return p[p.Count - 1];\n    }\n\n    static mpz_t nxtP(mpz_t n) { mpz_t p = 0; mpir.mpz_nextprime(p, n); return p; }\n}\n"}
{"id": 410210, "name": "Speech synthesis", "source": "Translate Haskell to C#: import System.Process (callProcess) \n\nsay text = callProcess \"espeak\" [\"\n\nmain = say \"This is an example of speech synthesis.\"\n", "target": "using SpeechLib;\n\nnamespace Speaking_Computer\n{\n  public class Program\n  {\n    private static void Main()\n    {\n      var voice = new SpVoice();\n      voice.Speak(\"This is an example of speech synthesis.\");\n    }\n  }\n}\n"}
{"id": 410211, "name": "Tonelli-Shanks algorithm", "source": "Translate Haskell to C#: import Data.List (genericTake, genericLength)\nimport Data.Bits (shiftR)\n\npowMod :: Integer -> Integer -> Integer -> Integer\npowMod m b e = go b e 1\n  where\n    go b e r\n      | e == 0 = r\n      | odd e  = go ((b*b) `mod` m) (e `div` 2) ((r*b) `mod` m)\n      | even e = go ((b*b) `mod` m) (e `div` 2) r \n\nlegendre :: Integer -> Integer -> Integer\nlegendre a p = powMod p a ((p - 1) `div` 2) \n\ntonelli :: Integer -> Integer -> Maybe (Integer, Integer)\ntonelli n p | legendre n p /= 1 = Nothing\ntonelli n p =\n  let s = length $ takeWhile even $ iterate (`div` 2) (p-1)\n      q = shiftR (p-1) s\n  in if s == 1\n    then let r = powMod p n ((p+1) `div` 4)\n         in Just (r, p - r)\n    else let z = (2 +) . genericLength\n               $ takeWhile (\\i -> p - 1 /= legendre i p)\n               $ [2..p-1]\n         in loop s\n            ( powMod p z q )\n            ( powMod p n $ (q+1) `div` 2 )\n            ( powMod p n q )\n  where\n    loop m c r t\n      | (t - 1) `mod` p == 0 = Just (r, p - r)\n      | otherwise =\n        let i = (1 +) . genericLength . genericTake (m - 2)\n              $ takeWhile (\\t2 -> (t2 - 1) `mod` p /= 0)\n              $ iterate (\\t2 -> (t2*t2) `mod` p)\n              $ (t*t) `mod` p\n            b = powMod p c (2^(m - i - 1))\n            r' = (r*b)  `mod` p\n            c' = (b*b)  `mod` p\n            t' = (t*c') `mod` p\n        in loop i c' r' t'\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace TonelliShanks {\n    class Solution {\n        private readonly BigInteger root1, root2;\n        private readonly bool exists;\n\n        public Solution(BigInteger root1, BigInteger root2, bool exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n\n        public BigInteger Root1() {\n            return root1;\n        }\n\n        public BigInteger Root2() {\n            return root2;\n        }\n\n        public bool Exists() {\n            return exists;\n        }\n    }\n\n    class Program {\n        static Solution Ts(BigInteger n, BigInteger p) {\n            if (BigInteger.ModPow(n, (p - 1) / 2, p) != 1) {\n                return new Solution(0, 0, false);\n            }\n\n            BigInteger q = p - 1;\n            BigInteger ss = 0;\n            while ((q & 1) == 0) {\n                ss = ss + 1;\n                q = q >> 1;\n            }\n\n            if (ss == 1) {\n                BigInteger r1 = BigInteger.ModPow(n, (p + 1) / 4, p);\n                return new Solution(r1, p - r1, true);\n            }\n\n            BigInteger z = 2;\n            while (BigInteger.ModPow(z, (p - 1) / 2, p) != p - 1) {\n                z = z + 1;\n            }\n            BigInteger c = BigInteger.ModPow(z, q, p);\n            BigInteger r = BigInteger.ModPow(n, (q + 1) / 2, p);\n            BigInteger t = BigInteger.ModPow(n, q, p);\n            BigInteger m = ss;\n\n            while (true) {\n                if (t == 1) {\n                    return new Solution(r, p - r, true);\n                }\n                BigInteger i = 0;\n                BigInteger zz = t;\n                while (zz != 1 && i < (m - 1)) {\n                    zz = zz * zz % p;\n                    i = i + 1;\n                }\n                BigInteger b = c;\n                BigInteger e = m - i - 1;\n                while (e > 0) {\n                    b = b * b % p;\n                    e = e - 1;\n                }\n                r = r * b % p;\n                c = b * b % p;\n                t = t * c % p;\n                m = i;\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Tuple<long, long>> pairs = new List<Tuple<long, long>>() {\n                new Tuple<long, long>(10, 13),\n                new Tuple<long, long>(56, 101),\n                new Tuple<long, long>(1030, 10009),\n                new Tuple<long, long>(1032, 10009),\n                new Tuple<long, long>(44402, 100049),\n                new Tuple<long, long>(665820697, 1000000009),\n                new Tuple<long, long>(881398088036, 1000000000039),\n            };\n\n            foreach (var pair in pairs) {\n                Solution sol = Ts(pair.Item1, pair.Item2);\n                Console.WriteLine(\"n = {0}\", pair.Item1);\n                Console.WriteLine(\"p = {0}\", pair.Item2);\n                if (sol.Exists()) {\n                    Console.WriteLine(\"root1 = {0}\", sol.Root1());\n                    Console.WriteLine(\"root2 = {0}\", sol.Root2());\n                } else {\n                    Console.WriteLine(\"No solution exists\");\n                }\n                Console.WriteLine();\n            }\n\n            BigInteger bn = BigInteger.Parse(\"41660815127637347468140745042827704103445750172002\");\n            BigInteger bp = BigInteger.Pow(10, 50) + 577;\n            Solution bsol = Ts(bn, bp);\n            Console.WriteLine(\"n = {0}\", bn);\n            Console.WriteLine(\"p = {0}\", bp);\n            if (bsol.Exists()) {\n                Console.WriteLine(\"root1 = {0}\", bsol.Root1());\n                Console.WriteLine(\"root2 = {0}\", bsol.Root2());\n            } else {\n                Console.WriteLine(\"No solution exists\");\n            }\n        }\n    }\n}\n"}
{"id": 410212, "name": "Tonelli-Shanks algorithm", "source": "Translate Haskell to C#: import Data.List (genericTake, genericLength)\nimport Data.Bits (shiftR)\n\npowMod :: Integer -> Integer -> Integer -> Integer\npowMod m b e = go b e 1\n  where\n    go b e r\n      | e == 0 = r\n      | odd e  = go ((b*b) `mod` m) (e `div` 2) ((r*b) `mod` m)\n      | even e = go ((b*b) `mod` m) (e `div` 2) r \n\nlegendre :: Integer -> Integer -> Integer\nlegendre a p = powMod p a ((p - 1) `div` 2) \n\ntonelli :: Integer -> Integer -> Maybe (Integer, Integer)\ntonelli n p | legendre n p /= 1 = Nothing\ntonelli n p =\n  let s = length $ takeWhile even $ iterate (`div` 2) (p-1)\n      q = shiftR (p-1) s\n  in if s == 1\n    then let r = powMod p n ((p+1) `div` 4)\n         in Just (r, p - r)\n    else let z = (2 +) . genericLength\n               $ takeWhile (\\i -> p - 1 /= legendre i p)\n               $ [2..p-1]\n         in loop s\n            ( powMod p z q )\n            ( powMod p n $ (q+1) `div` 2 )\n            ( powMod p n q )\n  where\n    loop m c r t\n      | (t - 1) `mod` p == 0 = Just (r, p - r)\n      | otherwise =\n        let i = (1 +) . genericLength . genericTake (m - 2)\n              $ takeWhile (\\t2 -> (t2 - 1) `mod` p /= 0)\n              $ iterate (\\t2 -> (t2*t2) `mod` p)\n              $ (t*t) `mod` p\n            b = powMod p c (2^(m - i - 1))\n            r' = (r*b)  `mod` p\n            c' = (b*b)  `mod` p\n            t' = (t*c') `mod` p\n        in loop i c' r' t'\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\n\nnamespace TonelliShanks {\n    class Solution {\n        private readonly BigInteger root1, root2;\n        private readonly bool exists;\n\n        public Solution(BigInteger root1, BigInteger root2, bool exists) {\n            this.root1 = root1;\n            this.root2 = root2;\n            this.exists = exists;\n        }\n\n        public BigInteger Root1() {\n            return root1;\n        }\n\n        public BigInteger Root2() {\n            return root2;\n        }\n\n        public bool Exists() {\n            return exists;\n        }\n    }\n\n    class Program {\n        static Solution Ts(BigInteger n, BigInteger p) {\n            if (BigInteger.ModPow(n, (p - 1) / 2, p) != 1) {\n                return new Solution(0, 0, false);\n            }\n\n            BigInteger q = p - 1;\n            BigInteger ss = 0;\n            while ((q & 1) == 0) {\n                ss = ss + 1;\n                q = q >> 1;\n            }\n\n            if (ss == 1) {\n                BigInteger r1 = BigInteger.ModPow(n, (p + 1) / 4, p);\n                return new Solution(r1, p - r1, true);\n            }\n\n            BigInteger z = 2;\n            while (BigInteger.ModPow(z, (p - 1) / 2, p) != p - 1) {\n                z = z + 1;\n            }\n            BigInteger c = BigInteger.ModPow(z, q, p);\n            BigInteger r = BigInteger.ModPow(n, (q + 1) / 2, p);\n            BigInteger t = BigInteger.ModPow(n, q, p);\n            BigInteger m = ss;\n\n            while (true) {\n                if (t == 1) {\n                    return new Solution(r, p - r, true);\n                }\n                BigInteger i = 0;\n                BigInteger zz = t;\n                while (zz != 1 && i < (m - 1)) {\n                    zz = zz * zz % p;\n                    i = i + 1;\n                }\n                BigInteger b = c;\n                BigInteger e = m - i - 1;\n                while (e > 0) {\n                    b = b * b % p;\n                    e = e - 1;\n                }\n                r = r * b % p;\n                c = b * b % p;\n                t = t * c % p;\n                m = i;\n            }\n        }\n\n        static void Main(string[] args) {\n            List<Tuple<long, long>> pairs = new List<Tuple<long, long>>() {\n                new Tuple<long, long>(10, 13),\n                new Tuple<long, long>(56, 101),\n                new Tuple<long, long>(1030, 10009),\n                new Tuple<long, long>(1032, 10009),\n                new Tuple<long, long>(44402, 100049),\n                new Tuple<long, long>(665820697, 1000000009),\n                new Tuple<long, long>(881398088036, 1000000000039),\n            };\n\n            foreach (var pair in pairs) {\n                Solution sol = Ts(pair.Item1, pair.Item2);\n                Console.WriteLine(\"n = {0}\", pair.Item1);\n                Console.WriteLine(\"p = {0}\", pair.Item2);\n                if (sol.Exists()) {\n                    Console.WriteLine(\"root1 = {0}\", sol.Root1());\n                    Console.WriteLine(\"root2 = {0}\", sol.Root2());\n                } else {\n                    Console.WriteLine(\"No solution exists\");\n                }\n                Console.WriteLine();\n            }\n\n            BigInteger bn = BigInteger.Parse(\"41660815127637347468140745042827704103445750172002\");\n            BigInteger bp = BigInteger.Pow(10, 50) + 577;\n            Solution bsol = Ts(bn, bp);\n            Console.WriteLine(\"n = {0}\", bn);\n            Console.WriteLine(\"p = {0}\", bp);\n            if (bsol.Exists()) {\n                Console.WriteLine(\"root1 = {0}\", bsol.Root1());\n                Console.WriteLine(\"root2 = {0}\", bsol.Root2());\n            } else {\n                Console.WriteLine(\"No solution exists\");\n            }\n        }\n    }\n}\n"}
{"id": 410213, "name": "Truth table", "source": "Translate Haskell to C#: import Control.Monad (mapM, foldM, forever)\nimport Data.List (unwords, unlines, nub)\nimport Data.Maybe (fromJust)\n\ntruthTable expr = let\n    tokens = words expr\n    operators = [\"&\", \"|\", \"!\", \"^\", \"=>\"]\n    variables = nub $ filter (not . (`elem` operators)) tokens\n    table = zip variables <$> mapM (const [True,False]) variables\n    results = map (\\r -> (map snd r) ++ (calculate tokens) r) table\n    header = variables ++ [\"result\"]\n    in\n      showTable $ header : map (map show) results\n\n\n\n\ncalculate :: [String] -> [(String, Bool)] -> [Bool]\ncalculate = foldM interprete []\n  where\n    interprete (x:y:s) \"&\"  = (: s) <$> pure (x && y)\n    interprete (x:y:s) \"|\"  = (: s) <$> pure (x || y)\n    interprete (x:y:s) \"^\"  = (: s) <$> pure (x /= y)\n    interprete (x:y:s) \"=>\" = (: s) <$> pure (not y || x)\n    interprete (x:s)   \"!\"  = (: s) <$> pure (not x)\n    interprete s var        = (: s) <$> fromJust . lookup var\n \n\nshowTable tbl = unlines $ map (unwords . map align) tbl\n  where\n    align txt = take colWidth $ txt ++ repeat ' '\n    colWidth = max 6 $ maximum $ map length (head tbl)\n \nmain = forever $ getLine >>= putStrLn . truthTable\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\npublic class TruthTable\n{\n    enum TokenType { Unknown, WhiteSpace, Constant, Operand, Operator, LeftParenthesis, RightParenthesis }\n\n    readonly char trueConstant, falseConstant;\n    readonly IDictionary<char, Operator> operators = new Dictionary<char, Operator>();\n\n    public TruthTable(char falseConstant, char trueConstant)\n    {\n        this.trueConstant = trueConstant;\n        this.falseConstant = falseConstant;\n        Operators = new OperatorCollection(operators);\n    }\n\n    public OperatorCollection Operators { get; }\n\n    public void PrintTruthTable(string expression, bool isPostfix = false)\n    {\n        try {\n            foreach (string line in GetTruthTable(expression, isPostfix)) {\n                Console.WriteLine(line);\n            }\n        } catch (ArgumentException ex) {\n            Console.WriteLine(expression + \"   \" + ex.Message);\n        }\n    }\n\n    public IEnumerable<string> GetTruthTable(string expression, bool isPostfix = false)\n    {\n        if (string.IsNullOrWhiteSpace(expression)) throw new ArgumentException(\"Invalid expression.\");\n        \n        \n        var parameters = expression\n            .Where(c => TypeOf(c) == TokenType.Operand)\n            .Distinct()\n            .Reverse()\n            .Select((c, i) => (symbol: c, index: i))\n            .ToDictionary(p => p.symbol, p => p.index);\n\n        int count = parameters.Count;\n        if (count > 32) throw new ArgumentException(\"Cannot have more than 32 parameters.\");\n        string header = count == 0 ? expression : string.Join(\" \",\n            parameters.OrderByDescending(p => p.Value).Select(p => p.Key)) + \" \" + expression;\n\n        if (!isPostfix) expression = ConvertToPostfix(expression);\n\n        var values = default(BitSet);\n        var stack = new Stack<char>(expression.Length);\n        for (int loop = 1 << count; loop > 0; loop--) {\n            foreach (char token in expression) stack.Push(token);\n            bool result = Evaluate(stack, values, parameters);\n            if (header != null) {\n                if (stack.Count > 0) throw new ArgumentException(\"Invalid expression.\");\n                yield return header;\n                header = null;\n            }\n            string line = (count == 0 ? \"\" : \" \") + (result ? trueConstant : falseConstant);\n            line = string.Join(\" \", Enumerable.Range(0, count)\n                .Select(i => values[count - i - 1] ? trueConstant : falseConstant)) + line;\n            yield return line;\n            values++;\n        }\n    }\n\n    public string ConvertToPostfix(string infix)\n    {\n        var stack = new Stack<char>();\n        var postfix = new StringBuilder();\n        foreach (char c in infix) {\n            switch (TypeOf(c)) {\n            case TokenType.WhiteSpace:\n                continue;\n            case TokenType.Constant:\n            case TokenType.Operand:\n                postfix.Append(c);\n                break;\n            case TokenType.Operator:\n                int precedence = Precedence(c);\n                while (stack.Count > 0 && Precedence(stack.Peek()) > precedence) {\n                    postfix.Append(stack.Pop());\n                }\n                stack.Push(c);\n                break;\n            case TokenType.LeftParenthesis:\n                stack.Push(c);\n                break;\n            case TokenType.RightParenthesis:\n                char top = default(char);\n                while (stack.Count > 0) {\n                    top = stack.Pop();\n                    if (top == '(') break;\n                    else postfix.Append(top);\n                }\n                if (top != '(') throw new ArgumentException(\"No matching left parenthesis.\");\n                break;\n            default:\n                throw new ArgumentException(\"Invalid character: \" + c);\n            }\n        }\n        while (stack.Count > 0) {\n            char top = stack.Pop();\n            if (top == '(') throw new ArgumentException(\"No matching right parenthesis.\");\n            postfix.Append(top);\n        }\n        return postfix.ToString();\n    }\n\n    private bool Evaluate(Stack<char> expression, BitSet values, IDictionary<char, int> parameters)\n    {\n        if (expression.Count == 0) throw new ArgumentException(\"Invalid expression.\");\n        char c = expression.Pop();\n        TokenType type = TypeOf(c);\n        while (type == TokenType.WhiteSpace) type = TypeOf(c = expression.Pop());\n        switch (type) {\n        case TokenType.Constant:\n            return c == trueConstant;\n        case TokenType.Operand:\n            return values[parameters[c]];\n        case TokenType.Operator:\n            bool right = Evaluate(expression, values, parameters);\n            Operator op = operators[c];\n            if (op.Arity == 1) return op.Function(right, right);\n            bool left = Evaluate(expression, values, parameters);\n            return op.Function(left, right);\n        default:\n            throw new ArgumentException(\"Invalid character: \" + c);\n        }\n    }\n\n    private TokenType TypeOf(char c)\n    {\n        if (char.IsWhiteSpace(c)) return TokenType.WhiteSpace;\n        if (c == '(') return TokenType.LeftParenthesis;\n        if (c == ')') return TokenType.RightParenthesis;\n        if (c == trueConstant || c == falseConstant) return TokenType.Constant;\n        if (operators.ContainsKey(c)) return TokenType.Operator;\n        if (char.IsLetter(c)) return TokenType.Operand;\n        return TokenType.Unknown;\n    }\n\n    private int Precedence(char op) => operators.TryGetValue(op, out var o) ? o.Precedence : int.MinValue;\n}\n\nstruct Operator\n{\n    public Operator(char symbol, int precedence, Func<bool, bool> function) : this(symbol, precedence, 1, (l, r) => function(r)) { }\n\n    public Operator(char symbol, int precedence, Func<bool, bool, bool> function) : this(symbol, precedence, 2, function) { }\n\n    private Operator(char symbol, int precedence, int arity, Func<bool, bool, bool> function) : this()\n    {\n        Symbol = symbol;\n        Precedence = precedence;\n        Arity = arity;\n        Function = function;\n    }\n\n    public char Symbol { get; }\n    public int Precedence { get; }\n    public int Arity { get; }\n    public Func<bool, bool, bool> Function { get; }\n}\n\npublic class OperatorCollection : IEnumerable\n{\n    readonly IDictionary<char, Operator> operators;\n\n    internal OperatorCollection(IDictionary<char, Operator> operators) {\n        this.operators = operators;\n    }\n\n    public void Add(char symbol, int precedence, Func<bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n    public void Add(char symbol, int precedence, Func<bool, bool, bool> function)\n        => operators[symbol] = new Operator(symbol, precedence, function);\n\n    public void Remove(char symbol) => operators.Remove(symbol);\n\n    IEnumerator IEnumerable.GetEnumerator() => operators.Values.GetEnumerator();\n}\n\nstruct BitSet\n{\n    private int bits;\n\n    private BitSet(int bits) { this.bits = bits; }\n\n    public static BitSet operator ++(BitSet bitSet) => new BitSet(bitSet.bits + 1);\n\n    public bool this[int index] => (bits & (1 << index)) != 0;\n}\n\nclass Program\n{\n    public static void Main() {\n        TruthTable tt = new TruthTable('F', 'T') {\n            Operators = {\n                { '!', 6, r => !r },\n                { '&', 5, (l, r) => l && r },\n                { '^', 4, (l, r) => l ^ r },\n                { '|', 3, (l, r) => l || r }\n            }\n        };\n        \n        var rng = new Random();\n        tt.Operators.Add('?', 6, r => rng.NextDouble() < 0.5);\n        string[] expressions = {\n            \"!!!T\",\n            \"?T\",\n            \"F & x | T\",\n            \"F & (x | T\",\n            \"F & x | T)\",\n            \"a\u00a0! (a & a)\",\n            \"a | (a * a)\",\n            \"a ^ T & (b & !c)\",\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n\n        \n        tt = new TruthTable('0', '1') {\n            Operators = {\n                { '-', 6, r => !r },\n                { '^', 5, (l, r) => l && r },\n                { 'v', 3, (l, r) => l || r },\n                { '>', 2, (l, r) => !l || r },\n                { '=', 1, (l, r) => l == r },\n            }\n        };\n        expressions = new[] {\n            \"-X v 0 = X ^ 1\",\n            \"(H > M) ^ (S > H) > (S > M)\"\n        };\n        foreach (string expression in expressions) {\n            tt.PrintTruthTable(expression);\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 410214, "name": "Set of real numbers", "source": "Translate Haskell to C#: \n\nimport Data.List\nimport Data.Maybe\n\ndata BracketType = OpenSub | ClosedSub\n    deriving (Show, Enum, Eq, Ord)\n\ndata RealInterval = RealInterval {left :: BracketType, right :: BracketType, \n    lowerBound :: Double, upperBound :: Double}\n    deriving (Eq)\n\ntype RealSet = [RealInterval]\nposInf = 1.0/0.0 :: Double \nnegInf = (-1.0/0.0) :: Double\nset_R = RealInterval ClosedSub ClosedSub negInf posInf :: RealInterval\n\nemptySet = [] :: [RealInterval]\n\ninstance Show RealInterval where\n    show x@(RealInterval _ _ y y')\n        | y == y' && (left x == right x) && (left x == ClosedSub) = \"{\" ++ (show y) ++ \"}\"\n        | otherwise = [['(', '[']!!(fromEnum $ left x)] ++ (show $ lowerBound x) ++\n         \",\" ++ (show $ upperBound x) ++ [[')', ']']!!(fromEnum $ right x)]\n    showList [x] = shows x\n    showList (h:t) = shows h . (\" U \" ++) . showList t\n    showList [] =  (++ \"(/)\") \n\nconstruct_interval :: Char -> Double -> Double -> Char -> RealInterval\nconstruct_interval '(' x y ')' = RealInterval OpenSub OpenSub x y \nconstruct_interval '(' x y ']' = RealInterval OpenSub ClosedSub x y \nconstruct_interval '[' x y ')' = RealInterval ClosedSub OpenSub x y \nconstruct_interval _ x y _ = RealInterval ClosedSub ClosedSub x y \n\nset_is_empty :: RealSet -> Bool\nset_is_empty rs = (rs == emptySet)\n\nset_in :: Double -> RealSet -> Bool\nset_in x [] = False\nset_in x rs =\n    isJust (find (\\s ->\n        ((lowerBound s < x) && (x < upperBound s)) ||\n        (x == lowerBound s && left s == ClosedSub) ||\n        (x == upperBound s && right s == ClosedSub))\n        rs)\n\n\nmax_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmin_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmax_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, max y y') \n    | x < x'  = p2\n    | otherwise = p1\n\nmin_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, min y y')\n    | x < x'  = p1\n    | otherwise = p2\n\nsimple_intersection :: RealInterval -> RealInterval -> [RealInterval]\nsimple_intersection ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = emptySet\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = emptySet\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = emptySet\n    | otherwise = let lb = if x1 == x2 then (x1, min l_ri1 l_ri2) else max_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = min_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_union :: RealInterval -> RealInterval -> [RealInterval]\nsimple_union ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = [ri2, ri1]\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = [ri1, ri2]\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = [ri1, ri2]\n    | otherwise = let lb = if x1 == x2 then (x1, max l_ri1 l_ri2) else min_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = max_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_complement :: RealInterval -> [RealInterval]\nsimple_complement ri1@(RealInterval l_ri1 r_ri1 x1 y1) =\n    [(RealInterval ClosedSub (inv l_ri1) negInf x1), (RealInterval (inv r_ri1) ClosedSub y1 posInf)]\n    where\n        inv OpenSub = ClosedSub\n        inv ClosedSub = OpenSub\n\nset_sort :: RealSet -> RealSet \nset_sort rs =\n    sortBy\n        (\\s1 s2 ->\n            let (lp, rp) = ((lowerBound s1, left s1), (lowerBound s2, left s2)) in\n                if max_p lp rp == lp then GT else LT)\n        rs\n\nset_simplify :: RealSet -> RealSet\nset_simplify [] = emptySet\nset_simplify rs =\n    concat (map make_empty (set_sort (foldl\n        (\\acc ri1 -> (simple_union (head acc) ri1) ++ (tail acc))\n        [head sorted_rs]\n        sorted_rs)))\n    where\n        sorted_rs = set_sort rs\n        make_empty ri@(RealInterval lb rb x y)\n            | x >= y && (lb /= rb || rb /= ClosedSub) = emptySet\n            | otherwise = [ri]\n\n\nset_complement :: RealSet -> RealSet\nset_union :: RealSet -> RealSet -> RealSet\nset_intersection :: RealSet -> RealSet -> RealSet\nset_difference :: RealSet -> RealSet -> RealSet\nset_measure :: RealSet -> Double\n\nset_complement rs =\n    foldl set_intersection [set_R] (map simple_complement rs)\nset_union rs1 rs2 =\n    set_simplify (rs1 ++ rs2)\nset_intersection rs1 rs2 =\n    set_simplify $ concat [simple_intersection s1 s2 | s1 <- rs1, s2 <- rs2]\nset_difference rs1 rs2 =\n    set_intersection (set_complement rs2) rs1\nset_measure rs =\n    foldl (\\acc x -> acc + (upperBound x) - (lowerBound x)) 0.0 rs\n\n\ntest = map (\\x -> [x]) [construct_interval '(' 0 1 ']', construct_interval '[' 0 2 ')',\n    construct_interval '[' 0 2 ')', construct_interval '(' 1 2 ']',\n    construct_interval '[' 0 3 ')', construct_interval '(' 0 1 ')',\n    construct_interval '[' 0 3 ')', construct_interval '[' 0 1 ']']\nrestest = [set_union (test!!0) (test!!1), set_intersection (test!!2) (test!!3),\n    set_difference (test!!4) (test!!5), set_difference (test!!6) (test!!7)]\nisintest s = \n    mapM_\n        (\\x -> putStrLn ((show x) ++ \" is in \" ++ (show s) ++ \"\u00a0: \" ++ (show (set_in x s))))\n        [0, 1, 2]\n\ntestA = [construct_interval '(' (sqrt (n + (1.0/6))) (sqrt (n + (5.0/6))) ')' | n <- [0..99]]\ntestB = [construct_interval '(' (n + (1.0/6)) (n + (5.0/6)) ')' | n <- [0..9]]\n\nmain =\n    putStrLn (\"union \" ++ (show (test!!0)) ++ \" \" ++ (show (test!!1)) ++ \" = \" ++ (show (restest!!0))) >>\n    putStrLn (\"inter \" ++ (show (test!!2)) ++ \" \" ++ (show (test!!3)) ++ \" = \" ++ (show (restest!!1))) >>\n    putStrLn (\"diff \" ++ (show (test!!4)) ++ \" \" ++ (show (test!!5)) ++ \" = \" ++ (show (restest!!2))) >>\n    putStrLn (\"diff \" ++ (show (test!!6)) ++ \" \" ++ (show (test!!7)) ++ \" = \" ++ (show (restest!!3))) >>\n    mapM_ isintest restest >>\n    putStrLn (\"measure: \" ++ (show (set_measure (set_difference testA testB))))\n", "target": "using System;\n\nnamespace RosettaCode.SetOfRealNumbers\n{\n    public class Set<TValue>\n    {\n        public Set(Predicate<TValue> contains)\n        {\n            Contains = contains;\n        }\n\n        public Predicate<TValue> Contains\n        {\n            get;\n            private set;\n        }\n\n        public Set<TValue> Union(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) || set.Contains(value));\n        }\n\n        public Set<TValue> Intersection(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && set.Contains(value));\n        }\n\n        public Set<TValue> Difference(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && !set.Contains(value));\n        }\n    }\n}\n"}
{"id": 410215, "name": "Set of real numbers", "source": "Translate Haskell to C#: \n\nimport Data.List\nimport Data.Maybe\n\ndata BracketType = OpenSub | ClosedSub\n    deriving (Show, Enum, Eq, Ord)\n\ndata RealInterval = RealInterval {left :: BracketType, right :: BracketType, \n    lowerBound :: Double, upperBound :: Double}\n    deriving (Eq)\n\ntype RealSet = [RealInterval]\nposInf = 1.0/0.0 :: Double \nnegInf = (-1.0/0.0) :: Double\nset_R = RealInterval ClosedSub ClosedSub negInf posInf :: RealInterval\n\nemptySet = [] :: [RealInterval]\n\ninstance Show RealInterval where\n    show x@(RealInterval _ _ y y')\n        | y == y' && (left x == right x) && (left x == ClosedSub) = \"{\" ++ (show y) ++ \"}\"\n        | otherwise = [['(', '[']!!(fromEnum $ left x)] ++ (show $ lowerBound x) ++\n         \",\" ++ (show $ upperBound x) ++ [[')', ']']!!(fromEnum $ right x)]\n    showList [x] = shows x\n    showList (h:t) = shows h . (\" U \" ++) . showList t\n    showList [] =  (++ \"(/)\") \n\nconstruct_interval :: Char -> Double -> Double -> Char -> RealInterval\nconstruct_interval '(' x y ')' = RealInterval OpenSub OpenSub x y \nconstruct_interval '(' x y ']' = RealInterval OpenSub ClosedSub x y \nconstruct_interval '[' x y ')' = RealInterval ClosedSub OpenSub x y \nconstruct_interval _ x y _ = RealInterval ClosedSub ClosedSub x y \n\nset_is_empty :: RealSet -> Bool\nset_is_empty rs = (rs == emptySet)\n\nset_in :: Double -> RealSet -> Bool\nset_in x [] = False\nset_in x rs =\n    isJust (find (\\s ->\n        ((lowerBound s < x) && (x < upperBound s)) ||\n        (x == lowerBound s && left s == ClosedSub) ||\n        (x == upperBound s && right s == ClosedSub))\n        rs)\n\n\nmax_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmin_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmax_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, max y y') \n    | x < x'  = p2\n    | otherwise = p1\n\nmin_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, min y y')\n    | x < x'  = p1\n    | otherwise = p2\n\nsimple_intersection :: RealInterval -> RealInterval -> [RealInterval]\nsimple_intersection ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = emptySet\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = emptySet\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = emptySet\n    | otherwise = let lb = if x1 == x2 then (x1, min l_ri1 l_ri2) else max_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = min_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_union :: RealInterval -> RealInterval -> [RealInterval]\nsimple_union ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = [ri2, ri1]\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = [ri1, ri2]\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = [ri1, ri2]\n    | otherwise = let lb = if x1 == x2 then (x1, max l_ri1 l_ri2) else min_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = max_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_complement :: RealInterval -> [RealInterval]\nsimple_complement ri1@(RealInterval l_ri1 r_ri1 x1 y1) =\n    [(RealInterval ClosedSub (inv l_ri1) negInf x1), (RealInterval (inv r_ri1) ClosedSub y1 posInf)]\n    where\n        inv OpenSub = ClosedSub\n        inv ClosedSub = OpenSub\n\nset_sort :: RealSet -> RealSet \nset_sort rs =\n    sortBy\n        (\\s1 s2 ->\n            let (lp, rp) = ((lowerBound s1, left s1), (lowerBound s2, left s2)) in\n                if max_p lp rp == lp then GT else LT)\n        rs\n\nset_simplify :: RealSet -> RealSet\nset_simplify [] = emptySet\nset_simplify rs =\n    concat (map make_empty (set_sort (foldl\n        (\\acc ri1 -> (simple_union (head acc) ri1) ++ (tail acc))\n        [head sorted_rs]\n        sorted_rs)))\n    where\n        sorted_rs = set_sort rs\n        make_empty ri@(RealInterval lb rb x y)\n            | x >= y && (lb /= rb || rb /= ClosedSub) = emptySet\n            | otherwise = [ri]\n\n\nset_complement :: RealSet -> RealSet\nset_union :: RealSet -> RealSet -> RealSet\nset_intersection :: RealSet -> RealSet -> RealSet\nset_difference :: RealSet -> RealSet -> RealSet\nset_measure :: RealSet -> Double\n\nset_complement rs =\n    foldl set_intersection [set_R] (map simple_complement rs)\nset_union rs1 rs2 =\n    set_simplify (rs1 ++ rs2)\nset_intersection rs1 rs2 =\n    set_simplify $ concat [simple_intersection s1 s2 | s1 <- rs1, s2 <- rs2]\nset_difference rs1 rs2 =\n    set_intersection (set_complement rs2) rs1\nset_measure rs =\n    foldl (\\acc x -> acc + (upperBound x) - (lowerBound x)) 0.0 rs\n\n\ntest = map (\\x -> [x]) [construct_interval '(' 0 1 ']', construct_interval '[' 0 2 ')',\n    construct_interval '[' 0 2 ')', construct_interval '(' 1 2 ']',\n    construct_interval '[' 0 3 ')', construct_interval '(' 0 1 ')',\n    construct_interval '[' 0 3 ')', construct_interval '[' 0 1 ']']\nrestest = [set_union (test!!0) (test!!1), set_intersection (test!!2) (test!!3),\n    set_difference (test!!4) (test!!5), set_difference (test!!6) (test!!7)]\nisintest s = \n    mapM_\n        (\\x -> putStrLn ((show x) ++ \" is in \" ++ (show s) ++ \"\u00a0: \" ++ (show (set_in x s))))\n        [0, 1, 2]\n\ntestA = [construct_interval '(' (sqrt (n + (1.0/6))) (sqrt (n + (5.0/6))) ')' | n <- [0..99]]\ntestB = [construct_interval '(' (n + (1.0/6)) (n + (5.0/6)) ')' | n <- [0..9]]\n\nmain =\n    putStrLn (\"union \" ++ (show (test!!0)) ++ \" \" ++ (show (test!!1)) ++ \" = \" ++ (show (restest!!0))) >>\n    putStrLn (\"inter \" ++ (show (test!!2)) ++ \" \" ++ (show (test!!3)) ++ \" = \" ++ (show (restest!!1))) >>\n    putStrLn (\"diff \" ++ (show (test!!4)) ++ \" \" ++ (show (test!!5)) ++ \" = \" ++ (show (restest!!2))) >>\n    putStrLn (\"diff \" ++ (show (test!!6)) ++ \" \" ++ (show (test!!7)) ++ \" = \" ++ (show (restest!!3))) >>\n    mapM_ isintest restest >>\n    putStrLn (\"measure: \" ++ (show (set_measure (set_difference testA testB))))\n", "target": "using System;\n\nnamespace RosettaCode.SetOfRealNumbers\n{\n    public class Set<TValue>\n    {\n        public Set(Predicate<TValue> contains)\n        {\n            Contains = contains;\n        }\n\n        public Predicate<TValue> Contains\n        {\n            get;\n            private set;\n        }\n\n        public Set<TValue> Union(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) || set.Contains(value));\n        }\n\n        public Set<TValue> Intersection(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && set.Contains(value));\n        }\n\n        public Set<TValue> Difference(Set<TValue> set)\n        {\n            return new Set<TValue>(value => Contains(value) && !set.Contains(value));\n        }\n    }\n}\n"}
{"id": 410216, "name": "Super-d numbers", "source": "Translate Haskell to C#: import Data.List (isInfixOf)\nimport Data.Char (intToDigit)\n\nisSuperd :: (Show a, Integral a) => a -> a -> Bool\nisSuperd p n =\n  (replicate <*> intToDigit) (fromIntegral p) `isInfixOf` show (p * n ^ p)\n\nfindSuperd :: (Show a, Integral a) => a -> [a]\nfindSuperd p = filter (isSuperd p) [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn .\n     (\"First 10 super-\" ++) .\n     ((++) . show <*> ((\"\u00a0: \" ++) . show . take 10 . findSuperd)))\n    [2 .. 6]\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 410217, "name": "Super-d numbers", "source": "Translate Haskell to C#: import Data.List (isInfixOf)\nimport Data.Char (intToDigit)\n\nisSuperd :: (Show a, Integral a) => a -> a -> Bool\nisSuperd p n =\n  (replicate <*> intToDigit) (fromIntegral p) `isInfixOf` show (p * n ^ p)\n\nfindSuperd :: (Show a, Integral a) => a -> [a]\nfindSuperd p = filter (isSuperd p) [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn .\n     (\"First 10 super-\" ++) .\n     ((++) . show <*> ((\"\u00a0: \" ++) . show . take 10 . findSuperd)))\n    [2 .. 6]\n", "target": "using System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\nusing lbi = System.Collections.Generic.List<System.Numerics.BigInteger[]>;\nusing static System.Console;\n\nclass Program {\n\n    \n    struct LI { public UInt64 lo, ml, mh, hi, tp; }\n\n    const UInt64 Lm = 1_000_000_000_000_000_000UL;\n    const string Fm = \"D18\";\n\n    static void inc(ref LI d, LI s) { \n        d.lo += s.lo; while (d.lo >= Lm) { d.ml++; d.lo -= Lm; }\n        d.ml += s.ml; while (d.ml >= Lm) { d.mh++; d.ml -= Lm; }\n        d.mh += s.mh; while (d.mh >= Lm) { d.hi++; d.mh -= Lm; }\n        d.hi += s.hi; while (d.hi >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n\n    static void set(ref LI d, UInt64 s) { \n        d.lo = s; d.ml = d.mh = d.hi = d.tp = 0;\n    }\n\n    const int ls = 10;\n\n    static lbi co = new lbi { new BI[] { 0 } }; \n    static List<LI[]> Co = new List<LI[]> { new LI[1] }; \n\n    static Int64 ipow(Int64 bas, Int64 exp) { \n        Int64 res = 1; while (exp != 0) {\n            if ((exp & 1) != 0) res *= bas; exp >>= 1; bas *= bas;\n        }\n        return res;\n    }\n\n    \n    static void fin() { WriteLine(\"{0}s\", (DateTime.Now - st).TotalSeconds.ToString().Substring(0, 5)); }\n\n    static void funM(int d) { \n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++)\n            if ((BI.Pow((BI)i, d) * d).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n        fin();\n    }\n\n    static void funS(int d) { \n        BI[] m = co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = 0, c = 0; c < ls; i++) {\n            if ((d * m[0]).ToString().Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--) m[k] += m[j];\n        }\n        fin();\n    }\n\n    static string scale(uint s, ref LI x) { \n        ulong Lo = x.lo * s, Ml = x.ml * s, Mh = x.mh * s, Hi = x.hi * s, Tp = x.tp * s;\n        while (Lo >= Lm) { Lo -= Lm; Ml++; }\n        while (Ml >= Lm) { Ml -= Lm; Mh++; }\n        while (Mh >= Lm) { Mh -= Lm; Hi++; }\n        while (Hi >= Lm) { Hi -= Lm; Tp++; }\n        if (Tp > 0) return Tp.ToString() + Hi.ToString(Fm) + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Hi > 0) return Hi.ToString() + Mh.ToString(Fm) + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Mh > 0) return Mh.ToString() + Ml.ToString(Fm) + Lo.ToString(Fm);\n        if (Ml > 0) return Ml.ToString() + Lo.ToString(Fm);\n        return Lo.ToString();\n    }\n\n    static void funF(int d) { \n        LI[] m = Co[d];\n        string s = new string(d.ToString()[0], d); Write(\"{0}: \", d);\n        for (int i = d, c = 0; c < ls; i++) {\n            if (scale((uint)d, ref m[0]).Contains(s))\n                Write(\"{0} \", i, ++c);\n            for (int j = d, k = d - 1; j > 0; j = k--)\n                inc(ref m[k], m[j]);\n        }\n        fin();\n    }\n\n    static void init() { \n        for (int v = 1; v < 10; v++) {\n            BI[] res = new BI[v + 1];\n            long[] f = new long[v + 1], l = new long[v + 1];\n            for (int j = 0; j <= v; j++) {\n                if (j == v) {\n                    LI[] t = new LI[v + 1];\n                    for (int y = 0; y <= v; y++) set(ref t[y], (UInt64)f[y]);\n                    Co.Add(t);\n                }\n                res[j] = f[j];\n                l[0] = f[0]; f[0] = ipow(j + 1, v);\n                for (int a = 0, b = 1; b <= v; a = b++) {\n                    l[b] = f[b]; f[b] = f[a] - l[a];\n                }\n            }\n            for (int z = res.Length - 2; z > 0; z -= 2) res[z] *= -1;\n            co.Add(res);\n        }\n    }\n\n    static DateTime st;\n\n    static void doOne(string title, int top, Action<int> func) {\n        WriteLine('\\n' + title); st = DateTime.Now;\n        for (int i = 2; i <= top; i++) func(i);\n    }\n\n    static void Main(string[] args)\n    {\n        init(); const int top = 9;\n        doOne(\"BigInteger mostly addition:\", top, funS);\n        doOne(\"BigInteger.Pow():\", top, funM);\n        doOne(\"UInt64 structure mostly addition:\", top, funF);\n    }\n}\n"}
{"id": 410218, "name": "Monads_Maybe monad", "source": "Translate Haskell to C#: main = do print $ Just 3 >>= (return . (*2)) >>= (return . (+1))  \n          print $ Nothing >>= (return . (*2)) >>= (return . (+1)) \n", "target": "using System;\n\nnamespace RosettaMaybe\n{\n    \n    public abstract class Maybe<T>\n    {\n        public sealed class Some : Maybe<T>\n        {\n            public Some(T value) => Value = value;\n            public T Value { get; }\n        }\n        public sealed class None : Maybe<T> { }\n    }\n\n    class Program\n    {\n        static Maybe<double> MonadicSquareRoot(double x)\n        {\n            if (x >= 0)\n            {\n                return new Maybe<double>.Some(Math.Sqrt(x));\n            }\n            else\n            {\n                return new Maybe<double>.None();\n            }\n        }\n        static void Main(string[] args)\n        {\n            foreach (double x in new double[] { 4.0D, 8.0D, -15.0D, 16.23D, -42 })\n            {\n                Maybe<double> maybe = MonadicSquareRoot(x);\n                if (maybe is Maybe<double>.Some some)\n                {\n                    Console.WriteLine($\"The square root of {x} is \" + some.Value);\n                }\n                else\n                {\n                    Console.WriteLine($\"Square root of {x} is undefined.\");\n                }\n            }\n        }\n    }\n}\n"}
{"id": 410219, "name": "Church numerals", "source": "Translate Haskell to C#: import Unsafe.Coerce ( unsafeCoerce )\n\ntype Church a = (a -> a) -> a -> a\n\nchurchZero :: Church  a\nchurchZero = const id\n\nchurchOne :: Church a\nchurchOne = id\n\nsuccChurch :: Church a -> Church a\nsuccChurch = (<*>) (.) \n\naddChurch :: Church a -> Church a -> Church a\naddChurch = (<*>). fmap (.) \n\nmultChurch :: Church a -> Church a -> Church a\nmultChurch = (.) \n\nexpChurch :: Church a -> Church a -> Church a\nexpChurch basech expch = unsafeCoerce expch basech\n\nisChurchZero :: Church a -> Church a\nisChurchZero ch = unsafeCoerce ch (const churchZero) churchOne\n\npredChurch :: Church a -> Church a\npredChurch ch f x = unsafeCoerce ch (\\ g h -> h (g f)) (const x) id\n\nminusChurch :: Church a -> Church a -> Church a\nminusChurch ach bch = unsafeCoerce bch predChurch ach\n\n\ndivChurch :: Church a -> Church a -> Church a\ndivChurch dvdnd dvsr =\n  let divr n d =\n        (\\ v -> v (const $ succChurch $ divr v d) \n                  churchZero \n        ) (minusChurch n d)\n  in divr (unsafeCoerce succChurch dvdnd) $ unsafeCoerce dvsr\n\nchurchFromInt :: Int -> Church a\nchurchFromInt 0 = churchZero\nchurchFromInt n = succChurch $ churchFromInt (n - 1)\n\n\n\n\n\n\n\nintFromChurch :: Church Int -> Int\nintFromChurch ch = ch succ 0\n\n\nmain :: IO ()\nmain = do\n  let [cThree, cFour, cEleven, cTwelve] = churchFromInt <$> [3, 4, 11, 12]\n  print $ fmap intFromChurch  [ addChurch cThree cFour\n                              , multChurch cThree cFour\n                              , expChurch cFour cThree\n                              , expChurch cThree cFour\n                              , isChurchZero churchZero\n                              , predChurch cFour\n                              , minusChurch cEleven cThree\n                              , divChurch cEleven cThree\n                              , divChurch cTwelve cThree\n                              ]\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 410220, "name": "Church numerals", "source": "Translate Haskell to C#: import Unsafe.Coerce ( unsafeCoerce )\n\ntype Church a = (a -> a) -> a -> a\n\nchurchZero :: Church  a\nchurchZero = const id\n\nchurchOne :: Church a\nchurchOne = id\n\nsuccChurch :: Church a -> Church a\nsuccChurch = (<*>) (.) \n\naddChurch :: Church a -> Church a -> Church a\naddChurch = (<*>). fmap (.) \n\nmultChurch :: Church a -> Church a -> Church a\nmultChurch = (.) \n\nexpChurch :: Church a -> Church a -> Church a\nexpChurch basech expch = unsafeCoerce expch basech\n\nisChurchZero :: Church a -> Church a\nisChurchZero ch = unsafeCoerce ch (const churchZero) churchOne\n\npredChurch :: Church a -> Church a\npredChurch ch f x = unsafeCoerce ch (\\ g h -> h (g f)) (const x) id\n\nminusChurch :: Church a -> Church a -> Church a\nminusChurch ach bch = unsafeCoerce bch predChurch ach\n\n\ndivChurch :: Church a -> Church a -> Church a\ndivChurch dvdnd dvsr =\n  let divr n d =\n        (\\ v -> v (const $ succChurch $ divr v d) \n                  churchZero \n        ) (minusChurch n d)\n  in divr (unsafeCoerce succChurch dvdnd) $ unsafeCoerce dvsr\n\nchurchFromInt :: Int -> Church a\nchurchFromInt 0 = churchZero\nchurchFromInt n = succChurch $ churchFromInt (n - 1)\n\n\n\n\n\n\n\nintFromChurch :: Church Int -> Int\nintFromChurch ch = ch succ 0\n\n\nmain :: IO ()\nmain = do\n  let [cThree, cFour, cEleven, cTwelve] = churchFromInt <$> [3, 4, 11, 12]\n  print $ fmap intFromChurch  [ addChurch cThree cFour\n                              , multChurch cThree cFour\n                              , expChurch cFour cThree\n                              , expChurch cThree cFour\n                              , isChurchZero churchZero\n                              , predChurch cFour\n                              , minusChurch cEleven cThree\n                              , divChurch cEleven cThree\n                              , divChurch cTwelve cThree\n                              ]\n", "target": "using System;\n \npublic delegate Church Church(Church f);\n \npublic static class ChurchNumeral\n{\n    public static readonly Church ChurchZero = _ => x => x;\n    public static readonly Church ChurchOne = f => f;\n \n    public static Church Successor(this Church n) => f => x => f(n(f)(x));\n    public static Church Add(this Church m, Church n) => f => x => m(f)(n(f)(x));\n    public static Church Multiply(this Church m, Church n) => f => m(n(f));\n    public static Church Exponent(this Church m, Church n) => n(m);\n    public static Church IsZero(this Church n) => n(_ => ChurchZero)(ChurchOne);\n    public static Church Predecessor(this Church n) =>\n      f => x => n(g => h => h(g(f)))(_ => x)(a => a);\n    public static Church Subtract(this Church m, Church n) => n(Predecessor)(m);\n    static Church looper(this Church v, Church d) =>\n        v(_ => v.divr(d).Successor())(ChurchZero);\n    static Church divr(this Church n, Church d) =>\n        n.Subtract(d).looper(d);\n    public static Church Divide(this Church dvdnd, Church dvsr) =>\n        (dvdnd.Successor()).divr(dvsr);\n \n    public static Church FromInt(int i) =>\n      i <= 0 ? ChurchZero : Successor(FromInt(i - 1));\n \n    public static int ToInt(this Church ch) {\n        int count = 0;\n        ch(x => { count++; return x; })(null);\n        return count;\n    }\n \n    public static void Main() {\n        Church c3 = FromInt(3);\n        Church c4 = c3.Successor();\n        Church c11 = FromInt(11);\n        Church c12 = c11.Successor();\n        int sum = c3.Add(c4).ToInt();\n        int product = c3.Multiply(c4).ToInt();\n        int exp43 = c4.Exponent(c3).ToInt();\n        int exp34 = c3.Exponent(c4).ToInt();\n        int tst0 = ChurchZero.IsZero().ToInt();\n        int pred4 = c4.Predecessor().ToInt();\n        int sub43 = c4.Subtract(c3).ToInt();\n        int div11by3 = c11.Divide(c3).ToInt();\n        int div12by3 = c12.Divide(c3).ToInt();\n        Console.Write($\"{sum} {product} {exp43} {exp34} {tst0} \");\n        Console.WriteLine($\"{pred4} {sub43} {div11by3} {div12by3}\");\n    } \n}\n"}
{"id": 410221, "name": "Canonicalize CIDR", "source": "Translate Haskell to C#: import Control.Monad (guard)\nimport Data.Bits ((.|.), (.&.), complement, shiftL, shiftR, zeroBits)\nimport Data.Maybe (listToMaybe)\nimport Data.Word (Word32, Word8)\nimport Text.ParserCombinators.ReadP (ReadP, char, readP_to_S)\nimport Text.Printf (printf)\nimport Text.Read.Lex (readDecP)\n\n\n\ndata CIDR = CIDR Word32 Word8\n\n\ncidrRead :: String -> Maybe CIDR\ncidrRead = listToMaybe . map fst . readP_to_S cidrP\n\n\ncidrShow :: CIDR -> String\ncidrShow (CIDR addr n) = let (a, b, c, d) = octetsFrom addr\n                         in printf \"%u.%u.%u.%u/%u\" a b c d n\n\n\n\n\ncidrP :: ReadP CIDR\ncidrP = do a <- octetP <* char '.'\n           b <- octetP <* char '.'\n           c <- octetP <* char '.'\n           d <- octetP <* char '/'\n           n <- netBitsP\n           return $ CIDR (addrFrom a b c d .&. netmask n) n\n  where octetP   = wordP 255\n        netBitsP = wordP  32\n\n\n\n\n\nwordP :: Integral a => Integer -> ReadP a\nwordP lim = do n <- readDecP\n               guard $ n <= lim\n               return $ fi n\n\n\noctetsFrom :: Word32 -> (Word8, Word8, Word8, Word8)\noctetsFrom addr = (oct addr 3, oct addr 2, oct addr 1, oct addr 0)\n  where oct w n = fi $ w `shiftR` (8*n) .&. 0xff\n\n\naddrFrom :: Word8 -> Word8 -> Word8 -> Word8 -> Word32\naddrFrom a b c d = 0 <<+ a <<+ b <<+ c <<+ d\n  where w <<+ o = w `shiftL` 8 .|. fi o\n\n\n\nnetmask :: Word8 -> Word32\nnetmask n = complement $ complement zeroBits `shiftR` fi n\n\nfi :: (Integral a, Num b) => a -> b\nfi = fromIntegral\n\ntest :: String -> IO ()\ntest str = do\n  let cidrStr = maybe \"invalid CIDR string\" cidrShow (cidrRead str)\n  printf \"%-18s -> %s\\n\" str cidrStr\n\nmain :: IO ()\nmain = do\n  test \"87.70.141.1/22\"\n  test \"36.18.154.103/12\"\n  test \"62.62.197.11/29\"\n  test \"67.137.119.181/4\"\n  test \"161.214.74.21/24\"\n  test \"184.232.176.184/18\"\n  \n  test \"184.256.176.184/12\" \n  test \"184.232.176.184/33\" \n  test \"184.232.184/18\"     \n", "target": "using System;\nusing System.Net;\nusing System.Linq;\n                    \npublic class Program\n{\n    public static void Main()\n    {\n        string[] tests = {\n            \"87.70.141.1/22\",\n            \"36.18.154.103/12\",\n            \"62.62.197.11/29\",\n            \"67.137.119.181/4\",\n            \"161.214.74.21/24\",\n            \"184.232.176.184/18\"\n        };\n        \n        foreach (string t in tests) Console.WriteLine($\"{t}   =>   {Canonicalize(t)}\");\n    }\n    \n    static string Canonicalize(string cidr) => CIDR.Parse(cidr).Canonicalize().ToString();\n}\n\nreadonly struct CIDR\n{\n    public readonly IPAddress ip;\n    public readonly int length;\n    \n    public static CIDR Parse(string cidr)\n    {\n        string[] parts = cidr.Split('/');\n        return new CIDR(IPAddress.Parse(parts[0]), int.Parse(parts[1]));\n    }\n    \n    public CIDR(IPAddress ip, int length) => (this.ip, this.length) = (ip, length);\n    \n    public CIDR Canonicalize() =>\n        new CIDR(\n            new IPAddress(\n                ToBytes(\n                    ToInt(\n                        ip.GetAddressBytes()\n                    )\n                    & ~((1 << (32 - length)) - 1)\n                )\n            ),\n            length\n        );\n    \n    private int ToInt(byte[] bytes) => bytes.Aggregate(0, (n, b) => (n << 8) | b);\n    \n    private byte[] ToBytes(int n)\n    {\n        byte[] bytes = new byte[4];\n        for (int i = 3; i >= 0; i--) {\n            bytes[i] = (byte)(n & 0xFF);\n            n >>= 8;\n        }\n        return bytes;\n    }\n    \n    public override string ToString() => $\"{ip}/{length}\";\n}\n"}
{"id": 410222, "name": "Canonicalize CIDR", "source": "Translate Haskell to C#: import Control.Monad (guard)\nimport Data.Bits ((.|.), (.&.), complement, shiftL, shiftR, zeroBits)\nimport Data.Maybe (listToMaybe)\nimport Data.Word (Word32, Word8)\nimport Text.ParserCombinators.ReadP (ReadP, char, readP_to_S)\nimport Text.Printf (printf)\nimport Text.Read.Lex (readDecP)\n\n\n\ndata CIDR = CIDR Word32 Word8\n\n\ncidrRead :: String -> Maybe CIDR\ncidrRead = listToMaybe . map fst . readP_to_S cidrP\n\n\ncidrShow :: CIDR -> String\ncidrShow (CIDR addr n) = let (a, b, c, d) = octetsFrom addr\n                         in printf \"%u.%u.%u.%u/%u\" a b c d n\n\n\n\n\ncidrP :: ReadP CIDR\ncidrP = do a <- octetP <* char '.'\n           b <- octetP <* char '.'\n           c <- octetP <* char '.'\n           d <- octetP <* char '/'\n           n <- netBitsP\n           return $ CIDR (addrFrom a b c d .&. netmask n) n\n  where octetP   = wordP 255\n        netBitsP = wordP  32\n\n\n\n\n\nwordP :: Integral a => Integer -> ReadP a\nwordP lim = do n <- readDecP\n               guard $ n <= lim\n               return $ fi n\n\n\noctetsFrom :: Word32 -> (Word8, Word8, Word8, Word8)\noctetsFrom addr = (oct addr 3, oct addr 2, oct addr 1, oct addr 0)\n  where oct w n = fi $ w `shiftR` (8*n) .&. 0xff\n\n\naddrFrom :: Word8 -> Word8 -> Word8 -> Word8 -> Word32\naddrFrom a b c d = 0 <<+ a <<+ b <<+ c <<+ d\n  where w <<+ o = w `shiftL` 8 .|. fi o\n\n\n\nnetmask :: Word8 -> Word32\nnetmask n = complement $ complement zeroBits `shiftR` fi n\n\nfi :: (Integral a, Num b) => a -> b\nfi = fromIntegral\n\ntest :: String -> IO ()\ntest str = do\n  let cidrStr = maybe \"invalid CIDR string\" cidrShow (cidrRead str)\n  printf \"%-18s -> %s\\n\" str cidrStr\n\nmain :: IO ()\nmain = do\n  test \"87.70.141.1/22\"\n  test \"36.18.154.103/12\"\n  test \"62.62.197.11/29\"\n  test \"67.137.119.181/4\"\n  test \"161.214.74.21/24\"\n  test \"184.232.176.184/18\"\n  \n  test \"184.256.176.184/12\" \n  test \"184.232.176.184/33\" \n  test \"184.232.184/18\"     \n", "target": "using System;\nusing System.Net;\nusing System.Linq;\n                    \npublic class Program\n{\n    public static void Main()\n    {\n        string[] tests = {\n            \"87.70.141.1/22\",\n            \"36.18.154.103/12\",\n            \"62.62.197.11/29\",\n            \"67.137.119.181/4\",\n            \"161.214.74.21/24\",\n            \"184.232.176.184/18\"\n        };\n        \n        foreach (string t in tests) Console.WriteLine($\"{t}   =>   {Canonicalize(t)}\");\n    }\n    \n    static string Canonicalize(string cidr) => CIDR.Parse(cidr).Canonicalize().ToString();\n}\n\nreadonly struct CIDR\n{\n    public readonly IPAddress ip;\n    public readonly int length;\n    \n    public static CIDR Parse(string cidr)\n    {\n        string[] parts = cidr.Split('/');\n        return new CIDR(IPAddress.Parse(parts[0]), int.Parse(parts[1]));\n    }\n    \n    public CIDR(IPAddress ip, int length) => (this.ip, this.length) = (ip, length);\n    \n    public CIDR Canonicalize() =>\n        new CIDR(\n            new IPAddress(\n                ToBytes(\n                    ToInt(\n                        ip.GetAddressBytes()\n                    )\n                    & ~((1 << (32 - length)) - 1)\n                )\n            ),\n            length\n        );\n    \n    private int ToInt(byte[] bytes) => bytes.Aggregate(0, (n, b) => (n << 8) | b);\n    \n    private byte[] ToBytes(int n)\n    {\n        byte[] bytes = new byte[4];\n        for (int i = 3; i >= 0; i--) {\n            bytes[i] = (byte)(n & 0xFF);\n            n >>= 8;\n        }\n        return bytes;\n    }\n    \n    public override string ToString() => $\"{ip}/{length}\";\n}\n"}
{"id": 410223, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Haskell to C#: import Prelude hiding (pi)\nimport Data.Number.MPFR hiding (sqrt, pi, div)\nimport Data.Number.MPFR.Instances.Near ()\n\n\n\ndigitBits :: (Integral a, Num a) => a -> a\ndigitBits n = (n + 1) `div` 2 * 8\n\n\npi :: Integer -> MPFR\npi digits =\n  let eps = fromString (\"1e-\" ++ show digits)\n            (fromInteger $ digitBits digits) 0\n      two = fromInt Near (getPrec eps) 2\n      twoi = 2 :: Int\n      twoI = 2 :: Integer\n      pis a g s n =\n        let aB = (a + g) / two\n            gB = sqrt (a * g)\n            aB2 = aB ^^ twoi\n            sB = s + (two ^^ n) * (aB2 - gB ^^ twoi)\n            num = 4 * aB2\n            den = 1 - sB\n        in (num / den) : pis aB gB sB (n + 1)\n      puntil f (a:b:xs) = if f a b then b else puntil f (b:xs)\n  in puntil (\\a b -> abs (a - b) < eps)\n     $ pis one (one / sqrt two) zero twoI\n\nmain :: IO ()\nmain = do\n  \n  putStrLn $ toString 1000 $ pi 1000\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 410224, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Haskell to C#: import Prelude hiding (pi)\nimport Data.Number.MPFR hiding (sqrt, pi, div)\nimport Data.Number.MPFR.Instances.Near ()\n\n\n\ndigitBits :: (Integral a, Num a) => a -> a\ndigitBits n = (n + 1) `div` 2 * 8\n\n\npi :: Integer -> MPFR\npi digits =\n  let eps = fromString (\"1e-\" ++ show digits)\n            (fromInteger $ digitBits digits) 0\n      two = fromInt Near (getPrec eps) 2\n      twoi = 2 :: Int\n      twoI = 2 :: Integer\n      pis a g s n =\n        let aB = (a + g) / two\n            gB = sqrt (a * g)\n            aB2 = aB ^^ twoi\n            sB = s + (two ^^ n) * (aB2 - gB ^^ twoi)\n            num = 4 * aB2\n            den = 1 - sB\n        in (num / den) : pis aB gB sB (n + 1)\n      puntil f (a:b:xs) = if f a b then b else puntil f (b:xs)\n  in puntil (\\a b -> abs (a - b) < eps)\n     $ pis one (one / sqrt two) zero twoI\n\nmain :: IO ()\nmain = do\n  \n  putStrLn $ toString 1000 $ pi 1000\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 410225, "name": "Long primes", "source": "Translate Haskell to C#: import Data.List (elemIndex)\n\nlongPrimesUpTo :: Int -> [Int]\nlongPrimesUpTo n =\n  filter isLongPrime $\n    takeWhile (< n) primes\n  where\n    sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p /= 0]\n    primes = sieve [2 ..]\n    isLongPrime n = found\n      where\n        cycles = take n (iterate ((`mod` n) . (10 *)) 1)\n        index = elemIndex (head cycles) $ tail cycles\n        found = case index of\n          (Just i) -> n - i == 2\n          _ -> False\n\ndisplay :: Int -> IO ()\ndisplay n =\n  if n <= 64000\n    then do\n      putStrLn\n        ( show n <> \" is \"\n            <> show (length $ longPrimesUpTo n)\n        )\n      display (n * 2)\n    else pure ()\n\nmain :: IO ()\nmain = do\n  let fiveHundred = longPrimesUpTo 500\n  putStrLn\n    ( \"The long primes up to 35 are:\\n\"\n        <> show fiveHundred\n        <> \"\\n\"\n    )\n  putStrLn (\"500 is \" <> show (length fiveHundred))\n  display 1000\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class LongPrimes\n{\n    public static void Main() {\n        var primes = SomePrimeGenerator.Primes(64000).Skip(1).Where(p => Period(p) == p - 1).Append(99999);\n        Console.WriteLine(string.Join(\" \", primes.TakeWhile(p => p <= 500)));\n        int count = 0, limit = 500;\n        foreach (int prime in primes) {\n            if (prime > limit) {\n                Console.WriteLine($\"There are {count} long primes below {limit}\");\n                limit *= 2;\n            }\n            count++;\n        }\n\n        int Period(int n) {\n            int r = 1, rr;\n            for (int i = 0; i <= n; i++) r = 10 * r % n;\n            rr = r;\n            for (int period = 1;; period++) {\n                r = (10 * r) % n;\n                if (r == rr) return period;\n            }\n        }\n    }\n\n}\n\nstatic class SomePrimeGenerator {\n\n    public static IEnumerable<int> Primes(int lim) {\n        bool [] flags = new bool[lim + 1]; int j = 2;\n        for (int d = 3, sq = 4; sq <= lim; j++, sq += d += 2)\n            if (!flags[j]) {\n                yield return j; for (int k = sq; k <= lim; k += j)\n                    flags[k] = true;\n            }\n        for (; j<= lim; j++) if (!flags[j]) yield return j;\n    }\n}\n"}
{"id": 410226, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Haskell to C#: import Data.Ratio (Ratio, (%), denominator, numerator)\n\negyptianFraction :: Integral a => Ratio a -> [Ratio a]\negyptianFraction n\n  | n < 0 = map negate (egyptianFraction (-n))\n  | n == 0 = []\n  | x == 1 = [n]\n  | x > y = (x `div` y % 1) : egyptianFraction (x `mod` y % y)\n  | otherwise = (1 % r) : egyptianFraction ((-y) `mod` x % (y * r))\n  where\n    x = numerator n\n    y = denominator n\n    r = y `div` x + 1\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EgyptianFractions {\n    class Program {\n        class Rational : IComparable<Rational>, IComparable<int> {\n            public BigInteger Num { get; }\n            public BigInteger Den { get; }\n\n            public Rational(BigInteger n, BigInteger d) {\n                var c = Gcd(n, d);\n                Num = n / c;\n                Den = d / c;\n                if (Den < 0) {\n                    Num = -Num;\n                    Den = -Den;\n                }\n            }\n\n            public Rational(BigInteger n) {\n                Num = n;\n                Den = 1;\n            }\n\n            public override string ToString() {\n                if (Den == 1) {\n                    return Num.ToString();\n                } else {\n                    return string.Format(\"{0}/{1}\", Num, Den);\n                }\n            }\n\n            public Rational Add(Rational rhs) {\n                return new Rational(Num * rhs.Den + rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public Rational Sub(Rational rhs) {\n                return new Rational(Num * rhs.Den - rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public int CompareTo(Rational rhs) {\n                var ad = Num * rhs.Den;\n                var bc = Den * rhs.Num;\n                return ad.CompareTo(bc);\n            }\n\n            public int CompareTo(int rhs) {\n                var ad = Num * rhs;\n                var bc = Den * rhs;\n                return ad.CompareTo(bc);\n            }\n        }\n\n        static BigInteger Gcd(BigInteger a, BigInteger b) {\n            if (b == 0) {\n                if (a < 0) {\n                    return -a;\n                } else {\n                    return a;\n                }\n            } else {\n                return Gcd(b, a % b);\n            }\n        }\n\n        static List<Rational> Egyptian(Rational r) {\n            List<Rational> result = new List<Rational>();\n\n            if (r.CompareTo(1) >= 0) {\n                if (r.Den == 1) {\n                    result.Add(r);\n                    result.Add(new Rational(0));\n                    return result;\n                }\n                result.Add(new Rational(r.Num / r.Den));\n                r = r.Sub(result[0]);\n            }\n\n            BigInteger modFunc(BigInteger m, BigInteger n) {\n                return ((m % n) + n) % n;\n            }\n\n            while (r.Num != 1) {\n                var q = (r.Den + r.Num - 1) / r.Num;\n                result.Add(new Rational(1, q));\n                r = new Rational(modFunc(-r.Den, r.Num), r.Den * q);\n            }\n\n            result.Add(r);\n            return result;\n        }\n\n        static string FormatList<T>(IEnumerable<T> col) {\n            StringBuilder sb = new StringBuilder();\n            var iter = col.GetEnumerator();\n\n            sb.Append('[');\n            if (iter.MoveNext()) {\n                sb.Append(iter.Current);\n            }\n            while (iter.MoveNext()) {\n                sb.AppendFormat(\", {0}\", iter.Current);\n            }\n            sb.Append(']');\n\n            return sb.ToString();\n        }\n\n        static void Main() {\n            List<Rational> rs = new List<Rational> {\n                new Rational(43, 48),\n                new Rational(5, 121),\n                new Rational(2014, 59)\n            };\n            foreach (var r in rs) {\n                Console.WriteLine(\"{0} => {1}\", r, FormatList(Egyptian(r)));\n            }\n\n            var lenMax = Tuple.Create(0UL, new Rational(0));\n            var denomMax = Tuple.Create(BigInteger.Zero, new Rational(0));\n\n            var query = (from i in Enumerable.Range(1, 100)\n                         from j in Enumerable.Range(1, 100)\n                         select new Rational(i, j))\n                         .Distinct()\n                         .ToList();\n            foreach (var r in query) {\n                var e = Egyptian(r);\n                ulong eLen = (ulong) e.Count;\n                var eDenom = e.Last().Den;\n                if (eLen > lenMax.Item1) {\n                    lenMax = Tuple.Create(eLen, r);\n                }\n                if (eDenom > denomMax.Item1) {\n                    denomMax = Tuple.Create(eDenom, r);\n                }\n            }\n\n            Console.WriteLine(\"Term max is {0} with {1} terms\", lenMax.Item2, lenMax.Item1);\n            var dStr = denomMax.Item1.ToString();\n            Console.WriteLine(\"Denominator max is {0} with {1} digits {2}...{3}\", denomMax.Item2, dStr.Length, dStr.Substring(0, 5), dStr.Substring(dStr.Length - 5, 5));\n        }\n    }\n}\n"}
{"id": 410227, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Haskell to C#: import Data.Ratio (Ratio, (%), denominator, numerator)\n\negyptianFraction :: Integral a => Ratio a -> [Ratio a]\negyptianFraction n\n  | n < 0 = map negate (egyptianFraction (-n))\n  | n == 0 = []\n  | x == 1 = [n]\n  | x > y = (x `div` y % 1) : egyptianFraction (x `mod` y % y)\n  | otherwise = (1 % r) : egyptianFraction ((-y) `mod` x % (y * r))\n  where\n    x = numerator n\n    y = denominator n\n    r = y `div` x + 1\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace EgyptianFractions {\n    class Program {\n        class Rational : IComparable<Rational>, IComparable<int> {\n            public BigInteger Num { get; }\n            public BigInteger Den { get; }\n\n            public Rational(BigInteger n, BigInteger d) {\n                var c = Gcd(n, d);\n                Num = n / c;\n                Den = d / c;\n                if (Den < 0) {\n                    Num = -Num;\n                    Den = -Den;\n                }\n            }\n\n            public Rational(BigInteger n) {\n                Num = n;\n                Den = 1;\n            }\n\n            public override string ToString() {\n                if (Den == 1) {\n                    return Num.ToString();\n                } else {\n                    return string.Format(\"{0}/{1}\", Num, Den);\n                }\n            }\n\n            public Rational Add(Rational rhs) {\n                return new Rational(Num * rhs.Den + rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public Rational Sub(Rational rhs) {\n                return new Rational(Num * rhs.Den - rhs.Num * Den, Den * rhs.Den);\n            }\n\n            public int CompareTo(Rational rhs) {\n                var ad = Num * rhs.Den;\n                var bc = Den * rhs.Num;\n                return ad.CompareTo(bc);\n            }\n\n            public int CompareTo(int rhs) {\n                var ad = Num * rhs;\n                var bc = Den * rhs;\n                return ad.CompareTo(bc);\n            }\n        }\n\n        static BigInteger Gcd(BigInteger a, BigInteger b) {\n            if (b == 0) {\n                if (a < 0) {\n                    return -a;\n                } else {\n                    return a;\n                }\n            } else {\n                return Gcd(b, a % b);\n            }\n        }\n\n        static List<Rational> Egyptian(Rational r) {\n            List<Rational> result = new List<Rational>();\n\n            if (r.CompareTo(1) >= 0) {\n                if (r.Den == 1) {\n                    result.Add(r);\n                    result.Add(new Rational(0));\n                    return result;\n                }\n                result.Add(new Rational(r.Num / r.Den));\n                r = r.Sub(result[0]);\n            }\n\n            BigInteger modFunc(BigInteger m, BigInteger n) {\n                return ((m % n) + n) % n;\n            }\n\n            while (r.Num != 1) {\n                var q = (r.Den + r.Num - 1) / r.Num;\n                result.Add(new Rational(1, q));\n                r = new Rational(modFunc(-r.Den, r.Num), r.Den * q);\n            }\n\n            result.Add(r);\n            return result;\n        }\n\n        static string FormatList<T>(IEnumerable<T> col) {\n            StringBuilder sb = new StringBuilder();\n            var iter = col.GetEnumerator();\n\n            sb.Append('[');\n            if (iter.MoveNext()) {\n                sb.Append(iter.Current);\n            }\n            while (iter.MoveNext()) {\n                sb.AppendFormat(\", {0}\", iter.Current);\n            }\n            sb.Append(']');\n\n            return sb.ToString();\n        }\n\n        static void Main() {\n            List<Rational> rs = new List<Rational> {\n                new Rational(43, 48),\n                new Rational(5, 121),\n                new Rational(2014, 59)\n            };\n            foreach (var r in rs) {\n                Console.WriteLine(\"{0} => {1}\", r, FormatList(Egyptian(r)));\n            }\n\n            var lenMax = Tuple.Create(0UL, new Rational(0));\n            var denomMax = Tuple.Create(BigInteger.Zero, new Rational(0));\n\n            var query = (from i in Enumerable.Range(1, 100)\n                         from j in Enumerable.Range(1, 100)\n                         select new Rational(i, j))\n                         .Distinct()\n                         .ToList();\n            foreach (var r in query) {\n                var e = Egyptian(r);\n                ulong eLen = (ulong) e.Count;\n                var eDenom = e.Last().Den;\n                if (eLen > lenMax.Item1) {\n                    lenMax = Tuple.Create(eLen, r);\n                }\n                if (eDenom > denomMax.Item1) {\n                    denomMax = Tuple.Create(eDenom, r);\n                }\n            }\n\n            Console.WriteLine(\"Term max is {0} with {1} terms\", lenMax.Item2, lenMax.Item1);\n            var dStr = denomMax.Item1.ToString();\n            Console.WriteLine(\"Denominator max is {0} with {1} digits {2}...{3}\", denomMax.Item2, dStr.Length, dStr.Substring(0, 5), dStr.Substring(dStr.Length - 5, 5));\n        }\n    }\n}\n"}
{"id": 410228, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Haskell to C#: gaussLegendre n f a b = d*sum [ w x*f(m + d*x) | x <- roots ]\n  where d = (b - a)/2\n        m = (b + a)/2\n        w x = 2/(1-x^2)/(legendreP' n x)^2\n        roots = map (findRoot (legendreP n) (legendreP' n) . x0) [1..n]\n        x0 i = cos (pi*(i-1/4)/(n+1/2))\n", "target": "using System;\n\n\n                    \npublic class Program {\n\n    public static double[][] legeCoef(int N) {\n        \n        double[][] lcoef = new double[N+1][];\n        for (int i=0; i < lcoef.Length; ++i) \n            lcoef[i] = new double[N+1];\n\n\n        lcoef[0][0] = lcoef[1][1] = 1;\n        for (int n = 2; n <= N; n++) {\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n            for (int i = 1; i <= n; i++) \n                lcoef[n][i] = ((2*n - 1) * lcoef[n-1][i-1] \n                               - (n-1) * lcoef[n-2][i] ) / n;\n        }\n        return lcoef;\n    }\n\n\n    static double legeEval(double[][] lcoef, int N, double x) {\n        double s = lcoef[N][N];\n        for (int i = N; i > 0; --i)\n            s = s * x + lcoef[N][i-1];\n        return s;\n    }\n\n    static double legeDiff(double[][] lcoef, int N, double x) {\n        return N * (x * legeEval(lcoef, N, x) - legeEval(lcoef, N-1, x)) / (x*x - 1);\n    }\n\n    static void legeRoots(double[][] lcoef, int N, out double[] lroots,  out double[] weight) {\n        lroots = new double[N];\n        weight = new double[N];\n\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = Math.Cos(Math.PI * (i - 0.25) / (N + 0.5));\n            do { \n                x1 = x;\n                x -= legeEval(lcoef, N, x) / legeDiff(lcoef, N, x);\n            } \n            while (x != x1);\n            lroots[i-1] = x;\n\n            x1 = legeDiff(lcoef, N, x);\n            weight[i-1] = 2 / ((1 - x*x) * x1*x1);\n        }\n    }\n    \n    \n\n    static double legeInte(Func<Double, Double> f, int N, double[] weights, double[] lroots, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weights[i] * f.Invoke(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n    \n    \n    public static string Combine(double[] arrayD) {\n        return string.Join(\", \", arrayD);\t\n    }\n\n    public static void Main() {\n        int N = 5;\n        \n        var lcoeff = legeCoef(N);\n        \n        double[] roots;\n        double[] weights;\n        legeRoots(lcoeff, N, out roots, out weights);\n        \n        var integrateResult = legeInte(x=>Math.Exp(x), N, weights, roots, -3, 3);\n        \n        Console.WriteLine(\"Roots:   \" + Combine(roots));\n        Console.WriteLine(\"Weights: \" + Combine(weights)+ \"\\n\" );\n        Console.WriteLine(\"integral: \" + integrateResult );\n        Console.WriteLine(\"actual:   \" + (Math.Exp(3)-Math.Exp(-3)) );\n    }\n\n\n}\n"}
{"id": 410229, "name": "Cuban primes", "source": "Translate Haskell to C#: import Data.Numbers.Primes (isPrime)\nimport Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\ncubans :: [Int]\ncubans = filter isPrime . map (\\x -> (succ x ^ 3) - (x ^ 3)) $ [1 ..]\n\nmain :: IO ()\nmain = do\n  mapM_ (\\row -> mapM_ (printf \"%10s\" . thousands) row >> printf \"\\n\") $ rows cubans\n  printf \"\\nThe 100,000th cuban prime is: %10s\\n\" $ thousands $ cubans !! 99999\n  where\n    rows = chunksOf 10 . take 200\n    thousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nstatic class Program\n{\n    static List<long> primes = new List<long>() { 3, 5 };\n\n     static void Main(string[] args)\n    {\n        const int cutOff = 200;\n        const int bigUn = 100000;\n        const int chunks = 50;\n        const int little = bigUn / chunks;\n        const string tn = \" cuban prime\";\n        Console.WriteLine(\"The first {0:n0}{1}s:\", cutOff, tn);\n        int c = 0;\n        bool showEach = true;\n        long u = 0, v = 1;\n        DateTime st = DateTime.Now;\n        for (long i = 1; i <= long.MaxValue; i++)\n        {\n            bool found = false;\n            int mx = System.Convert.ToInt32(Math.Ceiling(Math.Sqrt(v += (u += 6))));\n            foreach (long item in primes)\n            {\n                if (item > mx) break;\n                if (v % item == 0) { found = true; break; }\n            }\n            if (!found)\n            {\n                c += 1; if (showEach)\n                {\n                    for (var z = primes.Last() + 2; z <= v - 2; z += 2)\n                    {\n                        bool fnd = false;\n                        foreach (long item in primes)\n                        {\n                            if (item > mx) break;\n                            if (z % item == 0) { fnd = true; break; }\n                        }\n                        if (!fnd) primes.Add(z);\n                    }\n                    primes.Add(v); Console.Write(\"{0,11:n0}\", v);\n                    if (c % 10 == 0) Console.WriteLine();\n                    if (c == cutOff)\n                    {\n                        showEach = false;\n                        Console.Write(\"\\nProgress to the {0:n0}th{1}: \", bigUn, tn);\n                    }\n                }\n                if (c % little == 0) { Console.Write(\".\"); if (c == bigUn) break; }\n            }\n        }\n        Console.WriteLine(\"\\nThe {1:n0}th{2} is {0,17:n0}\", v, c, tn);\n        Console.WriteLine(\"Computation time was {0} seconds\", (DateTime.Now - st).TotalSeconds);\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 410230, "name": "Chaos game", "source": "Translate Haskell to C#: import Control.Monad (replicateM)\nimport Control.Monad.Random (fromList)\n\ntype Point = (Float,Float)\ntype Transformations = [(Point -> Point, Float)] \n\n\ngameOfChaos :: MonadRandom m => Int -> Transformations -> Point -> m [Point]\ngameOfChaos n transformations x = iterateA (fromList transformations) x\n  where iterateA f x = scanr ($) x <$> replicateM n f\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 410231, "name": "Chaos game", "source": "Translate Haskell to C#: import Control.Monad (replicateM)\nimport Control.Monad.Random (fromList)\n\ntype Point = (Float,Float)\ntype Transformations = [(Point -> Point, Float)] \n\n\ngameOfChaos :: MonadRandom m => Int -> Transformations -> Point -> m [Point]\ngameOfChaos n transformations x = iterateA (fromList transformations) x\n  where iterateA f x = scanr ($) x <$> replicateM n f\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 410232, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Haskell to C#: import Text.Printf\n\nprec :: String -> Int\nprec \"^\" = 4\nprec \"*\" = 3\nprec \"/\" = 3\nprec \"+\" = 2\nprec \"-\" = 2\n\nleftAssoc :: String -> Bool\nleftAssoc \"^\" = False\nleftAssoc _ = True\n\nisOp :: String -> Bool\nisOp [t] = t `elem` \"-+/*^\"\nisOp _ = False\n\nsimSYA :: [String] -> [([String], [String], String)]\nsimSYA xs = final <> [lastStep]\n  where\n    final = scanl f ([], [], \"\") xs\n    lastStep =\n      ( \\(x, y, _) ->\n          (reverse y <> x, [], \"\")\n      )\n        $ last final\n    f (out, st, _) t\n      | isOp t =\n        ( reverse (takeWhile testOp st) <> out,\n          (t :) (dropWhile testOp st),\n          t\n        )\n      | t == \"(\" = (out, \"(\" : st, t)\n      | t == \")\" =\n        ( reverse (takeWhile (/= \"(\") st) <> out,\n          tail $ dropWhile (/= \"(\") st,\n          t\n        )\n      | otherwise = (t : out, st, t)\n      where\n        testOp x =\n          isOp x\n            && ( leftAssoc t && prec t == prec x\n                   || prec t < prec x\n               )\n\nmain :: IO ()\nmain = do\n  a <- getLine\n  printf \"%30s%20s%7s\" \"Output\" \"Stack\" \"Token\"\n  mapM_\n    ( \\(x, y, z) ->\n        printf\n          \"%30s%20s%7s\\n\"\n          (unwords $ reverse x)\n          (unwords y)\n          z\n    )\n    $ simSYA $ words a\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        string infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        Console.WriteLine(infix.ToPostfix());\n    }\n}\n\npublic static class ShuntingYard\n{\n    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators\n        = new (string symbol, int precedence, bool rightAssociative) [] {\n            (\"^\", 4, true),\n            (\"*\", 3, false),\n            (\"/\", 3, false),\n            (\"+\", 2, false),\n            (\"-\", 2, false)\n    }.ToDictionary(op => op.symbol);\n\n    public static string ToPostfix(this string infix) {\n        string[] tokens = infix.Split(' ');\n        var stack = new Stack<string>();\n        var output = new List<string>();\n        foreach (string token in tokens) {\n            if (int.TryParse(token, out _)) {\n                output.Add(token);\n                Print(token);\n            } else if (operators.TryGetValue(token, out var op1)) {\n                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {\n                    int c = op1.precedence.CompareTo(op2.precedence);\n                    if (c < 0 || !op1.rightAssociative && c <= 0) {\n                        output.Add(stack.Pop());\n                    } else {\n                        break;\n                    }\n                }\n                stack.Push(token);\n                Print(token);\n            } else if (token == \"(\") {\n                stack.Push(token);\n                Print(token);\n            } else if (token == \")\") {\n                string top = \"\";\n                while (stack.Count > 0 && (top = stack.Pop()) != \"(\") {\n                    output.Add(top);\n                }\n                if (top != \"(\") throw new ArgumentException(\"No matching left parenthesis.\");\n                Print(token);\n            }\n        }\n        while (stack.Count > 0) {\n            var top = stack.Pop();\n            if (!operators.ContainsKey(top)) throw new ArgumentException(\"No matching right parenthesis.\");\n            output.Add(top);\n        }\n        Print(\"pop\");\n        return string.Join(\" \", output);\n        \n        \n        void Print(string action) => Console.WriteLine($\"{action + \":\",-4} {$\"stack[ {string.Join(\" \", stack.Reverse())} ]\",-18} {$\"out[ {string.Join(\" \", output)} ]\"}\");\n        \n        void Print(string action) => Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {string.Join(\" \", stack.Reverse())} ]\", $\"out[ {string.Join(\" \", output)} ]\");\n    }\n}\n"}
{"id": 410233, "name": "A_ search algorithm", "source": "Translate Haskell to C#: \n\nmodule PQueue where\n\ndata PQueue a = EmptyQueue\n              | Node (Int, a) (PQueue a) (PQueue a)\n  deriving (Show, Foldable)\n\ninstance Ord a => Semigroup (PQueue a) where\n  h1@(Node (w1, x1) l1 r1) <> h2@(Node (w2, x2) l2 r2)\n    | w1 < w2   = Node (w1, x1) (h2 <> r1) l1\n    | otherwise = Node (w2, x2) (h1 <> r2) l2\n  EmptyQueue <> h = h\n  h <> EmptyQueue = h\n\nentry :: Ord a => a -> Int -> PQueue a\nentry x w = Node (w, x) EmptyQueue EmptyQueue\n\nenque :: Ord a => PQueue a -> a -> Int -> PQueue a\nenque q x w = if x `notElem` q\n              then entry x w <> q\n              else q\n\ndeque :: Ord a => PQueue a -> Maybe (a, PQueue a)\ndeque q = case q of\n            EmptyQueue -> Nothing\n            Node (_, x) l r -> Just (x, l <> r)\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace A_star\n{\n    class A_star\n    {\n        \n        public class Coordinates : IEquatable<Coordinates>\n        {\n            public int row;\n            public int col;\n\n            public Coordinates() { this.row = -1; this.col = -1; }\n            public Coordinates(int row, int col) { this.row = row; this.col = col; }\n\n            public Boolean Equals(Coordinates c)\n            {\n                if (this.row == c.row && this.col == c.col)\n                    return true;\n                else\n                    return false;\n            }\n        }\n\n        \n        \n        public class Cell\n        {\n            public int cost;\n            public int g;\n            public int f;\n            public Coordinates parent;\n        }\n\n        \n        public class Astar\n        {\n            \n            public Cell[,] cells = new Cell[8, 8];\n            \n            public List<Coordinates> path = new List<Coordinates>();\n            \n            public List<Coordinates> opened = new List<Coordinates>();\n            \n            public List<Coordinates> closed = new List<Coordinates>();\n            \n            public Coordinates startCell = new Coordinates(0, 0);\n            \n            public Coordinates finishCell = new Coordinates(7, 7);\n\n            \n            public Astar()\n            {\n                \n                for (int i = 0; i < 8; i++)\n                    for (int j = 0; j < 8; j++)\n                    {\n                        cells[i, j] = new Cell();\n                        cells[i, j].parent = new Coordinates();\n                        if (IsAWall(i, j))\n                            cells[i, j].cost = 100;\n                        else\n                            cells[i, j].cost = 1;\n                    }\n\n                \n                opened.Add(startCell);\n\n                \n                Boolean pathFound = false;\n\n                \n                do\n                {\n                    List<Coordinates> neighbors = new List<Coordinates>();\n                    \n                    Coordinates currentCell = ShorterExpectedPath();\n                    \n                    neighbors = neighborsCells(currentCell);\n                    foreach (Coordinates newCell in neighbors)\n                    {\n                        \n                        if (newCell.row == finishCell.row && newCell.col == finishCell.col)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            pathFound = true;\n                            break;\n                        }\n\n                        \n                        else if (!opened.Contains(newCell) && !closed.Contains(newCell))\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                        }\n\n                        \n                        \n                        else if (cells[newCell.row, newCell.col].g > cells[currentCell.row,\n                            currentCell.col].g + cells[newCell.row, newCell.col].cost)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                            ResetCell(newCell, closed);\n                        }\n                    }\n                    SetCell(currentCell, closed);\n                    ResetCell(currentCell, opened);\n                } while (opened.Count > 0 && pathFound == false);\n\n                if (pathFound)\n                {\n                    path.Add(finishCell);\n                    Coordinates currentCell = new Coordinates(finishCell.row, finishCell.col);\n                    \n                    while (cells[currentCell.row, currentCell.col].parent.row >= 0)\n                    {\n                        path.Add(cells[currentCell.row, currentCell.col].parent);\n                        int tmp_row = cells[currentCell.row, currentCell.col].parent.row;\n                        currentCell.col = cells[currentCell.row, currentCell.col].parent.col;\n                        currentCell.row = tmp_row;\n                    }\n\n                    \n                    for (int i = 0; i < 8; i++)\n                    {\n                        for (int j = 0; j < 8; j++)\n                        {\n                            \n                            \n                            char gr = '.';\n                            \n                            if (path.Contains(new Coordinates(i, j))) { gr = 'X'; }\n                            \n                            else if (cells[i, j].cost > 1) { gr = '\\u2588'; }\n                            System.Console.Write(gr);\n                        }\n                        System.Console.WriteLine();\n                    }\n\n                    \n                    System.Console.Write(\"\\nPath: \");\n                    for (int i = path.Count - 1; i >= 0; i--)\n                    {\n                        System.Console.Write(\"({0},{1})\", path[i].row, path[i].col);\n                    }\n\n                    \n                    System.Console.WriteLine(\"\\nPath cost: {0}\", path.Count - 1);\n\n                    \n                    String wt = System.Console.ReadLine();\n                }\n            }\n\n            \n            \n            public Coordinates ShorterExpectedPath()\n            {\n                int sep = 0;\n                if (opened.Count > 1)\n                {\n                    for (int i = 1; i < opened.Count; i++)\n                    {\n                        if (cells[opened[i].row, opened[i].col].f < cells[opened[sep].row,\n                            opened[sep].col].f)\n                        {\n                            sep = i;\n                        }\n                    }\n                }\n                return opened[sep];\n            }\n\n            \n            public List<Coordinates> neighborsCells(Coordinates c)\n            {\n                List<Coordinates> lc = new List<Coordinates>();\n                for (int i = -1; i <= 1; i++)\n                    for (int j = -1; j <= 1; j++)\n                        if (c.row+i >= 0 && c.row+i < 8 && c.col+j >= 0 && c.col+j < 8 &&\n                            (i != 0 || j != 0))\n                        {\n                            lc.Add(new Coordinates(c.row + i, c.col + j));\n                        }\n                return lc;\n            }\n\n            \n            public bool IsAWall(int row, int col)\n            {\n                int[,] walls = new int[,] { { 2, 4 }, { 2, 5 }, { 2, 6 }, { 3, 6 }, { 4, 6 },\n                    { 5, 6 }, { 5, 5 }, { 5, 4 }, { 5, 3 }, { 5, 2 }, { 4, 2 }, { 3, 2 } };\n                bool found = false;\n                for (int i = 0; i < walls.GetLength(0); i++)\n                    if (walls[i,0] == row && walls[i,1] == col)\n                        found = true;\n                return found;\n            }\n\n            \n            \n            public int Heuristic(Coordinates cell)\n            {\n                int dRow = Math.Abs(finishCell.row - cell.row);\n                int dCol = Math.Abs(finishCell.col - cell.col);\n                return Math.Max(dRow, dCol);\n            }\n\n            \n            public void SetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell) == false)\n                {\n                    coordinatesList.Add(cell);\n                }\n            }\n\n            \n            public void ResetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell))\n                {\n                    coordinatesList.Remove(cell);\n                }\n            }\n        }\n\n        \n        static void Main(string[] args)\n        {\n            Astar astar = new Astar();\n        }\n    }\n}\n"}
{"id": 410234, "name": "A_ search algorithm", "source": "Translate Haskell to C#: \n\nmodule PQueue where\n\ndata PQueue a = EmptyQueue\n              | Node (Int, a) (PQueue a) (PQueue a)\n  deriving (Show, Foldable)\n\ninstance Ord a => Semigroup (PQueue a) where\n  h1@(Node (w1, x1) l1 r1) <> h2@(Node (w2, x2) l2 r2)\n    | w1 < w2   = Node (w1, x1) (h2 <> r1) l1\n    | otherwise = Node (w2, x2) (h1 <> r2) l2\n  EmptyQueue <> h = h\n  h <> EmptyQueue = h\n\nentry :: Ord a => a -> Int -> PQueue a\nentry x w = Node (w, x) EmptyQueue EmptyQueue\n\nenque :: Ord a => PQueue a -> a -> Int -> PQueue a\nenque q x w = if x `notElem` q\n              then entry x w <> q\n              else q\n\ndeque :: Ord a => PQueue a -> Maybe (a, PQueue a)\ndeque q = case q of\n            EmptyQueue -> Nothing\n            Node (_, x) l r -> Just (x, l <> r)\n", "target": "using System;\nusing System.Collections.Generic;\n\nnamespace A_star\n{\n    class A_star\n    {\n        \n        public class Coordinates : IEquatable<Coordinates>\n        {\n            public int row;\n            public int col;\n\n            public Coordinates() { this.row = -1; this.col = -1; }\n            public Coordinates(int row, int col) { this.row = row; this.col = col; }\n\n            public Boolean Equals(Coordinates c)\n            {\n                if (this.row == c.row && this.col == c.col)\n                    return true;\n                else\n                    return false;\n            }\n        }\n\n        \n        \n        public class Cell\n        {\n            public int cost;\n            public int g;\n            public int f;\n            public Coordinates parent;\n        }\n\n        \n        public class Astar\n        {\n            \n            public Cell[,] cells = new Cell[8, 8];\n            \n            public List<Coordinates> path = new List<Coordinates>();\n            \n            public List<Coordinates> opened = new List<Coordinates>();\n            \n            public List<Coordinates> closed = new List<Coordinates>();\n            \n            public Coordinates startCell = new Coordinates(0, 0);\n            \n            public Coordinates finishCell = new Coordinates(7, 7);\n\n            \n            public Astar()\n            {\n                \n                for (int i = 0; i < 8; i++)\n                    for (int j = 0; j < 8; j++)\n                    {\n                        cells[i, j] = new Cell();\n                        cells[i, j].parent = new Coordinates();\n                        if (IsAWall(i, j))\n                            cells[i, j].cost = 100;\n                        else\n                            cells[i, j].cost = 1;\n                    }\n\n                \n                opened.Add(startCell);\n\n                \n                Boolean pathFound = false;\n\n                \n                do\n                {\n                    List<Coordinates> neighbors = new List<Coordinates>();\n                    \n                    Coordinates currentCell = ShorterExpectedPath();\n                    \n                    neighbors = neighborsCells(currentCell);\n                    foreach (Coordinates newCell in neighbors)\n                    {\n                        \n                        if (newCell.row == finishCell.row && newCell.col == finishCell.col)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            pathFound = true;\n                            break;\n                        }\n\n                        \n                        else if (!opened.Contains(newCell) && !closed.Contains(newCell))\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                        }\n\n                        \n                        \n                        else if (cells[newCell.row, newCell.col].g > cells[currentCell.row,\n                            currentCell.col].g + cells[newCell.row, newCell.col].cost)\n                        {\n                            cells[newCell.row, newCell.col].g = cells[currentCell.row,\n                                currentCell.col].g + cells[newCell.row, newCell.col].cost;\n                            cells[newCell.row, newCell.col].f =\n                                cells[newCell.row, newCell.col].g + Heuristic(newCell);\n                            cells[newCell.row, newCell.col].parent.row = currentCell.row;\n                            cells[newCell.row, newCell.col].parent.col = currentCell.col;\n                            SetCell(newCell, opened);\n                            ResetCell(newCell, closed);\n                        }\n                    }\n                    SetCell(currentCell, closed);\n                    ResetCell(currentCell, opened);\n                } while (opened.Count > 0 && pathFound == false);\n\n                if (pathFound)\n                {\n                    path.Add(finishCell);\n                    Coordinates currentCell = new Coordinates(finishCell.row, finishCell.col);\n                    \n                    while (cells[currentCell.row, currentCell.col].parent.row >= 0)\n                    {\n                        path.Add(cells[currentCell.row, currentCell.col].parent);\n                        int tmp_row = cells[currentCell.row, currentCell.col].parent.row;\n                        currentCell.col = cells[currentCell.row, currentCell.col].parent.col;\n                        currentCell.row = tmp_row;\n                    }\n\n                    \n                    for (int i = 0; i < 8; i++)\n                    {\n                        for (int j = 0; j < 8; j++)\n                        {\n                            \n                            \n                            char gr = '.';\n                            \n                            if (path.Contains(new Coordinates(i, j))) { gr = 'X'; }\n                            \n                            else if (cells[i, j].cost > 1) { gr = '\\u2588'; }\n                            System.Console.Write(gr);\n                        }\n                        System.Console.WriteLine();\n                    }\n\n                    \n                    System.Console.Write(\"\\nPath: \");\n                    for (int i = path.Count - 1; i >= 0; i--)\n                    {\n                        System.Console.Write(\"({0},{1})\", path[i].row, path[i].col);\n                    }\n\n                    \n                    System.Console.WriteLine(\"\\nPath cost: {0}\", path.Count - 1);\n\n                    \n                    String wt = System.Console.ReadLine();\n                }\n            }\n\n            \n            \n            public Coordinates ShorterExpectedPath()\n            {\n                int sep = 0;\n                if (opened.Count > 1)\n                {\n                    for (int i = 1; i < opened.Count; i++)\n                    {\n                        if (cells[opened[i].row, opened[i].col].f < cells[opened[sep].row,\n                            opened[sep].col].f)\n                        {\n                            sep = i;\n                        }\n                    }\n                }\n                return opened[sep];\n            }\n\n            \n            public List<Coordinates> neighborsCells(Coordinates c)\n            {\n                List<Coordinates> lc = new List<Coordinates>();\n                for (int i = -1; i <= 1; i++)\n                    for (int j = -1; j <= 1; j++)\n                        if (c.row+i >= 0 && c.row+i < 8 && c.col+j >= 0 && c.col+j < 8 &&\n                            (i != 0 || j != 0))\n                        {\n                            lc.Add(new Coordinates(c.row + i, c.col + j));\n                        }\n                return lc;\n            }\n\n            \n            public bool IsAWall(int row, int col)\n            {\n                int[,] walls = new int[,] { { 2, 4 }, { 2, 5 }, { 2, 6 }, { 3, 6 }, { 4, 6 },\n                    { 5, 6 }, { 5, 5 }, { 5, 4 }, { 5, 3 }, { 5, 2 }, { 4, 2 }, { 3, 2 } };\n                bool found = false;\n                for (int i = 0; i < walls.GetLength(0); i++)\n                    if (walls[i,0] == row && walls[i,1] == col)\n                        found = true;\n                return found;\n            }\n\n            \n            \n            public int Heuristic(Coordinates cell)\n            {\n                int dRow = Math.Abs(finishCell.row - cell.row);\n                int dCol = Math.Abs(finishCell.col - cell.col);\n                return Math.Max(dRow, dCol);\n            }\n\n            \n            public void SetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell) == false)\n                {\n                    coordinatesList.Add(cell);\n                }\n            }\n\n            \n            public void ResetCell(Coordinates cell, List<Coordinates> coordinatesList)\n            {\n                if (coordinatesList.Contains(cell))\n                {\n                    coordinatesList.Remove(cell);\n                }\n            }\n        }\n\n        \n        static void Main(string[] args)\n        {\n            Astar astar = new Astar();\n        }\n    }\n}\n"}
{"id": 410235, "name": "Nonogram solver", "source": "Translate Haskell to C#: import           Control.Applicative          ((<|>))\nimport           Control.Monad\nimport           Control.Monad.CSP\nimport           Data.List                    (transpose)\nimport           System.Environment           (getArgs)\nimport           Text.ParserCombinators.ReadP (ReadP)\nimport qualified Text.ParserCombinators.ReadP as P\nimport           Text.Printf                  (printf)\n\nmain :: IO ()\nmain = do\n    file <- parseArgs\n    printf \"reading problem file from %s\\n\" file\n    ps <- parseProblems file\n    forM_ ps $ \\p -> do\n        print p\n        putStrLn \"\"\n        printSolution $ solve p\n        putStrLn \"\"\n\n\n\n\n\nparseArgs :: IO FilePath\nparseArgs = do\n    args <- getArgs\n    case args of\n        [file] -> return file\n        _      -> ioError $ userError \"expected exactly one command line argument, the name of the problem file\"\n\ndata Problem = Problem\n    { rows :: [[Int]]\n    , cols :: [[Int]]\n    } deriving (Show, Read, Eq, Ord)\n\nentryP :: ReadP Int\nentryP = do\n    n <- fromEnum <$> P.get\n    if n < 65 || n > 90\n        then P.pfail\n        else return $ n - 64\n\nblankP, eolP :: ReadP Char\nblankP = P.char ' '\neolP   = P.char '\\n'\n\nentriesP :: ReadP [Int]\nentriesP = ([] <$ blankP) <|> P.many1 entryP\n\nlineP :: ReadP [[Int]]\nlineP = P.sepBy1 entriesP blankP <* eolP\n\nproblemP :: ReadP Problem\nproblemP = Problem <$> lineP <*> lineP\n\nproblemsP :: ReadP [Problem]\nproblemsP = P.sepBy1 problemP (P.many blankP <* eolP) <* P.eof\n\nparseProblems :: FilePath -> IO [Problem]\nparseProblems file = do\n    s <- readFile file\n    case P.readP_to_S problemsP s of\n        [(ps, \"\")] -> return ps\n        _          -> ioError $ userError $ \"error parsing file \" <> file\n\n\n\n\n\nsolve :: Problem -> [[Bool]]\nsolve = oneCSPSolution . problemCSP\n\nproblemCSP :: Problem -> CSP r [[DV r Bool]]\nproblemCSP p = do\n    let rowCount = length $ rows p\n        colCount = length $ cols p\n    cells <- replicateM rowCount\n           $ replicateM colCount\n           $ mkDV [False, True]\n\n    forM_ (zip cells             $ rows p) $ uncurry rowOrColCSP\n    forM_ (zip (transpose cells) $ cols p) $ uncurry rowOrColCSP\n\n    return cells\n\nrowOrColCSP :: [DV r Bool] -> [Int] -> CSP r ()\nrowOrColCSP ws [] = forM_ ws $ constraint1 not\nrowOrColCSP ws xs = do\n    let vs = zip [0 ..] ws\n        n  = length ws\n\n    blocks <- forM xs $ \\x ->\n        mkDV [(i, i + x - 1) | i <- [0 .. n - x]] \n\n    \n    f blocks\n\n    \n    forM_ blocks $ \\x ->\n        forM_ vs $ \\(i, y) ->\n            constraint2 (\\(x1, x2) b -> i < x1 || i > x2 || b) x y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(y', _) b -> i >= y' || not b) (head blocks) y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(_, y') b -> i <= y' || not b) (last blocks) y\n\n    \n    forM_ (zip blocks $ tail blocks) $ \\(x, y) ->\n        forM_ vs $ \\(i, z) ->\n            constraint3 (\\(_, x') (y', _) b -> i <= x' || i >= y' || not b) x y z\n  where\n    f :: [DV r (Int, Int)] -> CSP r ()\n    f (u : v : bs) = do\n        constraint2 (\\(_, u') (v', _) -> v' >= u' + 2)  u v\n        f $ v : bs\n    f _            = return ()\n\n\n\n\n\nprintSolution :: [[Bool]] -> IO ()\nprintSolution bss =\n    forM_ bss $ \\bs -> do\n        forM_ bs $ \\b ->\n            putChar $ if b then '#' else '.'\n        putChar '\\n'\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class NonogramSolver\n{\n    public static void Main2() {\n        foreach (var (x, y) in new [] {\n            (\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"),\n            (\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\",\n                \"D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"),\n            (\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n                \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC\"),\n            (\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G\",\n                \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\")\n            })\n        {\n            Solve(x, y);\n            Console.WriteLine();\n        }\n    }\n\n    static void Solve(string rowLetters, string columnLetters) {\n        var r = rowLetters.Split(\" \").Select(row => row.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        var c = columnLetters.Split(\" \").Select(column => column.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        Solve(r, c);\n    }\n\n    static void Solve(int[][] rowRuns, int[][] columnRuns) {\n        int len = columnRuns.Length;\n        var rows = rowRuns.Select(row => Generate(len, row)).ToList();\n        var columns = columnRuns.Select(column => Generate(rowRuns.Length, column)).ToList();\n        Reduce(rows, columns);\n        foreach (var list in rows) {\n            if (list.Count != 1) Console.WriteLine(Repeat('?', len).Spaced());\n            else Console.WriteLine(list[0].ToString().PadLeft(len, '0').Replace('1', '#').Replace('0', '.').Reverse().Spaced());\n        }\n    }\n\n    static List<BitSet> Generate(int length, params int[] runs) {\n        var list = new List<BitSet>();\n        BitSet initial = BitSet.Empty;\n        int[] sums = new int[runs.Length];\n        sums[0] = 0;\n        for (int i = 1; i < runs.Length; i++) sums[i] = sums[i - 1] + runs[i - 1] + 1;\n        for (int r = 0; r < runs.Length; r++) initial = initial.AddRange(sums[r], runs[r]);\n        Generate(list, BitSet.Empty.Add(length), runs, sums, initial, 0, 0);\n        return list;\n    }\n\n    static void Generate(List<BitSet> result, BitSet max, int[] runs, int[] sums, BitSet current, int index, int shift) {\n        if (index == runs.Length) {\n            result.Add(current);\n            return;\n        }\n        while (current.Value < max.Value) {\n            Generate(result, max, runs, sums, current, index + 1, shift);\n            current = current.ShiftLeftAt(sums[index] + shift);\n            shift++;\n        }\n    }\n\n    static void Reduce(List<List<BitSet>> rows, List<List<BitSet>> columns) {\n        for (int count = 1; count > 0; ) {\n            foreach (var (rowIndex, row) in rows.WithIndex()) {\n                var allOn  = row.Aggregate((a, b) => a & b);\n                var allOff = row.Aggregate((a, b) => a | b);\n                foreach (var (columnIndex, column) in columns.WithIndex()) {\n                    count  = column.RemoveAll(c => allOn.Contains(columnIndex) && !c.Contains(rowIndex));\n                    count += column.RemoveAll(c => !allOff.Contains(columnIndex) && c.Contains(rowIndex));\n                }\n            }\n            foreach (var (columnIndex, column) in columns.WithIndex()) {\n                var allOn  = column.Aggregate((a, b) => a & b);\n                var allOff = column.Aggregate((a, b) => a | b);\n                foreach (var (rowIndex, row) in rows.WithIndex()) {\n                    count += row.RemoveAll(r => allOn.Contains(rowIndex) && !r.Contains(columnIndex));\n                    count += row.RemoveAll(r => !allOff.Contains(rowIndex) && r.Contains(columnIndex));\n                }\n            }\n        }\n    }\n\n    static IEnumerable<(int index, T element)> WithIndex<T>(this IEnumerable<T> source) {\n        int i = 0;\n        foreach (T element in source) {\n            yield return (i++, element);\n        }\n    }\n\n    static string Reverse(this string s) {\n        char[] array = s.ToCharArray();\n        Array.Reverse(array);\n        return new string(array);\n    }\n\n    static string Spaced(this IEnumerable<char> s) => string.Join(\" \", s);\n\n    struct BitSet \n    {\n        public static BitSet Empty => default;\n        private readonly int bits;\n        public int Value => bits;\n\n        private BitSet(int bits) => this.bits = bits;\n\n        public BitSet Add(int item) => new BitSet(bits | (1 << item));\n        public BitSet AddRange(int start, int count) => new BitSet(bits | (((1 << (start + count)) - 1) - ((1 << start) - 1)));\n        public bool Contains(int item) => (bits & (1 << item)) != 0;\n        public BitSet ShiftLeftAt(int index)  => new BitSet((bits >> index << (index + 1)) | (bits & ((1 << index) - 1)));\n        public override string ToString() => Convert.ToString(bits, 2);\n\n        public static BitSet operator &(BitSet a, BitSet b) => new BitSet(a.bits & b.bits);\n        public static BitSet operator |(BitSet a, BitSet b) => new BitSet(a.bits | b.bits);\n    }\n\n}\n"}
{"id": 410236, "name": "Nonogram solver", "source": "Translate Haskell to C#: import           Control.Applicative          ((<|>))\nimport           Control.Monad\nimport           Control.Monad.CSP\nimport           Data.List                    (transpose)\nimport           System.Environment           (getArgs)\nimport           Text.ParserCombinators.ReadP (ReadP)\nimport qualified Text.ParserCombinators.ReadP as P\nimport           Text.Printf                  (printf)\n\nmain :: IO ()\nmain = do\n    file <- parseArgs\n    printf \"reading problem file from %s\\n\" file\n    ps <- parseProblems file\n    forM_ ps $ \\p -> do\n        print p\n        putStrLn \"\"\n        printSolution $ solve p\n        putStrLn \"\"\n\n\n\n\n\nparseArgs :: IO FilePath\nparseArgs = do\n    args <- getArgs\n    case args of\n        [file] -> return file\n        _      -> ioError $ userError \"expected exactly one command line argument, the name of the problem file\"\n\ndata Problem = Problem\n    { rows :: [[Int]]\n    , cols :: [[Int]]\n    } deriving (Show, Read, Eq, Ord)\n\nentryP :: ReadP Int\nentryP = do\n    n <- fromEnum <$> P.get\n    if n < 65 || n > 90\n        then P.pfail\n        else return $ n - 64\n\nblankP, eolP :: ReadP Char\nblankP = P.char ' '\neolP   = P.char '\\n'\n\nentriesP :: ReadP [Int]\nentriesP = ([] <$ blankP) <|> P.many1 entryP\n\nlineP :: ReadP [[Int]]\nlineP = P.sepBy1 entriesP blankP <* eolP\n\nproblemP :: ReadP Problem\nproblemP = Problem <$> lineP <*> lineP\n\nproblemsP :: ReadP [Problem]\nproblemsP = P.sepBy1 problemP (P.many blankP <* eolP) <* P.eof\n\nparseProblems :: FilePath -> IO [Problem]\nparseProblems file = do\n    s <- readFile file\n    case P.readP_to_S problemsP s of\n        [(ps, \"\")] -> return ps\n        _          -> ioError $ userError $ \"error parsing file \" <> file\n\n\n\n\n\nsolve :: Problem -> [[Bool]]\nsolve = oneCSPSolution . problemCSP\n\nproblemCSP :: Problem -> CSP r [[DV r Bool]]\nproblemCSP p = do\n    let rowCount = length $ rows p\n        colCount = length $ cols p\n    cells <- replicateM rowCount\n           $ replicateM colCount\n           $ mkDV [False, True]\n\n    forM_ (zip cells             $ rows p) $ uncurry rowOrColCSP\n    forM_ (zip (transpose cells) $ cols p) $ uncurry rowOrColCSP\n\n    return cells\n\nrowOrColCSP :: [DV r Bool] -> [Int] -> CSP r ()\nrowOrColCSP ws [] = forM_ ws $ constraint1 not\nrowOrColCSP ws xs = do\n    let vs = zip [0 ..] ws\n        n  = length ws\n\n    blocks <- forM xs $ \\x ->\n        mkDV [(i, i + x - 1) | i <- [0 .. n - x]] \n\n    \n    f blocks\n\n    \n    forM_ blocks $ \\x ->\n        forM_ vs $ \\(i, y) ->\n            constraint2 (\\(x1, x2) b -> i < x1 || i > x2 || b) x y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(y', _) b -> i >= y' || not b) (head blocks) y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(_, y') b -> i <= y' || not b) (last blocks) y\n\n    \n    forM_ (zip blocks $ tail blocks) $ \\(x, y) ->\n        forM_ vs $ \\(i, z) ->\n            constraint3 (\\(_, x') (y', _) b -> i <= x' || i >= y' || not b) x y z\n  where\n    f :: [DV r (Int, Int)] -> CSP r ()\n    f (u : v : bs) = do\n        constraint2 (\\(_, u') (v', _) -> v' >= u' + 2)  u v\n        f $ v : bs\n    f _            = return ()\n\n\n\n\n\nprintSolution :: [[Bool]] -> IO ()\nprintSolution bss =\n    forM_ bss $ \\bs -> do\n        forM_ bs $ \\b ->\n            putChar $ if b then '#' else '.'\n        putChar '\\n'\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class NonogramSolver\n{\n    public static void Main2() {\n        foreach (var (x, y) in new [] {\n            (\"C BA CB BB F AE F A B\", \"AB CA AE GA E C D C\"),\n            (\"F CAC ACAC CN AAA AABB EBB EAA ECCC HCCC\",\n                \"D D AE CD AE A DA BBB CC AAB BAA AAB DA AAB AAA BAB AAA CD BBA DA\"),\n            (\"CA BDA ACC BD CCAC CBBAC BBBBB BAABAA ABAD AABB BBH BBBD ABBAAA CCEA AACAAB BCACC ACBH DCH ADBE ADBB DBE ECE DAA DB CC\",\n                \"BC CAC CBAB BDD CDBDE BEBDF ADCDFA DCCFB DBCFC ABDBA BBF AAF BADB DBF AAAAD BDG CEF CBDB BBB FC\"),\n            (\"E BCB BEA BH BEK AABAF ABAC BAA BFB OD JH BADCF Q Q R AN AAN EI H G\",\n                \"E CB BAB AAA AAA AC BB ACC ACCA AGB AIA AJ AJ ACE AH BAF CAG DAG FAH FJ GJ ADK ABK BL CM\")\n            })\n        {\n            Solve(x, y);\n            Console.WriteLine();\n        }\n    }\n\n    static void Solve(string rowLetters, string columnLetters) {\n        var r = rowLetters.Split(\" \").Select(row => row.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        var c = columnLetters.Split(\" \").Select(column => column.Select(s => s - 'A' + 1).ToArray()).ToArray();\n        Solve(r, c);\n    }\n\n    static void Solve(int[][] rowRuns, int[][] columnRuns) {\n        int len = columnRuns.Length;\n        var rows = rowRuns.Select(row => Generate(len, row)).ToList();\n        var columns = columnRuns.Select(column => Generate(rowRuns.Length, column)).ToList();\n        Reduce(rows, columns);\n        foreach (var list in rows) {\n            if (list.Count != 1) Console.WriteLine(Repeat('?', len).Spaced());\n            else Console.WriteLine(list[0].ToString().PadLeft(len, '0').Replace('1', '#').Replace('0', '.').Reverse().Spaced());\n        }\n    }\n\n    static List<BitSet> Generate(int length, params int[] runs) {\n        var list = new List<BitSet>();\n        BitSet initial = BitSet.Empty;\n        int[] sums = new int[runs.Length];\n        sums[0] = 0;\n        for (int i = 1; i < runs.Length; i++) sums[i] = sums[i - 1] + runs[i - 1] + 1;\n        for (int r = 0; r < runs.Length; r++) initial = initial.AddRange(sums[r], runs[r]);\n        Generate(list, BitSet.Empty.Add(length), runs, sums, initial, 0, 0);\n        return list;\n    }\n\n    static void Generate(List<BitSet> result, BitSet max, int[] runs, int[] sums, BitSet current, int index, int shift) {\n        if (index == runs.Length) {\n            result.Add(current);\n            return;\n        }\n        while (current.Value < max.Value) {\n            Generate(result, max, runs, sums, current, index + 1, shift);\n            current = current.ShiftLeftAt(sums[index] + shift);\n            shift++;\n        }\n    }\n\n    static void Reduce(List<List<BitSet>> rows, List<List<BitSet>> columns) {\n        for (int count = 1; count > 0; ) {\n            foreach (var (rowIndex, row) in rows.WithIndex()) {\n                var allOn  = row.Aggregate((a, b) => a & b);\n                var allOff = row.Aggregate((a, b) => a | b);\n                foreach (var (columnIndex, column) in columns.WithIndex()) {\n                    count  = column.RemoveAll(c => allOn.Contains(columnIndex) && !c.Contains(rowIndex));\n                    count += column.RemoveAll(c => !allOff.Contains(columnIndex) && c.Contains(rowIndex));\n                }\n            }\n            foreach (var (columnIndex, column) in columns.WithIndex()) {\n                var allOn  = column.Aggregate((a, b) => a & b);\n                var allOff = column.Aggregate((a, b) => a | b);\n                foreach (var (rowIndex, row) in rows.WithIndex()) {\n                    count += row.RemoveAll(r => allOn.Contains(rowIndex) && !r.Contains(columnIndex));\n                    count += row.RemoveAll(r => !allOff.Contains(rowIndex) && r.Contains(columnIndex));\n                }\n            }\n        }\n    }\n\n    static IEnumerable<(int index, T element)> WithIndex<T>(this IEnumerable<T> source) {\n        int i = 0;\n        foreach (T element in source) {\n            yield return (i++, element);\n        }\n    }\n\n    static string Reverse(this string s) {\n        char[] array = s.ToCharArray();\n        Array.Reverse(array);\n        return new string(array);\n    }\n\n    static string Spaced(this IEnumerable<char> s) => string.Join(\" \", s);\n\n    struct BitSet \n    {\n        public static BitSet Empty => default;\n        private readonly int bits;\n        public int Value => bits;\n\n        private BitSet(int bits) => this.bits = bits;\n\n        public BitSet Add(int item) => new BitSet(bits | (1 << item));\n        public BitSet AddRange(int start, int count) => new BitSet(bits | (((1 << (start + count)) - 1) - ((1 << start) - 1)));\n        public bool Contains(int item) => (bits & (1 << item)) != 0;\n        public BitSet ShiftLeftAt(int index)  => new BitSet((bits >> index << (index + 1)) | (bits & ((1 << index) - 1)));\n        public override string ToString() => Convert.ToString(bits, 2);\n\n        public static BitSet operator &(BitSet a, BitSet b) => new BitSet(a.bits & b.bits);\n        public static BitSet operator |(BitSet a, BitSet b) => new BitSet(a.bits | b.bits);\n    }\n\n}\n"}
{"id": 410237, "name": "Almkvist-Giullera formula for pi", "source": "Translate Haskell to C#: import Control.Monad\nimport Data.Number.CReal\nimport GHC.Integer\nimport Text.Printf\n\niterations = 52\nmain = do\n  printf \"N. %44s %4s %s\\n\" \n          \"Integral part of Nth term\" \"\u00d710^\" \"=Actual value of Nth term\"\n\n  forM_ [0..9] $ \\n ->\n    printf \"%d. %44d %4d %s\\n\" n\n                               (almkvistGiulleraIntegral n)\n                               (tenExponent n)\n                               (showCReal 50 (almkvistGiullera n))\n\n  printf \"\\nPi after %d iterations:\\n\" iterations\n  putStrLn $ showCReal 70 $ almkvistGiulleraPi iterations\n\n\nalmkvistGiulleraIntegral n =\n  let polynomial  = (532 `timesInteger` n `timesInteger` n) `plusInteger` (126 `timesInteger` n) `plusInteger` 9\n      numerator   = 32 `timesInteger` (facInteger (6 `timesInteger` n)) `timesInteger` polynomial\n      denominator = 3 `timesInteger` (powInteger (facInteger n) 6)\n   in numerator `divInteger` denominator\n\n\ntenExponent n = 3 `minusInteger` (6 `timesInteger` (1 `plusInteger` n))\n\n\nalmkvistGiullera n = fromInteger (almkvistGiulleraIntegral n) / fromInteger (powInteger 10 (abs (tenExponent n)))\n\n\nalmkvistGiulleraSum n = sum $ map almkvistGiullera [0 .. n]\n\n\nalmkvistGiulleraPi n = sqrt $ 1 / almkvistGiulleraSum n\n\n\nfacInteger n = if n `leInteger` 1 then 1 else n `timesInteger` facInteger (n `minusInteger` 1)\n\n\npowInteger 1 _ = 1\npowInteger _ 0 = 1\npowInteger b 1 = b\npowInteger b e = b `timesInteger` powInteger b (e `minusInteger` 1)\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\nusing static System.Console;\n\nclass Program {\n\n  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\n\u00a0 static string dump(int digs, bool show = false) {\n    int gb = 1, dg = ++digs + gb, z;\n    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,\n       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;\n    for (BI n = 0; n < dg; n++) {\n      if (n > 0) t3 *= BI.Pow(n, 6);\n      te = t1 * t2 / t3;\n      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);\n      else te /= BI.Pow (10, -z);\n      if (show && n < 10)\n        WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t);\n      su += te; if (te < 10) {\n        if (show) WriteLine(\"\\n{0} iterations required for {1} digits \" +\n        \"after the decimal point.\\n\", n, --digs); break; }\n      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;\n      t2 += 126 + 532 * (d += 2);\n    }\n    string s = string.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) /\n      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));\n    return s[0] + \".\" + s.Substring(1, digs); }\n\n  static void Main(string[] args) {\n    WriteLine(dump(70, true)); }\n}\n"}
{"id": 410238, "name": "Almkvist-Giullera formula for pi", "source": "Translate Haskell to C#: import Control.Monad\nimport Data.Number.CReal\nimport GHC.Integer\nimport Text.Printf\n\niterations = 52\nmain = do\n  printf \"N. %44s %4s %s\\n\" \n          \"Integral part of Nth term\" \"\u00d710^\" \"=Actual value of Nth term\"\n\n  forM_ [0..9] $ \\n ->\n    printf \"%d. %44d %4d %s\\n\" n\n                               (almkvistGiulleraIntegral n)\n                               (tenExponent n)\n                               (showCReal 50 (almkvistGiullera n))\n\n  printf \"\\nPi after %d iterations:\\n\" iterations\n  putStrLn $ showCReal 70 $ almkvistGiulleraPi iterations\n\n\nalmkvistGiulleraIntegral n =\n  let polynomial  = (532 `timesInteger` n `timesInteger` n) `plusInteger` (126 `timesInteger` n) `plusInteger` 9\n      numerator   = 32 `timesInteger` (facInteger (6 `timesInteger` n)) `timesInteger` polynomial\n      denominator = 3 `timesInteger` (powInteger (facInteger n) 6)\n   in numerator `divInteger` denominator\n\n\ntenExponent n = 3 `minusInteger` (6 `timesInteger` (1 `plusInteger` n))\n\n\nalmkvistGiullera n = fromInteger (almkvistGiulleraIntegral n) / fromInteger (powInteger 10 (abs (tenExponent n)))\n\n\nalmkvistGiulleraSum n = sum $ map almkvistGiullera [0 .. n]\n\n\nalmkvistGiulleraPi n = sqrt $ 1 / almkvistGiulleraSum n\n\n\nfacInteger n = if n `leInteger` 1 then 1 else n `timesInteger` facInteger (n `minusInteger` 1)\n\n\npowInteger 1 _ = 1\npowInteger _ 0 = 1\npowInteger b 1 = b\npowInteger b e = b `timesInteger` powInteger b (e `minusInteger` 1)\n", "target": "using System;\nusing BI = System.Numerics.BigInteger;\nusing static System.Console;\n\nclass Program {\n\n  static BI isqrt(BI x) { BI q = 1, r = 0, t; while (q <= x) q <<= 2; while (q > 1) {\n    q >>= 2; t = x - r - q; r >>= 1; if (t >= 0) { x = t; r += q; } } return r; }\n\n\u00a0 static string dump(int digs, bool show = false) {\n    int gb = 1, dg = ++digs + gb, z;\n    BI t1 = 1, t2 = 9, t3 = 1, te, su = 0,\n       t = BI.Pow(10, dg <= 60 ? 0 : dg - 60), d = -1, fn = 1;\n    for (BI n = 0; n < dg; n++) {\n      if (n > 0) t3 *= BI.Pow(n, 6);\n      te = t1 * t2 / t3;\n      if ((z = dg - 1 - (int)n * 6) > 0) te *= BI.Pow (10, z);\n      else te /= BI.Pow (10, -z);\n      if (show && n < 10)\n        WriteLine(\"{0,2} {1,62}\", n, te * 32 / 3 / t);\n      su += te; if (te < 10) {\n        if (show) WriteLine(\"\\n{0} iterations required for {1} digits \" +\n        \"after the decimal point.\\n\", n, --digs); break; }\n      for (BI j = n * 6 + 1; j <= n * 6 + 6; j++) t1 *= j;\n      t2 += 126 + 532 * (d += 2);\n    }\n    string s = string.Format(\"{0}\", isqrt(BI.Pow(10, dg * 2 + 3) /\n      su / 32 * 3 * BI.Pow((BI)10, dg + 5)));\n    return s[0] + \".\" + s.Substring(1, digs); }\n\n  static void Main(string[] args) {\n    WriteLine(dump(70, true)); }\n}\n"}
{"id": 410239, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Haskell to C#: import           Control.Monad (guard)\nimport           Text.Printf   (printf)\n\np :: Int -> Int -> Int\np l n = calc !! pred n\n  where\n    digitCount = floor $ logBase 10 (fromIntegral l :: Float)\n    log10pwr   = logBase 10 2\n    calc = do\n      raised <- [-1 ..]\n      let firstDigits = floor $ 10 ** (snd (properFraction $ log10pwr * realToFrac raised) \n                        + realToFrac digitCount)\n      guard (firstDigits == l)\n      [raised]\n\nmain :: IO ()\nmain = mapM_ (\\(l, n) -> printf \"p(%d, %d) = %d\\n\" l n (p l n))\n  [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 410240, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Haskell to C#: import           Control.Monad (guard)\nimport           Text.Printf   (printf)\n\np :: Int -> Int -> Int\np l n = calc !! pred n\n  where\n    digitCount = floor $ logBase 10 (fromIntegral l :: Float)\n    log10pwr   = logBase 10 2\n    calc = do\n      raised <- [-1 ..]\n      let firstDigits = floor $ 10 ** (snd (properFraction $ log10pwr * realToFrac raised) \n                        + realToFrac digitCount)\n      guard (firstDigits == l)\n      [raised]\n\nmain :: IO ()\nmain = mapM_ (\\(l, n) -> printf \"p(%d, %d) = %d\\n\" l n (p l n))\n  [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]\n", "target": "\n\nusing System;\n\nclass Program {\n\n    \n    static long js(int l, int n) {\n        long res = 0, f = 1;\n        double lf = Math.Log10(2);\n        for (int i = l; i > 10; i /= 10) f *= 10;\n        while (n > 0)\n            if ((int)(f * Math.Pow(10, ++res * lf % 1)) == l) n--;\n        return res;\n    }\n\n    \n    static long gi(int ld, int n) {\n        string Ls = ld.ToString();\n        long res = 0, count = 0, f = 1;\n        for (int i = 1; i <= 18 - Ls.Length; i++) f *= 10;\n        const long ten18 = (long)1e18; long probe = 1;\n        do {\n            probe <<= 1; res++; if (probe >= ten18)\n                do {\n                    if (probe >= ten18) probe /= 10;\n                    if (probe / f == ld)\n                        if (++count >= n) { count--; break; }\n                    probe <<= 1; res++;\n                } while (true);\n            string ps = probe.ToString();\n            if (ps.Substring(0, Math.Min(Ls.Length, ps.Length)) == Ls)\n                if (++count >= n) break;\n        } while (true);\n        return res;\n    }\n\n    \n    static long pa(int ld, int n) {\n        double L_float64 = Math.Pow(2, 64);\n        ulong Log10_2_64 = (ulong)(L_float64 * Math.Log10(2));\n        double Log10Num; ulong LmtUpper, LmtLower, Frac64;\n        long res = 0, dgts = 1, cnt;\n        for (int i = ld; i >= 10; i /= 10) dgts *= 10;\n        Log10Num = Math.Log10((ld + 1.0) / dgts);\n        \n        if (Log10Num >= 0.5) {\n            LmtUpper = (ld + 1.0) / dgts < 10.0 ? (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2) : 0;\n            Log10Num = Math.Log10((double)ld / dgts);\n            LmtLower = (ulong)(Log10Num * (L_float64 * 0.5)) * 2 + (ulong)(Log10Num * 2);\n        } else {\n            LmtUpper = (ulong)(Log10Num * L_float64);\n            LmtLower = (ulong)(Math.Log10((double)ld / dgts) * L_float64);\n        }\n        cnt = 0; Frac64 = 0; if (LmtUpper != 0)\n            do {\n                res++; Frac64 += Log10_2_64;\n                if ((Frac64 >= LmtLower) & (Frac64 < LmtUpper))\n                    if (++cnt >= n) break;\n            } while (true);\n        else \n            do {\n                res++; Frac64 += Log10_2_64;\n                if (Frac64 >= LmtLower) if (++cnt >= n) break;\n            } while (true);\n        return res;\n    }\n\n    static int[] values = new int[] { 12, 1, 12, 2, 123, 45, 123, 12345, 123, 678910, 99, 1 };\n\n    static void doOne(string name, Func<int, int, long> fun) {\n        Console.WriteLine(\"{0} version:\", name);\n        var start = DateTime.Now;\n        for (int i = 0; i < values.Length; i += 2)\n            Console.WriteLine(\"p({0,3}, {1,6}) = {2,11:n0}\", values[i], values[i + 1], fun(values[i], values[i + 1]));\n        Console.WriteLine(\"Took {0} seconds\\n\", DateTime.Now - start);\n    }\n\n    static void Main() {\n        doOne(\"java simple\", js);\n        doOne(\"go integer\", gi);\n        doOne(\"pascal alternative\", pa);\n    }\n}\n"}
{"id": 410241, "name": "N-smooth numbers", "source": "Translate Haskell to C#: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\n \nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] b = b\nmerge a@(x:xs) b@(y:ys) | x < y     = x : merge xs b\n                        | otherwise = y : merge a ys\n \nnSmooth :: Integer -> [Integer]\nnSmooth p = 1 : foldr u [] factors\n where\n   factors = takeWhile (<=p) primes\n   u n s = r\n    where r = merge s (map (n*) (1:r))\n\nmain :: IO ()\nmain = do\n  mapM_ (printf \"First 25 %d-smooth:\\n%s\\n\\n\" <*> showTwentyFive) firstTenPrimes\n  mapM_\n    (printf \"The 3,000 to 3,202 %d-smooth numbers are:\\n%s\\n\\n\" <*> showRange1)\n    firstTenPrimes\n  mapM_\n    (printf \"The 30,000 to 30,019 %d-smooth numbers are:\\n%s\\n\\n\" <*> showRange2)\n    [503, 509, 521]\n  where\n    firstTenPrimes = take 10 primes\n    showTwentyFive = show . take 25 . nSmooth\n    showRange1 = show . ((<$> [2999 .. 3001]) . (!!) . nSmooth)\n    showRange2 = show . ((<$> [29999 .. 30018]) . (!!) . nSmooth)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NSmooth {\n    class Program {\n        static readonly List<BigInteger> primes = new List<BigInteger>();\n        static readonly List<int> smallPrimes = new List<int>();\n\n        static Program() {\n            primes.Add(2);\n            smallPrimes.Add(2);\n\n            BigInteger i = 3;\n            while (i <= 521) {\n                if (IsPrime(i)) {\n                    primes.Add(i);\n                    if (i <= 29) {\n                        smallPrimes.Add((int)i);\n                    }\n                }\n                i += 2;\n            }\n        }\n\n        static bool IsPrime(BigInteger value) {\n            if (value < 2) return false;\n\n            if (value % 2 == 0) return value == 2;\n            if (value % 3 == 0) return value == 3;\n\n            if (value % 5 == 0) return value == 5;\n            if (value % 7 == 0) return value == 7;\n\n            if (value % 11 == 0) return value == 11;\n            if (value % 13 == 0) return value == 13;\n\n            if (value % 17 == 0) return value == 17;\n            if (value % 19 == 0) return value == 19;\n\n            if (value % 23 == 0) return value == 23;\n\n            BigInteger t = 29;\n            while (t * t < value) {\n                if (value % t == 0) return false;\n                value += 2;\n\n                if (value % t == 0) return false;\n                value += 4;\n            }\n\n            return true;\n        }\n\n        static List<BigInteger> NSmooth(int n, int size) {\n            if (n < 2 || n > 521) {\n                throw new ArgumentOutOfRangeException(\"n\");\n            }\n            if (size < 1) {\n                throw new ArgumentOutOfRangeException(\"size\");\n            }\n\n            BigInteger bn = n;\n            bool ok = false;\n            foreach (var prime in primes) {\n                if (bn == prime) {\n                    ok = true;\n                    break;\n                }\n            }\n            if (!ok) {\n                throw new ArgumentException(\"must be a prime number\", \"n\");\n            }\n\n            BigInteger[] ns = new BigInteger[size];\n            ns[0] = 1;\n            for (int i = 1; i < size; i++) {\n                ns[i] = 0;\n            }\n\n            List<BigInteger> next = new List<BigInteger>();\n            foreach (var prime in primes) {\n                if (prime > bn) {\n                    break;\n                }\n                next.Add(prime);\n            }\n\n            int[] indices = new int[next.Count];\n            for (int i = 0; i < indices.Length; i++) {\n                indices[i] = 0;\n            }\n            for (int m = 1; m < size; m++) {\n                ns[m] = next.Min();\n                for (int i = 0; i < indices.Length; i++) {\n                    if (ns[m] == next[i]) {\n                        indices[i]++;\n                        next[i] = primes[i] * ns[indices[i]];\n                    }\n                }\n            }\n\n            return ns.ToList();\n        }\n\n        static void Println<T>(IEnumerable<T> nums) {\n            Console.Write('[');\n\n            var it = nums.GetEnumerator();\n            if (it.MoveNext()) {\n                Console.Write(it.Current);\n            }\n            while (it.MoveNext()) {\n                Console.Write(\", \");\n                Console.Write(it.Current);\n            }\n\n            Console.WriteLine(']');\n        }\n\n        static void Main() {\n            foreach (var i in smallPrimes) {\n                Console.WriteLine(\"The first {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 25));\n                Console.WriteLine();\n            }\n            foreach (var i in smallPrimes.Skip(1)) {\n                Console.WriteLine(\"The 3,000 to 3,202 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 3_002).Skip(2_999));\n                Console.WriteLine();\n            }\n            foreach (var i in new int[] { 503, 509, 521 }) {\n                Console.WriteLine(\"The 30,000 to 3,019 {0}-smooth numbers are:\", i);\n                Println(NSmooth(i, 30_019).Skip(29_999));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 410242, "name": "Partition an integer x into n primes", "source": "Translate Haskell to C#: import Data.List (delete, intercalate)\nimport Data.Numbers.Primes (primes)\nimport Data.Bool (bool)\n\n\npartitions :: Int -> Int -> [Int]\npartitions x n\n  | n <= 1 =\n    [ x\n    | x == last ps ]\n  | otherwise = go ps x n\n  where\n    ps = takeWhile (<= x) primes\n    go ps_ x 1 =\n      [ x\n      | x `elem` ps_ ]\n    go ps_ x n = ((flip bool [] . head) <*> null) (ps_ >>= found)\n      where\n        found p =\n          ((flip bool [] . return . (p :)) <*> null)\n            ((go =<< delete p . flip takeWhile ps_ . (>=)) (x - p) (pred n))\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  (\\(x, n) ->\n      intercalate\n        \" -> \"\n        [ justifyLeft 9 ' ' (show (x, n))\n        , let xs = partitions x n\n          in bool\n               (tail $ concatMap (('+' :) . show) xs)\n               \"(no solution)\"\n               (null xs)\n        ]) <$>\n  concat\n    [ [(99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24)]\n    , (,) 22699 <$> [1 .. 4]\n    , [(40355, 3)]\n    ]\n\n\njustifyLeft :: Int -> Char -> String -> String\njustifyLeft n c s = take n (s ++ replicate n c)\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class Rosetta\n{\n    static void Main()\n    {\n        foreach ((int x, int n) in new [] {\n            (99809, 1),\n            (18, 2),\n            (19, 3),\n            (20, 4),\n            (2017, 24),\n            (22699, 1),\n            (22699, 2),\n            (22699, 3),\n            (22699, 4),\n            (40355, 3)\n        }) {\n            Console.WriteLine(Partition(x, n));\n        }\n    }\n\n    public static string Partition(int x, int n) {\n        if (x < 1 || n < 1) throw new ArgumentOutOfRangeException(\"Parameters must be positive.\");\n        string header = $\"{x} with {n} {(n == 1\u00a0? \"prime\"\u00a0: \"primes\")}: \";\n        int[] primes = SievePrimes(x).ToArray();\n        if (primes.Length < n) return header + \"not enough primes\";\n        int[] solution = CombinationsOf(n, primes).FirstOrDefault(c => c.Sum() == x);\n        return header + (solution == null ? \"not possible\" : string.Join(\"+\", solution);\n    }\n\n    static IEnumerable<int> SievePrimes(int bound) {\n        if (bound < 2) yield break;\n        yield return 2;\n\n        BitArray composite = new BitArray((bound - 1) / 2);\n        int limit = ((int)(Math.Sqrt(bound)) - 1) / 2;\n        for (int i = 0; i < limit; i++) {\n            if (composite[i]) continue;\n            int prime = 2 * i + 3;\n            yield return prime;\n            for (int j = (prime * prime - 2) / 2; j < composite.Count; j += prime) composite[j] = true;\n        }\n        for (int i = limit; i < composite.Count; i++) {\n            if (!composite[i]) yield return 2 * i + 3;\n        }\n    }\n\n    static IEnumerable<int[]> CombinationsOf(int count, int[] input) {\n        T[] result = new T[count];\n        foreach (int[] indices in Combinations(input.Length, count)) {\n            for (int i = 0; i < count; i++) result[i] = input[indices[i]];\n            yield return result;\n        }\n    }\n\n    static IEnumerable<int[]> Combinations(int n, int k) {\n        var result = new int[k];\n        var stack = new Stack<int>();\n        stack.Push(0);\n        while (stack.Count > 0) {\n            int index = stack.Count - 1;\n            int value = stack.Pop();\n            while (value < n) {\n                result[index++] = value++;\n                stack.Push(value);\n                if (index == k) {\n                    yield return result;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n"}
{"id": 410243, "name": "Zeckendorf arithmetic", "source": "Translate Haskell to C#: \nimport Data.List (find, mapAccumL)\nimport Control.Arrow (first, second)\n\n\n\nfibs :: Num a => a -> a -> [a]\nfibs a b = res\n  where\n    res = a : b : zipWith (+) res (tail res)\n\ndata Fib = Fib { sign :: Int, digits :: [Int]}\n\n\nmkFib s ds =\n  case dropWhile (==0) ds of\n    [] -> 0\n    ds -> Fib s (reverse ds)\n\n\ninstance Show Fib where\n  show (Fib s ds) = sig s ++ foldMap show (reverse ds)\n    where sig = \\case { -1 -> \"-\"; s -> \"\" }\n\n\ninstance Eq Fib where\n  Fib sa a == Fib sb b = sa == sb && a == b\n\n\ninstance Ord Fib where\n  a `compare` b =\n    sign a `compare` sign b <>\n    case find (/= 0) $ alignWith (-) (digits a) (digits b) of\n      Nothing -> EQ\n      Just 1 -> if sign a > 0 then GT else LT\n      Just (-1) -> if sign a > 0 then LT else GT\n\n\ninstance Num Fib where\n  negate (Fib s ds) = Fib (negate s) ds\n  abs (Fib s ds) = Fib 1 ds\n  signum (Fib s _) = fromIntegral s\n\n  fromInteger n =\n    case compare n 0 of\n      LT -> negate $ fromInteger (- n)\n      EQ -> Fib 0 [0]\n      GT -> Fib 1 . reverse . fst $ divModFib n 1\n\n  0 + a = a\n  a + 0 = a\n  a + b =\n    case (sign a, sign b) of\n      ( 1, 1) -> res\n      (-1, 1) -> b - (-a)\n      ( 1,-1) -> a - (-b)\n      (-1,-1) -> - ((- a) + (- b))\n    where\n      res = mkFib 1 . process $ 0:0:c\n      c = alignWith (+) (digits a) (digits b)\n       \n      process =\n        runRight 3 r2 . runLeftR 3 r2 . runRightR 4 r1\n\n  0 - a = -a\n  a - 0 = a\n  a - b =\n    case (sign a, sign b) of\n      ( 1, 1) -> res\n      (-1, 1) -> - ((-a) + b)\n      ( 1,-1) -> a + (-b)\n      (-1,-1) -> - ((-a) - (-b))  \n    where\n      res = case find (/= 0) c of\n        Just 1  -> mkFib 1 . process $ c\n        Just (-1) -> - (b - a)\n        Nothing -> 0\n      c = alignWith (-) (digits a) (digits b)\n      \n      process =\n        runRight 3 r2 . runLeftR 3 r2 . runRightR 4 r1 . runRight 3 r3\n\n  0 * a = 0\n  a * 0 = 0\n  1 * a = a\n  a * 1 = a\n  a * b =\n    case (sign a, sign b) of\n      (1, 1) -> res\n      (-1, 1) -> - ((-a) * b)\n      ( 1,-1) -> - (a * (-b))\n      (-1,-1) -> ((-a) * (-b))  \n    where\n      \n      table = fibs a (a + a)\n      res = sum $ onlyOnes $ zip (digits b) table\n      onlyOnes = map snd . filter ((==1) . fst)\n\n\ninstance Enum Fib where\n  toEnum = fromInteger . fromIntegral\n  fromEnum = fromIntegral . toInteger\n  \ninstance Real Fib where\n  toRational = fromInteger . toInteger\n  \n\ninstance Integral Fib where\n  toInteger (Fib s ds) = signum (fromIntegral s) * res\n    where\n      res = sum (zipWith (*) (fibs 1 2) (fromIntegral <$> ds))\n\n  quotRem 0 _ = (0, 0)\n  quotRem a 0 = error \"divide by zero\"\n  quotRem a b = case (sign a, sign b) of\n      (1, 1) -> first (mkFib 1) $ divModFib a b\n      (-1, 1) -> second negate . first negate $ quotRem (-a) b\n      ( 1,-1) -> first negate $ quotRem a (-b)\n      (-1,-1) -> second negate $ quotRem (-a) (-b) \n\n\n\n\n\ndivModFib :: (Ord a, Num c, Num a) => a -> a -> ([c], a)\ndivModFib a b = (q, r)\n  where\n    (r, q) = mapAccumL f a $ reverse $ takeWhile (<= a) table\n    table = fibs b (b+b)\n    f n x = if  n < x then (n, 0) else (n - x, 1)\n\n\n\nrunRight n f = go\n  where\n    go []  = []\n    go lst = let (w, r) = splitAt n lst \n                 (h: t) = f w\n             in h : go (t ++ r)\n                    \n\nrunRightR n f = go []\n  where\n    go res []  = res\n    go res lst = let (w, r) = splitAt n lst \n                     (h: t) = f w\n                 in go (h : res) (t ++ r)\n\n\nrunLeftR n f = runRightR n (reverse . f . reverse) \n\n\nr1 = \\case [0,3,0]   -> [1,1,1]\n           [0,2,0]   -> [1,0,1]\n           [0,1,2]   -> [1,0,1]\n           [0,2,1]   -> [1,1,0]\n           [x,0,2]   -> [x,1,0]\n           [x,0,3]   -> [x,1,1]\n           [0,1,2,0] -> [1,0,1,0]\n           [0,2,0,x] -> [1,0,0,x+1]\n           [0,3,0,x] -> [1,1,0,x+1]\n           [0,2,1,x] -> [1,1,0,x  ]\n           [0,1,2,x] -> [1,0,1,x  ]\n           l -> l\n\nr2 = \\case [0,1,1] -> [1,0,0]\n           l -> l\n\nr3 = \\case [1,-1]    -> [0,1]\n           [2,-1]    -> [1,1]\n           [1, 0, 0] -> [0,1,1]\n           [1,-1, 0] -> [0,0,1]\n           [1,-1, 1] -> [0,0,2]\n           [1, 0,-1] -> [0,1,0]\n           [2, 0, 0] -> [1,1,1]\n           [2,-1, 0] -> [1,0,1]\n           [2,-1, 1] -> [1,0,2]\n           [2, 0,-1] -> [1,1,0]\n           l -> l\n\nalignWith :: (Int -> Int -> a) -> [Int] -> [Int] -> [a]\nalignWith f a b = go [] a b\n  where\n    go res as [] = ((`f` 0) <$> reverse as) ++ res\n    go res [] bs = ((0 `f`) <$> reverse bs) ++ res\n    go res (a:as) (b:bs) = go (f a b : res) as bs\n", "target": "using System;\nusing System.Text;\n\nnamespace ZeckendorfArithmetic {\n    class Zeckendorf : IComparable<Zeckendorf> {\n        private static readonly string[] dig = { \"00\", \"01\", \"10\" };\n        private static readonly string[] dig1 = { \"\", \"1\", \"10\" };\n\n        private int dVal = 0;\n        private int dLen = 0;\n\n        public Zeckendorf() : this(\"0\") {\n            \n        }\n\n        public Zeckendorf(string x) {\n            int q = 1;\n            int i = x.Length - 1;\n            dLen = i / 2;\n            while (i >= 0) {\n                dVal += (x[i] - '0') * q;\n                q *= 2;\n                i--;\n            }\n        }\n\n        private void A(int n) {\n            int i = n;\n            while (true) {\n                if (dLen < i) dLen = i;\n                int j = (dVal >> (i * 2)) & 3;\n                switch (j) {\n                    case 0:\n                    case 1:\n                        return;\n                    case 2:\n                        if (((dVal >> ((i + 1) * 2)) & 1) != 1) return;\n                        dVal += 1 << (i * 2 + 1);\n                        return;\n                    case 3:\n                        int temp = 3 << (i * 2);\n                        temp ^= -1;\n                        dVal = dVal & temp;\n                        B((i + 1) * 2);\n                        break;\n                }\n                i++;\n            }\n        }\n\n        private void B(int pos) {\n            if (pos == 0) {\n                Inc();\n                return;\n            }\n            if (((dVal >> pos) & 1) == 0) {\n                dVal += 1 << pos;\n                A(pos / 2);\n                if (pos > 1) A(pos / 2 - 1);\n            }\n            else {\n                int temp = 1 << pos;\n                temp ^= -1;\n                dVal = dVal & temp;\n                B(pos + 1);\n                B(pos - (pos > 1 ? 2 : 1));\n            }\n        }\n\n        private void C(int pos) {\n            if (((dVal >> pos) & 1) == 1) {\n                int temp = 1 << pos;\n                temp ^= -1;\n                dVal = dVal & temp;\n                return;\n            }\n            C(pos + 1);\n            if (pos > 0) {\n                B(pos - 1);\n            }\n            else {\n                Inc();\n            }\n        }\n\n        public Zeckendorf Inc() {\n            dVal++;\n            A(0);\n            return this;\n        }\n\n        public Zeckendorf Copy() {\n            Zeckendorf z = new Zeckendorf {\n                dVal = dVal,\n                dLen = dLen\n            };\n            return z;\n        }\n\n        public void PlusAssign(Zeckendorf other) {\n            for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n                if (((other.dVal >> gn) & 1) == 1) {\n                    B(gn);\n                }\n            }\n        }\n\n        public void MinusAssign(Zeckendorf other) {\n            for (int gn = 0; gn < (other.dLen + 1) * 2; gn++) {\n                if (((other.dVal >> gn) & 1) == 1) {\n                    C(gn);\n                }\n            }\n            while ((((dVal >> dLen * 2) & 3) == 0) || (dLen == 0)) {\n                dLen--;\n            }\n        }\n\n        public void TimesAssign(Zeckendorf other) {\n            Zeckendorf na = other.Copy();\n            Zeckendorf nb = other.Copy();\n            Zeckendorf nt;\n            Zeckendorf nr = new Zeckendorf();\n            for (int i = 0; i < (dLen + 1) * 2; i++) {\n                if (((dVal >> i) & 1) > 0) {\n                    nr.PlusAssign(nb);\n                }\n                nt = nb.Copy();\n                nb.PlusAssign(na);\n                na = nt.Copy();\n            }\n            dVal = nr.dVal;\n            dLen = nr.dLen;\n        }\n\n        public int CompareTo(Zeckendorf other) {\n            return dVal.CompareTo(other.dVal);\n        }\n\n        public override string ToString() {\n            if (dVal == 0) {\n                return \"0\";\n            }\n\n            int idx = (dVal >> (dLen * 2)) & 3;\n            StringBuilder sb = new StringBuilder(dig1[idx]);\n            for (int i = dLen - 1; i >= 0; i--) {\n                idx = (dVal >> (i * 2)) & 3;\n                sb.Append(dig[idx]);\n            }\n            return sb.ToString();\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            Console.WriteLine(\"Addition:\");\n            Zeckendorf g = new Zeckendorf(\"10\");\n            g.PlusAssign(new Zeckendorf(\"10\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"10\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"1001\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"1000\"));\n            Console.WriteLine(g);\n            g.PlusAssign(new Zeckendorf(\"10101\"));\n            Console.WriteLine(g);\n            Console.WriteLine();\n\n            Console.WriteLine(\"Subtraction:\");\n            g = new Zeckendorf(\"1000\");\n            g.MinusAssign(new Zeckendorf(\"101\"));\n            Console.WriteLine(g);\n            g = new Zeckendorf(\"10101010\");\n            g.MinusAssign(new Zeckendorf(\"1010101\"));\n            Console.WriteLine(g);\n            Console.WriteLine();\n\n            Console.WriteLine(\"Multiplication:\");\n            g = new Zeckendorf(\"1001\");\n            g.TimesAssign(new Zeckendorf(\"101\"));\n            Console.WriteLine(g);\n            g = new Zeckendorf(\"101010\");\n            g.PlusAssign(new Zeckendorf(\"101\"));\n            Console.WriteLine(g);\n        }\n    }\n}\n"}
{"id": 410244, "name": "Vector", "source": "Translate Haskell to C#: add (u,v) (x,y)      = (u+x,v+y)\nminus (u,v) (x,y)    = (u-x,v-y)\nmultByScalar k (x,y) = (k*x,k*y)\ndivByScalar (x,y) k  = (x/k,y/k)\n\nmain = do\n  let vecA = (3.0,8.0) \n  let (r,theta) = (3,pi/12) :: (Double,Double)\n  let vecB = (r*(cos theta),r*(sin theta)) \n  putStrLn $ \"vecA = \" ++ (show vecA)\n  putStrLn $ \"vecB = \" ++ (show vecB)\n  putStrLn $ \"vecA + vecB = \" ++ (show.add vecA $ vecB)\n  putStrLn $ \"vecA - vecB = \" ++ (show.minus vecA $ vecB)\n  putStrLn $ \"2 * vecB = \" ++ (show.multByScalar 2 $ vecB)\n  putStrLn $ \"vecA / 3 = \" ++ (show.divByScalar vecA $ 3)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaVectors\n{\n    public class Vector\n    {\n        public double[] store;\n        public Vector(IEnumerable<double> init)\n        {\n            store = init.ToArray();\n        }\n        public Vector(double x, double y)\n        {\n            store = new double[] { x, y };\n        }\n        static public Vector operator+(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a + b));\n        }\n        static public Vector operator -(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a - b));\n        }\n        static public Vector operator *(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x * scalar));\n        }\n        static public Vector operator /(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x / scalar));\n        }\n        public override string ToString()\n        {\n            return string.Format(\"[{0}]\", string.Join(\",\", store));\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var v1 = new Vector(5, 7);\n            var v2 = new Vector(2, 3);\n            Console.WriteLine(v1 + v2);\n            Console.WriteLine(v1 - v2);\n            Console.WriteLine(v1 * 11);\n            Console.WriteLine(v1 / 2);\n            \n            var lostVector = new Vector(new double[] { 4, 8, 15, 16, 23, 42 });\n            Console.WriteLine(lostVector * 7);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 410245, "name": "Burrows\u2013Wheeler transform", "source": "Translate Haskell to C#: \n\n\n\n\n\nimport Data.List ((!!), find, sort, tails, transpose)\nimport Data.Maybe (fromJust)\nimport Text.Printf (printf)\n\nnewtype BWT a = BWT [Val a]\n\nbwt :: Ord a => [a] -> BWT a\nbwt xs = let n  = length xs + 2\n             ys = transpose $ sort $ take n $ tails $ cycle $ pos xs\n         in BWT $ ys !! (n-1)\n\ninvBwt :: Ord a => BWT a -> [a]\ninvBwt (BWT xs) = let ys = iterate step (map (const []) xs) !! length xs\n                  in unpos $ fromJust $ find ((== Post) . last) ys\n  where step = sort . zipWith (:) xs\n\n\ndata Val a = In a | Pre | Post deriving (Eq, Ord)\n\npos :: [a] -> [Val a]\npos xs = Pre : map In xs ++ [Post]\n\nunpos :: [Val a] -> [a]\nunpos xs = [x | In x <- xs]\n\n\nmain :: IO ()\nmain = mapM_ testBWT [ \"\", \"a\", \"BANANA\", \"dogwood\",\n                       \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                       \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\" ]\n\ntestBWT :: String -> IO ()\ntestBWT xs = let fwd = bwt xs\n                 inv = invBwt fwd\n             in printf \"%s\\n\\t%s\\n\\t%s\\n\" xs (pretty fwd) inv\n  where pretty (BWT ps) = map prettyVal ps\n        prettyVal (In c) = c\n        prettyVal Pre    = '^'\n        prettyVal Post   = '|'\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 410246, "name": "Burrows\u2013Wheeler transform", "source": "Translate Haskell to C#: \n\n\n\n\n\nimport Data.List ((!!), find, sort, tails, transpose)\nimport Data.Maybe (fromJust)\nimport Text.Printf (printf)\n\nnewtype BWT a = BWT [Val a]\n\nbwt :: Ord a => [a] -> BWT a\nbwt xs = let n  = length xs + 2\n             ys = transpose $ sort $ take n $ tails $ cycle $ pos xs\n         in BWT $ ys !! (n-1)\n\ninvBwt :: Ord a => BWT a -> [a]\ninvBwt (BWT xs) = let ys = iterate step (map (const []) xs) !! length xs\n                  in unpos $ fromJust $ find ((== Post) . last) ys\n  where step = sort . zipWith (:) xs\n\n\ndata Val a = In a | Pre | Post deriving (Eq, Ord)\n\npos :: [a] -> [Val a]\npos xs = Pre : map In xs ++ [Post]\n\nunpos :: [Val a] -> [a]\nunpos xs = [x | In x <- xs]\n\n\nmain :: IO ()\nmain = mapM_ testBWT [ \"\", \"a\", \"BANANA\", \"dogwood\",\n                       \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                       \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\" ]\n\ntestBWT :: String -> IO ()\ntestBWT xs = let fwd = bwt xs\n                 inv = invBwt fwd\n             in printf \"%s\\n\\t%s\\n\\t%s\\n\" xs (pretty fwd) inv\n  where pretty (BWT ps) = map prettyVal ps\n        prettyVal (In c) = c\n        prettyVal Pre    = '^'\n        prettyVal Post   = '|'\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace BurrowsWheeler {\n    class Program {\n        const char STX = (char)0x02;\n        const char ETX = (char)0x03;\n\n        private static void Rotate(ref char[] a) {\n            char t = a.Last();\n            for (int i = a.Length - 1; i > 0; --i) {\n                a[i] = a[i - 1];\n            }\n            a[0] = t;\n        }\n\n        \n        private static int Compare(string s1, string s2) {\n            for (int i = 0; i < s1.Length && i < s2.Length; ++i) {\n                if (s1[i] < s2[i]) {\n                    return -1;\n                }\n                if (s2[i] < s1[i]) {\n                    return 1;\n                }\n            }\n            if (s1.Length < s2.Length) {\n                return -1;\n            }\n            if (s2.Length < s1.Length) {\n                return 1;\n            }\n            return 0;\n        }\n\n        static string Bwt(string s) {\n            if (s.Any(a => a == STX || a == ETX)) {\n                throw new ArgumentException(\"Input can't contain STX or ETX\");\n            }\n            char[] ss = (STX + s + ETX).ToCharArray();\n            List<string> table = new List<string>();\n            for (int i = 0; i < ss.Length; ++i) {\n                table.Add(new string(ss));\n                Rotate(ref ss);\n            }\n            table.Sort(Compare);\n            return new string(table.Select(a => a.Last()).ToArray());\n        }\n\n        static string Ibwt(string r) {\n            int len = r.Length;\n            List<string> table = new List<string>(new string[len]);\n            for (int i = 0; i < len; ++i) {\n                for (int j = 0; j < len; ++j) {\n                    table[j] = r[j] + table[j];\n                }\n                table.Sort(Compare);\n            }\n            foreach (string row in table) {\n                if (row.Last() == ETX) {\n                    return row.Substring(1, len - 2);\n                }\n            }\n            return \"\";\n        }\n\n        static string MakePrintable(string s) {\n            return s.Replace(STX, '^').Replace(ETX, '|');\n        }\n\n        static void Main() {\n            string[] tests = new string[] {\n                \"banana\",\n                \"appellee\",\n                \"dogwood\",\n                \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\",\n                \"\\u0002ABC\\u0003\"\n            };\n\n            foreach (string test in tests) {\n                Console.WriteLine(MakePrintable(test));\n                Console.Write(\" --> \");\n\n                string t = \"\";\n                try {\n                    t = Bwt(test);\n                    Console.WriteLine(MakePrintable(t));\n                } catch (Exception e) {\n                    Console.WriteLine(\"ERROR: {0}\", e.Message);\n                }\n\n                string r = Ibwt(t);\n                Console.WriteLine(\" --> {0}\", r);\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 410247, "name": "Faulhaber's triangle", "source": "Translate Haskell to C#: import Data.Ratio (Ratio, denominator, numerator, (%))\n\n\n\nfaulhaber :: Int -> Rational -> Rational\nfaulhaber p n =\n  sum $\n    zipWith ((*) . (n ^)) [1 ..] (faulhaberTriangle !! p)\n\n\nfaulhaberTriangle :: [[Rational]]\nfaulhaberTriangle =\n  tail $\n    scanl\n      ( \\rs n ->\n          let xs = zipWith ((*) . (n %)) [2 ..] rs\n           in 1 - sum xs : xs\n      )\n      []\n      [0 ..]\n\n\n\nmain :: IO ()\nmain = do\n  let triangle = take 10 faulhaberTriangle\n      widths = maxWidths triangle\n  mapM_\n    putStrLn\n    [ unlines\n        ( (justifyRatio widths 8 ' ' =<<)\n            <$> triangle\n        ),\n      (show . numerator) (faulhaber 17 1000)\n    ]\n\n\n\njustifyRatio ::\n  (Int, Int) -> Int -> Char -> Rational -> String\njustifyRatio (wn, wd) n c nd =\n  go $\n    [numerator, denominator] <*> [nd]\n  where\n    \n    w = max n (wn + wd + 2)\n    go [num, den]\n      | 1 == den = center w c (show num)\n      | otherwise =\n        let (q, r) = quotRem (w - 1) 2\n         in concat\n              [ justifyRight q c (show num),\n                \"/\",\n                justifyLeft (q + r) c (show den)\n              ]\n\njustifyLeft :: Int -> a -> [a] -> [a]\njustifyLeft n c s = take n (s <> replicate n c)\n\njustifyRight :: Int -> a -> [a] -> [a]\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n\ncenter :: Int -> a -> [a] -> [a]\ncenter n c s =\n  let (q, r) = quotRem (n - length s) 2\n      pad = replicate q c\n   in concat [pad, s, pad, replicate r c]\n\nmaxWidths :: [[Rational]] -> (Int, Int)\nmaxWidths xss =\n  let widest f xs = maximum $ fmap (length . show . f) xs\n   in ((,) . widest numerator <*> widest denominator) $\n        concat xss\n", "target": "using System;\n\nnamespace FaulhabersTriangle {\n    internal class Frac {\n        private long num;\n        private long denom;\n\n        public static readonly Frac ZERO = new Frac(0, 1);\n        public static readonly Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) {\n                throw new ArgumentException(\"d must not be zero\");\n            }\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            }\n            else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.Abs(Gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        private static long Gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            return Gcd(b, a % b);\n        }\n\n        public static Frac operator -(Frac self) {\n            return new Frac(-self.num, self.denom);\n        }\n\n        public static Frac operator +(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);\n        }\n\n        public static Frac operator -(Frac lhs, Frac rhs) {\n            return lhs + -rhs;\n        }\n\n        public static Frac operator *(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);\n        }\n\n        public static bool operator <(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x < y;\n        }\n\n        public static bool operator >(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x > y;\n        }\n\n        public static bool operator ==(Frac lhs, Frac rhs) {\n            return lhs.num == rhs.num && lhs.denom == rhs.denom;\n        }\n\n        public static bool operator !=(Frac lhs, Frac rhs) {\n            return lhs.num != rhs.num || lhs.denom != rhs.denom;\n        }\n\n        public override string ToString() {\n            if (denom == 1) {\n                return num.ToString();\n            }\n            return string.Format(\"{0}/{1}\", num, denom);\n        }\n\n        public override bool Equals(object obj) {\n            var frac = obj as Frac;\n            return frac != null &&\n                   num == frac.num &&\n                   denom == frac.denom;\n        }\n\n        public override int GetHashCode() {\n            var hashCode = 1317992671;\n            hashCode = hashCode * -1521134295 + num.GetHashCode();\n            hashCode = hashCode * -1521134295 + denom.GetHashCode();\n            return hashCode;\n        }\n    }\n\n    class Program {\n        static Frac Bernoulli(int n) {\n            if (n < 0) {\n                throw new ArgumentException(\"n may not be negative or zero\");\n            }\n            Frac[] a = new Frac[n + 1];\n            for (int m = 0; m <= n; m++) {\n                a[m] = new Frac(1, m + 1);\n                for (int j = m; j >= 1; j--) {\n                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);\n                }\n            }\n            \n            if (n != 1) return a[0];\n            return -a[0];\n        }\n\n        static int Binomial(int n, int k) {\n            if (n < 0 || k < 0 || n < k) {\n                throw new ArgumentException();\n            }\n            if (n == 0 || k == 0) return 1;\n            int num = 1;\n            for (int i = k + 1; i <= n; i++) {\n                num = num * i;\n            }\n            int denom = 1;\n            for (int i = 2; i <= n - k; i++) {\n                denom = denom * i;\n            }\n            return num / denom;\n        }\n\n        static Frac[] FaulhaberTriangle(int p) {\n            Frac[] coeffs = new Frac[p + 1];\n            for (int i = 0; i < p + 1; i++) {\n                coeffs[i] = Frac.ZERO;\n            }\n            Frac q = new Frac(1, p + 1);\n            int sign = -1;\n            for (int j = 0; j <= p; j++) {\n                sign *= -1;\n                coeffs[p - j] = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);\n            }\n            return coeffs;\n        }\n\n        static void Main(string[] args) {\n            for (int i = 0; i < 10; i++) {\n                Frac[] coeffs = FaulhaberTriangle(i);\n                foreach (Frac coeff in coeffs) {\n                    Console.Write(\"{0,5}  \", coeff);\n                }\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 410248, "name": "Faulhaber's formula", "source": "Translate Haskell to C#: import Data.Ratio ((%), numerator, denominator)\nimport Data.List (intercalate, transpose)\nimport Data.Bifunctor (bimap)\nimport Data.Char (isSpace)\nimport Data.Monoid ((<>))\nimport Data.Bool (bool)\n \n\nfaulhaber :: [[Rational]]\nfaulhaber =\n  tail $\n  scanl\n    (\\rs n ->\n        let xs = zipWith ((*) . (n %)) [2 ..] rs\n        in 1 - sum xs : xs)\n    []\n    [0 ..]\n    \npolynomials :: [[(String, String)]]\npolynomials = fmap ((ratioPower =<<) . reverse . flip zip [1 ..]) faulhaber\n    \n\n\nmain :: IO ()\nmain = (putStrLn . unlines . expressionTable . take 10) polynomials\n\n \n\n\n\nexpressionTable :: [[(String, String)]] -> [String]\nexpressionTable ps =\n  let cols = transpose (fullTable ps)\n  in expressionRow <$>\n     zip\n       [0 ..]\n       (transpose $\n        zipWith\n          (\\(lw, rw) col ->\n              fmap (bimap (justifyLeft lw ' ') (justifyLeft rw ' ')) col)\n          (colWidths cols)\n          cols)\n          \n\nratioPower :: (Rational, Integer) -> [(String, String)]\nratioPower (nd, j) =\n  let (num, den) = ((,) . numerator <*> denominator) nd\n      sn\n        | num == 0 = []\n        | (j /= 1) = (\"n^\" <> show j)\n        | otherwise = \"n\"\n      sr\n        | num == 0 = []\n        | den == 1 && num == 1 = []\n        | den == 1 = show num <> \"n\"\n        | otherwise = intercalate \"/\" [show num, show den]\n      s = sr <> sn\n  in bool [(sn, sr)] [] (null s)\n \n\nfullTable :: [[(String, String)]] -> [[(String, String)]]\nfullTable xs =\n  let lng = maximum $ length <$> xs\n  in (<>) <*> (flip replicate ([], []) . (-) lng . length) <$> xs\n \njustifyLeft :: Int -> Char -> String -> String\njustifyLeft n c s = take n (s <> replicate n c)\n \n\nexpressionRow :: (Int, [(String, String)]) -> String\nexpressionRow (i, row) =\n  concat\n    [ show i\n    , \" ->  \"\n    , foldr\n        (\\s a -> concat [s, bool \" + \" \" \" (blank a || head a == '-'), a])\n        []\n        (polyTerm <$> row)\n    ]\n \n\npolyTerm :: (String, String) -> String\npolyTerm (l, r)\n  | blank l || blank r = l <> r\n  | head r == '-' = concat [\"- \", l, \" * \", tail r]\n  | otherwise = intercalate \" * \" [l, r]\n \nblank :: String -> Bool\nblank = all isSpace\n \n\ncolWidths :: [[(String, String)]] -> [(Int, Int)]\ncolWidths =\n  fmap\n    (foldr\n       (\\(ls, rs) (lMax, rMax) -> (max (length ls) lMax, max (length rs) rMax))\n       (0, 0))\n \n\nunsignedLength :: String -> Int\nunsignedLength xs =\n  let l = length xs\n  in bool (bool l (l - 1) ('-' == head xs)) 0 (0 == l)\n", "target": "using System;\n\nnamespace FaulhabersFormula {\n    internal class Frac {\n        private long num;\n        private long denom;\n\n        public static readonly Frac ZERO = new Frac(0, 1);\n        public static readonly Frac ONE = new Frac(1, 1);\n\n        public Frac(long n, long d) {\n            if (d == 0) {\n                throw new ArgumentException(\"d must not be zero\");\n            }\n            long nn = n;\n            long dd = d;\n            if (nn == 0) {\n                dd = 1;\n            }\n            else if (dd < 0) {\n                nn = -nn;\n                dd = -dd;\n            }\n            long g = Math.Abs(Gcd(nn, dd));\n            if (g > 1) {\n                nn /= g;\n                dd /= g;\n            }\n            num = nn;\n            denom = dd;\n        }\n\n        private static long Gcd(long a, long b) {\n            if (b == 0) {\n                return a;\n            }\n            return Gcd(b, a % b);\n        }\n\n        public static Frac operator -(Frac self) {\n            return new Frac(-self.num, self.denom);\n        }\n\n        public static Frac operator +(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.denom + lhs.denom * rhs.num, rhs.denom * lhs.denom);\n        }\n\n        public static Frac operator -(Frac lhs, Frac rhs) {\n            return lhs + -rhs;\n        }\n\n        public static Frac operator *(Frac lhs, Frac rhs) {\n            return new Frac(lhs.num * rhs.num, lhs.denom * rhs.denom);\n        }\n\n        public static bool operator <(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x < y;\n        }\n\n        public static bool operator >(Frac lhs, Frac rhs) {\n            double x = (double)lhs.num / lhs.denom;\n            double y = (double)rhs.num / rhs.denom;\n            return x > y;\n        }\n\n        public static bool operator ==(Frac lhs, Frac rhs) {\n            return lhs.num == rhs.num && lhs.denom == rhs.denom;\n        }\n\n        public static bool operator !=(Frac lhs, Frac rhs) {\n            return lhs.num != rhs.num || lhs.denom != rhs.denom;\n        }\n\n        public override string ToString() {\n            if (denom == 1) {\n                return num.ToString();\n            }\n            return string.Format(\"{0}/{1}\", num, denom);\n        }\n\n        public override bool Equals(object obj) {\n            var frac = obj as Frac;\n            return frac != null &&\n                   num == frac.num &&\n                   denom == frac.denom;\n        }\n\n        public override int GetHashCode() {\n            var hashCode = 1317992671;\n            hashCode = hashCode * -1521134295 + num.GetHashCode();\n            hashCode = hashCode * -1521134295 + denom.GetHashCode();\n            return hashCode;\n        }\n    }\n\n    class Program {\n        static Frac Bernoulli(int n) {\n            if (n < 0) {\n                throw new ArgumentException(\"n may not be negative or zero\");\n            }\n            Frac[] a = new Frac[n + 1];\n            for (int m = 0; m <= n; m++) {\n                a[m] = new Frac(1, m + 1);\n                for (int j = m; j >= 1; j--) {\n                    a[j - 1] = (a[j - 1] - a[j]) * new Frac(j, 1);\n                }\n            }\n            \n            if (n != 1) return a[0];\n            return -a[0];\n        }\n\n        static int Binomial(int n, int k) {\n            if (n < 0 || k < 0 || n < k) {\n                throw new ArgumentException();\n            }\n            if (n == 0 || k == 0) return 1;\n            int num = 1;\n            for (int i = k + 1; i <= n; i++) {\n                num = num * i;\n            }\n            int denom = 1;\n            for (int i = 2; i <= n - k; i++) {\n                denom = denom * i;\n            }\n            return num / denom;\n        }\n\n        static void Faulhaber(int p) {\n            Console.Write(\"{0}\u00a0: \", p);\n            Frac q = new Frac(1, p + 1);\n            int sign = -1;\n            for (int j = 0; j <= p; j++) {\n                sign *= -1;\n                Frac coeff = q * new Frac(sign, 1) * new Frac(Binomial(p + 1, j), 1) * Bernoulli(j);\n                if (Frac.ZERO == coeff) continue;\n                if (j == 0) {\n                    if (Frac.ONE != coeff) {\n                        if (-Frac.ONE == coeff) {\n                            Console.Write(\"-\");\n                        }\n                        else {\n                            Console.Write(coeff);\n                        }\n                    }\n                }\n                else {\n                    if (Frac.ONE == coeff) {\n                        Console.Write(\" + \");\n                    }\n                    else if (-Frac.ONE == coeff) {\n                        Console.Write(\" - \");\n                    }\n                    else if (Frac.ZERO < coeff) {\n                        Console.Write(\" + {0}\", coeff);\n                    }\n                    else {\n                        Console.Write(\" - {0}\", -coeff);\n                    }\n                }\n                int pwr = p + 1 - j;\n                if (pwr > 1) {\n                    Console.Write(\"n^{0}\", pwr);\n                }\n                else {\n                    Console.Write(\"n\");\n                }\n            }\n            Console.WriteLine();\n        }\n\n        static void Main(string[] args) {\n            for (int i = 0; i < 10; i++) {\n                Faulhaber(i);\n            }\n        }\n    }\n}\n"}
{"id": 410249, "name": "Prime conspiracy", "source": "Translate Haskell to C#: import Data.List (group, sort)\nimport Text.Printf (printf)\nimport Data.Numbers.Primes (primes)\n\nfreq :: [(Int, Int)] -> Float\nfreq xs = realToFrac (length xs) / 100\n\nline :: [(Int, Int)] -> IO ()\nline t@((n1, n2):xs) = printf \"%d -> %d count: %5d frequency: %2.2f\u00a0%%\\n\" n1 n2 (length t) (freq t) \n\nmain :: IO ()\nmain = mapM_ line $ groups primes\n  where groups = tail . group . sort . (\\n -> zip (0: n) n) . fmap (`mod` 10) . take 10000\n", "target": "using System;\n\nnamespace PrimeConspiracy {\n    class Program {\n        static void Main(string[] args) {\n            const int limit = 1_000_000;\n            const int sieveLimit = 15_500_000;\n\n            int[,] buckets = new int[10, 10];\n            int prevDigit = 2;\n            bool[] notPrime = Sieve(sieveLimit);\n\n            for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n                if (notPrime[n]) continue;\n\n                int digit = n % 10;\n                buckets[prevDigit, digit]++;\n                prevDigit = digit;\n                primeCount++;\n            }\n\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (buckets[i, j] != 0) {\n                        Console.WriteLine(\"{0} -> {1}  count: {2,5:d}  frequency\u00a0: {3,6:0.00%}\", i, j, buckets[i, j], 1.0 * buckets[i, j] / limit);\n                    }\n                }\n            }\n        }\n\n        public static bool[] Sieve(int limit) {\n            bool[] composite = new bool[limit];\n            composite[0] = composite[1] = true;\n\n            int max = (int)Math.Sqrt(limit);\n            for (int n = 2; n <= max; n++) {\n                if (!composite[n]) {\n                    for (int k = n * n; k < limit; k += n) {\n                        composite[k] = true;\n                    }\n                }\n            }\n\n            return composite;\n        }\n    }\n}\n"}
{"id": 410250, "name": "Imaginary base numbers", "source": "Translate Haskell to C#: import Data.Char (chr, digitToInt, intToDigit, isDigit, ord)\nimport Data.Complex (Complex (..), imagPart, realPart)\nimport Data.List (delete, elemIndex)\nimport Data.Maybe (fromMaybe)\n\nbase :: Complex Float\nbase = 0 :+ 2\n\nquotRemPositive :: Int -> Int -> (Int, Int)\nquotRemPositive a b\n  | r < 0 = (1 + q, floor (realPart (-base ^^ 2)) + r)\n  | otherwise = (q, r)\n  where\n    (q, r) = quotRem a b\n\ndigitToIntQI :: Char -> Int\ndigitToIntQI c\n  | isDigit c = digitToInt c\n  | otherwise = ord c - ord 'a' + 10\n\nshiftRight :: String -> String\nshiftRight n\n  | l == '0' = h\n  | otherwise = h <> ('.' : [l])\n  where\n    (l, h) = (last n, init n)\n\nintToDigitQI :: Int -> Char\nintToDigitQI i\n  | i `elem` [0 .. 9] = intToDigit i\n  | otherwise = chr (i - 10 + ord 'a')\n\nfromQItoComplex :: String -> Complex Float -> Complex Float\nfromQItoComplex num b =\n  let dot = fromMaybe (length num) (elemIndex '.' num)\n   in fst $\n        foldl\n          ( \\(a, indx) x ->\n              ( a + fromIntegral (digitToIntQI x)\n                  * (b ^^ (dot - indx)),\n                indx + 1\n              )\n          )\n          (0, 1)\n          (delete '.' num)\n\neuclidEr :: Int -> Int -> [Int] -> [Int]\neuclidEr a b l\n  | a == 0 = l\n  | otherwise =\n      let (q, r) = quotRemPositive a b\n       in euclidEr q b (0 : r : l)\n\nfromIntToQI :: Int -> [Int]\nfromIntToQI 0 = [0]\nfromIntToQI x =\n  tail\n    ( euclidEr\n        x\n        (floor $ realPart (base ^^ 2))\n        []\n    )\n\ngetCuid :: Complex Int -> Int\ngetCuid c = imagPart c * floor (imagPart (-base))\n\nqizip :: Complex Int -> [Int]\nqizip c =\n  let (r, i) =\n        ( fromIntToQI (realPart c) <> [0],\n          fromIntToQI (getCuid c)\n        )\n   in let m = min (length r) (length i)\n       in take (length r - m) r\n            <> take (length i - m) i\n            <> reverse\n              ( zipWith\n                  (+)\n                  (take m (reverse r))\n                  (take m (reverse i))\n              )\n\nfromComplexToQI :: Complex Int -> String\nfromComplexToQI = shiftRight . fmap intToDigitQI . qizip\n\nmain :: IO ()\nmain =\n  putStrLn (fromComplexToQI (35 :+ 23))\n    >> print (fromQItoComplex \"10.2\" base)\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\n\nnamespace ImaginaryBaseNumbers {\n    class Complex {\n        private double real, imag;\n\n        public Complex(int r, int i) {\n            real = r;\n            imag = i;\n        }\n\n        public Complex(double r, double i) {\n            real = r;\n            imag = i;\n        }\n\n        public static Complex operator -(Complex self) =>\n            new Complex(-self.real, -self.imag);\n\n        public static Complex operator +(Complex rhs, Complex lhs) =>\n            new Complex(rhs.real + lhs.real, rhs.imag + lhs.imag);\n\n        public static Complex operator -(Complex rhs, Complex lhs) =>\n            new Complex(rhs.real - lhs.real, rhs.imag - lhs.imag);\n\n        public static Complex operator *(Complex rhs, Complex lhs) =>\n            new Complex(\n                rhs.real * lhs.real - rhs.imag * lhs.imag,\n                rhs.real * lhs.imag + rhs.imag * lhs.real\n                );\n\n        public static Complex operator *(Complex rhs, double lhs) =>\n             new Complex(rhs.real * lhs, rhs.imag * lhs);\n\n        public static Complex operator /(Complex rhs, Complex lhs) =>\n            rhs * lhs.Inv();\n\n        public Complex Inv() {\n            double denom = real * real + imag * imag;\n            return new Complex(real / denom, -imag / denom);\n        }\n\n        public QuaterImaginary ToQuaterImaginary() {\n            if (real == 0.0 && imag == 0.0) return new QuaterImaginary(\"0\");\n            int re = (int)real;\n            int im = (int)imag;\n            int fi = -1;\n            StringBuilder sb = new StringBuilder();\n            while (re != 0) {\n                int rem = re % -4;\n                re /= -4;\n                if (rem < 0) {\n                    rem = 4 + rem;\n                    re++;\n                }\n                sb.Append(rem);\n                sb.Append(0);\n            }\n            if (im != 0) {\n                double f = (new Complex(0.0, imag) / new Complex(0.0, 2.0)).real;\n                im = (int)Math.Ceiling(f);\n                f = -4.0 * (f - im);\n                int index = 1;\n                while (im != 0) {\n                    int rem = im % -4;\n                    im /= -4;\n                    if (rem < 0) {\n                        rem = 4 + rem;\n                        im++;\n                    }\n                    if (index < sb.Length) {\n                        sb[index] = (char)(rem + 48);\n                    } else {\n                        sb.Append(0);\n                        sb.Append(rem);\n                    }\n                    index += 2;\n                }\n                fi = (int)f;\n            }\n            string reverse = new string(sb.ToString().Reverse().ToArray());\n            sb.Length = 0;\n            sb.Append(reverse);\n            if (fi != -1) sb.AppendFormat(\".{0}\", fi);\n            string s = sb.ToString().TrimStart('0');\n            if (s[0] == '.') s = \"0\" + s;\n            return new QuaterImaginary(s);\n        }\n\n        public override string ToString() {\n            double real2 = (real == -0.0) ? 0.0 : real;  \n            double imag2 = (imag == -0.0) ? 0.0 : imag;  \n            if (imag2 == 0.0) {\n                return string.Format(\"{0}\", real2);\n            }\n            if (real2 == 0.0) {\n                return string.Format(\"{0}i\", imag2);\n            }\n            if (imag2 > 0.0) {\n                return string.Format(\"{0} + {1}i\", real2, imag2);\n            }\n            return string.Format(\"{0} - {1}i\", real2, -imag2);\n        }\n    }\n\n    class QuaterImaginary {\n        internal static Complex twoI = new Complex(0.0, 2.0);\n        internal static Complex invTwoI = twoI.Inv();\n\n        private string b2i;\n\n        public QuaterImaginary(string b2i) {\n            if (b2i == \"\" || !b2i.All(c => \"0123.\".IndexOf(c) > -1) || b2i.Count(c => c == '.') > 1) {\n                throw new Exception(\"Invalid Base 2i number\");\n            }\n            this.b2i = b2i;\n        }\n\n        public Complex ToComplex() {\n            int pointPos = b2i.IndexOf(\".\");\n            int posLen = (pointPos != -1) ? pointPos : b2i.Length;\n            Complex sum = new Complex(0.0, 0.0);\n            Complex prod = new Complex(1.0, 0.0);\n            for (int j = 0; j < posLen; j++) {\n                double k = (b2i[posLen - 1 - j] - '0');\n                if (k > 0.0) {\n                    sum += prod * k;\n                }\n                prod *= twoI;\n            }\n            if (pointPos != -1) {\n                prod = invTwoI;\n                for (int j = posLen + 1; j < b2i.Length; j++) {\n                    double k = (b2i[j] - '0');\n                    if (k > 0.0) {\n                        sum += prod * k;\n                    }\n                    prod *= invTwoI;\n                }\n            }\n\n            return sum;\n        }\n\n        public override string ToString() {\n            return b2i;\n        }\n    }\n\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 1; i <= 16; i++) {\n                Complex c1 = new Complex(i, 0);\n                QuaterImaginary qi = c1.ToQuaterImaginary();\n                Complex c2 = qi.ToComplex();\n                Console.Write(\"{0,4} -> {1,8} -> {2,4}     \", c1, qi, c2);\n                c1 = -c1;\n                qi = c1.ToQuaterImaginary();\n                c2 = qi.ToComplex();\n                Console.WriteLine(\"{0,4} -> {1,8} -> {2,4}\", c1, qi, c2);\n            }\n            Console.WriteLine();\n            for (int i = 1; i <= 16; i++) {\n                Complex c1 = new Complex(0, i);\n                QuaterImaginary qi = c1.ToQuaterImaginary();\n                Complex c2 = qi.ToComplex();\n                Console.Write(\"{0,4} -> {1,8} -> {2,4}     \", c1, qi, c2);\n                c1 = -c1;\n                qi = c1.ToQuaterImaginary();\n                c2 = qi.ToComplex();\n                Console.WriteLine(\"{0,4} -> {1,8} -> {2,4}\", c1, qi, c2);\n            }\n        }\n    }\n}\n"}
{"id": 410251, "name": "Statistics_Normal distribution", "source": "Translate Haskell to C#: import Data.Map (Map, empty, insert, findWithDefault, toList)\nimport Data.Maybe (fromMaybe)\nimport Text.Printf (printf)\nimport Data.Function (on)\nimport Data.List (sort, maximumBy, minimumBy)\nimport Control.Monad.Random (RandomGen, Rand, evalRandIO, getRandomR)\nimport Control.Monad (replicateM)\n\n\ngetNorm :: RandomGen g => Rand g Double\ngetNorm = do\n    u0 <- getRandomR (0.0, 1.0) \n    u1 <- getRandomR (0.0, 1.0) \n    let r = sqrt $ (-2.0) * log u0\n        theta = 2.0 * pi * u1\n    return $ r * sin theta\n\nputInBin :: Double -> Map Int Int -> Double -> Map Int Int\nputInBin binWidth t v = \n    let bin = round (v / binWidth)\n        count = findWithDefault 0 bin t \n    in insert bin (count+1) t\n\nrunTest :: Int -> IO ()\nrunTest n = do\n    rs <- evalRandIO $ replicateM n getNorm \n    let binWidth = 0.1\n\n        tally v (sv, sv2, t) = (sv+v, sv2 + v*v, putInBin binWidth t v)\n\n        (sum, sum2, tallies) = foldr tally (0.0, 0.0, empty) rs\n\n        tallyList = sort $ toList tallies\n\n        printStars tallies binWidth maxCount selection = \n            let count = findWithDefault 0 selection tallies \n                bin = binWidth * fromIntegral selection\n                maxStars = 100\n                starCount = if maxCount <= maxStars\n                            then count \n                            else maxStars * count `div` maxCount\n                stars = replicate  starCount '*'\n            in printf \"%5.2f: %s  %d\\n\" bin stars count\n\n        mean = sum / fromIntegral n\n        stddev = sqrt (sum2/fromIntegral n - mean*mean)\n\n    printf \"\\n\"\n    printf \"sample count: %d\\n\" n\n    printf \"mean:         %9.7f\\n\" mean\n    printf \"stddev:       %9.7f\\n\" stddev\n\n    let maxCount = snd $ maximumBy (compare `on` snd) tallyList\n        maxBin = fst $ maximumBy (compare `on` fst) tallyList\n        minBin = fst $ minimumBy (compare `on` fst) tallyList\n\n    mapM_ (printStars tallies binWidth maxCount) [minBin..maxBin]\n\nmain = do\n    runTest 1000\n    runTest 2000000\n", "target": "using System;\nusing MathNet.Numerics.Distributions;\nusing MathNet.Numerics.Statistics;\n\nclass Program\n{\n    static void RunNormal(int sampleSize)\n    {\n        double[] X = new double[sampleSize];\n        var norm = new Normal(new Random());\n        norm.Samples(X);\n\n        const int numBuckets = 10;\n        var histogram = new Histogram(X, numBuckets);\n        Console.WriteLine(\"Sample size: {0:N0}\", sampleSize);\n        for (int i = 0; i < numBuckets; i++)\n        {\n            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));\n            Console.WriteLine(\" {0:0.00}\u00a0: {1}\", histogram[i].LowerBound, bar);\n        }\n        var statistics = new DescriptiveStatistics(X);\n        Console.WriteLine(\"  Mean: \" + statistics.Mean);\n        Console.WriteLine(\"StdDev: \" + statistics.StandardDeviation);\n        Console.WriteLine();\n    }\n    static void Main(string[] args)\n    {\n        RunNormal(100);\n        RunNormal(1000);\n        RunNormal(10000);\n    }\n}\n"}
{"id": 410252, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Haskell to C#: import Data.Bifunctor (bimap)\nimport Data.List (find)\nimport Data.Maybe (isJust)\n\n\n\nb10 :: Integral a => a -> Integer\nb10 n = read (digitMatch rems sums) :: Integer\n  where\n    (_, rems, _, Just (_, sums)) =\n      until\n        (\\(_, _, _, mb) -> isJust mb)\n        ( \\(e, rems, ms, _) ->\n            let m = rem (10 ^ e) n\n                newSums =\n                  (m, [m]) :\n                  fmap (bimap (m +) (m :)) ms\n             in ( succ e,\n                  m : rems,\n                  ms <> newSums,\n                  find\n                    ( (0 ==) . flip rem n . fst\n                    )\n                    newSums\n                )\n        )\n        (0, [], [], Nothing)\n\ndigitMatch :: Eq a => [a] -> [a] -> String\ndigitMatch [] _ = []\ndigitMatch xs [] = '0' <$ xs\ndigitMatch (x : xs) yys@(y : ys)\n  | x /= y = '0' : digitMatch xs yys\n  | otherwise = '1' : digitMatch xs ys\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( putStrLn\n        . ( \\x ->\n              let b = b10 x\n               in justifyRight 5 ' ' (show x)\n                    <> \" * \"\n                    <> justifyLeft 25 ' ' (show $ div b x)\n                    <> \" -> \"\n                    <> show b\n          )\n    )\n    ( [1 .. 10]\n        <> [95 .. 105]\n        <> [297, 576, 594, 891, 909, 999]\n    )\n\njustifyLeft, justifyRight :: Int -> a -> [a] -> [a]\njustifyLeft n c s = take n (s <> replicate n c)\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "using System;\nusing System.Collections.Generic;\nusing static System.Console;\n \nclass Program {\n \n  static string B10(int n) {\n    int[] pow = new int[n + 1], val = new int[29];\n    for (int count = 0, ten = 1, x = 1; x <= n; x++) {\n      val[x] = ten;\n      for (int j = 0, t; j <= n; j++)\n        if (pow[j] != 0 && pow[j] != x && pow[t = (j + ten) % n] == 0)\n          pow[t] = x;\n      if (pow[ten] == 0) pow[ten] = x;\n      ten = (10 * ten) % n;\n      if (pow[0] != 0) {\n        x = n;\n        string s = \"\"; \n        while (x != 0) {\n          int p = pow[x % n];\n          if (count > p) s += new string('0', count - p);\n          count = p - 1;\n          s += \"1\";\n          x = (n + x - val[p]) % n;\n        }\n        if (count > 0) s += new string('0', count);\n        return s;\n      }\n    } \n    return \"1\";\n  }\n \n  static void Main(string[] args) {\n    string fmt = \"{0,4} * {1,24} = {2,-28}\\n\";\n    int[] m = new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10,\n      95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105,\n      297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878 };\n    string[] r = new string[m.Length]; \n    WriteLine(fmt + new string('-', 62), \"n\", \"multiplier\", \"B10\");\n    var sw = System.Diagnostics.Stopwatch.StartNew();\n    for (int i = 0; i < m.Length; i++) r[i] = B10(m[i]);\n    sw.Stop();\n    for (int i = 0; i < m.Length; i++) Write(fmt, m[i], decimal.Parse(r[i]) / m[i], r[i]);\n    Write(\"\\nTook {0}ms\", sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 410253, "name": "Weird numbers", "source": "Translate Haskell to C#: weirds :: [Int]\nweirds = filter abundantNotSemiperfect [1 ..]\n\nabundantNotSemiperfect :: Int -> Bool\nabundantNotSemiperfect n =\n  let ds = descProperDivisors n\n      d = sum ds - n\n  in 0 < d && not (hasSum d ds)\n\nhasSum :: Int -> [Int] -> Bool\nhasSum _ [] = False\nhasSum n (x:xs)\n  | n < x = hasSum n xs\n  | otherwise = (n == x) || hasSum (n - x) xs || hasSum n xs\n\ndescProperDivisors\n  :: Integral a\n  => a -> [a]\ndescProperDivisors n =\n  let root = (floor . sqrt) (fromIntegral n :: Double)\n      lows = filter ((0 ==) . rem n) [root,root - 1 .. 1]\n      factors\n        | n == root ^ 2 = tail lows \n        | otherwise = lows\n  in tail $ reverse (quot n <$> lows) ++ factors\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n  zipWith (\\i x -> show i ++ (\" -> \" ++ show x)) [1 ..] (take 25 weirds)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace WeirdNumbers {\n    class Program {\n        static List<int> Divisors(int n) {\n            List<int> divs = new List<int> { 1 };\n            List<int> divs2 = new List<int>();\n\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs2.Add(j);\n                    }\n                }\n            }\n\n            divs.Reverse();\n            divs2.AddRange(divs);\n            return divs2;\n        }\n\n        static bool Abundant(int n, List<int> divs) {\n            return divs.Sum() > n;\n        }\n\n        static bool Semiperfect(int n, List<int> divs) {\n            if (divs.Count > 0) {\n                var h = divs[0];\n                var t = divs.Skip(1).ToList();\n                if (n < h) {\n                    return Semiperfect(n, t);\n                } else {\n                    return n == h\n                        || Semiperfect(n - h, t)\n                        || Semiperfect(n, t);\n                }\n            } else {\n                return false;\n            }\n        }\n\n        static List<bool> Sieve(int limit) {\n            \n            \n            bool[] w = new bool[limit];\n            for (int i = 2; i < limit; i += 2) {\n                if (w[i]) continue;\n                var divs = Divisors(i);\n                if (!Abundant(i, divs)) {\n                    w[i] = true;\n                } else if (Semiperfect(i, divs)) {\n                    for (int j = i; j < limit; j += i) {\n                        w[j] = true;\n                    }\n                }\n            }\n            return w.ToList();\n        }\n\n        static void Main() {\n            var w = Sieve(17_000);\n            int count = 0;\n            int max = 25;\n            Console.WriteLine(\"The first 25 weird numbers:\");\n            for (int n = 2; count < max; n += 2) {\n                if (!w[n]) {\n                    Console.Write(\"{0} \", n);\n                    count++;\n                }\n            }\n            Console.WriteLine();\n        }\n    }\n}\n"}
{"id": 410254, "name": "Addition chains", "source": "Translate Haskell to C#: import Data.List (union)\n\n\ntotal [] = []\ntotal (x:xs) = brauer (x:xs) `union` total xs\n\nbrauer [] = []\nbrauer (x:xs) = map (+ x) (x:xs)\n\n\nchains _ 1 = [[1]]\nchains sums n = go [[1]]\n  where\n    go ch = let next = ch >>= step\n                complete = filter ((== n) . head) next\n            in if null complete then go next else complete\n\n    step ch = (: ch) <$> filter (\\s -> s > head ch && s <= n) (sums ch)\n\n\nisBrauer [_] = True\nisBrauer [_,_] = True\nisBrauer (x:y:xs) = (x - y) `elem` (y:xs) && isBrauer (y:xs)\n", "target": "using System;\n\nnamespace AdditionChains {\n    class Program {\n        static int[] Prepend(int n, int[] seq) {\n            int[] result = new int[seq.Length + 1];\n            Array.Copy(seq, 0, result, 1, seq.Length);\n            result[0] = n;\n            return result;\n        }\n\n        static Tuple<int, int> CheckSeq(int pos, int[] seq, int n, int min_len) {\n            if (pos > min_len || seq[0] > n) return new Tuple<int, int>(min_len, 0);\n            if (seq[0] == n) return new Tuple<int, int>(pos, 1);\n            if (pos < min_len) return TryPerm(0, pos, seq, n, min_len);\n            return new Tuple<int, int>(min_len, 0);\n        }\n\n        static Tuple<int, int> TryPerm(int i, int pos, int[] seq, int n, int min_len) {\n            if (i > pos) return new Tuple<int, int>(min_len, 0);\n\n            Tuple<int, int> res1 = CheckSeq(pos + 1, Prepend(seq[0] + seq[i], seq), n, min_len);\n            Tuple<int, int> res2 = TryPerm(i + 1, pos, seq, n, res1.Item1);\n\n            if (res2.Item1 < res1.Item1) return res2;\n            if (res2.Item1 == res1.Item1) return new Tuple<int, int>(res2.Item1, res1.Item2 + res2.Item2);\n\n            throw new Exception(\"TryPerm exception\");\n        }\n\n        static Tuple<int, int> InitTryPerm(int x) {\n            return TryPerm(0, 0, new int[] { 1 }, x, 12);\n        }\n\n        static void FindBrauer(int num) {\n            Tuple<int, int> res = InitTryPerm(num);\n            Console.WriteLine();\n            Console.WriteLine(\"N = {0}\", num);\n            Console.WriteLine(\"Minimum length of chains: L(n)= {0}\", res.Item1);\n            Console.WriteLine(\"Number of minimum length Brauer chains: {0}\", res.Item2);\n        }\n\n        static void Main(string[] args) {\n            int[] nums = new int[] { 7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379 };\n            Array.ForEach(nums, n => FindBrauer(n));\n        }\n    }\n}\n"}
{"id": 410255, "name": "Sokoban", "source": "Translate Haskell to C#: import Control.Monad (liftM)\nimport Data.Array\nimport Data.List (transpose)\nimport Data.Maybe (mapMaybe)\nimport qualified Data.Sequence as Seq\nimport qualified Data.Set as Set\nimport Prelude hiding (Left, Right)\n\ndata Field = Space | Wall | Goal\n           deriving (Eq)\n\ndata Action = Up | Down | Left | Right | PushUp | PushDown | PushLeft | PushRight\n\ninstance Show Action where\n  show Up        = \"u\"\n  show Down      = \"d\"\n  show Left      = \"l\"\n  show Right     = \"r\"\n  show PushUp    = \"U\"\n  show PushDown  = \"D\"\n  show PushLeft  = \"L\"\n  show PushRight = \"R\"\n\ntype Index = (Int, Int)\ntype FieldArray = Array Index Field\ntype BoxArray = Array Index Bool\ntype PlayerPos = Index\ntype GameState = (BoxArray, PlayerPos)\ntype Game = (FieldArray, GameState)\n\ntoField :: Char -> Field\ntoField '#' = Wall\ntoField ' ' = Space\ntoField '@' = Space\ntoField '$' = Space\ntoField '.' = Goal\ntoField '+' = Goal\ntoField '*' = Goal\n\ntoPush :: Action -> Action\ntoPush Up    = PushUp\ntoPush Down  = PushDown\ntoPush Left  = PushLeft\ntoPush Right = PushRight\ntoPush n     = n\n\ntoMove :: Action -> Index\ntoMove PushUp    = ( 0, -1)\ntoMove PushDown  = ( 0,  1)\ntoMove PushLeft  = (-1,  0)\ntoMove PushRight = ( 1,  0)\ntoMove n = toMove $ toPush n\n\n\n\nparseGame :: [String] -> Game\nparseGame fieldStrs = (field, (boxes, player))\n  where\n    width     = length $ head fieldStrs\n    height    = length fieldStrs\n    bound     = ((0, 0), (width - 1, height - 1))\n    flatField = concat $ transpose fieldStrs\n    charField = listArray bound flatField\n    field     = fmap toField charField\n    boxes     = fmap (`elem` \"$*\") charField\n    player    = fst $ head $ filter (flip elem \"@+\" . snd) $ assocs charField\n\nadd :: (Num a, Num b) => (a, b) -> (a, b) -> (a, b)\nadd (a, b) (x, y) = (a + x, b + y)\n\n\n\ntryAction :: Game -> Action -> Maybe (Game, Action)\ntryAction (field, (boxes, player)) action\n  | field ! vec == Wall = Nothing\n  | boxes ! vec =\n     if boxes ! vecB || field ! vecB == Wall\n     then Nothing\n     else Just ((field, (boxes // [(vec, False), (vecB, True)], vec)),\n               toPush action)\n  | otherwise = Just ((field, (boxes, vec)), action)\n  where\n    actionVec = toMove action\n    vec       = player `add` actionVec\n    vecB      = vec `add` actionVec\n\n\nsolveGame :: Game -> Maybe [Action]\nsolveGame (field, initState) =\n  liftM reverse $ bfs (Seq.singleton (initState, [])) (Set.singleton initState)\n  where\n    goals           = map fst $ filter ((== Goal) . snd) $ assocs field\n    isSolved st     = all (st !) goals\n    possibleActions = [Up, Down, Left, Right]\n    \n    \n    bfs :: Seq.Seq (GameState, [Action]) -> Set.Set GameState -> Maybe [Action]\n    bfs queue visited =\n      case Seq.viewl queue of\n        Seq.EmptyL -> Nothing\n        (game@(boxes, _), actions) Seq.:< queueB ->\n          if isSolved boxes\n          then Just actions\n          else\n            let newMoves = filter (flip Set.notMember visited . fst) $\n                           map (\\((_, g), a) -> (g, a)) $\n                           mapMaybe (tryAction (field, game)) possibleActions\n                visitedB = foldl (flip Set.insert) visited $\n                           map fst newMoves\n                queueC   = foldl (Seq.|>) queueB $\n                           map (\\(g, a) -> (g, a:actions)) newMoves\n            in bfs queueC visitedB\n\nexampleA :: [String]\nexampleA =\n  [\"#######\"\n  ,\"#     #\"\n  ,\"#     #\"\n  ,\"#. #  #\"\n  ,\"#. $$ #\"\n  ,\"#.$$  #\"\n  ,\"#.#  @#\"\n  ,\"#######\"]\n\nmain :: IO ()\nmain =\n  case solveGame $ parseGame exampleA of\n    Nothing       -> putStrLn \"Unsolvable\"\n    Just solution -> do\n      mapM_ putStrLn exampleA\n      putStrLn \"\"\n      putStrLn $ concatMap show solution\n", "target": "using System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace SokobanSolver\n{\n    public class SokobanSolver\n    {\n        private class Board\n        {\n            public string Cur { get; internal set; }\n            public string Sol { get; internal set; }\n            public int X { get; internal set; }\n            public int Y { get; internal set; }\n\n            public Board(string cur, string sol, int x, int y)\n            {\n                Cur = cur;\n                Sol = sol;\n                X = x;\n                Y = y;\n            }\n        }\n\n        private string destBoard, currBoard;\n        private int playerX, playerY, nCols;\n\n        SokobanSolver(string[] board)\n        {\n            nCols = board[0].Length;\n            StringBuilder destBuf = new StringBuilder();\n            StringBuilder currBuf = new StringBuilder();\n\n            for (int r = 0; r < board.Length; r++)\n            {\n                for (int c = 0; c < nCols; c++)\n                {\n\n                    char ch = board[r][c];\n\n                    destBuf.Append(ch != '$' && ch != '@' ? ch : ' ');\n                    currBuf.Append(ch != '.' ? ch : ' ');\n\n                    if (ch == '@')\n                    {\n                        this.playerX = c;\n                        this.playerY = r;\n                    }\n                }\n            }\n            destBoard = destBuf.ToString();\n            currBoard = currBuf.ToString();\n        }\n\n        private string Move(int x, int y, int dx, int dy, string trialBoard)\n        {\n\n            int newPlayerPos = (y + dy) * nCols + x + dx;\n\n            if (trialBoard[newPlayerPos] != ' ')\n                return null;\n\n            char[] trial = trialBoard.ToCharArray();\n            trial[y * nCols + x] = ' ';\n            trial[newPlayerPos] = '@';\n\n            return new string(trial);\n        }\n\n        private string Push(int x, int y, int dx, int dy, string trialBoard)\n        {\n\n            int newBoxPos = (y + 2 * dy) * nCols + x + 2 * dx;\n\n            if (trialBoard[newBoxPos] != ' ')\n                return null;\n\n            char[] trial = trialBoard.ToCharArray();\n            trial[y * nCols + x] = ' ';\n            trial[(y + dy) * nCols + x + dx] = '@';\n            trial[newBoxPos] = '$';\n\n            return new string(trial);\n        }\n\n        private bool IsSolved(string trialBoard)\n        {\n            for (int i = 0; i < trialBoard.Length; i++)\n                if ((destBoard[i] == '.')\n                        != (trialBoard[i] == '$'))\n                    return false;\n            return true;\n        }\n\n        private string Solve()\n        {\n            char[,] dirLabels = { { 'u', 'U' }, { 'r', 'R' }, { 'd', 'D' }, { 'l', 'L' } };\n            int[,] dirs = { { 0, -1 }, { 1, 0 }, { 0, 1 }, { -1, 0 } };\n            ISet<string> history = new HashSet<string>();\n            LinkedList<Board> open = new LinkedList<Board>();\n\n            history.Add(currBoard);\n            open.AddLast(new Board(currBoard, string.Empty, playerX, playerY));\n\n            while (!open.Count.Equals(0))\n            {\n                Board item = open.First();\n                open.RemoveFirst();\n                string cur = item.Cur;\n                string sol = item.Sol;\n                int x = item.X;\n                int y = item.Y;\n\n                for (int i = 0; i < dirs.GetLength(0); i++)\n                {\n                    string trial = cur;\n                    int dx = dirs[i, 0];\n                    int dy = dirs[i, 1];\n\n                    \n                    if (trial[(y + dy) * nCols + x + dx] == '$')\n                    {\n                        \n                        if ((trial = Push(x, y, dx, dy, trial)) != null)\n                        {\n                            \n                            if (!history.Contains(trial))\n                            {\n\n                                string newSol = sol + dirLabels[i, 1];\n\n                                if (IsSolved(trial))\n                                    return newSol;\n\n                                open.AddLast(new Board(trial, newSol, x + dx, y + dy));\n                                history.Add(trial);\n                            }\n                        }\n                        \n                    }\n                    else if ((trial = Move(x, y, dx, dy, trial)) != null)\n                    {\n                        if (!history.Contains(trial))\n                        {\n                            string newSol = sol + dirLabels[i, 0];\n                            open.AddLast(new Board(trial, newSol, x + dx, y + dy));\n                            history.Add(trial);\n                        }\n                    }\n                }\n            }\n            return \"No solution\";\n        }\n\n        public static void Main(string[] a)\n        {\n            string level = \"#######,\" +\n                           \"#     #,\" +\n                           \"#     #,\" +\n                           \"#. #  #,\" +\n                           \"#. $$ #,\" +\n                           \"#.$$  #,\" +\n                           \"#.#  @#,\" +\n                           \"#######\";\n            System.Console.WriteLine(\"Level:\\n\");\n            foreach (string line in level.Split(','))\n            {\n                System.Console.WriteLine(line);\n            }\n            System.Console.WriteLine(\"\\nSolution:\\n\");\n            System.Console.WriteLine(new SokobanSolver(level.Split(',')).Solve());\n        }\n    }\n}\n"}
{"id": 410256, "name": "Zumkeller numbers", "source": "Translate Haskell to C#: import Data.List (group, sort)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primeFactors)\n\n\n\nisZumkeller :: Int -> Bool\nisZumkeller n =\n  let ds = divisors n\n      m = sum ds\n   in ( even m\n          && let half = div m 2\n              in elem half ds\n                   || ( all (half >=) ds\n                          && summable half ds\n                      )\n      )\n\nsummable :: Int -> [Int] -> Bool\nsummable _ [] = False\nsummable x xs@(h : t) =\n  elem x xs\n    || summable (x - h) t\n    || summable x t\n\ndivisors :: Int -> [Int]\ndivisors x =\n  sort\n    ( foldr\n        ( flip ((<*>) . fmap (*))\n            . scanl (*) 1\n        )\n        [1]\n        (group (primeFactors x))\n    )\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( \\(s, n, xs) ->\n        putStrLn $\n          s\n            <> ( '\\n' :\n                 tabulated\n                   10\n                   (take n (filter isZumkeller xs))\n               )\n    )\n    [ (\"First 220 Zumkeller numbers:\", 220, [1 ..]),\n      (\"First 40 odd Zumkeller numbers:\", 40, [1, 3 ..])\n    ]\n\n\ntabulated ::\n  Show a =>\n  Int ->\n  [a] ->\n  String\ntabulated nCols = go\n  where\n    go xs =\n      let ts = show <$> xs\n          w = succ (maximum (length <$> ts))\n       in unlines\n            ( concat\n                <$> chunksOf\n                  nCols\n                  (justifyRight w ' ' <$> ts)\n            )\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace ZumkellerNumbers {\n    class Program {\n        static List<int> GetDivisors(int n) {\n            List<int> divs = new List<int> {\n                1, n\n            };\n            for (int i = 2; i * i <= n; i++) {\n                if (n % i == 0) {\n                    int j = n / i;\n                    divs.Add(i);\n                    if (i != j) {\n                        divs.Add(j);\n                    }\n                }\n            }\n            return divs;\n        }\n\n        static bool IsPartSum(List<int> divs, int sum) {\n            if (sum == 0) {\n                return true;\n            }\n            var le = divs.Count;\n            if (le == 0) {\n                return false;\n            }\n            var last = divs[le - 1];\n            List<int> newDivs = new List<int>();\n            for (int i = 0; i < le - 1; i++) {\n                newDivs.Add(divs[i]);\n            }\n            if (last > sum) {\n                return IsPartSum(newDivs, sum);\n            }\n            return IsPartSum(newDivs, sum) || IsPartSum(newDivs, sum - last);\n        }\n\n        static bool IsZumkeller(int n) {\n            var divs = GetDivisors(n);\n            var sum = divs.Sum();\n            \n            if (sum % 2 == 1) {\n                return false;\n            }\n            \n            if (n % 2 == 1) {\n                var abundance = sum - 2 * n;\n                return abundance > 0 && abundance % 2 == 0;\n            }\n            \n            return IsPartSum(divs, sum / 2);\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The first 220 Zumkeller numbers are:\");\n            int i = 2;\n            for (int count = 0; count < 220; i++) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,3} \", i);\n                    count++;\n                    if (count % 20 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (IsZumkeller(i)) {\n                    Console.Write(\"{0,5} \", i);\n                    count++;\n                    if (count % 10 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n\n            Console.WriteLine(\"\\nThe first 40 odd Zumkeller numbers which don't end in 5 are:\");\n            i = 3;\n            for (int count = 0; count < 40; i += 2) {\n                if (i % 10 != 5 && IsZumkeller(i)) {\n                    Console.Write(\"{0,7} \", i);\n                    count++;\n                    if (count % 8 == 0) {\n                        Console.WriteLine();\n                    }\n                }\n            }\n        }\n    }\n}\n"}
{"id": 410257, "name": "Commatizing numbers", "source": "Translate Haskell to C#: #!/usr/bin/env runhaskell\n\nimport Control.Monad (forM_)\nimport Data.Char (isDigit)\nimport Data.List (intercalate)\nimport Data.Maybe (fromMaybe)\n\n\n\nisDigitOrPeriod :: Char -> Bool\nisDigitOrPeriod '.' = True\nisDigitOrPeriod c = isDigit c\n\nchopUp :: Int -> String -> [String]\nchopUp _ [] = []\nchopUp by str\n  | by < 1 = [str]              \n  | otherwise = let (pfx, sfx) = splitAt by str\n                in pfx : chopUp by sfx\n\naddSeps :: String -> Char -> Int -> (String -> String) -> String\naddSeps str sep by rev =\n  let (leading, number) = span (== '0') str\n      number2 = rev $ intercalate [sep] $ chopUp by $ rev number\n  in leading ++ number2\n\nprocessNumber :: String -> Char -> Int -> String\nprocessNumber str sep by =\n  let (beforeDecimal, rest) = span isDigit str\n      (decimal, afterDecimal) = splitAt 1 rest\n      beforeDecimal2 = addSeps beforeDecimal sep by reverse\n      afterDecimal2 = addSeps afterDecimal sep by id\n  in beforeDecimal2 ++ decimal ++ afterDecimal2\n\ncommatize2 :: String -> Char -> Int -> String\ncommatize2 [] _ _ = []\ncommatize2 str sep by =\n  let (pfx, sfx) = break isDigitOrPeriod str\n      (number, sfx2) = span isDigitOrPeriod sfx\n  in pfx ++ processNumber number sep by ++ sfx2\n\ncommatize :: String -> Maybe Char -> Maybe Int -> String\ncommatize str sep by = commatize2 str (fromMaybe ',' sep) (fromMaybe 3 by)\n\ninput :: [(String, Maybe Char, Maybe Int)]\ninput =\n  [ (\"pi=3.14159265358979323846264338327950288419716939937510582097494459231\", Just ' ', Just 5)\n  , (\"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\", Just '.', Nothing)\n  , (\"\\\"-in Aus$+1411.8millions\\\"\", Nothing, Nothing)\n  , (\"===US$0017440 millions=== (in 2000 dollars)\", Nothing, Nothing)\n  , (\"123.e8000 is pretty big.\", Nothing, Nothing)\n  , (\"The land area of the earth is 57268900(29% of the surface) square miles.\", Nothing, Nothing)\n  , (\"Ain't no numbers in this here words, nohow, no way, Jose.\", Nothing, Nothing)\n  , (\"James was never known as 0000000007\", Nothing, Nothing)\n  , (\"Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.\", Nothing, Nothing)\n  , (\"   $-140000\u00b1100 millions.\", Nothing, Nothing)\n  , (\"6/9/1946 was a good year for some.\", Nothing, Nothing)\n  ]\n\nmain :: IO ()\nmain =\n  forM_ input $ \\(str, by, sep) -> do\n    putStrLn str\n    putStrLn $ commatize str by sep\n    putStrLn \"\"\n", "target": "static string[] inputs = {\n\t\"pi=3.14159265358979323846264338327950288419716939937510582097494459231\",\n\t\"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\",\n\t\"\\\"-in Aus$+1411.8millions\\\"\",\n\t\"===US$0017440 millions=== (in 2000 dollars)\"\n};\n\nvoid Main()\n{\n\tinputs.Select(s => Commatize(s, 0, 3, \",\"))\n              .ToList()\n              .ForEach(Console.WriteLine);\n}\n\nstring Commatize(string text, int startPosition, int interval, string separator)\n{\n\tvar matches = Regex.Matches(text.Substring(startPosition), \"[0-9]*\");\n\tvar x = matches.Cast<Match>().Select(match => Commatize(match, interval, separator, text)).ToList();\n\treturn string.Join(\"\", x);\n}\n\n\nstring Commatize(Match match, int interval, string separator, string original)\n{\n\tif (match.Length <= interval)\n\t\treturn original.Substring(match.Index, \n                match.Index == original.Length ? 0 : Math.Max(match.Length, 1));\n\t\n\treturn string.Join(separator, match.Value.Split(interval));\n}\n\npublic static class Extension\n{\n\tpublic static string[] Split(this string source, int interval)\n\t{\n\t\treturn SplitImpl(source, interval).ToArray();\n\t}\n\t\n\tstatic IEnumerable<string>SplitImpl(string source, int interval)\n\t{\n\t\tfor\t(int i = 1; i < source.Length; i++)\n\t\t{\n\t\t\tif (i % interval != 0) continue;\n\t\t\t\n\t\t\tyield return source.Substring(i - interval, interval);\n\t\t}\n\t}\n}\n"}
{"id": 410258, "name": "Base58Check encoding", "source": "Translate Haskell to C#: import Numeric (showIntAtBase)\n\nchars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58Encode :: Integer -> String\nbase58Encode n = showIntAtBase 58 (chars !!) n \"\"\n\nmain :: IO ()\nmain = mapM_ (putStrLn . base58Encode)\n        [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Text;\n\nnamespace Base58CheckEncoding {\n    class Program {\n        const string ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        static BigInteger ToBigInteger(string value, int @base) {\n            const string HEX = \"0123456789ABCDEF\";\n            if (@base < 1 || @base > HEX.Length) {\n                throw new ArgumentException(\"Base is out of range.\");\n            }\n\n            BigInteger bi = BigInteger.Zero;\n            foreach (char c in value) {\n                char c2 = Char.ToUpper(c);\n                int idx = HEX.IndexOf(c2);\n                if (idx == -1 || idx >= @base) {\n                    throw new ArgumentOutOfRangeException(\"Illegal character encountered.\");\n                }\n                bi = bi * @base + idx;\n            }\n\n            return bi;\n        }\n\n        static string ConvertToBase58(string hash, int @base = 16) {\n            BigInteger x;\n            if (@base == 16 && hash.Substring(0, 2) == \"0x\") {\n                x = ToBigInteger(hash.Substring(2), @base);\n            } else {\n                x = ToBigInteger(hash, @base);\n            }\n\n            StringBuilder sb = new StringBuilder();\n            while (x > 0) {\n                BigInteger r = x % 58;\n                sb.Append(ALPHABET[(int)r]);\n                x = x / 58;\n            }\n\n            char[] ca = sb.ToString().ToCharArray();\n            Array.Reverse(ca);\n            return new string(ca);\n        }\n\n        static void Main(string[] args) {\n            string s = \"25420294593250030202636073700053352635053786165627414518\";\n            string b = ConvertToBase58(s, 10);\n            Console.WriteLine(\"{0} -> {1}\", s, b);\n\n            List<string> hashes = new List<string>() {\n                \"0x61\",\n                \"0x626262\",\n                \"0x636363\",\n                \"0x73696d706c792061206c6f6e6720737472696e67\",\n                \"0x516b6fcd0f\",\n                \"0xbf4f89001e670274dd\",\n                \"0x572e4794\",\n                \"0xecac89cad93923c02321\",\n                \"0x10c8511e\",\n            };\n            foreach (string hash in hashes) {\n                string b58 = ConvertToBase58(hash);\n                Console.WriteLine(\"{0,-56} -> {1}\", hash, b58);\n            }\n        }\n    }\n}\n"}
{"id": 410259, "name": "Base58Check encoding", "source": "Translate Haskell to C#: import Numeric (showIntAtBase)\n\nchars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58Encode :: Integer -> String\nbase58Encode n = showIntAtBase 58 (chars !!) n \"\"\n\nmain :: IO ()\nmain = mapM_ (putStrLn . base58Encode)\n        [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Numerics;\nusing System.Text;\n\nnamespace Base58CheckEncoding {\n    class Program {\n        const string ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n\n        static BigInteger ToBigInteger(string value, int @base) {\n            const string HEX = \"0123456789ABCDEF\";\n            if (@base < 1 || @base > HEX.Length) {\n                throw new ArgumentException(\"Base is out of range.\");\n            }\n\n            BigInteger bi = BigInteger.Zero;\n            foreach (char c in value) {\n                char c2 = Char.ToUpper(c);\n                int idx = HEX.IndexOf(c2);\n                if (idx == -1 || idx >= @base) {\n                    throw new ArgumentOutOfRangeException(\"Illegal character encountered.\");\n                }\n                bi = bi * @base + idx;\n            }\n\n            return bi;\n        }\n\n        static string ConvertToBase58(string hash, int @base = 16) {\n            BigInteger x;\n            if (@base == 16 && hash.Substring(0, 2) == \"0x\") {\n                x = ToBigInteger(hash.Substring(2), @base);\n            } else {\n                x = ToBigInteger(hash, @base);\n            }\n\n            StringBuilder sb = new StringBuilder();\n            while (x > 0) {\n                BigInteger r = x % 58;\n                sb.Append(ALPHABET[(int)r]);\n                x = x / 58;\n            }\n\n            char[] ca = sb.ToString().ToCharArray();\n            Array.Reverse(ca);\n            return new string(ca);\n        }\n\n        static void Main(string[] args) {\n            string s = \"25420294593250030202636073700053352635053786165627414518\";\n            string b = ConvertToBase58(s, 10);\n            Console.WriteLine(\"{0} -> {1}\", s, b);\n\n            List<string> hashes = new List<string>() {\n                \"0x61\",\n                \"0x626262\",\n                \"0x636363\",\n                \"0x73696d706c792061206c6f6e6720737472696e67\",\n                \"0x516b6fcd0f\",\n                \"0xbf4f89001e670274dd\",\n                \"0x572e4794\",\n                \"0xecac89cad93923c02321\",\n                \"0x10c8511e\",\n            };\n            foreach (string hash in hashes) {\n                string b58 = ConvertToBase58(hash);\n                Console.WriteLine(\"{0,-56} -> {1}\", hash, b58);\n            }\n        }\n    }\n}\n"}
{"id": 410260, "name": "Latin Squares in reduced form", "source": "Translate Haskell to C#: import Data.List (permutations, (\\\\))\nimport Control.Monad (foldM, forM_)\n\nlatinSquares :: Eq a => [a] -> [[[a]]]\nlatinSquares [] = []\nlatinSquares set = map reverse <$> squares\n  where\n    squares = foldM addRow firstRow perm\n    perm = tail (groupedPermutations set)\n    firstRow = pure <$> set\n    addRow tbl rows = [ zipWith (:) row tbl\n                      | row <- rows                      \n                      , and $ different (tail row) (tail tbl) ]\n    different = zipWith $ (not .) . elem\n       \ngroupedPermutations :: Eq a => [a] -> [[[a]]]\ngroupedPermutations lst = map (\\x -> (x :) <$> permutations (lst \\\\ [x])) lst\n\nprintTable :: Show a => [[a]] -> IO () \nprintTable tbl = putStrLn $ unlines $ unwords . map show <$> tbl\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace LatinSquares {\n    using matrix = List<List<int>>;\n\n    class Program {\n        static void Swap<T>(ref T a, ref T b) {\n            var t = a;\n            a = b;\n            b = t;\n        }\n\n        static matrix DList(int n, int start) {\n            start--; \n            var a = Enumerable.Range(0, n).ToArray();\n            a[start] = a[0];\n            a[0] = start;\n            Array.Sort(a, 1, a.Length - 1);\n            var first = a[1];\n            \n            matrix r = new matrix();\n            void recurse(int last) {\n                if (last == first) {\n                    \n                    \n                    for (int j = 1; j < a.Length; j++) {\n                        var v = a[j];\n                        if (j == v) {\n                            return; \n                        }\n                    }\n                    \n                    var b = a.Select(v => v + 1).ToArray();\n                    r.Add(b.ToList());\n                    return;\n                }\n                for (int i = last; i >= 1; i--) {\n                    Swap(ref a[i], ref a[last]);\n                    recurse(last - 1);\n                    Swap(ref a[i], ref a[last]);\n                }\n            }\n            recurse(n - 1);\n            return r;\n        }\n\n        static ulong ReducedLatinSquares(int n, bool echo) {\n            if (n <= 0) {\n                if (echo) {\n                    Console.WriteLine(\"[]\\n\");\n                }\n                return 0;\n            } else if (n == 1) {\n                if (echo) {\n                    Console.WriteLine(\"[1]\\n\");\n                }\n                return 1;\n            }\n\n            matrix rlatin = new matrix();\n            for (int i = 0; i < n; i++) {\n                rlatin.Add(new List<int>());\n                for (int j = 0; j < n; j++) {\n                    rlatin[i].Add(0);\n                }\n            }\n            \n            for (int j = 0; j < n; j++) {\n                rlatin[0][j] = j + 1;\n            }\n\n            ulong count = 0;\n            void recurse(int i) {\n                var rows = DList(n, i);\n\n                for (int r = 0; r < rows.Count; r++) {\n                    rlatin[i - 1] = rows[r];\n                    for (int k = 0; k < i - 1; k++) {\n                        for (int j = 1; j < n; j++) {\n                            if (rlatin[k][j] == rlatin[i - 1][j]) {\n                                if (r < rows.Count - 1) {\n                                    goto outer;\n                                }\n                                if (i > 2) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                    if (i < n) {\n                        recurse(i + 1);\n                    } else {\n                        count++;\n                        if (echo) {\n                            PrintSquare(rlatin, n);\n                        }\n                    }\n                outer: { }\n                }\n            }\n\n            \n            recurse(2);\n            return count;\n        }\n\n        static void PrintSquare(matrix latin, int n) {\n            foreach (var row in latin) {\n                var it = row.GetEnumerator();\n                Console.Write(\"[\");\n                if (it.MoveNext()) {\n                    Console.Write(it.Current);\n                }\n                while (it.MoveNext()) {\n                    Console.Write(\", {0}\", it.Current);\n                }\n                Console.WriteLine(\"]\");\n            }\n            Console.WriteLine();\n        }\n\n        static ulong Factorial(ulong n) {\n            if (n <= 0) {\n                return 1;\n            }\n            ulong prod = 1;\n            for (ulong i = 2; i < n + 1; i++) {\n                prod *= i;\n            }\n            return prod;\n        }\n\n        static void Main() {\n            Console.WriteLine(\"The four reduced latin squares of order 4 are:\\n\");\n            ReducedLatinSquares(4, true);\n\n            Console.WriteLine(\"The size of the set of reduced latin squares for the following orders\");\n            Console.WriteLine(\"and hence the total number of latin squares of these orders are:\\n\");\n            for (int n = 1; n < 7; n++) {\n                ulong nu = (ulong)n;\n\n                var size = ReducedLatinSquares(n, false);\n                var f = Factorial(nu - 1);\n                f *= f * nu * size;\n                Console.WriteLine(\"Order {0}: Size {1} x {2}! x {3}! => Total {4}\", n, size, n, n - 1, f);\n            }\n        }\n    }\n}\n"}
{"id": 410261, "name": "Partition function P", "source": "Translate Haskell to C#: \n\n\n\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving (Functor)\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Memo Int\nnats =\n  Node\n    0\n    ((+ 1) . (* 2) <$> nats)\n    ((* 2) . (+ 1) <$> nats)\n\n\n\n\npartitions :: Memo Integer\npartitions = partitionP <$> nats\n\npartitionP :: Int -> Integer\npartitionP n\n  | n < 2 = 1\n  | otherwise = sum $ zipWith (*) signs terms\n  where\n    terms =\n      [ memo partitions (n - i)\n        | i <- takeWhile (<= n) ofsets\n      ]\n    signs = cycle [1, 1, -1, -1]\n\nofsets :: [Int]\nofsets = scanl1 (+) $ mix [1, 3 ..] [1, 2 ..]\n  where\n    mix a b = concat $ zipWith (\\x y -> [x, y]) a b\n\nmain :: IO ()\nmain = print $ partitionP 6666\n", "target": "using System;\n\nclass Program {\n\n    const long Lm = (long)1e18;\n    const string Fm = \"D18\";\n\n    \n    struct LI { public long lo, ml, mh, hi, tp; }\n\n    static void inc(ref LI d, LI s) { \n        if ((d.lo += s.lo) >= Lm) { d.ml++; d.lo -= Lm; }\n        if ((d.ml += s.ml) >= Lm) { d.mh++; d.ml -= Lm; }\n        if ((d.mh += s.mh) >= Lm) { d.hi++; d.mh -= Lm; }\n        if ((d.hi += s.hi) >= Lm) { d.tp++; d.hi -= Lm; }\n        d.tp += s.tp;\n    }\n \n    static void dec(ref LI d, LI s) { \n        if ((d.lo -= s.lo) < 0) { d.ml--; d.lo += Lm; }\n        if ((d.ml -= s.ml) < 0) { d.mh--; d.ml += Lm; }\n        if ((d.mh -= s.mh) < 0) { d.hi--; d.mh += Lm; }\n        if ((d.hi -= s.hi) < 0) { d.tp--; d.hi += Lm; }\n        d.tp -= s.tp;\n    }\n\n    static LI set(long s) { LI d;\n      d.lo = s; d.ml = d.mh = d.hi = d.tp = 0; return d; }\n\n  static string fmt(LI x) { \n    if (x.tp > 0) return x.tp.ToString() + x.hi.ToString(Fm) + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.hi > 0) return x.hi.ToString() + x.mh.ToString(Fm) + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.mh > 0) return x.mh.ToString() + x.ml.ToString(Fm) + x.lo.ToString(Fm);\n    if (x.ml > 0) return x.ml.ToString() + x.lo.ToString(Fm);\n    return x.lo.ToString();\n  }\n\n  static LI partcount(int n) {\n    var P = new LI[n + 1]; P[0] = set(1);\n    for (int i = 1; i <= n; i++) {\n      int k = 0, d = -2, j = i;\n      LI x = set(0);\n      while (true) {\n        if ((j -= (d += 3) -k) >= 0) inc(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) inc(ref x, P[j]); else break;\n        if ((j -= (d += 3) -k) >= 0) dec(ref x, P[j]); else break;\n        if ((j -= ++k)         >= 0) dec(ref x, P[j]); else break;\n      }\n      P[i] = x;\n    }\n    return P[n];\n  }\n\n  static void Main(string[] args) {\n    var sw = System.Diagnostics.Stopwatch.StartNew ();\n    var res = partcount(6666); sw.Stop();\n    Console.Write(\"{0}  {1} ms\", fmt(res), sw.Elapsed.TotalMilliseconds);\n  }\n}\n"}
{"id": 410262, "name": "Polynomial synthetic division", "source": "Translate Haskell to C#: import Data.List\n\nnormalized :: (Eq a, Num a) => [a] -> [a]\nnormalized = dropWhile (== 0)\n\nisZero :: (Eq a, Num a) => [a] -> Bool\nisZero = null . normalized\n\nshortDiv :: (Eq a, Fractional a) => [a] -> [a] -> ([a], [a])\nshortDiv p1 p2\n  | isZero p2 = error \"zero divisor\"\n  | otherwise =\n      let go 0 p = p \n          go i (h:t) = (h/a) : go (i-1) (zipWith (+) (map ((h/a) *) ker) t)\n      in splitAt k $ go k p1\n  where\n    k = length p1 - length as\n    a:as = normalized p2\n    ker = negate <$> (as ++ repeat 0)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace SyntheticDivision\n{\n    class Program\n    {\n        static (List<int>,List<int>) extendedSyntheticDivision(List<int> dividend, List<int> divisor)\n        {\n            List<int> output = dividend.ToList();\n            int normalizer = divisor[0];\n\n            for (int i = 0; i < dividend.Count() - (divisor.Count() - 1); i++)\n            {\n                output[i] /= normalizer;\n\n                int coef = output[i];\n                if (coef != 0)\n                {\n                    for (int j = 1; j < divisor.Count(); j++)\n                        output[i + j] += -divisor[j] * coef;\n                }\n            }\n\n            int separator = output.Count() - (divisor.Count() - 1);\n\n            return (\n                output.GetRange(0, separator),\n                output.GetRange(separator, output.Count() - separator)\n            );\n        }\n\n        static void Main(string[] args)\n        {\n            List<int> N = new List<int>{ 1, -12, 0, -42 };\n            List<int> D = new List<int> { 1, -3 };\n\n            var (quotient, remainder) = extendedSyntheticDivision(N, D);\n            Console.WriteLine(\"[ {0} ] / [ {1} ] = [ {2} ], remainder [ {3} ]\" ,\n                string.Join(\",\", N),\n                string.Join(\",\", D),\n                string.Join(\",\", quotient),\n                string.Join(\",\", remainder)\n            );\n        }\n    }\n}\n"}
{"id": 410263, "name": "The sieve of Sundaram", "source": "Translate Haskell to C#: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport qualified Data.Set as S\nimport Text.Printf (printf)\n\n\n\nsundaram :: Integral a => a -> [a]\nsundaram n =\n  [ succ (2 * x)\n    | x <- [1 .. m],\n      x `S.notMember` excluded\n  ]\n  where\n    m = div (pred n) 2\n    excluded =\n      S.fromList\n        [ 2 * i * j + i + j\n          | let fm = fromIntegral m,\n            i <- [1 .. floor (sqrt (fm / 2))],\n            let fi = fromIntegral i,\n            j <- [i .. floor ((fm - fi) / succ (2 * fi))]\n        ]\n\nnSundaramPrimes ::\n  (Integral a1, RealFrac a2, Floating a2) => a2 -> [a1]\nnSundaramPrimes n =\n  sundaram $ floor $ (2.4 * n * log n) / 2\n\n\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"First 100 Sundaram primes (starting at 3):\\n\"\n  (putStrLn . table \" \" . chunksOf 10) $\n    show <$> nSundaramPrimes 100\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nclass Program\n{\n    static string fmt(int[] a)\n    {\n        var sb = new System.Text.StringBuilder();\n        for (int i = 0; i < a.Length; i++)\n            sb.Append(string.Format(\"{0,5}{1}\",\n              a[i], i % 10 == 9 ? \"\\n\" : \" \"));\n        return sb.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        var pr = PG.Sundaram(15_500_000).Take(1_000_000).ToArray();\n        sw.Stop();\n        Write(\"The first 100 odd prime numbers:\\n{0}\\n\",\n          fmt(pr.Take(100).ToArray()));\n        Write(\"The millionth odd prime number: {0}\", pr.Last());\n        Write(\"\\n{0} ms\", sw.Elapsed.TotalMilliseconds);\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<int> Sundaram(int n)\n    {\n        \n        int i = 1, k = (n + 1) >> 1, t = 1, v = 1, d = 1, s = 1;\n        var comps = new bool[k + 1];\n        for (; t < k; t = ((++i + (s += d += 2)) << 1) - d - 2)\n            while ((t += d + 2) < k)\n                comps[t] = true;\n        for (; v < k; v++)\n            if (!comps[v])\n                yield return (v << 1) + 1;\n    }\n}\n"}
{"id": 410264, "name": "Consecutive primes with ascending or descending differences", "source": "Translate Haskell to C#: import Data.Numbers.Primes (primes)\n\n\nconsecutives equiv = filter ((> 1) . length) . go []\n  where\n    go r [] = [r]\n    go [] (h : t) = go [h] t\n    go (y : ys) (h : t)\n      | y `equiv` h = go (h : y : ys) t\n      | otherwise = (y : ys) : go [h] t\n\n\nmaximumBy g (h : t) = foldr f h t\n  where\n    f r x = if g r < g x then x else r\n\n\ntask ord n = reverse $ p + s : p : (fst <$> rest)\n  where\n    (p, s) : rest =\n      maximumBy length $\n        consecutives (\\(_, a) (_, b) -> a `ord` b) $\n          differences $\n            takeWhile (< n) primes\n    differences l = zip l $ zipWith (-) (tail l) l\n", "target": "using System.Linq;\nusing System.Collections.Generic;\nusing TG = System.Tuple<int, int>;\nusing static System.Console;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        const int mil = (int)1e6;\n        foreach (var amt in new int[] { 1, 2, 6, 12, 18 })\n        {\n            int lmt = mil * amt, lg = 0, ng, d, ld = 0;\n            var desc = new string[] { \"A\", \"\", \"De\" };\n            int[] mx = new int[] { 0, 0, 0 },\n                  bi = new int[] { 0, 0, 0 },\n                   c = new int[] { 2, 2, 2 };\n            WriteLine(\"For primes up to {0:n0}:\", lmt);\n            var pr = PG.Primes(lmt).ToArray();\n            for (int i = 0; i < pr.Length; i++)\n            {\n                ng = pr[i].Item2; d = ng.CompareTo(lg) + 1;\n                if (ld == d)\n                    c[2 - d]++;\n                else\n                {\n                    if (c[d] > mx[d]) { mx[d] = c[d]; bi[d] = i - mx[d] - 1; }\n                    c[d] = 2;\n                }\n                ld = d; lg = ng;\n            }\n            for (int r = 0; r <= 2; r += 2)\n            {\n                Write(\"{0}scending, found run of {1} consecutive primes:\\n  {2} \",\n                    desc[r], mx[r] + 1, pr[bi[r]++].Item1);\n                foreach (var itm in pr.Skip(bi[r]).Take(mx[r]))\n                    Write(\"({0}) {1} \", itm.Item2, itm.Item1); WriteLine(r == 0 ? \"\" : \"\\n\");\n            }\n        }\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<TG> Primes(int lim)\n    {\n        bool[] flags = new bool[lim + 1];\n        int j = 3, lj = 2;\n        for (int d = 8, sq = 9; sq <= lim; j += 2, sq += d += 8)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n                for (int k = sq, i = j << 1; k <= lim; k += i) flags[k] = true;\n            }\n        for (; j <= lim; j += 2)\n            if (!flags[j])\n            {\n                yield return new TG(j, j - lj);\n                lj = j;\n            }\n    }\n}\n"}
{"id": 410265, "name": "Gauss-Jordan matrix inversion", "source": "Translate Haskell to C#: isMatrix xs = null xs || all ((== (length.head $ xs)).length) xs\n\nisSquareMatrix xs = null xs || all ((== (length xs)).length) xs\n\nmult:: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs). zipWith (\\vs u -> map (u*) vs) vss) uss\n\nmatI::(Num a) => Int -> [[a]]\nmatI n = [ [fromIntegral.fromEnum $ i == j | j <- [1..n]] | i <- [1..n]]\n\ninversion xs = gauss xs (matI $ length xs)\n\ngauss::[[Double]] -> [[Double]] -> [[Double]]\ngauss xs bs = map (map fromRational) $ solveGauss (toR xs) (toR bs)\n    where toR = map $ map toRational\n\nsolveGauss:: (Fractional a, Ord a) => [[a]] -> [[a]] -> [[a]]\nsolveGauss xs bs | null xs || null bs || length xs /= length bs || (not $ isSquareMatrix xs) || (not $ isMatrix bs) = []\n                 | otherwise = uncurry solveTriangle $ triangle xs bs\n\nsolveTriangle::(Fractional a,Eq a) => [[a]] -> [[a]] -> [[a]]\nsolveTriangle us _ | not.null.dropWhile ((/= 0).head) $ us = []\nsolveTriangle ([c]:as) (b:bs) = go as bs [map (/c) b]\n  where\n  val us vs ws = let u = head us in map (/u) $ zipWith (-) vs (head $ mult [tail us] ws)\n  go [] _ zs          = zs\n  go _ [] zs          = zs\n  go (x:xs) (y:ys) zs = go xs ys $ (val x y zs):zs\n\ntriangle::(Num a, Ord a) => [[a]] -> [[a]] -> ([[a]],[[a]])\ntriangle xs bs = triang ([],[]) (xs,bs)\n    where\n    triang ts (_,[]) = ts\n    triang ts ([],_) = ts\n    triang (os,ps) zs = triang (us:os,cs:ps).unzip $ [(fun tus vs, fun cs es) | (v:vs,es) <- zip uss css,let fun = zipWith (\\x y -> v*x - u*y)]\n        where ((us@(u:tus)):uss,cs:css) = bubble zs\n\nbubble::(Num a, Ord a) => ([[a]],[[a]]) -> ([[a]],[[a]])\nbubble (xs,bs) = (go xs, go bs)\n    where\n    idmax = snd.maximum.flip zip [0..].map (abs.head) $ xs\n    go ys = let (us,vs) = splitAt idmax ys in vs ++ us\n \nmain = do\n  let a = [[1, 2, 3], [4, 1, 6], [7, 8, 9]]\n  let b = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]\n  putStrLn \"inversion a =\"\n  mapM_ print $ inversion a\n  putStrLn \"\\ninversion b =\"\n  mapM_ print $ inversion b\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 410266, "name": "Gauss-Jordan matrix inversion", "source": "Translate Haskell to C#: isMatrix xs = null xs || all ((== (length.head $ xs)).length) xs\n\nisSquareMatrix xs = null xs || all ((== (length xs)).length) xs\n\nmult:: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs). zipWith (\\vs u -> map (u*) vs) vss) uss\n\nmatI::(Num a) => Int -> [[a]]\nmatI n = [ [fromIntegral.fromEnum $ i == j | j <- [1..n]] | i <- [1..n]]\n\ninversion xs = gauss xs (matI $ length xs)\n\ngauss::[[Double]] -> [[Double]] -> [[Double]]\ngauss xs bs = map (map fromRational) $ solveGauss (toR xs) (toR bs)\n    where toR = map $ map toRational\n\nsolveGauss:: (Fractional a, Ord a) => [[a]] -> [[a]] -> [[a]]\nsolveGauss xs bs | null xs || null bs || length xs /= length bs || (not $ isSquareMatrix xs) || (not $ isMatrix bs) = []\n                 | otherwise = uncurry solveTriangle $ triangle xs bs\n\nsolveTriangle::(Fractional a,Eq a) => [[a]] -> [[a]] -> [[a]]\nsolveTriangle us _ | not.null.dropWhile ((/= 0).head) $ us = []\nsolveTriangle ([c]:as) (b:bs) = go as bs [map (/c) b]\n  where\n  val us vs ws = let u = head us in map (/u) $ zipWith (-) vs (head $ mult [tail us] ws)\n  go [] _ zs          = zs\n  go _ [] zs          = zs\n  go (x:xs) (y:ys) zs = go xs ys $ (val x y zs):zs\n\ntriangle::(Num a, Ord a) => [[a]] -> [[a]] -> ([[a]],[[a]])\ntriangle xs bs = triang ([],[]) (xs,bs)\n    where\n    triang ts (_,[]) = ts\n    triang ts ([],_) = ts\n    triang (os,ps) zs = triang (us:os,cs:ps).unzip $ [(fun tus vs, fun cs es) | (v:vs,es) <- zip uss css,let fun = zipWith (\\x y -> v*x - u*y)]\n        where ((us@(u:tus)):uss,cs:css) = bubble zs\n\nbubble::(Num a, Ord a) => ([[a]],[[a]]) -> ([[a]],[[a]])\nbubble (xs,bs) = (go xs, go bs)\n    where\n    idmax = snd.maximum.flip zip [0..].map (abs.head) $ xs\n    go ys = let (us,vs) = splitAt idmax ys in vs ++ us\n \nmain = do\n  let a = [[1, 2, 3], [4, 1, 6], [7, 8, 9]]\n  let b = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]\n  putStrLn \"inversion a =\"\n  mapM_ print $ inversion a\n  putStrLn \"\\ninversion b =\"\n  mapM_ print $ inversion b\n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 410267, "name": "Numbers which are the cube roots of the product of their proper divisors", "source": "Translate Haskell to C#: import Data.List (group, intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes ( primeFactors )\nimport Text.Printf (printf)\n\n\n\n\noeisA111398 :: [Integer]\noeisA111398 = 1 : [n | n <- [1..], 8 == length (divisors n)]\n\n\ndivisors :: Integer -> [Integer]\ndivisors =\n  foldr\n    (flip ((<*>) . fmap (*)) . scanl (*) 1)\n    [1]\n    . group\n    . primeFactors\n    \n\n\n\nmain :: IO ()\nmain = do\n  putStrLn $ table \"   \" $ chunksOf 10 $\n    take 50 (show <$> oeisA111398)\n   \n  mapM_ print $ \n   (,) <*> ((oeisA111398 !!) . pred) <$> [500, 5000, 50000]\n  \n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "using System;\nclass Program {\n\n  static bool dc8(uint n) {\n    uint res = 1, count, p, d;\n    for ( ; (n & 1) == 0; n >>= 1) res++;\n    for (count = 1; n % 3 == 0; n /= 3) count++;\n    for (p = 5, d = 4; p * p <= n; p += d = 6 - d)\n        for (res *= count, count = 1; n % p == 0; n /= p) count++;\n    return n > 1 ? res * count == 4 : res * count == 8;\n  }\n\n  static void Main(string[] args) {\n    Console.WriteLine(\"First 50 numbers which are the cube roots of the products of \"\n                      + \"their proper divisors:\");\n    for (uint n = 1, count = 0, lmt = 500; count < 5e6; ++n) if (n == 1 || dc8(n))\n        if (++count <= 50) Console.Write(\"{0,3}{1}\",n, count % 10 == 0 ? '\\n' : ' ');\n        else if (count == lmt) Console.Write(\"{0,16:n0}th: {1:n0}\\n\", count, n, lmt *= 10);\n  }\n}\n"}
{"id": 410268, "name": "Fibonacci matrix-exponentiation", "source": "Translate Haskell to C#: import System.CPUTime (getCPUTime)\nimport Data.List\n\nmain = do\n    startTime <- getCPUTime\n    mapM_ (putStrLn.formatAns).take 7.iterate (*10) $ 10\n    mapM_ (putStrLn.seeFib) [16,32]\n    finishTime <- getCPUTime\n    putStrLn $ \"Took \" ++ (took startTime finishTime)\n\ntook t = fromChrono.chrono t\n\nfromChrono :: (Integer,Integer,Integer) -> String\nfromChrono (m,s,ms) = show m ++ \"m\" ++ show s ++ \".\" ++ show ms ++ \"s\"\n\nchrono :: Integer -> Integer -> (Integer,Integer,Integer)\nchrono start end = (m,s,ms)\n    where\n    tera = 1000000000000\n    fdt = fromIntegral (end - start) / tera\n    dt = floor fdt\n    (m,s) = quotRem dt 60 \n    ms = round $ fromIntegral (round (fdt - (fromIntegral dt))*1000) / 1000\n\nbagOf :: Int -> [a] -> [[a]]\nbagOf _ [] = []\nbagOf n xs = let (us,vs) = splitAt n xs in us : bagOf n vs\n\nformatIntegral :: Show a => String -> a -> String\nformatIntegral sep = reverse.intercalate sep.bagOf 3.reverse.show\n \nformatAns :: Integer -> String\nformatAns p = start ++ go x\n    where\n    start = \"Fibonacci(\"++ (formatIntegral \"_\" p) ++ \") = \"\n    x = fib p\n    tenPow20 = 10^20\n    tenPow40 = tenPow20^2\n    go u | u <= tenPow20 = show u\n    go u | u <= tenPow40 = let (us,vs) = splitAt 20 $ show u in us ++ \" ... \" ++ vs\n    go u = (take 20 $ show u) ++ \" ... \" ++ (show . rem u $ 10^20)\n\nseeFib :: Integer -> String\nseeFib n = start ++ xs ++ \" ... \" ++ (show . rem x $ 10^20)\n    where\n    start = \"Fibonacci(2^\" ++ (show n) ++\") = \"\n    x = fib (2^n)\n    xs = take 20 $ show x\n \nfib :: Integer -> Integer\nfib 0 = 0 \n\nfib n = (last . head . unMat) (Mat [[1, 1], [1, 0]] ^ n)\n \nmult :: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs) . zipWith (flip (map . (*))) vss) uss\n \nnewtype Mat a = Mat\n  { unMat :: [[a]]\n  } deriving (Eq,Show)\n \ninstance Num a =>  Num (Mat a) where\n  negate xm = Mat $ map (map negate) $ unMat xm\n  xm + ym = Mat $ zipWith (zipWith (+)) (unMat xm) (unMat ym)\n  xm * ym =  Mat $ mult (unMat xm) (unMat ym)\n  fromInteger n = Mat [[fromInteger n]]\n  abs = undefined\n  signum = undefined\n", "target": "using System;\nusing System.IO;\nusing System.Numerics;\nusing System.Threading;\nusing System.Diagnostics;\nusing System.Globalization;\n\nnamespace Fibonacci {\n    class Program\n    {\n        private static readonly BigInteger[,] F = { { BigInteger.One, BigInteger.One }, { BigInteger.One, BigInteger.Zero } };\n        private static NumberFormatInfo nfi  = new NumberFormatInfo { NumberGroupSeparator = \"_\" };\n        private static BigInteger[,] Multiply(in BigInteger[,] A, in BigInteger[,] B)\n        {\n            if (A.GetLength(1) != B.GetLength(0))\n            {\n                throw new ArgumentException(\"Illegal matrix dimensions for multiplication.\");\n            }\n            var C = new BigInteger[A.GetLength(0), B.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < B.GetLength(1); ++j)\n                {\n                    for (int k = 0; k < A.GetLength(1); ++k)\n                    {\n                        C[i, j] +=  A[i, k] * B[k, j];\n                    }\n                }\n            }\n            return C;\n        }\n        private static BigInteger[,] Power(in BigInteger[,] A, ulong n)\n        {\n            if (A.GetLength(1) != A.GetLength(0))\n            {\n                throw new ArgumentException(\"Not a square matrix.\");\n            }\n            var C = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                C[i, i] = BigInteger.One;\n            }\n            if (0 == n) return C;\n            var S = new BigInteger[A.GetLength(0), A.GetLength(1)];\n            for (int i = 0; i < A.GetLength(0); ++i)\n            {\n                for (int j = 0; j < A.GetLength(1); ++j)\n                {\n                    S[i, j] = A[i, j];\n                }\n            }\n            while (0 < n)\n            {\n                if (1 == n % 2) C = Multiply(C, S);\n                S = Multiply(S,S);\n                n /= 2;\n            }\n            return C;\n        }\n        public static BigInteger Fib(in ulong n)\n        {\n            var C = Power(F, n);\n            return C[0, 1];\n        }\n        public static void Task(in ulong p)\n        {\n            var ans = Fib(p).ToString();\n            var sp = p.ToString(\"N0\", nfi);\n            if (ans.Length <= 40)\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1}\", sp, ans);\n            }\n            else\n            {\n                Console.WriteLine(\"Fibonacci({0}) = {1} ... {2}\", sp, ans[0..19], ans[^20..]);\n            }\n        }\n        public static void Main()\n        {\n            Stopwatch stopWatch = new Stopwatch();\n            stopWatch.Start();\n            for (ulong p = 10; p <= 10_000_000; p *= 10) {\n                Task(p);\n            }\n            stopWatch.Stop();\n            TimeSpan ts = stopWatch.Elapsed;\n            string elapsedTime = String.Format(\"{0:00}:{1:00}:{2:00}.{3:00}\",\n                ts.Hours, ts.Minutes, ts.Seconds,\n                ts.Milliseconds / 10);\n            Console.WriteLine(\"Took \" + elapsedTime);\n        }\n    }\n}\n"}
{"id": 410269, "name": "Cyclotomic polynomial", "source": "Translate Haskell to C#: import Data.List\nimport Data.Numbers.Primes (primeFactors)\n\nnegateVar p = zipWith (*) p $ reverse $ take (length p) $ cycle [1,-1]\n\nlift p 1 = p\nlift p n = intercalate (replicate (n-1) 0) (pure <$> p)\n\nshortDiv :: [Integer] -> [Integer] -> [Integer]\nshortDiv p1 (_:p2) = unfoldr go (length p1 - length p2, p1)\n  where\n    go (0, _) = Nothing\n    go (i, h:t) = Just (h, (i-1, zipWith (+) (map (h *) ker) t))\n    ker = negate <$> p2 ++ repeat 0\n\nprimePowerFactors = sortOn fst . map (\\x-> (head x, length x)) . group . primeFactors\n                     \n\ncyclotomics :: [[Integer]]\ncyclotomics = cyclotomic <$> [0..]\n\ncyclotomic :: Int -> [Integer]\ncyclotomic 0 = [0]\ncyclotomic 1 = [1, -1]\ncyclotomic 2 = [1, 1]\ncyclotomic n = case primePowerFactors n of\n  \n  [(2,h)]       -> 1 : replicate (2 ^ (h-1) - 1) 0 ++ [1]\n  \n  [(p,1)]       -> replicate n 1\n  \n  [(p,m)]       -> lift (cyclotomics !! p) (p^(m-1))\n  \n  [(2,1),(p,1)] -> take (n `div` 2) $ cycle [1,-1]\n  \n  (2,1):_       -> negateVar $ cyclotomics !! (n `div` 2)\n  \n  (p, m):ps     -> let cm = cyclotomics !! (n `div` (p ^ m))\n                   in lift (lift cm p `shortDiv` cm) (p^(m-1))\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing IntMap = System.Collections.Generic.Dictionary<int, int>;\n\npublic static class CyclotomicPolynomial\n{\n    public static void Main2() {\n        Console.WriteLine(\"Task 1: Cyclotomic polynomials for n <= 30:\");\n        for (int i = 1; i <= 30; i++) {\n            var p = GetCyclotomicPolynomial(i);\n            Console.WriteLine($\"CP[{i}] = {p.ToString()}\");\n        }\n        Console.WriteLine();\n\n        Console.WriteLine(\"Task 2: Smallest cyclotomic polynomial with n or -n as a coefficient:\");\n        for (int i = 1, n = 0; i <= 10; i++) {\n            while (true) {\n                n++;\n                var p = GetCyclotomicPolynomial(n);\n                if (p.Any(t => Math.Abs(t.Coefficient) == i)) {\n                    Console.WriteLine($\"CP[{n}] has coefficient with magnitude = {i}\");\n                    n--;\n                    break;\n                }\n            }\n        }\n    }\n\n    private const int MaxFactors = 100_000;\n    private const int Algorithm = 2;\n    private static readonly Term x = new Term(1, 1);\n    private static readonly Dictionary<int, Polynomial> polyCache =\n        new Dictionary<int, Polynomial> { [1] = x - 1 };\n    private static readonly Dictionary<int, IntMap> factorCache =\n        new Dictionary<int, IntMap> { [2] = new IntMap { [2] = 1 } };\n\n    private static Polynomial GetCyclotomicPolynomial(in int n) {\n        if (polyCache.TryGetValue(n, out var result)) return result;\n\n        var factors = GetFactors(n);\n        if (factors.ContainsKey(n)) { \n            result = new Polynomial(from exp in ..n select x[exp]);\n        } else if (factors.Count == 2 && factors.Contains(2, 1) && factors.Contains(n/2, 1)) { \n            result = new Polynomial(from i in ..(n/2) select (IsOdd(i) ? -x : x)[i]);\n        } else if (factors.Count == 1 && factors.TryGetValue(2, out int h)) { \n            result = x[1<<(h-1)] + 1;\n        } else if (factors.Count == 1 && !factors.ContainsKey(n)) { \n            (int p, int k) = factors.First();\n            result = new Polynomial(from i in ..p select x[i * (int)Math.Pow(p, k-1)]);\n        } else if (factors.Count == 2 && factors.ContainsKey(2)) { \n            (int p, int k) = factors.First(entry => entry.Key != 2);\n            int twoExp = 1 << (factors[2] - 1);\n            result = new Polynomial(from i in ..p select (IsOdd(i) ? -x : x)[i * twoExp * (int)Math.Pow(p, k-1)]);\n        } else if (factors.ContainsKey(2) && IsOdd(n/2) && n/2 > 1) { \n            Polynomial cycloDiv2 = GetCyclotomicPolynomial(n/2);\n            result = new Polynomial(from term in cycloDiv2 select IsOdd(term.Exponent) ? -term : term);\n            #pragma warning disable CS0162\n        } else if (Algorithm == 0) {\n            var divisors = GetDivisors(n);\n            result = x[n] - 1;\n            foreach (int d in divisors) result /= GetCyclotomicPolynomial(d);\n        } else if (Algorithm == 1) {\n            var divisors = GetDivisors(n).ToList();\n            int maxDivisor = divisors.Max();\n            result = (x[n] - 1) / (x[maxDivisor] - 1);\n            foreach (int d in divisors.Where(div => maxDivisor % div == 0)) {\n                result /= GetCyclotomicPolynomial(d);\n            }\n        } else if (Algorithm == 2) {\n            int m = 1;\n            result = GetCyclotomicPolynomial(m);\n            var primes = factors.Keys.ToList();\n            primes.Sort();\n            foreach (int prime in primes) {\n                var cycloM = result;\n                result = new Polynomial(from term in cycloM select term.Coefficient * x[term.Exponent * prime]);\n                result /= cycloM;\n                m *= prime;\n            }\n            int s = n / m;\n            result = new Polynomial(from term in result select term.Coefficient * x[term.Exponent * s]);\n            #pragma warning restore CS0162\n        } else {\n            throw new InvalidOperationException(\"Invalid algorithm\");\n        }\n        polyCache[n] = result;\n        return result;\n    }\n\n    private static bool IsOdd(int i) => (i & 1) != 0;\n    private static bool Contains(this IntMap map, int key, int value) => map.TryGetValue(key, out int v) && v == value;\n    private static int GetOrZero(this IntMap map, int key) => map.TryGetValue(key, out int v) ? v : 0;\n    private static IEnumerable<T> Select<T>(this Range r, Func<int, T> f) => Enumerable.Range(r.Start.Value, r.End.Value - r.Start.Value).Select(f);\n\n    private static IntMap GetFactors(in int n) {\n        if (factorCache.TryGetValue(n, out var factors)) return factors;\n\n        factors = new IntMap();\n        if (!IsOdd(n)) {\n            foreach (var entry in GetFactors(n/2)) factors.Add(entry.Key, entry.Value);\n            factors[2] = factors.GetOrZero(2) + 1;\n            return Cache(n, factors);\n        }\n        for (int i = 3; i * i <= n; i+=2) {\n            if (n % i == 0) {\n                foreach (var entry in GetFactors(n/i)) factors.Add(entry.Key, entry.Value);\n                factors[i] = factors.GetOrZero(i) + 1;\n                return Cache(n, factors);\n            }\n        }\n        factors[n] = 1;\n        return Cache(n, factors);\n    }\n\n    private static IntMap Cache(int n, IntMap factors) {\n        if (n < MaxFactors) factorCache[n] = factors;\n        return factors;\n    }\n\n    private static IEnumerable<int> GetDivisors(int n) {\n        for (int i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                yield return i;\n                int div = n / i;\n                if (div != i && div != n) yield return div;\n            }\n        }\n    }\n\n    public sealed class Polynomial : IEnumerable<Term>\n    {\n        public Polynomial() { }\n        public Polynomial(params Term[] terms) : this(terms.AsEnumerable()) { }\n\n        public Polynomial(IEnumerable<Term> terms) {\n            Terms.AddRange(terms);\n            Simplify();\n        }\n\n        private List<Term>? terms;\n        private List<Term> Terms => terms ??= new List<Term>();\n\n        public int Count => terms?.Count ?? 0;\n        public int Degree => Count == 0 ? -1 : Terms[0].Exponent;\n        public int LeadingCoefficient => Count == 0 ? 0 : Terms[0].Coefficient;\n\n        public IEnumerator<Term> GetEnumerator() => Terms.GetEnumerator();\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public override string ToString() => Count == 0 ? \"0\" : string.Join(\" + \", Terms).Replace(\"+ -\", \"- \");\n\n        public static Polynomial operator *(Polynomial p, Term t) => new Polynomial(from s in p select s * t);\n        public static Polynomial operator +(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms));\n        public static Polynomial operator -(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms.Select(t => -t)));\n        public static Polynomial operator *(Polynomial p, Polynomial q) => new Polynomial(from s in p from t in q select s * t);\n        public static Polynomial operator /(Polynomial p, Polynomial q) => p.Divide(q).quotient;\n\n        public (Polynomial quotient, Polynomial remainder) Divide(Polynomial divisor) {\n            if (Degree < 0) return (new Polynomial(), this);\n            Polynomial quotient = new Polynomial();\n            Polynomial remainder = this;\n            int lcv = divisor.LeadingCoefficient;\n            int dv = divisor.Degree;\n            while (remainder.Degree >= divisor.Degree) {\n                int lcr = remainder.LeadingCoefficient;\n                Term div = new Term(lcr / lcv, remainder.Degree - dv);\n                quotient.Terms.Add(div);\n                remainder += divisor * -div;\n            }\n            quotient.Simplify();\n            remainder.Simplify();\n            return (quotient, remainder);\n        }\n\n        private void Simplify() {\n            if (Count < 2) return;\n            Terms.Sort((a, b) => -a.CompareTo(b));\n            for (int i = Terms.Count - 1; i > 0; i--) {\n                Term s = Terms[i-1];\n                Term t = Terms[i];\n                if (t.Exponent == s.Exponent) {\n                    Terms[i-1] = new Term(s.Coefficient + t.Coefficient, s.Exponent);\n                    Terms.RemoveAt(i);\n                }\n            }\n            Terms.RemoveAll(t => t.IsZero);\n        }\n\n    }\n    \n    public readonly struct Term : IEquatable<Term>, IComparable<Term>\n    {\n        public Term(int coefficient, int exponent = 0) => (Coefficient, Exponent) = (coefficient, exponent);\n\n        public Term this[int exponent] => new Term(Coefficient, exponent); \n        public int Coefficient { get; }\n        public int Exponent { get; }\n        public bool IsZero => Coefficient == 0;\n\n        public static Polynomial operator +(Term left, Term right) => new Polynomial(left, right);\n        public static Polynomial operator -(Term left, Term right) => new Polynomial(left, -right);\n        public static implicit operator Term(int coefficient) => new Term(coefficient);\n        public static Term operator -(Term t) => new Term(-t.Coefficient, t.Exponent);\n        public static Term operator *(Term left, Term right) => new Term(left.Coefficient * right.Coefficient, left.Exponent + right.Exponent);\n\n        public static bool operator ==(Term left, Term right) => left.Equals(right);\n        public static bool operator !=(Term left, Term right) => !left.Equals(right);\n        public static bool operator  <(Term left, Term right) => left.CompareTo(right)  < 0;\n        public static bool operator  >(Term left, Term right) => left.CompareTo(right)  > 0;\n        public static bool operator <=(Term left, Term right) => left.CompareTo(right) <= 0;\n        public static bool operator >=(Term left, Term right) => left.CompareTo(right) >= 0;\n\n        public bool Equals(Term other) => Exponent == other.Exponent && Coefficient == other.Coefficient;\n        public override bool Equals(object? obj) => obj is Term t && Equals(t);\n        public override int GetHashCode() => Coefficient.GetHashCode() * 31 + Exponent.GetHashCode();\n\n        public int CompareTo(Term other) {\n            int c = Exponent.CompareTo(other.Exponent);\n            if (c != 0) return c;\n            return Coefficient.CompareTo(other.Coefficient);\n        }\n\n        public override string ToString() => (Coefficient, Exponent) switch {\n            (0,  _) => \"0\",\n            (_,  0) => $\"{Coefficient}\",\n            (1,  1) => \"x\",\n            (-1, 1) => \"-x\",\n            (_,  1) => $\"{Coefficient}x\",\n            (1,  _) => $\"x^{Exponent}\",\n            (-1, _) => $\"-x^{Exponent}\",\n                    _ => $\"{Coefficient}x^{Exponent}\"\n        };\n    }\n}\n"}
{"id": 410270, "name": "Cyclotomic polynomial", "source": "Translate Haskell to C#: import Data.List\nimport Data.Numbers.Primes (primeFactors)\n\nnegateVar p = zipWith (*) p $ reverse $ take (length p) $ cycle [1,-1]\n\nlift p 1 = p\nlift p n = intercalate (replicate (n-1) 0) (pure <$> p)\n\nshortDiv :: [Integer] -> [Integer] -> [Integer]\nshortDiv p1 (_:p2) = unfoldr go (length p1 - length p2, p1)\n  where\n    go (0, _) = Nothing\n    go (i, h:t) = Just (h, (i-1, zipWith (+) (map (h *) ker) t))\n    ker = negate <$> p2 ++ repeat 0\n\nprimePowerFactors = sortOn fst . map (\\x-> (head x, length x)) . group . primeFactors\n                     \n\ncyclotomics :: [[Integer]]\ncyclotomics = cyclotomic <$> [0..]\n\ncyclotomic :: Int -> [Integer]\ncyclotomic 0 = [0]\ncyclotomic 1 = [1, -1]\ncyclotomic 2 = [1, 1]\ncyclotomic n = case primePowerFactors n of\n  \n  [(2,h)]       -> 1 : replicate (2 ^ (h-1) - 1) 0 ++ [1]\n  \n  [(p,1)]       -> replicate n 1\n  \n  [(p,m)]       -> lift (cyclotomics !! p) (p^(m-1))\n  \n  [(2,1),(p,1)] -> take (n `div` 2) $ cycle [1,-1]\n  \n  (2,1):_       -> negateVar $ cyclotomics !! (n `div` 2)\n  \n  (p, m):ps     -> let cm = cyclotomics !! (n `div` (p ^ m))\n                   in lift (lift cm p `shortDiv` cm) (p^(m-1))\n", "target": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing IntMap = System.Collections.Generic.Dictionary<int, int>;\n\npublic static class CyclotomicPolynomial\n{\n    public static void Main2() {\n        Console.WriteLine(\"Task 1: Cyclotomic polynomials for n <= 30:\");\n        for (int i = 1; i <= 30; i++) {\n            var p = GetCyclotomicPolynomial(i);\n            Console.WriteLine($\"CP[{i}] = {p.ToString()}\");\n        }\n        Console.WriteLine();\n\n        Console.WriteLine(\"Task 2: Smallest cyclotomic polynomial with n or -n as a coefficient:\");\n        for (int i = 1, n = 0; i <= 10; i++) {\n            while (true) {\n                n++;\n                var p = GetCyclotomicPolynomial(n);\n                if (p.Any(t => Math.Abs(t.Coefficient) == i)) {\n                    Console.WriteLine($\"CP[{n}] has coefficient with magnitude = {i}\");\n                    n--;\n                    break;\n                }\n            }\n        }\n    }\n\n    private const int MaxFactors = 100_000;\n    private const int Algorithm = 2;\n    private static readonly Term x = new Term(1, 1);\n    private static readonly Dictionary<int, Polynomial> polyCache =\n        new Dictionary<int, Polynomial> { [1] = x - 1 };\n    private static readonly Dictionary<int, IntMap> factorCache =\n        new Dictionary<int, IntMap> { [2] = new IntMap { [2] = 1 } };\n\n    private static Polynomial GetCyclotomicPolynomial(in int n) {\n        if (polyCache.TryGetValue(n, out var result)) return result;\n\n        var factors = GetFactors(n);\n        if (factors.ContainsKey(n)) { \n            result = new Polynomial(from exp in ..n select x[exp]);\n        } else if (factors.Count == 2 && factors.Contains(2, 1) && factors.Contains(n/2, 1)) { \n            result = new Polynomial(from i in ..(n/2) select (IsOdd(i) ? -x : x)[i]);\n        } else if (factors.Count == 1 && factors.TryGetValue(2, out int h)) { \n            result = x[1<<(h-1)] + 1;\n        } else if (factors.Count == 1 && !factors.ContainsKey(n)) { \n            (int p, int k) = factors.First();\n            result = new Polynomial(from i in ..p select x[i * (int)Math.Pow(p, k-1)]);\n        } else if (factors.Count == 2 && factors.ContainsKey(2)) { \n            (int p, int k) = factors.First(entry => entry.Key != 2);\n            int twoExp = 1 << (factors[2] - 1);\n            result = new Polynomial(from i in ..p select (IsOdd(i) ? -x : x)[i * twoExp * (int)Math.Pow(p, k-1)]);\n        } else if (factors.ContainsKey(2) && IsOdd(n/2) && n/2 > 1) { \n            Polynomial cycloDiv2 = GetCyclotomicPolynomial(n/2);\n            result = new Polynomial(from term in cycloDiv2 select IsOdd(term.Exponent) ? -term : term);\n            #pragma warning disable CS0162\n        } else if (Algorithm == 0) {\n            var divisors = GetDivisors(n);\n            result = x[n] - 1;\n            foreach (int d in divisors) result /= GetCyclotomicPolynomial(d);\n        } else if (Algorithm == 1) {\n            var divisors = GetDivisors(n).ToList();\n            int maxDivisor = divisors.Max();\n            result = (x[n] - 1) / (x[maxDivisor] - 1);\n            foreach (int d in divisors.Where(div => maxDivisor % div == 0)) {\n                result /= GetCyclotomicPolynomial(d);\n            }\n        } else if (Algorithm == 2) {\n            int m = 1;\n            result = GetCyclotomicPolynomial(m);\n            var primes = factors.Keys.ToList();\n            primes.Sort();\n            foreach (int prime in primes) {\n                var cycloM = result;\n                result = new Polynomial(from term in cycloM select term.Coefficient * x[term.Exponent * prime]);\n                result /= cycloM;\n                m *= prime;\n            }\n            int s = n / m;\n            result = new Polynomial(from term in result select term.Coefficient * x[term.Exponent * s]);\n            #pragma warning restore CS0162\n        } else {\n            throw new InvalidOperationException(\"Invalid algorithm\");\n        }\n        polyCache[n] = result;\n        return result;\n    }\n\n    private static bool IsOdd(int i) => (i & 1) != 0;\n    private static bool Contains(this IntMap map, int key, int value) => map.TryGetValue(key, out int v) && v == value;\n    private static int GetOrZero(this IntMap map, int key) => map.TryGetValue(key, out int v) ? v : 0;\n    private static IEnumerable<T> Select<T>(this Range r, Func<int, T> f) => Enumerable.Range(r.Start.Value, r.End.Value - r.Start.Value).Select(f);\n\n    private static IntMap GetFactors(in int n) {\n        if (factorCache.TryGetValue(n, out var factors)) return factors;\n\n        factors = new IntMap();\n        if (!IsOdd(n)) {\n            foreach (var entry in GetFactors(n/2)) factors.Add(entry.Key, entry.Value);\n            factors[2] = factors.GetOrZero(2) + 1;\n            return Cache(n, factors);\n        }\n        for (int i = 3; i * i <= n; i+=2) {\n            if (n % i == 0) {\n                foreach (var entry in GetFactors(n/i)) factors.Add(entry.Key, entry.Value);\n                factors[i] = factors.GetOrZero(i) + 1;\n                return Cache(n, factors);\n            }\n        }\n        factors[n] = 1;\n        return Cache(n, factors);\n    }\n\n    private static IntMap Cache(int n, IntMap factors) {\n        if (n < MaxFactors) factorCache[n] = factors;\n        return factors;\n    }\n\n    private static IEnumerable<int> GetDivisors(int n) {\n        for (int i = 1; i * i <= n; i++) {\n            if (n % i == 0) {\n                yield return i;\n                int div = n / i;\n                if (div != i && div != n) yield return div;\n            }\n        }\n    }\n\n    public sealed class Polynomial : IEnumerable<Term>\n    {\n        public Polynomial() { }\n        public Polynomial(params Term[] terms) : this(terms.AsEnumerable()) { }\n\n        public Polynomial(IEnumerable<Term> terms) {\n            Terms.AddRange(terms);\n            Simplify();\n        }\n\n        private List<Term>? terms;\n        private List<Term> Terms => terms ??= new List<Term>();\n\n        public int Count => terms?.Count ?? 0;\n        public int Degree => Count == 0 ? -1 : Terms[0].Exponent;\n        public int LeadingCoefficient => Count == 0 ? 0 : Terms[0].Coefficient;\n\n        public IEnumerator<Term> GetEnumerator() => Terms.GetEnumerator();\n        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();\n\n        public override string ToString() => Count == 0 ? \"0\" : string.Join(\" + \", Terms).Replace(\"+ -\", \"- \");\n\n        public static Polynomial operator *(Polynomial p, Term t) => new Polynomial(from s in p select s * t);\n        public static Polynomial operator +(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms));\n        public static Polynomial operator -(Polynomial p, Polynomial q) => new Polynomial(p.Terms.Concat(q.Terms.Select(t => -t)));\n        public static Polynomial operator *(Polynomial p, Polynomial q) => new Polynomial(from s in p from t in q select s * t);\n        public static Polynomial operator /(Polynomial p, Polynomial q) => p.Divide(q).quotient;\n\n        public (Polynomial quotient, Polynomial remainder) Divide(Polynomial divisor) {\n            if (Degree < 0) return (new Polynomial(), this);\n            Polynomial quotient = new Polynomial();\n            Polynomial remainder = this;\n            int lcv = divisor.LeadingCoefficient;\n            int dv = divisor.Degree;\n            while (remainder.Degree >= divisor.Degree) {\n                int lcr = remainder.LeadingCoefficient;\n                Term div = new Term(lcr / lcv, remainder.Degree - dv);\n                quotient.Terms.Add(div);\n                remainder += divisor * -div;\n            }\n            quotient.Simplify();\n            remainder.Simplify();\n            return (quotient, remainder);\n        }\n\n        private void Simplify() {\n            if (Count < 2) return;\n            Terms.Sort((a, b) => -a.CompareTo(b));\n            for (int i = Terms.Count - 1; i > 0; i--) {\n                Term s = Terms[i-1];\n                Term t = Terms[i];\n                if (t.Exponent == s.Exponent) {\n                    Terms[i-1] = new Term(s.Coefficient + t.Coefficient, s.Exponent);\n                    Terms.RemoveAt(i);\n                }\n            }\n            Terms.RemoveAll(t => t.IsZero);\n        }\n\n    }\n    \n    public readonly struct Term : IEquatable<Term>, IComparable<Term>\n    {\n        public Term(int coefficient, int exponent = 0) => (Coefficient, Exponent) = (coefficient, exponent);\n\n        public Term this[int exponent] => new Term(Coefficient, exponent); \n        public int Coefficient { get; }\n        public int Exponent { get; }\n        public bool IsZero => Coefficient == 0;\n\n        public static Polynomial operator +(Term left, Term right) => new Polynomial(left, right);\n        public static Polynomial operator -(Term left, Term right) => new Polynomial(left, -right);\n        public static implicit operator Term(int coefficient) => new Term(coefficient);\n        public static Term operator -(Term t) => new Term(-t.Coefficient, t.Exponent);\n        public static Term operator *(Term left, Term right) => new Term(left.Coefficient * right.Coefficient, left.Exponent + right.Exponent);\n\n        public static bool operator ==(Term left, Term right) => left.Equals(right);\n        public static bool operator !=(Term left, Term right) => !left.Equals(right);\n        public static bool operator  <(Term left, Term right) => left.CompareTo(right)  < 0;\n        public static bool operator  >(Term left, Term right) => left.CompareTo(right)  > 0;\n        public static bool operator <=(Term left, Term right) => left.CompareTo(right) <= 0;\n        public static bool operator >=(Term left, Term right) => left.CompareTo(right) >= 0;\n\n        public bool Equals(Term other) => Exponent == other.Exponent && Coefficient == other.Coefficient;\n        public override bool Equals(object? obj) => obj is Term t && Equals(t);\n        public override int GetHashCode() => Coefficient.GetHashCode() * 31 + Exponent.GetHashCode();\n\n        public int CompareTo(Term other) {\n            int c = Exponent.CompareTo(other.Exponent);\n            if (c != 0) return c;\n            return Coefficient.CompareTo(other.Coefficient);\n        }\n\n        public override string ToString() => (Coefficient, Exponent) switch {\n            (0,  _) => \"0\",\n            (_,  0) => $\"{Coefficient}\",\n            (1,  1) => \"x\",\n            (-1, 1) => \"-x\",\n            (_,  1) => $\"{Coefficient}x\",\n            (1,  _) => $\"x^{Exponent}\",\n            (-1, _) => $\"-x^{Exponent}\",\n                    _ => $\"{Coefficient}x^{Exponent}\"\n        };\n    }\n}\n"}
{"id": 410271, "name": "Minimal steps down to 1", "source": "Translate Haskell to C#: \nimport Data.List\nimport Data.Ord\nimport Data.Function (on)\n\n\n\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving Functor\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Integral a => Memo a\nnats = Node 0 ((+1).(*2) <$> nats) ((*2).(+1) <$> nats)\n\nmemoize :: Integral a => (a -> b) -> (a -> b)\nmemoize f = memo (f <$> nats)\n\n\n\ndata Step = Div Int | Sub Int\n  deriving Show\n\nrun :: Int -> Step -> [(Step, Int)]\nrun n s = case s of\n  Sub i | n > i -> [(s, n - i)]\n  Div d | n `mod` d == 0 -> [(s, n `div` d)]\n  _ -> []\n\nminSteps :: [Step] -> Int -> (Int, [Step])\nminSteps steps = go\n  where\n    go = memoize goM\n    \n    goM 1 = (0, [])\n    goM n = minimumBy (comparing fst) $ do\n      (s, k) <- steps >>= run n\n      let (m, ss) = go k\n      return (m+1, s:ss)\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class MinimalSteps\n{\n    public static void Main() {\n        var (divisors, subtractors) = (new int[] { 2, 3 }, new [] { 1 });\n        var lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n        Console.WriteLine();\n\n        subtractors = new [] { 2 };\n        lookup = CreateLookup(2_000, divisors, subtractors);\n        Console.WriteLine($\"Divisors: [{divisors.Delimit()}], Subtractors: [{subtractors.Delimit()}]\");\n        PrintRange(lookup, 10);\n        PrintMaxMins(lookup);\n        lookup = CreateLookup(20_000, divisors, subtractors);\n        PrintMaxMins(lookup);\n    }\n\n    private static void PrintRange((char op, int param, int steps)[] lookup, int limit) {\n        for (int goal = 1; goal <= limit; goal++) {\n            var x = lookup[goal];\n            if (x.param == 0) {\n                Console.WriteLine($\"{goal} cannot be reached with these numbers.\");\n                continue;\n            }\n            Console.Write($\"{goal} takes {x.steps} {(x.steps == 1\u00a0? \"step\"\u00a0: \"steps\")}: \");\n            for (int n = goal; n > 1; ) {\n                Console.Write($\"{n},{x.op}{x.param}=> \");\n                n = x.op == '/' ? n / x.param : n - x.param;\n                x = lookup[n];\n            }\n            Console.WriteLine(\"1\");\n        }\n    }\n\n    private static void PrintMaxMins((char op, int param, int steps)[] lookup) {\n        var maxSteps = lookup.Max(x => x.steps);\n        var items = lookup.Select((x, i) => (i, x)).Where(t => t.x.steps == maxSteps).ToList();\n        Console.WriteLine(items.Count == 1\n            ? $\"There is one number below {lookup.Length-1} that requires {maxSteps} steps: {items[0].i}\"\n            : $\"There are {items.Count} numbers below {lookup.Length-1} that require {maxSteps} steps: {items.Select(t => t.i).Delimit()}\"\n        );\n    }\n\n    private static (char op, int param, int steps)[] CreateLookup(int goal, int[] divisors, int[] subtractors)\n    {\n        var lookup = new (char op, int param, int steps)[goal+1];\n        lookup[1] = ('/', 1, 0);\n        for (int n = 1; n < lookup.Length; n++) {\n            var ln = lookup[n];\n            if (ln.param == 0) continue;\n            for (int d = 0; d < divisors.Length; d++) {\n                int target = n * divisors[d];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('/', divisors[d], ln.steps + 1);\n            }\n            for (int s = 0; s < subtractors.Length; s++) {\n                int target = n + subtractors[s];\n                if (target > goal) break;\n                if (lookup[target].steps == 0 || lookup[target].steps > ln.steps) lookup[target] = ('-', subtractors[s], ln.steps + 1);\n            }\n        }\n        return lookup;\n    }\n\n    private static string Delimit<T>(this IEnumerable<T> source) => string.Join(\", \", source);\n}\n"}
{"id": 418525, "name": "2048", "source": "Translate Haskell to Python: import System.IO\nimport Data.List\nimport Data.Maybe\nimport Control.Monad\nimport Data.Random\nimport Data.Random.Distribution.Categorical\nimport System.Console.ANSI\nimport Control.Lens\n\n\n\n\nprob4 :: Double\nprob4 = 0.1\n\ntype Position = [[Int]]\n\ncombine, shift :: [Int]->[Int]\ncombine (x:y:l) | x==y = (2*x) : combine l\ncombine (x:l) = x : combine l\ncombine [] = []\n\nshift l = take (length l) $ combine (filter (>0) l) ++ [0,0..]\n\nreflect :: [[a]] ->[[a]]\nreflect = map reverse\n\ntype Move = Position -> Position\n\nleft, right, up, down :: Move\nleft = map shift\nright = reflect . left . reflect\nup = transpose . left . transpose\ndown = transpose . right . transpose\n\nprogress :: Eq a => (a -> a) -> a -> Maybe a\nprogress f pos = if pos==next_pos then Nothing else Just next_pos where next_pos= f pos\n\nlost, win:: Position -> Bool\nlost pos = all isNothing [progress move pos| move<-[left,right,up,down] ]\n\nwin = any $ any (>=2048)\n\ngo :: Position -> Maybe Move -> Maybe Position\ngo pos move = move >>= flip progress pos\n\n\n\n\n\nindicesOf :: [a] -> [ReifiedTraversal' [a] a]\nindicesOf l = [ Traversal $ ix i | i <- [0..length l - 1] ]\n\nindices2Of :: [[a]] -> [ReifiedTraversal' [[a]] a]\nindices2Of ls = [ Traversal $ i.j | Traversal i <- indicesOf ls, let Just l = ls ^? i, Traversal j <- indicesOf l]\n\nadd2or4 ::  Position -> RVar Position\nadd2or4 pos = do\n  xy <-  randomElement [ xy | Traversal xy <- indices2Of pos, pos ^? xy == Just 0 ]\n  a <- categorical [(1-prob4, 2), (prob4, 4) ]\n  return $  pos & xy .~ a\n\n\n\nplay :: Position -> IO ()\nplay pos = do\n   c <- getChar\n   case go pos $ lookup c [('D',left),('C',right),('A',up),('B',down)] of\n      Nothing -> play pos\n      Just pos1 -> do\n         pos2 <- sample $ add2or4 pos1\n         draw pos2\n         when (win pos2 && not (win pos)) $ putStrLn $ \"You win! You may keep going.\"\n         if lost pos2 then putStrLn \"You lost!\"\n            else play pos2\n\nmain :: IO ()\nmain = do\n  pos <- sample $ add2or4 $ replicate 4 (replicate 4 0)\n  draw pos\n  play pos\n\n\n\ncolors =\n [(0,\"\\ESC[38;5;234;48;5;250m     \")\n ,(2,\"\\ESC[38;5;234;48;5;255m  2  \")\n ,(4,\"\\ESC[38;5;234;48;5;230m  4  \")\n ,(8,\"\\ESC[38;5;15;48;5;208m  8  \")\n ,(16,\"\\ESC[38;5;15;48;5;209m  16 \")\n ,(32,\"\\ESC[38;5;15;48;5;203m  32 \")\n ,(64,\"\\ESC[38;5;15;48;5;9m  64 \")\n ,(128,\"\\ESC[38;5;15;48;5;228m 128 \")\n ,(256,\"\\ESC[38;5;15;48;5;227m 256 \")\n ,(512,\"\\ESC[38;5;15;48;5;226m 512 \")\n ,(1024,\"\\ESC[38;5;15;48;5;221m 1024\")\n ,(2048,\"\\ESC[38;5;15;48;5;220m 2048\")\n ,(4096,\"\\ESC[38;5;15;48;5;0m 4096\")\n ,(8192,\"\\ESC[38;5;15;48;5;0m 8192\")\n ,(16384,\"\\ESC[38;5;15;48;5;0m16384\")\n ,(32768,\"\\ESC[38;5;15;48;5;0m32768\")\n ,(65536,\"\\ESC[38;5;15;48;5;0m65536\")\n ,(131072,\"\\ESC[38;5;15;48;5;90m131072\")\n ]\n\nshowTile x = fromJust (lookup x colors) ++ \"\\ESC[B\\^H\\^H\\^H\\^H\\^H     \\ESC[A\\ESC[C\"\n\ndraw :: Position -> IO ()\ndraw pos = do\n  setSGR [Reset]\n  clearScreen\n  hideCursor\n  hSetEcho stdin False\n  hSetBuffering stdin NoBuffering\n  setSGR [SetConsoleIntensity BoldIntensity]\n  putStr \"\\ESC[38;5;234;48;5;248m\" \n  setCursorPosition 0 0\n  replicateM_ 13 $ putStrLn $ replicate 26 ' '\n  setCursorPosition 1 1\n  putStrLn $ intercalate \"\\n\\n\\n\\ESC[C\" $ concatMap showTile `map` pos\n", "target": "\n\nimport curses\nfrom random import randrange, choice \nfrom collections import defaultdict\n\nletter_codes = [ord(ch) for ch in 'WASDRQwasdrq']\nactions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']\nactions_dict = dict(zip(letter_codes, actions * 2))\n\ndef get_user_action(keyboard):    \n\tchar = \"N\"\n\twhile char not in actions_dict:    \n\t\tchar = keyboard.getch()\n\treturn actions_dict[char]\n\ndef transpose(field):\n\treturn [list(row) for row in zip(*field)]\n\ndef invert(field):\n\treturn [row[::-1] for row in field]\n\nclass GameField(object):\n\tdef __init__(self, height=4, width=4, win=2048):\n\t\tself.height = height\n\t\tself.width = width\n\t\tself.win_value = win\n\t\tself.score = 0\n\t\tself.highscore = 0\n\t\tself.reset()\n\n\tdef reset(self):\n\t\tif self.score > self.highscore:\n\t\t\tself.highscore = self.score\n\t\tself.score = 0\n\t\tself.field = [[0 for i in range(self.width)] for j in range(self.height)]\n\t\tself.spawn()\n\t\tself.spawn()\n\n\tdef move(self, direction):\n\t\tdef move_row_left(row):\n\t\t\tdef tighten(row): \n\t\t\t\tnew_row = [i for i in row if i != 0]\n\t\t\t\tnew_row += [0 for i in range(len(row) - len(new_row))]\n\t\t\t\treturn new_row\n\n\t\t\tdef merge(row):\n\t\t\t\tpair = False\n\t\t\t\tnew_row = []\n\t\t\t\tfor i in range(len(row)):\n\t\t\t\t\tif pair:\n\t\t\t\t\t\tnew_row.append(2 * row[i])\n\t\t\t\t\t\tself.score += 2 * row[i]\n\t\t\t\t\t\tpair = False\n\t\t\t\t\telse:\n\t\t\t\t\t\tif i + 1 < len(row) and row[i] == row[i + 1]:\n\t\t\t\t\t\t\tpair = True\n\t\t\t\t\t\t\tnew_row.append(0)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tnew_row.append(row[i])\n\t\t\t\tassert len(new_row) == len(row)\n\t\t\t\treturn new_row\n\t\t\treturn tighten(merge(tighten(row)))\n\n\t\tmoves = {}\n\t\tmoves['Left']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\t[move_row_left(row) for row in field]\n\t\tmoves['Right'] = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tinvert(moves['Left'](invert(field)))\n\t\tmoves['Up']    = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\ttranspose(moves['Left'](transpose(field)))\n\t\tmoves['Down']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\ttranspose(moves['Right'](transpose(field)))\n\n\t\tif direction in moves:\n\t\t\tif self.move_is_possible(direction):\n\t\t\t\tself.field = moves[direction](self.field)\n\t\t\t\tself.spawn()\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\n\tdef is_win(self):\n\t\treturn any(any(i >= self.win_value for i in row) for row in self.field)\n\n\tdef is_gameover(self):\n\t\treturn not any(self.move_is_possible(move) for move in actions)\n\n\tdef draw(self, screen):\n\t\thelp_string1 = '(W)Up (S)Down (A)Left (D)Right'\n\t\thelp_string2 = '     (R)Restart (Q)Exit'\n\t\tgameover_string = '           GAME OVER'\n\t\twin_string = '          YOU WIN!'\n\t\tdef cast(string):\n\t\t\tscreen.addstr(string + '\\n')\n\n\t\tdef draw_hor_separator():\n\t\t\ttop = '\u250c' + ('\u252c\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2510')[1:]\n\t\t\tmid = '\u251c' + ('\u253c\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2524')[1:]\n\t\t\tbot = '\u2514' + ('\u2534\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2518')[1:]\n\t\t\tseparator = defaultdict(lambda: mid)\n\t\t\tseparator[0], separator[self.height] = top, bot\n\t\t\tif not hasattr(draw_hor_separator, \"counter\"):\n\t\t\t\tdraw_hor_separator.counter = 0\n\t\t\tcast(separator[draw_hor_separator.counter])\n\t\t\tdraw_hor_separator.counter += 1\n\n\t\tdef draw_row(row):\n\t\t\tcast(''.join('\u2502{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '\u2502')\n\n\t\tscreen.clear()\n\t\tcast('SCORE: ' + str(self.score))\n\t\tif 0 != self.highscore:\n\t\t\tcast('HIGHSCORE: ' + str(self.highscore))\n\t\tfor row in self.field:\n\t\t\tdraw_hor_separator()\n\t\t\tdraw_row(row)\n\t\tdraw_hor_separator()\n\t\tif self.is_win():\n\t\t\tcast(win_string)\n\t\telse:\n\t\t\tif self.is_gameover():\n\t\t\t\tcast(gameover_string)\n\t\t\telse:\n\t\t\t\tcast(help_string1)\n\t\tcast(help_string2)\n\n\tdef spawn(self):\n\t\tnew_element = 4 if randrange(100) > 89 else 2\n\t\t(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])\n\t\tself.field[i][j] = new_element\n\n\tdef move_is_possible(self, direction):\n\t\tdef row_is_left_movable(row): \n\t\t\tdef change(i): \n\t\t\t\tif row[i] == 0 and row[i + 1] != 0: \n\t\t\t\t\treturn True\n\t\t\t\tif row[i] != 0 and row[i + 1] == row[i]: \n\t\t\t\t\treturn True\n\t\t\t\treturn False\n\t\t\treturn any(change(i) for i in range(len(row) - 1))\n\n\t\tcheck = {}\n\t\tcheck['Left']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tany(row_is_left_movable(row) for row in field)\n\n\t\tcheck['Right'] = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\t check['Left'](invert(field))\n\n\t\tcheck['Up']    = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tcheck['Left'](transpose(field))\n\n\t\tcheck['Down']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tcheck['Right'](transpose(field))\n\n\t\tif direction in check:\n\t\t\treturn check[direction](self.field)\n\t\telse:\n\t\t\treturn False\n\ndef main(stdscr):\n\tcurses.use_default_colors()\n\tgame_field = GameField(win=32)\n\tstate_actions = {} \n\tdef init():\n\t\tgame_field.reset()\n\t\treturn 'Game'\n\n\tstate_actions['Init'] = init\n\n\tdef not_game(state):\n\t\tgame_field.draw(stdscr)\n\t\taction = get_user_action(stdscr)\n\t\tresponses = defaultdict(lambda: state)\n\t\tresponses['Restart'], responses['Exit'] = 'Init', 'Exit'\n\t\treturn responses[action]\n\n\tstate_actions['Win'] = lambda: not_game('Win')\n\tstate_actions['Gameover'] = lambda: not_game('Gameover')\n\n\tdef game():\n\t\tgame_field.draw(stdscr)\n\t\taction = get_user_action(stdscr)\n\t\tif action == 'Restart':\n\t\t\treturn 'Init'\n\t\tif action == 'Exit':\n\t\t\treturn 'Exit'\n\t\tif game_field.move(action): \n\t\t\tif game_field.is_win():\n\t\t\t\treturn 'Win'\n\t\t\tif game_field.is_gameover():\n\t\t\t\treturn 'Gameover'\n\t\treturn 'Game'\n\t\t\n\tstate_actions['Game'] = game\n\n\tstate = 'Init'\n\twhile state != 'Exit':\n\t\tstate = state_actions[state]()\n\ncurses.wrapper(main)\n"}
{"id": 418526, "name": "Pig the dice game_Player", "source": "Translate Haskell to Python: \n\nmodule Main where\n\nimport System.Random (randomRIO)\nimport Text.Printf   (printf)\n\ndata PInfo = PInfo { stack :: Int\n                   , score :: Int\n                   , rolls :: Int\n                   , next  :: Bool\n                   , won   :: Bool\n                   , name  :: String\n                   }\n\ntype Strategy = [PInfo] -> IO ()\n\nroll :: [PInfo] -> IO [PInfo]\nroll (pinfo:xs) = do\n  face <- randomRIO (1, 6)\n  case (face, face + stack pinfo + score pinfo) of\n      (1,_)            -> do\n          printf \"%s rolled 1 - stack is being resetted\\n\\n\" (name pinfo)\n          return $ pinfo { stack = 0, rolls = 0, next = True } : xs\n      (_,x) | x >= 100 -> do\n          printf \"%s rolled %i - stack is now %i + score %i => %i - I won!\\n\" (name pinfo) face (face + stack pinfo) (score pinfo) x\n          return $ pinfo { won = True } : xs\n      (_,_)            -> do\n          printf \"%s rolled %i - stack is now %i\\n\" (name pinfo) face (face + (stack pinfo))\n          return $ pinfo { stack = face + (stack pinfo), rolls = 1 + (rolls pinfo) } : xs\n\nhold :: [PInfo] -> IO [PInfo]\nhold (pinfo:xs) = do\n  let score' = stack pinfo + score pinfo\n  printf \"%s holds - score is now %i\\n\\n\" (name pinfo) score'\n  return $ pinfo { score = score', stack = 0, rolls = 0, next = True } : xs\n\n\nlogic :: Strategy -> Strategy -> Strategy\nlogic _      _      ((won -> True)    : xs) = return ()\nlogic _      strat2 (p@(next -> True) : xs) = strat2 $ xs ++ [p { next = False }]\nlogic strat1 _      (pinfo            : xs) = strat1 (pinfo : xs)\n\nstrat1 :: Strategy\nstrat1 (pinfo:xs)\n  | stack pinfo < 20 = roll (pinfo:xs) >>= logic strat1 strat2\n  | otherwise        = hold (pinfo:xs) >>= logic strat1 strat2\n\nstrat2 :: Strategy\nstrat2 (pinfo:xs)\n  | rolls pinfo < 4 = roll (pinfo:xs) >>= logic strat2 strat3\n  | otherwise       = hold (pinfo:xs) >>= logic strat2 strat3\n\nstrat3 :: Strategy\nstrat3 (pinfo:xs)\n  | rolls pinfo < 3 && score pinfo < 60 = roll (pinfo:xs) >>= logic strat3 strat4\n  | stack pinfo < 20                    = roll (pinfo:xs) >>= logic strat3 strat4\n  | otherwise                           = hold (pinfo:xs) >>= logic strat3 strat4\n\nstrat4 :: Strategy\nstrat4 (pinfo:xs) | score pinfo > 75 = roll (pinfo:xs) >>= logic strat4 strat1\nstrat4 (pinfo:xs) = do\n  chance <- randomRIO (0, 3) :: IO Int\n  case chance of\n      0  -> hold (pinfo:xs) >>= logic strat4 strat1\n      _  -> roll (pinfo:xs) >>= logic strat4 strat1\n\nmain :: IO ()\nmain = do\n  let pInfo = PInfo 0 0 0 False False \"\"\n      p1    = pInfo { name = \"Peter\"   }\n      p2    = pInfo { name = \"Mia\"     }\n      p3    = pInfo { name = \"Liz\"     }\n      p4    = pInfo { name = \"Stephen\" }\n  strat1 [p1, p2, p3, p4]\n", "target": "\n\n\n\nfrom random import randint\nfrom collections import namedtuple\nimport random\nfrom pprint import pprint as pp\nfrom collections import Counter\n\n\nplayercount = 2\nmaxscore = 100\nmaxgames = 100000\n\n\nGame = namedtuple('Game', 'players, maxscore, rounds')\nRound = namedtuple('Round', 'who, start, scores, safe')\n\n\nclass Player():\n    def __init__(self, player_index):\n        self.player_index = player_index\n\n    def __repr__(self):\n        return '%s(%i)' % (self.__class__.__name__, self.player_index)\n\n    def __call__(self, safescore, scores, game):\n        'Returns boolean True to roll again'\n        pass\n\nclass RandPlay(Player):\n    def __call__(self, safe, scores, game):\n        'Returns random boolean choice of whether to roll again'\n        return bool(random.randint(0, 1))\n\nclass RollTo20(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and(sum(scores) < 20))                                  \n\nclass Desparat(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20 or someone is within 20 of winning'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and( (sum(scores) < 20)                                 \n                     or max(safe) >= (maxscore - 20)))                  \n\n\ndef game__str__(self):\n    'Pretty printer for Game class'\n    return (\"Game(players=%r, maxscore=%i,\\n  rounds=[\\n    %s\\n  ])\"\n            % (self.players, self.maxscore,\n               ',\\n    '.join(repr(round) for round in self.rounds)))\nGame.__str__ = game__str__\n\n\ndef winningorder(players, safescores):\n    'Return (players in winning order, their scores)'\n    return tuple(zip(*sorted(zip(players, safescores),\n                            key=lambda x: x[1], reverse=True)))\n\ndef playpig(game):\n    \n    players, maxscore, rounds = game\n    playercount = len(players)\n    safescore = [0] * playercount   \n    player = 0                      \n    scores=[]                       \n\n    while max(safescore) < maxscore:\n        startscore = safescore[player]\n        rolling = players[player](safescore, scores, game)\n        if rolling:\n            rolled = randint(1, 6)\n            scores.append(rolled)\n            if rolled == 1:\n                \n                round = Round(who=players[player],\n                              start=startscore,\n                              scores=scores,\n                              safe=safescore[player])\n                rounds.append(round)\n                scores, player = [], (player + 1) % playercount\n        else:\n            \n            safescore[player] += sum(scores)\n            round = Round(who=players[player],\n                          start=startscore,\n                          scores=scores,\n                          safe=safescore[player])\n            rounds.append(round)\n            if safescore[player] >= maxscore:\n                break\n            scores, player = [], (player + 1) % playercount\n\n    \n    return winningorder(players, safescore)\n\nif __name__ == '__main__':\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=20,\n                rounds=[])\n    print('ONE GAME')\n    print('Winning order: %r; Respective scores: %r\\n' % playpig(game))\n    print(game)\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=maxscore,\n                rounds=[])\n    algos = (RollTo20, RandPlay, Desparat)\n    print('\\n\\nMULTIPLE STATISTICS using %r\\n  for %i GAMES'\n          % (', '.join(p.__name__ for p in algos), maxgames,))\n    winners = Counter(repr(playpig(game._replace(players=tuple(random.choice(algos)(i)\n                                                               for i in range(playercount)),\n                                                 rounds=[]))[0])\n                      for i in range(maxgames))\n    print('  Players(position) winning on left; occurrences on right:\\n    %s'\n          % ',\\n    '.join(str(w) for w in winners.most_common()))\n"}
{"id": 418527, "name": "Pig the dice game_Player", "source": "Translate Haskell to Python: \n\nmodule Main where\n\nimport System.Random (randomRIO)\nimport Text.Printf   (printf)\n\ndata PInfo = PInfo { stack :: Int\n                   , score :: Int\n                   , rolls :: Int\n                   , next  :: Bool\n                   , won   :: Bool\n                   , name  :: String\n                   }\n\ntype Strategy = [PInfo] -> IO ()\n\nroll :: [PInfo] -> IO [PInfo]\nroll (pinfo:xs) = do\n  face <- randomRIO (1, 6)\n  case (face, face + stack pinfo + score pinfo) of\n      (1,_)            -> do\n          printf \"%s rolled 1 - stack is being resetted\\n\\n\" (name pinfo)\n          return $ pinfo { stack = 0, rolls = 0, next = True } : xs\n      (_,x) | x >= 100 -> do\n          printf \"%s rolled %i - stack is now %i + score %i => %i - I won!\\n\" (name pinfo) face (face + stack pinfo) (score pinfo) x\n          return $ pinfo { won = True } : xs\n      (_,_)            -> do\n          printf \"%s rolled %i - stack is now %i\\n\" (name pinfo) face (face + (stack pinfo))\n          return $ pinfo { stack = face + (stack pinfo), rolls = 1 + (rolls pinfo) } : xs\n\nhold :: [PInfo] -> IO [PInfo]\nhold (pinfo:xs) = do\n  let score' = stack pinfo + score pinfo\n  printf \"%s holds - score is now %i\\n\\n\" (name pinfo) score'\n  return $ pinfo { score = score', stack = 0, rolls = 0, next = True } : xs\n\n\nlogic :: Strategy -> Strategy -> Strategy\nlogic _      _      ((won -> True)    : xs) = return ()\nlogic _      strat2 (p@(next -> True) : xs) = strat2 $ xs ++ [p { next = False }]\nlogic strat1 _      (pinfo            : xs) = strat1 (pinfo : xs)\n\nstrat1 :: Strategy\nstrat1 (pinfo:xs)\n  | stack pinfo < 20 = roll (pinfo:xs) >>= logic strat1 strat2\n  | otherwise        = hold (pinfo:xs) >>= logic strat1 strat2\n\nstrat2 :: Strategy\nstrat2 (pinfo:xs)\n  | rolls pinfo < 4 = roll (pinfo:xs) >>= logic strat2 strat3\n  | otherwise       = hold (pinfo:xs) >>= logic strat2 strat3\n\nstrat3 :: Strategy\nstrat3 (pinfo:xs)\n  | rolls pinfo < 3 && score pinfo < 60 = roll (pinfo:xs) >>= logic strat3 strat4\n  | stack pinfo < 20                    = roll (pinfo:xs) >>= logic strat3 strat4\n  | otherwise                           = hold (pinfo:xs) >>= logic strat3 strat4\n\nstrat4 :: Strategy\nstrat4 (pinfo:xs) | score pinfo > 75 = roll (pinfo:xs) >>= logic strat4 strat1\nstrat4 (pinfo:xs) = do\n  chance <- randomRIO (0, 3) :: IO Int\n  case chance of\n      0  -> hold (pinfo:xs) >>= logic strat4 strat1\n      _  -> roll (pinfo:xs) >>= logic strat4 strat1\n\nmain :: IO ()\nmain = do\n  let pInfo = PInfo 0 0 0 False False \"\"\n      p1    = pInfo { name = \"Peter\"   }\n      p2    = pInfo { name = \"Mia\"     }\n      p3    = pInfo { name = \"Liz\"     }\n      p4    = pInfo { name = \"Stephen\" }\n  strat1 [p1, p2, p3, p4]\n", "target": "\n\n\n\nfrom random import randint\nfrom collections import namedtuple\nimport random\nfrom pprint import pprint as pp\nfrom collections import Counter\n\n\nplayercount = 2\nmaxscore = 100\nmaxgames = 100000\n\n\nGame = namedtuple('Game', 'players, maxscore, rounds')\nRound = namedtuple('Round', 'who, start, scores, safe')\n\n\nclass Player():\n    def __init__(self, player_index):\n        self.player_index = player_index\n\n    def __repr__(self):\n        return '%s(%i)' % (self.__class__.__name__, self.player_index)\n\n    def __call__(self, safescore, scores, game):\n        'Returns boolean True to roll again'\n        pass\n\nclass RandPlay(Player):\n    def __call__(self, safe, scores, game):\n        'Returns random boolean choice of whether to roll again'\n        return bool(random.randint(0, 1))\n\nclass RollTo20(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and(sum(scores) < 20))                                  \n\nclass Desparat(Player):\n    def __call__(self, safe, scores, game):\n        'Roll again if this rounds score < 20 or someone is within 20 of winning'\n        return (((sum(scores) + safe[self.player_index]) < maxscore)    \n                and( (sum(scores) < 20)                                 \n                     or max(safe) >= (maxscore - 20)))                  \n\n\ndef game__str__(self):\n    'Pretty printer for Game class'\n    return (\"Game(players=%r, maxscore=%i,\\n  rounds=[\\n    %s\\n  ])\"\n            % (self.players, self.maxscore,\n               ',\\n    '.join(repr(round) for round in self.rounds)))\nGame.__str__ = game__str__\n\n\ndef winningorder(players, safescores):\n    'Return (players in winning order, their scores)'\n    return tuple(zip(*sorted(zip(players, safescores),\n                            key=lambda x: x[1], reverse=True)))\n\ndef playpig(game):\n    \n    players, maxscore, rounds = game\n    playercount = len(players)\n    safescore = [0] * playercount   \n    player = 0                      \n    scores=[]                       \n\n    while max(safescore) < maxscore:\n        startscore = safescore[player]\n        rolling = players[player](safescore, scores, game)\n        if rolling:\n            rolled = randint(1, 6)\n            scores.append(rolled)\n            if rolled == 1:\n                \n                round = Round(who=players[player],\n                              start=startscore,\n                              scores=scores,\n                              safe=safescore[player])\n                rounds.append(round)\n                scores, player = [], (player + 1) % playercount\n        else:\n            \n            safescore[player] += sum(scores)\n            round = Round(who=players[player],\n                          start=startscore,\n                          scores=scores,\n                          safe=safescore[player])\n            rounds.append(round)\n            if safescore[player] >= maxscore:\n                break\n            scores, player = [], (player + 1) % playercount\n\n    \n    return winningorder(players, safescore)\n\nif __name__ == '__main__':\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=20,\n                rounds=[])\n    print('ONE GAME')\n    print('Winning order: %r; Respective scores: %r\\n' % playpig(game))\n    print(game)\n    game = Game(players=tuple(RandPlay(i) for i in range(playercount)),\n                maxscore=maxscore,\n                rounds=[])\n    algos = (RollTo20, RandPlay, Desparat)\n    print('\\n\\nMULTIPLE STATISTICS using %r\\n  for %i GAMES'\n          % (', '.join(p.__name__ for p in algos), maxgames,))\n    winners = Counter(repr(playpig(game._replace(players=tuple(random.choice(algos)(i)\n                                                               for i in range(playercount)),\n                                                 rounds=[]))[0])\n                      for i in range(maxgames))\n    print('  Players(position) winning on left; occurrences on right:\\n    %s'\n          % ',\\n    '.join(str(w) for w in winners.most_common()))\n"}
{"id": 418528, "name": "Find words which contain the most consonants", "source": "Translate Haskell to Python: \n\n\n\n\n\nimport Data.Bifunctor (first)\nimport Data.Char (toUpper)\nimport Data.Function (on)\nimport Data.List ((\\\\), groupBy, intersect, nub, sortOn)\nimport Data.Ord (Down(..))\n\n\nconsonants :: String\nconsonants = cons ++ map toUpper cons\n  where cons = ['a'..'z'] \\\\ \"aeiou\"\n\n\nonlyConsonants :: String -> String\nonlyConsonants = (`intersect` consonants)\n\n\nmostDistinctConsonants :: [String] -> [String]\nmostDistinctConsonants = map snd\n                       . head'\n                       . groupBy ((==) `on` fst)\n                       . sortOn (Down . fst)\n                       . map (first length)\n                       . filter (allDistinct . fst)\n                       . map (\\s -> (onlyConsonants s, s))\n  where head' = \\case { [] -> []; (xs:_) -> xs; }\n        allDistinct s = s == nub s\n\nmain :: IO ()\nmain = interact (unlines . mostDistinctConsonants . filter longEnough . words)\n  where longEnough xs = length xs > 10\n", "target": "print('\\n'.join((f'{x[0]}: {\" \".join(sorted(x[1]))}' if len(x[1]) < 30 else f'{x[0]}: {len(x[1])} words' for x in\n      (x for x in ((n, [x[1] for x in l if x[0] == n]) for n in range(maxlen, -1, -1)) if x[1]))) if (maxlen := max(l := [(len(c), w)\n      for w in [l for l in [l.rstrip() for l in open('unixdict.txt')] if len(l) > 10 and all(c >= 'a' and c <= 'z' for c in l)]\n      if sorted(c := w.replace('a', '').replace('e', '').replace('i', '').replace('o', '').replace('u', '')) == sorted(set(c))])[0]) else None)\n"}
{"id": 418529, "name": "Modified random distribution", "source": "Translate Haskell to Python: import System.Random\nimport Data.List\nimport Text.Printf\n\nmodify :: Ord a => (a -> a) -> [a] -> [a]\nmodify f = foldMap test . pairs \n  where\n    pairs lst = zip lst (tail lst)\n    test (r1, r2) = if r2 < f r1 then [r1] else []\n\nvShape x = if x < 0.5 then 2*(0.5-x) else 2*(x-0.5)\n\nhist b lst = zip [0,b..] res\n  where\n    res = (`div` sum counts) . (*300) <$> counts\n    counts = map length $ group $\n             sort $ floor . (/b) <$> lst\n\nshowHist h = foldMap mkLine h\n  where\n    mkLine (b,n) = printf \"%.2f\\t%s %d%%\\n\" b (replicate n '\u2587') n\n", "target": "import random\nfrom typing import List, Callable, Optional\n\n\ndef modifier(x: float) -> float:\n    \n    return 2*(.5 - x) if x < 0.5 else 2*(x - .5)\n\n\ndef modified_random_distribution(modifier: Callable[[float], float],\n                                 n: int) -> List[float]:\n    \n    d: List[float] = []\n    while len(d) < n:\n        r1 = prob = random.random()\n        if random.random() < modifier(prob):\n            d.append(r1)\n    return d\n\n\nif __name__ == '__main__':\n    from collections import Counter\n\n    data = modified_random_distribution(modifier, 50_000)\n    bins = 15\n    counts = Counter(d // (1 / bins) for d in data)\n    \n    mx = max(counts.values())\n    print(\"   BIN, COUNTS, DELTA: HISTOGRAM\\n\")\n    last: Optional[float] = None\n    for b, count in sorted(counts.items()):\n        delta = 'N/A' if last is None else str(count - last)\n        print(f\"  {b / bins:5.2f},  {count:4},  {delta:>4}: \"\n              f\"{'\n        last = count\n"}
{"id": 418530, "name": "Modified random distribution", "source": "Translate Haskell to Python: import System.Random\nimport Data.List\nimport Text.Printf\n\nmodify :: Ord a => (a -> a) -> [a] -> [a]\nmodify f = foldMap test . pairs \n  where\n    pairs lst = zip lst (tail lst)\n    test (r1, r2) = if r2 < f r1 then [r1] else []\n\nvShape x = if x < 0.5 then 2*(0.5-x) else 2*(x-0.5)\n\nhist b lst = zip [0,b..] res\n  where\n    res = (`div` sum counts) . (*300) <$> counts\n    counts = map length $ group $\n             sort $ floor . (/b) <$> lst\n\nshowHist h = foldMap mkLine h\n  where\n    mkLine (b,n) = printf \"%.2f\\t%s %d%%\\n\" b (replicate n '\u2587') n\n", "target": "import random\nfrom typing import List, Callable, Optional\n\n\ndef modifier(x: float) -> float:\n    \n    return 2*(.5 - x) if x < 0.5 else 2*(x - .5)\n\n\ndef modified_random_distribution(modifier: Callable[[float], float],\n                                 n: int) -> List[float]:\n    \n    d: List[float] = []\n    while len(d) < n:\n        r1 = prob = random.random()\n        if random.random() < modifier(prob):\n            d.append(r1)\n    return d\n\n\nif __name__ == '__main__':\n    from collections import Counter\n\n    data = modified_random_distribution(modifier, 50_000)\n    bins = 15\n    counts = Counter(d // (1 / bins) for d in data)\n    \n    mx = max(counts.values())\n    print(\"   BIN, COUNTS, DELTA: HISTOGRAM\\n\")\n    last: Optional[float] = None\n    for b, count in sorted(counts.items()):\n        delta = 'N/A' if last is None else str(count - last)\n        print(f\"  {b / bins:5.2f},  {count:4},  {delta:>4}: \"\n              f\"{'\n        last = count\n"}
{"id": 418531, "name": "Common list elements", "source": "Translate Haskell to Python: import qualified Data.Set as Set\n\ntask :: Ord a => [[a]] -> [a]\ntask [] = []\ntask xs = Set.toAscList . foldl1 Set.intersection . map Set.fromList $ xs\n\nmain = print $ task  [[2,5,1,3,8,9,4,6], [3,5,6,2,9,8,4], [1,3,7,6,9]]\n", "target": "\n\ndef common_list_elements(*lists):\n    return list(set.intersection(*(set(list_) for list_ in lists)))\n\n\nif __name__ == \"__main__\":\n    test_cases = [\n        ([2, 5, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 9, 8, 4], [1, 3, 7, 6, 9]),\n        ([2, 2, 1, 3, 8, 9, 4, 6], [3, 5, 6, 2, 2, 2, 4], [2, 3, 7, 6, 2]),\n    ]\n\n    for case in test_cases:\n        result = common_list_elements(*case)\n        print(f\"Intersection of {case} is {result}\")\n"}
{"id": 418532, "name": "Maze solving", "source": "Translate Haskell to Python: #!/usr/bin/runhaskell\n\nimport Data.Maybe (fromMaybe)\n\n\naverage :: (Int, Int) -> (Int, Int) -> (Int, Int)\naverage (x, y) (x_, y_) = ((x + x_) `div` 2, (y + y_) `div` 2)\n\n\n\nnotBlocked :: [String] -> ((Int, Int), (Int, Int)) -> Bool\nnotBlocked maze (_, (x, y)) = ' ' == (maze !! y) !! x\n\n\n\n\n\nsubstitute :: [a] -> Int -> a -> [a]\nsubstitute orig pos el =\n  let (before, after) = splitAt pos orig\n  in before ++ [el] ++ tail after\n\n\ndraw :: [String] -> (Int, Int) -> [String]\ndraw maze (x, y) =\n  let row = maze !! y\n  in substitute maze y $ substitute row x '*'\n\n\n\n\ntryMoves :: [String]\n         -> (Int, Int)\n         -> [((Int, Int), (Int, Int))]\n         -> Maybe [String]\ntryMoves _ _ [] = Nothing\ntryMoves maze prevPos ((newPos, wallPos):more) =\n  case solve_ maze newPos prevPos of\n    Nothing -> tryMoves maze prevPos more\n    Just maze_ -> Just $ foldl draw maze_ [newPos, wallPos]\n\n\n\n\nsolve_ :: [String] -> (Int, Int) -> (Int, Int) -> Maybe [String]\nsolve_ maze (2, 1) _ = Just maze\nsolve_ maze pos@(x, y) prevPos =\n  let newPositions = [(x, y - 2), (x + 4, y), (x, y + 2), (x - 4, y)]\n      notPrev pos_ = pos_ /= prevPos\n      newPositions_ = filter notPrev newPositions\n      wallPositions = map (average pos) newPositions_\n      zipped = zip newPositions_ wallPositions\n      legalMoves = filter (notBlocked maze) zipped\n  in tryMoves maze pos legalMoves\n\n\n\nsolve :: [String] -> Maybe [String]\nsolve maze = solve_ (draw maze start) start (-1, -1)\n  where\n    startx = length (head maze) - 3\n    starty = length maze - 2\n    start = (startx, starty)\n\n\nmain =\n  let main_ = unlines . fromMaybe [\"can_t solve\"] . solve . lines\n  in interact main_\n", "target": "\n\ndef Dijkstra(Graph, source):\n    \n    \n    infinity = float('infinity')\n    n = len(graph)\n    dist = [infinity]*n   \n    previous = [infinity]*n \n    dist[source] = 0        \n    Q = list(range(n)) \n    while Q:           \n        u = min(Q, key=lambda n:dist[n])                 \n        Q.remove(u)\n        if dist[u] == infinity:\n            break \n        for v in range(n):               \n            if Graph[u][v] and (v in Q): \n                alt = dist[u] + Graph[u][v]\n                if alt < dist[v]:       \n                    dist[v] = alt\n                    previous[v] = u\n    return dist,previous\n\ndef display_solution(predecessor):\n    cell = len(predecessor)-1\n    while cell:\n        print(cell,end='<')\n        cell = predecessor[cell]\n    print(0)\n"}
{"id": 418533, "name": "Deming's funnel", "source": "Translate Haskell to Python: import Data.List (mapAccumL, genericLength)\nimport Text.Printf\n\nfunnel :: (Num a) => (a -> a -> a) -> [a] -> [a]\nfunnel rule = snd . mapAccumL (\\x dx -> (rule x dx, x + dx)) 0\n\nmean :: (Fractional a) => [a] -> a \nmean xs = sum xs / genericLength xs\n\nstddev :: (Floating a) => [a] -> a\nstddev xs = sqrt $ sum [(x-m)**2 | x <- xs] / genericLength xs where\n              m = mean xs\n\nexperiment :: String -> [Double] -> [Double] -> (Double -> Double -> Double) -> IO ()\nexperiment label dxs dys rule = do\n  let rxs = funnel rule dxs\n      rys = funnel rule dys\n  putStrLn label\n  printf \"Mean x, y   \u00a0: %7.4f, %7.4f\\n\" (mean rxs) (mean rys)\n  printf \"Std dev x, y\u00a0: %7.4f, %7.4f\\n\" (stddev rxs) (stddev rys)\n  putStrLn \"\"\n\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nmain :: IO ()\nmain = do\n  experiment \"Rule 1:\" dxs dys (\\_ _  -> 0)\n  experiment \"Rule 2:\" dxs dys (\\_ dz -> -dz)\n  experiment \"Rule 3:\" dxs dys (\\z dz -> -(z+dz))\n  experiment \"Rule 4:\" dxs dys (\\z dz -> z+dz)\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 418534, "name": "Deming's funnel", "source": "Translate Haskell to Python: import Data.List (mapAccumL, genericLength)\nimport Text.Printf\n\nfunnel :: (Num a) => (a -> a -> a) -> [a] -> [a]\nfunnel rule = snd . mapAccumL (\\x dx -> (rule x dx, x + dx)) 0\n\nmean :: (Fractional a) => [a] -> a \nmean xs = sum xs / genericLength xs\n\nstddev :: (Floating a) => [a] -> a\nstddev xs = sqrt $ sum [(x-m)**2 | x <- xs] / genericLength xs where\n              m = mean xs\n\nexperiment :: String -> [Double] -> [Double] -> (Double -> Double -> Double) -> IO ()\nexperiment label dxs dys rule = do\n  let rxs = funnel rule dxs\n      rys = funnel rule dys\n  putStrLn label\n  printf \"Mean x, y   \u00a0: %7.4f, %7.4f\\n\" (mean rxs) (mean rys)\n  printf \"Std dev x, y\u00a0: %7.4f, %7.4f\\n\" (stddev rxs) (stddev rys)\n  putStrLn \"\"\n\n\ndxs = [ -0.533,  0.270,  0.859, -0.043, -0.205, -0.127, -0.071,  0.275,\n         1.251, -0.231, -0.401,  0.269,  0.491,  0.951,  1.150,  0.001,\n        -0.382,  0.161,  0.915,  2.080, -2.337,  0.034, -0.126,  0.014,\n         0.709,  0.129, -1.093, -0.483, -1.193,  0.020, -0.051,  0.047,\n        -0.095,  0.695,  0.340, -0.182,  0.287,  0.213, -0.423, -0.021,\n        -0.134,  1.798,  0.021, -1.099, -0.361,  1.636, -1.134,  1.315,\n         0.201,  0.034,  0.097, -0.170,  0.054, -0.553, -0.024, -0.181,\n        -0.700, -0.361, -0.789,  0.279, -0.174, -0.009, -0.323, -0.658,\n         0.348, -0.528,  0.881,  0.021, -0.853,  0.157,  0.648,  1.774,\n        -1.043,  0.051,  0.021,  0.247, -0.310,  0.171,  0.000,  0.106,\n         0.024, -0.386,  0.962,  0.765, -0.125, -0.289,  0.521,  0.017,\n         0.281, -0.749, -0.149, -2.436, -0.909,  0.394, -0.113, -0.598,\n         0.443, -0.521, -0.799,  0.087]\n\ndys = [  0.136,  0.717,  0.459, -0.225,  1.392,  0.385,  0.121, -0.395,\n         0.490, -0.682, -0.065,  0.242, -0.288,  0.658,  0.459,  0.000,\n         0.426,  0.205, -0.765, -2.188, -0.742, -0.010,  0.089,  0.208,\n         0.585,  0.633, -0.444, -0.351, -1.087,  0.199,  0.701,  0.096,\n        -0.025, -0.868,  1.051,  0.157,  0.216,  0.162,  0.249, -0.007,\n         0.009,  0.508, -0.790,  0.723,  0.881, -0.508,  0.393, -0.226,\n         0.710,  0.038, -0.217,  0.831,  0.480,  0.407,  0.447, -0.295,\n         1.126,  0.380,  0.549, -0.445, -0.046,  0.428, -0.074,  0.217,\n        -0.822,  0.491,  1.347, -0.141,  1.230, -0.044,  0.079,  0.219,\n         0.698,  0.275,  0.056,  0.031,  0.421,  0.064,  0.721,  0.104,\n        -0.729,  0.650, -1.103,  0.154, -1.720,  0.051, -0.385,  0.477,\n         1.537, -0.901,  0.939, -0.411,  0.341, -0.411,  0.106,  0.224,\n        -0.947, -1.424, -0.542, -1.032]\n\nmain :: IO ()\nmain = do\n  experiment \"Rule 1:\" dxs dys (\\_ _  -> 0)\n  experiment \"Rule 2:\" dxs dys (\\_ dz -> -dz)\n  experiment \"Rule 3:\" dxs dys (\\z dz -> -(z+dz))\n  experiment \"Rule 4:\" dxs dys (\\z dz -> z+dz)\n", "target": "import math \n\ndxs = [-0.533, 0.27, 0.859, -0.043, -0.205, -0.127, -0.071, 0.275, 1.251,\n       -0.231, -0.401, 0.269, 0.491, 0.951, 1.15, 0.001, -0.382, 0.161, 0.915,\n       2.08, -2.337, 0.034, -0.126, 0.014, 0.709, 0.129, -1.093, -0.483, -1.193, \n       0.02, -0.051, 0.047, -0.095, 0.695, 0.34, -0.182, 0.287, 0.213, -0.423,\n       -0.021, -0.134, 1.798, 0.021, -1.099, -0.361, 1.636, -1.134, 1.315, 0.201, \n       0.034, 0.097, -0.17, 0.054, -0.553, -0.024, -0.181, -0.7, -0.361, -0.789,\n       0.279, -0.174, -0.009, -0.323, -0.658, 0.348, -0.528, 0.881, 0.021, -0.853,\n       0.157, 0.648, 1.774, -1.043, 0.051, 0.021, 0.247, -0.31, 0.171, 0.0, 0.106,\n       0.024, -0.386, 0.962, 0.765, -0.125, -0.289, 0.521, 0.017, 0.281, -0.749,\n       -0.149, -2.436, -0.909, 0.394, -0.113, -0.598, 0.443, -0.521, -0.799, \n       0.087]\n\ndys = [0.136, 0.717, 0.459, -0.225, 1.392, 0.385, 0.121, -0.395, 0.49, -0.682,\n       -0.065, 0.242, -0.288, 0.658, 0.459, 0.0, 0.426, 0.205, -0.765, -2.188, \n       -0.742, -0.01, 0.089, 0.208, 0.585, 0.633, -0.444, -0.351, -1.087, 0.199,\n       0.701, 0.096, -0.025, -0.868, 1.051, 0.157, 0.216, 0.162, 0.249, -0.007, \n       0.009, 0.508, -0.79, 0.723, 0.881, -0.508, 0.393, -0.226, 0.71, 0.038, \n       -0.217, 0.831, 0.48, 0.407, 0.447, -0.295, 1.126, 0.38, 0.549, -0.445, \n       -0.046, 0.428, -0.074, 0.217, -0.822, 0.491, 1.347, -0.141, 1.23, -0.044, \n       0.079, 0.219, 0.698, 0.275, 0.056, 0.031, 0.421, 0.064, 0.721, 0.104, \n       -0.729, 0.65, -1.103, 0.154, -1.72, 0.051, -0.385, 0.477, 1.537, -0.901, \n       0.939, -0.411, 0.341, -0.411, 0.106, 0.224, -0.947, -1.424, -0.542, -1.032]\n\ndef funnel(dxs, rule):\n    x, rxs = 0, []\n    for dx in dxs:\n        rxs.append(x + dx)\n        x = rule(x, dx)\n    return rxs\n\ndef mean(xs): return sum(xs) / len(xs)\n\ndef stddev(xs):\n    m = mean(xs)\n    return math.sqrt(sum((x-m)**2 for x in xs) / len(xs))\n\ndef experiment(label, rule):\n    rxs, rys = funnel(dxs, rule), funnel(dys, rule)\n    print label\n    print 'Mean x, y   \u00a0: %.4f, %.4f' % (mean(rxs), mean(rys))\n    print 'Std dev x, y\u00a0: %.4f, %.4f' % (stddev(rxs), stddev(rys))\n    print\n\n\nexperiment('Rule 1:', lambda z, dz: 0)\nexperiment('Rule 2:', lambda z, dz: -dz)\nexperiment('Rule 3:', lambda z, dz: -(z+dz))\nexperiment('Rule 4:', lambda z, dz: z+dz)\n"}
{"id": 418535, "name": "Hunt the Wumpus", "source": "Translate Haskell to Python: import System.Random\nimport System.IO\nimport Data.List\nimport Data.Char\nimport Control.Monad\n\n\ncave :: [[Int]]\ncave = [\n    [1,4,7],    [0,2,9],   [1,3,11],   [2,4,13],   [0,3,5],\n    [4,6,14],   [5,7,16],  [0,6,8],    [7,9,17],   [1,8,10],\n    [9,11,18],  [2,10,12], [11,13,19], [3,12,14],  [5,13,15],\n    [14,16,19], [6,15,17], [8,16,18],  [10,17,19], [12,15,18]]\n\ncaveSize :: Int\ncaveSize = length cave\n\n\ndata GameState = GameState {\n    wumpus :: Int,\n    player :: Int,\n    arrows :: Int,\n    pits :: [Int],\n    bats :: [Int]\n}\n\n\ninstance Show GameState where\n    show g = \"You are in room \" ++ show (player g) ++ \". \" ++\n             \"Adjacent rooms are: \" ++ (intercalate \", \" $ map show adjs) ++\n             \".\\nYou have \" ++ show (arrows g) ++ \" arrows.\\n\\n\" ++\n             adjMsgs \n        where adjs    = cave!!player g\n              adj     = any (`elem` adjs) . ($ g)\n              adjMsgs = unlines $\n                  [\"You smell something terrible nearby.\" | adj $ pure.wumpus]\n               ++ [\"You hear a rustling.\" | adj bats]\n               ++ [\"You feel a cold wind blowing from a nearby cavern.\" | adj pits]\n\n\ninitGame :: StdGen -> GameState\ninitGame g = \n    GameState {wumpus=w, player=p, arrows=5, pits=[p1,p2], bats=[b1,b2]}\n    where [w, p, p1, p2, b1, b2] = take 6 $ nub $ map (`mod` 20) $ randoms g\n    \n\nmoveWumpus :: GameState -> StdGen -> GameState\nmoveWumpus s g\n    | null freeAdj = s\n    | otherwise = s {wumpus = freeAdj!!(fst $ randomR (0, length freeAdj-1) g)}\n    where freeAdj = [r | r <- cave!!wumpus s, not $ elem r $ pits s++bats s]\n    \n\nmovePlayer :: GameState -> StdGen -> GameState \nmovePlayer s g = s {player = (cave !! player s) !! (fst $ randomR (0,2) g)}\n\n\ndata Action = Move | Shoot | Quit deriving Show\ninputAction :: IO Action\ninputAction = do\n    putStr \"M)ove, S)hoot or Q)uit? \"\n    hFlush stdout\n    ch <- getChar\n    putStrLn \"\" \n    case toLower ch of\n        'm' -> return Move\n        's' -> return Shoot\n        'q' -> return Quit\n        _   -> putStrLn \"Invalid command\" >> inputAction\n        \n\ninputDestination :: Int -> IO Int\ninputDestination cur = do\n    putStr \"Where to? \"\n    hFlush stdout\n    input <- getLine\n    case reads input of\n        []      -> err \"Sorry?\"\n        [(x,_)] -> if x `elem` (cave !! cur)\n                   then return x\n                   else err \"Can't get there from here.\"\n  where\n    err x = putStrLn x >> inputDestination cur\n\n\ninputYesNo :: IO Bool\ninputYesNo = do\n    ch <- getChar\n    case toLower ch of\n        'n' -> putStrLn \"\" >> return False\n        'y' -> putStrLn \"\" >> return True\n        _   -> putStr (map chr [7,8]) >> inputYesNo\n\n\ndata PlayerState = NoArrows | Bat | Pit | Wumpus | Alive deriving Show\nplayerState :: GameState -> PlayerState\nplayerState s | player s == wumpus s   = Wumpus\n              | player s `elem` bats s = Bat \n              | player s `elem` pits s = Pit\n              | arrows s == 0          = NoArrows\n              | otherwise              = Alive\n\n\ndata GameResult = Win | Lose | Stop deriving Show\ngame :: GameState -> IO GameResult\ngame s = case playerState s of\n    Wumpus   -> putStrLn \"You find yourself face to face with the wumpus.\"\n             >> putStrLn \"It eats you alive in one bite.\\n\"\n             >> return Lose\n    Pit      -> putStrLn \"You fall into a deep pit. Death waits at the bottom.\\n\"\n             >> return Lose\n    Bat      -> putStrLn \"You have walked into the lair of a giant bat.\"\n             >> putStrLn \"It picks you up and deposits you outside.\\n\"\n             >> newStdGen >>= game . movePlayer s\n    NoArrows -> putStrLn \"You notice you are out of arrows.\"\n             >> putStrLn \"You hear a large beast approaching.\\n\"\n             >> return Lose\n    Alive    -> do\n        putStrLn \"\" \n        putStrLn $ show s\n        action <- inputAction\n        case action of\n            Quit -> return Stop\n            _    -> do\n                dest <- inputDestination (player s)\n                case action of\n                    Move  -> game s {player = dest}\n                    Shoot -> shoot s dest\n                    \n\nshoot :: GameState -> Int -> IO GameResult\nshoot s tgt\n    | tgt == wumpus s = do\n        putStrLn \"Congratulations! You shot the wumpus!\\n\"\n        return Win\n    | otherwise = do\n        let s'' = s { arrows = pred $ arrows s }\n        putStrLn \"That's a miss.\"\n        awake <- randomRIO (0,3::Int)\n        if awake /= 0 then do\n            putStrLn \"The wumpus wakes from his slumber.\"\n            newStdGen >>= game . moveWumpus s''\n        else\n            game s''\n \n\nplayGame :: IO () \nplayGame = do\n    result <- newStdGen >>= game . initGame \n    case result of\n        Stop -> return ()\n        _    -> do\n            case result of\n                Lose -> putStrLn \"You have met your demise.\"\n                Win  -> putStrLn \"You win!\"\n            putStr \"\\nAnother game? (Y/N) \"\n            inputYesNo >>= flip when playGame\n            \nmain :: IO ()\nmain = do\n    hSetBuffering stdin NoBuffering\n    hSetBuffering stdout NoBuffering\n    putStrLn \"*** HUNT THE WUMPUS ***\"\n    putStrLn \"\"\n    playGame\n", "target": "import random\n\nclass WumpusGame(object):\n\n\n\tdef __init__(self, edges=[]):\n\t\t\n\t\t\n\t\tif edges:\n\t\t\tcave = {}\n\t\t\tN = max([edges[i][0] for i in range(len(edges))])\n\t\t\tfor i in range(N):\n\t\t\t\texits = [edge[1] for edge in edges if edge[0] == i]\n\t\t\t\tcave[i] = exits\n\n\t\t\n\t\telse:\n\t\t\tcave = {1: [2,3,4], 2: [1,5,6], 3: [1,7,8], 4: [1,9,10], 5:[2,9,11],\n\t\t\t\t6: [2,7,12], 7: [3,6,13], 8: [3,10,14], 9: [4,5,15], 10: [4,8,16], \n\t\t\t\t11: [5,12,17], 12: [6,11,18], 13: [7,14,18], 14: [8,13,19], \n\t\t\t\t15: [9,16,17], 16: [10,15,19], 17: [11,20,15], 18: [12,13,20], \n\t\t\t\t19: [14,16,20], 20: [17,18,19]}\n\n\t\tself.cave = cave\n\n\t\tself.threats = {}\n\n\t\tself.arrows = 5\n\n\t\tself.arrow_travel_distance = 5\t\t\n\t\t\t\t\t\t\t\t\t\t\t\n\t\tself.player_pos = -1\n\n\n\t\n\n\n\tdef get_safe_rooms(self):\n\t\t\n\t\treturn list(set(self.cave.keys()).difference(self.threats.keys()))\n\n\n\tdef populate_cave(self):\n\t\t\n\t\tfor threat in ['bat', 'bat', 'pit', 'pit', 'wumpus']:\n\t\t\tpos = random.choice(self.get_safe_rooms())\n\t\t\tself.threats[pos] = threat\n\t\tself.player_pos = random.choice(self.get_safe_rooms())\n\n\n\tdef breadth_first_search(self, source, target, max_depth=5):\n\t\t\n\t\t\n\t\tgraph = self.cave\n\t\tdepth = 0\n\n\t\tdef search(stack, visited, target, depth):\n\t\t\tif stack == []:\t\t\t\t\t\n\t\t\t\treturn False, -1\n\t\t\tif target in stack:\n\t\t\t\treturn True, depth\n\t\t\tvisited = visited + stack\n\t\t\tstack = list(set([graph[v][i] for v in stack for i in range(len(graph[v]))]).difference(visited))\n\t\t\tdepth += 1\n\t\t\tif depth > max_depth:\t\t\t\n\t\t\t\treturn False, depth\n\t\t\telse:\t\t\t\t\t\t\t\n\t\t\t\treturn search(stack, visited, target, depth)\n\n\t\treturn search([source], [], target, depth)\n\n\n\t\n\n\n\tdef print_warning(self, threat):\n\t\t\n\t\tif threat == 'bat':\n\t\t\tprint(\"You hear a rustling.\")\n\t\telif threat == 'pit':\n\t\t\tprint(\"You feel a cold wind blowing from a nearby cavern.\")\n\t\telif threat == 'wumpus':\n\t\t\tprint(\"You smell something terrible nearby.\")\n\n\n\tdef get_players_input(self):\n\t\t\n\t\twhile 1:\t\t\t\t\t\t\t\t\n\n\t\t\tinpt = input(\"Shoot or move (S-M)? \")\n\t\t\ttry:\t\t\t\t\t\t\t\t\n\t\t\t\tmode = str(inpt).lower()\n\t\t\t\tassert mode in ['s', 'm', 'q']\n\t\t\t\tbreak\n\t\t\texcept (ValueError, AssertionError):\n\t\t\t\tprint(\"This is not a valid action: pick 'S' to shoot and 'M' to move.\")\n\n\t\tif mode == 'q':\t\t\t\t\t\t\t\n\t\t\treturn 'q', 0\n\n\t\twhile 1:\t\t\t\t\t\t\t\t\n\n\t\t\tinpt = input(\"Where to? \")\n\t\t\ttry:\t\t\t\t\t\t\t\t\n\t\t\t\ttarget = int(inpt)\n\t\t\texcept ValueError:\n\t\t\t\tprint(\"This is not even a real number.\")\n\t\t\t\tcontinue\t\t\t\t\t\t\n\n\t\t\tif mode == 'm':\n\t\t\t\ttry:\t\t\t\t\t\t\t\n\t\t\t\t\tassert target in self.cave[self.player_pos]\n\t\t\t\t\tbreak\n\t\t\t\texcept AssertionError:\n\t\t\t\t\tprint(\"You cannot walk that far. Please use one of the tunnels.\")\n\n\t\t\telif mode == 's':\n\t\t\t\ttry:\t\t\t\t\t\t\t\n\t\t\t\t\tbfs = self.breadth_first_search(self.player_pos, target)\n\t\t\t\t\tassert bfs[0] == True\n\t\t\t\t\tbreak\n\t\t\t\texcept AssertionError:\n\t\t\t\t\tif bfs[1] == -1: \t\t\t\n\t\t\t\t\t\tprint(\"There is no room with this number in the cave. Your arrow travels randomly.\")\n\t\t\t\t\t\ttarget = random.choice(self.cave.keys())\n\t\t\t\t\tif bfs[1] > self.arrow_travel_distance:\t\t\t\t\n\t\t\t\t\t\tprint(\"Arrows aren't that croocked.\")\n\n\t\treturn mode, target\n\n\n\t\n\n\n\tdef enter_room(self, room_number):\n\t\t\t\n\t\tprint(\"Entering room {}...\".format(room_number))\n\t\t\n\t\tif self.threats.get(room_number) == 'bat':\n\t\t\t\n\t\t\tprint(\"You encounter a bat, it transports you to a random empty room.\")\n\t\t\tnew_pos = random.choice(self.get_safe_rooms())\n\t\t\treturn self.enter_room(new_pos)\n\t\telif self.threats.get(room_number) == 'wumpus':\n\t\t\tprint(\"Wumpus eats you.\")\n\t\t\treturn -1\n\t\telif self.threats.get(room_number) == 'pit':\n\t\t\tprint(\"You fall into a pit.\")\n\t\t\treturn -1\n\n\t\t\n\t\tfor i in self.cave[room_number]:\n\t\t\tself.print_warning(self.threats.get(i))\n\n\t\t\n\t\treturn room_number\n\n\n\tdef shoot_room(self, room_number):\n\t\t\n\t\tprint(\"Shooting an arrow into room {}...\".format(room_number))\n\t\t\n\t\tself.arrows -= 1\n\t\tthreat = self.threats.get(room_number)\n\t\tif threat in ['bat', 'wumpus']:\n\t\t\tdel self.threats[room_number]\t\t\n\t\t\tif threat == 'wumpus':\n\t\t\t\tprint(\"Hurra, you killed the wumpus!\")\n\t\t\t\treturn -1\n\t\t\telif threat == 'bat':\n\t\t\t\tprint(\"You killed a bat.\")\n\t\telif threat in ['pit', None]:\n\t\t\tprint(\"This arrow is lost.\")\n\t\t\n\t\t\n\t\tif self.arrows < 1:\t\t\n\t\t\tprint(\"Your quiver is empty.\")\n\t\t\treturn -1\n\n\t\t\n\t\tif random.random() < 0.75:\n\t\t\t\n\t\t\tfor room_number, threat in self.threats.items():\n\t\t\t\tif threat == 'wumpus':\n\t\t\t\t\twumpus_pos = room_number\t\t\t\t\t\n\t\t\tnew_pos = random.choice(list(set(self.cave[wumpus_pos]).difference(self.threats.keys())))\n\t\t\tdel self.threats[room_number]\n\t\t\tself.threats[new_pos] = 'wumpus'\t\t\t\n\t\t\tif new_pos == self.player_pos: \n\t\t\t\tprint(\"Wumpus enters your room and eats you!\")\n\t\t\t\treturn -1\n\n\t\treturn self.player_pos\n\n\t\t\n\tdef gameloop(self):\n\n\t\tprint(\"HUNT THE WUMPUS\")\n\t\tprint(\"===============\")\n\t\tprint()\n\t\tself.populate_cave()\n\t\tself.enter_room(self.player_pos)\n\n\t\twhile 1:\n\n\t\t\t\n\t\t\t\n\t\t\t\n\n\t\t\tprint(\"You are in room {}.\".format(self.player_pos), end=\" \")\n\t\t\tprint(\"Tunnels lead to:  {0}  {1}  {2}\".format(*self.cave[self.player_pos]))\n\t\t\t\n\t\t\t\n\t\t\tinpt = self.get_players_input()\t\t\n\t\t\tprint()\t\t\t\t\t\t\t\t\n\t\t\tif inpt[0] == 'm':\t\t\t\t\t\n\t\t\t\ttarget = inpt[1] \n\t\t\t\tself.player_pos = self.enter_room(target)\n\t\t\telif inpt[0] == 's':\t\t\t\t\n\t\t\t\ttarget = inpt[1]\n\t\t\t\tself.player_pos = self.shoot_room(target)\n\t\t\telif inpt[0] == 'q':\t\t\t\t\n\t\t\t\tself.player_pos = -1\n\n\t\t\tif self.player_pos == -1:\t\t\t\n\t\t\t\tbreak\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\n\n\t\tprint()\n\t\tprint(\"Game over!\")\t\n\t\t\n\nif __name__ == '__main__':\t\t\t\t\t\t\n\t\n\t\n\t\n\t\n\n\t\n\n\tWG = WumpusGame()\n\tWG.gameloop()\n"}
{"id": 418536, "name": "MD5_Implementation", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\n\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Lazy.Char8 as BLC\nimport Data.Binary.Get\nimport Data.Binary.Put\nimport Data.Bits\n\nimport Data.Array (Array, listArray, (!))\nimport Data.List (foldl)\nimport Data.Word (Word32)\n\nimport Numeric (showHex)\n\n\n\ntype Fun = Word32 -> Word32 -> Word32 -> Word32\n\nfunF, funG, funH, funI :: Fun\nfunF x y z = (x .&. y) .|. (complement x .&. z)\nfunG x y z = (x .&. z) .|. (complement z .&. y)\nfunH x y z = x `xor` y `xor` z\nfunI x y z = y `xor` (complement z .|. x)\n\nidxF, idxG, idxH, idxI :: Int -> Int\nidxF i = i\nidxG i = (5 * i + 1) `mod` 16\nidxH i = (3 * i + 5) `mod` 16\nidxI i = 7 * i `mod` 16\n\n\n\nfunA :: Array Int Fun\nfunA = listArray (1,64) $ replicate 16 =<< [funF, funG, funH, funI]\n\nidxA :: Array Int Int\nidxA = listArray (1,64) $ zipWith ($) (replicate 16 =<< [idxF, idxG, idxH, idxI]) [0..63]\n\nrotA :: Array Int Int\nrotA = listArray (1,64) $ concat . replicate 4 =<<\n       [[7, 12, 17, 22], [5, 9, 14, 20], [4, 11, 16, 23], [6, 10, 15, 21]]\n\nsinA :: Array Int Word32\nsinA = listArray (1,64) $ map (floor . (*mult) . abs . sin) [1..64]\n    where mult = 2 ** 32 :: Double\n\n\n\n\n\nmain :: IO ()\nmain = mapM_ (putStrLn . md5sum . BLC.pack)\n        [ \"\" \n        , \"a\"\n        , \"abc\"\n        , \"message digest\"\n        , \"abcdefghijklmnopqrstuvwxyz\"\n        , \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n        , \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n        ]\n\n\nmd5sum :: BL.ByteString -> String\nmd5sum input =\n    let MD5 a b c d = getMD5 initial `runGet` input\n    in  foldr hex [] . BL.unpack . runPut $ mapM_ putWord32le [a,b,c,d]\n    where\n      initial = MD5 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476\n\n      hex x s | x < 16    = '0' : showHex x s \n              | otherwise =       showHex x s\n\n\ndata MD5 = MD5\n    { a ::  !Word32\n    , b ::  !Word32\n    , c ::  !Word32\n    , d ::  !Word32\n    }\n\n\ngetMD5 :: MD5 -> Get MD5\ngetMD5 md5 = do\n  chunk <- getLazyByteString 64\n  let len = BL.length chunk\n\n  if len == 64\n  then getMD5 $! md5 <+> chunk  \n\n  else do                       \n    bytes <- bytesRead\n    let fin   = runPut . putWord64le $ fromIntegral (bytes - 64 + len) * 8\n        pad n = chunk `BL.append` (0x80 `BL.cons` BL.replicate (n - 1) 0x00)\n\n    return $ if len >= 56\n        then md5 <+> pad (64 - len) <+> BL.replicate 56 0x00 `BL.append` fin\n        else md5 <+> pad (56 - len) `BL.append` fin\n\n\n(<+>) :: MD5 -> BL.ByteString -> MD5\ninfixl 5  <+>\nmd5@(MD5 a b c d) <+> bs =\n    let datA = listArray (0,15) $ replicateM 16 getWord32le `runGet` bs\n        MD5 a' b' c' d' = foldl' (md5round datA) md5 [1..64]\n    in MD5 (a + a') (b + b') (c + c') (d + d')\n\n\nmd5round :: Array Int Word32 -> MD5 -> Int -> MD5\nmd5round datA (MD5 a b c d) i =\n    let f  =  funA ! i\n        w  =  datA ! (idxA ! i)\n        a' =  b + (a + f b c d + w + sinA ! i) `rotateL` rotA ! i\n    in MD5 d a' b c\n", "target": "import math\n\nrotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n                  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n                  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n                  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]\n\nconstants = [int(abs(math.sin(i+1)) * 2**32) & 0xFFFFFFFF for i in range(64)]\n\ninit_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\nfunctions = 16*[lambda b, c, d: (b & c) | (~b & d)] + \\\n            16*[lambda b, c, d: (d & b) | (~d & c)] + \\\n            16*[lambda b, c, d: b ^ c ^ d] + \\\n            16*[lambda b, c, d: c ^ (b | ~d)]\n\nindex_functions = 16*[lambda i: i] + \\\n                  16*[lambda i: (5*i + 1)%16] + \\\n                  16*[lambda i: (3*i + 5)%16] + \\\n                  16*[lambda i: (7*i)%16]\n\ndef left_rotate(x, amount):\n    x &= 0xFFFFFFFF\n    return ((x<<amount) | (x>>(32-amount))) & 0xFFFFFFFF\n\ndef md5(message):\n\n    message = bytearray(message) \n    orig_len_in_bits = (8 * len(message)) & 0xffffffffffffffff\n    message.append(0x80)\n    while len(message)%64 != 56:\n        message.append(0)\n    message += orig_len_in_bits.to_bytes(8, byteorder='little')\n\n    hash_pieces = init_values[:]\n\n    for chunk_ofst in range(0, len(message), 64):\n        a, b, c, d = hash_pieces\n        chunk = message[chunk_ofst:chunk_ofst+64]\n        for i in range(64):\n            f = functions[i](b, c, d)\n            g = index_functions[i](i)\n            to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder='little')\n            new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) & 0xFFFFFFFF\n            a, b, c, d = d, new_b, b, c\n        for i, val in enumerate([a, b, c, d]):\n            hash_pieces[i] += val\n            hash_pieces[i] &= 0xFFFFFFFF\n    \n    return sum(x<<(32*i) for i, x in enumerate(hash_pieces))\n        \ndef md5_to_hex(digest):\n    raw = digest.to_bytes(16, byteorder='little')\n    return '{:032x}'.format(int.from_bytes(raw, byteorder='big'))\n\nif __name__=='__main__':\n    demo = [b\"\", b\"a\", b\"abc\", b\"message digest\", b\"abcdefghijklmnopqrstuvwxyz\",\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"]\n    for message in demo:\n        print(md5_to_hex(md5(message)),' <= \"',message.decode('ascii'),'\"', sep='')\n"}
{"id": 418537, "name": "Exponentiation with infix operators in (or operating on) the base", "source": "Translate Haskell to Python: \nmain = do\n    print [-5^2,-(5)^2,(-5)^2,-(5^2)] \n    print [-5^^2,-(5)^^2,(-5)^^2,-(5^^2)] \n    print [-5**2,-(5)**2,(-5)**2,-(5**2)] \n    print [-5^3,-(5)^3,(-5)^3,-(5^3)] \n    print [-5^^3,-(5)^^3,(-5)^^3,-(5^^3)] \n    print [-5**3,-(5)**3,(-5)**3,-(5**3)] \n", "target": "from itertools import product\n\nxx = '-5 +5'.split()\npp = '2 3'.split()\ntexts = '-x**p -(x)**p (-x)**p -(x**p)'.split()\n\nprint('Integer variable exponentiation')\nfor x, p in product(xx, pp):\n    print(f'  x,p = {x:2},{p}; ', end=' ')\n    x, p = int(x), int(p)\n    print('; '.join(f\"{t} =={eval(t):4}\" for t in texts))\n\nprint('\\nBonus integer literal exponentiation')\nX, P = 'xp'\nxx.insert(0, ' 5')\ntexts.insert(0, 'x**p')\nfor x, p in product(xx, pp):\n    texts2 = [t.replace(X, x).replace(P, p) for t in texts]\n    print(' ', '; '.join(f\"{t2} =={eval(t2):4}\" for t2 in texts2))\n"}
{"id": 418538, "name": "Exponentiation with infix operators in (or operating on) the base", "source": "Translate Haskell to Python: \nmain = do\n    print [-5^2,-(5)^2,(-5)^2,-(5^2)] \n    print [-5^^2,-(5)^^2,(-5)^^2,-(5^^2)] \n    print [-5**2,-(5)**2,(-5)**2,-(5**2)] \n    print [-5^3,-(5)^3,(-5)^3,-(5^3)] \n    print [-5^^3,-(5)^^3,(-5)^^3,-(5^^3)] \n    print [-5**3,-(5)**3,(-5)**3,-(5**3)] \n", "target": "from itertools import product\n\nxx = '-5 +5'.split()\npp = '2 3'.split()\ntexts = '-x**p -(x)**p (-x)**p -(x**p)'.split()\n\nprint('Integer variable exponentiation')\nfor x, p in product(xx, pp):\n    print(f'  x,p = {x:2},{p}; ', end=' ')\n    x, p = int(x), int(p)\n    print('; '.join(f\"{t} =={eval(t):4}\" for t in texts))\n\nprint('\\nBonus integer literal exponentiation')\nX, P = 'xp'\nxx.insert(0, ' 5')\ntexts.insert(0, 'x**p')\nfor x, p in product(xx, pp):\n    texts2 = [t.replace(X, x).replace(P, p) for t in texts]\n    print(' ', '; '.join(f\"{t2} =={eval(t2):4}\" for t2 in texts2))\n"}
{"id": 418539, "name": "History variables", "source": "Translate Haskell to Python: import Data.IORef\n\nnewtype HVar a = HVar (IORef [a])\n\nnewHVar :: a -> IO (HVar a)\nnewHVar value = fmap HVar (newIORef [value])\n\nreadHVar :: HVar a -> IO a\nreadHVar (HVar ref) = fmap head (readIORef ref)\n\nwriteHVar :: a -> HVar a -> IO ()\nwriteHVar value (HVar ref) = modifyIORef ref (value:)\n\nundoHVar :: HVar a -> IO ()\nundoHVar (HVar ref) = do\n    (_ : history) <- readIORef ref\n    writeIORef ref history\n\ngetHistory :: HVar a -> IO [a]\ngetHistory (HVar ref) = readIORef ref\n\n\nmain :: IO ()\nmain = do\n    var <- newHVar 0\n    writeHVar 1 var\n    writeHVar 2 var\n    writeHVar 3 var\n    getHistory var >>= print\n    undoHVar var\n    undoHVar var\n    undoHVar var\n", "target": "import sys\n\nHIST = {}\n\ndef trace(frame, event, arg):\n    for name,val in frame.f_locals.items():\n        if name not in HIST:\n            HIST[name] = []\n        else:\n            if HIST[name][-1] is val:\n                continue\n        HIST[name].append(val)\n    return trace\n\ndef undo(name):\n    HIST[name].pop(-1)\n    return HIST[name][-1]\n\ndef main():\n    a = 10\n    a = 20\n\n    for i in range(5):\n        c = i\n\n    print \"c:\", c, \"-> undo x3 ->\",\n    c = undo('c')\n    c = undo('c')\n    c = undo('c')\n    print c\n    print 'HIST:', HIST\n\nsys.settrace(trace)\nmain()\n"}
{"id": 418540, "name": "Reverse the order of lines in a text file while preserving the contents of each line", "source": "Translate Haskell to Python: import qualified Data.Text as T\nimport qualified Data.Text.IO as TIO\n\nmain :: IO ()\nmain = TIO.interact $ T.unlines . reverse . T.lines\n", "target": "\n\nimport sys\n\nif len(sys.argv)!=2:\n    print(\"Usage\u00a0: python \" + sys.argv[0] + \" <filename>\")\n    exit()\n\ndataFile = open(sys.argv[1],\"r\")\n\nfileData = dataFile.read().split('\\n')\n\ndataFile.close()\n\n[print(i) for i in fileData[::-1]]\n"}
{"id": 418541, "name": "Unique characters in each string", "source": "Translate Haskell to Python: import qualified Data.Map.Strict as M\nimport Data.Maybe (fromJust)\nimport qualified Data.Set as S\n\nonceInEach :: [String] -> String\nonceInEach [] = []\nonceInEach ws@(x : xs) =\n  S.elems $\n    S.filter\n      ((wordCount ==) . fromJust . flip M.lookup freq)\n      ( foldr\n          (S.intersection . S.fromList)\n          (S.fromList x)\n          xs\n      )\n  where\n    wordCount = length ws\n    freq =\n      foldr\n        (flip (M.insertWith (+)) 1)\n        M.empty\n        (concat ws)\n\n\nmain :: IO ()\nmain =\n  (putStrLn . onceInEach)\n    [ \"1a3c52debeffd\",\n      \"2b6178c97a938stf\",\n      \"3ycxdb1fgxa2yz\"\n    ]\n", "target": "LIST = [\"1a3c52debeffd\", \"2b6178c97a938stf\", \"3ycxdb1fgxa2yz\"]\n\nprint(sorted([ch for ch in set([c for c in ''.join(LIST)]) if all(w.count(ch) == 1 for w in LIST)]))\n"}
{"id": 418542, "name": "Jacobsthal numbers", "source": "Translate Haskell to Python: jacobsthal :: [Integer]\njacobsthal = 0 : 1 : zipWith (\\x y -> 2 * x + y) jacobsthal (tail jacobsthal)\n\njacobsthalLucas :: [Integer]\njacobsthalLucas = 2 : 1 : zipWith (\\x y -> 2 * x + y) jacobsthalLucas (tail jacobsthalLucas)\n\njacobsthalOblong :: [Integer]\njacobsthalOblong = zipWith (*) jacobsthal (tail jacobsthal)\n\nisPrime :: Integer -> Bool\nisPrime n = n > 1 && not (or [n `mod` i == 0 | i <- [2 .. floor (sqrt (fromInteger n))]])\n\nmain :: IO ()\nmain = do\n  putStrLn \"First 30 Jacobsthal numbers:\"\n  print $ take 30 jacobsthal\n  putStrLn \"\"\n  putStrLn \"First 30 Jacobsthal-Lucas numbers:\"\n  print $ take 30 jacobsthalLucas\n  putStrLn \"\"\n  putStrLn \"First 20 Jacobsthal oblong numbers:\"\n  print $ take 20 jacobsthalOblong\n  putStrLn \"\"\n  putStrLn \"First 10 Jacobsthal primes:\"\n  print $ take 10 $ filter isPrime jacobsthal\n", "target": "\nfrom math import floor, pow\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef odd(n):\n    return n and 1 != 0\n    \ndef jacobsthal(n):\n    return floor((pow(2,n)+odd(n))/3)\n\ndef jacobsthal_lucas(n):\n    return int(pow(2,n)+pow(-1,n))\n\ndef jacobsthal_oblong(n):\n    return jacobsthal(n)*jacobsthal(n+1)\n\n\nif __name__ == '__main__':\n    print(\"First 30 Jacobsthal numbers:\")\n    for j in range(0, 30):\n        print(jacobsthal(j), end=\"  \")\n\n    print(\"\\n\\nFirst 30 Jacobsthal-Lucas numbers: \")\n    for j in range(0, 30):\n        print(jacobsthal_lucas(j), end = '\\t')\n\n    print(\"\\n\\nFirst 20 Jacobsthal oblong numbers: \")\n    for j in range(0, 20):\n        print(jacobsthal_oblong(j), end=\"  \")\n\n    print(\"\\n\\nFirst 10 Jacobsthal primes: \")\n    for j in range(3, 33):\n        if isPrime(jacobsthal(j)):\n            print(jacobsthal(j))\n"}
{"id": 418543, "name": "Jacobsthal numbers", "source": "Translate Haskell to Python: jacobsthal :: [Integer]\njacobsthal = 0 : 1 : zipWith (\\x y -> 2 * x + y) jacobsthal (tail jacobsthal)\n\njacobsthalLucas :: [Integer]\njacobsthalLucas = 2 : 1 : zipWith (\\x y -> 2 * x + y) jacobsthalLucas (tail jacobsthalLucas)\n\njacobsthalOblong :: [Integer]\njacobsthalOblong = zipWith (*) jacobsthal (tail jacobsthal)\n\nisPrime :: Integer -> Bool\nisPrime n = n > 1 && not (or [n `mod` i == 0 | i <- [2 .. floor (sqrt (fromInteger n))]])\n\nmain :: IO ()\nmain = do\n  putStrLn \"First 30 Jacobsthal numbers:\"\n  print $ take 30 jacobsthal\n  putStrLn \"\"\n  putStrLn \"First 30 Jacobsthal-Lucas numbers:\"\n  print $ take 30 jacobsthalLucas\n  putStrLn \"\"\n  putStrLn \"First 20 Jacobsthal oblong numbers:\"\n  print $ take 20 jacobsthalOblong\n  putStrLn \"\"\n  putStrLn \"First 10 Jacobsthal primes:\"\n  print $ take 10 $ filter isPrime jacobsthal\n", "target": "\nfrom math import floor, pow\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef odd(n):\n    return n and 1 != 0\n    \ndef jacobsthal(n):\n    return floor((pow(2,n)+odd(n))/3)\n\ndef jacobsthal_lucas(n):\n    return int(pow(2,n)+pow(-1,n))\n\ndef jacobsthal_oblong(n):\n    return jacobsthal(n)*jacobsthal(n+1)\n\n\nif __name__ == '__main__':\n    print(\"First 30 Jacobsthal numbers:\")\n    for j in range(0, 30):\n        print(jacobsthal(j), end=\"  \")\n\n    print(\"\\n\\nFirst 30 Jacobsthal-Lucas numbers: \")\n    for j in range(0, 30):\n        print(jacobsthal_lucas(j), end = '\\t')\n\n    print(\"\\n\\nFirst 20 Jacobsthal oblong numbers: \")\n    for j in range(0, 20):\n        print(jacobsthal_oblong(j), end=\"  \")\n\n    print(\"\\n\\nFirst 10 Jacobsthal primes: \")\n    for j in range(3, 33):\n        if isPrime(jacobsthal(j)):\n            print(jacobsthal(j))\n"}
{"id": 418544, "name": "Successive prime differences", "source": "Translate Haskell to Python: \nimport Data.Numbers.Primes (primes)\n\ntype Result = [(String, [Int])]\n\noneMillionPrimes :: Integral p => [p]\noneMillionPrimes = takeWhile (<1_000_000) primes\n\ngetGroups :: [Int] -> Result\ngetGroups [] = []\ngetGroups ps@(n:x:y:z:xs) \n  | x-n == 6 && y-x == 4 && z-y == 2 = (\"(6 4 2)\", [n, x, y, z])            : getGroups (tail ps)\n  | x-n == 4 && y-x == 2             = (\"(4 2)\", [n, x, y])                 : getGroups (tail ps)\n  | x-n == 2 && y-x == 4             = (\"(2 4)\", [n, x, y]) : (\"2\", [n, x]) : getGroups (tail ps)\n  | x-n == 2 && y-x == 2             = (\"(2 2)\", [n, x, y]) : (\"2\", [n, x]) : getGroups (tail ps)\n  | x-n == 2                         = (\"2\", [n, x])                        : getGroups (tail ps)\n  | x-n == 1                         = (\"1\", [n, x])                        : getGroups (tail ps)\n  | otherwise                        = getGroups (tail ps)\ngetGroups (x:xs) = getGroups xs\n\ngroups :: Result\ngroups = getGroups oneMillionPrimes\n\nshowGroup :: String -> IO ()\nshowGroup group = do \n  putStrLn $ \"Differences of \" ++ group ++ \": \" ++ show (length r)\n  putStrLn $ \"First: \" ++ show (head r) ++ \"\\nLast:  \" ++ show (last r) ++ \"\\n\"\n  where r = foldr (\\(a, b) c -> if a == group then b : c else c) [] groups\n\nmain :: IO ()\nmain = showGroup \"2\" >> showGroup \"1\" >> showGroup \"(2 2)\" >> showGroup \"(2 4)\" >> showGroup \"(4 2)\" \n  >> showGroup \"(6 4 2)\"\n", "target": "\nfrom sympy import Sieve\n\ndef nsuccprimes(count, mx):\n    \"return tuple of <count> successive primes <= mx (generator)\"\n    sieve = Sieve()\n    sieve.extend(mx)\n    primes = sieve._list\n    return zip(*(primes[n:] for n in range(count)))\n\ndef check_value_diffs(diffs, values):\n    \"Differences between successive values given by successive items in diffs?\"\n    return all(v[1] - v[0] == d \n               for d, v in zip(diffs, zip(values, values[1:])))\n\ndef successive_primes(offsets=(2, ), primes_max=1_000_000):\n    return (sp for sp in nsuccprimes(len(offsets) + 1, primes_max) \n            if check_value_diffs(offsets, sp))\n\nif __name__ == '__main__':\n    for offsets, mx in [((2,),      1_000_000), \n                        ((1,),      1_000_000),\n                        ((2, 2),    1_000_000),\n                        ((2, 4),    1_000_000),\n                        ((4, 2),    1_000_000),\n                        ((6, 4, 2), 1_000_000),\n                       ]:\n        print(f\"\n              f\"SUCCESSIVE DIFFERENCES OF {str(list(offsets))[1:-1]}\")\n        for count, last in enumerate(successive_primes(offsets, mx), 1):\n            if count == 1:\n                first = last\n        print(\"  First group:\", str(first)[1:-1])\n        print(\"   Last group:\", str(last)[1:-1])\n        print(\"        Count:\", count)\n"}
{"id": 418545, "name": "Numbers whose binary and ternary digit sums are prime", "source": "Translate Haskell to Python: import Data.Bifunctor (first)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (isPrime)\n\n\n\ndigitSumsPrime :: Int -> [Int] -> Bool\ndigitSumsPrime n = all (isPrime . digitSum n)\n\ndigitSum :: Int -> Int -> Int\ndigitSum n base = go n\n  where\n    go 0 = 0\n    go n = uncurry (+) (first go $ quotRem n base)\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    show (length xs)\n      <> \" matches in [1..199]\\n\\n\"\n      <> table xs\n  where\n    xs =\n      [1 .. 199]\n        >>= \\x -> [show x | digitSumsPrime x [2, 3]]\n\n\n\ntable :: [String] -> String\ntable xs =\n  let w = length (last xs)\n   in unlines $\n        unwords\n          <$> chunksOf\n            10\n            (justifyRight w ' ' <$> xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "\n\n\n\ndef digitSumsPrime(n):\n    \n    def go(bases):\n        return all(\n            isPrime(digitSum(b)(n))\n            for b in bases\n        )\n    return go\n\n\n\ndef digitSum(base):\n    \n    def go(n):\n        q, r = divmod(n, base)\n        return go(q) + r if n else 0\n    return go\n\n\n\n\ndef main():\n    \n    xs = [\n        str(n) for n in range(1, 200)\n        if digitSumsPrime(n)([2, 3])\n    ]\n    print(f'{len(xs)} matches in [1..199]\\n')\n    print(table(10)(xs))\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418546, "name": "Summarize primes", "source": "Translate Haskell to Python: import Data.List (scanl)\nimport Data.Numbers.Primes (isPrime, primes)\n\n\n\nindexedPrimeSums :: [(Integer, Integer, Integer)]\nindexedPrimeSums =\n  filter (\\(_, _, n) -> isPrime n) $\n    scanl\n      (\\(i, _, m) p -> (succ i, p, p + m))\n      (0, 0, 0)\n      primes\n\n\nmain :: IO ()\nmain =\n  mapM_ print $\n    takeWhile (\\(_, p, _) -> 1000 > p) indexedPrimeSums\n", "target": "\n\n\nfrom itertools import accumulate, chain, takewhile\n\n\n\ndef primeSums():\n    \n    return (\n        x for x in enumerate(\n            accumulate(\n                chain([(0, 0)], primes()),\n                lambda a, p: (p, p + a[1])\n            )\n        ) if isPrime(x[1][1])\n    )\n\n\n\n\ndef main():\n    \n    for x in takewhile(\n            lambda t: 1000 > t[1][0],\n            primeSums()\n    ):\n        print(f'{x[0]} -> {x[1][1]}')\n\n\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418547, "name": "Summarize primes", "source": "Translate Haskell to Python: import Data.List (scanl)\nimport Data.Numbers.Primes (isPrime, primes)\n\n\n\nindexedPrimeSums :: [(Integer, Integer, Integer)]\nindexedPrimeSums =\n  filter (\\(_, _, n) -> isPrime n) $\n    scanl\n      (\\(i, _, m) p -> (succ i, p, p + m))\n      (0, 0, 0)\n      primes\n\n\nmain :: IO ()\nmain =\n  mapM_ print $\n    takeWhile (\\(_, p, _) -> 1000 > p) indexedPrimeSums\n", "target": "\n\n\nfrom itertools import accumulate, chain, takewhile\n\n\n\ndef primeSums():\n    \n    return (\n        x for x in enumerate(\n            accumulate(\n                chain([(0, 0)], primes()),\n                lambda a, p: (p, p + a[1])\n            )\n        ) if isPrime(x[1][1])\n    )\n\n\n\n\ndef main():\n    \n    for x in takewhile(\n            lambda t: 1000 > t[1][0],\n            primeSums()\n    ):\n        print(f'{x[0]} -> {x[1][1]}')\n\n\n\n\n\ndef isPrime(n):\n    \n    if n in (2, 3):\n        return True\n    if 2 > n or 0 == n % 2:\n        return False\n    if 9 > n:\n        return True\n    if 0 == n % 3:\n        return False\n\n    def p(x):\n        return 0 == n % x or 0 == n % (2 + x)\n\n    return not any(map(p, range(5, 1 + int(n ** 0.5), 6)))\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418548, "name": "Largest number divisible by its digits", "source": "Translate Haskell to Python: import Data.List (maximumBy, permutations, delete)\nimport Data.Ord (comparing)\nimport Data.Bool (bool)\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\nds :: [Int]\nds = [1, 2, 3, 4, 6, 7, 8, 9] \n\nlcmDigits :: Int\nlcmDigits = foldr1 lcm ds \n\nsevenDigits :: [[Int]]\nsevenDigits = (`delete` ds) <$> [1, 4, 7] \n\nmain :: IO ()\nmain =\n  print $\n  maximumBy\n  \n    (comparing (bool 0 <*> (0 ==) . (`rem` lcmDigits)))\n    (unDigits <$> concat (permutations <$> sevenDigits))\n", "target": "\n\nfrom itertools import (chain, permutations)\nfrom functools import (reduce)\nfrom math import (gcd)\n\n\n\ndef main():\n    \n\n    \n    digits = [1, 2, 3, 4, 6, 7, 8, 9]\n\n    \n    lcmDigits = reduce(lcm, digits)\n\n    \n    \n    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])\n\n    print(\n        max(\n            (\n                intFromDigits(x) for x\n                in concatMap(permutations)(sevenDigits)\n            ),\n            key=lambda n: n if 0 == n % lcmDigits else 0\n        )\n    )\n\n\n\ndef intFromDigits(xs):\n    \n    return reduce(lambda a, x: a * 10 + x, xs, 0)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef delete(xs):\n    \n    def go(x):\n        ys = xs.copy()\n        ys.remove(x)\n        return ys\n    return go\n\n\n\ndef lcm(x, y):\n    \n    return 0 if (0 == x or 0 == y) else abs(\n        y * (x // gcd(x, y))\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418549, "name": "Largest number divisible by its digits", "source": "Translate Haskell to Python: import Data.List (maximumBy, permutations, delete)\nimport Data.Ord (comparing)\nimport Data.Bool (bool)\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\nds :: [Int]\nds = [1, 2, 3, 4, 6, 7, 8, 9] \n\nlcmDigits :: Int\nlcmDigits = foldr1 lcm ds \n\nsevenDigits :: [[Int]]\nsevenDigits = (`delete` ds) <$> [1, 4, 7] \n\nmain :: IO ()\nmain =\n  print $\n  maximumBy\n  \n    (comparing (bool 0 <*> (0 ==) . (`rem` lcmDigits)))\n    (unDigits <$> concat (permutations <$> sevenDigits))\n", "target": "\n\nfrom itertools import (chain, permutations)\nfrom functools import (reduce)\nfrom math import (gcd)\n\n\n\ndef main():\n    \n\n    \n    digits = [1, 2, 3, 4, 6, 7, 8, 9]\n\n    \n    lcmDigits = reduce(lcm, digits)\n\n    \n    \n    sevenDigits = ((delete)(digits)(x) for x in [1, 4, 7])\n\n    print(\n        max(\n            (\n                intFromDigits(x) for x\n                in concatMap(permutations)(sevenDigits)\n            ),\n            key=lambda n: n if 0 == n % lcmDigits else 0\n        )\n    )\n\n\n\ndef intFromDigits(xs):\n    \n    return reduce(lambda a, x: a * 10 + x, xs, 0)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef delete(xs):\n    \n    def go(x):\n        ys = xs.copy()\n        ys.remove(x)\n        return ys\n    return go\n\n\n\ndef lcm(x, y):\n    \n    return 0 if (0 == x or 0 == y) else abs(\n        y * (x // gcd(x, y))\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418550, "name": "Jacobi symbol", "source": "Translate Haskell to Python: jacobi :: Integer -> Integer -> Integer\njacobi 0 1 = 1\njacobi 0 _ = 0\njacobi a n =\n  let a_mod_n = rem a n\n  in if even a_mod_n\n       then case rem n 8 of\n              1 -> jacobi (div a_mod_n 2) n\n              3 -> negate $ jacobi (div a_mod_n 2) n\n              5 -> negate $ jacobi (div a_mod_n 2) n\n              7 -> jacobi (div a_mod_n 2) n\n       else if rem a_mod_n 4 == 3 && rem n 4 == 3\n              then negate $ jacobi n a_mod_n\n              else jacobi n a_mod_n\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 418551, "name": "Jacobi symbol", "source": "Translate Haskell to Python: jacobi :: Integer -> Integer -> Integer\njacobi 0 1 = 1\njacobi 0 _ = 0\njacobi a n =\n  let a_mod_n = rem a n\n  in if even a_mod_n\n       then case rem n 8 of\n              1 -> jacobi (div a_mod_n 2) n\n              3 -> negate $ jacobi (div a_mod_n 2) n\n              5 -> negate $ jacobi (div a_mod_n 2) n\n              7 -> jacobi (div a_mod_n 2) n\n       else if rem a_mod_n 4 == 3 && rem n 4 == 3\n              then negate $ jacobi n a_mod_n\n              else jacobi n a_mod_n\n", "target": "def jacobi(a, n):\n    if n <= 0:\n        raise ValueError(\"'n' must be a positive integer.\")\n    if n % 2 == 0:\n        raise ValueError(\"'n' must be odd.\")\n    a %= n\n    result = 1\n    while a != 0:\n        while a % 2 == 0:\n            a /= 2\n            n_mod_8 = n % 8\n            if n_mod_8 in (3, 5):\n                result = -result\n        a, n = n, a\n        if a % 4 == 3 and n % 4 == 3:\n            result = -result\n        a %= n\n    if n == 1:\n        return result\n    else:\n        return 0\n"}
{"id": 418552, "name": "Determinant and permanent", "source": "Translate Haskell to Python: sPermutations :: [a] -> [([a], Int)]\nsPermutations = flip zip (cycle [1, -1]) . foldl aux [[]]\n  where\n    aux items x = do\n      (f, item) <- zip (cycle [reverse, id]) items\n      f (insertEv x item)\n    insertEv x [] = [[x]]\n    insertEv x l@(y:ys) = (x : l) : ((y :) <$>) (insertEv x ys)\n\nelemPos :: [[a]] -> Int -> Int -> a\nelemPos ms i j = (ms !! i) !! j\n\nprod\n  :: Num a\n  => ([[a]] -> Int -> Int -> a) -> [[a]] -> [Int] -> a\nprod f ms = product . zipWith (f ms) [0 ..]\n\nsDeterminant\n  :: Num a\n  => ([[a]] -> Int -> Int -> a) -> [[a]] -> [([Int], Int)] -> a\nsDeterminant f ms = sum . fmap (\\(is, s) -> fromIntegral s * prod f ms is)\n\ndeterminant\n  :: Num a\n  => [[a]] -> a\ndeterminant ms =\n  sDeterminant elemPos ms . sPermutations $ [0 .. pred . length $ ms]\n\npermanent\n  :: Num a\n  => [[a]] -> a\npermanent ms =\n  sum . fmap (prod elemPos ms . fst) . sPermutations $ [0 .. pred . length $ ms]\n\n\nresult\n  :: (Num a, Show a)\n  => [[a]] -> String\nresult ms =\n  unlines\n    [ \"Matrix:\"\n    , unlines (show <$> ms)\n    , \"Determinant:\"\n    , show (determinant ms)\n    , \"Permanent:\"\n    , show (permanent ms)\n    ]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . result)\n    [ [[5]]\n    , [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    , [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    , [[4, 3], [2, 5]]\n    , [[2, 5], [4, 3]]\n    , [[4, 4], [2, 2]]\n    ]\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 418553, "name": "Determinant and permanent", "source": "Translate Haskell to Python: sPermutations :: [a] -> [([a], Int)]\nsPermutations = flip zip (cycle [1, -1]) . foldl aux [[]]\n  where\n    aux items x = do\n      (f, item) <- zip (cycle [reverse, id]) items\n      f (insertEv x item)\n    insertEv x [] = [[x]]\n    insertEv x l@(y:ys) = (x : l) : ((y :) <$>) (insertEv x ys)\n\nelemPos :: [[a]] -> Int -> Int -> a\nelemPos ms i j = (ms !! i) !! j\n\nprod\n  :: Num a\n  => ([[a]] -> Int -> Int -> a) -> [[a]] -> [Int] -> a\nprod f ms = product . zipWith (f ms) [0 ..]\n\nsDeterminant\n  :: Num a\n  => ([[a]] -> Int -> Int -> a) -> [[a]] -> [([Int], Int)] -> a\nsDeterminant f ms = sum . fmap (\\(is, s) -> fromIntegral s * prod f ms is)\n\ndeterminant\n  :: Num a\n  => [[a]] -> a\ndeterminant ms =\n  sDeterminant elemPos ms . sPermutations $ [0 .. pred . length $ ms]\n\npermanent\n  :: Num a\n  => [[a]] -> a\npermanent ms =\n  sum . fmap (prod elemPos ms . fst) . sPermutations $ [0 .. pred . length $ ms]\n\n\nresult\n  :: (Num a, Show a)\n  => [[a]] -> String\nresult ms =\n  unlines\n    [ \"Matrix:\"\n    , unlines (show <$> ms)\n    , \"Determinant:\"\n    , show (determinant ms)\n    , \"Permanent:\"\n    , show (permanent ms)\n    ]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . result)\n    [ [[5]]\n    , [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n    , [[0, 0, 1], [0, 1, 0], [1, 0, 0]]\n    , [[4, 3], [2, 5]]\n    , [[2, 5], [4, 3]]\n    , [[4, 4], [2, 2]]\n    ]\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 418554, "name": "Sum of the digits of n is substring of n", "source": "Translate Haskell to Python: import Data.Char (digitToInt)\nimport Data.List (isInfixOf)\nimport Data.List.Split (chunksOf)\n\n\n\ndigitSumIsSubString :: String -> Bool\ndigitSumIsSubString =\n  isInfixOf\n    =<< show . foldr ((+) . digitToInt) 0\n\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    showMatches digitSumIsSubString <$> [999, 10000]\n\nshowMatches :: (String -> Bool) -> Int -> String\nshowMatches p limit =\n  ( show (length xs)\n      <> \" matches in [0..\"\n      <> show limit\n      <> \"]\\n\"\n  )\n    <> unlines\n      ( unwords\n          <$> chunksOf 10 (justifyRight w ' ' <$> xs)\n      )\n    <> \"\\n\"\n  where\n    xs = filter p $ fmap show [0 .. limit]\n    w = length (last xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 418555, "name": "Sum of the digits of n is substring of n", "source": "Translate Haskell to Python: import Data.Char (digitToInt)\nimport Data.List (isInfixOf)\nimport Data.List.Split (chunksOf)\n\n\n\ndigitSumIsSubString :: String -> Bool\ndigitSumIsSubString =\n  isInfixOf\n    =<< show . foldr ((+) . digitToInt) 0\n\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    showMatches digitSumIsSubString <$> [999, 10000]\n\nshowMatches :: (String -> Bool) -> Int -> String\nshowMatches p limit =\n  ( show (length xs)\n      <> \" matches in [0..\"\n      <> show limit\n      <> \"]\\n\"\n  )\n    <> unlines\n      ( unwords\n          <$> chunksOf 10 (justifyRight w ' ' <$> xs)\n      )\n    <> \"\\n\"\n  where\n    xs = filter p $ fmap show [0 .. limit]\n    w = length (last xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "Python 3.9.0 (tags/v3.9.0:9cf6752, Oct  5 2020, 15:34:40) [MSC v.1927 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> x = [n for n in range(1000) if str(sum(int(d) for d in str(n))) in str(n)]\n>>> len(x)\n48\n>>> for i in range(0, len(x), (stride:= 10)): print(str(x[i:i+stride])[1:-1])\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n10, 20, 30, 40, 50, 60, 70, 80, 90, 100\n109, 119, 129, 139, 149, 159, 169, 179, 189, 199\n200, 300, 400, 500, 600, 700, 800, 900, 910, 911\n912, 913, 914, 915, 916, 917, 918, 919\n>>>\n"}
{"id": 418556, "name": "Sattolo cycle", "source": "Translate Haskell to Python: import Control.Monad ((>=>), (>>=), forM_)\nimport Control.Monad.Primitive\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as M\nimport System.Random.MWC\n\ntype MutVec m a = M.MVector (PrimState m) a\n\n\n\n\ncyclicPermM :: PrimMonad m => Gen (PrimState m) -> MutVec m a -> m (MutVec m a)\ncyclicPermM rand vec = forM_ [1..M.length vec-1] upd >> return vec\n  where upd i = uniformR (0, i-1) rand >>= M.swap vec i\n\n\ncyclicPerm :: PrimMonad m => Gen (PrimState m) -> V.Vector a -> m (V.Vector a)\ncyclicPerm rand = V.thaw >=> cyclicPermM rand >=> V.unsafeFreeze\n\n\n\ntest :: Show a => [a] -> IO ()\ntest xs = do\n  let orig = V.fromList xs\n  cyc <- withSystemRandom . asGenIO $ \\rand -> cyclicPerm rand orig\n  putStrLn $ \"original: \" ++ show orig\n  putStrLn $ \"  cycled: \" ++ show cyc\n\nmain :: IO ()\nmain = do\n  test ([] :: [()])\n  test [10 :: Int]\n  test [10, 20 :: Int]\n  test [10, 20, 30 :: Int]\n  test [11..22 :: Int]\n  \n  test \"abcdef\"\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 418557, "name": "Sattolo cycle", "source": "Translate Haskell to Python: import Control.Monad ((>=>), (>>=), forM_)\nimport Control.Monad.Primitive\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as M\nimport System.Random.MWC\n\ntype MutVec m a = M.MVector (PrimState m) a\n\n\n\n\ncyclicPermM :: PrimMonad m => Gen (PrimState m) -> MutVec m a -> m (MutVec m a)\ncyclicPermM rand vec = forM_ [1..M.length vec-1] upd >> return vec\n  where upd i = uniformR (0, i-1) rand >>= M.swap vec i\n\n\ncyclicPerm :: PrimMonad m => Gen (PrimState m) -> V.Vector a -> m (V.Vector a)\ncyclicPerm rand = V.thaw >=> cyclicPermM rand >=> V.unsafeFreeze\n\n\n\ntest :: Show a => [a] -> IO ()\ntest xs = do\n  let orig = V.fromList xs\n  cyc <- withSystemRandom . asGenIO $ \\rand -> cyclicPerm rand orig\n  putStrLn $ \"original: \" ++ show orig\n  putStrLn $ \"  cycled: \" ++ show cyc\n\nmain :: IO ()\nmain = do\n  test ([] :: [()])\n  test [10 :: Int]\n  test [10, 20 :: Int]\n  test [10, 20, 30 :: Int]\n  test [11..22 :: Int]\n  \n  test \"abcdef\"\n", "target": ">>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  \n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> \n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n"}
{"id": 418558, "name": "FTP", "source": "Translate Haskell to Python: module Main (main) where\n\nimport           Control.Exception (bracket)\nimport           Control.Monad (void)\nimport           Data.Foldable (for_)\nimport           Network.FTP.Client\n                    ( cwd\n                    , easyConnectFTP\n                    , getbinary\n                    , loginAnon\n                    , nlst\n                    , quit\n                    , setPassive\n                    )\n\nmain :: IO ()\nmain = bracket ((flip setPassive) True <$> easyConnectFTP \"ftp.kernel.org\") quit $ \\h -> do\n    \n    void $ loginAnon h\n\n    \n    void $ cwd h \"/pub/linux/kernel/Historic\"\n\n    \n    fileNames <- nlst h Nothing\n    for_ fileNames $ \\fileName ->\n        putStrLn fileName\n\n    \n    (fileData, _) <- getbinary h \"linux-0.01.tar.gz.sign\"\n    print fileData\n", "target": "from ftplib import FTP\nftp = FTP('kernel.org')\nftp.login()\nftp.cwd('/pub/linux/kernel')\nftp.set_pasv(True) \nprint ftp.retrlines('LIST')\nprint ftp.retrbinary('RETR README', open('README', 'wb').write)\nftp.quit()\n"}
{"id": 418559, "name": "Table creation_Postal addresses", "source": "Translate Haskell to Python: \n\nimport Database.SQLite.Simple\n\nmain = do\n     db <- open \"postal.db\"\n     execute_ db \"\\ \n     \\CREATE TABLE address (\\\n        \\addrID     INTEGER PRIMARY KEY AUTOINCREMENT, \\\n        \\addrStreet TEXT NOT NULL, \\\n        \\addrCity   TEXT NOT NULL, \\\n        \\addrState  TEXT NOT NULL, \\\n        \\addrZIP    TEXT NOT NULL  \\\n     \\)\"\n     close db\n", "target": ">>> import sqlite3\n>>> conn = sqlite3.connect(':memory:')\n>>> conn.execute()\n<sqlite3.Cursor object at 0x013265C0>\n>>>\n"}
{"id": 418560, "name": "Brazilian numbers", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\n\nisBrazil :: Int -> Bool\nisBrazil n = 7 <= n && (even n || any (monoDigit n) [2 .. n - 2])\n\nmonoDigit :: Int -> Int -> Bool\nmonoDigit n b =\n  let (q, d) = quotRem n b\n  in d ==\n     snd\n       (until\n          (uncurry (flip ((||) . (d /=)) . (0 ==)))\n          ((`quotRem` b) . fst)\n          (q, d))\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\(s, xs) ->\n        (putStrLn . concat)\n          [ \"First 20 \"\n          , s\n          , \" Brazilians:\\n\"\n          , show . take 20 $ filter isBrazil xs\n          , \"\\n\"\n          ])\n    [([], [1 ..]), (\"odd\", [1,3 ..]), (\"prime\", primes)]\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418561, "name": "Brazilian numbers", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\n\nisBrazil :: Int -> Bool\nisBrazil n = 7 <= n && (even n || any (monoDigit n) [2 .. n - 2])\n\nmonoDigit :: Int -> Int -> Bool\nmonoDigit n b =\n  let (q, d) = quotRem n b\n  in d ==\n     snd\n       (until\n          (uncurry (flip ((||) . (d /=)) . (0 ==)))\n          ((`quotRem` b) . fst)\n          (q, d))\n\nmain :: IO ()\nmain =\n  mapM_\n    (\\(s, xs) ->\n        (putStrLn . concat)\n          [ \"First 20 \"\n          , s\n          , \" Brazilians:\\n\"\n          , show . take 20 $ filter isBrazil xs\n          , \"\\n\"\n          ])\n    [([], [1 ..]), (\"odd\", [1,3 ..]), (\"prime\", primes)]\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418562, "name": "Create a file on magnetic tape", "source": "Translate Haskell to Python: module Main (main) where\n\nmain :: IO ()\nmain = writeFile \"/dev/tape\" \"Hello from Rosetta Code!\"\n", "target": ">>> with open('/dev/tape', 'w') as t: t.write('Hi Tape!\\n')\n... \n>>>\n"}
{"id": 418563, "name": "Recaman's sequence", "source": "Translate Haskell to Python: recaman :: Int -> [Int]\nrecaman n = fst <$> reverse (go n)\n  where\n    go 0 = []\n    go 1 = [(0, 1)]\n    go x =\n        let xs@((r, i):_) = go (pred x)\n            back = r - i\n        in ( if 0 < back && not (any ((back ==) . fst) xs)\n               then back\n               else r + i\n           , succ i) :\n           xs\n\nmain :: IO ()\nmain = print $ recaman 15\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 418564, "name": "Recaman's sequence", "source": "Translate Haskell to Python: recaman :: Int -> [Int]\nrecaman n = fst <$> reverse (go n)\n  where\n    go 0 = []\n    go 1 = [(0, 1)]\n    go x =\n        let xs@((r, i):_) = go (pred x)\n            back = r - i\n        in ( if 0 < back && not (any ((back ==) . fst) xs)\n               then back\n               else r + i\n           , succ i) :\n           xs\n\nmain :: IO ()\nmain = print $ recaman 15\n", "target": "from itertools import islice\n\nclass Recamans():\n    \"Recam\u00e1n's sequence generator callable class\"\n    def __init__(self):\n        self.a = None   \n        self.n = None   \n    \n    def __call__(self):\n        \"Recam\u00e1n's sequence  generator\"\n        nxt = 0\n        a, n = {nxt}, 0\n        self.a = a\n        self.n = n\n        yield nxt\n        while True:\n            an1, n = nxt, n + 1\n            nxt = an1 - n\n            if nxt < 0 or nxt in a:\n                nxt = an1 + n\n            a.add(nxt)\n            self.n = n\n            yield nxt\n\nif __name__ == '__main__':\n    recamans = Recamans()\n    print(\"First fifteen members of Recamans sequence:\", \n          list(islice(recamans(), 15)))\n\n    so_far = set()\n    for term in recamans():\n        if term in so_far:\n            print(f\"First duplicate number in series is: a({recamans.n}) = {term}\")\n            break\n        so_far.add(term)\n    \n    n = 1_000\n    setn = set(range(n + 1))    \n    for _ in recamans():\n        if setn.issubset(recamans.a):\n            print(f\"Range 0 ..{n} is covered by terms up to a({recamans.n})\")\n            break\n"}
{"id": 418565, "name": "Y combinator", "source": "Translate Haskell to Python: newtype Mu a = Roll\n  { unroll :: Mu a -> a }\n \nfix :: (a -> a) -> a\nfix = g <*> (Roll . g)\n  where\n    g = (. (>>= id) unroll)\n \n- this version is not in tail call position...\n\n\n\n\n\nfac :: Integer -> Integer\nfac =\n  (fix $ \\f n i -> if i <= 0 then n else f (i * n) (i - 1)) 1\n \n\n\n\n\n{\nfibs\u00a0:: () -> [Integer]\nfibs() =\n  fix $\n    (0\u00a0:) . (1\u00a0:) .\n      (fix\n        (\\f (x:xs) (y:ys) ->\n          case x + y of n -> n `seq` n\u00a0: f xs ys) <*> tail)\n\n\n\nfibs :: () -> [Integer]\nfibs() = 0 : 1 : fix fibs_ 0 1\n  where\n    fibs_ fnc f s =\n      case f + s of n -> n `seq` n : fnc s n\n \nmain :: IO ()\nmain =\n  mapM_\n    print\n    [ map fac [1 .. 20]\n    , take 20 $ fibs()\n    ]\n", "target": ">>> Y = lambda f: (lambda x: x(x))(lambda y: f(lambda *args: y(y)(*args)))\n>>> fac = lambda f: lambda n: (1 if n<2 else n*f(n-1))\n>>> [ Y(fac)(i) for i in range(10) ]\n[1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880]\n>>> fib = lambda f: lambda n: 0 if n == 0 else (1 if n == 1 else f(n-1) + f(n-2))\n>>> [ Y(fib)(i) for i in range(10) ]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]\n"}
{"id": 418566, "name": "Total circles area", "source": "Translate Haskell to Python: data Circle = Circle { cx :: Double, cy :: Double, cr :: Double }\n\nisInside :: Double -> Double -> Circle -> Bool\nisInside x y c = (x - cx c) ^ 2 + (y - cy c) ^ 2 <= (cr c ^ 2)\n\nisInsideAny :: Double -> Double -> [Circle] -> Bool\nisInsideAny x y = any (isInside x y)\n\napproximatedArea :: [Circle] -> Int -> Double\napproximatedArea cs box_side = (fromIntegral count) * dx * dy\n  where\n    \n    x_min = minimum [cx c - cr c | c <- circles]\n    x_max = maximum [cx c + cr c | c <- circles]\n    y_min = minimum [cy c - cr c | c <- circles]\n    y_max = maximum [cy c + cr c | c <- circles]\n    dx = (x_max - x_min) / (fromIntegral box_side)\n    dy = (y_max - y_min) / (fromIntegral box_side)\n    count = length [0 | r <- [0 .. box_side - 1],\n                        c <- [0 .. box_side - 1],\n                        isInsideAny (posx c) (posy r) circles]\n    posy r = y_min + (fromIntegral r) * dy\n    posx c = x_min + (fromIntegral c) * dx\n\ncircles :: [Circle]\ncircles = [Circle ( 1.6417233788) ( 1.6121789534) 0.0848270516,\n           Circle (-1.4944608174) ( 1.2077959613) 1.1039549836,\n           Circle ( 0.6110294452) (-0.6907087527) 0.9089162485,\n           Circle ( 0.3844862411) ( 0.2923344616) 0.2375743054,\n           Circle (-0.2495892950) (-0.3832854473) 1.0845181219,\n           Circle ( 1.7813504266) ( 1.6178237031) 0.8162655711,\n           Circle (-0.1985249206) (-0.8343333301) 0.0538864941,\n           Circle (-1.7011985145) (-0.1263820964) 0.4776976918,\n           Circle (-0.4319462812) ( 1.4104420482) 0.7886291537,\n           Circle ( 0.2178372997) (-0.9499557344) 0.0357871187,\n           Circle (-0.6294854565) (-1.3078893852) 0.7653357688,\n           Circle ( 1.7952608455) ( 0.6281269104) 0.2727652452,\n           Circle ( 1.4168575317) ( 1.0683357171) 1.1016025378,\n           Circle ( 1.4637371396) ( 0.9463877418) 1.1846214562,\n           Circle (-0.5263668798) ( 1.7315156631) 1.4428514068,\n           Circle (-1.2197352481) ( 0.9144146579) 1.0727263474,\n           Circle (-0.1389358881) ( 0.1092805780) 0.7350208828,\n           Circle ( 1.5293954595) ( 0.0030278255) 1.2472867347,\n           Circle (-0.5258728625) ( 1.3782633069) 1.3495508831,\n           Circle (-0.1403562064) ( 0.2437382535) 1.3804956588,\n           Circle ( 0.8055826339) (-0.0482092025) 0.3327165165,\n           Circle (-0.6311979224) ( 0.7184578971) 0.2491045282,\n           Circle ( 1.4685857879) (-0.8347049536) 1.3670667538,\n           Circle (-0.6855727502) ( 1.6465021616) 1.0593087096,\n           Circle ( 0.0152957411) ( 0.0638919221) 0.9771215985]\n\nmain = putStrLn $ \"Approximated area: \" ++\n                  (show $ approximatedArea circles 5000)\n", "target": "from collections import namedtuple\n\nCircle = namedtuple(\"Circle\", \"x y r\")\n\ncircles = [\n    Circle( 1.6417233788,  1.6121789534, 0.0848270516),\n    Circle(-1.4944608174,  1.2077959613, 1.1039549836),\n    Circle( 0.6110294452, -0.6907087527, 0.9089162485),\n    Circle( 0.3844862411,  0.2923344616, 0.2375743054),\n    Circle(-0.2495892950, -0.3832854473, 1.0845181219),\n    Circle( 1.7813504266,  1.6178237031, 0.8162655711),\n    Circle(-0.1985249206, -0.8343333301, 0.0538864941),\n    Circle(-1.7011985145, -0.1263820964, 0.4776976918),\n    Circle(-0.4319462812,  1.4104420482, 0.7886291537),\n    Circle( 0.2178372997, -0.9499557344, 0.0357871187),\n    Circle(-0.6294854565, -1.3078893852, 0.7653357688),\n    Circle( 1.7952608455,  0.6281269104, 0.2727652452),\n    Circle( 1.4168575317,  1.0683357171, 1.1016025378),\n    Circle( 1.4637371396,  0.9463877418, 1.1846214562),\n    Circle(-0.5263668798,  1.7315156631, 1.4428514068),\n    Circle(-1.2197352481,  0.9144146579, 1.0727263474),\n    Circle(-0.1389358881,  0.1092805780, 0.7350208828),\n    Circle( 1.5293954595,  0.0030278255, 1.2472867347),\n    Circle(-0.5258728625,  1.3782633069, 1.3495508831),\n    Circle(-0.1403562064,  0.2437382535, 1.3804956588),\n    Circle( 0.8055826339, -0.0482092025, 0.3327165165),\n    Circle(-0.6311979224,  0.7184578971, 0.2491045282),\n    Circle( 1.4685857879, -0.8347049536, 1.3670667538),\n    Circle(-0.6855727502,  1.6465021616, 1.0593087096),\n    Circle( 0.0152957411,  0.0638919221, 0.9771215985)]\n\ndef main():\n    \n    x_min = min(c.x - c.r for c in circles)\n    x_max = max(c.x + c.r for c in circles)\n    y_min = min(c.y - c.r for c in circles)\n    y_max = max(c.y + c.r for c in circles)\n\n    box_side = 500\n\n    dx = (x_max - x_min) / box_side\n    dy = (y_max - y_min) / box_side\n\n    count = 0\n\n    for r in xrange(box_side):\n        y = y_min + r * dy\n        for c in xrange(box_side):\n            x = x_min + c * dx\n            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)\n                   for circle in circles):\n                count += 1\n\n    print \"Approximated area:\", count * dx * dy\n\nmain()\n"}
{"id": 418567, "name": "Total circles area", "source": "Translate Haskell to Python: data Circle = Circle { cx :: Double, cy :: Double, cr :: Double }\n\nisInside :: Double -> Double -> Circle -> Bool\nisInside x y c = (x - cx c) ^ 2 + (y - cy c) ^ 2 <= (cr c ^ 2)\n\nisInsideAny :: Double -> Double -> [Circle] -> Bool\nisInsideAny x y = any (isInside x y)\n\napproximatedArea :: [Circle] -> Int -> Double\napproximatedArea cs box_side = (fromIntegral count) * dx * dy\n  where\n    \n    x_min = minimum [cx c - cr c | c <- circles]\n    x_max = maximum [cx c + cr c | c <- circles]\n    y_min = minimum [cy c - cr c | c <- circles]\n    y_max = maximum [cy c + cr c | c <- circles]\n    dx = (x_max - x_min) / (fromIntegral box_side)\n    dy = (y_max - y_min) / (fromIntegral box_side)\n    count = length [0 | r <- [0 .. box_side - 1],\n                        c <- [0 .. box_side - 1],\n                        isInsideAny (posx c) (posy r) circles]\n    posy r = y_min + (fromIntegral r) * dy\n    posx c = x_min + (fromIntegral c) * dx\n\ncircles :: [Circle]\ncircles = [Circle ( 1.6417233788) ( 1.6121789534) 0.0848270516,\n           Circle (-1.4944608174) ( 1.2077959613) 1.1039549836,\n           Circle ( 0.6110294452) (-0.6907087527) 0.9089162485,\n           Circle ( 0.3844862411) ( 0.2923344616) 0.2375743054,\n           Circle (-0.2495892950) (-0.3832854473) 1.0845181219,\n           Circle ( 1.7813504266) ( 1.6178237031) 0.8162655711,\n           Circle (-0.1985249206) (-0.8343333301) 0.0538864941,\n           Circle (-1.7011985145) (-0.1263820964) 0.4776976918,\n           Circle (-0.4319462812) ( 1.4104420482) 0.7886291537,\n           Circle ( 0.2178372997) (-0.9499557344) 0.0357871187,\n           Circle (-0.6294854565) (-1.3078893852) 0.7653357688,\n           Circle ( 1.7952608455) ( 0.6281269104) 0.2727652452,\n           Circle ( 1.4168575317) ( 1.0683357171) 1.1016025378,\n           Circle ( 1.4637371396) ( 0.9463877418) 1.1846214562,\n           Circle (-0.5263668798) ( 1.7315156631) 1.4428514068,\n           Circle (-1.2197352481) ( 0.9144146579) 1.0727263474,\n           Circle (-0.1389358881) ( 0.1092805780) 0.7350208828,\n           Circle ( 1.5293954595) ( 0.0030278255) 1.2472867347,\n           Circle (-0.5258728625) ( 1.3782633069) 1.3495508831,\n           Circle (-0.1403562064) ( 0.2437382535) 1.3804956588,\n           Circle ( 0.8055826339) (-0.0482092025) 0.3327165165,\n           Circle (-0.6311979224) ( 0.7184578971) 0.2491045282,\n           Circle ( 1.4685857879) (-0.8347049536) 1.3670667538,\n           Circle (-0.6855727502) ( 1.6465021616) 1.0593087096,\n           Circle ( 0.0152957411) ( 0.0638919221) 0.9771215985]\n\nmain = putStrLn $ \"Approximated area: \" ++\n                  (show $ approximatedArea circles 5000)\n", "target": "from collections import namedtuple\n\nCircle = namedtuple(\"Circle\", \"x y r\")\n\ncircles = [\n    Circle( 1.6417233788,  1.6121789534, 0.0848270516),\n    Circle(-1.4944608174,  1.2077959613, 1.1039549836),\n    Circle( 0.6110294452, -0.6907087527, 0.9089162485),\n    Circle( 0.3844862411,  0.2923344616, 0.2375743054),\n    Circle(-0.2495892950, -0.3832854473, 1.0845181219),\n    Circle( 1.7813504266,  1.6178237031, 0.8162655711),\n    Circle(-0.1985249206, -0.8343333301, 0.0538864941),\n    Circle(-1.7011985145, -0.1263820964, 0.4776976918),\n    Circle(-0.4319462812,  1.4104420482, 0.7886291537),\n    Circle( 0.2178372997, -0.9499557344, 0.0357871187),\n    Circle(-0.6294854565, -1.3078893852, 0.7653357688),\n    Circle( 1.7952608455,  0.6281269104, 0.2727652452),\n    Circle( 1.4168575317,  1.0683357171, 1.1016025378),\n    Circle( 1.4637371396,  0.9463877418, 1.1846214562),\n    Circle(-0.5263668798,  1.7315156631, 1.4428514068),\n    Circle(-1.2197352481,  0.9144146579, 1.0727263474),\n    Circle(-0.1389358881,  0.1092805780, 0.7350208828),\n    Circle( 1.5293954595,  0.0030278255, 1.2472867347),\n    Circle(-0.5258728625,  1.3782633069, 1.3495508831),\n    Circle(-0.1403562064,  0.2437382535, 1.3804956588),\n    Circle( 0.8055826339, -0.0482092025, 0.3327165165),\n    Circle(-0.6311979224,  0.7184578971, 0.2491045282),\n    Circle( 1.4685857879, -0.8347049536, 1.3670667538),\n    Circle(-0.6855727502,  1.6465021616, 1.0593087096),\n    Circle( 0.0152957411,  0.0638919221, 0.9771215985)]\n\ndef main():\n    \n    x_min = min(c.x - c.r for c in circles)\n    x_max = max(c.x + c.r for c in circles)\n    y_min = min(c.y - c.r for c in circles)\n    y_max = max(c.y + c.r for c in circles)\n\n    box_side = 500\n\n    dx = (x_max - x_min) / box_side\n    dy = (y_max - y_min) / box_side\n\n    count = 0\n\n    for r in xrange(box_side):\n        y = y_min + r * dy\n        for c in xrange(box_side):\n            x = x_min + c * dx\n            if any((x-circle.x)**2 + (y-circle.y)**2 <= (circle.r ** 2)\n                   for circle in circles):\n                count += 1\n\n    print \"Approximated area:\", count * dx * dy\n\nmain()\n"}
{"id": 418568, "name": "Factorions", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.List (unfoldr)\nimport Control.Monad (guard)\n\nfactorion :: Int -> Int -> Bool\nfactorion b n = f b n == n\n where\n  f b = sum . map (product . enumFromTo 1) . unfoldr (\\x -> guard (x > 0) >> pure (x `mod` b, x `div` b))\n\nmain :: IO ()\nmain = mapM_ (uncurry (printf \"Factorions for base %2d: %s\\n\") . (\\(a, b) -> (b, result a b))) \n  [(3,9), (4,10), (5,11), (2,12)]\n where \n  factorions b = filter (factorion b) [1..]\n  result n = show . take n . factorions\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 418569, "name": "Factorions", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.List (unfoldr)\nimport Control.Monad (guard)\n\nfactorion :: Int -> Int -> Bool\nfactorion b n = f b n == n\n where\n  f b = sum . map (product . enumFromTo 1) . unfoldr (\\x -> guard (x > 0) >> pure (x `mod` b, x `div` b))\n\nmain :: IO ()\nmain = mapM_ (uncurry (printf \"Factorions for base %2d: %s\\n\") . (\\(a, b) -> (b, result a b))) \n  [(3,9), (4,10), (5,11), (2,12)]\n where \n  factorions b = filter (factorion b) [1..]\n  result n = show . take n . factorions\n", "target": "fact = [1] \nfor n in range(1, 12):\n    fact.append(fact[n-1] * n)\n\nfor b in range(9, 12+1):\n    print(f\"The factorions for base {b} are:\")\n    for i in range(1, 1500000):\n        fact_sum = 0\n        j = i\n        while j > 0:\n            d = j % b\n            fact_sum += fact[d]\n            j = j//b\n        if fact_sum == i:\n            print(i, end=\" \")\n    print(\"\\n\")\n"}
{"id": 418570, "name": "Sum of divisors", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\n\n\ndivisors\n  :: Integral a\n  => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n  filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\"\n    , test sum\n    , \"Products of divisors of [1..100]:\"\n    , test product\n    ]\n\ntest\n  :: (Show a, Integral a)\n  => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n  in unlines $ unwords <$> fmap (fmap (justifyRight w ' ')) (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 418571, "name": "Sum of divisors", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\n\n\ndivisors\n  :: Integral a\n  => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n  filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\"\n    , test sum\n    , \"Products of divisors of [1..100]:\"\n    , test product\n    ]\n\ntest\n  :: (Show a, Integral a)\n  => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n  in unlines $ unwords <$> fmap (fmap (justifyRight w ' ')) (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 418572, "name": "Order by pair comparisons", "source": "Translate Haskell to Python: import Control.Monad\nimport Control.Monad.ListM (sortByM, insertByM, partitionM, minimumByM)\nimport Data.Bool (bool)\nimport Data.Monoid\nimport Data.List\n\n\nisortM, msortM, tsortM :: Monad m => (a -> a -> m Ordering) -> [a] -> m [a]\n\n\nmsortM = sortByM\n\n\nisortM cmp = foldM (flip (insertByM cmp)) []\n\n\ntsortM cmp = go\n  where\n    go [] = pure []\n    go (h:t) = do (l, g) <- partitionM (fmap (LT /=) . cmp h) t\n                  go l <+> pure [h] <+> go g\n    (<+>) = liftM2 (++)\n", "target": "def _insort_right(a, x, q):\n    \n\n    lo, hi = 0, len(a)\n    while lo < hi:\n        mid = (lo+hi)//2\n        q += 1\n        less = input(f\"{q:2}: IS {x:>6} LESS-THAN {a[mid]:>6}\u00a0? y/n: \").strip().lower() == 'y'\n        if less: hi = mid\n        else: lo = mid+1\n    a.insert(lo, x)\n    return q\n\ndef order(items):\n    ordered, q = [], 0\n    for item in items:\n        q = _insort_right(ordered, item, q)\n    return ordered, q\n\nif __name__ == '__main__':\n    items = 'violet red green indigo blue yellow orange'.split()\n    ans, questions = order(items)\n    print('\\n' + ' '.join(ans))\n"}
{"id": 418573, "name": "Fermat numbers", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primeFactors)\nimport Data.Bool (bool)\n\nfermat :: Integer -> Integer\nfermat = succ . (2 ^) . (2 ^)\n\nfermats :: [Integer]\nfermats = fermat <$> [0 ..]\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ fTable \"First 10 Fermats:\" show show fermat [0 .. 9]\n    , fTable\n        \"Factors of first 7:\"\n        show\n        showFactors\n        primeFactors\n        (take 7 fermats)\n    ]\n\n\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  unlines $\n  s : fmap (((++) . rjust w ' ' . xShow) <*> ((\" -> \" ++) . fxShow . f)) xs\n  where\n    rjust n c = drop . length <*> (replicate n c ++)\n    w = maximum (length . xShow <$> xs)\n\nshowFactors :: [Integer] -> String\nshowFactors x\n  | 1 < length x = show x\n  | otherwise = \"(prime)\"\n", "target": "def factors(x):\n    factors = []\n    i = 2\n    s = int(x ** 0.5)\n    while i < s:\n        if x % i == 0:\n            factors.append(i)\n            x = int(x / i)\n            s = int(x ** 0.5)\n        i += 1\n    factors.append(x)\n    return factors\n\nprint(\"First 10 Fermat numbers:\")\nfor i in range(10):\n    fermat = 2 ** 2 ** i + 1\n    print(\"F{} = {}\".format(chr(i + 0x2080) , fermat))\n\nprint(\"\\nFactors of first few Fermat numbers:\")\nfor i in range(10):\n    fermat = 2 ** 2 ** i + 1\n    fac = factors(fermat)\n    if len(fac) == 1:\n        print(\"F{} -> IS PRIME\".format(chr(i + 0x2080)))\n    else:\n        print(\"F{} -> FACTORS: {}\".format(chr(i + 0x2080), fac))\n"}
{"id": 418574, "name": "Sorting algorithms_Bead sort", "source": "Translate Haskell to Python: import Data.List\n\nbeadSort :: [Int] -> [Int]\nbeadSort = map sum. transpose. transpose. map (flip replicate 1)\n", "target": "\nfrom itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))\n"}
{"id": 418575, "name": "Casting out nines", "source": "Translate Haskell to Python: co9 n\n  | n <= 8 = n\n  | otherwise = co9 $ sum $ filter (/= 9) $ digits 10 n\n\ntask2 = filter (\\n -> co9 n == co9 (n ^ 2)) [1 .. 100]\n\ntask3 k = filter (\\n -> n `mod` k == n ^ 2 `mod` k) [1 .. 100]\n", "target": "\n\n\n\ndef CastOut(Base=10, Start=1, End=999999):\n  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]\n  x,y = divmod(Start, Base-1)\n  while True:\n    for n in ran:\n      k = (Base-1)*x + n\n      if k < Start:\n        continue\n      if k > End:\n        return\n      yield k\n    x += 1\n\nfor V in CastOut(Base=16,Start=1,End=255):\n  print(V, end=' ')\n"}
{"id": 418576, "name": "Casting out nines", "source": "Translate Haskell to Python: co9 n\n  | n <= 8 = n\n  | otherwise = co9 $ sum $ filter (/= 9) $ digits 10 n\n\ntask2 = filter (\\n -> co9 n == co9 (n ^ 2)) [1 .. 100]\n\ntask3 k = filter (\\n -> n `mod` k == n ^ 2 `mod` k) [1 .. 100]\n", "target": "\n\n\n\ndef CastOut(Base=10, Start=1, End=999999):\n  ran = [y for y in range(Base-1) if y%(Base-1) == (y*y)%(Base-1)]\n  x,y = divmod(Start, Base-1)\n  while True:\n    for n in ran:\n      k = (Base-1)*x + n\n      if k < Start:\n        continue\n      if k > End:\n        return\n      yield k\n    x += 1\n\nfor V in CastOut(Base=16,Start=1,End=255):\n  print(V, end=' ')\n"}
{"id": 418577, "name": "Simple database", "source": "Translate Haskell to Python: import Control.Monad.State\nimport Data.List (sortBy, nub)\nimport System.Environment (getArgs, getProgName)\nimport System.Directory (doesFileExist)\nimport System.IO (openFile, hGetContents, hClose, IOMode(..),\n    Handle, hPutStrLn)\n\n\ndata Date = Date Integer Int Int deriving (Show, Read, Eq, Ord)\n\n\ndata Item = Item    {description :: String\n                    ,category    :: [String]\n                    ,date        :: Date\n                    ,optional    :: [String]}\n                    deriving (Show, Read)\n\n\n\ntype ItemList a = StateT [Item] IO a\n\n\naddItem :: Item -> ItemList ()\naddItem i = modify (++ [i])\n\n\nlatest :: [Item] -> [Item]\nlatest [] = []\nlatest [x]= [x]\nlatest xs = take 1 $ sortBy newer xs\n\n\nnewer :: Item -> Item -> Ordering\nnewer a b = compare (date b) (date a)\n\n\ncategories :: ItemList [String]\ncategories = liftM (nub . concatMap category) get\n\n\nfilterByCategory :: String -> ItemList [Item]\nfilterByCategory c = liftM (filter (\\i -> c `elem` category i)) get\n\n\nlastOfAll :: ItemList [Item]\nlastOfAll = liftM latest get\n    \n\nlatestByCategory :: ItemList [Item]\nlatestByCategory = do\n    cats <- categories\n    filt <- mapM filterByCategory cats\n    return $ concatMap latest filt\n\n\nsortByDate :: ItemList [Item]\nsortByDate = liftM (sortBy newer) get\n\ntoScreen :: Item -> IO ()\ntoScreen (Item desc cats (Date y m d) opt) = putStrLn $\n    \"Description:\\t\" ++ desc ++ \"\\nCategories:\\t\" ++ show cats ++\n    \"\\nDate:\\t\\t\" ++ show y ++ \"-\" ++ show m ++ \"-\" ++ show d ++\n    \"\\nOther info:\\t\" ++ show opt\n\n\n\n\n\narguments :: ItemList [Item]\narguments = do\n    args <- liftIO getArgs\n    case args of\n        (\"add\":desc:cat:year:month:day:opt) -> do\n            let newItem = parseItem args\n            addItem newItem\n            return [newItem]\n        (\"latest\":[]) -> do\n            item <- lastOfAll\n            lift $ mapM_ toScreen item\n            return []\n        (\"category\":[]) -> do\n            items <- latestByCategory\n            lift $ mapM_ toScreen items\n            return []\n        (\"all\":[]) -> do\n            sorted <- sortByDate\n            lift $ mapM_ toScreen sorted\n            return []\n        _ -> do\n            lift usage\n            return []\n\nparseItem :: [String] -> Item\nparseItem (_:desc:cat:year:month:day:opt) =\n    Item {description = desc, category = words cat,\n        date = Date (read year) (read month) (read day),\n        optional = opt}\n                \nusage :: IO ()\nusage = do\n    progName <- getProgName\n    putStrLn $ \"Usage: \" ++ progName ++ \" add|all|category|latest \\\n        \\OPTIONS\\n\\nadd \\\"description\\\" \\\"category1 category2\\\"... \\\n        \\year month day [\\\"note1\\\" \\\"note2\\\"...]\\n\\tAdds a new record \\\n        \\to the database.\\n\\nall\\n\\tPrints all items in chronological \\\n        \\order.\\n\\ncategory\\n\\tPrints the latest item for each category.\\\n        \\\\n\\nlatest\\n\\tPrints the latest item.\"\n\n\nmain :: IO ()\nmain = do\n    progName <- getProgName\n    let fileName = progName ++ \".db\"\n    e <- doesFileExist fileName\n    if e\n        then do\n            hr <- openFile fileName ReadMode\n            f <- hGetContents hr\n            v <- evalStateT arguments (map read $ lines f)\n            hClose hr \n            hw <- openFile fileName AppendMode\n            mapM_ (hPutStrLn hw . show) v\n            hClose hw\n        else do\n            v <- evalStateT arguments []\n            hw <- openFile fileName WriteMode\n            mapM_ (hPutStrLn hw . show) v\n            hClose hw\n", "target": "\n\n\n\nimport argparse\nfrom argparse import Namespace\nimport datetime\nimport shlex\n\n\ndef parse_args():\n    'Set up, parse, and return arguments'\n    \n    parser = argparse.ArgumentParser(epilog=globals()['__doc__'])\n\n    parser.add_argument('command', choices='add pl plc pa'.split(),\n                        help=)\n    parser.add_argument('-d', '--description',\n                        help='A description of the item. (e.g., title, name)')\n    parser.add_argument('-t', '--tag',\n                        help=(\n                              ))\n    parser.add_argument('-f', '--field', nargs=2, action='append', \n                        help='Other optional fields with value (can be repeated)')\n\n    return parser\n\ndef do_add(args, dbname):\n    'Add a new entry'\n    if args.description is None:\n        args.description = ''\n    if args.tag is None:\n        args.tag = ''\n    del args.command\n    print('Writing record to %s' % dbname)\n    with open(dbname, 'a') as db:\n        db.write('%r\\n' % args)\n    \ndef do_pl(args, dbname):\n    'Print the latest entry'\n    print('Getting last record from %s' % dbname)\n    with open(dbname, 'r') as db:\n        for line in db: pass\n    record = eval(line)\n    del record._date\n    print(str(record))\n    \ndef do_plc(args, dbname):\n    'Print the latest entry for each category/tag'\n    print('Getting latest record for each tag from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    tags = set(record.tag for record in records)\n    records.reverse()\n    for record in records:\n        if record.tag in tags:\n            del record._date\n            print(str(record))\n            tags.discard(record.tag)\n            if not tags: break\n\ndef do_pa(args, dbname):\n    'Print all entries sorted by a date'\n    print('Getting all records by date from %s' % dbname)\n    with open(dbname, 'r') as db:\n        records = [eval(line) for line in db]\n    for record in records:\n        del record._date\n        print(str(record))\n\ndef test():\n    import time\n    parser = parse_args()\n    for cmdline in [\n                    ,\n                    ,\n                    ,\n                    ,\n                    ,\n                    ]:\n        args = parser.parse_args(shlex.split(cmdline))\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n        time.sleep(0.5)\n\n\n    \ndo_command = dict(add=do_add, pl=do_pl, plc=do_plc, pa=do_pa)\ndbname = '_simple_db_db.py'\n\n\nif __name__ == '__main__':\n    if 0:\n        test()\n    else:\n        parser = parse_args()\n        args = parser.parse_args()\n        now = datetime.datetime.utcnow()\n        args._date = now.isoformat()\n        do_command[args.command](args, dbname)\n"}
{"id": 418578, "name": "Tau function", "source": "Translate Haskell to Python: tau :: Integral a => a -> a\ntau n | n <= 0 = error \"Not a positive integer\"\ntau n = go 0 (1, 1)\n    where\n    yo i = (i, i * i)\n    go r (i, ii)\n        | n < ii = r\n        | n == ii = r + 1\n        | 0 == mod n i = go (r + 2) (yo $ i + 1)\n        | otherwise = go r (yo $ i + 1)\n\nmain = print $ map tau [1..100]\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 418579, "name": "Tau function", "source": "Translate Haskell to Python: tau :: Integral a => a -> a\ntau n | n <= 0 = error \"Not a positive integer\"\ntau n = go 0 (1, 1)\n    where\n    yo i = (i, i * i)\n    go r (i, ii)\n        | n < ii = r\n        | n == ii = r + 1\n        | 0 == mod n i = go (r + 2) (yo $ i + 1)\n        | otherwise = go r (yo $ i + 1)\n\nmain = print $ map tau [1..100]\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef tau(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= 1 + k\n    return ans\n\nif __name__ == \"__main__\":\n    print(*map(tau, range(1, 101)))\n"}
{"id": 418580, "name": "M\u00f6bius function", "source": "Translate Haskell to Python: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Data.Vector.Unboxed (toList)\nimport Math.NumberTheory.ArithmeticFunctions.Moebius (Moebius(..),\n                                                      sieveBlockMoebius)\nimport System.Environment (getArgs, getProgName)\nimport System.IO (hPutStrLn, stderr)\nimport Text.Read (readMaybe)\n\n\nmoebiusBlock :: Word -> [Moebius]\nmoebiusBlock = toList . sieveBlockMoebius 1\n\nshowMoebiusBlock :: Word -> [Moebius] -> String\nshowMoebiusBlock cols = intercalate \"\\n\" . map (concatMap showMoebius) .\n                        chunksOf (fromIntegral cols)\n  where showMoebius MoebiusN = \" -1\"\n        showMoebius MoebiusZ = \"  0\"\n        showMoebius MoebiusP = \"  1\"\n\nmain :: IO ()\nmain = do\n  prog <- getProgName\n  args <- map readMaybe <$> getArgs\n  case args of\n    [Just cols, Just n] ->\n      putStrLn (\"\u03bc(n) for 1 \u2264 n \u2264 \" ++ show n ++ \":\\n\") >>\n      putStrLn (showMoebiusBlock cols $ moebiusBlock n)\n    _ -> hPutStrLn stderr $ \"Usage: \" ++ prog ++ \" num-columns maximum-number\"\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\ndef isPrime(n) :\n \n    if (n < 2) :\n        return False\n    for i in range(2, n + 1) :\n        if (i * i <= n and n % i == 0) :\n            return False\n    return True\n \ndef mobius(N) :\n     \n    \n    if (N == 1) :\n        return 1\n \n    \n    \n    \n    p = 0\n    for i in range(1, N + 1) :\n        if (N % i == 0 and\n                isPrime(i)) :\n \n            \n            \n            if (N % (i * i) == 0) :\n                return 0\n            else :\n \n                \n                \n                p = p + 1\n \n    \n    \n    \n    \n    if(p % 2 != 0) :\n        return -1\n    else :\n        return 1\n \n\nprint(\"Mobius numbers from 1..99:\")\n      \nfor i in range(1, 100):\n  print(f\"{mobius(i):>4}\", end = '')\n\n  if i % 20 == 0: print()\n\n\n"}
{"id": 418581, "name": "Coprime triplets", "source": "Translate Haskell to Python: import Data.List (find, transpose, unfoldr)\nimport Data.List.Split (chunksOf)\nimport qualified Data.Set as S\n\n\n\ncoprimeTriples :: Integral a => [a]\ncoprimeTriples =\n  [1, 2] <> unfoldr go (S.fromList [1, 2], (1, 2))\n  where\n    go (seen, (a, b)) =\n      Just\n        (c, (S.insert c seen, (b, c)))\n      where\n        Just c =\n          find\n            ( ((&&) . flip S.notMember seen)\n                <*> ((&&) . coprime a <*> coprime b)\n            )\n            [3 ..]\n\ncoprime :: Integral a => a -> a -> Bool\ncoprime a b = 1 == gcd a b\n\n\n\nmain :: IO ()\nmain =\n  let xs = takeWhile (< 50) coprimeTriples\n   in putStrLn (show (length xs) <> \" terms below 50:\\n\")\n        >> putStrLn\n          ( spacedTable\n              justifyRight\n              (chunksOf 10 (show <$> xs))\n          )\n\n\n\nspacedTable ::\n  (Int -> Char -> String -> String) -> [[String]] -> String\nspacedTable aligned rows =\n  unlines $\n    unwords\n      . zipWith\n        (`aligned` ' ')\n        (maximum . fmap length <$> transpose rows)\n      <$> rows\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\ndef Gcd(v1, v2):\n    a, b = v1, v2\n    if (a < b):\n        a, b = v2, v1\n    r = 1\n    while (r != 0):\n        r = a % b\n        if (r != 0):\n            a = b\n            b = r\n    return b\n\n\na = [1, 2]\n\nn = 3\n\nwhile (n < 50):\n    gcd1 = Gcd(n, a[-1])\n    gcd2 = Gcd(n, a[-2])\n    \n    \n    if (gcd1 == 1 and gcd2 == 1 and not(n in a)):\n        \n        a.append(n)\n        n = 3\n    else:\n        \n        n += 1\n\n\nfor i in range(0, len(a)):\n    if (i % 10 == 0):\n        print('')\n    print(\"%4d\" % a[i], end = '');\n    \n\nprint(\"\\n\\nNumber of elements in coprime triplets = \" + str(len(a)), end = \"\\n\")\n"}
{"id": 418582, "name": "Coprime triplets", "source": "Translate Haskell to Python: import Data.List (find, transpose, unfoldr)\nimport Data.List.Split (chunksOf)\nimport qualified Data.Set as S\n\n\n\ncoprimeTriples :: Integral a => [a]\ncoprimeTriples =\n  [1, 2] <> unfoldr go (S.fromList [1, 2], (1, 2))\n  where\n    go (seen, (a, b)) =\n      Just\n        (c, (S.insert c seen, (b, c)))\n      where\n        Just c =\n          find\n            ( ((&&) . flip S.notMember seen)\n                <*> ((&&) . coprime a <*> coprime b)\n            )\n            [3 ..]\n\ncoprime :: Integral a => a -> a -> Bool\ncoprime a b = 1 == gcd a b\n\n\n\nmain :: IO ()\nmain =\n  let xs = takeWhile (< 50) coprimeTriples\n   in putStrLn (show (length xs) <> \" terms below 50:\\n\")\n        >> putStrLn\n          ( spacedTable\n              justifyRight\n              (chunksOf 10 (show <$> xs))\n          )\n\n\n\nspacedTable ::\n  (Int -> Char -> String -> String) -> [[String]] -> String\nspacedTable aligned rows =\n  unlines $\n    unwords\n      . zipWith\n        (`aligned` ' ')\n        (maximum . fmap length <$> transpose rows)\n      <$> rows\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\ndef Gcd(v1, v2):\n    a, b = v1, v2\n    if (a < b):\n        a, b = v2, v1\n    r = 1\n    while (r != 0):\n        r = a % b\n        if (r != 0):\n            a = b\n            b = r\n    return b\n\n\na = [1, 2]\n\nn = 3\n\nwhile (n < 50):\n    gcd1 = Gcd(n, a[-1])\n    gcd2 = Gcd(n, a[-2])\n    \n    \n    if (gcd1 == 1 and gcd2 == 1 and not(n in a)):\n        \n        a.append(n)\n        n = 3\n    else:\n        \n        n += 1\n\n\nfor i in range(0, len(a)):\n    if (i % 10 == 0):\n        print('')\n    print(\"%4d\" % a[i], end = '');\n    \n\nprint(\"\\n\\nNumber of elements in coprime triplets = \" + str(len(a)), end = \"\\n\")\n"}
{"id": 418583, "name": "Curzon numbers", "source": "Translate Haskell to Python: import Data.List.Split ( chunksOf )\n\nisGeneralizedCurzon :: Integer -> Integer -> Bool\nisGeneralizedCurzon base n = mod ( base ^ n + 1 ) ( base * n + 1 ) == 0\n\nsolution :: Integer -> [Integer]\nsolution base = take 50 $ filter (\\i -> isGeneralizedCurzon base i ) [1..]\n\nprintChunk :: [Integer] -> String\nprintChunk chunk = foldl1 (++) $ map (\\i -> (take ( 4 - (length $ show i) )\n $ repeat ' ' ) ++ show i ++ \" \") chunk\n\nprettyPrint :: [Integer] -> [String]\nprettyPrint list = map printChunk $ chunksOf 10 list\n\noneThousandth :: Integer -> Integer\noneThousandth base = last $ take 950 $ filter (\\i -> isGeneralizedCurzon base i ) \n [(last $ solution base) + 1 ..]  \n\nprintBlock :: Integer -> [String]\nprintBlock base = [\"first 50 Curzon numbers using a base of \" ++ show base ++ \"\u00a0:\"]\n ++  (prettyPrint $ solution base) ++ [\"one thousandth at base \" ++ show base ++\n  \": \" ++ (show $ oneThousandth base)] ++ [take 50 $ repeat '-']\n           \nmain :: IO ( )\nmain = do\n   blocks <- return $ concat $ map (\\i -> printBlock i ) [2 , 4 , 6 , 8 , 10]\n   mapM_ putStrLn blocks\n", "target": "def is_Curzon(n, k):\n    r = k * n\n    return pow(k, n, r + 1) == r\n\nfor k in [2, 4, 6, 8, 10]:\n    n, curzons = 1, []\n    while len(curzons) < 1000:\n        if is_Curzon(n, k):\n            curzons.append(n)\n        n += 1\n    print(f'Curzon numbers with k = {k}:')\n    for i, c in enumerate(curzons[:50]):\n        print(f'{c: 5,}', end='\\n' if (i + 1) % 25 == 0 else '')\n    print(f'    Thousandth Curzon with k = {k}: {curzons[999]}.\\n')\n"}
{"id": 418584, "name": "Curzon numbers", "source": "Translate Haskell to Python: import Data.List.Split ( chunksOf )\n\nisGeneralizedCurzon :: Integer -> Integer -> Bool\nisGeneralizedCurzon base n = mod ( base ^ n + 1 ) ( base * n + 1 ) == 0\n\nsolution :: Integer -> [Integer]\nsolution base = take 50 $ filter (\\i -> isGeneralizedCurzon base i ) [1..]\n\nprintChunk :: [Integer] -> String\nprintChunk chunk = foldl1 (++) $ map (\\i -> (take ( 4 - (length $ show i) )\n $ repeat ' ' ) ++ show i ++ \" \") chunk\n\nprettyPrint :: [Integer] -> [String]\nprettyPrint list = map printChunk $ chunksOf 10 list\n\noneThousandth :: Integer -> Integer\noneThousandth base = last $ take 950 $ filter (\\i -> isGeneralizedCurzon base i ) \n [(last $ solution base) + 1 ..]  \n\nprintBlock :: Integer -> [String]\nprintBlock base = [\"first 50 Curzon numbers using a base of \" ++ show base ++ \"\u00a0:\"]\n ++  (prettyPrint $ solution base) ++ [\"one thousandth at base \" ++ show base ++\n  \": \" ++ (show $ oneThousandth base)] ++ [take 50 $ repeat '-']\n           \nmain :: IO ( )\nmain = do\n   blocks <- return $ concat $ map (\\i -> printBlock i ) [2 , 4 , 6 , 8 , 10]\n   mapM_ putStrLn blocks\n", "target": "def is_Curzon(n, k):\n    r = k * n\n    return pow(k, n, r + 1) == r\n\nfor k in [2, 4, 6, 8, 10]:\n    n, curzons = 1, []\n    while len(curzons) < 1000:\n        if is_Curzon(n, k):\n            curzons.append(n)\n        n += 1\n    print(f'Curzon numbers with k = {k}:')\n    for i, c in enumerate(curzons[:50]):\n        print(f'{c: 5,}', end='\\n' if (i + 1) % 25 == 0 else '')\n    print(f'    Thousandth Curzon with k = {k}: {curzons[999]}.\\n')\n"}
{"id": 418585, "name": "Mertens function", "source": "Translate Haskell to Python: import           Data.List.Split          (chunksOf)\nimport qualified Data.MemoCombinators  as Memo\nimport           Math.NumberTheory.Primes (unPrime, factorise)\nimport           Text.Printf              (printf)\n\nmoebius :: Integer -> Int\nmoebius = product . fmap m . factorise\n  where\n    m (p, e)\n      | unPrime p == 0 = 0\n      | e == 1 = -1\n      | otherwise = 0\n\nmertens :: Integer -> Int\nmertens = Memo.integral (\\n -> sum $ fmap moebius [1..n])\n\ncountZeros :: [Integer] -> Int\ncountZeros = length . filter ((==0) . mertens)\n\ncrossesZero :: [Integer] -> Int\ncrossesZero = length . go . fmap mertens\n  where\n    go (x:y:xs) \n      | y == 0 && x /= 0 = y : go (y:xs)\n      | otherwise        = go (y:xs)\n    go _ = []\n\nmain :: IO ()\nmain = do\n  printf \"The first 99 terms for M(1..99):\\n\\n   \"\n  mapM_ (printf \"%3d\" . mertens) [1..9] >> printf \"\\n\"\n  mapM_ (\\row -> mapM_ (printf \"%3d\" . mertens) row >> printf \"\\n\") $ chunksOf 10 [10..99]\n  printf \"\\nM(n) is zero %d times for 1 <= n <= 1000.\\n\" $ countZeros [1..1000]\n  printf \"M(n) crosses zero %d times for 1 <= n <= 1000.\\n\" $ crossesZero [1..1000]\n", "target": "def mertens(count):\n    \n    m = [None, 1]\n    for n in range(2, count+1):\n        m.append(1)\n        for k in range(2, n+1):\n            m[n] -= m[n//k]\n    return m\n    \n\nms = mertens(1000)\n\nprint(\"The first 99 Mertens numbers are:\")\nprint(\"  \", end=' ')\ncol = 1\nfor n in ms[1:100]:\n    print(\"{:2d}\".format(n), end=' ')\n    col += 1\n    if col == 10:\n        print()\n        col = 0\n        \nzeroes = sum(x==0 for x in ms)\ncrosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))\nprint(\"M(N) equals zero {} times.\".format(zeroes))\nprint(\"M(N) crosses zero {} times.\".format(crosses))\n"}
{"id": 418586, "name": "Product of divisors", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\n\n\n\ndivisors :: Integral a => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n    filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\",\n      test sum,\n      \"Products of divisors of [1..100]:\",\n      test product\n    ]\n\ntest :: (Show a, Integral a) => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n   in unlines $\n        unwords\n          <$> fmap\n            (fmap (justifyRight w ' '))\n            (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 418587, "name": "Product of divisors", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\n\n\n\ndivisors :: Integral a => a -> [a]\ndivisors n =\n  ((<>) <*> (rest . reverse . fmap (quot n))) $\n    filter ((0 ==) . rem n) [1 .. root]\n  where\n    root = (floor . sqrt . fromIntegral) n\n    rest\n      | n == root * root = tail\n      | otherwise = id\n\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sums of divisors of [1..100]:\",\n      test sum,\n      \"Products of divisors of [1..100]:\",\n      test product\n    ]\n\ntest :: (Show a, Integral a) => ([a] -> a) -> String\ntest f =\n  let xs = show . f . divisors <$> [1 .. 100]\n      w = maximum $ length <$> xs\n   in unlines $\n        unwords\n          <$> fmap\n            (fmap (justifyRight w ' '))\n            (chunksOf 5 xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 418588, "name": "Playing cards", "source": "Translate Haskell to Python: import System.Random\n\ndata Pip = Two | Three | Four | Five | Six | Seven | Eight | Nine | Ten | \n           Jack | Queen | King | Ace \n  deriving (Ord, Enum, Bounded, Eq, Show)\n\ndata Suit = Diamonds | Spades | Hearts | Clubs\n  deriving (Ord, Enum, Bounded, Eq, Show)\n\ntype Card = (Pip, Suit)\n\nfullRange :: (Bounded a, Enum a) => [a]\nfullRange = [minBound..maxBound]\n\nfullDeck :: [Card]\nfullDeck = [(pip, suit) | pip <- fullRange, suit <- fullRange]\n\ninsertAt :: Int -> a -> [a] -> [a]\ninsertAt 0 x ys     = x:ys\ninsertAt n _ []     = error \"insertAt: list too short\"\ninsertAt n x (y:ys) = y : insertAt (n-1) x ys\n\nshuffle :: RandomGen g => g -> [a] -> [a]\nshuffle g xs = shuffle' g xs 0 [] where\n  shuffle' g []     _ ys = ys\n  shuffle' g (x:xs) n ys = shuffle' g' xs (n+1) (insertAt k x ys) where\n    (k,g') = randomR (0,n) g\n", "target": "import random\n\nclass Card(object):\n    suits = (\"Clubs\",\"Hearts\",\"Spades\",\"Diamonds\")\n    pips = (\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"Jack\",\"Queen\",\"King\",\"Ace\")\n\n    def __init__(self, pip,suit):\n        self.pip=pip\n        self.suit=suit\n\n    def __str__(self):\n        return \"%s %s\"%(self.pip,self.suit)\n\nclass Deck(object):\n    def __init__(self):\n        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]\n\n    def __str__(self):\n        return \"[%s]\"%\", \".join( (str(card) for card in self.deck))\n\n    def shuffle(self):\n        random.shuffle(self.deck)\n\n    def deal(self):\n        self.shuffle()  \n        return self.deck.pop(0)\n"}
{"id": 418589, "name": "Coprimes", "source": "Translate Haskell to Python: \n\ncoprime :: Integral a => a -> a -> Bool\ncoprime a b = 1 == gcd a b\n\n\n\nmain :: IO ()\nmain =\n  print $\n    filter\n      ((1 ==) . uncurry gcd)\n      [ (21, 15),\n        (17, 23),\n        (36, 12),\n        (18, 29),\n        (60, 15)\n      ]\n", "target": "\n\nfrom math import gcd\n\n\n\ndef coprime(a, b):\n    \n    return 1 == gcd(a, b)\n\n\n\n\ndef main():\n    \n\n    print([\n        xy for xy in [\n            (21, 15), (17, 23), (36, 12),\n            (18, 29), (60, 15)\n        ]\n        if coprime(*xy)\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418590, "name": "Coprimes", "source": "Translate Haskell to Python: \n\ncoprime :: Integral a => a -> a -> Bool\ncoprime a b = 1 == gcd a b\n\n\n\nmain :: IO ()\nmain =\n  print $\n    filter\n      ((1 ==) . uncurry gcd)\n      [ (21, 15),\n        (17, 23),\n        (36, 12),\n        (18, 29),\n        (60, 15)\n      ]\n", "target": "\n\nfrom math import gcd\n\n\n\ndef coprime(a, b):\n    \n    return 1 == gcd(a, b)\n\n\n\n\ndef main():\n    \n\n    print([\n        xy for xy in [\n            (21, 15), (17, 23), (36, 12),\n            (18, 29), (60, 15)\n        ]\n        if coprime(*xy)\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418591, "name": "Perfect totient numbers", "source": "Translate Haskell to Python: perfectTotients :: [Int]\nperfectTotients =\n  filter ((==) <*> (succ . sum . tail . takeWhile (1 /=) . iterate \u03c6)) [2 ..]\n\n\u03c6 :: Int -> Int\n\u03c6 = memoize (\\n -> length (filter ((1 ==) . gcd n) [1 .. n]))\n\nmemoize :: (Int -> a) -> (Int -> a)\nmemoize f = (!!) (f <$> [0 ..])\n\nmain :: IO ()\nmain = print $ take 20 perfectTotients\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 418592, "name": "Perfect totient numbers", "source": "Translate Haskell to Python: perfectTotients :: [Int]\nperfectTotients =\n  filter ((==) <*> (succ . sum . tail . takeWhile (1 /=) . iterate \u03c6)) [2 ..]\n\n\u03c6 :: Int -> Int\n\u03c6 = memoize (\\n -> length (filter ((1 ==) . gcd n) [1 .. n]))\n\nmemoize :: (Int -> a) -> (Int -> a)\nmemoize f = (!!) (f <$> [0 ..])\n\nmain :: IO ()\nmain = print $ take 20 perfectTotients\n", "target": "from math import gcd\nfrom functools import lru_cache\nfrom itertools import islice, count\n\n@lru_cache(maxsize=None)\ndef  \u03c6(n):\n    return sum(1 for k in range(1, n + 1) if gcd(n, k) == 1)\n\ndef perfect_totient():\n    for n0 in count(1):\n        parts, n = 0, n0\n        while n != 1:\n            n = \u03c6(n)\n            parts += n\n        if parts == n0:\n            yield n0\n        \n\nif __name__ == '__main__':\n    print(list(islice(perfect_totient(), 20)))\n"}
{"id": 418593, "name": "Lah numbers", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Control.Monad (when)\n \nfactorial :: Integral n => n -> n\nfactorial 0 = 1\nfactorial n = product [1..n]\n \nlah :: Integral n => n -> n -> n\nlah n k\n  | k == 1 = factorial n\n  | k == n = 1\n  | k > n  = 0\n  | k < 1 || n < 1 = 0\n  | otherwise = f n `div` f k `div` factorial (n - k)\n      where\n        f = (*) =<< (^ 2) . factorial . pred  \n \nprintLah :: (Word, Word) -> IO ()\nprintLah (n, k) = do\n  when (k == 0) (printf \"\\n%3d\" n)\n  printf \"%11d\" (lah n k)\n \nmain :: IO ()\nmain = do\n  printf \"Unsigned Lah numbers: L(n, k):\\nn/k\"\n  mapM_ (printf \"%11d\") zeroToTwelve\n  mapM_ printLah $ (,) <$> zeroToTwelve <*> zeroToTwelve\n  printf \"\\nMaximum value from the L(100, *) row:\\n%d\\n\"\n    (maximum $ lah 100 <$> ([0..100] :: [Integer]))\n  where zeroToTwelve = [0..12]\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418594, "name": "Lah numbers", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Control.Monad (when)\n \nfactorial :: Integral n => n -> n\nfactorial 0 = 1\nfactorial n = product [1..n]\n \nlah :: Integral n => n -> n -> n\nlah n k\n  | k == 1 = factorial n\n  | k == n = 1\n  | k > n  = 0\n  | k < 1 || n < 1 = 0\n  | otherwise = f n `div` f k `div` factorial (n - k)\n      where\n        f = (*) =<< (^ 2) . factorial . pred  \n \nprintLah :: (Word, Word) -> IO ()\nprintLah (n, k) = do\n  when (k == 0) (printf \"\\n%3d\" n)\n  printf \"%11d\" (lah n k)\n \nmain :: IO ()\nmain = do\n  printf \"Unsigned Lah numbers: L(n, k):\\nn/k\"\n  mapM_ (printf \"%11d\") zeroToTwelve\n  mapM_ printLah $ (,) <$> zeroToTwelve <*> zeroToTwelve\n  printf \"\\nMaximum value from the L(100, *) row:\\n%d\\n\"\n    (maximum $ lah 100 <$> ([0..100] :: [Integer]))\n  where zeroToTwelve = [0..12]\n", "target": "from math import (comb,\n                  factorial)\n\n\ndef lah(n, k):\n    if k == 1:\n        return factorial(n)\n    if k == n:\n        return 1\n    if k > n:\n        return 0\n    if k < 1 or n < 1:\n        return 0\n    return comb(n, k) * factorial(n - 1) // factorial(k - 1)\n\n\ndef main():\n    print(\"Unsigned Lah numbers: L(n, k):\")\n    print(\"n/k \", end='\\t')\n    for i in range(13):\n        print(\"%11d\" % i, end='\\t')\n    print()\n    for row in range(13):\n        print(\"%-4d\" % row, end='\\t')\n        for i in range(row + 1):\n            l = lah(row, i)\n            print(\"%11d\" % l, end='\\t')\n        print()\n    print(\"\\nMaximum value from the L(100, *) row:\")\n    max_val = max(lah(100, a) for a in range(100))\n    print(max_val)\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418595, "name": "Two sum", "source": "Translate Haskell to Python: twoSum::(Num a,Ord a) => a -> [a] -> [Int]\ntwoSum num list = sol ls (reverse ls)\n  where\n  ls = zip list [0..]\n  sol [] _ = []\n  sol _ [] = []\n  sol xs@((x,i):us) ys@((y,j):vs) = ans\n    where\n    s = x + y\n    ans | s == num  = [i,j]\n        | j <= i    = []\n        | s < num   = sol (dropWhile ((<num).(+y).fst) us) ys\n        | otherwise = sol xs $ dropWhile ((num <).(+x).fst) vs\n\nmain = print $ twoSum 21 [0, 2, 11, 19, 90]\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 418596, "name": "Two sum", "source": "Translate Haskell to Python: twoSum::(Num a,Ord a) => a -> [a] -> [Int]\ntwoSum num list = sol ls (reverse ls)\n  where\n  ls = zip list [0..]\n  sol [] _ = []\n  sol _ [] = []\n  sol xs@((x,i):us) ys@((y,j):vs) = ans\n    where\n    s = x + y\n    ans | s == num  = [i,j]\n        | j <= i    = []\n        | s < num   = sol (dropWhile ((<num).(+y).fst) us) ys\n        | otherwise = sol xs $ dropWhile ((num <).(+x).fst) vs\n\nmain = print $ twoSum 21 [0, 2, 11, 19, 90]\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 418597, "name": "Terminal control_Unicode output", "source": "Translate Haskell to Python: import System.Environment\nimport Data.List\nimport Data.Char\nimport Data.Maybe\n\nmain = do \n        x <- mapM lookupEnv [\"LANG\", \"LC_ALL\", \"LC_CTYPE\"]\n        if any (isInfixOf \"UTF\". map toUpper) $ catMaybes x \n         then putStrLn \"UTF supported: \\x25b3\"\n         else putStrLn \"UTF not supported\"\n", "target": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")\n"}
{"id": 418598, "name": "Terminal control_Unicode output", "source": "Translate Haskell to Python: import System.Environment\nimport Data.List\nimport Data.Char\nimport Data.Maybe\n\nmain = do \n        x <- mapM lookupEnv [\"LANG\", \"LC_ALL\", \"LC_CTYPE\"]\n        if any (isInfixOf \"UTF\". map toUpper) $ catMaybes x \n         then putStrLn \"UTF supported: \\x25b3\"\n         else putStrLn \"UTF not supported\"\n", "target": "import sys\n\nif \"UTF-8\" in sys.stdout.encoding:\n    print(\"\u25b3\")\nelse:\n    raise Exception(\"Terminal can't handle UTF-8\")\n"}
{"id": 418599, "name": "Unprimeable numbers", "source": "Translate Haskell to Python: import Control.Lens ((.~), ix, (&))\nimport Data.Numbers.Primes (isPrime)\nimport Data.List (find, intercalate)\nimport Data.Char (intToDigit)\nimport Data.Maybe (mapMaybe)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\nisUnprimable :: Int -> Bool\nisUnprimable = all (not . isPrime) . swapdigits\n\nswapdigits :: Int -> [Int]\nswapdigits n = map read $ go $ pred $ length digits\n where\n  digits = show n\n  go (-1) = []\n  go n''  = map (\\x -> digits & (ix n'') .~ intToDigit x) [0..9] <> go (pred n'')\n\nunPrimeable :: [Int]\nunPrimeable = filter isUnprimable [1..]\n\nmain :: IO ()\nmain = do \n  printf \"First 35 unprimeable numbers:\\n%s\\n\\n\" $ show $ take 35 unPrimeable\n  printf \"600th unprimeable number: %d\\n\\n\" $ unPrimeable !! 599\n  mapM_ (uncurry (printf \"Lowest unprimeable number ending with %d: %10s\\n\")) $ mapMaybe lowest [0..9]\n where \n  thousands = reverse . intercalate \",\" . chunksOf 3 . reverse\n  lowest n = do\n    x <- find (\\x -> x `mod` 10 == n) unPrimeable\n    pure (n, thousands $ show x)\n", "target": "from itertools import count, islice\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n, _seen={0: False, 1: False}):\n    def _isprime(n):\n        for p in primes():\n            if p*p > n:\n                return True\n            if n%p == 0:\n                return False\n\n    if n not in _seen:\n        _seen[n] = _isprime(n)\n    return _seen[n]\n\ndef unprime():\n    for a in count(1):\n        d = 1\n        while d <= a:\n            base = (a//(d*10))*(d*10) + (a%d) \n            if any(isprime(y) for y in range(base, base + d*10, d)):\n                break\n            d *= 10\n        else:\n            yield a\n\n\nprint('First 35:')\nprint(' '.join(str(i) for i in islice(unprime(), 35)))\n\nprint('\\nThe 600-th:')\nprint(list(islice(unprime(), 599, 600))[0])\nprint()\n\nfirst, need = [False]*10, 10\nfor p in unprime():\n    i = p%10\n    if first[i]: continue\n\n    first[i] = p\n    need -= 1\n    if not need:\n        break\n\nfor i,v in enumerate(first):\n    print(f'{i} ending: {v}')\n"}
{"id": 418600, "name": "Tau number", "source": "Translate Haskell to Python: tau :: Integral a => a -> a\ntau n | n <= 0 = error \"Not a positive integer\"\ntau n = go 0 (1, 1)\n    where\n    yo i = (i, i * i)\n    go r (i, ii)\n        | n < ii = r\n        | n == ii = r + 1\n        | 0 == mod n i = go (r + 2) (yo $ i + 1)\n        | otherwise = go r (yo $ i + 1)\n\nisTau :: Integral a => a -> Bool\nisTau n = 0 == mod n (tau n)\n\nmain = print . take 100 . filter isTau $ [1..]\n", "target": "def tau(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans, i, j = 0, 1, 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans += 1\n            j = n//i\n            if j != i:\n                ans += 1\n        i += 1\n    return ans\n\ndef is_tau_number(n):\n    assert(isinstance(n, int))\n    if n <= 0:\n        return False\n    return 0 == n%tau(n)\n\nif __name__ == \"__main__\":\n    n = 1\n    ans = []\n    while len(ans) < 100:\n        if is_tau_number(n):\n            ans.append(n)\n        n += 1\n    print(ans)\n"}
{"id": 418601, "name": "Primes whose sum of digits is 25", "source": "Translate Haskell to Python: import Data.Bifunctor (second)\nimport Data.List (replicate)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primes)\n\n\n\nmatchingPrimes :: [Int]\nmatchingPrimes =\n  takeWhile\n    (< 5000)\n    [n | n <- primes, 25 == decimalDigitSum n]\n\ndecimalDigitSum :: Int -> Int\ndecimalDigitSum n =\n  snd $\n    until\n      ((0 ==) . fst)\n      (\\(n, x) -> second (+ x) $ quotRem n 10)\n      (n, 0)\n\n\nmain :: IO ()\nmain = do\n  let w = length (show (last matchingPrimes))\n  mapM_ putStrLn $\n    ( show (length matchingPrimes)\n        <> \" primes (< 5000) with decimal digits totalling 25:\\n\"\n    ) :\n    ( unwords\n        <$> chunksOf\n          4\n          (justifyRight w ' ' . show <$> matchingPrimes)\n    )\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef primesWithGivenDigitSum(below, n):\n    \n    return list(\n        takewhile(\n            lambda x: below > x,\n            (\n                x for x in primes()\n                if n == sum(int(c) for c in str(x))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n    matches = primesWithGivenDigitSum(5000, 25)\n    print(\n        str(len(matches)) + (\n            ' primes below 5000 with a decimal digit sum of 25:\\n'\n        )\n    )\n    print(\n        '\\n'.join([\n            ' '.join([str(x).rjust(4, ' ') for x in xs])\n            for xs in chunksOf(4)(matches)\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418602, "name": "Primes whose sum of digits is 25", "source": "Translate Haskell to Python: import Data.Bifunctor (second)\nimport Data.List (replicate)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primes)\n\n\n\nmatchingPrimes :: [Int]\nmatchingPrimes =\n  takeWhile\n    (< 5000)\n    [n | n <- primes, 25 == decimalDigitSum n]\n\ndecimalDigitSum :: Int -> Int\ndecimalDigitSum n =\n  snd $\n    until\n      ((0 ==) . fst)\n      (\\(n, x) -> second (+ x) $ quotRem n 10)\n      (n, 0)\n\n\nmain :: IO ()\nmain = do\n  let w = length (show (last matchingPrimes))\n  mapM_ putStrLn $\n    ( show (length matchingPrimes)\n        <> \" primes (< 5000) with decimal digits totalling 25:\\n\"\n    ) :\n    ( unwords\n        <$> chunksOf\n          4\n          (justifyRight w ' ' . show <$> matchingPrimes)\n    )\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef primesWithGivenDigitSum(below, n):\n    \n    return list(\n        takewhile(\n            lambda x: below > x,\n            (\n                x for x in primes()\n                if n == sum(int(c) for c in str(x))\n            )\n        )\n    )\n\n\n\n\ndef main():\n    \n    matches = primesWithGivenDigitSum(5000, 25)\n    print(\n        str(len(matches)) + (\n            ' primes below 5000 with a decimal digit sum of 25:\\n'\n        )\n    )\n    print(\n        '\\n'.join([\n            ' '.join([str(x).rjust(4, ' ') for x in xs])\n            for xs in chunksOf(4)(matches)\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418603, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\nimport Data.List (intercalate, transpose, unfoldr)\nimport Text.Printf\n\nprimeDigitsNumsSummingToN :: Int -> [Int]\nprimeDigitsNumsSummingToN n = concat $ unfoldr go (return <$> primeDigits)\n  where\n    primeDigits = [2, 3, 5, 7]\n    \n    go :: [[Int]] -> Maybe ([Int], [[Int]])\n    go xs\n      | null xs = Nothing\n      | otherwise = Just (nextLength xs)\n      \n    nextLength :: [[Int]] -> ([Int], [[Int]])\n    nextLength xs =\n      let harvest nv =\n            [ unDigits $ fst nv\n            | n == snd nv ]\n          prune nv =\n            [ fst nv\n            | pred n > snd nv ]\n      in ((,) . concatMap harvest <*> concatMap prune)\n           (((,) <*> sum) <$> ((<$> xs) . (<>) . return =<< primeDigits))\n\n\nmain :: IO ()\nmain = do\n  let n = 13\n      xs = primeDigitsNumsSummingToN n\n  mapM_\n    putStrLn\n    [ concat\n        [ (show . length) xs\n        , \" numbers with prime digits summing to \"\n        , show n\n        , \":\\n\"\n        ]\n    , table \" \" $ chunksOf 10 (show <$> xs)\n    ]\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ic = intercalate\n      ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip ic [\"%\", \"s\"] . show\n  in unlines $ ic gap . zipWith pw ws <$> rows\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n", "target": "from collections import deque\n\ndef prime_digits_sum(r):\n    q = deque([(r, 0)])\n    while q:\n        r, n = q.popleft()\n        for d in 2, 3, 5, 7:\n            if d >= r:\n                if d == r: yield n + d\n                break\n            q.append((r - d, (n + d) * 10))\n\nprint(*prime_digits_sum(13))\n"}
{"id": 418604, "name": "Numbers with prime digits whose sum is 13", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\nimport Data.List (intercalate, transpose, unfoldr)\nimport Text.Printf\n\nprimeDigitsNumsSummingToN :: Int -> [Int]\nprimeDigitsNumsSummingToN n = concat $ unfoldr go (return <$> primeDigits)\n  where\n    primeDigits = [2, 3, 5, 7]\n    \n    go :: [[Int]] -> Maybe ([Int], [[Int]])\n    go xs\n      | null xs = Nothing\n      | otherwise = Just (nextLength xs)\n      \n    nextLength :: [[Int]] -> ([Int], [[Int]])\n    nextLength xs =\n      let harvest nv =\n            [ unDigits $ fst nv\n            | n == snd nv ]\n          prune nv =\n            [ fst nv\n            | pred n > snd nv ]\n      in ((,) . concatMap harvest <*> concatMap prune)\n           (((,) <*> sum) <$> ((<$> xs) . (<>) . return =<< primeDigits))\n\n\nmain :: IO ()\nmain = do\n  let n = 13\n      xs = primeDigitsNumsSummingToN n\n  mapM_\n    putStrLn\n    [ concat\n        [ (show . length) xs\n        , \" numbers with prime digits summing to \"\n        , show n\n        , \":\\n\"\n        ]\n    , table \" \" $ chunksOf 10 (show <$> xs)\n    ]\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ic = intercalate\n      ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip ic [\"%\", \"s\"] . show\n  in unlines $ ic gap . zipWith pw ws <$> rows\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n", "target": "from collections import deque\n\ndef prime_digits_sum(r):\n    q = deque([(r, 0)])\n    while q:\n        r, n = q.popleft()\n        for d in 2, 3, 5, 7:\n            if d >= r:\n                if d == r: yield n + d\n                break\n            q.append((r - d, (n + d) * 10))\n\nprint(*prime_digits_sum(13))\n"}
{"id": 418605, "name": "Circular primes", "source": "Translate Haskell to Python: import Math.NumberTheory.Primes (Prime, unPrime, nextPrime)\nimport Math.NumberTheory.Primes.Testing (isPrime, millerRabinV)\nimport Text.Printf (printf)\n\nrotated :: [Integer] -> [Integer]\nrotated xs \n  | any (< head xs) xs = []\n  | otherwise          = map asNum $ take (pred $ length xs) $ rotate xs\n where\n  rotate [] = []\n  rotate (d:ds) = ds <> [d] : rotate (ds <> [d])\n\nasNum :: [Integer] -> Integer\nasNum [] = 0\nasNum n@(d:ds) \n | all (==1) n = read $ concatMap show n\n | otherwise = (d * (10 ^ length ds)) + asNum ds \n\ndigits :: Integer -> [Integer]\ndigits 0 = []\ndigits n = digits d <> [r]\n where (d, r) = n `quotRem` 10\n\nisCircular :: Bool -> Integer -> Bool\nisCircular repunit n \n  | repunit = millerRabinV 0 n\n  | n < 10 = True\n  | even n = False\n  | null rotations = False\n  | any (<n) rotations = False\n  | otherwise = all isPrime rotations\n where\n  rotations = rotated $ digits n\n\nrepunits :: [Integer]\nrepunits = go 2\n where go n = asNum (replicate n 1) : go (succ n)\n\nasRepunit :: Int -> Integer\nasRepunit n = asNum $ replicate n 1\n\nmain :: IO ()\nmain = do \n  printf \"The first 19 circular primes are:\\n%s\\n\\n\" $ circular primes\n  printf \"The next 4 circular primes, in repunit format are:\\n\" \n  mapM_ (printf \"R(%d) \") $ reps repunits\n  printf \"\\n\\nThe following repunits are probably circular primes:\\n\"\n  mapM_ (uncurry (printf \"R(%d)\u00a0: %s\\n\") . checkReps) [5003, 9887, 15073, 25031, 35317, 49081]\n where\n  primes = map unPrime [nextPrime 1..]\n  circular = show . take 19 . filter (isCircular False)\n  reps = map (sum . digits). tail . take 5 . filter (isCircular True)\n  checkReps = (,) <$> id <*> show . isCircular True . asRepunit\n", "target": "import random\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n\n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n\n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True\n\n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n\n    return True\n\ndef isPrime(n: int) -> bool:\n    \n    \n    if (n <= 1) :\n        return False\n    if (n <= 3) :\n        return True\n    \n    \n    if (n % 2 == 0 or n % 3 == 0) :\n        return False\n    i = 5\n    while(i * i <= n) :\n        if (n % i == 0 or n % (i + 2) == 0) :\n            return False\n        i = i + 6\n    return True\n\ndef rotations(n: int)-> set((int,)):\n    \n    a = str(n)\n    return set(int(a[i:] + a[:i]) for i in range(len(a)))\n\ndef isCircular(n: int) -> bool:\n    \n    return all(isPrime(int(o)) for o in rotations(n))\n\nfrom itertools import product\n\ndef main():\n    result = [2, 3, 5, 7]\n    first = '137'\n    latter = '1379'\n    for i in range(1, 6):\n        s = set(int(''.join(a)) for a in product(first, *((latter,) * i)))\n        while s:\n            a = s.pop()\n            b = rotations(a)\n            if isCircular(a):\n                result.append(min(b))\n            s -= b\n    result.sort()\n    return result\n\nassert [2, 3, 5, 7, 11, 13, 17, 37, 79, 113, 197, 199, 337, 1193, 3779, 11939, 19937, 193939, 199933] == main()\n\n\nrepunit = lambda n: int('1' * n)\n\ndef repmain(n: int) -> list:\n    \n    result = []\n    i = 2\n    while len(result) < n:\n        if is_Prime(repunit(i)):\n            result.append(i)\n        i += 1\n    return result\n\nassert [2, 19, 23, 317, 1031] == repmain(5)\n\n\n"}
{"id": 418606, "name": "Frobenius numbers", "source": "Translate Haskell to Python: primes = 2 : sieve [3,5..]\n  where sieve (x:xs) = x : sieve (filter (\\y -> y `mod` x /= 0) xs)\n\nfrobenius = zipWith (\\a b -> a*b - a - b) primes (tail primes)\n", "target": "\n\ndef isPrime(v):\n  if v <= 1:\n    return False\n  if v < 4:\n    return True\n  if v % 2 == 0:\n    return False\n  if v < 9:\n    return True\n  if v % 3 == 0:\n    return False\n  else:\n    r = round(pow(v,0.5))\n    f = 5\n    while f <= r:\n      if v % f == 0 or v % (f + 2) == 0:\n        return False\n      f += 6\n    return True\n\npn = 2\nn = 0\nfor i in range(3, 9999, 2):\n  if isPrime(i):\n    n += 1\n    f = (pn * i) - pn - i\n    if f > 10000:\n      break\n    print (n, ' => ', f)\n    pn = i\n"}
{"id": 418607, "name": "Frobenius numbers", "source": "Translate Haskell to Python: primes = 2 : sieve [3,5..]\n  where sieve (x:xs) = x : sieve (filter (\\y -> y `mod` x /= 0) xs)\n\nfrobenius = zipWith (\\a b -> a*b - a - b) primes (tail primes)\n", "target": "\n\ndef isPrime(v):\n  if v <= 1:\n    return False\n  if v < 4:\n    return True\n  if v % 2 == 0:\n    return False\n  if v < 9:\n    return True\n  if v % 3 == 0:\n    return False\n  else:\n    r = round(pow(v,0.5))\n    f = 5\n    while f <= r:\n      if v % f == 0 or v % (f + 2) == 0:\n        return False\n      f += 6\n    return True\n\npn = 2\nn = 0\nfor i in range(3, 9999, 2):\n  if isPrime(i):\n    n += 1\n    f = (pn * i) - pn - i\n    if f > 10000:\n      break\n    print (n, ' => ', f)\n    pn = i\n"}
{"id": 418608, "name": "Sorting algorithms_Permutation sort", "source": "Translate Haskell to Python: import Control.Monad\n\npermutationSort l = head [p | p <- permute l, sorted p]\n\nsorted (e1 : e2 : r) = e1 <= e2 && sorted (e2 : r)\nsorted _             = True\n\npermute              = foldM (flip insert) []\n\ninsert e []          = return [e]\ninsert e l@(h : t)   = return (e : l) `mplus`\n                       do { t' <- insert e t ; return (h : t') }\n", "target": "from itertools import permutations\n\nin_order = lambda s: all(x <= s[i+1] for i,x in enumerate(s[:-1]))\nperm_sort = lambda s: (p for p in permutations(s) if in_order(p)).next()\n"}
{"id": 418609, "name": "Integer roots", "source": "Translate Haskell to Python: root :: Integer -> Integer -> Integer\nroot a b = findAns $ iterate (\\x -> (a1 * x + b `div` (x ^ a1)) `div` a) 1\n  where\n    a1 = a - 1\n    findAns (x:xs@(y:z:_))\n      | x == y || x == z = min y z\n      | otherwise = findAns xs\n\nmain :: IO ()\nmain = do\n  print $ root 3 8\n  print $ root 3 9\n  print $ root 2 (2 * 100 ^ 2000) \n", "target": "def root(a, b):\n    if b < 2:\n        return b\n    a1 = a - 1\n    c = 1\n    d = (a1 * c + b // (c ** a1)) // a\n    e = (a1 * d + b // (d ** a1)) // a\n    while c not in (d, e):\n        c, d, e = d, e, (a1 * e + b // (e ** a1)) // a\n    return min(d, e)\n\n\nprint(\"First 2,001 digits of the square root of two:\\n{}\".format(\n    root(2, 2 * 100 ** 2000)\n))\n"}
{"id": 418610, "name": "Integer roots", "source": "Translate Haskell to Python: root :: Integer -> Integer -> Integer\nroot a b = findAns $ iterate (\\x -> (a1 * x + b `div` (x ^ a1)) `div` a) 1\n  where\n    a1 = a - 1\n    findAns (x:xs@(y:z:_))\n      | x == y || x == z = min y z\n      | otherwise = findAns xs\n\nmain :: IO ()\nmain = do\n  print $ root 3 8\n  print $ root 3 9\n  print $ root 2 (2 * 100 ^ 2000) \n", "target": "def root(a, b):\n    if b < 2:\n        return b\n    a1 = a - 1\n    c = 1\n    d = (a1 * c + b // (c ** a1)) // a\n    e = (a1 * d + b // (d ** a1)) // a\n    while c not in (d, e):\n        c, d, e = d, e, (a1 * e + b // (e ** a1)) // a\n    return min(d, e)\n\n\nprint(\"First 2,001 digits of the square root of two:\\n{}\".format(\n    root(2, 2 * 100 ** 2000)\n))\n"}
{"id": 418611, "name": "Fortunate numbers", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\nimport Math.NumberTheory.Primes.Testing (isPrime)\nimport Data.List (nub)\n\nprimorials :: [Integer]\nprimorials = 1 : scanl1 (*) primes\n\nnextPrime :: Integer -> Integer\nnextPrime n\n  | even n = head $ dropWhile (not . isPrime) [n+1, n+3..]\n  | even n = nextPrime (n+1)\n\nfortunateNumbers :: [Integer]\nfortunateNumbers = (\\p -> nextPrime (p + 2) - p) <$> tail primorials\n", "target": "from sympy.ntheory.generate import primorial\nfrom sympy.ntheory import isprime\n\ndef fortunate_number(n):\n    \n    \n    \n    i = 3\n    primorial_ = primorial(n)\n    while True:\n        if isprime(primorial_ + i):\n            return i\n        i += 2\n\nfortunate_numbers = set()\nfor i in range(1, 76):\n    fortunate_numbers.add(fortunate_number(i))\n\n\nfirst50 = sorted(list(fortunate_numbers))[:50]\n\nprint('The first 50 fortunate numbers:')\nprint(('{:<3} ' * 10).format(*(first50[:10])))\nprint(('{:<3} ' * 10).format(*(first50[10:20])))\nprint(('{:<3} ' * 10).format(*(first50[20:30])))\nprint(('{:<3} ' * 10).format(*(first50[30:40])))\nprint(('{:<3} ' * 10).format(*(first50[40:])))\n"}
{"id": 418612, "name": "Modulinos", "source": "Translate Haskell to Python: #!/usr/bin/env runhaskell\n\n\n\n\n\nmodule ScriptedMain where\n\nmeaningOfLife :: Int\nmeaningOfLife = 42\n\nmain :: IO ()\nmain = putStrLn $ \"Main: The meaning of life is \" ++ show meaningOfLife\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 418613, "name": "Modulinos", "source": "Translate Haskell to Python: #!/usr/bin/env runhaskell\n\n\n\n\n\nmodule ScriptedMain where\n\nmeaningOfLife :: Int\nmeaningOfLife = 42\n\nmain :: IO ()\nmain = putStrLn $ \"Main: The meaning of life is \" ++ show meaningOfLife\n", "target": "\n\n\n\ndef meaning_of_life():\n  return 42\n\nif __name__ == \"__main__\":\n  print(\"Main: The meaning of life is %s\" % meaning_of_life())\n"}
{"id": 418614, "name": "Function frequency", "source": "Translate Haskell to Python: import Language.Haskell.Parser (parseModule)\nimport Data.List.Split (splitOn)\nimport Data.List (nub, sortOn, elemIndices)\n\nfindApps src = freq $ concat [apps, comps]\n  where\n    ast = show $ parseModule src\n    apps = extract <$> splitApp ast\n    comps = extract <$> concat (splitComp <$> splitInfix ast)\n    splitApp = tail . splitOn \"(HsApp (HsVar (UnQual (HsIdent \\\"\" \n    splitInfix = tail . splitOn \"(HsInfixApp (HsVar (UnQual (HsIdent \\\"\"\n    splitComp = take 1 . splitOn \"(HsQVarOp (UnQual (HsSymbol \\\"\"\n    extract = takeWhile (/= '\\\"')\n    freq lst = [ (count x lst, x) | x <- nub lst ]\n    count x = length . elemIndices x\n\nmain = do\n  src <- readFile \"CountFunctions.hs\"\n  let res = sortOn (negate . fst) $ findApps src\n  mapM_ (\\(n, f) -> putStrLn $ show n ++ \"\\t\" ++ f) res\n", "target": "import ast\n\nclass CallCountingVisitor(ast.NodeVisitor):\n\n    def __init__(self):\n        self.calls = {}\n\n    def visit_Call(self, node):\n        if isinstance(node.func, ast.Name):\n            fun_name = node.func.id\n            call_count = self.calls.get(fun_name, 0)\n            self.calls[fun_name] = call_count + 1\n        self.generic_visit(node)\n\nfilename = input('Enter a filename to parse: ')\nwith open(filename, encoding='utf-8') as f:\n    contents = f.read()\nroot = ast.parse(contents, filename=filename) \nvisitor = CallCountingVisitor()\nvisitor.visit(root)\ntop10 = sorted(visitor.calls.items(), key=lambda x: x[1], reverse=True)[:10]\nfor name, count in top10:\n    print(name,'called',count,'times')\n"}
{"id": 418615, "name": "Nice primes", "source": "Translate Haskell to Python: import Data.Char ( digitToInt ) \n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ndigitsum :: Int -> Int\ndigitsum n = sum $ map digitToInt $ show n\n\nfindSumn :: Int -> Int\nfindSumn n = until ( (== 1) . length . show ) digitsum n\n\nisNicePrime :: Int -> Bool\nisNicePrime n = isPrime n && isPrime ( findSumn n ) \n\nsolution :: [Int]\nsolution = filter isNicePrime [501..999]\n", "target": "nicePrimes( s, e ) = { local( m );\n    forprime( p = s, e,\n        m = p;                      \\\\\n        while( m > 9,               \\\\   m == p mod 9\n            m = sumdigits( m ) );   \\\\\n        if( isprime( m ),\n            print1( p, \" \" ) ) ); \n}\n"}
{"id": 418616, "name": "Nice primes", "source": "Translate Haskell to Python: import Data.Char ( digitToInt ) \n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\ndigitsum :: Int -> Int\ndigitsum n = sum $ map digitToInt $ show n\n\nfindSumn :: Int -> Int\nfindSumn n = until ( (== 1) . length . show ) digitsum n\n\nisNicePrime :: Int -> Bool\nisNicePrime n = isPrime n && isPrime ( findSumn n ) \n\nsolution :: [Int]\nsolution = filter isNicePrime [501..999]\n", "target": "nicePrimes( s, e ) = { local( m );\n    forprime( p = s, e,\n        m = p;                      \\\\\n        while( m > 9,               \\\\   m == p mod 9\n            m = sumdigits( m ) );   \\\\\n        if( isprime( m ),\n            print1( p, \" \" ) ) ); \n}\n"}
{"id": 418617, "name": "Find the last Sunday of each month", "source": "Translate Haskell to Python: import Data.List (find, intercalate, transpose)\nimport Data.Maybe (fromJust)\nimport Data.Time.Calendar\n  ( Day,\n    addDays,\n    fromGregorian,\n    gregorianMonthLength,\n    showGregorian,\n  )\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\n\n\nlastSundayOfEachMonth = lastWeekDayDates 7\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    ( intercalate \"  \"\n        <$> transpose\n          (lastSundayOfEachMonth <$> [2013 .. 2017])\n    )\n\n\n\nlastWeekDayDates :: Int -> Integer -> [String]\nlastWeekDayDates dayOfWeek year =\n  (showGregorian . mostRecentWeekday dayOfWeek)\n    . (fromGregorian year <*> gregorianMonthLength year)\n    <$> [1 .. 12]\n\nmostRecentWeekday :: Int -> Day -> Day\nmostRecentWeekday dayOfWeek date =\n  fromJust\n    (find p ((`addDays` date) <$> [-6 .. 0]))\n  where\n    p x =\n      let (_, _, day) = toWeekDate x\n       in dayOfWeek == day\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 418618, "name": "Find the last Sunday of each month", "source": "Translate Haskell to Python: import Data.List (find, intercalate, transpose)\nimport Data.Maybe (fromJust)\nimport Data.Time.Calendar\n  ( Day,\n    addDays,\n    fromGregorian,\n    gregorianMonthLength,\n    showGregorian,\n  )\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\n\n\nlastSundayOfEachMonth = lastWeekDayDates 7\n\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    ( intercalate \"  \"\n        <$> transpose\n          (lastSundayOfEachMonth <$> [2013 .. 2017])\n    )\n\n\n\nlastWeekDayDates :: Int -> Integer -> [String]\nlastWeekDayDates dayOfWeek year =\n  (showGregorian . mostRecentWeekday dayOfWeek)\n    . (fromGregorian year <*> gregorianMonthLength year)\n    <$> [1 .. 12]\n\nmostRecentWeekday :: Int -> Day -> Day\nmostRecentWeekday dayOfWeek date =\n  fromJust\n    (find p ((`addDays` date) <$> [-6 .. 0]))\n  where\n    p x =\n      let (_, _, day) = toWeekDate x\n       in dayOfWeek == day\n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 418619, "name": "Random Latin squares", "source": "Translate Haskell to Python: import Data.List (permutations, (\\\\))\n\nlatinSquare :: Eq a => [a] -> [a] -> [[a]]\nlatinSquare [] [] = []\nlatinSquare c r\n  | head r /= head c = []\n  | otherwise = reverse <$> foldl addRow firstRow perms\n  where\n    \n    perms =\n      tail $\n        fmap\n          (fmap . (:) <*> (permutations . (r \\\\) . return))\n          c\n    firstRow = pure <$> r\n    addRow tbl rows =\n      head\n        [ zipWith (:) row tbl\n          | row <- rows,\n            and $ different (tail row) (tail tbl)\n        ]\n    different = zipWith $ (not .) . elem\n\nprintTable :: Show a => [[a]] -> IO ()\nprintTable tbl =\n  putStrLn $\n    unlines $\n      unwords . map show <$> tbl\n", "target": "from random import choice, shuffle\nfrom copy import deepcopy\n\ndef rls(n):\n    if n <= 0:\n        return []\n    else:\n        symbols = list(range(n))\n        square = _rls(symbols)\n        return _shuffle_transpose_shuffle(square)\n\n\ndef _shuffle_transpose_shuffle(matrix):\n    square = deepcopy(matrix)\n    shuffle(square)\n    trans = list(zip(*square))\n    shuffle(trans)\n    return trans\n\n\ndef _rls(symbols):\n    n = len(symbols)\n    if n == 1:\n        return [symbols]\n    else:\n        sym = choice(symbols)\n        symbols.remove(sym)\n        square = _rls(symbols)\n        square.append(square[0].copy())\n        for i in range(n):\n            square[i].insert(i, sym)\n        return square\n\ndef _to_text(square):\n    if square:\n        width = max(len(str(sym)) for row in square for sym in row)\n        txt = '\\n'.join(' '.join(f\"{sym:>{width}}\" for sym in row)\n                        for row in square)\n    else:\n        txt = ''\n    return txt\n\ndef _check(square):\n    transpose = list(zip(*square))\n    assert _check_rows(square) and _check_rows(transpose), \\\n        \"Not a Latin square\"\n\ndef _check_rows(square):\n    if not square:\n        return True\n    set_row0 = set(square[0])\n    return all(len(row) == len(set(row)) and set(row) == set_row0\n               for row in square)\n\n\nif __name__ == '__main__':\n    for i in [3, 3,  5, 5, 12]:\n        square = rls(i)\n        print(_to_text(square))\n        _check(square)\n        print()\n"}
{"id": 418620, "name": "Teacup rim text", "source": "Translate Haskell to Python: import Data.List (groupBy, intercalate, sort, sortBy)\nimport qualified Data.Set as S\nimport Data.Ord (comparing)\nimport Data.Function (on)\n\nmain :: IO ()\nmain =\n  readFile \"mitWords.txt\" >>= (putStrLn . showGroups . circularWords . lines)\n\ncircularWords :: [String] -> [String]\ncircularWords ws =\n  let lexicon = S.fromList ws\n  in filter (isCircular lexicon) ws\n\nisCircular :: S.Set String -> String -> Bool\nisCircular lex w = 2 < length w && all (`S.member` lex) (rotations w)\n\nrotations :: [a] -> [[a]]\nrotations = fmap <$> rotated <*> (enumFromTo 0 . pred . length)\n\nrotated :: [a] -> Int -> [a]\nrotated [] _ = []\nrotated xs n = zipWith const (drop n (cycle xs)) xs\n\nshowGroups :: [String] -> String\nshowGroups xs =\n  unlines $\n  intercalate \" -> \" . fmap snd <$>\n  filter\n    ((1 <) . length)\n    (groupBy (on (==) fst) (sortBy (comparing fst) (((,) =<< sort) <$> xs)))\n", "target": "\n\nfrom itertools import chain, groupby\nfrom os.path import expanduser\nfrom functools import reduce\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        concatMap(circularGroup)(\n            anagrams(3)(\n                \n                lines(readFile('~/mitWords.txt'))\n            )\n        )\n    ))\n\n\n\ndef anagrams(n):\n    \n    def go(ws):\n        def f(xs):\n            return [\n                [snd(x) for x in xs]\n            ] if n <= len(xs) >= len(xs[0][0]) else []\n        return concatMap(f)(groupBy(fst)(sorted(\n            [(''.join(sorted(w)), w) for w in ws],\n            key=fst\n        )))\n    return go\n\n\n\ndef circularGroup(ws):\n    \n    lex = set(ws)\n    iLast = len(ws) - 1\n    \n    \n    (i, blnCircular) = until(\n        lambda tpl: tpl[1] or (tpl[0] > iLast)\n    )(\n        lambda tpl: (1 + tpl[0], isCircular(lex)(ws[tpl[0]]))\n    )(\n        (0, False)\n    )\n    return [' -> '.join(allRotations(ws[i]))] if blnCircular else []\n\n\n\ndef isCircular(lexicon):\n    \n    def go(w):\n        def f(tpl):\n            (i, _, x) = tpl\n            return (1 + i, x in lexicon, rotated(x))\n\n        iLast = len(w) - 1\n        return until(\n            lambda tpl: iLast < tpl[0] or (not tpl[1])\n        )(f)(\n            (0, True, rotated(w))\n        )[1]\n    return go\n\n\n\ndef allRotations(w):\n    \n    return takeIterate(len(w) - 1)(\n        rotated\n    )(w)\n\n\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef fst(tpl):\n    \n    return tpl[0]\n\n\n\ndef groupBy(f):\n    \n    def go(xs):\n        return [\n            list(x[1]) for x in groupby(xs, key=f)\n        ]\n    return go\n\n\n\ndef lines(s):\n    \n    return s.splitlines()\n\n\n\ndef mapAccumL(f):\n    \n    def go(a, x):\n        tpl = f(a[0], x)\n        return (tpl[0], a[1] + [tpl[1]])\n    return lambda acc: lambda xs: (\n        reduce(go, xs, (acc, []))\n    )\n\n\n\ndef readFile(fp):\n    \n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n\ndef rotated(s):\n    \n    return s[1:] + s[0]\n\n\n\ndef snd(tpl):\n    \n    return tpl[1]\n\n\n\ndef takeIterate(n):\n    \n    def go(f):\n        def g(x):\n            def h(a, i):\n                v = f(a) if i else x\n                return (v, v)\n            return mapAccumL(h)(x)(\n                range(0, 1 + n)\n            )[1]\n        return g\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418621, "name": "Fairshare between two and more", "source": "Translate Haskell to Python: import Data.Bool (bool)\nimport Data.List (intercalate, unfoldr)\nimport Data.Tuple (swap)\n\n\n\nthueMorse :: Int -> [Int]\nthueMorse base = baseDigitsSumModBase base <$> [0 ..]\n\nbaseDigitsSumModBase :: Int -> Int -> Int\nbaseDigitsSumModBase base n =\n  mod\n    ( sum $\n        unfoldr\n          ( bool Nothing\n              . Just\n              . swap\n              . flip quotRem base\n              <*> (0 <)\n          )\n          n\n    )\n    base\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    fTable\n      ( \"First 25 fairshare terms \"\n          <> \"for a given number of players:\\n\"\n      )\n      show\n      ( ('[' :) . (<> \"]\") . intercalate \",\"\n          . fmap show\n      )\n      (take 25 . thueMorse)\n      [2, 3, 5, 11]\n\n\nfTable ::\n  String ->\n  (a -> String) ->\n  (b -> String) ->\n  (a -> b) ->\n  [a] ->\n  String\nfTable s xShow fxShow f xs =\n  unlines $\n    s :\n    fmap\n      ( ((<>) . justifyRight w ' ' . xShow)\n          <*> ((\" -> \" <>) . fxShow . f)\n      )\n      xs\n  where\n    w = maximum (length . xShow <$> xs)\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "from itertools import count, islice\n\ndef _basechange_int(num, b):\n    \n    if num == 0:\n        return [0]\n    result = []\n    while num != 0:\n        num, d = divmod(num, b)\n        result.append(d)\n    return result[::-1]\n\ndef fairshare(b=2):\n    for i in count():\n        yield sum(_basechange_int(i, b)) % b\n\nif __name__ == '__main__':\n    for b in (2, 3, 5, 11):\n        print(f\"{b:>2}: {str(list(islice(fairshare(b), 25)))[1:-1]}\")\n"}
{"id": 418622, "name": "Esthetic numbers", "source": "Translate Haskell to Python: import Data.List (unfoldr, genericIndex)\nimport Control.Monad (replicateM, foldM, mzero)\n\n\nisEsthetic b = all ((== 1) . abs) . differences . toBase b\n  where\n    differences lst = zipWith (-) lst (tail lst)\n\n\nesthetics_m b =\n  do differences <- (\\n -> replicateM n [-1, 1]) <$> [0..]\n     firstDigit <- [1..b-1]\n     differences >>= fromBase b <$> scanl (+) firstDigit\n\n\n\nesthetics b = tail $ fst <$> iterate step (undefined, q)\n  where\n    q = [(d, d) | d <- [1..b-1]]\n    step (_, queue) =\n      let (num, lsd) = head queue\n          new_lsds = [d | d <- [lsd-1, lsd+1], d < b, d >= 0]\n      in (num, tail queue ++ [(num*b + d, d) | d <- new_lsds])\n\n\nfromBase b = foldM f 0\n  where f r d | d < 0 || d >= b = mzero\n              | otherwise = pure (r*b + d)\n\ntoBase b = reverse . unfoldr f\n  where\n    f 0 = Nothing\n    f n = let (q, r) = divMod n b in Just (r, q)\n\nshowInBase b = foldMap (pure . digit) . toBase b\n  where digit = genericIndex (['0'..'9'] <> ['a'..'z'])\n", "target": "from collections import deque\nfrom itertools import dropwhile, islice, takewhile\nfrom textwrap import wrap\nfrom typing import Iterable, Iterator\n\n\nDigits = str  \n\n\ndef esthetic_nums(base: int) -> Iterator[int]:\n    \n    queue: deque[tuple[int, int]] = deque()\n    queue.extendleft((d, d) for d in range(1, base))\n    while True:\n        num, lsd = queue.pop()\n        yield num\n        new_lsds = (d for d in (lsd - 1, lsd + 1) if 0 <= d < base)\n        num *= base  \n        queue.extendleft((num + d, d) for d in new_lsds)\n\n\ndef to_digits(num: int, base: int) -> Digits:\n    \n    digits: list[str] = []\n    while num:\n        num, d = divmod(num, base)\n        digits.append(\"0123456789abcdef\"[d])\n    return \"\".join(reversed(digits)) if digits else \"0\"\n\n\ndef pprint_it(it: Iterable[str], indent: int = 4, width: int = 80) -> None:\n    \n    joined = \", \".join(it)\n    lines = wrap(joined, width=width - indent)\n    for line in lines:\n        print(f\"{indent*' '}{line}\")\n    print()\n\n\ndef task_2() -> None:\n    nums: Iterator[int]\n    for base in range(2, 16 + 1):\n        start, stop = 4 * base, 6 * base\n        nums = esthetic_nums(base)\n        nums = islice(nums, start - 1, stop)  \n        print(\n            f\"Base-{base} esthetic numbers from \"\n            f\"index {start} through index {stop} inclusive:\\n\"\n        )\n        pprint_it(to_digits(num, base) for num in nums)\n\n\ndef task_3(lower: int, upper: int, base: int = 10) -> None:\n    nums: Iterator[int] = esthetic_nums(base)\n    nums = dropwhile(lambda num: num < lower, nums)\n    nums = takewhile(lambda num: num <= upper, nums)\n    print(\n        f\"Base-{base} esthetic numbers with \"\n        f\"magnitude between {lower:,} and {upper:,}:\\n\"\n    )\n    pprint_it(to_digits(num, base) for num in nums)\n\n\nif __name__ == \"__main__\":\n    print(\"======\\nTask 2\\n======\\n\")\n    task_2()\n\n    print(\"======\\nTask 3\\n======\\n\")\n    task_3(1_000, 9_999)\n\n    print(\"======\\nTask 4\\n======\\n\")\n    task_3(100_000_000, 130_000_000)\n"}
{"id": 418623, "name": "Permutations by swapping", "source": "Translate Haskell to Python: sPermutations :: [a] -> [([a], Int)]\nsPermutations = flip zip (cycle [-1, 1]) . foldr aux [[]]\n  where\n    aux x items = do\n      (f, item) <- zip (repeat id) items\n      f (insertEv x item)\n    insertEv x [] = [[x]]\n    insertEv x l@(y:ys) = (x : l) : ((y :) <$> insertEv x ys)\n\nmain :: IO ()\nmain = do\n  putStrLn \"3 items:\"\n  mapM_ print $ sPermutations [1 .. 3]\n  putStrLn \"\\n4 items:\"\n  mapM_ print $ sPermutations [1 .. 4]\n", "target": "from operator import itemgetter\n \nDEBUG = False \n \ndef spermutations(n):\n    \n    sign = 1\n    p = [[i, 0 if i == 0 else -1] \n         for i in range(n)]\n \n    if DEBUG: print ' \n    yield tuple(pp[0] for pp in p), sign\n \n    while any(pp[1] for pp in p): \n        i1, (n1, d1) = max(((i, pp) for i, pp in enumerate(p) if pp[1]),\n                           key=itemgetter(1))\n        sign *= -1\n        if d1 == -1:\n            \n            i2 = i1 - 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == 0 or p[i2 - 1][0] > n1:\n                \n                p[i2][1] = 0\n        elif d1 == 1:\n            \n            i2 = i1 + 1\n            p[i1], p[i2] = p[i2], p[i1]\n            \n            \n            \n            if i2 == n - 1 or p[i2 + 1][0] > n1:\n                \n                p[i2][1] = 0\n        if DEBUG: print ' \n        yield tuple(pp[0] for pp in p), sign\n \n        for i3, pp in enumerate(p):\n            n3, d3 = pp\n            if n3 > n1:\n                pp[1] = 1 if i3 < i2 else -1\n                if DEBUG: print ' \n \n \nif __name__ == '__main__':\n    from itertools import permutations\n \n    for n in (3, 4):\n        print '\\nPermutations and sign of %i items' % n\n        sp = set()\n        for i in spermutations(n):\n            sp.add(i[0])\n            print('Perm: %r Sign: %2i' % i)\n            \n        \n        p = set(permutations(range(n)))\n        assert sp == p, 'Two methods of generating permutations do not agree'\n"}
{"id": 418624, "name": "RPG attributes generator", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\nimport System.Random (randomRIO)\nimport Data.Bool (bool)\nimport Data.List (sort)\n\ncharacter :: IO [Int]\ncharacter =\n  discardUntil\n    (((&&) . (75 <) . sum) <*> ((2 <=) . length . filter (15 <=)))\n    (replicateM 6 $ sum . tail . sort <$> replicateM 4 (randomRIO (1, 6 :: Int)))\n\ndiscardUntil :: ([Int] -> Bool) -> IO [Int] -> IO [Int]\ndiscardUntil p throw = go\n  where\n    go = throw >>= (<*>) (bool go . return) p\n\n\nmain :: IO ()\nmain = replicateM 10 character >>= mapM_ (print . (sum >>= (,)))\n", "target": "import random\nrandom.seed()\nattributes_total = 0\ncount = 0\n\nwhile attributes_total < 75 or count < 2:\n    attributes = []\n\n    for attribute in range(0, 6):\n        rolls = []\n        \n        for roll in range(0, 4):\n            result = random.randint(1, 6)\n            rolls.append(result)\n        \n        sorted_rolls = sorted(rolls)\n        largest_3 = sorted_rolls[1:]\n        rolls_total = sum(largest_3)\n        \n        if rolls_total >= 15:\n            count += 1\n        \n        attributes.append(rolls_total)\n\n    attributes_total = sum(attributes)\n    \nprint(attributes_total, attributes)\n"}
{"id": 418625, "name": "Kolakoski sequence", "source": "Translate Haskell to Python: import Data.List (group)\nimport Control.Monad (forM_)\n\nreplicateAtLeastOne :: Int -> a -> [a]\nreplicateAtLeastOne n x = x : replicate (n-1) x\n\nzipWithLazy :: (a -> b -> c) -> [a] -> [b] -> [c]\nzipWithLazy f ~(x:xs) ~(y:ys) = f x y : zipWithLazy f xs ys\n\nkolakoski :: [Int] -> [Int]\nkolakoski items = s\n  where s = concat $ zipWithLazy replicateAtLeastOne s $ cycle items\n\nrle :: Eq a => [a] -> [Int]\nrle = map length . group\n\nsameAsRleUpTo :: Int -> [Int] -> Bool\nsameAsRleUpTo n s = r == take (length r) prefix\n  where prefix = take n s\n        r = init $ rle prefix\n\nmain :: IO ()\nmain = forM_ [([1, 2], 20),\n              ([2, 1], 20), \n              ([1, 3, 1, 2], 30),\n              ([1, 3, 2, 1], 30)]\n        $ \\(items, n) -> do\n          putStrLn $ \"First \" ++ show n ++ \" members of the sequence generated by \" ++ show items ++ \":\"\n          let s = kolakoski items\n          print $ take n s\n          putStrLn $ \"Possible Kolakoski sequence? \" ++ show (sameAsRleUpTo n s)\n          putStrLn \"\"\n", "target": "import itertools\n\ndef cycler(start_items):\n\treturn itertools.cycle(start_items).__next__\n\ndef _kolakoski_gen(start_items):\n    s, k = [], 0\n    c = cycler(start_items)\n    while True:\n        c_next = c()\n        s.append(c_next)\n        sk = s[k]\n        yield sk\n        if sk > 1:\n            s += [c_next] * (sk - 1)\n        k += 1\n\ndef kolakoski(start_items=(1, 2), length=20):\n    return list(itertools.islice(_kolakoski_gen(start_items), length))\n\ndef _run_len_encoding(truncated_series):\n    return [len(list(group)) for grouper, group in itertools.groupby(truncated_series)][:-1]\n\ndef is_series_eq_its_rle(series):\n    rle = _run_len_encoding(series)\n    return (series[:len(rle)] == rle) if rle else not series\n\nif __name__ == '__main__':\n    for start_items, length in [((1, 2), 20), ((2, 1), 20), \n                                ((1, 3, 1, 2), 30), ((1, 3, 2, 1), 30)]:\n        print(f'\\n\n        s = kolakoski(start_items, length)\n        print(f'  {s}')\n        ans = 'YES' if is_series_eq_its_rle(s) else 'NO'\n        print(f'  Does it look like a Kolakoski sequence: {ans}')\n"}
{"id": 418626, "name": "Sequence_ smallest number with exactly n divisors", "source": "Translate Haskell to Python: import Data.List (find, group, sort)\nimport Data.Maybe (mapMaybe)\nimport Data.Numbers.Primes (primeFactors)\n\n\n\na005179 :: [Int]\na005179 =\n  mapMaybe\n    ( \\n ->\n        find\n          ((n ==) . succ . length . properDivisors)\n          [1 ..]\n    )\n    [1 ..]\n\n\nmain :: IO ()\nmain = print $ take 15 a005179\n\n\n\nproperDivisors :: Int -> [Int]\nproperDivisors =\n  init\n    . sort\n    . foldr\n      (flip ((<*>) . fmap (*)) . scanl (*) 1)\n      [1]\n    . group\n    . primeFactors\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef sequence(max_n=None):\n    n = 0\n    while True:\n        n += 1\n        ii = 0\n        if max_n is not None:\n            if n > max_n:\n                break\n        while True:\n            ii += 1\n            if len(divisors(ii)) == n:\n                yield ii\n                break\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 418627, "name": "Sparkline in unicode", "source": "Translate Haskell to Python: import Data.List.Split (splitOneOf)\nimport Data.Char (chr)\n\n\ntoSparkLine :: [Double] -> String\ntoSparkLine xs = map cl xs\n  where\n    top = maximum xs\n    bot = minimum xs\n    range = top - bot\n    cl x = chr $ 0x2581 + floor (min 7 ((x - bot) / range * 8))\n\nmakeSparkLine :: String -> (String, Stats)\nmakeSparkLine xs = (toSparkLine parsed, stats parsed)\n  where\n    parsed = map read $ filter (not . null) $ splitOneOf \" ,\" xs\n\ndata Stats = Stats\n  { minValue, maxValue, rangeOfValues :: Double\n  , numberOfValues :: Int\n  }\n\ninstance Show Stats where\n  show (Stats mn mx r n) =\n    \"min: \" ++\n    show mn ++\n    \"; max: \" ++\n    show mx ++ \"; range: \" ++ show r ++ \"; no. of values: \" ++ show n\n\nstats :: [Double] -> Stats\nstats xs =\n  Stats\n  { minValue = mn\n  , maxValue = mx\n  , rangeOfValues = mx - mn\n  , numberOfValues = length xs\n  }\n  where\n    mn = minimum xs\n    mx = maximum xs\n\ndrawSparkLineWithStats :: String -> IO ()\ndrawSparkLineWithStats xs = putStrLn sp >> print st\n  where\n    (sp, st) = makeSparkLine xs\n\nmain :: IO ()\nmain =\n  mapM_\n    drawSparkLineWithStats\n    [ \"0, 1, 19, 20\"\n    , \"0, 999, 4000, 4999, 7000, 7999\"\n    , \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1\"\n    , \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5\"\n    , \"3 2 1 0 -1 -2 -3 -4 -3 -2 -1 0 1 2 3\"\n    , \"-1000 100 1000 500 200 -400 -700 621 -189 3\"\n    ]\n", "target": "\n\n\nbar = '\u2581\u2582\u2583\u2584\u2585\u2586\u2587\u2588'\nbarcount = len(bar)\n\ndef sparkline(numbers):\n    mn, mx = min(numbers), max(numbers)\n    extent = mx - mn\n    sparkline = ''.join(bar[min([barcount - 1,\n                                 int((n - mn) / extent * barcount)])]\n                        for n in numbers)\n    return mn, mx, sparkline\n\nif __name__ == '__main__':\n    import re\n    \n    for line in (\"0 0 1 1; 0 1 19 20; 0 999 4000 4999 7000 7999;\"\n                 \"1 2 3 4 5 6 7 8 7 6 5 4 3 2 1;\"\n                 \"1.5, 0.5 3.5, 2.5 5.5, 4.5 7.5, 6.5 \").split(';'):\n        print(\"\\nNumbers:\", line)\n        numbers = [float(n) for n in re.split(r'[\\s,]+', line.strip())]\n        mn, mx, sp = sparkline(numbers)\n        print('  min: %5f; max: %5f' % (mn, mx))\n        print(\"  \" + sp)\n"}
{"id": 418628, "name": "Levenshtein distance_Alignment", "source": "Translate Haskell to Python: costs :: String -> String -> [[Int]]\ncosts s1 s2 = reverse $ reverse <$> matrix\n  where\n    matrix = scanl transform [0 .. length s1] s2\n    transform ns@(n:ns1) c = scanl calc (n + 1) $ zip3 s1 ns ns1\n      where\n        calc z (c1, x, y) = minimum [ y + 1, z + 1\n                                    , x + fromEnum (c1 /= c)]\n\nlevenshteinDistance :: String -> String -> Int\nlevenshteinDistance s1 s2 = head.head $ costs s1 s2\n", "target": "from difflib import ndiff\n\ndef levenshtein(str1, str2):\n    result = \"\"\n    pos, removed = 0, 0\n    for x in ndiff(str1, str2):\n        if pos<len(str1) and str1[pos] == x[2]:\n          pos += 1\n          result += x[2]\n          if x[0] == \"-\":\n              removed += 1\n          continue\n        else:\n          if removed > 0:\n            removed -=1\n          else:\n            result += \"-\"\n    print(result)\n\nlevenshtein(\"place\",\"palace\")\nlevenshtein(\"rosettacode\",\"raisethysword\")\n"}
{"id": 418629, "name": "Longest increasing subsequence", "source": "Translate Haskell to Python: import Data.Ord          ( comparing )\nimport Data.List         ( maximumBy, subsequences )\nimport Data.List.Ordered ( isSorted, nub )\n\nlis :: Ord a => [a] -> [a]\nlis = maximumBy (comparing length) . map nub  . filter isSorted . subsequences                 \n\n\nmain = do\n  print $ lis [3,2,6,4,5,1]\n  print $ lis [0,8,4,12,2,10,6,14,1,9,5,13,3,11,7,15]\n  print $ lis [1,1,1,1]\n", "target": "def longest_increasing_subsequence(X):\n    \n    N = len(X)\n    P = [0] * N\n    M = [0] * (N+1)\n    L = 0\n    for i in range(N):\n       lo = 1\n       hi = L\n       while lo <= hi:\n           mid = (lo+hi)//2\n           if (X[M[mid]] < X[i]):\n               lo = mid+1\n           else:\n               hi = mid-1\n    \n       newL = lo\n       P[i] = M[newL-1]\n       M[newL] = i\n    \n       if (newL > L):\n           L = newL\n    \n    S = []\n    k = M[L]\n    for i in range(L-1, -1, -1):\n        S.append(X[k])\n        k = P[k]\n    return S[::-1]\n\nif __name__ == '__main__':\n    for d in [[3,2,6,4,5,1], [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]]:\n        print('a L.I.S. of %s is %s' % (d, longest_increasing_subsequence(d)))\n"}
{"id": 418630, "name": "Odd and square numbers", "source": "Translate Haskell to Python: main :: IO ()\nmain = print $ takeWhile (<1000) $ filter odd $ map (^2) $ [10..]\n", "target": "import math\nszamok=[]\nlimit = 1000\n\nfor i in range(1,int(math.ceil(math.sqrt(limit))),2):\n    num = i*i\n    if (num < 1000 and num > 99):\n        szamok.append(num)\n\nprint(szamok)\n"}
{"id": 418631, "name": "Sum of square and cube digits of an integer are primes", "source": "Translate Haskell to Python: import Data.Bifunctor (first)\nimport Data.Numbers.Primes (isPrime)\n\n\n\np :: Int -> Bool\np =\n  ((&&) . primeDigitSum . (^ 2))\n    <*> (primeDigitSum . (^ 3))\n\n\nmain :: IO ()\nmain = print $ filter p [2 .. 99]\n\n\nprimeDigitSum :: Int -> Bool\nprimeDigitSum = isPrime . digitSum 10\n\ndigitSum :: Int -> Int -> Int\ndigitSum base = go\n  where\n    go 0 = 0\n    go n = uncurry (+) . first go $ quotRem n base\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\ndef digSum(n, b):\n    s = 0\n    while n:\n        s += (n % b)\n        n = n // b\n    return s\n\nif __name__ == '__main__':\n    for n in range(11, 99):\n        if isPrime(digSum(n**3, 10)) and isPrime(digSum(n**2, 10)):\n            print(n, end = \"  \")\n"}
{"id": 418632, "name": "Dynamic variable names", "source": "Translate Haskell to Python: data Var a = Var String a deriving Show\nmain = do\n    putStrLn \"please enter you variable name\"\n    vName <- getLine\n    let var = Var vName 42\n    putStrLn $ \"this is your variable: \" ++ show var\n", "target": ">>> name = raw_input(\"Enter a variable name: \")\nEnter a variable name: X\n>>> globals()[name] = 42\n>>> X\n42\n"}
{"id": 418633, "name": "Brilliant numbers", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf, splitWhen)\nimport Data.Numbers.Primes (primeFactors)\nimport Text.Printf (printf)\n\n\n\nisBrilliant :: (Integral a, Show a) => a -> Bool\nisBrilliant n = case primeFactors n of\n  [a, b] -> length (show a) == length (show b)\n  _ -> False\n\n\nmain :: IO ()\nmain = do\n  let indexedBrilliants =\n        zip\n          [1 ..]\n          (filter isBrilliant [1 ..])\n\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . snd\n          <$> take 100 indexedBrilliants\n\n  putStrLn \"(index, brilliant)\"\n  mapM_ print $\n    take 6 $\n      fmap (fst . head) $\n        splitWhen\n          (uncurry (<) . join bimap (length . show . snd))\n          $ zip indexedBrilliants (tail indexedBrilliants)\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 418634, "name": "Brilliant numbers", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf, splitWhen)\nimport Data.Numbers.Primes (primeFactors)\nimport Text.Printf (printf)\n\n\n\nisBrilliant :: (Integral a, Show a) => a -> Bool\nisBrilliant n = case primeFactors n of\n  [a, b] -> length (show a) == length (show b)\n  _ -> False\n\n\nmain :: IO ()\nmain = do\n  let indexedBrilliants =\n        zip\n          [1 ..]\n          (filter isBrilliant [1 ..])\n\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . snd\n          <$> take 100 indexedBrilliants\n\n  putStrLn \"(index, brilliant)\"\n  mapM_ print $\n    take 6 $\n      fmap (fst . head) $\n        splitWhen\n          (uncurry (<) . join bimap (length . show . snd))\n          $ zip indexedBrilliants (tail indexedBrilliants)\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "from primesieve.numpy import primes\nfrom math import isqrt\nimport numpy as np\n\nmax_order = 9\nblocks = [primes(10**n, 10**(n + 1)) for n in range(max_order)]\n\ndef smallest_brilliant(lb):\n    pos = 1\n    root = isqrt(lb)\n\n    for blk in blocks:\n        n = len(blk)\n        if blk[-1]*blk[-1] < lb:\n            pos += n*(n + 1)//2\n            continue\n\n        i = np.searchsorted(blk, root, 'left')\n        i += blk[i]*blk[i] < lb\n\n        if not i:\n            return blk[0]*blk[0], pos\n\n        p = blk[:i + 1]\n        q = (lb - 1)//p\n        idx = np.searchsorted(blk, q, 'right')\n\n        sel = idx < n\n        p, idx = p[sel], idx[sel]\n        q = blk[idx]\n\n        sel = q >= p\n        p, q, idx = p[sel], q[sel], idx[sel]\n\n        pos += np.sum(idx - np.arange(len(idx)))\n        return np.min(p*q), pos\n\nres = []\np = 0\nfor i in range(100):\n    p, _ = smallest_brilliant(p + 1)\n    res.append(p)\n\nprint(f'first 100 are {res}')\n\nfor i in range(max_order*2):\n    thresh = 10**i\n    p, pos = smallest_brilliant(thresh)\n    print(f'Above 10^{i:2d}: {p:20d} at \n"}
{"id": 418635, "name": "Calkin-Wilf sequence", "source": "Translate Haskell to Python: import Control.Monad (forM_)\nimport Data.Bool (bool)\nimport Data.List.NonEmpty (NonEmpty, fromList, toList, unfoldr)\nimport Text.Printf (printf)\n\n\ncalkinWilfs :: [Rational]\ncalkinWilfs = iterate (recip . succ . ((-) =<< (2 *) . fromIntegral . floor)) 1\n\n\n\ncalkinWilfIdx :: Rational -> Integer\ncalkinWilfIdx = rld . cfo\n\n\n\ncfo :: Rational -> NonEmpty Int\ncfo = oddLen . cf\n\n\n\ncf :: Rational -> NonEmpty Int\ncf = unfoldr step\n  where\n    step r =\n      case properFraction r of\n        (n, 1) -> (succ n, Nothing)\n        (n, 0) -> (n, Nothing)\n        (n, f) -> (n, Just (recip f))\n\n\noddLen :: NonEmpty Int -> NonEmpty Int\noddLen = fromList . go . toList\n  where\n    go [x, y] = [x, pred y, 1]\n    go (x:y:zs) = x : y : go zs\n    go xs = xs\n\n\nrld :: NonEmpty Int -> Integer\nrld = snd . foldr step (True, 0)\n  where\n    step i (b, n) =\n      let p = 2 ^ i\n      in (not b, n * p + bool 0 (pred p) b)\n\nmain :: IO ()\nmain = do\n  forM_ (take 20 $ zip [1 :: Int ..] calkinWilfs) $\n    \\(i, r) -> printf \"%2d  %s\\n\" i (show r)\n  let r = 83116 / 51639\n  printf\n    \"\\n%s is at index %d of the Calkin-Wilf sequence.\\n\"\n    (show r)\n    (calkinWilfIdx r)\n", "target": "from fractions import Fraction\nfrom math import floor\nfrom itertools import islice, groupby\n\n\ndef cw():\n    a = Fraction(1)\n    while True:\n        yield a\n        a = 1 / (2 * floor(a) + 1 - a)\n\ndef r2cf(rational):\n    num, den = rational.numerator, rational.denominator\n    while den:\n        num, (digit, den) = den, divmod(num, den)\n        yield digit\n\ndef get_term_num(rational):\n    ans, dig, pwr = 0, 1, 0\n    for n in r2cf(rational):\n        for _ in range(n):\n            ans |= dig << pwr\n            pwr += 1\n        dig ^= 1\n    return ans\n\n          \nif __name__ == '__main__':\n    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))\n    x = Fraction(83116, 51639)\n    print(f\"\\n{x} is the {get_term_num(x):_}'th term.\")\n"}
{"id": 418636, "name": "Calkin-Wilf sequence", "source": "Translate Haskell to Python: import Control.Monad (forM_)\nimport Data.Bool (bool)\nimport Data.List.NonEmpty (NonEmpty, fromList, toList, unfoldr)\nimport Text.Printf (printf)\n\n\ncalkinWilfs :: [Rational]\ncalkinWilfs = iterate (recip . succ . ((-) =<< (2 *) . fromIntegral . floor)) 1\n\n\n\ncalkinWilfIdx :: Rational -> Integer\ncalkinWilfIdx = rld . cfo\n\n\n\ncfo :: Rational -> NonEmpty Int\ncfo = oddLen . cf\n\n\n\ncf :: Rational -> NonEmpty Int\ncf = unfoldr step\n  where\n    step r =\n      case properFraction r of\n        (n, 1) -> (succ n, Nothing)\n        (n, 0) -> (n, Nothing)\n        (n, f) -> (n, Just (recip f))\n\n\noddLen :: NonEmpty Int -> NonEmpty Int\noddLen = fromList . go . toList\n  where\n    go [x, y] = [x, pred y, 1]\n    go (x:y:zs) = x : y : go zs\n    go xs = xs\n\n\nrld :: NonEmpty Int -> Integer\nrld = snd . foldr step (True, 0)\n  where\n    step i (b, n) =\n      let p = 2 ^ i\n      in (not b, n * p + bool 0 (pred p) b)\n\nmain :: IO ()\nmain = do\n  forM_ (take 20 $ zip [1 :: Int ..] calkinWilfs) $\n    \\(i, r) -> printf \"%2d  %s\\n\" i (show r)\n  let r = 83116 / 51639\n  printf\n    \"\\n%s is at index %d of the Calkin-Wilf sequence.\\n\"\n    (show r)\n    (calkinWilfIdx r)\n", "target": "from fractions import Fraction\nfrom math import floor\nfrom itertools import islice, groupby\n\n\ndef cw():\n    a = Fraction(1)\n    while True:\n        yield a\n        a = 1 / (2 * floor(a) + 1 - a)\n\ndef r2cf(rational):\n    num, den = rational.numerator, rational.denominator\n    while den:\n        num, (digit, den) = den, divmod(num, den)\n        yield digit\n\ndef get_term_num(rational):\n    ans, dig, pwr = 0, 1, 0\n    for n in r2cf(rational):\n        for _ in range(n):\n            ans |= dig << pwr\n            pwr += 1\n        dig ^= 1\n    return ans\n\n          \nif __name__ == '__main__':\n    print('TERMS 1..20: ', ', '.join(str(x) for x in islice(cw(), 20)))\n    x = Fraction(83116, 51639)\n    print(f\"\\n{x} is the {get_term_num(x):_}'th term.\")\n"}
{"id": 418637, "name": "Order disjoint list items", "source": "Translate Haskell to Python: import Data.List (mapAccumL, sort)\n\norder\n  :: Ord a\n  => [[a]] -> [a]\norder [ms, ns] = snd . mapAccumL yu ls $ ks\n  where\n    ks = zip ms [(0 :: Int) ..]\n    ls = zip ns . sort . snd . foldl go (sort ns, []) . sort $ ks\n    yu ((u, v):us) (_, y)\n      | v == y = (us, u)\n    yu ys (x, _) = (ys, x)\n    go (u:us, ys) (x, y)\n      | u == x = (us, y : ys)\n    go ts _ = ts\n\ntask :: [String] -> IO ()\ntask ls@[ms, ns] =\n  putStrLn $\n  \"M: \" ++ ms ++ \" | N: \" ++ ns ++ \" |> \" ++ (unwords . order . map words $ ls)\n\nmain :: IO ()\nmain =\n  mapM_\n    task\n    [ [\"the cat sat on the mat\", \"mat cat\"]\n    , [\"the cat sat on the mat\", \"cat mat\"]\n    , [\"A B C A B C A B C\", \"C A C A\"]\n    , [\"A B C A B D A B E\", \"E A D A\"]\n    , [\"A B\", \"B\"]\n    , [\"A B\", \"B A\"]\n    , [\"A B B A\", \"B A\"]\n    ]\n", "target": "from __future__ import print_function\n\ndef order_disjoint_list_items(data, items):\n    \n    itemindices = []\n    for item in set(items):\n        itemcount = items.count(item)\n        \n        lastindex = [-1]\n        for i in range(itemcount):\n            lastindex.append(data.index(item, lastindex[-1] + 1))\n        itemindices += lastindex[1:]\n    itemindices.sort()\n    for index, item in zip(itemindices, items):\n        data[index] = item\n\nif __name__ == '__main__':\n    tostring = ' '.join\n    for data, items in [ (str.split('the cat sat on the mat'), str.split('mat cat')),\n                         (str.split('the cat sat on the mat'), str.split('cat mat')),\n                         (list('ABCABCABC'), list('CACA')),\n                         (list('ABCABDABE'), list('EADA')),\n                         (list('AB'), list('B')),\n                         (list('AB'), list('BA')),\n                         (list('ABBA'), list('BA')),\n                         (list(''), list('')),\n                         (list('A'), list('A')),\n                         (list('AB'), list('')),\n                         (list('ABBA'), list('AB')),\n                         (list('ABAB'), list('AB')),\n                         (list('ABAB'), list('BABA')),\n                         (list('ABCCBA'), list('ACAC')),\n                         (list('ABCCBA'), list('CACA')),\n                       ]:\n        print('Data M: %-24r Order N: %-9r' % (tostring(data), tostring(items)), end=' ')\n        order_disjoint_list_items(data, items)\n        print(\"-> M' %r\" % tostring(data))\n"}
{"id": 418638, "name": "Palindromic primes", "source": "Translate Haskell to Python: import Data.Numbers.Primes\n\npalindromicPrimes :: [Integer]\npalindromicPrimes =\n  filter (((==) <*> reverse) . show) primes\n\nmain :: IO ()\nmain =\n  mapM_ print $\n    takeWhile\n      (1000 >)\n      palindromicPrimes\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef palindromicPrimes():\n    \n    def p(n):\n        s = str(n)\n        return s == s[::-1]\n    return (n for n in primes() if p(n))\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        str(x) for x in takewhile(\n            lambda n: 1000 > n,\n            palindromicPrimes()\n        )\n    ))\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418639, "name": "Palindromic primes", "source": "Translate Haskell to Python: import Data.Numbers.Primes\n\npalindromicPrimes :: [Integer]\npalindromicPrimes =\n  filter (((==) <*> reverse) . show) primes\n\nmain :: IO ()\nmain =\n  mapM_ print $\n    takeWhile\n      (1000 >)\n      palindromicPrimes\n", "target": "\n\nfrom itertools import takewhile\n\n\n\ndef palindromicPrimes():\n    \n    def p(n):\n        s = str(n)\n        return s == s[::-1]\n    return (n for n in primes() if p(n))\n\n\n\ndef main():\n    \n    print('\\n'.join(\n        str(x) for x in takewhile(\n            lambda n: 1000 > n,\n            palindromicPrimes()\n        )\n    ))\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418640, "name": "Sylvester's sequence", "source": "Translate Haskell to Python: sylvester :: [Integer]\nsylvester = map s [0 ..]\n  where\n    s 0 = 2\n    s n = succ $ foldr ((*) . s) 1 [0 .. pred n]\n\nmain :: IO ()\nmain = do\n  putStrLn \"First 10 elements of Sylvester's sequence:\"\n  putStr $ unlines $ map show $ take 10 sylvester\n\n  putStr \"\\nSum of reciprocals by sum over map: \"\n  print $ sum $ map ((1 /) . fromInteger) $ take 10 sylvester\n\n  putStr \"Sum of reciprocals by fold: \"\n  print $ foldr ((+) . (1 /) . fromInteger) 0 $ take 10 sylvester\n", "target": "\n\nfrom functools import reduce\nfrom itertools import count, islice\n\n\n\ndef sylvester():\n    \n    def go(n):\n        return 1 + reduce(\n            lambda a, x: a * go(x),\n            range(0, n),\n            1\n        ) if 0 != n else 2\n\n    return map(go, count(0))\n\n\n\n\ndef main():\n    \n\n    print(\"First 10 terms of OEIS A000058:\")\n    xs = list(islice(sylvester(), 10))\n    print('\\n'.join([\n        str(x) for x in xs\n    ]))\n\n    print(\"\\nSum of the reciprocals of the first 10 terms:\")\n    print(\n        reduce(lambda a, x: a + 1 / x, xs, 0)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418641, "name": "Harmonic series", "source": "Translate Haskell to Python: import Data.List (find)\nimport Data.Ratio\n\n\n\nharmonic :: [Rational]\nharmonic =\n  scanl1\n    (\\a x -> a + 1 / x)\n    [1 ..]\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"First 20 terms:\"\n  mapM_ putStrLn $\n    showRatio <$> take 20 harmonic\n\n  putStrLn \"\\n100th term:\"\n  putStrLn $ showRatio (harmonic !! 99)\n  putStrLn \"\"\n\n  putStrLn \"One-based indices of first terms above threshold values:\"\n  let indexedHarmonic = zip [0 ..] harmonic\n  mapM_\n    putStrLn\n    $ fmap\n      ( showFirstLimit\n          <*> \\n -> find ((> n) . snd) indexedHarmonic\n      )\n      [1 .. 10]\n\n\n\nshowFirstLimit n (Just (i, r)) =\n  \"Term \"\n    <> show (succ i)\n    <> \" is the first above \"\n    <> show (numerator n)\n\nshowRatio :: Ratio Integer -> String\nshowRatio =\n  ((<>) . show . numerator)\n    <*> (('/' :) . show . denominator)\n", "target": "from  fractions import Fraction\n\ndef harmonic_series():\n    n, h = Fraction(1), Fraction(1)\n    while True:\n        yield h\n        h += 1 / (n + 1)\n        n += 1\n\nif __name__ == '__main__':\n    from itertools import islice\n    for n, d in (h.as_integer_ratio() for h in islice(harmonic_series(), 20)):\n        print(n, '/', d)\n"}
{"id": 418642, "name": "Interactive programming (repl)", "source": "Translate Haskell to Python: $ ghci\n   ___         ___ _\n  / _ \\ /\\  /\\/ __(_)\n / /_\\// /_/ / /  | |      GHC Interactive, version 6.4.2, for Haskell 98.\n/ /_\\\\/ __  / /___| |      http://www.haskell.org/ghc/\n\\____/\\/ /_/\\____/|_|      Type :? for help.\n\nLoading package base-1.0 ... linking ... done.\nPrelude> let f as bs sep = as ++ sep ++ sep ++ bs\nPrelude> f \"Rosetta\" \"Code\" \":\"\n\"Rosetta::Code\"\n", "target": "python\nPython 2.6.1 (r261:67517, Dec  4 2008, 16:51:00) [MSC v.1500 32 bit (Intel)] on\nwin32\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> def f(string1, string2, separator):\n\treturn separator.join([string1, '', string2])\n\n>>> f('Rosetta', 'Code', ':')\n'Rosetta::Code'\n>>>\n"}
{"id": 418643, "name": "Reverse the gender of a string", "source": "Translate Haskell to Python: id\n", "target": "\n\n \nimport re\nmale2female=u\n \nre_nl=re.compile(r\",[ \\n]*\")\nm2f=[ tok.split(\" \") for tok in re_nl.split(male2female) ]\n \nswitch={}\nwords=[]\n \n \nre_plural=re.compile(\"E*S$\")\nre_ES=re.compile(\"ES$\")\n \ndef gen_pluralize(m,f):\n\n  yield re_plural.sub(\"\",m),re_plural.sub(\"\",f)\n  yield re_ES.sub(\"es\",m),re_ES.sub(\"es\",f)\n  yield re_plural.sub(\"s\",m),re_plural.sub(\"s\",f)\n \ndef gen_capitalize_pluralize(m,f):\n  for m,f in gen_pluralize(m,f):\n    yield m.capitalize(), f.capitalize()\n    yield m,f\n \ndef gen_switch_role_capitalize_pluralize(m,f):\n  for m,f in gen_capitalize_pluralize(m,f):\n    yield m,f\n    yield f,m\n \nfor m,f in m2f:\n  for xy,xx in gen_switch_role_capitalize_pluralize(m,f):\n    if xy not in switch: \n      switch[xy]=xx\n      words.append(xy)\n \nwords=\"|\".join(words)\n \nre_word=re.compile(ur\"\\b(\"+words+ur\")\\b\")\n \ntext=u\n \n \ndef rev_gender(text):\n  text=re_word.split(text)\n  return \"\".join([ word+switch[gen] for word,gen in zip(text[::2],text[1::2])])+text[-1]\n \nprint rev_gender(text)\n"}
{"id": 418644, "name": "Reverse the gender of a string", "source": "Translate Haskell to Python: id\n", "target": "\n\n \nimport re\nmale2female=u\n \nre_nl=re.compile(r\",[ \\n]*\")\nm2f=[ tok.split(\" \") for tok in re_nl.split(male2female) ]\n \nswitch={}\nwords=[]\n \n \nre_plural=re.compile(\"E*S$\")\nre_ES=re.compile(\"ES$\")\n \ndef gen_pluralize(m,f):\n\n  yield re_plural.sub(\"\",m),re_plural.sub(\"\",f)\n  yield re_ES.sub(\"es\",m),re_ES.sub(\"es\",f)\n  yield re_plural.sub(\"s\",m),re_plural.sub(\"s\",f)\n \ndef gen_capitalize_pluralize(m,f):\n  for m,f in gen_pluralize(m,f):\n    yield m.capitalize(), f.capitalize()\n    yield m,f\n \ndef gen_switch_role_capitalize_pluralize(m,f):\n  for m,f in gen_capitalize_pluralize(m,f):\n    yield m,f\n    yield f,m\n \nfor m,f in m2f:\n  for xy,xx in gen_switch_role_capitalize_pluralize(m,f):\n    if xy not in switch: \n      switch[xy]=xx\n      words.append(xy)\n \nwords=\"|\".join(words)\n \nre_word=re.compile(ur\"\\b(\"+words+ur\")\\b\")\n \ntext=u\n \n \ndef rev_gender(text):\n  text=re_word.split(text)\n  return \"\".join([ word+switch[gen] for word,gen in zip(text[::2],text[1::2])])+text[-1]\n \nprint rev_gender(text)\n"}
{"id": 418645, "name": "Index finite lists of positive integers", "source": "Translate Haskell to Python: import Data.List\n\ntoBase :: Int -> Integer -> [Int]\ntoBase b = unfoldr f\n  where\n    f 0 = Nothing\n    f n = let (q, r) = n `divMod` fromIntegral b in Just (fromIntegral r, q)\n\nfromBase :: Int -> [Int] -> Integer\nfromBase n lst = foldr (\\x r -> fromIntegral n*r + fromIntegral x) 0 lst\n\n\n               \nlistToInt :: Int -> [Int] -> Integer\nlistToInt b lst = fromBase (b+1) $ concat seq\n  where\n    seq = [ let (q, r) = divMod n b\n            in replicate q 0 ++ [r+1]\n          | n <- lst ]\n\nintToList :: Int -> Integer -> [Int]\nintToList b lst = go 0 $ toBase (b+1) lst\n  where\n    go 0 [] = []\n    go i (0:xs) = go (i+1) xs\n    go i (x:xs) = (i*b + x - 1) : go 0 xs\n", "target": "def rank(x): return int('a'.join(map(str, [1] + x)), 11)\n\ndef unrank(n):\n\ts = ''\n\twhile n: s,n = \"0123456789a\"[n%11] + s, n//11\n\treturn map(int, s.split('a'))[1:]\n\nl = [1, 2, 3, 10, 100, 987654321]\nprint l\nn = rank(l)\nprint n\nl = unrank(n)\nprint l\n"}
{"id": 418646, "name": "Generate random numbers without repeating a value", "source": "Translate Haskell to Python: import Data.List (sortBy)\nimport Data.Ord (comparing)\nimport System.Random (newStdGen, randomRs)\n\n\n\ninRandomOrder :: [a] -> IO [a]\ninRandomOrder xs =\n  fmap fst . sortBy (comparing snd) . zip xs\n    <$> (randomRs (0, 1) <$> newStdGen :: IO [Double])\n\n\nmain :: IO ()\nmain =\n  inRandomOrder [1 .. 20]\n    >>= print\n", "target": "import random\n\nprint(random.sample(range(1, 21), 20))\n"}
{"id": 418647, "name": "Cyclops numbers", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\nimport Data.Numbers.Primes (isPrime)\n\n\n\ncyclops :: [Integer]\ncyclops = [0 ..] >>= go\n  where\n    go 0 = [0]\n    go n =\n      (\\s -> read s :: Integer)\n        <$> (fmap ((<>) . (<> \"0\")) >>= (<*>))\n          (replicateM n ['1' .. '9'])\n\nblindPrime :: Integer -> Bool\nblindPrime n =\n  let s = show n\n      m = quot (length s) 2\n   in isPrime $\n        (\\t -> read t :: Integer)\n          (take m s <> drop (succ m) s)\n\npalindromic :: Integer -> Bool\npalindromic = ((==) =<< reverse) . show\n\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines)\n    [ \"First 50 Cyclops numbers \u2013 A134808:\",\n      unwords (show <$> take 50 cyclops),\n      \"\",\n      \"First 50 Cyclops primes \u2013 A134809:\",\n      unwords $ take 50 [show n | n <- cyclops, isPrime n],\n      \"\",\n      \"First 50 blind prime Cyclops numbers \u2013 A329737:\",\n      unwords $\n        take\n          50\n          [show n | n <- cyclops, isPrime n, blindPrime n],\n      \"\",\n      \"First 50 prime palindromic cyclops numbers \u2013 A136098:\",\n      unwords $\n        take\n          50\n          [show n | n <- cyclops, isPrime n, palindromic n]\n    ]\n", "target": "from sympy import isprime\n\n\ndef print50(a, width=8):\n    for i, n in enumerate(a):\n        print(f'{n: {width},}', end='\\n' if (i + 1) % 10 == 0 else '')\n\n\ndef generate_cyclops(maxdig=9):\n    yield 0\n    for d in range((maxdig + 1) // 2):\n        arr = [str(i) for i in range(10**d, 10**(d+1)) if not('0' in str(i))]\n        for left in arr:\n            for right in arr:\n                yield int(left + '0' + right)\n\n\ndef generate_prime_cyclops():\n    for c in generate_cyclops():\n        if isprime(c):\n            yield c\n\n\ndef generate_blind_prime_cyclops():\n    for c in generate_prime_cyclops():\n        cstr = str(c)\n        mid = len(cstr) // 2\n        if isprime(int(cstr[:mid] + cstr[mid+1:])):\n            yield c\n\n\ndef generate_palindromic_cyclops(maxdig=9):\n    for d in range((maxdig + 1) // 2):\n        arr = [str(i) for i in range(10**d, 10**(d+1)) if not('0' in str(i))]\n        for s in arr:\n            yield int(s + '0' + s[::-1])\n\n\ndef generate_palindromic_prime_cyclops():\n    for c in generate_palindromic_cyclops():\n        if isprime(c):\n            yield c\n\n\nprint('The first 50 cyclops numbers are:')\ngen = generate_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 prime cyclops numbers are:')\ngen = generate_prime_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next prime cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 blind prime cyclops numbers are:')\ngen = generate_blind_prime_cyclops()\nprint50([next(gen) for _ in range(50)])\nfor i, c in enumerate(generate_blind_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next blind prime cyclops number after 10,000,000 is {c} at position {i:,}.')\n        break\n\nprint('\\nThe first 50 palindromic prime cyclops numbers are:')\ngen = generate_palindromic_prime_cyclops()\nprint50([next(gen) for _ in range(50)], 11)\nfor i, c in enumerate(generate_palindromic_prime_cyclops()):\n    if c > 10000000:\n        print(\n            f'\\nThe next palindromic prime cyclops number after 10,000,000 is {c} at position {i}.')\n        break\n"}
{"id": 418648, "name": "Prime numbers which contain 123", "source": "Translate Haskell to Python: import Data.List ( isInfixOf )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n   \ncondition :: Int -> Bool\ncondition n = isPrime n && isInfixOf \"123\" ( show n )\n\nsolution :: [Int]\nsolution = filter condition [2..99999]\n", "target": "\n\ndef prime(limite, mostrar):\n    global columna\n    columna = 0\n    \n    for n in range(limite):\n        strn = str(n)\n        if isPrime(n) and ('123' in str(n)):\n            columna += 1                \n            if mostrar == True:\n                print(n, end=\"  \");\n                if columna % 8 == 0:\n                    print('')\n    return columna\n\n\nif __name__ == \"__main__\":\n    print(\"N\u00fameros primos que contienen 123:\")\n    limite = 100000\n    prime(limite, True)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n    limite = 1000000\n    prime(limite, False)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n"}
{"id": 418649, "name": "Prime numbers which contain 123", "source": "Translate Haskell to Python: import Data.List ( isInfixOf )\n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n   \ncondition :: Int -> Bool\ncondition n = isPrime n && isInfixOf \"123\" ( show n )\n\nsolution :: [Int]\nsolution = filter condition [2..99999]\n", "target": "\n\ndef prime(limite, mostrar):\n    global columna\n    columna = 0\n    \n    for n in range(limite):\n        strn = str(n)\n        if isPrime(n) and ('123' in str(n)):\n            columna += 1                \n            if mostrar == True:\n                print(n, end=\"  \");\n                if columna % 8 == 0:\n                    print('')\n    return columna\n\n\nif __name__ == \"__main__\":\n    print(\"N\u00fameros primos que contienen 123:\")\n    limite = 100000\n    prime(limite, True)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n    limite = 1000000\n    prime(limite, False)\n    print(\"\\n\\nEncontrados \", columna, \" n\u00fameros primos por debajo de\", limite)\n"}
{"id": 418650, "name": "Neighbour primes", "source": "Translate Haskell to Python: import Data.List.Split ( divvy ) \n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n   \nsolution :: [Int]\nsolution = map head $ filter (\\li -> isPrime ((head li * last li) + 2 ))\n $ divvy 2 1 $ filter isPrime [2..upTo]\n where\n  upTo :: Int\n  upTo = head $ take 1 $ filter isPrime [500..]\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    print(\"p        q       pq+2\")\n    print(\"-----------------------\")\n    for p in range(2, 499):\n        if not isPrime(p):\n            continue\n        q = p + 1\n        while not isPrime(q):\n            q += 1\n        if not isPrime(2 + p*q):\n            continue \n        print(p, \"\\t\", q, \"\\t\", 2+p*q)\n"}
{"id": 418651, "name": "Neighbour primes", "source": "Translate Haskell to Python: import Data.List.Split ( divvy ) \n\nisPrime :: Int -> Bool\nisPrime n \n   |n < 2 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n   \nsolution :: [Int]\nsolution = map head $ filter (\\li -> isPrime ((head li * last li) + 2 ))\n $ divvy 2 1 $ filter isPrime [2..upTo]\n where\n  upTo :: Int\n  upTo = head $ take 1 $ filter isPrime [500..]\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\n\nif __name__ == '__main__':\n    print(\"p        q       pq+2\")\n    print(\"-----------------------\")\n    for p in range(2, 499):\n        if not isPrime(p):\n            continue\n        q = p + 1\n        while not isPrime(q):\n            q += 1\n        if not isPrime(2 + p*q):\n            continue \n        print(p, \"\\t\", q, \"\\t\", 2+p*q)\n"}
{"id": 418652, "name": "Collect and sort square numbers in ascending order from three lists", "source": "Translate Haskell to Python: import Data.List (sort)\n\n\n\nsquaresSorted :: Integral a => [[a]] -> [a]\nsquaresSorted = sort . (filter isPerfectSquare =<<)\n\nisPerfectSquare :: Integral a => a -> Bool\nisPerfectSquare n =\n  let sqr = (floor . sqrt) (fromIntegral n :: Double)\n   in n == sqr ^ 2\n\n\nmain :: IO ()\nmain =\n  print $\n  squaresSorted\n    [ [3, 4, 34, 25, 9, 12, 36, 56, 36]\n    , [2, 8, 81, 169, 34, 55, 76, 49, 7]\n    , [75, 121, 75, 144, 35, 16, 46, 35]\n    ]\n", "target": "import math\n\nprint(\"working...\")\nlist = [(3,4,34,25,9,12,36,56,36),(2,8,81,169,34,55,76,49,7),(75,121,75,144,35,16,46,35)]\nSquares = []\n\ndef issquare(x):\n\tfor p in range(x):\n\t\tif x == p*p:\n\t\t\treturn 1\nfor n in range(3):\n\tfor m in range(len(list[n])):\n\t\tif issquare(list[n][m]):\n\t\t\tSquares.append(list[n][m])\n\nSquares.sort()\nprint(Squares)\nprint(\"done...\")\n"}
{"id": 418653, "name": "Collect and sort square numbers in ascending order from three lists", "source": "Translate Haskell to Python: import Data.List (sort)\n\n\n\nsquaresSorted :: Integral a => [[a]] -> [a]\nsquaresSorted = sort . (filter isPerfectSquare =<<)\n\nisPerfectSquare :: Integral a => a -> Bool\nisPerfectSquare n =\n  let sqr = (floor . sqrt) (fromIntegral n :: Double)\n   in n == sqr ^ 2\n\n\nmain :: IO ()\nmain =\n  print $\n  squaresSorted\n    [ [3, 4, 34, 25, 9, 12, 36, 56, 36]\n    , [2, 8, 81, 169, 34, 55, 76, 49, 7]\n    , [75, 121, 75, 144, 35, 16, 46, 35]\n    ]\n", "target": "import math\n\nprint(\"working...\")\nlist = [(3,4,34,25,9,12,36,56,36),(2,8,81,169,34,55,76,49,7),(75,121,75,144,35,16,46,35)]\nSquares = []\n\ndef issquare(x):\n\tfor p in range(x):\n\t\tif x == p*p:\n\t\t\treturn 1\nfor n in range(3):\n\tfor m in range(len(list[n])):\n\t\tif issquare(list[n][m]):\n\t\t\tSquares.append(list[n][m])\n\nSquares.sort()\nprint(Squares)\nprint(\"done...\")\n"}
{"id": 418654, "name": "Comments", "source": "Translate Haskell to Python: i code = True \n\n\n   let u x = x x (this code not compiled)\n   Are you? -}\n\n\ni code = True\n\n\n\ni code = True\n", "target": "\n\nvar x = 0 \n\nvar y = 0 \n\n\nThere are also multi-line comments\nEverything inside of \n]\n\n\n\ndiscard \n"}
{"id": 418655, "name": "Cullen and Woodall numbers", "source": "Translate Haskell to Python: findCullen :: Int -> Integer\nfindCullen n = toInteger ( n * 2 ^ n + 1 )\n\ncullens :: [Integer]\ncullens = map findCullen [1 .. 20]\n\nwoodalls :: [Integer]\nwoodalls = map (\\i -> i - 2 ) cullens\n\nmain :: IO ( )\nmain = do\n   putStrLn \"First 20 Cullen numbers:\"\n   print cullens\n   putStrLn \"First 20 Woodall numbers:\"\n   print woodalls\n", "target": "print(\"working...\")\nprint(\"First 20 Cullen numbers:\")\n\nfor n in range(1,21):\n    num = n*pow(2,n)+1\n    print(str(num),end= \" \")\n\nprint()\nprint(\"First 20 Woodall numbers:\")\n\nfor n in range(1,21):\n    num = n*pow(2,n)-1\n    print(str(num),end=\" \")\n\nprint()\nprint(\"done...\")\n"}
{"id": 418656, "name": "Long literals, with continuations", "source": "Translate Haskell to Python: elements = words \"hydrogen \\ \n\\   fluorine     neon          sodium       magnesium     \\\n\\   aluminum     silicon       phosphorous  sulfur        \\\n\\   chlorine     argon         potassium    calcium       \\\n\\   scandium     titanium      vanadium     chromium      \\\n\\   manganese    iron          cobalt       nickel        \\\n\\   copper       zinc          gallium      germanium     \\\n\\   arsenic      selenium      bromine      krypton       \\\n\\   rubidium     strontium     yttrium      zirconium     \\\n\\   niobium      molybdenum    technetium   ruthenium     \\\n\\   rhodium      palladium     silver       cadmium       \\\n\\   indium       tin           antimony     tellurium     \\\n\\   iodine       xenon         cesium       barium        \\\n\\   lanthanum    cerium        praseodymium neodymium     \\\n\\   promethium   samarium      europium     gadolinium    \\\n\\   terbium      dysprosium    holmium      erbium        \\\n\\   thulium      ytterbium     lutetium     hafnium       \\\n\\   tantalum     tungsten      rhenium      osmium        \\\n\\   iridium      platinum      gold         mercury       \\\n\\   thallium     lead          bismuth      polonium      \\\n\\   astatine     radon         francium     radium        \\\n\\   actinium     thorium       protactinium uranium       \\\n\\   neptunium    plutonium     americium    curium        \\\n\\   berkelium    californium   einsteinium  fermium       \\\n\\   mendelevium  nobelium      lawrencium   rutherfordium \\\n\\   dubnium      seaborgium    bohrium      hassium       \\\n\\   meitnerium   darmstadtium  roentgenium  copernicium   \\\n\\   nihonium     flerovium     moscovium    livermorium   \\\n\\   tennessine   oganesson\"\n", "target": "\n\nrevision = \"October 13th 2020\"\n\n\n\n\nelements = (\n    \"hydrogen helium lithium beryllium boron carbon nitrogen oxygen fluorine \"\n    \"neon sodium magnesium aluminum silicon phosphorous sulfur chlorine argon \"\n    \"potassium calcium scandium titanium vanadium chromium manganese iron \"\n    \"cobalt nickel copper zinc gallium germanium arsenic selenium bromine \"\n    \"krypton rubidium strontium yttrium zirconium niobium molybdenum \"\n    \"technetium ruthenium rhodium palladium silver cadmium indium tin \"\n    \"antimony tellurium iodine xenon cesium barium lanthanum cerium \"\n    \"praseodymium neodymium promethium samarium europium gadolinium terbium \"\n    \"dysprosium holmium erbium thulium ytterbium lutetium hafnium tantalum \"\n    \"tungsten rhenium osmium iridium platinum gold mercury thallium lead \"\n    \"bismuth polonium astatine radon francium radium actinium thorium \"\n    \"protactinium uranium neptunium plutonium americium curium berkelium \"\n    \"californium einsteinium fermium mendelevium nobelium lawrencium \"\n    \"rutherfordium dubnium seaborgium bohrium hassium meitnerium darmstadtium \"\n    \"roentgenium copernicium nihonium flerovium moscovium livermorium \"\n    \"tennessine oganesson\"\n)\n\n\ndef report():\n    \n    items = elements.split()\n\n    print(f\"Last revision date: {revision}\")\n    print(f\"Number of elements: {len(items)}\")\n    print(f\"Last element     \u00a0: {items[-1]}\")\n\n\nif __name__ == \"__main__\":\n    report()\n"}
{"id": 418657, "name": "Find minimum number of coins that make a given value", "source": "Translate Haskell to Python: import Data.List (mapAccumL)\nimport Data.Tuple (swap)\n\n\n\nchange :: [Int] -> Int -> [(Int, Int)]\nchange xs n = zip (snd $ mapAccumL go n xs) xs\n  where\n    go m v = swap (quotRem m v)\n\n\n\nmain :: IO ()\nmain =\n  mapM_ print $\n    change [200, 100, 50, 20, 10, 5, 2, 1] 988\n", "target": "def makechange(denominations = [1,2,5,10,20,50,100,200], total = 988):\n    print(f\"Available denominations: {denominations}. Total is to be: {total}.\")\n    coins, remaining = sorted(denominations, reverse=True), total\n    for n in range(len(coins)):\n        coinsused, remaining = divmod(remaining, coins[n])\n        if coinsused > 0:\n            print(\"   \", coinsused, \"*\", coins[n])\n\nmakechange()\n"}
{"id": 418658, "name": "Longest palindromic substrings", "source": "Translate Haskell to Python: \n\nlongestPalindromes :: String -> ([String], Int)\nlongestPalindromes [] = ([], 0)\nlongestPalindromes s = go $ palindromes s\n  where\n    go xs\n      | null xs = (return <$> s, 1)\n      | otherwise = (filter ((w ==) . length) xs, w)\n      where\n        w = maximum $ length <$> xs\n\npalindromes :: String -> [String]\npalindromes = fmap go . palindromicNuclei\n  where\n    go (pivot, (xs, ys)) =\n      let suffix = fmap fst (takeWhile (uncurry (==)) (zip xs ys))\n      in reverse suffix <> pivot <> suffix\n\npalindromicNuclei :: String -> [(String, (String, String))]\npalindromicNuclei =\n  concatMap go .\n  init . tail . ((zip . scanl (flip ((<>) . return)) []) <*> scanr (:) [])\n  where\n    go (a@(x:_), b@(h:y:ys))\n      | x == h = [(\"\", (a, b))]\n      | otherwise =\n        [ ([h], (a, y : ys))\n        | x == y ]\n    go _ = []\n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n  fTable\n    \"Longest palindromic substrings:\\n\"\n    show\n    show\n    longestPalindromes\n    [ \"three old rotators\"\n    , \"never reverse\"\n    , \"stable was I ere I saw elbatrosses\"\n    , \"abracadabra\"\n    , \"drome\"\n    , \"the abbatial palace\"\n    , \"\"\n    ]\n\n\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  unlines $\n  s : fmap (((++) . rjust w ' ' . xShow) <*> ((\" -> \" ++) . fxShow . f)) xs\n  where\n    rjust n c = drop . length <*> (replicate n c ++)\n    w = maximum (length . xShow <$> xs)\n", "target": "\n\n\n\ndef longestPalindromes(s):\n    \n    k = s.lower()\n    palindromes = [\n        palExpansion(k)(ab) for ab\n        in palindromicNuclei(k)\n    ]\n    maxLength = max([\n        len(x) for x in palindromes\n    ]) if palindromes else 1\n    return (\n        [\n            x for x in palindromes if maxLength == len(x)\n        ] if palindromes else list(s),\n        maxLength\n    ) if s else ([], 0)\n\n\n\ndef palindromicNuclei(s):\n    \n    cs = list(s)\n    return [\n        \n        (i, 1 + i) for (i, (a, b))\n        in enumerate(zip(cs, cs[1:]))\n        if a == b\n    ] + [\n        \n        (i, 2 + i) for (i, (a, b, c))\n        in enumerate(zip(cs, cs[1:], cs[2:]))\n        if a == c\n    ]\n\n\n\ndef palExpansion(s):\n    \n    iEnd = len(s) - 1\n\n    def limit(ij):\n        i, j = ij\n        return 0 == i or iEnd == j or s[i-1] != s[j+1]\n\n    def expansion(ij):\n        i, j = ij\n        return (i - 1, 1 + j)\n\n    def go(ij):\n        ab = until(limit)(expansion)(ij)\n        return s[ab[0]:ab[1] + 1]\n    return go\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(repr)(\n            longestPalindromes\n        )([\n            'three old rotators',\n            'never reverse',\n            'stable was I ere I saw elbatrosses',\n            'abracadabra',\n            'drome',\n            'the abbatial palace',\n            ''\n        ])\n    )\n\n\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\n\n\n\ndef fTable(s):\n    \n    def gox(xShow):\n        def gofx(fxShow):\n            def gof(f):\n                def goxs(xs):\n                    ys = [xShow(x) for x in xs]\n                    w = max(map(len, ys))\n\n                    def arrowed(x, y):\n                        return y.rjust(w, ' ') + ' -> ' + (\n                            fxShow(f(x))\n                        )\n                    return s + '\\n' + '\\n'.join(\n                        map(arrowed, xs, ys)\n                    )\n                return goxs\n            return gof\n        return gofx\n    return gox\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418659, "name": "Read a file character by character_UTF8", "source": "Translate Haskell to Python: #!/usr/bin/env runhaskell\n\n\n\nimport System.Environment (getArgs)\nimport System.IO (\n        Handle, IOMode (..),\n        hGetChar, hIsEOF, hSetEncoding, stdin, utf8, withFile\n    )\nimport Control.Monad (forM_, unless)\nimport Text.Printf (printf)\nimport Data.Char (ord)\n\nprocessCharacters :: Handle -> IO ()\nprocessCharacters h = do\n  done <- hIsEOF h\n  unless done $ do\n    c <- hGetChar h\n    putStrLn $ printf \"U+%04X\" (ord c)\n    processCharacters h\n\nprocessOneFile :: Handle -> IO ()\nprocessOneFile h = do\n  hSetEncoding h utf8\n  processCharacters h\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    [] -> processOneFile stdin\n    xs -> forM_ xs $ \\name -> do\n      putStrLn name\n      withFile name ReadMode processOneFile\n", "target": "def get_next_character(f):\n  \n  c = f.read(1)\n  while c:\n    while True:\n      try:\n        yield c.decode('utf-8')\n      except UnicodeDecodeError:\n        \n        \n        c += f.read(1)\n      else:\n        \n        c = f.read(1)\n        break\n\n\nwith open(\"input.txt\",\"rb\") as f:\n    for c in get_next_character(f):\n        print(c)\n"}
{"id": 418660, "name": "Galton box animation", "source": "Translate Haskell to Python: import Data.Map hiding (map, filter)\nimport Graphics.Gloss\nimport Control.Monad.Random\n\ndata Ball = Ball { position :: (Int, Int), turns :: [Int] }\n\ntype World = ( Int           \n             , [Ball]        \n             , Map Int Int ) \n\nupdateWorld :: World -> World\nupdateWorld (nRows, balls, bins)\n  | y < -nRows-5  = (nRows, map update bs, bins <+> x)\n  | otherwise     = (nRows, map update balls, bins)\n  where\n    (Ball (x,y) _) : bs = balls\n\n    b <+> x = unionWith (+) b (singleton x 1)\n\n    update (Ball (x,y) turns)\n      | -nRows <= y && y < 0 = Ball (x + head turns, y - 1) (tail turns)\n      | otherwise            = Ball (x, y - 1) turns\n        \ndrawWorld :: World -> Picture\ndrawWorld (nRows, balls, bins) = pictures [ color red ballsP\n                                          , color black binsP\n                                          , color blue pinsP ]\n  where ballsP = foldMap (disk 1) $ takeWhile ((3 >).snd) $ map position balls        \n        binsP  = foldMapWithKey drawBin bins\n        pinsP  = foldMap (disk 0.2) $ [1..nRows] >>= \\i ->\n                                          [1..i] >>= \\j -> [(2*j-i-1, -i-1)]\n\n        disk r pos = trans pos $ circleSolid (r*10)\n        drawBin x h = trans (x,-nRows-7)\n                    $ rectangleUpperSolid 20 (-fromIntegral h)\n        trans (x,y) = Translate (20 * fromIntegral x) (20 * fromIntegral y)\n\nstartSimulation :: Int -> [Ball] -> IO ()\nstartSimulation nRows balls = simulate display white 50 world drawWorld update\n  where display = InWindow \"Galton box\" (400, 400) (0, 0)\n        world = (nRows, balls, empty)\n        update _ _ = updateWorld\n\nmain = evalRandIO balls >>= startSimulation 10\n  where balls = mapM makeBall [1..]\n        makeBall y = Ball (0, y) <$> randomTurns\n        randomTurns = filter (/=0) <$> getRandomRs (-1, 1)\n", "target": "\n\nimport sys, os\nimport random\nimport time\n\ndef print_there(x, y, text):\n     sys.stdout.write(\"\\x1b7\\x1b[%d;%df%s\\x1b8\" % (x, y, text))\n     sys.stdout.flush()\n\n\nclass Ball():\n    def __init__(self):\n        self.x = 0\n        self.y = 0\n        \n    def update(self):\n        self.x += random.randint(0,1)\n        self.y += 1\n\n    def fall(self):\n        self.y +=1\n\n\nclass Board():\n    def __init__(self, width, well_depth, N):\n        self.balls = []\n        self.fallen = [0] * (width + 1)\n        self.width = width\n        self.well_depth = well_depth\n        self.N = N\n        self.shift = 4\n        \n    def update(self):\n        for ball in self.balls:\n            if ball.y < self.width:\n                ball.update()\n            elif ball.y < self.width + self.well_depth - self.fallen[ball.x]:\n                ball.fall()\n            elif ball.y == self.width + self.well_depth - self.fallen[ball.x]:\n                self.fallen[ball.x] += 1\n            else:\n                pass\n                \n    def balls_on_board(self):\n        return len(self.balls) - sum(self.fallen)\n                \n    def add_ball(self):\n        if(len(self.balls) <= self.N):\n            self.balls.append(Ball())\n\n    def print_board(self):\n        for y in range(self.width + 1):\n            for x in range(y):\n                print_there( y + 1 ,self.width - y + 2*x + self.shift + 1, \"\n    def print_ball(self, ball):\n        if ball.y <= self.width:\n            x = self.width - ball.y + 2*ball.x + self.shift\n        else:\n            x = 2*ball.x + self.shift\n        y = ball.y + 1\n        print_there(y, x, \"*\")\n         \n    def print_all(self):\n        print(chr(27) + \"[2J\")\n        self.print_board();\n        for ball in self.balls:\n            self.print_ball(ball)\n\n\ndef main():\n    board = Board(width = 15, well_depth = 5, N = 10)\n    board.add_ball() \n    while(board.balls_on_board() > 0):\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.print_all()\n         time.sleep(0.25)\n         board.update()\n         board.add_ball()\n\n\nif __name__==\"__main__\":\n    main()\n"}
{"id": 418661, "name": "Primes - allocate descendants to their ancestors", "source": "Translate Haskell to Python: \nimport Data.Numbers.Primes (isPrime)\nimport Data.List\n\n\n\n\ntype Memo2 a = Memo (Memo a)\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving Functor\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Integral a => Memo a\nnats = Node 0 ((+1).(*2) <$> nats) ((*2).(+1) <$> nats)\n\nmemoize :: Integral a => (a -> b) -> (a -> b)\nmemoize f = memo (f <$> nats)\n\nmemoize2 :: (Integral a, Integral b) => (a -> b -> c) -> (a -> b -> c)\nmemoize2 f = memoize (memoize . f)\n\n\n\npartProd = memoize2 partProdM\n  where\n    partProdM x p\n      | p == 0 = []\n      | x == 0 = [1]\n      | x < 0 = []\n      | isPrime p = ((p *) <$> partProdM (x - p) p) ++\n                    partProd x (p - 1)\n      | otherwise = partProd x (p - 1)\n\ndescendants = memoize descendantsM\n  where\n    descendantsM x =\n      if x == 4 then [] else sort (partProd x (x - 1))\n\nancestors = memoize ancestorsM\n  where\n    ancestorsM z = concat [ ancestors x ++ [x]\n                          | x <- [z-1,z-2..1]\n                          , z `elem` descendants x ]\n\nmain = do\n  mapM_ (putStrLn . task1) [1..15]\n  putStrLn (task2 46)\n  putStrLn (task2 99)\n  putStrLn task3\n  where\n    task1 n = show n ++\n              \"  ancestors:\" ++ show (ancestors n) ++\n              \"  descendants:\" ++ show (descendants n)\n    task2 n = show n ++ \" has \" ++\n              show (length (ancestors n)) ++ \" ancestors, \" ++\n              show (length (descendants n)) ++ \" descendants.\"\n    task3 = \"Total ancestors up to 99: \" ++\n            show (sum $ length . ancestors <$> [1..99]) ++\n            \"\\nTotal descendants up to 99: \" ++\n            show (sum $ length . descendants <$> [1..99])\n", "target": "from __future__ import print_function\nfrom itertools import takewhile\n\nmaxsum = 99\n\ndef get_primes(max):\n    if max < 2:\n        return []\n    lprimes = [2]\n    for x in range(3, max + 1, 2):\n        for p in lprimes:\n            if x % p == 0:\n                break\n        else:\n            lprimes.append(x)\n    return lprimes\n\ndescendants = [[] for _ in range(maxsum + 1)]\nancestors = [[] for _ in range(maxsum + 1)]\n\nprimes = get_primes(maxsum)\n\nfor p in primes:\n    descendants[p].append(p)\n    for s in range(1, len(descendants) - p):\n        descendants[s + p] += [p * pr for pr in descendants[s]]\n\nfor p in primes + [4]:\n    descendants[p].pop()\n\ntotal = 0\nfor s in range(1, maxsum + 1):\n    descendants[s].sort()\n    for d in takewhile(lambda x: x <= maxsum, descendants[s]):\n        ancestors[d] = ancestors[s] + [s]\n    print([s], \"Level:\", len(ancestors[s]))\n    print(\"Ancestors:\", ancestors[s] if len(ancestors[s]) else \"None\")\n    print(\"Descendants:\", len(descendants[s]) if len(descendants[s]) else \"None\")\n    if len(descendants[s]):\n        print(descendants[s])\n    print()\n    total += len(descendants[s])\n\nprint(\"Total descendants\", total)\n"}
{"id": 418662, "name": "Smallest square that begins with n", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.List (find, intercalate, isPrefixOf, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nfirstSquareWithPrefix :: Int -> Int\nfirstSquareWithPrefix n = unDigits match\n  where\n    ds = digits n\n    Just match = find (isPrefixOf ds) squareDigits\n\nsquareDigits :: [[Int]]\nsquareDigits = digits . join (*) <$> [0 ..]\n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . firstSquareWithPrefix <$> [1 .. 49]\n\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418663, "name": "Smallest square that begins with n", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.List (find, intercalate, isPrefixOf, transpose)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nfirstSquareWithPrefix :: Int -> Int\nfirstSquareWithPrefix n = unDigits match\n  where\n    ds = digits n\n    Just match = find (isPrefixOf ds) squareDigits\n\nsquareDigits :: [[Int]]\nsquareDigits = digits . join (*) <$> [0 ..]\n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    table \"  \" $\n      chunksOf 10 $\n        show . firstSquareWithPrefix <$> [1 .. 49]\n\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\nunDigits :: [Int] -> Int\nunDigits = foldl ((+) . (10 *)) 0\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstSquareWithPrefix(n):\n    \n    pfx = str(n)\n    lng = len(pfx)\n    return int(\n        next(\n            s for s in (\n                str(x * x) for x in count(0)\n            )\n            if pfx == s[0:lng]\n        )\n    )\n\n\n\ndef main():\n    \n\n    print('\\n'.join([\n        str(firstSquareWithPrefix(x)) for x in range(1, 50)\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418664, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Haskell to Python: import Data.Bool (bool)\n\ncircleSort :: Ord a => [a] -> [a]\ncircleSort xs = if swapped then circleSort ks else ks\n  where\n    (swapped,ks) = go False xs (False,[])\n    \n    go d []  sks = sks\n    go d [x] (s,ks) = (s,x:ks)\n    go d xs  (s,ks) =\n      let (st,_,ls,rs) = halve d s xs xs\n      in go False ls (go True rs (st,ks))\n \n    halve d s (y:ys) (_:_:zs) = swap d y (halve d s ys zs)\n    halve d s ys     []       = (s,ys,[],[])\n    halve d s (y:ys) [_]      = (s,ys,[y | e],[y | not e])\n      where e = y <= head ys\n \n    swap d x (s,y:ys,ls,rs)\n      | bool (<=) (<) d x y = (    d || s,ys,x:ls,y:rs)\n      | otherwise           = (not d || s,ys,y:ls,x:rs)\n", "target": "\n\n\n\n\ndef circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':\n    \n    n = R-L\n    if n < 2:\n        return 0\n    swaps = 0\n    m = n//2\n    for i in range(m):\n        if A[R-(i+1)] < A[L+i]:\n            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)\n            swaps += 1\n    if (n & 1) and (A[L+m] < A[L+m-1]):\n        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)\n        swaps += 1\n    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R)\n\ndef circle_sort(L:list)->'sort A in place, returning the number of swaps':\n    swaps = 0\n    s = 1\n    while s:\n        s = circle_sort_backend(L, 0, len(L))\n        swaps += s\n    return swaps\n\n\nif __name__ == '__main__':\n    from random import shuffle\n    for i in range(309):\n        L = list(range(i))\n        M = L[:]\n        shuffle(L)\n        N = L[:]\n        circle_sort(L)\n        if L != M:\n            print(len(L))\n            print(N)\n            print(L)\n"}
{"id": 418665, "name": "Word wheel", "source": "Translate Haskell to Python: import Data.Char (toLower)\nimport Data.List (sort)\nimport System.IO (readFile)\n\n\n\ngridWords :: [String] -> [String] -> [String]\ngridWords grid =\n  filter\n    ( ((&&) . (2 <) . length)\n        <*> (((&&) . elem mid) <*> wheelFit wheel)\n    )\n  where\n    cs = toLower <$> concat grid\n    wheel = sort cs\n    mid = cs !! 4\n\nwheelFit :: String -> String -> Bool\nwheelFit wheel = go wheel . sort\n  where\n    go _ [] = True\n    go [] _ = False\n    go (w : ws) ccs@(c : cs)\n      | w == c = go ws cs\n      | otherwise = go ws ccs\n\n\nmain :: IO ()\nmain =\n  readFile \"unixdict.txt\"\n    >>= ( mapM_ putStrLn\n            . gridWords [\"NDE\", \"OKG\", \"ELW\"]\n            . lines\n        )\n", "target": "import urllib.request\nfrom collections import Counter\n\n\nGRID = \n\n\ndef getwords(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    \"Return lowercased words of 3 to 9 characters\"\n    words = urllib.request.urlopen(url).read().decode().strip().lower().split()\n    return (w for w in words if 2 < len(w) < 10)\n\ndef solve(grid, dictionary):\n    gridcount = Counter(grid)\n    mid = grid[4]\n    return [word for word in dictionary\n            if mid in word and not (Counter(word) - gridcount)]\n\n\nif __name__ == '__main__':\n    chars = ''.join(GRID.strip().lower().split())\n    found = solve(chars, dictionary=getwords())\n    print('\\n'.join(found))\n"}
{"id": 418666, "name": "Brace expansion", "source": "Translate Haskell to Python: import qualified Text.Parsec as P\n\nshowExpansion :: String -> String\nshowExpansion =\n  (<>) . (<> \"\\n\n\nparser :: P.Parsec String u [String]\nparser = expansion P.anyChar\n\nexpansion :: P.Parsec String u Char -> P.Parsec String u [String]\nexpansion =\n  fmap expand .\n  P.many .\n  ((P.try alts P.<|> P.try alt1 P.<|> escape) P.<|>) . fmap (pure . pure)\n\nexpand :: [[String]] -> [String]\nexpand = foldr ((<*>) . fmap (<>)) [[]]\n\nalts :: P.Parsec String u [String]\nalts = concat <$> P.between (P.char '{') (P.char '}') (alt `sepBy2` P.char ',')\n\nalt :: P.Parsec String u [String]\nalt = expansion (P.noneOf \",}\")\n\nalt1 :: P.Parsec String u [String]\nalt1 =\n  (\\x -> ['{' : (x <> \"}\")]) <$>\n  P.between (P.char '{') (P.char '}') (P.many $ P.noneOf \",{}\")\n\nsepBy2 :: P.Parsec String u a -> P.Parsec String u b -> P.Parsec String u [a]\np `sepBy2` sep = (:) <$> p <*> P.many1 (sep >> p)\n\nescape :: P.Parsec String u [String]\nescape = pure <$> sequence [P.char '\\\\', P.anyChar]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . showExpansion)\n    [ \"~/{Downloads,Pictures}/*.{jpg,gif,png}\"\n    , \"It{{em,alic}iz,erat}e{d,}, please.\"\n    , \"{,{,gotta have{ ,\\\\, again\\\\, }}more }cowbell!\"\n    , \"{}} some }{,{\\\\\\\\{ edge, edge} \\\\,}{ cases, {here} \\\\\\\\\\\\\\\\\\\\}\"\n    ]\n", "target": "def getitem(s, depth=0):\n    out = [\"\"]\n    while s:\n        c = s[0]\n        if depth and (c == ',' or c == '}'):\n            return out,s\n        if c == '{':\n            x = getgroup(s[1:], depth+1)\n            if x:\n                out,s = [a+b for a in out for b in x[0]], x[1]\n                continue\n        if c == '\\\\' and len(s) > 1:\n            s, c = s[1:], c + s[1]\n\n        out, s = [a+c for a in out], s[1:]\n\n    return out,s\n\ndef getgroup(s, depth):\n    out, comma = [], False\n    while s:\n        g,s = getitem(s, depth)\n        if not s: break\n        out += g\n\n        if s[0] == '}':\n            if comma: return out, s[1:]\n            return ['{' + a + '}' for a in out], s[1:]\n\n        if s[0] == ',':\n            comma,s = True, s[1:]\n\n    return None\n\n\nfor s in .split('\\n'):\n    print \"\\n\\t\".join([s] + getitem(s)[0]) + \"\\n\"\n"}
{"id": 418667, "name": "Intersecting number wheels", "source": "Translate Haskell to Python: import Data.Char (isDigit)\nimport Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nclockWorkTick ::\n  M.Map Char String ->\n  (M.Map Char String, Char)\nclockWorkTick = flip click 'A'\n  where\n    click wheels name\n      | isDigit name = (wheels, name)\n      | otherwise =\n        ( click\n            . flip\n              (M.insert name . leftRotate)\n              wheels\n            <*> head\n        )\n          $ fromMaybe ['?'] $ M.lookup name wheels\n\nleftRotate :: [a] -> [a]\nleftRotate = take . length <*> (tail . cycle)\n\n\nmain :: IO ()\nmain = do\n  let wheelSets =\n        [ [('A', \"123\")],\n          [('A', \"1B2\"), ('B', \"34\")],\n          [('A', \"1DD\"), ('D', \"678\")],\n          [('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")]\n        ]\n  putStrLn \"State of each wheel-set after 20 clicks:\\n\"\n  mapM_ print $\n    fmap\n      ( flip\n          (mapAccumL (const . clockWorkTick))\n          (replicate 20 undefined)\n          . M.fromList\n      )\n      wheelSets\n  putStrLn \"\\nInitial state of the wheel-sets:\\n\"\n  mapM_ print wheelSets\n", "target": "from itertools import islice\n\nclass INW():\n    \n\n    def __init__(self, **wheels):\n        self._wheels = wheels\n        self.isect = {name: self._wstate(name, wheel) \n                      for name, wheel in wheels.items()}\n    \n    def _wstate(self, name, wheel):\n        \"Wheel state holder\"\n        assert all(val in self._wheels for val in wheel if type(val) == str), \\\n               f\"ERROR: Interconnected wheel not found in {name}: {wheel}\"\n        pos = 0\n        ln = len(wheel)\n        while True:\n            nxt, pos = wheel[pos % ln], pos + 1\n            yield next(self.isect[nxt]) if type(nxt) == str else nxt\n                \n    def __iter__(self):\n        base_wheel_name = next(self.isect.__iter__())\n        yield from self.isect[base_wheel_name]\n        \n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self._wheels})\"\n    \n    def __str__(self):\n        txt = \"Intersecting Number Wheel group:\"\n        for name, wheel in self._wheels.items():\n            txt += f\"\\n  {name+':':4}\" + ' '.join(str(v) for v in wheel)\n        return txt\n\ndef first(iter, n):\n    \"Pretty print first few terms\"\n    return ' '.join(f\"{nxt}\" for nxt in islice(iter, n))\n\nif __name__ == '__main__':\n    for group in[\n      {'A': (1, 2, 3)},\n      {'A': (1, 'B', 2),\n       'B': (3, 4)},\n      {'A': (1, 'D', 'D'),\n       'D': (6, 7, 8)},\n      {'A': (1, 'B', 'C'),\n       'B': (3, 4),\n       'C': (5, 'B')}, \n     ]:\n        w = INW(**group)\n        print(f\"{w}\\n  Generates:\\n    {first(w, 20)} ...\\n\")\n"}
{"id": 418668, "name": "Intersecting number wheels", "source": "Translate Haskell to Python: import Data.Char (isDigit)\nimport Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nclockWorkTick ::\n  M.Map Char String ->\n  (M.Map Char String, Char)\nclockWorkTick = flip click 'A'\n  where\n    click wheels name\n      | isDigit name = (wheels, name)\n      | otherwise =\n        ( click\n            . flip\n              (M.insert name . leftRotate)\n              wheels\n            <*> head\n        )\n          $ fromMaybe ['?'] $ M.lookup name wheels\n\nleftRotate :: [a] -> [a]\nleftRotate = take . length <*> (tail . cycle)\n\n\nmain :: IO ()\nmain = do\n  let wheelSets =\n        [ [('A', \"123\")],\n          [('A', \"1B2\"), ('B', \"34\")],\n          [('A', \"1DD\"), ('D', \"678\")],\n          [('A', \"1BC\"), ('B', \"34\"), ('C', \"5B\")]\n        ]\n  putStrLn \"State of each wheel-set after 20 clicks:\\n\"\n  mapM_ print $\n    fmap\n      ( flip\n          (mapAccumL (const . clockWorkTick))\n          (replicate 20 undefined)\n          . M.fromList\n      )\n      wheelSets\n  putStrLn \"\\nInitial state of the wheel-sets:\\n\"\n  mapM_ print wheelSets\n", "target": "from itertools import islice\n\nclass INW():\n    \n\n    def __init__(self, **wheels):\n        self._wheels = wheels\n        self.isect = {name: self._wstate(name, wheel) \n                      for name, wheel in wheels.items()}\n    \n    def _wstate(self, name, wheel):\n        \"Wheel state holder\"\n        assert all(val in self._wheels for val in wheel if type(val) == str), \\\n               f\"ERROR: Interconnected wheel not found in {name}: {wheel}\"\n        pos = 0\n        ln = len(wheel)\n        while True:\n            nxt, pos = wheel[pos % ln], pos + 1\n            yield next(self.isect[nxt]) if type(nxt) == str else nxt\n                \n    def __iter__(self):\n        base_wheel_name = next(self.isect.__iter__())\n        yield from self.isect[base_wheel_name]\n        \n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self._wheels})\"\n    \n    def __str__(self):\n        txt = \"Intersecting Number Wheel group:\"\n        for name, wheel in self._wheels.items():\n            txt += f\"\\n  {name+':':4}\" + ' '.join(str(v) for v in wheel)\n        return txt\n\ndef first(iter, n):\n    \"Pretty print first few terms\"\n    return ' '.join(f\"{nxt}\" for nxt in islice(iter, n))\n\nif __name__ == '__main__':\n    for group in[\n      {'A': (1, 2, 3)},\n      {'A': (1, 'B', 2),\n       'B': (3, 4)},\n      {'A': (1, 'D', 'D'),\n       'D': (6, 7, 8)},\n      {'A': (1, 'B', 'C'),\n       'B': (3, 4),\n       'C': (5, 'B')}, \n     ]:\n        w = INW(**group)\n        print(f\"{w}\\n  Generates:\\n    {first(w, 20)} ...\\n\")\n"}
{"id": 418669, "name": "Yahoo! search interface", "source": "Translate Haskell to Python: import Network.HTTP\nimport Text.Parsec\n\ndata YahooSearchItem = YahooSearchItem {\n    itemUrl, itemTitle, itemContent :: String }\n\ndata YahooSearch = YahooSearch {\n    searchQuery :: String,\n    searchPage :: Int,\n    searchItems :: [YahooSearchItem] }\n    \n\nyahooUrl = \"http://search.yahoo.com/search?p=\"\n\n\nyahoo :: String -> IO YahooSearch\nyahoo q = simpleHTTP (getRequest $ yahooUrl ++ q) >>=\n    getResponseBody >>= return . YahooSearch q 1 . items\n\n\nnext :: YahooSearch -> IO YahooSearch\nnext (YahooSearch q p _) =\n    simpleHTTP (getRequest $\n    \n    yahooUrl ++ q ++ \"&b=\" ++ show (p + 1)) >>=\n    getResponseBody >>= return . YahooSearch q (p + 1) . items\n\nprintResults :: YahooSearch -> IO ()\nprintResults (YahooSearch q p items) = do\n    putStrLn $ \"Showing Yahoo! search results for query: \" ++ q\n    putStrLn $ \"Page: \" ++ show p\n    putChar '\\n'\n    mapM_ printOne items\n    where\n        printOne (YahooSearchItem itemUrl itemTitle itemContent) = do\n            putStrLn $ \"URL  \u00a0: \" ++ itemUrl\n            putStrLn $ \"Title\u00a0: \" ++ itemTitle\n            putStrLn $ \"Abstr\u00a0: \" ++ itemContent\n            putChar '\\n'\n\nurlTag, titleTag, contentTag1, contentTag2, ignoreTag,\n    ignoreText :: Parsec String () String\n    \n\nurlTag = do { string \"<a id=\\\"link-\";\n    many digit; string \"\\\" class=\\\"yschttl spt\\\" href=\\\"\";\n    url <- manyTill anyChar (char '\"'); manyTill anyChar (char '>');\n    return url }\n\n\n\ntitleTag = do { urlTag; manyTill anyChar (try (string \"</a>\")) }\n\n\n\ncontentTag1 = do { string \"<div class=\\\"sm-abs\\\">\";\n    manyTill anyChar (try (string \"</div>\")) }\n\ncontentTag2 = do { string \"<div class=\\\"abstr\\\">\";\n    manyTill anyChar (try (string \"</div>\")) }\n\n\nignoreTag = do { char ('<'); manyTill anyChar (char '>');\n    return \"\" }\n\n\nignoreText = do { many1 (noneOf \"<\"); return \"\" }\n\n\nnonempty :: [String] -> Parsec String () [String]\nnonempty xs = return [ x | x <- xs, not (null x) ]\n\n\n\nparseCategory x = do\n    res <- many x\n    eof\n    nonempty res\n    \nurls, titles, contents :: Parsec String () [String]\n\n\nurls = parseCategory url where\n    url = (try urlTag) <|> ignoreTag <|> ignoreText\n\n\ntitles = parseCategory title where\n    title = (try titleTag) <|> ignoreTag <|> ignoreText\n\n\ncontents = parseCategory content where\n    content = (try contentTag1) <|> (try contentTag2) <|>\n        ignoreTag <|> ignoreText\n\n\n\n\nitems :: String -> [YahooSearchItem]\nitems q =\n    let ignoreOrKeep = either (const []) id\n        us = ignoreOrKeep $ parse urls \"\" q\n        ts = ignoreOrKeep $ parse titles \"\" q\n        cs = ignoreOrKeep $ parse contents \"\" q\n    in [ YahooSearchItem { itemUrl = u, itemTitle = t, itemContent = c } |\n        (u, t, c) <- zip3 us ts cs ]\n", "target": "import urllib\nimport re\n\ndef fix(x):\n    p = re.compile(r'<[^<]*?>')\n    return p.sub('', x).replace('&amp;', '&')\n \nclass YahooSearch:\n    def __init__(self, query, page=1):       \n        self.query = query\n        self.page = page\n        self.url = \"http://search.yahoo.com/search?p=%s&b=%s\" %(self.query, ((self.page - 1) * 10 + 1))\n        self.content = urllib.urlopen(self.url).read()        \n \n    def getresults(self):\n        self.results = []\n \n        for i in re.findall('<a class=\"yschttl spt\" href=\".+?\">(.+?)</a></h3></div>(.+?)</div>.*?<span class=url>(.+?)</span>', self.content):\n \n            title = fix(i[0])\n            content = fix(i[1])\n            url = fix(i[2])\n \n            self.results.append(YahooResult(title, content, url))\n \n        return self.results\n \n    def getnextpage(self):\n        return YahooSearch(self.query, self.page+1)\n \n    search_results = property(fget=getresults)\n    nextpage = property(fget=getnextpage)\n \nclass YahooResult:\n    def __init__(self,title,content,url):\n        self.title = title\n        self.content = content\n        self.url = url\n \n\n \nx = YahooSearch(\"test\")\n \nfor result in x.search_results:\n    print result.title\n"}
{"id": 418670, "name": "Circles of given radius through two points", "source": "Translate Haskell to Python: add (a, b) (x, y) = (a + x, b + y)\nsub (a, b) (x, y) = (a - x, b - y)\nmagSqr (a, b)     = (a ^^ 2) + (b ^^ 2)\nmag a             = sqrt $ magSqr a\nmul (a, b) c      = (a * c, b * c)\ndiv2 (a, b) c     = (a / c, b / c)\nperp (a, b)       = (negate b, a)\nnorm a            = a `div2` mag a\n\ncirclePoints :: (Ord a, Floating a) =>\n                (a, a) -> (a, a) -> a -> Maybe ((a, a), (a, a))\ncirclePoints p q radius\n  | radius == 0      = Nothing\n  | p == q           = Nothing\n  | diameter < magPQ = Nothing\n  | otherwise        = Just (center1, center2)\n  where\n    diameter = radius * 2\n    pq       = p `sub` q\n    magPQ    = mag pq\n    midpoint = (p `add` q) `div2` 2\n    halfPQ   = magPQ / 2\n    magMidC  = sqrt . abs $ (radius ^^ 2) - (halfPQ ^^ 2)\n    midC     = (norm $ perp pq) `mul` magMidC\n    center1  = midpoint `add` midC\n    center2  = midpoint `sub` midC\n\nuncurry3 f (a, b, c) = f a b c\n\nmain :: IO ()\nmain = mapM_ (print . uncurry3 circlePoints)\n  [((0.1234, 0.9876), (0.8765, 0.2345), 2),\n   ((0     , 2     ), (0     , 0     ), 1),\n   ((0.1234, 0.9876), (0.1234, 0.9876), 2),\n   ((0.1234, 0.9876), (0.8765, 0.2345), 0.5),\n   ((0.1234, 0.9876), (0.1234, 0.1234), 0)]\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 418671, "name": "Circles of given radius through two points", "source": "Translate Haskell to Python: add (a, b) (x, y) = (a + x, b + y)\nsub (a, b) (x, y) = (a - x, b - y)\nmagSqr (a, b)     = (a ^^ 2) + (b ^^ 2)\nmag a             = sqrt $ magSqr a\nmul (a, b) c      = (a * c, b * c)\ndiv2 (a, b) c     = (a / c, b / c)\nperp (a, b)       = (negate b, a)\nnorm a            = a `div2` mag a\n\ncirclePoints :: (Ord a, Floating a) =>\n                (a, a) -> (a, a) -> a -> Maybe ((a, a), (a, a))\ncirclePoints p q radius\n  | radius == 0      = Nothing\n  | p == q           = Nothing\n  | diameter < magPQ = Nothing\n  | otherwise        = Just (center1, center2)\n  where\n    diameter = radius * 2\n    pq       = p `sub` q\n    magPQ    = mag pq\n    midpoint = (p `add` q) `div2` 2\n    halfPQ   = magPQ / 2\n    magMidC  = sqrt . abs $ (radius ^^ 2) - (halfPQ ^^ 2)\n    midC     = (norm $ perp pq) `mul` magMidC\n    center1  = midpoint `add` midC\n    center2  = midpoint `sub` midC\n\nuncurry3 f (a, b, c) = f a b c\n\nmain :: IO ()\nmain = mapM_ (print . uncurry3 circlePoints)\n  [((0.1234, 0.9876), (0.8765, 0.2345), 2),\n   ((0     , 2     ), (0     , 0     ), 1),\n   ((0.1234, 0.9876), (0.1234, 0.9876), 2),\n   ((0.1234, 0.9876), (0.8765, 0.2345), 0.5),\n   ((0.1234, 0.9876), (0.1234, 0.1234), 0)]\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 418672, "name": "Vampire number", "source": "Translate Haskell to Python: import Data.List (sort)\nimport Control.Arrow ((&&&))\n\n\nvampires :: [Int]\nvampires = filter (not . null . fangs) [1 ..]\n\nfangs :: Int -> [(Int, Int)]\nfangs n\n  | odd w = []\n  | otherwise = ((,) <*> quot n) <$> filter isfang (integerFactors n)\n  where\n    ndigit :: Int -> Int\n    ndigit 0 = 0\n    ndigit n = 1 + ndigit (quot n 10)\n    w = ndigit n\n    xmin = 10 ^ (quot w 2 - 1)\n    xmax = xmin * 10\n    isfang x =\n      x > xmin &&\n      x < y &&\n      y < xmax && \n      (quot x 10 /= 0 || quot y 10 /= 0) && \n      sort (show n) == sort (show x ++ show y)\n      where\n        y = quot n x\n\n\nintegerFactors :: Int -> [Int]\nintegerFactors n\n  | n < 1 = []\n  | otherwise =\n    lows ++\n    (quot n <$>\n     (if intSquared == n \n        then tail \n        else id)\n       (reverse lows))\n  where\n    (intSquared, lows) =\n      (^ 2) &&& (filter ((0 ==) . rem n) . enumFromTo 1) $\n      floor (sqrt $ fromIntegral n)\n\n\nmain :: IO [()]\nmain =\n  mapM\n    (print . ((,) <*>) fangs)\n    (take 25 vampires ++ [16758243290880, 24959017348650, 14593825548650])\n", "target": "from __future__ import division\n\nimport math\nfrom operator import mul\nfrom itertools import product\nfrom functools import reduce\n\n\ndef fac(n):\n    \n    step = lambda x: 1 + x*4 - (x//2)*2\n    maxq = int(math.floor(math.sqrt(n)))\n    d = 1\n    q = n % 2 == 0 and 2 or 3 \n    while q <= maxq and n % q != 0:\n        q = step(d)\n        d += 1\n    res = []\n    if q <= maxq:\n        res.extend(fac(n//q))\n        res.extend(fac(q)) \n    else: res=[n]\n    return res\n\ndef fact(n):\n    \n    res = fac(n)\n    return [(c, res.count(c)) for c in set(res)]\n\ndef divisors(n):\n    'Returns all the divisors of n'\n    factors = fact(n)   \n    primes, maxpowers = zip(*factors)\n    powerranges = (range(m+1) for m in maxpowers)\n    powers = product(*powerranges)\n    return (\n        reduce(mul,\n               (prime**power for prime, power in zip(primes, powergroup)),\n               1)\n        for powergroup in powers)\n    \ndef vampire(n):\n    fangsets = set( frozenset([d, n//d])\n                    for d in divisors(n)\n                    if (len(str(d)) == len(str(n))/2.\n                        and sorted(str(d) + str(n//d)) == sorted(str(n))\n                        and (str(d)[-1] == 0) + (str(n//d)[-1] == 0) <=1) )\n    return sorted(tuple(sorted(fangs)) for fangs in fangsets)\n    \n\nif __name__ == '__main__':\n    print('First 25 vampire numbers')\n    count = n = 0\n    while count <25:\n        n += 1\n        fangpairs = vampire(n)\n        if fangpairs:\n            count += 1\n            print('%i: %r' % (n, fangpairs))\n    print('\\nSpecific checks for fangpairs')\n    for n in (16758243290880, 24959017348650, 14593825548650):\n        fangpairs = vampire(n)\n        print('%i: %r' % (n, fangpairs))\n"}
{"id": 418673, "name": "Mind boggling card trick", "source": "Translate Haskell to Python: import System.Random (randomRIO)\nimport Data.List (partition)\nimport Data.Monoid ((<>))\n \nmain :: IO [Int]\nmain = do\n \n  \n  ns <- knuthShuffle [1 .. 52]\n  let (rs_, bs_, discards) = threeStacks (rb <$> ns)\n \n  \n  nSwap <- randomRIO (1, min (length rs_) (length bs_))\n  let (rs, bs) = exchange nSwap rs_ bs_\n \n  \n  let rrs = filter ('R' ==) rs\n  let bbs = filter ('B' ==) bs\n  putStrLn $\n    unlines\n      [ \"Discarded: \" <> discards\n      , \"Swapped: \" <> show nSwap\n      , \"Red pile: \" <> rs\n      , \"Black pile: \" <> bs\n      , rrs <> \" = Red cards in the red pile\"\n      , bbs <> \" = Black cards in the black pile\"\n      , show $ length rrs == length bbs\n      ]\n  return ns\n \n\nrb :: Int -> Char\nrb n\n  | even n = 'R'\n  | otherwise = 'B'\n \n\nthreeStacks :: String -> (String, String, String)\nthreeStacks = go ([], [], [])\n  where\n    go tpl [] = tpl\n    go (rs, bs, ds) [x] = (rs, bs, x : ds)\n    go (rs, bs, ds) (x:y:xs)\n      | 'R' == x = go (y : rs, bs, x : ds) xs\n      | otherwise = go (rs, y : bs, x : ds) xs\n \nexchange :: Int -> [a] -> [a] -> ([a], [a])\nexchange n xs ys =\n  let [xs_, ys_] = splitAt n <$> [xs, ys]\n  in (fst ys_ <> snd xs_, fst xs_ <> snd ys_)\n \n\n\nknuthShuffle :: [a] -> IO [a]\nknuthShuffle xs = (foldr swapElems xs . zip [1 ..]) <$> randoms (length xs)\n \nrandoms :: Int -> IO [Int]\nrandoms x = traverse (randomRIO . (,) 0) [1 .. (pred x)]\n \nswapElems :: (Int, Int) -> [a] -> [a]\nswapElems (i, j) xs\n  | i == j = xs\n  | otherwise = replaceAt j (xs !! i) $ replaceAt i (xs !! j) xs\n \nreplaceAt :: Int -> a -> [a] -> [a]\nreplaceAt i c l =\n  let (a, b) = splitAt i l\n  in a ++ c : drop 1 b\n", "target": "import random\n\n\nn = 52\nBlack, Red = 'Black', 'Red'\nblacks = [Black] * (n // 2) \nreds = [Red] * (n // 2)\npack = blacks + reds\n\nrandom.shuffle(pack)\n\n\nblack_stack, red_stack, discard = [], [], []\nwhile pack:\n    top = pack.pop()\n    if top == Black:\n        black_stack.append(pack.pop())\n    else:\n        red_stack.append(pack.pop())\n    discard.append(top)\nprint('(Discards:', ' '.join(d[0] for d in discard), ')\\n')\n\n\n\nmax_swaps = min(len(black_stack), len(red_stack))\n\nswap_count = random.randint(0, max_swaps)\nprint('Swapping', swap_count)\n\ndef random_partition(stack, count):\n    \"Partition the stack into 'count' randomly selected members and the rest\"\n    sample = random.sample(stack, count)\n    rest = stack[::]\n    for card in sample:\n        rest.remove(card)\n    return rest, sample\n\nblack_stack, black_swap = random_partition(black_stack, swap_count)\nred_stack, red_swap = random_partition(red_stack, swap_count)\n\n\nblack_stack += red_swap\nred_stack += black_swap\n\n\nif black_stack.count(Black) == red_stack.count(Red):\n    print('Yeha! The mathematicians assertion is correct.')\nelse:\n    print('Whoops - The mathematicians (or my card manipulations) are flakey')\n"}
{"id": 418674, "name": "Mind boggling card trick", "source": "Translate Haskell to Python: import System.Random (randomRIO)\nimport Data.List (partition)\nimport Data.Monoid ((<>))\n \nmain :: IO [Int]\nmain = do\n \n  \n  ns <- knuthShuffle [1 .. 52]\n  let (rs_, bs_, discards) = threeStacks (rb <$> ns)\n \n  \n  nSwap <- randomRIO (1, min (length rs_) (length bs_))\n  let (rs, bs) = exchange nSwap rs_ bs_\n \n  \n  let rrs = filter ('R' ==) rs\n  let bbs = filter ('B' ==) bs\n  putStrLn $\n    unlines\n      [ \"Discarded: \" <> discards\n      , \"Swapped: \" <> show nSwap\n      , \"Red pile: \" <> rs\n      , \"Black pile: \" <> bs\n      , rrs <> \" = Red cards in the red pile\"\n      , bbs <> \" = Black cards in the black pile\"\n      , show $ length rrs == length bbs\n      ]\n  return ns\n \n\nrb :: Int -> Char\nrb n\n  | even n = 'R'\n  | otherwise = 'B'\n \n\nthreeStacks :: String -> (String, String, String)\nthreeStacks = go ([], [], [])\n  where\n    go tpl [] = tpl\n    go (rs, bs, ds) [x] = (rs, bs, x : ds)\n    go (rs, bs, ds) (x:y:xs)\n      | 'R' == x = go (y : rs, bs, x : ds) xs\n      | otherwise = go (rs, y : bs, x : ds) xs\n \nexchange :: Int -> [a] -> [a] -> ([a], [a])\nexchange n xs ys =\n  let [xs_, ys_] = splitAt n <$> [xs, ys]\n  in (fst ys_ <> snd xs_, fst xs_ <> snd ys_)\n \n\n\nknuthShuffle :: [a] -> IO [a]\nknuthShuffle xs = (foldr swapElems xs . zip [1 ..]) <$> randoms (length xs)\n \nrandoms :: Int -> IO [Int]\nrandoms x = traverse (randomRIO . (,) 0) [1 .. (pred x)]\n \nswapElems :: (Int, Int) -> [a] -> [a]\nswapElems (i, j) xs\n  | i == j = xs\n  | otherwise = replaceAt j (xs !! i) $ replaceAt i (xs !! j) xs\n \nreplaceAt :: Int -> a -> [a] -> [a]\nreplaceAt i c l =\n  let (a, b) = splitAt i l\n  in a ++ c : drop 1 b\n", "target": "import random\n\n\nn = 52\nBlack, Red = 'Black', 'Red'\nblacks = [Black] * (n // 2) \nreds = [Red] * (n // 2)\npack = blacks + reds\n\nrandom.shuffle(pack)\n\n\nblack_stack, red_stack, discard = [], [], []\nwhile pack:\n    top = pack.pop()\n    if top == Black:\n        black_stack.append(pack.pop())\n    else:\n        red_stack.append(pack.pop())\n    discard.append(top)\nprint('(Discards:', ' '.join(d[0] for d in discard), ')\\n')\n\n\n\nmax_swaps = min(len(black_stack), len(red_stack))\n\nswap_count = random.randint(0, max_swaps)\nprint('Swapping', swap_count)\n\ndef random_partition(stack, count):\n    \"Partition the stack into 'count' randomly selected members and the rest\"\n    sample = random.sample(stack, count)\n    rest = stack[::]\n    for card in sample:\n        rest.remove(card)\n    return rest, sample\n\nblack_stack, black_swap = random_partition(black_stack, swap_count)\nred_stack, red_swap = random_partition(red_stack, swap_count)\n\n\nblack_stack += red_swap\nred_stack += black_swap\n\n\nif black_stack.count(Black) == red_stack.count(Red):\n    print('Yeha! The mathematicians assertion is correct.')\nelse:\n    print('Whoops - The mathematicians (or my card manipulations) are flakey')\n"}
{"id": 418675, "name": "Poker hand analyser", "source": "Translate Haskell to Python: \n\nimport Data.Function (on)\nimport Data.List     (group, nub, any, sort, sortBy)\nimport Data.Maybe    (mapMaybe)\nimport Text.Read     (readMaybe)\n\ndata Suit = Club | Diamond | Spade | Heart deriving (Show, Eq)\n\ndata Rank = Ace | Two | Three | Four | Five | Six | Seven\n          | Eight | Nine | Ten | Jack | Queen | King\n          deriving (Show, Eq, Enum, Ord, Bounded)\n\ndata Card = Card { suit :: Suit, rank :: Rank } deriving (Show, Eq)\n\ntype Hand = [Card]\n\nconsumed = pure . (, \"\")\n\ninstance Read Suit where\n  readsPrec d s = case s of \"\u2665\" -> consumed Heart\n                            \"\u2666\" -> consumed Diamond\n                            \"\u2663\" -> consumed Spade\n                            \"\u2660\" -> consumed Club\n                            \"h\" -> consumed Heart\n                            _   -> []\n\ninstance Read Rank where\n  readsPrec d s = case s of \"a\"  -> consumed Ace\n                            \"2\"  -> consumed Two\n                            \"3\"  -> consumed Three\n                            \"4\"  -> consumed Four\n                            \"5\"  -> consumed Five\n                            \"6\"  -> consumed Six\n                            \"7\"  -> consumed Seven\n                            \"8\"  -> consumed Eight\n                            \"9\"  -> consumed Nine\n                            \"10\" -> consumed Ten\n                            \"j\"  -> consumed Jack\n                            \"q\"  -> consumed Queen\n                            \"k\"  -> consumed King\n                            _    -> []\n\ninstance Read Card where\n  readsPrec d = fmap (, \"\") . mapMaybe card . lex\n    where \n      card (r, s) = Card <$> (readMaybe s :: Maybe Suit)\n                         <*> (readMaybe r :: Maybe Rank)\n\n\nacesHigh :: [Rank]\nacesHigh = [Ace, Ten, Jack, Queen, King]\n\nisSucc :: (Enum a, Eq a, Bounded a) => [a] -> Bool\nisSucc []  = True\nisSucc [x] = True\nisSucc (x:y:zs) = (x /= maxBound && y == succ x) && isSucc (y:zs)\n\nnameHand :: Hand -> String\nnameHand [] = \"Invalid Input\"\nnameHand cards | invalidHand          = \"Invalid hand\"\n               | straight && flush    = \"Straight flush\"\n               | ofKind 4             = \"Four of a kind\"\n               | ofKind 3 && ofKind 2 = \"Full house\"\n               | flush                = \"Flush\"\n               | straight             = \"Straight\"\n               | ofKind 3             = \"Three of a kind\"\n               | uniqRanks == 3       = \"Two pair\"\n               | uniqRanks == 4       = \"One pair\"\n               | otherwise            = \"High card\"\n where\n  sortedRank  = sort $ rank <$> cards\n  rankCounts  = sortBy (compare `on` snd) $ (,) <$> head <*> length <$> group sortedRank\n  uniqRanks   = length rankCounts\n  ofKind n    = any ((==n) . snd) rankCounts\n  straight    = isSucc sortedRank || sortedRank == acesHigh\n  flush       = length (nub $ suit <$> cards) == 1\n  invalidHand = length (nub cards) /= 5\n\ntestHands :: [(String, Hand)]\ntestHands = (,) <$> id <*> mapMaybe readMaybe . words <$>\n  [ \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\"\n  , \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\"\n  , \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\"\n  , \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\"\n  , \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\"\n  , \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 7\u2663\" \n  , \"Bad input\" ]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . (fst <> const \": \" <> nameHand . snd)) testHands\n", "target": ":- initialization(main).\n\n\nfaces([a,k,q,j,10,9,8,7,6,5,4,3,2]).\n\nface(F) :- faces(Fs), member(F,Fs).\nsuit(S) :- member(S, ['\u2665','\u2666','\u2663','\u2660']).\n\n\nbest_hand(Cards,H) :-\n    straight_flush(Cards,C) -> H = straight-flush(C)\n  ; many_kind(Cards,F,4)    -> H = four-of-a-kind(F)\n  ; full_house(Cards,F1,F2) -> H = full-house(F1,F2)\n  ; flush(Cards,S)          -> H = flush(S)\n  ; straight(Cards,F)       -> H = straight(F)\n  ; many_kind(Cards,F,3)    -> H = three-of-a-kind(F)\n  ; two_pair(Cards,F1,F2)   -> H = two-pair(F1,F2)\n  ; many_kind(Cards,F,2)    -> H = one-pair(F)\n  ; many_kind(Cards,F,1)    -> H = high-card(F)\n  ;                            H = invalid\n  .\n\nstraight_flush(Cards, c(F,S)) :- straight(Cards,F), flush(Cards,S).\n\nfull_house(Cards,F1,F2) :-\n    many_kind(Cards,F1,3), many_kind(Cards,F2,2), F1 \\= F2.\n\nflush(Cards,S) :- maplist(has_suit(S), Cards).\nhas_suit(S, c(_,S)).\n\nstraight(Cards,F) :-\n    select(c(F,_), Cards, Cs), pred_face(F,F1), straight(Cs,F1).\nstraight([],_).\npred_face(F,F1) :- F = 2 -> F1 = a ; faces(Fs), append(_, [F,F1|_], Fs).\n\ntwo_pair(Cards,F1,F2) :-\n    many_kind(Cards,F1,2), many_kind(Cards,F2,2), F1 \\= F2.\n\nmany_kind(Cards,F,N) :-\n    face(F), findall(_, member(c(F,_), Cards), Xs), length(Xs,N).\n\n\n% utils/parser\nparse_line(Cards)  --> \" \", parse_line(Cards).\nparse_line([C|Cs]) --> parse_card(C), parse_line(Cs).\nparse_line([])     --> [].\n\nparse_card(c(F,S)) --> parse_face(F), parse_suit(S).\n\nparse_suit(S,In,Out) :- suit(S), atom_codes(S,Xs), append(Xs,Out,In).\nparse_face(F,In,Out) :- face(F), face_codes(F,Xs), append(Xs,Out,In).\n\nface_codes(F,Xs) :- number(F) -> number_codes(F,Xs) ; atom_codes(F,Xs).\n\n\n% tests\ntest(\" 2\u2665  2\u2666 2\u2663 k\u2663  q\u2666\").\ntest(\" 2\u2665  5\u2665 7\u2666 8\u2663  9\u2660\").\ntest(\" a\u2665  2\u2666 3\u2663 4\u2663  5\u2666\").\ntest(\" 2\u2665  3\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 7\u2666 7\u2663  7\u2660\").\ntest(\"10\u2665  j\u2665 q\u2665 k\u2665  a\u2665\").\ntest(\" 4\u2665  4\u2660 k\u2660 5\u2666 10\u2660\").\ntest(\" q\u2663 10\u2663 7\u2663 6\u2663  4\u2663\").\n\nrun_tests :-\n    test(Line), phrase(parse_line(Cards), Line), best_hand(Cards,H)\n  , write(Cards), write('\\t'), write(H), nl\n  .\nmain :- findall(_, run_tests, _), halt.\n"}
{"id": 418676, "name": "Poker hand analyser", "source": "Translate Haskell to Python: \n\nimport Data.Function (on)\nimport Data.List     (group, nub, any, sort, sortBy)\nimport Data.Maybe    (mapMaybe)\nimport Text.Read     (readMaybe)\n\ndata Suit = Club | Diamond | Spade | Heart deriving (Show, Eq)\n\ndata Rank = Ace | Two | Three | Four | Five | Six | Seven\n          | Eight | Nine | Ten | Jack | Queen | King\n          deriving (Show, Eq, Enum, Ord, Bounded)\n\ndata Card = Card { suit :: Suit, rank :: Rank } deriving (Show, Eq)\n\ntype Hand = [Card]\n\nconsumed = pure . (, \"\")\n\ninstance Read Suit where\n  readsPrec d s = case s of \"\u2665\" -> consumed Heart\n                            \"\u2666\" -> consumed Diamond\n                            \"\u2663\" -> consumed Spade\n                            \"\u2660\" -> consumed Club\n                            \"h\" -> consumed Heart\n                            _   -> []\n\ninstance Read Rank where\n  readsPrec d s = case s of \"a\"  -> consumed Ace\n                            \"2\"  -> consumed Two\n                            \"3\"  -> consumed Three\n                            \"4\"  -> consumed Four\n                            \"5\"  -> consumed Five\n                            \"6\"  -> consumed Six\n                            \"7\"  -> consumed Seven\n                            \"8\"  -> consumed Eight\n                            \"9\"  -> consumed Nine\n                            \"10\" -> consumed Ten\n                            \"j\"  -> consumed Jack\n                            \"q\"  -> consumed Queen\n                            \"k\"  -> consumed King\n                            _    -> []\n\ninstance Read Card where\n  readsPrec d = fmap (, \"\") . mapMaybe card . lex\n    where \n      card (r, s) = Card <$> (readMaybe s :: Maybe Suit)\n                         <*> (readMaybe r :: Maybe Rank)\n\n\nacesHigh :: [Rank]\nacesHigh = [Ace, Ten, Jack, Queen, King]\n\nisSucc :: (Enum a, Eq a, Bounded a) => [a] -> Bool\nisSucc []  = True\nisSucc [x] = True\nisSucc (x:y:zs) = (x /= maxBound && y == succ x) && isSucc (y:zs)\n\nnameHand :: Hand -> String\nnameHand [] = \"Invalid Input\"\nnameHand cards | invalidHand          = \"Invalid hand\"\n               | straight && flush    = \"Straight flush\"\n               | ofKind 4             = \"Four of a kind\"\n               | ofKind 3 && ofKind 2 = \"Full house\"\n               | flush                = \"Flush\"\n               | straight             = \"Straight\"\n               | ofKind 3             = \"Three of a kind\"\n               | uniqRanks == 3       = \"Two pair\"\n               | uniqRanks == 4       = \"One pair\"\n               | otherwise            = \"High card\"\n where\n  sortedRank  = sort $ rank <$> cards\n  rankCounts  = sortBy (compare `on` snd) $ (,) <$> head <*> length <$> group sortedRank\n  uniqRanks   = length rankCounts\n  ofKind n    = any ((==n) . snd) rankCounts\n  straight    = isSucc sortedRank || sortedRank == acesHigh\n  flush       = length (nub $ suit <$> cards) == 1\n  invalidHand = length (nub cards) /= 5\n\ntestHands :: [(String, Hand)]\ntestHands = (,) <$> id <*> mapMaybe readMaybe . words <$>\n  [ \"2\u2665 2\u2666 2\u2663 k\u2663 q\u2666\"\n  , \"2\u2665 5\u2665 7\u2666 8\u2663 9\u2660\"\n  , \"a\u2665 2\u2666 3\u2663 4\u2663 5\u2666\"\n  , \"2\u2665 3\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 2\u2666 3\u2663 3\u2666\"\n  , \"2\u2665 7\u2665 7\u2666 7\u2663 7\u2660\"\n  , \"10\u2665 j\u2665 q\u2665 k\u2665 a\u2665\"\n  , \"4\u2665 4\u2660 k\u2660 5\u2666 10\u2660\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 4\u2663\"\n  , \"q\u2663 10\u2663 7\u2663 6\u2663 7\u2663\" \n  , \"Bad input\" ]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . (fst <> const \": \" <> nameHand . snd)) testHands\n", "target": ":- initialization(main).\n\n\nfaces([a,k,q,j,10,9,8,7,6,5,4,3,2]).\n\nface(F) :- faces(Fs), member(F,Fs).\nsuit(S) :- member(S, ['\u2665','\u2666','\u2663','\u2660']).\n\n\nbest_hand(Cards,H) :-\n    straight_flush(Cards,C) -> H = straight-flush(C)\n  ; many_kind(Cards,F,4)    -> H = four-of-a-kind(F)\n  ; full_house(Cards,F1,F2) -> H = full-house(F1,F2)\n  ; flush(Cards,S)          -> H = flush(S)\n  ; straight(Cards,F)       -> H = straight(F)\n  ; many_kind(Cards,F,3)    -> H = three-of-a-kind(F)\n  ; two_pair(Cards,F1,F2)   -> H = two-pair(F1,F2)\n  ; many_kind(Cards,F,2)    -> H = one-pair(F)\n  ; many_kind(Cards,F,1)    -> H = high-card(F)\n  ;                            H = invalid\n  .\n\nstraight_flush(Cards, c(F,S)) :- straight(Cards,F), flush(Cards,S).\n\nfull_house(Cards,F1,F2) :-\n    many_kind(Cards,F1,3), many_kind(Cards,F2,2), F1 \\= F2.\n\nflush(Cards,S) :- maplist(has_suit(S), Cards).\nhas_suit(S, c(_,S)).\n\nstraight(Cards,F) :-\n    select(c(F,_), Cards, Cs), pred_face(F,F1), straight(Cs,F1).\nstraight([],_).\npred_face(F,F1) :- F = 2 -> F1 = a ; faces(Fs), append(_, [F,F1|_], Fs).\n\ntwo_pair(Cards,F1,F2) :-\n    many_kind(Cards,F1,2), many_kind(Cards,F2,2), F1 \\= F2.\n\nmany_kind(Cards,F,N) :-\n    face(F), findall(_, member(c(F,_), Cards), Xs), length(Xs,N).\n\n\n% utils/parser\nparse_line(Cards)  --> \" \", parse_line(Cards).\nparse_line([C|Cs]) --> parse_card(C), parse_line(Cs).\nparse_line([])     --> [].\n\nparse_card(c(F,S)) --> parse_face(F), parse_suit(S).\n\nparse_suit(S,In,Out) :- suit(S), atom_codes(S,Xs), append(Xs,Out,In).\nparse_face(F,In,Out) :- face(F), face_codes(F,Xs), append(Xs,Out,In).\n\nface_codes(F,Xs) :- number(F) -> number_codes(F,Xs) ; atom_codes(F,Xs).\n\n\n% tests\ntest(\" 2\u2665  2\u2666 2\u2663 k\u2663  q\u2666\").\ntest(\" 2\u2665  5\u2665 7\u2666 8\u2663  9\u2660\").\ntest(\" a\u2665  2\u2666 3\u2663 4\u2663  5\u2666\").\ntest(\" 2\u2665  3\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 2\u2666 3\u2663  3\u2666\").\ntest(\" 2\u2665  7\u2665 7\u2666 7\u2663  7\u2660\").\ntest(\"10\u2665  j\u2665 q\u2665 k\u2665  a\u2665\").\ntest(\" 4\u2665  4\u2660 k\u2660 5\u2666 10\u2660\").\ntest(\" q\u2663 10\u2663 7\u2663 6\u2663  4\u2663\").\n\nrun_tests :-\n    test(Line), phrase(parse_line(Cards), Line), best_hand(Cards,H)\n  , write(Cards), write('\\t'), write(H), nl\n  .\nmain :- findall(_, run_tests, _), halt.\n"}
{"id": 418677, "name": "Fibonacci word_fractal", "source": "Translate Haskell to Python: import Data.List (unfoldr)\nimport Data.Bool (bool)\nimport Data.Semigroup (Sum(..), Min(..), Max(..))\nimport System.IO (writeFile)\n\nfibonacciWord :: a -> a -> [[a]]\nfibonacciWord a b = unfoldr (\\(a,b) -> Just (a, (b, a <> b))) ([a], [b])\n\ntoPath :: [Bool] -> ((Min Int, Max Int, Min Int, Max Int), String)\ntoPath = foldMap (\\p -> (box p, point p)) .\n         scanl (<>) mempty .\n         scanl (\\dir (turn, s) -> bool dir (turn dir) s) (1, 0) .\n         zip (cycle [left, right])\n  where\n    box (Sum x, Sum y) = (Min x, Max x, Min y, Max y)\n    point (Sum x, Sum y) = show x ++ \",\" ++ show y ++ \" \"\n    left (x,y) = (-y, x)\n    right (x,y) = (y, -x)\n\ntoSVG :: [Bool] -> String\ntoSVG w =\n  let ((Min x1, Max x2, Min y1, Max y2), path) = toPath w\n  in unwords\n     [ \"<svg xmlns='http://www.w3.org/2000/svg'\"\n     , \"width='500' height='500'\"\n     , \"stroke='black' fill='none' strokeWidth='2'\" \n     , \"viewBox='\" ++ unwords (show <$> [x1,y1,x2-x1,y2-y1]) ++ \"'>\"\n     , \"<polyline points='\" ++ path ++ \"'/>\"\n     , \"</svg>\"]  \n\nmain = writeFile \"test.html\" $ toSVG $ fibonacciWord True False !! 21\n", "target": "from functools import wraps\nfrom turtle import *\n\ndef memoize(obj):\n    cache = obj.cache = {}\n    @wraps(obj)\n    def memoizer(*args, **kwargs):\n        key = str(args) + str(kwargs)\n        if key not in cache:\n            cache[key] = obj(*args, **kwargs)\n        return cache[key]\n    return memoizer\n\n@memoize\ndef fibonacci_word(n):\n    assert n > 0\n    if n == 1:\n        return \"1\"\n    if n == 2:\n        return \"0\"\n    return fibonacci_word(n - 1) + fibonacci_word(n - 2)\n\ndef draw_fractal(word, step):\n    for i, c in enumerate(word, 1):\n        forward(step)\n        if c == \"0\":\n            if i % 2 == 0:\n                left(90)\n            else:\n                right(90)\n\ndef main():\n    n = 25 \n    step = 1 \n    width = 1050 \n    height = 1050 \n    w = fibonacci_word(n)\n\n    setup(width=width, height=height)\n    speed(0)\n    setheading(90)\n    left(90)\n    penup()\n    forward(500)\n    right(90)\n    backward(500)\n    pendown()\n    tracer(10000)\n    hideturtle()\n\n    draw_fractal(w, step)\n\n    \n    getscreen().getcanvas().postscript(file=\"fibonacci_word_fractal.eps\")\n    exitonclick()\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418678, "name": "Penney's game", "source": "Translate Haskell to Python: import qualified Data.List as L\nimport System.IO\nimport System.Random\n\ndata CoinToss = H | T deriving (Read, Show, Eq)\n\nparseToss :: String -> [CoinToss]\nparseToss [] = []\nparseToss (s:sx)\n  | s == 'h' || s == 'H' = H : parseToss sx\n  | s == 't' || s == 'T' = T : parseToss sx\n  | otherwise = parseToss sx\n\nnotToss :: CoinToss -> CoinToss\nnotToss H = T\nnotToss T = H\n\ninstance Random CoinToss where\n  random g = let (b, gb) = random g in (if b then H else T, gb)\n  randomR = undefined\n\nprompt :: (Read a) => String -> String -> (String -> Maybe a) -> IO a\nprompt msg err parse = do\n  putStrLn msg\n  line <- getLine\n  let ans = parse line\n  case ans of\n    Nothing   -> do\n      putStrLn err\n      prompt msg err parse\n    Just ansB -> return ansB\n\nshowCat :: (Show a) => [a] -> String\nshowCat = concatMap show\n\ndata Winner = Player | CPU\n\n\nrunToss :: (RandomGen g) => [CoinToss] -> [CoinToss] -> g -> ([CoinToss], Winner)\nrunToss player cpu gen =\n  let stream = randoms gen\n      run ss@(s:sx)\n        | L.isPrefixOf player ss = player\n        | L.isPrefixOf cpu ss    = cpu\n        | otherwise              = s : run sx\n      winner = run stream\n  in if L.isSuffixOf player winner\n     then (winner, Player)\n     else (winner, CPU)\n\ngame :: (RandomGen g, Num a, Show a) => Bool -> a -> a -> g -> IO ()\ngame cpuTurn playerScore cpuScore gen = do\n  putStrLn $ \"\\nThe current score is CPU: \" ++ show cpuScore\n    ++ \", You: \" ++ show playerScore\n\n  let (genA, genB) = split gen\n      promptPlayer check =\n        prompt \"Pick 3 coin sides: \" \"Invalid input.\" $ \\s ->\n          let tosses = parseToss s in\n          if check tosses then Just tosses else Nothing\n      promptCpu x  = putStrLn $ \"I have chosen: \" ++ showCat x\n\n  (tosses, winner) <-\n    if cpuTurn\n    then do\n      let cpuChoice = take 3 $ randoms gen\n      promptCpu cpuChoice\n      playerChoice <- promptPlayer $ \\n -> n /= cpuChoice && 3 == length n\n      return $ runToss playerChoice cpuChoice genA\n    else do\n      playerChoice <- promptPlayer $ \\n -> 3 == length n\n      let cpuChoice = case playerChoice of [a,b,_] -> [notToss b, a, b]\n      promptCpu cpuChoice\n      return $ runToss playerChoice cpuChoice genA\n\n  putStrLn $ \"The sequence tossed was: \" ++ showCat tosses\n\n  case winner of\n    Player -> do\n      putStrLn \"You win!\"\n      game (not cpuTurn) (playerScore + 1) cpuScore genB\n    CPU -> do\n      putStrLn \"I win!\"\n      game (not cpuTurn) playerScore (cpuScore + 1) genB\n\nmain :: IO ()\nmain = do\n  hSetBuffering stdin LineBuffering\n  stdgen <- getStdGen\n  let (cpuFirst, genA) = random stdgen\n  game cpuFirst 0 0 genA\n", "target": "from __future__ import print_function\nimport random\nfrom time import sleep\n\nfirst = random.choice([True, False])\n\nyou = ''\nif first:\n    me = ''.join(random.sample('HT'*3, 3))\n    print('I choose first and will win on first seeing {} in the list of tosses'.format(me))\n    while len(you) != 3 or any(ch not in 'HT' for ch in you) or you == me:\n        you = input('What sequence of three Heads/Tails will you win with: ')\nelse:\n    while len(you) != 3 or any(ch not in 'HT' for ch in you):\n        you = input('After you: What sequence of three Heads/Tails will you win with: ')\n    me = ('H' if you[1] == 'T' else 'T') + you[:2]\n    print('I win on first seeing {} in the list of tosses'.format(me))\n    \nprint('Rolling:\\n  ', end='')\nrolled = ''\nwhile True:\n    rolled += random.choice('HT')\n    print(rolled[-1], end='')\n    if rolled.endswith(you):\n        print('\\n  You win!')\n        break\n    if rolled.endswith(me):\n        print('\\n  I win!')\n        break\n    sleep(1)    \n"}
{"id": 418679, "name": "Sierpinski triangle_Graphical", "source": "Translate Haskell to Python: import Diagrams.Prelude\nimport Diagrams.Backend.Cairo.CmdLine\n\ntriangle = eqTriangle # fc black # lw 0\n\nreduce t =     t\n              ===\n           (t ||| t)\n\nsierpinski = iterate reduce triangle\n\nmain = defaultMain $ sierpinski !! 7\n", "target": "\nimport turtle as t\ndef sier(n,length):\n    if n == 0:\n        return\n    for i in range(3):\n        sier(n - 1, length / 2)\n        t.fd(length)\n        t.rt(120)\n"}
{"id": 418680, "name": "Sierpinski triangle_Graphical", "source": "Translate Haskell to Python: import Diagrams.Prelude\nimport Diagrams.Backend.Cairo.CmdLine\n\ntriangle = eqTriangle # fc black # lw 0\n\nreduce t =     t\n              ===\n           (t ||| t)\n\nsierpinski = iterate reduce triangle\n\nmain = defaultMain $ sierpinski !! 7\n", "target": "\nimport turtle as t\ndef sier(n,length):\n    if n == 0:\n        return\n    for i in range(3):\n        sier(n - 1, length / 2)\n        t.fd(length)\n        t.rt(120)\n"}
{"id": 418681, "name": "Eban numbers", "source": "Translate Haskell to Python: \nimport Data.List (intercalate)\nimport Text.Printf (printf)\nimport Data.List.Split (chunksOf)\n\nisEban :: Int -> Bool\nisEban n = all (`elem` [0, 2, 4, 6]) z\n where\n  (b, r1) = n  `quotRem` (10 ^ 9)\n  (m, r2) = r1 `quotRem` (10 ^ 6)\n  (t, r3) = r2 `quotRem` (10 ^ 3)\n  z       = b : map (\\x -> if x >= 30 && x <= 66 then x `mod` 10 else x) [m, t, r3]\n\nebans = map f\n where\n  f x = (thousands x, thousands $ length $ filter isEban [1..x])\n\nthousands:: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  uncurry (printf \"eban numbers up to and including 1000: %2s\\n%s\\n\\n\") $ r [1..1000]\n  uncurry (printf \"eban numbers between 1000 and 4000: %2s\\n%s\\n\\n\") $ r [1000..4000]\n  mapM_ (uncurry (printf \"eban numbers up and including %13s: %5s\\n\")) ebanCounts\n where \n  ebanCounts = ebans [        10_000\n                     ,       100_000\n                     ,     1_000_000\n                     ,    10_000_000\n                     ,   100_000_000\n                     , 1_000_000_000 ]\n  r = ((,) <$> thousands . length <*> show) . filter isEban\n", "target": "\n\n\n\nimport inflect\nimport time\n\nbefore = time.perf_counter()\n\np = inflect.engine()\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers between 1000 and 4000 (inclusive):')\nprint(' ')\n\ncount = 0\n\nfor i in range(1000,4001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 100000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,100001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\nafter = time.perf_counter()\n\nprint(\" \")\nprint(\"Run time in seconds: \"+str(after - before))\n"}
{"id": 418682, "name": "Eban numbers", "source": "Translate Haskell to Python: \nimport Data.List (intercalate)\nimport Text.Printf (printf)\nimport Data.List.Split (chunksOf)\n\nisEban :: Int -> Bool\nisEban n = all (`elem` [0, 2, 4, 6]) z\n where\n  (b, r1) = n  `quotRem` (10 ^ 9)\n  (m, r2) = r1 `quotRem` (10 ^ 6)\n  (t, r3) = r2 `quotRem` (10 ^ 3)\n  z       = b : map (\\x -> if x >= 30 && x <= 66 then x `mod` 10 else x) [m, t, r3]\n\nebans = map f\n where\n  f x = (thousands x, thousands $ length $ filter isEban [1..x])\n\nthousands:: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  uncurry (printf \"eban numbers up to and including 1000: %2s\\n%s\\n\\n\") $ r [1..1000]\n  uncurry (printf \"eban numbers between 1000 and 4000: %2s\\n%s\\n\\n\") $ r [1000..4000]\n  mapM_ (uncurry (printf \"eban numbers up and including %13s: %5s\\n\")) ebanCounts\n where \n  ebanCounts = ebans [        10_000\n                     ,       100_000\n                     ,     1_000_000\n                     ,    10_000_000\n                     ,   100_000_000\n                     , 1_000_000_000 ]\n  r = ((,) <$> thousands . length <*> show) . filter isEban\n", "target": "\n\n\n\nimport inflect\nimport time\n\nbefore = time.perf_counter()\n\np = inflect.engine()\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers between 1000 and 4000 (inclusive):')\nprint(' ')\n\ncount = 0\n\nfor i in range(1000,4001):\n    if not 'e' in p.number_to_words(i):\n        print(str(i)+' ',end='')\n        count += 1\n        \nprint(' ')\nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 100000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,100001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 1000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,1000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\n\n\nprint(' ')\nprint('eban numbers up to and including 10000000:')\nprint(' ')\n\ncount = 0\n\nfor i in range(1,10000001):\n    if not 'e' in p.number_to_words(i):\n        count += 1\n        \nprint(' ')\nprint('count = '+str(count))\nprint(' ')\n\nafter = time.perf_counter()\n\nprint(\" \")\nprint(\"Run time in seconds: \"+str(after - before))\n"}
{"id": 418683, "name": "Mayan numerals", "source": "Translate Haskell to Python: import Data.Bool (bool)\nimport Data.List (intercalate, transpose)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (maybe)\n\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n    mayanFramed\n      <$> [ 4005,\n            8017,\n            326205,\n            886205,\n            1081439556,\n            1000000,\n            1000000000\n          ]\n\n\nmayanGlyph :: Int -> [[String]]\nmayanGlyph =\n  filter (any (not . null))\n    . transpose\n    . leftPadded\n    . flip (showIntAtBaseS 20 mayanDigit) []\n\nmayanDigit :: Int -> [String]\nmayanDigit n\n  | 0 /= n =\n    replicate (rem n 5) mayaOne :\n    concat\n      ( replicate (quot n 5) [mayaFive]\n      )\n  | otherwise = [[mayaZero]]\n\nmayanFramed :: Int -> String\nmayanFramed =\n  (\"Mayan \" <>)\n    . ( (<>) <$> show\n          <*> ( (\":\\n\\n\" <>)\n                  . wikiTable\n                    ( M.fromList\n                        [ ( \"style\",\n                            concat\n                              [ \"text-align:center;\",\n                                \"background-color:#F0EDDE;\",\n                                \"color:#605B4B;\",\n                                \"border:2px solid silver;\"\n                              ]\n                          ),\n                          (\"colwidth\", \"3em;\")\n                        ]\n                    )\n                  . mayanGlyph\n              )\n      )\n\nmayaZero, mayaOne :: Char\nmayaZero = '\\920'\nmayaOne = '\\9679'\n\nmayaFive :: String\nmayaFive = \"\\9473\\9473\"\n\n\n\n\n\n\n\n\n\nshowIntAtBaseS ::\n  Integral a =>\n  a ->\n  (Int -> [String]) ->\n  a ->\n  [[String]] ->\n  [[String]]\nshowIntAtBaseS base toStr n0 r0 =\n  let go (n, d) r =\n        seq s $\n          case n of\n            0 -> r_\n            _ -> go (quotRem n base) r_\n        where\n          s = toStr (fromIntegral d)\n          r_ = s : r\n   in go (quotRem n0 base) r0\n\n\nwikiTable :: M.Map String String -> [[String]] -> String\nwikiTable opts rows\n  | null rows = []\n  | otherwise =\n    \"{| \"\n      <> foldr\n        ( \\k a ->\n            maybe\n              a\n              ( ((a <> k <> \"=\\\"\") <>)\n                  . ( <> \"\\\" \"\n                    )\n              )\n              (M.lookup k opts)\n        )\n        []\n        [\"class\", \"style\"]\n      <> ( '\\n' :\n           intercalate\n             \"|-\\n\"\n             ( zipWith renderedRow rows [0 ..]\n             )\n         )\n      <> \"|}\\n\\n\"\n  where\n    renderedRow row i =\n      unlines\n        ( fmap\n            ( ( bool\n                  []\n                  ( maybe\n                      \"|\"\n                      ((\"|style=\\\"width:\" <>) . (<> \"\\\"\"))\n                      (M.lookup \"colwidth\" opts)\n                  )\n                  (0 == i)\n                  <>\n              )\n                . ('|' :)\n            )\n            row\n        )\n\nleftPadded :: [[String]] -> [[String]]\nleftPadded xs =\n  let w = maximum (length <$> xs)\n   in ((<>) =<< flip replicate [] . (-) w . length) <$> xs\n", "target": "\n\nfrom functools import (reduce)\n\n\n\n\n\ndef mayanNumerals(n):\n    \n    return showIntAtBase(20)(\n        mayanDigit\n    )(n)([])\n\n\n\ndef mayanDigit(n):\n    \n    if 0 < n:\n        r = n % 5\n        return [\n            (['\u25cf' * r] if 0 < r else []) +\n            (['\u2501\u2501'] * (n // 5))\n        ]\n    else:\n        return ['\u0398']\n\n\n\ndef mayanFramed(n):\n    \n    return 'Mayan ' + str(n) + ':\\n\\n' + (\n        wikiTable({\n            'class': 'wikitable',\n            'style': cssFromDict({\n                'text-align': 'center',\n                'background-color': '\n                'color': '\n                'border': '2px solid silver'\n            }),\n            'colwidth': '3em',\n            'cell': 'vertical-align: bottom;'\n        })([[\n            '<br>'.join(col) for col in mayanNumerals(n)\n        ]])\n    )\n\n\n\n\n\ndef main():\n    \n    print(\n        main.__doc__ + ':\\n\\n' +\n        '\\n'.join(mayanFramed(n) for n in [\n            4005, 8017, 326205, 886205, 1081439556,\n            1000000, 1000000000\n        ])\n    )\n\n\n\n\n\ndef wikiTable(opts):\n    \n    def colWidth():\n        return 'width:' + opts['colwidth'] + '; ' if (\n            'colwidth' in opts\n        ) else ''\n\n    def cellStyle():\n        return opts['cell'] if 'cell' in opts else ''\n\n    return lambda rows: '{| ' + reduce(\n        lambda a, k: (\n            a + k + '=\"' + opts[k] + '\" ' if (\n                k in opts\n            ) else a\n        ),\n        ['class', 'style'],\n        ''\n    ) + '\\n' + '\\n|-\\n'.join(\n        '\\n'.join(\n            ('|' if (\n                0 != i and ('cell' not in opts)\n            ) else (\n                '|style=\"' + colWidth() + cellStyle() + '\"|'\n            )) + (\n                str(x) or ' '\n            ) for x in row\n        ) for i, row in enumerate(rows)\n    ) + '\\n|}\\n\\n'\n\n\n\n\n\ndef cssFromDict(dct):\n    \n    return reduce(\n        lambda a, k: a + k + ':' + dct[k] + '; ',\n        dct.keys(),\n        ''\n    )\n\n\n\n\ndef showIntAtBase(base):\n    \n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0 != n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418684, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Haskell to Python: import Control.Monad ((>=>))\nimport Data.Maybe (mapMaybe)\nimport System.Environment (getArgs)\n\n\n\ntryFor :: Int -> Int -> Maybe Int\ntryFor s = foldr (>=>) pure $ replicate s step\n  where\n    step n\n      | n `mod` (s - 1) == 0 = Just $ n * s `div` (s - 1) + 1\n      | otherwise = Nothing\n\n\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let n =\n        case args of\n          [] -> 5\n          s:_ -> read s\n      a = head . mapMaybe (tryFor n) $ [n,2 * n ..]\n  print a\n", "target": "def monkey_coconuts(sailors=5):\n    \"Parameterised the number of sailors using an inner loop including the last mornings case\"    \n    nuts = sailors\n    while True:\n        n0, wakes = nuts, []\n        for sailor in range(sailors + 1):\n            portion, remainder = divmod(n0, sailors)\n            wakes.append((n0, portion, remainder))\n            if portion <= 0 or remainder != (1 if sailor != sailors else 0):\n                nuts += 1\n                break\n            n0 = n0 - portion - remainder\n        else:\n            break\n    return nuts, wakes\n\nif __name__ == \"__main__\":\n    for sailors in [5, 6]:\n        nuts, wake_stats = monkey_coconuts(sailors)\n        print(\"\\nFor %i sailors the initial nut count is %i\" % (sailors, nuts))\n        print(\"On each waking, the nut count, portion taken, and monkeys share are:\\n \", \n              ',\\n  '.join(repr(ws) for ws in wake_stats))\n"}
{"id": 418685, "name": "Sailors, coconuts and a monkey problem", "source": "Translate Haskell to Python: import Control.Monad ((>=>))\nimport Data.Maybe (mapMaybe)\nimport System.Environment (getArgs)\n\n\n\ntryFor :: Int -> Int -> Maybe Int\ntryFor s = foldr (>=>) pure $ replicate s step\n  where\n    step n\n      | n `mod` (s - 1) == 0 = Just $ n * s `div` (s - 1) + 1\n      | otherwise = Nothing\n\n\n\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let n =\n        case args of\n          [] -> 5\n          s:_ -> read s\n      a = head . mapMaybe (tryFor n) $ [n,2 * n ..]\n  print a\n", "target": "def monkey_coconuts(sailors=5):\n    \"Parameterised the number of sailors using an inner loop including the last mornings case\"    \n    nuts = sailors\n    while True:\n        n0, wakes = nuts, []\n        for sailor in range(sailors + 1):\n            portion, remainder = divmod(n0, sailors)\n            wakes.append((n0, portion, remainder))\n            if portion <= 0 or remainder != (1 if sailor != sailors else 0):\n                nuts += 1\n                break\n            n0 = n0 - portion - remainder\n        else:\n            break\n    return nuts, wakes\n\nif __name__ == \"__main__\":\n    for sailors in [5, 6]:\n        nuts, wake_stats = monkey_coconuts(sailors)\n        print(\"\\nFor %i sailors the initial nut count is %i\" % (sailors, nuts))\n        print(\"On each waking, the nut count, portion taken, and monkeys share are:\\n \", \n              ',\\n  '.join(repr(ws) for ws in wake_stats))\n"}
{"id": 418686, "name": "Nautical bell", "source": "Translate Haskell to Python: import Control.Concurrent\nimport Control.Monad\nimport Data.Time\nimport Text.Printf\n\ntype Microsecond = Int\ntype Scheduler = TimeOfDay -> Microsecond\n\n\n\n\ngetTime :: TimeZone -> IO TimeOfDay\ngetTime tz = do\n    t  <- getCurrentTime\n    return $ localTimeOfDay $ utcToLocalTime tz t\n\ngetGMTTime   = getTime utc\ngetLocalTime = getCurrentTimeZone >>= getTime\n\n\nnextInterval x y\n    | x > y = x - y\n    | mod y x > 0 = x - mod y x\n    | otherwise = 0\n\n\nonInterval :: Int -> Scheduler\nonInterval interval time = toNext dMS\n  where\n    toNext = nextInterval (1000000 * interval)\n    tDelta = timeOfDayToTime time\n    dMS    = truncate $ 1000000 * tDelta\n\ndoWithScheduler :: Scheduler -> (Int -> IO ()) -> IO ThreadId\ndoWithScheduler sched task = forkIO $ forM_ [0..] exec\n  where\n    exec n = do\n        t <- getLocalTime\n        threadDelay $ sched t\n        task n\n\n\n\n\nwatchNames = words \"Middle Morning Forenoon Afternoon Dog First\"\ncountWords = words \"One Two Three Four Five Six Seven Eight\"\n\n\npostDelay n fn = fn >> threadDelay n\n\ntermBell        = putStr \"\\a\"\ntermBells n     = replicateM_ n $ postDelay 100000 termBell\ntermBellSeq seq = forM_ seq $ postDelay 500000 . termBells\n\ntoNoteGlyph 1 = \"\u266a\"\ntoNoteGlyph 2 = \"\u266b\"\ntoNoteGlyph _ = \"\"\n\nringBells :: Int -> IO ()\nringBells n = do\n    t <- getLocalTime\n    let numBells    = 1 + (mod n 8)\n        watch       = watchNames!!(mod (div n 8) 8)\n        count       = countWords!!(numBells - 1)\n        (twos,ones) = quotRem numBells 2\n        pattern     = (replicate twos 2) ++ (replicate ones 1)\n        notes       = unwords $ map toNoteGlyph pattern\n        plural       = if numBells > 1 then \"s\" else \"\"\n        strFMT      = show t ++ \": %s watch, %5s bell%s:  \" ++ notes ++ \"\\n\"\n    printf strFMT watch count plural\n    termBellSeq pattern\n\n\n\n\nbellRinger :: IO ThreadId\nbellRinger = doWithScheduler (onInterval (30*60)) ringBells\n", "target": "import time, calendar, sched, winsound\n\nduration = 750      \nfreq = 1280         \nbellchar = \"\\u2407\"\nwatches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',')\n\ndef gap(n=1):\n    time.sleep(n * duration / 1000)\noff = gap\n \ndef on(n=1):\n    winsound.Beep(freq, n * duration)\n \ndef bong():\n    on(); off(0.5)\n\ndef bongs(m):\n    for i in range(m):\n        print(bellchar, end=' ')\n        bong()\n        if i % 2:\n            print('  ', end='')\n            off(0.5)\n    print('')\n        \nscheds =  sched.scheduler(time.time, time.sleep)\n\ndef ships_bell(now=None):\n    def adjust_to_half_hour(atime):\n        atime[4] = (atime[4] // 30) * 30\n        atime[5] = 0\n        return atime\n\n    debug = now is not None\n    rightnow = time.gmtime()\n    if not debug:\n        now = adjust_to_half_hour( list(rightnow) )\n    then = now[::]\n    then[4] += 30\n    hr, mn = now[3:5]\n    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)\n    b += 1\n    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')\n    if debug:\n        print(\"%02i:%02i, %-20s %s\" % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')\n    else:\n        print(\"%02i:%02i, %-20s %s\" % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')\n    bongs(b)\n    if not debug:\n        scheds.enterabs(calendar.timegm(then), 0, ships_bell)\n        \n        scheds.run()\n\ndef dbg_tester():\n    for h in range(24):\n        for m in (0, 30):\n            if (h,m) == (24,30): break\n            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )\n        \n    \nif __name__ == '__main__':\n    ships_bell()\n"}
{"id": 418687, "name": "Nautical bell", "source": "Translate Haskell to Python: import Control.Concurrent\nimport Control.Monad\nimport Data.Time\nimport Text.Printf\n\ntype Microsecond = Int\ntype Scheduler = TimeOfDay -> Microsecond\n\n\n\n\ngetTime :: TimeZone -> IO TimeOfDay\ngetTime tz = do\n    t  <- getCurrentTime\n    return $ localTimeOfDay $ utcToLocalTime tz t\n\ngetGMTTime   = getTime utc\ngetLocalTime = getCurrentTimeZone >>= getTime\n\n\nnextInterval x y\n    | x > y = x - y\n    | mod y x > 0 = x - mod y x\n    | otherwise = 0\n\n\nonInterval :: Int -> Scheduler\nonInterval interval time = toNext dMS\n  where\n    toNext = nextInterval (1000000 * interval)\n    tDelta = timeOfDayToTime time\n    dMS    = truncate $ 1000000 * tDelta\n\ndoWithScheduler :: Scheduler -> (Int -> IO ()) -> IO ThreadId\ndoWithScheduler sched task = forkIO $ forM_ [0..] exec\n  where\n    exec n = do\n        t <- getLocalTime\n        threadDelay $ sched t\n        task n\n\n\n\n\nwatchNames = words \"Middle Morning Forenoon Afternoon Dog First\"\ncountWords = words \"One Two Three Four Five Six Seven Eight\"\n\n\npostDelay n fn = fn >> threadDelay n\n\ntermBell        = putStr \"\\a\"\ntermBells n     = replicateM_ n $ postDelay 100000 termBell\ntermBellSeq seq = forM_ seq $ postDelay 500000 . termBells\n\ntoNoteGlyph 1 = \"\u266a\"\ntoNoteGlyph 2 = \"\u266b\"\ntoNoteGlyph _ = \"\"\n\nringBells :: Int -> IO ()\nringBells n = do\n    t <- getLocalTime\n    let numBells    = 1 + (mod n 8)\n        watch       = watchNames!!(mod (div n 8) 8)\n        count       = countWords!!(numBells - 1)\n        (twos,ones) = quotRem numBells 2\n        pattern     = (replicate twos 2) ++ (replicate ones 1)\n        notes       = unwords $ map toNoteGlyph pattern\n        plural       = if numBells > 1 then \"s\" else \"\"\n        strFMT      = show t ++ \": %s watch, %5s bell%s:  \" ++ notes ++ \"\\n\"\n    printf strFMT watch count plural\n    termBellSeq pattern\n\n\n\n\nbellRinger :: IO ThreadId\nbellRinger = doWithScheduler (onInterval (30*60)) ringBells\n", "target": "import time, calendar, sched, winsound\n\nduration = 750      \nfreq = 1280         \nbellchar = \"\\u2407\"\nwatches = 'Middle,Morning,Forenoon,Afternoon,First/Last dog,First'.split(',')\n\ndef gap(n=1):\n    time.sleep(n * duration / 1000)\noff = gap\n \ndef on(n=1):\n    winsound.Beep(freq, n * duration)\n \ndef bong():\n    on(); off(0.5)\n\ndef bongs(m):\n    for i in range(m):\n        print(bellchar, end=' ')\n        bong()\n        if i % 2:\n            print('  ', end='')\n            off(0.5)\n    print('')\n        \nscheds =  sched.scheduler(time.time, time.sleep)\n\ndef ships_bell(now=None):\n    def adjust_to_half_hour(atime):\n        atime[4] = (atime[4] // 30) * 30\n        atime[5] = 0\n        return atime\n\n    debug = now is not None\n    rightnow = time.gmtime()\n    if not debug:\n        now = adjust_to_half_hour( list(rightnow) )\n    then = now[::]\n    then[4] += 30\n    hr, mn = now[3:5]\n    watch, b = divmod(int(2 * hr + mn // 30 - 1), 8)\n    b += 1\n    bells = '%i bell%s' % (b, 's' if b > 1 else ' ')\n    if debug:\n        print(\"%02i:%02i, %-20s %s\" % (now[3], now[4], watches[watch] + ' watch', bells), end=' ')\n    else:\n        print(\"%02i:%02i, %-20s %s\" % (rightnow[3], rightnow[4], watches[watch] + ' watch', bells), end=' ')\n    bongs(b)\n    if not debug:\n        scheds.enterabs(calendar.timegm(then), 0, ships_bell)\n        \n        scheds.run()\n\ndef dbg_tester():\n    for h in range(24):\n        for m in (0, 30):\n            if (h,m) == (24,30): break\n            ships_bell( [2013, 3, 2, h, m, 15, 5, 61, 0] )\n        \n    \nif __name__ == '__main__':\n    ships_bell()\n"}
{"id": 418688, "name": "Polyspiral", "source": "Translate Haskell to Python: \nimport Reflex\nimport Reflex.Dom\nimport Reflex.Dom.Time\nimport Data.Text (Text, pack) \nimport Data.Map (Map, fromList)\nimport Data.Time.Clock (getCurrentTime)\nimport Control.Monad.Trans (liftIO)\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\nmain = mainWidget $ do \n\n  \n  dTick <- tickLossy 0.05 =<< liftIO getCurrentTime \n\n  \n  dCounter <- foldDyn (\\_ c -> c+1) (0::Int) dTick\n\n  let \n      \n      dAngle = fmap (\\c -> fromIntegral c / 800.0) dCounter\n\n      \n      dSpiralMap = fmap toSpiralMap dAngle\n\n      \n      width = 600\n      height = 600\n\n      boardAttrs = \n         fromList [ (\"width\" , pack $ show width)\n                  , (\"height\", pack $ show height)\n                  , (\"viewBox\", pack $ show (-width/2) ++ \" \" ++ show (-height/2) ++ \" \" ++ show width ++ \" \" ++ show height)\n                  ]\n\n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Polyspiral\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Polyspiral#Haskell\") $ text \"Rosetta Code / Polyspiral / Haskell\"\n\n  el \"br\" $ return ()\n  elSvgns \"svg\" (constDyn boardAttrs) (listWithKey dSpiralMap showLine)\n\n  return ()\n\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n  fromList [ ( \"x1\",    pack $ show x1)\n           , ( \"y1\",    pack $ show y1)\n           , ( \"x2\",    pack $ show x2)\n           , ( \"y2\",    pack $ show y2)\n           , ( \"style\", \"stroke:blue\")\n           ]    \n\n\nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n\n\nadvance :: Float -> (Point, Float, Float) -> (Point, Float, Float)\nadvance angle ((x,y), len, rot) = \n  let new_x = x + len * cos rot\n      new_y = y + len * sin rot\n      new_len = len + 3.0 \n      new_rot = rot + angle\n  in ((new_x, new_y), new_len, new_rot)\n\n\ntoSpiralMap :: Float -> Map Int ((Float,Float),(Float,Float))\ntoSpiralMap angle =\n      fromList                       \n  $   zip [0..]                      \n  $   (\\pts -> zip pts $ tail pts)   \n  $   take 80                        \n  $   (\\(pt,_,_) -> pt)              \n  <$> iterate (advance angle) ((0, 0), 0, 0)  \n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "import math\n\nimport pygame\nfrom pygame.locals import *\n\npygame.init()\nscreen = pygame.display.set_mode((1024, 600))\n\npygame.display.set_caption(\"Polyspiral\")\n\nincr = 0\n\nrunning = True\n\nwhile running:\n\tpygame.time.Clock().tick(60)\n\tfor event in pygame.event.get():\n\t\tif event.type==QUIT:\n\t\t\trunning = False\n\t\t\tbreak\n\n\tincr = (incr + 0.05) % 360\n\tx1 = pygame.display.Info().current_w / 2\n\ty1 = pygame.display.Info().current_h / 2\n\tlength = 5\n\tangle = incr\n\n\tscreen.fill((255,255,255))\n\n\tfor i in range(1,151):\n\t\tx2 = x1 + math.cos(angle) * length\n\t\ty2 = y1 + math.sin(angle) * length\n\t\tpygame.draw.line(screen, (255,0,0), (x1, y1), (x2, y2), 1)\n\t\t\n\t\tx1, y1 = x2, y2\n\t\tlength += 3\n\t\tangle = (angle + incr) % 360\n\n\tpygame.display.flip()\n"}
{"id": 418689, "name": "Polyspiral", "source": "Translate Haskell to Python: \nimport Reflex\nimport Reflex.Dom\nimport Reflex.Dom.Time\nimport Data.Text (Text, pack) \nimport Data.Map (Map, fromList)\nimport Data.Time.Clock (getCurrentTime)\nimport Control.Monad.Trans (liftIO)\n\ntype Point = (Float,Float)\ntype Segment = (Point,Point)\n\nmain = mainWidget $ do \n\n  \n  dTick <- tickLossy 0.05 =<< liftIO getCurrentTime \n\n  \n  dCounter <- foldDyn (\\_ c -> c+1) (0::Int) dTick\n\n  let \n      \n      dAngle = fmap (\\c -> fromIntegral c / 800.0) dCounter\n\n      \n      dSpiralMap = fmap toSpiralMap dAngle\n\n      \n      width = 600\n      height = 600\n\n      boardAttrs = \n         fromList [ (\"width\" , pack $ show width)\n                  , (\"height\", pack $ show height)\n                  , (\"viewBox\", pack $ show (-width/2) ++ \" \" ++ show (-height/2) ++ \" \" ++ show width ++ \" \" ++ show height)\n                  ]\n\n  elAttr \"h1\" (\"style\" =: \"color:black\") $ text \"Polyspiral\" \n  elAttr \"a\" (\"href\" =: \"http://rosettacode.org/wiki/Polyspiral#Haskell\") $ text \"Rosetta Code / Polyspiral / Haskell\"\n\n  el \"br\" $ return ()\n  elSvgns \"svg\" (constDyn boardAttrs) (listWithKey dSpiralMap showLine)\n\n  return ()\n\n\nlineAttrs :: Segment -> Map Text Text\nlineAttrs ((x1,y1), (x2,y2)) =\n  fromList [ ( \"x1\",    pack $ show x1)\n           , ( \"y1\",    pack $ show y1)\n           , ( \"x2\",    pack $ show x2)\n           , ( \"y2\",    pack $ show y2)\n           , ( \"style\", \"stroke:blue\")\n           ]    \n\n\nshowLine :: MonadWidget t m => Int -> Dynamic t Segment -> m ()\nshowLine _ dSegment = elSvgns \"line\" (lineAttrs <$> dSegment) $ return ()\n\n\nadvance :: Float -> (Point, Float, Float) -> (Point, Float, Float)\nadvance angle ((x,y), len, rot) = \n  let new_x = x + len * cos rot\n      new_y = y + len * sin rot\n      new_len = len + 3.0 \n      new_rot = rot + angle\n  in ((new_x, new_y), new_len, new_rot)\n\n\ntoSpiralMap :: Float -> Map Int ((Float,Float),(Float,Float))\ntoSpiralMap angle =\n      fromList                       \n  $   zip [0..]                      \n  $   (\\pts -> zip pts $ tail pts)   \n  $   take 80                        \n  $   (\\(pt,_,_) -> pt)              \n  <$> iterate (advance angle) ((0, 0), 0, 0)  \n\n\nelSvgns :: MonadWidget t m => Text -> Dynamic t (Map Text Text) -> m a -> m a\nelSvgns t m ma = do\n    (el, val) <- elDynAttrNS' (Just \"http://www.w3.org/2000/svg\") t m ma\n    return val\n", "target": "import math\n\nimport pygame\nfrom pygame.locals import *\n\npygame.init()\nscreen = pygame.display.set_mode((1024, 600))\n\npygame.display.set_caption(\"Polyspiral\")\n\nincr = 0\n\nrunning = True\n\nwhile running:\n\tpygame.time.Clock().tick(60)\n\tfor event in pygame.event.get():\n\t\tif event.type==QUIT:\n\t\t\trunning = False\n\t\t\tbreak\n\n\tincr = (incr + 0.05) % 360\n\tx1 = pygame.display.Info().current_w / 2\n\ty1 = pygame.display.Info().current_h / 2\n\tlength = 5\n\tangle = incr\n\n\tscreen.fill((255,255,255))\n\n\tfor i in range(1,151):\n\t\tx2 = x1 + math.cos(angle) * length\n\t\ty2 = y1 + math.sin(angle) * length\n\t\tpygame.draw.line(screen, (255,0,0), (x1, y1), (x2, y2), 1)\n\t\t\n\t\tx1, y1 = x2, y2\n\t\tlength += 3\n\t\tangle = (angle + incr) % 360\n\n\tpygame.display.flip()\n"}
{"id": 418690, "name": "Merge and aggregate datasets", "source": "Translate Haskell to Python: import Data.List\nimport Data.Maybe\nimport System.IO (readFile)\nimport Text.Read (readMaybe)\nimport Control.Applicative ((<|>))\n\n\n\nnewtype DB = DB { entries :: [Patient] }\n  deriving Show\n\ninstance Semigroup DB where\n  DB a <> DB b = normalize $ a <> b\n\ninstance Monoid DB where\n  mempty = DB []\n\nnormalize :: [Patient] -> DB\nnormalize = DB\n            . map mconcat \n            . groupBy (\\x y -> pid x == pid y)\n            . sortOn pid\n \n\n\ndata Patient = Patient { pid :: String\n                       , name :: Maybe String\n                       , visits :: [String]\n                       , scores :: [Float] }\n  deriving Show\n\ninstance Semigroup Patient where\n  Patient p1 n1 v1 s1 <> Patient p2 n2 v2 s2 =\n    Patient (fromJust $ Just p1 <|> Just p2)\n            (n1 <|> n2)\n            (v1 <|> v2)\n            (s1 <|> s2)\n\ninstance Monoid Patient where\n  mempty = Patient mempty mempty mempty mempty\n    \n\n\nreadDB :: String  -> DB\nreadDB = normalize\n         . mapMaybe readPatient\n         . readCSV\n\nreadPatient r = do\n  i <- lookup \"PATIENT_ID\" r\n  let n = lookup \"LASTNAME\" r\n  let d = lookup \"VISIT_DATE\" r >>= readDate\n  let s = lookup \"SCORE\" r >>= readMaybe\n  return $ Patient i n (maybeToList d) (maybeToList s)\n  where\n    readDate [] = Nothing\n    readDate d = Just d\n\nreadCSV :: String -> [(String, String)]\nreadCSV txt = zip header <$> body\n  where\n    header:body = splitBy ',' <$> lines txt\n    splitBy ch = unfoldr go\n      where\n        go [] = Nothing\n        go s  = Just $ drop 1 <$> span (/= ch) s\n", "target": "\n\n\nimport pandas as pd\n\n\ndf_patients = pd.read_csv (r'patients.csv', sep = \",\", decimal=\".\")\ndf_visits = pd.read_csv (r'visits.csv', sep = \",\", decimal=\".\")\n\n\n\n\ndf_visits['VISIT_DATE'] = pd.to_datetime(df_visits['VISIT_DATE'])\n\n\ndf_merge = df_patients.merge(df_visits, on='PATIENT_ID', how='left')\n\n\ndf_group = df_merge.groupby(['PATIENT_ID','LASTNAME'], as_index=False)\n\n\ndf_result = df_group.agg({'VISIT_DATE': 'max', 'SCORE': [lambda x: x.sum(min_count=1),'mean']})\n\nprint(df_result)\n"}
{"id": 418691, "name": "Voronoi diagram", "source": "Translate Haskell to Python: \n\nmodule Main where\n\nimport System.Random\n\nimport Data.Word\nimport Data.Array.Repa as Repa\nimport Data.Array.Repa.IO.BMP\n\n    \nsqDistance :: Word32 -> Word32 -> Word32 -> Word32 -> Word32\nsqDistance !x1 !y1 !x2 !y2 = ((x1-x2)^2) + ((y1-y2)^2)\n\ncenters :: Int -> Int -> Array U DIM2 Word32\ncenters nCenters nCells =\n    fromListUnboxed (Z :. nCenters :. 2) $ take (2*nCenters) $ randomRs (0, fromIntegral nCells) (mkStdGen 1)\n\napplyReduce2 arr f = \n    traverse arr (\\(i :. j) -> i) $ \\lookup (Z:.i) ->\n        f (lookup (Z:.i:.0)) (lookup (Z:.i:.1))\n\nminimize1D arr = foldS f h t\n  where\n    indexed arr = traverse arr id (\\src idx@(Z :. i) -> (src idx, (fromIntegral i)))        \n    (Z :. n) = extent arr\n    iarr = indexed arr\n    h = iarr ! (Z :. 0)\n    t = extract (Z :. 1) (Z :. (n-1)) iarr\n\n    f min@(!valMin, !iMin ) x@(!val, !i) | val < valMin = x\n                                         | otherwise = min\n\nvoronoi :: Int -> Int -> Array D DIM2 Word32\nvoronoi nCenters nCells =\n    let\n      \n      cellReducer = applyReduce2 (centers nCenters nCells)\n      \n      nearestCenterIndex = snd . (Repa.! Z) . minimize1D\n    in        \n      Repa.fromFunction (Z :. nCells :. nCells :: DIM2) $ \\ (Z:.i:.j) ->\n          nearestCenterIndex $ cellReducer (sqDistance (fromIntegral i) (fromIntegral j))\n\ngenColorTable :: Int -> Array U DIM1 (Word8, Word8, Word8)\ngenColorTable n = fromListUnboxed (Z :. n) $ zip3 l1 l2 l3\n    where\n      randoms = randomRs (0,255) (mkStdGen 1)\n      (l1, rest1) = splitAt n randoms\n      (l2, rest2) = splitAt n rest1\n      l3 = take n rest2\n\ncolorize :: Array U DIM1 (Word8, Word8, Word8) -> Array D DIM2 Word32 -> Array D DIM2 (Word8, Word8, Word8)\ncolorize ctable = Repa.map $ \\x -> ctable Repa.! (Z:. fromIntegral x)\n\nmain = do\n  let nsites = 150\n  let ctable = genColorTable nsites \n  voro <- computeP $ colorize ctable (voronoi nsites 512) :: IO (Array U DIM2 (Word8, Word8, Word8))\n  writeImageToBMP \"out.bmp\" voro\n", "target": "def setup():\n    size(500, 500)\n    generate_voronoi_diagram(width, height, 25)\n    saveFrame(\"VoronoiDiagram.png\")\n\ndef generate_voronoi_diagram(w, h, num_cells):\n    nx, ny, nr, ng, nb = [], [], [], [], [] \n    for i in range(num_cells):\n        nx.append(int(random(w)))\n        ny.append(int(random(h)))\n        nr.append(int(random(256)))\n        ng.append(int(random(256)))\n        nb.append(int(random(256)))\n    for y in range(h):\n        for x in range(w):\n            dmin = dist(0, 0, w - 1, h - 1)\n            j = -1\n            for i in range(num_cells):\n                d = dist(0, 0, nx[i] - x, ny[i] - y)\n                if d < dmin:\n                    dmin = d\n                    j = i\n            set(x, y, color(nr[j], ng[j], nb[j]))\n"}
{"id": 418692, "name": "Voronoi diagram", "source": "Translate Haskell to Python: \n\nmodule Main where\n\nimport System.Random\n\nimport Data.Word\nimport Data.Array.Repa as Repa\nimport Data.Array.Repa.IO.BMP\n\n    \nsqDistance :: Word32 -> Word32 -> Word32 -> Word32 -> Word32\nsqDistance !x1 !y1 !x2 !y2 = ((x1-x2)^2) + ((y1-y2)^2)\n\ncenters :: Int -> Int -> Array U DIM2 Word32\ncenters nCenters nCells =\n    fromListUnboxed (Z :. nCenters :. 2) $ take (2*nCenters) $ randomRs (0, fromIntegral nCells) (mkStdGen 1)\n\napplyReduce2 arr f = \n    traverse arr (\\(i :. j) -> i) $ \\lookup (Z:.i) ->\n        f (lookup (Z:.i:.0)) (lookup (Z:.i:.1))\n\nminimize1D arr = foldS f h t\n  where\n    indexed arr = traverse arr id (\\src idx@(Z :. i) -> (src idx, (fromIntegral i)))        \n    (Z :. n) = extent arr\n    iarr = indexed arr\n    h = iarr ! (Z :. 0)\n    t = extract (Z :. 1) (Z :. (n-1)) iarr\n\n    f min@(!valMin, !iMin ) x@(!val, !i) | val < valMin = x\n                                         | otherwise = min\n\nvoronoi :: Int -> Int -> Array D DIM2 Word32\nvoronoi nCenters nCells =\n    let\n      \n      cellReducer = applyReduce2 (centers nCenters nCells)\n      \n      nearestCenterIndex = snd . (Repa.! Z) . minimize1D\n    in        \n      Repa.fromFunction (Z :. nCells :. nCells :: DIM2) $ \\ (Z:.i:.j) ->\n          nearestCenterIndex $ cellReducer (sqDistance (fromIntegral i) (fromIntegral j))\n\ngenColorTable :: Int -> Array U DIM1 (Word8, Word8, Word8)\ngenColorTable n = fromListUnboxed (Z :. n) $ zip3 l1 l2 l3\n    where\n      randoms = randomRs (0,255) (mkStdGen 1)\n      (l1, rest1) = splitAt n randoms\n      (l2, rest2) = splitAt n rest1\n      l3 = take n rest2\n\ncolorize :: Array U DIM1 (Word8, Word8, Word8) -> Array D DIM2 Word32 -> Array D DIM2 (Word8, Word8, Word8)\ncolorize ctable = Repa.map $ \\x -> ctable Repa.! (Z:. fromIntegral x)\n\nmain = do\n  let nsites = 150\n  let ctable = genColorTable nsites \n  voro <- computeP $ colorize ctable (voronoi nsites 512) :: IO (Array U DIM2 (Word8, Word8, Word8))\n  writeImageToBMP \"out.bmp\" voro\n", "target": "def setup():\n    size(500, 500)\n    generate_voronoi_diagram(width, height, 25)\n    saveFrame(\"VoronoiDiagram.png\")\n\ndef generate_voronoi_diagram(w, h, num_cells):\n    nx, ny, nr, ng, nb = [], [], [], [], [] \n    for i in range(num_cells):\n        nx.append(int(random(w)))\n        ny.append(int(random(h)))\n        nr.append(int(random(256)))\n        ng.append(int(random(256)))\n        nb.append(int(random(256)))\n    for y in range(h):\n        for x in range(w):\n            dmin = dist(0, 0, w - 1, h - 1)\n            j = -1\n            for i in range(num_cells):\n                d = dist(0, 0, nx[i] - x, ny[i] - y)\n                if d < dmin:\n                    dmin = d\n                    j = i\n            set(x, y, color(nr[j], ng[j], nb[j]))\n"}
{"id": 418693, "name": "Active Directory_Connect", "source": "Translate Haskell to Python: \n\nmodule Main (main) where\n\nimport           Data.Foldable (for_)\nimport qualified Data.Text.Encoding as Text (encodeUtf8)\nimport           Ldap.Client (Attr(..), Filter(..))\nimport qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly)\n\nmain :: IO ()\nmain = do\n    entries <- Ldap.with (Ldap.Plain \"localhost\") 389 $ \\ldap ->\n        Ldap.search ldap (Ldap.Dn \"o=example.com\") (Ldap.typesOnly True) (Attr \"uid\" := Text.encodeUtf8 \"user\") []\n    for_ entries $ \\entry ->\n        print entry\n", "target": "import ldap\n\nl = ldap.initialize(\"ldap://ldap.example.com\")\ntry:\n    l.protocol_version = ldap.VERSION3\n    l.set_option(ldap.OPT_REFERRALS, 0)\n\n    bind = l.simple_bind_s(\"me@example.com\", \"password\")\nfinally:\n    l.unbind()\n"}
{"id": 418694, "name": "Knapsack problem_Bounded", "source": "Translate Haskell to Python: inv = \t[(\"map\",9,150,1), (\"compass\",13,35,1), (\"water\",153,200,2), (\"sandwich\",50,60,2),\n\t(\"glucose\",15,60,2), (\"tin\",68,45,3), (\"banana\",27,60,3), (\"apple\",39,40,3),\n\t(\"cheese\",23,30,1), (\"beer\",52,10,3), (\"cream\",11,70,1), (\"camera\",32,30,1),\n\t\n\t(\"tshirt\",24,15,2), (\"trousers\",48,10,2), (\"umbrella\",73,40,1), (\"wtrousers\",42,70,1),\n\t(\"woverclothes\",43,75,1), (\"notecase\",22,80,1), (\"sunglasses\",7,20,1), (\"towel\",18,12,2),\n\t(\"socks\",4,50,1), (\"book\",30,10,2)]\n\nknapsack = foldr addItem (repeat (0,[])) where\n\taddItem (name,w,v,c) old = foldr inc old [1..c] where\n\t\tinc i list = left ++ zipWith max right new where\n\t\t\t(left, right) = splitAt (w * i) list\n\t\t\tnew = map (\\(val,itms)->(val + v * i, (name,i):itms)) old\n\nmain = print $ (knapsack inv) !! 400\n", "target": "\n\nimport strformat\nimport tables\n\n\ntype Item = tuple[name: string; weight, value, pieces: int]\n\n\nconst Items: seq[Item] = @[(\"map\", 9, 150, 1),\n                           (\"compass\", 13, 35, 1),\n                           (\"water\", 153, 200, 2),\n                           (\"sandwich\", 50, 60, 2),\n                           (\"glucose\", 15, 60, 2),\n                           (\"tin\", 68, 45, 3),\n                           (\"banana\", 27, 60, 3),\n                           (\"apple\", 39, 40, 3),\n                           (\"cheese\", 23, 30, 1),\n                           (\"beer\", 52, 10, 3),\n                           (\"suntan cream\", 11, 70, 1),\n                           (\"camera\", 32, 30, 1),\n                           (\"T-shirt\", 24, 15, 2),\n                           (\"trousers\", 48, 10, 2),\n                           (\"umbrella\", 73, 40, 1),\n                           (\"waterproof trousers\", 42, 70, 1),\n                           (\"waterproof overclothes\", 43, 75, 1),\n                           (\"note-case\", 22, 80, 1),\n                           (\"sunglasses\", 7, 20, 1),\n                           (\"towel\", 18, 12, 2),\n                           (\"socks\", 4, 50, 1),\n                           (\"book\", 30, 10, 2)\n                          ]\n\ntype\n\n  \n  Number = range[0..Items.high]\n\n  \n  ExpandedItem = tuple[num: Number; weight, value: int]\n\n\n\n\nproc expandedItems(items: seq[Item]): seq[ExpandedItem] =\n  \n  for idx, item in Items:\n    for _ in 1..item.pieces:\n      result.add((idx.Number, item.weight, item.value))\n\nconst ItemList = expandedItems(Items)\n\ntype\n\n  \n  ExpandedIndex = 0..ItemList.high\n\n  \n  Choice = tuple[indexes: set[ExpandedIndex]; weight, value: int]\n\n\nvar cache: Table[tuple[index, weight: int], Choice]\n\n\n\n\nproc select(idx, weightLimit: int): Choice =\n  \n\n  if idx < 0 or weightLimit == 0:\n    return\n\n  if (idx, weightLimit) in cache:\n    return cache[(idx, weightLimit)]\n\n  let weight = ItemList[idx].weight\n  if weight > weightLimit:\n    return select(idx - 1, weightLimit)\n\n  \n  result = select(idx - 1, weightLimit)\n\n  \n  var result1 = select(idx - 1, weightLimit - weight)\n  inc result1.value, ItemList[idx].value\n\n  \n  if result1.value > result.value:\n    result = (result1.indexes + {idx.ExpandedIndex}, result1.weight + weight, result1.value)\n\n  cache[(idx, weightLimit)] = result\n\n\n\nlet (indexes, weight, value) = select(ItemList.high, 400)\n\n\nvar pieces = newSeq[int](Items.len)\nfor idx in indexes:\n  inc pieces[ItemList[idx].num]\n\necho \"List of items:\"\nfor num in 0..Items.high:\n  if pieces[num] > 0:\n    echo fmt\"\u2013 {pieces[num]} of {Items[num].pieces} {Items[num].name}\"\necho \"\"\necho \"Total weight: \", weight\necho \"Total value: \", value\n"}
{"id": 418695, "name": "Solve a Hidato puzzle", "source": "Translate Haskell to Python: \n\n\nimport qualified Data.IntMap as I\nimport Data.IntMap (IntMap)\nimport Data.List\nimport Data.Maybe\nimport Data.Time.Clock\n\ndata BoardProblem = Board\n  { cells :: IntMap (IntMap Int)\n  , endVal :: Int\n  , onePos :: (Int, Int)\n  , givens :: [Int]\n  } deriving (Show, Eq)\n\ntupIns x y v m = I.insert x (I.insert y v (I.findWithDefault I.empty x m)) m\n\ntupLookup x y m = I.lookup x m >>= I.lookup y\n\nmakeBoard =\n  (\\x ->\n      x\n      { givens = dropWhile (<= 1) $ sort $ givens x\n      }) .\n  foldl' \n    f\n    (Board I.empty 0 (0, 0) []) .\n  concatMap (zip [0 ..]) . zipWith (\\y w -> map (y, ) $ words w) [0 ..]\n  where\n    f bd (x, (y, v)) =\n      if v == \".\"\n        then bd\n        else Board\n               (tupIns x y (read v) (cells bd))\n               (if read v > endVal bd\n                  then read v\n                  else endVal bd)\n               (if v == \"1\"\n                  then (x, y)\n                  else onePos bd)\n               (read v : givens bd)\n\nhidato brd = listToMaybe $ h 2 (cells brd) (onePos brd) (givens brd)\n  where\n    h nval pmap (x, y) gs\n      | nval == endVal brd = [pmap]\n      | nval == head gs =\n        if null nvalAdj\n          then []\n          else h (nval + 1) pmap (fst $ head nvalAdj) (tail gs)\n      | not $ null nvalAdj = h (nval + 1) pmap (fst $ head nvalAdj) gs\n      | otherwise = hEmptyAdj\n      where\n        around =\n          [ (x - 1, y - 1)\n          , (x, y - 1)\n          , (x + 1, y - 1)\n          , (x - 1, y)\n          , (x + 1, y)\n          , (x - 1, y + 1)\n          , (x, y + 1)\n          , (x + 1, y + 1)\n          ]\n        lkdUp = map (\\(x, y) -> ((x, y), tupLookup x y pmap)) around\n        nvalAdj = filter ((== Just nval) . snd) lkdUp\n        hEmptyAdj =\n          concatMap\n            (\\((nx, ny), _) -> h (nval + 1) (tupIns nx ny nval pmap) (nx, ny) gs) $\n          filter ((== Just 0) . snd) lkdUp\n\nprintCellMap cellmap = putStrLn $ concat strings\n  where\n    maxPos = xyBy I.findMax maximum\n    minPos = xyBy I.findMin minimum\n    xyBy :: (forall a. IntMap a -> (Int, a)) -> ([Int] -> Int) -> (Int, Int)\n    xyBy a b = (fst (a cellmap), b $ map (fst . a . snd) $ I.toList cellmap)\n    strings =\n      map\n        f\n        [ (x, y)\n        | y <- [snd minPos .. snd maxPos] \n        , x <- [fst minPos .. fst maxPos] ]\n    f (x, y) =\n      let z =\n            if x == fst maxPos\n              then \"\\n\"\n              else \" \"\n      in case tupLookup x y cellmap of\n           Nothing -> \"  \" ++ z\n           Just n ->\n             (if n < 10\n                then ' ' : show n\n                else show n) ++\n             z\n\nmain = do\n  let sampleBoard = makeBoard sample\n  printCellMap $ cells sampleBoard\n  printCellMap $ fromJust $ hidato sampleBoard\n\nsample =\n  [ \" 0 33 35  0  0\"\n  , \" 0  0 24 22  0\"\n  , \" 0  0  0 21  0  0\"\n  , \" 0 26  0 13 40 11\"\n  , \"27  0  0  0  9  0  1\"\n  , \".  .   0  0 18  0  0\"\n  , \".  .  .  .   0  7  0  0\"\n  , \".  .  .  .  .  .   5  0\"\n  ]\n", "target": "board = []\ngiven = []\nstart = None\n\ndef setup(s):\n    global board, given, start\n    lines = s.splitlines()\n    ncols = len(lines[0].split())\n    nrows = len(lines)\n    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]\n\n    for r, row in enumerate(lines):\n        for c, cell in enumerate(row.split()):\n            if cell == \"__\" :\n                board[r + 1][c + 1] = 0\n                continue\n            elif cell == \".\":\n                continue \n            else:\n                val = int(cell)\n                board[r + 1][c + 1] = val\n                given.append(val)\n                if val == 1:\n                    start = (r + 1, c + 1)\n    given.sort()\n\ndef solve(r, c, n, next=0):\n    if n > given[-1]:\n        return True\n    if board[r][c] and board[r][c] != n:\n        return False\n    if board[r][c] == 0 and given[next] == n:\n        return False\n\n    back = 0\n    if board[r][c] == n:\n        next += 1\n        back = n\n\n    board[r][c] = n\n    for i in xrange(-1, 2):\n        for j in xrange(-1, 2):\n            if solve(r + i, c + j, n + 1, next):\n                return True\n    board[r][c] = back\n    return False\n\ndef print_board():\n    d = {-1: \"  \", 0: \"__\"}\n    bmax = max(max(r) for r in board)\n    form = \"%\" + str(len(str(bmax)) + 1) + \"s\"\n    for r in board[1:-1]:\n        print \"\".join(form % d.get(c, str(c)) for c in r[1:-1])\n\nhi = \n\nsetup(hi)\nprint_board()\nsolve(start[0], start[1], 1)\nprint\nprint_board()\n"}
{"id": 418696, "name": "Solve a Hidato puzzle", "source": "Translate Haskell to Python: \n\n\nimport qualified Data.IntMap as I\nimport Data.IntMap (IntMap)\nimport Data.List\nimport Data.Maybe\nimport Data.Time.Clock\n\ndata BoardProblem = Board\n  { cells :: IntMap (IntMap Int)\n  , endVal :: Int\n  , onePos :: (Int, Int)\n  , givens :: [Int]\n  } deriving (Show, Eq)\n\ntupIns x y v m = I.insert x (I.insert y v (I.findWithDefault I.empty x m)) m\n\ntupLookup x y m = I.lookup x m >>= I.lookup y\n\nmakeBoard =\n  (\\x ->\n      x\n      { givens = dropWhile (<= 1) $ sort $ givens x\n      }) .\n  foldl' \n    f\n    (Board I.empty 0 (0, 0) []) .\n  concatMap (zip [0 ..]) . zipWith (\\y w -> map (y, ) $ words w) [0 ..]\n  where\n    f bd (x, (y, v)) =\n      if v == \".\"\n        then bd\n        else Board\n               (tupIns x y (read v) (cells bd))\n               (if read v > endVal bd\n                  then read v\n                  else endVal bd)\n               (if v == \"1\"\n                  then (x, y)\n                  else onePos bd)\n               (read v : givens bd)\n\nhidato brd = listToMaybe $ h 2 (cells brd) (onePos brd) (givens brd)\n  where\n    h nval pmap (x, y) gs\n      | nval == endVal brd = [pmap]\n      | nval == head gs =\n        if null nvalAdj\n          then []\n          else h (nval + 1) pmap (fst $ head nvalAdj) (tail gs)\n      | not $ null nvalAdj = h (nval + 1) pmap (fst $ head nvalAdj) gs\n      | otherwise = hEmptyAdj\n      where\n        around =\n          [ (x - 1, y - 1)\n          , (x, y - 1)\n          , (x + 1, y - 1)\n          , (x - 1, y)\n          , (x + 1, y)\n          , (x - 1, y + 1)\n          , (x, y + 1)\n          , (x + 1, y + 1)\n          ]\n        lkdUp = map (\\(x, y) -> ((x, y), tupLookup x y pmap)) around\n        nvalAdj = filter ((== Just nval) . snd) lkdUp\n        hEmptyAdj =\n          concatMap\n            (\\((nx, ny), _) -> h (nval + 1) (tupIns nx ny nval pmap) (nx, ny) gs) $\n          filter ((== Just 0) . snd) lkdUp\n\nprintCellMap cellmap = putStrLn $ concat strings\n  where\n    maxPos = xyBy I.findMax maximum\n    minPos = xyBy I.findMin minimum\n    xyBy :: (forall a. IntMap a -> (Int, a)) -> ([Int] -> Int) -> (Int, Int)\n    xyBy a b = (fst (a cellmap), b $ map (fst . a . snd) $ I.toList cellmap)\n    strings =\n      map\n        f\n        [ (x, y)\n        | y <- [snd minPos .. snd maxPos] \n        , x <- [fst minPos .. fst maxPos] ]\n    f (x, y) =\n      let z =\n            if x == fst maxPos\n              then \"\\n\"\n              else \" \"\n      in case tupLookup x y cellmap of\n           Nothing -> \"  \" ++ z\n           Just n ->\n             (if n < 10\n                then ' ' : show n\n                else show n) ++\n             z\n\nmain = do\n  let sampleBoard = makeBoard sample\n  printCellMap $ cells sampleBoard\n  printCellMap $ fromJust $ hidato sampleBoard\n\nsample =\n  [ \" 0 33 35  0  0\"\n  , \" 0  0 24 22  0\"\n  , \" 0  0  0 21  0  0\"\n  , \" 0 26  0 13 40 11\"\n  , \"27  0  0  0  9  0  1\"\n  , \".  .   0  0 18  0  0\"\n  , \".  .  .  .   0  7  0  0\"\n  , \".  .  .  .  .  .   5  0\"\n  ]\n", "target": "board = []\ngiven = []\nstart = None\n\ndef setup(s):\n    global board, given, start\n    lines = s.splitlines()\n    ncols = len(lines[0].split())\n    nrows = len(lines)\n    board = [[-1] * (ncols + 2) for _ in xrange(nrows + 2)]\n\n    for r, row in enumerate(lines):\n        for c, cell in enumerate(row.split()):\n            if cell == \"__\" :\n                board[r + 1][c + 1] = 0\n                continue\n            elif cell == \".\":\n                continue \n            else:\n                val = int(cell)\n                board[r + 1][c + 1] = val\n                given.append(val)\n                if val == 1:\n                    start = (r + 1, c + 1)\n    given.sort()\n\ndef solve(r, c, n, next=0):\n    if n > given[-1]:\n        return True\n    if board[r][c] and board[r][c] != n:\n        return False\n    if board[r][c] == 0 and given[next] == n:\n        return False\n\n    back = 0\n    if board[r][c] == n:\n        next += 1\n        back = n\n\n    board[r][c] = n\n    for i in xrange(-1, 2):\n        for j in xrange(-1, 2):\n            if solve(r + i, c + j, n + 1, next):\n                return True\n    board[r][c] = back\n    return False\n\ndef print_board():\n    d = {-1: \"  \", 0: \"__\"}\n    bmax = max(max(r) for r in board)\n    form = \"%\" + str(len(str(bmax)) + 1) + \"s\"\n    for r in board[1:-1]:\n        print \"\".join(form % d.get(c, str(c)) for c in r[1:-1])\n\nhi = \n\nsetup(hi)\nprint_board()\nsolve(start[0], start[1], 1)\nprint\nprint_board()\n"}
{"id": 418697, "name": "Sorting algorithms_Strand sort", "source": "Translate Haskell to Python: \nmerge :: (Ord a) => [a] -> [a] -> [a]\nmerge [] ys = ys\nmerge xs [] = xs\nmerge (x : xs) (y : ys)\n\t| x <= y = x : merge xs (y : ys)\n\t| otherwise = y : merge (x : xs) ys\n\nstrandSort :: (Ord a) => [a] -> [a]\nstrandSort [] = []\nstrandSort (x : xs) = merge strand (strandSort rest) where\n\t(strand, rest) = extractStrand x xs\n\textractStrand x [] = ([x], [])\n\textractStrand x (x1 : xs)\n\t\t| x <= x1 = let (strand, rest) = extractStrand x1 xs in (x : strand, rest)\n\t\t| otherwise = let (strand, rest) = extractStrand x xs in (strand, x1 : rest)\n", "target": "def merge_list(a, b):\n\tout = []\n\twhile len(a) and len(b):\n\t\tif a[0] < b[0]:\n\t\t\tout.append(a.pop(0))\n\t\telse:\n\t\t\tout.append(b.pop(0))\n\tout += a\n\tout += b\n\treturn out\n\ndef strand(a):\n\ti, s = 0, [a.pop(0)]\n\twhile i < len(a):\n\t\tif a[i] > s[-1]:\n\t\t\ts.append(a.pop(i))\n\t\telse:\n\t\t\ti += 1\n\treturn s\n\ndef strand_sort(a):\n\tout = strand(a)\n\twhile len(a):\n\t\tout = merge_list(out, strand(a))\n\treturn out\n\nprint strand_sort([1, 6, 3, 2, 1, 7, 5, 3])\n"}
{"id": 418698, "name": "Angles (geometric), normalization and conversion", "source": "Translate Haskell to Python: \n\n\n  \nimport Text.Printf\n \nclass (Num a, Fractional a, RealFrac a) => Angle a where\n  fullTurn :: a \n  mkAngle :: Double -> a\n  value :: a -> Double\n  fromTurn :: Double -> a\n  toTurn :: a -> Double\n  normalize :: a -> a\n\n  \n  fromTurn t = angle t * fullTurn\n  toTurn a = value $ a / fullTurn\n\n  \n  normalize a = a `modulo` fullTurn\n    where\n      modulo x r | x == r = r\n                 | x < 0 = signum x * abs x `modulo` r\n                 | x >= 0 = x - fromInteger (floor (x / r)) * r \n\n\nangle :: Angle a => Double -> a\nangle = normalize . mkAngle\n\n\nfrom :: forall a b. (Angle a, Angle b) => a -> b\nfrom = fromTurn . toTurn\n\nto :: forall b a. (Angle a, Angle b) => a -> b\nto = fromTurn . toTurn\n", "target": "PI = 3.141592653589793\nTWO_PI = 6.283185307179586\n\ndef normalize2deg(a):\n  while a < 0: a += 360\n  while a >= 360: a -= 360\n  return a\ndef normalize2grad(a):\n  while a < 0: a += 400\n  while a >= 400: a -= 400\n  return a\ndef normalize2mil(a):\n  while a < 0: a += 6400\n  while a >= 6400: a -= 6400\n  return a\ndef normalize2rad(a):\n  while a < 0: a += TWO_PI\n  while a >= TWO_PI: a -= TWO_PI\n  return a\n\ndef deg2grad(a): return a * 10.0 / 9.0\ndef deg2mil(a): return a * 160.0 / 9.0\ndef deg2rad(a): return a * PI / 180.0\n\ndef grad2deg(a): return a * 9.0 / 10.0\ndef grad2mil(a): return a * 16.0\ndef grad2rad(a): return a * PI / 200.0\n\ndef mil2deg(a): return a * 9.0 / 160.0\ndef mil2grad(a): return a / 16.0\ndef mil2rad(a): return a * PI / 3200.0\n\ndef rad2deg(a): return a * 180.0 / PI\ndef rad2grad(a): return a * 200.0 / PI\ndef rad2mil(a): return a * 3200.0 / PI\n"}
{"id": 418699, "name": "XML_XPath", "source": "Translate Haskell to Python: import Data.List\nimport Control.Arrow\nimport Control.Monad\n\ntakeWhileIncl           :: (a -> Bool) -> [a] -> [a]\ntakeWhileIncl _ []      =  []\ntakeWhileIncl p (x:xs)\n            | p x       =  x : takeWhileIncl p xs\n            | otherwise =  [x] \n\ngetmultiLineItem n = takeWhileIncl(not.isInfixOf (\"</\" ++ n)). dropWhile(not.isInfixOf ('<': n))\ngetsingleLineItems n = map (takeWhile(/='<'). drop 1. dropWhile(/='>')). filter (isInfixOf ('<': n))\n\nmain = do\n  xml <- readFile \"./Rosetta/xmlpath.xml\"\n  let xmlText = lines xml\n      \n  putStrLn \"\\n== First item ==\\n\"\n  mapM_ putStrLn $ head $ unfoldr (Just. liftM2 (id &&&) (\\\\) (getmultiLineItem \"item\")) xmlText\n  \n  putStrLn \"\\n== Prices ==\\n\"\n  mapM_ putStrLn $ getsingleLineItems \"price\" xmlText\n  \n  putStrLn \"\\n== Names ==\\n\"\n  print $ getsingleLineItems \"name\" xmlText\n", "target": "\n\nfrom xml.dom import minidom\n\nxmlfile = file(\"test3.xml\") \nxmldoc = minidom.parse(xmlfile).documentElement \nxmldoc = minidom.parseString(\"<inventory title=\"OmniCorp Store \n\t\n\ni = xmldoc.getElementsByTagName(\"item\") \nfirstItemElement = i[0] \n\n\nfor j in xmldoc.getElementsByTagName(\"price\"): \n\tprint j.childNodes[0].data \n\n\nnamesArray = xmldoc.getElementsByTagName(\"name\")\n"}
{"id": 418700, "name": "HTTPS_Authenticated", "source": "Translate Haskell to Python: \n\nmodule Main (main) where\n\nimport           Data.Aeson (Value)\nimport           Data.Default.Class (def)\nimport           Network.HTTP.Req\n                    ( (/:)\n                    , GET(..)\n                    , NoReqBody(..)\n                    , basicAuth\n                    , https\n                    , jsonResponse\n                    , req\n                    , responseBody\n                    , runReq\n                    )\n\nmain :: IO ()\nmain = do\n    response <- runReq def $ req\n            GET\n            (https \"httpbin.org\" /: \"basic-auth\" /: \"someuser\" /: \"somepassword\")\n            NoReqBody\n            jsonResponse\n            (basicAuth \"someuser\" \"somepassword\")\n    print (responseBody response :: Value)\n", "target": "\n\n\nfrom mechanize import Browser\n\nUSER_AGENT = \"Mozilla/5.0 (X11; U; Linux i686; tr-TR; rv:1.8.1.9) Gecko/20071102 Pardus/2007 Firefox/2.0.0.9\"\n\nbr = Browser()\nbr.addheaders = [(\"User-agent\", USER_AGENT)]\n\n\n\n\n\n\nbr.open(\"https://www.facebook.com\")\n\nbr.select_form(\"loginform\")\nbr['email'] = \"xxxxxxx@xxxxx.com\"\nbr['pass'] = \"xxxxxxxxx\"\nbr['persistent'] = [\"1\"]\n\nresponse = br.submit()\nprint response.read()\n"}
{"id": 418701, "name": "Ranking methods", "source": "Translate Haskell to Python: import Data.List (groupBy, sortBy, intercalate)\n\ntype Item = (Int, String)\n\ntype ItemList = [Item]\n\ntype ItemGroups = [ItemList]\n\ntype RankItem a = (a, Int, String)\n\ntype RankItemList a = [RankItem a]\n\n\nprepare :: ItemList -> ItemGroups\nprepare = groupBy gf . sortBy (flip compare)\n  where\n    gf (a, _) (b, _) = a == b\n\n\nrank\n  :: Num a\n  => a -> Item -> RankItem a\nrank n (a, b) = (n, a, b)\n\n\nstandard, modified, dense, ordinal :: ItemGroups -> RankItemList Int\nstandard = ms 1\n  where\n    ms _ [] = []\n    ms n (x:xs) = (rank n <$> x) ++ ms (n + length x) xs\n\nmodified = md 1\n  where\n    md _ [] = []\n    md n (x:xs) =\n      let l = length x\n          nl = n + l\n          nl1 = nl - 1\n      in (rank nl1 <$> x) ++ md (n + l) xs\n\ndense = md 1\n  where\n    md _ [] = []\n    md n (x:xs) = map (rank n) x ++ md (n + 1) xs\n\nordinal = zipWith rank [1 ..] . concat\n\nfractional :: ItemGroups -> RankItemList Double\nfractional = mf 1.0\n  where\n    mf _ [] = []\n    mf n (x:xs) =\n      let l = length x\n          o = take l [n ..]\n          ld = fromIntegral l\n          a = sum o / ld\n      in map (rank a) x ++ mf (n + ld) xs\n\n\ntest :: ItemGroups\ntest =\n  prepare\n    [ (44, \"Solomon\")\n    , (42, \"Jason\")\n    , (42, \"Errol\")\n    , (41, \"Garry\")\n    , (41, \"Bernard\")\n    , (41, \"Barry\")\n    , (39, \"Stephen\")\n    ]\n\n\nnicePrint\n  :: Show a\n  => String -> RankItemList a -> IO ()\nnicePrint xs items = do\n  putStrLn xs\n  mapM_ np items\n  putStr \"\\n\"\n  where\n    np (a, b, c) = putStrLn $ intercalate \"\\t\" [show a, show b, c]\n\nmain :: IO ()\nmain = do\n  nicePrint \"Standard:\" $ standard test\n  nicePrint \"Modified:\" $ modified test\n  nicePrint \"Dense:\" $ dense test\n  nicePrint \"Ordinal:\" $ ordinal test\n  nicePrint \"Fractional:\" $ fractional test\n", "target": "def mc_rank(iterable, start=1):\n    \n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n"}
{"id": 418702, "name": "Update a configuration file", "source": "Translate Haskell to Python: import Data.Char (toUpper)\nimport qualified System.IO.Strict  as S\n", "target": "\n\n\n\n\nimport re\nimport string\n\n\n\n\n\nDISABLED_PREFIX = ';'\n\n\n\n\n\nclass Option(object):\n    \n\n    \n    def __init__(self, name, value=None, disabled=False,\n                 disabled_prefix=DISABLED_PREFIX):\n        \n        self.name = str(name)\n        self.value = value\n        self.disabled = bool(disabled)\n        self.disabled_prefix = disabled_prefix\n\n    \n    def __str__(self):\n        \n        disabled = ('', '%s ' % self.disabled_prefix)[self.disabled]\n        value = (' %s' % self.value, '')[self.value is None]\n        return ''.join((disabled, self.name, value))\n\n    \n    def get(self):\n        \n        enabled = not bool(self.disabled)\n        if self.value is None:\n            value = enabled\n        else:\n            value = enabled and self.value\n        return value\n\n    \n\n\n\nclass Config(object):\n    \n    \n    reOPTION = r'^\\s*(?P<disabled>%s*)\\s*(?P<name>\\w+)(?:\\s+(?P<value>.+?))?\\s*$'\n\n    \n    def __init__(self, fname=None, disabled_prefix=DISABLED_PREFIX):\n        \n        self.disabled_prefix = disabled_prefix\n        self.contents = []          \n        self.options = {}           \n        self.creOPTION = re.compile(self.reOPTION % self.disabled_prefix)\n        if fname:\n            self.parse_file(fname)\n\n    \n    def __str__(self):\n        \n        return '\\n'.join(map(str, self.contents))\n\n    \n    def parse_file(self, fname):\n        \n        with open(fname) as f:\n            self.parse_lines(f)\n        return self\n\n    \n    def parse_lines(self, lines):\n        \n        for line in lines:\n            self.parse_line(line)\n        return self\n\n    \n    def parse_line(self, line):\n        \n        s = ''.join(c for c in line.strip() if c in string.printable) \n        moOPTION = self.creOPTION.match(s)\n        if moOPTION:\n            name = moOPTION.group('name').upper()\n            if not name in self.options:\n                self.add_option(name, moOPTION.group('value'),\n                                moOPTION.group('disabled'))\n        else:\n            if not s.startswith(self.disabled_prefix):\n                self.contents.append(line.rstrip())\n        return self\n\n    \n    def add_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = Option(name, value, disabled)\n        self.options[name] = opt\n        self.contents.append(opt)\n        return opt\n\n    \n    def set_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = self.options.get(name)\n        if opt:\n            opt.value = value\n            opt.disabled = disabled\n        else:\n            opt = self.add_option(name, value, disabled)\n        return opt\n\n    \n    def enable_option(self, name, value=None):\n        \n        return self.set_option(name, value, False)\n\n    \n    def disable_option(self, name, value=None):\n        \n        return self.set_option(name, value, True)\n\n    \n    def get_option(self, name):\n        \n        opt = self.options.get(name.upper())\n        value = opt.get() if opt else None\n        return value\n\n\n\n\n\nif __name__ == '__main__':\n    import sys\n    cfg = Config(sys.argv[1] if len(sys.argv) > 1 else None)\n    cfg.disable_option('needspeeling')\n    cfg.enable_option('seedsremoved')\n    cfg.enable_option('numberofbananas', 1024)\n    cfg.enable_option('numberofstrawberries', 62000)\n    print cfg\n"}
{"id": 418703, "name": "Straddling checkerboard", "source": "Translate Haskell to Python: import Data.Char\nimport Data.Map\n\ncharToInt :: Char -> Int\ncharToInt c = ord c - ord '0'\n\n\n\ndecodeChar :: String -> (Char,String)\ndecodeChar ('7':'9':r:rs) = (r,rs)\ndecodeChar ('7':r:rs)     = (\"PQUVWXYZ. \" !! charToInt r, rs)\ndecodeChar ('3':r:rs)     = (\"ABCDFGIJKN\" !! charToInt r, rs)\ndecodeChar (r:rs)         = (\"HOL MES RT\" !! charToInt r, rs)\n\n\ndecode :: String -> String\ndecode [] = []\ndecode st = let (c, s) = decodeChar st in c:decode s\n\n\n\n\nrevEnc :: String -> (Char, String)\nrevEnc enc = let (dec, rm) = decodeChar enc in (dec, take (length enc - length rm) enc)\n\nds :: String\nds = ['0'..'9']\n\n\n\nencodeMap :: Map Char String\nencodeMap = fromList [ revEnc [d2,d1,d0] | d2 <- ds, d1 <- ds, d0 <- ds ]\n\n\nencodeChar :: Char -> String\nencodeChar c = findWithDefault \"\" c encodeMap \n\n\nencode :: String -> String\nencode st = concatMap encodeChar $ fmap toUpper st\n\n\nmain = let orig = \"One night-it was on the twentieth of March, 1888-I was returning\"\n           enc = encode orig\n           dec = decode enc\n       in mapM_ putStrLn [ \"Original: \" ++ orig\n                         , \"Encoded: \" ++ enc \n                         , \"Decoded: \" ++ dec ]\n", "target": "T = [[\"79\", \"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\"],\n     [\"\",   \"H\", \"O\", \"L\", \"\",  \"M\", \"E\", \"S\", \"\",  \"R\", \"T\"],\n     [\"3\",  \"A\", \"B\", \"C\", \"D\", \"F\", \"G\", \"I\", \"J\", \"K\", \"N\"],\n     [\"7\",  \"P\", \"Q\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\", \".\", \"/\"]]\n\ndef straddle(s):\n    return \"\".join(L[0]+T[0][L.index(c)] for c in s.upper() for L in T if c in L)\n\ndef unstraddle(s):\n    s = iter(s)\n    for c in s:\n        if c in [T[2][0], T[3][0]]:\n            i = [T[2][0], T[3][0]].index(c)\n            n = T[2 + i][T[0].index(s.next())]\n            yield s.next() if n == \"/\" else n\n        else:\n            yield T[1][T[0].index(c)]\n\nO = \"One night-it was on the twentieth of March, 1888-I was returning\"\nprint \"Encoded:\", straddle(O)\nprint \"Decoded:\", \"\".join(unstraddle(straddle(O)))\n"}
{"id": 418704, "name": "I before E except after C", "source": "Translate Haskell to Python: import Network.HTTP\nimport Text.Regex.TDFA\nimport Text.Printf\n\ngetWordList :: IO String\ngetWordList  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n\nmain = do\n    words <- getWordList\n    putStrLn \"Checking Rule 1: \\\"I before E when not preceded by C\\\"...\"\n    let numTrueRule1   =  matchCount (makeRegex \"[^c]ie\" :: Regex) words\n        numFalseRule1  =  matchCount (makeRegex \"[^c]ei\" :: Regex) words\n        rule1Plausible  =  numTrueRule1 > (2*numFalseRule1)\n    printf \"Rule 1 is correct for %d\\n        incorrect for %d\\n\" numTrueRule1 numFalseRule1\n    printf \"*** Rule 1 is %splausible.\\n\" (if rule1Plausible then \"\" else \"im\")\n    \n    putStrLn \"Checking Rule 2: \\\"E before I when preceded by C\\\"...\"\n    let numTrueRule2   =  matchCount (makeRegex \"cei\" :: Regex) words\n        numFalseRule2  =  matchCount (makeRegex \"cie\" :: Regex) words\n        rule2Plausible  =  numTrueRule2 > (2*numFalseRule2)\n    printf \"Rule 2 is correct for %d\\n        incorrect for %d\\n\" numTrueRule2 numFalseRule2\n    printf \"*** Rule 2 is %splausible.\\n\" (if rule2Plausible then \"\" else \"im\")\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 418705, "name": "I before E except after C", "source": "Translate Haskell to Python: import Network.HTTP\nimport Text.Regex.TDFA\nimport Text.Printf\n\ngetWordList :: IO String\ngetWordList  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n\nmain = do\n    words <- getWordList\n    putStrLn \"Checking Rule 1: \\\"I before E when not preceded by C\\\"...\"\n    let numTrueRule1   =  matchCount (makeRegex \"[^c]ie\" :: Regex) words\n        numFalseRule1  =  matchCount (makeRegex \"[^c]ei\" :: Regex) words\n        rule1Plausible  =  numTrueRule1 > (2*numFalseRule1)\n    printf \"Rule 1 is correct for %d\\n        incorrect for %d\\n\" numTrueRule1 numFalseRule1\n    printf \"*** Rule 1 is %splausible.\\n\" (if rule1Plausible then \"\" else \"im\")\n    \n    putStrLn \"Checking Rule 2: \\\"E before I when preceded by C\\\"...\"\n    let numTrueRule2   =  matchCount (makeRegex \"cei\" :: Regex) words\n        numFalseRule2  =  matchCount (makeRegex \"cie\" :: Regex) words\n        rule2Plausible  =  numTrueRule2 > (2*numFalseRule2)\n    printf \"Rule 2 is correct for %d\\n        incorrect for %d\\n\" numTrueRule2 numFalseRule2\n    printf \"*** Rule 2 is %splausible.\\n\" (if rule2Plausible then \"\" else \"im\")\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 418706, "name": "Abelian sandpile model", "source": "Translate Haskell to Python: \n\n\n\nmodule Rosetta.AbelianSandpileModel.ST \n    ( simulate\n    , test\n    , toPGM\n    ) where\n\nimport Control.Monad.Reader (asks, MonadReader (..), ReaderT, runReaderT)\nimport Control.Monad.ST (runST, ST)\nimport Control.Monad.State (evalStateT, forM_, lift, MonadState (..), StateT, modify, when)\nimport Data.Array.ST (freeze, readArray, STUArray, thaw, writeArray)\nimport Data.Array.Unboxed (array, assocs, bounds, UArray, (!))\nimport Data.Word (Word32)\nimport System.IO (hPutStr, hPutStrLn, IOMode (WriteMode), withFile)\nimport Text.Printf (printf)\n\ntype Point     = (Int, Int)\ntype ArrayST s = STUArray s Point Word32\ntype ArrayU    = UArray Point Word32\n\nnewtype M s a = M (ReaderT (S s) (StateT [Point] (ST s)) a)\n    deriving (Functor, Applicative, Monad, MonadReader (S s), MonadState [Point])\n\ndata S s = S \n    { bMin :: !Point\n    , bMax :: !Point\n    , arr  :: !(ArrayST s)\n    }\n\nrunM :: M s a -> S s -> [Point]-> ST s a\nrunM (M m) = evalStateT . runReaderT m\n\nliftST :: ST s a -> M s a\nliftST = M . lift . lift\n\nsimulate :: ArrayU -> ArrayU\nsimulate a = runST $ simulateST a\n\nsimulateST :: forall s. ArrayU -> ST s ArrayU\nsimulateST a = do\n    let (p1, p2) = bounds a\n        s = [p | (p, c) <- assocs a, c >= 4]\n    b <- thaw a :: ST s (ArrayST s)\n    let st = S { bMin = p1\n               , bMax = p2\n               , arr  = b\n               }\n    runM simulateM st s\n\nsimulateM :: forall s. M s ArrayU\nsimulateM = do\n    ps <- get\n    case ps of\n        []      -> asks arr >>= liftST . freeze\n        p : ps' -> do\n            c <- changeArr p $ \\x -> x - 4\n            when (c < 4) $ put ps'\n            forM_ [north, east, south, west] $ inc . ($ p)\n            simulateM\n\nchangeArr :: Point -> (Word32 -> Word32) -> M s Word32\nchangeArr p f = do\n    a    <- asks arr\n    oldC <- liftST $ readArray a p\n    let newC = f oldC\n    liftST $ writeArray a p newC\n    return newC\n\ninc :: Point -> M s ()\ninc p = do\n    b <- inBounds p\n    when b $ do\n        c <- changeArr p succ\n        when (c == 4) $ modify $ (p :)\n\ninBounds :: Point -> M s Bool\ninBounds p = do\n    st <- ask\n    return $ p >= bMin st && p <= bMax st\n\nnorth, east, south, west :: Point -> Point\nnorth (x, y) = (x, y + 1)\neast  (x, y) = (x + 1, y)\nsouth (x, y) = (x, y - 1)\nwest  (x, y) = (x - 1, y)\n\ntoPGM :: ArrayU -> FilePath -> IO ()\ntoPGM a fp = withFile fp WriteMode $ \\h -> do\n    let ((x1, y1), (x2, y2)) = bounds a\n        width  = x2 - x1 + 1\n        height = y2 - y1 + 1\n    hPutStrLn h \"P2\"\n    hPutStrLn h $ show width ++ \" \" ++ show height\n    hPutStrLn h \"3\"\n    forM_ [y1 .. y2] $ \\y -> do\n        forM_ [x1 .. x2] $ \\x -> do\n            let c = min 3 $ a ! (x, y)\n            hPutStr h $ show c ++ \" \"\n        hPutStrLn h \"\"\n\ninitArray :: Int -> Word32 -> ArrayU\ninitArray size height = array \n    ((-size, -size), (size, size))\n    [((x, y), if x == 0 && y == 0 then height else 0) | x <- [-size .. size], y <- [-size .. size]]\n\ntest :: Int -> Word32 -> IO ()\ntest size height = do\n    printf \"size = %d, height = %d\\n\" size height\n    let a  = initArray size height\n        b  = simulate a\n        fp = printf \"sandpile_%d_%d.pgm\" size height\n    toPGM b fp\n    putStrLn $ \"wrote image to \" ++ fp\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"}
{"id": 418707, "name": "Abelian sandpile model", "source": "Translate Haskell to Python: \n\n\n\nmodule Rosetta.AbelianSandpileModel.ST \n    ( simulate\n    , test\n    , toPGM\n    ) where\n\nimport Control.Monad.Reader (asks, MonadReader (..), ReaderT, runReaderT)\nimport Control.Monad.ST (runST, ST)\nimport Control.Monad.State (evalStateT, forM_, lift, MonadState (..), StateT, modify, when)\nimport Data.Array.ST (freeze, readArray, STUArray, thaw, writeArray)\nimport Data.Array.Unboxed (array, assocs, bounds, UArray, (!))\nimport Data.Word (Word32)\nimport System.IO (hPutStr, hPutStrLn, IOMode (WriteMode), withFile)\nimport Text.Printf (printf)\n\ntype Point     = (Int, Int)\ntype ArrayST s = STUArray s Point Word32\ntype ArrayU    = UArray Point Word32\n\nnewtype M s a = M (ReaderT (S s) (StateT [Point] (ST s)) a)\n    deriving (Functor, Applicative, Monad, MonadReader (S s), MonadState [Point])\n\ndata S s = S \n    { bMin :: !Point\n    , bMax :: !Point\n    , arr  :: !(ArrayST s)\n    }\n\nrunM :: M s a -> S s -> [Point]-> ST s a\nrunM (M m) = evalStateT . runReaderT m\n\nliftST :: ST s a -> M s a\nliftST = M . lift . lift\n\nsimulate :: ArrayU -> ArrayU\nsimulate a = runST $ simulateST a\n\nsimulateST :: forall s. ArrayU -> ST s ArrayU\nsimulateST a = do\n    let (p1, p2) = bounds a\n        s = [p | (p, c) <- assocs a, c >= 4]\n    b <- thaw a :: ST s (ArrayST s)\n    let st = S { bMin = p1\n               , bMax = p2\n               , arr  = b\n               }\n    runM simulateM st s\n\nsimulateM :: forall s. M s ArrayU\nsimulateM = do\n    ps <- get\n    case ps of\n        []      -> asks arr >>= liftST . freeze\n        p : ps' -> do\n            c <- changeArr p $ \\x -> x - 4\n            when (c < 4) $ put ps'\n            forM_ [north, east, south, west] $ inc . ($ p)\n            simulateM\n\nchangeArr :: Point -> (Word32 -> Word32) -> M s Word32\nchangeArr p f = do\n    a    <- asks arr\n    oldC <- liftST $ readArray a p\n    let newC = f oldC\n    liftST $ writeArray a p newC\n    return newC\n\ninc :: Point -> M s ()\ninc p = do\n    b <- inBounds p\n    when b $ do\n        c <- changeArr p succ\n        when (c == 4) $ modify $ (p :)\n\ninBounds :: Point -> M s Bool\ninBounds p = do\n    st <- ask\n    return $ p >= bMin st && p <= bMax st\n\nnorth, east, south, west :: Point -> Point\nnorth (x, y) = (x, y + 1)\neast  (x, y) = (x + 1, y)\nsouth (x, y) = (x, y - 1)\nwest  (x, y) = (x - 1, y)\n\ntoPGM :: ArrayU -> FilePath -> IO ()\ntoPGM a fp = withFile fp WriteMode $ \\h -> do\n    let ((x1, y1), (x2, y2)) = bounds a\n        width  = x2 - x1 + 1\n        height = y2 - y1 + 1\n    hPutStrLn h \"P2\"\n    hPutStrLn h $ show width ++ \" \" ++ show height\n    hPutStrLn h \"3\"\n    forM_ [y1 .. y2] $ \\y -> do\n        forM_ [x1 .. x2] $ \\x -> do\n            let c = min 3 $ a ! (x, y)\n            hPutStr h $ show c ++ \" \"\n        hPutStrLn h \"\"\n\ninitArray :: Int -> Word32 -> ArrayU\ninitArray size height = array \n    ((-size, -size), (size, size))\n    [((x, y), if x == 0 && y == 0 then height else 0) | x <- [-size .. size], y <- [-size .. size]]\n\ntest :: Int -> Word32 -> IO ()\ntest size height = do\n    printf \"size = %d, height = %d\\n\" size height\n    let a  = initArray size height\n        b  = simulate a\n        fp = printf \"sandpile_%d_%d.pgm\" size height\n    toPGM b fp\n    putStrLn $ \"wrote image to \" ++ fp\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"}
{"id": 418708, "name": "Xiaolin Wu's line algorithm", "source": "Translate Haskell to Python: \n\nmodule Main (main) where\n\nimport Codec.Picture (writePng)\nimport Codec.Picture.Types (Image, MutableImage(..), Pixel, PixelRGB8(..), createMutableImage, unsafeFreezeImage, writePixel)\nimport Control.Monad (void)\nimport Control.Monad.Primitive (PrimMonad, PrimState)\nimport Data.Foldable (foldlM)\n\ntype MImage m px = MutableImage (PrimState m) px\n\n\nwithMutableImage\n    :: (Pixel px, PrimMonad m)\n    => Int                      \n    -> Int                      \n    -> px                       \n    -> (MImage m px -> m ())    \n    -> m (Image px)             \nwithMutableImage w h px f = createMutableImage w h px >>= \\m -> f m >> unsafeFreezeImage m\n\n\nplot\n    :: (Pixel px, PrimMonad m)\n    => MImage m px  \n    -> Int          \n    -> Int          \n    -> px           \n    -> m ()         \nplot = writePixel\n\n\ndrawAntialiasedLine\n    :: forall px m . (Pixel px, PrimMonad m)\n    => MImage m px      \n    -> Int              \n    -> Int              \n    -> Int              \n    -> Int              \n    -> (Double -> px)   \n    -> m ()             \ndrawAntialiasedLine m p1x p1y p2x p2y colour = do\n    let steep = abs (p2y - p1y) > abs (p2x - p1x)\n        ((p3x, p4x), (p3y, p4y)) = swapIf steep ((p1x, p2x), (p1y, p2y))\n        ((ax, ay), (bx, by)) = swapIf (p3x > p4x) ((p3x, p3y), (p4x, p4y))\n        dx = bx - ax\n        dy = by - ay\n        gradient = if dx == 0 then 1.0 else fromIntegral dy / fromIntegral dx\n\n    \n    let xpxl1 = ax \n        yend1 = fromIntegral ay + gradient * fromIntegral (xpxl1 - ax)\n        xgap1 = rfpart (fromIntegral ax + 0.5)\n    endpoint steep xpxl1 yend1 xgap1\n\n    \n    let xpxl2 = bx \n        yend2 = fromIntegral by + gradient * fromIntegral (xpxl2 - bx)\n        xgap2 = fpart (fromIntegral bx + 0.5)\n    endpoint steep xpxl2 yend2 xgap2\n\n    \n    let intery = yend1 + gradient\n    void $ if steep\n        then foldlM (\\i x -> do\n            plot m (ipart i) x (colour (rfpart i))\n            plot m (ipart i + 1) x (colour (fpart i))\n            pure $ i + gradient) intery [xpxl1 + 1..xpxl2 - 1]\n        else foldlM (\\i x -> do\n            plot m x (ipart i) (colour (rfpart i))\n            plot m x (ipart i + 1) (colour (fpart i))\n            pure $ i + gradient) intery [xpxl1 + 1..xpxl2 - 1]\n\n    where\n        endpoint :: Bool -> Int -> Double -> Double -> m ()\n        endpoint True xpxl yend xgap = do\n            plot m ypxl xpxl (colour (rfpart yend * xgap))\n            plot m (ypxl + 1) xpxl (colour (fpart yend * xgap))\n            where ypxl = ipart yend\n        endpoint False xpxl yend xgap = do\n            plot m xpxl ypxl (colour (rfpart yend * xgap))\n            plot m xpxl (ypxl + 1) (colour (fpart yend * xgap))\n            where ypxl = ipart yend\n\nswapIf :: Bool -> (a, a) -> (a, a)\nswapIf False p = p\nswapIf True (x, y) = (y, x)\n\nipart :: Double -> Int\nipart = truncate\n\nfpart :: Double -> Double\nfpart x\n    | x > 0 = x - temp\n    | otherwise = x - (temp + 1)\n    where temp = fromIntegral (ipart x)\n\nrfpart :: Double -> Double\nrfpart x = 1 - fpart x\n\nmain :: IO ()\nmain = do\n    \n    \n    img <- withMutableImage 640 480 (PixelRGB8 0 0 0) $ \\m@(MutableImage w h _) ->\n            drawAntialiasedLine m 2 2 (w - 2) (h - 2)\n            (\\brightness -> let level = round (brightness * 255) in PixelRGB8 level level level)\n\n    \n    writePng \"xiaolin-wu-algorithm.png\" img\n", "target": "\nfrom __future__ import division\nimport sys\n\nfrom PIL import Image\n\n\ndef _fpart(x):\n    return x - int(x)\n\ndef _rfpart(x):\n    return 1 - _fpart(x)\n\ndef putpixel(img, xy, color, alpha=1):\n    \n    compose_color = lambda bg, fg: int(round(alpha * fg + (1-alpha) * bg))\n    c = compose_color(img.getpixel(xy), color)\n    img.putpixel(xy, c)\n\ndef draw_line(img, p1, p2, color):\n    \n    x1, y1 = p1\n    x2, y2 = p2\n    dx, dy = x2-x1, y2-y1\n    steep = abs(dx) < abs(dy)\n    p = lambda px, py: ((px,py), (py,px))[steep]\n\n    if steep:\n        x1, y1, x2, y2, dx, dy = y1, x1, y2, x2, dy, dx\n    if x2 < x1:\n        x1, x2, y1, y2 = x2, x1, y2, y1\n\n    grad = dy/dx\n    intery = y1 + _rfpart(x1) * grad\n    def draw_endpoint(pt):\n        x, y = pt\n        xend = round(x)\n        yend = y + grad * (xend - x)\n        xgap = _rfpart(x + 0.5)\n        px, py = int(xend), int(yend)\n        putpixel(img, p(px, py), color, _rfpart(yend) * xgap)\n        putpixel(img, p(px, py+1), color, _fpart(yend) * xgap)\n        return px\n\n    xstart = draw_endpoint(p(*p1)) + 1\n    xend = draw_endpoint(p(*p2))\n\n    for x in range(xstart, xend):\n        y = int(intery)\n        putpixel(img, p(x, y), color, _rfpart(intery))\n        putpixel(img, p(x, y+1), color, _fpart(intery))\n        intery += grad\n\n\nif __name__ == '__main__':\n    if len(sys.argv) != 2:\n        print 'usage: python xiaolinwu.py [output-file]'\n        sys.exit(-1)\n\n    blue = (0, 0, 255)\n    yellow = (255, 255, 0)\n    img = Image.new(\"RGB\", (500,500), blue)\n    for a in range(10, 431, 60):\n        draw_line(img, (10, 10), (490, a), yellow)\n        draw_line(img, (10, 10), (a, 490), yellow)\n    draw_line(img, (10, 10), (490, 490), yellow)\n    filename = sys.argv[1]\n    img.save(filename)\n    print 'image saved to', filename\n"}
{"id": 418709, "name": "Next highest int from digits", "source": "Translate Haskell to Python: import Data.List (nub, permutations, sort)\n\ndigitShuffleSuccessors :: Integer -> [Integer]\ndigitShuffleSuccessors n =\n  (fmap . (+) <*> (nub . sort . concatMap go . permutations . show)) n\n  where\n    go ds\n      | 0 >= delta = []\n      | otherwise = [delta]\n      where\n        delta = (read ds :: Integer) - n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n  fTable\n    \"Taking up to 5 digit-shuffle successors of a positive integer:\\n\"\n    show\n    (\\xs ->\n        let harvest = take 5 xs\n        in rjust\n             12\n             ' '\n             (show (length harvest) <> \" of \" <> show (length xs) <> \": \") <>\n           show harvest)\n    digitShuffleSuccessors\n    [0, 9, 12, 21, 12453, 738440, 45072010, 95322020]\n\n\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  unlines $\n  s : fmap (((<>) . rjust w ' ' . xShow) <*> ((\" -> \" <>) . fxShow . f)) xs\n  where\n    w = maximum (length . xShow <$> xs)\n\nrjust :: Int -> Char -> String -> String\nrjust n c = drop . length <*> (replicate n c <>)\n", "target": "def closest_more_than(n, lst):\n    \"(index of) closest int from lst, to n that is also > n\"\n    large = max(lst) + 1\n    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))\n\ndef nexthigh(n):\n    \"Return nxt highest number from n's digits using scan & re-order\"\n    assert n == int(abs(n)), \"n >= 0\"\n    this = list(int(digit) for digit in str(int(n)))[::-1]\n    mx = this[0]\n    for i, digit in enumerate(this[1:], 1):\n        if digit < mx:\n            mx_index = closest_more_than(digit, this[:i + 1])\n            this[mx_index], this[i] = this[i], this[mx_index]\n            this[:i] = sorted(this[:i], reverse=True)\n            return int(''.join(str(d) for d in this[::-1]))\n        elif digit > mx:\n            mx, mx_index = digit, i\n    return 0\n\n\nif __name__ == '__main__':\n    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,\n              9589776899767587796600]:\n        print(f\"{x:>12_d} -> {nexthigh(x):>12_d}\")\n"}
{"id": 418710, "name": "Next highest int from digits", "source": "Translate Haskell to Python: import Data.List (nub, permutations, sort)\n\ndigitShuffleSuccessors :: Integer -> [Integer]\ndigitShuffleSuccessors n =\n  (fmap . (+) <*> (nub . sort . concatMap go . permutations . show)) n\n  where\n    go ds\n      | 0 >= delta = []\n      | otherwise = [delta]\n      where\n        delta = (read ds :: Integer) - n\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n  fTable\n    \"Taking up to 5 digit-shuffle successors of a positive integer:\\n\"\n    show\n    (\\xs ->\n        let harvest = take 5 xs\n        in rjust\n             12\n             ' '\n             (show (length harvest) <> \" of \" <> show (length xs) <> \": \") <>\n           show harvest)\n    digitShuffleSuccessors\n    [0, 9, 12, 21, 12453, 738440, 45072010, 95322020]\n\n\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  unlines $\n  s : fmap (((<>) . rjust w ' ' . xShow) <*> ((\" -> \" <>) . fxShow . f)) xs\n  where\n    w = maximum (length . xShow <$> xs)\n\nrjust :: Int -> Char -> String -> String\nrjust n c = drop . length <*> (replicate n c <>)\n", "target": "def closest_more_than(n, lst):\n    \"(index of) closest int from lst, to n that is also > n\"\n    large = max(lst) + 1\n    return lst.index(min(lst, key=lambda x: (large if x <= n else x)))\n\ndef nexthigh(n):\n    \"Return nxt highest number from n's digits using scan & re-order\"\n    assert n == int(abs(n)), \"n >= 0\"\n    this = list(int(digit) for digit in str(int(n)))[::-1]\n    mx = this[0]\n    for i, digit in enumerate(this[1:], 1):\n        if digit < mx:\n            mx_index = closest_more_than(digit, this[:i + 1])\n            this[mx_index], this[i] = this[i], this[mx_index]\n            this[:i] = sorted(this[:i], reverse=True)\n            return int(''.join(str(d) for d in this[::-1]))\n        elif digit > mx:\n            mx, mx_index = digit, i\n    return 0\n\n\nif __name__ == '__main__':\n    for x in [0, 9, 12, 21, 12453, 738440, 45072010, 95322020,\n              9589776899767587796600]:\n        print(f\"{x:>12_d} -> {nexthigh(x):>12_d}\")\n"}
{"id": 418711, "name": "Four is magic", "source": "Translate Haskell to Python: module Main where\n\nimport Data.List (find)\nimport Data.Char (toUpper)\n\nfirstNums :: [String]\nfirstNums =\n  [ \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \"ten\",\n    \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n  ]\n\ntens :: [String]\ntens = [\"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\n\nbiggerNumbers :: [(Int, String)]\nbiggerNumbers =\n  [(100, \"hundred\"), (1000, \"thousand\"), (1000000, \"million\"), (1000000000, \"billion\"), (1000000000000, \"trillion\")]\n\ncardinal :: Int -> String\ncardinal n\n  | n' < 20 =\n    negText ++ firstNums !! n'\n  | n' < 100 =\n    negText ++ tens !! (n' `div` 10 - 2) ++ if n' `mod` 10 /= 0 then \"-\" ++ firstNums !! (n' `mod` 10) else \"\"\n  | otherwise =\n    let (num, name) =\n          maybe\n            (last biggerNumbers)\n            fst\n            (find (\\((num_, _), (num_', _)) -> n' < num_') (zip biggerNumbers (tail biggerNumbers)))\n        smallerNum = cardinal (n' `div` num)\n     in negText ++ smallerNum ++ \" \" ++ name ++ if n' `mod` num /= 0 then \" \" ++ cardinal (n' `mod` num) else \"\"\n  where\n    n' = abs n\n    negText = if n < 0 then \"negative \" else \"\"\n\ncapitalized :: String -> String\ncapitalized (x : xs) = toUpper x : xs\ncapitalized [] = []\n\nmagic :: Int -> String\nmagic =\n  go True\n  where\n    go first num =\n      let cardiNum = cardinal num\n       in (if first then capitalized else id) cardiNum ++ \" is \"\n            ++ if num == 4\n              then \"magic.\"\n              else cardinal (length cardiNum) ++ \", \" ++ go False (length cardiNum)\n\nmain :: IO ()\nmain = do\n  putStrLn $ magic 3\n  putStrLn $ magic 15\n  putStrLn $ magic 4\n  putStrLn $ magic 10\n  putStrLn $ magic 20\n  putStrLn $ magic (-13)\n  putStrLn $ magic 999999\n", "target": "import random\nfrom collections import OrderedDict\n\nnumbers = {  \n    1: 'one',\n    2: 'two',\n    3: 'three',\n    4: 'four',\n    5: 'five',\n    6: 'six',\n    7: 'seven',\n    8: 'eight',\n    9: 'nine',\n    10: 'ten',\n    11: 'eleven',\n    12: 'twelve',\n    13: 'thirteen',\n    14: 'fourteen',\n    15: 'fifteen',\n    16: 'sixteen',\n    17: 'seventeen',\n    18: 'eighteen',\n    19: 'nineteen',\n    20: 'twenty',\n    30: 'thirty',\n    40: 'forty',\n    50: 'fifty',\n    60: 'sixty',\n    70: 'seventy',\n    80: 'eighty',\n    90: 'ninety',\n    100: 'hundred',\n    1000: 'thousand',\n    10 ** 6: 'million',\n    10 ** 9: 'billion',\n    10 ** 12: 'trillion',\n    10 ** 15: 'quadrillion',\n    10 ** 18: 'quintillion',\n    10 ** 21: 'sextillion',\n    10 ** 24: 'septillion',\n    10 ** 27: 'octillion',\n    10 ** 30: 'nonillion',\n    10 ** 33: 'decillion',\n    10 ** 36: 'undecillion',\n    10 ** 39: 'duodecillion',\n    10 ** 42: 'tredecillion',\n    10 ** 45: 'quattuordecillion',\n    10 ** 48: 'quinquadecillion',\n    10 ** 51: 'sedecillion',\n    10 ** 54: 'septendecillion',\n    10 ** 57: 'octodecillion',\n    10 ** 60: 'novendecillion',\n    10 ** 63: 'vigintillion',\n    10 ** 66: 'unvigintillion',\n    10 ** 69: 'duovigintillion',\n    10 ** 72: 'tresvigintillion',\n    10 ** 75: 'quattuorvigintillion',\n    10 ** 78: 'quinquavigintillion',\n    10 ** 81: 'sesvigintillion',\n    10 ** 84: 'septemvigintillion',\n    10 ** 87: 'octovigintillion',\n    10 ** 90: 'novemvigintillion',\n    10 ** 93: 'trigintillion',\n    10 ** 96: 'untrigintillion',\n    10 ** 99: 'duotrigintillion',\n    10 ** 102: 'trestrigintillion',\n    10 ** 105: 'quattuortrigintillion',\n    10 ** 108: 'quinquatrigintillion',\n    10 ** 111: 'sestrigintillion',\n    10 ** 114: 'septentrigintillion',\n    10 ** 117: 'octotrigintillion',\n    10 ** 120: 'noventrigintillion',\n    10 ** 123: 'quadragintillion',\n    10 ** 153: 'quinquagintillion',\n    10 ** 183: 'sexagintillion',\n    10 ** 213: 'septuagintillion',\n    10 ** 243: 'octogintillion',\n    10 ** 273: 'nonagintillion',\n    10 ** 303: 'centillion',\n    10 ** 306: 'uncentillion',\n    10 ** 309: 'duocentillion',\n    10 ** 312: 'trescentillion',\n    10 ** 333: 'decicentillion',\n    10 ** 336: 'undecicentillion',\n    10 ** 363: 'viginticentillion',\n    10 ** 366: 'unviginticentillion',\n    10 ** 393: 'trigintacentillion',\n    10 ** 423: 'quadragintacentillion',\n    10 ** 453: 'quinquagintacentillion',\n    10 ** 483: 'sexagintacentillion',\n    10 ** 513: 'septuagintacentillion',\n    10 ** 543: 'octogintacentillion',\n    10 ** 573: 'nonagintacentillion',\n    10 ** 603: 'ducentillion',\n    10 ** 903: 'trecentillion',\n    10 ** 1203: 'quadringentillion',\n    10 ** 1503: 'quingentillion',\n    10 ** 1803: 'sescentillion',\n    10 ** 2103: 'septingentillion',\n    10 ** 2403: 'octingentillion',\n    10 ** 2703: 'nongentillion',\n    10 ** 3003: 'millinillion'\n}\nnumbers = OrderedDict(sorted(numbers.items(), key=lambda t: t[0], reverse=True))\n\n\ndef string_representation(i: int) -> str:\n    \n    if i == 0:\n        return 'zero'\n\n    words = ['negative'] if i < 0 else []\n    working_copy = abs(i)\n\n    for key, value in numbers.items():\n        if key <= working_copy:\n            times = int(working_copy / key)\n\n            if key >= 100:\n                words.append(string_representation(times))\n\n            words.append(value)\n            working_copy -= times * key\n\n        if working_copy == 0:\n            break\n\n    return ' '.join(words)\n\n\ndef next_phrase(i: int):\n    \n    while not i == 4:  \n        str_i = string_representation(i)\n        len_i = len(str_i)\n\n        yield str_i, 'is', string_representation(len_i)\n\n        i = len_i\n\n    \n    yield string_representation(i), 'is', 'magic'\n\n\ndef magic(i: int) -> str:\n    phrases = []\n\n    for phrase in next_phrase(i):\n        phrases.append(' '.join(phrase))\n\n    return f'{\", \".join(phrases)}.'.capitalize()\n\n\nif __name__ == '__main__':\n\n    for j in (random.randint(0, 10 ** 3) for i in range(5)):\n        print(j, ':\\n', magic(j), '\\n')\n\n    for j in (random.randint(-10 ** 24, 10 ** 24) for i in range(2)):\n        print(j, ':\\n', magic(j), '\\n')\n"}
{"id": 418712, "name": "Sierpinski pentagon", "source": "Translate Haskell to Python: import Graphics.Gloss \n\npentaflake :: Int -> Picture\npentaflake order = iterate transformation pentagon !! order\n  where\n    transformation = Scale s s . foldMap copy [0,72..288]\n    copy a = Rotate a . Translate 0 x\n    pentagon = Polygon [ (sin a, cos a) | a <- [0,2*pi/5..2*pi] ]\n    x = 2*cos(pi/5)\n    s = 1/(1+x)\n\nmain = display dc white (Color blue $ Scale 300 300 $ pentaflake 5)\n  where dc = InWindow \"Pentaflake\" (400, 400) (0, 0)\n", "target": "from turtle import *\nimport math\nspeed(0)      \nhideturtle()  \n\npart_ratio = 2 * math.cos(math.radians(72))\nside_ratio = 1 / (part_ratio + 2)\n\nhide_turtles = True   \npath_color = \"black\"  \nfill_color = \"black\"  \n\n\ndef pentagon(t, s):\n  t.color(path_color, fill_color)\n  t.pendown()\n  t.right(36)\n  t.begin_fill()\n  for i in range(5):\n    t.forward(s)\n    t.right(72)\n  t.end_fill()\n\n\ndef sierpinski(i, t, s):\n  t.setheading(0)\n  new_size = s * side_ratio\n  \n  if i > 1:\n    i -= 1\n    \n    \n    for j in range(4):\n      t.right(36)\n      short = s * side_ratio / part_ratio\n      dist = [short, s, s, short][j]\n      \n      \n      spawn = Turtle()\n      if hide_turtles:spawn.hideturtle()\n      spawn.penup()\n      spawn.setposition(t.position())\n      spawn.setheading(t.heading())\n      spawn.forward(dist)\n      \n      \n      sierpinski(i, spawn, new_size)\n    \n    \n    sierpinski(i, t, new_size)\n    \n  else:\n    \n    pentagon(t, s)\n    \n    del t\n\ndef main():\n  t = Turtle()\n  t.hideturtle()\n  t.penup()\n  screen = t.getscreen()\n  y = screen.window_height()\n  t.goto(0, y/2-20)\n  \n  i = 5       \n  size = 300  \n  \n  \n  size *= part_ratio\n  \n  \n  sierpinski(i, t, size)\n\nmain()\n"}
{"id": 418713, "name": "Zhang-Suen thinning algorithm", "source": "Translate Haskell to Python: import Data.Array\nimport qualified Data.List as List\n\ndata BW = Black | White\n        deriving (Eq, Show)\n\ntype Index = (Int, Int)\ntype BWArray = Array Index BW\n\ntoBW :: Char -> BW\ntoBW '0' = White\ntoBW '1' = Black\ntoBW ' ' = White\ntoBW '#' = Black\ntoBW _   = error \"toBW: illegal char\"\n\ntoBWArray :: [String] -> BWArray\ntoBWArray strings = arr\n  where\n    height = length strings\n    width  = minimum $ map length strings\n    arr    = listArray ((0, 0), (width - 1, height - 1))\n             . map toBW . concat . List.transpose $ map (take width) strings\n\ntoChar :: BW -> Char\ntoChar White = ' '\ntoChar Black = '#'\n\nchunksOf :: Int -> [a] -> [[a]]\nchunksOf _ [] = []\nchunksOf n xs = take n xs : (chunksOf n $ drop n xs)\n\nshowBWArray :: BWArray -> String\nshowBWArray arr =\n  List.intercalate \"\\n\" . List.transpose\n  . chunksOf (height + 1) . map toChar $ elems arr\n  where\n    (_, (_, height)) = bounds arr\n\nadd :: Num a => (a, a) -> (a, a) -> (a, a)\nadd (a, b) (x, y) = (a + x, b + y)\n\nwithin :: Ord a => ((a, a), (a, a)) -> (a, a) -> Bool\nwithin ((a, b), (c, d)) (x, y) =\n  a <= x && x <= c &&\n  b <= y && y <= d\n\np2, p3, p4, p5, p6, p7, p8, p9 :: Index\np2 = ( 0, -1)\np3 = ( 1, -1)\np4 = ( 1,  0)\np5 = ( 1,  1)\np6 = ( 0,  1)\np7 = (-1,  1)\np8 = (-1,  0)\np9 = (-1, -1)\n\nixamap :: Ix i => ((i, a) -> b) -> Array i a -> Array i b\nixamap f a = listArray (bounds a) $ map f $ assocs a\n\nthin :: BWArray -> BWArray\nthin arr =\n  if pass2 == arr then pass2 else thin pass2\n  where\n    (low, high)     = bounds arr\n    lowB            = low `add` (1, 1)\n    highB           = high `add` (-1, -1)\n    isInner         = within (lowB, highB)\n    offs p          = map (add p) [p2, p3, p4, p5, p6, p7, p8, p9]\n    trans c (a, b)  = if a == White && b == Black then c + 1 else c\n    zipshift xs     = zip xs (drop 1 xs ++ xs)\n    transitions a   = (== (1 :: Int)) . foldl trans 0 . zipshift . map (a !) . offs\n    within2to6 n    = 2 <= n && n <= 6\n    blacks a p      = within2to6 . length . filter ((== Black) . (a !)) $ offs p\n    oneWhite xs a p = any ((== White) . (a !) . add p) xs\n    oneRight        = oneWhite [p2, p4, p6]\n    oneDown         = oneWhite [p4, p6, p8]\n    oneUp           = oneWhite [p2, p4, p8]\n    oneLeft         = oneWhite [p2, p6, p8]\n    precond a p     = (a ! p == Black) && isInner p && blacks a p && transitions a p\n    stage1 a p      = precond a p && oneRight a p && oneDown a p\n    stage2 a p      = precond a p && oneUp a p && oneLeft a p\n    stager f (p, d) = if f p then White else d\n    pass1           = ixamap (stager $ stage1 arr) arr\n    pass2           = ixamap (stager $ stage2 pass1) pass1\n\nsampleExA :: [String]\nsampleExA =\n  [\"00000000000000000000000000000000\"\n  ,\"01111111110000000111111110000000\"\n  ,\"01110001111000001111001111000000\"\n  ,\"01110000111000001110000111000000\"\n  ,\"01110001111000001110000000000000\"\n  ,\"01111111110000001110000000000000\"\n  ,\"01110111100000001110000111000000\"\n  ,\"01110011110011101111001111011100\"\n  ,\"01110001111011100111111110011100\"\n  ,\"00000000000000000000000000000000\"]\n\nsampleExB :: [String]\nsampleExB =\n  [\"                                                          \"\n  ,\" #################                   #############        \"\n  ,\" ##################               ################        \"\n  ,\" ###################            ##################        \"\n  ,\" ########     #######          ###################        \"\n  ,\"   ######     #######         #######       ######        \"\n  ,\"   ######     #######        #######                      \"\n  ,\"   #################         #######                      \"\n  ,\"   ################          #######                      \"\n  ,\"   #################         #######                      \"\n  ,\"   ######     #######        #######                      \"\n  ,\"   ######     #######        #######                      \"\n  ,\"   ######     #######         #######       ######        \"\n  ,\" ########     #######          ###################        \"\n  ,\" ########     ####### ######    ################## ###### \"\n  ,\" ########     ####### ######      ################ ###### \"\n  ,\" ########     ####### ######         ############# ###### \"\n  ,\"                                                          \"]\n\nmain :: IO ()\nmain = mapM_ (putStrLn . showBWArray . thin . toBWArray) [sampleExA, sampleExB]\n", "target": "\n\n\nbeforeTxt = \n\n\nsmallrc01 = \n\nrc01 = \n\ndef intarray(binstring):\n    \n    return [[1 if ch == '1' else 0 for ch in line] \n            for line in binstring.strip().split()]\n\ndef chararray(intmatrix):\n    \n    return '\\n'.join(''.join(str(p) for p in row) for row in intmatrix)\n\ndef toTxt(intmatrix):\n    Return 8-neighbours of point p1 of picture, in order'''\n    i = image\n    x1, y1, x_1, y_1 = x+1, y-1, x-1, y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n\ndef transitions(neighbours):\n    n = neighbours + neighbours[0:1]    \n    return sum((n1, n2) == (0, 1) for n1, n2 in zip(n, n[1:]))\n\ndef zhangSuen(image):\n    changing1 = changing2 = [(-1, -1)]\n    while changing1 or changing2:\n        \n        changing1 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P4 * P6 * P8 == 0 and   \n                    P2 * P4 * P6 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing1.append((x,y))\n        for x, y in changing1: image[y][x] = 0\n        \n        changing2 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P2 * P6 * P8 == 0 and   \n                    P2 * P4 * P8 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing2.append((x,y))\n        for x, y in changing2: image[y][x] = 0\n        \n        \n    return image\n            \n\nif __name__ == '__main__':\n    for picture in (beforeTxt, smallrc01, rc01):\n        image = intarray(picture)\n        print('\\nFrom:\\n%s' % toTxt(image))\n        after = zhangSuen(image)\n        print('\\nTo thinned:\\n%s' % toTxt(after))\n"}
{"id": 418714, "name": "Generate Chess960 starting position", "source": "Translate Haskell to Python: import Data.List\nimport qualified Data.Set as Set\n\ndata Piece = K | Q | R | B | N deriving (Eq, Ord, Show)\n\nisChess960 :: [Piece] -> Bool\nisChess960 rank =\n  (odd . sum $ findIndices (== B) rank) && king > rookA && king < rookB\n  where\n    Just king      = findIndex (== K) rank\n    [rookA, rookB] = findIndices (== R) rank\n\nmain :: IO ()\nmain = mapM_ (putStrLn . concatMap show) . Set.toList . Set.fromList\n       . filter isChess960 $ permutations [R,N,B,Q,K,B,N,R]\n", "target": ">>> from itertools import permutations\n>>> pieces = 'KQRrBbNN'\n>>> starts = {''.join(p).upper() for p in permutations(pieces)\n                     if p.index('B') % 2 != p.index('b') % 2 \t\t\n                     and ( p.index('r') < p.index('K') < p.index('R')\t\n                           or p.index('R') < p.index('K') < p.index('r') ) }\n>>> len(starts)\n960\n>>> starts.pop()\n'QNBRNKRB'\n>>>\n"}
{"id": 418715, "name": "Spelling of ordinal numbers", "source": "Translate Haskell to Python: spellOrdinal :: Integer -> String\nspellOrdinal n\n | n <=   0  = \"not ordinal\"\n | n <   20  = small n\n | n < 100   = case divMod n 10 of\n     (k, 0) -> spellInteger (10*k) ++ \"th\"\n     (k, m) -> spellInteger (10*k) ++ \"-\" ++ spellOrdinal m\n | n < 1000 = case divMod n 100 of\n     (k, 0) -> spellInteger (100*k) ++ \"th\"\n     (k, m) -> spellInteger (100*k) ++ \" and \" ++ spellOrdinal m\n | otherwise = case divMod n 1000 of\n     (k, 0) -> spellInteger (1000*k) ++ \"th\"\n     (k, m) -> spellInteger (k*1000) ++ s ++ spellOrdinal m\n       where s = if m < 100 then \" and \" else \", \"   \n  where \n   small = ([ undefined, \"first\", \"second\", \"third\", \"fourth\", \"fifth\"\n            , \"sixth\", \"seventh\", \"eighth\", \"nineth\", \"tenth\", \"eleventh\"\n            , \"twelveth\", \"thirteenth\", \"fourteenth\", \"fifteenth\", \"sixteenth\"\n            , \"seventeenth\", \"eighteenth\", \"nineteenth\"] !!) . fromEnum\n", "target": "irregularOrdinals = {\n\t\"one\":    \"first\",\n\t\"two\":    \"second\",\n\t\"three\":  \"third\",\n\t\"five\":   \"fifth\",\n\t\"eight\":  \"eighth\",\n\t\"nine\":   \"ninth\",\n\t\"twelve\": \"twelfth\",\n}\n\ndef num2ordinal(n):\n    conversion = int(float(n))\n    num = spell_integer(conversion)\n    hyphen = num.rsplit(\"-\", 1)\n    num = num.rsplit(\" \", 1)\n    delim = \" \"\n    if len(num[-1]) > len(hyphen[-1]):\n        num = hyphen\n        delim = \"-\"\n    \n    if num[-1] in irregularOrdinals:\n        num[-1] = delim + irregularOrdinals[num[-1]]\n    elif num[-1].endswith(\"y\"):\n        num[-1] = delim + num[-1][:-1] + \"ieth\"\n    else:\n        num[-1] = delim + num[-1] + \"th\"\n    return \"\".join(num)\n    \nif __name__ == \"__main__\":\n    tests = \"1  2  3  4  5  11  65  100  101  272  23456  8007006005004003 123   00123.0   1.23e2\".split()\n    for num in tests:\n        print(\"{} => {}\".format(num, num2ordinal(num)))\n\n\n\n\nTENS = [None, None, \"twenty\", \"thirty\", \"forty\",\n        \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"]\nSMALL = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\",\n         \"six\", \"seven\", \"eight\", \"nine\", \"ten\", \"eleven\",\n         \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\",\n         \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"]\nHUGE = [None, None] + [h + \"illion\" \n                       for h in (\"m\", \"b\", \"tr\", \"quadr\", \"quint\", \"sext\", \n                                  \"sept\", \"oct\", \"non\", \"dec\")]\n \ndef nonzero(c, n, connect=''):\n    return \"\" if n == 0 else connect + c + spell_integer(n)\n \ndef last_and(num):\n    if ',' in num:\n        pre, last = num.rsplit(',', 1)\n        if ' and ' not in last:\n            last = ' and' + last\n        num = ''.join([pre, ',', last])\n    return num\n \ndef big(e, n):\n    if e == 0:\n        return spell_integer(n)\n    elif e == 1:\n        return spell_integer(n) + \" thousand\"\n    else:\n        return spell_integer(n) + \" \" + HUGE[e]\n \ndef base1000_rev(n):\n    \n    \n    while n != 0:\n        n, r = divmod(n, 1000)\n        yield r\n \ndef spell_integer(n):\n    if n < 0:\n        return \"minus \" + spell_integer(-n)\n    elif n < 20:\n        return SMALL[n]\n    elif n < 100:\n        a, b = divmod(n, 10)\n        return TENS[a] + nonzero(\"-\", b)\n    elif n < 1000:\n        a, b = divmod(n, 100)\n        return SMALL[a] + \" hundred\" + nonzero(\" \", b, ' and')\n    else:\n        num = \", \".join([big(e, x) for e, x in\n                         enumerate(base1000_rev(n)) if x][::-1])\n        return last_and(num)\n"}
{"id": 418716, "name": "Parse an IP Address", "source": "Translate Haskell to Python: import Data.List (isInfixOf)\nimport Numeric (showHex)\nimport Data.Char (isDigit)\n\ndata IPChunk = IPv6Chunk String | IPv4Chunk (String, String) |\n    IPv6WithPort [IPChunk] String | IPv6NoPort [IPChunk] |\n    IPv4WithPort IPChunk String | IPv4NoPort IPChunk |\n    IPInvalid | IPZeroSection | IPUndefinedWithPort String |\n    IPUndefinedNoPort\n\ninstance Show IPChunk where\n    show (IPv6Chunk a) = a\n    show (IPv4Chunk (a,b)) = a ++ b\n    show (IPv6WithPort a p) = \"IPv6 \" ++ concatMap show a ++ \" port \" ++ p\n    show (IPv6NoPort a) = \"IPv6 \" ++ concatMap show a ++ \" no port\"\n    show (IPv4WithPort a p) = \"IPv4 \" ++ show a ++ \" port \" ++ p\n    show (IPv4NoPort a) = \"IPv4 \" ++ show a\n    show IPInvalid = \"Invalid IP address\"\n    \nisIPInvalid IPInvalid = True\nisIPInvalid _ = False\n\nisIPZeroSection IPZeroSection = True\nisIPZeroSection _ = False\n\nsplitOn _ [] = []\nsplitOn x xs = let (a, b) = break (== x) xs in a : splitOn x (drop 1 b)\n\ncount x = length . filter (== x)\n\nbetween a b x = x >= a && x <= b\n\nnone f = all (not . f)\n\nparse1 [] = IPInvalid\nparse1 \"::\" = IPUndefinedNoPort\nparse1 ('[':':':':':']':':':ps) = if portIsValid ps then IPUndefinedWithPort ps else IPInvalid\nparse1 ('[':xs) = if \"]:\" `isInfixOf` xs\n    then let (a, b) = break (== ']') xs in\n            if tail b == \":\" then IPInvalid else IPv6WithPort (map chunk (splitOn ':' a)) (drop 2 b)\n    else IPInvalid\nparse1 xs\n    | count ':' xs <= 1 && count '.' xs == 3 =\n        let (a, b) = break (== ':') xs in case b of\n                \"\" -> IPv4NoPort (chunk a)\n                (':':ps) -> IPv4WithPort (chunk a) ps\n                _ -> IPInvalid\n    | count ':' xs > 1 && count '.' xs <= 3 =\n        IPv6NoPort (map chunk (splitOn ':' xs))\n            \nchunk [] = IPZeroSection\nchunk xs\n    | '.' `elem` xs = case splitOn '.' xs of\n        [a,b,c,d] -> let [e,f,g,h] = map read [a,b,c,d]\n                     in if all (between 0 255) [e,f,g,h]\n                            then let [i,j,k,l] = map (\\n -> fill 2 $ showHex n \"\") [e,f,g,h]\n                                 in IPv4Chunk (i ++ j, k ++ l)\n                            else IPInvalid\n    | ':' `notElem` xs && between 1 4 (length xs) && all (`elem` \"0123456789abcdef\") xs = IPv6Chunk (fill 4 xs)\n    | otherwise = IPInvalid \n\nfill n xs = replicate (n - length xs) '0' ++ xs\n\nparse2 IPInvalid = IPInvalid\nparse2 (IPUndefinedWithPort p) = IPv6WithPort (replicate 8 zeroChunk) p\nparse2 IPUndefinedNoPort = IPv6NoPort (replicate 8 zeroChunk)\nparse2 a = case a of\n    IPv6WithPort xs p -> if none isIPInvalid xs && portIsValid p\n        then let ys = complete xs\n             in  if countChunks ys == 8\n                     then IPv6WithPort ys p\n                     else IPInvalid\n        else IPInvalid\n    IPv6NoPort xs -> if none isIPInvalid xs\n        then let ys = complete xs\n             in  if countChunks ys == 8\n                     then IPv6NoPort ys\n                     else IPInvalid\n        else IPInvalid\n    IPv4WithPort (IPv4Chunk a) p -> if portIsValid p\n        then IPv4WithPort (IPv4Chunk a) p\n        else IPInvalid\n    IPv4NoPort (IPv4Chunk a) -> IPv4NoPort (IPv4Chunk a)\n    _ -> IPInvalid\n\nzeroChunk = IPv6Chunk \"0000\"\n\nportIsValid a = all isDigit a && between 0 65535 (read a)\n\ncomplete xs = case break isIPZeroSection xs of\n    (_, [IPZeroSection]) -> []\n    (ys, []) -> ys\n    ([], (IPZeroSection:IPZeroSection:ys)) -> if any isIPZeroSection ys || countChunks ys > 7\n        then []\n        else replicate (8 - countChunks ys) zeroChunk ++ ys\n    (ys, (IPZeroSection:zs)) -> if any isIPZeroSection zs || countChunks ys + countChunks zs > 7\n        then []\n        else ys ++ replicate (8 - countChunks ys - countChunks zs) zeroChunk ++ zs\n    _ -> []\n\ncountChunks xs = foldl f 0 xs\n    where f n (IPv4Chunk _) = n + 2\n          f n (IPv6Chunk _) = n + 1\n    \nip = parse2 . parse1\n\nmain = mapM_ (putStrLn . show . ip)\n    [\"127.0.0.1\",                                  \n     \"127.0.0.1:80\",                               \n     \"::1\",                                        \n     \"[::1]:80\",                                   \n     \"2605:2700:0:3::4713:93e3\",                   \n     \"[2605:2700:0:3::4713:93e3]:80\"]              \n", "target": "from ipaddress import ip_address\nfrom urllib.parse import urlparse\n\ntests = [\n    \"127.0.0.1\",\n    \"127.0.0.1:80\",\n    \"::1\",\n    \"[::1]:80\",\n    \"::192.168.0.1\",\n    \"2605:2700:0:3::4713:93e3\",\n    \"[2605:2700:0:3::4713:93e3]:80\" ]\n\ndef parse_ip_port(netloc):\n    try:\n        ip = ip_address(netloc)\n        port = None\n    except ValueError:\n        parsed = urlparse('//{}'.format(netloc))\n        ip = ip_address(parsed.hostname)\n        port = parsed.port\n    return ip, port\n\nfor address in tests:\n    ip, port = parse_ip_port(address)\n    hex_ip = {4:'{:08X}', 6:'{:032X}'}[ip.version].format(int(ip))\n    print(\"{:39s}  {:>32s}  IPv{}  port={}\".format(\n        str(ip), hex_ip, ip.version, port ))\n"}
{"id": 418717, "name": "Getting the number of decimal places", "source": "Translate Haskell to Python: decimal :: String -> Int\ndecimal [] = 0\ndecimal ('.':xs) = length xs\ndecimal (_:xs) = decimal xs\n\nnumDecimal :: Double -> Int\nnumDecimal = decimal . show\n\nmain = print . map numDecimal $ [12.0, 12.345, 12.3450, 12.345555555555, 12.34555555555555555555, 1.2345e+54]\n", "target": "In [6]: def dec(n):\n   ...:     return len(n.rsplit('.')[-1]) if '.' in n else 0\n\nIn [7]: dec('12.345')\nOut[7]: 3\n\nIn [8]: dec('12.3450')\nOut[8]: 4\n\nIn [9]:\n"}
{"id": 418718, "name": "Minimum number of cells after, before, above and below NxN squares", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\n\n\n\ndistancesToEdge :: Int -> [[Int]]\ndistancesToEdge n =\n  ( \\i ->\n      chunksOf n $\n        (\\(x, y) -> minimum [x, y, i - x, i - y])\n          <$> (fmap (,) >>= (<*>)) [0 .. i]\n  )\n    $ pred n\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    showMatrix . distancesToEdge <$> [10, 9, 2, 1]\n\n\n\nshowMatrix :: Show a => [[a]] -> String\nshowMatrix m =\n  let w = (succ . maximum) $ fmap (length . show) =<< m\n      rjust n c = (drop . length) <*> (replicate n c <>)\n   in unlines (unwords . fmap (rjust w ' ' . show) <$> m)\n", "target": "def min_cells_matrix(siz):\n    return [[min(row, col, siz - row - 1, siz - col - 1) for col in range(siz)] for row in range(siz)]\n\ndef display_matrix(mat):\n    siz = len(mat)\n    spaces = 2 if siz < 20 else 3 if siz < 200 else 4\n    print(f\"\\nMinimum number of cells after, before, above and below {siz} x {siz} square:\")\n    for row in range(siz):\n        print(\"\".join([f\"{n:{spaces}}\" for n in mat[row]]))\n\ndef test_min_mat():\n    for siz in [23, 10, 9, 2, 1]:\n        display_matrix(min_cells_matrix(siz))\n\nif __name__ == \"__main__\":\n    test_min_mat()\n"}
{"id": 418719, "name": "Maximum difference between adjacent elements of list", "source": "Translate Haskell to Python: import Data.List (maximumBy)\nimport Data.Ord (comparing)\n\nmaxDeltas :: (Num a, Ord a) => [a] -> [(a, (a, a))]\nmaxDeltas xs = filter ((delta ==) . fst) pairs\n  where\n    pairs =\n      zipWith\n        (\\a b -> (abs (a - b), (a, b)))\n        xs\n        (tail xs)\n    delta = fst $ maximumBy (comparing fst) pairs\n\nmain :: IO ()\nmain =\n  mapM_ print $\n    maxDeltas [1, 8, 2, -3, 0, 1, 1, -2.3, 0, 5.5, 8, 6, 2, 9, 11, 10, 3]\n", "target": "\n\n\n\ndef maxDeltas(ns):\n    \n    pairs = [\n        (abs(a - b), (a, b)) for a, b\n        in zip(ns, ns[1:])\n    ]\n    delta = max(pairs, key=lambda ab: ab[0])[0]\n\n    return [\n        ab for ab in pairs\n        if delta == ab[0]\n    ]\n\n\n\n\ndef main():\n    \n\n    maxPairs = maxDeltas([\n        1, 8, 2, -3, 0, 1, 1, -2.3, 0,\n        5.5, 8, 6, 2, 9, 11, 10, 3\n    ])\n\n    for ab in maxPairs:\n        print(ab)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418720, "name": "Chemical calculator", "source": "Translate Haskell to Python: import Control.Monad (forM_)\nimport Control.Monad.Reader (Reader, ask, runReader)\nimport Data.Bifunctor (first)\nimport Data.Map (Map)\nimport qualified Data.Map as M\nimport Data.Void (Void)\nimport System.Environment (getArgs)\nimport System.IO (IOMode(ReadMode), withFile)\nimport System.IO.Strict (hGetContents)\nimport Text.Megaparsec (ParsecT, (<|>), between, errorBundlePretty, getOffset,\n                        many, option, runParserT, some, setOffset)\nimport Text.Megaparsec.Char (char, lowerChar, upperChar)\nimport Text.Megaparsec.Char.Lexer (decimal)\nimport Text.Printf (printf)\n\ntype Masses     = Map String Double\ntype ChemParser = ParsecT Void String (Reader Masses) Double\n\n\nmolecule :: ChemParser\nmolecule = sum <$> some (atomGroup <|> atom)\n\n\n\natomGroup :: ChemParser\natomGroup = mul <$> between (char '(') (char ')') molecule <*> option 1 decimal\n\n\natom :: ChemParser\natom = mul <$> atomMass <*> option 1 decimal\n\n\natomMass :: ChemParser\natomMass = do\n  off <- getOffset\n  masses <- ask\n  atomName <- (:) <$> upperChar <*> many lowerChar\n  case M.lookup atomName masses of\n    Nothing -> setOffset off >> fail \"invalid atom name starting here\"\n    Just mass -> return mass\n\n\n\nmolarMass :: String -> String -> Masses -> Either String Double\nmolarMass file formula = first errorBundlePretty . runChemParser\n  where runChemParser = runReader (runParserT molecule file formula)\n\n\ngetMasses :: FilePath -> IO Masses\ngetMasses path = withFile path ReadMode (fmap read . hGetContents)\n\nmul :: Double -> Int -> Double\nmul s n = s * fromIntegral n\n\nmain :: IO ()\nmain = do\n  masses <- getMasses \"chemcalc_masses.in\"\n  molecs <- getArgs\n  forM_ molecs $ \\molec -> do\n    printf \"%-20s\" molec\n    case molarMass \"<stdin>\" molec masses of\n      Left err   -> printf \"\\n%s\" err\n      Right mass -> printf \"\u00a0%.4f\\n\" mass\n", "target": "assert   1.008 == molar_mass('H')                  \nassert   2.016 == molar_mass('H2')                 \nassert  18.015 == molar_mass('H2O')                \nassert  34.014 == molar_mass('H2O2')               \nassert  34.014 == molar_mass('(HO)2')              \nassert 142.036 == molar_mass('Na2SO4')             \nassert  84.162 == molar_mass('C6H12')              \nassert 186.295 == molar_mass('COOH(C(CH3)2)3CH3')  \nassert 176.124 == molar_mass('C6H4O2(OH)4')        \nassert 386.664 == molar_mass('C27H46O')            \nassert 315     == molar_mass('Uue')                \n"}
{"id": 418721, "name": "Arithmetic evaluation", "source": "Translate Haskell to Python: \n\nimport Text.Parsec\nimport Text.Parsec.Expr\nimport Text.Parsec.Combinator\nimport Data.Functor\nimport Data.Function (on)\n\ndata Exp\n  = Num Int\n  | Add Exp\n        Exp\n  | Sub Exp\n        Exp\n  | Mul Exp\n        Exp\n  | Div Exp\n        Exp\n\nexpr\n  :: Stream s m Char\n  => ParsecT s u m Exp\nexpr = buildExpressionParser table factor\n  where\n    table =\n      [ [op \"*\" Mul AssocLeft, op \"/\" Div AssocLeft]\n      , [op \"+\" Add AssocLeft, op \"-\" Sub AssocLeft]\n      ]\n    op s f = Infix (f <$ string s)\n    factor = (between `on` char) '(' ')' expr <|> (Num . read <$> many1 digit)\n\neval\n  :: Integral a\n  => Exp -> a\neval (Num x) = fromIntegral x\neval (Add a b) = eval a + eval b\neval (Sub a b) = eval a - eval b\neval (Mul a b) = eval a * eval b\neval (Div a b) = eval a `div` eval b\n\nsolution\n  :: Integral a\n  => String -> a\nsolution = either (const (error \"Did not parse\")) eval . parse expr \"\"\n\nmain :: IO ()\nmain = print $ solution \"(1+3)*7\"\n", "target": "import operator\n\nclass AstNode(object):\n   def __init__( self, opr, left, right ):\n      self.opr = opr\n      self.l = left\n      self.r = right\n\n   def eval(self):\n      return self.opr(self.l.eval(), self.r.eval())\n\nclass LeafNode(object):\n   def __init__( self, valStrg ):\n      self.v = int(valStrg)\n\n   def eval(self):\n      return self.v\n\nclass Yaccer(object):\n   def __init__(self):\n      self.operstak = []\n      self.nodestak =[]\n      self.__dict__.update(self.state1)\n\n   def v1( self, valStrg ):\n      \n      self.nodestak.append( LeafNode(valStrg))\n      self.__dict__.update(self.state2)\n      \n\n   def o2( self, operchar ):\n      \n      def openParen(a,b):\n         return 0\t\t\n\n      opDict= { '+': ( operator.add, 2, 2 ),\n         '-': (operator.sub, 2, 2 ),\n         '*': (operator.mul, 3, 3 ),\n         '/': (operator.div, 3, 3 ),\n         '^': ( pow,         4, 5 ),  \n         '(': ( openParen,   0, 8 )\n         }\n      operPrecidence = opDict[operchar][2]\n      self.redeuce(operPrecidence)\n\n      self.operstak.append(opDict[operchar])\n      self.__dict__.update(self.state1)\n      \n\n   def syntaxErr(self, char ):\n      \n      print 'parse error - near operator \"%s\"' %char\n\n   def pc2( self,operchar ):\n      \n      \n      self.redeuce( 1 )\n      if len(self.operstak)>0:\n         self.operstak.pop()\t\t\n      else:\n         print 'Error - no open parenthesis matches close parens.'\n      self.__dict__.update(self.state2)\n\n   def end(self):\n      self.redeuce(0)\n      return self.nodestak.pop()\n\n   def redeuce(self, precidence):\n      while len(self.operstak)>0:\n         tailOper = self.operstak[-1]\n         if tailOper[1] < precidence: break\n\n         tailOper = self.operstak.pop()\n         vrgt = self.nodestak.pop()\n         vlft= self.nodestak.pop()\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\n         \n\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\n\n\ndef Lex( exprssn, p ):\n   bgn = None\n   cp = -1\n   for c in exprssn:\n      cp += 1\n      if c in '+-/*^()':         \n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         if c=='(': p.po(p, c)\n         elif c==')':p.pc(p, c)\n         else: p.o(p, c)\n      elif c in ' \\t':\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n      elif c in '0123456789':\n         if bgn is None:\n            bgn = cp\n      else:\n         print 'Invalid character in expression'\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         \n   if bgn is not None:\n      p.v(p, exprssn[bgn:cp+1])\n      bgn = None\n   return p.end()\n\n\nexpr = raw_input(\"Expression:\")\nastTree = Lex( expr, Yaccer())\nprint expr, '=',astTree.eval()\n"}
{"id": 418722, "name": "Arithmetic evaluation", "source": "Translate Haskell to Python: \n\nimport Text.Parsec\nimport Text.Parsec.Expr\nimport Text.Parsec.Combinator\nimport Data.Functor\nimport Data.Function (on)\n\ndata Exp\n  = Num Int\n  | Add Exp\n        Exp\n  | Sub Exp\n        Exp\n  | Mul Exp\n        Exp\n  | Div Exp\n        Exp\n\nexpr\n  :: Stream s m Char\n  => ParsecT s u m Exp\nexpr = buildExpressionParser table factor\n  where\n    table =\n      [ [op \"*\" Mul AssocLeft, op \"/\" Div AssocLeft]\n      , [op \"+\" Add AssocLeft, op \"-\" Sub AssocLeft]\n      ]\n    op s f = Infix (f <$ string s)\n    factor = (between `on` char) '(' ')' expr <|> (Num . read <$> many1 digit)\n\neval\n  :: Integral a\n  => Exp -> a\neval (Num x) = fromIntegral x\neval (Add a b) = eval a + eval b\neval (Sub a b) = eval a - eval b\neval (Mul a b) = eval a * eval b\neval (Div a b) = eval a `div` eval b\n\nsolution\n  :: Integral a\n  => String -> a\nsolution = either (const (error \"Did not parse\")) eval . parse expr \"\"\n\nmain :: IO ()\nmain = print $ solution \"(1+3)*7\"\n", "target": "import operator\n\nclass AstNode(object):\n   def __init__( self, opr, left, right ):\n      self.opr = opr\n      self.l = left\n      self.r = right\n\n   def eval(self):\n      return self.opr(self.l.eval(), self.r.eval())\n\nclass LeafNode(object):\n   def __init__( self, valStrg ):\n      self.v = int(valStrg)\n\n   def eval(self):\n      return self.v\n\nclass Yaccer(object):\n   def __init__(self):\n      self.operstak = []\n      self.nodestak =[]\n      self.__dict__.update(self.state1)\n\n   def v1( self, valStrg ):\n      \n      self.nodestak.append( LeafNode(valStrg))\n      self.__dict__.update(self.state2)\n      \n\n   def o2( self, operchar ):\n      \n      def openParen(a,b):\n         return 0\t\t\n\n      opDict= { '+': ( operator.add, 2, 2 ),\n         '-': (operator.sub, 2, 2 ),\n         '*': (operator.mul, 3, 3 ),\n         '/': (operator.div, 3, 3 ),\n         '^': ( pow,         4, 5 ),  \n         '(': ( openParen,   0, 8 )\n         }\n      operPrecidence = opDict[operchar][2]\n      self.redeuce(operPrecidence)\n\n      self.operstak.append(opDict[operchar])\n      self.__dict__.update(self.state1)\n      \n\n   def syntaxErr(self, char ):\n      \n      print 'parse error - near operator \"%s\"' %char\n\n   def pc2( self,operchar ):\n      \n      \n      self.redeuce( 1 )\n      if len(self.operstak)>0:\n         self.operstak.pop()\t\t\n      else:\n         print 'Error - no open parenthesis matches close parens.'\n      self.__dict__.update(self.state2)\n\n   def end(self):\n      self.redeuce(0)\n      return self.nodestak.pop()\n\n   def redeuce(self, precidence):\n      while len(self.operstak)>0:\n         tailOper = self.operstak[-1]\n         if tailOper[1] < precidence: break\n\n         tailOper = self.operstak.pop()\n         vrgt = self.nodestak.pop()\n         vlft= self.nodestak.pop()\n         self.nodestak.append( AstNode(tailOper[0], vlft, vrgt))\n         \n\n   state1 = { 'v': v1, 'o':syntaxErr, 'po':o2, 'pc':syntaxErr }\n   state2 = { 'v': syntaxErr, 'o':o2, 'po':syntaxErr, 'pc':pc2 }\n\n\ndef Lex( exprssn, p ):\n   bgn = None\n   cp = -1\n   for c in exprssn:\n      cp += 1\n      if c in '+-/*^()':         \n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         if c=='(': p.po(p, c)\n         elif c==')':p.pc(p, c)\n         else: p.o(p, c)\n      elif c in ' \\t':\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n      elif c in '0123456789':\n         if bgn is None:\n            bgn = cp\n      else:\n         print 'Invalid character in expression'\n         if bgn is not None:\n            p.v(p, exprssn[bgn:cp])\n            bgn = None\n         \n   if bgn is not None:\n      p.v(p, exprssn[bgn:cp+1])\n      bgn = None\n   return p.end()\n\n\nexpr = raw_input(\"Expression:\")\nastTree = Lex( expr, Yaccer())\nprint expr, '=',astTree.eval()\n"}
{"id": 418723, "name": "Selectively replace multiple instances of a character within a string", "source": "Translate Haskell to Python: import Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nnthCharsReplaced :: M.Map Char [Maybe Char] -> String -> String\nnthCharsReplaced ruleMap = snd . mapAccumL go ruleMap\n  where\n    go a c =\n      case M.lookup c a of\n        Nothing -> (a, c)\n        Just [] -> (a, c)\n        Just (d : ds) ->\n          ( M.insert c ds a,\n            fromMaybe c d\n          )\n\n\nmain :: IO ()\nmain = putStrLn $ nthCharsReplaced rules \"abracadabra\"\n\nrules :: M.Map Char [Maybe Char]\nrules =\n  M.fromList\n    [ ('a', (Just <$> \"AB\") <> [Nothing] <> (Just <$> \"CD\")),\n      ('b', [Just 'E']),\n      ('r', [Nothing, Just 'F'])\n    ]\n", "target": "from collections import defaultdict\n\nrep = {'a' : {1 : 'A', 2 : 'B', 4 : 'C', 5 : 'D'}, 'b' : {1 : 'E'}, 'r' : {2 : 'F'}}\n \ndef trstring(oldstring, repdict):\n    seen, newchars = defaultdict(lambda:1, {}), []\n    for c in oldstring:\n        i = seen[c]\n        newchars.append(repdict[c][i] if c in repdict and i in repdict[c] else c)\n        seen[c] += 1\n    return ''.join(newchars)\n\nprint('abracadabra ->', trstring('abracadabra', rep))\n"}
{"id": 418724, "name": "Selectively replace multiple instances of a character within a string", "source": "Translate Haskell to Python: import Data.List (mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\n\n\nnthCharsReplaced :: M.Map Char [Maybe Char] -> String -> String\nnthCharsReplaced ruleMap = snd . mapAccumL go ruleMap\n  where\n    go a c =\n      case M.lookup c a of\n        Nothing -> (a, c)\n        Just [] -> (a, c)\n        Just (d : ds) ->\n          ( M.insert c ds a,\n            fromMaybe c d\n          )\n\n\nmain :: IO ()\nmain = putStrLn $ nthCharsReplaced rules \"abracadabra\"\n\nrules :: M.Map Char [Maybe Char]\nrules =\n  M.fromList\n    [ ('a', (Just <$> \"AB\") <> [Nothing] <> (Just <$> \"CD\")),\n      ('b', [Just 'E']),\n      ('r', [Nothing, Just 'F'])\n    ]\n", "target": "from collections import defaultdict\n\nrep = {'a' : {1 : 'A', 2 : 'B', 4 : 'C', 5 : 'D'}, 'b' : {1 : 'E'}, 'r' : {2 : 'F'}}\n \ndef trstring(oldstring, repdict):\n    seen, newchars = defaultdict(lambda:1, {}), []\n    for c in oldstring:\n        i = seen[c]\n        newchars.append(repdict[c][i] if c in repdict and i in repdict[c] else c)\n        seen[c] += 1\n    return ''.join(newchars)\n\nprint('abracadabra ->', trstring('abracadabra', rep))\n"}
{"id": 418725, "name": "Joystick position", "source": "Translate Haskell to Python: import qualified Graphics.UI.GLFW as GLFW \nimport Graphics.Win32.Key\nimport Control.Monad.RWS.Strict  (liftIO)\n\nmain = do\n    liftIO $ do\n          _ <- GLFW.init\n          GLFW.pollEvents\n          (jxrot, jyrot) <- liftIO $ getJoystickDirections GLFW.Joystick'1\n          putStrLn $ (show jxrot) ++ \" \" ++ (show jyrot)\n          w <- getAsyncKeyState 27 \n          if (w<1) then main else do \n                     GLFW.terminate\n                     return ()\n                     \ngetJoystickDirections :: GLFW.Joystick -> IO (Double, Double)\n\ngetJoystickDirections js = do\n    maxes <- GLFW.getJoystickAxes js\n    return $ case maxes of\n      (Just (x:y:_)) -> (-y, x)\n      _ -> ( 0, 0)\n", "target": "import sys\nimport pygame\n\npygame.init()\n\n\nclk = pygame.time.Clock()\n\n\nif pygame.joystick.get_count() == 0:\n    raise IOError(\"No joystick detected\")\njoy = pygame.joystick.Joystick(0)\njoy.init()\n\n\nsize = width, height = 600, 600\nscreen = pygame.display.set_mode(size)\npygame.display.set_caption(\"Joystick Tester\")\n\n\nframeRect = pygame.Rect((45, 45), (510, 510))\n\n\ncrosshair = pygame.surface.Surface((10, 10))\ncrosshair.fill(pygame.Color(\"magenta\"))\npygame.draw.circle(crosshair, pygame.Color(\"blue\"), (5,5), 5, 0)\ncrosshair.set_colorkey(pygame.Color(\"magenta\"), pygame.RLEACCEL)\ncrosshair = crosshair.convert()\n\n\nwriter = pygame.font.Font(pygame.font.get_default_font(), 15)\nbuttons = {}\nfor b in range(joy.get_numbuttons()):\n    buttons[b] = [\n        writer.render(\n            hex(b)[2:].upper(),\n            1,\n            pygame.Color(\"red\"),\n            pygame.Color(\"black\")\n        ).convert(),\n        \n        \n        ((15*b)+45, 560)\n    ]\n\nwhile True:\n    \n    pygame.event.pump()\n    for events in pygame.event.get():\n        if events.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n\n    \n    screen.fill(pygame.Color(\"black\"))\n\n    \n    x = joy.get_axis(0)\n    y = joy.get_axis(1)\n\n    \n    \n    screen.blit(crosshair, ((x*250)+300-5, (y*250)+300-5))\n    pygame.draw.rect(screen, pygame.Color(\"red\"), frameRect, 1)\n\n    \n    for b in range(joy.get_numbuttons()):\n        if joy.get_button(b):\n            screen.blit(buttons[b][0], buttons[b][1])\n\n    \n    pygame.display.flip()\n    clk.tick(40) \n"}
{"id": 418726, "name": "Nested templated data", "source": "Translate Haskell to Python: \n\ndata Template a = Val a | List [Template a]\n  deriving ( Show\n           , Functor\n           , Foldable\n           , Traversable )\n", "target": "from pprint import pprint as pp\n\nclass Template():\n    def __init__(self, structure):\n        self.structure = structure\n        self.used_payloads, self.missed_payloads = [], []\n    \n    def inject_payload(self, id2data):\n        \n        def _inject_payload(substruct, i2d, used, missed):\n            used.extend(i2d[x] for x in substruct if type(x) is not tuple and x in i2d)\n            missed.extend(f'??\n                          for x in substruct if type(x) is not tuple and x not in i2d)\n            return tuple(_inject_payload(x, i2d, used, missed) \n                           if type(x) is tuple \n                           else i2d.get(x, f'??\n                         for x in substruct)\n                           \n        ans = _inject_payload(self.structure, id2data, \n                              self.used_payloads, self.missed_payloads)\n        self.unused_payloads = sorted(set(id2data.values()) \n                                      - set(self.used_payloads))\n        self.missed_payloads = sorted(set(self.missed_payloads))\n        return ans\n\nif __name__ == '__main__':\n    index2data = {p: f'Payload\n    print(\"\n    print('\\n  '.join(list(index2data.values())))\n    for structure in [\n     (((1, 2),\n       (3, 4, 1),\n       5),),\n    \n     (((1, 2),\n       (10, 4, 1),\n       5),)]:\n        print(\"\\n\\n\n        pp(structure, width=13)\n        print(\"\\n TEMPLATE WITH PAYLOADS:\")\n        t = Template(structure)\n        out = t.inject_payload(index2data)\n        pp(out)\n        print(\"\\n UNUSED PAYLOADS:\\n  \", end='')\n        unused = t.unused_payloads\n        print('\\n  '.join(unused) if unused else '-')\n        print(\" MISSING PAYLOADS:\\n  \", end='')\n        missed = t.missed_payloads\n        print('\\n  '.join(missed) if missed else '-')\n"}
{"id": 418727, "name": "Sort an outline at every level", "source": "Translate Haskell to Python: \n\nimport Data.Tree (Tree(..), foldTree)\nimport qualified Data.Text.IO as T\nimport qualified Data.Text as T\nimport qualified Data.List as L\nimport Data.Bifunctor (first)\nimport Data.Ord (comparing)\nimport Data.Char (isSpace)\n\n\n\n\nsortedOutline :: (Tree T.Text -> Tree T.Text -> Ordering)\n              -> T.Text\n              -> Either T.Text T.Text\nsortedOutline cmp outlineText =\n  let xs = T.lines outlineText\n  in consistentIndentUnit (nonZeroIndents xs) >>=\n     \\indentUnit ->\n        let forest = forestFromLineIndents $ indentLevelsFromLines xs\n            sortedForest =\n              subForest $\n              foldTree (\\x xs -> Node x (L.sortBy cmp xs)) (Node \"\" forest)\n        in Right $ outlineFromForest indentUnit sortedForest\n\n\n\n\nmain :: IO ()\nmain =\n  mapM_ T.putStrLn $\n  concat $\n  [ \\(comparatorLabel, cmp) ->\n       (\\kv ->\n           let section = headedSection (fst kv) comparatorLabel\n           in (either (section . (\" -> \" <>)) section . sortedOutline cmp . snd)\n                kv) <$>\n       [ (\"Four-spaced\", spacedOutline)\n       , (\"Tabbed\", tabbedOutline)\n       , (\"First unknown type\", confusedOutline)\n       , (\"Second unknown type\", raggedOutline)\n       ]\n  ] <*>\n  [(\"(A -> Z)\", comparing rootLabel), (\"(Z -> A)\", flip (comparing rootLabel))]\n\nheadedSection :: T.Text -> T.Text -> T.Text -> T.Text\nheadedSection outlineType comparatorName x =\n  T.concat [\"\\n\", outlineType, \" \", comparatorName, \":\\n\\n\", x]\n\nspacedOutline, tabbedOutline, confusedOutline, raggedOutline :: T.Text\nspacedOutline =\n  \"zeta\\n\\\n    \\    beta\\n\\\n    \\    gamma\\n\\\n    \\        lambda\\n\\\n    \\        kappa\\n\\\n    \\        mu\\n\\\n    \\    delta\\n\\\n    \\alpha\\n\\\n    \\    theta\\n\\\n    \\    iota\\n\\\n    \\    epsilon\"\n\ntabbedOutline =\n  \"zeta\\n\\\n    \\\\tbeta\\n\\\n    \\\\tgamma\\n\\\n    \\\\t\\tlambda\\n\\\n    \\\\t\\tkappa\\n\\\n    \\\\t\\tmu\\n\\\n    \\\\tdelta\\n\\\n    \\alpha\\n\\\n    \\\\ttheta\\n\\\n    \\\\tiota\\n\\\n    \\\\tepsilon\"\n\nconfusedOutline =\n  \"zeta\\n\\\n    \\    beta\\n\\\n    \\  gamma\\n\\\n    \\        lambda\\n\\\n    \\  \\t    kappa\\n\\\n    \\        mu\\n\\\n    \\    delta\\n\\\n    \\alpha\\n\\\n    \\    theta\\n\\\n    \\    iota\\n\\\n    \\    epsilon\"\n\nraggedOutline =\n  \"zeta\\n\\\n    \\    beta\\n\\\n    \\   gamma\\n\\\n    \\        lambda\\n\\\n    \\         kappa\\n\\\n    \\        mu\\n\\\n    \\    delta\\n\\\n    \\alpha\\n\\\n    \\    theta\\n\\\n    \\    iota\\n\\\n    \\    epsilon\"\n\n\n\n\nforestFromLineIndents :: [(Int, T.Text)] -> [Tree T.Text]\nforestFromLineIndents = go\n  where\n    go [] = []\n    go ((n, s):xs) = Node s (go subOutline) : go rest\n      where\n        (subOutline, rest) = span ((n <) . fst) xs\n\nindentLevelsFromLines :: [T.Text] -> [(Int, T.Text)]\nindentLevelsFromLines xs = first (`div` indentUnit) <$> pairs\n  where\n    pairs = first T.length . T.span isSpace <$> xs\n    indentUnit = maybe 1 fst (L.find ((0 <) . fst) pairs)\n\noutlineFromForest :: T.Text -> [Tree T.Text] -> T.Text\noutlineFromForest tabString forest = T.unlines $ forest >>= go \"\"\n  where\n    go indent node =\n      indent <> rootLabel node :\n      (subForest node >>= go (T.append tabString indent))\n\n\nconsistentIndentUnit :: [T.Text] -> Either T.Text T.Text\nconsistentIndentUnit prefixes = minimumIndent prefixes >>= checked prefixes\n  where\n    checked xs indentUnit\n      | all ((0 ==) . (`rem` unitLength) . T.length) xs = Right indentUnit\n      | otherwise =\n        Left\n          (\"Inconsistent indent depths: \" <>\n           T.pack (show (T.length <$> prefixes)))\n      where\n        unitLength = T.length indentUnit\n\nminimumIndent :: [T.Text] -> Either T.Text T.Text\nminimumIndent prefixes = go $ T.foldr newChar \"\" $ T.concat prefixes\n  where\n    newChar c seen\n      | c `L.elem` seen = seen\n      | otherwise = c : seen\n    go cs\n      | 1 < length cs =\n        Left $ \"Mixed indent characters used: \" <> T.pack (show cs)\n      | otherwise = Right $ L.minimumBy (comparing T.length) prefixes\n\nnonZeroIndents :: [T.Text] -> [T.Text]\nnonZeroIndents textLines =\n  [ s\n  | x <- textLines \n  , s <- [T.takeWhile isSpace x] \n  , 0 /= T.length s ]\n", "target": "\n\n\nfrom itertools import chain, product, takewhile, tee\nfrom functools import cmp_to_key, reduce\n\n\n\n\n\n\n\ndef sortedOutline(cmp):\n    \n    def go(outlineText):\n        indentTuples = indentTextPairs(\n            outlineText.splitlines()\n        )\n        return bindLR(\n            minimumIndent(enumerate(indentTuples))\n        )(lambda unitIndent: Right(\n            outlineFromForest(\n                unitIndent,\n                nest(foldTree(\n                    lambda x: lambda xs: Node(x)(\n                        sorted(xs, key=cmp_to_key(cmp))\n                    )\n                )(Node('')(\n                    forestFromIndentLevels(\n                        indentLevelsFromLines(\n                            unitIndent\n                        )(indentTuples)\n                    )\n                )))\n            )\n        ))\n    return go\n\n\n\n\ndef main():\n    \n\n    ascending = comparing(root)\n    descending = flip(ascending)\n\n    spacedOutline = \n\n    tabbedOutline = \n\n    confusedOutline = \n\n    raggedOutline = \n\n    def displaySort(kcmp):\n        \n        k, cmp = kcmp\n        return [\n            tested(cmp, k, label)(\n                outline\n            ) for (label, outline) in [\n                ('4-space indented', spacedOutline),\n                ('tab indented', tabbedOutline),\n                ('Unknown 1', confusedOutline),\n                ('Unknown 2', raggedOutline)\n            ]\n        ]\n\n    def tested(cmp, cmpName, outlineName):\n        \n        def go(outline):\n            print('\\n' + outlineName, cmpName + ':')\n            either(print)(print)(\n                sortedOutline(cmp)(outline)\n            )\n        return go\n\n    \n    ap([\n        displaySort\n    ])([\n        (\"(A -> Z)\", ascending),\n        (\"(Z -> A)\", descending)\n    ])\n\n\n\n\n\ndef forestFromIndentLevels(tuples):\n    \n    def go(xs):\n        if xs:\n            intIndent, v = xs[0]\n            firstTreeLines, rest = span(\n                lambda x: intIndent < x[0]\n            )(xs[1:])\n            return [Node(v)(go(firstTreeLines))] + go(rest)\n        else:\n            return []\n    return go(tuples)\n\n\n\n\ndef indentLevelsFromLines(indentUnit):\n    \n    def go(xs):\n        w = len(indentUnit)\n        return [\n            (len(x[0]) // w, x[1])\n            for x in xs\n        ]\n    return go\n\n\n\ndef indentTextPairs(xs):\n    \n    def indentAndText(s):\n        pfx = list(takewhile(lambda c: c.isspace(), s))\n        return (pfx, s[len(pfx):])\n    return [indentAndText(x) for x in xs]\n\n\n\ndef outlineFromForest(tabString, forest):\n    \n    def go(indent):\n        def serial(node):\n            return [indent + root(node)] + list(\n                concatMap(\n                    go(tabString + indent)\n                )(nest(node))\n            )\n        return serial\n    return '\\n'.join(\n        concatMap(go(''))(forest)\n    )\n\n\n\n\n\n\ndef minimumIndent(indexedPrefixes):\n    \n    (xs, ts) = tee(indexedPrefixes)\n    (ys, zs) = tee(ts)\n\n    def mindentLR(charSet):\n        if list(charSet):\n            def w(x):\n                return len(x[1][0])\n\n            unit = min(filter(w, ys), key=w)[1][0]\n            unitWidth = len(unit)\n\n            def widthCheck(a, ix):\n                \n                wx = len(ix[1][0])\n                return a if (a or 0 == wx) else (\n                    ix[0] if 0 != wx % unitWidth else a\n                )\n            oddLine = reduce(widthCheck, zs, None)\n            return Left(\n                'Inconsistent indentation width at line ' + (\n                    str(1 + oddLine)\n                )\n            ) if oddLine else Right(''.join(unit))\n        else:\n            return Right('')\n\n    def tabSpaceCheck(a, ics):\n        \n        charSet = a[0].union(set(ics[1][0]))\n        return a if a[1] else (\n            charSet, ics[0] if 1 < len(charSet) else None\n        )\n\n    indentCharSet, mbAnomalyLine = reduce(\n        tabSpaceCheck, xs, (set([]), None)\n    )\n    return bindLR(\n        Left(\n            'Mixed indent characters found in line ' + str(\n                1 + mbAnomalyLine\n            )\n        ) if mbAnomalyLine else Right(list(indentCharSet))\n    )(mindentLR)\n\n\n\n\n\ndef Left(x):\n    \n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n\ndef Right(x):\n    \n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n\ndef Node(v):\n    \n    return lambda xs: {'type': 'Tree', 'root': v, 'nest': xs}\n\n\n\ndef ap(fs):\n    \n    def go(xs):\n        return [\n            f(x) for (f, x)\n            in product(fs, xs)\n        ]\n    return go\n\n\n\ndef bindLR(m):\n    \n    def go(mf):\n        return (\n            mf(m.get('Right')) if None is m.get('Left') else m\n        )\n    return go\n\n\n\ndef comparing(f):\n    \n    def go(x, y):\n        fx = f(x)\n        fy = f(y)\n        return -1 if fx < fy else (1 if fx > fy else 0)\n    return go\n\n\n\ndef concatMap(f):\n    \n    def go(xs):\n        return chain.from_iterable(map(f, xs))\n    return go\n\n\n\ndef either(fl):\n    \n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n\ndef flip(f):\n    \n    return lambda a, b: f(b, a)\n\n\n\ndef foldTree(f):\n    \n    def go(node):\n        return f(root(node))([\n            go(x) for x in nest(node)\n        ])\n    return go\n\n\n\ndef nest(t):\n    \n    return t.get('nest')\n\n\n\ndef root(t):\n    \n    return t.get('root')\n\n\n\ndef span(p):\n    \n    def match(ab):\n        b = ab[1]\n        return not b or not p(b[0])\n\n    def f(ab):\n        a, b = ab\n        return a + [b[0]], b[1:]\n\n    def go(xs):\n        return until(match)(f)(([], xs))\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418728, "name": "Display an outline as a nested table", "source": "Translate Haskell to Python: \n\nmodule OutlineTree where\n\nimport Data.Bifunctor (first)\nimport Data.Bool (bool)\nimport Data.Char (isSpace)\nimport Data.List (find, intercalate)\nimport Data.Tree (Tree (..), foldTree, levels)\n\n\n\nwikiTablesFromOutline :: [String] -> String -> String\nwikiTablesFromOutline colorSwatch outline =\n  intercalate \"\\n\\n\" $\n    wikiTableFromTree colorSwatch\n      <$> ( forestFromLineIndents\n              . indentLevelsFromLines\n              . lines\n          )\n        outline\n\nwikiTableFromTree :: [String] -> Tree String -> String\nwikiTableFromTree colorSwatch =\n  wikiTableFromRows\n    . levels\n    . paintedTree colorSwatch\n    . widthLabelledTree\n    . (paddedTree \"\" <*> treeDepth)\n\n\nmain :: IO ()\nmain =\n  ( putStrLn\n      . wikiTablesFromOutline\n        [ \"#ffffe6\",\n          \"#ffebd2\",\n          \"#f0fff0\",\n          \"#e6ffff\",\n          \"#ffeeff\"\n        ]\n  )\n    \"Display an outline as a nested table.\\n\\\n    \\    Parse the outline to a tree,\\n\\\n    \\        measuring the indent of each line,\\n\\\n    \\        translating the indentation to a nested structure,\\n\\\n    \\        and padding the tree to even depth.\\n\\\n    \\    count the leaves descending from each node,\\n\\\n    \\        defining the width of a leaf as 1,\\n\\\n    \\        and the width of a parent node as a sum.\\n\\\n    \\            (The sum of the widths of its children)\\n\\\n    \\    and write out a table with 'colspan' values\\n\\\n    \\        either as a wiki table,\\n\\\n    \\        or as HTML.\"\n\n\n\nforestFromLineIndents :: [(Int, String)] -> [Tree String]\nforestFromLineIndents = go\n  where\n    go [] = []\n    go ((n, s) : xs) =\n      let (subOutline, rest) = span ((n <) . fst) xs\n       in Node s (go subOutline) : go rest\n\nindentLevelsFromLines :: [String] -> [(Int, String)]\nindentLevelsFromLines xs =\n  let pairs = first length . span isSpace <$> xs\n      indentUnit = maybe 1 fst (find ((0 <) . fst) pairs)\n   in first (`div` indentUnit) <$> pairs\n\n\n\npaddedTree :: a -> Tree a -> Int -> Tree a\npaddedTree padValue = go\n  where\n    go tree n\n      | 1 >= n = tree\n      | otherwise =\n        Node\n          (rootLabel tree)\n          ( (`go` pred n)\n              <$> bool nest [Node padValue []] (null nest)\n          )\n      where\n        nest = subForest tree\n\ntreeDepth :: Tree a -> Int\ntreeDepth = foldTree go\n  where\n    go _ [] = 1\n    go _ xs = (succ . maximum) xs\n\n\n\nwidthLabelledTree :: Tree a -> Tree (a, Int)\nwidthLabelledTree = foldTree go\n  where\n    go x [] = Node (x, 1) []\n    go x xs =\n      Node\n        (x, foldr ((+) . snd . rootLabel) 0 xs)\n        xs\n\n\n\npaintedTree :: [String] -> Tree a -> Tree (String, a)\npaintedTree [] tree = fmap (\"\",) tree\npaintedTree (color : colors) tree =\n  Node\n    (color, rootLabel tree)\n    ( zipWith\n        (fmap . (,))\n        (cycle colors)\n        (subForest tree)\n    )\n\n\n\nwikiTableFromRows :: [[(String, (String, Int))]] -> String\nwikiTableFromRows rows =\n  let wikiRow = unlines . fmap cellText\n      cellText (color, (txt, width))\n        | null txt = \"| |\"\n        | otherwise =\n          \"| \"\n            <> cw color width\n            <> \"| \"\n            <> txt\n      cw color width =\n        let go w\n              | 1 < w = \" colspan=\" <> show w\n              | otherwise = \"\"\n         in \"style=\\\"background:\"\n              <> color\n              <> \"; \\\"\"\n              <> go width\n              <> \" \"\n   in \"{| class=\\\"wikitable\\\" \"\n        <> \"style=\\\"text-align: center;\\\"\\n|-\\n\"\n        <> intercalate \"|-\\n\" (wikiRow <$> rows)\n        <> \"|}\"\n", "target": "\n\nimport itertools\nimport re\nimport sys\n\nfrom collections import deque\nfrom typing import NamedTuple\n\n\nRE_OUTLINE = re.compile(r\"^((?: |\\t)*)(.+)$\", re.M)\n\nCOLORS = itertools.cycle(\n    [\n        \"\n        \"\n        \"\n        \"\n        \"\n    ]\n)\n\n\nclass Node:\n    def __init__(self, indent, value, parent, children=None):\n        self.indent = indent\n        self.value = value\n        self.parent = parent\n        self.children = children or []\n\n        self.color = None\n\n    def depth(self):\n        if self.parent:\n            return self.parent.depth() + 1\n        return -1\n\n    def height(self):\n        \n        if not self.children:\n            return 0\n        return max(child.height() for child in self.children) + 1\n\n    def colspan(self):\n        if self.leaf:\n            return 1\n        return sum(child.colspan() for child in self.children)\n\n    @property\n    def leaf(self):\n        return not bool(self.children)\n\n    def __iter__(self):\n        \n        q = deque()\n        q.append(self)\n        while q:\n            node = q.popleft()\n            yield node\n            q.extend(node.children)\n\n\nclass Token(NamedTuple):\n    indent: int\n    value: str\n\n\ndef tokenize(outline):\n    \n    for match in RE_OUTLINE.finditer(outline):\n        indent, value = match.groups()\n        yield Token(len(indent), value)\n\n\ndef parse(outline):\n    \n    \n    tokens = list(tokenize(outline))\n\n    \n    temp_root = Node(-1, \"\", None)\n    _parse(tokens, 0, temp_root)\n\n    \n    root = temp_root.children[0]\n    pad_tree(root, root.height())\n\n    return root\n\n\ndef _parse(tokens, index, node):\n    \n    \n    if index >= len(tokens):\n        return\n\n    token = tokens[index]\n\n    if token.indent == node.indent:\n        \n        current = Node(token.indent, token.value, node.parent)\n        node.parent.children.append(current)\n        _parse(tokens, index + 1, current)\n\n    elif token.indent > node.indent:\n        \n        current = Node(token.indent, token.value, node)\n        node.children.append(current)\n        _parse(tokens, index + 1, current)\n\n    elif token.indent < node.indent:\n        \n        _parse(tokens, index, node.parent)\n\n\ndef pad_tree(node, height):\n    \n    if node.leaf and node.depth() < height:\n        pad_node = Node(node.indent + 1, \"\", node)\n        node.children.append(pad_node)\n\n    for child in node.children:\n        pad_tree(child, height)\n\n\ndef color_tree(node):\n    \n    if not node.value:\n        node.color = \"\n    elif node.depth() <= 1:\n        node.color = next(COLORS)\n    else:\n        node.color = node.parent.color\n\n    for child in node.children:\n        color_tree(child)\n\n\ndef table_data(node):\n    \n    indent = \"    \"\n\n    if node.colspan() > 1:\n        colspan = f'colspan=\"{node.colspan()}\"'\n    else:\n        colspan = \"\"\n\n    if node.color:\n        style = f'style=\"background-color: {node.color};\"'\n    else:\n        style = \"\"\n\n    attrs = \" \".join([colspan, style])\n    return f\"{indent}<td{attrs}>{node.value}</td>\"\n\n\ndef html_table(tree):\n    \n    \n    table_cols = tree.colspan()\n\n    \n    row_cols = 0\n\n    \n    buf = [\"<table style='text-align: center;'>\"]\n\n    \n    for node in tree:\n        if row_cols == 0:\n            buf.append(\"  <tr>\")\n\n        buf.append(table_data(node))\n        row_cols += node.colspan()\n\n        if row_cols == table_cols:\n            buf.append(\"  </tr>\")\n            row_cols = 0\n\n    buf.append(\"</table>\")\n    return \"\\n\".join(buf)\n\n\ndef wiki_table_data(node):\n    \n    if not node.value:\n        return \"|  |\"\n\n    if node.colspan() > 1:\n        colspan = f\"colspan={node.colspan()}\"\n    else:\n        colspan = \"\"\n\n    if node.color:\n        style = f'style=\"background: {node.color};\"'\n    else:\n        style = \"\"\n\n    attrs = \" \".join([colspan, style])\n    return f\"| {attrs} | {node.value}\"\n\n\ndef wiki_table(tree):\n    \n    \n    table_cols = tree.colspan()\n\n    \n    row_cols = 0\n\n    \n    buf = ['{| class=\"wikitable\" style=\"text-align: center;\"']\n\n    for node in tree:\n        if row_cols == 0:\n            buf.append(\"|-\")\n\n        buf.append(wiki_table_data(node))\n        row_cols += node.colspan()\n\n        if row_cols == table_cols:\n            row_cols = 0\n\n    buf.append(\"|}\")\n    return \"\\n\".join(buf)\n\n\ndef example(table_format=\"wiki\"):\n    \n\n    outline = (\n        \"Display an outline as a nested table.\\n\"\n        \"    Parse the outline to a tree,\\n\"\n        \"        measuring the indent of each line,\\n\"\n        \"        translating the indentation to a nested structure,\\n\"\n        \"        and padding the tree to even depth.\\n\"\n        \"    count the leaves descending from each node,\\n\"\n        \"        defining the width of a leaf as 1,\\n\"\n        \"        and the width of a parent node as a sum.\\n\"\n        \"            (The sum of the widths of its children)\\n\"\n        \"    and write out a table with 'colspan' values\\n\"\n        \"        either as a wiki table,\\n\"\n        \"        or as HTML.\"\n    )\n\n    tree = parse(outline)\n    color_tree(tree)\n\n    if table_format == \"wiki\":\n        print(wiki_table(tree))\n    else:\n        print(html_table(tree))\n\n\nif __name__ == \"__main__\":\n    args = sys.argv[1:]\n\n    if len(args) == 1:\n        table_format = args[0]\n    else:\n        table_format = \"wiki\"\n\n    example(table_format)\n"}
{"id": 418729, "name": "Smallest multiple", "source": "Translate Haskell to Python: import Text.Printf (printf)\n\n\n\nsmallest :: Integer -> Integer\nsmallest =\n  foldr lcm 1 . enumFromTo 1\n\n\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n    showSmallest <$> [10, 20, 200, 2000]\n\n\nshowSmallest :: Integer -> String\nshowSmallest =\n  ((<>) . (<> \" -> \") . printf \"%4d\")\n    <*> (printf \"%d\" . smallest)\n", "target": "\n\nfrom math import gcd\nfrom functools import reduce\n\n\ndef lcm(a, b):\n    \n    return 0 if 0 == a or 0 == b else (\n        abs(a * b) // gcd(a, b)\n    )\n\n\nfor i in [10, 20, 200, 2000]:\n    print(str(i) + ':', reduce(lcm, range(1, i + 1)))\n"}
{"id": 418730, "name": "Find first missing positive", "source": "Translate Haskell to Python: import Data.List (sort)\n\ntask :: Integral a => [a] -> a\ntask = go . (0 :) . sort . filter (> 0)\n  where\n    go [x] = succ x\n    go (w : xs@(x : _))\n      | x == succ w = go xs\n      | otherwise = succ w\n\n\nmain :: IO ()\nmain =\n  print $\n    map\n      task\n      [[1, 2, 0], [3, 4, -1, 1], [7, 8, 9, 11, 12]]\n", "target": "\n\nfrom itertools import count\n\n\n\ndef firstGap(xs):\n    \n    return next(x for x in count(1) if x not in xs)\n\n\n\n\ndef main():\n    \n    print('\\n'.join([\n        f'{repr(xs)} -> {firstGap(xs)}' for xs in [\n            [1, 2, 0],\n            [3, 4, -1, 1],\n            [7, 8, 9, 11, 12]\n        ]\n    ]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418731, "name": "Find adjacent primes which differ by a square integer", "source": "Translate Haskell to Python: import Data.List.Split ( divvy )\n\nisSquare :: Int -> Bool\nisSquare n = (snd $ properFraction $ sqrt $ fromIntegral n) == 0.0\n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\nsolution :: [[Int]]\nsolution = filter (\\li -> isSquare (last li - head li ) &&\n ( last li - head li ) > 36 ) $ divvy 2 1 $ filter isPrime [2..1000000]\n\nprintResultLine :: [Int] -> String\nprintResultLine list = show ( last list ) ++ \" - \" ++ ( show $ head list )\n ++ \" = \" ++ ( show ( last list - head list ))\n\nmain :: IO ( )\nmain = do\n   let resultPairs = solution\n   mapM_ (\\li -> putStrLn $ printResultLine li ) resultPairs\n", "target": "import math\nprint(\"working...\")\nlimit = 1000000\nPrimes = []\noldPrime = 0\nnewPrime = 0\nx = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(x):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit):\n    if isPrime(n):\n       Primes.append(n)\n\nfor n in range(2,len(Primes)):\n    pr1 = Primes[n]\n    pr2 = Primes[n-1]\n    diff = pr1 - pr2\n    flag = issquare(diff)\n    if (flag == 1 and diff > 36):\n       print(str(pr1) + \" \" + str(pr2) + \" diff = \" + str(diff))\n\nprint(\"done...\")\n"}
{"id": 418732, "name": "Find adjacent primes which differ by a square integer", "source": "Translate Haskell to Python: import Data.List.Split ( divvy )\n\nisSquare :: Int -> Bool\nisSquare n = (snd $ properFraction $ sqrt $ fromIntegral n) == 0.0\n\nisPrime :: Int -> Bool\nisPrime n \n   |n == 2 = True\n   |n == 1 = False\n   |otherwise = null $ filter (\\i -> mod n i == 0 ) [2 .. root]\n   where\n      root :: Int\n      root = floor $ sqrt $ fromIntegral n\n\nsolution :: [[Int]]\nsolution = filter (\\li -> isSquare (last li - head li ) &&\n ( last li - head li ) > 36 ) $ divvy 2 1 $ filter isPrime [2..1000000]\n\nprintResultLine :: [Int] -> String\nprintResultLine list = show ( last list ) ++ \" - \" ++ ( show $ head list )\n ++ \" = \" ++ ( show ( last list - head list ))\n\nmain :: IO ( )\nmain = do\n   let resultPairs = solution\n   mapM_ (\\li -> putStrLn $ printResultLine li ) resultPairs\n", "target": "import math\nprint(\"working...\")\nlimit = 1000000\nPrimes = []\noldPrime = 0\nnewPrime = 0\nx = 0\n\ndef isPrime(n):\n    for i in range(2,int(n**0.5)+1):\n        if n%i==0:\n            return False\n    return True\n\ndef issquare(x):\n\tfor n in range(x):\n\t\tif (x == n*n):\n\t\t\treturn 1\n\treturn 0\n\nfor n in range(limit):\n    if isPrime(n):\n       Primes.append(n)\n\nfor n in range(2,len(Primes)):\n    pr1 = Primes[n]\n    pr2 = Primes[n-1]\n    diff = pr1 - pr2\n    flag = issquare(diff)\n    if (flag == 1 and diff > 36):\n       print(str(pr1) + \" \" + str(pr2) + \" diff = \" + str(diff))\n\nprint(\"done...\")\n"}
{"id": 418733, "name": "Farey sequence", "source": "Translate Haskell to Python: import Data.List (unfoldr, mapAccumR)\nimport Data.Ratio ((%), denominator, numerator)\nimport Text.Printf (PrintfArg, printf)\n\n\nfarey :: Integer -> [Rational]\nfarey n = 0 : unfoldr step (0, 1, 1, n)\n  where\n    step (a, b, c, d)\n      | c > n = Nothing\n      | otherwise =\n        let k = (n + b) `quot` d\n        in Just (c %d, (c, d, k * c - a, k * d - b))\n\n\n\n\n\nfareys :: ([Rational] -> a) -> [Integer] -> [(Integer, a)]\nfareys fn ns = snd $ mapAccumR prune (farey $ last ns) ns\n  where\n    prune rs n =\n      let rs'' = filter ((<= n) . denominator) rs\n      in (rs'', (n, fn rs''))\n\nfprint\n  :: (PrintfArg b)\n  => String -> [(Integer, b)] -> IO ()\nfprint fmt = mapM_ (uncurry $ printf fmt)\n\nshowFracs :: [Rational] -> String\nshowFracs =\n  unwords .\n  map (concat . (<*>) [show . numerator, const \"/\", show . denominator] . pure)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Farey Sequences\\n\"\n  fprint \"%2d %s\\n\" $ fareys showFracs [1 .. 11]\n  putStrLn \"\\nSequence Lengths\\n\"\n  fprint \"%4d %d\\n\" $ fareys length [100,200 .. 1000]\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 418734, "name": "Farey sequence", "source": "Translate Haskell to Python: import Data.List (unfoldr, mapAccumR)\nimport Data.Ratio ((%), denominator, numerator)\nimport Text.Printf (PrintfArg, printf)\n\n\nfarey :: Integer -> [Rational]\nfarey n = 0 : unfoldr step (0, 1, 1, n)\n  where\n    step (a, b, c, d)\n      | c > n = Nothing\n      | otherwise =\n        let k = (n + b) `quot` d\n        in Just (c %d, (c, d, k * c - a, k * d - b))\n\n\n\n\n\nfareys :: ([Rational] -> a) -> [Integer] -> [(Integer, a)]\nfareys fn ns = snd $ mapAccumR prune (farey $ last ns) ns\n  where\n    prune rs n =\n      let rs'' = filter ((<= n) . denominator) rs\n      in (rs'', (n, fn rs''))\n\nfprint\n  :: (PrintfArg b)\n  => String -> [(Integer, b)] -> IO ()\nfprint fmt = mapM_ (uncurry $ printf fmt)\n\nshowFracs :: [Rational] -> String\nshowFracs =\n  unwords .\n  map (concat . (<*>) [show . numerator, const \"/\", show . denominator] . pure)\n\nmain :: IO ()\nmain = do\n  putStrLn \"Farey Sequences\\n\"\n  fprint \"%2d %s\\n\" $ fareys showFracs [1 .. 11]\n  putStrLn \"\\nSequence Lengths\\n\"\n  fprint \"%4d %d\\n\" $ fareys length [100,200 .. 1000]\n", "target": "from fractions import Fraction\n\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '(%s/%s)' % (self.numerator, self.denominator)\n\n\ndef farey(n, length=False):\n    if not length:\n        return [Fr(0, 1)] + sorted({Fr(m, k) for k in range(1, n+1) for m in range(1, k+1)})\n    else:\n        \n        return  (n*(n+3))//2 - sum(farey(n//k, True) for k in range(2, n+1))\n        \nif __name__ == '__main__':\n    print('Farey sequence for order 1 through 11 (inclusive):')\n    for n in range(1, 12): \n        print(farey(n))\n    print('Number of fractions in the Farey sequence for order 100 through 1,000 (inclusive) by hundreds:')\n    print([farey(i, length=True) for i in range(100, 1001, 100)])\n"}
{"id": 418735, "name": "Aliquot sequence classifications", "source": "Translate Haskell to Python: divisors :: (Integral a) => a -> [a]\ndivisors n = filter ((0 ==) . (n `mod`)) [1 .. (n `div` 2)]\n\ndata Class\n  = Terminating\n  | Perfect\n  | Amicable\n  | Sociable\n  | Aspiring\n  | Cyclic\n  | Nonterminating\n  deriving (Show)\n\naliquot :: (Integral a) => a -> [a]\naliquot 0 = [0]\naliquot n = n : (aliquot $ sum $ divisors n)\n\nclassify :: (Num a, Eq a) => [a] -> Class\nclassify []             = Nonterminating\nclassify [0]            = Terminating\nclassify [_]            = Nonterminating\nclassify [a,b]\n  | a == b              = Perfect\n  | b == 0              = Terminating\n  | otherwise           = Nonterminating\nclassify x@(a:b:c:_)\n  | a == b              = Perfect\n  | a == c              = Amicable\n  | a `elem` (drop 1 x) = Sociable\n  | otherwise           =\n    case classify (drop 1 x) of\n      Perfect  -> Aspiring\n      Amicable -> Cyclic\n      Sociable -> Cyclic\n      d        -> d\n\nmain :: IO ()\nmain = do\n  let cls n = let ali = take 16 $ aliquot n in (classify ali, ali)\n  mapM_ (print . cls) $ [1..10] ++\n    [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 418736, "name": "Aliquot sequence classifications", "source": "Translate Haskell to Python: divisors :: (Integral a) => a -> [a]\ndivisors n = filter ((0 ==) . (n `mod`)) [1 .. (n `div` 2)]\n\ndata Class\n  = Terminating\n  | Perfect\n  | Amicable\n  | Sociable\n  | Aspiring\n  | Cyclic\n  | Nonterminating\n  deriving (Show)\n\naliquot :: (Integral a) => a -> [a]\naliquot 0 = [0]\naliquot n = n : (aliquot $ sum $ divisors n)\n\nclassify :: (Num a, Eq a) => [a] -> Class\nclassify []             = Nonterminating\nclassify [0]            = Terminating\nclassify [_]            = Nonterminating\nclassify [a,b]\n  | a == b              = Perfect\n  | b == 0              = Terminating\n  | otherwise           = Nonterminating\nclassify x@(a:b:c:_)\n  | a == b              = Perfect\n  | a == c              = Amicable\n  | a `elem` (drop 1 x) = Sociable\n  | otherwise           =\n    case classify (drop 1 x) of\n      Perfect  -> Aspiring\n      Amicable -> Cyclic\n      Sociable -> Cyclic\n      d        -> d\n\nmain :: IO ()\nmain = do\n  let cls n = let ali = take 16 $ aliquot n in (classify ali, ali)\n  mapM_ (print . cls) $ [1..10] ++\n    [11, 12, 28, 496, 220, 1184, 12496, 1264460, 790, 909, 562, 1064, 1488]\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 418737, "name": "Mersenne primes", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\nlucasLehmer :: Int -> Bool\nlucasLehmer p = iterate f 4 !! p-2 == 0\n where\n  f b = (b^2 - 2) `mod` m\n  m = 2^p - 1\n\nmain = mapM_ (printf \"M %d\\n\") $ take 20 mersenne\n where\n  mersenne = filter lucasLehmer primes\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 418738, "name": "Mersenne primes", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\nlucasLehmer :: Int -> Bool\nlucasLehmer p = iterate f 4 !! p-2 == 0\n where\n  f b = (b^2 - 2) `mod` m\n  m = 2^p - 1\n\nmain = mapM_ (printf \"M %d\\n\") $ take 20 mersenne\n where\n  mersenne = filter lucasLehmer primes\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 418739, "name": "Sexy primes", "source": "Translate Haskell to Python: import Text.Printf         (printf)\nimport Data.Numbers.Primes (isPrime, primes)\n\ntype Pair = (Int, Int)\ntype Triplet = (Int, Int, Int)\ntype Quad = (Int, Int, Int, Int)\ntype Quin = (Int, Int, Int, Int, Int)\n\ntype Result = ([Pair], [Triplet], [Quad], [Quin], [Int])\n\ngroups :: Int -> Result -> Result\ngroups n r@(p, t, q, qn, u)\n  | isPrime n4 && isPrime n3 && isPrime n2 && isPrime n1 = (addPair, addTriplet, addQuad, addQuin, u)\n  | isPrime n3 && isPrime n2 && isPrime n1               = (addPair, addTriplet, addQuad, qn, u)\n  | isPrime n2 && isPrime n1                             = (addPair, addTriplet, q, qn, u)\n  | isPrime n1                                           = (addPair, t, q, qn, u)\n  | not (isPrime (n+6)) && not (isPrime n1)              = (p, t, q, qn, n : u)\n  | otherwise                                            = r\n  where addPair    = (n1, n) : p\n        addTriplet = (n2, n1, n) : t\n        addQuad    = (n3, n2, n1, n) : q\n        addQuin    = (n4, n3, n2, n1, n) : qn\n        n1         = n - 6\n        n2         = n - 12\n        n3         = n - 18\n        n4         = n - 24\n\nmain :: IO ()\nmain = do\n  printf (\"Number of sexy prime pairs: %d\\n\" <> lastFiveText) (length pairs) (lastFive pairs)\n  printf (\"Number of sexy prime triplets: %d\\n\" <> lastFiveText) (length triplets) (lastFive triplets)\n  printf (\"Number of sexy prime quadruplets: %d\\n\" <> lastFiveText) (length quads) (lastFive quads)\n  printf \"Number of sexy prime quintuplets: %d\\n  Last 1\u00a0: %s\\n\\n\" (length quins) (show $ last quins)\n  printf \"Number of unsexy primes: %d\\n  Last 10: %s\\n\\n\" (length unsexy) (show $ drop (length unsexy - 10) unsexy)\n  where (pairs, triplets, quads, quins, unsexy) = foldr groups ([], [], [], [], []) $ takeWhile (< 1000035) primes\n        lastFive xs = show $ drop (length xs - 5) xs\n        lastFiveText = \"  Last 5\u00a0: %s\\n\\n\"\n", "target": "LIMIT = 1_000_035\ndef primes2(limit=LIMIT):\n    if limit < 2: return []\n    if limit < 3: return [2]\n    lmtbf = (limit - 3) // 2\n    buf = [True] * (lmtbf + 1)\n    for i in range((int(limit ** 0.5) - 3) // 2 + 1):\n        if buf[i]:\n            p = i + i + 3\n            s = p * (i + 1) + i\n            buf[s::p] = [False] * ((lmtbf - s) // p + 1)\n    return [2] + [i + i + 3 for i, v in enumerate(buf) if v]\n\nprimes = primes2(LIMIT +6)\nprimeset = set(primes)\nprimearray = [n in primeset for n in range(LIMIT)]\n\n\ns = [[] for x in range(4)]\nunsexy = []\n\nfor p in primes:\n    if p > LIMIT:\n        break\n    if p + 6 in primeset and p + 6 < LIMIT:\n        s[0].append((p, p+6))\n    elif p + 6 in primeset:\n        break\n    else:\n        if p - 6 not in primeset:\n            unsexy.append(p)\n        continue\n    if p + 12 in primeset and p + 12 < LIMIT:\n        s[1].append((p, p+6, p+12))\n    else:\n        continue\n    if p + 18 in primeset and p + 18 < LIMIT:\n        s[2].append((p, p+6, p+12, p+18))\n    else:\n        continue\n    if p + 24 in primeset and p + 24 < LIMIT:\n        s[3].append((p, p+6, p+12, p+18, p+24))\n\n\nprint('\"SEXY\" PRIME GROUPINGS:')\nfor sexy, name in zip(s, 'pairs triplets quadruplets quintuplets'.split()):\n    print(f'  {len(sexy)} {na (not isPrime(n-6))))) |> Array.ofSeq\nprintfn \"There are %d unsexy primes less than 1,000,035. The last 10 are:\" n.Length\nArray.skip (n.Length-10) n |> Array.iter(fun n->printf \"%d \" n); printfn \"\"\nlet ni=pCache |> Seq.takeWhile(fun n->nme} ending with ...')\n    for sx in sexy[-5:]:\n        print('   ',sx)\n\nprint(f'\\nThere are {len(unsexy)} unsexy primes ending with ...')\nfor usx in unsexy[-10:]:\n    print(' ',usx)\n"}
{"id": 418740, "name": "Klarner-Rado sequence", "source": "Translate Haskell to Python: import Data.List (intercalate)\nimport Data.List.Ordered (union)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nklarnerRado :: [Integer]\nklarnerRado =\n  1 : \n  union \n    (succ . (2 *) <$> klarnerRado) \n    (succ . (3 *) <$> klarnerRado)\n\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"First one hundred elements of the sequence:\\n\"\n  mapM_\n    putStrLn\n    (intercalate \"  \" <$> chunksOf 10 \n      (printf \"%3d\" <$> take 100 klarnerRado))\n      \n  putStrLn \"\\nKth and 10Kth elements of the sequence:\\n\"\n  mapM_\n    (putStrLn .\n      (<*>) (flip (printf \"%7dth %s %8d\") \" ->\") \n      ((klarnerRado !!) . pred)) $\n        (10 ^) <$> [3 .. 6]\n", "target": "def KlarnerRado(N):\n    K = [1]\n    for i in range(N):\n        j = K[i]\n        firstadd, secondadd = 2 * j + 1, 3 * j + 1\n        if firstadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < firstadd < K[pos + 1]:\n                    K.insert(pos + 1, firstadd)\n                    break\n        elif firstadd > K[-1]:\n            K.append(firstadd)\n        if secondadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < secondadd < K[pos + 1]:\n                    K.insert(pos + 1, secondadd)\n                    break\n        elif secondadd > K[-1]:\n            K.append(secondadd)\n\n    return K\n\nkr1m = KlarnerRado(100_000)\n\nprint('First 100 Klarner-Rado sequence numbers:')\nfor idx, v in enumerate(kr1m[:100]):\n    print(f'{v: 4}', end='\\n' if (idx + 1) % 20 == 0 else '')\nfor n in [1000, 10_000, 100_000]:\n    print(f'The {n :,}th Klarner-Rado number is {kr1m[n-1] :,}')\n"}
{"id": 418741, "name": "Klarner-Rado sequence", "source": "Translate Haskell to Python: import Data.List (intercalate)\nimport Data.List.Ordered (union)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\n\n\nklarnerRado :: [Integer]\nklarnerRado =\n  1 : \n  union \n    (succ . (2 *) <$> klarnerRado) \n    (succ . (3 *) <$> klarnerRado)\n\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"First one hundred elements of the sequence:\\n\"\n  mapM_\n    putStrLn\n    (intercalate \"  \" <$> chunksOf 10 \n      (printf \"%3d\" <$> take 100 klarnerRado))\n      \n  putStrLn \"\\nKth and 10Kth elements of the sequence:\\n\"\n  mapM_\n    (putStrLn .\n      (<*>) (flip (printf \"%7dth %s %8d\") \" ->\") \n      ((klarnerRado !!) . pred)) $\n        (10 ^) <$> [3 .. 6]\n", "target": "def KlarnerRado(N):\n    K = [1]\n    for i in range(N):\n        j = K[i]\n        firstadd, secondadd = 2 * j + 1, 3 * j + 1\n        if firstadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < firstadd < K[pos + 1]:\n                    K.insert(pos + 1, firstadd)\n                    break\n        elif firstadd > K[-1]:\n            K.append(firstadd)\n        if secondadd < K[-1]:\n            for pos in range(len(K)-1, 1, -1):\n                if K[pos] < secondadd < K[pos + 1]:\n                    K.insert(pos + 1, secondadd)\n                    break\n        elif secondadd > K[-1]:\n            K.append(secondadd)\n\n    return K\n\nkr1m = KlarnerRado(100_000)\n\nprint('First 100 Klarner-Rado sequence numbers:')\nfor idx, v in enumerate(kr1m[:100]):\n    print(f'{v: 4}', end='\\n' if (idx + 1) % 20 == 0 else '')\nfor n in [1000, 10_000, 100_000]:\n    print(f'The {n :,}th Klarner-Rado number is {kr1m[n-1] :,}')\n"}
{"id": 418742, "name": "Taxicab numbers", "source": "Translate Haskell to Python: import Data.List (groupBy, sortOn, tails, transpose)\nimport Data.Function (on)\n\n\n\ntaxis :: Int -> [[(Int, ((Int, Int), (Int, Int)))]]\ntaxis nCubes =\n  filter ((> 1) . length) $\n  groupBy (on (==) fst) $\n  sortOn fst\n    [ (fst x + fst y, (x, y))\n    | (x:t) <- tails $ ((^ 3) >>= (,)) <$> [1 .. nCubes] \n    , y <- t ]\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  concat <$>\n  transpose\n    (((<$>) =<< flip justifyRight ' ' . maximum . (length <$>)) <$>\n     transpose (taxiRow <$> (take 25 xs <> take 7 (drop 1999 xs))))\n  where\n    xs = zip [1 ..] (taxis 1200)\n    justifyRight n c = (drop . length) <*> (replicate n c <>)\n\n\ntaxiRow :: (Int, [(Int, ((Int, Int), (Int, Int)))]) -> [String]\ntaxiRow (n, [(a, ((axc, axr), (ayc, ayr))), (b, ((bxc, bxr), (byc, byr)))]) =\n  concat\n    [ [show n, \". \", show a, \" = \"]\n    , term axr axc \" + \"\n    , term ayr ayc \"  or  \"\n    , term bxr bxc \" + \"\n    , term byr byc []\n    ]\n  where\n    term r c l = [\"(\", show r, \"^3=\", show c, \")\", l]\n", "target": "from collections import defaultdict\nfrom itertools import product\nfrom pprint import pprint as pp\n\ncube2n = {x**3:x for x in range(1, 1201)}\nsum2cubes = defaultdict(set)\nfor c1, c2 in product(cube2n, cube2n):\n\tif c1 >= c2: sum2cubes[c1 + c2].add((cube2n[c1], cube2n[c2]))\n\t\ntaxied = sorted((k, v) for k,v in sum2cubes.items() if len(v) >= 2)\n\n\nfor t in enumerate(taxied[:25], 1):\n    pp(t)\nprint('...')    \nfor t in enumerate(taxied[2000-1:2000+6], 2000):\n    pp(t)\n"}
{"id": 418743, "name": "Strong and weak primes", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.Numbers.Primes (primes)\n\nxPrimes :: (Real a, Fractional b) => (b -> b -> Bool) -> [a] -> [a]\nxPrimes op ps@(p1:p2:p3:xs)\n  | realToFrac p2 `op` (realToFrac (p1 + p3) / 2) = p2 : xPrimes op (tail ps)\n  | otherwise = xPrimes op (tail ps)\n\nmain :: IO ()\nmain = do \n  printf \"First 36 strong primes: %s\\n\" . show . take 36 $ strongPrimes\n  printf \"Strong primes below 1,000,000: %d\\n\" . length . takeWhile (<1000000) $ strongPrimes\n  printf \"Strong primes below 10,000,000: %d\\n\\n\" . length . takeWhile (<10000000) $ strongPrimes\n\n  printf \"First 37 weak primes: %s\\n\" . show . take 37 $ weakPrimes \n  printf \"Weak primes below 1,000,000: %d\\n\" . length . takeWhile (<1000000) $ weakPrimes\n  printf \"Weak primes below 10,000,000: %d\\n\\n\" . length . takeWhile (<10000000) $ weakPrimes\n  where strongPrimes = xPrimes (>) primes\n        weakPrimes   = xPrimes (<) primes\n", "target": "import numpy as np\n\ndef primesfrom2to(n):\n    \n    \n    sieve = np.ones(n//3 + (n%6==2), dtype=np.bool)\n    sieve[0] = False\n    for i in range(int(n**0.5)//3+1):\n        if sieve[i]:\n            k=3*i+1|1\n            sieve[      ((k*k)//3)      ::2*k] = False\n            sieve[(k*k+4*k-2*k*(i&1))//3::2*k] = False\n    return np.r_[2,3,((3*np.nonzero(sieve)[0]+1)|1)]\n\np = primes10m   = primesfrom2to(10_000_000)\ns = strong10m   = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t > (s + u) / 2]\nw = weak10m     = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t < (s + u) / 2]\nb = balanced10m = [t for s, t, u in zip(p, p[1:], p[2:]) \n                   if t == (s + u) / 2]\n\nprint('The first   36   strong primes:', s[:36])\nprint('The   count   of the strong primes below   1,000,000:',\n      sum(1 for p in s if p < 1_000_000))\nprint('The   count   of the strong primes below  10,000,000:', len(s))\nprint('\\nThe first   37   weak primes:', w[:37])\nprint('The   count   of the weak   primes below   1,000,000:',\n      sum(1 for p in w if p < 1_000_000))\nprint('The   count   of the weak   primes below  10,000,000:', len(w))\nprint('\\n\\nThe first   10 balanced primes:', b[:10])\nprint('The   count   of balanced   primes below   1,000,000:',\n      sum(1 for p in b if p < 1_000_000))\nprint('The   count   of balanced   primes below  10,000,000:', len(b))\nprint('\\nTOTAL primes below   1,000,000:',\n      sum(1 for pr in p if pr < 1_000_000))\nprint('TOTAL primes below  10,000,000:', len(p))\n"}
{"id": 418744, "name": "Left factorials", "source": "Translate Haskell to Python: leftFact :: [Integer]\nleftFact = scanl (+) 0 fact\n\nfact :: [Integer]\nfact = scanl (*) 1 [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"0 ~ 10:\"\n    , show $ (leftFact !!) <$> [0 .. 10]\n    , \"\"\n    , \"20 ~ 110 by tens:\"\n    , unlines $ show . (leftFact !!) <$> [20,30 .. 110]\n    , \"\"\n    , \"length of 1,000 ~ 10,000 by thousands:\"\n    , show $ length . show . (leftFact !!) <$> [1000,2000 .. 10000]\n    , \"\"\n    ]\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 418745, "name": "Left factorials", "source": "Translate Haskell to Python: leftFact :: [Integer]\nleftFact = scanl (+) 0 fact\n\nfact :: [Integer]\nfact = scanl (*) 1 [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"0 ~ 10:\"\n    , show $ (leftFact !!) <$> [0 .. 10]\n    , \"\"\n    , \"20 ~ 110 by tens:\"\n    , unlines $ show . (leftFact !!) <$> [20,30 .. 110]\n    , \"\"\n    , \"length of 1,000 ~ 10,000 by thousands:\"\n    , show $ length . show . (leftFact !!) <$> [1000,2000 .. 10000]\n    , \"\"\n    ]\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 418746, "name": "Motzkin numbers", "source": "Translate Haskell to Python: import Control.Monad.Memo (Memo, memo, startEvalMemo)\nimport Math.NumberTheory.Primes.Testing (isPrime)\nimport System.Environment (getArgs)\nimport Text.Printf (printf)\n\ntype I = Integer\n\n\n\nmotzkin :: I -> Memo I I I\nmotzkin 0 = return 1\nmotzkin 1 = return 1\nmotzkin n = do\n  m1 <- memo motzkin (n-1)\n  m2 <- memo motzkin (n-2)\n  return $ ((2*n+1)*m1 + (3*n-3)*m2) `div` (n+2)\n\n\nmotzkins :: I -> [I]\nmotzkins = startEvalMemo . mapM motzkin . enumFromTo 0\n\n\nprintMotzkins :: I -> IO ()\nprintMotzkins n = mapM_ prnt $ zip [0 :: I ..] (motzkins n)\n  where prnt (i, m) = printf \"%2d %20d %s\\n\" i m $ prime m\n        prime m = if isPrime m then \"prime\" else \"\"\n\nmain :: IO ()\nmain = do\n  [n] <- map read <$> getArgs\n  printMotzkins n\n", "target": "\n\nfrom sympy import isprime\n\n\ndef motzkin(num_wanted):\n    \n    mot = [1] * (num_wanted + 1)\n    for i in range(2, num_wanted + 1):\n        mot[i] = (mot[i-1]*(2*i+1) + mot[i-2]*(3*i-3)) // (i + 2)\n    return mot\n\n\ndef print_motzkin_table(N=41):\n    \n    print(\n        \" n          M[n]             Prime?\\n-----------------------------------\")\n    for i, e in enumerate(motzkin(N)):\n        print(f'{i : 3}{e : 24,}', isprime(e))\n\n\nprint_motzkin_table()\n"}
{"id": 418747, "name": "Strange plus numbers", "source": "Translate Haskell to Python: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrangePlus :: Int -> Bool\nisStrangePlus n =\n  all\n    (\\(a, b) -> (a + b) `elem` [2, 3, 5, 7, 11, 13, 17])\n    $ (zip <*> tail) (digits n)\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrangePlus [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"\\\"Strange Plus\\\" numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 418748, "name": "Strange plus numbers", "source": "Translate Haskell to Python: import Data.List (intercalate)\nimport Data.List.Split (chunksOf)\n\n\n\nisStrangePlus :: Int -> Bool\nisStrangePlus n =\n  all\n    (\\(a, b) -> (a + b) `elem` [2, 3, 5, 7, 11, 13, 17])\n    $ (zip <*> tail) (digits n)\n\n\ndigits :: Int -> [Int]\ndigits = fmap (read . return) . show\n\n\nmain =\n  let xs = filter isStrangePlus [100 .. 500]\n   in (putStrLn . intercalate \"\\n\\n\")\n        [ \"\\\"Strange Plus\\\" numbers found in range [100..500]\",\n          \"(total \" <> (show . length) xs <> \")\",\n          \"Full list:\",\n          unlines\n            (unwords <$> chunksOf 10 (show <$> xs))\n        ]\n", "target": "Python 3.8.5 (default, Sep  3 2020, 21:29:08) [MSC v.1916 64 bit (AMD64)] on win32\nType \"help\", \"copyright\", \"credits\" or \"license()\" for more information.\n>>> from sympy import isprime\n\n>>> [x for x in range(101,500) \n if isprime(sum(int(c) for c in str(x)[:2])) and\n    isprime(sum(int(c) for c in str(x)[1:]))]\n[111, 112, 114, 116, 120, 121, 123, 125, 129, 141, 143, 147, 149, 161, 165, 167, 202, 203, 205, 207, 211, 212, 214, 216, 230, 232, 234, 238, 250, 252, 256, 258, 292, 294, 298, 302, 303, 305, 307, 320, 321, 323, 325, 329, 341, 343, 347, 349, 383, 385, 389, 411, 412, 414, 416, 430, 432, 434, 438, 470, 474, 476, 492, 494, 498]\n>>>\n"}
{"id": 418749, "name": "Smarandache prime-digital sequence", "source": "Translate Haskell to Python: \nimport Control.Monad (guard)\nimport Math.NumberTheory.Primes.Testing (isPrime)\nimport Data.List.Split (chunksOf)\nimport Data.List (intercalate)\nimport Text.Printf (printf)\n\nsmarandache :: [Integer]\nsmarandache = [2,3,5,7] <> s [2,3,5,7] >>= \\x -> guard (isPrime x) >> [x]\n where s xs = r <> s r where r = xs >>= \\x -> [x*10+2, x*10+3, x*10+5, x*10+7]\n\nnextSPDSTerms :: [Int] -> [(String, String)]\nnextSPDSTerms = go 1 smarandache\n where\n  go _ _ [] = []\n  go c (x:xs) terms\n   | c `elem` terms = (commas c, commas x) : go nextCount xs (tail terms)\n   | otherwise      = go nextCount xs terms\n   where nextCount = succ c\n\ncommas :: Show a => a -> String\ncommas = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do\n  printf \"The first 25 SPDS:\\n%s\\n\\n\" $ f smarandache\n  mapM_ (uncurry (printf \"The %9sth SPDS: %15s\\n\")) $ \n    nextSPDSTerms [100, 1_000, 10_000, 100_000, 1_000_000]\n where f = show . take 25\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef is_prime(n):\n    return len(divisors(n)) == 2\n\n\ndef digit_check(n):\n    if len(str(n))<2:\n        return True\n    else:\n        for digit in str(n):\n            if not is_prime(int(digit)):\n                return False\n        return True\n\n\ndef sequence(max_n=None):\n    ii = 0\n    n = 0\n    while True:\n        ii += 1\n        if is_prime(ii):\n            if max_n is not None:\n                if n>max_n:\n                    break\n            if digit_check(ii):\n                n += 1\n                yield ii\n\n\nif __name__ == '__main__':\n    generator = sequence(100)\n    for index, item in zip(range(1, 16), generator):\n        print(index, item)\n    for index, item in zip(range(16, 100), generator):\n        pass\n    print(100, generator.__next__())\n"}
{"id": 418750, "name": "Magic squares of doubly even order", "source": "Translate Haskell to Python: import Data.List (transpose, unfoldr, intercalate)\nimport Data.List.Split (chunksOf)\nimport Data.Bool (bool)\nimport Control.Monad (forM_)\n\nmagicSquare :: Int -> [[Int]]\nmagicSquare n\n  | rem n 4 > 0 = []\n  | otherwise =\n    chunksOf n $ zipWith (flip (bool =<< (-) limit)) series [1 .. sqr]\n  where\n    sqr = n * n\n    limit = sqr + 1\n    series\n      | isPowerOf 2 n = magicSeries $ floor (logBase 2 (fromIntegral sqr))\n      | otherwise =\n        concat . concat . concat . scale $ scale <$> chunksOf 4 (magicSeries 4)\n      where\n        scale = replicate $ quot n 4\n\nmagicSeries :: Int -> [Bool]\nmagicSeries = (iterate ((++) <*> fmap not) [True] !!)\n\nisPowerOf :: Int -> Int -> Bool\nisPowerOf k n = until ((0 /=) . flip rem k) (`quot` k) n == 1\n\n\nchecked :: [[Int]] -> (Int, Bool)\nchecked square =\n  let diagonals =\n        fmap (flip (zipWith (!!)) [0 ..]) . ((:) <*> (return . reverse))\n      h:t =\n        sum <$>\n        square ++ \n        transpose square ++ \n        diagonals square \n  in (h, all (h ==) t)\n\ntable :: String -> [[String]] -> [String]\ntable delim rows =\n  let justifyRight c n s = drop (length s) (replicate n c ++ s)\n  in intercalate delim <$>\n     transpose\n       ((fmap =<< justifyRight ' ' . maximum . fmap length) <$> transpose rows)\n\nmain :: IO ()\nmain =\n  forM_ [4, 8, 16] $\n  \\n -> do\n    let test = magicSquare n\n    putStrLn $ unlines (table \" \" (fmap show <$> test))\n    print $ checked test\n    putStrLn []\n", "target": "def MagicSquareDoublyEven(order):\n    sq = [range(1+n*order,order + (n*order)+1) for n in range(order) ]\n    n1 = order/4\n    for r in range(n1):\n        r1 = sq[r][n1:-n1]\n        r2 = sq[order -r - 1][n1:-n1]\n        r1.reverse()\n        r2.reverse()\n        sq[r][n1:-n1] = r2\n        sq[order -r - 1][n1:-n1] = r1\n    for r in range(n1, order-n1):\n        r1 = sq[r][:n1]\n        r2 = sq[order -r - 1][order-n1:]\n        r1.reverse()\n        r2.reverse()\n        sq[r][:n1] = r2\n        sq[order -r - 1][order-n1:] = r1\n    return sq\n\ndef printsq(s):\n    n = len(s)\n    bl = len(str(n**2))+1\n    for i in range(n):\n        print ''.join( [ (\"%\"+str(bl)+\"s\")%(str(x)) for x in s[i]] )\n    print \"\\nMagic constant = %d\"%sum(s[0])\n\nprintsq(MagicSquareDoublyEven(8))\n"}
{"id": 418751, "name": "Square-free integers", "source": "Translate Haskell to Python: import Data.List.Split (chunksOf)\nimport Math.NumberTheory.Primes (factorise)\nimport Text.Printf (printf)\n\n\nisSquareFree :: Integer -> Bool\nisSquareFree = all ((== 1) . snd) . factorise\n\n\nsquareFrees :: Integer -> Integer -> [Integer]\nsquareFrees lo hi = filter isSquareFree [lo..hi]\n\n\n\n\ncounts :: (Ord a, Num b) => [a] -> [a] -> [b]\ncounts = go 0\n  where go c lims@(l:ls) (v:vs) | v > l     = c : go (c+1) ls vs\n                                | otherwise = go (c+1) lims vs\n        go _ [] _  = []\n        go c ls [] = replicate (length ls) c\n\nprintSquareFrees :: Int -> Integer -> Integer -> IO ()\nprintSquareFrees cols lo hi =\n  let ns = squareFrees lo hi\n      title = printf \"Square free numbers from %d to %d\\n\" lo hi\n      body = unlines $ map concat $ chunksOf cols $ map (printf \" %3d\") ns\n  in putStrLn $ title ++ body\n\nprintSquareFreeCounts :: [Integer] -> Integer -> Integer -> IO ()\nprintSquareFreeCounts lims lo hi =\n  let cs = counts lims $ squareFrees lo hi :: [Integer]\n      title = printf \"Counts of square-free numbers\\n\"\n      body = unlines $ zipWith (printf \"  from 1 to %d: %d\") lims cs\n  in putStrLn $ title ++ body\n\nmain :: IO ()\nmain = do\n  printSquareFrees 20 1 145\n  printSquareFrees 5 1000000000000 1000000000145\n  printSquareFreeCounts [100, 1000, 10000, 100000, 1000000] 1 1000000\n", "target": "import math\n\ndef SquareFree ( _number ) :\n\tmax = (int) (math.sqrt ( _number ))\n\n\tfor root in range ( 2, max+1 ):\t\t\t\t\t\n\t\tif 0 == _number % ( root * root ):\n\t\t\treturn False\n\n\treturn True\n\ndef ListSquareFrees( _start, _end ):\n\tcount = 0\n\tfor i in range ( _start, _end+1 ):\n\t\tif True == SquareFree( i ):\n\t\t\tprint ( \"{}\\t\".format(i), end=\"\" )\n\t\t\tcount += 1\n\n\tprint ( \"\\n\\nTotal count of square-free numbers between {} and {}: {}\".format(_start, _end, count))\n\nListSquareFrees( 1, 100 )\nListSquareFrees( 1000000000000, 1000000000145 )\n"}
{"id": 418752, "name": "Self numbers", "source": "Translate Haskell to Python: import Control.Monad (forM_)\nimport Text.Printf\n\nselfs :: [Integer]\nselfs = sieve (sumFs [0..]) [0..]\n  where\n    sumFs = zipWith (+) [ a+b+c+d+e+f+g+h+i+j\n                        | a <- [0..9] , b <- [0..9]\n                        , c <- [0..9] , d <- [0..9]\n                        , e <- [0..9] , f <- [0..9]\n                        , g <- [0..9] , h <- [0..9]\n                        , i <- [0..9] , j <- [0..9] ]\n\n    \n    \n\n    sieve (f:fs) (n:ns)\n      | n > f = sieve fs (n:ns)\n      | n `notElem` take 81 (f:fs) = n : sieve (f:fs) ns\n      | otherwise = sieve (f:fs) ns\n\nmain = do\n  print $ take 50 selfs\n  forM_ [1..8] $ \\i -> \n    printf \"1e%v\\t%v\\n\" (i :: Int) (selfs !! (10^i-1))\n", "target": "class DigitSumer :\n    def __init__(self): \n        sumdigit = lambda n : sum( map( int,str( n )))\n        self.t = [sumdigit( i ) for i in xrange( 10000 )]\n    def __call__ ( self,n ):\n        r = 0\n        while n >= 10000 :\n            n,q = divmod( n,10000 )\n            r += self.t[q]\n        return r + self.t[n] \n\n\ndef self_numbers ():\n    d = DigitSumer()\n    s = set([])\n    i = 1\n    while 1 :\n        n = i + d( i )\n        if i in s :\n            s.discard( i )\n        else:\n            yield i\n        s.add( n )\n        i += 1\n\nimport time\np = 100\nt = time.time()\nfor i,s in enumerate( self_numbers(),1 ):\n    if i <= 50 : \n        print s,\n        if i == 50 : print\n    if i == p :\n        print '%7.1f sec  %9dth = %d'%( time.time()-t,i,s )\n        p *= 10\n"}
{"id": 418753, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Haskell to Python: \nimport Control.Monad (guard)\nimport Text.Printf (printf)\nimport Data.List (intercalate, unfoldr)\nimport Data.List.Split (chunksOf)\nimport Data.Tuple (swap)\n\nnivens :: [Int]\nnivens = [1..] >>= \\n -> guard (n `rem` digitSum n == 0) >> [n]\n where\n  digitSum = sum . unfoldr (\\x -> guard (x > 0) >> pure (swap $ x `quotRem` 10))\n\nfindGaps :: [(Int, Int, Int)]\nfindGaps = go (zip [1..] nivens) 0\n where\n  go [] n = []\n  go r@((c, currentNiven):(_, nextNiven):xs) lastGap\n   | gap > lastGap = (gap, c, currentNiven) : go (tail r) gap\n   | otherwise     = go (tail r) lastGap\n   where\n    gap = nextNiven - currentNiven\n  go (x:xs) _ = []\n\nthousands :: Int -> String\nthousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n\nmain :: IO ()\nmain = do \n  printf row \"Gap\" \"Index of Gap\" \"Starting Niven\"\n  mapM_ (\\(gap, gapIndex, niven) -> printf row (show gap) (thousands gapIndex) (thousands niven)) \n    $ takeWhile (\\(_, gapIndex, _) -> gapIndex < 10_000_000) findGaps\n where\n  row = \"%5s%15s%15s\\n\"\n", "target": "\n\n\n\n\n\ndef digit_sum(n, sum):\n    sum += 1\n    while n > 0 and n % 10 == 0:\n        sum -= 9\n        n /= 10\n    \n    return sum\n    \nprevious = 1\ngap = 0\nsum = 0\nniven_index = 0\ngap_index = 1\n \nprint(\"Gap index  Gap    Niven index    Niven number\")\n\nniven = 1\n\nwhile gap_index <= 22:\n    sum = digit_sum(niven, sum)\n    if niven % sum == 0:\n        if niven > previous + gap:\n            gap = niven - previous;\n            print('{0:9d} {1:4d}  {2:13d}     {3:11d}'.format(gap_index, gap, niven_index, previous))\n            gap_index += 1\n        previous = niven\n        niven_index += 1\n    niven += 1\n"}
{"id": 418754, "name": "Old Russian measure of length", "source": "Translate Haskell to Python: module Main where\n\nimport Text.Printf (printf)\nimport System.Environment (getArgs, getProgName)\n\ntochka     = (\"tochka\"    , 0.000254)\nliniya     = (\"liniya\"    , 0.00254)\ncentimeter = (\"centimeter\", 0.01)\ndiuym      = (\"diuym\"     , 0.0254)\nvershok    = (\"vershok\"   , 0.04445)\npiad       = (\"piad\"      , 0.1778)\nfut        = (\"fut\"       , 0.3048)\narshin     = (\"arshin\"    , 0.7112)\nmeter      = (\"meter\"     , 1.0)\nsazhen     = (\"sazhen\"    , 2.1336)\nkilometer  = (\"kilometer\" , 1000.0)\nversta     = (\"versta\"    , 1066.8)\nmilia      = (\"milia\"     , 7467.6)\n\nunits :: [(String, Double)]\nunits = [tochka, liniya, centimeter, diuym, vershok, piad, fut, arshin, meter, sazhen, kilometer, versta, milia]\n\n\nconvert :: Double -> Double -> IO ()\nconvert num factor = mapM_ (\\(unit, fac) -> printf \"|\u00a0%-10s |\u00a0%-22f|\\n\" unit  (num * factor / fac)) units\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    [x,y] | [(num, \"\")]   <- reads x :: [(Double, String)]\n          , (Just factor) <- lookup y units -> convert num factor\n    (_) -> do\n      name <- getProgName\n      printf \"Arguments were wrong - please use ./%s <number> <unit>\\n\" name\n", "target": "from sys import argv\n \nunit2mult = {\"arshin\": 0.7112, \"centimeter\": 0.01,     \"diuym\":   0.0254,\n             \"fut\":    0.3048, \"kilometer\":  1000.0,   \"liniya\":  0.00254,\n             \"meter\":  1.0,    \"milia\":      7467.6,   \"piad\":    0.1778,\n             \"sazhen\": 2.1336, \"tochka\":     0.000254, \"vershok\": 0.04445,\n             \"versta\": 1066.8}\n \nif __name__ == '__main__':\n    assert len(argv) == 3, 'ERROR. Need two arguments - number then units'\n    try:\n        value = float(argv[1])\n    except:\n        print('ERROR. First argument must be a (float) number')\n        raise\n    unit = argv[2]\n    assert unit in unit2mult, ( 'ERROR. Only know the following units: ' \n                                + ' '.join(unit2mult.keys()) )\n\n    print(\"%g %s to:\" % (value, unit))\n    for unt, mlt in sorted(unit2mult.items()):\n        print('  %10s: %g' % (unt, value * unit2mult[unit] / mlt))\n"}
{"id": 418755, "name": "Minimum multiple of m where digital sum equals m", "source": "Translate Haskell to Python: import Data.Bifunctor (first)\nimport Data.List (elemIndex, intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Maybe (fromJust)\nimport Text.Printf (printf)\n\n\n\na131382 :: [Int]\na131382 =\n  fromJust . (elemIndex <*> productDigitSums)\n    <$> [1 ..]\n\nproductDigitSums :: Int -> [Int]\nproductDigitSums n = digitSum . (n *) <$> [0 ..]\n\n\nmain :: IO ()\nmain =\n  (putStrLn . table \" \") $\n    chunksOf 10 $ show <$> take 40 a131382\n\n\ndigitSum :: Int -> Int\ndigitSum 0 = 0\ndigitSum n = uncurry (+) (first digitSum $ quotRem n 10)\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef a131382():\n    \n    return (\n        elemIndex(x)(\n            productDigitSums(x)\n        ) for x in count(1)\n    )\n\n\n\ndef productDigitSums(n):\n    \n    return (digitSum(n * x) for x in count(0))\n\n\n\n\ndef main():\n    \n\n    print(\n        table(10)([\n            str(x) for x in islice(\n                a131382(),\n                40\n            )\n        ])\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    def go(xs):\n        return (\n            xs[i:n + i] for i in range(0, len(xs), n)\n        ) if 0 < n else None\n    return go\n\n\n\ndef digitSum(n):\n    \n    return sum(int(x) for x in list(str(n)))\n\n\n\ndef elemIndex(x):\n    \n    def go(xs):\n        try:\n            return next(\n                i for i, v in enumerate(xs) if x == v\n            )\n        except StopIteration:\n            return None\n    return go\n\n\n\ndef table(n):\n    \n    def go(xs):\n        w = len(xs[-1])\n        return '\\n'.join(\n            ' '.join(row) for row in chunksOf(n)([\n                s.rjust(w, ' ') for s in xs\n            ])\n        )\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418756, "name": "Pythagorean quadruples", "source": "Translate Haskell to Python: powersOfTwo :: [Int]\npowersOfTwo = iterate (2 *) 1\n\nunrepresentable :: [Int]\nunrepresentable = merge powersOfTwo ((5 *) <$> powersOfTwo)\n\nmerge :: [Int] -> [Int] -> [Int]\nmerge xxs@(x:xs) yys@(y:ys)\n  | x < y = x : merge xs yys\n  | otherwise = y : merge xxs ys\n\nmain :: IO ()\nmain = do\n  putStrLn \"The values of d <= 2200 which can't be represented.\"\n  print $ takeWhile (<= 2200) unrepresentable\n", "target": "def quad(top=2200):\n    r = [False] * top\n    ab = [False] * (top * 2)**2\n    for a in range(1, top):\n        for b in range(a, top):\n            ab[a * a + b * b] = True\n    s = 3\n    for c in range(1, top):\n        s1, s, s2 = s, s + 2, s + 2\n        for d in range(c + 1, top):\n            if ab[s1]:\n                r[d] = True\n            s1 += s2\n            s2 += 2\n    return [i for i, val in enumerate(r) if not val and i]\n    \nif __name__ == '__main__':\n    n = 2200\n    print(f\"Those values of d in 1..{n} that can't be represented: {quad(n)}\")\n"}
{"id": 418757, "name": "Sum and product puzzle", "source": "Translate Haskell to Python: import Data.List (intersect)\n\ns1, s2, s3, s4 :: [(Int, Int)]\ns1 = [(x, y) | x <- [1 .. 100], y <- [1 .. 100], 1 < x && x < y && x + y < 100]\n\nadd, mul :: (Int, Int) -> Int\nadd (x, y) = x + y\nmul (x, y) = x * y\n\nsumEq, mulEq :: (Int, Int) -> [(Int, Int)]\nsumEq p = filter (\\q -> add q == add p) s1\nmulEq p = filter (\\q -> mul q == mul p) s1\n\ns2 = filter (\\p -> all (\\q -> (length $ mulEq q) /= 1) (sumEq p)) s1\ns3 = filter (\\p -> length (mulEq p `intersect` s2) == 1) s2\ns4 = filter (\\p -> length (sumEq p `intersect` s3) == 1) s3\n\nmain = print s4\n", "target": "\n\nfrom collections import Counter\n\ndef decompose_sum(s):\n    return [(a,s-a) for a in range(2,int(s/2+1))]\n\n\nall_pairs = set((a,b) for a in range(2,100) for b in range(a+1,100) if a+b<100)\n\n\nproduct_counts = Counter(c*d for c,d in all_pairs)\nunique_products = set((a,b) for a,b in all_pairs if product_counts[a*b]==1)\ns_pairs = [(a,b) for a,b in all_pairs if\n    all((x,y) not in unique_products for (x,y) in decompose_sum(a+b))]\n\n\nproduct_counts = Counter(c*d for c,d in s_pairs)\np_pairs = [(a,b) for a,b in s_pairs if product_counts[a*b]==1]\n\n\nsum_counts = Counter(c+d for c,d in p_pairs)\nfinal_pairs = [(a,b) for a,b in p_pairs if sum_counts[a+b]==1]\n\nprint(final_pairs)\n"}
{"id": 418758, "name": "Test integerness", "source": "Translate Haskell to Python: import Data.Decimal\nimport Data.Ratio\nimport Data.Complex\n", "target": ">>> def isint(f): \n    return complex(f).imag == 0 and complex(f).real.is_integer()\n\n>>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))]\n[True, True, True, False, False, False]\n\n>>> \n...\n>>> isint(25.000000)\nTrue\n>>> isint(24.999999)\nFalse\n>>> isint(25.000100)\nFalse\n>>> isint(-2.1e120)\nTrue\n>>> isint(-5e-2)\nFalse\n>>> isint(float('nan'))\nFalse\n>>> isint(float('inf'))\nFalse\n>>> isint(5.0+0.0j)\nTrue\n>>> isint(5-5j)\nFalse\n"}
{"id": 418759, "name": "Sum of two adjacent numbers are primes", "source": "Translate Haskell to Python: import Data.Numbers.Primes\n\nprimeSumsOfConsecutiveNumbers :: Integral a => [(a, (a, a))]\nprimeSumsOfConsecutiveNumbers =\n  let go a b = [(n, (a, b)) | let n = a + b, isPrime n]\n   in concat $ zipWith go [1 ..] [2 ..]\n\nmain :: IO ()\nmain = mapM_ print $ take 20 primeSumsOfConsecutiveNumbers\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == \"__main__\":\n    n = 0\n    num = 0\n\n    print('The first 20 pairs of numbers whose sum is prime:') \n    while True:\n        n += 1\n        suma = 2*n+1\n        if isPrime(suma):\n            num += 1\n            if num < 21:\n                print('{:2}'.format(n), \"+\", '{:2}'.format(n+1), \"=\", '{:2}'.format(suma))\n            else:\n                break\n"}
{"id": 418760, "name": "Linux CPU utilization", "source": "Translate Haskell to Python: import Data.List ( (!!) ) \n\nsplitString :: Char -> String -> [String]\nsplitString c [] = []\nsplitString c s = let ( item , rest ) = break ( == c ) s\n                      ( _ , next ) = break ( /= c ) rest\n\t\t  in item : splitString c next    \n\t\t  \ncomputeUsage :: String -> Double\ncomputeUsage s = (1.0 - ((lineElements !! 3 ) /  sum times)) * 100\n   where\n      lineElements = map (fromInteger . read ) $ tail $ splitString ' ' s\n      times = tail lineElements\n\nmain :: IO ( )      \nmain = do \n   theTimes <- fmap lines $ readFile \"/proc/stat\" \n   putStr $ show $ computeUsage $ head theTimes\n   putStrLn \"\u00a0%\"\n", "target": "from __future__ import print_function\nfrom time import sleep\n\n\nlast_idle = last_total = 0\nwhile True:\n    with open('/proc/stat') as f:\n        fields = [float(column) for column in f.readline().strip().split()[1:]]\n    idle, total = fields[3], sum(fields)\n    idle_delta, total_delta = idle - last_idle, total - last_total\n    last_idle, last_total = idle, total\n    utilisation = 100.0 * (1.0 - idle_delta / total_delta)\n    print('%5.1f%%' % utilisation, end='\\r')\n    sleep(5)\n"}
{"id": 418761, "name": "Ulam numbers", "source": "Translate Haskell to Python: import Data.List\n\nulam \n  :: Integral i =>\n     Int -> i\nulam 1 = 1\nulam 2 = 2\nulam n\n  | n > 2 = ulams !! (n-1)\n\nulams\n  :: Integral n =>\n     [n]\nulams = 1:2:(nexts [2,1])\nnexts us = u: (nexts (u:us))\n  where\n    n = length us\n    [u] = head . filter isSingleton . group . sort  $ \n            [v | i <- [0 .. n-2], j <- [i+1 .. n-1] \n               , let s = us !! i\n               , let t = us !! j\n               , let v = s+t\n               , v > head us\n               ]\n\nisSingleton :: [a] -> Bool\nisSingleton as\n  | length as == 1 = True\n  | otherwise      = False\n", "target": "import time\n\ndef ulam(n):\n    if n <= 2:\n        return n\n    mx = 1352000\n    lst = [1, 2] + [0] * mx\n    sums = [0] * (mx * 2 + 1)\n    sums[3] = 1\n    size = 2\n    while size < n:\n        query = lst[size-1] + 1\n        while True:\n            if sums[query] == 1:\n                for i in range(size):\n                    sum = query + lst[i]\n                    t = sums[sum] + 1\n                    if t <= 2:\n                        sums[sum] = t\n                lst[size], size = query, size + 1\n                break\n            query += 1\n    return query\n \nt0 = time.time()\nfor p in range(5):\n    n = 10**p\n    print(f\"The {n}{'th' if n!=1 else 'st'} Ulam number is {ulam(n)}\")\n\nprint(\"\\nElapsed time:\", time.time() - t0)\n"}
{"id": 418762, "name": "Smallest power of 6 whose decimal expansion contains n", "source": "Translate Haskell to Python: import Data.List (find, isInfixOf)\nimport Text.Printf (printf)\n\nsmallest :: Integer -> Integer\nsmallest n = d\n  where\n    Just d = find ((show n `isInfixOf`) . show) sixes\n      \nsixes :: [Integer]\nsixes = iterate (* 6) 1\n\nmain :: IO ()\nmain =\n  putStr $\n    [0 .. 21] >>= printf \"%2d: %d\\n\" <*> smallest\n", "target": "def smallest_six(n):\n    p = 1\n    while str(n) not in str(p): p *= 6\n    return p\n    \nfor n in range(22):\n    print(\"{:2}: {}\".format(n, smallest_six(n)))\n"}
{"id": 418763, "name": "Summation of primes", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\n\nsumOfPrimesBelow :: Integral a => a -> a\nsumOfPrimesBelow n =\n  sum $ takeWhile (< n) primes\n\nmain :: IO ()\nmain = print $ sumOfPrimesBelow 2000000\n", "target": "\n\ndef isPrime(n):\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False        \n    return True\n\nif __name__ == '__main__':\n    suma = 2\n    n = 1\n    for i in range(3, 2000000, 2):\n        if isPrime(i):\n            suma += i\n            n+=1 \n    print(suma)\n"}
{"id": 418764, "name": "Steady squares", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.List (isSuffixOf)\n\n\n\np :: Int -> Bool\np = isSuffixOf . show <*> (show . join (*))\n\n\n\nmain :: IO ()\nmain =\n  print $\n    takeWhile (< 10000) $ filter p [0 ..]\n", "target": "print(\"working...\")\nprint(\"Steady squares under 10.000 are:\")\nlimit = 10000\n\nfor n in range(1,limit):\n    nstr = str(n)\n    nlen = len(nstr)\n    square = str(pow(n,2))\n    rn = square[-nlen:]\n    if nstr == rn:\n       print(str(n) + \" \" + str(square))\n\nprint(\"done...\")\n"}
{"id": 418765, "name": "Safe primes and unsafe primes", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.Numbers.Primes (isPrime, primes)\n\nmain = do \n  printf \"First 35 safe primes: %s\\n\" (show $ take 35 safe)\n  printf \"There are %d safe primes below 100,000.\\n\" (length $ takeWhile (<1000000) safe)\n  printf \"There are %d safe primes below 10,000,000.\\n\\n\" (length $ takeWhile (<10000000) safe)\n\n  printf \"First 40 unsafe primes: %s\\n\" (show $ take 40 unsafe)\n  printf \"There are %d unsafe primes below 100,000.\\n\" (length $ takeWhile (<1000000) unsafe)\n  printf \"There are %d unsafe primes below 10,000,000.\\n\\n\" (length $ takeWhile (<10000000) unsafe)\n\n  where safe = filter (\\n -> isPrime ((n-1) `div` 2)) primes\n        unsafe = filter (\\n -> not (isPrime((n-1) `div` 2))) primes\n", "target": "primes =[]\nsp =[]\nusp=[]\nn = 10000000\nif 2<n:\n    primes.append(2)\nfor i in range(3,n+1,2):\n    for j in primes:\n        if(j>i/2) or (j==primes[-1]):\n            primes.append(i)\n            if((i-1)/2) in primes:\n                sp.append(i)\n                break\n            else:\n                usp.append(i)\n                break\n        if (i%j==0):\n            break\n\nprint('First 35 safe primes are:\\n' , sp[:35])\nprint('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')\nprint('There are '+str(len(sp))+' safe primes below 10,000,000')\nprint('First 40 unsafe primes:\\n',usp[:40])\nprint('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')\nprint('There are '+str(len(usp))+' safe primes below 10,000,000')\n"}
{"id": 418766, "name": "Hash join", "source": "Translate Haskell to Python: \nimport qualified Data.HashTable.ST.Basic as H\nimport Data.Hashable\nimport Control.Monad.ST\nimport Control.Monad\nimport Data.STRef\n\nhashJoin :: (Eq k, Hashable k) =>\n            [t] -> (t -> k) -> [a] -> (a -> k) -> [(t, a)]\nhashJoin xs fx ys fy = runST $ do\n  l <- newSTRef []\n  ht <- H.new\n  forM_ ys $ \\y -> H.insert ht (fy y) =<< \n    (H.lookup ht (fy y) >>= \\case\n      Nothing -> return [y]\n      Just v -> return (y:v))\n  forM_ xs $ \\x -> do\n    H.lookup ht (fx x) >>= \\case\n      Nothing -> return ()\n      Just v -> modifySTRef' l ((map (x,)  v) ++) \n  readSTRef l\n\nmain = mapM_ print $ hashJoin \n    [(1, \"Jonah\"), (2, \"Alan\"), (3, \"Glory\"), (4, \"Popeye\")]\n        snd\n    [(\"Jonah\", \"Whales\"), (\"Jonah\", \"Spiders\"), \n      (\"Alan\", \"Ghosts\"), (\"Alan\", \"Zombies\"), (\"Glory\", \"Buffy\")]\n        fst\n", "target": "from collections import defaultdict\n\ndef hashJoin(table1, index1, table2, index2):\n    h = defaultdict(list)\n    \n    for s in table1:\n        h[s[index1]].append(s)\n    \n    return [(s, r) for r in table2 for s in h[r[index2]]]\n\ntable1 = [(27, \"Jonah\"),\n          (18, \"Alan\"),\n          (28, \"Glory\"),\n          (18, \"Popeye\"),\n          (28, \"Alan\")]\ntable2 = [(\"Jonah\", \"Whales\"),\n          (\"Jonah\", \"Spiders\"),\n          (\"Alan\", \"Ghosts\"),\n          (\"Alan\", \"Zombies\"),\n          (\"Glory\", \"Buffy\")]\n\nfor row in hashJoin(table1, 1, table2, 0):\n    print(row)\n"}
{"id": 418767, "name": "Giuga numbers", "source": "Translate Haskell to Python: \n\nprimeFactors :: Int -> [Int]\nprimeFactors n = snd $ until ( (== 1) . fst ) step (n , [] )\n where\n  step :: (Int , [Int] ) -> (Int , [Int] )\n  step (n , li) = ( div n h , li ++ [h] )\n   where\n    h :: Int\n    h = head $ tail $ divisors n \n\ndivisors :: Int -> [Int]\ndivisors n = [d | d <- [1 .. n] , mod n d == 0]\n\nisGiuga :: Int -> Bool\nisGiuga n = (divisors n /= [1,n]) && all (\\i -> mod ( div n i - 1 ) i == 0 )\n (primeFactors n)\n\nsolution :: [Int]\nsolution = take 4 $ filter isGiuga [2..]\n", "target": "\n\nfrom math import sqrt\n\ndef isGiuga(m):\n    n = m\n    f = 2\n    l = sqrt(n)\n    while True:\n        if n % f == 0:\n            if ((m / f) - 1) % f != 0:\n                return False\n            n /= f\n            if f > n:\n                return True\n        else:\n            f += 1\n            if f > l:\n                return False\n\n\nif __name__ == '__main__':\n    n = 3\n    c = 0\n    print(\"The first 4 Giuga numbers are: \")\n    while c < 4:\n        if isGiuga(n):\n            c += 1\n            print(n)\n        n += 1\n"}
{"id": 418768, "name": "Permutations with repetitions", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\n\nmain = mapM_ print (replicateM 2 [1,2,3])\n", "target": "\n\nfrom itertools import product\n\n\n\ndef replicateM(n):\n    \n    def rep(m):\n        def go(x):\n            return [[]] if 1 > x else (\n                liftA2List(lambda a, b: [a] + b)(m)(go(x - 1))\n            )\n        return go(n)\n    return lambda m: rep(m)\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(showList)(\n\n            replicateM(2)\n\n        )([[1, 2, 3], 'abc'])\n    )\n\n\n\n\n\ndef liftA2List(f):\n    \n    return lambda xs: lambda ys: [\n        f(*xy) for xy in product(xs, ys)\n    ]\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(\n        showList(x) if isinstance(x, list) else repr(x) for x in xs\n    ) + ']'\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418769, "name": "Permutations with repetitions", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\n\nmain = mapM_ print (replicateM 2 [1,2,3])\n", "target": "\n\nfrom itertools import product\n\n\n\ndef replicateM(n):\n    \n    def rep(m):\n        def go(x):\n            return [[]] if 1 > x else (\n                liftA2List(lambda a, b: [a] + b)(m)(go(x - 1))\n            )\n        return go(n)\n    return lambda m: rep(m)\n\n\n\n\ndef main():\n    \n    print(\n        fTable(main.__doc__ + ':\\n')(repr)(showList)(\n\n            replicateM(2)\n\n        )([[1, 2, 3], 'abc'])\n    )\n\n\n\n\n\ndef liftA2List(f):\n    \n    return lambda xs: lambda ys: [\n        f(*xy) for xy in product(xs, ys)\n    ]\n\n\n\n\n\n\ndef fTable(s):\n    \n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(\n        showList(x) if isinstance(x, list) else repr(x) for x in xs\n    ) + ']'\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418770, "name": "Find largest left truncatable prime in a given base", "source": "Translate Haskell to Python: primesTo100 = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]\n\n\nfind2km :: Integral a => a -> (Int,a)\nfind2km n = f 0 n\n\twhere f k m\n            | r == 1 = (k,m)\n            | otherwise = f (k+1) q\n            where (q,r) = quotRem m 2\n\n\nmillerRabinPrimality :: Integer -> Integer -> Bool\nmillerRabinPrimality n a\n    | a >= n_ = True\n    | b0 == 1 || b0 == n_ = True\n    | otherwise = iter (tail b)\n    where\n        n_ = n-1\n        (k,m) = find2km n_\n        b0 = powMod n a m\n        b = take k $ iterate (squareMod n) b0\n        iter [] = False\n        iter (x:xs)\n            | x == 1 = False\n            | x == n_ = True\n            | otherwise = iter xs\n\n\npow_ :: (Num a, Integral b) => (a->a->a) -> (a->a) -> a -> b -> a\npow_ _ _ _ 0 = 1\npow_ mul sq x_ n_ = f x_ n_ 1\n    where\n        f x n y\n            | n == 1 = x `mul` y\n            | r == 0 = f x2 q y\n            | otherwise = f x2 q (x `mul` y)\n            where\n                (q,r) = quotRem n 2\n                x2 = sq x\n\nmulMod :: Integral a => a -> a -> a -> a\nmulMod a b c = (b * c) `mod` a\nsquareMod :: Integral a => a -> a -> a\nsquareMod a b = (b * b) `rem` a\n\n\npowMod :: Integral a => a -> a -> a -> a\npowMod m = pow_ (mulMod m) (squareMod m)\n\n\n\n\nis_prime w n\n\t| n < 100 = n `elem` primesTo100\n\t| any ((==0).(n`mod`)) primesTo100 = False\n\t| otherwise = all (millerRabinPrimality n) w\n\n\nleft_trunc base = head $ filter (is_prime primesTo100) (reverse hopeful) where\n\thopeful = extend base $ takeWhile (<base) primesTo100 where\n\textend b x = if null d then x else extend (b*base) d where\n\t\td = concatMap addDigit [1..base-1]\n\t\t\n\t\taddDigit a = filter (is_prime [3]) $ map (a*b+) x\n\nmain = mapM_ print $ map (\\x->(x, left_trunc x)) [3..21]\n", "target": "import random\n\ndef is_probable_prime(n,k):\n    \n    if n==0 or n==1:\n        return False\n    if n==2:\n        return True\n    if n % 2 == 0:\n        return False\n    s = 0\n    d = n-1\n\n    while True:\n        quotient, remainder = divmod(d, 2)\n        if remainder == 1:\n            break\n        s += 1\n        d = quotient\n\n    def try_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True \n \n    for i in range(k):\n        a = random.randrange(2, n)\n        if try_composite(a):\n            return False\n \n    return True \n    \n    \ndef largest_left_truncatable_prime(base):    \n    radix = 0\n    candidates = [0]\n    while True:\n        new_candidates=[]\n        multiplier = base**radix\n        for i in range(1,base):\n            new_candidates += [x+i*multiplier for x in candidates if is_probable_prime(x+i*multiplier,30)]\n        if len(new_candidates)==0:\n            return max(candidates)\n        candidates = new_candidates\n        radix += 1\n\nfor b in range(3,24):\n    print(\"%d:%d\\n\" % (b,largest_left_truncatable_prime(b)))\n"}
{"id": 418771, "name": "Speech synthesis", "source": "Translate Haskell to Python: import System.Process (callProcess) \n\nsay text = callProcess \"espeak\" [\"\n\nmain = say \"This is an example of speech synthesis.\"\n", "target": "import pyttsx\n\nengine = pyttsx.init()\nengine.say(\"It was all a dream.\")\nengine.runAndWait()\n"}
{"id": 418772, "name": "Compare sorting algorithms' performance", "source": "Translate Haskell to Python: import Data.Time.Clock\nimport Data.List\n\ntype Time = Integer\ntype Sorter a = [a] -> [a]\n\n\ntimed :: IO a -> IO (a, Time)\ntimed prog = do\n  t0 <- getCurrentTime\n  x <- prog\n  t1 <- x `seq` getCurrentTime\n  return (x, ceiling $ 1000000 * diffUTCTime t1 t0)\n \n\ntest :: [a] -> Sorter a -> IO [(Int, Time)]\ntest set srt = mapM (timed . run) ns\n  where\n    ns = take 15 $ iterate (\\x -> (x * 5) `div` 3) 10\n    run n = pure $ length $ srt (take n set) \n\n\nconstant = repeat 1\n\npresorted = [1..]\n\nrandom = (`mod` 100) <$> iterate step 42\n  where\n    step x = (x * a + c) `mod` m\n    (a, c, m) = (1103515245, 12345, 2^31-1)\n", "target": "def builtinsort(x):\n    x.sort()\n\ndef partition(seq, pivot):\n   low, middle, up = [], [], []\n   for x in seq:\n       if x < pivot:\n           low.append(x)\n       elif x == pivot:\n           middle.append(x)\n       else:\n           up.append(x)\n   return low, middle, up\nimport random\ndef qsortranpart(seq):\n   size = len(seq)\n   if size < 2: return seq\n   low, middle, up = partition(seq, random.choice(seq))\n   return qsortranpart(low) + middle + qsortranpart(up)\n"}
{"id": 418773, "name": "24 game_Solve", "source": "Translate Haskell to Python: import Data.List\nimport Data.Ratio\nimport Control.Monad\nimport System.Environment (getArgs)\n\ndata Expr = Constant Rational |\n    Expr :+ Expr | Expr :- Expr |\n    Expr :* Expr | Expr :/ Expr\n    deriving (Eq)\n\nops = [(:+), (:-), (:*), (:/)]\n\ninstance Show Expr where\n    show (Constant x) = show $ numerator x\n      \n    show (a :+ b)     = strexp \"+\" a b\n    show (a :- b)     = strexp \"-\" a b\n    show (a :* b)     = strexp \"*\" a b\n    show (a :/ b)     = strexp \"/\" a b\n\nstrexp :: String -> Expr -> Expr -> String\nstrexp op a b = \"(\" ++ show a ++ \" \" ++ op ++ \" \" ++ show b ++ \")\"\n\ntemplates :: [[Expr] -> Expr]\ntemplates = do\n    op1 <- ops\n    op2 <- ops\n    op3 <- ops\n    [\\[a, b, c, d] -> op1 a $ op2 b $ op3 c d,\n     \\[a, b, c, d] -> op1 (op2 a b) $ op3 c d,\n     \\[a, b, c, d] -> op1 a $ op2 (op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 a $ op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 (op3 a b) c) d]\n\neval :: Expr -> Maybe Rational\neval (Constant c) = Just c\neval (a :+ b)     = liftM2 (+) (eval a) (eval b)\neval (a :- b)     = liftM2 (-) (eval a) (eval b)\neval (a :* b)     = liftM2 (*) (eval a) (eval b)\neval (a :/ b)     = do\n    denom <- eval b\n    guard $ denom /= 0\n    liftM (/ denom) $ eval a\n\nsolve :: Rational -> [Rational] -> [Expr]\nsolve target r4 = filter (maybe False (== target) . eval) $\n    liftM2 ($) templates $\n    nub $ permutations $ map Constant r4 \n\nmain = getArgs >>= mapM_ print . solve 24 . map (toEnum . read)\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 418774, "name": "24 game_Solve", "source": "Translate Haskell to Python: import Data.List\nimport Data.Ratio\nimport Control.Monad\nimport System.Environment (getArgs)\n\ndata Expr = Constant Rational |\n    Expr :+ Expr | Expr :- Expr |\n    Expr :* Expr | Expr :/ Expr\n    deriving (Eq)\n\nops = [(:+), (:-), (:*), (:/)]\n\ninstance Show Expr where\n    show (Constant x) = show $ numerator x\n      \n    show (a :+ b)     = strexp \"+\" a b\n    show (a :- b)     = strexp \"-\" a b\n    show (a :* b)     = strexp \"*\" a b\n    show (a :/ b)     = strexp \"/\" a b\n\nstrexp :: String -> Expr -> Expr -> String\nstrexp op a b = \"(\" ++ show a ++ \" \" ++ op ++ \" \" ++ show b ++ \")\"\n\ntemplates :: [[Expr] -> Expr]\ntemplates = do\n    op1 <- ops\n    op2 <- ops\n    op3 <- ops\n    [\\[a, b, c, d] -> op1 a $ op2 b $ op3 c d,\n     \\[a, b, c, d] -> op1 (op2 a b) $ op3 c d,\n     \\[a, b, c, d] -> op1 a $ op2 (op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 a $ op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 (op3 a b) c) d]\n\neval :: Expr -> Maybe Rational\neval (Constant c) = Just c\neval (a :+ b)     = liftM2 (+) (eval a) (eval b)\neval (a :- b)     = liftM2 (-) (eval a) (eval b)\neval (a :* b)     = liftM2 (*) (eval a) (eval b)\neval (a :/ b)     = do\n    denom <- eval b\n    guard $ denom /= 0\n    liftM (/ denom) $ eval a\n\nsolve :: Rational -> [Rational] -> [Expr]\nsolve target r4 = filter (maybe False (== target) . eval) $\n    liftM2 ($) templates $\n    nub $ permutations $ map Constant r4 \n\nmain = getArgs >>= mapM_ print . solve 24 . map (toEnum . read)\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 418775, "name": "Hough transform", "source": "Translate Haskell to Python: import Control.Monad (forM_, when)\nimport Data.Array ((!))\nimport Data.Array.ST (newArray, writeArray, readArray, runSTArray)\nimport qualified Data.Foldable as F (maximum)\nimport System.Environment (getArgs, getProgName)\n\n\nimport Codec.Picture\n       (DynamicImage(ImageRGB8, ImageRGBA8), Image, PixelRGB8(PixelRGB8),\n        PixelRGBA8(PixelRGBA8), imageWidth, imageHeight, pixelAt,\n        generateImage, readImage, pixelMap, savePngImage)\nimport Codec.Picture.Types (extractLumaPlane, dropTransparency)\n\ndot\n  :: Num a\n  => (a, a) -> (a, a) -> a\ndot (x1, y1) (x2, y2) = x1 * x2 + y1 * y2\n\nmag\n  :: Floating a\n  => (a, a) -> a\nmag a = sqrt $ dot a a\n\nsub\n  :: Num a\n  => (a, a) -> (a, a) -> (a, a)\nsub (x1, y1) (x2, y2) = (x1 - x2, y1 - y2)\n\nfromIntegralP\n  :: (Integral a, Num b)\n  => (a, a) -> (b, b)\nfromIntegralP (x, y) = (fromIntegral x, fromIntegral y)\n\n\nhough :: Image PixelRGB8 -> Int -> Int -> Image PixelRGB8\nhough image thetaSize distSize = hImage\n  where\n    width = imageWidth image\n    height = imageHeight image\n    wMax = width - 1\n    hMax = height - 1\n    xCenter = wMax `div` 2\n    yCenter = hMax `div` 2\n    lumaMap = extractLumaPlane image\n    gradient x y =\n      let orig = pixelAt lumaMap x y\n          x_ = pixelAt lumaMap (min (x + 1) wMax) y\n          y_ = pixelAt lumaMap x (min (y + 1) hMax)\n      in fromIntegralP (orig - x_, orig - y_)\n    gradMap =\n      [ ((x, y), gradient x y)\n      | x <- [0 .. wMax] \n      , y <- [0 .. hMax] ]\n    \n    distMax :: Double\n    distMax = (sqrt . fromIntegral $ height ^ 2 + width ^ 2) / 2\n    \n    accBin =\n      runSTArray $\n      do arr <- newArray ((0, 0), (thetaSize, distSize)) 0\n         forM_ gradMap $\n           \\((x, y), grad) -> do\n             let (x_, y_) = fromIntegralP $ (xCenter, yCenter) `sub` (x, y)\n             when (mag grad > 127) $\n               forM_ [0 .. thetaSize] $\n               \\theta -> do\n                 let theta_ =\n                       fromIntegral theta * 360 / fromIntegral thetaSize / 180 *\n                       pi :: Double\n                     dist = cos theta_ * x_ + sin theta_ * y_\n                     dist_ = truncate $ dist * fromIntegral distSize / distMax\n                     idx = (theta, dist_)\n                 when (dist_ >= 0 && dist_ < distSize) $\n                   do old <- readArray arr idx\n                      writeArray arr idx $ old + 1\n         return arr\n    maxAcc = F.maximum accBin\n    \n    hTransform x y =\n      let l = 255 - truncate ((accBin ! (x, y)) / maxAcc * 255)\n      in PixelRGB8 l l l\n    hImage = generateImage hTransform thetaSize distSize\n\nhoughIO :: FilePath -> FilePath -> Int -> Int -> IO ()\nhoughIO path outpath thetaSize distSize = do\n  image <- readImage path\n  case image of\n    Left err -> putStrLn err\n    Right (ImageRGB8 image_) -> doImage image_\n    Right (ImageRGBA8 image_) -> doImage $ pixelMap dropTransparency image_\n    _ -> putStrLn \"Expecting RGB8 or RGBA8 image\"\n  where\n    doImage image = do\n      let houghImage = hough image thetaSize distSize\n      savePngImage outpath $ ImageRGB8 houghImage\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  prog <- getProgName\n  case args of\n    [path, outpath, thetaSize, distSize] ->\n      houghIO path outpath (read thetaSize) (read distSize)\n    _ ->\n      putStrLn $\n      \"Usage: \" ++ prog ++ \" <image-file> <out-file.png> <width> <height>\"\n", "target": "from math import hypot, pi, cos, sin\nfrom PIL import Image\n\n\ndef hough(im, ntx=460, mry=360):\n    \"Calculate Hough transform.\"\n    pim = im.load()\n    nimx, mimy = im.size\n    mry = int(mry/2)*2          \n    him = Image.new(\"L\", (ntx, mry), 255)\n    phim = him.load()\n\n    rmax = hypot(nimx, mimy)\n    dr = rmax / (mry/2)\n    dth = pi / ntx\n\n    for jx in xrange(nimx):\n        for iy in xrange(mimy):\n            col = pim[jx, iy]\n            if col == 255: continue\n            for jtx in xrange(ntx):\n                th = dth * jtx\n                r = jx*cos(th) + iy*sin(th)\n                iry = mry/2 + int(r/dr+0.5)\n                phim[jtx, iry] -= 1\n    return him\n\n\ndef test():\n    \"Test Hough transform with pentagon.\"\n    im = Image.open(\"pentagon.png\").convert(\"L\")\n    him = hough(im)\n    him.save(\"ho5.bmp\")\n\n\nif __name__ == \"__main__\": test()\n"}
{"id": 418776, "name": "First class environments", "source": "Translate Haskell to Python: hailstone n\n  | n == 1 = 1\n  | even n = n `div` 2\n  | odd n  = 3*n + 1\n", "target": "environments = [{'cnt':0, 'seq':i+1} for i in range(12)]\n\ncode = \n\nwhile any(env['seq'] > 1 for env in environments):\n    for env in environments:\n        exec(code, globals(), env)\n    print()\n\nprint('Counts')\nfor env in environments:\n    print('% 4d' % env['cnt'], end='')\nprint()\n"}
{"id": 418777, "name": "Tonelli-Shanks algorithm", "source": "Translate Haskell to Python: import Data.List (genericTake, genericLength)\nimport Data.Bits (shiftR)\n\npowMod :: Integer -> Integer -> Integer -> Integer\npowMod m b e = go b e 1\n  where\n    go b e r\n      | e == 0 = r\n      | odd e  = go ((b*b) `mod` m) (e `div` 2) ((r*b) `mod` m)\n      | even e = go ((b*b) `mod` m) (e `div` 2) r \n\nlegendre :: Integer -> Integer -> Integer\nlegendre a p = powMod p a ((p - 1) `div` 2) \n\ntonelli :: Integer -> Integer -> Maybe (Integer, Integer)\ntonelli n p | legendre n p /= 1 = Nothing\ntonelli n p =\n  let s = length $ takeWhile even $ iterate (`div` 2) (p-1)\n      q = shiftR (p-1) s\n  in if s == 1\n    then let r = powMod p n ((p+1) `div` 4)\n         in Just (r, p - r)\n    else let z = (2 +) . genericLength\n               $ takeWhile (\\i -> p - 1 /= legendre i p)\n               $ [2..p-1]\n         in loop s\n            ( powMod p z q )\n            ( powMod p n $ (q+1) `div` 2 )\n            ( powMod p n q )\n  where\n    loop m c r t\n      | (t - 1) `mod` p == 0 = Just (r, p - r)\n      | otherwise =\n        let i = (1 +) . genericLength . genericTake (m - 2)\n              $ takeWhile (\\t2 -> (t2 - 1) `mod` p /= 0)\n              $ iterate (\\t2 -> (t2*t2) `mod` p)\n              $ (t*t) `mod` p\n            b = powMod p c (2^(m - i - 1))\n            r' = (r*b)  `mod` p\n            c' = (b*b)  `mod` p\n            t' = (t*c') `mod` p\n        in loop i c' r' t'\n", "target": "def legendre(a, p):\n    return pow(a, (p - 1) // 2, p)\n\ndef tonelli(n, p):\n    assert legendre(n, p) == 1, \"not a square (mod p)\"\n    q = p - 1\n    s = 0\n    while q % 2 == 0:\n        q //= 2\n        s += 1\n    if s == 1:\n        return pow(n, (p + 1) // 4, p)\n    for z in range(2, p):\n        if p - 1 == legendre(z, p):\n            break\n    c = pow(z, q, p)\n    r = pow(n, (q + 1) // 2, p)\n    t = pow(n, q, p)\n    m = s\n    t2 = 0\n    while (t - 1) % p != 0:\n        t2 = (t * t) % p\n        for i in range(1, m):\n            if (t2 - 1) % p == 0:\n                break\n            t2 = (t2 * t2) % p\n        b = pow(c, 1 << (m - i - 1), p)\n        r = (r * b) % p\n        c = (b * b) % p\n        t = (t * c) % p\n        m = i\n    return r\n\nif __name__ == '__main__':\n    ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049),\n\t     (665820697, 1000000009), (881398088036, 1000000000039),\n             (41660815127637347468140745042827704103445750172002, 10**50 + 577)]\n    for n, p in ttest:\n        r = tonelli(n, p)\n        assert (r * r - n) % p == 0\n        print(\"n = %d p = %d\" % (n, p))\n        print(\"\\t  roots\u00a0: %d %d\" % (r, p - r))\n"}
{"id": 418778, "name": "Tonelli-Shanks algorithm", "source": "Translate Haskell to Python: import Data.List (genericTake, genericLength)\nimport Data.Bits (shiftR)\n\npowMod :: Integer -> Integer -> Integer -> Integer\npowMod m b e = go b e 1\n  where\n    go b e r\n      | e == 0 = r\n      | odd e  = go ((b*b) `mod` m) (e `div` 2) ((r*b) `mod` m)\n      | even e = go ((b*b) `mod` m) (e `div` 2) r \n\nlegendre :: Integer -> Integer -> Integer\nlegendre a p = powMod p a ((p - 1) `div` 2) \n\ntonelli :: Integer -> Integer -> Maybe (Integer, Integer)\ntonelli n p | legendre n p /= 1 = Nothing\ntonelli n p =\n  let s = length $ takeWhile even $ iterate (`div` 2) (p-1)\n      q = shiftR (p-1) s\n  in if s == 1\n    then let r = powMod p n ((p+1) `div` 4)\n         in Just (r, p - r)\n    else let z = (2 +) . genericLength\n               $ takeWhile (\\i -> p - 1 /= legendre i p)\n               $ [2..p-1]\n         in loop s\n            ( powMod p z q )\n            ( powMod p n $ (q+1) `div` 2 )\n            ( powMod p n q )\n  where\n    loop m c r t\n      | (t - 1) `mod` p == 0 = Just (r, p - r)\n      | otherwise =\n        let i = (1 +) . genericLength . genericTake (m - 2)\n              $ takeWhile (\\t2 -> (t2 - 1) `mod` p /= 0)\n              $ iterate (\\t2 -> (t2*t2) `mod` p)\n              $ (t*t) `mod` p\n            b = powMod p c (2^(m - i - 1))\n            r' = (r*b)  `mod` p\n            c' = (b*b)  `mod` p\n            t' = (t*c') `mod` p\n        in loop i c' r' t'\n", "target": "def legendre(a, p):\n    return pow(a, (p - 1) // 2, p)\n\ndef tonelli(n, p):\n    assert legendre(n, p) == 1, \"not a square (mod p)\"\n    q = p - 1\n    s = 0\n    while q % 2 == 0:\n        q //= 2\n        s += 1\n    if s == 1:\n        return pow(n, (p + 1) // 4, p)\n    for z in range(2, p):\n        if p - 1 == legendre(z, p):\n            break\n    c = pow(z, q, p)\n    r = pow(n, (q + 1) // 2, p)\n    t = pow(n, q, p)\n    m = s\n    t2 = 0\n    while (t - 1) % p != 0:\n        t2 = (t * t) % p\n        for i in range(1, m):\n            if (t2 - 1) % p == 0:\n                break\n            t2 = (t2 * t2) % p\n        b = pow(c, 1 << (m - i - 1), p)\n        r = (r * b) % p\n        c = (b * b) % p\n        t = (t * c) % p\n        m = i\n    return r\n\nif __name__ == '__main__':\n    ttest = [(10, 13), (56, 101), (1030, 10009), (44402, 100049),\n\t     (665820697, 1000000009), (881398088036, 1000000000039),\n             (41660815127637347468140745042827704103445750172002, 10**50 + 577)]\n    for n, p in ttest:\n        r = tonelli(n, p)\n        assert (r * r - n) % p == 0\n        print(\"n = %d p = %d\" % (n, p))\n        print(\"\\t  roots\u00a0: %d %d\" % (r, p - r))\n"}
{"id": 418779, "name": "Doubly-linked list_Definition", "source": "Translate Haskell to Python: import qualified Data.Map as M\n\ntype NodeID = Maybe Rational\ndata Node a = Node\n   {vNode :: a,\n    pNode, nNode :: NodeID}\ntype DLList a = M.Map Rational (Node a)\n\nempty = M.empty\n\nsingleton a = M.singleton 0 $ Node a Nothing Nothing\n\nfcons :: a -> DLList a -> DLList a\nfcons a list | M.null list = singleton a\n             | otherwise   = M.insert newid new $\n                             M.insert firstid changed list\n  where (firstid, Node firstval _ secondid) = M.findMin list\n        newid = firstid - 1\n        new     = Node a        Nothing      (Just firstid)\n        changed = Node firstval (Just newid) secondid\n\nrcons :: a -> DLList a -> DLList a\nrcons a list | M.null list = singleton a\n             | otherwise   = M.insert lastid changed $\n                             M.insert newid new list\n  where (lastid, Node lastval penultimateid _) = M.findMax list\n        newid = lastid + 1\n        changed = Node lastval penultimateid (Just newid)\n        new     = Node a       (Just lastid) Nothing\n\nmcons :: a -> Node a -> Node a -> DLList a -> DLList a\nmcons a n1 n2 = M.insert n1id left .\n    M.insert midid mid . M.insert n2id right\n  where Node n1val farleftid   (Just n2id) = n1\n        Node n2val (Just n1id) farrightid  = n2\n        midid = (n1id + n2id) / 2   \n        mid = Node a (Just n1id) (Just n2id)\n        left  = Node n1val farleftid    (Just midid)\n        right = Node n2val (Just midid) farrightid\n\nfirstNode :: DLList a -> Node a\nfirstNode = snd . M.findMin\n\nlastNode :: DLList a -> Node a\nlastNode = snd . M.findMax\n\nnextNode :: DLList a -> Node a -> Maybe (Node a)\nnextNode l n = nNode n >>= flip M.lookup l\n\nprevNode :: DLList a -> Node a -> Maybe (Node a)\nprevNode l n = pNode n >>= flip M.lookup l\n\nfromList = foldr fcons empty\n\ntoList = map vNode . M.elems\n", "target": "from collections import deque\n\nsome_list = deque([\"a\", \"b\", \"c\"])\nprint(some_list)\n\nsome_list.appendleft(\"Z\")\nprint(some_list)\n\nfor value in reversed(some_list):\n    print(value)\n"}
{"id": 418780, "name": "Truth table", "source": "Translate Haskell to Python: import Control.Monad (mapM, foldM, forever)\nimport Data.List (unwords, unlines, nub)\nimport Data.Maybe (fromJust)\n\ntruthTable expr = let\n    tokens = words expr\n    operators = [\"&\", \"|\", \"!\", \"^\", \"=>\"]\n    variables = nub $ filter (not . (`elem` operators)) tokens\n    table = zip variables <$> mapM (const [True,False]) variables\n    results = map (\\r -> (map snd r) ++ (calculate tokens) r) table\n    header = variables ++ [\"result\"]\n    in\n      showTable $ header : map (map show) results\n\n\n\n\ncalculate :: [String] -> [(String, Bool)] -> [Bool]\ncalculate = foldM interprete []\n  where\n    interprete (x:y:s) \"&\"  = (: s) <$> pure (x && y)\n    interprete (x:y:s) \"|\"  = (: s) <$> pure (x || y)\n    interprete (x:y:s) \"^\"  = (: s) <$> pure (x /= y)\n    interprete (x:y:s) \"=>\" = (: s) <$> pure (not y || x)\n    interprete (x:s)   \"!\"  = (: s) <$> pure (not x)\n    interprete s var        = (: s) <$> fromJust . lookup var\n \n\nshowTable tbl = unlines $ map (unwords . map align) tbl\n  where\n    align txt = take colWidth $ txt ++ repeat ' '\n    colWidth = max 6 $ maximum $ map length (head tbl)\n \nmain = forever $ getLine >>= putStrLn . truthTable\n", "target": "from itertools import product\n\nwhile True:\n    bexp = input('\\nBoolean expression: ')\n    bexp = bexp.strip()\n    if not bexp:\n        print(\"\\nThank you\")\n        break\n    code = compile(bexp, '<string>', 'eval')\n    names = code.co_names\n    print('\\n' + ' '.join(names), ':', bexp)\n    for values in product(range(2), repeat=len(names)):\n        env = dict(zip(names, values))\n        print(' '.join(str(v) for v in values), ':', eval(code, env))\n"}
{"id": 418781, "name": "Truth table", "source": "Translate Haskell to Python: import Control.Monad (mapM, foldM, forever)\nimport Data.List (unwords, unlines, nub)\nimport Data.Maybe (fromJust)\n\ntruthTable expr = let\n    tokens = words expr\n    operators = [\"&\", \"|\", \"!\", \"^\", \"=>\"]\n    variables = nub $ filter (not . (`elem` operators)) tokens\n    table = zip variables <$> mapM (const [True,False]) variables\n    results = map (\\r -> (map snd r) ++ (calculate tokens) r) table\n    header = variables ++ [\"result\"]\n    in\n      showTable $ header : map (map show) results\n\n\n\n\ncalculate :: [String] -> [(String, Bool)] -> [Bool]\ncalculate = foldM interprete []\n  where\n    interprete (x:y:s) \"&\"  = (: s) <$> pure (x && y)\n    interprete (x:y:s) \"|\"  = (: s) <$> pure (x || y)\n    interprete (x:y:s) \"^\"  = (: s) <$> pure (x /= y)\n    interprete (x:y:s) \"=>\" = (: s) <$> pure (not y || x)\n    interprete (x:s)   \"!\"  = (: s) <$> pure (not x)\n    interprete s var        = (: s) <$> fromJust . lookup var\n \n\nshowTable tbl = unlines $ map (unwords . map align) tbl\n  where\n    align txt = take colWidth $ txt ++ repeat ' '\n    colWidth = max 6 $ maximum $ map length (head tbl)\n \nmain = forever $ getLine >>= putStrLn . truthTable\n", "target": "from itertools import product\n\nwhile True:\n    bexp = input('\\nBoolean expression: ')\n    bexp = bexp.strip()\n    if not bexp:\n        print(\"\\nThank you\")\n        break\n    code = compile(bexp, '<string>', 'eval')\n    names = code.co_names\n    print('\\n' + ' '.join(names), ':', bexp)\n    for values in product(range(2), repeat=len(names)):\n        env = dict(zip(names, values))\n        print(' '.join(str(v) for v in values), ':', eval(code, env))\n"}
{"id": 418782, "name": "Set of real numbers", "source": "Translate Haskell to Python: \n\nimport Data.List\nimport Data.Maybe\n\ndata BracketType = OpenSub | ClosedSub\n    deriving (Show, Enum, Eq, Ord)\n\ndata RealInterval = RealInterval {left :: BracketType, right :: BracketType, \n    lowerBound :: Double, upperBound :: Double}\n    deriving (Eq)\n\ntype RealSet = [RealInterval]\nposInf = 1.0/0.0 :: Double \nnegInf = (-1.0/0.0) :: Double\nset_R = RealInterval ClosedSub ClosedSub negInf posInf :: RealInterval\n\nemptySet = [] :: [RealInterval]\n\ninstance Show RealInterval where\n    show x@(RealInterval _ _ y y')\n        | y == y' && (left x == right x) && (left x == ClosedSub) = \"{\" ++ (show y) ++ \"}\"\n        | otherwise = [['(', '[']!!(fromEnum $ left x)] ++ (show $ lowerBound x) ++\n         \",\" ++ (show $ upperBound x) ++ [[')', ']']!!(fromEnum $ right x)]\n    showList [x] = shows x\n    showList (h:t) = shows h . (\" U \" ++) . showList t\n    showList [] =  (++ \"(/)\") \n\nconstruct_interval :: Char -> Double -> Double -> Char -> RealInterval\nconstruct_interval '(' x y ')' = RealInterval OpenSub OpenSub x y \nconstruct_interval '(' x y ']' = RealInterval OpenSub ClosedSub x y \nconstruct_interval '[' x y ')' = RealInterval ClosedSub OpenSub x y \nconstruct_interval _ x y _ = RealInterval ClosedSub ClosedSub x y \n\nset_is_empty :: RealSet -> Bool\nset_is_empty rs = (rs == emptySet)\n\nset_in :: Double -> RealSet -> Bool\nset_in x [] = False\nset_in x rs =\n    isJust (find (\\s ->\n        ((lowerBound s < x) && (x < upperBound s)) ||\n        (x == lowerBound s && left s == ClosedSub) ||\n        (x == upperBound s && right s == ClosedSub))\n        rs)\n\n\nmax_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmin_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmax_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, max y y') \n    | x < x'  = p2\n    | otherwise = p1\n\nmin_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, min y y')\n    | x < x'  = p1\n    | otherwise = p2\n\nsimple_intersection :: RealInterval -> RealInterval -> [RealInterval]\nsimple_intersection ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = emptySet\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = emptySet\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = emptySet\n    | otherwise = let lb = if x1 == x2 then (x1, min l_ri1 l_ri2) else max_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = min_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_union :: RealInterval -> RealInterval -> [RealInterval]\nsimple_union ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = [ri2, ri1]\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = [ri1, ri2]\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = [ri1, ri2]\n    | otherwise = let lb = if x1 == x2 then (x1, max l_ri1 l_ri2) else min_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = max_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_complement :: RealInterval -> [RealInterval]\nsimple_complement ri1@(RealInterval l_ri1 r_ri1 x1 y1) =\n    [(RealInterval ClosedSub (inv l_ri1) negInf x1), (RealInterval (inv r_ri1) ClosedSub y1 posInf)]\n    where\n        inv OpenSub = ClosedSub\n        inv ClosedSub = OpenSub\n\nset_sort :: RealSet -> RealSet \nset_sort rs =\n    sortBy\n        (\\s1 s2 ->\n            let (lp, rp) = ((lowerBound s1, left s1), (lowerBound s2, left s2)) in\n                if max_p lp rp == lp then GT else LT)\n        rs\n\nset_simplify :: RealSet -> RealSet\nset_simplify [] = emptySet\nset_simplify rs =\n    concat (map make_empty (set_sort (foldl\n        (\\acc ri1 -> (simple_union (head acc) ri1) ++ (tail acc))\n        [head sorted_rs]\n        sorted_rs)))\n    where\n        sorted_rs = set_sort rs\n        make_empty ri@(RealInterval lb rb x y)\n            | x >= y && (lb /= rb || rb /= ClosedSub) = emptySet\n            | otherwise = [ri]\n\n\nset_complement :: RealSet -> RealSet\nset_union :: RealSet -> RealSet -> RealSet\nset_intersection :: RealSet -> RealSet -> RealSet\nset_difference :: RealSet -> RealSet -> RealSet\nset_measure :: RealSet -> Double\n\nset_complement rs =\n    foldl set_intersection [set_R] (map simple_complement rs)\nset_union rs1 rs2 =\n    set_simplify (rs1 ++ rs2)\nset_intersection rs1 rs2 =\n    set_simplify $ concat [simple_intersection s1 s2 | s1 <- rs1, s2 <- rs2]\nset_difference rs1 rs2 =\n    set_intersection (set_complement rs2) rs1\nset_measure rs =\n    foldl (\\acc x -> acc + (upperBound x) - (lowerBound x)) 0.0 rs\n\n\ntest = map (\\x -> [x]) [construct_interval '(' 0 1 ']', construct_interval '[' 0 2 ')',\n    construct_interval '[' 0 2 ')', construct_interval '(' 1 2 ']',\n    construct_interval '[' 0 3 ')', construct_interval '(' 0 1 ')',\n    construct_interval '[' 0 3 ')', construct_interval '[' 0 1 ']']\nrestest = [set_union (test!!0) (test!!1), set_intersection (test!!2) (test!!3),\n    set_difference (test!!4) (test!!5), set_difference (test!!6) (test!!7)]\nisintest s = \n    mapM_\n        (\\x -> putStrLn ((show x) ++ \" is in \" ++ (show s) ++ \"\u00a0: \" ++ (show (set_in x s))))\n        [0, 1, 2]\n\ntestA = [construct_interval '(' (sqrt (n + (1.0/6))) (sqrt (n + (5.0/6))) ')' | n <- [0..99]]\ntestB = [construct_interval '(' (n + (1.0/6)) (n + (5.0/6)) ')' | n <- [0..9]]\n\nmain =\n    putStrLn (\"union \" ++ (show (test!!0)) ++ \" \" ++ (show (test!!1)) ++ \" = \" ++ (show (restest!!0))) >>\n    putStrLn (\"inter \" ++ (show (test!!2)) ++ \" \" ++ (show (test!!3)) ++ \" = \" ++ (show (restest!!1))) >>\n    putStrLn (\"diff \" ++ (show (test!!4)) ++ \" \" ++ (show (test!!5)) ++ \" = \" ++ (show (restest!!2))) >>\n    putStrLn (\"diff \" ++ (show (test!!6)) ++ \" \" ++ (show (test!!7)) ++ \" = \" ++ (show (restest!!3))) >>\n    mapM_ isintest restest >>\n    putStrLn (\"measure: \" ++ (show (set_measure (set_difference testA testB))))\n", "target": "class Setr():\n    def __init__(self, lo, hi, includelo=True, includehi=False):\n        self.eqn = \"(%i<%sX<%s%i)\" % (lo,\n                                      '=' if includelo else '',\n                                      '=' if includehi else '',\n                                      hi)\n\n    def __contains__(self, X):\n        return eval(self.eqn, locals())\n\n    \n    def __or__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sor%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __and__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __sub__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand not%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    def __repr__(self):\n        return \"Setr%s\" % self.eqn\n\n\nsets = [\n    Setr(0,1, 0,1) | Setr(0,2, 1,0),\n    Setr(0,2, 1,0) & Setr(1,2, 0,1),\n    Setr(0,3, 1,0) - Setr(0,1, 0,0),\n    Setr(0,3, 1,0) - Setr(0,1, 1,1),\n]\nsettexts = '(0, 1] \u222a [0, 2);[0, 2) \u2229 (1, 2];[0, 3) \u2212 (0, 1);[0, 3) \u2212 [0, 1]'.split(';')\n\nfor s,t in zip(sets, settexts):\n    print(\"Set %s %s. %s\" % (t,\n                             ', '.join(\"%scludes %i\"\n                                     % ('in' if v in s else 'ex', v)\n                                     for v in range(3)),\n                             s.eqn))\n"}
{"id": 418783, "name": "Set of real numbers", "source": "Translate Haskell to Python: \n\nimport Data.List\nimport Data.Maybe\n\ndata BracketType = OpenSub | ClosedSub\n    deriving (Show, Enum, Eq, Ord)\n\ndata RealInterval = RealInterval {left :: BracketType, right :: BracketType, \n    lowerBound :: Double, upperBound :: Double}\n    deriving (Eq)\n\ntype RealSet = [RealInterval]\nposInf = 1.0/0.0 :: Double \nnegInf = (-1.0/0.0) :: Double\nset_R = RealInterval ClosedSub ClosedSub negInf posInf :: RealInterval\n\nemptySet = [] :: [RealInterval]\n\ninstance Show RealInterval where\n    show x@(RealInterval _ _ y y')\n        | y == y' && (left x == right x) && (left x == ClosedSub) = \"{\" ++ (show y) ++ \"}\"\n        | otherwise = [['(', '[']!!(fromEnum $ left x)] ++ (show $ lowerBound x) ++\n         \",\" ++ (show $ upperBound x) ++ [[')', ']']!!(fromEnum $ right x)]\n    showList [x] = shows x\n    showList (h:t) = shows h . (\" U \" ++) . showList t\n    showList [] =  (++ \"(/)\") \n\nconstruct_interval :: Char -> Double -> Double -> Char -> RealInterval\nconstruct_interval '(' x y ')' = RealInterval OpenSub OpenSub x y \nconstruct_interval '(' x y ']' = RealInterval OpenSub ClosedSub x y \nconstruct_interval '[' x y ')' = RealInterval ClosedSub OpenSub x y \nconstruct_interval _ x y _ = RealInterval ClosedSub ClosedSub x y \n\nset_is_empty :: RealSet -> Bool\nset_is_empty rs = (rs == emptySet)\n\nset_in :: Double -> RealSet -> Bool\nset_in x [] = False\nset_in x rs =\n    isJust (find (\\s ->\n        ((lowerBound s < x) && (x < upperBound s)) ||\n        (x == lowerBound s && left s == ClosedSub) ||\n        (x == upperBound s && right s == ClosedSub))\n        rs)\n\n\nmax_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmin_p :: (Double, BracketType) -> (Double, BracketType) -> (Double, BracketType)\nmax_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, max y y') \n    | x < x'  = p2\n    | otherwise = p1\n\nmin_p p1@(x, y) p2@(x', y')\n    | x == x' = (x, min y y')\n    | x < x'  = p1\n    | otherwise = p2\n\nsimple_intersection :: RealInterval -> RealInterval -> [RealInterval]\nsimple_intersection ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = emptySet\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = emptySet\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = emptySet\n    | otherwise = let lb = if x1 == x2 then (x1, min l_ri1 l_ri2) else max_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = min_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_union :: RealInterval -> RealInterval -> [RealInterval]\nsimple_union ri1@(RealInterval l_ri1 r_ri1 x1 y1) ri2@(RealInterval l_ri2 r_ri2 x2 y2)\n    | (y1 < x2) || (y2 < x1) = [ri2, ri1]\n    | (y1 == x2) && ((fromEnum r_ri1) + (fromEnum l_ri2) /= 2) = [ri1, ri2]\n    | (y2 == x1) && ((fromEnum r_ri2) + (fromEnum l_ri1) /= 2) = [ri1, ri2]\n    | otherwise = let lb = if x1 == x2 then (x1, max l_ri1 l_ri2) else min_p (x1, l_ri1) (x2, l_ri2) in\n        let rb = max_p (y1, right ri1) (y2, right ri2) in\n            [RealInterval (snd lb) (snd rb) (fst lb) (fst rb)]\n\nsimple_complement :: RealInterval -> [RealInterval]\nsimple_complement ri1@(RealInterval l_ri1 r_ri1 x1 y1) =\n    [(RealInterval ClosedSub (inv l_ri1) negInf x1), (RealInterval (inv r_ri1) ClosedSub y1 posInf)]\n    where\n        inv OpenSub = ClosedSub\n        inv ClosedSub = OpenSub\n\nset_sort :: RealSet -> RealSet \nset_sort rs =\n    sortBy\n        (\\s1 s2 ->\n            let (lp, rp) = ((lowerBound s1, left s1), (lowerBound s2, left s2)) in\n                if max_p lp rp == lp then GT else LT)\n        rs\n\nset_simplify :: RealSet -> RealSet\nset_simplify [] = emptySet\nset_simplify rs =\n    concat (map make_empty (set_sort (foldl\n        (\\acc ri1 -> (simple_union (head acc) ri1) ++ (tail acc))\n        [head sorted_rs]\n        sorted_rs)))\n    where\n        sorted_rs = set_sort rs\n        make_empty ri@(RealInterval lb rb x y)\n            | x >= y && (lb /= rb || rb /= ClosedSub) = emptySet\n            | otherwise = [ri]\n\n\nset_complement :: RealSet -> RealSet\nset_union :: RealSet -> RealSet -> RealSet\nset_intersection :: RealSet -> RealSet -> RealSet\nset_difference :: RealSet -> RealSet -> RealSet\nset_measure :: RealSet -> Double\n\nset_complement rs =\n    foldl set_intersection [set_R] (map simple_complement rs)\nset_union rs1 rs2 =\n    set_simplify (rs1 ++ rs2)\nset_intersection rs1 rs2 =\n    set_simplify $ concat [simple_intersection s1 s2 | s1 <- rs1, s2 <- rs2]\nset_difference rs1 rs2 =\n    set_intersection (set_complement rs2) rs1\nset_measure rs =\n    foldl (\\acc x -> acc + (upperBound x) - (lowerBound x)) 0.0 rs\n\n\ntest = map (\\x -> [x]) [construct_interval '(' 0 1 ']', construct_interval '[' 0 2 ')',\n    construct_interval '[' 0 2 ')', construct_interval '(' 1 2 ']',\n    construct_interval '[' 0 3 ')', construct_interval '(' 0 1 ')',\n    construct_interval '[' 0 3 ')', construct_interval '[' 0 1 ']']\nrestest = [set_union (test!!0) (test!!1), set_intersection (test!!2) (test!!3),\n    set_difference (test!!4) (test!!5), set_difference (test!!6) (test!!7)]\nisintest s = \n    mapM_\n        (\\x -> putStrLn ((show x) ++ \" is in \" ++ (show s) ++ \"\u00a0: \" ++ (show (set_in x s))))\n        [0, 1, 2]\n\ntestA = [construct_interval '(' (sqrt (n + (1.0/6))) (sqrt (n + (5.0/6))) ')' | n <- [0..99]]\ntestB = [construct_interval '(' (n + (1.0/6)) (n + (5.0/6)) ')' | n <- [0..9]]\n\nmain =\n    putStrLn (\"union \" ++ (show (test!!0)) ++ \" \" ++ (show (test!!1)) ++ \" = \" ++ (show (restest!!0))) >>\n    putStrLn (\"inter \" ++ (show (test!!2)) ++ \" \" ++ (show (test!!3)) ++ \" = \" ++ (show (restest!!1))) >>\n    putStrLn (\"diff \" ++ (show (test!!4)) ++ \" \" ++ (show (test!!5)) ++ \" = \" ++ (show (restest!!2))) >>\n    putStrLn (\"diff \" ++ (show (test!!6)) ++ \" \" ++ (show (test!!7)) ++ \" = \" ++ (show (restest!!3))) >>\n    mapM_ isintest restest >>\n    putStrLn (\"measure: \" ++ (show (set_measure (set_difference testA testB))))\n", "target": "class Setr():\n    def __init__(self, lo, hi, includelo=True, includehi=False):\n        self.eqn = \"(%i<%sX<%s%i)\" % (lo,\n                                      '=' if includelo else '',\n                                      '=' if includehi else '',\n                                      hi)\n\n    def __contains__(self, X):\n        return eval(self.eqn, locals())\n\n    \n    def __or__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sor%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __and__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    \n    def __sub__(self, b):\n        ans = Setr(0,0)\n        ans.eqn = \"(%sand not%s)\" % (self.eqn, b.eqn)\n        return ans\n\n    def __repr__(self):\n        return \"Setr%s\" % self.eqn\n\n\nsets = [\n    Setr(0,1, 0,1) | Setr(0,2, 1,0),\n    Setr(0,2, 1,0) & Setr(1,2, 0,1),\n    Setr(0,3, 1,0) - Setr(0,1, 0,0),\n    Setr(0,3, 1,0) - Setr(0,1, 1,1),\n]\nsettexts = '(0, 1] \u222a [0, 2);[0, 2) \u2229 (1, 2];[0, 3) \u2212 (0, 1);[0, 3) \u2212 [0, 1]'.split(';')\n\nfor s,t in zip(sets, settexts):\n    print(\"Set %s %s. %s\" % (t,\n                             ', '.join(\"%scludes %i\"\n                                     % ('in' if v in s else 'ex', v)\n                                     for v in range(3)),\n                             s.eqn))\n"}
{"id": 418784, "name": "State name puzzle", "source": "Translate Haskell to Python: \n\nimport Data.Char (isLetter, toLower)\nimport Data.Function (on)\nimport Data.List (groupBy, nub, sort, sortBy)\n\n\n\npuzzle :: [String] -> [((String, String), (String, String))]\npuzzle states =\n  concatMap\n    ((filter isValid . pairs) . map snd)\n    ( filter ((> 1) . length) $\n        groupBy ((==) `on` fst) $\n          sortBy\n            (compare `on` fst)\n            [ (pkey (a <> b), (a, b))\n              | (a, b) <- pairs (nub $ sort states)\n            ]\n    )\n  where\n    pkey = sort . filter isLetter . map toLower\n    isValid ((a0, a1), (b0, b1)) =\n      (a0 /= b0)\n        && (a0 /= b1)\n        && (a1 /= b0)\n        && (a1 /= b1)\n\npairs :: [a] -> [(a, a)]\npairs [] = []\npairs (y : ys) = map (y,) ys <> pairs ys\n\n\nmain :: IO ()\nmain = do\n  putStrLn $\n    \"Matching pairs generated from \"\n      <> show (length stateNames)\n      <> \" state names and \"\n      <> show (length fakeStateNames)\n      <> \" fake state names:\"\n  mapM_ print $ puzzle $ stateNames <> fakeStateNames\n\nstateNames :: [String]\nstateNames =\n  [ \"Alabama\",\n    \"Alaska\",\n    \"Arizona\",\n    \"Arkansas\",\n    \"California\",\n    \"Colorado\",\n    \"Connecticut\",\n    \"Delaware\",\n    \"Florida\",\n    \"Georgia\",\n    \"Hawaii\",\n    \"Idaho\",\n    \"Illinois\",\n    \"Indiana\",\n    \"Iowa\",\n    \"Kansas\",\n    \"Kentucky\",\n    \"Louisiana\",\n    \"Maine\",\n    \"Maryland\",\n    \"Massachusetts\",\n    \"Michigan\",\n    \"Minnesota\",\n    \"Mississippi\",\n    \"Missouri\",\n    \"Montana\",\n    \"Nebraska\",\n    \"Nevada\",\n    \"New Hampshire\",\n    \"New Jersey\",\n    \"New Mexico\",\n    \"New York\",\n    \"North Carolina\",\n    \"North Dakota\",\n    \"Ohio\",\n    \"Oklahoma\",\n    \"Oregon\",\n    \"Pennsylvania\",\n    \"Rhode Island\",\n    \"South Carolina\",\n    \"South Dakota\",\n    \"Tennessee\",\n    \"Texas\",\n    \"Utah\",\n    \"Vermont\",\n    \"Virginia\",\n    \"Washington\",\n    \"West Virginia\",\n    \"Wisconsin\",\n    \"Wyoming\"\n  ]\n\nfakeStateNames :: [String]\nfakeStateNames =\n  [ \"New Kory\",\n    \"Wen Kory\",\n    \"York New\",\n    \"Kory New\",\n    \"New Kory\"\n  ]\n", "target": "from collections import defaultdict\n\nstates = [\"Alabama\", \"Alaska\", \"Arizona\", \"Arkansas\",\n\"California\", \"Colorado\", \"Connecticut\", \"Delaware\", \"Florida\",\n\"Georgia\", \"Hawaii\", \"Idaho\", \"Illinois\", \"Indiana\", \"Iowa\", \"Kansas\",\n\"Kentucky\", \"Louisiana\", \"Maine\", \"Maryland\", \"Massachusetts\",\n\"Michigan\", \"Minnesota\", \"Mississippi\", \"Missouri\", \"Montana\",\n\"Nebraska\", \"Nevada\", \"New Hampshire\", \"New Jersey\", \"New Mexico\",\n\"New York\", \"North Carolina\", \"North Dakota\", \"Ohio\", \"Oklahoma\",\n\"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\",\n\"South Dakota\", \"Tennessee\", \"Texas\", \"Utah\", \"Vermont\", \"Virginia\",\n\"Washington\", \"West Virginia\", \"Wisconsin\", \"Wyoming\",\n\n\n]\n\nstates = sorted(set(states))\n\nsmap = defaultdict(list)\nfor i, s1 in enumerate(states[:-1]):\n    for s2 in states[i + 1:]:\n        smap[\"\".join(sorted(s1 + s2))].append(s1 + \" + \" + s2)\n\nfor pairs in sorted(smap.itervalues()):\n    if len(pairs) > 1:\n        print \" = \".join(pairs)\n"}
{"id": 418785, "name": "Super-d numbers", "source": "Translate Haskell to Python: import Data.List (isInfixOf)\nimport Data.Char (intToDigit)\n\nisSuperd :: (Show a, Integral a) => a -> a -> Bool\nisSuperd p n =\n  (replicate <*> intToDigit) (fromIntegral p) `isInfixOf` show (p * n ^ p)\n\nfindSuperd :: (Show a, Integral a) => a -> [a]\nfindSuperd p = filter (isSuperd p) [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn .\n     (\"First 10 super-\" ++) .\n     ((++) . show <*> ((\"\u00a0: \" ++) . show . take 10 . findSuperd)))\n    [2 .. 6]\n", "target": "from itertools import islice, count\n\ndef superd(d):\n    if d != int(d) or not 2 <= d <= 9:\n        raise ValueError(\"argument must be integer from 2 to 9 inclusive\")\n    tofind = str(d) * d\n    for n in count(2):\n        if tofind in str(d * n ** d):\n            yield n\n\nif __name__ == '__main__':\n    for d in range(2, 9):\n        print(f\"{d}:\", ', '.join(str(n) for n in islice(superd(d), 10)))\n"}
{"id": 418786, "name": "Super-d numbers", "source": "Translate Haskell to Python: import Data.List (isInfixOf)\nimport Data.Char (intToDigit)\n\nisSuperd :: (Show a, Integral a) => a -> a -> Bool\nisSuperd p n =\n  (replicate <*> intToDigit) (fromIntegral p) `isInfixOf` show (p * n ^ p)\n\nfindSuperd :: (Show a, Integral a) => a -> [a]\nfindSuperd p = filter (isSuperd p) [1 ..]\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn .\n     (\"First 10 super-\" ++) .\n     ((++) . show <*> ((\"\u00a0: \" ++) . show . take 10 . findSuperd)))\n    [2 .. 6]\n", "target": "from itertools import islice, count\n\ndef superd(d):\n    if d != int(d) or not 2 <= d <= 9:\n        raise ValueError(\"argument must be integer from 2 to 9 inclusive\")\n    tofind = str(d) * d\n    for n in count(2):\n        if tofind in str(d * n ** d):\n            yield n\n\nif __name__ == '__main__':\n    for d in range(2, 9):\n        print(f\"{d}:\", ', '.join(str(n) for n in islice(superd(d), 10)))\n"}
{"id": 418787, "name": "Padovan sequence", "source": "Translate Haskell to Python: \npRec = map (\\(a,_,_) -> a) $ iterate (\\(a,b,c) -> (b,c,a+b)) (1,1,1)\n\n\npSelfRef = 1 : 1 : 1 : zipWith (+) pSelfRef (tail pSelfRef)\n\n\npFloor = map f [0..]\n    where f n = floor $ p**fromInteger (pred n) / s + 0.5\n          p   = 1.324717957244746025960908854 \n          s   = 1.0453567932525329623\n          \n\nlSystem = iterate f \"A\"\n    where f []      = []\n          f ('A':s) = 'B':f s\n          f ('B':s) = 'C':f s\n          f ('C':s) = 'A':'B':f s\n\n\ncheckN n as bs = take n as == take n bs\n\nmain = do\n    putStr \"P_0 .. P_19: \"\n    putStrLn $ unwords $ map show $ take 20 pRec\n    \n    putStr \"The floor- and recurrence-based functions \"\n    putStr $ if checkN 64 pRec pFloor then \"match\" else \"do not match\"\n    putStr \" from P_0 to P_63.\\n\"\n\n    putStr \"The self-referential- and recurrence-based functions \"\n    putStr $ if checkN 64 pRec pSelfRef then \"match\" else \"do not match\"\n    putStr \" from P_0 to P_63.\\n\\n\"\n        \n    putStr \"The first 10 L-system strings are:\\n\"\n    putStrLn $ unwords $ take 10 lSystem\n    \n    putStr \"\\nThe floor- and L-system-based functions \"\n    putStr $ if checkN 32 pFloor (map length lSystem) \n             then \"match\" else \"do not match\"\n    putStr \" from P_0 to P_31.\\n\"\n", "target": "from math import floor\nfrom collections import deque\nfrom typing import Dict, Generator\n\n\ndef padovan_r() -> Generator[int, None, None]:\n    last = deque([1, 1, 1], 4)\n    while True:\n        last.append(last[-2] + last[-3])\n        yield last.popleft()\n\n_p, _s = 1.324717957244746025960908854, 1.0453567932525329623\n\ndef padovan_f(n: int) -> int:\n    return floor(_p**(n-1) / _s + .5)\n\ndef padovan_l(start: str='A',\n             rules: Dict[str, str]=dict(A='B', B='C', C='AB')\n             ) -> Generator[str, None, None]:\n    axiom = start\n    while True:\n        yield axiom\n        axiom = ''.join(rules[ch] for ch in axiom)\n\n\nif __name__ == \"__main__\":\n    from itertools import islice\n\n    print(\"The first twenty terms of the sequence.\")\n    print(str([padovan_f(n) for n in range(20)])[1:-1])\n\n    r_generator = padovan_r()\n    if all(next(r_generator) == padovan_f(n) for n in range(64)):\n        print(\"\\nThe recurrence and floor based algorithms match to n=63 .\")\n    else:\n        print(\"\\nThe recurrence and floor based algorithms DIFFER!\")\n\n    print(\"\\nThe first 10 L-system string-lengths and strings\")\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    print('\\n'.join(f\"  {len(string):3} {repr(string)}\"\n                    for string in islice(l_generator, 10)))\n\n    r_generator = padovan_r()\n    l_generator = padovan_l(start='A', rules=dict(A='B', B='C', C='AB'))\n    if all(len(next(l_generator)) == padovan_f(n) == next(r_generator)\n           for n in range(32)):\n        print(\"\\nThe L-system, recurrence and floor based algorithms match to n=31 .\")\n    else:\n        print(\"\\nThe L-system, recurrence and floor based algorithms DIFFER!\")\n"}
{"id": 418788, "name": "Monads_Maybe monad", "source": "Translate Haskell to Python: main = do print $ Just 3 >>= (return . (*2)) >>= (return . (+1))  \n          print $ Nothing >>= (return . (*2)) >>= (return . (+1)) \n", "target": "\nfrom __future__ import annotations\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import Optional\nfrom typing import TypeVar\nfrom typing import Union\n\n\nT = TypeVar(\"T\")\n\n\nclass Maybe(Generic[T]):\n    def __init__(self, value: Union[Optional[T], Maybe[T]] = None):\n        if isinstance(value, Maybe):\n            self.value: Optional[T] = value.value\n        else:\n            self.value = value\n\n    def __rshift__(self, func: Callable[[Optional[T]], Maybe[Any]]):\n        return self.bind(func)\n\n    def bind(self, func: Callable[[Optional[T]], Maybe[Any]]) -> Maybe[Any]:\n        return func(self.value)\n\n    def __str__(self):\n        return f\"{self.__class__.__name__}({self.value!r})\"\n\n\ndef plus_one(value: Optional[int]) -> Maybe[int]:\n    if value is not None:\n        return Maybe[int](value + 1)\n    return Maybe[int](None)\n\n\ndef currency(value: Optional[int]) -> Maybe[str]:\n    if value is not None:\n        return Maybe[str](f\"${value}.00\")\n    return Maybe[str](None)\n\n\nif __name__ == \"__main__\":\n    test_cases = [1, 99, None, 4]\n\n    for case in test_cases:\n        m_int = Maybe[int](case)\n        result = m_int >> plus_one >> currency\n        \n        \n        print(f\"{str(case):<4} -> {result}\")\n"}
{"id": 418789, "name": "Monads_List monad", "source": "Translate Haskell to Python: main = print $ [3,4,5] >>= (return . (+1)) >>= (return . (*2)) \n", "target": "\nfrom __future__ import annotations\nfrom itertools import chain\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Iterable\nfrom typing import List\nfrom typing import TypeVar\n\n\nT = TypeVar(\"T\")\n\n\nclass MList(List[T]):\n    @classmethod\n    def unit(cls, value: Iterable[T]) -> MList[T]:\n        return cls(value)\n\n    def bind(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return MList(chain.from_iterable(map(func, self)))\n\n    def __rshift__(self, func: Callable[[T], MList[Any]]) -> MList[Any]:\n        return self.bind(func)\n\n\nif __name__ == \"__main__\":\n    \n    print(\n        MList([1, 99, 4])\n        .bind(lambda val: MList([val + 1]))\n        .bind(lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList([1, 99, 4])\n        >> (lambda val: MList([val + 1]))\n        >> (lambda val: MList([f\"${val}.00\"]))\n    )\n\n    \n    print(\n        MList(range(1, 6)).bind(\n            lambda x: MList(range(6, 11)).bind(lambda y: MList([(x, y)]))\n        )\n    )\n\n    \n    print(\n        MList(range(1, 26)).bind(\n            lambda x: MList(range(x + 1, 26)).bind(\n                lambda y: MList(range(y + 1, 26)).bind(\n                    lambda z: MList([(x, y, z)])\n                    if x * x + y * y == z * z\n                    else MList([])\n                )\n            )\n        )\n    )\n"}
{"id": 418790, "name": "Textonyms", "source": "Translate Haskell to Python: import Data.Char (toUpper)\nimport Data.Function (on)\nimport Data.List (groupBy, sortBy)\nimport Data.Maybe (fromMaybe, isJust, isNothing)\n\ntoKey :: Char -> Maybe Char\ntoKey ch\n  | ch < 'A' = Nothing\n  | ch < 'D' = Just '2'\n  | ch < 'G' = Just '3'\n  | ch < 'J' = Just '4'\n  | ch < 'M' = Just '5'\n  | ch < 'P' = Just '6'\n  | ch < 'T' = Just '7'\n  | ch < 'W' = Just '8'\n  | ch <= 'Z' = Just '9'\n  | otherwise = Nothing\n\ntoKeyString :: String -> Maybe String\ntoKeyString st\n  | any isNothing mch = Nothing\n  | otherwise = Just $ map (fromMaybe '!') mch\n  where\n    mch = map (toKey . toUpper) st\n\nshowTextonym :: [(String, String)] -> String\nshowTextonym ts =\n  fst (head ts)\n    ++ \" => \"\n    ++ concat\n      [ w ++ \" \"\n        | (_, w) <- ts\n      ]\n\nmain :: IO ()\nmain = do\n  let src = \"unixdict.txt\"\n  contents <- readFile src\n  let wordList = lines contents\n      keyedList =\n        [ (key, word)\n          | (Just key, word) <-\n              filter (isJust . fst) $\n                zip (map toKeyString wordList) wordList\n        ]\n      groupedList =\n        groupBy ((==) `on` fst) $\n          sortBy (compare `on` fst) keyedList\n      textonymList = filter ((> 1) . length) groupedList\n  mapM_ putStrLn $\n    [ \"There are \"\n        ++ show (length keyedList)\n        ++ \" words in \"\n        ++ src\n        ++ \" which can be represented by the digit key mapping.\",\n      \"They require \"\n        ++ show (length groupedList)\n        ++ \" digit combinations to represent them.\",\n      show (length textonymList) ++ \" digit combinations represent Textonyms.\",\n      \"\",\n      \"Top 5 in ambiguity:\"\n    ]\n      ++ fmap\n        showTextonym\n        ( take 5 $\n            sortBy (flip compare `on` length) textonymList\n        )\n      ++ [\"\", \"Top 5 in length:\"]\n      ++ fmap\n        showTextonym\n        (take 5 $ sortBy (flip compare `on` (length . fst . head)) textonymList)\n", "target": "from collections import defaultdict\nimport urllib.request\n\nCH2NUM = {ch: str(num) for num, chars in enumerate('abc def ghi jkl mno pqrs tuv wxyz'.split(), 2) for ch in chars}\nURL = 'http://www.puzzlers.org/pub/wordlists/unixdict.txt'\n\n\ndef getwords(url):\n return urllib.request.urlopen(url).read().decode(\"utf-8\").lower().split()\n\ndef mapnum2words(words):\n    number2words = defaultdict(list)\n    reject = 0\n    for word in words:\n        try:\n            number2words[''.join(CH2NUM[ch] for ch in word)].append(word)\n        except KeyError:\n            \n            reject += 1\n    return dict(number2words), reject\n\ndef interactiveconversions():\n    global inp, ch, num\n    while True:\n        inp = input(\"\\nType a number or a word to get the translation and textonyms: \").strip().lower()\n        if inp:\n            if all(ch in '23456789' for ch in inp):\n                if inp in num2words:\n                    print(\"  Number {0} has the following textonyms in the dictionary: {1}\".format(inp, ', '.join(\n                        num2words[inp])))\n                else:\n                    print(\"  Number {0} has no textonyms in the dictionary.\".format(inp))\n            elif all(ch in CH2NUM for ch in inp):\n                num = ''.join(CH2NUM[ch] for ch in inp)\n                print(\"  Word {0} is{1} in the dictionary and is number {2} with textonyms: {3}\".format(\n                    inp, ('' if inp in wordset else \"n't\"), num, ', '.join(num2words[num])))\n            else:\n                print(\"  I don't understand %r\" % inp)\n        else:\n            print(\"Thank you\")\n            break\n\n\nif __name__ == '__main__':\n    words = getwords(URL)\n    print(\"Read %i words from %r\" % (len(words), URL))\n    wordset = set(words)\n    num2words, reject = mapnum2words(words)\n    morethan1word = sum(1 for w in num2words if len(num2words[w]) > 1)\n    maxwordpernum = max(len(values) for values in num2words.values())\n    print(.format(len(words) - reject, URL, len(num2words), morethan1word))\n\n    print(\"\\nThe numbers mapping to the most words map to %i words each:\" % maxwordpernum)\n    maxwpn = sorted((key, val) for key, val in num2words.items() if len(val) == maxwordpernum)\n    for num, wrds in maxwpn:\n        print(\"  %s maps to: %s\" % (num, ', '.join(wrds)))\n\n    interactiveconversions()\n"}
{"id": 418791, "name": "Minesweeper game", "source": "Translate Haskell to Python: \n\nmodule MineSweeper\n  ( Board\n  , Cell(..)\n  , CellState(..)\n  , Pos\n    \n  , pos\n  , coveredLens\n  , coveredFlaggedLens\n  , coveredMinedLens\n  , xCoordLens\n  , yCoordLens\n    \n  , emptyBoard\n  , groupedByRows\n  , displayCell\n  , isLoss\n  , isWin\n  , exposeMines\n  , openCell\n  , flagCell\n  , mineBoard\n  , totalRows\n  , totalCols )\nwhere\n\nimport Control.Lens  ((%~), (&), (.~), (^.), (^?), Lens', Traversal', _1, _2,\n                      anyOf, filtered, folded, lengthOf, makeLenses, makePrisms,\n                      preview, to, view)\nimport Data.List     (find, groupBy, nub, delete, sortBy)\nimport Data.Maybe    (isJust)\nimport System.Random (getStdGen, getStdRandom, randomR, randomRs)\n\ntype Pos = (Int, Int)\ntype Board = [Cell]\n\ndata CellState = Covered   { _mined :: Bool, _flagged :: Bool }\n               | UnCovered { _mined :: Bool }\n               deriving (Show, Eq)\n\ndata Cell = Cell\n          { _pos :: Pos\n          , _state :: CellState\n          , _cellId :: Int\n          , _adjacentMines :: Int }\n          deriving (Show, Eq)\n\nmakePrisms ''CellState\nmakeLenses ''CellState\nmakeLenses ''Cell\n\n\ncoveredLens :: Traversal' Cell (Bool, Bool) \ncoveredLens = state . _Covered\n\ncoveredMinedLens, coveredFlaggedLens, unCoveredLens :: Traversal' Cell Bool \ncoveredMinedLens = coveredLens . _1\ncoveredFlaggedLens = coveredLens . _2\nunCoveredLens = state . _UnCovered\n\nxCoordLens, yCoordLens :: Lens' Cell Int \nxCoordLens = pos . _1\nyCoordLens = pos . _2\n\n\ntotalRows, totalCols :: Int\ntotalRows = 4\ntotalCols = 6\n\nemptyBoard :: Board\nemptyBoard = (\\(n, p) -> Cell { _pos = p\n                              , _state = Covered False False\n                              , _adjacentMines = 0\n                              , _cellId = n }) <$> zip [1..] positions\n  where\n    positions = (,) <$> [1..totalCols] <*> [1..totalRows]\n\nupdateCell :: Cell -> Board -> Board\nupdateCell cell = fmap (\\c -> if cell ^. cellId == c ^. cellId then cell else c)\n\nupdateBoard :: Board -> [Cell] -> Board\nupdateBoard = foldr updateCell\n\nokToOpen :: [Cell] -> [Cell]\nokToOpen = filter (\\c -> c ^? coveredLens == Just (False, False))\n\nopenUnMined :: Cell -> Cell\nopenUnMined = state .~ UnCovered False\n\nopenCell :: Pos -> Board -> Board\nopenCell p b = f $ find (\\c -> c ^. pos == p) b\n where\n  f (Just c)\n    | c ^? coveredFlaggedLens == Just True = b\n    | c ^? coveredMinedLens == Just True = updateCell\n      (c & state .~ UnCovered True)\n      b\n    | isCovered c = if c ^. adjacentMines == 0 && not (isFirstMove b)\n      then updateCell (openUnMined c) $ expandEmptyCells b c\n      else updateCell (openUnMined c) b\n    | otherwise = b\n  f Nothing = b\n  isCovered = isJust . preview coveredLens\n\nexpandEmptyCells :: Board -> Cell -> Board\nexpandEmptyCells board cell\n  | null openedCells = board\n  | otherwise = foldr (flip expandEmptyCells) updatedBoard (zeroAdjacent openedCells)\n where\n  findMore _ [] = []\n  findMore exclude (c : xs)\n    | c `elem` exclude        = findMore exclude xs\n    | c ^. adjacentMines == 0 = c : adjacent c <>\n      findMore (c : exclude <> adjacent c) xs\n    | otherwise               = c : findMore (c : exclude) xs\n  adjacent     = okToOpen . flip adjacentCells board\n  openedCells  = openUnMined <$> nub (findMore [cell] (adjacent cell))\n  zeroAdjacent = filter (view (adjacentMines . to (== 0)))\n  updatedBoard = updateBoard board openedCells\n\nflagCell :: Pos -> Board -> Board\nflagCell p board = case find ((== p) . view pos) board of\n  Just c  -> updateCell (c & state . flagged %~ not) board\n  Nothing -> board\n\nadjacentCells :: Cell -> Board -> [Cell]\nadjacentCells Cell {_pos = c@(x1, y1)} = filter (\\c -> c ^. pos `elem` positions)\n  where\n    f n = [pred n, n, succ n]\n    positions = delete c $ [(x, y) | x <- f x1, x > 0, y <- f y1, y > 0]\n\nisLoss, isWin, allUnMinedOpen, allMinesFlagged, isFirstMove :: Board -> Bool\nisLoss = anyOf (traverse . unCoveredLens) (== True)\nisWin b = allUnMinedOpen b || allMinesFlagged b\n\nallUnMinedOpen = (== 0) . lengthOf (traverse . coveredMinedLens . filtered (== False))\nallMinesFlagged b = minedCount b == flaggedMineCount b\n where\n  minedCount = lengthOf (traverse . coveredMinedLens . filtered (== True))\n  flaggedMineCount = lengthOf (traverse . coveredLens . filtered (== (True, True)))\n\nisFirstMove = (== totalCols * totalRows) . lengthOf (folded . coveredFlaggedLens . filtered (== False))\n\ngroupedByRows :: Board -> [Board]\ngroupedByRows = groupBy (\\c1 c2 -> yAxis c1 == yAxis c2)\n              . sortBy (\\c1 c2 -> yAxis c1 `compare` yAxis c2)\n  where\n    yAxis = view yCoordLens\n\ndisplayCell :: Cell -> String\ndisplayCell c\n  | c ^? unCoveredLens            == Just True = \"X\"\n  | c ^? coveredFlaggedLens       == Just True = \"?\"\n  | c ^? (unCoveredLens . to not) == Just True =\n    if c ^. adjacentMines > 0 then show $ c ^. adjacentMines else \"\u25a2\"\n  | otherwise = \".\"\n\nexposeMines :: Board -> Board\nexposeMines = fmap (\\c -> c & state . filtered (\\s -> s ^? _Covered . _1 == Just True) .~ UnCovered True)\n\nupdateMineCount :: Board -> Board\nupdateMineCount b = go b\n where\n  go []       = []\n  go (x : xs) = (x & adjacentMines .~ totalAdjacentMines b) : go xs\n   where\n    totalAdjacentMines =\n      foldr (\\c acc -> if c ^. (state . mined) then succ acc else acc) 0 . adjacentCells x\n\n\nmineBoard :: Pos -> Board -> IO Board\nmineBoard p board = do\n  totalMines <- randomMinedCount\n  minedBoard totalMines >>= \\mb -> pure $ updateMineCount mb\n where\n  mines n = take n <$> randomCellIds\n  minedBoard n = (\\m -> \n    fmap (\\c -> if c ^. cellId `elem` m then c & state . mined .~ True else c)\n        board) . filter (\\c -> openedCell ^. cellId /= c)\n      <$> mines n\n  openedCell = head $ filter (\\c -> c ^. pos == p) board\n\nrandomCellIds :: IO [Int]\nrandomCellIds = randomRs (1, totalCols * totalRows) <$> getStdGen\n\nrandomMinedCount :: IO Int\nrandomMinedCount = getStdRandom $ randomR (minMinedCells, maxMinedCells)\n where\n  maxMinedCells = floor $ realToFrac (totalCols * totalRows) * 0.2\n  minMinedCells = floor $ realToFrac (totalCols * totalRows) * 0.1\n", "target": "\n\n\ngridsize  = (6, 4)\nminerange = (0.2, 0.6)\n\n\ntry:\n    raw_input\nexcept:\n    raw_input = input\n    \nimport random\nfrom itertools import product\nfrom pprint import pprint as pp\n\n\ndef gridandmines(gridsize=gridsize, minerange=minerange):\n    xgrid, ygrid = gridsize\n    minmines, maxmines = minerange\n    minecount = xgrid * ygrid    \n    minecount = random.randint(int(minecount*minmines), int(minecount*maxmines))\n    grid = set(product(range(xgrid), range(ygrid)))\n    mines = set(random.sample(grid, minecount))\n    show = {xy:'.' for xy in grid}\n    return grid, mines, show\n\ndef printgrid(show, gridsize=gridsize):\n    xgrid, ygrid = gridsize\n    grid = '\\n'.join(''.join(show[(x,y)] for x in range(xgrid))\n                     for y in range(ygrid))\n    print( grid )\n\ndef resign(showgrid, mines, markedmines):\n    for m in mines:\n        showgrid[m] = 'Y' if m in markedmines else 'N'\n\ndef clear(x,y, showgrid, grid, mines, markedmines):\n    if showgrid[(x, y)] == '.':\n        xychar = str(sum(1\n                         for xx in (x-1, x, x+1)\n                         for yy in (y-1, y, y+1)\n                         if (xx, yy) in mines ))\n        if xychar == '0': xychar = '.'\n        showgrid[(x,y)] = xychar\n        for xx in (x-1, x, x+1):\n            for yy in (y-1, y, y+1):\n                xxyy = (xx, yy)\n                if ( xxyy != (x, y)\n                     and xxyy in grid\n                     and xxyy not in mines | markedmines ):\n                    clear(xx, yy, showgrid, grid, mines, markedmines)\n\nif __name__ == '__main__':\n    grid, mines, showgrid = gridandmines()\n    markedmines = set([])\n    print( __doc__ )\n    print( '\\nThere are %i true mines of fixed position in the grid\\n' % len(mines) )\n    printgrid(showgrid)\n    while markedmines != mines:\n        inp = raw_input('m x y/c x y/p/r: ').strip().split()\n        if inp:\n            if inp[0] == 'm':\n                x, y = [int(i)-1 for i in inp[1:3]]\n                if (x,y) in markedmines:\n                    markedmines.remove((x,y))\n                    showgrid[(x,y)] = '.'\n                else:\n                    markedmines.add((x,y))\n                    showgrid[(x,y)] = '?'\n            elif inp[0] == 'p':\n                printgrid(showgrid)\n            elif inp[0] == 'c':\n                x, y = [int(i)-1 for i in inp[1:3]]\n                if (x,y) in mines | markedmines:\n                    print( '\\nKLABOOM!! You hit a mine.\\n' )\n                    resign(showgrid, mines, markedmines)\n                    printgrid(showgrid)\n                    break\n                clear(x,y, showgrid, grid, mines, markedmines)\n                printgrid(showgrid)\n            elif inp[0] == 'r':\n                print( '\\nResigning!\\n' )\n                resign(showgrid, mines, markedmines)\n                printgrid(showgrid)\n                break\n    \n    print( '\\nYou got %i and missed %i of the %i mines'\n           % (len(mines.intersection(markedmines)),\n              len(markedmines.difference(mines)),\n              len(mines)) )\n"}
{"id": 418792, "name": "Church numerals", "source": "Translate Haskell to Python: import Unsafe.Coerce ( unsafeCoerce )\n\ntype Church a = (a -> a) -> a -> a\n\nchurchZero :: Church  a\nchurchZero = const id\n\nchurchOne :: Church a\nchurchOne = id\n\nsuccChurch :: Church a -> Church a\nsuccChurch = (<*>) (.) \n\naddChurch :: Church a -> Church a -> Church a\naddChurch = (<*>). fmap (.) \n\nmultChurch :: Church a -> Church a -> Church a\nmultChurch = (.) \n\nexpChurch :: Church a -> Church a -> Church a\nexpChurch basech expch = unsafeCoerce expch basech\n\nisChurchZero :: Church a -> Church a\nisChurchZero ch = unsafeCoerce ch (const churchZero) churchOne\n\npredChurch :: Church a -> Church a\npredChurch ch f x = unsafeCoerce ch (\\ g h -> h (g f)) (const x) id\n\nminusChurch :: Church a -> Church a -> Church a\nminusChurch ach bch = unsafeCoerce bch predChurch ach\n\n\ndivChurch :: Church a -> Church a -> Church a\ndivChurch dvdnd dvsr =\n  let divr n d =\n        (\\ v -> v (const $ succChurch $ divr v d) \n                  churchZero \n        ) (minusChurch n d)\n  in divr (unsafeCoerce succChurch dvdnd) $ unsafeCoerce dvsr\n\nchurchFromInt :: Int -> Church a\nchurchFromInt 0 = churchZero\nchurchFromInt n = succChurch $ churchFromInt (n - 1)\n\n\n\n\n\n\n\nintFromChurch :: Church Int -> Int\nintFromChurch ch = ch succ 0\n\n\nmain :: IO ()\nmain = do\n  let [cThree, cFour, cEleven, cTwelve] = churchFromInt <$> [3, 4, 11, 12]\n  print $ fmap intFromChurch  [ addChurch cThree cFour\n                              , multChurch cThree cFour\n                              , expChurch cFour cThree\n                              , expChurch cThree cFour\n                              , isChurchZero churchZero\n                              , predChurch cFour\n                              , minusChurch cEleven cThree\n                              , divChurch cEleven cThree\n                              , divChurch cTwelve cThree\n                              ]\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418793, "name": "Church numerals", "source": "Translate Haskell to Python: import Unsafe.Coerce ( unsafeCoerce )\n\ntype Church a = (a -> a) -> a -> a\n\nchurchZero :: Church  a\nchurchZero = const id\n\nchurchOne :: Church a\nchurchOne = id\n\nsuccChurch :: Church a -> Church a\nsuccChurch = (<*>) (.) \n\naddChurch :: Church a -> Church a -> Church a\naddChurch = (<*>). fmap (.) \n\nmultChurch :: Church a -> Church a -> Church a\nmultChurch = (.) \n\nexpChurch :: Church a -> Church a -> Church a\nexpChurch basech expch = unsafeCoerce expch basech\n\nisChurchZero :: Church a -> Church a\nisChurchZero ch = unsafeCoerce ch (const churchZero) churchOne\n\npredChurch :: Church a -> Church a\npredChurch ch f x = unsafeCoerce ch (\\ g h -> h (g f)) (const x) id\n\nminusChurch :: Church a -> Church a -> Church a\nminusChurch ach bch = unsafeCoerce bch predChurch ach\n\n\ndivChurch :: Church a -> Church a -> Church a\ndivChurch dvdnd dvsr =\n  let divr n d =\n        (\\ v -> v (const $ succChurch $ divr v d) \n                  churchZero \n        ) (minusChurch n d)\n  in divr (unsafeCoerce succChurch dvdnd) $ unsafeCoerce dvsr\n\nchurchFromInt :: Int -> Church a\nchurchFromInt 0 = churchZero\nchurchFromInt n = succChurch $ churchFromInt (n - 1)\n\n\n\n\n\n\n\nintFromChurch :: Church Int -> Int\nintFromChurch ch = ch succ 0\n\n\nmain :: IO ()\nmain = do\n  let [cThree, cFour, cEleven, cTwelve] = churchFromInt <$> [3, 4, 11, 12]\n  print $ fmap intFromChurch  [ addChurch cThree cFour\n                              , multChurch cThree cFour\n                              , expChurch cFour cThree\n                              , expChurch cThree cFour\n                              , isChurchZero churchZero\n                              , predChurch cFour\n                              , minusChurch cEleven cThree\n                              , divChurch cEleven cThree\n                              , divChurch cTwelve cThree\n                              ]\n", "target": "\n\nfrom itertools import repeat\nfrom functools import reduce\n\n\n\n\ndef churchZero():\n    \n    return lambda f: identity\n\n\ndef churchSucc(cn):\n    \n    return lambda f: compose(f)(cn(f))\n\n\ndef churchAdd(m):\n    \n    return lambda n: lambda f: compose(m(f))(n(f))\n\n\ndef churchMult(m):\n    \n    return lambda n: compose(m)(n)\n\n\ndef churchExp(m):\n    \n    return lambda n: n(m)\n\n\ndef churchFromInt(n):\n    \n    return lambda f: (\n        foldl\n        (compose)\n        (identity)\n        (replicate(n)(f))\n    )\n\n\n\ndef churchFromInt_(n):\n    \n    if 0 == n:\n        return churchZero()\n    else:\n        return churchSucc(churchFromInt(n - 1))\n\n\ndef intFromChurch(cn):\n    \n    return cn(succ)(0)\n\n\n\n\ndef main():\n    'Tests'\n\n    cThree = churchFromInt(3)\n    cFour = churchFromInt(4)\n\n    print(list(map(intFromChurch, [\n        churchAdd(cThree)(cFour),\n        churchMult(cThree)(cFour),\n        churchExp(cFour)(cThree),\n        churchExp(cThree)(cFour),\n    ])))\n\n\n\n\n\ndef compose(f):\n    \n    return lambda g: lambda x: g(f(x))\n\n\n\ndef foldl(f):\n    \n    def go(acc, xs):\n        return reduce(lambda a, x: f(a)(x), xs, acc)\n    return lambda acc: lambda xs: go(acc, xs)\n\n\n\ndef identity(x):\n    \n    return x\n\n\n\ndef replicate(n):\n    \n    return lambda x: repeat(x, n)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418794, "name": "Topic variable", "source": "Translate Haskell to Python: Prelude> [1..10]\n[1,2,3,4,5,6,7,8,9,10]\nPrelude> map (^2) it\n[1,4,9,16,25,36,49,64,81,100]\n", "target": ">>> 3\n3\n>>> _*_, _**0.5\n(9, 1.7320508075688772)\n>>>\n"}
{"id": 418795, "name": "Topic variable", "source": "Translate Haskell to Python: Prelude> [1..10]\n[1,2,3,4,5,6,7,8,9,10]\nPrelude> map (^2) it\n[1,4,9,16,25,36,49,64,81,100]\n", "target": ">>> 3\n3\n>>> _*_, _**0.5\n(9, 1.7320508075688772)\n>>>\n"}
{"id": 418796, "name": "Bitcoin_public point to address", "source": "Translate Haskell to Python: import Numeric (showIntAtBase)\nimport Data.List (unfoldr)\nimport Data.Binary (Word8)\nimport Crypto.Hash.SHA256 as S (hash)\nimport Crypto.Hash.RIPEMD160 as R (hash)\nimport Data.ByteString (unpack, pack)\n\npublicPointToAddress :: Integer -> Integer -> String\npublicPointToAddress x y = \n  let toBytes x = reverse $ unfoldr (\\b -> if b == 0 then Nothing else Just (fromIntegral $ b `mod` 256, b `div` 256)) x\n      ripe = 0 : unpack (R.hash $ S.hash $ pack $ 4 : toBytes x ++ toBytes y)\n      ripe_checksum = take 4 $ unpack $ S.hash $ S.hash $ pack ripe\n      addressAsList = ripe ++ ripe_checksum\n      address = foldl (\\v b -> v * 256 + fromIntegral b) 0 addressAsList\n      base58Digits = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  in showIntAtBase 58 (base58Digits !!) address \"\"\n\nmain = print $ publicPointToAddress \n  0x50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352\n  0x2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6\n", "target": "\n\nimport binascii\nimport functools\nimport hashlib\n\ndigits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef b58(n):\n    return b58(n//58) + digits58[n%58:n%58+1] if n else b''\n\ndef public_point_to_address(x, y):\n    c = b'\\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)\n    r = hashlib.new('ripemd160')\n    r.update(hashlib.sha256(c).digest())\n    c = b'\\x00' + r.digest()\n    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()\n    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))\n\nif __name__ == '__main__':\n    print(public_point_to_address(\n        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))\n"}
{"id": 418797, "name": "Bitcoin_public point to address", "source": "Translate Haskell to Python: import Numeric (showIntAtBase)\nimport Data.List (unfoldr)\nimport Data.Binary (Word8)\nimport Crypto.Hash.SHA256 as S (hash)\nimport Crypto.Hash.RIPEMD160 as R (hash)\nimport Data.ByteString (unpack, pack)\n\npublicPointToAddress :: Integer -> Integer -> String\npublicPointToAddress x y = \n  let toBytes x = reverse $ unfoldr (\\b -> if b == 0 then Nothing else Just (fromIntegral $ b `mod` 256, b `div` 256)) x\n      ripe = 0 : unpack (R.hash $ S.hash $ pack $ 4 : toBytes x ++ toBytes y)\n      ripe_checksum = take 4 $ unpack $ S.hash $ S.hash $ pack ripe\n      addressAsList = ripe ++ ripe_checksum\n      address = foldl (\\v b -> v * 256 + fromIntegral b) 0 addressAsList\n      base58Digits = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n  in showIntAtBase 58 (base58Digits !!) address \"\"\n\nmain = print $ publicPointToAddress \n  0x50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352\n  0x2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6\n", "target": "\n\nimport binascii\nimport functools\nimport hashlib\n\ndigits58 = b'123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\ndef b58(n):\n    return b58(n//58) + digits58[n%58:n%58+1] if n else b''\n\ndef public_point_to_address(x, y):\n    c = b'\\x04' + binascii.unhexlify(x) + binascii.unhexlify(y)\n    r = hashlib.new('ripemd160')\n    r.update(hashlib.sha256(c).digest())\n    c = b'\\x00' + r.digest()\n    d = hashlib.sha256(hashlib.sha256(c).digest()).digest()\n    return b58(functools.reduce(lambda n, b: n<<8|b, c + d[:4]))\n\nif __name__ == '__main__':\n    print(public_point_to_address(\n        b'50863AD64A87AE8A2FE83C1AF1A8403CB53F53E486D8511DAD8A04887E5B2352',\n        b'2CD470243453A299FA9E77237716103ABC11A1DF38855ED6F2EE187E9C582BA6'))\n"}
{"id": 418798, "name": "Canonicalize CIDR", "source": "Translate Haskell to Python: import Control.Monad (guard)\nimport Data.Bits ((.|.), (.&.), complement, shiftL, shiftR, zeroBits)\nimport Data.Maybe (listToMaybe)\nimport Data.Word (Word32, Word8)\nimport Text.ParserCombinators.ReadP (ReadP, char, readP_to_S)\nimport Text.Printf (printf)\nimport Text.Read.Lex (readDecP)\n\n\n\ndata CIDR = CIDR Word32 Word8\n\n\ncidrRead :: String -> Maybe CIDR\ncidrRead = listToMaybe . map fst . readP_to_S cidrP\n\n\ncidrShow :: CIDR -> String\ncidrShow (CIDR addr n) = let (a, b, c, d) = octetsFrom addr\n                         in printf \"%u.%u.%u.%u/%u\" a b c d n\n\n\n\n\ncidrP :: ReadP CIDR\ncidrP = do a <- octetP <* char '.'\n           b <- octetP <* char '.'\n           c <- octetP <* char '.'\n           d <- octetP <* char '/'\n           n <- netBitsP\n           return $ CIDR (addrFrom a b c d .&. netmask n) n\n  where octetP   = wordP 255\n        netBitsP = wordP  32\n\n\n\n\n\nwordP :: Integral a => Integer -> ReadP a\nwordP lim = do n <- readDecP\n               guard $ n <= lim\n               return $ fi n\n\n\noctetsFrom :: Word32 -> (Word8, Word8, Word8, Word8)\noctetsFrom addr = (oct addr 3, oct addr 2, oct addr 1, oct addr 0)\n  where oct w n = fi $ w `shiftR` (8*n) .&. 0xff\n\n\naddrFrom :: Word8 -> Word8 -> Word8 -> Word8 -> Word32\naddrFrom a b c d = 0 <<+ a <<+ b <<+ c <<+ d\n  where w <<+ o = w `shiftL` 8 .|. fi o\n\n\n\nnetmask :: Word8 -> Word32\nnetmask n = complement $ complement zeroBits `shiftR` fi n\n\nfi :: (Integral a, Num b) => a -> b\nfi = fromIntegral\n\ntest :: String -> IO ()\ntest str = do\n  let cidrStr = maybe \"invalid CIDR string\" cidrShow (cidrRead str)\n  printf \"%-18s -> %s\\n\" str cidrStr\n\nmain :: IO ()\nmain = do\n  test \"87.70.141.1/22\"\n  test \"36.18.154.103/12\"\n  test \"62.62.197.11/29\"\n  test \"67.137.119.181/4\"\n  test \"161.214.74.21/24\"\n  test \"184.232.176.184/18\"\n  \n  test \"184.256.176.184/12\" \n  test \"184.232.176.184/33\" \n  test \"184.232.184/18\"     \n", "target": "\n\n\n\nimport sys\nfrom socket import inet_aton, inet_ntoa\nfrom struct import pack, unpack\n\nargs = sys.argv[1:]\nif len(args) == 0:\n    args = sys.stdin.readlines()\n\nfor cidr in args:\n   \n   dotted, size_str = cidr.split('/')\n   size = int(size_str)\n\n   numeric = unpack('!I', inet_aton(dotted))[0]  \n   binary = f'{numeric:\n   prefix = binary[:size + 2]                    \n                                                 \n                                                 \n\n   canon_binary = prefix + '0' * (32 - size)     \n   canon_numeric = int(canon_binary, 2)          \n   canon_dotted = inet_ntoa(pack('!I',\n                            (canon_numeric)))    \n   print(f'{canon_dotted}/{size}')               \n"}
{"id": 418799, "name": "Canonicalize CIDR", "source": "Translate Haskell to Python: import Control.Monad (guard)\nimport Data.Bits ((.|.), (.&.), complement, shiftL, shiftR, zeroBits)\nimport Data.Maybe (listToMaybe)\nimport Data.Word (Word32, Word8)\nimport Text.ParserCombinators.ReadP (ReadP, char, readP_to_S)\nimport Text.Printf (printf)\nimport Text.Read.Lex (readDecP)\n\n\n\ndata CIDR = CIDR Word32 Word8\n\n\ncidrRead :: String -> Maybe CIDR\ncidrRead = listToMaybe . map fst . readP_to_S cidrP\n\n\ncidrShow :: CIDR -> String\ncidrShow (CIDR addr n) = let (a, b, c, d) = octetsFrom addr\n                         in printf \"%u.%u.%u.%u/%u\" a b c d n\n\n\n\n\ncidrP :: ReadP CIDR\ncidrP = do a <- octetP <* char '.'\n           b <- octetP <* char '.'\n           c <- octetP <* char '.'\n           d <- octetP <* char '/'\n           n <- netBitsP\n           return $ CIDR (addrFrom a b c d .&. netmask n) n\n  where octetP   = wordP 255\n        netBitsP = wordP  32\n\n\n\n\n\nwordP :: Integral a => Integer -> ReadP a\nwordP lim = do n <- readDecP\n               guard $ n <= lim\n               return $ fi n\n\n\noctetsFrom :: Word32 -> (Word8, Word8, Word8, Word8)\noctetsFrom addr = (oct addr 3, oct addr 2, oct addr 1, oct addr 0)\n  where oct w n = fi $ w `shiftR` (8*n) .&. 0xff\n\n\naddrFrom :: Word8 -> Word8 -> Word8 -> Word8 -> Word32\naddrFrom a b c d = 0 <<+ a <<+ b <<+ c <<+ d\n  where w <<+ o = w `shiftL` 8 .|. fi o\n\n\n\nnetmask :: Word8 -> Word32\nnetmask n = complement $ complement zeroBits `shiftR` fi n\n\nfi :: (Integral a, Num b) => a -> b\nfi = fromIntegral\n\ntest :: String -> IO ()\ntest str = do\n  let cidrStr = maybe \"invalid CIDR string\" cidrShow (cidrRead str)\n  printf \"%-18s -> %s\\n\" str cidrStr\n\nmain :: IO ()\nmain = do\n  test \"87.70.141.1/22\"\n  test \"36.18.154.103/12\"\n  test \"62.62.197.11/29\"\n  test \"67.137.119.181/4\"\n  test \"161.214.74.21/24\"\n  test \"184.232.176.184/18\"\n  \n  test \"184.256.176.184/12\" \n  test \"184.232.176.184/33\" \n  test \"184.232.184/18\"     \n", "target": "\n\n\n\nimport sys\nfrom socket import inet_aton, inet_ntoa\nfrom struct import pack, unpack\n\nargs = sys.argv[1:]\nif len(args) == 0:\n    args = sys.stdin.readlines()\n\nfor cidr in args:\n   \n   dotted, size_str = cidr.split('/')\n   size = int(size_str)\n\n   numeric = unpack('!I', inet_aton(dotted))[0]  \n   binary = f'{numeric:\n   prefix = binary[:size + 2]                    \n                                                 \n                                                 \n\n   canon_binary = prefix + '0' * (32 - size)     \n   canon_numeric = int(canon_binary, 2)          \n   canon_dotted = inet_ntoa(pack('!I',\n                            (canon_numeric)))    \n   print(f'{canon_dotted}/{size}')               \n"}
{"id": 418800, "name": "Sequence of primorial primes", "source": "Translate Haskell to Python: import Data.List (scanl1, elemIndices, nub)\n\nprimes :: [Integer]\nprimes = 2 : filter isPrime [3,5 ..]\n\nisPrime :: Integer -> Bool\nisPrime = isPrime_ primes\n  where\n    isPrime_ :: [Integer] -> Integer -> Bool\n    isPrime_ (p:ps) n\n      | p * p > n = True\n      | n `mod` p == 0 = False\n      | otherwise = isPrime_ ps n\n\nprimorials :: [Integer]\nprimorials = 1 : scanl1 (*) primes\n\nprimorialsPlusMinusOne :: [Integer]\nprimorialsPlusMinusOne = concatMap (((:) . pred) <*> (return . succ)) primorials\n\nsequenceOfPrimorialPrimes :: [Int]\nsequenceOfPrimorialPrimes = (tail . nub) $ (`div` 2) <$> elemIndices True bools\n  where\n    bools = isPrime <$> primorialsPlusMinusOne\n\nmain :: IO ()\nmain = mapM_ print $ take 10 sequenceOfPrimorialPrimes\n", "target": "import pyprimes\n\ndef primorial_prime(_pmax=500):\n    isprime = pyprimes.isprime\n    n, primo = 0, 1\n    for prime in pyprimes.nprimes(_pmax):\n        n, primo = n+1, primo * prime\n        if isprime(primo-1) or isprime(primo+1):\n            yield n\n        \nif __name__ == '__main__':\n    \n    pyprimes.warn_probably = False  \n    for i, n in zip(range(20), primorial_prime()):\n        print('Primorial prime %2i at primorial index: %3i' % (i+1, n))\n"}
{"id": 418801, "name": "Combinations and permutations", "source": "Translate Haskell to Python: perm :: Integer -> Integer -> Integer\nperm n k = product [n-k+1..n]\n\ncomb :: Integer -> Integer -> Integer\ncomb n k = perm n k `div` product [1..k]\n\nmain :: IO ()\nmain = do\n        let showBig maxlen b =\n                let st = show b\n                    stlen = length st\n                in if stlen < maxlen then st else take maxlen st ++ \"... (\"  ++ show (stlen-maxlen) ++  \" more digits)\"\n\n        let showPerm pr = \n                putStrLn $ \"perm(\" ++ show n ++ \",\" ++ show k ++ \") = \"  ++ showBig 40 (perm n k)\n                where n = fst pr\n                      k = snd pr\n\n        let showComb pr = \n                putStrLn $ \"comb(\" ++ show n ++ \",\" ++ show k ++ \") = \"  ++ showBig 40 (comb n k)\n                where n = fst pr\n                      k = snd pr\n\n        putStrLn \"A sample of permutations from 1 to 12:\"\n        mapM_  showPerm [(n, n `div` 3) | n <- [1..12] ]\n\n        putStrLn \"\"\n        putStrLn \"A sample of combinations from 10 to 60:\"\n        mapM_  showComb [(n, n `div` 3) | n <- [10,20..60] ]\n\n        putStrLn \"\"\n        putStrLn \"A sample of permutations from 5 to 15000:\"\n        mapM_  showPerm [(n, n `div` 3) | n <- [5,50,500,1000,5000,15000] ]\n\n        putStrLn \"\"\n        putStrLn \"A sample of combinations from 100 to 1000:\"\n        mapM_  showComb [(n, n `div` 3) | n <- [100,200..1000] ]\n", "target": "from __future__ import print_function\n\nfrom scipy.misc import factorial as fact\nfrom scipy.misc import comb\n\ndef perm(N, k, exact=0):\n    return comb(N, k, exact) * fact(k, exact)\n\nexact=True\nprint('Sample Perms 1..12')\nfor N in range(1, 13):\n    k = max(N-2, 1)\n    print('%iP%i =' % (N, k), perm(N, k, exact), end=', ' if N % 5 else '\\n')\n          \nprint('\\n\\nSample Combs 10..60')\nfor N in range(10, 61, 10):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact), end=', ' if N % 50 else '\\n')\n\nexact=False\nprint('\\n\\nSample Perms 5..1500 Using FP approximations')\nfor N in [5, 15, 150, 1500, 15000]:\n    k = N-2\n    print('%iP%i =' % (N, k), perm(N, k, exact))\n          \nprint('\\nSample Combs 100..1000 Using FP approximations')\nfor N in range(100, 1001, 100):\n    k = N-2\n    print('%iC%i =' % (N, k), comb(N, k, exact))\n"}
{"id": 418802, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Haskell to Python: import Prelude hiding (pi)\nimport Data.Number.MPFR hiding (sqrt, pi, div)\nimport Data.Number.MPFR.Instances.Near ()\n\n\n\ndigitBits :: (Integral a, Num a) => a -> a\ndigitBits n = (n + 1) `div` 2 * 8\n\n\npi :: Integer -> MPFR\npi digits =\n  let eps = fromString (\"1e-\" ++ show digits)\n            (fromInteger $ digitBits digits) 0\n      two = fromInt Near (getPrec eps) 2\n      twoi = 2 :: Int\n      twoI = 2 :: Integer\n      pis a g s n =\n        let aB = (a + g) / two\n            gB = sqrt (a * g)\n            aB2 = aB ^^ twoi\n            sB = s + (two ^^ n) * (aB2 - gB ^^ twoi)\n            num = 4 * aB2\n            den = 1 - sB\n        in (num / den) : pis aB gB sB (n + 1)\n      puntil f (a:b:xs) = if f a b then b else puntil f (b:xs)\n  in puntil (\\a b -> abs (a - b) < eps)\n     $ pis one (one / sqrt two) zero twoI\n\nmain :: IO ()\nmain = do\n  \n  putStrLn $ toString 1000 $ pi 1000\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 418803, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Haskell to Python: import Prelude hiding (pi)\nimport Data.Number.MPFR hiding (sqrt, pi, div)\nimport Data.Number.MPFR.Instances.Near ()\n\n\n\ndigitBits :: (Integral a, Num a) => a -> a\ndigitBits n = (n + 1) `div` 2 * 8\n\n\npi :: Integer -> MPFR\npi digits =\n  let eps = fromString (\"1e-\" ++ show digits)\n            (fromInteger $ digitBits digits) 0\n      two = fromInt Near (getPrec eps) 2\n      twoi = 2 :: Int\n      twoI = 2 :: Integer\n      pis a g s n =\n        let aB = (a + g) / two\n            gB = sqrt (a * g)\n            aB2 = aB ^^ twoi\n            sB = s + (two ^^ n) * (aB2 - gB ^^ twoi)\n            num = 4 * aB2\n            den = 1 - sB\n        in (num / den) : pis aB gB sB (n + 1)\n      puntil f (a:b:xs) = if f a b then b else puntil f (b:xs)\n  in puntil (\\a b -> abs (a - b) < eps)\n     $ pis one (one / sqrt two) zero twoI\n\nmain :: IO ()\nmain = do\n  \n  putStrLn $ toString 1000 $ pi 1000\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 418804, "name": "Window creation_X11", "source": "Translate Haskell to Python: import Graphics.X11.Xlib\nimport Control.Concurrent (threadDelay)\n\nmain = do\n  display <- openDisplay \"\"\n  let defScr = defaultScreen display\n  rw <- rootWindow display defScr\n\n  xwin <- createSimpleWindow display rw\n      0 0 400 200 1\n      (blackPixel display defScr)\n      (whitePixel display defScr)\n\n  setTextProperty display xwin \"Rosetta Code: X11 simple window\" wM_NAME\n\n  mapWindow display xwin\n\n  sync display False\n  threadDelay (5000000)\n\n  destroyWindow display xwin\n  closeDisplay display\n", "target": "from Xlib import X, display\n\nclass Window:\n    def __init__(self, display, msg):\n        self.display = display\n        self.msg = msg\n        \n        self.screen = self.display.screen()\n        self.window = self.screen.root.create_window(\n            10, 10, 100, 100, 1,\n            self.screen.root_depth,\n            background_pixel=self.screen.white_pixel,\n            event_mask=X.ExposureMask | X.KeyPressMask,\n            )\n        self.gc = self.window.create_gc(\n            foreground = self.screen.black_pixel,\n            background = self.screen.white_pixel,\n            )\n\n        self.window.map()\n\n    def loop(self):\n        while True:\n            e = self.display.next_event()\n                \n            if e.type == X.Expose:\n                self.window.fill_rectangle(self.gc, 20, 20, 10, 10)\n                self.window.draw_text(self.gc, 10, 50, self.msg)\n            elif e.type == X.KeyPress:\n                raise SystemExit\n\n                \nif __name__ == \"__main__\":\n    Window(display.Display(), \"Hello, World!\").loop()\n"}
{"id": 418805, "name": "Long primes", "source": "Translate Haskell to Python: import Data.List (elemIndex)\n\nlongPrimesUpTo :: Int -> [Int]\nlongPrimesUpTo n =\n  filter isLongPrime $\n    takeWhile (< n) primes\n  where\n    sieve (p : xs) = p : sieve [x | x <- xs, x `mod` p /= 0]\n    primes = sieve [2 ..]\n    isLongPrime n = found\n      where\n        cycles = take n (iterate ((`mod` n) . (10 *)) 1)\n        index = elemIndex (head cycles) $ tail cycles\n        found = case index of\n          (Just i) -> n - i == 2\n          _ -> False\n\ndisplay :: Int -> IO ()\ndisplay n =\n  if n <= 64000\n    then do\n      putStrLn\n        ( show n <> \" is \"\n            <> show (length $ longPrimesUpTo n)\n        )\n      display (n * 2)\n    else pure ()\n\nmain :: IO ()\nmain = do\n  let fiveHundred = longPrimesUpTo 500\n  putStrLn\n    ( \"The long primes up to 35 are:\\n\"\n        <> show fiveHundred\n        <> \"\\n\"\n    )\n  putStrLn (\"500 is \" <> show (length fiveHundred))\n  display 1000\n", "target": "def sieve(limit):\n    primes = []\n    c = [False] * (limit + 1) \n    \n    p = 3\n    while True:\n        p2 = p * p\n        if p2 > limit: break\n        for i in range(p2, limit, 2 * p): c[i] = True\n        while True:\n            p += 2\n            if not c[p]: break\n\n    for i in range(3, limit, 2):\n        if not c[i]: primes.append(i)\n    return primes\n\n\ndef findPeriod(n):\n    r = 1\n    for i in range(1, n): r = (10 * r) % n\n    rr = r\n    period = 0\n    while True:\n        r = (10 * r) % n\n        period += 1\n        if r == rr: break\n    return period\n\nprimes = sieve(64000)\nlongPrimes = []\nfor prime in primes:\n    if findPeriod(prime) == prime - 1:\n        longPrimes.append(prime)\nnumbers = [500, 1000, 2000, 4000, 8000, 16000, 32000, 64000]\ncount = 0\nindex = 0\ntotals = [0] * len(numbers)\nfor longPrime in longPrimes:\n    if longPrime > numbers[index]:\n        totals[index] = count\n        index += 1\n    count += 1\ntotals[-1] = count\nprint('The long primes up to 500 are:')\nprint(str(longPrimes[:totals[0]]).replace(',', ''))\nprint('\\nThe number of long primes up to:')\nfor (i, total) in enumerate(totals):\n    print('  %5d is %d' % (numbers[i], total))\n"}
{"id": 418806, "name": "Primorial numbers", "source": "Translate Haskell to Python: import Control.Arrow ((&&&))\nimport Data.List (scanl1, foldl1')\n\ngetNthPrimorial :: Int -> Integer\ngetNthPrimorial n = foldl1' (*) (take n primes)\n\nprimes :: [Integer]\nprimes = 2 : filter isPrime [3,5..]\n\nisPrime :: Integer -> Bool\nisPrime = isPrime_ primes\n  where isPrime_ :: [Integer] -> Integer -> Bool\n        isPrime_ (p:ps) n\n          | p * p > n      = True\n          | n `mod` p == 0 = False\n          | otherwise      = isPrime_ ps n\n\nprimorials :: [Integer]\nprimorials = 1 : scanl1 (*) primes\n\nmain :: IO ()\nmain = do\n  \n  let firstTen = take 10 primorials\n  putStrLn $ \"The first 10 primorial numbers are: \" ++ show firstTen\n\n  \n  let powersOfTen = [1..6]\n      primorialTens = map (id &&& (length . show . getNthPrimorial . (10^))) powersOfTen\n      calculate = mapM_ (\\(a,b) -> putStrLn $ \"Primorial(10^\"++show a++\") has \"++show b++\" digits\")\n  calculate primorialTens\n", "target": "from pyprimes import nprimes\nfrom functools import reduce\n\n\nprimelist = list(nprimes(1000001))    \n\ndef primorial(n):\n    return reduce(int.__mul__, primelist[:n], 1)\n\nif __name__ == '__main__':\n    print('First ten primorals:', [primorial(n) for n in range(10)])\n    for e in range(7):\n        n = 10**e\n        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))\n"}
{"id": 418807, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Haskell to Python: import Data.Ratio (Ratio, (%), denominator, numerator)\n\negyptianFraction :: Integral a => Ratio a -> [Ratio a]\negyptianFraction n\n  | n < 0 = map negate (egyptianFraction (-n))\n  | n == 0 = []\n  | x == 1 = [n]\n  | x > y = (x `div` y % 1) : egyptianFraction (x `mod` y % y)\n  | otherwise = (1 % r) : egyptianFraction ((-y) `mod` x % (y * r))\n  where\n    x = numerator n\n    y = denominator n\n    r = y `div` x + 1\n", "target": "from fractions import Fraction\nfrom math import ceil\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '%s/%s' % (self.numerator, self.denominator)\n\ndef ef(fr):\n    ans = []\n    if fr >= 1:\n        if fr.denominator == 1:\n            return [[int(fr)], Fr(0, 1)]\n        intfr = int(fr)\n        ans, fr = [[intfr]], fr - intfr\n    x, y = fr.numerator, fr.denominator\n    while x != 1:\n        ans.append(Fr(1, ceil(1/fr)))\n        fr = Fr(-y % x, y* ceil(1/fr))\n        x, y = fr.numerator, fr.denominator\n    ans.append(fr)\n    return ans\n\nif __name__ == '__main__':\n    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:\n        print('%r \u2500\u25ba %s' % (fr, ' '.join(str(x) for x in ef(fr))))\n    lenmax = denommax = (0, None) \n    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):\n        e = ef(fr)\n        \n        elen, edenom = len(e), e[-1].denominator\n        if elen > lenmax[0]:\n            lenmax = (elen, fr, e)\n        if edenom > denommax[0]:\n            denommax = (edenom, fr, e)\n    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))\n    dstr = str(denommax[0])\n    print('Denominator max is %r with %i digits %s...%s' %\n          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))\n"}
{"id": 418808, "name": "Greedy algorithm for Egyptian fractions", "source": "Translate Haskell to Python: import Data.Ratio (Ratio, (%), denominator, numerator)\n\negyptianFraction :: Integral a => Ratio a -> [Ratio a]\negyptianFraction n\n  | n < 0 = map negate (egyptianFraction (-n))\n  | n == 0 = []\n  | x == 1 = [n]\n  | x > y = (x `div` y % 1) : egyptianFraction (x `mod` y % y)\n  | otherwise = (1 % r) : egyptianFraction ((-y) `mod` x % (y * r))\n  where\n    x = numerator n\n    y = denominator n\n    r = y `div` x + 1\n", "target": "from fractions import Fraction\nfrom math import ceil\n\nclass Fr(Fraction):\n    def __repr__(self):\n        return '%s/%s' % (self.numerator, self.denominator)\n\ndef ef(fr):\n    ans = []\n    if fr >= 1:\n        if fr.denominator == 1:\n            return [[int(fr)], Fr(0, 1)]\n        intfr = int(fr)\n        ans, fr = [[intfr]], fr - intfr\n    x, y = fr.numerator, fr.denominator\n    while x != 1:\n        ans.append(Fr(1, ceil(1/fr)))\n        fr = Fr(-y % x, y* ceil(1/fr))\n        x, y = fr.numerator, fr.denominator\n    ans.append(fr)\n    return ans\n\nif __name__ == '__main__':\n    for fr in [Fr(43, 48), Fr(5, 121), Fr(2014, 59)]:\n        print('%r \u2500\u25ba %s' % (fr, ' '.join(str(x) for x in ef(fr))))\n    lenmax = denommax = (0, None) \n    for fr in set(Fr(a, b) for a in range(1,100) for b in range(1, 100)):\n        e = ef(fr)\n        \n        elen, edenom = len(e), e[-1].denominator\n        if elen > lenmax[0]:\n            lenmax = (elen, fr, e)\n        if edenom > denommax[0]:\n            denommax = (edenom, fr, e)\n    print('Term max is %r with %i terms' % (lenmax[1], lenmax[0]))\n    dstr = str(denommax[0])\n    print('Denominator max is %r with %i digits %s...%s' %\n          (denommax[1], len(dstr), dstr[:5], dstr[-5:]))\n"}
{"id": 418809, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Haskell to Python: gaussLegendre n f a b = d*sum [ w x*f(m + d*x) | x <- roots ]\n  where d = (b - a)/2\n        m = (b + a)/2\n        w x = 2/(1-x^2)/(legendreP' n x)^2\n        roots = map (findRoot (legendreP n) (legendreP' n) . x0) [1..n]\n        x0 i = cos (pi*(i-1/4)/(n+1/2))\n", "target": "from numpy import *\n \n\n\ndef Legendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0+1.0\n\telif (n==1):\n\t\treturn x\n\telse:\n\t\treturn ((2.0*n-1.0)*x*Legendre(n-1,x)-(n-1)*Legendre(n-2,x))/n\n \n\n\ndef DLegendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0\n\telif (n==1):\n\t\treturn x*0+1.0\n\telse:\n\t\treturn (n/(x**2-1.0))*(x*Legendre(n,x)-Legendre(n-1,x))\n\n\ndef LegendreRoots(polyorder,tolerance=1e-20):\n\tif polyorder<2:\n\t\terr=1 \n\telse:\n\t\troots=[]\n\t\t\n\t\tfor i in range(1,int(polyorder)/2 +1):\n\t\t\tx=cos(pi*(i-0.25)/(polyorder+0.5))\n\t\t\terror=10*tolerance\n\t\t        iters=0\n\t\t        while (error>tolerance) and (iters<1000):\n\t\t                dx=-Legendre(polyorder,x)/DLegendre(polyorder,x)\n\t\t                x=x+dx\n\t\t                iters=iters+1\n\t\t                error=abs(dx)\n\t\t\troots.append(x)\n\t\t\n\t\troots=array(roots)\n\t\tif polyorder%2==0:\n\t\t\troots=concatenate( (-1.0*roots, roots[::-1]) )\n\t\telse:\n\t\t\troots=concatenate( (-1.0*roots, [0.0], roots[::-1]) )\n\t\terr=0 \n\treturn [roots, err]\n\n\ndef GaussLegendreWeights(polyorder):\n\tW=[]\n\t[xis,err]=LegendreRoots(polyorder)\n\tif err==0:\n\t\tW=2.0/( (1.0-xis**2)*(DLegendre(polyorder,xis)**2) )\n\t\terr=0\n\telse:\n\t\terr=1 \n\treturn [W, xis, err]\n\n\n\n\n\n\ndef GaussLegendreQuadrature(func, polyorder, a, b):\n\t[Ws,xs, err]= GaussLegendreWeights(polyorder)\n\tif err==0:\n\t\tans=(b-a)*0.5*sum( Ws*func( (b-a)*0.5*xs+ (b+a)*0.5 ) )\n\telse: \n\t\t\n\t\terr=1\n\t\tans=None\n\treturn [ans,err]\n\n\ndef func(x):\n\treturn exp(x)\n\n\n \norder=5\n[Ws,xs,err]=GaussLegendreWeights(order)\nif err==0:\n\tprint \"Order   \u00a0: \", order\n\tprint \"Roots   \u00a0: \", xs\n\tprint \"Weights \u00a0: \", Ws\nelse:\n\tprint \"Roots/Weights evaluation failed\"\n \n\n[ans,err]=GaussLegendreQuadrature(func , order, -3,3)\nif err==0:\n\tprint \"Integral\u00a0: \", ans\nelse:\n\tprint \"Integral evaluation failed\"\n"}
{"id": 418810, "name": "K-d tree", "source": "Translate Haskell to Python: import System.Random\nimport Data.List (sortBy, genericLength, minimumBy)\nimport Data.Ord (comparing)\n\n\n\ntype DimensionalAccessors a b = [a -> b]\n\n\ndata Tree a = Node a (Tree a) (Tree a)\n            | Empty\n\ninstance Show a => Show (Tree a) where\n  show Empty = \"Empty\"\n  show (Node value left right) =\n    \"(\" ++ show value ++ \" \" ++ show left ++ \" \" ++ show right ++ \")\" \n\n\ndata KDTree a b = KDTree (DimensionalAccessors a b) (Tree a)\n\ninstance Show a => Show (KDTree a b) where\n  show (KDTree _ tree) = \"KDTree \" ++ show tree\n\n\nsqrDist :: Num b => DimensionalAccessors a b -> a -> a -> b\nsqrDist dims a b = sum $ map square $ zipWith (-) a' b'\n  where\n    a' = map ($ a) dims\n    b' = map ($ b) dims\n\nsquare :: Num a => a -> a\nsquare = (^ 2)\n\n\ninsert :: Ord b => KDTree a b -> a -> KDTree a b\ninsert (KDTree dims tree) value = KDTree dims $ ins (cycle dims) tree\n  where\n    ins _      Empty                   = Node value Empty Empty\n    ins (d:ds) (Node split left right) =\n      if d value < d split\n      then Node split (ins ds left) right\n      else Node split left (ins ds right)\n\n\nempty :: DimensionalAccessors a b -> KDTree a b\nempty dims = KDTree dims Empty\n\n\nsingleton :: Ord b => DimensionalAccessors a b -> a -> KDTree a b\nsingleton dims value = insert (empty dims) value\n\n\nfromList :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromList dims values = KDTree dims $ fList (cycle dims) values\n  where\n    fList _      []     = Empty\n    fList (d:ds) values =\n      let sorted          = sortBy (comparing d) values\n          (lower, higher) = splitAt (genericLength sorted `div` 2) sorted\n      in case higher of\n        []          -> Empty\n        median:rest -> Node median (fList ds lower) (fList ds rest)\n\n\n\nfromListLinear :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromListLinear dims values = foldl insert (empty dims) values\n\n\n\nnearest :: (Ord b, Num b, Integral c) => KDTree a b -> a -> (Maybe a, c)\nnearest (KDTree dims tree) value = near (cycle dims) tree\n  where\n    dist = sqrDist dims\n    \n    near _      Empty                    = (Nothing, 1)\n    \n    near _      (Node split Empty Empty) = (Just split, 1)\n    near (d:ds) (Node split left right)  =\n      \n      let dimdist x y    = square (d x - d y)\n          splitDist      = dist value split\n          hyperPlaneDist = dimdist value split\n          bestLeft       = near ds left\n          bestRight      = near ds right\n          \n          \n          ((maybeThisBest, thisCount), (maybeOtherBest, otherCount)) =\n            if d value < d split\n            then (bestLeft, bestRight)\n            else (bestRight, bestLeft)\n      in case maybeThisBest of\n        Nothing    ->\n          \n          \n          \n          let count = 1 + thisCount + otherCount\n          in case maybeOtherBest of\n            \n            \n            \n            Nothing         -> (Just split, count)\n            \n            \n            Just otherBest ->\n              if dist value otherBest < splitDist\n              then (maybeOtherBest, count)\n              else (Just split, count)\n        \n        Just thisBest ->\n          let thisBestDist = dist value thisBest\n              best         =\n                \n                if splitDist < thisBestDist\n                then split\n                else thisBest\n              bestDist     = dist value best\n          in\n            if bestDist < hyperPlaneDist\n            \n            \n            \n            then (Just best, 1 + thisCount)\n            \n            \n            else\n              let count = 1 + thisCount + otherCount\n              in case maybeOtherBest of\n                Nothing        -> (Just best, count)\n                Just otherBest ->\n                  if bestDist < dist value otherBest\n                  then (Just best, count)\n                  else (maybeOtherBest, count)\n\n\ntuple2D :: [(a, a) -> a]\ntuple2D = [fst, snd]\n\n\ntuple3D :: [(a, a, a) -> a]\ntuple3D = [d1, d2, d3]\n  where\n    d1 (a, _, _) = a\n    d2 (_, b, _) = b\n    d3 (_, _, c) = c\n\n\ninstance (Random a, Random b, Random c) => Random (a, b, c) where\n  random gen =\n    let (vA, genA) = random gen\n        (vB, genB) = random genA\n        (vC, genC) = random genB\n    in ((vA, vB, vC), genC)\n\n  randomR ((lA, lB, lC), (hA, hB, hC)) gen =\n    let (vA, genA) = randomR (lA, hA) gen\n        (vB, genB) = randomR (lB, hB) genA\n        (vC, genC) = randomR (lC, hC) genB\n    in ((vA, vB, vC), genC)\n\nprintResults :: (Show a, Show b, Show c, Floating c) =>\n                a -> (Maybe a, b) -> DimensionalAccessors a c -> IO ()\nprintResults point result dims = do\n  let (nearest, visited) = result\n  case nearest of\n    Nothing    -> putStrLn \"Could not find nearest.\"\n    Just value -> do\n      let dist = sqrt $ sqrDist dims point value\n      putStrLn $ \"Point:    \" ++ show point\n      putStrLn $ \"Nearest:  \" ++ show value\n      putStrLn $ \"Distance: \" ++ show dist\n      putStrLn $ \"Visited:  \" ++ show visited\n      putStrLn \"\"\n\n\nlinearNearest :: (Ord b, Num b) => DimensionalAccessors a b -> a -> [a] -> Maybe a\nlinearNearest _    _     [] = Nothing\nlinearNearest dims value xs = Just $ minimumBy (comparing $ sqrDist dims value) xs\n\nmain :: IO ()\nmain = do\n  let wikiValues :: [(Double, Double)]\n      wikiValues  = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)]\n      wikiTree    = fromList tuple2D wikiValues\n      wikiSearch  = (9, 2)\n      wikiNearest = nearest wikiTree wikiSearch\n  putStrLn \"Wikipedia example:\"\n  printResults wikiSearch wikiNearest tuple2D\n\n  let stdGen                = mkStdGen 0\n      randRange :: ((Double, Double, Double), (Double, Double, Double))\n      randRange             = ((0, 0, 0), (1000, 1000, 1000))\n      (randSearch, stdGenB) = randomR randRange stdGen\n      randValues            = take 1000 $ randomRs randRange stdGenB\n      randTree              = fromList tuple3D randValues\n      randNearest           = nearest randTree randSearch\n      randNearestLinear     = linearNearest tuple3D randSearch randValues\n  putStrLn \"1000 random 3D points on the range of [0, 1000):\"\n  printResults randSearch randNearest tuple3D\n  putStrLn \"Confirm naive nearest:\"\n  print randNearestLinear\n", "target": "from random import seed, random\nfrom time import time\nfrom operator import itemgetter\nfrom collections import namedtuple\nfrom math import sqrt\nfrom copy import deepcopy\n\n\ndef sqd(p1, p2):\n    return sum((c1 - c2) ** 2 for c1, c2 in zip(p1, p2))\n\n\nclass KdNode(object):\n    __slots__ = (\"dom_elt\", \"split\", \"left\", \"right\")\n\n    def __init__(self, dom_elt, split, left, right):\n        self.dom_elt = dom_elt\n        self.split = split\n        self.left = left\n        self.right = right\n\n\nclass Orthotope(object):\n    __slots__ = (\"min\", \"max\")\n\n    def __init__(self, mi, ma):\n        self.min, self.max = mi, ma\n\n\nclass KdTree(object):\n    __slots__ = (\"n\", \"bounds\")\n\n    def __init__(self, pts, bounds):\n        def nk2(split, exset):\n            if not exset:\n                return None\n            exset.sort(key=itemgetter(split))\n            m = len(exset) // 2\n            d = exset[m]\n            while m + 1 < len(exset) and exset[m + 1][split] == d[split]:\n                m += 1\n            d = exset[m]\n\n\n            s2 = (split + 1) % len(d)  \n            return KdNode(d, split, nk2(s2, exset[:m]),\n                                    nk2(s2, exset[m + 1:]))\n        self.n = nk2(0, pts)\n        self.bounds = bounds\n\nT3 = namedtuple(\"T3\", \"nearest dist_sqd nodes_visited\")\n\n\ndef find_nearest(k, t, p):\n    def nn(kd, target, hr, max_dist_sqd):\n        if kd is None:\n            return T3([0.0] * k, float(\"inf\"), 0)\n\n        nodes_visited = 1\n        s = kd.split\n        pivot = kd.dom_elt\n        left_hr = deepcopy(hr)\n        right_hr = deepcopy(hr)\n        left_hr.max[s] = pivot[s]\n        right_hr.min[s] = pivot[s]\n\n        if target[s] <= pivot[s]:\n            nearer_kd, nearer_hr = kd.left, left_hr\n            further_kd, further_hr = kd.right, right_hr\n        else:\n            nearer_kd, nearer_hr = kd.right, right_hr\n            further_kd, further_hr = kd.left, left_hr\n\n        n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd)\n        nearest = n1.nearest\n        dist_sqd = n1.dist_sqd\n        nodes_visited += n1.nodes_visited\n\n        if dist_sqd < max_dist_sqd:\n            max_dist_sqd = dist_sqd\n        d = (pivot[s] - target[s]) ** 2\n        if d > max_dist_sqd:\n            return T3(nearest, dist_sqd, nodes_visited)\n        d = sqd(pivot, target)\n        if d < dist_sqd:\n            nearest = pivot\n            dist_sqd = d\n            max_dist_sqd = dist_sqd\n\n        n2 = nn(further_kd, target, further_hr, max_dist_sqd)\n        nodes_visited += n2.nodes_visited\n        if n2.dist_sqd < dist_sqd:\n            nearest = n2.nearest\n            dist_sqd = n2.dist_sqd\n\n        return T3(nearest, dist_sqd, nodes_visited)\n\n    return nn(t.n, p, t.bounds, float(\"inf\"))\n\n\ndef show_nearest(k, heading, kd, p):\n    print(heading + \":\")\n    print(\"Point:           \", p)\n    n = find_nearest(k, kd, p)\n    print(\"Nearest neighbor:\", n.nearest)\n    print(\"Distance:        \", sqrt(n.dist_sqd))\n    print(\"Nodes visited:   \", n.nodes_visited, \"\\n\")\n\n\ndef random_point(k):\n    return [random() for _ in range(k)]\n\n\ndef random_points(k, n):\n    return [random_point(k) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    seed(1)\n    P = lambda *coords: list(coords)\n    kd1 = KdTree([P(2, 3), P(5, 4), P(9, 6), P(4, 7), P(8, 1), P(7, 2)],\n                  Orthotope(P(0, 0), P(10, 10)))\n    show_nearest(2, \"Wikipedia example data\", kd1, P(9, 2))\n\n    N = 400000\n    t0 = time()\n    kd2 = KdTree(random_points(3, N), Orthotope(P(0, 0, 0), P(1, 1, 1)))\n    t1 = time()\n    text = lambda *parts: \"\".join(map(str, parts))\n    show_nearest(2, text(\"k-d tree with \", N,\n                         \" random 3D points (generation time: \",\n                         t1-t0, \"s)\"),\n                 kd2, random_point(3))\n"}
{"id": 418811, "name": "K-d tree", "source": "Translate Haskell to Python: import System.Random\nimport Data.List (sortBy, genericLength, minimumBy)\nimport Data.Ord (comparing)\n\n\n\ntype DimensionalAccessors a b = [a -> b]\n\n\ndata Tree a = Node a (Tree a) (Tree a)\n            | Empty\n\ninstance Show a => Show (Tree a) where\n  show Empty = \"Empty\"\n  show (Node value left right) =\n    \"(\" ++ show value ++ \" \" ++ show left ++ \" \" ++ show right ++ \")\" \n\n\ndata KDTree a b = KDTree (DimensionalAccessors a b) (Tree a)\n\ninstance Show a => Show (KDTree a b) where\n  show (KDTree _ tree) = \"KDTree \" ++ show tree\n\n\nsqrDist :: Num b => DimensionalAccessors a b -> a -> a -> b\nsqrDist dims a b = sum $ map square $ zipWith (-) a' b'\n  where\n    a' = map ($ a) dims\n    b' = map ($ b) dims\n\nsquare :: Num a => a -> a\nsquare = (^ 2)\n\n\ninsert :: Ord b => KDTree a b -> a -> KDTree a b\ninsert (KDTree dims tree) value = KDTree dims $ ins (cycle dims) tree\n  where\n    ins _      Empty                   = Node value Empty Empty\n    ins (d:ds) (Node split left right) =\n      if d value < d split\n      then Node split (ins ds left) right\n      else Node split left (ins ds right)\n\n\nempty :: DimensionalAccessors a b -> KDTree a b\nempty dims = KDTree dims Empty\n\n\nsingleton :: Ord b => DimensionalAccessors a b -> a -> KDTree a b\nsingleton dims value = insert (empty dims) value\n\n\nfromList :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromList dims values = KDTree dims $ fList (cycle dims) values\n  where\n    fList _      []     = Empty\n    fList (d:ds) values =\n      let sorted          = sortBy (comparing d) values\n          (lower, higher) = splitAt (genericLength sorted `div` 2) sorted\n      in case higher of\n        []          -> Empty\n        median:rest -> Node median (fList ds lower) (fList ds rest)\n\n\n\nfromListLinear :: Ord b => DimensionalAccessors a b -> [a] -> KDTree a b\nfromListLinear dims values = foldl insert (empty dims) values\n\n\n\nnearest :: (Ord b, Num b, Integral c) => KDTree a b -> a -> (Maybe a, c)\nnearest (KDTree dims tree) value = near (cycle dims) tree\n  where\n    dist = sqrDist dims\n    \n    near _      Empty                    = (Nothing, 1)\n    \n    near _      (Node split Empty Empty) = (Just split, 1)\n    near (d:ds) (Node split left right)  =\n      \n      let dimdist x y    = square (d x - d y)\n          splitDist      = dist value split\n          hyperPlaneDist = dimdist value split\n          bestLeft       = near ds left\n          bestRight      = near ds right\n          \n          \n          ((maybeThisBest, thisCount), (maybeOtherBest, otherCount)) =\n            if d value < d split\n            then (bestLeft, bestRight)\n            else (bestRight, bestLeft)\n      in case maybeThisBest of\n        Nothing    ->\n          \n          \n          \n          let count = 1 + thisCount + otherCount\n          in case maybeOtherBest of\n            \n            \n            \n            Nothing         -> (Just split, count)\n            \n            \n            Just otherBest ->\n              if dist value otherBest < splitDist\n              then (maybeOtherBest, count)\n              else (Just split, count)\n        \n        Just thisBest ->\n          let thisBestDist = dist value thisBest\n              best         =\n                \n                if splitDist < thisBestDist\n                then split\n                else thisBest\n              bestDist     = dist value best\n          in\n            if bestDist < hyperPlaneDist\n            \n            \n            \n            then (Just best, 1 + thisCount)\n            \n            \n            else\n              let count = 1 + thisCount + otherCount\n              in case maybeOtherBest of\n                Nothing        -> (Just best, count)\n                Just otherBest ->\n                  if bestDist < dist value otherBest\n                  then (Just best, count)\n                  else (maybeOtherBest, count)\n\n\ntuple2D :: [(a, a) -> a]\ntuple2D = [fst, snd]\n\n\ntuple3D :: [(a, a, a) -> a]\ntuple3D = [d1, d2, d3]\n  where\n    d1 (a, _, _) = a\n    d2 (_, b, _) = b\n    d3 (_, _, c) = c\n\n\ninstance (Random a, Random b, Random c) => Random (a, b, c) where\n  random gen =\n    let (vA, genA) = random gen\n        (vB, genB) = random genA\n        (vC, genC) = random genB\n    in ((vA, vB, vC), genC)\n\n  randomR ((lA, lB, lC), (hA, hB, hC)) gen =\n    let (vA, genA) = randomR (lA, hA) gen\n        (vB, genB) = randomR (lB, hB) genA\n        (vC, genC) = randomR (lC, hC) genB\n    in ((vA, vB, vC), genC)\n\nprintResults :: (Show a, Show b, Show c, Floating c) =>\n                a -> (Maybe a, b) -> DimensionalAccessors a c -> IO ()\nprintResults point result dims = do\n  let (nearest, visited) = result\n  case nearest of\n    Nothing    -> putStrLn \"Could not find nearest.\"\n    Just value -> do\n      let dist = sqrt $ sqrDist dims point value\n      putStrLn $ \"Point:    \" ++ show point\n      putStrLn $ \"Nearest:  \" ++ show value\n      putStrLn $ \"Distance: \" ++ show dist\n      putStrLn $ \"Visited:  \" ++ show visited\n      putStrLn \"\"\n\n\nlinearNearest :: (Ord b, Num b) => DimensionalAccessors a b -> a -> [a] -> Maybe a\nlinearNearest _    _     [] = Nothing\nlinearNearest dims value xs = Just $ minimumBy (comparing $ sqrDist dims value) xs\n\nmain :: IO ()\nmain = do\n  let wikiValues :: [(Double, Double)]\n      wikiValues  = [(2, 3), (5, 4), (9, 6), (4, 7), (8, 1), (7, 2)]\n      wikiTree    = fromList tuple2D wikiValues\n      wikiSearch  = (9, 2)\n      wikiNearest = nearest wikiTree wikiSearch\n  putStrLn \"Wikipedia example:\"\n  printResults wikiSearch wikiNearest tuple2D\n\n  let stdGen                = mkStdGen 0\n      randRange :: ((Double, Double, Double), (Double, Double, Double))\n      randRange             = ((0, 0, 0), (1000, 1000, 1000))\n      (randSearch, stdGenB) = randomR randRange stdGen\n      randValues            = take 1000 $ randomRs randRange stdGenB\n      randTree              = fromList tuple3D randValues\n      randNearest           = nearest randTree randSearch\n      randNearestLinear     = linearNearest tuple3D randSearch randValues\n  putStrLn \"1000 random 3D points on the range of [0, 1000):\"\n  printResults randSearch randNearest tuple3D\n  putStrLn \"Confirm naive nearest:\"\n  print randNearestLinear\n", "target": "from random import seed, random\nfrom time import time\nfrom operator import itemgetter\nfrom collections import namedtuple\nfrom math import sqrt\nfrom copy import deepcopy\n\n\ndef sqd(p1, p2):\n    return sum((c1 - c2) ** 2 for c1, c2 in zip(p1, p2))\n\n\nclass KdNode(object):\n    __slots__ = (\"dom_elt\", \"split\", \"left\", \"right\")\n\n    def __init__(self, dom_elt, split, left, right):\n        self.dom_elt = dom_elt\n        self.split = split\n        self.left = left\n        self.right = right\n\n\nclass Orthotope(object):\n    __slots__ = (\"min\", \"max\")\n\n    def __init__(self, mi, ma):\n        self.min, self.max = mi, ma\n\n\nclass KdTree(object):\n    __slots__ = (\"n\", \"bounds\")\n\n    def __init__(self, pts, bounds):\n        def nk2(split, exset):\n            if not exset:\n                return None\n            exset.sort(key=itemgetter(split))\n            m = len(exset) // 2\n            d = exset[m]\n            while m + 1 < len(exset) and exset[m + 1][split] == d[split]:\n                m += 1\n            d = exset[m]\n\n\n            s2 = (split + 1) % len(d)  \n            return KdNode(d, split, nk2(s2, exset[:m]),\n                                    nk2(s2, exset[m + 1:]))\n        self.n = nk2(0, pts)\n        self.bounds = bounds\n\nT3 = namedtuple(\"T3\", \"nearest dist_sqd nodes_visited\")\n\n\ndef find_nearest(k, t, p):\n    def nn(kd, target, hr, max_dist_sqd):\n        if kd is None:\n            return T3([0.0] * k, float(\"inf\"), 0)\n\n        nodes_visited = 1\n        s = kd.split\n        pivot = kd.dom_elt\n        left_hr = deepcopy(hr)\n        right_hr = deepcopy(hr)\n        left_hr.max[s] = pivot[s]\n        right_hr.min[s] = pivot[s]\n\n        if target[s] <= pivot[s]:\n            nearer_kd, nearer_hr = kd.left, left_hr\n            further_kd, further_hr = kd.right, right_hr\n        else:\n            nearer_kd, nearer_hr = kd.right, right_hr\n            further_kd, further_hr = kd.left, left_hr\n\n        n1 = nn(nearer_kd, target, nearer_hr, max_dist_sqd)\n        nearest = n1.nearest\n        dist_sqd = n1.dist_sqd\n        nodes_visited += n1.nodes_visited\n\n        if dist_sqd < max_dist_sqd:\n            max_dist_sqd = dist_sqd\n        d = (pivot[s] - target[s]) ** 2\n        if d > max_dist_sqd:\n            return T3(nearest, dist_sqd, nodes_visited)\n        d = sqd(pivot, target)\n        if d < dist_sqd:\n            nearest = pivot\n            dist_sqd = d\n            max_dist_sqd = dist_sqd\n\n        n2 = nn(further_kd, target, further_hr, max_dist_sqd)\n        nodes_visited += n2.nodes_visited\n        if n2.dist_sqd < dist_sqd:\n            nearest = n2.nearest\n            dist_sqd = n2.dist_sqd\n\n        return T3(nearest, dist_sqd, nodes_visited)\n\n    return nn(t.n, p, t.bounds, float(\"inf\"))\n\n\ndef show_nearest(k, heading, kd, p):\n    print(heading + \":\")\n    print(\"Point:           \", p)\n    n = find_nearest(k, kd, p)\n    print(\"Nearest neighbor:\", n.nearest)\n    print(\"Distance:        \", sqrt(n.dist_sqd))\n    print(\"Nodes visited:   \", n.nodes_visited, \"\\n\")\n\n\ndef random_point(k):\n    return [random() for _ in range(k)]\n\n\ndef random_points(k, n):\n    return [random_point(k) for _ in range(n)]\n\nif __name__ == \"__main__\":\n    seed(1)\n    P = lambda *coords: list(coords)\n    kd1 = KdTree([P(2, 3), P(5, 4), P(9, 6), P(4, 7), P(8, 1), P(7, 2)],\n                  Orthotope(P(0, 0), P(10, 10)))\n    show_nearest(2, \"Wikipedia example data\", kd1, P(9, 2))\n\n    N = 400000\n    t0 = time()\n    kd2 = KdTree(random_points(3, N), Orthotope(P(0, 0, 0), P(1, 1, 1)))\n    t1 = time()\n    text = lambda *parts: \"\".join(map(str, parts))\n    show_nearest(2, text(\"k-d tree with \", N,\n                         \" random 3D points (generation time: \",\n                         t1-t0, \"s)\"),\n                 kd2, random_point(3))\n"}
{"id": 418812, "name": "Color quantization", "source": "Translate Haskell to Python: import qualified Data.ByteString.Lazy as BS\nimport qualified Data.Foldable as Fold\nimport qualified Data.List as List\nimport Data.Ord\nimport qualified Data.Sequence as Seq\nimport Data.Word\nimport System.Environment\n\nimport Codec.Picture\nimport Codec.Picture.Types\n\ntype Accessor = PixelRGB8 -> Pixel8\n\n\n\nred, blue, green :: Accessor\nred   (PixelRGB8 r _ _) = r\ngreen (PixelRGB8 _ g _) = g\nblue  (PixelRGB8 _ _ b) = b\n\n\ngetPixels :: Pixel a => Image a -> [a]\ngetPixels image =\n  [pixelAt image x y\n  | x <- [0..(imageWidth image - 1)]\n  , y <- [0..(imageHeight image - 1)]]\n\n\nextents :: [PixelRGB8] -> (PixelRGB8, PixelRGB8)\nextents pixels = (extent minimum, extent maximum)\n  where\n    bound f g = f $ map g pixels\n    extent f  = PixelRGB8 (bound f red) (bound f green) (bound f blue)\n\n\naverage :: [PixelRGB8] -> PixelRGB8\naverage pixels = PixelRGB8 (avg red) (avg green) (avg blue)\n  where\n    len   = toInteger $ length pixels\n    avg c = fromIntegral $ (sum $ map (toInteger . c) pixels) `div` len\n\n\ncompwise :: (Word8 -> Word8 -> Word8) -> PixelRGB8 -> PixelRGB8 -> PixelRGB8\ncompwise f (PixelRGB8 ra ga ba) (PixelRGB8 rb gb bb) =\n  PixelRGB8 (f ra rb) (f ga gb) (f ba bb)\n\n\ndiffPixel :: PixelRGB8 -> PixelRGB8 -> PixelRGB8\ndiffPixel = compwise (\\x y -> max x y - min x y)\n\n\ndistPixel :: PixelRGB8 -> PixelRGB8 -> Integer\ndistPixel x y = (rr ^ 2) + (gg ^ 2) + (bb ^ 2) \n  where\n    PixelRGB8 r g b = diffPixel x y\n    rr              = toInteger r\n    gg              = toInteger g\n    bb              = toInteger b\n\n\nlongestAccessor :: (PixelRGB8, PixelRGB8) -> Accessor\nlongestAccessor (l, h) =\n  snd $ Fold.maximumBy (comparing fst) $ zip [r, g, b] [red, green, blue]\n  where\n    PixelRGB8 r g b = diffPixel h l\n\n\nnearestIdx :: PixelRGB8 -> [PixelRGB8] -> Int\nnearestIdx pixel px = ans\n  where\n    Just ans = List.findIndex (== near) px\n    near     = List.foldl1 comp px\n    comp a b = if distPixel a pixel <= distPixel b pixel then a else b\n\n\n\n\nmeanSplit :: [PixelRGB8] -> Accessor -> ([PixelRGB8], [PixelRGB8])\nmeanSplit l f = List.splitAt index sorted\n  where\n    sorted = List.sortBy (comparing f) l\n    index  = nearestIdx (average l) sorted\n\n\n\nmeanCutQuant :: Image PixelRGB8 -> Int -> (Image Pixel8, Palette)\nmeanCutQuant image numRegions = (indexmap, palette)\n  where\n    extentsP p   = (p, extents p)\n    regions      = map (\\(p, e) -> (average p, e))\n                   $ search $ Seq.singleton $ extentsP $ getPixels image\n    palette      = snd $ generateFoldImage (\\(x:xs) _ _ -> (xs, x))\n                   (map fst regions) numRegions 1\n    indexmap     = pixelMap\n                   (\\pixel -> fromIntegral $ nearestIdx pixel $ map fst regions)\n                   image\n    search queue =\n      case Seq.viewl queue of\n        (pixels, extent) Seq.:< queueB ->\n          let (left, right) = meanSplit pixels $ longestAccessor extent\n              queueC        = Fold.foldl (Seq.|>) queueB $ map extentsP [left, right]\n          in if Seq.length queueC >= numRegions\n             then List.take numRegions $ Fold.toList queueC\n             else search queueC\n        Seq.EmptyL                     -> error \"Queue should never be empty.\"\n\nquantizeIO :: FilePath -> FilePath -> Int -> IO ()\nquantizeIO path outpath numRegions = do\n  dynimage <- readImage path\n  case dynimage of\n    Left err                 -> putStrLn err\n    Right (ImageRGB8 image)  -> doImage image \n    Right (ImageRGBA8 image) -> doImage (pixelMap dropTransparency image)\n    _                        -> putStrLn \"Expecting RGB8 or RGBA8 image\"\n  where\n    doImage image = do\n      let (indexmap, palette) = meanCutQuant image numRegions\n      case encodePalettedPng palette indexmap of\n        Left err      -> putStrLn err\n        Right bstring -> BS.writeFile outpath bstring\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  prog <- getProgName\n  case args of\n    [path, outpath] -> quantizeIO path outpath 16\n    _               -> putStrLn $ \"Usage: \" ++ prog ++ \" <image-file> <out-file.png>\"\n", "target": "from PIL import Image\n\nif __name__==\"__main__\":\n\tim = Image.open(\"frog.png\")\n\tim2 = im.quantize(16)\n\tim2.show()\n"}
{"id": 418813, "name": "Cut a rectangle", "source": "Translate Haskell to Python: import qualified Data.Vector.Unboxed.Mutable as V\nimport Data.STRef\nimport Control.Monad (forM_, when)\nimport Control.Monad.ST\n\ndir :: [(Int, Int)]\ndir = [(1, 0), (-1, 0), (0, -1), (0, 1)]\n\ndata Env = Env { w, h, len, count, ret :: !Int, next :: ![Int] }\n\ncutIt :: STRef s Env -> ST s ()\ncutIt env = do\n    e <- readSTRef env\n    when (odd $ h e) $ modifySTRef env $ \\en -> en { h = w e,\n        w = h e }\n    e <- readSTRef env\n    if odd (h e)\n        then modifySTRef env $ \\en -> en { ret = 0 }\n        else\n            if w e == 1\n            then modifySTRef env $ \\en -> en { ret = 1 }\n            else do\n                let blen = (h e + 1) * (w e + 1) - 1\n                    t = (h e `div` 2) * (w e + 1) + (w e `div` 2)\n                modifySTRef env $ \\en -> en { len = blen,\n                    count = 0,\n                    next = [ w e + 1, (negate $ w e) - 1, -1, 1] }\n                grid <- V.replicate (blen + 1) False\n                case odd (w e) of\n                    True -> do\n                        V.write grid t True\n                        V.write grid (t + 1) True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e1 <- readSTRef env\n                        let res1 = count e1\n                        modifySTRef env $ \\en -> en { count = 0 }\n                        walk grid (h e `div` 2 - 1) (w e `div` 2)\n                        modifySTRef env $ \\en -> en { ret = res1 +\n                            (count en * 2) }\n                    False -> do\n                        V.write grid t True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e2 <- readSTRef env\n                        let count2 = count e2\n                        if h e == w e\n                            then modifySTRef env $ \\en -> en { ret =\n                                count2 * 2 }\n                            else do\n                                walk grid (h e `div` 2 - 1)\n                                    (w e `div` 2)\n                                modifySTRef env $ \\en -> en { ret =\n                                    count en }\n    where\n        walk grid y x = do\n            e <- readSTRef env\n            if y <= 0 || y >= h e || x <= 0 || x >= w e\n                then modifySTRef env $ \\en -> en { count = count en + 1 }\n                else do\n                    let t = y * (w e + 1) + x\n                    V.write grid t True\n                    V.write grid (len e - t) True\n                    forM_ (zip (next e) [0..3]) $ \\(n, d) -> do\n                        g <- V.read grid (t + n)\n                        when (not g) $\n                            walk grid (y + fst (dir !! d)) (x + snd (dir !! d))\n                    V.write grid t False\n                    V.write grid (len e - t) False\n\ncut :: (Int, Int) -> Int\ncut (x, y) = runST $ do\n    env <- newSTRef $ Env { w = y, h = x, len = 0, count = 0, ret = 0, next = [] }\n    cutIt env\n    result <- readSTRef env\n    return $ ret result\n\nmain :: IO ()\nmain = do\n    mapM_ (\\(x, y) -> when (even (x * y)) (putStrLn $ \n        show x ++ \" x \" ++ show y ++ \": \" ++ show (cut (x, y))))\n        [ (x, y) | x <- [1..10], y <- [1..x] ]\n", "target": "def cut_it(h, w):\n    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))\n    if h % 2: h, w = w, h\n    if h % 2: return 0\n    if w == 1: return 1\n    count = 0\n\n    next = [w + 1, -w - 1, -1, 1]\n    blen = (h + 1) * (w + 1) - 1\n    grid = [False] * (blen + 1)\n\n    def walk(y, x, count):\n        if not y or y == h or not x or x == w:\n            return count + 1\n\n        t = y * (w + 1) + x\n        grid[t] = grid[blen - t] = True\n\n        if not grid[t + next[0]]:\n            count = walk(y + dirs[0][0], x + dirs[0][1], count)\n        if not grid[t + next[1]]:\n            count = walk(y + dirs[1][0], x + dirs[1][1], count)\n        if not grid[t + next[2]]:\n            count = walk(y + dirs[2][0], x + dirs[2][1], count)\n        if not grid[t + next[3]]:\n            count = walk(y + dirs[3][0], x + dirs[3][1], count)\n\n        grid[t] = grid[blen - t] = False\n        return count\n\n    t = h // 2 * (w + 1) + w // 2\n    if w % 2:\n        grid[t] = grid[t + 1] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        res = count\n        count = 0\n        count = walk(h // 2 - 1, w // 2, count)\n        return res + count * 2\n    else:\n        grid[t] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        if h == w:\n            return count * 2\n        count = walk(h // 2 - 1, w // 2, count)\n        return count\n\ndef main():\n    for w in xrange(1, 10):\n        for h in xrange(1, w + 1):\n            if not((w * h) % 2):\n                print \"%d x %d: %d\" % (w, h, cut_it(w, h))\n\nmain()\n"}
{"id": 418814, "name": "Cut a rectangle", "source": "Translate Haskell to Python: import qualified Data.Vector.Unboxed.Mutable as V\nimport Data.STRef\nimport Control.Monad (forM_, when)\nimport Control.Monad.ST\n\ndir :: [(Int, Int)]\ndir = [(1, 0), (-1, 0), (0, -1), (0, 1)]\n\ndata Env = Env { w, h, len, count, ret :: !Int, next :: ![Int] }\n\ncutIt :: STRef s Env -> ST s ()\ncutIt env = do\n    e <- readSTRef env\n    when (odd $ h e) $ modifySTRef env $ \\en -> en { h = w e,\n        w = h e }\n    e <- readSTRef env\n    if odd (h e)\n        then modifySTRef env $ \\en -> en { ret = 0 }\n        else\n            if w e == 1\n            then modifySTRef env $ \\en -> en { ret = 1 }\n            else do\n                let blen = (h e + 1) * (w e + 1) - 1\n                    t = (h e `div` 2) * (w e + 1) + (w e `div` 2)\n                modifySTRef env $ \\en -> en { len = blen,\n                    count = 0,\n                    next = [ w e + 1, (negate $ w e) - 1, -1, 1] }\n                grid <- V.replicate (blen + 1) False\n                case odd (w e) of\n                    True -> do\n                        V.write grid t True\n                        V.write grid (t + 1) True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e1 <- readSTRef env\n                        let res1 = count e1\n                        modifySTRef env $ \\en -> en { count = 0 }\n                        walk grid (h e `div` 2 - 1) (w e `div` 2)\n                        modifySTRef env $ \\en -> en { ret = res1 +\n                            (count en * 2) }\n                    False -> do\n                        V.write grid t True\n                        walk grid (h e `div` 2) (w e `div` 2 - 1)\n                        e2 <- readSTRef env\n                        let count2 = count e2\n                        if h e == w e\n                            then modifySTRef env $ \\en -> en { ret =\n                                count2 * 2 }\n                            else do\n                                walk grid (h e `div` 2 - 1)\n                                    (w e `div` 2)\n                                modifySTRef env $ \\en -> en { ret =\n                                    count en }\n    where\n        walk grid y x = do\n            e <- readSTRef env\n            if y <= 0 || y >= h e || x <= 0 || x >= w e\n                then modifySTRef env $ \\en -> en { count = count en + 1 }\n                else do\n                    let t = y * (w e + 1) + x\n                    V.write grid t True\n                    V.write grid (len e - t) True\n                    forM_ (zip (next e) [0..3]) $ \\(n, d) -> do\n                        g <- V.read grid (t + n)\n                        when (not g) $\n                            walk grid (y + fst (dir !! d)) (x + snd (dir !! d))\n                    V.write grid t False\n                    V.write grid (len e - t) False\n\ncut :: (Int, Int) -> Int\ncut (x, y) = runST $ do\n    env <- newSTRef $ Env { w = y, h = x, len = 0, count = 0, ret = 0, next = [] }\n    cutIt env\n    result <- readSTRef env\n    return $ ret result\n\nmain :: IO ()\nmain = do\n    mapM_ (\\(x, y) -> when (even (x * y)) (putStrLn $ \n        show x ++ \" x \" ++ show y ++ \": \" ++ show (cut (x, y))))\n        [ (x, y) | x <- [1..10], y <- [1..x] ]\n", "target": "def cut_it(h, w):\n    dirs = ((1, 0), (-1, 0), (0, -1), (0, 1))\n    if h % 2: h, w = w, h\n    if h % 2: return 0\n    if w == 1: return 1\n    count = 0\n\n    next = [w + 1, -w - 1, -1, 1]\n    blen = (h + 1) * (w + 1) - 1\n    grid = [False] * (blen + 1)\n\n    def walk(y, x, count):\n        if not y or y == h or not x or x == w:\n            return count + 1\n\n        t = y * (w + 1) + x\n        grid[t] = grid[blen - t] = True\n\n        if not grid[t + next[0]]:\n            count = walk(y + dirs[0][0], x + dirs[0][1], count)\n        if not grid[t + next[1]]:\n            count = walk(y + dirs[1][0], x + dirs[1][1], count)\n        if not grid[t + next[2]]:\n            count = walk(y + dirs[2][0], x + dirs[2][1], count)\n        if not grid[t + next[3]]:\n            count = walk(y + dirs[3][0], x + dirs[3][1], count)\n\n        grid[t] = grid[blen - t] = False\n        return count\n\n    t = h // 2 * (w + 1) + w // 2\n    if w % 2:\n        grid[t] = grid[t + 1] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        res = count\n        count = 0\n        count = walk(h // 2 - 1, w // 2, count)\n        return res + count * 2\n    else:\n        grid[t] = True\n        count = walk(h // 2, w // 2 - 1, count)\n        if h == w:\n            return count * 2\n        count = walk(h // 2 - 1, w // 2, count)\n        return count\n\ndef main():\n    for w in xrange(1, 10):\n        for h in xrange(1, w + 1):\n            if not((w * h) % 2):\n                print \"%d x %d: %d\" % (w, h, cut_it(w, h))\n\nmain()\n"}
{"id": 418815, "name": "Cuban primes", "source": "Translate Haskell to Python: import Data.Numbers.Primes (isPrime)\nimport Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Text.Printf (printf)\n\ncubans :: [Int]\ncubans = filter isPrime . map (\\x -> (succ x ^ 3) - (x ^ 3)) $ [1 ..]\n\nmain :: IO ()\nmain = do\n  mapM_ (\\row -> mapM_ (printf \"%10s\" . thousands) row >> printf \"\\n\") $ rows cubans\n  printf \"\\nThe 100,000th cuban prime is: %10s\\n\" $ thousands $ cubans !! 99999\n  where\n    rows = chunksOf 10 . take 200\n    thousands = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n", "target": "import datetime\nimport math\n\nprimes = [ 3, 5 ]\n\ncutOff = 200\n\nbigUn =  100_000\nchunks = 50\nlittle = bigUn / chunks\n\ntn = \" cuban prime\"\nprint (\"The first {:,}{}s:\".format(cutOff, tn))\n\nc = 0\nshowEach = True\nu = 0\nv = 1\nst = datetime.datetime.now()\n\nfor i in range(1, int(math.pow(2,20))):\n\tfound = False\n\tu += 6\n\tv += u\n\tmx = int(math.sqrt(v))\n\t\n\tfor item in primes:\n\t\tif (item > mx):\n\t\t\tbreak\n\t\tif (v % item == 0):\n\t\t\tfound = True\n\t\t\tbreak\n\t\n\tif (found == 0):\n\t\tc += 1\n\t\tif (showEach):\n\t\t\tz = primes[-1]\n\t\t\twhile (z <= v - 2):\n\t\t\t\tz += 2\n\t\t\t\t\n\t\t\t\tfnd = False\n\t\t\t\tfor item in primes:\n\t\t\t\t\tif (item > mx):\n\t\t\t\t\t\tbreak\n\t\t\t\t\tif (z % item == 0):\n\t\t\t\t\t\tfnd = True\n\t\t\t\t\t\tbreak\n\t\t\t\t\n\t\t\t\tif (not fnd):\n\t\t\t\t\tprimes.append(z)\n\t\t\t\n\t\t\tprimes.append(v)\n\t\t\tprint(\"{:>11,}\".format(v), end='')\n\t\t\t\n\t\t\tif (c % 10 == 0):\n\t\t\t\tprint(\"\");\n\t\t\tif (c == cutOff):\n\t\t\t\tshowEach = False\n\t\t\t\tprint (\"Progress to the {:,}th {}:\".format(bigUn, tn), end='')\n\t\tif (c % little == 0):\n\t\t\tprint('.', end='')\n\t\tif (c == bigUn):\n\t\t\tbreak\n\nprint(\"\");\nprint (\"The {:,}th{} is {:,}\".format(c, tn, v))\nprint(\"Computation time was {} seconds\".format((datetime.datetime.now() - st).seconds))\n"}
{"id": 418816, "name": "Chaos game", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\nimport Control.Monad.Random (fromList)\n\ntype Point = (Float,Float)\ntype Transformations = [(Point -> Point, Float)] \n\n\ngameOfChaos :: MonadRandom m => Int -> Transformations -> Point -> m [Point]\ngameOfChaos n transformations x = iterateA (fromList transformations) x\n  where iterateA f x = scanr ($) x <$> replicateM n f\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 418817, "name": "Chaos game", "source": "Translate Haskell to Python: import Control.Monad (replicateM)\nimport Control.Monad.Random (fromList)\n\ntype Point = (Float,Float)\ntype Transformations = [(Point -> Point, Float)] \n\n\ngameOfChaos :: MonadRandom m => Int -> Transformations -> Point -> m [Point]\ngameOfChaos n transformations x = iterateA (fromList transformations) x\n  where iterateA f x = scanr ($) x <$> replicateM n f\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 418818, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Haskell to Python: import Text.Printf\n\nprec :: String -> Int\nprec \"^\" = 4\nprec \"*\" = 3\nprec \"/\" = 3\nprec \"+\" = 2\nprec \"-\" = 2\n\nleftAssoc :: String -> Bool\nleftAssoc \"^\" = False\nleftAssoc _ = True\n\nisOp :: String -> Bool\nisOp [t] = t `elem` \"-+/*^\"\nisOp _ = False\n\nsimSYA :: [String] -> [([String], [String], String)]\nsimSYA xs = final <> [lastStep]\n  where\n    final = scanl f ([], [], \"\") xs\n    lastStep =\n      ( \\(x, y, _) ->\n          (reverse y <> x, [], \"\")\n      )\n        $ last final\n    f (out, st, _) t\n      | isOp t =\n        ( reverse (takeWhile testOp st) <> out,\n          (t :) (dropWhile testOp st),\n          t\n        )\n      | t == \"(\" = (out, \"(\" : st, t)\n      | t == \")\" =\n        ( reverse (takeWhile (/= \"(\") st) <> out,\n          tail $ dropWhile (/= \"(\") st,\n          t\n        )\n      | otherwise = (t : out, st, t)\n      where\n        testOp x =\n          isOp x\n            && ( leftAssoc t && prec t == prec x\n                   || prec t < prec x\n               )\n\nmain :: IO ()\nmain = do\n  a <- getLine\n  printf \"%30s%20s%7s\" \"Output\" \"Stack\" \"Token\"\n  mapM_\n    ( \\(x, y, z) ->\n        printf\n          \"%30s%20s%7s\\n\"\n          (unwords $ reverse x)\n          (unwords y)\n          z\n    )\n    $ simSYA $ words a\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\n\nOpInfo = namedtuple('OpInfo', 'prec assoc')\nL, R = 'Left Right'.split()\n\nops = {\n '^': OpInfo(prec=4, assoc=R),\n '*': OpInfo(prec=3, assoc=L),\n '/': OpInfo(prec=3, assoc=L),\n '+': OpInfo(prec=2, assoc=L),\n '-': OpInfo(prec=2, assoc=L),\n '(': OpInfo(prec=9, assoc=L),\n ')': OpInfo(prec=0, assoc=L),\n }\n\nNUM, LPAREN, RPAREN = 'NUMBER ( )'.split()\n\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    tokenvals = []\n    for token in tokens:\n        if token in ops:\n            tokenvals.append((token, ops[token]))\n        \n        \n        else:    \n            tokenvals.append((NUM, token))\n    return tokenvals\n\ndef shunting(tokenvals):\n    outq, stack = [], []\n    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]\n    for token, val in tokenvals:\n        note = action = ''\n        if token is NUM:\n            action = 'Add number to output'\n            outq.append(val)\n            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        elif token in ops:\n            t1, (p1, a1) = token, val\n            v = t1\n            note = 'Pop ops from stack to output' \n            while stack:\n                t2, (p2, a2) = stack[-1]\n                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):\n                    if t1 != RPAREN:\n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            break\n                    else:        \n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            stack.pop()\n                            action = '(Pop & discard \"(\")'\n                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                            break\n                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                    v = note = ''\n                else:\n                    note = ''\n                    break\n                note = '' \n            note = '' \n            if t1 != RPAREN:\n                stack.append((token, val))\n                action = 'Push op token to stack'\n            else:\n                action = 'Discard \")\"'\n            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n    note = 'Drain stack to output'\n    while stack:\n        v = ''\n        t2, (p2, a2) = stack[-1]\n        action = '(Pop op)'\n        stack.pop()\n        outq.append(t2)\n        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        v = note = ''\n    return table\n\nif __name__ == '__main__':\n    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'\n    print( 'For infix expression: %r\\n' % infix )\n    rp = shunting(get_input(infix))\n    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output RPN is: %r' % rp[-1][2])\n"}
{"id": 418819, "name": "A_ search algorithm", "source": "Translate Haskell to Python: \n\nmodule PQueue where\n\ndata PQueue a = EmptyQueue\n              | Node (Int, a) (PQueue a) (PQueue a)\n  deriving (Show, Foldable)\n\ninstance Ord a => Semigroup (PQueue a) where\n  h1@(Node (w1, x1) l1 r1) <> h2@(Node (w2, x2) l2 r2)\n    | w1 < w2   = Node (w1, x1) (h2 <> r1) l1\n    | otherwise = Node (w2, x2) (h1 <> r2) l2\n  EmptyQueue <> h = h\n  h <> EmptyQueue = h\n\nentry :: Ord a => a -> Int -> PQueue a\nentry x w = Node (w, x) EmptyQueue EmptyQueue\n\nenque :: Ord a => PQueue a -> a -> Int -> PQueue a\nenque q x w = if x `notElem` q\n              then entry x w <> q\n              else q\n\ndeque :: Ord a => PQueue a -> Maybe (a, PQueue a)\ndeque q = case q of\n            EmptyQueue -> Nothing\n            Node (_, x) l r -> Just (x, l <> r)\n", "target": "from __future__ import print_function\nimport matplotlib.pyplot as plt\n\nclass AStarGraph(object):\n\t\n\n\tdef __init__(self):\n\t\tself.barriers = []\n\t\tself.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\n\n\tdef heuristic(self, start, goal):\n\t\t\n\t\t\n\t\tD = 1\n\t\tD2 = 1\n\t\tdx = abs(start[0] - goal[0])\n\t\tdy = abs(start[1] - goal[1])\n\t\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\n\tdef get_vertex_neighbours(self, pos):\n\t\tn = []\n\t\t\n\t\tfor dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\n\t\t\tx2 = pos[0] + dx\n\t\t\ty2 = pos[1] + dy\n\t\t\tif x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\n\t\t\t\tcontinue\n\t\t\tn.append((x2, y2))\n\t\treturn n\n\n\tdef move_cost(self, a, b):\n\t\tfor barrier in self.barriers:\n\t\t\tif b in barrier:\n\t\t\t\treturn 100 \n\t\treturn 1 \n\ndef AStarSearch(start, end, graph):\n\n\tG = {} \n\tF = {} \n\n\t\n\tG[start] = 0\n\tF[start] = graph.heuristic(start, end)\n\n\tclosedVertices = set()\n\topenVertices = set([start])\n\tcameFrom = {}\n\n\twhile len(openVertices) > 0:\n\t\t\n\t\tcurrent = None\n\t\tcurrentFscore = None\n\t\tfor pos in openVertices:\n\t\t\tif current is None or F[pos] < currentFscore:\n\t\t\t\tcurrentFscore = F[pos]\n\t\t\t\tcurrent = pos\n\n\t\t\n\t\tif current == end:\n\t\t\t\n\t\t\tpath = [current]\n\t\t\twhile current in cameFrom:\n\t\t\t\tcurrent = cameFrom[current]\n\t\t\t\tpath.append(current)\n\t\t\tpath.reverse()\n\t\t\treturn path, F[end] \n\n\t\t\n\t\topenVertices.remove(current)\n\t\tclosedVertices.add(current)\n\n\t\t\n\t\tfor neighbour in graph.get_vertex_neighbours(current):\n\t\t\tif neighbour in closedVertices:\n\t\t\t\tcontinue \n\t\t\tcandidateG = G[current] + graph.move_cost(current, neighbour)\n\n\t\t\tif neighbour not in openVertices:\n\t\t\t\topenVertices.add(neighbour) \n\t\t\telif candidateG >= G[neighbour]:\n\t\t\t\tcontinue \n\n\t\t\t\n\t\t\tcameFrom[neighbour] = current\n\t\t\tG[neighbour] = candidateG\n\t\t\tH = graph.heuristic(neighbour, end)\n\t\t\tF[neighbour] = G[neighbour] + H\n\n\traise RuntimeError(\"A* failed to find a solution\")\n\nif __name__==\"__main__\":\n\tgraph = AStarGraph()\n\tresult, cost = AStarSearch((0,0), (7,7), graph)\n\tprint (\"route\", result)\n\tprint (\"cost\", cost)\n\tplt.plot([v[0] for v in result], [v[1] for v in result])\n\tfor barrier in graph.barriers:\n\t\tplt.plot([v[0] for v in barrier], [v[1] for v in barrier])\n\tplt.xlim(-1,8)\n\tplt.ylim(-1,8)\n\tplt.show()\n"}
{"id": 418820, "name": "A_ search algorithm", "source": "Translate Haskell to Python: \n\nmodule PQueue where\n\ndata PQueue a = EmptyQueue\n              | Node (Int, a) (PQueue a) (PQueue a)\n  deriving (Show, Foldable)\n\ninstance Ord a => Semigroup (PQueue a) where\n  h1@(Node (w1, x1) l1 r1) <> h2@(Node (w2, x2) l2 r2)\n    | w1 < w2   = Node (w1, x1) (h2 <> r1) l1\n    | otherwise = Node (w2, x2) (h1 <> r2) l2\n  EmptyQueue <> h = h\n  h <> EmptyQueue = h\n\nentry :: Ord a => a -> Int -> PQueue a\nentry x w = Node (w, x) EmptyQueue EmptyQueue\n\nenque :: Ord a => PQueue a -> a -> Int -> PQueue a\nenque q x w = if x `notElem` q\n              then entry x w <> q\n              else q\n\ndeque :: Ord a => PQueue a -> Maybe (a, PQueue a)\ndeque q = case q of\n            EmptyQueue -> Nothing\n            Node (_, x) l r -> Just (x, l <> r)\n", "target": "from __future__ import print_function\nimport matplotlib.pyplot as plt\n\nclass AStarGraph(object):\n\t\n\n\tdef __init__(self):\n\t\tself.barriers = []\n\t\tself.barriers.append([(2,4),(2,5),(2,6),(3,6),(4,6),(5,6),(5,5),(5,4),(5,3),(5,2),(4,2),(3,2)])\n\n\tdef heuristic(self, start, goal):\n\t\t\n\t\t\n\t\tD = 1\n\t\tD2 = 1\n\t\tdx = abs(start[0] - goal[0])\n\t\tdy = abs(start[1] - goal[1])\n\t\treturn D * (dx + dy) + (D2 - 2 * D) * min(dx, dy)\n\n\tdef get_vertex_neighbours(self, pos):\n\t\tn = []\n\t\t\n\t\tfor dx, dy in [(1,0),(-1,0),(0,1),(0,-1),(1,1),(-1,1),(1,-1),(-1,-1)]:\n\t\t\tx2 = pos[0] + dx\n\t\t\ty2 = pos[1] + dy\n\t\t\tif x2 < 0 or x2 > 7 or y2 < 0 or y2 > 7:\n\t\t\t\tcontinue\n\t\t\tn.append((x2, y2))\n\t\treturn n\n\n\tdef move_cost(self, a, b):\n\t\tfor barrier in self.barriers:\n\t\t\tif b in barrier:\n\t\t\t\treturn 100 \n\t\treturn 1 \n\ndef AStarSearch(start, end, graph):\n\n\tG = {} \n\tF = {} \n\n\t\n\tG[start] = 0\n\tF[start] = graph.heuristic(start, end)\n\n\tclosedVertices = set()\n\topenVertices = set([start])\n\tcameFrom = {}\n\n\twhile len(openVertices) > 0:\n\t\t\n\t\tcurrent = None\n\t\tcurrentFscore = None\n\t\tfor pos in openVertices:\n\t\t\tif current is None or F[pos] < currentFscore:\n\t\t\t\tcurrentFscore = F[pos]\n\t\t\t\tcurrent = pos\n\n\t\t\n\t\tif current == end:\n\t\t\t\n\t\t\tpath = [current]\n\t\t\twhile current in cameFrom:\n\t\t\t\tcurrent = cameFrom[current]\n\t\t\t\tpath.append(current)\n\t\t\tpath.reverse()\n\t\t\treturn path, F[end] \n\n\t\t\n\t\topenVertices.remove(current)\n\t\tclosedVertices.add(current)\n\n\t\t\n\t\tfor neighbour in graph.get_vertex_neighbours(current):\n\t\t\tif neighbour in closedVertices:\n\t\t\t\tcontinue \n\t\t\tcandidateG = G[current] + graph.move_cost(current, neighbour)\n\n\t\t\tif neighbour not in openVertices:\n\t\t\t\topenVertices.add(neighbour) \n\t\t\telif candidateG >= G[neighbour]:\n\t\t\t\tcontinue \n\n\t\t\t\n\t\t\tcameFrom[neighbour] = current\n\t\t\tG[neighbour] = candidateG\n\t\t\tH = graph.heuristic(neighbour, end)\n\t\t\tF[neighbour] = G[neighbour] + H\n\n\traise RuntimeError(\"A* failed to find a solution\")\n\nif __name__==\"__main__\":\n\tgraph = AStarGraph()\n\tresult, cost = AStarSearch((0,0), (7,7), graph)\n\tprint (\"route\", result)\n\tprint (\"cost\", cost)\n\tplt.plot([v[0] for v in result], [v[1] for v in result])\n\tfor barrier in graph.barriers:\n\t\tplt.plot([v[0] for v in barrier], [v[1] for v in barrier])\n\tplt.xlim(-1,8)\n\tplt.ylim(-1,8)\n\tplt.show()\n"}
{"id": 418821, "name": "Nonogram solver", "source": "Translate Haskell to Python: import           Control.Applicative          ((<|>))\nimport           Control.Monad\nimport           Control.Monad.CSP\nimport           Data.List                    (transpose)\nimport           System.Environment           (getArgs)\nimport           Text.ParserCombinators.ReadP (ReadP)\nimport qualified Text.ParserCombinators.ReadP as P\nimport           Text.Printf                  (printf)\n\nmain :: IO ()\nmain = do\n    file <- parseArgs\n    printf \"reading problem file from %s\\n\" file\n    ps <- parseProblems file\n    forM_ ps $ \\p -> do\n        print p\n        putStrLn \"\"\n        printSolution $ solve p\n        putStrLn \"\"\n\n\n\n\n\nparseArgs :: IO FilePath\nparseArgs = do\n    args <- getArgs\n    case args of\n        [file] -> return file\n        _      -> ioError $ userError \"expected exactly one command line argument, the name of the problem file\"\n\ndata Problem = Problem\n    { rows :: [[Int]]\n    , cols :: [[Int]]\n    } deriving (Show, Read, Eq, Ord)\n\nentryP :: ReadP Int\nentryP = do\n    n <- fromEnum <$> P.get\n    if n < 65 || n > 90\n        then P.pfail\n        else return $ n - 64\n\nblankP, eolP :: ReadP Char\nblankP = P.char ' '\neolP   = P.char '\\n'\n\nentriesP :: ReadP [Int]\nentriesP = ([] <$ blankP) <|> P.many1 entryP\n\nlineP :: ReadP [[Int]]\nlineP = P.sepBy1 entriesP blankP <* eolP\n\nproblemP :: ReadP Problem\nproblemP = Problem <$> lineP <*> lineP\n\nproblemsP :: ReadP [Problem]\nproblemsP = P.sepBy1 problemP (P.many blankP <* eolP) <* P.eof\n\nparseProblems :: FilePath -> IO [Problem]\nparseProblems file = do\n    s <- readFile file\n    case P.readP_to_S problemsP s of\n        [(ps, \"\")] -> return ps\n        _          -> ioError $ userError $ \"error parsing file \" <> file\n\n\n\n\n\nsolve :: Problem -> [[Bool]]\nsolve = oneCSPSolution . problemCSP\n\nproblemCSP :: Problem -> CSP r [[DV r Bool]]\nproblemCSP p = do\n    let rowCount = length $ rows p\n        colCount = length $ cols p\n    cells <- replicateM rowCount\n           $ replicateM colCount\n           $ mkDV [False, True]\n\n    forM_ (zip cells             $ rows p) $ uncurry rowOrColCSP\n    forM_ (zip (transpose cells) $ cols p) $ uncurry rowOrColCSP\n\n    return cells\n\nrowOrColCSP :: [DV r Bool] -> [Int] -> CSP r ()\nrowOrColCSP ws [] = forM_ ws $ constraint1 not\nrowOrColCSP ws xs = do\n    let vs = zip [0 ..] ws\n        n  = length ws\n\n    blocks <- forM xs $ \\x ->\n        mkDV [(i, i + x - 1) | i <- [0 .. n - x]] \n\n    \n    f blocks\n\n    \n    forM_ blocks $ \\x ->\n        forM_ vs $ \\(i, y) ->\n            constraint2 (\\(x1, x2) b -> i < x1 || i > x2 || b) x y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(y', _) b -> i >= y' || not b) (head blocks) y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(_, y') b -> i <= y' || not b) (last blocks) y\n\n    \n    forM_ (zip blocks $ tail blocks) $ \\(x, y) ->\n        forM_ vs $ \\(i, z) ->\n            constraint3 (\\(_, x') (y', _) b -> i <= x' || i >= y' || not b) x y z\n  where\n    f :: [DV r (Int, Int)] -> CSP r ()\n    f (u : v : bs) = do\n        constraint2 (\\(_, u') (v', _) -> v' >= u' + 2)  u v\n        f $ v : bs\n    f _            = return ()\n\n\n\n\n\nprintSolution :: [[Bool]] -> IO ()\nprintSolution bss =\n    forM_ bss $ \\bs -> do\n        forM_ bs $ \\b ->\n            putChar $ if b then '#' else '.'\n        putChar '\\n'\n", "target": "from itertools import izip\n\ndef gen_row(w, s):\n    \n    def gen_seg(o, sp):\n        if not o:\n            return [[2] * sp]\n        return [[2] * x + o[0] + tail\n                for x in xrange(1, sp - len(o) + 2)\n                for tail in gen_seg(o[1:], sp - x)]\n\n    return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]\n\n\ndef deduce(hr, vr):\n    \n    def allowable(row):\n        return reduce(lambda a, b: [x | y for x, y in izip(a, b)], row)\n\n    def fits(a, b):\n        return all(x & y for x, y in izip(a, b))\n\n    def fix_col(n):\n        \n        c = [x[n] for x in can_do]\n        cols[n] = [x for x in cols[n] if fits(x, c)]\n        for i, x in enumerate(allowable(cols[n])):\n            if x != can_do[i][n]:\n                mod_rows.add(i)\n                can_do[i][n] &= x\n\n    def fix_row(n):\n        \n        c = can_do[n]\n        rows[n] = [x for x in rows[n] if fits(x, c)]\n        for i, x in enumerate(allowable(rows[n])):\n            if x != can_do[n][i]:\n                mod_cols.add(i)\n                can_do[n][i] &= x\n\n    def show_gram(m):\n        \n        \n        for x in m:\n            print \" \".join(\"x\n        print\n\n    w, h = len(vr), len(hr)\n    rows = [gen_row(w, x) for x in hr]\n    cols = [gen_row(h, x) for x in vr]\n    can_do = map(allowable, rows)\n\n    \n    mod_rows, mod_cols = set(), set(xrange(w))\n\n    while mod_cols:\n        for i in mod_cols:\n            fix_col(i)\n        mod_cols = set()\n        for i in mod_rows:\n            fix_row(i)\n        mod_rows = set()\n\n    if all(can_do[i][j] in (1, 2) for j in xrange(w) for i in xrange(h)):\n        print \"Solution would be unique\" \n    else:\n        print \"Solution may not be unique, doing exhaustive search:\"\n\n    \n    \n    \n    out = [0] * h\n\n    def try_all(n = 0):\n        if n >= h:\n            for j in xrange(w):\n                if [x[j] for x in out] not in cols[j]:\n                    return 0\n            show_gram(out)\n            return 1\n        sol = 0\n        for x in rows[n]:\n            out[n] = x\n            sol += try_all(n + 1)\n        return sol\n\n    n = try_all()\n    if not n:\n        print \"No solution.\"\n    elif n == 1:\n        print \"Unique solution.\"\n    else:\n        print n, \"solutions.\"\n    print\n\n\ndef solve(p, show_runs=True):\n    s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]\n         for l in p.splitlines()]\n    if show_runs:\n        print \"Horizontal runs:\", s[0]\n        print \"Vertical runs:\", s[1]\n    deduce(s[0], s[1])\n\n\ndef main():\n    \n    fn = \"nonogram_problems.txt\"\n    for p in (x for x in open(fn).read().split(\"\\n\\n\") if x):\n        solve(p)\n\n    print \"Extra example not solvable by deduction alone:\"\n    solve(\"B B A A\\nB B A A\")\n\n    print \"Extra example where there is no solution:\"\n    solve(\"B A A\\nA A A\")\n\nmain()\n"}
{"id": 418822, "name": "Nonogram solver", "source": "Translate Haskell to Python: import           Control.Applicative          ((<|>))\nimport           Control.Monad\nimport           Control.Monad.CSP\nimport           Data.List                    (transpose)\nimport           System.Environment           (getArgs)\nimport           Text.ParserCombinators.ReadP (ReadP)\nimport qualified Text.ParserCombinators.ReadP as P\nimport           Text.Printf                  (printf)\n\nmain :: IO ()\nmain = do\n    file <- parseArgs\n    printf \"reading problem file from %s\\n\" file\n    ps <- parseProblems file\n    forM_ ps $ \\p -> do\n        print p\n        putStrLn \"\"\n        printSolution $ solve p\n        putStrLn \"\"\n\n\n\n\n\nparseArgs :: IO FilePath\nparseArgs = do\n    args <- getArgs\n    case args of\n        [file] -> return file\n        _      -> ioError $ userError \"expected exactly one command line argument, the name of the problem file\"\n\ndata Problem = Problem\n    { rows :: [[Int]]\n    , cols :: [[Int]]\n    } deriving (Show, Read, Eq, Ord)\n\nentryP :: ReadP Int\nentryP = do\n    n <- fromEnum <$> P.get\n    if n < 65 || n > 90\n        then P.pfail\n        else return $ n - 64\n\nblankP, eolP :: ReadP Char\nblankP = P.char ' '\neolP   = P.char '\\n'\n\nentriesP :: ReadP [Int]\nentriesP = ([] <$ blankP) <|> P.many1 entryP\n\nlineP :: ReadP [[Int]]\nlineP = P.sepBy1 entriesP blankP <* eolP\n\nproblemP :: ReadP Problem\nproblemP = Problem <$> lineP <*> lineP\n\nproblemsP :: ReadP [Problem]\nproblemsP = P.sepBy1 problemP (P.many blankP <* eolP) <* P.eof\n\nparseProblems :: FilePath -> IO [Problem]\nparseProblems file = do\n    s <- readFile file\n    case P.readP_to_S problemsP s of\n        [(ps, \"\")] -> return ps\n        _          -> ioError $ userError $ \"error parsing file \" <> file\n\n\n\n\n\nsolve :: Problem -> [[Bool]]\nsolve = oneCSPSolution . problemCSP\n\nproblemCSP :: Problem -> CSP r [[DV r Bool]]\nproblemCSP p = do\n    let rowCount = length $ rows p\n        colCount = length $ cols p\n    cells <- replicateM rowCount\n           $ replicateM colCount\n           $ mkDV [False, True]\n\n    forM_ (zip cells             $ rows p) $ uncurry rowOrColCSP\n    forM_ (zip (transpose cells) $ cols p) $ uncurry rowOrColCSP\n\n    return cells\n\nrowOrColCSP :: [DV r Bool] -> [Int] -> CSP r ()\nrowOrColCSP ws [] = forM_ ws $ constraint1 not\nrowOrColCSP ws xs = do\n    let vs = zip [0 ..] ws\n        n  = length ws\n\n    blocks <- forM xs $ \\x ->\n        mkDV [(i, i + x - 1) | i <- [0 .. n - x]] \n\n    \n    f blocks\n\n    \n    forM_ blocks $ \\x ->\n        forM_ vs $ \\(i, y) ->\n            constraint2 (\\(x1, x2) b -> i < x1 || i > x2 || b) x y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(y', _) b -> i >= y' || not b) (head blocks) y\n\n    \n    forM_ vs $ \\(i, y) ->\n        constraint2 (\\(_, y') b -> i <= y' || not b) (last blocks) y\n\n    \n    forM_ (zip blocks $ tail blocks) $ \\(x, y) ->\n        forM_ vs $ \\(i, z) ->\n            constraint3 (\\(_, x') (y', _) b -> i <= x' || i >= y' || not b) x y z\n  where\n    f :: [DV r (Int, Int)] -> CSP r ()\n    f (u : v : bs) = do\n        constraint2 (\\(_, u') (v', _) -> v' >= u' + 2)  u v\n        f $ v : bs\n    f _            = return ()\n\n\n\n\n\nprintSolution :: [[Bool]] -> IO ()\nprintSolution bss =\n    forM_ bss $ \\bs -> do\n        forM_ bs $ \\b ->\n            putChar $ if b then '#' else '.'\n        putChar '\\n'\n", "target": "from itertools import izip\n\ndef gen_row(w, s):\n    \n    def gen_seg(o, sp):\n        if not o:\n            return [[2] * sp]\n        return [[2] * x + o[0] + tail\n                for x in xrange(1, sp - len(o) + 2)\n                for tail in gen_seg(o[1:], sp - x)]\n\n    return [x[1:] for x in gen_seg([[1] * i for i in s], w + 1 - sum(s))]\n\n\ndef deduce(hr, vr):\n    \n    def allowable(row):\n        return reduce(lambda a, b: [x | y for x, y in izip(a, b)], row)\n\n    def fits(a, b):\n        return all(x & y for x, y in izip(a, b))\n\n    def fix_col(n):\n        \n        c = [x[n] for x in can_do]\n        cols[n] = [x for x in cols[n] if fits(x, c)]\n        for i, x in enumerate(allowable(cols[n])):\n            if x != can_do[i][n]:\n                mod_rows.add(i)\n                can_do[i][n] &= x\n\n    def fix_row(n):\n        \n        c = can_do[n]\n        rows[n] = [x for x in rows[n] if fits(x, c)]\n        for i, x in enumerate(allowable(rows[n])):\n            if x != can_do[n][i]:\n                mod_cols.add(i)\n                can_do[n][i] &= x\n\n    def show_gram(m):\n        \n        \n        for x in m:\n            print \" \".join(\"x\n        print\n\n    w, h = len(vr), len(hr)\n    rows = [gen_row(w, x) for x in hr]\n    cols = [gen_row(h, x) for x in vr]\n    can_do = map(allowable, rows)\n\n    \n    mod_rows, mod_cols = set(), set(xrange(w))\n\n    while mod_cols:\n        for i in mod_cols:\n            fix_col(i)\n        mod_cols = set()\n        for i in mod_rows:\n            fix_row(i)\n        mod_rows = set()\n\n    if all(can_do[i][j] in (1, 2) for j in xrange(w) for i in xrange(h)):\n        print \"Solution would be unique\" \n    else:\n        print \"Solution may not be unique, doing exhaustive search:\"\n\n    \n    \n    \n    out = [0] * h\n\n    def try_all(n = 0):\n        if n >= h:\n            for j in xrange(w):\n                if [x[j] for x in out] not in cols[j]:\n                    return 0\n            show_gram(out)\n            return 1\n        sol = 0\n        for x in rows[n]:\n            out[n] = x\n            sol += try_all(n + 1)\n        return sol\n\n    n = try_all()\n    if not n:\n        print \"No solution.\"\n    elif n == 1:\n        print \"Unique solution.\"\n    else:\n        print n, \"solutions.\"\n    print\n\n\ndef solve(p, show_runs=True):\n    s = [[[ord(c) - ord('A') + 1 for c in w] for w in l.split()]\n         for l in p.splitlines()]\n    if show_runs:\n        print \"Horizontal runs:\", s[0]\n        print \"Vertical runs:\", s[1]\n    deduce(s[0], s[1])\n\n\ndef main():\n    \n    fn = \"nonogram_problems.txt\"\n    for p in (x for x in open(fn).read().split(\"\\n\\n\") if x):\n        solve(p)\n\n    print \"Extra example not solvable by deduction alone:\"\n    solve(\"B B A A\\nB B A A\")\n\n    print \"Extra example where there is no solution:\"\n    solve(\"B A A\\nA A A\")\n\nmain()\n"}
{"id": 418823, "name": "Almkvist-Giullera formula for pi", "source": "Translate Haskell to Python: import Control.Monad\nimport Data.Number.CReal\nimport GHC.Integer\nimport Text.Printf\n\niterations = 52\nmain = do\n  printf \"N. %44s %4s %s\\n\" \n          \"Integral part of Nth term\" \"\u00d710^\" \"=Actual value of Nth term\"\n\n  forM_ [0..9] $ \\n ->\n    printf \"%d. %44d %4d %s\\n\" n\n                               (almkvistGiulleraIntegral n)\n                               (tenExponent n)\n                               (showCReal 50 (almkvistGiullera n))\n\n  printf \"\\nPi after %d iterations:\\n\" iterations\n  putStrLn $ showCReal 70 $ almkvistGiulleraPi iterations\n\n\nalmkvistGiulleraIntegral n =\n  let polynomial  = (532 `timesInteger` n `timesInteger` n) `plusInteger` (126 `timesInteger` n) `plusInteger` 9\n      numerator   = 32 `timesInteger` (facInteger (6 `timesInteger` n)) `timesInteger` polynomial\n      denominator = 3 `timesInteger` (powInteger (facInteger n) 6)\n   in numerator `divInteger` denominator\n\n\ntenExponent n = 3 `minusInteger` (6 `timesInteger` (1 `plusInteger` n))\n\n\nalmkvistGiullera n = fromInteger (almkvistGiulleraIntegral n) / fromInteger (powInteger 10 (abs (tenExponent n)))\n\n\nalmkvistGiulleraSum n = sum $ map almkvistGiullera [0 .. n]\n\n\nalmkvistGiulleraPi n = sqrt $ 1 / almkvistGiulleraSum n\n\n\nfacInteger n = if n `leInteger` 1 then 1 else n `timesInteger` facInteger (n `minusInteger` 1)\n\n\npowInteger 1 _ = 1\npowInteger _ 0 = 1\npowInteger b 1 = b\npowInteger b e = b `timesInteger` powInteger b (e `minusInteger` 1)\n", "target": "import mpmath as mp\n\nwith mp.workdps(72):\n\n    def integer_term(n):\n        p = 532 * n * n + 126 * n + 9\n        return (p * 2**5 * mp.factorial(6 * n)) / (3 * mp.factorial(n)**6)\n\n    def exponent_term(n):\n        return -(mp.mpf(\"6.0\") * n + 3)\n\n    def nthterm(n):\n        return integer_term(n) * mp.mpf(\"10.0\")**exponent_term(n)\n\n\n    for n in range(10):\n        print(\"Term \", n, '  ', int(integer_term(n)))\n\n\n    def almkvist_guillera(floatprecision):\n        summed, nextadd = mp.mpf('0.0'), mp.mpf('0.0')\n        for n in range(100000000):\n            nextadd = summed + nthterm(n)\n            if abs(nextadd - summed) < 10.0**(-floatprecision):\n                break\n\n            summed = nextadd\n\n        return nextadd\n\n\n    print('\\n\u03c0 to 70 digits is ', end='')\n    mp.nprint(mp.mpf(1.0 / mp.sqrt(almkvist_guillera(70))), 71)\n    print('mpmath \u03c0 is       ', end='')\n    mp.nprint(mp.pi, 71)\n"}
{"id": 418824, "name": "Almkvist-Giullera formula for pi", "source": "Translate Haskell to Python: import Control.Monad\nimport Data.Number.CReal\nimport GHC.Integer\nimport Text.Printf\n\niterations = 52\nmain = do\n  printf \"N. %44s %4s %s\\n\" \n          \"Integral part of Nth term\" \"\u00d710^\" \"=Actual value of Nth term\"\n\n  forM_ [0..9] $ \\n ->\n    printf \"%d. %44d %4d %s\\n\" n\n                               (almkvistGiulleraIntegral n)\n                               (tenExponent n)\n                               (showCReal 50 (almkvistGiullera n))\n\n  printf \"\\nPi after %d iterations:\\n\" iterations\n  putStrLn $ showCReal 70 $ almkvistGiulleraPi iterations\n\n\nalmkvistGiulleraIntegral n =\n  let polynomial  = (532 `timesInteger` n `timesInteger` n) `plusInteger` (126 `timesInteger` n) `plusInteger` 9\n      numerator   = 32 `timesInteger` (facInteger (6 `timesInteger` n)) `timesInteger` polynomial\n      denominator = 3 `timesInteger` (powInteger (facInteger n) 6)\n   in numerator `divInteger` denominator\n\n\ntenExponent n = 3 `minusInteger` (6 `timesInteger` (1 `plusInteger` n))\n\n\nalmkvistGiullera n = fromInteger (almkvistGiulleraIntegral n) / fromInteger (powInteger 10 (abs (tenExponent n)))\n\n\nalmkvistGiulleraSum n = sum $ map almkvistGiullera [0 .. n]\n\n\nalmkvistGiulleraPi n = sqrt $ 1 / almkvistGiulleraSum n\n\n\nfacInteger n = if n `leInteger` 1 then 1 else n `timesInteger` facInteger (n `minusInteger` 1)\n\n\npowInteger 1 _ = 1\npowInteger _ 0 = 1\npowInteger b 1 = b\npowInteger b e = b `timesInteger` powInteger b (e `minusInteger` 1)\n", "target": "import mpmath as mp\n\nwith mp.workdps(72):\n\n    def integer_term(n):\n        p = 532 * n * n + 126 * n + 9\n        return (p * 2**5 * mp.factorial(6 * n)) / (3 * mp.factorial(n)**6)\n\n    def exponent_term(n):\n        return -(mp.mpf(\"6.0\") * n + 3)\n\n    def nthterm(n):\n        return integer_term(n) * mp.mpf(\"10.0\")**exponent_term(n)\n\n\n    for n in range(10):\n        print(\"Term \", n, '  ', int(integer_term(n)))\n\n\n    def almkvist_guillera(floatprecision):\n        summed, nextadd = mp.mpf('0.0'), mp.mpf('0.0')\n        for n in range(100000000):\n            nextadd = summed + nthterm(n)\n            if abs(nextadd - summed) < 10.0**(-floatprecision):\n                break\n\n            summed = nextadd\n\n        return nextadd\n\n\n    print('\\n\u03c0 to 70 digits is ', end='')\n    mp.nprint(mp.mpf(1.0 / mp.sqrt(almkvist_guillera(70))), 71)\n    print('mpmath \u03c0 is       ', end='')\n    mp.nprint(mp.pi, 71)\n"}
{"id": 418825, "name": "Lychrel numbers", "source": "Translate Haskell to Python: module Main where\n\nimport Data.List\n\nprocLychrel :: Integer -> [Integer]\nprocLychrel a = a : pl a\n  where\n    pl n =\n        let s = n + reverseInteger n\n             in if isPalindrome s\n                  then [s]\n                  else s : pl s\n\nisPalindrome :: Integer -> Bool\nisPalindrome n =\n  let s = show n\n  in (s == reverse s)\n\nisLychrel :: Integer -> Bool\nisLychrel = not . null . drop 500 . procLychrel\n\nreverseInteger :: Integer -> Integer\nreverseInteger = read . reverse . show\n\nseedAndRelated :: (Int, [Integer], [Integer], Int)\nseedAndRelated =\n  let (seed, related, _) = foldl sar ([], [], []) [1 .. 10000]\n      lseed = length seed\n      lrelated = length related\n      totalCount = lseed + lrelated\n      pal = filter isPalindrome $ seed ++ related\n  in (totalCount, pal, seed, lrelated)\n  where\n    sar (seed, related, lych) x =\n      let s = procLychrel x\n          sIsLychrel = not . null . drop 500 $ s\n          (isIn, isOut) = partition (`elem` lych) . take 501 $ s\n          newLych = lych ++ isOut\n      in if sIsLychrel\n           then if null isIn \n                  then (x : seed, related, newLych)\n                  else (seed, x : related, newLych) \n           else (seed, related, lych)\n\nmain = do\n  let (totalCount, palindromicLychrel, lychrelSeeds, relatedCount) = seedAndRelated\n  putStrLn $ \"[1..10,000] contains \" ++ show totalCount ++ \" Lychrel numbers.\"\n  putStrLn $ show palindromicLychrel ++ \" are palindromic Lychrel numbers.\"\n  putStrLn $ show lychrelSeeds ++ \" are Lychrel seeds.\"\n  putStrLn $ \"There are \" ++ show relatedCount ++ \" related Lychrel numbers.\"\n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 418826, "name": "Lychrel numbers", "source": "Translate Haskell to Python: module Main where\n\nimport Data.List\n\nprocLychrel :: Integer -> [Integer]\nprocLychrel a = a : pl a\n  where\n    pl n =\n        let s = n + reverseInteger n\n             in if isPalindrome s\n                  then [s]\n                  else s : pl s\n\nisPalindrome :: Integer -> Bool\nisPalindrome n =\n  let s = show n\n  in (s == reverse s)\n\nisLychrel :: Integer -> Bool\nisLychrel = not . null . drop 500 . procLychrel\n\nreverseInteger :: Integer -> Integer\nreverseInteger = read . reverse . show\n\nseedAndRelated :: (Int, [Integer], [Integer], Int)\nseedAndRelated =\n  let (seed, related, _) = foldl sar ([], [], []) [1 .. 10000]\n      lseed = length seed\n      lrelated = length related\n      totalCount = lseed + lrelated\n      pal = filter isPalindrome $ seed ++ related\n  in (totalCount, pal, seed, lrelated)\n  where\n    sar (seed, related, lych) x =\n      let s = procLychrel x\n          sIsLychrel = not . null . drop 500 $ s\n          (isIn, isOut) = partition (`elem` lych) . take 501 $ s\n          newLych = lych ++ isOut\n      in if sIsLychrel\n           then if null isIn \n                  then (x : seed, related, newLych)\n                  else (seed, x : related, newLych) \n           else (seed, related, lych)\n\nmain = do\n  let (totalCount, palindromicLychrel, lychrelSeeds, relatedCount) = seedAndRelated\n  putStrLn $ \"[1..10,000] contains \" ++ show totalCount ++ \" Lychrel numbers.\"\n  putStrLn $ show palindromicLychrel ++ \" are palindromic Lychrel numbers.\"\n  putStrLn $ show lychrelSeeds ++ \" are Lychrel seeds.\"\n  putStrLn $ \"There are \" ++ show relatedCount ++ \" related Lychrel numbers.\"\n", "target": "from __future__ import print_function\n\ndef add_reverse(num, max_iter=1000):\n    i, nums = 0, {num}\n    while True:\n        i, num = i+1, num + reverse_int(num)\n        nums.add(num)\n        if reverse_int(num) == num or i >= max_iter:\n            break\n    return nums\n    \n\ndef reverse_int(num):\n    return int(str(num)[::-1])\n\ndef split_roots_from_relateds(roots_and_relateds):\n    roots = roots_and_relateds[::]\n    i = 1\n    while i < len(roots):\n        this = roots[i]\n        if any(this.intersection(prev) for prev in roots[:i]):\n            del roots[i]\n        else:\n            i += 1\n    root = [min(each_set) for each_set in roots]\n    related = [min(each_set) for each_set in roots_and_relateds]\n    related = [n for n in related if n not in root]\n    return root, related\n\ndef find_lychrel(maxn, max_reversions):\n    'Lychrel number generator'\n    series = [add_reverse(n, max_reversions*2) for n in range(1, maxn + 1)]\n    roots_and_relateds = [s for s in series if len(s) > max_reversions]\n    return split_roots_from_relateds(roots_and_relateds)\n\n\nif __name__ == '__main__':\n    maxn, reversion_limit = 10000, 500\n    print(\"Calculations using n = 1..%i and limiting each search to 2*%i reverse-digits-and-adds\"\n          % (maxn, reversion_limit))\n    lychrel, l_related = find_lychrel(maxn, reversion_limit)\n    print('  Number of Lychrel numbers:', len(lychrel))\n    print('    Lychrel numbers:', ', '.join(str(n) for n in lychrel))\n    print('  Number of Lychrel related:', len(l_related))\n    \n    pals = [x for x in lychrel + l_related  if x == reverse_int(x)]\n    print('  Number of Lychrel palindromes:', len(pals))\n    print('    Lychrel palindromes:', ', '.join(str(n) for n in pals))\n"}
{"id": 418827, "name": "Check Machin-like formulas", "source": "Translate Haskell to Python: import Data.Ratio\nimport Data.List (foldl')\n\ntanPlus :: Fractional a => a -> a -> a\ntanPlus a b = (a + b) / (1 - a * b)\n\ntanEval :: (Integral a, Fractional b) => (a, b) -> b\ntanEval (0,_) = 0\ntanEval (coef,f)\n\t| coef < 0 = -tanEval (-coef, f)\n\t| odd coef = tanPlus f $ tanEval (coef - 1, f)\n\t| otherwise = tanPlus a a\n\t\twhere a = tanEval (coef `div` 2, f)\n\ntans :: (Integral a, Fractional b) => [(a, b)] -> b\ntans = foldl' tanPlus 0 . map tanEval\n\nmachins = [\n\t[(1, 1%2), (1, 1%3)],\n\t[(2, 1%3), (1, 1%7)],\n\t[(12, 1%18), (8, 1%57), (-5, 1%239)],\n\t[(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12943)]]\n\nnot_machin = [(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12944)]\n\nmain = do\n\tputStrLn \"Machins:\"\n\tmapM_ (\\x -> putStrLn $ show (tans x) ++ \" <\n\n\tputStr \"\\nnot Machin: \"; print not_machin\n\tprint (tans not_machin)\n", "target": "import re\nfrom fractions import Fraction\nfrom pprint import pprint as pp\n\n\nequationtext = \n\ndef parse_eqn(equationtext=equationtext):\n    eqn_re = re.compile(r)\n\n    found = eqn_re.findall(equationtext)\n    machins, part = [], []\n    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):\n        if lhs and part:\n            machins.append(part)\n            part = []\n        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),\n                       Fraction(int(numer), (int(denom) if denom else 1)) ) )\n    machins.append(part)\n    return machins\n\n\ndef tans(xs):\n    xslen = len(xs)\n    if xslen == 1:\n        return tanEval(*xs[0])\n    aa, bb = xs[:xslen//2], xs[xslen//2:]\n    a, b = tans(aa), tans(bb)\n    return (a + b) / (1 - a * b)\n\ndef tanEval(coef, f):\n    if coef == 1:\n        return f\n    if coef < 0:\n        return -tanEval(-coef, f)\n    ca = coef // 2\n    cb = coef - ca\n    a, b = tanEval(ca, f), tanEval(cb, f)\n    return (a + b) / (1 - a * b)\n\n\nif __name__ == '__main__':\n    machins = parse_eqn()\n    \n    for machin, eqn in zip(machins, equationtext.split('\\n')):\n        ans = tans(machin)\n        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))\n"}
{"id": 418828, "name": "Check Machin-like formulas", "source": "Translate Haskell to Python: import Data.Ratio\nimport Data.List (foldl')\n\ntanPlus :: Fractional a => a -> a -> a\ntanPlus a b = (a + b) / (1 - a * b)\n\ntanEval :: (Integral a, Fractional b) => (a, b) -> b\ntanEval (0,_) = 0\ntanEval (coef,f)\n\t| coef < 0 = -tanEval (-coef, f)\n\t| odd coef = tanPlus f $ tanEval (coef - 1, f)\n\t| otherwise = tanPlus a a\n\t\twhere a = tanEval (coef `div` 2, f)\n\ntans :: (Integral a, Fractional b) => [(a, b)] -> b\ntans = foldl' tanPlus 0 . map tanEval\n\nmachins = [\n\t[(1, 1%2), (1, 1%3)],\n\t[(2, 1%3), (1, 1%7)],\n\t[(12, 1%18), (8, 1%57), (-5, 1%239)],\n\t[(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12943)]]\n\nnot_machin = [(88, 1%172), (51, 1%239), (32 , 1%682), (44, 1%5357), (68, 1%12944)]\n\nmain = do\n\tputStrLn \"Machins:\"\n\tmapM_ (\\x -> putStrLn $ show (tans x) ++ \" <\n\n\tputStr \"\\nnot Machin: \"; print not_machin\n\tprint (tans not_machin)\n", "target": "import re\nfrom fractions import Fraction\nfrom pprint import pprint as pp\n\n\nequationtext = \n\ndef parse_eqn(equationtext=equationtext):\n    eqn_re = re.compile(r)\n\n    found = eqn_re.findall(equationtext)\n    machins, part = [], []\n    for lhs, sign, mult, numer, denom in eqn_re.findall(equationtext):\n        if lhs and part:\n            machins.append(part)\n            part = []\n        part.append( ( (-1 if sign == '-' else 1) * ( int(mult) if mult else 1),\n                       Fraction(int(numer), (int(denom) if denom else 1)) ) )\n    machins.append(part)\n    return machins\n\n\ndef tans(xs):\n    xslen = len(xs)\n    if xslen == 1:\n        return tanEval(*xs[0])\n    aa, bb = xs[:xslen//2], xs[xslen//2:]\n    a, b = tans(aa), tans(bb)\n    return (a + b) / (1 - a * b)\n\ndef tanEval(coef, f):\n    if coef == 1:\n        return f\n    if coef < 0:\n        return -tanEval(-coef, f)\n    ca = coef // 2\n    cb = coef - ca\n    a, b = tanEval(ca, f), tanEval(cb, f)\n    return (a + b) / (1 - a * b)\n\n\nif __name__ == '__main__':\n    machins = parse_eqn()\n    \n    for machin, eqn in zip(machins, equationtext.split('\\n')):\n        ans = tans(machin)\n        print('%5s: %s' % ( ('OK' if ans == 1 else 'ERROR'), eqn))\n"}
{"id": 418829, "name": "Names to numbers", "source": "Translate Haskell to Python: import Data.Char (toLower)\n\ntype Symbol = (String, Integer)\ntype BinOp = (Integer -> Integer -> Integer)\ntype State = [Transition]\n\ndata Transition = Transition [Symbol] State BinOp\n                | Illion State BinOp\n                | Done\n\ntype Words = [String]\ntype Accumulator = Integer\ntype TapeValue = (Accumulator, [Symbol], Words)\n\nones, teens, tens, hundred, illions :: [Symbol]\nones =\n    [(\"one\", 1)\n    ,(\"two\", 2)\n    ,(\"three\", 3)\n    ,(\"four\", 4)\n    ,(\"five\", 5)\n    ,(\"six\", 6)\n    ,(\"seven\", 7)\n    ,(\"eight\", 8)\n    ,(\"nine\", 9)]\n\nteens =\n    [(\"ten\", 10)\n    ,(\"eleven\", 11)\n    ,(\"twelve\", 12)\n    ,(\"thirteen\", 13)\n    ,(\"fourteen\", 14)\n    ,(\"fifteen\", 15)\n    ,(\"sixteen\", 16)\n    ,(\"seventeen\", 17)\n    ,(\"eighteen\", 18)\n    ,(\"nineteen\", 19)]\n\ntens =\n    [(\"twenty\", 20)\n    ,(\"thirty\", 30)\n    ,(\"forty\", 40)\n    ,(\"fifty\", 50)\n    ,(\"sixty\", 60)\n    ,(\"seventy\", 70)\n    ,(\"eighty\", 80)\n    ,(\"ninety\", 90)]\n\nhundred =\n    [(\"hundred\", 100)]\n\nillions =\n    [(\"quintillion\", 10 ^ 18)\n    ,(\"quadrillion\", 10 ^ 15) \n    ,(\"trillion\", 10 ^ 12)\n    ,(\"billion\", 10 ^ 9)\n    ,(\"million\", 10 ^ 6)\n    ,(\"thousand\", 10 ^ 3)]\n\ntokenize :: String -> Words\ntokenize = words . (map replace) . (map toLower)\n    where\n      replace c\n          | elem c ['a'..'z'] = c\n          | otherwise         = ' '\n\nlookupRest :: (Eq a) => a -> [(a,b)] -> Maybe (b, [(a,b)])\nlookupRest _ [] = Nothing\nlookupRest x ((y,z):ws) = if x == y\n                          then Just (z, ws)\n                          else lookupRest x ws\n\nrunState :: State -> TapeValue -> TapeValue\nrunState []     (_, _, word:_)             = error $ \"Unexpected token: \" ++ word\nrunState _      tv@(_, _, [])              = tv\nrunState (t:ts) tv@(int, illions, word:wx) =\n    case t of\n      Transition table state op ->\n          case lookup word table of\n            Nothing  -> runState ts tv\n            Just num -> runState state (op num int, illions, wx)\n      Illion state op           ->\n          case lookupRest word illions of\n            Nothing              -> runState ts tv\n            Just (num, illions') -> runState state (op num int, illions', wx)\n      Done                      -> tv\n\nstateIllion, stateA, stateB, stateC, stateD, stateE :: State\nstateIllion = [Illion [Done] (*)]\n\nstateA = [Transition ones stateB (+)\n         ,Transition tens stateD (+)\n         ,Transition teens stateE (+)]\n\nstateB = [Transition hundred stateC (*)]\n         ++ stateIllion\n\nstateC = [Transition ones stateE (+)\n         ,Transition tens stateD (+)\n         ,Transition teens stateE (+)]\n         ++ stateIllion\n\nstateD = [Transition ones stateE (+)]\n         ++ stateIllion\n\nstateE = stateIllion ++ [Done]\n\nparseSubWord :: [Symbol] -> Words -> TapeValue\nparseSubWord illions w = runState stateA (0, illions, w)\n                  \nparse :: [Symbol] -> Words -> Integer\nparse _       [] = 0\nparse illions wx = let (i, illions', wx') = parseSubWord illions wx\n                   in i + parse illions' wx'\n\nintegerSpell :: String -> Integer\nintegerSpell wx =\n    case tokenize wx of\n      (\"negative\":\"zero\":[]) -> -0\n      (\"zero\":[])            -> 0\n      (\"negative\":wx')       -> negate $ parse illions wx'\n      wx'                    -> parse illions wx'\n", "target": "from spell_integer import spell_integer, SMALL, TENS, HUGE\n\ndef int_from_words(num):\n    words = num.replace(',','').replace(' and ', ' ').replace('-', ' ').split()\n    if words[0] == 'minus':\n        negmult = -1\n        words.pop(0)\n    else:\n        negmult = 1\n    small, total = 0, 0\n    for word in words:\n        if word in SMALL:\n            small += SMALL.index(word)\n        elif word in TENS:\n            small += TENS.index(word) * 10\n        elif word == 'hundred':\n            small *= 100\n        elif word == 'thousand':\n            total += small * 1000\n            small = 0\n        elif word in HUGE:\n            total += small * 1000 ** HUGE.index(word)\n            small = 0\n        else:\n            raise ValueError(\"Don't understand %r part of %r\" % (word, num))\n    return negmult * (total + small)\n\n\nif __name__ == '__main__':\n    \n    for n in range(-10000, 10000, 17):\n        assert n == int_from_words(spell_integer(n))\n\n    for n in range(20):\n        assert 13**n == int_from_words(spell_integer(13**n))\n    \n    print('\\n\n    for n in (0, -3, 5, -7, 11, -13, 17, -19, 23, -29):\n        txt = spell_integer(n)\n        num = int_from_words(txt)\n        print('%+4i <%s> %s' % (n, '==' if n == num else '??', txt))\n    print('')  \n    \n    n = 201021002001\n    while n:\n        txt = spell_integer(n)\n        num = int_from_words(txt)\n        print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))\n        n //= -10\n    txt = spell_integer(n)\n    num = int_from_words(txt)\n    print('%12i <%s> %s' % (n, '==' if n == num else '??', txt))\n    print('')\n"}
{"id": 418830, "name": "The ISAAC cipher", "source": "Translate Haskell to Python: import Data.Array (Array, (!), (//), array, elems)\nimport Data.Word (Word, Word32)\nimport Data.Bits (shift, xor)\nimport Data.Char (toUpper)\nimport Data.List (unfoldr)\nimport Numeric (showHex)\n\ntype IArray = Array Word32 Word32\n\ndata IsaacState = IState\n  { randrsl :: IArray\n  , randcnt :: Word32\n  , mm :: IArray\n  , aa :: Word32\n  , bb :: Word32\n  , cc :: Word32\n  }\n\ninstance Show IsaacState where\n  show (IState _ cnt _ a b c) =\n    show cnt ++ \" \" ++ show a ++ \" \" ++ show b ++ \" \" ++ show c\n\ntoHex :: Char -> String\ntoHex c = showHex (fromEnum c) \"\"\n\nhexify :: String -> String\nhexify = map toUpper . concatMap toHex\n\ntoNum :: Char -> Word32\ntoNum = fromIntegral . fromEnum\n\ntoChar :: Word32 -> Char\ntoChar = toEnum . fromIntegral\n\ngolden :: Word32\ngolden = 0x9e3779b9\n\n\nmix :: [Word32] -> [Word32]\nmix set = foldl aux set [11, -2, 8, -16, 10, -4, 8, -9]\n  where\n    aux [a, b, c, d, e, f, g, h] x = [b + c, c, d + a_, e, f, g, h, a_]\n      where\n        a_ = a `xor` (b `shift` x)\n\n\nisaac :: IsaacState -> IsaacState\nisaac (IState rsl _ m a b c) = IState rsl_ 0 m_ a_ b_ c_\n  where\n    c_ = c + 1\n    (rsl_, m_, a_, b_) =\n      foldl aux (rsl, m, a, b) $ zip [0 .. 255] $ cycle [13, -6, 2, -16]\n    aux (rsl, m, a, b) (i, s) = (rsl_, m_, a_, b_)\n      where\n        x = m ! i\n        a_ = (a `xor` (a `shift` s)) + m ! ((i + 128) `mod` 256)\n        y = a_ + b + m ! ((x `shift` (-2)) `mod` 256)\n        m_ = m // [(i, y)]\n        b_ = x + m_ ! ((y `shift` (-10)) `mod` 256)\n        rsl_ = rsl // [(i, b_)]\n\n\nrandinit :: IsaacState -> Bool -> IsaacState\nrandinit state flag = isaac (IState randrsl_ 0 m 0 0 0)\n  where\n    firstSet = iterate mix (replicate 8 golden) !! 4\n    iter _ _ [] = []\n    iter flag set rsl =\n      let (rslH, rslT) = splitAt 8 rsl\n          set_ =\n            mix $\n            if flag\n              then zipWith (+) set rslH\n              else set\n      in set_ ++ iter flag set_ rslT\n    randrsl_ = randrsl state\n    firstPass = iter flag firstSet $ elems randrsl_\n    set_ = drop (256 - 8) firstPass\n    secondPass =\n      if flag\n        then iter True set_ firstPass\n        else firstPass\n    m = array (0, 255) $ zip [0 ..] secondPass\n\n\nseed :: String -> Bool -> IsaacState\nseed key flag =\n  let m = array (0, 255) $ zip [0 .. 255] $ repeat 0\n      rsl = m // zip [0 ..] (map toNum key)\n      state = IState rsl 0 m 0 0 0\n  in randinit state flag\n\n\nrandom :: IsaacState -> (Word32, IsaacState)\nrandom state@(IState rsl cnt m a b c) =\n  let r = rsl ! cnt\n      state_ =\n        if cnt + 1 > 255\n          then isaac $ IState rsl 0 m a b c\n          else IState rsl (cnt + 1) m a b c\n  in (r, state_)\n\n\nrandoms :: IsaacState -> [Word32]\nrandoms = unfoldr $ Just . random\n\n\n\nrandA :: IsaacState -> (Char, IsaacState)\nrandA state =\n  let (r, state_) = random state\n  in (toEnum $ fromIntegral $ (r `mod` 95) + 32, state_)\n\n\nrandAs :: IsaacState -> String\nrandAs = unfoldr $ Just . randA\n\n\nvernam :: IsaacState -> String -> String\nvernam state msg = map toChar $ zipWith xor msg_ randAs_\n  where\n    msg_ = map toNum msg\n    randAs_ = map toNum $ randAs state\n\nmain :: IO ()\nmain = do\n  let msg = \"a Top Secret secret\"\n      key = \"this is my secret key\"\n      st = seed key True\n      ver = vernam st msg\n      unver = vernam st ver\n  putStrLn $ \"Message: \" ++ msg\n  putStrLn $ \"Key   \u00a0: \" ++ key\n  putStrLn $ \"XOR   \u00a0: \" ++ hexify ver\n  putStrLn $ \"XOR dcr: \" ++ unver\n", "target": "import random\nimport collections\n\nINT_MASK = 0xFFFFFFFF       \n\nclass IsaacRandom(random.Random):\n    \n\n    def seed(self, seed=None):\n        \n        def mix():\n            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK\n            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK\n            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK\n            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK\n            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK\n            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK\n            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK\n            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK\n        \n        super().seed(0) \n        if seed is not None:\n            if isinstance(seed, str):\n                seed = [ord(x) for x in seed]\n            elif isinstance(seed, collections.Iterable):\n                seed = [x & INT_MASK for x in seed]\n            elif isinstance(seed, int):\n                val = abs(seed)\n                seed = []\n                while val:\n                    seed.append(val & INT_MASK)\n                    val >>= 32\n            else:\n                raise TypeError('Seed must be string, integer or iterable of integer')\n            \n            \n            if len(seed)>256:\n                del seed[256:]\n            elif len(seed)<256:\n                seed.extend([0]*(256-len(seed)))\n                \n        self.aa = self.bb = self.cc = 0\n        self.mm = []\n        init_state = [0x9e3779b9]*8\n        \n        for _ in range(4):\n            mix()\n        \n        for i in range(0, 256, 8):\n            if seed is not None:\n                for j in range(8):\n                    init_state[j] += seed[i+j]\n                    init_state[j] &= INT_MASK\n            mix()\n            self.mm += init_state\n                \n        if seed is not None:\n            for i in range(0, 256, 8):\n                for j in range(8):\n                    init_state[j] += self.mm[i+j]\n                    init_state[j] &= INT_MASK\n                mix()\n                for j in range(8):\n                    self.mm[i+j] = init_state[j]\n                \n        self.rand_count = 256\n        self.rand_result = [0]*256\n        \n    def getstate(self):\n        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result\n    \n    def setstate(self, state):\n        super().setstate(state[0])\n        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state \n        \n    def _generate(self):\n        \n        \n        self.cc = (self.cc + 1) & INT_MASK\n        self.bb = (self.bb + self.cc) & INT_MASK\n        \n        for i in range(256):\n            x = self.mm[i]\n            mod = i & 3\n            if mod==0:\n                self.aa ^= ((self.aa << 13) & INT_MASK)\n            elif mod==1:\n                self.aa ^= (self.aa >> 6)\n            elif mod==2:\n                self.aa ^= ((self.aa << 2) & INT_MASK)\n            else: \n                self.aa ^= (self.aa >> 16)\n            self.aa = (self.mm[i^128] + self.aa) & INT_MASK\n            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK\n            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK\n            \n        self.rand_count = 0\n        \n    def next_int(self):\n        \n        if self.rand_count == 256:\n            self._generate()\n        result = self.rand_result[self.rand_count]\n        self.rand_count += 1\n        return result\n        \n    def getrandbits(self, k):\n        \n        result = 0\n        ints_needed = (k+31)//32\n        ints_used = 0\n        while ints_used < ints_needed:\n            if self.rand_count == 256:\n                self._generate()\n            ints_to_take = min(256-self.rand_count, ints_needed)\n            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:\n                result = (result << 32) | val\n            self.rand_count += ints_to_take\n            ints_used += ints_to_take\n        result &= ((1<<k)-1)    \n        return result\n    \n    def random(self):\n        \n        \n        return self.getrandbits(53) * (2**-53)\n    \n    def rand_char(self):\n        \n        return self.next_int() % 95 + 32\n    \n    def vernam(self, msg):\n        \n        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)\n    \n    \n    ENCIPHER = 'encipher'\n    DECIPHER = 'decipher'\n    \n    @staticmethod\n    def _caesar(ciphermode, ch, shift, modulo, start):\n        if ciphermode == IsaacRandom.DECIPHER:\n            shift = -shift\n        n = ((ch-start)+shift) % modulo\n        if n<0:\n            n += modulo\n        return start+n\n    \n    def caesar(self, ciphermode, msg, modulo, start):\n        \n        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg)\n        \nif __name__=='__main__':\n    import binascii\n    \n    def hexify(b):\n        return binascii.hexlify(b).decode('ascii').upper()\n    \n    MOD = 95\n    START = 32\n    \n    msg = 'a Top Secret secret'\n    key = 'this is my secret key'\n    isaac_random = IsaacRandom(key)\n    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))\n    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)\n    isaac_random.seed(key)\n    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')\n    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')\n    \n    print('Message:', msg)\n    print('Key   \u00a0:', key)\n    print('XOR   \u00a0:', hexify(vernam_encoded))\n    print('XOR dcr:', vernam_decoded)\n    print('MOD   \u00a0:', hexify(caesar_encoded))\n    print('MOD dcr:', caesar_decoded)\n"}
{"id": 418831, "name": "The ISAAC cipher", "source": "Translate Haskell to Python: import Data.Array (Array, (!), (//), array, elems)\nimport Data.Word (Word, Word32)\nimport Data.Bits (shift, xor)\nimport Data.Char (toUpper)\nimport Data.List (unfoldr)\nimport Numeric (showHex)\n\ntype IArray = Array Word32 Word32\n\ndata IsaacState = IState\n  { randrsl :: IArray\n  , randcnt :: Word32\n  , mm :: IArray\n  , aa :: Word32\n  , bb :: Word32\n  , cc :: Word32\n  }\n\ninstance Show IsaacState where\n  show (IState _ cnt _ a b c) =\n    show cnt ++ \" \" ++ show a ++ \" \" ++ show b ++ \" \" ++ show c\n\ntoHex :: Char -> String\ntoHex c = showHex (fromEnum c) \"\"\n\nhexify :: String -> String\nhexify = map toUpper . concatMap toHex\n\ntoNum :: Char -> Word32\ntoNum = fromIntegral . fromEnum\n\ntoChar :: Word32 -> Char\ntoChar = toEnum . fromIntegral\n\ngolden :: Word32\ngolden = 0x9e3779b9\n\n\nmix :: [Word32] -> [Word32]\nmix set = foldl aux set [11, -2, 8, -16, 10, -4, 8, -9]\n  where\n    aux [a, b, c, d, e, f, g, h] x = [b + c, c, d + a_, e, f, g, h, a_]\n      where\n        a_ = a `xor` (b `shift` x)\n\n\nisaac :: IsaacState -> IsaacState\nisaac (IState rsl _ m a b c) = IState rsl_ 0 m_ a_ b_ c_\n  where\n    c_ = c + 1\n    (rsl_, m_, a_, b_) =\n      foldl aux (rsl, m, a, b) $ zip [0 .. 255] $ cycle [13, -6, 2, -16]\n    aux (rsl, m, a, b) (i, s) = (rsl_, m_, a_, b_)\n      where\n        x = m ! i\n        a_ = (a `xor` (a `shift` s)) + m ! ((i + 128) `mod` 256)\n        y = a_ + b + m ! ((x `shift` (-2)) `mod` 256)\n        m_ = m // [(i, y)]\n        b_ = x + m_ ! ((y `shift` (-10)) `mod` 256)\n        rsl_ = rsl // [(i, b_)]\n\n\nrandinit :: IsaacState -> Bool -> IsaacState\nrandinit state flag = isaac (IState randrsl_ 0 m 0 0 0)\n  where\n    firstSet = iterate mix (replicate 8 golden) !! 4\n    iter _ _ [] = []\n    iter flag set rsl =\n      let (rslH, rslT) = splitAt 8 rsl\n          set_ =\n            mix $\n            if flag\n              then zipWith (+) set rslH\n              else set\n      in set_ ++ iter flag set_ rslT\n    randrsl_ = randrsl state\n    firstPass = iter flag firstSet $ elems randrsl_\n    set_ = drop (256 - 8) firstPass\n    secondPass =\n      if flag\n        then iter True set_ firstPass\n        else firstPass\n    m = array (0, 255) $ zip [0 ..] secondPass\n\n\nseed :: String -> Bool -> IsaacState\nseed key flag =\n  let m = array (0, 255) $ zip [0 .. 255] $ repeat 0\n      rsl = m // zip [0 ..] (map toNum key)\n      state = IState rsl 0 m 0 0 0\n  in randinit state flag\n\n\nrandom :: IsaacState -> (Word32, IsaacState)\nrandom state@(IState rsl cnt m a b c) =\n  let r = rsl ! cnt\n      state_ =\n        if cnt + 1 > 255\n          then isaac $ IState rsl 0 m a b c\n          else IState rsl (cnt + 1) m a b c\n  in (r, state_)\n\n\nrandoms :: IsaacState -> [Word32]\nrandoms = unfoldr $ Just . random\n\n\n\nrandA :: IsaacState -> (Char, IsaacState)\nrandA state =\n  let (r, state_) = random state\n  in (toEnum $ fromIntegral $ (r `mod` 95) + 32, state_)\n\n\nrandAs :: IsaacState -> String\nrandAs = unfoldr $ Just . randA\n\n\nvernam :: IsaacState -> String -> String\nvernam state msg = map toChar $ zipWith xor msg_ randAs_\n  where\n    msg_ = map toNum msg\n    randAs_ = map toNum $ randAs state\n\nmain :: IO ()\nmain = do\n  let msg = \"a Top Secret secret\"\n      key = \"this is my secret key\"\n      st = seed key True\n      ver = vernam st msg\n      unver = vernam st ver\n  putStrLn $ \"Message: \" ++ msg\n  putStrLn $ \"Key   \u00a0: \" ++ key\n  putStrLn $ \"XOR   \u00a0: \" ++ hexify ver\n  putStrLn $ \"XOR dcr: \" ++ unver\n", "target": "import random\nimport collections\n\nINT_MASK = 0xFFFFFFFF       \n\nclass IsaacRandom(random.Random):\n    \n\n    def seed(self, seed=None):\n        \n        def mix():\n            init_state[0] ^= ((init_state[1]<<11)&INT_MASK); init_state[3] += init_state[0]; init_state[3] &= INT_MASK; init_state[1] += init_state[2]; init_state[1] &= INT_MASK\n            init_state[1] ^=  (init_state[2]>>2)           ; init_state[4] += init_state[1]; init_state[4] &= INT_MASK; init_state[2] += init_state[3]; init_state[2] &= INT_MASK\n            init_state[2] ^= ((init_state[3]<<8 )&INT_MASK); init_state[5] += init_state[2]; init_state[5] &= INT_MASK; init_state[3] += init_state[4]; init_state[3] &= INT_MASK\n            init_state[3] ^=  (init_state[4]>>16)          ; init_state[6] += init_state[3]; init_state[6] &= INT_MASK; init_state[4] += init_state[5]; init_state[4] &= INT_MASK\n            init_state[4] ^= ((init_state[5]<<10)&INT_MASK); init_state[7] += init_state[4]; init_state[7] &= INT_MASK; init_state[5] += init_state[6]; init_state[5] &= INT_MASK\n            init_state[5] ^=  (init_state[6]>>4 )          ; init_state[0] += init_state[5]; init_state[0] &= INT_MASK; init_state[6] += init_state[7]; init_state[6] &= INT_MASK\n            init_state[6] ^= ((init_state[7]<<8 )&INT_MASK); init_state[1] += init_state[6]; init_state[1] &= INT_MASK; init_state[7] += init_state[0]; init_state[7] &= INT_MASK\n            init_state[7] ^=  (init_state[0]>>9 )          ; init_state[2] += init_state[7]; init_state[2] &= INT_MASK; init_state[0] += init_state[1]; init_state[0] &= INT_MASK\n        \n        super().seed(0) \n        if seed is not None:\n            if isinstance(seed, str):\n                seed = [ord(x) for x in seed]\n            elif isinstance(seed, collections.Iterable):\n                seed = [x & INT_MASK for x in seed]\n            elif isinstance(seed, int):\n                val = abs(seed)\n                seed = []\n                while val:\n                    seed.append(val & INT_MASK)\n                    val >>= 32\n            else:\n                raise TypeError('Seed must be string, integer or iterable of integer')\n            \n            \n            if len(seed)>256:\n                del seed[256:]\n            elif len(seed)<256:\n                seed.extend([0]*(256-len(seed)))\n                \n        self.aa = self.bb = self.cc = 0\n        self.mm = []\n        init_state = [0x9e3779b9]*8\n        \n        for _ in range(4):\n            mix()\n        \n        for i in range(0, 256, 8):\n            if seed is not None:\n                for j in range(8):\n                    init_state[j] += seed[i+j]\n                    init_state[j] &= INT_MASK\n            mix()\n            self.mm += init_state\n                \n        if seed is not None:\n            for i in range(0, 256, 8):\n                for j in range(8):\n                    init_state[j] += self.mm[i+j]\n                    init_state[j] &= INT_MASK\n                mix()\n                for j in range(8):\n                    self.mm[i+j] = init_state[j]\n                \n        self.rand_count = 256\n        self.rand_result = [0]*256\n        \n    def getstate(self):\n        return super().getstate(), self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result\n    \n    def setstate(self, state):\n        super().setstate(state[0])\n        _, self.aa, self.bb, self.cc, self.mm, self.rand_count, self.rand_result = state \n        \n    def _generate(self):\n        \n        \n        self.cc = (self.cc + 1) & INT_MASK\n        self.bb = (self.bb + self.cc) & INT_MASK\n        \n        for i in range(256):\n            x = self.mm[i]\n            mod = i & 3\n            if mod==0:\n                self.aa ^= ((self.aa << 13) & INT_MASK)\n            elif mod==1:\n                self.aa ^= (self.aa >> 6)\n            elif mod==2:\n                self.aa ^= ((self.aa << 2) & INT_MASK)\n            else: \n                self.aa ^= (self.aa >> 16)\n            self.aa = (self.mm[i^128] + self.aa) & INT_MASK\n            y = self.mm[i] = (self.mm[(x>>2) & 0xFF] + self.aa + self.bb) & INT_MASK\n            self.rand_result[i] = self.bb = (self.mm[(y>>10) & 0xFF] + x) & INT_MASK\n            \n        self.rand_count = 0\n        \n    def next_int(self):\n        \n        if self.rand_count == 256:\n            self._generate()\n        result = self.rand_result[self.rand_count]\n        self.rand_count += 1\n        return result\n        \n    def getrandbits(self, k):\n        \n        result = 0\n        ints_needed = (k+31)//32\n        ints_used = 0\n        while ints_used < ints_needed:\n            if self.rand_count == 256:\n                self._generate()\n            ints_to_take = min(256-self.rand_count, ints_needed)\n            for val in self.rand_result[self.rand_count : self.rand_count+ints_to_take]:\n                result = (result << 32) | val\n            self.rand_count += ints_to_take\n            ints_used += ints_to_take\n        result &= ((1<<k)-1)    \n        return result\n    \n    def random(self):\n        \n        \n        return self.getrandbits(53) * (2**-53)\n    \n    def rand_char(self):\n        \n        return self.next_int() % 95 + 32\n    \n    def vernam(self, msg):\n        \n        return bytes((self.rand_char() & 0xFF) ^ x for x in msg)\n    \n    \n    ENCIPHER = 'encipher'\n    DECIPHER = 'decipher'\n    \n    @staticmethod\n    def _caesar(ciphermode, ch, shift, modulo, start):\n        if ciphermode == IsaacRandom.DECIPHER:\n            shift = -shift\n        n = ((ch-start)+shift) % modulo\n        if n<0:\n            n += modulo\n        return start+n\n    \n    def caesar(self, ciphermode, msg, modulo, start):\n        \n        return bytes(self._caesar(ciphermode, ch, self.rand_char(), modulo, start) for ch in msg)\n        \nif __name__=='__main__':\n    import binascii\n    \n    def hexify(b):\n        return binascii.hexlify(b).decode('ascii').upper()\n    \n    MOD = 95\n    START = 32\n    \n    msg = 'a Top Secret secret'\n    key = 'this is my secret key'\n    isaac_random = IsaacRandom(key)\n    vernam_encoded = isaac_random.vernam(msg.encode('ascii'))\n    caesar_encoded = isaac_random.caesar(IsaacRandom.ENCIPHER, msg.encode('ascii'), MOD, START)\n    isaac_random.seed(key)\n    vernam_decoded = isaac_random.vernam(vernam_encoded).decode('ascii')\n    caesar_decoded = isaac_random.caesar(IsaacRandom.DECIPHER, caesar_encoded, MOD, START).decode('ascii')\n    \n    print('Message:', msg)\n    print('Key   \u00a0:', key)\n    print('XOR   \u00a0:', hexify(vernam_encoded))\n    print('XOR dcr:', vernam_decoded)\n    print('MOD   \u00a0:', hexify(caesar_encoded))\n    print('MOD dcr:', caesar_decoded)\n"}
{"id": 418832, "name": "Permutations_Rank of a permutation", "source": "Translate Haskell to Python: fact :: Int -> Int\nfact n = product [1 .. n]\n\n\n\nrankPerm [] _ = []\nrankPerm list n = c : rankPerm (a ++ b) r\n  where\n    (q, r) = n `divMod` fact (length list - 1)\n    (a, c:b) = splitAt q list\n\npermRank [] = 0\npermRank (x:xs) = length (filter (< x) xs) * fact (length xs) + permRank xs\n\nmain :: IO ()\nmain = mapM_ f [0 .. 23]\n  where\n    f n = print (n, p, permRank p)\n      where\n        p = rankPerm [0 .. 3] n\n", "target": "from math import factorial as fact\nfrom random import randrange\nfrom textwrap import wrap\n\ndef identity_perm(n): \n    return list(range(n))\n\ndef unranker1(n, r, pi):\n    while n > 0:\n        n1, (rdivn, rmodn) = n-1, divmod(r, n)\n        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]\n        n = n1\n        r = rdivn\n    return pi\n\ndef init_pi1(n, pi): \n    pi1 = [-1] * n\n    for i in range(n): \n        pi1[pi[i]] = i\n    return pi1\n\ndef ranker1(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s + n * ranker1(n1, pi, pi1)\n\ndef unranker2(n, r, pi):\n    while n > 0:\n        n1 = n-1\n        s, rmodf = divmod(r, fact(n1))\n        pi[n1], pi[s] = pi[s], pi[n1]\n        n = n1\n        r = rmodf\n    return pi\n\ndef ranker2(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s * fact(n1) + ranker2(n1, pi, pi1)\n\ndef get_random_ranks(permsize, samplesize):    \n    perms = fact(permsize)\n    ranks = set()\n    while len(ranks) < samplesize:\n        ranks |= set( randrange(perms) \n                      for r in range(samplesize - len(ranks)) )\n    return ranks    \n\ndef test1(comment, unranker, ranker):    \n    n, samplesize, n2 = 3, 4, 12\n    print(comment)\n    perms = []\n    for r in range(fact(n)):\n        pi = identity_perm(n)\n        perm = unranker(n, r, pi)\n        perms.append((r, perm))\n    for r, pi in perms:\n        pi1 = init_pi1(n, pi)\n        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))\n    print('\\n  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))\n    print('')\n\ndef test2(comment, unranker):    \n    samplesize, n2 = 4, 144\n    print(comment)\n    print('  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + '\\n      '.join(wrap(repr(unranker(n2, r, pi)))))\n    print('')\n\nif __name__ == '__main__':\n    test1('First ordering:', unranker1, ranker1)\n    test1('Second ordering:', unranker2, ranker2)\n    test2('First ordering, large number of perms:', unranker1)\n"}
{"id": 418833, "name": "Permutations_Rank of a permutation", "source": "Translate Haskell to Python: fact :: Int -> Int\nfact n = product [1 .. n]\n\n\n\nrankPerm [] _ = []\nrankPerm list n = c : rankPerm (a ++ b) r\n  where\n    (q, r) = n `divMod` fact (length list - 1)\n    (a, c:b) = splitAt q list\n\npermRank [] = 0\npermRank (x:xs) = length (filter (< x) xs) * fact (length xs) + permRank xs\n\nmain :: IO ()\nmain = mapM_ f [0 .. 23]\n  where\n    f n = print (n, p, permRank p)\n      where\n        p = rankPerm [0 .. 3] n\n", "target": "from math import factorial as fact\nfrom random import randrange\nfrom textwrap import wrap\n\ndef identity_perm(n): \n    return list(range(n))\n\ndef unranker1(n, r, pi):\n    while n > 0:\n        n1, (rdivn, rmodn) = n-1, divmod(r, n)\n        pi[n1], pi[rmodn] = pi[rmodn], pi[n1]\n        n = n1\n        r = rdivn\n    return pi\n\ndef init_pi1(n, pi): \n    pi1 = [-1] * n\n    for i in range(n): \n        pi1[pi[i]] = i\n    return pi1\n\ndef ranker1(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s + n * ranker1(n1, pi, pi1)\n\ndef unranker2(n, r, pi):\n    while n > 0:\n        n1 = n-1\n        s, rmodf = divmod(r, fact(n1))\n        pi[n1], pi[s] = pi[s], pi[n1]\n        n = n1\n        r = rmodf\n    return pi\n\ndef ranker2(n, pi, pi1):\n    if n == 1: \n        return 0\n    n1 = n-1\n    s = pi[n1]\n    pi[n1], pi[pi1[n1]] = pi[pi1[n1]], pi[n1]\n    pi1[s], pi1[n1] = pi1[n1], pi1[s]\n    return s * fact(n1) + ranker2(n1, pi, pi1)\n\ndef get_random_ranks(permsize, samplesize):    \n    perms = fact(permsize)\n    ranks = set()\n    while len(ranks) < samplesize:\n        ranks |= set( randrange(perms) \n                      for r in range(samplesize - len(ranks)) )\n    return ranks    \n\ndef test1(comment, unranker, ranker):    \n    n, samplesize, n2 = 3, 4, 12\n    print(comment)\n    perms = []\n    for r in range(fact(n)):\n        pi = identity_perm(n)\n        perm = unranker(n, r, pi)\n        perms.append((r, perm))\n    for r, pi in perms:\n        pi1 = init_pi1(n, pi)\n        print('  From rank %2i to %r back to %2i' % (r, pi, ranker(n, pi[:], pi1)))\n    print('\\n  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + ' '.join('%2i' % i for i in unranker(n2, r, pi)))\n    print('')\n\ndef test2(comment, unranker):    \n    samplesize, n2 = 4, 144\n    print(comment)\n    print('  %i random individual samples of %i items:' % (samplesize, n2))\n    for r in get_random_ranks(n2, samplesize):\n        pi = identity_perm(n2)\n        print('    ' + '\\n      '.join(wrap(repr(unranker(n2, r, pi)))))\n    print('')\n\nif __name__ == '__main__':\n    test1('First ordering:', unranker1, ranker1)\n    test1('Second ordering:', unranker2, ranker2)\n    test2('First ordering, large number of perms:', unranker1)\n"}
{"id": 418834, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Haskell to Python: import           Control.Monad (guard)\nimport           Text.Printf   (printf)\n\np :: Int -> Int -> Int\np l n = calc !! pred n\n  where\n    digitCount = floor $ logBase 10 (fromIntegral l :: Float)\n    log10pwr   = logBase 10 2\n    calc = do\n      raised <- [-1 ..]\n      let firstDigits = floor $ 10 ** (snd (properFraction $ log10pwr * realToFrac raised) \n                        + realToFrac digitCount)\n      guard (firstDigits == l)\n      [raised]\n\nmain :: IO ()\nmain = mapM_ (\\(l, n) -> printf \"p(%d, %d) = %d\\n\" l n (p l n))\n  [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 418835, "name": "First power of 2 that has leading decimal digits of 12", "source": "Translate Haskell to Python: import           Control.Monad (guard)\nimport           Text.Printf   (printf)\n\np :: Int -> Int -> Int\np l n = calc !! pred n\n  where\n    digitCount = floor $ logBase 10 (fromIntegral l :: Float)\n    log10pwr   = logBase 10 2\n    calc = do\n      raised <- [-1 ..]\n      let firstDigits = floor $ 10 ** (snd (properFraction $ log10pwr * realToFrac raised) \n                        + realToFrac digitCount)\n      guard (firstDigits == l)\n      [raised]\n\nmain :: IO ()\nmain = mapM_ (\\(l, n) -> printf \"p(%d, %d) = %d\\n\" l n (p l n))\n  [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]\n", "target": "from math import log, modf, floor\n\ndef p(l, n, pwr=2):\n    l = int(abs(l))\n    digitcount = floor(log(l, 10))\n    log10pwr = log(pwr, 10)\n    raised, found = -1, 0\n    while found < n:\n        raised += 1\n        firstdigits = floor(10**(modf(log10pwr * raised)[0] + digitcount))\n        if firstdigits == l:\n            found += 1\n    return raised\n\n\nif __name__ == '__main__':\n    for l, n in [(12, 1), (12, 2), (123, 45), (123, 12345), (123, 678910)]:\n        print(f\"p({l}, {n}) =\", p(l, n))\n"}
{"id": 418836, "name": "Stirling numbers of the second kind", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling2 :: Integral a => (a, a) -> a\nstirling2 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      | (n > 0 && k == 0) || (n == 0 && k > 0) = 0\n      | n == k = 1\n      | k > n = 0\n      | otherwise = k * stirling2 (pred n, k) + stirling2 (pred n, pred k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >> \n    mapM_ (printf \"%10d\" . stirling2) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S2(100, k):\\n%d\\n\" $\n    maximum ([stirling2 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "computed = {}\n\ndef sterling2(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif (n > 0 and k == 0) or (n == 0 and k > 0):\n\t\treturn 0\n\tif n == k:\n\t\treturn 1\n\tif k > n:\n\t\treturn 0\n\tresult = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Stirling numbers of the second kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling2(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S2(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling2(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 418837, "name": "Stirling numbers of the second kind", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling2 :: Integral a => (a, a) -> a\nstirling2 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      | (n > 0 && k == 0) || (n == 0 && k > 0) = 0\n      | n == k = 1\n      | k > n = 0\n      | otherwise = k * stirling2 (pred n, k) + stirling2 (pred n, pred k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >> \n    mapM_ (printf \"%10d\" . stirling2) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S2(100, k):\\n%d\\n\" $\n    maximum ([stirling2 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "computed = {}\n\ndef sterling2(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif (n > 0 and k == 0) or (n == 0 and k > 0):\n\t\treturn 0\n\tif n == k:\n\t\treturn 1\n\tif k > n:\n\t\treturn 0\n\tresult = k * sterling2(n - 1, k) + sterling2(n - 1, k - 1)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Stirling numbers of the second kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling2(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S2(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling2(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 418838, "name": "Pierpont primes", "source": "Translate Haskell to Python: import Control.Monad (guard)\nimport Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Math.NumberTheory.Primes (Prime, unPrime, nextPrime)\nimport Math.NumberTheory.Primes.Testing (isPrime)\nimport Text.Printf (printf)\n\ndata PierPointKind = First | Second\n\nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] b = b\nmerge a@(x:xs) b@(y:ys) | x < y     = x : merge xs b\n                        | otherwise = y : merge a ys\n\nnSmooth :: Integer -> [Integer]\nnSmooth p = 1 : foldr u [] factors\n where\n  factors = takeWhile (<=p) primes\n  primes = map unPrime [nextPrime 1..]\n  u n s = r\n   where \n    r = merge s (map (n*) (1:r))\n\npierpoints :: PierPointKind -> [Integer]\npierpoints k = do \n  n <- nSmooth 3\n  let x = case k of First  -> succ n\n                    Second -> pred n\n  guard (isPrime x) >> [x]\n\nmain :: IO ()\nmain = do \n  printf \"\\nFirst 50 Pierpont primes of the first kind:\\n\"\n  mapM_ (\\row -> mapM_ (printf \"%12s\" . commas) row >> printf \"\\n\") (rows $ pierpoints First)\n  printf \"\\nFirst 50 Pierpont primes of the second kind:\\n\"\n  mapM_ (\\row -> mapM_ (printf \"%12s\" . commas) row >> printf \"\\n\") (rows $ pierpoints Second)\n  printf \"\\n250th Pierpont prime of the first kind: %s\\n\" (commas $ pierpoints First !! 249)\n  printf \"\\n250th Pierpont prime of the second kind: %s\\n\\n\" (commas $ pierpoints Second !! 249)\n where\n  rows = chunksOf 10 . take 50\n  commas = reverse . intercalate \",\" . chunksOf 3 . reverse . show\n", "target": "import random\n\n\ndef is_Prime(n):\n    \n    if n!=int(n):\n        return False\n    n=int(n)\n    \n    if n==0 or n==1 or n==4 or n==6 or n==8 or n==9:\n        return False\n\n    if n==2 or n==3 or n==5 or n==7:\n        return True\n    s = 0\n    d = n-1\n    while d%2==0:\n        d>>=1\n        s+=1\n    assert(2**s * d == n-1)\n\n    def trial_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True  \n\n    for i in range(8):\n        a = random.randrange(2, n)\n        if trial_composite(a):\n            return False\n\n    return True\n\ndef pierpont(ulim, vlim, first):\n    p = 0\n    p2 = 1\n    p3 = 1\n    pp = []\n    for v in xrange(vlim):\n        for u in xrange(ulim):\n            p = p2 * p3\n            if first:\n                p = p + 1\n            else:\n                p = p - 1\n            if is_Prime(p):\n                pp.append(p)\n            p2 = p2 * 2\n        p3 = p3 * 3\n        p2 = 1\n    pp.sort()\n    return pp\n\ndef main():\n    print \"First 50 Pierpont primes of the first kind:\"\n    pp = pierpont(120, 80, True)\n    for i in xrange(50):\n        print \"%8d \" % pp[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"First 50 Pierpont primes of the second kind:\"\n    pp2 = pierpont(120, 80, False)\n    for i in xrange(50):\n        print \"%8d \" % pp2[i],\n        if (i - 9) % 10 == 0:\n            print\n    print \"250th Pierpont prime of the first kind:\", pp[249]\n    print \"250th Pierpont prime of the second kind:\", pp2[249]\n\nmain()\n"}
{"id": 418839, "name": "N-smooth numbers", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\nimport Text.Printf (printf)\n\n \nmerge :: Ord a => [a] -> [a] -> [a]\nmerge [] b = b\nmerge a@(x:xs) b@(y:ys) | x < y     = x : merge xs b\n                        | otherwise = y : merge a ys\n \nnSmooth :: Integer -> [Integer]\nnSmooth p = 1 : foldr u [] factors\n where\n   factors = takeWhile (<=p) primes\n   u n s = r\n    where r = merge s (map (n*) (1:r))\n\nmain :: IO ()\nmain = do\n  mapM_ (printf \"First 25 %d-smooth:\\n%s\\n\\n\" <*> showTwentyFive) firstTenPrimes\n  mapM_\n    (printf \"The 3,000 to 3,202 %d-smooth numbers are:\\n%s\\n\\n\" <*> showRange1)\n    firstTenPrimes\n  mapM_\n    (printf \"The 30,000 to 30,019 %d-smooth numbers are:\\n%s\\n\\n\" <*> showRange2)\n    [503, 509, 521]\n  where\n    firstTenPrimes = take 10 primes\n    showTwentyFive = show . take 25 . nSmooth\n    showRange1 = show . ((<$> [2999 .. 3001]) . (!!) . nSmooth)\n    showRange2 = show . ((<$> [29999 .. 30018]) . (!!) . nSmooth)\n", "target": "primes = [2, 3, 5, 7, 11, 13, 17, 19, 23]\n\ndef isPrime(n):\n    if n < 2:\n        return False\n\n    for i in primes:\n        if n == i:\n            return True\n        if n % i == 0:\n            return False\n        if i * i > n:\n            return True\n    print \"Oops,\", n, \" is too large\"\n\ndef init():\n    s = 24\n    while s < 600:\n        if isPrime(s - 1) and s - 1 > primes[-1]:\n            primes.append(s - 1)\n        if isPrime(s + 1) and s + 1 > primes[-1]:\n            primes.append(s + 1)\n        s += 6\n\ndef nsmooth(n, size):\n    if n < 2 or n > 521:\n        raise Exception(\"n\")\n    if size < 1:\n        raise Exception(\"n\")\n\n    bn = n\n    ok = False\n    for prime in primes:\n        if bn == prime:\n            ok = True\n            break\n    if not ok:\n        raise Exception(\"must be a prime number: n\")\n\n    ns = [0] * size\n    ns[0] = 1\n\n    next = []\n    for prime in primes:\n        if prime > bn:\n            break\n        next.append(prime)\n\n    indicies = [0] * len(next)\n    for m in xrange(1, size):\n        ns[m] = min(next)\n        for i in xrange(0, len(indicies)):\n            if ns[m] == next[i]:\n                indicies[i] += 1\n                next[i] = primes[i] * ns[indicies[i]]\n\n    return ns\n\ndef main():\n    init()\n\n    for p in primes:\n        if p >= 30:\n            break\n        print \"The first\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 25)\n        print\n\n    for p in primes[1:]:\n        if p >= 30:\n            break\n        print \"The 3000 to 3202\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 3002)[2999:]\n        print\n\n    for p in [503, 509, 521]:\n        print \"The 30000 to 3019\", p, \"-smooth numbers are:\"\n        print nsmooth(p, 30019)[29999:]\n        print\n\nmain()\n"}
{"id": 418840, "name": "Partition an integer x into n primes", "source": "Translate Haskell to Python: import Data.List (delete, intercalate)\nimport Data.Numbers.Primes (primes)\nimport Data.Bool (bool)\n\n\npartitions :: Int -> Int -> [Int]\npartitions x n\n  | n <= 1 =\n    [ x\n    | x == last ps ]\n  | otherwise = go ps x n\n  where\n    ps = takeWhile (<= x) primes\n    go ps_ x 1 =\n      [ x\n      | x `elem` ps_ ]\n    go ps_ x n = ((flip bool [] . head) <*> null) (ps_ >>= found)\n      where\n        found p =\n          ((flip bool [] . return . (p :)) <*> null)\n            ((go =<< delete p . flip takeWhile ps_ . (>=)) (x - p) (pred n))\n\n\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  (\\(x, n) ->\n      intercalate\n        \" -> \"\n        [ justifyLeft 9 ' ' (show (x, n))\n        , let xs = partitions x n\n          in bool\n               (tail $ concatMap (('+' :) . show) xs)\n               \"(no solution)\"\n               (null xs)\n        ]) <$>\n  concat\n    [ [(99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24)]\n    , (,) 22699 <$> [1 .. 4]\n    , [(40355, 3)]\n    ]\n\n\njustifyLeft :: Int -> Char -> String -> String\njustifyLeft n c s = take n (s ++ replicate n c)\n", "target": "from itertools import combinations as cmb\n\n\ndef isP(n):\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    return all(n % x > 0 for x in range(3, int(n ** 0.5) + 1, 2))\n\n\ndef genP(n):\n    p = [2]\n    p.extend([x for x in range(3, n + 1, 2) if isP(x)])\n    return p\n\n\ndata = [\n    (99809, 1), (18, 2), (19, 3), (20, 4), (2017, 24),\n    (22699, 1), (22699, 2), (22699, 3), (22699, 4), (40355, 3)]\n\n\nfor n, cnt in data:\n    ci = iter(cmb(genP(n), cnt))\n    while True:\n        try:\n            c = next(ci)\n            if sum(c) == n:\n                print(' '.join(\n                    [repr((n, cnt)), \"->\", '+'.join(str(s) for s in c)]\n                ))\n                break\n        except StopIteration:\n            print(repr((n, cnt)) + \" -> Not possible\")\n            break\n"}
{"id": 418841, "name": "Zeckendorf arithmetic", "source": "Translate Haskell to Python: \nimport Data.List (find, mapAccumL)\nimport Control.Arrow (first, second)\n\n\n\nfibs :: Num a => a -> a -> [a]\nfibs a b = res\n  where\n    res = a : b : zipWith (+) res (tail res)\n\ndata Fib = Fib { sign :: Int, digits :: [Int]}\n\n\nmkFib s ds =\n  case dropWhile (==0) ds of\n    [] -> 0\n    ds -> Fib s (reverse ds)\n\n\ninstance Show Fib where\n  show (Fib s ds) = sig s ++ foldMap show (reverse ds)\n    where sig = \\case { -1 -> \"-\"; s -> \"\" }\n\n\ninstance Eq Fib where\n  Fib sa a == Fib sb b = sa == sb && a == b\n\n\ninstance Ord Fib where\n  a `compare` b =\n    sign a `compare` sign b <>\n    case find (/= 0) $ alignWith (-) (digits a) (digits b) of\n      Nothing -> EQ\n      Just 1 -> if sign a > 0 then GT else LT\n      Just (-1) -> if sign a > 0 then LT else GT\n\n\ninstance Num Fib where\n  negate (Fib s ds) = Fib (negate s) ds\n  abs (Fib s ds) = Fib 1 ds\n  signum (Fib s _) = fromIntegral s\n\n  fromInteger n =\n    case compare n 0 of\n      LT -> negate $ fromInteger (- n)\n      EQ -> Fib 0 [0]\n      GT -> Fib 1 . reverse . fst $ divModFib n 1\n\n  0 + a = a\n  a + 0 = a\n  a + b =\n    case (sign a, sign b) of\n      ( 1, 1) -> res\n      (-1, 1) -> b - (-a)\n      ( 1,-1) -> a - (-b)\n      (-1,-1) -> - ((- a) + (- b))\n    where\n      res = mkFib 1 . process $ 0:0:c\n      c = alignWith (+) (digits a) (digits b)\n       \n      process =\n        runRight 3 r2 . runLeftR 3 r2 . runRightR 4 r1\n\n  0 - a = -a\n  a - 0 = a\n  a - b =\n    case (sign a, sign b) of\n      ( 1, 1) -> res\n      (-1, 1) -> - ((-a) + b)\n      ( 1,-1) -> a + (-b)\n      (-1,-1) -> - ((-a) - (-b))  \n    where\n      res = case find (/= 0) c of\n        Just 1  -> mkFib 1 . process $ c\n        Just (-1) -> - (b - a)\n        Nothing -> 0\n      c = alignWith (-) (digits a) (digits b)\n      \n      process =\n        runRight 3 r2 . runLeftR 3 r2 . runRightR 4 r1 . runRight 3 r3\n\n  0 * a = 0\n  a * 0 = 0\n  1 * a = a\n  a * 1 = a\n  a * b =\n    case (sign a, sign b) of\n      (1, 1) -> res\n      (-1, 1) -> - ((-a) * b)\n      ( 1,-1) -> - (a * (-b))\n      (-1,-1) -> ((-a) * (-b))  \n    where\n      \n      table = fibs a (a + a)\n      res = sum $ onlyOnes $ zip (digits b) table\n      onlyOnes = map snd . filter ((==1) . fst)\n\n\ninstance Enum Fib where\n  toEnum = fromInteger . fromIntegral\n  fromEnum = fromIntegral . toInteger\n  \ninstance Real Fib where\n  toRational = fromInteger . toInteger\n  \n\ninstance Integral Fib where\n  toInteger (Fib s ds) = signum (fromIntegral s) * res\n    where\n      res = sum (zipWith (*) (fibs 1 2) (fromIntegral <$> ds))\n\n  quotRem 0 _ = (0, 0)\n  quotRem a 0 = error \"divide by zero\"\n  quotRem a b = case (sign a, sign b) of\n      (1, 1) -> first (mkFib 1) $ divModFib a b\n      (-1, 1) -> second negate . first negate $ quotRem (-a) b\n      ( 1,-1) -> first negate $ quotRem a (-b)\n      (-1,-1) -> second negate $ quotRem (-a) (-b) \n\n\n\n\n\ndivModFib :: (Ord a, Num c, Num a) => a -> a -> ([c], a)\ndivModFib a b = (q, r)\n  where\n    (r, q) = mapAccumL f a $ reverse $ takeWhile (<= a) table\n    table = fibs b (b+b)\n    f n x = if  n < x then (n, 0) else (n - x, 1)\n\n\n\nrunRight n f = go\n  where\n    go []  = []\n    go lst = let (w, r) = splitAt n lst \n                 (h: t) = f w\n             in h : go (t ++ r)\n                    \n\nrunRightR n f = go []\n  where\n    go res []  = res\n    go res lst = let (w, r) = splitAt n lst \n                     (h: t) = f w\n                 in go (h : res) (t ++ r)\n\n\nrunLeftR n f = runRightR n (reverse . f . reverse) \n\n\nr1 = \\case [0,3,0]   -> [1,1,1]\n           [0,2,0]   -> [1,0,1]\n           [0,1,2]   -> [1,0,1]\n           [0,2,1]   -> [1,1,0]\n           [x,0,2]   -> [x,1,0]\n           [x,0,3]   -> [x,1,1]\n           [0,1,2,0] -> [1,0,1,0]\n           [0,2,0,x] -> [1,0,0,x+1]\n           [0,3,0,x] -> [1,1,0,x+1]\n           [0,2,1,x] -> [1,1,0,x  ]\n           [0,1,2,x] -> [1,0,1,x  ]\n           l -> l\n\nr2 = \\case [0,1,1] -> [1,0,0]\n           l -> l\n\nr3 = \\case [1,-1]    -> [0,1]\n           [2,-1]    -> [1,1]\n           [1, 0, 0] -> [0,1,1]\n           [1,-1, 0] -> [0,0,1]\n           [1,-1, 1] -> [0,0,2]\n           [1, 0,-1] -> [0,1,0]\n           [2, 0, 0] -> [1,1,1]\n           [2,-1, 0] -> [1,0,1]\n           [2,-1, 1] -> [1,0,2]\n           [2, 0,-1] -> [1,1,0]\n           l -> l\n\nalignWith :: (Int -> Int -> a) -> [Int] -> [Int] -> [a]\nalignWith f a b = go [] a b\n  where\n    go res as [] = ((`f` 0) <$> reverse as) ++ res\n    go res [] bs = ((0 `f`) <$> reverse bs) ++ res\n    go res (a:as) (b:bs) = go (f a b : res) as bs\n", "target": "import copy\n\nclass Zeckendorf:\n    def __init__(self, x='0'):\n        q = 1\n        i = len(x) - 1\n        self.dLen = int(i / 2)\n        self.dVal = 0\n        while i >= 0:\n            self.dVal = self.dVal + (ord(x[i]) - ord('0')) * q\n            q = q * 2\n            i = i -1\n\n    def a(self, n):\n        i = n\n        while True:\n            if self.dLen < i:\n                self.dLen = i\n            j = (self.dVal >> (i * 2)) & 3\n            if j == 0 or j == 1:\n                return\n            if j == 2:\n                if (self.dVal >> ((i + 1) * 2) & 1) != 1:\n                    return\n                self.dVal = self.dVal + (1 << (i * 2 + 1))\n                return\n            if j == 3:\n                temp = 3 << (i * 2)\n                temp = temp ^ -1\n                self.dVal = self.dVal & temp\n                self.b((i + 1) * 2)\n            i = i + 1\n\n    def b(self, pos):\n        if pos == 0:\n            self.inc()\n            return\n        if (self.dVal >> pos) & 1 == 0:\n            self.dVal = self.dVal + (1 << pos)\n            self.a(int(pos / 2))\n            if pos > 1:\n                self.a(int(pos / 2) - 1)\n        else:\n            temp = 1 << pos\n            temp = temp ^ -1\n            self.dVal = self.dVal & temp\n            self.b(pos + 1)\n            self.b(pos - (2 if pos > 1 else 1))\n\n    def c(self, pos):\n        if (self.dVal >> pos) & 1 == 1:\n            temp = 1 << pos\n            temp = temp ^ -1\n            self.dVal = self.dVal & temp\n            return\n        self.c(pos + 1)\n        if pos > 0:\n            self.b(pos - 1)\n        else:\n            self.inc()\n\n    def inc(self):\n        self.dVal = self.dVal + 1\n        self.a(0)\n\n    def __add__(self, rhs):\n        copy = self\n        rhs_dVal = rhs.dVal\n        limit = (rhs.dLen + 1) * 2\n        for gn in range(0, limit):\n            if ((rhs_dVal >> gn) & 1) == 1:\n                copy.b(gn)\n        return copy\n\n    def __sub__(self, rhs):\n        copy = self\n        rhs_dVal = rhs.dVal\n        limit = (rhs.dLen + 1) * 2\n        for gn in range(0, limit):\n            if (rhs_dVal >> gn) & 1 == 1:\n                copy.c(gn)\n        while (((copy.dVal >> ((copy.dLen * 2) & 31)) & 3) == 0) or (copy.dLen == 0):\n            copy.dLen = copy.dLen - 1\n        return copy\n\n    def __mul__(self, rhs):\n        na = copy.deepcopy(rhs)\n        nb = copy.deepcopy(rhs)\n        nr = Zeckendorf()\n        dVal = self.dVal\n        for i in range(0, (self.dLen + 1) * 2):\n            if ((dVal >> i) & 1) > 0:\n                nr = nr + nb\n            nt = copy.deepcopy(nb)\n            nb = nb + na\n            na = copy.deepcopy(nt)\n        return nr\n\n    def __str__(self):\n        dig = [\"00\", \"01\", \"10\"]\n        dig1 = [\"\", \"1\", \"10\"]\n\n        if self.dVal == 0:\n            return '0'\n        idx = (self.dVal >> ((self.dLen * 2) & 31)) & 3\n        sb = dig1[idx]\n        i = self.dLen - 1\n        while i >= 0:\n            idx = (self.dVal >> (i * 2)) & 3\n            sb = sb + dig[idx]\n            i = i - 1\n        return sb\n\n\nprint \"Addition:\"\ng = Zeckendorf(\"10\")\ng = g + Zeckendorf(\"10\")\nprint g\ng = g + Zeckendorf(\"10\")\nprint g\ng = g + Zeckendorf(\"1001\")\nprint g\ng = g + Zeckendorf(\"1000\")\nprint g\ng = g + Zeckendorf(\"10101\")\nprint g\nprint\n\nprint \"Subtraction:\"\ng = Zeckendorf(\"1000\")\ng = g - Zeckendorf(\"101\")\nprint g\ng = Zeckendorf(\"10101010\")\ng = g - Zeckendorf(\"1010101\")\nprint g\nprint\n\nprint \"Multiplication:\"\ng = Zeckendorf(\"1001\")\ng = g * Zeckendorf(\"101\")\nprint g\ng = Zeckendorf(\"101010\")\ng = g + Zeckendorf(\"101\")\nprint g\n"}
{"id": 418842, "name": "Stirling numbers of the first kind", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling1 :: Integral a => (a, a) -> a\nstirling1 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      |  n > 0 && k == 0 = 0\n      | k > n            = 0\n      | otherwise = stirling1 (pred n, pred k) + pred n * stirling1 (pred n, k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >>\n    mapM_ (printf \"%10d\" . stirling1) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S1(100, k):\\n%d\\n\" $\n    maximum ([stirling1 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "computed = {}\n\ndef sterling1(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif n > 0 and k == 0:\n\t\treturn 0\n\tif k > n:\n\t\treturn 0\n\tresult = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Unsigned Stirling numbers of the first kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling1(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S1(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling1(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 418843, "name": "Stirling numbers of the first kind", "source": "Translate Haskell to Python: import Text.Printf (printf)\nimport Data.List (groupBy)\nimport qualified Data.MemoCombinators as Memo\n\nstirling1 :: Integral a => (a, a) -> a\nstirling1 = Memo.pair Memo.integral Memo.integral f\n  where\n    f (n, k)\n      | n == 0 && k == 0 = 1\n      |  n > 0 && k == 0 = 0\n      | k > n            = 0\n      | otherwise = stirling1 (pred n, pred k) + pred n * stirling1 (pred n, k)\n\nmain :: IO ()\nmain = do\n  printf \"n/k\" \n  mapM_ (printf \"%10d\") ([0..12] :: [Int]) >> printf \"\\n\"\n  printf \"%s\\n\" $ replicate (13 * 10 + 3) '-'\n  mapM_ (\\row -> printf \"%2d|\" (fst $ head row) >>\n    mapM_ (printf \"%10d\" . stirling1) row >> printf \"\\n\") table\n  printf \"\\nThe maximum value of S1(100, k):\\n%d\\n\" $\n    maximum ([stirling1 (100, n) | n <- [1..100]] :: [Integer])\n  where\n    table :: [[(Int, Int)]]\n    table = groupBy (\\a b -> fst a == fst b) $ (,) <$> [0..12] <*> [0..12]\n", "target": "computed = {}\n\ndef sterling1(n, k):\n\tkey = str(n) + \",\" + str(k)\n\n\tif key in computed.keys():\n\t\treturn computed[key]\n\tif n == k == 0:\n\t\treturn 1\n\tif n > 0 and k == 0:\n\t\treturn 0\n\tif k > n:\n\t\treturn 0\n\tresult = sterling1(n - 1, k - 1) + (n - 1) * sterling1(n - 1, k)\n\tcomputed[key] = result\n\treturn result\n\nprint(\"Unsigned Stirling numbers of the first kind:\")\nMAX = 12\nprint(\"n/k\".ljust(10), end=\"\")\nfor n in range(MAX + 1):\n\tprint(str(n).rjust(10), end=\"\")\nprint()\nfor n in range(MAX + 1):\n\tprint(str(n).ljust(10), end=\"\")\n\tfor k in range(n + 1):\n\t\tprint(str(sterling1(n, k)).rjust(10), end=\"\")\n\tprint()\nprint(\"The maximum value of S1(100, k) = \")\nprevious = 0\nfor k in range(1, 100 + 1):\n\tcurrent = sterling1(100, k)\n\tif current > previous:\n\t\tprevious = current\n\telse:\n\t\tprint(\"{0}\\n({1} digits, k = {2})\\n\".format(previous, len(str(previous)), k - 1))\n\t\tbreak\n"}
{"id": 418844, "name": "Vector", "source": "Translate Haskell to Python: add (u,v) (x,y)      = (u+x,v+y)\nminus (u,v) (x,y)    = (u-x,v-y)\nmultByScalar k (x,y) = (k*x,k*y)\ndivByScalar (x,y) k  = (x/k,y/k)\n\nmain = do\n  let vecA = (3.0,8.0) \n  let (r,theta) = (3,pi/12) :: (Double,Double)\n  let vecB = (r*(cos theta),r*(sin theta)) \n  putStrLn $ \"vecA = \" ++ (show vecA)\n  putStrLn $ \"vecB = \" ++ (show vecB)\n  putStrLn $ \"vecA + vecB = \" ++ (show.add vecA $ vecB)\n  putStrLn $ \"vecA - vecB = \" ++ (show.minus vecA $ vecB)\n  putStrLn $ \"2 * vecB = \" ++ (show.multByScalar 2 $ vecB)\n  putStrLn $ \"vecA / 3 = \" ++ (show.divByScalar vecA $ 3)\n", "target": "v1 = PVector(5, 7)\nv2 = PVector(2, 3)\n\nprintln('{} {} {} {}\\n'.format( v1.x, v1.y, v1.mag(), v1.heading()))\n\n\nprintln(v1 + v2) \nprintln(v1 - v2) \nprintln(v1 * 11) \nprintln(v1 / 2)  \nprintln('')\n\n\nprintln(v1.sub(v1))  \nprintln(v1.add(v2))  \nprintln(v1.mult(10)) \nprintln(v1.div(10))  \n"}
{"id": 418845, "name": "Elliptic curve arithmetic", "source": "Translate Haskell to Python: import Data.Monoid\nimport Control.Monad (guard)\nimport Test.QuickCheck (quickCheck)\n", "target": "\n\nclass Point:\n    b = 7\n    def __init__(self, x=float('inf'), y=float('inf')):\n        self.x = x\n        self.y = y\n\n    def copy(self):\n        return Point(self.x, self.y)\n\n    def is_zero(self):\n        return self.x > 1e20 or self.x < -1e20\n\n    def neg(self):\n        return Point(self.x, -self.y)\n\n    def dbl(self):\n        if self.is_zero():\n            return self.copy()\n        try:\n            L = (3 * self.x * self.x) / (2 * self.y)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - 2 * self.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def add(self, q):\n        if self.x == q.x and self.y == q.y:\n            return self.dbl()\n        if self.is_zero():\n            return q.copy()\n        if q.is_zero():\n            return self.copy()\n        try:\n            L = (q.y - self.y) / (q.x - self.x)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - self.x - q.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def mul(self, n):\n        p = self.copy()\n        r = Point()\n        i = 1\n        while i <= n:\n            if i&n:\n                r = r.add(p)\n            p = p.dbl()\n            i <<= 1\n        return r\n\n    def __str__(self):\n        return \"({:.3f}, {:.3f})\".format(self.x, self.y)\n\ndef show(s, p):\n    print(s, \"Zero\" if p.is_zero() else p)\n\ndef from_y(y):\n    n = y * y - Point.b\n    x = n**(1./3) if n>=0 else -((-n)**(1./3))\n    return Point(x, y)\n\n\na = from_y(1)\nb = from_y(2)\nshow(\"a =\", a)\nshow(\"b =\", b)\nc = a.add(b)\nshow(\"c = a + b =\", c)\nd = c.neg()\nshow(\"d = -c =\", d)\nshow(\"c + d =\", c.add(d))\nshow(\"a + b + d =\", a.add(b.add(d)))\nshow(\"a * 12345 =\", a.mul(12345))\n"}
{"id": 418846, "name": "Elliptic curve arithmetic", "source": "Translate Haskell to Python: import Data.Monoid\nimport Control.Monad (guard)\nimport Test.QuickCheck (quickCheck)\n", "target": "\n\nclass Point:\n    b = 7\n    def __init__(self, x=float('inf'), y=float('inf')):\n        self.x = x\n        self.y = y\n\n    def copy(self):\n        return Point(self.x, self.y)\n\n    def is_zero(self):\n        return self.x > 1e20 or self.x < -1e20\n\n    def neg(self):\n        return Point(self.x, -self.y)\n\n    def dbl(self):\n        if self.is_zero():\n            return self.copy()\n        try:\n            L = (3 * self.x * self.x) / (2 * self.y)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - 2 * self.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def add(self, q):\n        if self.x == q.x and self.y == q.y:\n            return self.dbl()\n        if self.is_zero():\n            return q.copy()\n        if q.is_zero():\n            return self.copy()\n        try:\n            L = (q.y - self.y) / (q.x - self.x)\n        except ZeroDivisionError:\n            return Point()\n        x = L * L - self.x - q.x\n        return Point(x, L * (self.x - x) - self.y)\n\n    def mul(self, n):\n        p = self.copy()\n        r = Point()\n        i = 1\n        while i <= n:\n            if i&n:\n                r = r.add(p)\n            p = p.dbl()\n            i <<= 1\n        return r\n\n    def __str__(self):\n        return \"({:.3f}, {:.3f})\".format(self.x, self.y)\n\ndef show(s, p):\n    print(s, \"Zero\" if p.is_zero() else p)\n\ndef from_y(y):\n    n = y * y - Point.b\n    x = n**(1./3) if n>=0 else -((-n)**(1./3))\n    return Point(x, y)\n\n\na = from_y(1)\nb = from_y(2)\nshow(\"a =\", a)\nshow(\"b =\", b)\nc = a.add(b)\nshow(\"c = a + b =\", c)\nd = c.neg()\nshow(\"d = -c =\", d)\nshow(\"c + d =\", c.add(d))\nshow(\"a + b + d =\", a.add(b.add(d)))\nshow(\"a * 12345 =\", a.mul(12345))\n"}
{"id": 418847, "name": "Burrows\u2013Wheeler transform", "source": "Translate Haskell to Python: \n\n\n\n\n\nimport Data.List ((!!), find, sort, tails, transpose)\nimport Data.Maybe (fromJust)\nimport Text.Printf (printf)\n\nnewtype BWT a = BWT [Val a]\n\nbwt :: Ord a => [a] -> BWT a\nbwt xs = let n  = length xs + 2\n             ys = transpose $ sort $ take n $ tails $ cycle $ pos xs\n         in BWT $ ys !! (n-1)\n\ninvBwt :: Ord a => BWT a -> [a]\ninvBwt (BWT xs) = let ys = iterate step (map (const []) xs) !! length xs\n                  in unpos $ fromJust $ find ((== Post) . last) ys\n  where step = sort . zipWith (:) xs\n\n\ndata Val a = In a | Pre | Post deriving (Eq, Ord)\n\npos :: [a] -> [Val a]\npos xs = Pre : map In xs ++ [Post]\n\nunpos :: [Val a] -> [a]\nunpos xs = [x | In x <- xs]\n\n\nmain :: IO ()\nmain = mapM_ testBWT [ \"\", \"a\", \"BANANA\", \"dogwood\",\n                       \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                       \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\" ]\n\ntestBWT :: String -> IO ()\ntestBWT xs = let fwd = bwt xs\n                 inv = invBwt fwd\n             in printf \"%s\\n\\t%s\\n\\t%s\\n\" xs (pretty fwd) inv\n  where pretty (BWT ps) = map prettyVal ps\n        prettyVal (In c) = c\n        prettyVal Pre    = '^'\n        prettyVal Post   = '|'\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 418848, "name": "Burrows\u2013Wheeler transform", "source": "Translate Haskell to Python: \n\n\n\n\n\nimport Data.List ((!!), find, sort, tails, transpose)\nimport Data.Maybe (fromJust)\nimport Text.Printf (printf)\n\nnewtype BWT a = BWT [Val a]\n\nbwt :: Ord a => [a] -> BWT a\nbwt xs = let n  = length xs + 2\n             ys = transpose $ sort $ take n $ tails $ cycle $ pos xs\n         in BWT $ ys !! (n-1)\n\ninvBwt :: Ord a => BWT a -> [a]\ninvBwt (BWT xs) = let ys = iterate step (map (const []) xs) !! length xs\n                  in unpos $ fromJust $ find ((== Post) . last) ys\n  where step = sort . zipWith (:) xs\n\n\ndata Val a = In a | Pre | Post deriving (Eq, Ord)\n\npos :: [a] -> [Val a]\npos xs = Pre : map In xs ++ [Post]\n\nunpos :: [Val a] -> [a]\nunpos xs = [x | In x <- xs]\n\n\nmain :: IO ()\nmain = mapM_ testBWT [ \"\", \"a\", \"BANANA\", \"dogwood\",\n                       \"TO BE OR NOT TO BE OR WANT TO BE OR NOT?\",\n                       \"SIX.MIXED.PIXIES.SIFT.SIXTY.PIXIE.DUST.BOXES\" ]\n\ntestBWT :: String -> IO ()\ntestBWT xs = let fwd = bwt xs\n                 inv = invBwt fwd\n             in printf \"%s\\n\\t%s\\n\\t%s\\n\" xs (pretty fwd) inv\n  where pretty (BWT ps) = map prettyVal ps\n        prettyVal (In c) = c\n        prettyVal Pre    = '^'\n        prettyVal Post   = '|'\n", "target": "def bwt(s):\n    \n    assert \"\\002\" not in s and \"\\003\" not in s, \"Input string cannot contain STX and ETX characters\"\n    s = \"\\002\" + s + \"\\003\"  \n    table = sorted(s[i:] + s[:i] for i in range(len(s)))  \n    last_column = [row[-1:] for row in table]  \n    return \"\".join(last_column)  \n\n\ndef ibwt(r):\n    \n    table = [\"\"] * len(r)  \n    for i in range(len(r)):\n        table = sorted(r[i] + table[i] for i in range(len(r)))  \n    s = [row for row in table if row.endswith(\"\\003\")][0]  \n    return s.rstrip(\"\\003\").strip(\"\\002\")  \n"}
{"id": 418849, "name": "Faulhaber's triangle", "source": "Translate Haskell to Python: import Data.Ratio (Ratio, denominator, numerator, (%))\n\n\n\nfaulhaber :: Int -> Rational -> Rational\nfaulhaber p n =\n  sum $\n    zipWith ((*) . (n ^)) [1 ..] (faulhaberTriangle !! p)\n\n\nfaulhaberTriangle :: [[Rational]]\nfaulhaberTriangle =\n  tail $\n    scanl\n      ( \\rs n ->\n          let xs = zipWith ((*) . (n %)) [2 ..] rs\n           in 1 - sum xs : xs\n      )\n      []\n      [0 ..]\n\n\n\nmain :: IO ()\nmain = do\n  let triangle = take 10 faulhaberTriangle\n      widths = maxWidths triangle\n  mapM_\n    putStrLn\n    [ unlines\n        ( (justifyRatio widths 8 ' ' =<<)\n            <$> triangle\n        ),\n      (show . numerator) (faulhaber 17 1000)\n    ]\n\n\n\njustifyRatio ::\n  (Int, Int) -> Int -> Char -> Rational -> String\njustifyRatio (wn, wd) n c nd =\n  go $\n    [numerator, denominator] <*> [nd]\n  where\n    \n    w = max n (wn + wd + 2)\n    go [num, den]\n      | 1 == den = center w c (show num)\n      | otherwise =\n        let (q, r) = quotRem (w - 1) 2\n         in concat\n              [ justifyRight q c (show num),\n                \"/\",\n                justifyLeft (q + r) c (show den)\n              ]\n\njustifyLeft :: Int -> a -> [a] -> [a]\njustifyLeft n c s = take n (s <> replicate n c)\n\njustifyRight :: Int -> a -> [a] -> [a]\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n\ncenter :: Int -> a -> [a] -> [a]\ncenter n c s =\n  let (q, r) = quotRem (n - length s) 2\n      pad = replicate q c\n   in concat [pad, s, pad, replicate r c]\n\nmaxWidths :: [[Rational]] -> (Int, Int)\nmaxWidths xss =\n  let widest f xs = maximum $ fmap (length . show . f) xs\n   in ((,) . widest numerator <*> widest denominator) $\n        concat xss\n", "target": "\n\nfrom itertools import accumulate, chain, count, islice\nfrom fractions import Fraction\n\n\n\ndef faulhaberTriangle(m):\n    \n    def go(rs, n):\n        def f(x, y):\n            return Fraction(n, x) * y\n        xs = list(map(f, islice(count(2), m), rs))\n        return [Fraction(1 - sum(xs), 1)] + xs\n\n    return list(accumulate(\n        [[]] + list(islice(count(0), 1 + m)),\n        go\n    ))[1:]\n\n\n\ndef faulhaberSum(p, n):\n    \n    def go(x, y):\n        return y * (n ** x)\n\n    return sum(\n        map(go, count(1), faulhaberTriangle(p)[-1])\n    )\n\n\n\ndef main():\n    \n\n    fs = faulhaberTriangle(9)\n    print(\n        fTable(__doc__ + ':\\n')(str)(\n            compose(concat)(\n                fmap(showRatio(3)(3))\n            )\n        )(\n            index(fs)\n        )(range(0, len(fs)))\n    )\n    print('')\n    print(\n        faulhaberSum(17, 1000)\n    )\n\n\n\n\n\n\ndef fTable(s):\n    \n    def gox(xShow):\n        def gofx(fxShow):\n            def gof(f):\n                def goxs(xs):\n                    ys = [xShow(x) for x in xs]\n                    w = max(map(len, ys))\n\n                    def arrowed(x, y):\n                        return y.rjust(w, ' ') + ' -> ' + (\n                            fxShow(f(x))\n                        )\n                    return s + '\\n' + '\\n'.join(\n                        map(arrowed, xs, ys)\n                    )\n                return goxs\n            return gof\n        return gofx\n    return gox\n\n\n\n\n\ndef compose(g):\n    \n    return lambda f: lambda x: g(f(x))\n\n\n\n\ndef concat(xs):\n    \n    def f(ys):\n        zs = list(chain(*ys))\n        return ''.join(zs) if isinstance(ys[0], str) else zs\n\n    return (\n        f(xs) if isinstance(xs, list) else (\n            chain.from_iterable(xs)\n        )\n    ) if xs else []\n\n\n\ndef fmap(f):\n    \n    def go(xs):\n        return list(map(f, xs))\n\n    return go\n\n\n\ndef index(xs):\n    \n    return lambda n: None if 0 > n else (\n        xs[n] if (\n            hasattr(xs, \"__getitem__\")\n        ) else next(islice(xs, n, None))\n    )\n\n\n\ndef showRatio(m):\n    \n    def go(n):\n        def f(r):\n            d = r.denominator\n            return str(r.numerator).rjust(m, ' ') + (\n                ('/' + str(d).ljust(n, ' ')) if 1 != d else (\n                    ' ' * (1 + n)\n                )\n            )\n        return f\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418850, "name": "Paraffins", "source": "Translate Haskell to Python: \na `nmul` n = map (*n) a\na `ndiv` n = map (`div` n) a\n\ninstance (Integral a) => Num [a] where\n  (+) = zipWith (+)\n  negate = map negate\n  a * b = foldr f undefined b where\n    f x z = (a `nmul` x) + (0 : z)\n  abs _ = undefined\n  signum _ = undefined\n  fromInteger n = fromInteger n : repeat 0\n\n\nrepl a n = concatMap (: replicate (n-1) 0) a\n\n\ncycleIndexS2 a b = (a*a + b)`ndiv` 2\n\n\ncycleIndexS4 a b c d =\t((a ^ 4) +\n\t\t\t (a ^ 2 * b) `nmul` 6 +\n\t\t\t (a * c) `nmul` 8 +\n\t\t\t (b ^ 2) `nmul` 3 +\n\t\t\t d `nmul` 6) `ndiv` 24\n\n\na598 = x1\n\nx1 = 1 : ((x1^3) + ((x2*x1)`nmul` 3) + (x3`nmul`2)) `ndiv` 6\nx2 = x1`repl`2\nx3 = x1`repl`3\nx4 = x1`repl`4\n\n\na678 = 0 : cycleIndexS4 x1 x2 x3 x4\n\n\na599 = cycleIndexS2 (0 : tail x1) (0 : tail x2)\n\n\na602 = a678 - a599 + x2\n\nmain = mapM_ print $ take 200 $ zip [0 ..] a602\n", "target": "try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\nMAX_N = 300\nBRANCH = 4\n\nra = [0] * MAX_N\nunrooted = [0] * MAX_N\n\ndef tree(br, n, l, sum = 1, cnt = 1):\n    global ra, unrooted, MAX_N, BRANCH\n    for b in xrange(br + 1, BRANCH + 1):\n        sum += n\n        if sum >= MAX_N:\n            return\n\n        \n        if l * 2 >= sum and b >= BRANCH:\n            return\n\n        if b == br + 1:\n            c = ra[n] * cnt\n        else:\n            c = c * (ra[n] + (b - br - 1)) / (b - br)\n\n        if l * 2 < sum:\n            unrooted[sum] += c\n\n        if b < BRANCH:\n            ra[sum] += c;\n            for m in range(1, n):\n                tree(b, m, l, sum, c)\n\ndef bicenter(s):\n    global ra, unrooted\n    if not (s & 1):\n        aux = ra[s / 2]\n        unrooted[s] += aux * (aux + 1) / 2\n\n\ndef main():\n    global ra, unrooted, MAX_N\n    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1\n\n    for n in xrange(1, MAX_N):\n        tree(0, n, n)\n        bicenter(n)\n        print \"%d: %d\" % (n, unrooted[n])\n\nmain()\n"}
{"id": 418851, "name": "Paraffins", "source": "Translate Haskell to Python: \na `nmul` n = map (*n) a\na `ndiv` n = map (`div` n) a\n\ninstance (Integral a) => Num [a] where\n  (+) = zipWith (+)\n  negate = map negate\n  a * b = foldr f undefined b where\n    f x z = (a `nmul` x) + (0 : z)\n  abs _ = undefined\n  signum _ = undefined\n  fromInteger n = fromInteger n : repeat 0\n\n\nrepl a n = concatMap (: replicate (n-1) 0) a\n\n\ncycleIndexS2 a b = (a*a + b)`ndiv` 2\n\n\ncycleIndexS4 a b c d =\t((a ^ 4) +\n\t\t\t (a ^ 2 * b) `nmul` 6 +\n\t\t\t (a * c) `nmul` 8 +\n\t\t\t (b ^ 2) `nmul` 3 +\n\t\t\t d `nmul` 6) `ndiv` 24\n\n\na598 = x1\n\nx1 = 1 : ((x1^3) + ((x2*x1)`nmul` 3) + (x3`nmul`2)) `ndiv` 6\nx2 = x1`repl`2\nx3 = x1`repl`3\nx4 = x1`repl`4\n\n\na678 = 0 : cycleIndexS4 x1 x2 x3 x4\n\n\na599 = cycleIndexS2 (0 : tail x1) (0 : tail x2)\n\n\na602 = a678 - a599 + x2\n\nmain = mapM_ print $ take 200 $ zip [0 ..] a602\n", "target": "try:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\nMAX_N = 300\nBRANCH = 4\n\nra = [0] * MAX_N\nunrooted = [0] * MAX_N\n\ndef tree(br, n, l, sum = 1, cnt = 1):\n    global ra, unrooted, MAX_N, BRANCH\n    for b in xrange(br + 1, BRANCH + 1):\n        sum += n\n        if sum >= MAX_N:\n            return\n\n        \n        if l * 2 >= sum and b >= BRANCH:\n            return\n\n        if b == br + 1:\n            c = ra[n] * cnt\n        else:\n            c = c * (ra[n] + (b - br - 1)) / (b - br)\n\n        if l * 2 < sum:\n            unrooted[sum] += c\n\n        if b < BRANCH:\n            ra[sum] += c;\n            for m in range(1, n):\n                tree(b, m, l, sum, c)\n\ndef bicenter(s):\n    global ra, unrooted\n    if not (s & 1):\n        aux = ra[s / 2]\n        unrooted[s] += aux * (aux + 1) / 2\n\n\ndef main():\n    global ra, unrooted, MAX_N\n    ra[0] = ra[1] = unrooted[0] = unrooted[1] = 1\n\n    for n in xrange(1, MAX_N):\n        tree(0, n, n)\n        bicenter(n)\n        print \"%d: %d\" % (n, unrooted[n])\n\nmain()\n"}
{"id": 418852, "name": "Faulhaber's formula", "source": "Translate Haskell to Python: import Data.Ratio ((%), numerator, denominator)\nimport Data.List (intercalate, transpose)\nimport Data.Bifunctor (bimap)\nimport Data.Char (isSpace)\nimport Data.Monoid ((<>))\nimport Data.Bool (bool)\n \n\nfaulhaber :: [[Rational]]\nfaulhaber =\n  tail $\n  scanl\n    (\\rs n ->\n        let xs = zipWith ((*) . (n %)) [2 ..] rs\n        in 1 - sum xs : xs)\n    []\n    [0 ..]\n    \npolynomials :: [[(String, String)]]\npolynomials = fmap ((ratioPower =<<) . reverse . flip zip [1 ..]) faulhaber\n    \n\n\nmain :: IO ()\nmain = (putStrLn . unlines . expressionTable . take 10) polynomials\n\n \n\n\n\nexpressionTable :: [[(String, String)]] -> [String]\nexpressionTable ps =\n  let cols = transpose (fullTable ps)\n  in expressionRow <$>\n     zip\n       [0 ..]\n       (transpose $\n        zipWith\n          (\\(lw, rw) col ->\n              fmap (bimap (justifyLeft lw ' ') (justifyLeft rw ' ')) col)\n          (colWidths cols)\n          cols)\n          \n\nratioPower :: (Rational, Integer) -> [(String, String)]\nratioPower (nd, j) =\n  let (num, den) = ((,) . numerator <*> denominator) nd\n      sn\n        | num == 0 = []\n        | (j /= 1) = (\"n^\" <> show j)\n        | otherwise = \"n\"\n      sr\n        | num == 0 = []\n        | den == 1 && num == 1 = []\n        | den == 1 = show num <> \"n\"\n        | otherwise = intercalate \"/\" [show num, show den]\n      s = sr <> sn\n  in bool [(sn, sr)] [] (null s)\n \n\nfullTable :: [[(String, String)]] -> [[(String, String)]]\nfullTable xs =\n  let lng = maximum $ length <$> xs\n  in (<>) <*> (flip replicate ([], []) . (-) lng . length) <$> xs\n \njustifyLeft :: Int -> Char -> String -> String\njustifyLeft n c s = take n (s <> replicate n c)\n \n\nexpressionRow :: (Int, [(String, String)]) -> String\nexpressionRow (i, row) =\n  concat\n    [ show i\n    , \" ->  \"\n    , foldr\n        (\\s a -> concat [s, bool \" + \" \" \" (blank a || head a == '-'), a])\n        []\n        (polyTerm <$> row)\n    ]\n \n\npolyTerm :: (String, String) -> String\npolyTerm (l, r)\n  | blank l || blank r = l <> r\n  | head r == '-' = concat [\"- \", l, \" * \", tail r]\n  | otherwise = intercalate \" * \" [l, r]\n \nblank :: String -> Bool\nblank = all isSpace\n \n\ncolWidths :: [[(String, String)]] -> [(Int, Int)]\ncolWidths =\n  fmap\n    (foldr\n       (\\(ls, rs) (lMax, rMax) -> (max (length ls) lMax, max (length rs) rMax))\n       (0, 0))\n \n\nunsignedLength :: String -> Int\nunsignedLength xs =\n  let l = length xs\n  in bool (bool l (l - 1) ('-' == head xs)) 0 (0 == l)\n", "target": "from fractions import Fraction\n\ndef nextu(a):\n    n = len(a)\n    a.append(1)\n    for i in range(n - 1, 0, -1):\n        a[i] = i * a[i] + a[i - 1]\n    return a\n\ndef nextv(a):\n    n = len(a) - 1\n    b = [(1 - n) * x for x in a]\n    b.append(1)\n    for i in range(n):\n        b[i + 1] += a[i]\n    return b\n\ndef sumpol(n):\n    u = [0, 1]\n    v = [[1], [1, 1]]\n    yield [Fraction(0), Fraction(1)]\n    for i in range(1, n):\n        v.append(nextv(v[-1]))\n        t = [0] * (i + 2)\n        p = 1\n        for j, r in enumerate(u):\n            r = Fraction(r, j + 1)\n            for k, s in enumerate(v[j + 1]):\n                t[k] += r * s\n        yield t\n        u = nextu(u)\n\ndef polstr(a):\n    s = \"\"\n    q = False\n    n = len(a) - 1\n    for i, x in enumerate(reversed(a)):\n        i = n - i\n        if i < 2:\n            m = \"n\" if i == 1 else \"\"\n        else:\n            m = \"n^%d\" % i\n        c = str(abs(x))\n        if i > 0:\n            if c == \"1\":\n                c = \"\"\n            else:\n                m = \" \" + m\n        if x != 0:\n            if q:\n                t = \" + \" if x > 0 else \" - \"\n                s += \"%s%s%s\" % (t, c, m)\n            else:\n                t = \"\" if x > 0 else \"-\"\n                s = \"%s%s%s\" % (t, c, m)\n                q = True\n    if q:\n        return s\n    else:\n        return \"0\"\n\nfor i, p in enumerate(sumpol(10)):\n    print(i, \":\", polstr(p))\n"}
{"id": 418853, "name": "Active Directory_Search for a user", "source": "Translate Haskell to Python: \n\nmodule Main (main) where\n\nimport           Data.Foldable (for_)\nimport qualified Data.Text.Encoding as Text (encodeUtf8)\nimport           Ldap.Client (Attr(..), Filter(..))\nimport qualified Ldap.Client as Ldap (Dn(..), Host(..), search, with, typesOnly)\n\nmain :: IO ()\nmain = do\n    entries <- Ldap.with (Ldap.Plain \"localhost\") 389 $ \\ldap ->\n        Ldap.search ldap (Ldap.Dn \"o=example.com\") (Ldap.typesOnly True) (Attr \"uid\" := Text.encodeUtf8 \"user\") []\n    for_ entries $ \\entry ->\n        print entry\n", "target": "Import-Module ActiveDirectory\n\n$searchData = \"user name\"\n$searchBase = \"DC=example,DC=com\"\n\n\nget-aduser -Filter((DistinguishedName -eq $searchdata) -or (UserPrincipalName -eq $searchdata) -or (SamAccountName -eq $searchdata)) -SearchBase $searchBase\n"}
{"id": 418854, "name": "Prime conspiracy", "source": "Translate Haskell to Python: import Data.List (group, sort)\nimport Text.Printf (printf)\nimport Data.Numbers.Primes (primes)\n\nfreq :: [(Int, Int)] -> Float\nfreq xs = realToFrac (length xs) / 100\n\nline :: [(Int, Int)] -> IO ()\nline t@((n1, n2):xs) = printf \"%d -> %d count: %5d frequency: %2.2f\u00a0%%\\n\" n1 n2 (length t) (freq t) \n\nmain :: IO ()\nmain = mapM_ line $ groups primes\n  where groups = tail . group . sort . (\\n -> zip (0: n) n) . fmap (`mod` 10) . take 10000\n", "target": "def isPrime(n):\n    if n < 2:\n        return False\n    if n % 2 == 0:\n        return n == 2\n    if n % 3 == 0:\n        return n == 3\n\n    d = 5\n    while d * d <= n:\n        if n % d == 0:\n            return False\n        d += 2\n\n        if n % d == 0:\n            return False\n        d += 4\n    return True\n\ndef generatePrimes():\n    yield 2\n    yield 3\n\n    p = 5\n    while p > 0:\n        if isPrime(p):\n            yield p\n        p += 2\n        if isPrime(p):\n            yield p\n        p += 4\n\ng = generatePrimes()\ntransMap = {}\nprev = None\nlimit = 1000000\nfor _ in xrange(limit):\n    prime = next(g)\n    if prev:\n        transition = (prev, prime %10)\n        if transition in transMap:\n            transMap[transition] += 1\n        else:\n            transMap[transition] = 1\n    prev = prime % 10\n\nprint \"First {:,} primes. Transitions prime\u00a0% 10 > next-prime\u00a0% 10.\".format(limit)\nfor trans in sorted(transMap):\n    print \"{0} -> {1} count {2:5} frequency: {3}%\".format(trans[0], trans[1], transMap[trans], 100.0 * transMap[trans] / limit)\n"}
{"id": 418855, "name": "List rooted trees", "source": "Translate Haskell to Python: \nparts :: Int -> [[(Int, Int)]]\nparts n = f n 1\n  where\n    f n x\n      | n == 0 = [[]]\n      | x > n = []\n      | otherwise =\n        f n (x + 1) ++\n        concatMap\n          (\\c -> map ((c, x) :) (f (n - c * x) (x + 1)))\n          [1 .. n `div` x]\n\n\npick :: Int -> [String] -> [String]\npick _ [] = []\npick 0 _ = [\"\"]\npick n aa@(a:as) = map (a ++) (pick (n - 1) aa) ++ pick n as\n\n\n\ntrees :: Int -> [String]\ntrees n =\n  map (\\x -> \"(\" ++ x ++ \")\") $\n  concatMap (foldr (prod . build) [\"\"]) (parts (n - 1))\n  where\n    build (c, x) = pick c $ trees x\n    prod aa bb =\n      [ a ++ b\n      | a <- aa \n      , b <- bb ]\n\nmain :: IO ()\nmain = mapM_ putStrLn $ trees 5\n", "target": "def bags(n,cache={}):\n\tif not n: return [(0, \"\")]\n\n\tupto = sum([bags(x) for x in range(n-1, 0, -1)], [])\n\treturn [(c+1, '('+s+')') for c,s in bagchain((0, \"\"), n-1, upto)]\n\ndef bagchain(x, n, bb, start=0):\n\tif not n: return [x]\n\n\tout = []\n\tfor i in range(start, len(bb)):\n\t\tc,s = bb[i]\n\t\tif c <= n: out += bagchain((x[0] + c, x[1] + s), n-c, bb, i)\n\treturn out\n\n\ndef replace_brackets(s):\n\tdepth,out = 0,[]\n\tfor c in s:\n\t\tif c == '(':\n\t\t\tout.append(\"([{\"[depth%3])\n\t\t\tdepth += 1\n\t\telse:\n\t\t\tdepth -= 1\n\t\t\tout.append(\")]}\"[depth%3])\n\treturn \"\".join(out)\n\nfor x in bags(5): print(replace_brackets(x[1]))\n"}
{"id": 418856, "name": "Elementary cellular automaton_Random number generator", "source": "Translate Haskell to Python: import CellularAutomata (fromList, rule, runCA)\nimport Control.Comonad\nimport Data.List (unfoldr)\n\nrnd = fromBits <$> unfoldr (pure . splitAt 8) bits\n  where\n    size = 80\n    bits =\n      extract\n        <$> runCA\n          (rule 30)\n          (fromList (1 : replicate size 0))\n\nfromBits = foldl ((+) . (2 *)) 0\n", "target": "from elementary_cellular_automaton import eca, eca_wrap\n\ndef rule30bytes(lencells=100):\n    cells = '1' + '0' * (lencells - 1)\n    gen = eca(cells, 30)\n    while True:\n        yield int(''.join(next(gen)[0] for i in range(8)), 2)\n\nif __name__ == '__main__':\n    print([b for i,b in zip(range(10), rule30bytes())])\n"}
{"id": 418857, "name": "Lucky and even lucky numbers", "source": "Translate Haskell to Python: import System.Environment\nimport Text.Regex.Posix\n\ndata Lucky = Lucky | EvenLucky \n\nhelpMessage :: IO ()\nhelpMessage = do\n  putStrLn \"                           what is displayed  (on a single line)\"\n  putStrLn \"     argument(s)              (optional verbiage is encouraged)\"\n  putStrLn \"======================|===================================================\"\n  putStrLn \" j                    | Jth       lucky number                            \"\n  putStrLn \" j  ,          lucky  | Jth       lucky number                            \"\n  putStrLn \" j  ,      evenLucky  | Jth  even lucky number                            \"\n  putStrLn \"                                                                          \"\n  putStrLn \" j  k                 | Jth  through  Kth (inclusive)       lucky numbers \"\n  putStrLn \" j  k          lucky  | Jth  through  Kth (inclusive)       lucky numbers \"\n  putStrLn \" j  k      evenlucky  | Jth  through  Kth (inclusive)  even lucky numbers \"\n  putStrLn \"                                                                          \"\n  putStrLn \" j -k                 | all       lucky numbers in the range  j -> |k|    \"\n  putStrLn \" j -k          lucky  | all       lucky numbers in the range  j -> |k|    \"\n  putStrLn \" j -k      evenlucky  | all  even lucky numbers in the range  j -> |k|    \"\n  putStrLn \"======================|===================================================\"\n\noddNumbers :: [Int]\noddNumbers = filter odd [1..]\n\nevenNumbers :: [Int]\nevenNumbers = filter even [1..]\n\nluckyNumbers :: [Int] -> [Int]\nluckyNumbers xs = \n  let i = 3 in\n  sieve i xs\n    where\n      sieve i (ln:s:xs) =\n        ln : sieve (i + 1) (s : [x | (n, x) <- zip [i..] xs, rem n s /= 0])\n\nnth :: Int -> Lucky -> Int\nnth j Lucky     = luckyNumbers oddNumbers !! (j-1)\nnth j EvenLucky = luckyNumbers evenNumbers !! (j-1)\n\nrange :: Int -> Int -> Lucky -> [Int]\nrange x x2 Lucky     = drop (x-1) (take x2 (luckyNumbers oddNumbers))\nrange x x2 EvenLucky = drop (x-1) (take x2 (luckyNumbers evenNumbers))\n\ninterval :: Int -> Int -> Lucky -> [Int]\ninterval x x2 Lucky     = dropWhile (<x) (takeWhile (<=x2) (luckyNumbers oddNumbers))\ninterval x x2 EvenLucky = dropWhile (<x) (takeWhile (<=x2) (luckyNumbers evenNumbers))\n\nlucky :: [String] -> Lucky\nlucky xs = \n  if \"evenLucky\" `elem` xs\n   then EvenLucky\n   else Lucky\n\nreadn :: String -> Int\nreadn s = read s :: Int\n\nisInt :: String -> Bool\nisInt s = not (null (s =~ \"-?[0-9]{0,10}\" :: String))\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  if head args == \"\n    then\n      helpMessage\n    else\n      let l = lucky args in\n      case map readn (filter isInt args) of\n        [] -> do\n          putStrLn \"Invalid input, missing arguments\"\n          putStrLn \"Type \n        [x] -> print (nth x l)\n        [x, x2] -> if x2 > 0\n          then print (range x x2 l)\n          else print (interval x (-x2) l)\n        _ -> do \n          putStrLn \"Invalid input, wrong number of arguments\"\n          putStrLn \"Type \n", "target": "from __future__ import print_function\n\ndef lgen(even=False, nmax=1000000):\n    start = 2 if even else 1\n    n, lst = 1, list(range(start, nmax + 1, 2))\n    lenlst = len(lst)\n    yield lst[0]\n    while n < lenlst and lst[n] < lenlst:\n        yield lst[n]\n        n, lst = n + 1, [j for i,j in enumerate(lst, 1) if i % lst[n]]\n        lenlst = len(lst)\n    \n    for i in lst[n:]:\n        yield i\n"}
{"id": 418858, "name": "Imaginary base numbers", "source": "Translate Haskell to Python: import Data.Char (chr, digitToInt, intToDigit, isDigit, ord)\nimport Data.Complex (Complex (..), imagPart, realPart)\nimport Data.List (delete, elemIndex)\nimport Data.Maybe (fromMaybe)\n\nbase :: Complex Float\nbase = 0 :+ 2\n\nquotRemPositive :: Int -> Int -> (Int, Int)\nquotRemPositive a b\n  | r < 0 = (1 + q, floor (realPart (-base ^^ 2)) + r)\n  | otherwise = (q, r)\n  where\n    (q, r) = quotRem a b\n\ndigitToIntQI :: Char -> Int\ndigitToIntQI c\n  | isDigit c = digitToInt c\n  | otherwise = ord c - ord 'a' + 10\n\nshiftRight :: String -> String\nshiftRight n\n  | l == '0' = h\n  | otherwise = h <> ('.' : [l])\n  where\n    (l, h) = (last n, init n)\n\nintToDigitQI :: Int -> Char\nintToDigitQI i\n  | i `elem` [0 .. 9] = intToDigit i\n  | otherwise = chr (i - 10 + ord 'a')\n\nfromQItoComplex :: String -> Complex Float -> Complex Float\nfromQItoComplex num b =\n  let dot = fromMaybe (length num) (elemIndex '.' num)\n   in fst $\n        foldl\n          ( \\(a, indx) x ->\n              ( a + fromIntegral (digitToIntQI x)\n                  * (b ^^ (dot - indx)),\n                indx + 1\n              )\n          )\n          (0, 1)\n          (delete '.' num)\n\neuclidEr :: Int -> Int -> [Int] -> [Int]\neuclidEr a b l\n  | a == 0 = l\n  | otherwise =\n      let (q, r) = quotRemPositive a b\n       in euclidEr q b (0 : r : l)\n\nfromIntToQI :: Int -> [Int]\nfromIntToQI 0 = [0]\nfromIntToQI x =\n  tail\n    ( euclidEr\n        x\n        (floor $ realPart (base ^^ 2))\n        []\n    )\n\ngetCuid :: Complex Int -> Int\ngetCuid c = imagPart c * floor (imagPart (-base))\n\nqizip :: Complex Int -> [Int]\nqizip c =\n  let (r, i) =\n        ( fromIntToQI (realPart c) <> [0],\n          fromIntToQI (getCuid c)\n        )\n   in let m = min (length r) (length i)\n       in take (length r - m) r\n            <> take (length i - m) i\n            <> reverse\n              ( zipWith\n                  (+)\n                  (take m (reverse r))\n                  (take m (reverse i))\n              )\n\nfromComplexToQI :: Complex Int -> String\nfromComplexToQI = shiftRight . fmap intToDigitQI . qizip\n\nmain :: IO ()\nmain =\n  putStrLn (fromComplexToQI (35 :+ 23))\n    >> print (fromQItoComplex \"10.2\" base)\n", "target": "import math\nimport re\n\ndef inv(c):\n    denom = c.real * c.real + c.imag * c.imag\n    return complex(c.real / denom, -c.imag / denom)\n\nclass QuaterImaginary:\n    twoI = complex(0, 2)\n    invTwoI = inv(twoI)\n\n    def __init__(self, str):\n        if not re.match(\"^[0123.]+$\", str) or str.count('.') > 1:\n            raise Exception('Invalid base 2i number')\n        self.b2i = str\n\n    def toComplex(self):\n        pointPos = self.b2i.find('.')\n        posLen = len(self.b2i) if (pointPos < 0) else pointPos\n        sum = complex(0, 0)\n        prod = complex(1, 0)\n        for j in xrange(0, posLen):\n            k = int(self.b2i[posLen - 1 - j])\n            if k > 0:\n                sum += prod * k\n            prod *= QuaterImaginary.twoI\n        if pointPos != -1:\n            prod = QuaterImaginary.invTwoI\n            for j in xrange(posLen + 1, len(self.b2i)):\n                k = int(self.b2i[j])\n                if k > 0:\n                    sum += prod * k\n                prod *= QuaterImaginary.invTwoI\n        return sum\n\n    def __str__(self):\n        return str(self.b2i)\n\ndef toQuaterImaginary(c):\n    if c.real == 0.0 and c.imag == 0.0:\n        return QuaterImaginary(\"0\")\n\n    re = int(c.real)\n    im = int(c.imag)\n    fi = -1\n    ss = \"\"\n    while re != 0:\n        re, rem = divmod(re, -4)\n        if rem < 0:\n            rem += 4\n            re += 1\n        ss += str(rem) + '0'\n    if im != 0:\n        f = c.imag / 2\n        im = int(math.ceil(f))\n        f = -4 * (f - im)\n        index = 1\n        while im != 0:\n            im, rem = divmod(im, -4)\n            if rem < 0:\n                rem += 4\n                im += 1\n            if index < len(ss):\n                ss[index] = str(rem)\n            else:\n                ss += '0' + str(rem)\n            index = index + 2\n        fi = int(f)\n    ss = ss[::-1]\n    if fi != -1:\n        ss += '.' + str(fi)\n    ss = ss.lstrip('0')\n    if ss[0] == '.':\n        ss = '0' + ss\n    return QuaterImaginary(ss)\n\nfor i in xrange(1,17):\n    c1 = complex(i, 0)\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}     \".format(c1, qi, c2),\n\n    c1 = -c1\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}\".format(c1, qi, c2)\nprint\n\nfor i in xrange(1,17):\n    c1 = complex(0, i)\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}     \".format(c1, qi, c2),\n\n    c1 = -c1\n    qi = toQuaterImaginary(c1)\n    c2 = qi.toComplex()\n    print \"{0:8} -> {1:>8} -> {2:8}\".format(c1, qi, c2)\n\nprint \"done\"\n"}
{"id": 418859, "name": "Statistics_Normal distribution", "source": "Translate Haskell to Python: import Data.Map (Map, empty, insert, findWithDefault, toList)\nimport Data.Maybe (fromMaybe)\nimport Text.Printf (printf)\nimport Data.Function (on)\nimport Data.List (sort, maximumBy, minimumBy)\nimport Control.Monad.Random (RandomGen, Rand, evalRandIO, getRandomR)\nimport Control.Monad (replicateM)\n\n\ngetNorm :: RandomGen g => Rand g Double\ngetNorm = do\n    u0 <- getRandomR (0.0, 1.0) \n    u1 <- getRandomR (0.0, 1.0) \n    let r = sqrt $ (-2.0) * log u0\n        theta = 2.0 * pi * u1\n    return $ r * sin theta\n\nputInBin :: Double -> Map Int Int -> Double -> Map Int Int\nputInBin binWidth t v = \n    let bin = round (v / binWidth)\n        count = findWithDefault 0 bin t \n    in insert bin (count+1) t\n\nrunTest :: Int -> IO ()\nrunTest n = do\n    rs <- evalRandIO $ replicateM n getNorm \n    let binWidth = 0.1\n\n        tally v (sv, sv2, t) = (sv+v, sv2 + v*v, putInBin binWidth t v)\n\n        (sum, sum2, tallies) = foldr tally (0.0, 0.0, empty) rs\n\n        tallyList = sort $ toList tallies\n\n        printStars tallies binWidth maxCount selection = \n            let count = findWithDefault 0 selection tallies \n                bin = binWidth * fromIntegral selection\n                maxStars = 100\n                starCount = if maxCount <= maxStars\n                            then count \n                            else maxStars * count `div` maxCount\n                stars = replicate  starCount '*'\n            in printf \"%5.2f: %s  %d\\n\" bin stars count\n\n        mean = sum / fromIntegral n\n        stddev = sqrt (sum2/fromIntegral n - mean*mean)\n\n    printf \"\\n\"\n    printf \"sample count: %d\\n\" n\n    printf \"mean:         %9.7f\\n\" mean\n    printf \"stddev:       %9.7f\\n\" stddev\n\n    let maxCount = snd $ maximumBy (compare `on` snd) tallyList\n        maxBin = fst $ maximumBy (compare `on` fst) tallyList\n        minBin = fst $ minimumBy (compare `on` fst) tallyList\n\n    mapM_ (printStars tallies binWidth maxCount) [minBin..maxBin]\n\nmain = do\n    runTest 1000\n    runTest 2000000\n", "target": "from __future__ import division\nimport matplotlib.pyplot as plt \nimport random\n\nmean, stddev, size = 50, 4, 100000\ndata = [random.gauss(mean, stddev) for c in range(size)]\n\nmn = sum(data) / size\nsd = (sum(x*x for x in data) / size \n      - (sum(data) / size) ** 2) ** 0.5\n\nprint(\"Sample mean = %g; Stddev = %g; max = %g; min = %g for %i values\" \n      % (mn, sd, max(data), min(data), size))\n\nplt.hist(data,bins=50)\n"}
{"id": 418860, "name": "Minimum positive multiple in base 10 using only 0 and 1", "source": "Translate Haskell to Python: import Data.Bifunctor (bimap)\nimport Data.List (find)\nimport Data.Maybe (isJust)\n\n\n\nb10 :: Integral a => a -> Integer\nb10 n = read (digitMatch rems sums) :: Integer\n  where\n    (_, rems, _, Just (_, sums)) =\n      until\n        (\\(_, _, _, mb) -> isJust mb)\n        ( \\(e, rems, ms, _) ->\n            let m = rem (10 ^ e) n\n                newSums =\n                  (m, [m]) :\n                  fmap (bimap (m +) (m :)) ms\n             in ( succ e,\n                  m : rems,\n                  ms <> newSums,\n                  find\n                    ( (0 ==) . flip rem n . fst\n                    )\n                    newSums\n                )\n        )\n        (0, [], [], Nothing)\n\ndigitMatch :: Eq a => [a] -> [a] -> String\ndigitMatch [] _ = []\ndigitMatch xs [] = '0' <$ xs\ndigitMatch (x : xs) yys@(y : ys)\n  | x /= y = '0' : digitMatch xs yys\n  | otherwise = '1' : digitMatch xs ys\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( putStrLn\n        . ( \\x ->\n              let b = b10 x\n               in justifyRight 5 ' ' (show x)\n                    <> \" * \"\n                    <> justifyLeft 25 ' ' (show $ div b x)\n                    <> \" -> \"\n                    <> show b\n          )\n    )\n    ( [1 .. 10]\n        <> [95 .. 105]\n        <> [297, 576, 594, 891, 909, 999]\n    )\n\njustifyLeft, justifyRight :: Int -> a -> [a] -> [a]\njustifyLeft n c s = take n (s <> replicate n c)\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "def getA004290(n):\n    if n < 2:\n        return 1\n    arr = [[0 for _ in range(n)] for _ in range(n)]\n    arr[0][0] = 1\n    arr[0][1] = 1\n    m = 0\n    while True:\n        m += 1\n        if arr[m - 1][-10 ** m % n] == 1:\n            break\n        arr[m][0] = 1\n        for k in range(1, n):\n            arr[m][k] = max([arr[m - 1][k], arr[m - 1][k - 10 ** m % n]])\n    r = 10 ** m\n    k = -r % n\n    for j in range((m - 1), 0, -1):\n        if arr[j - 1][k] == 0:\n            r = r + 10 ** j\n            k = (k - 10 ** j) % n   \n    if k == 1:\n        r += 1\n    return r\n \nfor n in [i for i in range(1, 11)] + \\\n          [i for i in range(95, 106)] + \\\n          [297, 576, 594, 891, 909, 999, 1998, 2079, 2251, 2277, 2439, 2997, 4878]:\n    result = getA004290(n)\n    print(f\"A004290({n}) = {result} = {n} * {result // n})\")\n"}
{"id": 418861, "name": "Magic squares of singly even order", "source": "Translate Haskell to Python: import qualified Data.Map.Strict as M\nimport Data.List (transpose, intercalate)\nimport Data.Maybe (fromJust, isJust)\nimport Control.Monad (forM_)\nimport Data.Monoid ((<>))\n\nmagic :: Int -> [[Int]]\nmagic n = mapAsTable ((4 * n) + 2) (hiResMap n)\n\n\nhiResMap :: Int -> M.Map (Int, Int) Int\nhiResMap n =\n  let mapLux = luxMap n\n      mapSiam = siamMap n\n  in M.fromList $\n     foldMap\n       (\\(xy, n) ->\n           luxNums xy (fromJust (M.lookup xy mapLux)) ((4 * (n - 1)) + 1))\n       (M.toList mapSiam)\n\n\nluxNums :: (Int, Int) -> Char -> Int -> [((Int, Int), Int)]\nluxNums xy lux n =\n  zipWith (\\x d -> (x, n + d)) (hiRes xy) $\n  case lux of\n    'L' -> [3, 0, 1, 2]\n    'U' -> [0, 3, 1, 2]\n    'X' -> [0, 3, 2, 1]\n    _ -> [0, 0, 0, 0]\n\n\nmapAsTable :: Int -> M.Map (Int, Int) Int -> [[Int]]\nmapAsTable nCols xyMap =\n  let axis = [0 .. nCols - 1]\n  in fmap (fromJust . flip M.lookup xyMap) <$>\n     (axis >>= \\y -> [axis >>= \\x -> [(x, y)]])\n\n\nluxMap :: Int -> M.Map (Int, Int) Char\nluxMap n =\n  (M.fromList . concat) $\n  zipWith\n    (\\y xs -> (zipWith (\\x c -> ((x, y), c)) [0 ..] xs))\n    [0 ..]\n    (luxPattern n)\n\n\nluxPattern :: Int -> [String]\nluxPattern n =\n  let d = (2 * n) + 1\n      [ls, us] = replicate n <$> \"LU\"\n      [lRow, xRow] = replicate d <$> \"LX\"\n  in replicate n lRow <> [ls <> ('U' : ls)] <> [us <> ('L' : us)] <>\n     replicate (n - 1) xRow\n\n\nsiamMap :: Int -> M.Map (Int, Int) Int\nsiamMap n =\n  let uBound = (2 * n)\n      sPath uBound sMap (x, y) n =\n        let newMap = M.insert (x, y) n sMap\n        in if y == uBound && x == quot uBound 2\n             then newMap\n             else sPath uBound newMap (nextSiam uBound sMap (x, y)) (n + 1)\n  in sPath uBound (M.fromList []) (n, 0) 1\n\n\nnextSiam :: Int -> M.Map (Int, Int) Int -> (Int, Int) -> (Int, Int)\nnextSiam uBound sMap (x, y) =\n  let alt (a, b)\n        | a > uBound && b < 0 = (uBound, 1) \n        | a > uBound = (0, b) \n        | b < 0 = (a, uBound) \n        | isJust (M.lookup (a, b) sMap) = (a - 1, b + 2) \n        | otherwise = (a, b) \n  in alt (x + 1, y - 1)\n\n\nhiRes :: (Int, Int) -> [(Int, Int)]\nhiRes (x, y) =\n  let [col, row] = (* 2) <$> [x, y]\n      [col1, row1] = succ <$> [col, row]\n  in [(col, row), (col1, row), (col, row1), (col1, row1)]\n\n\nchecked :: [[Int]] -> (Int, Bool)\nchecked square = (h, all (h ==) t)\n  where\n    diagonals = fmap (flip (zipWith (!!)) [0 ..]) . ((:) <*> (return . reverse))\n    h:t = sum <$> square <> transpose square <> diagonals square\n\ntable :: String -> [[String]] -> [String]\ntable delim rows =\n  let justifyRight c n s = drop (length s) (replicate n c <> s)\n  in intercalate delim <$>\n     transpose\n       ((fmap =<< justifyRight ' ' . maximum . fmap length) <$> transpose rows)\n\nmain :: IO ()\nmain =\n  forM_ [1, 2, 3] $\n  \\n -> do\n    let test = magic n\n    putStrLn $ unlines (table \" \" (fmap show <$> test))\n    print $ checked test\n    putStrLn \"\"\n", "target": "import math\nfrom sys import stdout\n\nLOG_10 = 2.302585092994\n\n\n\ndef build_oms(s):\n    if s % 2 == 0:\n        s += 1\n    q = [[0 for j in range(s)] for i in range(s)]\n    p = 1\n    i = s // 2\n    j = 0\n    while p <= (s * s):\n        q[i][j] = p\n        ti = i + 1\n        if ti >= s: ti = 0\n        tj = j - 1\n        if tj < 0: tj = s - 1\n        if q[ti][tj] != 0:\n            ti = i\n            tj = j + 1\n        i = ti\n        j = tj\n        p = p + 1\n\n    return q, s\n\n\n\ndef build_sems(s):\n    if s % 2 == 1:\n        s += 1\n    while s % 4 == 0:\n        s += 2\n\n    q = [[0 for j in range(s)] for i in range(s)]\n    z = s // 2\n    b = z * z\n    c = 2 * b\n    d = 3 * b\n    o = build_oms(z)\n\n    for j in range(0, z):\n        for i in range(0, z):\n            a = o[0][i][j]\n            q[i][j] = a\n            q[i + z][j + z] = a + b\n            q[i + z][j] = a + c\n            q[i][j + z] = a + d\n\n    lc = z // 2\n    rc = lc\n    for j in range(0, z):\n        for i in range(0, s):\n            if i < lc or i > s - rc or (i == lc and j == lc):\n                if not (i == 0 and j == lc):\n                    t = q[i][j]\n                    q[i][j] = q[i][j + z]\n                    q[i][j + z] = t\n\n    return q, s\n\n\ndef format_sqr(s, l):\n    for i in range(0, l - len(s)):\n        s = \"0\" + s\n    return s + \" \"\n\n\ndef display(q):\n    s = q[1]\n    print(\" - {0} x {1}\\n\".format(s, s))\n    k = 1 + math.floor(math.log(s * s) / LOG_10)\n    for j in range(0, s):\n        for i in range(0, s):\n            stdout.write(format_sqr(\"{0}\".format(q[0][i][j]), k))\n        print()\n    print(\"Magic sum: {0}\\n\".format(s * ((s * s) + 1) // 2))\n\n\nstdout.write(\"Singly Even Magic Square\")\ndisplay(build_sems(6))\n"}
{"id": 418862, "name": "Weird numbers", "source": "Translate Haskell to Python: weirds :: [Int]\nweirds = filter abundantNotSemiperfect [1 ..]\n\nabundantNotSemiperfect :: Int -> Bool\nabundantNotSemiperfect n =\n  let ds = descProperDivisors n\n      d = sum ds - n\n  in 0 < d && not (hasSum d ds)\n\nhasSum :: Int -> [Int] -> Bool\nhasSum _ [] = False\nhasSum n (x:xs)\n  | n < x = hasSum n xs\n  | otherwise = (n == x) || hasSum (n - x) xs || hasSum n xs\n\ndescProperDivisors\n  :: Integral a\n  => a -> [a]\ndescProperDivisors n =\n  let root = (floor . sqrt) (fromIntegral n :: Double)\n      lows = filter ((0 ==) . rem n) [root,root - 1 .. 1]\n      factors\n        | n == root ^ 2 = tail lows \n        | otherwise = lows\n  in tail $ reverse (quot n <$> lows) ++ factors\n\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n  zipWith (\\i x -> show i ++ (\" -> \" ++ show x)) [1 ..] (take 25 weirds)\n", "target": "\n\nfrom itertools import chain, count, islice, repeat\nfrom functools import reduce\nfrom math import sqrt\nfrom time import time\n\n\n\ndef weirds():\n    \n    def go(n):\n        ds = descPropDivs(n)\n        d = sum(ds) - n\n        return [n] if 0 < d and not hasSum(d, ds) else []\n    return concatMap(go)(count(1))\n\n\n\ndef hasSum(n, xs):\n    \n    def go(n, xs):\n        if xs:\n            h, t = xs[0], xs[1:]\n            if n < h:  \n                return go(n, t)\n            else:\n                \n                \n                \n                \n                return n == h or go(n - h, t) or go(n, t)\n        else:\n            return False\n    return go(n, xs)\n\n\n\ndef descPropDivs(n):\n    \n    root = sqrt(n)\n    intRoot = int(root)\n    blnSqr = root == intRoot\n    lows = [x for x in range(1, 1 + intRoot) if 0 == n % x]\n    return [\n        n // x for x in (\n            lows[1:-1] if blnSqr else lows[1:]\n        )\n    ] + list(reversed(lows))\n\n\n\n\n\ndef main():\n    \n\n    start = time()\n    n = 50\n    xs = take(n)(weirds())\n\n    print(\n        (tabulated('First ' + str(n) + ' weird numbers:\\n')(\n            lambda i: str(1 + i)\n        )(str)(5)(\n            index(xs)\n        )(range(0, n)))\n    )\n    print(\n        '\\nApprox computation time: ' +\n        str(int(1000 * (time() - start))) + ' ms'\n    )\n\n\n\n\n\ndef chunksOf(n):\n    \n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n\ndef compose(g):\n    \n    return lambda f: lambda x: g(f(x))\n\n\n\ndef concatMap(f):\n    \n    return lambda xs: chain.from_iterable(map(f, xs))\n\n\n\ndef index(xs):\n    \n    return lambda n: None if 0 > n else (\n        xs[n] if (\n            hasattr(xs, \"__getitem__\")\n        ) else next(islice(xs, n, None))\n    )\n\n\n\ndef paddedMatrix(v):\n    \n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n\ndef paddedRows(n):\n    \n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n\ndef showColumns(n):\n    \n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col))\n\n        q, r = divmod(len(xs), n)\n        return unlines(map(\n            fit,\n            transpose(paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(\n                    xs\n                )\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n\ndef succ(x):\n    \n    return 1 + x if isinstance(x, int) else (\n        chr(1 + ord(x))\n    )\n\n\n\n\n\n\ndef tabulated(s):\n    \n    def go(xShow, fxShow, intCols, f, xs):\n        w = max(map(compose(len)(xShow), xs))\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + fxShow(f(x)) for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n\n\ndef take(n):\n    \n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, list)\n        else list(islice(xs, n))\n    )\n\n\n\ndef transpose(m):\n    \n    if m:\n        inner = type(m[0])\n        z = zip(*m)\n        return (type(m))(\n            map(inner, z) if tuple != inner else z\n        )\n    else:\n        return m\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\ndef until(p):\n    \n    def go(f, x):\n        v = x\n        while not p(v):\n            v = f(v)\n        return v\n    return lambda f: lambda x: go(f, x)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418863, "name": "ASCII art diagram converter", "source": "Translate Haskell to Python: import Text.ParserCombinators.ReadP\nimport Control.Monad (guard)\n\ndata Field a = Field { fieldName :: String\n                     , fieldSize :: Int\n                     , fieldValue :: Maybe a}\n\ninstance Show a => Show (Field a) where\n  show (Field n s a) = case a of\n    Nothing -> n ++ \"\\t\" ++ show s\n    Just x -> n ++ \"\\t\" ++ show s ++ \"\\t\" ++ show x\n\nnewtype Data a = Data { fields :: [Field a] }\n\ninstance Show a => Show (Data a) where\n  show (Data fs) = \"NAME\\tSIZE\\tVALUE\\n\" ++ unlines (show <$> fs)\n\ninstance Read (Data a) where\n  readsPrec _ = readP_to_S parseData \n\nparseData = do n <- parseHeader               \n               guard (n `elem` [8,16,32,64]) \n               Data . concat <$> many1 (parseRow n)\n  where\n    parseRow n = do\n      fs <- char '|' *> many parseField <* char '\\n'\n      guard $ sum (fieldSize <$> fs) == n \n      m <- parseHeader\n      guard $ m == n \n      return fs\n \n    parseHeader = do\n      char '+'\n      n <- length <$> many1 (string \"\n      char '\\n'\n      return n\n  \n    parseField = do\n      s1 <- many (char ' ')\n      f <- munch1 $ not . (`elem` \" |\")\n      s2 <- many (char ' ')\n      char '|'\n      let n = (length (s1 ++ f ++ s2) + 1) `div` 3\n      return $ Field f n Nothing\n    \n\nreadData :: Data a -> [b] -> Data [b]\nreadData d = Data . go (fields d)\n  where\n    go fs [] = (\\f -> f {fieldValue = Nothing}) <$> fs\n    go (f:fs) s =\n      let (x, xs) = splitAt (fieldSize f) s\n      in f {fieldValue = Just x} : go fs xs\n  \n\ndiagram = unlines\n  [\"+\n  ,\"|                      ID                       |\"\n  ,\"+\n  ,\"|QR|   Opcode  |AA|TC|RD|RA|   Z    |   RCODE   |\"\n  ,\"+\n  ,\"|                    QDCOUNT                    |\"\n  ,\"+\n  ,\"|                    ANCOUNT                    |\"\n  ,\"+\n  ,\"|                    NSCOUNT                    |\"\n  ,\"+\n  ,\"|                    ARCOUNT                    |\"\n  ,\"+\n  \ndataSample = concat\n  [\"011110000100011101111011101111110101010010010110\",\n   \"111000010010111000011011111100010110100110100100\"]\n", "target": "\n\ndef validate(diagram):\n\n    \n    \n    rawlines = diagram.splitlines()\n    lines = []\n    for line in rawlines:\n        if line != '':\n            lines.append(line)\n            \n    \n            \n    if len(lines) == 0:\n        print('diagram has no non-empty lines!')\n        return None\n        \n    width = len(lines[0])\n    cols = (width - 1) // 3\n    \n    if cols not in [8, 16, 32, 64]: \n        print('number of columns should be 8, 16, 32 or 64')\n        return None\n        \n    if len(lines)%2 == 0:\n        print('number of non-empty lines should be odd')\n        return None\n    \n    if lines[0] != (('+--' * cols)+'+'):\n            print('incorrect header line')\n            return None\n\n    for i in range(len(lines)):\n        line=lines[i]\n        if i == 0:\n            continue\n        elif i%2 == 0:\n            if line != lines[0]:\n                print('incorrect separator line')\n                return None\n        elif len(line) != width:\n            print('inconsistent line widths')\n            return None\n        elif line[0] != '|' or line[width-1] != '|':\n            print(\"non-separator lines must begin and end with '|'\")    \n            return None\n    \n    return lines\n\n\n\ndef decode(lines):\n    print(\"Name     Bits  Start  End\")\n    print(\"=======  ====  =====  ===\")\n    \n    startbit = 0\n    \n    results = []\n    \n    for line in lines:\n        infield=False\n        for c in line:\n            if not infield and c == '|':\n                infield = True\n                spaces = 0\n                name = ''\n            elif infield:\n                if c == ' ':\n                    spaces += 1\n                elif c != '|':\n                    name += c\n                else:\n                    bits = (spaces + len(name) + 1) // 3\n                    endbit = startbit + bits - 1\n                    print('{0:7}    {1:2d}     {2:2d}   {3:2d}'.format(name, bits, startbit, endbit))\n                    reslist = [name, bits, startbit, endbit]\n                    results.append(reslist)\n                    spaces = 0\n                    name = ''\n                    startbit += bits\n                    \n    return results\n                        \ndef unpack(results, hex):\n    print(\"\\nTest string in hex:\")\n    print(hex)\n    print(\"\\nTest string in binary:\")\n    bin = f'{int(hex, 16):0>{4*len(hex)}b}'\n    print(bin)\n    print(\"\\nUnpacked:\\n\")\n    print(\"Name     Size  Bit pattern\")\n    print(\"=======  ====  ================\")\n    for r in results:\n        name = r[0]\n        size = r[1]\n        startbit = r[2]\n        endbit = r[3]\n        bitpattern = bin[startbit:endbit+1]\n        print('{0:7}    {1:2d}  {2:16}'.format(name, size, bitpattern))\n\n\ndiagram = \n\nlines = validate(diagram)\n\nif lines == None:\n    print(\"No lines returned\")\nelse:\n    print(\" \")\n    print(\"Diagram after trimming whitespace and removal of blank lines:\")\n    print(\" \")\n    for line in lines:\n        print(line)\n        \n    print(\" \")\n    print(\"Decoded:\")\n    print(\" \")\n\n    results = decode(lines)    \n    \n    \n    \n    hex = \"78477bbf5496e12e1bf169a4\" \n    \n    unpack(results, hex)\n"}
{"id": 418864, "name": "Sequence_ nth number with exactly n divisors", "source": "Translate Haskell to Python: import           Control.Monad                         (guard)\nimport           Math.NumberTheory.ArithmeticFunctions (divisorCount)\nimport           Math.NumberTheory.Primes              (Prime, unPrime)\nimport           Math.NumberTheory.Primes.Testing      (isPrime)\n\ncalc :: Integer -> [(Integer, Integer)]\ncalc n = do\n  x <- [1..]\n  guard (even n || odd n && f x == x)\n  [(x, divisorCount x)]\n where f n = floor (sqrt $ realToFrac n) ^ 2\n\nhavingNthDivisors :: Integer -> [(Integer, Integer)]\nhavingNthDivisors n = filter ((==n) . snd) $ calc n\n\nnths :: [(Integer, Integer)]\nnths = do\n  n <- [1..35] :: [Integer]\n  if isPrime n then\n    pure (n, nthPrime (fromIntegral n) ^ pred n)\n  else\n    pure (n, f n)\n where\n  f n = fst (havingNthDivisors n !! pred (fromIntegral n))\n  nthPrime n = unPrime (toEnum n :: Prime Integer)\n\nmain :: IO ()\nmain = mapM_ print nths\n", "target": "def divisors(n):\n    divs = [1]\n    for ii in range(2, int(n ** 0.5) + 3):\n        if n % ii == 0:\n            divs.append(ii)\n            divs.append(int(n / ii))\n    divs.append(n)\n    return list(set(divs))\n\n\ndef is_prime(n):\n    return len(divisors(n)) == 2\n\n\ndef primes():\n    ii = 1\n    while True:\n        ii += 1\n        if is_prime(ii):\n            yield ii\n\n\ndef prime(n):\n    generator = primes()\n    for ii in range(n - 1):\n        generator.__next__()\n    return generator.__next__()\n\n\ndef n_divisors(n):\n    ii = 0\n    while True:\n        ii += 1\n        if len(divisors(ii)) == n:\n            yield ii\n\n\ndef sequence(max_n=None):\n    if max_n is not None:\n        for ii in range(1, max_n + 1):\n            if is_prime(ii):\n                yield prime(ii) ** (ii - 1)\n            else:\n                generator = n_divisors(ii)\n                for jj, out in zip(range(ii - 1), generator):\n                    pass\n                yield generator.__next__()\n    else:\n        ii = 1\n        while True:\n            ii += 1\n            if is_prime(ii):\n                yield prime(ii) ** (ii - 1)\n            else:\n                generator = n_divisors(ii)\n                for jj, out in zip(range(ii - 1), generator):\n                    pass\n                yield generator.__next__()\n\n\nif __name__ == '__main__':\n    for item in sequence(15):\n        print(item)\n"}
{"id": 418865, "name": "Addition chains", "source": "Translate Haskell to Python: import Data.List (union)\n\n\ntotal [] = []\ntotal (x:xs) = brauer (x:xs) `union` total xs\n\nbrauer [] = []\nbrauer (x:xs) = map (+ x) (x:xs)\n\n\nchains _ 1 = [[1]]\nchains sums n = go [[1]]\n  where\n    go ch = let next = ch >>= step\n                complete = filter ((== n) . head) next\n            in if null complete then go next else complete\n\n    step ch = (: ch) <$> filter (\\s -> s > head ch && s <= n) (sums ch)\n\n\nisBrauer [_] = True\nisBrauer [_,_] = True\nisBrauer (x:y:xs) = (x - y) `elem` (y:xs) && isBrauer (y:xs)\n", "target": "def prepend(n, seq):\n    return [n] + seq\n\ndef check_seq(pos, seq, n, min_len):\n    if pos > min_len or seq[0] > n:\n        return min_len, 0\n    if seq[0] == n:\n        return pos, 1\n    if pos < min_len:\n        return try_perm(0, pos, seq, n, min_len)\n    return min_len, 0\n\ndef try_perm(i, pos, seq, n, min_len):\n    if i > pos:\n        return min_len, 0\n\n    res1 = check_seq(pos + 1, prepend(seq[0] + seq[i], seq), n, min_len)\n    res2 = try_perm(i + 1, pos, seq, n, res1[0])\n\n    if res2[0] < res1[0]:\n        return res2\n    if res2[0] == res1[0]:\n        return res2[0], res1[1] + res2[1]\n    raise Exception(\"try_perm exception\")\n\ndef init_try_perm(x):\n    return try_perm(0, 0, [1], x, 12)\n\ndef find_brauer(num):\n    res = init_try_perm(num)\n    print\n    print \"N = \", num\n    print \"Minimum length of chains: L(n) = \", res[0]\n    print \"Number of minimum length Brauer chains: \", res[1]\n\n\nnums = [7, 14, 21, 29, 32, 42, 64, 47, 79, 191, 382, 379]\nfor i in nums:\n    find_brauer(i)\n"}
{"id": 418866, "name": "Finite state machine", "source": "Translate Haskell to Python: import System.Exit\nimport Data.Maybe\nimport Control.Monad\nimport Data.List\nimport System.IO\n\ntype Name = String\ntype Sequence = String\ntype State = String\n\ndata Trigger = Trigger { name :: Name\n                       , tseq :: Sequence } deriving (Eq)\n\ninstance Show Trigger where\n  show (Trigger name tseq) = name ++ \"(\" ++ tseq ++ \")\"\n\ndata Transition = Implicit { start :: State\n                            , end :: State }\n                | Explicit { start :: State\n                           , trigger :: Trigger\n                           , end :: State }\n\nfindEndState :: Sequence -> [(Trigger, State)] -> Maybe State\nfindEndState sequence lst = if (isJust pair)\n                               then snd <$> pair\n                               else Nothing\n  where \n    pair = find (\\t -> (tseq . fst) t == sequence) lst\n\nfindRelevantTransitions :: State -> [Transition] -> [Transition]\nfindRelevantTransitions state transitions = filter (\\t -> state == start t) transitions\n\nfindImplicitTransition :: [Transition] -> Maybe Transition\nfindImplicitTransition [] = Nothing\nfindImplicitTransition (transition@(Implicit _ _):xs) = Just transition\nfindImplicitTransition (x:xs) = findImplicitTransition xs\n\nrunFSM :: State -> [Transition] -> [State] -> IO ()\nrunFSM state transitions finishStates = do\n  putStrLn $ \"State: \" ++ state\n  when (state `elem` finishStates) $ do\n    putStrLn \"Exiting..\"\n    exitWith ExitSuccess\n  let relTransitions = findRelevantTransitions state transitions\n  let implTransition = findImplicitTransition relTransitions\n  when (isJust implTransition) $ do\n    putStrLn \"Implicit transition\"\n    runFSM (end $ fromJust implTransition) transitions finishStates\n  let triggers = map (\\t -> (trigger t, end t)) relTransitions\n  handleExplicitTransition triggers\n    where handleExplicitTransition triggers = do\n          let prompt = (intercalate \" or \" (map (show . fst) triggers)) ++ \":\"\n          putStr prompt\n          resp <- getLine\n          let endState = findEndState resp triggers\n          case endState of\n            (Just e) -> runFSM e transitions finishStates\n            Nothing -> putStrLn \"invalid input\" >> handleExplicitTransition triggers\n\nmain = do\n  hSetBuffering stdout $ BlockBuffering $ Just 1\n  runFSM initialState transitions finishStates\n\ninitialState = \"Ready\"\ntransitions = [ Explicit \"Ready\" (Trigger \"Deposit\" \"d\") \"Waiting\"\n              , Explicit \"Ready\" (Trigger \"Quit\" \"q\") \"Exit\"\n              , Explicit \"Waiting\" (Trigger \"Select\" \"s\") \"Dispense\"\n              , Explicit \"Waiting\" (Trigger \"Refund\" \"r\") \"Refunding\"\n              , Explicit \"Dispense\" (Trigger \"Remove\" \"rm\") \"Ready\"\n              , Implicit \"Refunding\" \"Ready\" ]\nfinishStates = [\"Exit\"]\n", "target": "\n\nstates = {  'ready':{\n                'prompt' : 'Machine ready: (d)eposit, or (q)uit?',\n                'responses' : ['d','q']},\n            'waiting':{\n                'prompt' : 'Machine waiting: (s)elect, or (r)efund?',\n                'responses' : ['s','r']},\n            'dispense' : {\n                'prompt' : 'Machine dispensing: please (r)emove product',\n                'responses' : ['r']},\n            'refunding' : {\n                'prompt' : 'Refunding money',\n                'responses' : []},\n            'exit' :{}\n          }\ntransitions = { 'ready': { \n                    'd': 'waiting',\n                    'q': 'exit'},\n                'waiting' : {\n                    's' : 'dispense',\n                    'r' : 'refunding'},\n                'dispense' : {\n                    'r' : 'ready'},\n                'refunding' : {\n                    '' : 'ready'}}\n\ndef Acceptor(prompt, valids):\n    \n    if not valids: \n        print(prompt)\n        return ''\n    else:\n        while True:\n            resp = input(prompt)[0].lower()\n            if resp in valids:\n                return resp\n\ndef finite_state_machine(initial_state, exit_state):\n    response = True\n    next_state = initial_state\n    current_state = states[next_state]\n    while response != exit_state:\n        response = Acceptor(current_state['prompt'], current_state['responses'])\n        next_state = transitions[next_state][response]\n        current_state = states[next_state]\n\nif __name__ == \"__main__\":\n    finite_state_machine('ready','q')\n"}
{"id": 418867, "name": "Sokoban", "source": "Translate Haskell to Python: import Control.Monad (liftM)\nimport Data.Array\nimport Data.List (transpose)\nimport Data.Maybe (mapMaybe)\nimport qualified Data.Sequence as Seq\nimport qualified Data.Set as Set\nimport Prelude hiding (Left, Right)\n\ndata Field = Space | Wall | Goal\n           deriving (Eq)\n\ndata Action = Up | Down | Left | Right | PushUp | PushDown | PushLeft | PushRight\n\ninstance Show Action where\n  show Up        = \"u\"\n  show Down      = \"d\"\n  show Left      = \"l\"\n  show Right     = \"r\"\n  show PushUp    = \"U\"\n  show PushDown  = \"D\"\n  show PushLeft  = \"L\"\n  show PushRight = \"R\"\n\ntype Index = (Int, Int)\ntype FieldArray = Array Index Field\ntype BoxArray = Array Index Bool\ntype PlayerPos = Index\ntype GameState = (BoxArray, PlayerPos)\ntype Game = (FieldArray, GameState)\n\ntoField :: Char -> Field\ntoField '#' = Wall\ntoField ' ' = Space\ntoField '@' = Space\ntoField '$' = Space\ntoField '.' = Goal\ntoField '+' = Goal\ntoField '*' = Goal\n\ntoPush :: Action -> Action\ntoPush Up    = PushUp\ntoPush Down  = PushDown\ntoPush Left  = PushLeft\ntoPush Right = PushRight\ntoPush n     = n\n\ntoMove :: Action -> Index\ntoMove PushUp    = ( 0, -1)\ntoMove PushDown  = ( 0,  1)\ntoMove PushLeft  = (-1,  0)\ntoMove PushRight = ( 1,  0)\ntoMove n = toMove $ toPush n\n\n\n\nparseGame :: [String] -> Game\nparseGame fieldStrs = (field, (boxes, player))\n  where\n    width     = length $ head fieldStrs\n    height    = length fieldStrs\n    bound     = ((0, 0), (width - 1, height - 1))\n    flatField = concat $ transpose fieldStrs\n    charField = listArray bound flatField\n    field     = fmap toField charField\n    boxes     = fmap (`elem` \"$*\") charField\n    player    = fst $ head $ filter (flip elem \"@+\" . snd) $ assocs charField\n\nadd :: (Num a, Num b) => (a, b) -> (a, b) -> (a, b)\nadd (a, b) (x, y) = (a + x, b + y)\n\n\n\ntryAction :: Game -> Action -> Maybe (Game, Action)\ntryAction (field, (boxes, player)) action\n  | field ! vec == Wall = Nothing\n  | boxes ! vec =\n     if boxes ! vecB || field ! vecB == Wall\n     then Nothing\n     else Just ((field, (boxes // [(vec, False), (vecB, True)], vec)),\n               toPush action)\n  | otherwise = Just ((field, (boxes, vec)), action)\n  where\n    actionVec = toMove action\n    vec       = player `add` actionVec\n    vecB      = vec `add` actionVec\n\n\nsolveGame :: Game -> Maybe [Action]\nsolveGame (field, initState) =\n  liftM reverse $ bfs (Seq.singleton (initState, [])) (Set.singleton initState)\n  where\n    goals           = map fst $ filter ((== Goal) . snd) $ assocs field\n    isSolved st     = all (st !) goals\n    possibleActions = [Up, Down, Left, Right]\n    \n    \n    bfs :: Seq.Seq (GameState, [Action]) -> Set.Set GameState -> Maybe [Action]\n    bfs queue visited =\n      case Seq.viewl queue of\n        Seq.EmptyL -> Nothing\n        (game@(boxes, _), actions) Seq.:< queueB ->\n          if isSolved boxes\n          then Just actions\n          else\n            let newMoves = filter (flip Set.notMember visited . fst) $\n                           map (\\((_, g), a) -> (g, a)) $\n                           mapMaybe (tryAction (field, game)) possibleActions\n                visitedB = foldl (flip Set.insert) visited $\n                           map fst newMoves\n                queueC   = foldl (Seq.|>) queueB $\n                           map (\\(g, a) -> (g, a:actions)) newMoves\n            in bfs queueC visitedB\n\nexampleA :: [String]\nexampleA =\n  [\"#######\"\n  ,\"#     #\"\n  ,\"#     #\"\n  ,\"#. #  #\"\n  ,\"#. $$ #\"\n  ,\"#.$$  #\"\n  ,\"#.#  @#\"\n  ,\"#######\"]\n\nmain :: IO ()\nmain =\n  case solveGame $ parseGame exampleA of\n    Nothing       -> putStrLn \"Unsolvable\"\n    Just solution -> do\n      mapM_ putStrLn exampleA\n      putStrLn \"\"\n      putStrLn $ concatMap show solution\n", "target": "from array import array\nfrom collections import deque\nimport psyco\n\ndata = []\nnrows = 0\npx = py = 0\nsdata = \"\"\nddata = \"\"\n\ndef init(board):\n    global data, nrows, sdata, ddata, px, py\n    data = filter(None, board.splitlines())\n    nrows = max(len(r) for r in data)\n\n    maps = {' ':' ', '.': '.', '@':' ', '\n    mapd = {' ':' ', '.': ' ', '@':'@', '\n\n    for r, row in enumerate(data):\n        for c, ch in enumerate(row):\n            sdata += maps[ch]\n            ddata += mapd[ch]\n            if ch == '@':\n                px = c\n                py = r\n\ndef push(x, y, dx, dy, data):\n    if sdata[(y+2*dy) * nrows + x+2*dx] == '\n       data[(y+2*dy) * nrows + x+2*dx] != ' ':\n        return None\n\n    data2 = array(\"c\", data)\n    data2[y * nrows + x] = ' '\n    data2[(y+dy) * nrows + x+dx] = '@'\n    data2[(y+2*dy) * nrows + x+2*dx] = '*'\n    return data2.tostring()\n\ndef is_solved(data):\n    for i in xrange(len(data)):\n        if (sdata[i] == '.') != (data[i] == '*'):\n            return False\n    return True\n\ndef solve():\n    open = deque([(ddata, \"\", px, py)])\n    visited = set([ddata])\n    dirs = ((0, -1, 'u', 'U'), ( 1, 0, 'r', 'R'),\n            (0,  1, 'd', 'D'), (-1, 0, 'l', 'L'))\n\n    lnrows = nrows\n    while open:\n        cur, csol, x, y = open.popleft()\n\n        for di in dirs:\n            temp = cur\n            dx, dy = di[0], di[1]\n\n            if temp[(y+dy) * lnrows + x+dx] == '*':\n                temp = push(x, y, dx, dy, temp)\n                if temp and temp not in visited:\n                    if is_solved(temp):\n                        return csol + di[3]\n                    open.append((temp, csol + di[3], x+dx, y+dy))\n                    visited.add(temp)\n            else:\n                if sdata[(y+dy) * lnrows + x+dx] == '\n                   temp[(y+dy) * lnrows + x+dx] != ' ':\n                    continue\n\n                data2 = array(\"c\", temp)\n                data2[y * lnrows + x] = ' '\n                data2[(y+dy) * lnrows + x+dx] = '@'\n                temp = data2.tostring()\n\n                if temp not in visited:\n                    if is_solved(temp):\n                        return csol + di[2]\n                    open.append((temp, csol + di[2], x+dx, y+dy))\n                    visited.add(temp)\n\n    return \"No solution\"\n\n\nlevel = \"\"\"\\\n\n\n\n\n\n\n\n\n\npsyco.full()\ninit(level)\nprint level, \"\\n\\n\", solve()\n"}
{"id": 418868, "name": "Zumkeller numbers", "source": "Translate Haskell to Python: import Data.List (group, sort)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primeFactors)\n\n\n\nisZumkeller :: Int -> Bool\nisZumkeller n =\n  let ds = divisors n\n      m = sum ds\n   in ( even m\n          && let half = div m 2\n              in elem half ds\n                   || ( all (half >=) ds\n                          && summable half ds\n                      )\n      )\n\nsummable :: Int -> [Int] -> Bool\nsummable _ [] = False\nsummable x xs@(h : t) =\n  elem x xs\n    || summable (x - h) t\n    || summable x t\n\ndivisors :: Int -> [Int]\ndivisors x =\n  sort\n    ( foldr\n        ( flip ((<*>) . fmap (*))\n            . scanl (*) 1\n        )\n        [1]\n        (group (primeFactors x))\n    )\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( \\(s, n, xs) ->\n        putStrLn $\n          s\n            <> ( '\\n' :\n                 tabulated\n                   10\n                   (take n (filter isZumkeller xs))\n               )\n    )\n    [ (\"First 220 Zumkeller numbers:\", 220, [1 ..]),\n      (\"First 40 odd Zumkeller numbers:\", 40, [1, 3 ..])\n    ]\n\n\ntabulated ::\n  Show a =>\n  Int ->\n  [a] ->\n  String\ntabulated nCols = go\n  where\n    go xs =\n      let ts = show <$> xs\n          w = succ (maximum (length <$> ts))\n       in unlines\n            ( concat\n                <$> chunksOf\n                  nCols\n                  (justifyRight w ' ' <$> ts)\n            )\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n", "target": "from sympy import divisors\n\nfrom sympy.combinatorics.subsets import Subset\n\ndef isZumkeller(n):\n    d = divisors(n)\n    s = sum(d)\n    if not s % 2 and max(d) <= s/2:\n        for x in range(1, 2**len(d)):\n            if sum(Subset.unrank_binary(x, d).subset) == s/2:\n                return True\n\n    return False\n\n\n\ndef printZumkellers(N, oddonly=False):\n    nprinted = 0\n    for n in range(1, 10**5):\n        if (oddonly == False or n % 2) and isZumkeller(n):\n            print(f'{n:>8}', end='')\n            nprinted += 1\n            if nprinted % 10 == 0:\n                print()\n            if nprinted >= N:\n                return\n\n\nprint(\"220 Zumkeller numbers:\")\nprintZumkellers(220)\nprint(\"\\n\\n40 odd Zumkeller numbers:\")\nprintZumkellers(40, True)\n"}
{"id": 418869, "name": "Commatizing numbers", "source": "Translate Haskell to Python: #!/usr/bin/env runhaskell\n\nimport Control.Monad (forM_)\nimport Data.Char (isDigit)\nimport Data.List (intercalate)\nimport Data.Maybe (fromMaybe)\n\n\n\nisDigitOrPeriod :: Char -> Bool\nisDigitOrPeriod '.' = True\nisDigitOrPeriod c = isDigit c\n\nchopUp :: Int -> String -> [String]\nchopUp _ [] = []\nchopUp by str\n  | by < 1 = [str]              \n  | otherwise = let (pfx, sfx) = splitAt by str\n                in pfx : chopUp by sfx\n\naddSeps :: String -> Char -> Int -> (String -> String) -> String\naddSeps str sep by rev =\n  let (leading, number) = span (== '0') str\n      number2 = rev $ intercalate [sep] $ chopUp by $ rev number\n  in leading ++ number2\n\nprocessNumber :: String -> Char -> Int -> String\nprocessNumber str sep by =\n  let (beforeDecimal, rest) = span isDigit str\n      (decimal, afterDecimal) = splitAt 1 rest\n      beforeDecimal2 = addSeps beforeDecimal sep by reverse\n      afterDecimal2 = addSeps afterDecimal sep by id\n  in beforeDecimal2 ++ decimal ++ afterDecimal2\n\ncommatize2 :: String -> Char -> Int -> String\ncommatize2 [] _ _ = []\ncommatize2 str sep by =\n  let (pfx, sfx) = break isDigitOrPeriod str\n      (number, sfx2) = span isDigitOrPeriod sfx\n  in pfx ++ processNumber number sep by ++ sfx2\n\ncommatize :: String -> Maybe Char -> Maybe Int -> String\ncommatize str sep by = commatize2 str (fromMaybe ',' sep) (fromMaybe 3 by)\n\ninput :: [(String, Maybe Char, Maybe Int)]\ninput =\n  [ (\"pi=3.14159265358979323846264338327950288419716939937510582097494459231\", Just ' ', Just 5)\n  , (\"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\", Just '.', Nothing)\n  , (\"\\\"-in Aus$+1411.8millions\\\"\", Nothing, Nothing)\n  , (\"===US$0017440 millions=== (in 2000 dollars)\", Nothing, Nothing)\n  , (\"123.e8000 is pretty big.\", Nothing, Nothing)\n  , (\"The land area of the earth is 57268900(29% of the surface) square miles.\", Nothing, Nothing)\n  , (\"Ain't no numbers in this here words, nohow, no way, Jose.\", Nothing, Nothing)\n  , (\"James was never known as 0000000007\", Nothing, Nothing)\n  , (\"Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.\", Nothing, Nothing)\n  , (\"   $-140000\u00b1100 millions.\", Nothing, Nothing)\n  , (\"6/9/1946 was a good year for some.\", Nothing, Nothing)\n  ]\n\nmain :: IO ()\nmain =\n  forM_ input $ \\(str, by, sep) -> do\n    putStrLn str\n    putStrLn $ commatize str by sep\n    putStrLn \"\"\n", "target": "import re as RegEx\n\n\ndef Commatize( _string, _startPos=0, _periodLen=3, _separator=\",\" ):\n\toutString = \"\"\n\tstrPos = 0\n\tmatches = RegEx.findall( \"[0-9]*\", _string )\n\n\tfor match in matches[:-1]:\n\t\tif not match:\n\t\t\toutString += _string[ strPos ]\n\t\t\tstrPos += 1\n\t\telse:\n\t\t\tif len(match) > _periodLen:\n\t\t\t\tleadIn = match[:_startPos]\n\t\t\t\tperiods =  [ match [ i:i + _periodLen ] for i in range ( _startPos, len ( match ), _periodLen ) ]\n\t\t\t\toutString += leadIn + _separator.join( periods )\n\t\t\telse:\n\t\t\t\toutString += match\n\n\t\t\tstrPos += len( match )\n\n\treturn outString\n\n\n\nprint ( Commatize( \"pi=3.14159265358979323846264338327950288419716939937510582097494459231\", 0, 5, \" \" ) )\nprint ( Commatize( \"The author has two Z$100000000000000 Zimbabwe notes (100 trillion).\", 0, 3, \".\" ))\nprint ( Commatize( \"\\\"-in Aus$+1411.8millions\\\"\" ))\nprint ( Commatize( \"===US$0017440 millions=== (in 2000 dollars)\" ))\nprint ( Commatize( \"123.e8000 is pretty big.\" ))\nprint ( Commatize( \"The land area of the earth is 57268900(29% of the surface) square miles.\" ))\nprint ( Commatize( \"Ain't no numbers in this here words, nohow, no way, Jose.\" ))\nprint ( Commatize( \"James was never known as 0000000007\" ))\nprint ( Commatize( \"Arthur Eddington wrote: I believe there are 15747724136275002577605653961181555468044717914527116709366231425076185631031296 protons in the universe.\" ))\nprint ( Commatize( \"\u2422\u2422\u2422$-140000\u00b1100 millions.\" ))\nprint ( Commatize( \"6/9/1946 was a good year for some.\" ))\n"}
{"id": 418870, "name": "Base58Check encoding", "source": "Translate Haskell to Python: import Numeric (showIntAtBase)\n\nchars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58Encode :: Integer -> String\nbase58Encode n = showIntAtBase 58 (chars !!) n \"\"\n\nmain :: IO ()\nmain = mapM_ (putStrLn . base58Encode)\n        [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n", "target": "ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef convertToBase58(num):\n    sb = ''\n    while (num > 0):\n        r = num % 58\n        sb = sb + ALPHABET[r]\n        num = num // 58;\n    return sb[::-1]\n\ns = 25420294593250030202636073700053352635053786165627414518\nb = convertToBase58(s)\nprint(\"%-56d -> %s\" % (s, b))\n\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\nfor num in hash_arr:\n    b = convertToBase58(num)\n    print(\"0x%-54x -> %s\" % (num, b))\n"}
{"id": 418871, "name": "Base58Check encoding", "source": "Translate Haskell to Python: import Numeric (showIntAtBase)\n\nchars = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\nbase58Encode :: Integer -> String\nbase58Encode n = showIntAtBase 58 (chars !!) n \"\"\n\nmain :: IO ()\nmain = mapM_ (putStrLn . base58Encode)\n        [25420294593250030202636073700053352635053786165627414518,\n         0x61,\n         0x626262,\n         0x636363,\n         0x73696d706c792061206c6f6e6720737472696e67,\n         0x516b6fcd0f,\n         0xbf4f89001e670274dd,\n         0x572e4794,\n         0xecac89cad93923c02321,\n         0x10c8511e]\n", "target": "ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\"\n\ndef convertToBase58(num):\n    sb = ''\n    while (num > 0):\n        r = num % 58\n        sb = sb + ALPHABET[r]\n        num = num // 58;\n    return sb[::-1]\n\ns = 25420294593250030202636073700053352635053786165627414518\nb = convertToBase58(s)\nprint(\"%-56d -> %s\" % (s, b))\n\nhash_arr = [0x61, 0x626262, 0x636363, 0x73696d706c792061206c6f6e6720737472696e67, 0x516b6fcd0f, 0xbf4f89001e670274dd, 0x572e4794, 0xecac89cad93923c02321, 0x10c8511e]\nfor num in hash_arr:\n    b = convertToBase58(num)\n    print(\"0x%-54x -> %s\" % (num, b))\n"}
{"id": 418872, "name": "Latin Squares in reduced form", "source": "Translate Haskell to Python: import Data.List (permutations, (\\\\))\nimport Control.Monad (foldM, forM_)\n\nlatinSquares :: Eq a => [a] -> [[[a]]]\nlatinSquares [] = []\nlatinSquares set = map reverse <$> squares\n  where\n    squares = foldM addRow firstRow perm\n    perm = tail (groupedPermutations set)\n    firstRow = pure <$> set\n    addRow tbl rows = [ zipWith (:) row tbl\n                      | row <- rows                      \n                      , and $ different (tail row) (tail tbl) ]\n    different = zipWith $ (not .) . elem\n       \ngroupedPermutations :: Eq a => [a] -> [[[a]]]\ngroupedPermutations lst = map (\\x -> (x :) <$> permutations (lst \\\\ [x])) lst\n\nprintTable :: Show a => [[a]] -> IO () \nprintTable tbl = putStrLn $ unlines $ unwords . map show <$> tbl\n", "target": "def dList(n, start):\n    start -= 1 \n    a = range(n)\n    a[start] = a[0]\n    a[0] = start\n    a[1:] = sorted(a[1:])\n    first = a[1]\n    \n    r = []\n    def recurse(last):\n        if (last == first):\n            \n            \n            \n            for j,v in enumerate(a[1:]):\n                if j + 1 == v:\n                    return \n            b = [x + 1 for x in a]\n            r.append(b)\n            return\n        for i in xrange(last, 0, -1):\n            a[i], a[last] = a[last], a[i]\n            recurse(last - 1)\n            a[i], a[last] = a[last], a[i]\n    recurse(n - 1)\n    return r\n\ndef printSquare(latin,n):\n    for row in latin:\n        print row\n    print\n\ndef reducedLatinSquares(n,echo):\n    if n <= 0:\n        if echo:\n            print []\n        return 0\n    elif n == 1:\n        if echo:\n            print [1]\n        return 1\n\n    rlatin = [None] * n\n    for i in xrange(n):\n        rlatin[i] = [None] * n\n    \n    for j in xrange(0, n):\n        rlatin[0][j] = j + 1\n\n    class OuterScope:\n        count = 0\n    def recurse(i):\n        rows = dList(n, i)\n\n        for r in xrange(len(rows)):\n            rlatin[i - 1] = rows[r]\n            justContinue = False\n            k = 0\n            while not justContinue and k < i - 1:\n                for j in xrange(1, n):\n                    if rlatin[k][j] == rlatin[i - 1][j]:\n                        if r < len(rows) - 1:\n                            justContinue = True\n                            break\n                        if i > 2:\n                            return\n                k += 1\n            if not justContinue:\n                if i < n:\n                    recurse(i + 1)\n                else:\n                    OuterScope.count += 1\n                    if echo:\n                        printSquare(rlatin, n)\n\n    \n    recurse(2)\n    return OuterScope.count\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    prod = 1\n    for i in xrange(2, n + 1):\n        prod *= i\n    return prod\n\nprint \"The four reduced latin squares of order 4 are:\\n\"\nreducedLatinSquares(4,True)\n\nprint \"The size of the set of reduced latin squares for the following orders\"\nprint \"and hence the total number of latin squares of these orders are:\\n\"\nfor n in xrange(1, 7):\n    size = reducedLatinSquares(n, False)\n    f = factorial(n - 1)\n    f *= f * n * size\n    print \"Order %d: Size %-4d x %d! x %d! => Total %d\" % (n, size, n, n - 1, f)\n"}
{"id": 418873, "name": "Playfair cipher", "source": "Translate Haskell to Python: import Control.Monad     (guard)\nimport Data.Array        (Array, assocs, elems, listArray, (!))\nimport Data.Char         (toUpper)\nimport Data.List         (nub, (\\\\))\nimport Data.List.Split   (chunksOf)\nimport Data.Maybe        (listToMaybe)\nimport Data.String.Utils (replace)\n\ntype Square a = Array (Int, Int) a\n\n\narray2D ::\n       (Int, Int) \n    -> [e] -> Square e\narray2D maxCoord = listArray ((1, 1), maxCoord)\n\n\n\n\n\nmakeTable :: String -> String\nmakeTable k = nub key ++ (alpha \\\\ key)\n    where\n      alpha = ['A' .. 'Z'] \\\\ \"J\"\n      key = map toUpper =<< words k\n\n\nmakeSquare :: [a] -> Square a\nmakeSquare = array2D (5, 5)\n\n\nshowSquare :: Square Char -> String\nshowSquare d = unlines $ chunksOf 5 (elems d)\n\n\ngetIndex' :: (Eq a) => a -> [((Int, Int), a)] -> Maybe (Int, Int)\ngetIndex' el = fmap fst . listToMaybe . filter ((== el) . snd)\n\nencodePair, decodePair :: Eq a => Square a -> (a, a) -> Maybe (a, a)\nencodePair = pairHelper (\\x -> if x == 5 then 1 else x + 1)\ndecodePair = pairHelper (\\x -> if x == 1 then 5 else x - 1)\n\npairHelper :: (Eq t)\n    => (Int -> Int) \n    -> Square t \n    -> (t, t) \n    -> Maybe (t, t) \npairHelper adjust sqr (c1, c2) =\n    do let ps = assocs sqr\n       \n       (x1, y1) <- getIndex' c1 ps\n       (x2, y2) <- getIndex' c2 ps\n       \n       \n       guard $ c1 /= c2\n       \n       let get x = sqr ! x\n       \n       Just $\n           \n           case () of\n             () | y1 == y2 ->\n                    (get (adjust x1, y1), get (adjust x2, y2))\n                | x1 == x2 ->\n                    (get (x1, adjust y1), get (x2, adjust y2))\n                | otherwise ->\n                    (get (x1, y2), get (x2, y1))\n\n\nparsePair :: String -> [(Char, Char)]\nparsePair = fmap (\\[x, y] -> (x, y)) . words . fmap toUpper\n\n\nunparsePair :: [(Char, Char)] -> String\nunparsePair = unwords . fmap (\\(x, y) -> [x, y])\n\ncodeHelper :: (Square Char -> (Char, Char) -> Maybe (Char, Char))\n    -> String -> String -> Maybe String\ncodeHelper subs key =\n    fmap unparsePair .\n    mapM (subs (makeSquare $ makeTable key)) .\n    parsePair\n\nplayfair, unplayfair :: String -> String -> Maybe String\nplayfair key = codeHelper encodePair key . formatEncode\nunplayfair = codeHelper decodePair\n\nformatEncode :: String -> String\nformatEncode =\n    map toUpper .\n    unwords .\n    map (\\[x, y] -> if x == y then [x, 'x'] else [x, y]) .\n    chunksOf 2 .\n    replace \"j\" \"i\" .\n    concatMap adjustLength .\n    words .\n    filter (\\n -> n `elem` (['A'..'Z'] ++ ['a'..'z']))\n    where\n      adjustLength str\n          | odd (length str) = str ++ \"x\"\n          | otherwise = str\n", "target": "from string import ascii_uppercase\nfrom itertools import product\nfrom re import findall\n\ndef uniq(seq):\n    seen = {}\n    return [seen.setdefault(x, x) for x in seq if x not in seen]\n\ndef partition(seq, n):\n    return [seq[i : i + n] for i in xrange(0, len(seq), n)]\n\n\n\ndef playfair(key, from_ = 'J', to = None):\n    if to is None:\n        to = 'I' if from_ == 'J' else ''\n\n    def canonicalize(s):\n        return filter(str.isupper, s.upper()).replace(from_, to)\n\n    \n    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)\n\n    \n    enc = {}\n\n    \n    for row in m:\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]\n\n    \n    for c in zip(*m):\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]\n\n    \n    for i1, j1, i2, j2 in product(xrange(5), repeat=4):\n        if i1 != i2 and j1 != j2:\n            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]\n\n    \n    dec = dict((v, k) for k, v in enc.iteritems())\n\n    def sub_enc(txt):\n        lst = findall(r\"(.)(?:(?!\\1)(.))?\", canonicalize(txt))\n        return \" \".join(enc[a + (b if b else 'X')] for a, b in lst)\n\n    def sub_dec(encoded):\n        return \" \".join(dec[p] for p in partition(canonicalize(encoded), 2))\n\n    return sub_enc, sub_dec\n\n\n(encode, decode) = playfair(\"Playfair example\")\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprint \"Original:\", orig\nenc = encode(orig)\nprint \"Encoded:\", enc\nprint \"Decoded:\", decode(enc)\n"}
{"id": 418874, "name": "Playfair cipher", "source": "Translate Haskell to Python: import Control.Monad     (guard)\nimport Data.Array        (Array, assocs, elems, listArray, (!))\nimport Data.Char         (toUpper)\nimport Data.List         (nub, (\\\\))\nimport Data.List.Split   (chunksOf)\nimport Data.Maybe        (listToMaybe)\nimport Data.String.Utils (replace)\n\ntype Square a = Array (Int, Int) a\n\n\narray2D ::\n       (Int, Int) \n    -> [e] -> Square e\narray2D maxCoord = listArray ((1, 1), maxCoord)\n\n\n\n\n\nmakeTable :: String -> String\nmakeTable k = nub key ++ (alpha \\\\ key)\n    where\n      alpha = ['A' .. 'Z'] \\\\ \"J\"\n      key = map toUpper =<< words k\n\n\nmakeSquare :: [a] -> Square a\nmakeSquare = array2D (5, 5)\n\n\nshowSquare :: Square Char -> String\nshowSquare d = unlines $ chunksOf 5 (elems d)\n\n\ngetIndex' :: (Eq a) => a -> [((Int, Int), a)] -> Maybe (Int, Int)\ngetIndex' el = fmap fst . listToMaybe . filter ((== el) . snd)\n\nencodePair, decodePair :: Eq a => Square a -> (a, a) -> Maybe (a, a)\nencodePair = pairHelper (\\x -> if x == 5 then 1 else x + 1)\ndecodePair = pairHelper (\\x -> if x == 1 then 5 else x - 1)\n\npairHelper :: (Eq t)\n    => (Int -> Int) \n    -> Square t \n    -> (t, t) \n    -> Maybe (t, t) \npairHelper adjust sqr (c1, c2) =\n    do let ps = assocs sqr\n       \n       (x1, y1) <- getIndex' c1 ps\n       (x2, y2) <- getIndex' c2 ps\n       \n       \n       guard $ c1 /= c2\n       \n       let get x = sqr ! x\n       \n       Just $\n           \n           case () of\n             () | y1 == y2 ->\n                    (get (adjust x1, y1), get (adjust x2, y2))\n                | x1 == x2 ->\n                    (get (x1, adjust y1), get (x2, adjust y2))\n                | otherwise ->\n                    (get (x1, y2), get (x2, y1))\n\n\nparsePair :: String -> [(Char, Char)]\nparsePair = fmap (\\[x, y] -> (x, y)) . words . fmap toUpper\n\n\nunparsePair :: [(Char, Char)] -> String\nunparsePair = unwords . fmap (\\(x, y) -> [x, y])\n\ncodeHelper :: (Square Char -> (Char, Char) -> Maybe (Char, Char))\n    -> String -> String -> Maybe String\ncodeHelper subs key =\n    fmap unparsePair .\n    mapM (subs (makeSquare $ makeTable key)) .\n    parsePair\n\nplayfair, unplayfair :: String -> String -> Maybe String\nplayfair key = codeHelper encodePair key . formatEncode\nunplayfair = codeHelper decodePair\n\nformatEncode :: String -> String\nformatEncode =\n    map toUpper .\n    unwords .\n    map (\\[x, y] -> if x == y then [x, 'x'] else [x, y]) .\n    chunksOf 2 .\n    replace \"j\" \"i\" .\n    concatMap adjustLength .\n    words .\n    filter (\\n -> n `elem` (['A'..'Z'] ++ ['a'..'z']))\n    where\n      adjustLength str\n          | odd (length str) = str ++ \"x\"\n          | otherwise = str\n", "target": "from string import ascii_uppercase\nfrom itertools import product\nfrom re import findall\n\ndef uniq(seq):\n    seen = {}\n    return [seen.setdefault(x, x) for x in seq if x not in seen]\n\ndef partition(seq, n):\n    return [seq[i : i + n] for i in xrange(0, len(seq), n)]\n\n\n\ndef playfair(key, from_ = 'J', to = None):\n    if to is None:\n        to = 'I' if from_ == 'J' else ''\n\n    def canonicalize(s):\n        return filter(str.isupper, s.upper()).replace(from_, to)\n\n    \n    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)\n\n    \n    enc = {}\n\n    \n    for row in m:\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]\n\n    \n    for c in zip(*m):\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]\n\n    \n    for i1, j1, i2, j2 in product(xrange(5), repeat=4):\n        if i1 != i2 and j1 != j2:\n            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]\n\n    \n    dec = dict((v, k) for k, v in enc.iteritems())\n\n    def sub_enc(txt):\n        lst = findall(r\"(.)(?:(?!\\1)(.))?\", canonicalize(txt))\n        return \" \".join(enc[a + (b if b else 'X')] for a, b in lst)\n\n    def sub_dec(encoded):\n        return \" \".join(dec[p] for p in partition(canonicalize(encoded), 2))\n\n    return sub_enc, sub_dec\n\n\n(encode, decode) = playfair(\"Playfair example\")\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprint \"Original:\", orig\nenc = encode(orig)\nprint \"Encoded:\", enc\nprint \"Decoded:\", decode(enc)\n"}
{"id": 418875, "name": "Elementary cellular automaton_Infinite length", "source": "Translate Haskell to Python: \n\nimport Control.Comonad\nimport Data.InfList (InfList (..), (+++))\nimport qualified Data.InfList as Inf\n\ndata Cells a = Cells (InfList a) a (InfList a) deriving Functor\n\nview n (Cells l x r) = reverse (Inf.take n l) ++ [x] ++ (Inf.take n r)\n\nfromList []     = fromList [0]\nfromList (x:xs) = let zeros = Inf.repeat 0\n                  in Cells zeros x (xs +++ zeros)\n", "target": "def _notcell(c):\n    return '0' if c == '1' else '1'\n\ndef eca_infinite(cells, rule):\n    lencells = len(cells)\n    rulebits = '{0:08b}'.format(rule)\n    neighbours2next = {'{0:03b}'.format(n):rulebits[::-1][n] for n in range(8)}\n    c = cells\n    while True:\n        yield c\n        c = _notcell(c[0])*2 + c + _notcell(c[-1])*2    \n\n        c = ''.join(neighbours2next[c[i-1:i+2]] for i in range(1,len(c) - 1))\n        \n\nif __name__ == '__main__':\n    lines = 25\n    for rule in (90, 30):\n        print('\\nRule: %i' % rule)\n        for i, c in zip(range(lines), eca_infinite('1', rule)):\n            print('%2i: %s%s' % (i, ' '*(lines - i), c.replace('0', '.').replace('1', '\n"}
{"id": 418876, "name": "Word break problem", "source": "Translate Haskell to Python: import Data.List (isPrefixOf, intercalate)\nimport Data.Tree (Tree(..))\n\nwordBreaks :: [String] -> String -> String\nwordBreaks ws = (++) <*> (\":\\n\" ++) . report . fmap go . tokenTrees ws\n  where\n    go t\n      | null (subForest t) = [rootLabel t]\n      | otherwise = subForest t >>= ((:) (rootLabel t) . go)\n    report xs\n      | null xs = \"\\tNot parseable with these words\"\n      | otherwise = unlines $ ('\\t' :) . intercalate \" -> \" <$> xs\n\ntokenTrees :: [String] -> String -> [Tree String]\ntokenTrees ws = go\n  where\n    go s\n      | s `elem` ws = [Node s []]\n      | otherwise = ws >>= next s\n    next s w\n      | w `isPrefixOf` s = parse w (go (drop (length w) s))\n      | otherwise = []\n    parse w xs\n      | null xs = []\n      | otherwise = [Node w xs]\n\n\nws, texts :: [String]\nws = words \"a bc abc cd b\"\n\ntexts = words \"abcd abbc abcbcd acdbc abcdd\"\n\nmain :: IO ()\nmain = (putStrLn . unlines) $ wordBreaks ws <$> texts\n", "target": "\n\nfrom itertools import (chain)\n\n\n\ndef stringParse(lexicon):\n    \n    return lambda s: Node(s)(\n        tokenTrees(lexicon)(s)\n    )\n\n\n\ndef tokenTrees(wds):\n    \n    def go(s):\n        return [Node(s)([])] if s in wds else (\n            concatMap(nxt(s))(wds)\n        )\n\n    def nxt(s):\n        return lambda w: parse(\n            w, go(s[len(w):])\n        ) if s.startswith(w) else []\n\n    def parse(w, xs):\n        return [Node(w)(xs)] if xs else xs\n\n    return lambda s: go(s)\n\n\n\ndef showParse(tree):\n    \n    def showTokens(x):\n        xs = x['nest']\n        return ' ' + x['root'] + (showTokens(xs[0]) if xs else '')\n    parses = tree['nest']\n    return tree['root'] + ':\\n' + (\n        '\\n'.join(\n            map(showTokens, parses)\n        ) if parses else ' ( Not parseable in terms of these words )'\n    )\n\n\n\n\ndef main():\n    \n\n    lexicon = 'a bc abc cd b'.split()\n    testSamples = 'abcd abbc abcbcd acdbc abcdd'.split()\n\n    print(unlines(\n        map(\n            showParse,\n            map(\n                stringParse(lexicon),\n                testSamples\n            )\n        )\n    ))\n\n\n\n\n\ndef Node(v):\n    \n    return lambda xs: {'type': 'Node', 'root': v, 'nest': xs}\n\n\n\ndef concatMap(f):\n    \n    return lambda xs: list(\n        chain.from_iterable(map(f, xs))\n    )\n\n\n\ndef unlines(xs):\n    \n    return '\\n'.join(xs)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418877, "name": "K-means++ clustering", "source": "Translate Haskell to Python: \nmodule KMeans where\n \nimport Control.Applicative\nimport Control.Monad.Random\nimport Data.List (minimumBy, genericLength, transpose)\nimport Data.Ord (comparing)\nimport qualified Data.Map.Strict as M\n\n \ntype Vec = [Float]\ntype Cluster = [Vec]\n \nkMeansIteration :: [Vec] -> [Vec] -> [Cluster]\nkMeansIteration pts = clusterize . fixPoint iteration\n  where\n    iteration = map centroid . clusterize\n \n    clusterize centroids = M.elems $ foldr add m0 pts\n      where add x = M.insertWith (++) (centroids `nearestTo` x) [x]\n            m0 = M.unions $ map (`M.singleton` []) centroids\n \nnearestTo :: [Vec] -> Vec -> Vec\nnearestTo pts x =  minimumBy (comparing (distance x)) pts\n \ndistance :: Vec -> Vec -> Float\ndistance a b = sum $ map (^2) $ zipWith (-) a b\n \ncentroid :: [Vec] -> Vec\ncentroid = map mean . transpose\n  where  mean pts = sum pts / genericLength pts\n \nfixPoint :: Eq a => (a -> a) -> a -> a\nfixPoint f x = if x == fx then x else fixPoint f fx where fx = f x\n \n\n \nkMeans :: MonadRandom m => Int -> [Vec] -> m [Cluster]\nkMeans n pts = kMeansIteration pts <$> take n <$> randomElements pts\n \nkMeansPP :: MonadRandom m => Int -> [Vec] -> m [Cluster]\nkMeansPP n pts = kMeansIteration pts <$> centroids\n  where centroids = iterate (>>= nextCentroid) x0 !! (n-1)\n        x0 = take 1 <$> randomElements pts\n        nextCentroid cs = (: cs) <$> fromList (map (weight cs) pts)\n        weight cs x = (x, toRational $ distance x (cs `nearestTo` x))\n \nrandomElements :: MonadRandom m => [a] -> m [a]\nrandomElements pts = map (pts !!) <$> getRandomRs (0, length pts)\n\n\n\ninstance (RandomGen g, Monoid m) => Monoid (Rand g m) where\n   mempty = pure mempty\n   mappend = liftA2 mappend\n\nmkCluster n s m = take n . transpose <$> mapM randomsAround m\n  where randomsAround x0 = map (\\x -> x0+s*atanh x) <$> getRandomRs (-1,1)\n", "target": "from math import pi, sin, cos\nfrom collections import namedtuple\nfrom random import random, choice\nfrom copy import copy\n\ntry:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\n\nFLOAT_MAX = 1e100\n\n\nclass Point:\n    __slots__ = [\"x\", \"y\", \"group\"]\n    def __init__(self, x=0.0, y=0.0, group=0):\n        self.x, self.y, self.group = x, y, group\n\n\ndef generate_points(npoints, radius):\n    points = [Point() for _ in xrange(npoints)]\n\n    \n    for p in points:\n        r = random() * radius\n        ang = random() * 2 * pi\n        p.x = r * cos(ang)\n        p.y = r * sin(ang)\n\n    return points\n\n\ndef nearest_cluster_center(point, cluster_centers):\n    \n    def sqr_distance_2D(a, b):\n        return (a.x - b.x) ** 2  +  (a.y - b.y) ** 2\n\n    min_index = point.group\n    min_dist = FLOAT_MAX\n\n    for i, cc in enumerate(cluster_centers):\n        d = sqr_distance_2D(cc, point)\n        if min_dist > d:\n            min_dist = d\n            min_index = i\n\n    return (min_index, min_dist)\n\n\ndef kpp(points, cluster_centers):\n    cluster_centers[0] = copy(choice(points))\n    d = [0.0 for _ in xrange(len(points))]\n\n    for i in xrange(1, len(cluster_centers)):\n        sum = 0\n        for j, p in enumerate(points):\n            d[j] = nearest_cluster_center(p, cluster_centers[:i])[1]\n            sum += d[j]\n\n        sum *= random()\n\n        for j, di in enumerate(d):\n            sum -= di\n            if sum > 0:\n                continue\n            cluster_centers[i] = copy(points[j])\n            break\n\n    for p in points:\n        p.group = nearest_cluster_center(p, cluster_centers)[0]\n\n\ndef lloyd(points, nclusters):\n    cluster_centers = [Point() for _ in xrange(nclusters)]\n\n    \n    kpp(points, cluster_centers)\n\n    lenpts10 = len(points) >> 10\n\n    changed = 0\n    while True:\n        \n        for cc in cluster_centers:\n            cc.x = 0\n            cc.y = 0\n            cc.group = 0\n\n        for p in points:\n            cluster_centers[p.group].group += 1\n            cluster_centers[p.group].x += p.x\n            cluster_centers[p.group].y += p.y\n\n        for cc in cluster_centers:\n            cc.x /= cc.group\n            cc.y /= cc.group\n\n        \n        changed = 0\n        for p in points:\n            min_i = nearest_cluster_center(p, cluster_centers)[0]\n            if min_i != p.group:\n                changed += 1\n                p.group = min_i\n\n        \n        if changed <= lenpts10:\n            break\n\n    for i, cc in enumerate(cluster_centers):\n        cc.group = i\n\n    return cluster_centers\n\n\ndef print_eps(points, cluster_centers, W=400, H=400):\n    Color = namedtuple(\"Color\", \"r g b\");\n\n    colors = []\n    for i in xrange(len(cluster_centers)):\n        colors.append(Color((3 * (i + 1) % 11) / 11.0,\n                            (7 * i % 11) / 11.0,\n                            (9 * i % 11) / 11.0))\n\n    max_x = max_y = -FLOAT_MAX\n    min_x = min_y = FLOAT_MAX\n\n    for p in points:\n        if max_x < p.x: max_x = p.x\n        if min_x > p.x: min_x = p.x\n        if max_y < p.y: max_y = p.y\n        if min_y > p.y: min_y = p.y\n\n    scale = min(W / (max_x - min_x),\n                H / (max_y - min_y))\n    cx = (max_x + min_x) / 2\n    cy = (max_y + min_y) / 2\n\n    print \"%%!PS-Adobe-3.0\\n%%%%BoundingBox: -5 -5 %d %d\" % (W + 10, H + 10)\n\n    print (\"/l {rlineto} def /m {rmoveto} def\\n\" +\n           \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\" +\n           \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \" +\n           \"   gsave 1 setgray fill grestore gsave 3 setlinewidth\" +\n           \" 1 setgray stroke grestore 0 setgray stroke }def\")\n\n    for i, cc in enumerate(cluster_centers):\n        print (\"%g %g %g setrgbcolor\" %\n               (colors[i].r, colors[i].g, colors[i].b))\n\n        for p in points:\n            if p.group != i:\n                continue\n            print (\"%.3f %.3f c\" % ((p.x - cx) * scale + W / 2,\n                                    (p.y - cy) * scale + H / 2))\n\n        print (\"\\n0 setgray %g %g s\" % ((cc.x - cx) * scale + W / 2,\n                                        (cc.y - cy) * scale + H / 2))\n\n    print \"\\n%%%%EOF\"\n\n\ndef main():\n    npoints = 30000\n    k = 7 \n\n    points = generate_points(npoints, 10)\n    cluster_centers = lloyd(points, k)\n    print_eps(points, cluster_centers)\n\n\nmain()\n"}
{"id": 418878, "name": "Decimal floating point number to binary", "source": "Translate Haskell to Python: import Data.Char (intToDigit)\nimport Numeric (floatToDigits, showIntAtBase)\n\ndec2bin :: RealFloat a => a -> String\ndec2bin f = \"0.\" ++ map intToDigit digits ++ \"p+\" ++ showIntAtBase 2 intToDigit ex \"\"\n  where (digits, ex) = floatToDigits 2 f\n\nmain :: IO ()\nmain = putStrLn $ dec2bin 23.34375\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 418879, "name": "Decimal floating point number to binary", "source": "Translate Haskell to Python: import Data.Char (intToDigit)\nimport Numeric (floatToDigits, showIntAtBase)\n\ndec2bin :: RealFloat a => a -> String\ndec2bin f = \"0.\" ++ map intToDigit digits ++ \"p+\" ++ showIntAtBase 2 intToDigit ex \"\"\n  where (digits, ex) = floatToDigits 2 f\n\nmain :: IO ()\nmain = putStrLn $ dec2bin 23.34375\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 418880, "name": "Free polyominoes enumeration", "source": "Translate Haskell to Python: import System.Environment (getArgs)\nimport Control.Arrow ((***), first)\nimport Data.Set (toList, fromList)\nimport Data.List (sort)\nimport Data.Bool (bool)\n\ntype Coord = Int\n\ntype Point = (Coord, Coord)\n\ntype Polyomino = [Point]\n\n\nminima :: Polyomino -> Point\nminima (p:ps) = foldr (\\(x, y) (mx, my) -> (min x mx, min y my)) p ps\n\ntranslateToOrigin :: Polyomino -> Polyomino\ntranslateToOrigin p =\n  let (minx, miny) = minima p\n  in (subtract minx *** subtract miny) <$> p\n\nrotate90, rotate180, rotate270, reflect :: Point -> Point\nrotate90 = uncurry (flip (,) . negate)\n\nrotate180 = negate *** negate\n\nrotate270 = uncurry (flip ((,) . negate))\n\nreflect = first negate\n\n\nrotationsAndReflections :: Polyomino -> [Polyomino]\nrotationsAndReflections =\n  (<*>)\n    (fmap <$>\n     [ id\n     , rotate90\n     , rotate180\n     , rotate270\n     , reflect\n     , rotate90 . reflect\n     , rotate180 . reflect\n     , rotate270 . reflect\n     ]) .\n  return\n\ncanonical :: Polyomino -> Polyomino\ncanonical = minimum . map (sort . translateToOrigin) . rotationsAndReflections\n\nunique\n  :: (Ord a)\n  => [a] -> [a]\nunique = toList . fromList\n\n\ncontiguous :: Point -> [Point]\ncontiguous (x, y) = [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\n\nnewPoints :: Polyomino -> [Point]\nnewPoints p =\n  let notInP = filter (not . flip elem p)\n  in unique . notInP . concatMap contiguous $ p\n\nnewPolys :: Polyomino -> [Polyomino]\nnewPolys p = unique . map (canonical . flip (:) p) $ newPoints p\n\nmonomino = [(0, 0)]\n\nmonominoes = [monomino]\n\n\nrank :: Int -> [Polyomino]\nrank 0 = []\nrank 1 = monominoes\nrank n = unique . concatMap newPolys $ rank (n - 1)\n\n\ntextRepresentation :: Polyomino -> String\ntextRepresentation p =\n  unlines\n    [ [ bool ' ' '#' ((x, y) `elem` p)\n      | x <- [0 .. maxx - minx] ]\n    | y <- [0 .. maxy - miny] ]\n  where\n    maxima :: Polyomino -> Point\n    maxima (p:ps) = foldr (\\(x, y) (mx, my) -> (max x mx, max y my)) p ps\n    (minx, miny) = minima p\n    (maxx, maxy) = maxima p\n\nmain :: IO ()\nmain = do\n  print $ map (length . rank) [1 .. 10]\n  args <- getArgs\n  let n = bool (read $ head args :: Int) 5 (null args)\n  putStrLn (\"\\nAll free polyominoes of rank \" ++ show n ++ \":\")\n  mapM_ (putStrLn . textRepresentation) (rank n)\n", "target": "from itertools import imap, imap, groupby, chain, imap\nfrom operator import itemgetter\nfrom sys import argv\nfrom array import array\n\ndef concat_map(func, it):\n    return list(chain.from_iterable(imap(func, it)))\n\ndef minima(poly):\n    \n    return (min(pt[0] for pt in poly), min(pt[1] for pt in poly))\n\ndef translate_to_origin(poly):\n    (minx, miny) = minima(poly)\n    return [(x - minx, y - miny) for (x, y) in poly]\n\nrotate90   = lambda (x, y): ( y, -x)\nrotate180  = lambda (x, y): (-x, -y)\nrotate270  = lambda (x, y): (-y,  x)\nreflect    = lambda (x, y): (-x,  y)\n\ndef rotations_and_reflections(poly):\n    \n    return (poly,\n            map(rotate90, poly),\n            map(rotate180, poly),\n            map(rotate270, poly),\n            map(reflect, poly),\n            [reflect(rotate90(pt)) for pt in poly],\n            [reflect(rotate180(pt)) for pt in poly],\n            [reflect(rotate270(pt)) for pt in poly])\n\ndef canonical(poly):\n    return min(sorted(translate_to_origin(pl)) for pl in rotations_and_reflections(poly))\n\ndef unique(lst):\n    lst.sort()\n    return map(next, imap(itemgetter(1), groupby(lst)))\n\n\ncontiguous = lambda (x, y): [(x - 1, y), (x + 1, y), (x, y - 1), (x, y + 1)]\n\ndef new_points(poly):\n    \n    return unique([pt for pt in concat_map(contiguous, poly) if pt not in poly])\n\ndef new_polys(poly):\n    return unique([canonical(poly + [pt]) for pt in new_points(poly)])\n\nmonomino = [(0, 0)]\nmonominoes = [monomino]\n\ndef rank(n):\n    \n    assert n >= 0\n    if n == 0: return []\n    if n == 1: return monominoes\n    return unique(concat_map(new_polys, rank(n - 1)))\n\ndef text_representation(poly):\n    \n    min_pt = minima(poly)\n    max_pt = (max(p[0] for p in poly), max(p[1] for p in poly))\n    table = [array('c', ' ') * (max_pt[1] - min_pt[1] + 1)\n             for _ in xrange(max_pt[0] - min_pt[0] + 1)]\n    for pt in poly:\n        table[pt[0] - min_pt[0]][pt[1] - min_pt[1]] = '\n    return \"\\n\".join(row.tostring() for row in table)\n\ndef main():\n    print [len(rank(n)) for n in xrange(1, 11)]\n\n    n = int(argv[1]) if (len(argv) == 2) else 5\n    print \"\\nAll free polyominoes of rank %d:\" % n\n\n    for poly in rank(n):\n        print text_representation(poly), \"\\n\"\n\nmain()\n"}
{"id": 418881, "name": "Natural sorting", "source": "Translate Haskell to Python: import Data.List\nimport Data.Char\nimport Data.String.Utils\nimport Data.List.Utils\nimport Data.Function (on)\n\n\nprintOutput = do\n                putStrLn \"# Ignoring leading spaces \\n\"\n                printBlockOfMessages sample1Rule ignoringStartEndSpaces\n                putStrLn \"\\n # Ignoring multiple adjacent spaces (m.a.s) \\n\"\n                printBlockOfMessages sample2Rule ignoringMultipleAdjacentSpaces\n                putStrLn \"\\n # Equivalent whitespace characters \\n\"\n                printBlockOfMessages sample3Rule ignoringMultipleAdjacentSpaces\n                putStrLn \"\\n # Case Indepenent sorts \\n\"\n                printBlockOfMessages sample4Rule caseIndependent\n                putStrLn \"\\n # Numeric fields as numerics \\n\"\n                printBlockOfMessages sample5Rule numericFieldsAsNumbers\n                putStrLn \"\\n # Title sorts \\n\"\n                printBlockOfMessages sample6Rule removeLeadCommonWords\n\nprintMessage message content = do\n                 putStrLn message\n                 mapM_ print content\n\nprintBlockOfMessages list function = do\n      printMessage \"Text strings:\" list\n      printMessage \"Normally sorted:\" (sort list)\n      printMessage \"Naturally sorted:\" (sortListWith list function)\n\n\n\nsample1Rule = [\"ignore leading spaces: 2-2\", \" ignore leading spaces: 2-1\", \"  ignore leading spaces: 2+0\",  \"   ignore leading spaces: 2+1\"]\nsample2Rule = [\"ignore m.a.s spaces: 2-2\", \"ignore m.a.s  spaces: 2-1\", \"ignore m.a.s   spaces: 2+0\", \"ignore m.a.s    spaces: 2+1\"]\nsample3Rule = [\"Equiv. spaces: 3-3\", \"Equiv.\\rspaces: 3-2\", \"Equiv.\\x0cspaces: 3-1\", \"Equiv.\\x0bspaces: 3+0\", \"Equiv.\\nspaces: 3+1\", \"Equiv.\\tspaces: 3+2\"]\nsample4Rule = [\"cASE INDEPENENT: 3-2\", \"caSE INDEPENENT: 3-1\", \"casE INDEPENENT: 3+0\", \"case INDEPENENT: 3+1\"]\nsample5Rule = [\"foo100bar99baz0.txt\", \"foo100bar10baz0.txt\", \"foo1000bar99baz10.txt\", \"foo1000bar99baz9.txt\"]\nsample6Rule = [\"The Wind in the Willows\", \"The 40th step more\", \"The 39 steps\", \"Wanda\"]\n\n\n\nsortListWith l f = sort $ f l\n\n\n\n \n\n\n\nignoringStartEndSpaces :: [String] -> [String]\nignoringStartEndSpaces = map strip\n\n\n\nignoringMultipleAdjacentSpaces :: [String] -> [String]\nignoringMultipleAdjacentSpaces = map (unwords . words)\n\n\n\n\n\ncaseIndependent :: [String] -> [String]\ncaseIndependent = map (map toLower)\n\n\nnumericFieldsAsNumbers :: [String] -> [[Int]]\nnumericFieldsAsNumbers = map findOnlyNumerics\n\nfindOnlyNumerics :: String -> [Int]\nfindOnlyNumerics s = convertDigitAsStringToInt $ makeListOfDigitsAsString $ extractDigitsAsString s\nextractDigitsAsString :: String -> [String]\nextractDigitsAsString s = map (filter isNumber) $ groupBy ((==) `on` isNumber ) s\nmakeListOfDigitsAsString :: [String] -> [String]\nmakeListOfDigitsAsString l = tail $ nub l\nconvertDigitAsStringToInt :: [String] -> [Int]\nconvertDigitAsStringToInt = map (joiner . map  digitToInt)\n\n\n\njoiner :: [Int] -> Int\njoiner = read . concatMap show\n\n\nremoveLeadCommonWords l = map removeLeadCommonWord $ splitList l\n\nsplitList = map words\nremoveLeadCommonWord a = unwords $ if f a commonWords then tail a else a \n                        where f l1 = elem (map toLower (head l1))\n                              commonWords = [\"the\",\"a\",\"an\",\"of\"]\n", "target": "\n\n\n\nfrom itertools import groupby\nfrom unicodedata import decomposition, name\nfrom pprint import pprint as pp\n\ncommonleaders = ['the'] \nreplacements = {u'\u00df': 'ss',  \n                u'\u017f': 's',\n                u'\u0292': 's',\n                }\n\nhexdigits = set('0123456789abcdef')\ndecdigits = set('0123456789')   \n\ndef splitchar(c):\n    ' De-ligature. De-accent a char'\n    de = decomposition(c)\n    if de:\n        \n        de = [d for d in de.split()\n                  if all(c.lower()\n                         in hexdigits for c in d)]\n        n = name(c, c).upper()\n        \n        if len(de)> 1 and 'PRECEDE' in n:\n            \n            de[1], de[0] = de[0], de[1]\n        tmp = [ unichr(int(k, 16)) for k in de]\n        base, others = tmp[0], tmp[1:]\n        if 'LIGATURE' in n:\n            \n            base += others.pop(0)\n    else:\n        base = c\n    return base\n    \n\ndef sortkeygen(s):\n    \n    \n    s = unicode(s).strip()\n    \n    s = ' '.join(s.split())\n    \n    s = s.lower()\n    \n    words = s.split()\n    if len(words) > 1 and words[0] in commonleaders:\n        s = ' '.join( words[1:])\n    \n    s = ''.join(splitchar(c) for c in s)\n    \n    s = ''.join( replacements.get(ch, ch) for ch in s )\n    \n    s = [ int(\"\".join(g)) if isinteger else \"\".join(g)\n          for isinteger,g in groupby(s, lambda x: x in decdigits)]\n\n    return s\n\ndef naturalsort(items):\n    \n    return sorted(items, key=sortkeygen)\n\nif __name__ == '__main__':\n    import string\n    \n    ns = naturalsort\n\n    print '\\n\n    txt = ['%signore leading spaces: 2%+i' % (' '*i, i-2) for i in range(4)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['ignore m.a.s%s spaces: 2%+i' % (' '*i, i-2) for i in range(4)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['Equiv.%sspaces: 3%+i' % (ch, i-3)\n           for i,ch in enumerate(reversed(string.whitespace))]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    s = 'CASE INDEPENENT'\n    txt = [s[:i].lower() + s[i:] + ': 3%+i' % (i-3) for i in range(1,5)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['foo100bar99baz0.txt', 'foo100bar10baz0.txt',\n           'foo1000bar99baz10.txt', 'foo1000bar99baz9.txt']\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['The Wind in the Willows','The 40th step more',\n                         'The 39 steps', 'Wanda']\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = ['Equiv. %s accents: 2%+i' % (ch, i-2)\n           for i,ch in enumerate(u'\\xfd\\xddyY')]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n\n    print '\\n\n    txt = [u'\\462 ligatured ij', 'no ligature',]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; pp(sorted(txt))\n    print 'Naturally sorted:'; pp(ns(txt))\n    \n    print '\\n\n    s = u'\u0292\u017f\u00dfs' \n    txt = ['Start with an %s: 2%+i' % (ch, i-2)\n           for i,ch in enumerate(s)]\n    print 'Text strings:'; pp(txt)\n    print 'Normally sorted\u00a0:'; print '\\n'.join(sorted(txt))\n    print 'Naturally sorted:'; print '\\n'.join(ns(txt))\n"}
{"id": 418882, "name": "SHA-256 Merkle tree", "source": "Translate Haskell to Python: \n\nimport Control.Monad (mfilter)\nimport Crypto.Hash.SHA256 (hash)\nimport qualified Data.ByteString as B\nimport Data.ByteString.Builder (byteStringHex, char7, hPutBuilder)\nimport Data.Functor ((<&>))\nimport Data.Maybe (listToMaybe)\nimport Data.Strict.Tuple (Pair(..))\nimport qualified Data.Strict.Tuple as T\nimport System.Environment (getArgs)\nimport System.IO (Handle, stdin, stdout)\nimport System.IO.Streams (InputStream)\nimport qualified System.IO.Streams as S\nimport Text.Read (readMaybe)\n\ntype Node a    = Pair Int a\ntype LevelPred = Int -> Int -> Bool\ntype Combine a = a -> a -> a\n\n\n\n\n\n\nbuild :: Combine a -> [Node a] -> InputStream (Node a) -> IO (Maybe (Node a))\nbuild combine !stack is = S.read is >>= \\case\n  Nothing -> return $ listToMaybe $ reduce always combine stack\n  Just h  -> build combine (reduce (==) combine (h:stack)) is\n\n\n\n\nreduce :: LevelPred -> Combine a -> [Node a] -> [Node a]\nreduce prd combine (x@(i :!: _):y@(j :!: _):zs)\n  | prd i j = reduce prd combine (nodeLift combine y x : zs)\nreduce _ _ zs = zs\n\n\n\nnodeLift :: Combine a -> Node a -> Node a -> Node a\nnodeLift f (i :!: x) (j :!: y) = max i j + 1 :!: f x y\n\nalways :: a -> b -> Bool\nalways _ _ = True\n\n\n\nmerkleTreeSha256 :: Int -> Handle -> IO (Maybe B.ByteString)\nmerkleTreeSha256 sz h = mkHash <&> fmap T.snd\n  where mkHash = S.makeInputStream getBuf >>=\n                 S.map (\\bs -> 0 :!: hash bs) >>=\n                 build (\\x y -> hash (x `B.append` y)) []\n        getBuf = B.hGet h sz <&> (mfilter (/= B.empty) . Just)\n\n\nprintByteStringHex :: B.ByteString -> IO ()\nprintByteStringHex = hPutBuilder stdout . (<> char7 '\\n') . byteStringHex\n\nmain :: IO ()\nmain = getArgs <&> map readMaybe >>= \\case\n  [Just sz] -> merkleTreeSha256 sz stdin >>= \\case\n                 Nothing -> putStrLn \"No input to hash\"\n                 Just h  -> printByteStringHex h\n  _         -> putStrLn \"Argument usage: chunk-size\"\n", "target": "\n\n\nimport argh\nimport hashlib  \nimport sys\n  \n@argh.arg('filename', nargs='?', default=None)\ndef main(filename, block_size=1024*1024):\n    if filename:\n        fin = open(filename, 'rb')\n    else: \n        fin = sys.stdin\n    \n    stack = []\n    block = fin.read(block_size)\n    while block:\n        \n        node = (0, hashlib.sha256(block).digest())\n        stack.append(node)\n\n        \n        while len(stack) >= 2 and stack[-2][0] == stack[-1][0]:\n            a = stack[-2]\n            b = stack[-1]\n            l = a[0]\n            stack[-2:] = [(l+1, hashlib.sha256(a[1] + b[1]).digest())]\n\n        block = fin.read(block_size)\n    \n    while len(stack) > 1:\n        \n        a = stack[-2]\n        b = stack[-1]\n        al = a[0]\n        bl = b[0]\n        stack[-2:] = [(max(al, bl)+1, hashlib.sha256(a[1] + b[1]).digest())]\n\n    print(stack[0][1].hex())\n\n\nargh.dispatch_command(main)\n"}
{"id": 418883, "name": "Partition function P", "source": "Translate Haskell to Python: \n\n\n\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving (Functor)\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Memo Int\nnats =\n  Node\n    0\n    ((+ 1) . (* 2) <$> nats)\n    ((* 2) . (+ 1) <$> nats)\n\n\n\n\npartitions :: Memo Integer\npartitions = partitionP <$> nats\n\npartitionP :: Int -> Integer\npartitionP n\n  | n < 2 = 1\n  | otherwise = sum $ zipWith (*) signs terms\n  where\n    terms =\n      [ memo partitions (n - i)\n        | i <- takeWhile (<= n) ofsets\n      ]\n    signs = cycle [1, 1, -1, -1]\n\nofsets :: [Int]\nofsets = scanl1 (+) $ mix [1, 3 ..] [1, 2 ..]\n  where\n    mix a b = concat $ zipWith (\\x y -> [x, y]) a b\n\nmain :: IO ()\nmain = print $ partitionP 6666\n", "target": "from itertools import islice\n\ndef posd():\n    \"diff between position numbers. 1, 2, 3... interleaved with  3, 5, 7...\"\n    count, odd = 1, 3\n    while True:\n        yield count\n        yield odd\n        count, odd = count + 1, odd + 2\n\ndef pos_gen():\n    \"position numbers. 1 3 2 5 7 4 9 ...\"\n    val = 1\n    diff = posd()\n    while True:\n        yield val\n        val += next(diff)\n                \ndef plus_minus():\n    \"yield (list_offset, sign) or zero for Partition calc\"\n    n, sign = 0, [1, 1]\n    p_gen = pos_gen()\n    out_on = next(p_gen)\n    while True:\n        n += 1\n        if n == out_on:\n            next_sign = sign.pop(0)\n            if not sign:\n                sign = [-next_sign] * 2\n            yield -n, next_sign\n            out_on = next(p_gen)\n        else:\n            yield 0\n            \ndef part(n):\n    \"Partition numbers\"\n    p = [1]\n    p_m = plus_minus()\n    mods = []\n    for _ in range(n):\n        next_plus_minus = next(p_m)\n        if next_plus_minus:\n            mods.append(next_plus_minus)\n        p.append(sum(p[offset] * sign for offset, sign in mods))\n    return p[-1]\n        \nprint(\"(Intermediaries):\")\nprint(\"    posd:\", list(islice(posd(), 10)))\nprint(\"    pos_gen:\", list(islice(pos_gen(), 10)))\nprint(\"    plus_minus:\", list(islice(plus_minus(), 15)))\nprint(\"\\nPartitions:\", [part(x) for x in range(15)])\n"}
{"id": 418884, "name": "Polynomial synthetic division", "source": "Translate Haskell to Python: import Data.List\n\nnormalized :: (Eq a, Num a) => [a] -> [a]\nnormalized = dropWhile (== 0)\n\nisZero :: (Eq a, Num a) => [a] -> Bool\nisZero = null . normalized\n\nshortDiv :: (Eq a, Fractional a) => [a] -> [a] -> ([a], [a])\nshortDiv p1 p2\n  | isZero p2 = error \"zero divisor\"\n  | otherwise =\n      let go 0 p = p \n          go i (h:t) = (h/a) : go (i-1) (zipWith (+) (map ((h/a) *) ker) t)\n      in splitAt k $ go k p1\n  where\n    k = length p1 - length as\n    a:as = normalized p2\n    ker = negate <$> (as ++ repeat 0)\n", "target": "from __future__ import print_function\nfrom __future__ import division\n\n\n\n\ndef extended_synthetic_division(dividend, divisor):\n    \n    \n\n    out = list(dividend) \n    normalizer = divisor[0]\n    for i in xrange(len(dividend)-(len(divisor)-1)):\n        out[i] /= normalizer \n                                 \n        coef = out[i]\n        if coef != 0: \n            for j in xrange(1, len(divisor)): \n                                              \n                out[i + j] += -divisor[j] * coef\n\n    \n    \n    \n    separator = -(len(divisor)-1)\n    return out[:separator], out[separator:] \n\nif __name__ == '__main__':\n    print(\"POLYNOMIAL SYNTHETIC DIVISION\")\n    N = [1, -12, 0, -42]\n    D = [1, -3]\n    print(\"  %s / %s  =\" % (N,D), \" %s remainder %s\" % extended_synthetic_division(N, D))\n"}
{"id": 418885, "name": "Polynomial synthetic division", "source": "Translate Haskell to Python: import Data.List\n\nnormalized :: (Eq a, Num a) => [a] -> [a]\nnormalized = dropWhile (== 0)\n\nisZero :: (Eq a, Num a) => [a] -> Bool\nisZero = null . normalized\n\nshortDiv :: (Eq a, Fractional a) => [a] -> [a] -> ([a], [a])\nshortDiv p1 p2\n  | isZero p2 = error \"zero divisor\"\n  | otherwise =\n      let go 0 p = p \n          go i (h:t) = (h/a) : go (i-1) (zipWith (+) (map ((h/a) *) ker) t)\n      in splitAt k $ go k p1\n  where\n    k = length p1 - length as\n    a:as = normalized p2\n    ker = negate <$> (as ++ repeat 0)\n", "target": "from __future__ import print_function\nfrom __future__ import division\n\n\n\n\ndef extended_synthetic_division(dividend, divisor):\n    \n    \n\n    out = list(dividend) \n    normalizer = divisor[0]\n    for i in xrange(len(dividend)-(len(divisor)-1)):\n        out[i] /= normalizer \n                                 \n        coef = out[i]\n        if coef != 0: \n            for j in xrange(1, len(divisor)): \n                                              \n                out[i + j] += -divisor[j] * coef\n\n    \n    \n    \n    separator = -(len(divisor)-1)\n    return out[:separator], out[separator:] \n\nif __name__ == '__main__':\n    print(\"POLYNOMIAL SYNTHETIC DIVISION\")\n    N = [1, -12, 0, -42]\n    D = [1, -3]\n    print(\"  %s / %s  =\" % (N,D), \" %s remainder %s\" % extended_synthetic_division(N, D))\n"}
{"id": 418886, "name": "Find duplicate files", "source": "Translate Haskell to Python: import Crypto.Hash.MD5        (hash)\nimport Data.ByteString as BS  (readFile, ByteString())\nimport System.Environment     (getArgs, getProgName)\nimport System.Directory       (doesDirectoryExist, getDirectoryContents)\nimport System.FilePath.Posix  ((</>))\nimport Control.Monad          (forM)\nimport Text.Printf            (printf)\nimport System.IO              (withFile, IOMode(ReadMode), hFileSize)\n\n\ntype File = (BS.ByteString, \n             FilePath)      \n\ntype FileSize = Integer\n\ngetRecursiveContents :: FilePath -> FileSize -> IO [File]\ngetRecursiveContents curDir maxsize = do\n  names <- getDirectoryContents curDir\n  let dirs = filter (`notElem` [\".\", \"..\"]) names\n  files <- forM dirs $ \\path -> do\n             let path' = curDir </> path\n             exists <- doesDirectoryExist path'\n             if exists\n                then getRecursiveContents path' maxsize\n                else genFileHash path' maxsize\n  return $ concat files\n\n\ngenFileHash :: FilePath -> FileSize -> IO [File]\ngenFileHash path maxsize = do\n  size <- withFile path ReadMode hFileSize\n  if size <= maxsize\n    then BS.readFile path >>= \\bs -> return [(hash bs, path)]\n    else return []\n\nfindDuplicates :: FilePath -> FileSize -> IO ()\nfindDuplicates dir bytes = do\n  exists <- doesDirectoryExist dir\n  if exists\n    then getRecursiveContents dir bytes >>= findSameHashes\n    else printf \"Sorry, the directory \\\"%s\\\" does not exist...\\n\" dir\n\nfindSameHashes :: [File] -> IO ()\nfindSameHashes []     = return ()\nfindSameHashes ((hash, fp):xs) = do\n  case lookup hash xs of\n    (Just dupFile) -> printf \"===========================\\n\\\n                            \\Found duplicate:\\n\\\n                            \\=> %s \\n\\\n                            \\=> %s \\n\\n\" fp dupFile\n                      >> findSameHashes xs\n    (_)            -> findSameHashes xs\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  case args of\n    [dir, mbytes] | [(bytes ,\"\")] <- reads mbytes\n                   , bytes >= 1 -> findDuplicates dir bytes\n    (_) -> do\n      name <- getProgName\n      printf \"Something went wrong - please use ./%s <dir> <bytes>\\n\" name\n", "target": "from __future__ import print_function\nimport os\nimport hashlib\nimport datetime\n\ndef FindDuplicateFiles(pth, minSize = 0, hashName = \"md5\"):\n    knownFiles = {}\n\n    \n    for root, dirs, files in os.walk(pth):\n        for fina in files:\n            fullFina = os.path.join(root, fina)\n            isSymLink = os.path.islink(fullFina)\n            if isSymLink:\n                continue \n            si = os.path.getsize(fullFina)\n            if si < minSize:\n                continue\n            if si not in knownFiles:\n                knownFiles[si] = {}\n            h = hashlib.new(hashName)\n            h.update(open(fullFina, \"rb\").read())\n            hashed = h.digest()\n            if hashed in knownFiles[si]:\n                fileRec = knownFiles[si][hashed]\n                fileRec.append(fullFina)\n            else:\n                knownFiles[si][hashed] = [fullFina]\n\n    \n    sizeList = list(knownFiles.keys())\n    sizeList.sort(reverse=True)\n    for si in sizeList:\n        filesAtThisSize = knownFiles[si]\n        for hashVal in filesAtThisSize:\n            if len(filesAtThisSize[hashVal]) < 2:\n                continue\n            fullFinaLi = filesAtThisSize[hashVal]\n            print (\"=======Duplicate=======\")\n            for fullFina in fullFinaLi:\n                st = os.stat(fullFina)\n                isHardLink = st.st_nlink > 1 \n                infoStr = []\n                if isHardLink:\n                    infoStr.append(\"(Hard linked)\")\n                fmtModTime = datetime.datetime.utcfromtimestamp(st.st_mtime).strftime('%Y-%m-%dT%H:%M:%SZ')\n                print (fmtModTime, si, os.path.relpath(fullFina, pth), \" \".join(infoStr))\n\nif __name__==\"__main__\":\n\n    FindDuplicateFiles('/home/tim/Dropbox', 1024*1024)\n"}
{"id": 418887, "name": "Legendre prime counting function", "source": "Translate Haskell to Python: \n\n\nimport Data.Time.Clock.POSIX ( getPOSIXTime ) \n\nimport Data.Int ( Int64 )\nimport Data.Bits ( Bits( shiftL, shiftR ) )\n\ndata Memo a = EmptyNode | Node a (Memo a) (Memo a)\n  deriving Functor\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Integral a => Memo a\nnats = Node 0 ((+1).(*2) <$> nats) ((*2).(+1) <$> nats)\n\nmemoize :: Integral a => (a -> b) -> a -> b\nmemoize f = memo (f <$> nats)\n\nmemoize2 :: (Integral a, Integral b) => (a -> b -> c) -> a -> b -> c\nmemoize2 f = memoize (memoize . f)\n\nmemoList :: [b] -> Integer -> b\nmemoList = memo . mkList\n  where\n    mkList []     = EmptyNode \n    mkList (x:xs) = Node x (mkList l) (mkList r)\n      where (l,r) = split xs\n            split [] = ([],[])\n            split [x] = ([x],[])\n            split (x:y:xs) = let (l,r) = split xs in (x:l, y:r)\n\nisqrt :: Integer -> Integer\nisqrt n = go n 0 (q `shiftR` 2)\n where\n   q = head $ dropWhile (< n) $ iterate (`shiftL` 2) 1\n   go z r 0 = r\n   go z r q = let t = z - r - q\n              in if t >= 0\n                 then go t (r `shiftR` 1 + q) (q `shiftR` 2)\n                 else go z (r `shiftR` 1) (q `shiftR` 2)\n\nprimes :: [Integer]\nprimes = 2 : _Y ((3:) . gaps 5 . _U . map(\\p-> [p*p, p*p+2*p..])) where\n  _Y g = g (_Y g)  \n  gaps k s@(c:cs) | k < c     = k : gaps (k+2) s  \n                  | otherwise =     gaps (k+2) cs \n  _U ((x:xs):t) = x : (merge xs . _U . pairs) t   \n  pairs (xs:ys:t) = merge xs ys : pairs t\n  merge xs@(x:xt) ys@(y:yt) | x < y     = x : merge xt ys\n                            | y < x     = y : merge xs yt\n                            | otherwise = x : merge xt yt\n\nphi :: Integer -> Integer -> Integer\nphi = memoize2 phiM\n  where\n    phiM x 0 = x\n    phiM x a = phi x (a-1) - phi (x `div` p a) (a - 1)\n\n    p = memoList (undefined : primes)\n\nlegendrePi :: Integer -> Integer\nlegendrePi n\n  | n < 2 = 0\n  | otherwise = phi n a + a - 1\n    where a = legendrePi (floor (sqrt (fromInteger n)))\n\nmain :: IO ()\nmain = do\n  strt <- getPOSIXTime\n  mapM_ (\\n -> putStrLn $ show n ++ \"\\t\" ++ show (legendrePi (10^n))) [0..9]\n  stop <- getPOSIXTime\n  let elpsd = round $ 1e3 * (stop - strt) :: Int64\n  putStrLn $ \"This last took \" ++ show elpsd ++ \" milliseconds.\"\n", "target": "from primesieve import primes\nfrom math import isqrt\nfrom functools import cache\n\np = primes(isqrt(1_000_000_000))\n\n@cache\ndef phi(x, a):\n    res = 0\n    while True:\n        if not a or not x:\n            return x + res\n    \n        a -= 1\n        res -= phi(x//p[a], a) \n\ndef legpi(n):\n    if n < 2: return 0\n\n    a = legpi(isqrt(n))\n    return phi(n, a) + a - 1\n\nfor e in range(10):\n    print(f'10^{e}', legpi(10**e))\n"}
{"id": 418888, "name": "Rosetta Code_Find bare lang tags", "source": "Translate Haskell to Python: import System.Environment\nimport Network.HTTP\nimport Text.Printf\nimport Text.Regex.TDFA\nimport Data.List\nimport Data.Array\nimport qualified Data.Map as Map\n\n\nsplitByMatches :: String -> [MatchText String] -> [String]\nsplitByMatches str matches  =  foldr splitHead [str] matches\n    where splitHead match acc  =  before:after:(tail acc)\n            where before  =  take (matchOffset).head$ acc\n                  after  =  drop (matchOffset + matchLen).head$ acc\n                  matchOffset  =  fst.snd.(!0)$ match\n                  matchLen  =  snd.snd.(!0)$ match\n\n\ncountBareLangTags :: String -> Int\ncountBareLangTags  =  matchCount (makeRegex \"<lang[[:space:]]*>\" :: Regex)\n\n\ncountByLanguage :: String -> Map.Map String Int\ncountByLanguage str  =  Map.fromList.filter ((>0).snd)$ zip langs counts\n    where counts  =  map countBareLangTags.splitByMatches str$ allMatches\n          langs  =  \"\":(map (fst.(!1)) allMatches)\n          allMatches  =  matchAllText (makeRegex headerRegex :: Regex) str\n          headerRegex  =  \"==[[:space:]]*{{[[:space:]]*header[[:space:]]*\\\\|[[:space:]]*([^ }]*)[[:space:]]*}}[^=]*==\"\n\nmain = do\n    args <- getArgs\n    (contents, files) <- if length args == 0 then do\n        \n            content  <-  getContents\n            return ([content],[\"\"])\n        else if length args == 1 then do\n        \n        \n            content  <-  readFile (head args)\n            return ([content],[\"\"])\n        else if (args !! 0) == \"-w\" then do\n        \n        \n            contents  <-  mapM getPageContent.tail$ args\n            return (contents, if length args > 2 then tail args else [\"\"])\n        else do\n        \n            contents  <-  mapM readFile args\n            return (contents, args)\n    let tagsPerLang  =  map countByLanguage contents\n    let tagsWithFiles  =  zipWith addFileToTags files tagsPerLang\n    let combinedFiles  =  Map.unionsWith combine tagsWithFiles\n    printBareTags combinedFiles\n        where addFileToTags file  =  Map.map (flip (,) [file])\n              combine cur next  =  (fst cur + fst next, snd cur ++ snd next)\n        \nprintBareTags :: Map.Map String (Int,[String]) -> IO ()\nprintBareTags tags  =  do\n    let numBare  =  Map.foldr ((+).fst) 0 tags\n    printf \"%d bare language tags:\\n\\n\" numBare\n    mapM_ (\\(lang,(count,files)) ->\n        printf \"%d in %s%s\\n\" count\n                              (if lang == \"\" then \"no language\" else lang)\n                              (filesString files)\n        ) (Map.toAscList tags)\n\nfilesString :: [String] -> String\nfilesString []  =  \"\"\nfilesString (\"\":rest)  =  filesString rest\nfilesString files  =  \" (\"++listString files++\")\"\n    where listString [file]  =  \"[[\"++file++\"]]\"\n          listString (file:files)  =  \"[[\"++file++\"]], \"++listString files\n\ngetPageContent :: String -> IO String\ngetPageContent title  =  do\n    response  <-  simpleHTTP.getRequest$ url\n    getResponseBody response\n        where url  =  \"http://rosettacode.org/mw/index.php?action=raw&title=\"++title\n", "target": "\n\nfrom __future__ import annotations\n\nimport functools\nimport gzip\nimport json\nimport logging\nimport platform\nimport re\n\nfrom collections import Counter\nfrom collections import defaultdict\n\nfrom typing import Any\nfrom typing import Iterator\nfrom typing import Iterable\nfrom typing import List\nfrom typing import Mapping\nfrom typing import NamedTuple\nfrom typing import Optional\nfrom typing import Tuple\n\nfrom urllib.parse import urlencode\nfrom urllib.parse import urlunparse\nfrom urllib.parse import quote_plus\n\nimport urllib.error\nimport urllib.request\n\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.DEBUG)\n\n\n\n\n\n\n\nRE_SPEC = [\n    (\"NOWIKI\", r\"<\\s*nowiki\\s*>.*?</\\s*nowiki\\s*>\"),\n    (\"PRE\", r\"<\\s*pre\\s*>.*?</\\s*pre\\s*>\"),\n    (\"LANG\", r\"<\\s*lang\\s+.+?>.*?</\\s*lang\\s*>\"),\n    (\"HEAD\", r\"==\\{\\{\\s*header\\s*\\|\\s*(?P<header>.+?)\\s*}}==\"),\n    (\"BARE\", r\"<\\s*lang\\s*>.*?</\\s*lang\\s*>\"),\n]\n\nRE_BARE_LANG = re.compile(\n    \"|\".join(rf\"(?P<{name}>{pattern})\" for name, pattern in RE_SPEC),\n    re.DOTALL | re.IGNORECASE,\n)\n\n\n\nRE_MULTI_HEADER = re.compile(r\"(}|(\\{\\{\\s*header\\s*\\|\\s*))\", re.IGNORECASE)\n\n\ndef find_bare_lang_section_headers(wiki_text: str) -> Iterator[str]:\n    \n    current_heading = \"no language\"\n\n    for match in RE_BARE_LANG.finditer(wiki_text):\n        kind = match.lastgroup\n\n        if kind == \"HEAD\":\n            current_heading = RE_MULTI_HEADER.sub(\"\", match.group(\"header\"))\n        elif kind == \"BARE\":\n            yield current_heading\n\n\nclass Error(Exception):\n    \n\n\nclass TagCounter:\n    \n\n    def __init__(self):\n        self.counter = Counter()\n        self.pages = defaultdict(set)\n        self.total = 0\n\n    def __len__(self):\n        return len(self.counter)\n\n    @classmethod\n    def from_section_headers(\n        cls, page_title: str, section_headers: Iterable[str]\n    ) -> TagCounter:\n        \n        counter = cls()\n\n        for heading in section_headers:\n            counter.add(page_title, heading)\n\n        return counter\n\n    @classmethod\n    def from_wiki_text(cls, page_title: str, wiki_text: str) -> TagCounter:\n        \n        return cls.from_section_headers(\n            page_title,\n            find_bare_lang_section_headers(wiki_text),\n        )\n\n    def add(self, page_title: str, section_heading: str):\n        \n        self.counter[section_heading] += 1\n        self.pages[section_heading].add(page_title)\n        self.total += 1\n\n    def update(self, other):\n        \n        assert isinstance(other, TagCounter)\n\n        self.counter.update(other.counter)\n\n        for section_heading, pages in other.pages.items():\n            self.pages[section_heading].update(pages)\n\n        self.total += other.total\n\n    def most_common(self, n=None) -> str:\n        \n        buf = [f\"{sum(self.counter.values())} bare lang tags.\\n\"]\n\n        for section_heading, count in self.counter.most_common(n=n):\n            pages = list(self.pages[section_heading])\n            buf.append(f\"{count} in {section_heading} {pages}\")\n\n        return \"\\n\".join(buf)\n\n\ndef quote_underscore(string, safe=\"\", encoding=None, errors=None):\n    \n    string = quote_plus(string, safe, encoding, errors)\n    return string.replace(\"+\", \"_\")\n\n\nclass URL(NamedTuple):\n    \n\n    scheme: str\n    netloc: str\n    path: str\n    params: str\n    query: str\n    fragment: str\n\n    def __str__(self):\n        return urlunparse(self)\n\n    def with_query(self, query: Mapping[str, Any]) -> URL:\n        query_string = urlencode(query, safe=\":\", quote_via=quote_underscore)\n        return self._replace(query=query_string)\n\n\nAPI_BASE_URL = URL(\n    scheme=\"http\",\n    netloc=\"rosettacode.org\",\n    path=\"/mw/api.php\",\n    params=\"\",\n    query=\"\",\n    fragment=\"\",\n)\n\nUGLY_RAW_URL = URL(\n    scheme=\"http\",\n    netloc=\"rosettacode.org\",\n    path=\"/mw/index.php\",\n    params=\"\",\n    query=\"\",\n    fragment=\"\",\n)\n\n\nDEFAULT_HEADERS = {\n    \"User-agent\": f\"python/{platform.python_version()}\",\n    \"Accept-encoding\": \"gzip, deflate\",\n    \"Accept\": \"*/*\",\n    \"Connection\": \"keep-alive\",\n}\n\n\nclass Response(NamedTuple):\n    headers: Mapping[str, str]\n    body: bytes\n\n\ndef get(url: URL, headers=DEFAULT_HEADERS) -> Response:\n    \n    logger.debug(f\"GET {url}\")\n    request = urllib.request.Request(str(url), headers=headers)\n\n    try:\n        with urllib.request.urlopen(request) as response:\n            return Response(\n                headers=dict(response.getheaders()),\n                body=response.read(),\n            )\n    except urllib.error.HTTPError as e:\n        logging.debug(e.code)\n        logging.debug(gzip.decompress(e.read()))\n        raise\n\n\ndef raise_for_header(headers: Mapping[str, str], header: str, expect: str):\n    got = headers.get(header)\n    if got != expect:\n        raise Error(f\"expected '{expect}', got '{got}'\")\n\n\nraise_for_content_type = functools.partial(raise_for_header, header=\"Content-Type\")\n\n\nclass CMContinue(NamedTuple):\n    continue_: str\n    cmcontinue: str\n\n\nPages = Tuple[List[str], Optional[CMContinue]]\n\n\ndef get_wiki_page_titles(chunk_size: int = 500, continue_: CMContinue = None) -> Pages:\n    \n    query = {\n        \"action\": \"query\",\n        \"list\": \"categorymembers\",\n        \"cmtitle\": \"Category:Programming_Tasks\",\n        \"cmlimit\": chunk_size,\n        \"format\": \"json\",\n        \"continue\": \"\",\n    }\n\n    if continue_:\n        query[\"continue\"] = continue_.continue_\n        query[\"cmcontinue\"] = continue_.cmcontinue\n\n    response = get(API_BASE_URL.with_query(query))\n\n    \n    raise_for_content_type(response.headers, expect=\"application/json; charset=utf-8\")\n    raise_for_header(response.headers, \"Content-Encoding\", \"gzip\")\n\n    data = json.loads(gzip.decompress(response.body))\n    page_titles = [p[\"title\"] for p in data[\"query\"][\"categorymembers\"]]\n\n    if data.get(\"continue\", {}).get(\"cmcontinue\"):\n        _continue = CMContinue(\n            data[\"continue\"][\"continue\"],\n            data[\"continue\"][\"cmcontinue\"],\n        )\n    else:\n        _continue = None\n\n    return (page_titles, _continue)\n\n\ndef get_wiki_page_markup(page_title: str) -> str:\n    \n    query = {\"action\": \"raw\", \"title\": page_title}\n    response = get(UGLY_RAW_URL.with_query(query))\n\n    \n    raise_for_content_type(response.headers, expect=\"text/x-wiki; charset=UTF-8\")\n\n    return response.body.decode()\n\n\ndef example(limit=30):\n    \n    page_titles, continue_ = get_wiki_page_titles()\n\n    \n    while continue_ is not None:\n        more_page_titles, continue_ = get_wiki_page_titles(continue_=continue_)\n        page_titles.extend(more_page_titles)\n\n    \n    counter = TagCounter()\n\n    for i, page_title in enumerate(page_titles):\n        if i > limit:\n            break\n\n        \n        wiki_text = get_wiki_page_markup(page_title)\n        counts = TagCounter.from_wiki_text(page_title, wiki_text)\n        counter.update(counts)\n\n    \n    print(counter.most_common())\n\n\nif __name__ == \"__main__\":\n    logging.basicConfig(format=\"%(asctime)s %(message)s\", level=logging.DEBUG)\n    example()\n"}
{"id": 418889, "name": "Palindromic gapful numbers", "source": "Translate Haskell to Python: import Control.Monad (guard)\n\npalindromic :: Int -> Bool\npalindromic n = d == reverse d\n where\n  d = show n\n\ngapful :: Int -> Bool\ngapful n = n `rem` firstLastDigit == 0\n where\n  firstLastDigit = read [head asDigits, last asDigits]\n  asDigits = show n\n\nresult :: Int -> [Int]\nresult d = do \n  x <- [(d+100),(d+110)..]\n  guard $ palindromic x && gapful x\n  pure x\n \nshowSets :: (Int -> String) -> IO ()\nshowSets r = go 1 \n where\n  go n = if n <= 9 then do\n    putStrLn (show n ++ \": \" ++ r n)\n    go (succ n)\n    else pure ()\n\nmain :: IO ()\nmain = do \n  putStrLn \"\\nFirst 20 palindromic gapful numbers ending in:\"\n  showSets (show . take 20 . result)\n  putStrLn \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n  showSets (show . drop 85 . take 100 . result)\n  putStrLn \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n  showSets (show . drop 990 . take 1000 . result)\n  putStrLn \"\\ndone.\"\n", "target": "from itertools import count\nfrom pprint import pformat\nimport re\nimport heapq\n\n\ndef pal_part_gen(odd=True):\n    for i in count(1):\n        fwd = str(i)\n        rev = fwd[::-1][1:] if odd else fwd[::-1]\n        yield int(fwd + rev)\n\ndef pal_ordered_gen():\n    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))\n\ndef is_gapful(x):\n    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)\n\nif __name__ == '__main__':\n    start = 100\n    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:\n        print(f\"\\nLast {last} of the first {mx} binned-by-last digit \" \n              f\"gapful numbers >= {start}\")\n        bin = {i: [] for i in range(1, 10)}\n        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))\n        while any(len(val) < mx for val in bin.values()):\n            g = next(gen)\n            val = bin[g % 10]\n            if len(val) < mx:\n                val.append(g)\n        b = {k:v[-last:] for k, v in bin.items()}\n        txt = pformat(b, width=220)\n        print('', re.sub(r\"[{},\\[\\]]\", '', txt))\n"}
{"id": 418890, "name": "Palindromic gapful numbers", "source": "Translate Haskell to Python: import Control.Monad (guard)\n\npalindromic :: Int -> Bool\npalindromic n = d == reverse d\n where\n  d = show n\n\ngapful :: Int -> Bool\ngapful n = n `rem` firstLastDigit == 0\n where\n  firstLastDigit = read [head asDigits, last asDigits]\n  asDigits = show n\n\nresult :: Int -> [Int]\nresult d = do \n  x <- [(d+100),(d+110)..]\n  guard $ palindromic x && gapful x\n  pure x\n \nshowSets :: (Int -> String) -> IO ()\nshowSets r = go 1 \n where\n  go n = if n <= 9 then do\n    putStrLn (show n ++ \": \" ++ r n)\n    go (succ n)\n    else pure ()\n\nmain :: IO ()\nmain = do \n  putStrLn \"\\nFirst 20 palindromic gapful numbers ending in:\"\n  showSets (show . take 20 . result)\n  putStrLn \"\\nLast 15 of first 100 palindromic gapful numbers ending in:\"\n  showSets (show . drop 85 . take 100 . result)\n  putStrLn \"\\nLast 10 of first 1000 palindromic gapful numbers ending in:\"\n  showSets (show . drop 990 . take 1000 . result)\n  putStrLn \"\\ndone.\"\n", "target": "from itertools import count\nfrom pprint import pformat\nimport re\nimport heapq\n\n\ndef pal_part_gen(odd=True):\n    for i in count(1):\n        fwd = str(i)\n        rev = fwd[::-1][1:] if odd else fwd[::-1]\n        yield int(fwd + rev)\n\ndef pal_ordered_gen():\n    yield from heapq.merge(pal_part_gen(odd=True), pal_part_gen(odd=False))\n\ndef is_gapful(x):\n    return (x % (int(str(x)[0]) * 10 + (x % 10)) == 0)\n\nif __name__ == '__main__':\n    start = 100\n    for mx, last in [(20, 20), (100, 15), (1_000, 10)]:\n        print(f\"\\nLast {last} of the first {mx} binned-by-last digit \" \n              f\"gapful numbers >= {start}\")\n        bin = {i: [] for i in range(1, 10)}\n        gen = (i for i in pal_ordered_gen() if i >= start and is_gapful(i))\n        while any(len(val) < mx for val in bin.values()):\n            g = next(gen)\n            val = bin[g % 10]\n            if len(val) < mx:\n                val.append(g)\n        b = {k:v[-last:] for k, v in bin.items()}\n        txt = pformat(b, width=220)\n        print('', re.sub(r\"[{},\\[\\]]\", '', txt))\n"}
{"id": 418891, "name": "The sieve of Sundaram", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport qualified Data.Set as S\nimport Text.Printf (printf)\n\n\n\nsundaram :: Integral a => a -> [a]\nsundaram n =\n  [ succ (2 * x)\n    | x <- [1 .. m],\n      x `S.notMember` excluded\n  ]\n  where\n    m = div (pred n) 2\n    excluded =\n      S.fromList\n        [ 2 * i * j + i + j\n          | let fm = fromIntegral m,\n            i <- [1 .. floor (sqrt (fm / 2))],\n            let fi = fromIntegral i,\n            j <- [i .. floor ((fm - fi) / succ (2 * fi))]\n        ]\n\nnSundaramPrimes ::\n  (Integral a1, RealFrac a2, Floating a2) => a2 -> [a1]\nnSundaramPrimes n =\n  sundaram $ floor $ (2.4 * n * log n) / 2\n\n\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"First 100 Sundaram primes (starting at 3):\\n\"\n  (putStrLn . table \" \" . chunksOf 10) $\n    show <$> nSundaramPrimes 100\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "from numpy import log\n\ndef sieve_of_Sundaram(nth, print_all=True):\n    \n    assert nth > 0, \"nth must be a positive integer\"\n    k = int((2.4 * nth * log(nth)) // 2)  \n    integers_list = [True] * k\n    for i in range(1, k):\n        j = i\n        while i + j + 2 * i * j < k:\n            integers_list[i + j + 2 * i * j] = False\n            j += 1\n    pcount = 0\n    for i in range(1, k + 1):\n        if integers_list[i]:\n            pcount += 1\n            if print_all:\n                print(f\"{2 * i + 1:4}\", end=' ')\n                if pcount % 10 == 0:\n                    print()\n\n            if pcount == nth:\n                print(f\"\\nSundaram primes start with 3. The {nth}th Sundaram prime is {2 * i + 1}.\\n\")\n                break\n\n\n\nsieve_of_Sundaram(100, True)\n\nsieve_of_Sundaram(1000000, False)\n"}
{"id": 418892, "name": "Consecutive primes with ascending or descending differences", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\n\n\nconsecutives equiv = filter ((> 1) . length) . go []\n  where\n    go r [] = [r]\n    go [] (h : t) = go [h] t\n    go (y : ys) (h : t)\n      | y `equiv` h = go (h : y : ys) t\n      | otherwise = (y : ys) : go [h] t\n\n\nmaximumBy g (h : t) = foldr f h t\n  where\n    f r x = if g r < g x then x else r\n\n\ntask ord n = reverse $ p + s : p : (fst <$> rest)\n  where\n    (p, s) : rest =\n      maximumBy length $\n        consecutives (\\(_, a) (_, b) -> a `ord` b) $\n          differences $\n            takeWhile (< n) primes\n    differences l = zip l $ zipWith (-) (tail l) l\n", "target": "from sympy import sieve\n\nprimelist = list(sieve.primerange(2,1000000))\n\nlistlen = len(primelist)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff > old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n\n\n\npindex = 1\nold_diff = -1\ncurr_list=[primelist[0]]\nlongest_list=[]\n\nwhile pindex < listlen:\n\n    diff = primelist[pindex] - primelist[pindex-1]\n    if diff < old_diff:\n        curr_list.append(primelist[pindex])\n        if len(curr_list) > len(longest_list):\n            longest_list = curr_list\n    else:\n        curr_list = [primelist[pindex-1],primelist[pindex]]\n        \n    old_diff = diff\n    pindex += 1\n    \nprint(longest_list)\n"}
{"id": 418893, "name": "Padovan n-step number sequences", "source": "Translate Haskell to Python: import Data.Bifunctor (second)\nimport Data.List (transpose, uncons, unfoldr)\n\n\n\npadovans :: Int -> [Int]\npadovans n\n  | 0 > n = []\n  | otherwise = unfoldr (recurrence n) $ take (succ n) xs\n  where\n    xs\n      | 3 > n = repeat 1\n      | otherwise = padovans $ pred n\n\nrecurrence :: Int -> [Int] -> Maybe (Int, [Int])\nrecurrence n =\n  ( fmap\n      . second\n      . flip (<>)\n      . pure\n      . sum\n      . take n\n  )\n    <*> uncons\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    \"Padovan N-step series:\\n\\n\"\n      <> spacedTable\n        justifyRight\n        ( fmap\n            ( \\n ->\n                [show n <> \" -> \"]\n                  <> fmap show (take 15 $ padovans n)\n            )\n            [2 .. 8]\n        )\n\n\n\nspacedTable ::\n  (Int -> Char -> String -> String) -> [[String]] -> String\nspacedTable aligned rows =\n  unlines $\n    fmap\n      (unwords . zipWith (`aligned` ' ') columnWidths)\n      rows\n  where\n    columnWidths =\n      fmap\n        (maximum . fmap length)\n        (transpose rows)\n\njustifyRight :: Int -> a -> [a] -> [a]\njustifyRight n c = drop . length <*> (replicate n c <>)\n", "target": "def pad_like(max_n=8, t=15):\n    \n    start = [[], [1, 1, 1]]     \n    for n in range(2, max_n+1):\n        this = start[n-1][:n+1]     \n        while len(this) < t:\n            this.append(sum(this[i] for i in range(-2, -n - 2, -1)))\n        start.append(this)\n    return start[2:]\n\ndef pr(p):\n    print(.strip())\n    for n, seq in enumerate(p, 2):\n        print(f\"| {n:2} || {str(seq)[1:-1].replace(' ', '')+', ...'}\\n|-\")\n    print('|}')\n\nif __name__ == '__main__':\n    p = pad_like()\n    pr(p)\n"}
{"id": 418894, "name": "Honaker primes", "source": "Translate Haskell to Python: import Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primes)\n\n\n\nhonakers :: [(Integer, Integer)]\nhonakers =\n  filter\n    (uncurry (==) . both sumDigits)\n    (zip [1 ..] primes)\n\n\nmain :: IO ()\nmain =\n  putStrLn \"First Fifty:\\n\"\n    >> mapM_\n      (putStrLn . unwords)\n      ( chunksOf\n          5\n          (take 50 (show <$> honakers))\n      )\n    >> putStrLn \"\\n10Kth:\\n\"\n    >> print (honakers !! pred 10000)\n\n\nsumDigits :: Integer -> Integer\nsumDigits = foldr ((+) . read . pure) 0 . show\n\nboth :: (a -> b) -> (a, a) -> (b, b)\nboth = join bimap\n", "target": "\n\n\nfrom pyprimesieve import primes\n\n\ndef digitsum(num):\n    \n    return sum(int(c) for c in str(num))\n\n\ndef generate_honaker(limit=5_000_000):\n    \n    honaker = [(i + 1, p) for i, p in enumerate(primes(limit)) if digitsum(p) == digitsum(i + 1)]\n    for hcount, (ppi, pri) in enumerate(honaker):\n        yield hcount + 1, ppi, pri\n\n\nprint('First 50 Honaker primes:')\nfor p in generate_honaker():\n    if p[0] < 51:\n        print(f'{str(p):16}', end='\\n' if p[0] % 5 == 0 else '')\n    elif p[0] == 10_000:\n        print(f'\\nThe 10,000th Honaker prime is the {p[1]:,}th one, which is {p[2]:,}.')\n        break\n"}
{"id": 418895, "name": "Own digits power sum", "source": "Translate Haskell to Python: import Data.List (sort)\n\n\n\nownDigitsPowerSums :: Int -> [Int]\nownDigitsPowerSums n = sort (ns >>= go)\n  where\n    ns = combsWithRep n [0 .. 9]\n    go xs\n      | digitsMatch m xs = [m]\n      | otherwise = []\n      where\n        m = foldr ((+) . (^ n)) 0 xs\n\ndigitsMatch :: Show a => a -> [Int] -> Bool\ndigitsMatch n ds =\n  sort ds == sort (digits n)\n\n\nmain :: IO ()\nmain = do\n  putStrLn \"N \u2208 [3 .. 8]\"\n  mapM_ print ([3 .. 8] >>= ownDigitsPowerSums)\n  putStrLn \"\"\n  putStrLn \"N=9\"\n  mapM_ print $ ownDigitsPowerSums 9\n\n\ncombsWithRep ::\n  (Eq a) =>\n  Int ->\n  [a] ->\n  [[a]]\ncombsWithRep k xs = comb k []\n  where\n    comb 0 ys = ys\n    comb n [] = comb (pred n) (pure <$> xs)\n    comb n peers = comb (pred n) (peers >>= nextLayer)\n      where\n        nextLayer ys@(h : _) =\n          (: ys) <$> dropWhile (/= h) xs\n\ndigits :: Show a => a -> [Int]\ndigits n = (\\x -> read [x] :: Int) <$> show n\n", "target": "\n\ndef isowndigitspowersum(integer):\n    \n    digits = [int(c) for c in str(integer)]\n    exponent = len(digits)\n    return sum(x ** exponent for x in digits) == integer\n\nprint(\"Own digits power sums for N = 3 to 9 inclusive:\")\nfor i in range(100, 1000000000):\n    if isowndigitspowersum(i):\n        print(i)\n"}
{"id": 418896, "name": "Ormiston triples", "source": "Translate Haskell to Python: import Data.Numbers.Primes (primes)\nimport Data.List (sort)\n\n\n\n\normistons :: [(Integer, Integer, Integer)]    \normistons = \n  concat $ zipWith3 \n    (\\(dx, x) (dy, y) (dz, z) \n        -> [(x, y, z) | dx == dy && dx == dz])\n    primeDigits\n    (tail primeDigits)\n    (drop 2 primeDigits)\n    \n\nprimeDigits :: [(Integer, Integer)]\nprimeDigits = ((,) =<< read . sort . show) <$> primes\n\n\n\nmain :: IO ()\nmain = do\n   putStrLn \"First 25 Ormistons:\"\n   mapM_ print $ take 25 ormistons\n   \n   putStrLn \"\\nCount of Ormistons up to 10^8:\"\n   let limit = 10^8\n   print $ length $\n     takeWhile (\\(_, _, c) -> c <= limit) ormistons\n", "target": "import textwrap\n\nfrom itertools import pairwise\nfrom typing import Iterator\nfrom typing import List\n\nimport primesieve\n\n\ndef primes() -> Iterator[int]:\n    it = primesieve.Iterator()\n    while True:\n        yield it.next_prime()\n\n\ndef triplewise(iterable):\n    for (a, _), (b, c) in pairwise(pairwise(iterable)):\n        yield a, b, c\n\n\ndef is_anagram(a: int, b: int, c: int) -> bool:\n    return sorted(str(a)) == sorted(str(b)) == sorted(str(c))\n\n\ndef up_to_one_billion() -> int:\n    count = 0\n    for triple in triplewise(primes()):\n        if is_anagram(*triple):\n            count += 1\n        if triple[2] >= 1_000_000_000:\n            break\n    return count\n\n\ndef up_to_ten_billion() -> int:\n    count = 0\n    for triple in triplewise(primes()):\n        if is_anagram(*triple):\n            count += 1\n        if triple[2] >= 10_000_000_000:\n            break\n    return count\n\n\ndef first_25() -> List[int]:\n    rv: List[int] = []\n    for triple in triplewise(primes()):\n        if is_anagram(*triple):\n            rv.append(triple[0])\n            if len(rv) >= 25:\n                break\n    return rv\n\n\nif __name__ == \"__main__\":\n    print(\"Smallest members of first 25 Ormiston triples:\")\n    print(textwrap.fill(\" \".join(str(i) for i in first_25())), \"\\n\")\n    print(up_to_one_billion(), \"Ormiston triples before 1,000,000,000\")\n    print(up_to_ten_billion(), \"Ormiston triples before 10,000,000,000\")\n"}
{"id": 418897, "name": "Riordan numbers", "source": "Translate Haskell to Python: \n\nriordans :: [Integer]\nriordans =\n  1 :\n  0 :\n  zipWith\n    div\n    ( zipWith\n        (*)\n        [1 ..]\n        ( zipWith\n            (+)\n            ((2 *) <$> tail riordans)\n            ((3 *) <$> riordans)\n        )\n    )\n    [3 ..]\n\n\nmain :: IO ()\nmain =\n  putStrLn \"First 32 Riordan terms:\"\n    >> mapM_ print (take 32 riordans)\n    >> mapM_\n      ( \\x ->\n          putStrLn $\n            concat\n              [ \"\\nDigit count of \",\n                show x,\n                \"th Riordan term:\\n\",\n                (show . length . show)\n                  (riordans !! pred x)\n              ]\n      )\n      [1000, 10000]\n", "target": "def Riordan(N):\n    a = [1, 0, 1]\n    for n in range(3, N):\n        a.append((n - 1) * (2 * a[n - 1] + 3 * a[n - 2]) // (n + 1))\n    return a\n\nrios = Riordan(10_000)\n\nfor i in range(32):\n    print(f'{rios[i] : 18,}', end='\\n' if (i + 1) % 4 == 0 else '')\n\nprint(f'The 1,000th Riordan has {len(str(rios[999]))} digits.')\nprint(f'The 10,000th Rirdan has {len(str(rios[9999]))} digits.')\n"}
{"id": 418898, "name": "Riordan numbers", "source": "Translate Haskell to Python: \n\nriordans :: [Integer]\nriordans =\n  1 :\n  0 :\n  zipWith\n    div\n    ( zipWith\n        (*)\n        [1 ..]\n        ( zipWith\n            (+)\n            ((2 *) <$> tail riordans)\n            ((3 *) <$> riordans)\n        )\n    )\n    [3 ..]\n\n\nmain :: IO ()\nmain =\n  putStrLn \"First 32 Riordan terms:\"\n    >> mapM_ print (take 32 riordans)\n    >> mapM_\n      ( \\x ->\n          putStrLn $\n            concat\n              [ \"\\nDigit count of \",\n                show x,\n                \"th Riordan term:\\n\",\n                (show . length . show)\n                  (riordans !! pred x)\n              ]\n      )\n      [1000, 10000]\n", "target": "def Riordan(N):\n    a = [1, 0, 1]\n    for n in range(3, N):\n        a.append((n - 1) * (2 * a[n - 1] + 3 * a[n - 2]) // (n + 1))\n    return a\n\nrios = Riordan(10_000)\n\nfor i in range(32):\n    print(f'{rios[i] : 18,}', end='\\n' if (i + 1) % 4 == 0 else '')\n\nprint(f'The 1,000th Riordan has {len(str(rios[999]))} digits.')\nprint(f'The 10,000th Rirdan has {len(str(rios[9999]))} digits.')\n"}
{"id": 418899, "name": "Monads_Writer monad", "source": "Translate Haskell to Python: import Control.Monad.Trans.Writer\nimport Control.Monad ((>=>))\n\nloggingVersion :: (a -> b) -> c -> a -> Writer c b\nloggingVersion f log x = writer (f x, log)\n\nlogRoot = loggingVersion sqrt \"obtained square root, \"\nlogAddOne = loggingVersion (+1) \"added 1, \"\nlogHalf = loggingVersion (/2) \"divided by 2, \"\n\nhalfOfAddOneOfRoot = logRoot >=> logAddOne >=> logHalf\n\nmain = print $ runWriter (halfOfAddOneOfRoot 5)\n", "target": "\nfrom __future__ import annotations\n\nimport functools\nimport math\nimport os\n\nfrom typing import Any\nfrom typing import Callable\nfrom typing import Generic\nfrom typing import List\nfrom typing import TypeVar\nfrom typing import Union\n\n\nT = TypeVar(\"T\")\n\n\nclass Writer(Generic[T]):\n    def __init__(self, value: Union[T, Writer[T]], *msgs: str):\n        if isinstance(value, Writer):\n            self.value: T = value.value\n            self.msgs: List[str] = value.msgs + list(msgs)\n        else:\n            self.value = value\n            self.msgs = list(f\"{msg}: {self.value}\" for msg in msgs)\n\n    def bind(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:\n        writer = func(self.value)\n        return Writer(writer, *self.msgs)\n\n    def __rshift__(self, func: Callable[[T], Writer[Any]]) -> Writer[Any]:\n        return self.bind(func)\n\n    def __str__(self):\n        return f\"{self.value}\\n{os.linesep.join(reversed(self.msgs))}\"\n\n    def __repr__(self):\n        return f\"Writer({self.value}, \\\"{', '.join(reversed(self.msgs))}\\\")\"\n\n\ndef lift(func: Callable, msg: str) -> Callable[[Any], Writer[Any]]:\n    \n\n    @functools.wraps(func)\n    def wrapped(value):\n        return Writer(func(value), msg)\n\n    return wrapped\n\n\nif __name__ == \"__main__\":\n    square_root = lift(math.sqrt, \"square root\")\n    add_one = lift(lambda x: x + 1, \"add one\")\n    half = lift(lambda x: x / 2, \"div two\")\n\n    print(Writer(5, \"initial\") >> square_root >> add_one >> half)\n"}
{"id": 418900, "name": "Word ladder", "source": "Translate Haskell to Python: import System.IO (readFile)\nimport Control.Monad (foldM)\nimport Data.List (intercalate)\nimport qualified Data.Set as S\n\ndistance :: String -> String -> Int\ndistance s1 s2 = length $ filter not $ zipWith (==) s1 s2\n\nwordLadders :: [String] -> String -> String -> [[String]]\nwordLadders dict start end\n  | length start /= length end = []\n  | otherwise = [wordSpace] >>= expandFrom start >>= shrinkFrom end\n  where\n \n    wordSpace = S.fromList $ filter ((length start ==) . length) dict\n\n    expandFrom s = go [[s]]\n      where\n        go (h:t) d\n          | S.null d || S.null f = []\n          | end `S.member` f = [h:t]\n          | otherwise = go (S.elems f:h:t) (d S.\\\\ f)\n          where\n            f = foldr (\\w -> S.union (S.filter (oneStepAway w) d)) mempty h\n\n    shrinkFrom = scanM (filter . oneStepAway)\n\n    oneStepAway x = (1 ==) . distance x\n    \n    scanM f x = fmap snd . foldM g (x,[x])\n      where g (b, r) a = (\\x -> (x, x:r)) <$> f b a\n\nwordLadder :: [String] -> String -> String -> [String]\nwordLadder d s e = case wordLadders d s e of\n                     [] -> []\n                     h:_ -> h\n\nshowChain [] = putStrLn \"No chain\"\nshowChain ch = putStrLn $ intercalate \" -> \" ch\n\nmain = do\n  dict <- lines <$> readFile \"unixdict.txt\"\n  showChain $ wordLadder dict \"boy\" \"man\"\n  showChain $ wordLadder dict \"girl\" \"lady\"\n  showChain $ wordLadder dict \"john\" \"jane\"\n  showChain $ wordLadder dict \"alien\" \"drool\"\n  showChain $ wordLadder dict \"child\" \"adult\"\n", "target": "import os,sys,zlib,urllib.request\n\ndef h ( str,x=9 ):\n    for c in str :\n        x = ( x*33 + ord( c )) & 0xffffffffff\n    return x  \n\ndef cache ( func,*param ):\n    n = 'cache_%x.bin'%abs( h( repr( param )))\n    try    : return eval( zlib.decompress( open( n,'rb' ).read()))\n    except : pass\n    s = func( *param )\n    open( n,'wb' ).write( zlib.compress( bytes( repr( s ),'ascii' )))\n    return s\n\ndico_url  = 'https://raw.githubusercontent.com/quinnj/Rosetta-Julia/master/unixdict.txt'\nread_url  = lambda url   : urllib.request.urlopen( url ).read()\nload_dico = lambda url   : tuple( cache( read_url,url ).split( b'\\n'))\nisnext    = lambda w1,w2 : len( w1 ) == len( w2 ) and len( list( filter( lambda l : l[0]!=l[1] , zip( w1,w2 )))) == 1\n\ndef build_map ( words ):\n    map = [(w.decode('ascii'),[]) for w in words]\n    for i1,(w1,n1) in enumerate( map ):\n        for i2,(w2,n2) in enumerate( map[i1+1:],i1+1 ):\n            if isnext( w1,w2 ):\n                n1.append( i2 )\n                n2.append( i1 )\n    return map\n\ndef find_path ( words,w1,w2 ):\n    i = [w[0] for w in words].index( w1 )\n    front,done,res  = [i],{i:-1},[]\n    while front :\n        i = front.pop(0)\n        word,next = words[i]\n        for n in next :\n            if n in done : continue\n            done[n] = i\n            if words[n][0] == w2 :\n                while n >= 0 :\n                    res = [words[n][0]] + res\n                    n = done[n]\n                return ' '.join( res )\n            front.append( n )\n    return '%s can not be turned into %s'%( w1,w2 )\n\nfor w in ('boy man','girl lady','john jane','alien drool','child adult'):\n    print( find_path( cache( build_map,load_dico( dico_url )),*w.split()))\n"}
{"id": 418901, "name": "Non-transitive dice", "source": "Translate Haskell to Python: \nimport Data.List\nimport Control.Monad\n\nnewtype Dice = Dice [Int] \n\ninstance Show Dice where\n  show (Dice s) = \"(\" ++ unwords (show <$> s) ++ \")\"\n\ninstance Eq Dice where\n  d1 == d2 = d1 `compare` d2 == EQ\n  \ninstance Ord Dice where\n  Dice d1 `compare` Dice d2 = (add $ compare <$> d1 <*> d2) `compare` 0\n    where\n      add = sum . map (\\case {LT -> -1; EQ -> 0; GT -> 1})\n\ndices n = Dice <$> (nub $ sort <$> replicateM n [1..n]) \n\nnonTrans dice = filter (\\x -> last x < head x) . go\n  where\n    go 0 = []\n    go 1 = sequence [dice]\n    go n = do\n      (a:as) <- go (n-1)\n      b <- filter (< a) dice\n      return (b:a:as)\n", "target": "from itertools import combinations_with_replacement as cmbr\nfrom time import time\n \ndef dice_gen(n, faces, m):\n    dice = list(cmbr(faces, n))\n \n    succ = [set(j for j, b in enumerate(dice)\n                    if sum((x>y) - (x<y) for x in a for y in b) > 0)\n                for a in dice]\n \n    def loops(seq):\n        s = succ[seq[-1]]\n\n        if len(seq) == m:\n            if seq[0] in s: yield seq\n            return\n\n        for d in (x for x in s if x > seq[0] and not x in seq):\n            yield from loops(seq + (d,))\n \n    yield from (tuple(''.join(dice[s]) for s in x)\n                    for i, v in enumerate(succ)\n                    for x in loops((i,)))\n \nt = time()\nfor n, faces, loop_len in [(4, '1234', 3), (4, '1234', 4), (6, '123456', 3), (6, '1234567', 3)]:\n    for i, x in enumerate(dice_gen(n, faces, loop_len)): pass\n \n    print(f'{n}-sided, markings {faces}, loop length {loop_len}:')\n    print(f'\\t{i + 1}*{loop_len} solutions, e.g. {\" > \".join(x)} > [loop]')\n    t, t0 = time(), t\n    print(f'\\ttime: {t - t0:.4f} seconds\\n')\n"}
{"id": 418902, "name": "Factorial base numbers indexing permutations of a collection", "source": "Translate Haskell to Python: import Data.List (unfoldr, intercalate)\n\nnewtype Fact = Fact [Int]\n\n\nfact :: [Int] -> Fact\nfact = Fact . zipWith min [0..] . reverse\n\ninstance Show Fact where\n  show (Fact ds) = intercalate \".\" $ show <$> reverse ds\n    \ntoFact :: Integer -> Fact\ntoFact 0 = Fact [0]\ntoFact n = Fact $ unfoldr f (1, n)\n  where\n    f (b, 0) = Nothing\n    f (b, n) = let (q, r) = n `divMod` b\n               in Just (fromIntegral r, (b+1, q))\n\nfromFact :: Fact -> Integer\nfromFact (Fact ds) = foldr f 0 $ zip [1..] ds\n  where\n    f (b, d) r = r * b + fromIntegral d\n", "target": "\n\nimport math\n\ndef apply_perm(omega,fbn):\n    \n    for m in range(len(fbn)):\n        g = fbn[m]\n        if g > 0:\n            \n            \n            new_first = omega[m+g]\n            \n            omega[m+1:m+g+1] = omega[m:m+g]\n            \n            omega[m] = new_first\n            \n    return omega\n    \ndef int_to_fbn(i):\n    \n    current = i\n    divisor = 2\n    new_fbn = []\n    while current > 0:\n        remainder = current % divisor\n        current = current // divisor\n        new_fbn.append(remainder)\n        divisor += 1\n    \n    return list(reversed(new_fbn))\n    \ndef leading_zeros(l,n):\n   \n   if len(l) < n:\n       return(([0] * (n - len(l))) + l)\n   else:\n       return l\n\ndef get_fbn(n):\n    \n    max = math.factorial(n)\n    \n    for i in range(max):\n        \n        current = i\n        divisor = 1\n        new_fbn = int_to_fbn(i)\n        yield leading_zeros(new_fbn,n-1)\n        \ndef print_write(f, line):\n    \n    print(line)\n    f.write(str(line)+'\\n')     \n    \ndef dot_format(l):\n    \n    \n    if len(l) < 1:\n        return \"\"\n    \n    dot_string = str(l[0])\n    \n    for e in l[1:]:\n        dot_string += \".\"+str(e)\n        \n    return dot_string\n    \ndef str_format(l):\n    \n    if len(l) < 1:\n        return \"\"\n        \n    new_string = \"\"\n        \n    for e in l:\n        new_string += str(e)\n    \n    return new_string \n    \nwith open(\"output.html\", \"w\", encoding=\"utf-8\") as f:\n    f.write(\"<pre>\\n\")\n    \n    \n        \n    omega=[0,1,2,3]\n    \n    four_list = get_fbn(4)\n    \n    for l in four_list:\n        print_write(f,dot_format(l)+' -> '+str_format(apply_perm(omega[:],l)))\n        \n    print_write(f,\" \")\n    \n    \n    \n    \n    \n    \n        \n    num_permutations = 0\n    \n    for p in get_fbn(11):\n        num_permutations += 1\n        if num_permutations % 1000000 == 0:\n            print_write(f,\"permutations so far = \"+str(num_permutations))\n    \n    print_write(f,\" \")\n    print_write(f,\"Permutations generated = \"+str(num_permutations))\n    print_write(f,\"compared to 11! which  = \"+str(math.factorial(11)))\n    \n    print_write(f,\" \")\n    \n       \n    \n    \n    \n    shoe = []\n    \n    for suit in [u\"\\u2660\",u\"\\u2665\",u\"\\u2666\",u\"\\u2663\"]:\n        for value in ['A','K','Q','J','10','9','8','7','6','5','4','3','2']:\n            shoe.append(value+suit)\n                    \n    print_write(f,str_format(shoe))\n    \n    p1 = [39,49,7,47,29,30,2,12,10,3,29,37,33,17,12,31,29,34,17,25,2,4,25,4,1,14,20,6,21,18,1,1,1,4,0,5,15,12,4,3,10,10,9,1,6,5,5,3,0,0,0]\n    \n    p2 = [51,48,16,22,3,0,19,34,29,1,36,30,12,32,12,29,30,26,14,21,8,12,1,3,10,4,7,17,6,21,8,12,15,15,13,15,7,3,12,11,9,5,5,6,6,3,4,0,3,2,1]\n    \n    print_write(f,\" \")\n    print_write(f,dot_format(p1))\n    print_write(f,\" \")\n    print_write(f,str_format(apply_perm(shoe[:],p1)))\n    \n    print_write(f,\" \")\n    print_write(f,dot_format(p2))\n    print_write(f,\" \")\n    print_write(f,str_format(apply_perm(shoe[:],p2)))\n\n    \n    \n    import random\n    \n    max = math.factorial(52)\n    \n    random_int = random.randint(0, max-1)\n\n    myperm = leading_zeros(int_to_fbn(random_int),51)\n    \n    print(len(myperm))\n    \n    print_write(f,\" \")\n    print_write(f,dot_format(myperm))\n    print_write(f,\" \")\n    print_write(f,str_format(apply_perm(shoe[:],myperm)))\n\n    f.write(\"</pre>\\n\")\n"}
{"id": 418903, "name": "Separate the house number from the street name", "source": "Translate Haskell to Python: \n\n\n\nmodule Main where\n\nimport Control.Monad\nimport Data.Char\nimport Data.Monoid\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport Text.Regex.PCRE.Text\n\ntestSet :: [T.Text]\ntestSet =\n  [ \"Plataanstraat 5\"\n  , \"Straat 12\"\n  , \"Straat 12 II\"\n  , \"Dr. J. Straat   12\"\n  , \"Dr. J. Straat 12 a\"\n  , \"Dr. J. Straat 12-14\"\n  , \"Laan 1940 \u2013 1945 37\"\n  , \"Plein 1940 2\"\n  , \"1213-laan 11\"\n  , \"16 april 1944 Pad 1\"\n  , \"1e Kruisweg 36\"\n  , \"Laan 1940-\u201945 66\"\n  , \"Laan \u201940-\u201945\"\n  , \"Langelo\u00ebrduinen 3 46\"\n  , \"Marienwaerdt 2e Dreef 2\"\n  , \"Provincialeweg N205 1\"\n  , \"Rivium 2e Straat 59.\"\n  , \"Nieuwe gracht 20rd\"\n  , \"Nieuwe gracht 20rd 2\"\n  , \"Nieuwe gracht 20zw /2\"\n  , \"Nieuwe gracht 20zw/3\"\n  , \"Nieuwe gracht 20 zw/4\"\n  , \"Bahnhofstr. 4\"\n  , \"Wertstr. 10\"\n  , \"Lindenhof 1\"\n  , \"Nordesch 20\"\n  , \"Weilstr. 6\"\n  , \"Harthauer Weg 2\"\n  , \"Mainaustr. 49\"\n  , \"August-Horch-Str. 3\"\n  , \"Marktplatz 31\"\n  , \"Schmidener Weg 3\"\n  , \"Karl-Weysser-Str. 6\"\n  ]\n\n\naddressPattern :: T.Text\naddressPattern = T.unlines\n  [ \"^ (.*?) \\\\s+\"\n  , \"  (\"\n  , \"     \\\\d* (\\\\-|\\\\/)? \\\\d*\"\n  , \"   | \\\\d{1,3} [a-zI./ ]* \\\\d{0,3}\"\n  , \"  )\"\n  , \"$\"\n  ]\n\nsplitAddressASCII :: Regex -> T.Text -> IO (T.Text, T.Text)\nsplitAddressASCII rx txt = do\n  result <- regexec rx txt\n  case result of\n    Left w -> fail (show w)\n    Right (Just (_, _, _, (street:house:_))) -> return (street, house)\n    _ -> return (txt, \"\")\n\n\n\n\nsplitAddress :: Regex -> T.Text -> IO (T.Text, T.Text)\nsplitAddress rx txt = do\n  let prefix = T.dropWhileEnd isAscii txt\n      ascii = T.takeWhileEnd isAscii txt\n  (street, house) <- splitAddressASCII rx ascii\n  return (prefix <> street, house)\n\nformatPairs :: [(T.Text, T.Text)] -> [T.Text]\nformatPairs pairs =\n  let headings = (\"Street\", \"House Number\")\n      (streets, houses) = unzip (headings : pairs)\n      sLen = maximum $ map T.length streets\n      hLen = maximum $ map T.length houses\n      sep = (T.replicate sLen \"-\", T.replicate hLen \"-\")\n      fmt (s, h) = T.justifyLeft (sLen + 4) ' ' s <> h\n  in map (T.strip . fmt) (headings : sep : pairs)\n\nmain :: IO ()\nmain = do\n  erx <- compile (compExtended + compUTF8) execBlank addressPattern\n  rx <- case erx of\n          Left (offset, str) -> fail $ show offset ++ \": \" ++ str\n          Right r -> return r\n  pairs <- mapM (splitAddress rx) testSet\n  mapM_ T.putStrLn $ formatPairs pairs\n", "target": "Plataanstraat 5           split as (Plataanstraat, 5)\nStraat 12                 split as (Straat, 12)\nStraat 12 II              split as (Straat, 12 II)\nDr. J. Straat   12        split as (Dr. J. Straat  , 12)\nDr. J. Straat 12 a        split as (Dr. J. Straat, 12 a)\nDr. J. Straat 12-14       split as (Dr. J. Straat, 12-14)\nLaan 1940 \u2013 1945 37       split as (Laan 1940 \u2013 1945, 37)\nPlein 1940 2              split as (Plein 1940, 2)\n1213-laan 11              split as (1213-laan, 11)\n16 april 1944 Pad 1       split as (16 april 1944 Pad, 1)\n1e Kruisweg 36            split as (1e Kruisweg, 36)\nLaan 1940-\u201945 66          split as (Laan 1940-\u201945, 66)\nLaan \u201940-\u201945              split as (Laan \u201940-\u201945,)\nLangelo\u00ebrduinen 3 46      split as (Langelo\u00ebrduinen, 3 46)\nMarienwaerdt 2e Dreef 2   split as (Marienwaerdt 2e Dreef, 2)\nProvincialeweg N205 1     split as (Provincialeweg N205, 1)\nRivium 2e Straat 59.      split as (Rivium 2e Straat, 59.)\nNieuwe gracht 20rd        split as (Nieuwe gracht, 20rd)\nNieuwe gracht 20rd 2      split as (Nieuwe gracht, 20rd 2)\nNieuwe gracht 20zw /2     split as (Nieuwe gracht, 20zw /2)\nNieuwe gracht 20zw/3      split as (Nieuwe gracht, 20zw/3)\nNieuwe gracht 20 zw/4     split as (Nieuwe gracht, 20 zw/4)\nBahnhofstr. 4             split as (Bahnhofstr., 4)\nWertstr. 10               split as (Wertstr., 10)\nLindenhof 1               split as (Lindenhof, 1)\nNordesch 20               split as (Nordesch, 20)\nWeilstr. 6                split as (Weilstr., 6)\nHarthauer Weg 2           split as (Harthauer Weg, 2)\nMainaustr. 49             split as (Mainaustr., 49)\nAugust-Horch-Str. 3       split as (August-Horch-Str., 3)\nMarktplatz 31             split as (Marktplatz, 31)\nSchmidener Weg 3          split as (Schmidener Weg, 3)\nKarl-Weysser-Str. 6       split as (Karl-Weysser-Str., 6)''')\n"}
{"id": 418904, "name": "Doomsday rule", "source": "Translate Haskell to Python: import Text.Printf\n\ndata Date = Date {year :: Int, month :: Int, day :: Int}\n\ninstance Show Date where\n  show Date {year = y, month = m, day = d} =\n    printf \"%4d-%02d-%02d\" y m d\n\nleap :: Int -> Bool\nleap year =\n  year `mod` 4 == 0\n    && (year `mod` 100 /= 0 || year `mod` 400 == 0)\n\nweekday :: Date -> Int\nweekday Date {year = y, month = m, day = d} =\n  let doom = (s + t + (t `div` 4) + c_anchor) `mod` 7\n      anchor = dooms !! pred m\n      c_anchor = (5 * mod c 4 + 2) `mod` 7\n      dooms =\n        (if leap y then [4, 1] else [3, 7])\n          <> [7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n      (c, r) = y `divMod` 100\n      (s, t) = r `divMod` 12\n   in (doom + d - anchor + 7) `mod` 7\n\ndays :: [String]\ndays = words \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\"\n\ndates :: [Date]\ndates =\n  [ Date {year = 1800, month = 1, day = 6},\n    Date {year = 1875, month = 3, day = 29},\n    Date {year = 1915, month = 12, day = 7},\n    Date {year = 1970, month = 12, day = 23},\n    Date {year = 2043, month = 5, day = 14},\n    Date {year = 2077, month = 2, day = 12},\n    Date {year = 2101, month = 4, day = 2}\n  ]\n\ndateAndDay :: Date -> String\ndateAndDay d = printf \"%s: %s\" (show d) (days !! weekday d)\n\nmain :: IO ()\nmain = putStr $ unlines $ map dateAndDay dates\n", "target": "from datetime import date\nfrom calendar import isleap\n\ndef weekday(d):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n            \"Friday\", \"Saturday\"]\n    dooms = [\n        [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5],\n        [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n    ]\n    \n    c = d.year // 100\n    r = d.year % 100\n    s = r // 12\n    t = r % 12\n    c_anchor = (5 * (c % 4) + 2) % 7\n    doomsday = (s + t + (t // 4) + c_anchor) % 7\n    anchorday = dooms[isleap(d.year)][d.month - 1]\n    weekday = (doomsday + d.day - anchorday + 7) % 7\n    return days[weekday]\n\ndates = [date(*x) for x in\n    [(1800, 1, 6), (1875, 3, 29), (1915, 12, 7), (1970, 12, 23),\n     (2043, 5, 14), (2077, 2, 12), (2101, 4, 2)]\n]\n\nfor d in dates:\n    tense = \"was\" if d < date.today() else \"is\" if d == date.today() else \"will be\"\n    print(\"{} {} a {}\".format(d.strftime(\"%B %d, %Y\"), tense, weekday(d)))\n"}
{"id": 418905, "name": "Doomsday rule", "source": "Translate Haskell to Python: import Text.Printf\n\ndata Date = Date {year :: Int, month :: Int, day :: Int}\n\ninstance Show Date where\n  show Date {year = y, month = m, day = d} =\n    printf \"%4d-%02d-%02d\" y m d\n\nleap :: Int -> Bool\nleap year =\n  year `mod` 4 == 0\n    && (year `mod` 100 /= 0 || year `mod` 400 == 0)\n\nweekday :: Date -> Int\nweekday Date {year = y, month = m, day = d} =\n  let doom = (s + t + (t `div` 4) + c_anchor) `mod` 7\n      anchor = dooms !! pred m\n      c_anchor = (5 * mod c 4 + 2) `mod` 7\n      dooms =\n        (if leap y then [4, 1] else [3, 7])\n          <> [7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n      (c, r) = y `divMod` 100\n      (s, t) = r `divMod` 12\n   in (doom + d - anchor + 7) `mod` 7\n\ndays :: [String]\ndays = words \"Sunday Monday Tuesday Wednesday Thursday Friday Saturday\"\n\ndates :: [Date]\ndates =\n  [ Date {year = 1800, month = 1, day = 6},\n    Date {year = 1875, month = 3, day = 29},\n    Date {year = 1915, month = 12, day = 7},\n    Date {year = 1970, month = 12, day = 23},\n    Date {year = 2043, month = 5, day = 14},\n    Date {year = 2077, month = 2, day = 12},\n    Date {year = 2101, month = 4, day = 2}\n  ]\n\ndateAndDay :: Date -> String\ndateAndDay d = printf \"%s: %s\" (show d) (days !! weekday d)\n\nmain :: IO ()\nmain = putStr $ unlines $ map dateAndDay dates\n", "target": "from datetime import date\nfrom calendar import isleap\n\ndef weekday(d):\n    days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\",\n            \"Friday\", \"Saturday\"]\n    dooms = [\n        [3, 7, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5],\n        [4, 1, 7, 4, 2, 6, 4, 1, 5, 3, 7, 5]\n    ]\n    \n    c = d.year // 100\n    r = d.year % 100\n    s = r // 12\n    t = r % 12\n    c_anchor = (5 * (c % 4) + 2) % 7\n    doomsday = (s + t + (t // 4) + c_anchor) % 7\n    anchorday = dooms[isleap(d.year)][d.month - 1]\n    weekday = (doomsday + d.day - anchorday + 7) % 7\n    return days[weekday]\n\ndates = [date(*x) for x in\n    [(1800, 1, 6), (1875, 3, 29), (1915, 12, 7), (1970, 12, 23),\n     (2043, 5, 14), (2077, 2, 12), (2101, 4, 2)]\n]\n\nfor d in dates:\n    tense = \"was\" if d < date.today() else \"is\" if d == date.today() else \"will be\"\n    print(\"{} {} a {}\".format(d.strftime(\"%B %d, %Y\"), tense, weekday(d)))\n"}
{"id": 418906, "name": "Gauss-Jordan matrix inversion", "source": "Translate Haskell to Python: isMatrix xs = null xs || all ((== (length.head $ xs)).length) xs\n\nisSquareMatrix xs = null xs || all ((== (length xs)).length) xs\n\nmult:: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs). zipWith (\\vs u -> map (u*) vs) vss) uss\n\nmatI::(Num a) => Int -> [[a]]\nmatI n = [ [fromIntegral.fromEnum $ i == j | j <- [1..n]] | i <- [1..n]]\n\ninversion xs = gauss xs (matI $ length xs)\n\ngauss::[[Double]] -> [[Double]] -> [[Double]]\ngauss xs bs = map (map fromRational) $ solveGauss (toR xs) (toR bs)\n    where toR = map $ map toRational\n\nsolveGauss:: (Fractional a, Ord a) => [[a]] -> [[a]] -> [[a]]\nsolveGauss xs bs | null xs || null bs || length xs /= length bs || (not $ isSquareMatrix xs) || (not $ isMatrix bs) = []\n                 | otherwise = uncurry solveTriangle $ triangle xs bs\n\nsolveTriangle::(Fractional a,Eq a) => [[a]] -> [[a]] -> [[a]]\nsolveTriangle us _ | not.null.dropWhile ((/= 0).head) $ us = []\nsolveTriangle ([c]:as) (b:bs) = go as bs [map (/c) b]\n  where\n  val us vs ws = let u = head us in map (/u) $ zipWith (-) vs (head $ mult [tail us] ws)\n  go [] _ zs          = zs\n  go _ [] zs          = zs\n  go (x:xs) (y:ys) zs = go xs ys $ (val x y zs):zs\n\ntriangle::(Num a, Ord a) => [[a]] -> [[a]] -> ([[a]],[[a]])\ntriangle xs bs = triang ([],[]) (xs,bs)\n    where\n    triang ts (_,[]) = ts\n    triang ts ([],_) = ts\n    triang (os,ps) zs = triang (us:os,cs:ps).unzip $ [(fun tus vs, fun cs es) | (v:vs,es) <- zip uss css,let fun = zipWith (\\x y -> v*x - u*y)]\n        where ((us@(u:tus)):uss,cs:css) = bubble zs\n\nbubble::(Num a, Ord a) => ([[a]],[[a]]) -> ([[a]],[[a]])\nbubble (xs,bs) = (go xs, go bs)\n    where\n    idmax = snd.maximum.flip zip [0..].map (abs.head) $ xs\n    go ys = let (us,vs) = splitAt idmax ys in vs ++ us\n \nmain = do\n  let a = [[1, 2, 3], [4, 1, 6], [7, 8, 9]]\n  let b = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]\n  putStrLn \"inversion a =\"\n  mapM_ print $ inversion a\n  putStrLn \"\\ninversion b =\"\n  mapM_ print $ inversion b\n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 418907, "name": "Gauss-Jordan matrix inversion", "source": "Translate Haskell to Python: isMatrix xs = null xs || all ((== (length.head $ xs)).length) xs\n\nisSquareMatrix xs = null xs || all ((== (length xs)).length) xs\n\nmult:: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs). zipWith (\\vs u -> map (u*) vs) vss) uss\n\nmatI::(Num a) => Int -> [[a]]\nmatI n = [ [fromIntegral.fromEnum $ i == j | j <- [1..n]] | i <- [1..n]]\n\ninversion xs = gauss xs (matI $ length xs)\n\ngauss::[[Double]] -> [[Double]] -> [[Double]]\ngauss xs bs = map (map fromRational) $ solveGauss (toR xs) (toR bs)\n    where toR = map $ map toRational\n\nsolveGauss:: (Fractional a, Ord a) => [[a]] -> [[a]] -> [[a]]\nsolveGauss xs bs | null xs || null bs || length xs /= length bs || (not $ isSquareMatrix xs) || (not $ isMatrix bs) = []\n                 | otherwise = uncurry solveTriangle $ triangle xs bs\n\nsolveTriangle::(Fractional a,Eq a) => [[a]] -> [[a]] -> [[a]]\nsolveTriangle us _ | not.null.dropWhile ((/= 0).head) $ us = []\nsolveTriangle ([c]:as) (b:bs) = go as bs [map (/c) b]\n  where\n  val us vs ws = let u = head us in map (/u) $ zipWith (-) vs (head $ mult [tail us] ws)\n  go [] _ zs          = zs\n  go _ [] zs          = zs\n  go (x:xs) (y:ys) zs = go xs ys $ (val x y zs):zs\n\ntriangle::(Num a, Ord a) => [[a]] -> [[a]] -> ([[a]],[[a]])\ntriangle xs bs = triang ([],[]) (xs,bs)\n    where\n    triang ts (_,[]) = ts\n    triang ts ([],_) = ts\n    triang (os,ps) zs = triang (us:os,cs:ps).unzip $ [(fun tus vs, fun cs es) | (v:vs,es) <- zip uss css,let fun = zipWith (\\x y -> v*x - u*y)]\n        where ((us@(u:tus)):uss,cs:css) = bubble zs\n\nbubble::(Num a, Ord a) => ([[a]],[[a]]) -> ([[a]],[[a]])\nbubble (xs,bs) = (go xs, go bs)\n    where\n    idmax = snd.maximum.flip zip [0..].map (abs.head) $ xs\n    go ys = let (us,vs) = splitAt idmax ys in vs ++ us\n \nmain = do\n  let a = [[1, 2, 3], [4, 1, 6], [7, 8, 9]]\n  let b = [[2, -1, 0], [-1, 2, -1], [0, -1, 2]]\n  putStrLn \"inversion a =\"\n  mapM_ print $ inversion a\n  putStrLn \"\\ninversion b =\"\n  mapM_ print $ inversion b\n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 418908, "name": "Colorful numbers", "source": "Translate Haskell to Python: import Data.List ( nub ) \nimport Data.List.Split ( divvy ) \nimport Data.Char ( digitToInt ) \n\nisColourful :: Integer -> Bool\nisColourful n \n   |n >= 0 && n <= 10 = True\n   |n > 10 && n < 100 = ((length s) == (length $ nub s)) &&\n    (not $ any (\\c -> elem c \"01\") s)\n   |n >= 100 = ((length s) == (length $ nub s)) && (not $ any (\\c -> elem c \"01\") s)\n     && ((length products) == (length $ nub products))\n    where\n     s :: String\n     s = show n\n     products :: [Int]\n     products = map (\\p -> (digitToInt $ head p) * (digitToInt $ last p))\n      $ divvy 2 1 s\n\nsolution1 :: [Integer]\nsolution1 = filter isColourful [0 .. 100]\n\nsolution2 :: Integer\nsolution2 = head $ filter isColourful [98765432, 98765431 ..]\n", "target": "from math import prod\n\nlargest = [0]\n\ndef iscolorful(n):\n    if 0 <= n < 10:\n        return True\n    dig = [int(c) for c in str(n)]\n    if 1 in dig or 0 in dig or len(dig) > len(set(dig)):\n        return False\n    products = list(set(dig))\n    for i in range(len(dig)):\n        for j in range(i+2, len(dig)+1):\n            p = prod(dig[i:j])\n            if p in products:\n                return False\n            products.append(p)\n\n    largest[0] = max(n, largest[0])\n    return True\n\nprint('Colorful numbers for 1:25, 26:50, 51:75, and 76:100:')\nfor i in range(1, 101, 25):\n    for j in range(25):\n        if iscolorful(i + j):\n            print(f'{i + j: 5,}', end='')\n    print()\n\ncsum = 0\nfor i in range(8):\n    j = 0 if i == 0 else 10**i\n    k = 10**(i+1) - 1\n    n = sum(iscolorful(x) for x in range(j, k+1))\n    csum += n\n    print(f'The count of colorful numbers between {j} and {k} is {n}.')\n\nprint(f'The largest possible colorful number is {largest[0]}.')\nprint(f'The total number of colorful numbers is {csum}.')\n"}
{"id": 418909, "name": "Colorful numbers", "source": "Translate Haskell to Python: import Data.List ( nub ) \nimport Data.List.Split ( divvy ) \nimport Data.Char ( digitToInt ) \n\nisColourful :: Integer -> Bool\nisColourful n \n   |n >= 0 && n <= 10 = True\n   |n > 10 && n < 100 = ((length s) == (length $ nub s)) &&\n    (not $ any (\\c -> elem c \"01\") s)\n   |n >= 100 = ((length s) == (length $ nub s)) && (not $ any (\\c -> elem c \"01\") s)\n     && ((length products) == (length $ nub products))\n    where\n     s :: String\n     s = show n\n     products :: [Int]\n     products = map (\\p -> (digitToInt $ head p) * (digitToInt $ last p))\n      $ divvy 2 1 s\n\nsolution1 :: [Integer]\nsolution1 = filter isColourful [0 .. 100]\n\nsolution2 :: Integer\nsolution2 = head $ filter isColourful [98765432, 98765431 ..]\n", "target": "from math import prod\n\nlargest = [0]\n\ndef iscolorful(n):\n    if 0 <= n < 10:\n        return True\n    dig = [int(c) for c in str(n)]\n    if 1 in dig or 0 in dig or len(dig) > len(set(dig)):\n        return False\n    products = list(set(dig))\n    for i in range(len(dig)):\n        for j in range(i+2, len(dig)+1):\n            p = prod(dig[i:j])\n            if p in products:\n                return False\n            products.append(p)\n\n    largest[0] = max(n, largest[0])\n    return True\n\nprint('Colorful numbers for 1:25, 26:50, 51:75, and 76:100:')\nfor i in range(1, 101, 25):\n    for j in range(25):\n        if iscolorful(i + j):\n            print(f'{i + j: 5,}', end='')\n    print()\n\ncsum = 0\nfor i in range(8):\n    j = 0 if i == 0 else 10**i\n    k = 10**(i+1) - 1\n    n = sum(iscolorful(x) for x in range(j, k+1))\n    csum += n\n    print(f'The count of colorful numbers between {j} and {k} is {n}.')\n\nprint(f'The largest possible colorful number is {largest[0]}.')\nprint(f'The total number of colorful numbers is {csum}.')\n"}
{"id": 418910, "name": "Generate random chess position", "source": "Translate Haskell to Python: \n\nmodule RandomChess\n( placeKings\n, placePawns\n, placeRemaining\n, emptyBoard\n, toFen\n, ChessBoard\n, Square (..)\n, BoardState (..)\n, getBoard\n)\nwhere\n\nimport Control.Monad.State (State, get, gets, put)\nimport Data.List (find, sortBy)\nimport System.Random (Random, RandomGen, StdGen, random, randomR)\n\ntype Pos = (Char, Int)\n\ntype ChessBoard = [(Square, Pos)]\n\ndata PieceRank  = King | Queen | Rook | Bishop | Knight | Pawn\n  deriving (Enum, Bounded, Show, Eq, Ord)\ndata PieceColor = Black | White\n  deriving (Enum, Bounded, Show, Eq, Ord)\n\ndata Square = ChessPiece PieceRank PieceColor | EmptySquare\n  deriving (Eq, Ord)\n\ntype PieceCount = [(Square, Int)]\n\ndata BoardState = BoardState { board :: ChessBoard , generator :: StdGen }\n\ninstance Show Square where\n  show (ChessPiece King   Black) = \"\u265a\"\n  show (ChessPiece Queen  Black) = \"\u265b\"\n  show (ChessPiece Rook   Black) = \"\u265c\"\n  show (ChessPiece Bishop Black) = \"\u265d\"\n  show (ChessPiece Knight Black) = \"\u265e\"\n  show (ChessPiece Pawn   Black) = \"\u265f\"\n  show (ChessPiece King   White) = \"\u2654\"\n  show (ChessPiece Queen  White) = \"\u2655\"\n  show (ChessPiece Rook   White) = \"\u2656\"\n  show (ChessPiece Bishop White) = \"\u2657\"\n  show (ChessPiece Knight White) = \"\u2658\"\n  show (ChessPiece Pawn   White) = \"\u2659\"\n  show EmptySquare               = \" \"\n\ninstance Random PieceRank where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of\n    (x, g'') -> (toEnum x, g'')\n  random = randomR (minBound, maxBound)\n\ninstance Random PieceColor where\n  randomR (a, b) g = case randomR (fromEnum a, fromEnum b) g of\n    (x, g'') -> (toEnum x, g'')\n  random = randomR (minBound, maxBound)\n\nfullBoard :: PieceCount\nfullBoard =\n  [ (ChessPiece King Black  , 1)\n  , (ChessPiece Queen Black , 1)\n  , (ChessPiece Rook Black  , 2)\n  , (ChessPiece Bishop Black, 2)\n  , (ChessPiece Knight Black, 2)\n  , (ChessPiece Pawn Black  , 8)\n  , (ChessPiece King White  , 1)\n  , (ChessPiece Queen White , 1)\n  , (ChessPiece Rook White  , 2)\n  , (ChessPiece Bishop White, 2)\n  , (ChessPiece Knight White, 2)\n  , (ChessPiece Pawn White  , 8)\n  , (EmptySquare            , 32)\n  ]\n\nemptyBoard :: ChessBoard\nemptyBoard = fmap (EmptySquare,) . (,) <$> ['a'..'h'] <*> [1..8]\n\nreplaceSquareByPos :: (Square, Pos) -> ChessBoard -> ChessBoard\nreplaceSquareByPos e@(_, p) = fmap (\\x -> if p == snd x then e else x)\n\nisPosOccupied :: Pos -> ChessBoard -> Bool\nisPosOccupied p = occupied . find (\\x -> p == snd x)\n where\n  occupied (Just (EmptySquare, _)) = False\n  occupied _                       = True\n\nisAdjacent :: Pos -> Pos -> Bool\nisAdjacent (x1, y1) (x2, y2) =\n  let upOrDown    = (pred y1 == y2 || succ y1 == y2)\n      leftOrRight = (pred x1 == x2 || succ x1 == x2)\n  in  (x2 == x1 && upOrDown)\n        || (pred x1 == x2 && upOrDown)\n        || (succ x1 == x2 && upOrDown)\n        || (leftOrRight && y1 == y2)\n\nfen :: Square -> String\nfen (ChessPiece King   Black) = \"k\"\nfen (ChessPiece Queen  Black) = \"q\"\nfen (ChessPiece Rook   Black) = \"r\"\nfen (ChessPiece Bishop Black) = \"b\"\nfen (ChessPiece Knight Black) = \"n\"\nfen (ChessPiece Pawn   Black) = \"p\"\nfen (ChessPiece King   White) = \"K\"\nfen (ChessPiece Queen  White) = \"Q\"\nfen (ChessPiece Rook   White) = \"R\"\nfen (ChessPiece Bishop White) = \"B\"\nfen (ChessPiece Knight White) = \"N\"\nfen (ChessPiece Pawn   White) = \"P\"\n\nboardSort :: (Square, Pos) -> (Square, Pos) -> Ordering\nboardSort (_, (x1, y1)) (_, (x2, y2)) | y1 < y2  = GT\n                                      | y1 > y2  = LT\n                                      | y1 == y2 = compare x1 x2\n\ntoFen :: ChessBoard -> String\ntoFen [] = \" w - - 0 1\" <> []\ntoFen b = scanRow (fst <$> take 8 b) 0\n  where\n    scanRow [] 0               = nextRow\n    scanRow [] n               = show n <> nextRow\n    scanRow (EmptySquare:xs) n = scanRow xs (succ n)\n    scanRow (x:xs) 0           = nextPiece x xs\n    scanRow (x:xs) n           = show n <> nextPiece x xs\n    nextRow = \"/\" <> toFen (drop 8 b)\n    nextPiece x xs = fen x <> scanRow xs 0\n\n\nwithStateGen :: (StdGen -> (a, StdGen)) -> State BoardState a\nwithStateGen f = do\n  currentState <- get\n  let gen1 = generator currentState\n  let (x, gen2) = f gen1\n  put (currentState {generator = gen2})\n  pure x\n\nrandomPos :: State BoardState Pos\nrandomPos = do\n  boardState <- gets board\n  chr <- withStateGen (randomR ('a', 'h'))\n  num <- withStateGen (randomR (1, 8))\n  let pos = (chr, num)\n  if isPosOccupied pos boardState then\n    randomPos\n  else\n    pure pos\n\nrandomPiece :: State BoardState Square\nrandomPiece = ChessPiece <$> withStateGen random <*> withStateGen random\n\nplaceKings :: State BoardState ()\nplaceKings = do\n  currentState <- get\n  p1 <- randomPos\n  p2 <- randomPos\n  if p1 `isAdjacent` p2 || p1 == p2\n    then placeKings\n    else do\n      let updatedBoard = replaceSquareByPos (ChessPiece King White, p1) $\n            replaceSquareByPos (ChessPiece King Black, p2) (board currentState)\n      put currentState { board = updatedBoard }\n\nplacePawns :: State BoardState ()\nplacePawns = withStateGen (randomR (1, 16)) >>= go\n  where\n    go :: Int -> State BoardState ()\n    go 0 = pure ()\n    go n = do\n      currentState <- get\n      pos <- randomPos\n      color <- withStateGen random\n      let pawn = ChessPiece Pawn color\n      let currentBoard = board currentState\n      if promoted color == snd pos || isPosOccupied pos currentBoard ||\n                           enpassant color == snd pos || firstPos color == snd pos\n        then go n\n        else do\n          put currentState { board = replaceSquareByPos (pawn, pos) currentBoard }\n          go $ pred n\n    promoted White = 8\n    promoted Black = 1\n    enpassant White = 5\n    enpassant Black = 4\n    firstPos White = 1\n    firstPos Black = 8\n\nplaceRemaining :: State BoardState ()\nplaceRemaining =\n  withStateGen (randomR (5, sum $ fmap snd remaining)) >>= go remaining\n  where\n    remaining = filter (\\case\n                         (ChessPiece King _, _) -> False\n                         (ChessPiece Pawn _, _) -> False\n                         (EmptySquare, _) -> False\n                         _ -> True)\n                        fullBoard\n\n    go :: PieceCount -> Int -> State BoardState ()\n    go _ 0 = pure ()\n    go remaining n = do\n      currentState <- get\n      let currentBoard = board currentState\n      position <- randomPos\n      piece <- randomPiece\n      if not (isPermitted piece) || isPosOccupied position currentBoard\n        then go remaining n\n        else do\n          let updatedBoard = replaceSquareByPos (piece, position) currentBoard\n          put currentState { board = updatedBoard }\n          go (consume piece remaining) (pred n)\n      where\n        isPermitted p =\n          case find ((==p) . fst) remaining of\n            Just (_, count) -> count > 0\n            Nothing         -> False\n        consume p'' = fmap (\\(p, c) -> if p == p'' then (p, pred c) else (p, c))\n\ngetBoard :: State BoardState ChessBoard\ngetBoard = gets (sortBy boardSort . board)\n", "target": "import random\n\nboard = [[\" \" for x in range(8)] for y in range(8)]\npiece_list = [\"R\", \"N\", \"B\", \"Q\", \"P\"]\n\n\ndef place_kings(brd):\n\twhile True:\n\t\trank_white, file_white, rank_black, file_black = random.randint(0,7), random.randint(0,7), random.randint(0,7), random.randint(0,7)\n\t\tdiff_list = [abs(rank_white - rank_black),  abs(file_white - file_black)]\n\t\tif sum(diff_list) > 2 or set(diff_list) == set([0, 2]):\n\t\t\tbrd[rank_white][file_white], brd[rank_black][file_black] = \"K\", \"k\"\n\t\t\tbreak\n\ndef populate_board(brd, wp, bp):\n\tfor x in range(2):\n\t\tif x == 0:\n\t\t\tpiece_amount = wp\n\t\t\tpieces = piece_list\n\t\telse:\n\t\t\tpiece_amount = bp\n\t\t\tpieces = [s.lower() for s in piece_list]\n\t\twhile piece_amount != 0:\n\t\t\tpiece_rank, piece_file = random.randint(0, 7), random.randint(0, 7)\n\t\t\tpiece = random.choice(pieces)\n\t\t\tif brd[piece_rank][piece_file] == \" \" and pawn_on_promotion_square(piece, piece_rank) == False:\n\t\t\t\tbrd[piece_rank][piece_file] = piece\n\t\t\t\tpiece_amount -= 1\n\ndef fen_from_board(brd):\n\tfen = \"\"\n\tfor x in brd:\n\t\tn = 0\n\t\tfor y in x:\n\t\t\tif y == \" \":\n\t\t\t\tn += 1\n\t\t\telse:\n\t\t\t\tif n != 0:\n\t\t\t\t\tfen += str(n)\n\t\t\t\tfen += y\n\t\t\t\tn = 0\n\t\tif n != 0:\n\t\t\tfen += str(n)\n\t\tfen += \"/\" if fen.count(\"/\") < 7 else \"\"\n\tfen += \" w - - 0 1\\n\"\n\treturn fen\n\ndef pawn_on_promotion_square(pc, pr):\n\tif pc == \"P\" and pr == 0:\n\t\treturn True\n\telif pc == \"p\" and pr == 7:\n\t\treturn True\n\treturn False\n\n\ndef start():\n\tpiece_amount_white, piece_amount_black = random.randint(0, 15), random.randint(0, 15)\n\tplace_kings(board)\n\tpopulate_board(board, piece_amount_white, piece_amount_black)\n\tprint(fen_from_board(board))\n\tfor x in board:\n\t\tprint(x)\n\n\nstart()\n"}
{"id": 418911, "name": "Numbers which are the cube roots of the product of their proper divisors", "source": "Translate Haskell to Python: import Data.List (group, intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes ( primeFactors )\nimport Text.Printf (printf)\n\n\n\n\noeisA111398 :: [Integer]\noeisA111398 = 1 : [n | n <- [1..], 8 == length (divisors n)]\n\n\ndivisors :: Integer -> [Integer]\ndivisors =\n  foldr\n    (flip ((<*>) . fmap (*)) . scanl (*) 1)\n    [1]\n    . group\n    . primeFactors\n    \n\n\n\nmain :: IO ()\nmain = do\n  putStrLn $ table \"   \" $ chunksOf 10 $\n    take 50 (show <$> oeisA111398)\n   \n  mapM_ print $ \n   (,) <*> ((oeisA111398 !!) . pred) <$> [500, 5000, 50000]\n  \n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "\n\nfrom functools import reduce\nfrom sympy import divisors\n\n\nFOUND = 0\nfor num in range(1, 1_000_000):\n    divprod = reduce(lambda x, y: x * y, divisors(num)[:-1])if num > 1 else 1\n    if num * num * num == divprod:\n        FOUND += 1\n        if FOUND <= 50:\n            print(f'{num:5}', end='\\n' if FOUND % 10 == 0 else '')\n        if FOUND == 500:\n            print(f'\\nFive hundreth: {num:,}')\n        if FOUND == 5000:\n            print(f'\\nFive thousandth: {num:,}')\n        if FOUND == 50000:\n            print(f'\\nFifty thousandth: {num:,}')\n            break\n"}
{"id": 418912, "name": "Arithmetic derivative", "source": "Translate Haskell to Python: import Control.Monad (forM_)\nimport Data.List (intercalate)\nimport Data.List.Split (chunksOf)\nimport Math.NumberTheory.Primes (factorise, unPrime)\nimport Text.Printf (printf)\n\n\narithderiv_ :: Integer -> Integer\narithderiv_ 0 = 0\narithderiv_ n = foldr step 0 $ factorise n\n  where step (p, v) s = s + n `quot` unPrime p * fromIntegral v\n\n\narithderiv :: Integer -> Integer\narithderiv n | n < 0     = negate $ arithderiv_ (negate n)\n             | otherwise = arithderiv_ n\n\nprintTable :: [Integer] -> IO ()\nprintTable = putStrLn\n           . intercalate \"\\n\"\n           . map unwords\n           . chunksOf 10\n           . map (printf \"%5d\")\n\nmain :: IO ()\nmain = do\n  printTable [arithderiv n | n <- [-99..100]]\n  putStrLn \"\"\n  forM_ [1..20 :: Integer] $ \\i ->\n    let q = 7\n        n = arithderiv (10^i) `quot` q\n    in printf \"D(10^%-2d) / %d = %d\\n\" i q n\n", "target": "from sympy.ntheory import factorint\n\ndef D(n):\n    if n < 0:\n        return -D(-n)\n    elif n < 2:\n        return 0\n    else:\n        fdict = factorint(n)\n        if len(fdict) == 1 and 1 in fdict: \n            return 1\n        return sum([n * e // p for p, e in fdict.items()])\n\nfor n in range(-99, 101):\n    print('{:5}'.format(D(n)), end='\\n' if n % 10 == 0 else '')\n\nprint()\nfor m in range(1, 21):\n    print('(D for 10**{}) divided by 7 is {}'.format(m, D(10 ** m) // 7))\n"}
{"id": 418913, "name": "Product of min and max prime factors", "source": "Translate Haskell to Python: import Data.List (intercalate, transpose)\nimport Data.List.Split (chunksOf)\nimport Data.Numbers.Primes (primeFactors)\nimport Text.Printf (printf)\n\n\n\noeisA066048 :: [Integer]\noeisA066048 = 1 : fmap f [2 ..]\n  where\n    f = ((*) . head <*> last) . primeFactors\n\n\nmain :: IO ()\nmain = putStrLn $ \n  table \"  \" $ (chunksOf 10 . take 100) $ \n    fmap show oeisA066048\n\n\n\ntable :: String -> [[String]] -> String\ntable gap rows =\n  let ws = maximum . fmap length <$> transpose rows\n      pw = printf . flip intercalate [\"%\", \"s\"] . show\n   in unlines $ intercalate gap . zipWith pw ws <$> rows\n", "target": "\n\n\nfrom sympy import factorint\n\nNUM_WANTED = 100\n\nfor num in range(1, NUM_WANTED + 1):\n    fac = factorint(num, multiple=True)\n    product = fac[0] * fac[-1] if len(fac) > 0 else 1\n    print(f'{product:5}', end='\\n' if num % 10 == 0 else '')\n"}
{"id": 418914, "name": "Tropical algebra overloading", "source": "Translate Haskell to Python: \n\nimport Prelude hiding ((^))\nimport Data.Monoid (Sum(Sum))\nimport Data.Number.CReal (CReal)\nimport Data.Semiring (Semiring, (^), plus, times)\nimport Data.Semiring.Tropical (Tropical(..), Extrema(Maxima))\n\n\n\n\n\n\n\n\n\nnewtype MaxPlus = MaxPlus (Tropical 'Maxima CReal)\n\n\n\n(\u2295), (\u2297) :: MaxPlus -> MaxPlus -> MaxPlus\n(\u2295) = plus\n(\u2297) = times\n\ninfixl 6 \u2295\ninfixl 7 \u2297\n\n(\u2191) :: Integral a => MaxPlus -> a -> MaxPlus\n(\u2191) = (^)\n\ninfixr 8 \u2191\n\nmain :: IO ()\nmain = do\n  \n  test \"2 \u2297 (-2) == 0\"           (2 \u2297 (-2))                  0\n  test \"-0.001 \u2295 -Inf == -0.001\" (-0.001 \u2295 MaxPlus Infinity) (-0.001)\n  test \"0 \u2297 -Inf == -Inf\"        (0 \u2297 MaxPlus Infinity)      (MaxPlus Infinity)\n  test \"1.5 \u2295 -1 == 1.5\"         (1.5 \u2295 (-1))                1.5\n  test \"-0.5 \u2297 0 == -0.5\"        ((-0.5) \u2297 0)                (-0.5)\n  test \"5 \u2191 7 == 35\"             (5 \u2191 7)                     35\n  test \"5 \u2297 (8 \u2295 7) == 13\"       (5 \u2297 (8 \u2295 7))               13\n  test \"5 \u2297 8 \u2295 5 \u2297 7 == 13\"     (5 \u2297 8 \u2295 5 \u2297 7)             13\n\n\n\n\n\n\n\nderiving via (Sum CReal) instance Semigroup CReal\nderiving via (Sum CReal) instance Monoid CReal\nderiving via Tropical 'Maxima CReal instance Semiring MaxPlus\nderiving via Tropical 'Maxima CReal instance Eq MaxPlus\nderiving via Tropical 'Maxima CReal instance Ord MaxPlus\n\n\n\n\ninstance Num MaxPlus where\n  (+) = plus\n  (*) = times\n  abs = opError \"absolute value\"\n  signum (MaxPlus Infinity) = -1\n  signum x = wrap . signum . unwrap $ x\n  fromInteger = wrap . fromInteger\n  negate (MaxPlus Infinity) = opError \"negation of -Inf\"\n  negate x = wrap . negate . unwrap $ x\n\n\n\ninstance Fractional MaxPlus where\n  fromRational = wrap . fromRational\n  recip _ = opError \"reciprocal\"\n\ninstance Show MaxPlus where\n  show (MaxPlus Infinity) = \"-Inf\"\n  show x = show . unwrap $ x\n\n\ntest :: String -> MaxPlus -> MaxPlus -> IO ()\ntest s actual expected = do\n  putStr $ \"Expecting \" ++ s ++ \".  Got \" ++ show actual ++ \" \"\n  putStrLn $ if actual == expected then \"\u2714\" else \"\u2718\"\n\n\n\nwrap :: CReal -> MaxPlus\nwrap = MaxPlus . Tropical\n\nunwrap :: MaxPlus -> CReal\nunwrap (MaxPlus (Tropical x)) = x\nunwrap (MaxPlus Infinity) = error \"can't convert -Inf to a CReal\"\n\nopError :: String -> a\nopError op = error $ op ++ \" is not defined on a max-plus semiring\"\n", "target": "from numpy import Inf\n\nclass MaxTropical:\n    \n    def __init__(self, x=0):\n        self.x = x\n\n    def __str__(self):\n        return str(self.x)\n\n    def __add__(self, other):\n        return MaxTropical(max(self.x, other.x))\n\n    def __mul__(self, other):\n        return MaxTropical(self.x + other.x)\n\n    def __pow__(self, other):\n        assert other.x // 1 == other.x and other.x > 0, \"Invalid Operation\" \n        return MaxTropical(self.x * other.x)\n\n    def __eq__(self, other):\n        return self.x == other.x\n\n\nif __name__ == \"__main__\":\n    a = MaxTropical(-2)\n    b = MaxTropical(-1)\n    c = MaxTropical(-0.5)\n    d = MaxTropical(-0.001)\n    e = MaxTropical(0)\n    f = MaxTropical(0.5)\n    g = MaxTropical(1)\n    h = MaxTropical(1.5)\n    i = MaxTropical(2)\n    j = MaxTropical(5)\n    k = MaxTropical(7)\n    l = MaxTropical(8)\n    m = MaxTropical(-Inf)\n\n    print(\"2 * -2 == \", i * a)\n    print(\"-0.001 + -Inf == \", d + m)\n    print(\"0 * -Inf == \", e * m)\n    print(\"1.5 + -1 == \", h + b)\n    print(\"-0.5 * 0 == \", c * e)\n    print(\"5**7 == \", j**k)\n    print(\"5 * (8 + 7)) == \", j * (l + k))\n    print(\"5 * 8 + 5 * 7 == \", j * l + j * k)\n    print(\"5 * (8 + 7) == 5 * 8 + 5 * 7\", j * (l + k) == j * l + j * k)\n"}
{"id": 418915, "name": "Permutations with some identical elements", "source": "Translate Haskell to Python: permutationsSomeIdentical :: [(a, Int)] -> [[a]]\npermutationsSomeIdentical [] = [[]]\npermutationsSomeIdentical xs =\n  [ x : ys\n    | (x, xs_) <- select xs,\n      ys <- permutationsSomeIdentical xs_\n  ]\n  where\n    select [] = []\n    select ((x, n) : xs) =\n      (x, xs_) :\n        [ (y, (x, n) : cs)\n          | (y, cs) <- select xs\n        ]\n      where\n        xs_\n          | 1 == n = xs\n          | otherwise = (x, pred n) : xs\n\n\nmain :: IO ()\nmain = do\n  print $ permutationsSomeIdentical [(1, 2), (2, 1)]\n  print $ permutationsSomeIdentical [(1, 2), (2, 3), (3, 1)]\n  print $ permutationsSomeIdentical [('A', 2), ('B', 3), ('C', 1)]\n", "target": "\n\nfrom itertools import permutations\n\nnumList = [2,3,1]\n\nbaseList = []\n\nfor i in numList:\n    for j in range(0,i):\n        baseList.append(i)\n\nstringDict = {'A':2,'B':3,'C':1}\n\nbaseString=\"\"\n\nfor i in stringDict:\n    for j in range(0,stringDict[i]):\n        baseString+=i\n\nprint(\"Permutations for \" + str(baseList) + \"\u00a0: \")\n[print(i) for i in set(permutations(baseList))]\n\nprint(\"Permutations for \" + baseString + \"\u00a0: \")\n[print(i) for i in set(permutations(baseString))]\n"}
{"id": 418916, "name": "Pisano period", "source": "Translate Haskell to Python: import qualified Data.Text as T\n\nmain = do\n  putStrLn \"PisanoPrime(p,2) for prime p lower than 15\"\n  putStrLn . see 15 . map (`pisanoPrime` 2) . filter isPrime $ [1 .. 15]\n  putStrLn \"PisanoPrime(p,1) for prime p lower than 180\"\n  putStrLn . see 15 . map (`pisanoPrime` 1) . filter isPrime $ [1 .. 180]\n  let ns = [1 .. 180] :: [Int]\n  let xs = map pisanoPeriod ns\n  let ys = map pisano ns\n  let zs = map pisanoConjecture ns\n  putStrLn \"Pisano(m) for m from 1 to 180\"\n  putStrLn . see 15 $ map pisano [1 .. 180]\n  putStrLn $\n    \"map pisanoPeriod [1..180] == map pisano [1..180] = \" ++ show (xs == ys)\n  putStrLn $\n    \"map pisanoPeriod [1..180] == map pisanoConjecture [1..180] = \" ++\n    show (ys == zs)\n\nbagOf :: Int -> [a] -> [[a]]\nbagOf _ [] = []\nbagOf n xs =\n  let (us, vs) = splitAt n xs\n  in us : bagOf n vs\n\nsee\n  :: Show a\n  => Int -> [a] -> String\nsee n =\n  unlines .\n  map unwords . bagOf n . map (T.unpack . T.justifyRight 3 ' ' . T.pack . show)\n\nfibMod\n  :: Integral a\n  => a -> [a]\nfibMod 1 = repeat 0\nfibMod n = fib\n  where\n    fib = 0 : 1 : zipWith (\\x y -> rem (x + y) n) fib (tail fib)\n\npisanoPeriod\n  :: Integral a\n  => a -> a\npisanoPeriod m\n  | m <= 0 = 0\npisanoPeriod 1 = 1\npisanoPeriod m = go 1 (tail $ fibMod m)\n  where\n    go t (0:1:_) = t\n    go t (_:xs) = go (succ t) xs\n\npowMod\n  :: Integral a\n  => a -> a -> a -> a\npowMod _ _ k\n  | k < 0 = error \"negative power\"\npowMod m _ _\n  | 1 == abs m = 0\npowMod m p k\n  | 1 == abs p = mod v m\n  where\n    v\n      | 1 == p || even k = 1\n      | otherwise = p\npowMod m p k = go p k\n  where\n    to x y = mod (x * y) m\n    go _ 0 = 1\n    go u 1 = mod u m\n    go u i\n      | even i = to w w\n      | otherwise = to u (to w w)\n      where\n        w = go u (quot i 2)\n\n\nprobablyPrime\n  :: Integral a\n  => a -> Bool\nprobablyPrime p\n  | p < 2 || even p = 2 == p\n  | otherwise = 1 == powMod p 2 (p - 1)\n\nprimes\n  :: Integral a\n  => [a]\nprimes =\n  2 :\n  3 :\n  5 :\n  7 :\n  [ p\n  | p <- [11,13 ..] \n  , isPrime p ]\n\nlimitDivisor\n  :: Integral a\n  => a -> a\nlimitDivisor = floor . (+ 0.05) . sqrt . fromIntegral\n\nisPrime\n  :: Integral a\n  => a -> Bool\nisPrime p\n  | not $ probablyPrime p = False\nisPrime p = go primes\n  where\n    stop = limitDivisor p\n    go (n:_)\n      | stop < n = True\n    go (n:ns) = (0 /= rem p n) && go ns\n    go [] = True\n\nfactor\n  :: Integral a\n  => a -> [(a, a)]\nfactor n\n  | n <= 1 = []\nfactor n = go n primes\n  where\n    fun x d c\n      | 0 /= rem x d = (x, c)\n      | otherwise = fun (quot x d) d (succ c)\n    go 1 _ = []\n    go _ [] = []\n    go x (d:ds)\n      | 0 /= rem x d = go x $ dropWhile ((0 /=) . rem x) ds\n    go x (d:ds) =\n      let (u, c) = fun (quot x d) d 1\n      in (d, c) : go u ds\n\npisanoPrime\n  :: Integral a\n  => a -> a -> a\npisanoPrime p k\n  | p <= 0 || k < 0 = 0\npisanoPrime p k = pisanoPeriod $ p ^ k\n\npisano\n  :: Integral a\n  => a -> a\npisano m\n  | m < 1 = 0\npisano 1 = 1\npisano m = foldl1 lcm . map (uncurry pisanoPrime) $ factor m\n\npisanoConjecture\n  :: Integral a\n  => a -> a\npisanoConjecture m\n  | m < 1 = 0\npisanoConjecture 1 = 1\npisanoConjecture m = foldl1 lcm . map (uncurry pisanoPrime') $ factor m\n  where\n    pisanoPrime' p k = (p ^ (k - 1)) * pisanoPeriod p\n", "target": "from sympy import isprime, lcm, factorint, primerange\nfrom functools import reduce\n\n\ndef pisano1(m):\n    \"Simple definition\"\n    if m < 2:\n        return 1\n    lastn, n = 0, 1\n    for i in range(m ** 2):\n        lastn, n = n, (lastn + n) % m\n        if lastn == 0 and n == 1:\n            return i + 1\n    return 1\n\ndef pisanoprime(p, k):\n    \"Use conjecture \u03c0(p ** k) == p ** (k \u2212 1) * \u03c0(p) for prime p and int k > 1\"\n    assert isprime(p) and k > 0\n    return p ** (k - 1) * pisano1(p)\n\ndef pisano_mult(m, n):\n    \"pisano(m*n) where m and n assumed coprime integers\"\n    return lcm(pisano1(m), pisano1(n))\n\ndef pisano2(m):\n    \"Uses prime factorization of m\"\n    return reduce(lcm, (pisanoprime(prime, mult)\n                        for prime, mult in factorint(m).items()), 1)\n\n\nif __name__ == '__main__':\n    for n in range(1, 181):\n        assert pisano1(n) == pisano2(n), \"Wall-Sun-Sun prime exists??!!\"\n    print(\"\\nPisano period (p, 2) for primes less than 50\\n \",\n          [pisanoprime(prime, 2) for prime in primerange(1, 50)])\n    print(\"\\nPisano period (p, 1) for primes less than 180\\n \",\n          [pisanoprime(prime, 1) for prime in primerange(1, 180)])\n    print(\"\\nPisano period (p) for integers 1 to 180\")\n    for i in range(1, 181):\n        print(\" %3d\" % pisano2(i), end=\"\" if i % 10 else \"\\n\")\n"}
{"id": 418917, "name": "Minkowski question-mark function", "source": "Translate Haskell to Python: import Data.Tree\nimport Data.Ratio\nimport Data.List\n\nintervalTree :: (a -> a -> a) -> (a, a) -> Tree a\nintervalTree node = unfoldTree $\n  \\(a, b) -> let m = node a b in (m, [(a,m), (m,b)])\n\nNode a _ ==> Node b [] = const b\nNode a [] ==> Node b _ = const b\nNode a [l1, r1] ==> Node b [l2, r2] =\n  \\x -> case x `compare` a of\n          LT -> (l1 ==> l2) x\n          EQ -> b\n          GT -> (r1 ==> r2) x\n\nmirror :: Num a => Tree a -> Tree a\nmirror t = Node 0 [reflect (negate <$> t), t]\n  where\n    reflect (Node a [l,r]) = Node a [reflect r, reflect l]\n\n\n\nsternBrocot :: Tree Rational\nsternBrocot = toRatio <$> intervalTree mediant ((0,1), (1,0))\n  where\n    mediant (p, q) (r, s) = (p + r, q + s)\n\ntoRatio (p, q) = p % q\n\nminkowski :: Tree Rational\nminkowski = toRatio <$> intervalTree mean ((0,1), (1,0))\n\nmean (p, q) (1, 0) = (p+1, q)\nmean (p, q) (r, s) = (p*s + q*r, 2*q*s)\n\n\nquestionMark, invQuestionMark :: Rational -> Rational\nquestionMark    = mirror sternBrocot ==> mirror minkowski\ninvQuestionMark = mirror minkowski ==> mirror sternBrocot\n\n\n\n\nsternBrocotF :: Tree Double\nsternBrocotF = mirror $ fromRational <$> sternBrocot\n\nminkowskiF :: Tree Double\nminkowskiF = mirror $ intervalTree mean (0, 1/0)\n  where\n    mean a b | isInfinite b = a + 1\n             | otherwise = (a + b) / 2\n\nquestionMarkF, invQuestionMarkF :: Double -> Double\nquestionMarkF = sternBrocotF ==> minkowskiF\ninvQuestionMarkF = minkowskiF ==> sternBrocotF\n", "target": "    print(\n        \"{:19.16f} {:19.16f}\".format(\n            minkowski(minkowski_inv(4.04145188432738056)),\n            minkowski_inv(minkowski(4.04145188432738056)),\n        )\n    )\n"}
{"id": 418918, "name": "Addition-chain exponentiation", "source": "Translate Haskell to Python: dichotomicChain :: Integral a => a -> [a]\ndichotomicChain n\n  | n == 3  = [3, 2, 1]\n  | n == 2 ^ log2 n = takeWhile (> 0) $ iterate (`div` 2) n\n  | otherwise = let k = n `div` (2 ^ ((log2 n + 1) `div` 2))\n                in chain n k\n  where\n    chain n1 n2 \n      | n2 <= 1 = dichotomicChain n1\n      | otherwise = case n1 `divMod` n2 of\n          (q, 0) -> dichotomicChain q `mul` dichotomicChain n2\n          (q, r) -> [r] `add` (dichotomicChain q `mul` chain n2 r)\n\n    c1 `mul` c2 = map (head c2 *) c1 ++ tail c2\n    c1 `add` c2 = map (head c2 +) c1 ++ c2\n \n    log2 = floor . logBase 2 . fromIntegral\n\nbinaryChain :: Integral a => a -> [a]\nbinaryChain 1 = [1]\nbinaryChain n | even n = n : binaryChain (n `div` 2)\n              | odd n = n : binaryChain (n - 1)\n", "target": "\n\nfrom math import sqrt\nfrom numpy import array\nfrom mpmath import mpf\n\n\nclass AdditionChains:\n    \n\n    def __init__(self):\n        \n        self.chains, self.idx, self.pos = [[1]], 0, 0\n        self.pat, self.lvl = {1: 0}, [[1]]\n\n    def add_chain(self):\n        \n        newchain = self.chains[self.idx].copy()\n        newchain.append(self.chains[self.idx][-1] +\n                        self.chains[self.idx][self.pos])\n        self.chains.append(newchain)\n        if self.pos == len(self.chains[self.idx])-1:\n            self.idx += 1\n            self.pos = 0\n        else:\n            self.pos += 1\n        return newchain\n\n    def find_chain(self, nexp):\n        \n        assert nexp > 0\n        if nexp == 1:\n            return [1]\n        chn = next((a for a in self.chains if a[-1] == nexp), None)\n        if chn is None:\n            while True:\n                chn = self.add_chain()\n                if chn[-1] == nexp:\n                    break\n\n        return chn\n\n    def knuth_path(self, ngoal):\n        \n        if ngoal < 1:\n            return []\n        while not ngoal in self.pat:\n            new_lvl = []\n            for i in self.lvl[0]:\n                for j in self.knuth_path(i):\n                    if not i + j in self.pat:\n                        self.pat[i + j] = i\n                        new_lvl.append(i + j)\n\n            self.lvl[0] = new_lvl\n\n        returnpath = self.knuth_path(self.pat[ngoal])\n        returnpath.append(ngoal)\n        return returnpath\n\n\ndef cpow(xbase, chain):\n    \n    pows, products = 0, {0: 1, 1: xbase}\n    for i in chain:\n        products[i] = products[pows] * products[i - pows]\n        pows = i\n    return products[chain[-1]]\n\n\nif __name__ == '__main__':\n    \n    acs = AdditionChains()\n    print('First one hundred addition chain lengths:')\n    for k in range(1, 101):\n        print(f'{len(acs.find_chain(k))-1:3}', end='\\n'if k % 10 == 0 else '')\n\n    print('\\nKnuth chains for addition chains of 31415 and 27182:')\n    chns = {m: acs.knuth_path(m) for m in [31415, 27182]}\n    for (num, cha) in chns.items():\n        print(f'Exponent: {num:10}\\n  Addition Chain: {cha[:-1]}')\n    print('\\n1.00002206445416^31415 =', cpow(1.00002206445416, chns[31415]))\n    print('1.00002550055251^27182 =', cpow(1.00002550055251, chns[27182]))\n    print('1.000025 + 0.000058i)^27182 =',\n          cpow(complex(1.000025, 0.000058), chns[27182]))\n    print('1.000022 + 0.000050i)^31415 =',\n          cpow(complex(1.000022, 0.000050), chns[31415]))\n    sq05 = mpf(sqrt(0.5))\n    mat = array([[sq05, 0, sq05, 0, 0, 0], [0, sq05, 0, sq05, 0, 0], [0, sq05, 0, -sq05, 0, 0],\n                 [-sq05, 0, sq05, 0, 0, 0], [0, 0, 0, 0, 0, 1], [0, 0, 0, 0, 1, 0]])\n    print('matrix A ^ 27182 =')\n    print(cpow(mat, chns[27182]))\n    print('matrix A ^ 31415 =')\n    print(cpow(mat, chns[31415]))\n    print('(matrix A ** 27182) ** 31415 =')\n    print(cpow(cpow(mat, chns[27182]), chns[31415]))\n"}
{"id": 418919, "name": "Four is the number of letters in the ...", "source": "Translate Haskell to Python: import Data.Char\n\nsentence = start ++ foldMap add (zip [2..] $ tail $ words sentence)\n  where\n    start = \"Four is the number of letters in the first word of this sentence, \"\n    add (i, w) = unwords [spellInteger (alphaLength w), \"in the\", spellOrdinal i ++ \", \"]\n\nalphaLength w = fromIntegral $ length $ filter isAlpha w\n\nmain = mapM_ (putStrLn . say) [1000,10000,100000,1000000]\n  where\n    ws = words sentence\n    say n =\n      let (a, w:_) = splitAt (n-1) ws\n      in \"The \" ++ spellOrdinal n ++ \" word is \\\"\" ++ w ++ \"\\\" which has \" ++\n         spellInteger (alphaLength  w) ++ \" letters. The sentence length is \" ++\n         show (length $ unwords a) ++ \" chars.\"\n", "target": "\n\n\n\n\nimport inflect\n\ndef count_letters(word):\n    \n    count = 0\n    for letter in word:\n        if letter != ',' and letter !='-' and letter !=' ':\n            count += 1\n            \n    return count\n    \ndef split_with_spaces(sentence):\n    \n    sentence_list = []\n    curr_word = \"\"\n    for c in sentence:\n        if c == \" \" and curr_word != \"\":\n            \n            \n            sentence_list.append(curr_word+\" \")\n            curr_word = \"\"\n        else:\n            curr_word += c\n    \n    \n    \n    if len(curr_word) > 0:\n        sentence_list.append(curr_word)\n    \n    return sentence_list\n    \ndef my_num_to_words(p, my_number):\n    \n    \n    number_string_list = p.number_to_words(my_number, wantlist=True, andword='')\n    \n    number_string = number_string_list[0]\n    \n    for i in range(1,len(number_string_list)):\n        number_string += \" \" + number_string_list[i]\n    \n    return number_string\n        \ndef build_sentence(p, max_words):\n    \n    \n    \n    \n    sentence_list = split_with_spaces(\"Four is the number of letters in the first word of this sentence,\")\n      \n    num_words = 13\n    \n    \n    \n    \n    word_number = 2\n    \n    \n    \n    while num_words < max_words:\n        \n        \n        \n        \n        \n        ordinal_string = my_num_to_words(p, p.ordinal(word_number))\n        \n        \n        \n        word_number_string = my_num_to_words(p, count_letters(sentence_list[word_number - 1]))\n        \n        \n        \n        new_string = \" \"+word_number_string+\" in the \"+ordinal_string+\",\"\n\n        new_list = split_with_spaces(new_string)\n        \n        sentence_list += new_list\n\n        \n        \n        num_words += len(new_list)\n        \n        \n        \n        word_number += 1\n        \n    return sentence_list, num_words\n    \ndef word_and_counts(word_num):\n    \n        \n    sentence_list, num_words = build_sentence(p, word_num)\n    \n    word_str = sentence_list[word_num - 1].strip(' ,')\n    \n    num_letters = len(word_str)\n    \n    num_characters = 0\n    \n    for word in sentence_list:\n       num_characters += len(word)\n       \n    print('Word {0:8d} is \"{1}\", with {2} letters.  Length of the sentence so far: {3}  '.format(word_num,word_str,num_letters,num_characters))\n   \n    \np = inflect.engine()\n\nsentence_list, num_words = build_sentence(p, 201)\n\nprint(\" \")\nprint(\"The lengths of the first 201 words are:\")\nprint(\" \")\n\nprint('{0:3d}:  '.format(1),end='')\n\ntotal_characters = 0\n\nfor word_index in range(201):\n\n    word_length = count_letters(sentence_list[word_index])\n    \n    total_characters += len(sentence_list[word_index])\n    \n    print('{0:2d}'.format(word_length),end='')\n    if (word_index+1) % 20 == 0:\n        \n        print(\" \")\n        print('{0:3d}:  '.format(word_index + 2),end='')\n    else:\n        print(\" \",end='')\n \nprint(\" \")\nprint(\" \")\nprint(\"Length of the sentence so far: \"+str(total_characters))\nprint(\" \")\n\n\n\nword_and_counts(1000)\nword_and_counts(10000)\nword_and_counts(100000)\nword_and_counts(1000000)\nword_and_counts(10000000)\n"}
{"id": 418920, "name": "Wordle comparison", "source": "Translate Haskell to Python: import Data.Bifunctor (first)\nimport Data.List (intercalate, mapAccumL)\nimport qualified Data.Map.Strict as M\nimport Data.Maybe (fromMaybe)\n\ntype Tally = M.Map Char Int\n\n\n\nwordleScore :: String -> String -> [Int]\nwordleScore target guess =\n  snd $\n    uncurry (mapAccumL amber) $\n      first charCounts $\n        mapAccumL green [] (zip target guess)\n\ngreen :: String -> (Char, Char) -> (String, (Char, Int))\ngreen residue (t, g)\n  | t == g = (residue, (g, 2))\n  | otherwise = (t : residue, (g, 0))\n\namber :: Tally -> (Char, Int) -> (Tally, Int)\namber tally (_, 2) = (tally, 2)\namber tally (c, _)\n  | 0 < fromMaybe 0 (M.lookup c tally) =\n      (M.adjust pred c tally, 1)\n  | otherwise = (tally, 0)\n\ncharCounts :: String -> Tally\ncharCounts =\n  foldr\n    (flip (M.insertWith (+)) 1)\n    M.empty\n\n\nmain :: IO ()\nmain = do\n  putStrLn $ intercalate \" -> \" [\"Target\", \"Guess\", \"Scores\"]\n  putStrLn []\n  mapM_ (either putStrLn putStrLn) $\n    uncurry wordleReport\n      <$> [ (\"ALLOW\", \"LOLLY\"),\n            (\"CHANT\", \"LATTE\"),\n            (\"ROBIN\", \"ALERT\"),\n            (\"ROBIN\", \"SONIC\"),\n            (\"ROBIN\", \"ROBIN\"),\n            (\"BULLY\", \"LOLLY\"),\n            (\"ADAPT\", \"S\u00c5L\u00c5D\"),\n            (\"Ukraine\", \"Ukra\u00edne\"),\n            (\"BBAAB\", \"BBBBBAA\"),\n            (\"BBAABBB\", \"AABBBAA\")\n          ]\n\nwordleReport :: String -> String -> Either String String\nwordleReport target guess\n  | 5 /= length target =\n      Left (target <> \": Expected 5 character target.\")\n  | 5 /= length guess =\n      Left (guess <> \": Expected 5 character guess.\")\n  | otherwise =\n      let scores = wordleScore target guess\n       in Right\n            ( intercalate\n                \" -> \"\n                [ target,\n                  guess,\n                  show scores,\n                  unwords (color <$> scores)\n                ]\n            )\n\ncolor 2 = \"green\"\ncolor 1 = \"amber\"\ncolor _ = \"gray\"\n", "target": "\n\nfrom functools import reduce\nfrom operator import add\n\n\n\ndef wordleScore(target, guess):\n    \n    return mapAccumL(amber)(\n        *first(charCounts)(\n            mapAccumL(green)(\n                [], zip(target, guess)\n            )\n        )\n    )[1]\n\n\n\ndef green(residue, tg):\n    \n    t, g = tg\n    return (residue, (g, 2)) if t == g else (\n        [t] + residue, (g, 0)\n    )\n\n\n\ndef amber(tally, cn):\n    \n    c, n = cn\n    return (tally, 2) if 2 == n else (\n        adjust(\n            lambda x: x - 1,\n            c, tally\n        ),\n        1\n    ) if 0 < tally.get(c, 0) else (tally, 0)\n\n\n\n\ndef main():\n    \n    print(' -> '.join(['Target', 'Guess', 'Scores']))\n    print()\n    print(\n        '\\n'.join([\n            wordleReport(*tg) for tg in [\n                (\"ALLOW\", \"LOLLY\"),\n                (\"CHANT\", \"LATTE\"),\n                (\"ROBIN\", \"ALERT\"),\n                (\"ROBIN\", \"SONIC\"),\n                (\"ROBIN\", \"ROBIN\"),\n                (\"BULLY\", \"LOLLY\"),\n                (\"ADAPT\", \"S\u00c5L\u00c5D\"),\n                (\"Ukraine\", \"Ukra\u00edne\"),\n                (\"BBAAB\", \"BBBBBAA\"),\n                (\"BBAABBB\", \"AABBBAA\")\n            ]\n        ])\n    )\n\n\n\ndef wordleReport(target, guess):\n    \n    scoreName = {2: 'green', 1: 'amber', 0: 'gray'}\n\n    if 5 != len(target):\n        return f'{target}: Expected 5 character target.'\n    elif 5 != len(guess):\n        return f'{guess}: Expected 5 character guess.'\n    else:\n        scores = wordleScore(target, guess)\n        return ' -> '.join([\n            target, guess, repr(scores),\n            ' '.join([\n                scoreName[n] for n in scores\n            ])\n        ])\n\n\n\n\n\ndef adjust(f, k, dct):\n    \n    return dict(\n        dct,\n        **{k: f(dct[k]) if k in dct else None}\n    )\n\n\n\ndef charCounts(s):\n    \n    return reduce(\n        lambda a, c: insertWith(add)(c)(1)(a),\n        list(s),\n        {}\n    )\n\n\n\ndef first(f):\n    \n    return lambda xy: (f(xy[0]), xy[1])\n\n\n\n\ndef insertWith(f):\n    \n    return lambda k: lambda x: lambda dct: dict(\n        dct,\n        **{k: f(dct[k], x) if k in dct else x}\n    )\n\n\n\n\ndef mapAccumL(f):\n    \n    def nxt(a, x):\n        return second(lambda v: a[1] + [v])(\n            f(a[0], x)\n        )\n    return lambda acc, xs: reduce(\n        nxt, xs, (acc, [])\n    )\n\n\n\ndef second(f):\n    \n    return lambda xy: (xy[0], f(xy[1]))\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 418921, "name": "Fibonacci matrix-exponentiation", "source": "Translate Haskell to Python: import System.CPUTime (getCPUTime)\nimport Data.List\n\nmain = do\n    startTime <- getCPUTime\n    mapM_ (putStrLn.formatAns).take 7.iterate (*10) $ 10\n    mapM_ (putStrLn.seeFib) [16,32]\n    finishTime <- getCPUTime\n    putStrLn $ \"Took \" ++ (took startTime finishTime)\n\ntook t = fromChrono.chrono t\n\nfromChrono :: (Integer,Integer,Integer) -> String\nfromChrono (m,s,ms) = show m ++ \"m\" ++ show s ++ \".\" ++ show ms ++ \"s\"\n\nchrono :: Integer -> Integer -> (Integer,Integer,Integer)\nchrono start end = (m,s,ms)\n    where\n    tera = 1000000000000\n    fdt = fromIntegral (end - start) / tera\n    dt = floor fdt\n    (m,s) = quotRem dt 60 \n    ms = round $ fromIntegral (round (fdt - (fromIntegral dt))*1000) / 1000\n\nbagOf :: Int -> [a] -> [[a]]\nbagOf _ [] = []\nbagOf n xs = let (us,vs) = splitAt n xs in us : bagOf n vs\n\nformatIntegral :: Show a => String -> a -> String\nformatIntegral sep = reverse.intercalate sep.bagOf 3.reverse.show\n \nformatAns :: Integer -> String\nformatAns p = start ++ go x\n    where\n    start = \"Fibonacci(\"++ (formatIntegral \"_\" p) ++ \") = \"\n    x = fib p\n    tenPow20 = 10^20\n    tenPow40 = tenPow20^2\n    go u | u <= tenPow20 = show u\n    go u | u <= tenPow40 = let (us,vs) = splitAt 20 $ show u in us ++ \" ... \" ++ vs\n    go u = (take 20 $ show u) ++ \" ... \" ++ (show . rem u $ 10^20)\n\nseeFib :: Integer -> String\nseeFib n = start ++ xs ++ \" ... \" ++ (show . rem x $ 10^20)\n    where\n    start = \"Fibonacci(2^\" ++ (show n) ++\") = \"\n    x = fib (2^n)\n    xs = take 20 $ show x\n \nfib :: Integer -> Integer\nfib 0 = 0 \n\nfib n = (last . head . unMat) (Mat [[1, 1], [1, 0]] ^ n)\n \nmult :: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs) . zipWith (flip (map . (*))) vss) uss\n \nnewtype Mat a = Mat\n  { unMat :: [[a]]\n  } deriving (Eq,Show)\n \ninstance Num a =>  Num (Mat a) where\n  negate xm = Mat $ map (map negate) $ unMat xm\n  xm + ym = Mat $ zipWith (zipWith (+)) (unMat xm) (unMat ym)\n  xm * ym =  Mat $ mult (unMat xm) (unMat ym)\n  fromInteger n = Mat [[fromInteger n]]\n  abs = undefined\n  signum = undefined\n", "target": "class Head():\n    def __init__(self, lo, hi=None, shift=0):\n        if hi is None: hi = lo\n\n        d = hi - lo\n        ds, ls, hs = str(d), str(lo), str(hi)\n\n        if d and len(ls) > len(ds):\n            assert(len(ls) - len(ds) + 1 > 21)\n            lo = int(str(lo)[:len(ls) - len(ds) + 1])\n            hi = int(str(hi)[:len(hs) - len(ds) + 1]) + 1\n            shift += len(ds) - 1\n        elif len(ls) > 100:\n            lo = int(str(ls)[:100])\n            hi = lo + 1\n            shift = len(ls) - 100\n\n        self.lo, self.hi, self.shift = lo, hi, shift\n\n    def __mul__(self, other):\n        lo = self.lo*other.lo\n        hi = self.hi*other.hi\n        shift = self.shift + other.shift\n\n        return Head(lo, hi, shift)\n\n    def __add__(self, other):\n        if self.shift < other.shift:\n            return other + self\n\n        sh = self.shift - other.shift\n        if sh >= len(str(other.hi)):\n            return Head(self.lo, self.hi, self.shift)\n\n        ls = str(other.lo)\n        hs = str(other.hi)\n\n        lo = self.lo + int(ls[:len(ls)-sh])\n        hi = self.hi + int(hs[:len(hs)-sh])\n\n        return Head(lo, hi, self.shift)\n\n    def __repr__(self):\n        return str(self.hi)[:20]\n\nclass Tail():\n    def __init__(self, v):\n        self.v = int(f'{v:020d}'[-20:])\n\n    def __add__(self, other):\n        return Tail(self.v + other.v)\n\n    def __mul__(self, other):\n        return Tail(self.v*other.v)\n\n    def __repr__(self):\n        return f'{self.v:020d}'[-20:]\n        \ndef mul(a, b):\n    return a[0]*b[0] + a[1]*b[1], a[0]*b[1] + a[1]*b[2], a[1]*b[1] + a[2]*b[2]\n\ndef fibo(n, cls):\n    n -= 1\n    zero, one = cls(0), cls(1)\n    m = (one, one, zero)\n    e = (one, zero, one)\n\n    while n:\n        if n&1: e = mul(m, e)\n        m = mul(m, m)\n        n >>= 1\n\n    return f'{e[0]}'\n\nfor i in range(2, 10):\n    n = 10**i\n    print(f'10^{i}\u00a0:', fibo(n, Head), '...', fibo(n, Tail))\n\nfor i in range(3, 8):\n    n = 2**i\n    s = f'2^{n}'\n    print(f'{s:5s}:', fibo(2**n, Head), '...', fibo(2**n, Tail))\n"}
{"id": 418922, "name": "Fibonacci matrix-exponentiation", "source": "Translate Haskell to Python: import System.CPUTime (getCPUTime)\nimport Data.List\n\nmain = do\n    startTime <- getCPUTime\n    mapM_ (putStrLn.formatAns).take 7.iterate (*10) $ 10\n    mapM_ (putStrLn.seeFib) [16,32]\n    finishTime <- getCPUTime\n    putStrLn $ \"Took \" ++ (took startTime finishTime)\n\ntook t = fromChrono.chrono t\n\nfromChrono :: (Integer,Integer,Integer) -> String\nfromChrono (m,s,ms) = show m ++ \"m\" ++ show s ++ \".\" ++ show ms ++ \"s\"\n\nchrono :: Integer -> Integer -> (Integer,Integer,Integer)\nchrono start end = (m,s,ms)\n    where\n    tera = 1000000000000\n    fdt = fromIntegral (end - start) / tera\n    dt = floor fdt\n    (m,s) = quotRem dt 60 \n    ms = round $ fromIntegral (round (fdt - (fromIntegral dt))*1000) / 1000\n\nbagOf :: Int -> [a] -> [[a]]\nbagOf _ [] = []\nbagOf n xs = let (us,vs) = splitAt n xs in us : bagOf n vs\n\nformatIntegral :: Show a => String -> a -> String\nformatIntegral sep = reverse.intercalate sep.bagOf 3.reverse.show\n \nformatAns :: Integer -> String\nformatAns p = start ++ go x\n    where\n    start = \"Fibonacci(\"++ (formatIntegral \"_\" p) ++ \") = \"\n    x = fib p\n    tenPow20 = 10^20\n    tenPow40 = tenPow20^2\n    go u | u <= tenPow20 = show u\n    go u | u <= tenPow40 = let (us,vs) = splitAt 20 $ show u in us ++ \" ... \" ++ vs\n    go u = (take 20 $ show u) ++ \" ... \" ++ (show . rem u $ 10^20)\n\nseeFib :: Integer -> String\nseeFib n = start ++ xs ++ \" ... \" ++ (show . rem x $ 10^20)\n    where\n    start = \"Fibonacci(2^\" ++ (show n) ++\") = \"\n    x = fib (2^n)\n    xs = take 20 $ show x\n \nfib :: Integer -> Integer\nfib 0 = 0 \n\nfib n = (last . head . unMat) (Mat [[1, 1], [1, 0]] ^ n)\n \nmult :: Num a => [[a]] -> [[a]] -> [[a]]\nmult uss vss = map ((\\xs -> if null xs then [] else foldl1 (zipWith (+)) xs) . zipWith (flip (map . (*))) vss) uss\n \nnewtype Mat a = Mat\n  { unMat :: [[a]]\n  } deriving (Eq,Show)\n \ninstance Num a =>  Num (Mat a) where\n  negate xm = Mat $ map (map negate) $ unMat xm\n  xm + ym = Mat $ zipWith (zipWith (+)) (unMat xm) (unMat ym)\n  xm * ym =  Mat $ mult (unMat xm) (unMat ym)\n  fromInteger n = Mat [[fromInteger n]]\n  abs = undefined\n  signum = undefined\n", "target": "class Head():\n    def __init__(self, lo, hi=None, shift=0):\n        if hi is None: hi = lo\n\n        d = hi - lo\n        ds, ls, hs = str(d), str(lo), str(hi)\n\n        if d and len(ls) > len(ds):\n            assert(len(ls) - len(ds) + 1 > 21)\n            lo = int(str(lo)[:len(ls) - len(ds) + 1])\n            hi = int(str(hi)[:len(hs) - len(ds) + 1]) + 1\n            shift += len(ds) - 1\n        elif len(ls) > 100:\n            lo = int(str(ls)[:100])\n            hi = lo + 1\n            shift = len(ls) - 100\n\n        self.lo, self.hi, self.shift = lo, hi, shift\n\n    def __mul__(self, other):\n        lo = self.lo*other.lo\n        hi = self.hi*other.hi\n        shift = self.shift + other.shift\n\n        return Head(lo, hi, shift)\n\n    def __add__(self, other):\n        if self.shift < other.shift:\n            return other + self\n\n        sh = self.shift - other.shift\n        if sh >= len(str(other.hi)):\n            return Head(self.lo, self.hi, self.shift)\n\n        ls = str(other.lo)\n        hs = str(other.hi)\n\n        lo = self.lo + int(ls[:len(ls)-sh])\n        hi = self.hi + int(hs[:len(hs)-sh])\n\n        return Head(lo, hi, self.shift)\n\n    def __repr__(self):\n        return str(self.hi)[:20]\n\nclass Tail():\n    def __init__(self, v):\n        self.v = int(f'{v:020d}'[-20:])\n\n    def __add__(self, other):\n        return Tail(self.v + other.v)\n\n    def __mul__(self, other):\n        return Tail(self.v*other.v)\n\n    def __repr__(self):\n        return f'{self.v:020d}'[-20:]\n        \ndef mul(a, b):\n    return a[0]*b[0] + a[1]*b[1], a[0]*b[1] + a[1]*b[2], a[1]*b[1] + a[2]*b[2]\n\ndef fibo(n, cls):\n    n -= 1\n    zero, one = cls(0), cls(1)\n    m = (one, one, zero)\n    e = (one, zero, one)\n\n    while n:\n        if n&1: e = mul(m, e)\n        m = mul(m, m)\n        n >>= 1\n\n    return f'{e[0]}'\n\nfor i in range(2, 10):\n    n = 10**i\n    print(f'10^{i}\u00a0:', fibo(n, Head), '...', fibo(n, Tail))\n\nfor i in range(3, 8):\n    n = 2**i\n    s = f'2^{n}'\n    print(f'{s:5s}:', fibo(2**n, Head), '...', fibo(2**n, Tail))\n"}
{"id": 418923, "name": "Cyclotomic polynomial", "source": "Translate Haskell to Python: import Data.List\nimport Data.Numbers.Primes (primeFactors)\n\nnegateVar p = zipWith (*) p $ reverse $ take (length p) $ cycle [1,-1]\n\nlift p 1 = p\nlift p n = intercalate (replicate (n-1) 0) (pure <$> p)\n\nshortDiv :: [Integer] -> [Integer] -> [Integer]\nshortDiv p1 (_:p2) = unfoldr go (length p1 - length p2, p1)\n  where\n    go (0, _) = Nothing\n    go (i, h:t) = Just (h, (i-1, zipWith (+) (map (h *) ker) t))\n    ker = negate <$> p2 ++ repeat 0\n\nprimePowerFactors = sortOn fst . map (\\x-> (head x, length x)) . group . primeFactors\n                     \n\ncyclotomics :: [[Integer]]\ncyclotomics = cyclotomic <$> [0..]\n\ncyclotomic :: Int -> [Integer]\ncyclotomic 0 = [0]\ncyclotomic 1 = [1, -1]\ncyclotomic 2 = [1, 1]\ncyclotomic n = case primePowerFactors n of\n  \n  [(2,h)]       -> 1 : replicate (2 ^ (h-1) - 1) 0 ++ [1]\n  \n  [(p,1)]       -> replicate n 1\n  \n  [(p,m)]       -> lift (cyclotomics !! p) (p^(m-1))\n  \n  [(2,1),(p,1)] -> take (n `div` 2) $ cycle [1,-1]\n  \n  (2,1):_       -> negateVar $ cyclotomics !! (n `div` 2)\n  \n  (p, m):ps     -> let cm = cyclotomics !! (n `div` (p ^ m))\n                   in lift (lift cm p `shortDiv` cm) (p^(m-1))\n", "target": "from itertools import count, chain\nfrom collections import deque\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n):\n    for p in primes():\n        if n%p == 0:\n            return False\n        if p*p > n:\n            return True\n\ndef factors(n):\n    for p in primes():\n    \n    \n    \n        if p*p > n:\n            if n > 1:\n                yield(n, 1, 1)\n            break\n\n        if n%p == 0:\n            cnt = 0\n            while True:\n                n, cnt = n//p, cnt+1\n                if n%p != 0: break\n            yield p, cnt, n\n\n\n\n\n\ndef cyclotomic(n):\n    def poly_div(num, den):\n        return (num[0] + den[1], num[1] + den[0])\n\n    def elevate(poly, n): \n        powerup = lambda p, n: [a*n for a in p]\n        return poly if n == 1 else (powerup(poly[0], n), powerup(poly[1], n))\n\n\n    if n == 0:\n        return ([], [])\n    if n == 1:\n        return ([1], [])\n\n    p, m, r = next(factors(n))\n    poly = cyclotomic(r)\n    return elevate(poly_div(elevate(poly, p), poly), p**(m-1))\n\ndef to_text(poly):\n    def getx(c, e):\n        if e == 0:\n            return '1'\n        elif e == 1:\n            return 'x'\n        return 'x' + (''.join('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079'[i] for i in map(int, str(e))))\n\n    parts = []\n    for (c,e) in (poly):\n        if c < 0:\n            coef = ' - ' if c == -1 else f' - {-c} '\n        else:\n            coef = (parts and ' + ' or '') if c == 1 else f' + {c}'\n        parts.append(coef + getx(c,e))\n    return ''.join(parts)\n\ndef terms(poly):\n    \n\n    def merge(a, b):\n        \n        while a or b:\n            l = a[0] if a else (0, -1) \n            r = b[0] if b else (0, -1)\n            if l[1] > r[1]:\n                a.popleft()\n            elif l[1] < r[1]:\n                b.popleft()\n                l = r\n            else:\n                a.popleft()\n                b.popleft()\n                l = (l[0] + r[0], l[1])\n            yield l\n\n    def mul(poly, p): \n        poly = list(poly)\n        return merge(deque((c, e+p) for c,e in poly),\n                     deque((-c, e) for c,e in poly))\n\n    def div(poly, p): \n        q = deque()\n        for c,e in merge(deque(poly), q):\n            if c:\n                q.append((c, e - p))\n                yield (c, e - p)\n            if e == p: break\n\n    p = [(1, 0)]  \n\n    for x in poly[0]: \n        p = mul(p, x)\n    for x in sorted(poly[1], reverse=True): \n        p = div(p, x)\n    return p\n\nfor n in chain(range(11), [2]):\n    print(f'{n}: {to_text(terms(cyclotomic(n)))}')\n\nwant = 1\nfor n in count():\n    c = [c for c,_ in terms(cyclotomic(n))]\n    while want in c or -want in c:\n        print(f'C[{want}]: {n}')\n        want += 1\n"}
{"id": 418924, "name": "Cyclotomic polynomial", "source": "Translate Haskell to Python: import Data.List\nimport Data.Numbers.Primes (primeFactors)\n\nnegateVar p = zipWith (*) p $ reverse $ take (length p) $ cycle [1,-1]\n\nlift p 1 = p\nlift p n = intercalate (replicate (n-1) 0) (pure <$> p)\n\nshortDiv :: [Integer] -> [Integer] -> [Integer]\nshortDiv p1 (_:p2) = unfoldr go (length p1 - length p2, p1)\n  where\n    go (0, _) = Nothing\n    go (i, h:t) = Just (h, (i-1, zipWith (+) (map (h *) ker) t))\n    ker = negate <$> p2 ++ repeat 0\n\nprimePowerFactors = sortOn fst . map (\\x-> (head x, length x)) . group . primeFactors\n                     \n\ncyclotomics :: [[Integer]]\ncyclotomics = cyclotomic <$> [0..]\n\ncyclotomic :: Int -> [Integer]\ncyclotomic 0 = [0]\ncyclotomic 1 = [1, -1]\ncyclotomic 2 = [1, 1]\ncyclotomic n = case primePowerFactors n of\n  \n  [(2,h)]       -> 1 : replicate (2 ^ (h-1) - 1) 0 ++ [1]\n  \n  [(p,1)]       -> replicate n 1\n  \n  [(p,m)]       -> lift (cyclotomics !! p) (p^(m-1))\n  \n  [(2,1),(p,1)] -> take (n `div` 2) $ cycle [1,-1]\n  \n  (2,1):_       -> negateVar $ cyclotomics !! (n `div` 2)\n  \n  (p, m):ps     -> let cm = cyclotomics !! (n `div` (p ^ m))\n                   in lift (lift cm p `shortDiv` cm) (p^(m-1))\n", "target": "from itertools import count, chain\nfrom collections import deque\n\ndef primes(_cache=[2, 3]):\n    yield from _cache\n    for n in count(_cache[-1]+2, 2):\n        if isprime(n):\n            _cache.append(n)\n            yield n\n\ndef isprime(n):\n    for p in primes():\n        if n%p == 0:\n            return False\n        if p*p > n:\n            return True\n\ndef factors(n):\n    for p in primes():\n    \n    \n    \n        if p*p > n:\n            if n > 1:\n                yield(n, 1, 1)\n            break\n\n        if n%p == 0:\n            cnt = 0\n            while True:\n                n, cnt = n//p, cnt+1\n                if n%p != 0: break\n            yield p, cnt, n\n\n\n\n\n\ndef cyclotomic(n):\n    def poly_div(num, den):\n        return (num[0] + den[1], num[1] + den[0])\n\n    def elevate(poly, n): \n        powerup = lambda p, n: [a*n for a in p]\n        return poly if n == 1 else (powerup(poly[0], n), powerup(poly[1], n))\n\n\n    if n == 0:\n        return ([], [])\n    if n == 1:\n        return ([1], [])\n\n    p, m, r = next(factors(n))\n    poly = cyclotomic(r)\n    return elevate(poly_div(elevate(poly, p), poly), p**(m-1))\n\ndef to_text(poly):\n    def getx(c, e):\n        if e == 0:\n            return '1'\n        elif e == 1:\n            return 'x'\n        return 'x' + (''.join('\u2070\u00b9\u00b2\u00b3\u2074\u2075\u2076\u2077\u2078\u2079'[i] for i in map(int, str(e))))\n\n    parts = []\n    for (c,e) in (poly):\n        if c < 0:\n            coef = ' - ' if c == -1 else f' - {-c} '\n        else:\n            coef = (parts and ' + ' or '') if c == 1 else f' + {c}'\n        parts.append(coef + getx(c,e))\n    return ''.join(parts)\n\ndef terms(poly):\n    \n\n    def merge(a, b):\n        \n        while a or b:\n            l = a[0] if a else (0, -1) \n            r = b[0] if b else (0, -1)\n            if l[1] > r[1]:\n                a.popleft()\n            elif l[1] < r[1]:\n                b.popleft()\n                l = r\n            else:\n                a.popleft()\n                b.popleft()\n                l = (l[0] + r[0], l[1])\n            yield l\n\n    def mul(poly, p): \n        poly = list(poly)\n        return merge(deque((c, e+p) for c,e in poly),\n                     deque((-c, e) for c,e in poly))\n\n    def div(poly, p): \n        q = deque()\n        for c,e in merge(deque(poly), q):\n            if c:\n                q.append((c, e - p))\n                yield (c, e - p)\n            if e == p: break\n\n    p = [(1, 0)]  \n\n    for x in poly[0]: \n        p = mul(p, x)\n    for x in sorted(poly[1], reverse=True): \n        p = div(p, x)\n    return p\n\nfor n in chain(range(11), [2]):\n    print(f'{n}: {to_text(terms(cyclotomic(n)))}')\n\nwant = 1\nfor n in count():\n    c = [c for c,_ in terms(cyclotomic(n))]\n    while want in c or -want in c:\n        print(f'C[{want}]: {n}')\n        want += 1\n"}
{"id": 418925, "name": "Minimal steps down to 1", "source": "Translate Haskell to Python: \nimport Data.List\nimport Data.Ord\nimport Data.Function (on)\n\n\n\n\ndata Memo a = Node a (Memo a) (Memo a)\n  deriving Functor\n\nmemo :: Integral a => Memo p -> a -> p\nmemo (Node a l r) n\n  | n == 0 = a\n  | odd n = memo l (n `div` 2)\n  | otherwise = memo r (n `div` 2 - 1)\n\nnats :: Integral a => Memo a\nnats = Node 0 ((+1).(*2) <$> nats) ((*2).(+1) <$> nats)\n\nmemoize :: Integral a => (a -> b) -> (a -> b)\nmemoize f = memo (f <$> nats)\n\n\n\ndata Step = Div Int | Sub Int\n  deriving Show\n\nrun :: Int -> Step -> [(Step, Int)]\nrun n s = case s of\n  Sub i | n > i -> [(s, n - i)]\n  Div d | n `mod` d == 0 -> [(s, n `div` d)]\n  _ -> []\n\nminSteps :: [Step] -> Int -> (Int, [Step])\nminSteps steps = go\n  where\n    go = memoize goM\n    \n    goM 1 = (0, [])\n    goM n = minimumBy (comparing fst) $ do\n      (s, k) <- steps >>= run n\n      let (m, ss) = go k\n      return (m+1, s:ss)\n", "target": "from functools import lru_cache\n\n\n\n\nDIVS = {2, 3}\nSUBS = {1}\n\nclass Minrec():\n    \"Recursive, memoised minimised steps to 1\"\n\n    def __init__(self, divs=DIVS, subs=SUBS):\n        self.divs, self.subs = divs, subs\n\n    @lru_cache(maxsize=None)\n    def _minrec(self, n):\n        \"Recursive, memoised\"\n        if n == 1:\n            return 0, ['=1']\n        possibles = {}\n        for d in self.divs:\n            if n % d == 0:\n                possibles[f'/{d}=>{n // d:2}'] = self._minrec(n // d)\n        for s in self.subs:\n            if n > s:\n                possibles[f'-{s}=>{n - s:2}'] = self._minrec(n - s)\n        thiskind, (count, otherkinds) = min(possibles.items(), key=lambda x: x[1])\n        ret = 1 + count, [thiskind] + otherkinds\n        return ret\n\n    def __call__(self, n):\n        \"Recursive, memoised\"\n        ans = self._minrec(n)[1][:-1]\n        return len(ans), ans\n\n\nif __name__ == '__main__':\n    for DIVS, SUBS in [({2, 3}, {1}), ({2, 3}, {2})]:\n        minrec = Minrec(DIVS, SUBS)\n        print('\\nMINIMUM STEPS TO 1: Recursive algorithm')\n        print('  Possible divisors:  ', DIVS)\n        print('  Possible decrements:', SUBS)\n        for n in range(1, 11):\n            steps, how = minrec(n)\n            print(f'    minrec({n:2}) in {steps:2} by: ', ', '.join(how))\n\n        upto = 2000\n        print(f'\\n    Those numbers up to {upto} that take the maximum, \"minimal steps down to 1\":')\n        stepn = sorted((minrec(n)[0], n) for n in range(upto, 0, -1))\n        mx = stepn[-1][0]\n        ans = [x[1] for x in stepn if x[0] == mx]\n        print('      Taking', mx, f'steps is/are the {len(ans)} numbers:',\n              ', '.join(str(n) for n in sorted(ans)))\n        \n        print()\n"}
{"id": 418926, "name": "Ramanujan's constant", "source": "Translate Haskell to Python: import Control.Monad (forM_)\nimport Data.Number.CReal (CReal, showCReal)\nimport Text.Printf (printf)\n\nramfun :: CReal -> CReal\nramfun x = exp (pi * sqrt x)\n\n\nramanujan :: CReal\nramanujan = ramfun 163\n\n\nheegners :: [Int]\nheegners = [19, 43, 67, 163]\n\n\nintDist :: CReal -> CReal\nintDist x = abs (x - fromIntegral (round x))\n\nmain :: IO ()\nmain = do\n  let n = 35\n  printf \"Ramanujan's constant: %s\\n\\n\" (showCReal n ramanujan)\n  printf \"%3s %34s%20s%s\\n\\n\" \" h \" \"e^(pi*sqrt(h))\" \"\" \" Dist. to integer\"\n  forM_ heegners $ \\h ->\n    let r = ramfun (fromIntegral h)\n        d = intDist r\n    in printf \"%3d %54s %s\\n\" h (showCReal n r) (showCReal 15 d)\n", "target": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))\n"}
{"id": 418927, "name": "Ramanujan's constant", "source": "Translate Haskell to Python: import Control.Monad (forM_)\nimport Data.Number.CReal (CReal, showCReal)\nimport Text.Printf (printf)\n\nramfun :: CReal -> CReal\nramfun x = exp (pi * sqrt x)\n\n\nramanujan :: CReal\nramanujan = ramfun 163\n\n\nheegners :: [Int]\nheegners = [19, 43, 67, 163]\n\n\nintDist :: CReal -> CReal\nintDist x = abs (x - fromIntegral (round x))\n\nmain :: IO ()\nmain = do\n  let n = 35\n  printf \"Ramanujan's constant: %s\\n\\n\" (showCReal n ramanujan)\n  printf \"%3s %34s%20s%s\\n\\n\" \" h \" \"e^(pi*sqrt(h))\" \"\" \" Dist. to integer\"\n  forM_ heegners $ \\h ->\n    let r = ramfun (fromIntegral h)\n        d = intDist r\n    in printf \"%3d %54s %s\\n\" h (showCReal n r) (showCReal 15 d)\n", "target": "from mpmath import mp\nheegner = [19,43,67,163]\nmp.dps = 50\nx = mp.exp(mp.pi*mp.sqrt(163))\nprint(\"calculated Ramanujan's constant: {}\".format(x))\nprint(\"Heegner numbers yielding 'almost' integers:\")\nfor i in heegner:\n    print(\" for {}: {} ~ {} error: {}\".format(str(i),mp.exp(mp.pi*mp.sqrt(i)),round(mp.exp(mp.pi*mp.sqrt(i))),(mp.pi*mp.sqrt(i)) - round(mp.pi*mp.sqrt(i))))\n"}
{"id": 418928, "name": "Tree from nesting levels", "source": "Translate Haskell to Python: \n\nimport Data.Bifunctor (bimap)\nimport Data.Tree (Forest, Tree (..), drawTree, foldTree)\n\n\n\ntreeFromSparseLevels :: [Int] -> Tree (Maybe Int)\ntreeFromSparseLevels =\n  Node Nothing\n    . forestFromNestLevels\n    . rooted\n    . normalised\n\nsparseLevelsFromTree :: Tree (Maybe Int) -> [Int]\nsparseLevelsFromTree = foldTree go\n  where\n    go Nothing xs = concat xs\n    go (Just x) xs = x : concat xs\n\nforestFromNestLevels :: [(Int, a)] -> Forest a\nforestFromNestLevels = go\n  where\n    go [] = []\n    go ((n, v) : xs) =\n      uncurry (:) $\n        bimap (Node v . go) go (span ((n <) . fst) xs)\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( \\xs ->\n        putStrLn (\"From: \" <> show xs)\n          >> let tree = treeFromSparseLevels xs\n              in putStrLn ((drawTree . fmap show) tree)\n                   >> putStrLn\n                     ( \"Back to: \"\n                         <> show (sparseLevelsFromTree tree)\n                         <> \"\\n\\n\"\n                     )\n    )\n    [ [],\n      [1, 2, 4],\n      [3, 1, 3, 1],\n      [1, 2, 3, 1],\n      [3, 2, 1, 3],\n      [3, 3, 3, 1, 1, 3, 3, 3]\n    ]\n\n\n\n\nrooted :: [(Int, Maybe Int)] -> [(Int, Maybe Int)]\nrooted [] = []\nrooted xs = go $ filter ((1 <=) . fst) xs\n  where\n    go xs@((1, mb) : _) = xs\n    go xs@((n, mb) : _) =\n      fmap (,Nothing) [1 .. pred n] <> xs\n\n\nnormalised [] = []\nnormalised [x] = [(x, Just x)]\nnormalised (x : y : xs)\n  | 1 < (y - x) =\n    (x, Just x) :\n    (succ x, Nothing) : normalised (y : xs)\n  | otherwise = (x, Just x) : normalised (y : xs)\n", "target": "def to_tree(x, index=0, depth=1):\n   so_far = []\n   while index < len(x):\n       this = x[index]\n       if this == depth:\n           so_far.append(this)\n       elif this > depth:\n           index, deeper = to_tree(x, index, depth + 1)\n           so_far.append(deeper)\n       else: \n           index -=1\n           break\n       index += 1\n   return (index, so_far) if depth > 1 else so_far\n\n\nif __name__ ==  \"__main__\":\n    from pprint import pformat\n\n    def pnest(nest:list, width: int=9) -> str:\n        text = pformat(nest, width=width).replace('\\n', '\\n    ')\n        print(f\" OR {text}\\n\")\n\n    exercises = [\n        [],\n        [1, 2, 4],\n        [3, 1, 3, 1],\n        [1, 2, 3, 1],\n        [3, 2, 1, 3],\n        [3, 3, 3, 1, 1, 3, 3, 3],\n        ]\n    for flat in exercises:\n        nest = to_tree(flat)\n        print(f\"{flat} NESTS TO: {nest}\")\n        pnest(nest)\n"}
{"id": 418929, "name": "Tree from nesting levels", "source": "Translate Haskell to Python: \n\nimport Data.Bifunctor (bimap)\nimport Data.Tree (Forest, Tree (..), drawTree, foldTree)\n\n\n\ntreeFromSparseLevels :: [Int] -> Tree (Maybe Int)\ntreeFromSparseLevels =\n  Node Nothing\n    . forestFromNestLevels\n    . rooted\n    . normalised\n\nsparseLevelsFromTree :: Tree (Maybe Int) -> [Int]\nsparseLevelsFromTree = foldTree go\n  where\n    go Nothing xs = concat xs\n    go (Just x) xs = x : concat xs\n\nforestFromNestLevels :: [(Int, a)] -> Forest a\nforestFromNestLevels = go\n  where\n    go [] = []\n    go ((n, v) : xs) =\n      uncurry (:) $\n        bimap (Node v . go) go (span ((n <) . fst) xs)\n\n\nmain :: IO ()\nmain =\n  mapM_\n    ( \\xs ->\n        putStrLn (\"From: \" <> show xs)\n          >> let tree = treeFromSparseLevels xs\n              in putStrLn ((drawTree . fmap show) tree)\n                   >> putStrLn\n                     ( \"Back to: \"\n                         <> show (sparseLevelsFromTree tree)\n                         <> \"\\n\\n\"\n                     )\n    )\n    [ [],\n      [1, 2, 4],\n      [3, 1, 3, 1],\n      [1, 2, 3, 1],\n      [3, 2, 1, 3],\n      [3, 3, 3, 1, 1, 3, 3, 3]\n    ]\n\n\n\n\nrooted :: [(Int, Maybe Int)] -> [(Int, Maybe Int)]\nrooted [] = []\nrooted xs = go $ filter ((1 <=) . fst) xs\n  where\n    go xs@((1, mb) : _) = xs\n    go xs@((n, mb) : _) =\n      fmap (,Nothing) [1 .. pred n] <> xs\n\n\nnormalised [] = []\nnormalised [x] = [(x, Just x)]\nnormalised (x : y : xs)\n  | 1 < (y - x) =\n    (x, Just x) :\n    (succ x, Nothing) : normalised (y : xs)\n  | otherwise = (x, Just x) : normalised (y : xs)\n", "target": "def to_tree(x, index=0, depth=1):\n   so_far = []\n   while index < len(x):\n       this = x[index]\n       if this == depth:\n           so_far.append(this)\n       elif this > depth:\n           index, deeper = to_tree(x, index, depth + 1)\n           so_far.append(deeper)\n       else: \n           index -=1\n           break\n       index += 1\n   return (index, so_far) if depth > 1 else so_far\n\n\nif __name__ ==  \"__main__\":\n    from pprint import pformat\n\n    def pnest(nest:list, width: int=9) -> str:\n        text = pformat(nest, width=width).replace('\\n', '\\n    ')\n        print(f\" OR {text}\\n\")\n\n    exercises = [\n        [],\n        [1, 2, 4],\n        [3, 1, 3, 1],\n        [1, 2, 3, 1],\n        [3, 2, 1, 3],\n        [3, 3, 3, 1, 1, 3, 3, 3],\n        ]\n    for flat in exercises:\n        nest = to_tree(flat)\n        print(f\"{flat} NESTS TO: {nest}\")\n        pnest(nest)\n"}
{"id": 418930, "name": "Tree datastructures", "source": "Translate Haskell to Python: \n\n\n\n\nimport Data.List (span)\n\n\n\n\ndata Nest a = Nest (Maybe a) [Nest a]\n  deriving Eq\n\ninstance Show a => Show (Nest a) where\n  show (Nest (Just a) []) = show a\n  show (Nest (Just a) s) = show a ++ show s\n  show (Nest Nothing []) = \"\\\"\\\"\"\n  show (Nest Nothing s) = \"\\\"\\\"\" ++ show s\n\n\ntype Indent a = [(Int, a)]\n\n\nclass Iso b a => Iso a b where\n  from :: a -> b\n\n\ninstance Iso (Nest a) (Indent a) where\n  from = go (-1)\n    where\n      go n (Nest a t) =\n        case a of\n          Just a -> (n, a) : foldMap (go (n + 1)) t \n          Nothing -> foldMap (go (n + 1)) t\n\n\ninstance Iso (Indent a) (Nest a) where\n  from = revNest . foldl add (Nest Nothing [])\n    where\n      add t (d,x) = go 0 t\n        where\n          go n (Nest a s) =\n            case compare n d of\n              EQ -> Nest a $ Nest (Just x) [] : s\n              LT -> case s of\n                      h:t -> Nest a $ go (n+1) h : t\n                      [] -> go n $ Nest a [Nest Nothing []]\n              GT -> go (n-1) $ Nest Nothing [Nest a s]\n\n      revNest (Nest a s) = Nest a (reverse $ revNest <$> s)  \n\n\ninstance Iso (Indent String) String where\n  from = unlines . map process\n    where\n      process (d, s) = replicate (4*d) ' ' ++ s\n\n\ninstance Iso String (Indent String) where\n  from = map process . lines\n    where\n      process s = let (i, a) = span (== ' ') s\n                  in (length i `div` 4, a)\n\n\ninstance Iso (Nest String) String where\n  from = from @(Indent String) . from\n\n\ninstance Iso String (Nest String) where\n  from = from @(Indent String) . from\n", "target": "from pprint import pprint as pp\n\ndef to_indent(node, depth=0, flat=None):\n    if flat is None:\n        flat = []\n    if node:\n        flat.append((depth, node[0]))\n    for child in node[1]:\n        to_indent(child, depth + 1, flat)\n    return flat\n\ndef to_nest(lst, depth=0, level=None):\n    if level is None:\n        level = []\n    while lst:\n        d, name = lst[0]\n        if d == depth:\n            children = []\n            level.append((name, children))\n            lst.pop(0)\n        elif d > depth:  \n            to_nest(lst, d, children)\n        elif d < depth:  \n            return\n    return level[0] if level else None\n                    \nif __name__ == '__main__':\n    print('Start Nest format:')\n    nest = ('RosettaCode', [('rocks', [('code', []), ('comparison', []), ('wiki', [])]), \n                            ('mocks', [('trolling', [])])])\n    pp(nest, width=25)\n\n    print('\\n... To Indent format:')\n    as_ind = to_indent(nest)\n    pp(as_ind, width=25)\n\n    print('\\n... To Nest format:')\n    as_nest = to_nest(as_ind)\n    pp(as_nest, width=25)\n\n    if nest != as_nest:\n        print(\"Whoops round-trip issues\")\n"}
{"id": 418931, "name": "Most frequent k chars distance", "source": "Translate Haskell to Python: module MostFrequentK \n   where\nimport Data.List ( nub , sortBy )\nimport qualified Data.Set as S \n\ncount :: Eq a => [a] -> a -> Int\ncount [] x = 0 \ncount ( x:xs ) k \n   |x == k = 1 + count xs k\n   |otherwise = count xs k\n\norderedStatistics :: String -> [(Char , Int)]\norderedStatistics s = sortBy myCriterion $ nub $ zip s ( map (\\c -> count s c ) s )\n   where\n      myCriterion :: (Char , Int) -> (Char , Int) -> Ordering\n      myCriterion (c1 , n1) (c2, n2) \n\t |n1 > n2 = LT\n\t |n1 < n2 = GT\n\t |n1 == n2 = compare ( found c1 s ) ( found c2 s )\n      found :: Char -> String -> Int\n      found e s = length $ takeWhile (/= e ) s\n\nmostFreqKHashing :: String -> Int -> String\nmostFreqKHashing s n = foldl ((++)) [] $ map toString $ take n $ orderedStatistics s\n   where\n      toString :: (Char , Int) -> String\n      toString ( c , i ) = c : show i\n\nmostFreqKSimilarity :: String -> String -> Int\nmostFreqKSimilarity s t = snd $ head $ S.toList $ S.fromList ( doublets s ) `S.intersection`\n                           S.fromList ( doublets t )\n   where\n      toPair :: String -> (Char , Int)\n      toPair s = ( head s , fromEnum ( head $ tail s ) - 48 )\n      doublets :: String -> [(Char , Int)]\n      doublets str = map toPair [take 2 $ drop start str | start <- [0 , 2 ..length str - 2]]\n                           \nmostFreqKSDF :: String -> String -> Int ->Int\nmostFreqKSDF s t n = mostFreqKSimilarity ( mostFreqKHashing s n ) (mostFreqKHashing t n )\n", "target": "import collections\ndef MostFreqKHashing(inputString, K):\n    occuDict = collections.defaultdict(int)\n    for c in inputString:\n        occuDict[c] += 1\n    occuList = sorted(occuDict.items(), key = lambda x: x[1], reverse = True)\n    outputStr = ''.join(c + str(cnt) for c, cnt in occuList[:K])\n    return outputStr \n\n\ndef MostFreqKSimilarity(inputStr1, inputStr2):\n    similarity = 0\n    for i in range(0, len(inputStr1), 2):\n        c = inputStr1[i]\n        cnt1 = int(inputStr1[i + 1])\n        for j in range(0, len(inputStr2), 2):\n            if inputStr2[j] == c:\n                cnt2 = int(inputStr2[j + 1])\n                similarity += cnt1 + cnt2\n                break\n    return similarity\n\ndef MostFreqKSDF(inputStr1, inputStr2, K, maxDistance):\n    return maxDistance - MostFreqKSimilarity(MostFreqKHashing(inputStr1,K), MostFreqKHashing(inputStr2,K))\n"}
{"id": 418932, "name": "One-time pad", "source": "Translate Haskell to Python: \n\n\n\n\nmodule OneTimePad (main) where\n\nimport           Control.Monad\nimport           Data.Char\nimport           Data.Function         (on)\nimport qualified Data.Text             as T\nimport qualified Data.Text.IO          as TI\nimport           Data.Time\nimport           System.Console.GetOpt\nimport           System.Environment\nimport           System.Exit\nimport           System.IO\n\n\ndata Options = Options  { optCommand :: String\n                        , optInput   :: IO T.Text\n                        , optOutput  :: T.Text -> IO ()\n                        , optPad     :: (IO T.Text, T.Text -> IO ())\n                        , optLines   :: Int\n                        }\n\nstartOptions :: Options\nstartOptions = Options  { optCommand    = \"decrypt\"\n                        , optInput      = TI.getContents\n                        , optOutput     = TI.putStr\n                        , optPad        = (TI.getContents, TI.putStr)\n                        , optLines      = 0\n                        }\n\noptions :: [ OptDescr (Options -> IO Options) ]\noptions =\n    [ Option \"e\" [\"encrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"encrypt\" }))\n        \"Encrypt file\"\n    , Option \"d\" [\"decrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"decrypt\" }))\n        \"Decrypt file (default)\"\n    , Option \"g\" [\"generate\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"generate\" }))\n        \"Generate a one-time pad\"\n    , Option \"i\" [\"input\"]\n        (ReqArg\n            (\\arg opt -> return opt { optInput = TI.readFile arg })\n            \"FILE\")\n        \"Input file (for decryption and encryption)\"\n    , Option \"o\" [\"output\"]\n        (ReqArg\n            (\\arg opt -> return opt { optOutput = TI.writeFile arg })\n            \"FILE\")\n        \"Output file (for generation, decryption, and encryption)\"\n    , Option \"p\" [\"pad\"]\n        (ReqArg\n            (\\arg opt -> return opt { optPad = (TI.readFile arg,\n                                                TI.writeFile arg) })\n            \"FILE\")\n        \"One-time pad to use (for decryption and encryption)\"\n    , Option \"l\" [\"lines\"]\n        (ReqArg\n            (\\arg opt -> return opt { optLines = read arg :: Int })\n            \"LINES\")\n        \"New one-time pad's length (in lines of 48 characters) (for generation)\"\n    , Option \"V\" [\"version\"]\n        (NoArg\n            (\\_ -> do\n                hPutStrLn stderr \"Version 0.01\"\n                exitWith ExitSuccess))\n        \"Print version\"\n    , Option \"h\" [\"help\"]\n        (NoArg\n            (\\_ -> do\n                prg <- getProgName\n                putStrLn \"usage: OneTimePad [-h] [-V] [\n                hPutStrLn stderr (usageInfo prg options)\n                exitWith ExitSuccess))\n        \"Show this help message and exit\"\n    ]\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let (actions, nonOptions, errors) = getOpt RequireOrder options args\n  opts <- Prelude.foldl (>>=) (return startOptions) actions\n  let Options { optCommand = command\n              , optInput   = input\n              , optOutput  = output\n              , optPad     = (inPad, outPad)\n              , optLines   = linecnt } = opts\n\n  case command of\n    \"generate\" -> generate linecnt output\n    \"encrypt\"  -> do\n      inputContents <- clean <$> input\n      padContents <- inPad\n      output $ format $ encrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n    \"decrypt\"  -> do\n      inputContents <- unformat <$> input\n      padContents <- inPad\n      output $ decrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n      let discardLines = ceiling\n            $ ((/) `on` fromIntegral) (T.length inputContents) 48\n      outPad $ discard discardLines $ T.lines padContents\n\n\ndiscard :: Int -> [T.Text] -> T.Text\ndiscard 0 ts = T.unlines ts\ndiscard x (t:ts) = if (T.head t == '-' || T.head t == '#')\n  then T.unlines [t, (discard x ts)]\n  else T.unlines [(T.append (T.pack \"- \") t), (discard (x-1) ts)]\n\n\nclean :: T.Text -> T.Text\nclean = T.map toUpper . T.filter (\\c -> let oc = ord c\n                                   in oc >= 65 && oc <= 122\n                                   && (not $ oc >=91 && oc <= 96))\n\n\nformat :: T.Text -> T.Text\nformat = T.unlines . map (T.intercalate (T.pack \" \") . T.chunksOf 6)\n  . T.chunksOf 48\n\n\nunformat :: T.Text -> T.Text\nunformat = T.filter (\\c -> c/='\\n' && c/=' ')\n\n\ngenerate :: Int -> (T.Text -> IO ()) -> IO ()\ngenerate lines output = do\n  withBinaryFile \"/dev/random\" ReadMode\n    (\\handle -> do\n        contents <- replicateM (48 * lines) $ hGetChar handle\n        time <- getCurrentTime\n        output\n          $ T.unlines [ T.pack\n                        $ \"# OTP pad, generated by https://github.com/kssytsrk/one-time-pad on \"\n                        ++ show time\n                      , format $ T.pack\n                        $ map (chr . (65 +) . flip mod 26 . ord) contents\n                      ])\n\n\ncrypt :: (Int -> Int -> Int) -> T.Text -> T.Text -> T.Text\ncrypt f = T.zipWith ((chr .) . f `on` ord)\n\n\nencrypt :: T.Text -> T.Text -> T.Text\nencrypt = crypt ((((+65) . flip mod 26 . subtract 130) .) . (+))\n\n\ndecrypt :: T.Text -> T.Text -> T.Text\ndecrypt = crypt ((((+65) . flip mod 26) .) . (-))\n", "target": "\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n\nMAGIC = \"\n\n\ndef make_keys(n, size):\n    \n    \n    \n    \n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \n    pad = [\n        MAGIC,\n        f\"\n        f\"\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    \n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    \n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    \n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n"}
{"id": 418933, "name": "One-time pad", "source": "Translate Haskell to Python: \n\n\n\n\nmodule OneTimePad (main) where\n\nimport           Control.Monad\nimport           Data.Char\nimport           Data.Function         (on)\nimport qualified Data.Text             as T\nimport qualified Data.Text.IO          as TI\nimport           Data.Time\nimport           System.Console.GetOpt\nimport           System.Environment\nimport           System.Exit\nimport           System.IO\n\n\ndata Options = Options  { optCommand :: String\n                        , optInput   :: IO T.Text\n                        , optOutput  :: T.Text -> IO ()\n                        , optPad     :: (IO T.Text, T.Text -> IO ())\n                        , optLines   :: Int\n                        }\n\nstartOptions :: Options\nstartOptions = Options  { optCommand    = \"decrypt\"\n                        , optInput      = TI.getContents\n                        , optOutput     = TI.putStr\n                        , optPad        = (TI.getContents, TI.putStr)\n                        , optLines      = 0\n                        }\n\noptions :: [ OptDescr (Options -> IO Options) ]\noptions =\n    [ Option \"e\" [\"encrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"encrypt\" }))\n        \"Encrypt file\"\n    , Option \"d\" [\"decrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"decrypt\" }))\n        \"Decrypt file (default)\"\n    , Option \"g\" [\"generate\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"generate\" }))\n        \"Generate a one-time pad\"\n    , Option \"i\" [\"input\"]\n        (ReqArg\n            (\\arg opt -> return opt { optInput = TI.readFile arg })\n            \"FILE\")\n        \"Input file (for decryption and encryption)\"\n    , Option \"o\" [\"output\"]\n        (ReqArg\n            (\\arg opt -> return opt { optOutput = TI.writeFile arg })\n            \"FILE\")\n        \"Output file (for generation, decryption, and encryption)\"\n    , Option \"p\" [\"pad\"]\n        (ReqArg\n            (\\arg opt -> return opt { optPad = (TI.readFile arg,\n                                                TI.writeFile arg) })\n            \"FILE\")\n        \"One-time pad to use (for decryption and encryption)\"\n    , Option \"l\" [\"lines\"]\n        (ReqArg\n            (\\arg opt -> return opt { optLines = read arg :: Int })\n            \"LINES\")\n        \"New one-time pad's length (in lines of 48 characters) (for generation)\"\n    , Option \"V\" [\"version\"]\n        (NoArg\n            (\\_ -> do\n                hPutStrLn stderr \"Version 0.01\"\n                exitWith ExitSuccess))\n        \"Print version\"\n    , Option \"h\" [\"help\"]\n        (NoArg\n            (\\_ -> do\n                prg <- getProgName\n                putStrLn \"usage: OneTimePad [-h] [-V] [\n                hPutStrLn stderr (usageInfo prg options)\n                exitWith ExitSuccess))\n        \"Show this help message and exit\"\n    ]\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let (actions, nonOptions, errors) = getOpt RequireOrder options args\n  opts <- Prelude.foldl (>>=) (return startOptions) actions\n  let Options { optCommand = command\n              , optInput   = input\n              , optOutput  = output\n              , optPad     = (inPad, outPad)\n              , optLines   = linecnt } = opts\n\n  case command of\n    \"generate\" -> generate linecnt output\n    \"encrypt\"  -> do\n      inputContents <- clean <$> input\n      padContents <- inPad\n      output $ format $ encrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n    \"decrypt\"  -> do\n      inputContents <- unformat <$> input\n      padContents <- inPad\n      output $ decrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n      let discardLines = ceiling\n            $ ((/) `on` fromIntegral) (T.length inputContents) 48\n      outPad $ discard discardLines $ T.lines padContents\n\n\ndiscard :: Int -> [T.Text] -> T.Text\ndiscard 0 ts = T.unlines ts\ndiscard x (t:ts) = if (T.head t == '-' || T.head t == '#')\n  then T.unlines [t, (discard x ts)]\n  else T.unlines [(T.append (T.pack \"- \") t), (discard (x-1) ts)]\n\n\nclean :: T.Text -> T.Text\nclean = T.map toUpper . T.filter (\\c -> let oc = ord c\n                                   in oc >= 65 && oc <= 122\n                                   && (not $ oc >=91 && oc <= 96))\n\n\nformat :: T.Text -> T.Text\nformat = T.unlines . map (T.intercalate (T.pack \" \") . T.chunksOf 6)\n  . T.chunksOf 48\n\n\nunformat :: T.Text -> T.Text\nunformat = T.filter (\\c -> c/='\\n' && c/=' ')\n\n\ngenerate :: Int -> (T.Text -> IO ()) -> IO ()\ngenerate lines output = do\n  withBinaryFile \"/dev/random\" ReadMode\n    (\\handle -> do\n        contents <- replicateM (48 * lines) $ hGetChar handle\n        time <- getCurrentTime\n        output\n          $ T.unlines [ T.pack\n                        $ \"# OTP pad, generated by https://github.com/kssytsrk/one-time-pad on \"\n                        ++ show time\n                      , format $ T.pack\n                        $ map (chr . (65 +) . flip mod 26 . ord) contents\n                      ])\n\n\ncrypt :: (Int -> Int -> Int) -> T.Text -> T.Text -> T.Text\ncrypt f = T.zipWith ((chr .) . f `on` ord)\n\n\nencrypt :: T.Text -> T.Text -> T.Text\nencrypt = crypt ((((+65) . flip mod 26 . subtract 130) .) . (+))\n\n\ndecrypt :: T.Text -> T.Text -> T.Text\ndecrypt = crypt ((((+65) . flip mod 26) .) . (-))\n", "target": "\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n\nMAGIC = \"\n\n\ndef make_keys(n, size):\n    \n    \n    \n    \n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \n    pad = [\n        MAGIC,\n        f\"\n        f\"\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    \n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    \n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    \n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n"}
{"id": 418934, "name": "Functional coverage tree", "source": "Translate Haskell to Python: \n\nimport Data.Bifunctor (first)\nimport Data.Bool (bool)\nimport Data.Char (isSpace)\nimport qualified Data.Text as T\nimport qualified Data.Text.IO as T\nimport qualified Data.Text.Read as T\nimport Data.Tree (Forest, Tree (..), foldTree)\nimport Numeric (showFFloat)\nimport System.Directory (doesFileExist)\n\n\n\ndata Coverage = Coverage\n  { name :: T.Text,\n    weight :: Float,\n    coverage :: Float,\n    share :: Float\n  }\n  deriving (Show)\n\n\nfp = \"./coverageOutline.txt\"\n\nmain :: IO ()\nmain =\n  doesFileExist fp\n    >>= bool\n      (print $ \"File not found: \" <> fp)\n      (T.readFile fp >>= T.putStrLn . updatedCoverageOutline)\n\n\nupdatedCoverageOutline :: T.Text -> T.Text\nupdatedCoverageOutline s =\n  let delimiter = \"|\"\n      indentedLines = T.lines s\n      columnNames =\n        init $\n          tokenizeWith\n            delimiter\n            ( head indentedLines\n            )\n   in T.unlines\n        [ tabulation\n            delimiter\n            (columnNames <> [\"SHARE OF RESIDUE\"]),\n          indentedLinesFromTree\n            \"    \"\n            (showCoverage delimiter)\n            $ withResidueShares 1.0 $\n              foldTree\n                weightedCoverage\n                (parseTreeFromOutline delimiter indentedLines)\n        ]\n\n\nweightedCoverage ::\n  Coverage ->\n  Forest Coverage ->\n  Tree Coverage\nweightedCoverage x xs =\n  let cws = ((,) . coverage <*> weight) . rootLabel <$> xs\n      totalWeight = foldr ((+) . snd) 0 cws\n   in Node\n        ( x\n            { coverage =\n                foldr\n                  (\\(c, w) a -> (c * w) + a)\n                  (coverage x)\n                  cws\n                  / bool 1 totalWeight (0 < totalWeight)\n            }\n        )\n        xs\n\nwithResidueShares :: Float -> Tree Coverage -> Tree Coverage\nwithResidueShares shareOfTotal tree =\n  let go fraction node =\n        let forest = subForest node\n            weights = weight . rootLabel <$> forest\n            weightTotal = sum weights\n            nodeRoot = rootLabel node\n         in Node\n              ( nodeRoot\n                  { share =\n                      fraction\n                        * (1 - coverage nodeRoot)\n                  }\n              )\n              ( zipWith\n                  go\n                  ((fraction *) . (/ weightTotal) <$> weights)\n                  forest\n              )\n   in go shareOfTotal tree\n\n\nparseTreeFromOutline :: T.Text -> [T.Text] -> Tree Coverage\nparseTreeFromOutline delimiter indentedLines =\n  partialRecord . tokenizeWith delimiter\n    <$> head\n      ( forestFromLineIndents $\n          indentLevelsFromLines $ tail indentedLines\n      )\n\nforestFromLineIndents :: [(Int, T.Text)] -> [Tree T.Text]\nforestFromLineIndents pairs =\n  let go [] = []\n      go ((n, s) : xs) =\n        let (firstTreeLines, rest) = span ((n <) . fst) xs\n         in Node s (go firstTreeLines) : go rest\n   in go pairs\n\nindentLevelsFromLines :: [T.Text] -> [(Int, T.Text)]\nindentLevelsFromLines xs =\n  let pairs = T.span isSpace <$> xs\n      indentUnit =\n        foldr\n          ( \\x a ->\n              let w = (T.length . fst) x\n               in bool a w (w < a && 0 < w)\n          )\n          (maxBound :: Int)\n          pairs\n   in first (flip div indentUnit . T.length) <$> pairs\n\npartialRecord :: [T.Text] -> Coverage\npartialRecord xs =\n  let [name, weightText, coverageText] =\n        take\n          3\n          (xs <> repeat \"\")\n   in Coverage\n        { name = name,\n          weight = defaultOrRead 1.0 weightText,\n          coverage = defaultOrRead 0.0 coverageText,\n          share = 0.0\n        }\n\ndefaultOrRead :: Float -> T.Text -> Float\ndefaultOrRead n txt = either (const n) fst $ T.rational txt\n\ntokenizeWith :: T.Text -> T.Text -> [T.Text]\ntokenizeWith delimiter = fmap T.strip . T.splitOn delimiter\n\n\nindentedLinesFromTree ::\n  T.Text ->\n  (T.Text -> a -> T.Text) ->\n  Tree a ->\n  T.Text\nindentedLinesFromTree tab showRoot tree =\n  let go indent node =\n        showRoot indent (rootLabel node) :\n        (subForest node >>= go (T.append tab indent))\n   in T.unlines $ go \"\" tree\n\nshowCoverage :: T.Text -> T.Text -> Coverage -> T.Text\nshowCoverage delimiter indent x =\n  tabulation\n    delimiter\n    ( [T.append indent (name x), T.pack (showN 0 (weight x))]\n        <> (T.pack . showN 4 <$> ([coverage, share] <*> [x]))\n    )\n\ntabulation :: T.Text -> [T.Text] -> T.Text\ntabulation delimiter =\n  T.intercalate (T.append delimiter \" \")\n    . zipWith (`T.justifyLeft` ' ') [31, 9, 9, 9]\n\njustifyRight :: Int -> a -> [a] -> [a]\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n\nshowN :: Int -> Float -> String\nshowN p n = justifyRight 7 ' ' (showFFloat (Just p) n \"\")\n", "target": "from itertools import zip_longest\n\n\nfc2 = \n\nNAME, WT, COV = 0, 1, 2\n\ndef right_type(txt):\n    try:\n        return float(txt)\n    except ValueError:\n        return txt\n\ndef commas_to_list(the_list, lines, start_indent=0):\n    \n    for n, line in lines:\n        indent = 0\n        while line.startswith(' ' * (4 * indent)):\n            indent += 1\n        indent -= 1\n        fields = [right_type(f) for f in line.strip().split(',')]\n        if indent == start_indent:\n            the_list.append(fields)\n        elif indent > start_indent:\n            lst = [fields]\n            sub = commas_to_list(lst, lines, indent)\n            the_list[-1] = (the_list[-1], lst)\n            if sub not in (None, ['']) :\n                the_list.append(sub)\n        else:\n            return fields if fields else None\n    return None\n\n\ndef pptreefields(lst, indent=0, widths=['%-32s', '%-8g', '%-10g']):\n    \n    lhs = ' ' * (4 * indent)\n    for item in lst:\n        if type(item) != tuple:\n            name, *rest = item\n            print(widths[0] % (lhs + name), end='|')\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\n                if type(item) == str:\n                    width = width[:-1] + 's'\n                print(width % item, end='|')\n            print()\n        else:\n            item, children = item\n            name, *rest = item\n            print(widths[0] % (lhs + name), end='|')\n            for width, item in zip_longest(widths[1:len(rest)], rest, fillvalue=widths[-1]):\n                if type(item) == str:\n                    width = width[:-1] + 's'\n                print(width % item, end='|')\n            print()\n            pptreefields(children, indent+1)\n\n\ndef default_field(node_list):\n    node_list[WT] = node_list[WT] if node_list[WT] else 1.0\n    node_list[COV] = node_list[COV] if node_list[COV] else 0.0\n\ndef depth_first(tree, visitor=default_field):\n    for item in tree:\n        if type(item) == tuple:\n            item, children = item\n            depth_first(children, visitor)\n        visitor(item)\n            \n\ndef covercalc(tree):\n    \n    sum_covwt, sum_wt = 0, 0\n    for item in tree:\n        if type(item) == tuple:\n            item, children = item\n            item[COV] = covercalc(children)\n        sum_wt  += item[WT]\n        sum_covwt += item[COV] * item[WT]\n    cov = sum_covwt / sum_wt\n    return cov\n\nif __name__ == '__main__':        \n    lstc = []\n    commas_to_list(lstc, ((n, ln) for n, ln in enumerate(fc2.split('\\n'))))\n    \n    \n    \n    depth_first(lstc)\n    \n    \n    print('\\n\\nTOP COVERAGE = %f\\n' % covercalc(lstc))\n    depth_first(lstc)\n    pptreefields(['NAME_HIERARCHY WEIGHT COVERAGE'.split()] + lstc)\n"}
{"id": 418935, "name": "Graph colouring", "source": "Translate Haskell to Python: import Data.Maybe\nimport Data.List\nimport Control.Monad.State\nimport qualified Data.Map as M\nimport Text.Printf\n\n\n\n\ntype Node = Int\ntype Color = Int\ntype Graph = M.Map Node [Node]\n\nnodes :: Graph -> [Node]\nnodes = M.keys\n\nadjacentNodes :: Graph -> Node -> [Node]\nadjacentNodes g n = fromMaybe [] $ M.lookup n g \n\ndegree :: Graph -> Node -> Int \ndegree g = length . adjacentNodes g\n\nfromList :: [(Node, [Node])] -> Graph\nfromList  = foldr add M.empty\n  where\n    add (a, bs) g = foldr (join [a]) (join bs a g) bs\n    join = flip (M.insertWith (++))\n\nreadGraph :: String -> Graph\nreadGraph = fromList . map interprete . words\n  where\n    interprete s = case span (/= '-') s of\n      (a, \"\") -> (read a, [])\n      (a, '-':b) -> (read a, [read b])\n\n\n\n\nuncolored :: Node -> State [(Node, Color)] Bool\nuncolored n = isNothing <$> colorOf n\n\ncolorOf :: Node -> State [(Node, Color)] (Maybe Color)\ncolorOf n = gets (lookup n)\n\ngreedyColoring :: Graph -> [(Node, Color)]\ngreedyColoring g = mapM_ go (nodes g) `execState` []\n  where\n    go n = do\n      c <- colorOf n\n      when (isNothing c) $ do\n        adjacentColors <- nub . catMaybes <$> mapM colorOf (adjacentNodes g n)\n        let newColor = head $ filter (`notElem` adjacentColors) [1..]\n        modify ((n, newColor) :)\n      filterM uncolored (adjacentNodes g n) >>= mapM_ go\n\nwpColoring :: Graph -> [(Node, Color)]\nwpColoring g = go [1..] nodesList `execState` []\n  where\n    nodesList = sortOn (negate . degree g) (nodes g)\n\n    go _ [] = pure ()\n    go (c:cs) ns = do \n      mark c ns \n      filterM uncolored ns >>= go cs\n\n    mark c [] = pure () :: State [(Node, Color)] ()\n    mark c (n:ns) = do \n      modify ((n, c) :) \n      mark c (filter (`notElem` adjacentNodes g n) ns)\n", "target": "import re\nfrom collections import defaultdict\nfrom itertools import count\n\n\nconnection_re = r\n\nclass Graph:\n\n    def __init__(self, name, connections):\n        self.name = name\n        self.connections = connections\n        g = self.graph = defaultdict(list)  \n\n        matches = re.finditer(connection_re, connections,\n                              re.MULTILINE | re.VERBOSE)\n        for match in matches:\n            n1, n2, n = match.groups()\n            if n:\n                g[n] += []\n            else:\n                g[n1].append(n2)    \n                g[n2].append(n1)\n\n    def greedy_colour(self, order=None):\n        \"Greedy colourisation algo.\"\n        if order is None:\n            order = self.graph      \n        colour = self.colour = {}\n        neighbours = self.graph\n        for node in order:\n            used_neighbour_colours = (colour[nbr] for nbr in neighbours[node]\n                                      if nbr in colour)\n            colour[node] = first_avail_int(used_neighbour_colours)\n        self.pp_colours()\n        return colour\n\n    def pp_colours(self):\n        print(f\"\\n{self.name}\")\n        c = self.colour\n        e = canonical_edges = set()\n        for n1, neighbours in sorted(self.graph.items()):\n            if neighbours:\n                for n2 in neighbours:\n                    edge = tuple(sorted([n1, n2]))\n                    if edge not in canonical_edges:\n                        print(f\"       {n1}-{n2}: Colour: {c[n1]}, {c[n2]}\")\n                        canonical_edges.add(edge)\n            else:\n                print(f\"         {n1}: Colour: {c[n1]}\")\n        lc = len(set(c.values()))\n        print(f\"    \n\n\ndef first_avail_int(data):\n    \"return lowest int 0... not in data\"\n    d = set(data)\n    for i in count():\n        if i not in d:\n            return i\n\n\nif __name__ == '__main__':\n    for name, connections in [\n            ('Ex1', \"0-1 1-2 2-0 3\"),\n            ('Ex2', \"1-6 1-7 1-8 2-5 2-7 2-8 3-5 3-6 3-8 4-5 4-6 4-7\"),\n            ('Ex3', \"1-4 1-6 1-8 3-2 3-6 3-8 5-2 5-4 5-8 7-2 7-4 7-6\"),\n            ('Ex4', \"1-6 7-1 8-1 5-2 2-7 2-8 3-5 6-3 3-8 4-5 4-6 4-7\"),\n            ]:\n        g = Graph(name, connections)\n        g.greedy_colour()\n"}
{"id": 418936, "name": "Faces from a mesh", "source": "Translate Haskell to Python: import Data.List (find, delete, (\\\\))\nimport Control.Applicative ((<|>))\n\n\n\nnewtype Perimeter a = Perimeter [a]\n  deriving Show\n\ninstance Eq a => Eq (Perimeter a) where\n  Perimeter p1 == Perimeter p2 =\n    null (p1 \\\\ p2)\n    && ((p1 `elem` zipWith const (iterate rotate p2) p1)\n        || Perimeter p1 == Perimeter (reverse p2))\n\nrotate lst = zipWith const (tail (cycle lst)) lst\n\ntoEdges :: Ord a => Perimeter a -> Maybe (Edges a)\ntoEdges (Perimeter ps)\n  | allDifferent ps = Just . Edges $ zipWith ord ps (tail (cycle ps))\n  | otherwise = Nothing\n  where\n    ord a b = if a < b then (a, b) else (b, a)\n\nallDifferent [] = True\nallDifferent (x:xs) = all (x /=) xs && allDifferent xs\n\n\n\nnewtype Edges a = Edges [(a, a)]\n  deriving Show\n\ninstance Eq a => Eq (Edges a) where\n  e1 == e2 = toPerimeter e1 == toPerimeter e2\n\ntoPerimeter :: Eq a => Edges a -> Maybe (Perimeter a)\ntoPerimeter (Edges ((a, b):es)) = Perimeter . (a :) <$> go b es\n  where\n    go x rs\n      | x == a = return []\n      | otherwise = do\n          p <- find ((x ==) . fst) rs <|> find ((x ==) . snd) rs\n          let next = if fst p == x then snd p else fst p\n          (x :) <$> go next (delete p rs)\n", "target": "def perim_equal(p1, p2):\n    \n    if len(p1) != len(p2) or set(p1) != set(p2):\n        return False\n    if any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1))):\n        return True\n    p2 = p2[::-1] \n    return any(p2 == (p1[n:] + p1[:n]) for n in range(len(p1)))\n\ndef edge_to_periphery(e):\n    edges = sorted(e)\n    p = list(edges.pop(0)) if edges else []\n    last = p[-1] if p else None\n    while edges:\n        for n, (i, j) in enumerate(edges):\n            if i == last:\n                p.append(j)\n                last = j\n                edges.pop(n)\n                break\n            elif j == last:\n                p.append(i)\n                last = i\n                edges.pop(n)\n                break\n        else:\n            \n            return \">>>Error! Invalid edge format<<<\"\n    return p[:-1]\n\nif __name__ == '__main__':\n    print('Perimeter format equality checks:')\n    for eq_check in [\n            { 'Q': (8, 1, 3),\n              'R': (1, 3, 8)},\n            { 'U': (18, 8, 14, 10, 12, 17, 19),\n              'V': (8, 14, 10, 12, 17, 19, 18)} ]:\n        (n1, p1), (n2, p2) = eq_check.items()\n        eq = '==' if perim_equal(p1, p2) else '!='\n        print(' ', n1, eq, n2)\n\n    print('\\nEdge to perimeter format translations:')\n    edge_d = {\n     'E': {(1, 11), (7, 11), (1, 7)},\n     'F': {(11, 23), (1, 17), (17, 23), (1, 11)},\n     'G': {(8, 14), (17, 19), (10, 12), (10, 14), (12, 17), (8, 18), (18, 19)},\n     'H': {(1, 3), (9, 11), (3, 11), (1, 11)}\n            }\n    for name, edges in edge_d.items():\n        print(f\"  {name}: {edges}\\n     -> {edge_to_periphery(edges)}\")\n"}

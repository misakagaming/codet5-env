{"id": 331679, "name": "Pascal matrix generation", "source": "Translate Fortran to C#: module pascal\n\nimplicit none\n\ncontains\n    function pascal_lower(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(i, 1) = 1\n        end do\n        do i = 2, n\n            do j = 2, i\n                a(i, j) = a(i - 1, j) + a(i - 1, j - 1)\n            end do\n        end do\n    end function\n    \n    function pascal_upper(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(1, i) = 1\n        end do\n        do i = 2, n\n            do j = 2, i\n                a(j, i) = a(j, i - 1) + a(j - 1, i - 1)\n            end do\n        end do\n    end function\n\n    function pascal_symmetric(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(i, 1) = 1\n            a(1, i) = 1\n        end do\n        do i = 2, n\n            do j = 2, n\n                a(i, j) = a(i - 1, j) + a(i, j - 1)\n            end do\n        end do\n    end function\n\n    subroutine print_matrix(a)\n        integer :: a(:, :)\n        integer :: n, i\n        n = ubound(a, 1)\n        do i = 1, n\n            print *, a(i, :)\n        end do\n    end subroutine\nend module\n\nprogram ex_pascal\n    use pascal\n    implicit none\n    integer :: n\n    integer, allocatable :: a(:, :)\n    print *, \"Size?\"\n    read *, n\n    print *, \"Lower Pascal Matrix\"\n    a = pascal_lower(n)\n    call print_matrix(a)\n    print *, \"Upper Pascal Matrix\"\n    a = pascal_upper(n)\n    call print_matrix(a)\n    print *, \"Symmetric Pascal Matrix\"\n    a = pascal_symmetric(n)\n    call print_matrix(a)\nend program\n", "target": "using System;\n\npublic static class PascalMatrixGeneration\n{\n    public static void Main() {\n        Print(GenerateUpper(5));\n        Console.WriteLine();\n        Print(GenerateLower(5));\n        Console.WriteLine();\n        Print(GenerateSymmetric(5));\n    }\n\n    static int[,] GenerateUpper(int size) {\n        int[,] m = new int[size, size];\n        for (int c = 0; c < size; c++) m[0, c] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = r; c < size; c++) {\n                m[r, c] = m[r-1, c-1] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateLower(int size) {\n        int[,] m = new int[size, size];\n        for (int r = 0; r < size; r++) m[r, 0] = 1;\n        for (int c = 1; c < size; c++) {\n            for (int r = c; r < size; r++) {\n                m[r, c] = m[r-1, c-1] + m[r-1, c];\n            }\n        }\n        return m;\n    }\n\n    static int[,] GenerateSymmetric(int size) {\n        int[,] m = new int[size, size];\n        for (int i = 0; i < size; i++) m[0, i] = m[i, 0] = 1;\n        for (int r = 1; r < size; r++) {\n            for (int c = 1; c < size; c++) {\n                m[r, c] = m[r-1, c] + m[r, c-1];\n            }\n        }\n        return m;\n    }\n\n    static void Print(int[,] matrix) {\n        string[,] m = ToString(matrix);\n        int width = m.Cast<string>().Select(s => s.Length).Max();\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        for (int row = 0; row < rows; row++) {\n            Console.WriteLine(\"|\" + string.Join(\" \", Range(0, columns).Select(column => m[row, column].PadLeft(width, ' '))) + \"|\");\n        }\n    }\n\n    static string[,] ToString(int[,] matrix) {\n        int rows = matrix.GetLength(0), columns = matrix.GetLength(1);\n        string[,] m = new string[rows, columns];\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < columns; c++) {\n                m[r, c] = matrix[r, c].ToString();\n            }\n        }\n        return m;\n    }\n    \n}\n"}
{"id": 331680, "name": "Mad Libs", "source": "Translate Fortran to C#:       MODULE MADLIB\t\n       INTEGER MSG,KBD,INF\t\t\n       DATA MSG,KBD,INF/6,5,10/\t\t\n       INTEGER LSTASH,NSTASH,MSTASH\t\n       PARAMETER (LSTASH = 246810, MSTASH = 6666)\t\n       CHARACTER*(LSTASH) STASH\t\t\n       INTEGER ISTASH(MSTASH + 1)\t\n       DATA NSTASH,ISTASH(1)/0,1/\t\n       INTEGER MANYLINES,MANYTESTS\t\n       PARAMETER (MANYLINES = 1234)\t\n       INTEGER NSTORY,STORY(MANYLINES)\t\n       PARAMETER (MANYTESTS = 1234)\t\n       INTEGER NTESTS,TARGET(MANYTESTS),REPLACEMENT(MANYTESTS)\t\n       DATA NSTORY,NTESTS/0,0/\t\t\n       INTEGER STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 28)\t\n\n       CONTAINS\n        SUBROUTINE CROAK(GASP)\t\n         CHARACTER*(*) GASP\t\n         WRITE (MSG,*) \"Oh dear.\"\t\n         WRITE (MSG,*) GASP\t\t\n         STOP \"How sad.\"\t\t\n        END SUBROUTINE CROAK\t\n\n        SUBROUTINE SHOWSTASH(BLAH,I)\t\n         CHARACTER*(*) BLAH\t\t\n         INTEGER I\t\t\t\n          WRITE (MSG,1) BLAH,I,STASH(ISTASH(I):ISTASH(I + 1) - 1)\t\n    1     FORMAT (A,': Text(',I0,')=\"',A,'\"')\t\n        END SUBROUTINE SHOWSTASH\t\n\n        INTEGER FUNCTION EATTEXT(IN)\t\nCo-opts the as-yet unused space in STASH as its scratchpad.\n         INTEGER IN\t\n         INTEGER I,N,L\t\n          I = ISTASH(NSTASH + 1)\n          N = LSTASH - I + 1\t\n          IF (N.LT.666) CALL CROAK(\"Insufficient STASH space remains\n          READ (IN,1,END = 66) L,STASH(I:I + MIN(L,N) - 1)\t\n    1     FORMAT (Q,A)\t\t\n          L = I + MIN(L,N) - 1\t\n   10     IF (L.LT.I) GO TO 66\t\n          IF (ICHAR(STASH(L:L)).LE.ICHAR(\" \")) THEN\t\n            L = L - 1\t\t\n            GO TO 10\t\t\n          END IF\t\t\n          IF (NSTASH.GE.MSTASH) CALL CROAK(\"Too many texts\n          NSTASH = NSTASH + 1\t\n          ISTASH(NSTASH + 1) = L + 1\t\n          EATTEXT = NSTASH\t\n         RETURN\t\t\t\n   66     EATTEXT = 0\t\t\n        END FUNCTION EATTEXT\t\n\n        INTEGER FUNCTION ADDSTASH(TEXT)\t\n         CHARACTER*(*) TEXT\t\n         INTEGER I\t\t\n          IF (NSTASH.GE.MSTASH) CALL CROAK(\"The text pool is crowded\n          I = ISTASH(NSTASH + 1)\t\n          IF (I + LEN(TEXT).GT.LSTASH) CALL CROAK(\"Overtexted\n          STASH(I:I + LEN(TEXT) - 1) = TEXT\t\n          NSTASH = NSTASH + 1\t\t\t\n          ISTASH(NSTASH + 1) = I + LEN(TEXT)\t\n          ADDSTASH = NSTASH\t\n        END FUNCTION ADDSTASH\t\n\n        INTEGER FUNCTION ANOTHER(TEXT)\t\nCollects TARGET REPLACEMENT pairs (increasing NTESTS) as directed by INSPECT.\n         CHARACTER*(*) TEXT\t\n         INTEGER I,IT\t\t\n          ANOTHER = 0\t\t\n          DO I = 1,NTESTS\t\n            IT = TARGET(I)\t\t\n            IF (TEXT.EQ.STASH(ISTASH(IT):ISTASH(IT + 1) - 1)) RETURN\t\n          END DO\t\t\n          IF (NTESTS.GE.MANYTESTS) CALL CROAK(\"Too many tests\n          NTESTS = NTESTS + 1\t\t\n          TARGET(NTESTS) = ADDSTASH(TEXT)\n          ANOTHER = NTESTS\t\t\n          WRITE (MSG,1) TEXT\t\t\n    1     FORMAT (\"Enter your text for \",A,\": \",$)\t\n          REPLACEMENT(NTESTS) = EATTEXT(KBD)\t\n        END FUNCTION ANOTHER\t\n\n        SUBROUTINE INSPECT(X)\t\nCalls for inspection of REPLACEMENT texts as well, should ANOTHER report a new entry.\n         INTEGER X\t\n         INTEGER MARK\t\n         INTEGER IT,NEW\t\n         INTEGER I\t\n         INTEGER SP,STACK(STACKLIMIT)\t\n          SP = 1\t\t\n          STACK(1) = X\t\t\n          DO WHILE(SP.GT.0)\t\n            IT = STACK(SP)\t\t\n            SP = SP - 1\t\t\t\n            MARK = 0\t\t\t\n            DO I = ISTASH(IT),ISTASH(IT + 1) - 1\n              IF (STASH(I:I).EQ.\"<\") THEN\t\n                MARK = I\t\t\t\n              ELSE IF (STASH(I:I).EQ.\">\") THEN\t\n                IF (MARK.LE.0) CALL CROAK(\"A > with no preceeding <\n                NEW = ANOTHER(STASH(MARK:I))\t\n                IF (NEW.GT.0) THEN\t\t\n                  IF (SP.GE.STACKLIMIT) CALL CROAK(\"Stack overflow\n                  SP = SP + 1\t\t\t\n                  STACK(SP) = REPLACEMENT(NEW)\t\n                END IF\t\t\t\n                MARK = 0\t\t\n              END IF\t\t\n            END DO\t\t\n          END DO\t\n        END SUBROUTINE INSPECT\t\n\n        SUBROUTINE READSTORY(IN)\n         INTEGER IN\t\t\n         INTEGER LINE\t\t\n   10    LINE = EATTEXT(IN)\t\n         IF (LINE.GT.0) THEN\t\n           NSTORY = NSTORY + 1\t\n           STORY(NSTORY) = LINE\t\n           CALL INSPECT(LINE)\t\n           GO TO 10\t\t\n         END IF\t\t\t\n        END SUBROUTINE READSTORY\n\n        SUBROUTINE WRITESTORY(WIDTH)\t\nCo-opts the as-yet unused space in STASH as its output scratchpad.\nCan't rely on changing the index and bounds of a DO-loop on the fly.\n         INTEGER WIDTH\n         INTEGER LINE,IT,I,J\t\n         INTEGER L,L0,N\t\t\n         INTEGER TAIL,MARK,LAST\t\n         INTEGER SP,STACKI(STACKLIMIT),STACKL(STACKLIMIT)\t\n          L0 = ISTASH(NSTASH + 1)\t\n          L = L0 - 1\t\t\t\n       LL:DO LINE = 1,NSTORY\t\t\n            SP = 0\t\t\t\n            IT = STORY(LINE)\t\t\n            LAST = ISTASH(IT + 1) - 1\t\n            I = ISTASH(IT)\t\t\n            TAIL = I - 1\t\t\n            IF (STASH(I:I).LE.\" \") THEN\t\n              CALL BURP\t\t\t\n            ELSE IF (LINE.GT.1) THEN\t\n              L = L + 1\t\t\t\n              STASH(L:L) = \" \"\t\t\n            END IF\t\t\t\n  666    II:DO WHILE(I.LE.LAST)\t\t\n              IF (STASH(I:I).EQ.\"<\") THEN\t\n                MARK = I\t\t\t\n              ELSE IF (STASH(I:I).EQ.\">\") THEN\t\n                CALL APPEND(TAIL + 1,MARK - 1)\t\n             JJ:DO J = 1,NTESTS\t\t\n                  IT = TARGET(J)\t\t\n                  IF (STASH(ISTASH(IT):ISTASH(IT + 1) - 1)\t\n     1            .EQ.STASH(MARK:I)) THEN\t\t\n                    IT = REPLACEMENT(J)\t\t\n                    IF (IT.GT.0) THEN\t\n                      IF (SP.GE.STACKLIMIT) CALL CROAK(\"StackOverflow\n                      SP = SP + 1\t\t\n                      STACKI(SP) = I\t\t\n                      STACKL(SP) = LAST\t\t\n                      I = ISTASH(IT) - 1\t\n                      LAST = ISTASH(IT + 1) - 1\t\n                    END IF\t\t\t\n                    EXIT JJ\t\t\n                  END IF\t\t\n                END DO JJ\t\t\n                TAIL = I\t\t\n              END IF\t\t\t\n              I = I + 1\t\t\t\n            END DO II\t\t\n            IF (SP.GT.0) THEN\t\n              CALL APPEND(TAIL + 1,LAST)\n              TAIL = STACKI(SP)\t\t\n              LAST = STACKL(SP)\t\t\n              SP = SP - 1\t\t\n              I = TAIL + 1\t\t\n              GO TO 666\t\t\t\n            END IF\t\t\n            CALL APPEND(TAIL + 1,LAST)\t\n          END DO LL\t\t\t\n          CALL BURP\t\t\n         CONTAINS\t\t\n          SUBROUTINE APPEND(IST,LST)\t\n           INTEGER IST,LST\t\t\n           INTEGER N\t\t\t\n            N = LST - IST + 1\t\t\n            IF (N.LE.0) RETURN\t\t\n            IF (L + N.GT.LSTASH) CALL CROAK(\"Out of stash\n            STASH(L + 1:L + N) = STASH(IST:LST)\t\n            L = L + N\t\t\t\n            IF (L - L0 + 1.GE.WIDTH) CALL BURP\t\n          END SUBROUTINE APPEND\t\t\n          SUBROUTINE BURP\t\t\n           INTEGER N,W,L1\t\t\n            N = L - L0 + 1\t\t\n            IF (N.LE.WIDTH) THEN\t\n              L1 = L\t\t\t\n             ELSE\t\t\t\n              W = L0 + WIDTH - 1\t\n              DO L1 = W,L0,-1\t\t\n                IF (STASH(L1:L1).LE.\" \") EXIT\t\n              END DO\t\t\t\n              IF (L1.LE.L0) L1 = W\t\n            END IF\t\t\t\n            WRITE (MSG,\"(A)\") STASH(L0:L1)\t\n            IF (N.LE.WIDTH) THEN\t\n              L = L0 - 1\t\t\n             ELSE\t\t\t\n              W = L0 + L - L1 - 1\t\n              STASH(L0:W) = STASH(L1 + 1:L)\t\n              L = W\t\t\t\n            END IF\t\t\t\n          END SUBROUTINE BURP\t\t\n        END SUBROUTINE WRITESTORY\t\n      END MODULE MADLIB\t\t\n\n      PROGRAM MADLIBBER\t\n      USE MADLIB\n      WRITE (MSG,1)\t\n    10FORMAT (\"Reads a story in template form, containing special \",\n     1 \"entries such as <dog's name> amongst the text.\",/,\n     2 \"You will be invited to supply a replacement text for each \"\n     3 \"such entry, as encountered,\",/,\n     4 \"after which the story will be presented with your \",\n     5 \"substitutions made.\",//,\n     6 \"Here goes... Reading file Madlib.txt\",/)\n      OPEN(INF,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\",\n     1 FILE = \"Madlib.txt\")\n      CALL READSTORY(INF)\n      CLOSE(INF)\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"  Righto\n      WRITE (MSG,*)\n      CALL WRITESTORY(66)\n      END\n", "target": "using System;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\n\nnamespace MadLibs_RosettaCode\n{\n\tclass Program\n\t{\n\t\tstatic void Main(string[] args)\n\t\t{\n\t\t\tstring madLibs = \n@\"Write a program to create a Mad Libs like story.\nThe program should read an arbitrary multiline story from input.\nThe story will be terminated with a blank line.\nThen, find each replacement to be made within the story, \nask the user for a word to replace it with, and make all the replacements.\nStop when there are none left and print the final story.\nThe input should be an arbitrary story in the form:\n<name> went for a walk in the park. <he or she>\nfound a <noun>. <name> decided to take it home.\nGiven this example, it should then ask for a name, \na he or she and a noun (<name> gets replaced both times with the same value).\";\n\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tRegex pattern = new Regex(@\"\\<(.*?)\\>\");\n\t\t\tstring storyLine;\n\t\t\tstring replacement;\n\n\t\t\tConsole.WriteLine(madLibs + Environment.NewLine + Environment.NewLine);\n\t\t\tConsole.WriteLine(\"Enter a story: \");\n\n\t\t\t\n\t\t\tdo\n\t\t\t{\n\t\t\t\tstoryLine = Console.ReadLine();\n\t\t\t\tsb.Append(storyLine + Environment.NewLine);\n\t\t\t} while (!string.IsNullOrEmpty(storyLine) && !string.IsNullOrWhiteSpace(storyLine));\n\n\t\t\t\n\t\t\tMatch nameMatch = pattern.Matches(sb.ToString()).OfType<Match>().Where(x => x.Value.Equals(\"<name>\")).Select(x => x.Value).Distinct() as Match;\n\t\t\tif(nameMatch != null)\n\t\t\t{\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + nameMatch.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\t\t\t\tsb.Replace(nameMatch.Value, replacement);\n\t\t\t}\n\n\t\t\tforeach (Match match in pattern.Matches(sb.ToString()))\n\t\t\t{\n\t\t\t\treplacement = string.Empty;\n\t\t\t\t\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\tConsole.WriteLine(\"Enter value for: \" + match.Value);\n\t\t\t\t\treplacement = Console.ReadLine();\n\t\t\t\t} while (string.IsNullOrEmpty(replacement) || string.IsNullOrWhiteSpace(replacement));\n\n\t\t\t\tint location = sb.ToString().IndexOf(match.Value);\n\t\t\t\tsb.Remove(location, match.Value.Length).Insert(location, replacement);\n\t\t\t}\n\n\t\t\tConsole.WriteLine(Environment.NewLine + Environment.NewLine + \"--[ Here's your story! ]--\");\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t}\n}\n"}
{"id": 331681, "name": "Long year", "source": "Translate Fortran to C#: program longyear\n    use iso_fortran_env, only: output_unit, input_unit\n    implicit none\n\n    integer             :: start, ende, i, counter\n    integer, parameter  :: line_break=10\n\n    write(output_unit,*) \"Enter beginning of interval\"\n    read(input_unit,*) start\n    write(output_unit,*) \"Enter end of interval\"\n    read(input_unit,*) ende\n\n    if (start>=ende) error stop \"Last year must be after first year\n\n    counter = 0\n    do i = start, ende\n        if (is_long_year(i)) then\n            write(output_unit,'(I0,x)', advance=\"no\") i\n            counter = counter + 1\n            if (modulo(counter,line_break) == 0) write(output_unit,*)\n        end if\n    end do\ncontains\n    pure function p(year)\n        integer, intent(in) :: year\n        integer             :: p\n\n        p = modulo(year + year/4 - year/100 + year/400, 7)\n    end function p\n\n    pure function is_long_year(year)\n        integer, intent(in) :: year\n        logical             :: is_long_year\n\n        is_long_year = p(year) == 4 .or. p(year-1) == 3\n    end function is_long_year\nend program longyear\n", "target": "using static System.Console;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Globalization;\n\npublic static class Program\n{\n    public static void Main()\n    {\n        WriteLine(\"Long years in the 21st century:\");\n        WriteLine(string.Join(\" \", 2000.To(2100).Where(y => ISOWeek.GetWeeksInYear(y) == 53)));\n    }\n    \n    public static IEnumerable<int> To(this int start, int end) {\n        for (int i = start; i < end; i++) yield return i;\n    }\n    \n}\n"}
{"id": 331682, "name": "Magic 8-ball", "source": "Translate Fortran to C#: PROGRAM EIGHT_BALL\n    CHARACTER(LEN=100) :: RESPONSE\n    CHARACTER(LEN=100) :: QUESTION\n    CHARACTER(LEN=100), DIMENSION(20) :: RESPONSES\n    REAL :: R\n\n    CALL RANDOM_SEED()\n\n    RESPONSES(1) = \"It is certain\" \n    RESPONSES(2) = \"It is decidedly so\"\n    RESPONSES(3) = \"Without a doubt\"\n    RESPONSES(4) = \"Yes, definitely\"\n    RESPONSES(5) = \"You may rely on it\"\n    RESPONSES(6) = \"As I see it, yes\"\n    RESPONSES(7) = \"Most likely\"\n    RESPONSES(8) = \"Outlook good\"\n    RESPONSES(9) = \"Signs point to yes\"\n    RESPONSES(10) = \"Yes\"\n    RESPONSES(11) = \"Reply hazy, try again\"\n    RESPONSES(12) = \"Ask again later\"\n    RESPONSES(13) = \"Better not tell you now\"\n    RESPONSES(14) = \"Cannot predict now\"\n    RESPONSES(15) = \"Concentrate and ask again\"\n    RESPONSES(16) = \"Don't bet on it\"\n    RESPONSES(17) = \"My reply is no\"\n    RESPONSES(18) = \"My sources say no\"\n    RESPONSES(19) = \"Outlook not so good\"\n    RESPONSES(20) = \"Very doubtful\"\n\n    WRITE(*,*) \"Welcome to 8 Ball\n    WRITE(*,*) \"you seek, type either 'quit' or 'q' to exit\", NEW_LINE('A')\n\n    DO WHILE(.TRUE.)\n        PRINT*, \"Ask your question: \"\n        READ(*,*) QUESTION\n        IF(QUESTION == \"q\" .OR. QUESTION == \"quit\") THEN\n            CALL EXIT(0)\n        ENDIF\n        CALL RANDOM_NUMBER(R)\n        PRINT*, \"Response: \", TRIM(RESPONSES(FLOOR(R*20))), NEW_LINE('A')\n    ENDDO\nEND PROGRAM EIGHT_BALL\n", "target": "using System;\n\nnamespace newProg\n{\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string[] answers =\n            {\n                \"It is certain.\",\n                \"It is decidedly so.\",\n                \"Without a doubt.\",\n                \"Yes \u2013 definitely.\",\n                \"You may rely on it.\",\n                \"As I see it, yes.\",\n                \"Most likely.\",\n                \"Outlook good.\",\n                \"Yes.\",\n                \"Signs point to yes.\",\n                \"Reply hazy, try again.\",\n                \"Ask again later\",\n                \"Better not tell you now.\",\n                \"Cannot predict now.\",\n                \"Concentrate and ask again.\",\n                \"Don't count on it.\",\n                \"My reply is no.\",\n                \"My sources say no.\",\n                \"Outlook not so good.\",\n                \"Very doubtful.\"\n            };\n\n            while (true)\n            {\n                Random rnd = new Random();\n                int result = rnd.Next(0, 19);\n\n                Console.WriteLine(\"Magic 8 Ball! Ask question and hit a key for the answer!\");\n\n                string inp = Console.ReadLine();\n                \n                Console.WriteLine(answers[result]);\n\n            }\n        }\n    }\n}\n"}
{"id": 331683, "name": "Validate International Securities Identification Number", "source": "Translate Fortran to C#: program isin\n    use ctype\n    implicit none\n    character(20) :: test(7) = [\"US0378331005        \", &\n                                \"US0373831005        \", &\n                                \"U50378331005        \", &\n                                \"US03378331005       \", &\n                                \"AU0000XVGZA3        \", &\n                                \"AU0000VXGZA3        \", &\n                                \"FR0000988040        \"]\n    print *, check_isin(test)\ncontains\n    elemental logical function check_isin(a)\n        character(*), intent(in) :: a\n        integer :: s(24)\n        integer :: i, j, k, n, v\n\n        check_isin = .false.\n\n        n = len_trim(a)\n        if (n /= 12) return\n        \n        \n        j = 0\n        do i = 1, n\n            k = iachar(a(i:i))\n            if (k >= 48 .and. k <= 57) then\n                if (i < 3) return\n                k = k - 48\n                j = j + 1\n                s(j) = k\n            else if (k >= 65 .and. k <= 90) then\n                if (i == 12) return\n                k = k - 65 + 10\n                j = j + 1\n                s(j) = k / 10\n                j = j + 1\n                s(j) = mod(k, 10)\n            else\n                return\n            end if\n        end do\n\n        \n        v = 0\n        do i = j - 1, 1, -2\n            k = 2 * s(i)\n            if (k > 9) k = k - 9\n            v = v + k\n        end do\n        do i = j, 1, -2\n            v = v + s(i)\n        end do\n        \n        check_isin = 0 == mod(v, 10)\n    end function\nend program\n", "target": "using System;\nusing System.Linq;\nusing System.Text.RegularExpressions;\n\nnamespace ValidateIsin\n{\n    public static class IsinValidator\n    {\n        public static bool IsValidIsin(string isin) => \n            IsinRegex.IsMatch(isin) && LuhnTest(Digitize(isin));\n\n        private static readonly Regex IsinRegex = \n            new Regex(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\", RegexOptions.Compiled);\n\n        private static string Digitize(string isin) =>\n            string.Join(\"\", isin.Select(c => $\"{DigitValue(c)}\"));\n\n        private static bool LuhnTest(string number) => \n            number.Reverse().Select(DigitValue).Select(Summand).Sum() % 10 == 0;\n\n        private static int Summand(int digit, int i) =>\n            digit + (i % 2) * (digit - digit / 5 * 9);\n\n        private static int DigitValue(char c) =>\n            c >= '0' && c <= '9' \n                ? c - '0' \n                : c - 'A' + 10;\n   }\n\t\n   public class Program\n   {\n        public static void Main() \n        {\n            string[] isins = \n            {\n                \"US0378331005\",\n                \"US0373831005\",\n                \"U50378331005\",\n                \"US03378331005\",\n                \"AU0000XVGZA3\",\n                \"AU0000VXGZA3\",\n                \"FR0000988040\"\n            };\n\n            foreach (string isin in isins) {\n                string validOrNot = IsinValidator.IsValidIsin(isin) ? \"valid\" : \"not valid\";\n                Console.WriteLine($\"{isin} is {validOrNot}\");\n            }\n        }\n    }\n}\n"}
{"id": 331684, "name": "Input_Output for pairs of numbers", "source": "Translate Fortran to C#: program i_o_pairs\n  implicit none\n\n  integer :: npairs\n  integer :: i\n  integer, allocatable :: pairs(:,:)\n\n  read(*,*) npairs\n  allocate(pairs(npairs,2))\n \n  do i = 1, npairs\n    read(*,*) pairs(i,:)\n  end do\n  write(*, \"(i0)\") sum(pairs, 2)\n\nend program\n", "target": "using System;\nusing static System.Linq.Enumerable;\n\npublic class Program\n{\n    static void Main(string[] args)\n    {\n\tint count = Convert.ToInt32(Console.ReadLine());\n\tfor (int line = 0; line < count; line++) {\n            Console.WriteLine(Console.ReadLine().Split(' ').Sum(i => Convert.ToInt32(i)));\n\t}\n    }\n}\n"}
{"id": 331685, "name": "Kahan summation", "source": "Translate Fortran to C#:       FUNCTION SUMC(A,N)\nCOMPENSATED SUMMATION. C WILL NOT STAY ZERO, DESPITE MATHEMATICS.\n       DIMENSION A(12345)\n        S = 0.0\n        C = 0.0\n        DO 1 I = 1,N\n          Y = A(I) - C\n          T = S + Y\n          C = (T - S) - Y\n          S = T\n    1   CONTINUE\n        SUMC = S\n      END\n      DIMENSION A(3)\n      A(1) = 10000.0\n      A(2) = 3.14159\n      A(3) = 2.71828\n      TYPE 1, A(1) + A(2) + A(3)\n      TYPE 1, SUMC(A,3)\n    1 FORMAT (6HSUM = ,F12.1)\n      END\n", "target": "using System;\n\nnamespace KahanSummation {\n    class Program {\n        static float KahanSum(params float[] fa) {\n            float sum = 0.0f;\n            float c = 0.0f;\n            foreach (float f in fa) {\n                float y = f - c;\n                float t = sum + y;\n                c = (t - sum) - y;\n                sum = t;\n            }\n\n            return sum;\n        }\n\n        static float Epsilon() {\n            float eps = 1.0f;\n            while (1.0f + eps != 1.0f) eps /= 2.0f;\n            return eps;\n        }\n\n        static void Main(string[] args) {\n            float a = 1.0f;\n            float b = Epsilon();\n            float c = -b;\n            Console.WriteLine(\"Epsilon      = {0}\", b);\n            Console.WriteLine(\"(a + b) + c  = {0}\", (a + b) + c);\n            Console.WriteLine(\"Kahan sum    = {0}\", KahanSum(a, b, c));\n        }\n    }\n}\n"}
{"id": 331686, "name": "Two identical strings", "source": "Translate Fortran to C#:       program IdentStr\n          implicit none\n          integer n, concat, bits\n          \n          n = 1\n  100     if (concat(n) .lt. 1000) then\n              write (*,'(I3,2X,I11)') concat(n), bits(concat(n))\n              n = n + 1\n              goto 100\n          end if\n          stop\n      end\n\nC     Concatenate binary representation of number with itself      \n      integer function concat(num)\n          integer num, sl, sr\n          sl = num\n          sr = num\n  100     if (sr .gt. 0) then\n              sl = sl * 2\n              sr = sr / 2\n              goto 100\n          end if\n          concat = num + sl\n      end\n\nC     Calculate binary representation of number\n      integer function bits(num)\n          integer num, n, bx\n          n = num\n          bits = 0\n          bx = 1\n  100     if (n .gt. 0) then\n              bits = bits + bx * mod(n,2)\n              bx = bx * 10\n              n = n / 2\n              goto 100\n          end if\n      end\n", "target": "using System; using static System.Console;\nclass Program { static void Main() { int c = 0, lmt = 1000;\n    for (int n = 1, p = 2, k; n <= lmt; n++)\n      if ((k = n + n * (p += n >= p ? p : 0)) > lmt) break;\n      else Console.Write(\"{0,3} ({1,-10})  {2}\", k,\n          Convert.ToString(k, 2), ++c % 5 == 0 ? \"\\n\" : \"\");\n    Write(\"\\nFound {0} numbers whose base 2 representation is the \" +\n      \"concatenation of two identical binary strings.\", c); } }\n"}
{"id": 331687, "name": "Flow-control structures", "source": "Translate Fortran to C#:       ...\n      ASSIGN 1101 to WHENCE   \n      GO TO 1000              \n 1101 CONTINUE                \n      ... \n      ASSIGN 1102 to WHENCE   \n      GO TO 1000              \n 1102 CONTINUE                \n      ...\nCommon code, far away.\n 1000 do something            \n      GO TO WHENCE            \n", "target": "int GetNumber() {\n    return 5;\n}\n"}
{"id": 331688, "name": "Boolean values", "source": "Translate Fortran to C#:       TYPE MIXED\n       LOGICAL*1 LIVE\n       REAL*8    VALUE\n      END TYPE MIXED\n      TYPE(MIXED) STUFF(100)\n", "target": "bool? value = null\n"}
{"id": 331689, "name": "Address of a variable", "source": "Translate Fortran to C#: program test_loc\n  implicit none\n\n  integer :: i\n  real    :: r\n\n  i = loc(r)\n  print *, i\nend program\n", "target": "int i = 5;\nint* p = &i;\n"}
{"id": 331690, "name": "2048", "source": "Translate Fortran to C#:         WRITE (MSG,1)\t\t\n    1   FORMAT (\"|\",<NC>(<W>(\"-\"),\"|\"))\t\n    2     FORMAT (\"|\",<NC>(<W>(\" \"),\"|\"))\t\n          WRITE (MSG,22) ((\" \",L1  = 1,W),\"|\",C = 1,NC)\t\n   22     FORMAT (\"|\",666A1)\t\t\t\t\n    4     FORMAT (\"|\",<NC - 1>(<W>(\"-\"),\"+\"),<W>(\"-\"),\"|\")\t\n", "target": "using System;\n\nnamespace g2048_csharp\n{\n    internal class Tile\n    {\n        public Tile()\n        {\n            Value = 0;\n            IsBlocked = false;\n        }\n\n        public int Value { get; set; }\n        public bool IsBlocked { get; set; }\n    }\n\n    internal enum MoveDirection\n    {\n        Up,\n        Down,\n        Left,\n        Right\n    }\n\n    internal class G2048\n    {\n        public G2048()\n        {\n            _isDone = false;\n            _isWon = false;\n            _isMoved = true;\n            _score = 0;\n            InitializeBoard();\n        }\n\n        private void InitializeBoard()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    _board[x, y] = new Tile();\n                }\n            }\n        }\n\n        private bool _isDone;\n        private bool _isWon;\n        private bool _isMoved;\n        private int _score;\n        private readonly Tile[,] _board = new Tile[4, 4];\n        private readonly Random _rand = new Random();\n\n        public void Loop()\n        {\n            AddTile();\n            while (true)\n            {\n                if (_isMoved)\n                {\n                    AddTile();\n                }\n\n                DrawBoard();\n                if (_isDone)\n                {\n                    break;\n                }\n\n                WaitKey();\n            }\n\n            string endMessage = _isWon ? \"You've made it!\" : \"Game Over!\";\n            Console.WriteLine(endMessage);\n        }\n\n        private void DrawBoard()\n        {\n            Console.Clear();\n            Console.WriteLine(\"Score: \" + _score + \"\\n\");\n            for (int y = 0; y < 4; y++)\n            {\n                Console.WriteLine(\"+------+------+------+------+\");\n                Console.Write(\"| \");\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value == 0)\n                    {\n                        const string empty = \" \";\n                        Console.Write(empty.PadRight(4));\n                    }\n                    else\n                    {\n                        Console.Write(_board[x, y].Value.ToString().PadRight(4));\n                    }\n\n                    Console.Write(\" | \");\n                }\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"+------+------+------+------+\\n\\n\");\n        }\n\n        private void WaitKey()\n        {\n            _isMoved = false;\n            Console.WriteLine(\"(W) Up (S) Down (A) Left (D) Right\");\n            char input;\n            char.TryParse(Console.ReadKey().Key.ToString(), out input);\n\n            switch (input)\n            {\n                case 'W':\n                    Move(MoveDirection.Up);\n                    break;\n                case 'A':\n                    Move(MoveDirection.Left);\n                    break;\n                case 'S':\n                    Move(MoveDirection.Down);\n                    break;\n                case 'D':\n                    Move(MoveDirection.Right);\n                    break;\n            }\n\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    _board[x, y].IsBlocked = false;\n                }\n            }\n        }\n\n        private void AddTile()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value != 0) continue;\n                    int a, b;\n                    do\n                    {\n                        a = _rand.Next(0, 4);\n                        b = _rand.Next(0, 4);\n                    } while (_board[a, b].Value != 0);\n\n                    double r = _rand.NextDouble();\n                    _board[a, b].Value = r > 0.89f ? 4 : 2;\n\n                    if (CanMove())\n                    {\n                        return;\n                    }\n                }\n            }\n\n            _isDone = true;\n        }\n\n        private bool CanMove()\n        {\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (_board[x, y].Value == 0)\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            for (int y = 0; y < 4; y++)\n            {\n                for (int x = 0; x < 4; x++)\n                {\n                    if (TestAdd(x + 1, y, _board[x, y].Value)\n                        || TestAdd(x - 1, y, _board[x, y].Value)\n                        || TestAdd(x, y + 1, _board[x, y].Value)\n                        || TestAdd(x, y - 1, _board[x, y].Value))\n                    {\n                        return true;\n                    }\n                }\n            }\n\n            return false;\n        }\n\n        private bool TestAdd(int x, int y, int value)\n        {\n            if (x < 0 || x > 3 || y < 0 || y > 3)\n            {\n                return false;\n            }\n\n            return _board[x, y].Value == value;\n        }\n\n        private void MoveVertically(int x, int y, int d)\n        {\n            if (_board[x, y + d].Value != 0\n                && _board[x, y + d].Value == _board[x, y].Value\n                && !_board[x, y].IsBlocked\n                && !_board[x, y + d].IsBlocked)\n            {\n                _board[x, y].Value = 0;\n                _board[x, y + d].Value *= 2;\n                _score += _board[x, y + d].Value;\n                _board[x, y + d].IsBlocked = true;\n                _isMoved = true;\n            }\n            else if (_board[x, y + d].Value == 0\n                     && _board[x, y].Value != 0)\n            {\n                _board[x, y + d].Value = _board[x, y].Value;\n                _board[x, y].Value = 0;\n                _isMoved = true;\n            }\n\n            if (d > 0)\n            {\n                if (y + d < 3)\n                {\n                    MoveVertically(x, y + d, 1);\n                }\n            }\n            else\n            {\n                if (y + d > 0)\n                {\n                    MoveVertically(x, y + d, -1);\n                }\n            }\n        }\n\n        private void MoveHorizontally(int x, int y, int d)\n        {\n            if (_board[x + d, y].Value != 0\n                && _board[x + d, y].Value == _board[x, y].Value\n                && !_board[x + d, y].IsBlocked\n                && !_board[x, y].IsBlocked)\n            {\n                _board[x, y].Value = 0;\n                _board[x + d, y].Value *= 2;\n                _score += _board[x + d, y].Value;\n                _board[x + d, y].IsBlocked = true;\n                _isMoved = true;\n            }\n            else if (_board[x + d, y].Value == 0\n                     && _board[x, y].Value != 0)\n            {\n                _board[x + d, y].Value = _board[x, y].Value;\n                _board[x, y].Value = 0;\n                _isMoved = true;\n            }\n\n            if (d > 0)\n            {\n                if (x + d < 3)\n                {\n                    MoveHorizontally(x + d, y, 1);\n                }\n            }\n            else\n            {\n                if (x + d > 0)\n                {\n                    MoveHorizontally(x + d, y, -1);\n                }\n            }\n        }\n\n        private void Move(MoveDirection direction)\n        {\n            switch (direction)\n            {\n                case MoveDirection.Up:\n                    for (int x = 0; x < 4; x++)\n                    {\n                        int y = 1;\n                        while (y < 4)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveVertically(x, y, -1);\n                            }\n\n                            y++;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Down:\n                    for (int x = 0; x < 4; x++)\n                    {\n                        int y = 2;\n                        while (y >= 0)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveVertically(x, y, 1);\n                            }\n\n                            y--;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Left:\n                    for (int y = 0; y < 4; y++)\n                    {\n                        int x = 1;\n                        while (x < 4)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveHorizontally(x, y, -1);\n                            }\n\n                            x++;\n                        }\n                    }\n\n                    break;\n                case MoveDirection.Right:\n                    for (int y = 0; y < 4; y++)\n                    {\n                        int x = 2;\n                        while (x >= 0)\n                        {\n                            if (_board[x, y].Value != 0)\n                            {\n                                MoveHorizontally(x, y, 1);\n                            }\n\n                            x--;\n                        }\n                    }\n\n                    break;\n            }\n        }\n    }\n\n    internal static class Program\n    {\n        public static void Main(string[] args)\n        {\n            RunGame();\n        }\n\n        private static void RunGame()\n        {\n            G2048 game = new G2048();\n            game.Loop();\n\n            CheckRestart();\n        }\n\n        private static void CheckRestart()\n        {\n            Console.WriteLine(\"(N) New game (P) Exit\");\n            while (true)\n            {\n                char input;\n                char.TryParse(Console.ReadKey().Key.ToString(), out input);\n                switch (input)\n                {\n                    case 'N':\n                        RunGame();\n                        break;\n                    case 'P':\n                        return;\n                    default:\n                        ClearLastLine();\n                        break;\n                }\n            }\n        }\n\n        private static void ClearLastLine()\n        {\n            Console.SetCursorPosition(0, Console.CursorTop);\n            Console.Write(new string(' ', Console.BufferWidth));\n            Console.SetCursorPosition(0, Console.CursorTop - 1);\n        }\n    }\n}\n"}
{"id": 331691, "name": "Loops_Infinite", "source": "Translate Fortran to C#:       \n   10 WRITE(*,*) 'SPAM'\n      GO TO 10\n      END\n", "target": "while (true)\n{\n    Console.WriteLine(\"SPAM\");\n}\n"}
{"id": 331692, "name": "Brazilian numbers", "source": "Translate Fortran to C#: \n\n      PROGRAM BRAZILIAN\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  MAX_NUMBER = 2000000 , NUMVARS = 20\n\n\n\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  b\n      INTEGER  ::  bcount\n      INTEGER  ::  bpos\n      CHARACTER(15)  ::  holder\n      CHARACTER(100)  ::  outline\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  p\n\n\n\n\n\n\n      CALL BRAZILIANSIEVE(b , MAX_NUMBER)\n      WRITE(6 , 34)\"The first 20 Brazilian numbers:\"\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n \n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 odd Brazilian numbers:\"\n      outline = ''\n      holder = ''\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 2\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 prime Brazilian numbers:\"\n      CALL ERATOSTHENES(p , MAX_NUMBER)\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) .AND. p(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"Various Brazilian numbers:\"\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<1000000 )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            IF( (bcount==100) .OR. (bcount==1000) .OR. (bcount==10000) .OR.               &\n              & (bcount==100000) .OR. (bcount==1000000) )WRITE(* , *)bcount ,             &\n               &\"th Brazilian number: \" , bpos\n         END IF\n         bpos = bpos + 1\n      END DO\n      STOP\n 34   FORMAT(/ , a)\n      END PROGRAM BRAZILIAN\n\n      SUBROUTINE BRAZILIANSIEVE(B , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  B\n      INTENT (IN) N\n      INTENT (OUT) B\n\n\n\n      INTEGER  ::  b11\n      INTEGER  ::  base\n      INTEGER  ::  bn\n      INTEGER  ::  bnn\n      INTEGER  ::  bpower\n      INTEGER  ::  digit\n      INTEGER  ::  i\n      LOGICAL  ::  iseven\n      INTEGER  ::  powermax\n\n      iseven = .FALSE.\n      B(1:6) = .FALSE.                 \n      DO i = 7 , N\n         B(i) = iseven\n         iseven = .NOT.iseven\n      END DO\n      DO base = 2 , (N/2)\n         b11 = base + 1\n         bnn = b11\n         DO digit = 3 , base - 1 , 2\n            bnn = bnn + b11 + b11\n            IF( bnn>N )EXIT\n            B(bnn) = .TRUE.\n         END DO\n      END DO\n      DO base = 2 , INT(SQRT(FLOAT(N)))\n         powermax = HUGE(powermax)/base             \n         IF( powermax>N )powermax = N               \n         DO digit = 1 , base - 1 , 2\n            bpower = base*base\n            bn = digit*(bpower + base + 1)\n            DO WHILE ( (bn<=N) .AND. (bpower<=powermax) )\n               IF( bn<=N )B(bn) = .TRUE.\n               bpower = bpower*base\n               bn = bn + (digit*bpower)\n            END DO\n         END DO\n      END DO\n      RETURN\n      END SUBROUTINE BRAZILIANSIEVE\n\n      SUBROUTINE ERATOSTHENES(P , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  P\n      INTENT (IN) N\n      INTENT (INOUT) P\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  ii\n      LOGICAL  ::  oddeven\n      INTEGER  ::  pr\n\n      P(1) = .FALSE.\n      P(2) = .TRUE.\n      oddeven = .TRUE.\n      DO i = 3 , N\n         P(i) = oddeven\n         oddeven = .NOT.oddeven\n      END DO\n      DO i = 2 , INT(SQRT(FLOAT(N)))\n         ii = i + i\n         IF( P(i) )THEN\n            DO pr = i*i , N , ii\n               P(pr) = .FALSE.\n            END DO\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE ERATOSTHENES\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 331693, "name": "Brazilian numbers", "source": "Translate Fortran to C#: \n\n      PROGRAM BRAZILIAN\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  MAX_NUMBER = 2000000 , NUMVARS = 20\n\n\n\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  b\n      INTEGER  ::  bcount\n      INTEGER  ::  bpos\n      CHARACTER(15)  ::  holder\n      CHARACTER(100)  ::  outline\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  p\n\n\n\n\n\n\n      CALL BRAZILIANSIEVE(b , MAX_NUMBER)\n      WRITE(6 , 34)\"The first 20 Brazilian numbers:\"\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n \n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 odd Brazilian numbers:\"\n      outline = ''\n      holder = ''\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 2\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 prime Brazilian numbers:\"\n      CALL ERATOSTHENES(p , MAX_NUMBER)\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) .AND. p(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"Various Brazilian numbers:\"\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<1000000 )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            IF( (bcount==100) .OR. (bcount==1000) .OR. (bcount==10000) .OR.               &\n              & (bcount==100000) .OR. (bcount==1000000) )WRITE(* , *)bcount ,             &\n               &\"th Brazilian number: \" , bpos\n         END IF\n         bpos = bpos + 1\n      END DO\n      STOP\n 34   FORMAT(/ , a)\n      END PROGRAM BRAZILIAN\n\n      SUBROUTINE BRAZILIANSIEVE(B , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  B\n      INTENT (IN) N\n      INTENT (OUT) B\n\n\n\n      INTEGER  ::  b11\n      INTEGER  ::  base\n      INTEGER  ::  bn\n      INTEGER  ::  bnn\n      INTEGER  ::  bpower\n      INTEGER  ::  digit\n      INTEGER  ::  i\n      LOGICAL  ::  iseven\n      INTEGER  ::  powermax\n\n      iseven = .FALSE.\n      B(1:6) = .FALSE.                 \n      DO i = 7 , N\n         B(i) = iseven\n         iseven = .NOT.iseven\n      END DO\n      DO base = 2 , (N/2)\n         b11 = base + 1\n         bnn = b11\n         DO digit = 3 , base - 1 , 2\n            bnn = bnn + b11 + b11\n            IF( bnn>N )EXIT\n            B(bnn) = .TRUE.\n         END DO\n      END DO\n      DO base = 2 , INT(SQRT(FLOAT(N)))\n         powermax = HUGE(powermax)/base             \n         IF( powermax>N )powermax = N               \n         DO digit = 1 , base - 1 , 2\n            bpower = base*base\n            bn = digit*(bpower + base + 1)\n            DO WHILE ( (bn<=N) .AND. (bpower<=powermax) )\n               IF( bn<=N )B(bn) = .TRUE.\n               bpower = bpower*base\n               bn = bn + (digit*bpower)\n            END DO\n         END DO\n      END DO\n      RETURN\n      END SUBROUTINE BRAZILIANSIEVE\n\n      SUBROUTINE ERATOSTHENES(P , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  P\n      INTENT (IN) N\n      INTENT (INOUT) P\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  ii\n      LOGICAL  ::  oddeven\n      INTEGER  ::  pr\n\n      P(1) = .FALSE.\n      P(2) = .TRUE.\n      oddeven = .TRUE.\n      DO i = 3 , N\n         P(i) = oddeven\n         oddeven = .NOT.oddeven\n      END DO\n      DO i = 2 , INT(SQRT(FLOAT(N)))\n         ii = i + i\n         IF( P(i) )THEN\n            DO pr = i*i , N , ii\n               P(pr) = .FALSE.\n            END DO\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE ERATOSTHENES\n", "target": "using System;\nclass Program {\n \n  static bool sameDigits(int n, int b) {\n    int f = n % b;\n    while ((n /= b) > 0) if (n % b != f) return false;\n    return true;\n  }\n \n  static bool isBrazilian(int n) {\n    if (n < 7) return false;\n    if (n % 2 == 0) return true;\n    for (int b = 2; b < n - 1; b++) if (sameDigits(n, b)) return true;\n    return false;\n  }\n \n  static bool isPrime(int n) {\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n    int d = 5;\n    while (d * d <= n) {\n      if (n % d == 0) return false; d += 2;\n      if (n % d == 0) return false; d += 4;\n    }\n    return true;\n  }\n \n  static void Main(string[] args) {\n    foreach (string kind in \",odd ,prime \".Split(',')) {\n      bool quiet = false; int BigLim = 99999, limit = 20;\n      Console.WriteLine(\"First {0} {1}Brazilian numbers:\", limit, kind);\n      int c = 0, n = 7;\n      while (c < BigLim) {\n        if (isBrazilian(n)) {\n          if (!quiet) Console.Write(\"{0:n0} \", n);\n          if (++c == limit) { Console.Write(\"\\n\\n\"); quiet = true; }\n        }\n        if (quiet && kind != \"\") continue;\n        switch (kind) {\n          case \"\": n++; break;\n          case \"odd \": n += 2; break;\n          case \"prime \":\n            while (true) {\n              n += 2;\n              if (isPrime(n)) break;\n            } break;\n        }\n      }\n      if (kind == \"\") Console.WriteLine(\"The {0:n0}th Brazilian number is: {1:n0}\\n\", BigLim + 1, n);\n    }\n  }\n}\n"}
{"id": 331694, "name": "Execute HQ9+", "source": "Translate Fortran to C#: \"bottle\" // IF (B.NE.1) THEN \"s\" FI // \" of beer\"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 336221, "name": "Pascal matrix generation", "source": "Translate Fortran to Java: module pascal\n\nimplicit none\n\ncontains\n    function pascal_lower(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(i, 1) = 1\n        end do\n        do i = 2, n\n            do j = 2, i\n                a(i, j) = a(i - 1, j) + a(i - 1, j - 1)\n            end do\n        end do\n    end function\n    \n    function pascal_upper(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(1, i) = 1\n        end do\n        do i = 2, n\n            do j = 2, i\n                a(j, i) = a(j, i - 1) + a(j - 1, i - 1)\n            end do\n        end do\n    end function\n\n    function pascal_symmetric(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(i, 1) = 1\n            a(1, i) = 1\n        end do\n        do i = 2, n\n            do j = 2, n\n                a(i, j) = a(i - 1, j) + a(i, j - 1)\n            end do\n        end do\n    end function\n\n    subroutine print_matrix(a)\n        integer :: a(:, :)\n        integer :: n, i\n        n = ubound(a, 1)\n        do i = 1, n\n            print *, a(i, :)\n        end do\n    end subroutine\nend module\n\nprogram ex_pascal\n    use pascal\n    implicit none\n    integer :: n\n    integer, allocatable :: a(:, :)\n    print *, \"Size?\"\n    read *, n\n    print *, \"Lower Pascal Matrix\"\n    a = pascal_lower(n)\n    call print_matrix(a)\n    print *, \"Upper Pascal Matrix\"\n    a = pascal_upper(n)\n    call print_matrix(a)\n    print *, \"Symmetric Pascal Matrix\"\n    a = pascal_symmetric(n)\n    call print_matrix(a)\nend program\n", "target": "import static java.lang.System.out;\nimport java.util.List;\nimport java.util.function.Function;\nimport java.util.stream.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class PascalMatrix {\n    static int binomialCoef(int n, int k) {\n        int result = 1;\n        for (int i = 1; i <= k; i++)\n            result = result * (n - i + 1) / i;\n        return result;\n    }\n\n    static List<IntStream> pascal(int n, Function<Integer, IntStream> f) {\n        return range(0, n).mapToObj(i -> f.apply(i)).collect(toList());\n    }\n\n    static List<IntStream> pascalUpp(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(j, i)));\n    }\n\n    static List<IntStream> pascalLow(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i, j)));\n    }\n\n    static List<IntStream> pascalSym(int n) {\n        return pascal(n, i -> range(0, n).map(j -> binomialCoef(i + j, i)));\n    }\n\n    static void print(String label, List<IntStream> result) {\n        out.println(\"\\n\" + label);\n        for (IntStream row : result) {\n            row.forEach(i -> out.printf(\"%2d \", i));\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] a) {\n        print(\"Upper: \", pascalUpp(5));\n        print(\"Lower: \", pascalLow(5));\n        print(\"Symmetric:\", pascalSym(5));\n    }\n}\n"}
{"id": 336222, "name": "Mad Libs", "source": "Translate Fortran to Java:       MODULE MADLIB\t\n       INTEGER MSG,KBD,INF\t\t\n       DATA MSG,KBD,INF/6,5,10/\t\t\n       INTEGER LSTASH,NSTASH,MSTASH\t\n       PARAMETER (LSTASH = 246810, MSTASH = 6666)\t\n       CHARACTER*(LSTASH) STASH\t\t\n       INTEGER ISTASH(MSTASH + 1)\t\n       DATA NSTASH,ISTASH(1)/0,1/\t\n       INTEGER MANYLINES,MANYTESTS\t\n       PARAMETER (MANYLINES = 1234)\t\n       INTEGER NSTORY,STORY(MANYLINES)\t\n       PARAMETER (MANYTESTS = 1234)\t\n       INTEGER NTESTS,TARGET(MANYTESTS),REPLACEMENT(MANYTESTS)\t\n       DATA NSTORY,NTESTS/0,0/\t\t\n       INTEGER STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 28)\t\n\n       CONTAINS\n        SUBROUTINE CROAK(GASP)\t\n         CHARACTER*(*) GASP\t\n         WRITE (MSG,*) \"Oh dear.\"\t\n         WRITE (MSG,*) GASP\t\t\n         STOP \"How sad.\"\t\t\n        END SUBROUTINE CROAK\t\n\n        SUBROUTINE SHOWSTASH(BLAH,I)\t\n         CHARACTER*(*) BLAH\t\t\n         INTEGER I\t\t\t\n          WRITE (MSG,1) BLAH,I,STASH(ISTASH(I):ISTASH(I + 1) - 1)\t\n    1     FORMAT (A,': Text(',I0,')=\"',A,'\"')\t\n        END SUBROUTINE SHOWSTASH\t\n\n        INTEGER FUNCTION EATTEXT(IN)\t\nCo-opts the as-yet unused space in STASH as its scratchpad.\n         INTEGER IN\t\n         INTEGER I,N,L\t\n          I = ISTASH(NSTASH + 1)\n          N = LSTASH - I + 1\t\n          IF (N.LT.666) CALL CROAK(\"Insufficient STASH space remains\n          READ (IN,1,END = 66) L,STASH(I:I + MIN(L,N) - 1)\t\n    1     FORMAT (Q,A)\t\t\n          L = I + MIN(L,N) - 1\t\n   10     IF (L.LT.I) GO TO 66\t\n          IF (ICHAR(STASH(L:L)).LE.ICHAR(\" \")) THEN\t\n            L = L - 1\t\t\n            GO TO 10\t\t\n          END IF\t\t\n          IF (NSTASH.GE.MSTASH) CALL CROAK(\"Too many texts\n          NSTASH = NSTASH + 1\t\n          ISTASH(NSTASH + 1) = L + 1\t\n          EATTEXT = NSTASH\t\n         RETURN\t\t\t\n   66     EATTEXT = 0\t\t\n        END FUNCTION EATTEXT\t\n\n        INTEGER FUNCTION ADDSTASH(TEXT)\t\n         CHARACTER*(*) TEXT\t\n         INTEGER I\t\t\n          IF (NSTASH.GE.MSTASH) CALL CROAK(\"The text pool is crowded\n          I = ISTASH(NSTASH + 1)\t\n          IF (I + LEN(TEXT).GT.LSTASH) CALL CROAK(\"Overtexted\n          STASH(I:I + LEN(TEXT) - 1) = TEXT\t\n          NSTASH = NSTASH + 1\t\t\t\n          ISTASH(NSTASH + 1) = I + LEN(TEXT)\t\n          ADDSTASH = NSTASH\t\n        END FUNCTION ADDSTASH\t\n\n        INTEGER FUNCTION ANOTHER(TEXT)\t\nCollects TARGET REPLACEMENT pairs (increasing NTESTS) as directed by INSPECT.\n         CHARACTER*(*) TEXT\t\n         INTEGER I,IT\t\t\n          ANOTHER = 0\t\t\n          DO I = 1,NTESTS\t\n            IT = TARGET(I)\t\t\n            IF (TEXT.EQ.STASH(ISTASH(IT):ISTASH(IT + 1) - 1)) RETURN\t\n          END DO\t\t\n          IF (NTESTS.GE.MANYTESTS) CALL CROAK(\"Too many tests\n          NTESTS = NTESTS + 1\t\t\n          TARGET(NTESTS) = ADDSTASH(TEXT)\n          ANOTHER = NTESTS\t\t\n          WRITE (MSG,1) TEXT\t\t\n    1     FORMAT (\"Enter your text for \",A,\": \",$)\t\n          REPLACEMENT(NTESTS) = EATTEXT(KBD)\t\n        END FUNCTION ANOTHER\t\n\n        SUBROUTINE INSPECT(X)\t\nCalls for inspection of REPLACEMENT texts as well, should ANOTHER report a new entry.\n         INTEGER X\t\n         INTEGER MARK\t\n         INTEGER IT,NEW\t\n         INTEGER I\t\n         INTEGER SP,STACK(STACKLIMIT)\t\n          SP = 1\t\t\n          STACK(1) = X\t\t\n          DO WHILE(SP.GT.0)\t\n            IT = STACK(SP)\t\t\n            SP = SP - 1\t\t\t\n            MARK = 0\t\t\t\n            DO I = ISTASH(IT),ISTASH(IT + 1) - 1\n              IF (STASH(I:I).EQ.\"<\") THEN\t\n                MARK = I\t\t\t\n              ELSE IF (STASH(I:I).EQ.\">\") THEN\t\n                IF (MARK.LE.0) CALL CROAK(\"A > with no preceeding <\n                NEW = ANOTHER(STASH(MARK:I))\t\n                IF (NEW.GT.0) THEN\t\t\n                  IF (SP.GE.STACKLIMIT) CALL CROAK(\"Stack overflow\n                  SP = SP + 1\t\t\t\n                  STACK(SP) = REPLACEMENT(NEW)\t\n                END IF\t\t\t\n                MARK = 0\t\t\n              END IF\t\t\n            END DO\t\t\n          END DO\t\n        END SUBROUTINE INSPECT\t\n\n        SUBROUTINE READSTORY(IN)\n         INTEGER IN\t\t\n         INTEGER LINE\t\t\n   10    LINE = EATTEXT(IN)\t\n         IF (LINE.GT.0) THEN\t\n           NSTORY = NSTORY + 1\t\n           STORY(NSTORY) = LINE\t\n           CALL INSPECT(LINE)\t\n           GO TO 10\t\t\n         END IF\t\t\t\n        END SUBROUTINE READSTORY\n\n        SUBROUTINE WRITESTORY(WIDTH)\t\nCo-opts the as-yet unused space in STASH as its output scratchpad.\nCan't rely on changing the index and bounds of a DO-loop on the fly.\n         INTEGER WIDTH\n         INTEGER LINE,IT,I,J\t\n         INTEGER L,L0,N\t\t\n         INTEGER TAIL,MARK,LAST\t\n         INTEGER SP,STACKI(STACKLIMIT),STACKL(STACKLIMIT)\t\n          L0 = ISTASH(NSTASH + 1)\t\n          L = L0 - 1\t\t\t\n       LL:DO LINE = 1,NSTORY\t\t\n            SP = 0\t\t\t\n            IT = STORY(LINE)\t\t\n            LAST = ISTASH(IT + 1) - 1\t\n            I = ISTASH(IT)\t\t\n            TAIL = I - 1\t\t\n            IF (STASH(I:I).LE.\" \") THEN\t\n              CALL BURP\t\t\t\n            ELSE IF (LINE.GT.1) THEN\t\n              L = L + 1\t\t\t\n              STASH(L:L) = \" \"\t\t\n            END IF\t\t\t\n  666    II:DO WHILE(I.LE.LAST)\t\t\n              IF (STASH(I:I).EQ.\"<\") THEN\t\n                MARK = I\t\t\t\n              ELSE IF (STASH(I:I).EQ.\">\") THEN\t\n                CALL APPEND(TAIL + 1,MARK - 1)\t\n             JJ:DO J = 1,NTESTS\t\t\n                  IT = TARGET(J)\t\t\n                  IF (STASH(ISTASH(IT):ISTASH(IT + 1) - 1)\t\n     1            .EQ.STASH(MARK:I)) THEN\t\t\n                    IT = REPLACEMENT(J)\t\t\n                    IF (IT.GT.0) THEN\t\n                      IF (SP.GE.STACKLIMIT) CALL CROAK(\"StackOverflow\n                      SP = SP + 1\t\t\n                      STACKI(SP) = I\t\t\n                      STACKL(SP) = LAST\t\t\n                      I = ISTASH(IT) - 1\t\n                      LAST = ISTASH(IT + 1) - 1\t\n                    END IF\t\t\t\n                    EXIT JJ\t\t\n                  END IF\t\t\n                END DO JJ\t\t\n                TAIL = I\t\t\n              END IF\t\t\t\n              I = I + 1\t\t\t\n            END DO II\t\t\n            IF (SP.GT.0) THEN\t\n              CALL APPEND(TAIL + 1,LAST)\n              TAIL = STACKI(SP)\t\t\n              LAST = STACKL(SP)\t\t\n              SP = SP - 1\t\t\n              I = TAIL + 1\t\t\n              GO TO 666\t\t\t\n            END IF\t\t\n            CALL APPEND(TAIL + 1,LAST)\t\n          END DO LL\t\t\t\n          CALL BURP\t\t\n         CONTAINS\t\t\n          SUBROUTINE APPEND(IST,LST)\t\n           INTEGER IST,LST\t\t\n           INTEGER N\t\t\t\n            N = LST - IST + 1\t\t\n            IF (N.LE.0) RETURN\t\t\n            IF (L + N.GT.LSTASH) CALL CROAK(\"Out of stash\n            STASH(L + 1:L + N) = STASH(IST:LST)\t\n            L = L + N\t\t\t\n            IF (L - L0 + 1.GE.WIDTH) CALL BURP\t\n          END SUBROUTINE APPEND\t\t\n          SUBROUTINE BURP\t\t\n           INTEGER N,W,L1\t\t\n            N = L - L0 + 1\t\t\n            IF (N.LE.WIDTH) THEN\t\n              L1 = L\t\t\t\n             ELSE\t\t\t\n              W = L0 + WIDTH - 1\t\n              DO L1 = W,L0,-1\t\t\n                IF (STASH(L1:L1).LE.\" \") EXIT\t\n              END DO\t\t\t\n              IF (L1.LE.L0) L1 = W\t\n            END IF\t\t\t\n            WRITE (MSG,\"(A)\") STASH(L0:L1)\t\n            IF (N.LE.WIDTH) THEN\t\n              L = L0 - 1\t\t\n             ELSE\t\t\t\n              W = L0 + L - L1 - 1\t\n              STASH(L0:W) = STASH(L1 + 1:L)\t\n              L = W\t\t\t\n            END IF\t\t\t\n          END SUBROUTINE BURP\t\t\n        END SUBROUTINE WRITESTORY\t\n      END MODULE MADLIB\t\t\n\n      PROGRAM MADLIBBER\t\n      USE MADLIB\n      WRITE (MSG,1)\t\n    10FORMAT (\"Reads a story in template form, containing special \",\n     1 \"entries such as <dog's name> amongst the text.\",/,\n     2 \"You will be invited to supply a replacement text for each \"\n     3 \"such entry, as encountered,\",/,\n     4 \"after which the story will be presented with your \",\n     5 \"substitutions made.\",//,\n     6 \"Here goes... Reading file Madlib.txt\",/)\n      OPEN(INF,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\",\n     1 FILE = \"Madlib.txt\")\n      CALL READSTORY(INF)\n      CLOSE(INF)\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"  Righto\n      WRITE (MSG,*)\n      CALL WRITESTORY(66)\n      END\n", "target": "import java.util.*;\n\npublic class MadLibs {\n    \n    public static void main(String[] args){\n        Scanner input = new Scanner(System.in);\n        \n        String name, gender, noun;\n        \n        System.out.print(\"Enter a name: \");\n        name = input.next();\n        \n        System.out.print(\"He or she: \");\n        gender = input.next();\n        \n        System.out.print(\"Enter a noun: \");\n        noun = input.next();\n        \n        System.out.println(\"\\f\" + name + \" went for a walk in the park. \" + gender + \"\\nfound a \" + noun + \". \" + name + \" decided to take it home.\");\n        \n    \n    }\n}\n"}
{"id": 336223, "name": "Long year", "source": "Translate Fortran to Java: program longyear\n    use iso_fortran_env, only: output_unit, input_unit\n    implicit none\n\n    integer             :: start, ende, i, counter\n    integer, parameter  :: line_break=10\n\n    write(output_unit,*) \"Enter beginning of interval\"\n    read(input_unit,*) start\n    write(output_unit,*) \"Enter end of interval\"\n    read(input_unit,*) ende\n\n    if (start>=ende) error stop \"Last year must be after first year\n\n    counter = 0\n    do i = start, ende\n        if (is_long_year(i)) then\n            write(output_unit,'(I0,x)', advance=\"no\") i\n            counter = counter + 1\n            if (modulo(counter,line_break) == 0) write(output_unit,*)\n        end if\n    end do\ncontains\n    pure function p(year)\n        integer, intent(in) :: year\n        integer             :: p\n\n        p = modulo(year + year/4 - year/100 + year/400, 7)\n    end function p\n\n    pure function is_long_year(year)\n        integer, intent(in) :: year\n        logical             :: is_long_year\n\n        is_long_year = p(year) == 4 .or. p(year-1) == 3\n    end function is_long_year\nend program longyear\n", "target": "import java.time.LocalDate;\nimport java.time.temporal.WeekFields;\n\npublic class LongYear {\n\n    public static void main(String[] args) {\n        System.out.printf(\"Long years this century:%n\");\n        for (int year = 2000 ; year < 2100 ; year++ ) {\n            if ( longYear(year) ) {\n                System.out.print(year + \"  \");\n            }\n        }\n    }\n    \n    private static boolean longYear(int year) {\n        return LocalDate.of(year, 12, 28).get(WeekFields.ISO.weekOfYear()) == 53;\n    }\n\n}\n"}
{"id": 336224, "name": "Magic 8-ball", "source": "Translate Fortran to Java: PROGRAM EIGHT_BALL\n    CHARACTER(LEN=100) :: RESPONSE\n    CHARACTER(LEN=100) :: QUESTION\n    CHARACTER(LEN=100), DIMENSION(20) :: RESPONSES\n    REAL :: R\n\n    CALL RANDOM_SEED()\n\n    RESPONSES(1) = \"It is certain\" \n    RESPONSES(2) = \"It is decidedly so\"\n    RESPONSES(3) = \"Without a doubt\"\n    RESPONSES(4) = \"Yes, definitely\"\n    RESPONSES(5) = \"You may rely on it\"\n    RESPONSES(6) = \"As I see it, yes\"\n    RESPONSES(7) = \"Most likely\"\n    RESPONSES(8) = \"Outlook good\"\n    RESPONSES(9) = \"Signs point to yes\"\n    RESPONSES(10) = \"Yes\"\n    RESPONSES(11) = \"Reply hazy, try again\"\n    RESPONSES(12) = \"Ask again later\"\n    RESPONSES(13) = \"Better not tell you now\"\n    RESPONSES(14) = \"Cannot predict now\"\n    RESPONSES(15) = \"Concentrate and ask again\"\n    RESPONSES(16) = \"Don't bet on it\"\n    RESPONSES(17) = \"My reply is no\"\n    RESPONSES(18) = \"My sources say no\"\n    RESPONSES(19) = \"Outlook not so good\"\n    RESPONSES(20) = \"Very doubtful\"\n\n    WRITE(*,*) \"Welcome to 8 Ball\n    WRITE(*,*) \"you seek, type either 'quit' or 'q' to exit\", NEW_LINE('A')\n\n    DO WHILE(.TRUE.)\n        PRINT*, \"Ask your question: \"\n        READ(*,*) QUESTION\n        IF(QUESTION == \"q\" .OR. QUESTION == \"quit\") THEN\n            CALL EXIT(0)\n        ENDIF\n        CALL RANDOM_NUMBER(R)\n        PRINT*, \"Response: \", TRIM(RESPONSES(FLOOR(R*20))), NEW_LINE('A')\n    ENDDO\nEND PROGRAM EIGHT_BALL\n", "target": "import java.util.Random;\nimport java.util.Scanner;\n\npublic class MagicEightBall {\n\n    public static void main(String[] args) {\n        new MagicEightBall().run();\n    }\n    \n    private static String[] ANSWERS = new String[] {\"It is certain.\", \"It is decidedly so.\", \"Without a doubt.\", \"Yes - definitely.\",\n            \"You may rely on it.\", \"As I see it, yes.\", \"Most likely.\", \"Outlook good.\", \"Yes.\", \"Signs point to yes.\",\n            \"Reply hazy, try again.\", \"Ask again later.\", \"Better not tell you now.\", \"Cannot predict now.\", \"Concentrate and ask again.\",\n            \"Don't count on it.\", \"My reply is no.\", \"My sources say no.\", \"Outlook not so good.\", \"Very doubtful. \"};\n\n    public void run() {\n        Random random = new Random();\n        System.out.printf(\"Hello.  The Magic 8 Ball knows all.  Type your question.%n%n\");\n        try ( Scanner in = new Scanner(System.in); ) {\n            System.out.printf(\"?  \");\n            while ( (in.nextLine()).length() > 0 ) {\n                System.out.printf(\"8 Ball Response:  %s%n\", ANSWERS[random.nextInt(ANSWERS.length)]);\n                System.out.printf(\"?  \");\n            }\n        }\n        System.out.printf(\"%n8 Ball Done.  Bye.\");\n    }\n}\n"}
{"id": 336225, "name": "Validate International Securities Identification Number", "source": "Translate Fortran to Java: program isin\n    use ctype\n    implicit none\n    character(20) :: test(7) = [\"US0378331005        \", &\n                                \"US0373831005        \", &\n                                \"U50378331005        \", &\n                                \"US03378331005       \", &\n                                \"AU0000XVGZA3        \", &\n                                \"AU0000VXGZA3        \", &\n                                \"FR0000988040        \"]\n    print *, check_isin(test)\ncontains\n    elemental logical function check_isin(a)\n        character(*), intent(in) :: a\n        integer :: s(24)\n        integer :: i, j, k, n, v\n\n        check_isin = .false.\n\n        n = len_trim(a)\n        if (n /= 12) return\n        \n        \n        j = 0\n        do i = 1, n\n            k = iachar(a(i:i))\n            if (k >= 48 .and. k <= 57) then\n                if (i < 3) return\n                k = k - 48\n                j = j + 1\n                s(j) = k\n            else if (k >= 65 .and. k <= 90) then\n                if (i == 12) return\n                k = k - 65 + 10\n                j = j + 1\n                s(j) = k / 10\n                j = j + 1\n                s(j) = mod(k, 10)\n            else\n                return\n            end if\n        end do\n\n        \n        v = 0\n        do i = j - 1, 1, -2\n            k = 2 * s(i)\n            if (k > 9) k = k - 9\n            v = v + k\n        end do\n        do i = j, 1, -2\n            v = v + s(i)\n        end do\n        \n        check_isin = 0 == mod(v, 10)\n    end function\nend program\n", "target": "public class ISIN {\n \n    public static void main(String[] args) {\n        String[] isins = {\n            \"US0378331005\", \n            \"US0373831005\", \n            \"U50378331005\", \n            \"US03378331005\",\n            \"AU0000XVGZA3\", \n            \"AU0000VXGZA3\", \n            \"FR0000988040\"\n        };\n        for (String isin : isins)\n            System.out.printf(\"%s is %s\\n\", isin, ISINtest(isin) ? \"valid\" : \"not valid\");\n    }\n \n    static boolean ISINtest(String isin) {\n        isin = isin.trim().toUpperCase();\n \n        if (!isin.matches(\"^[A-Z]{2}[A-Z0-9]{9}\\\\d$\"))\n            return false;\n \n        StringBuilder sb = new StringBuilder();\n        for (char c : isin.substring(0, 12).toCharArray())\n            sb.append(Character.digit(c, 36));\n \n        return luhnTest(sb.toString());\n    }\n\n    static boolean luhnTest(String number) {\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for (int i = 0; i < reverse.length(); i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            \n            if (i % 2 == 0){\n                s1 += digit;\n            } else { \n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n"}
{"id": 336226, "name": "Input_Output for pairs of numbers", "source": "Translate Fortran to Java: program i_o_pairs\n  implicit none\n\n  integer :: npairs\n  integer :: i\n  integer, allocatable :: pairs(:,:)\n\n  read(*,*) npairs\n  allocate(pairs(npairs,2))\n \n  do i = 1, npairs\n    read(*,*) pairs(i,:)\n  end do\n  write(*, \"(i0)\") sum(pairs, 2)\n\nend program\n", "target": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static int doStuff(int a, int b){\n\t    int sum = a+b;\n\t    return sum;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\n\t\tint n = in.nextInt();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint a = in.nextInt();\n\t\t\tint b= in.nextInt();\n\t\t\tint result = doStuff(a, b);\n\t\t\tSystem.out.println(result);\n\t\t}\n\t}\n}\n"}
{"id": 336227, "name": "Kahan summation", "source": "Translate Fortran to Java:       FUNCTION SUMC(A,N)\nCOMPENSATED SUMMATION. C WILL NOT STAY ZERO, DESPITE MATHEMATICS.\n       DIMENSION A(12345)\n        S = 0.0\n        C = 0.0\n        DO 1 I = 1,N\n          Y = A(I) - C\n          T = S + Y\n          C = (T - S) - Y\n          S = T\n    1   CONTINUE\n        SUMC = S\n      END\n      DIMENSION A(3)\n      A(1) = 10000.0\n      A(2) = 3.14159\n      A(3) = 2.71828\n      TYPE 1, A(1) + A(2) + A(3)\n      TYPE 1, SUMC(A,3)\n    1 FORMAT (6HSUM = ,F12.1)\n      END\n", "target": "public class KahanSummation {\n    private static float kahanSum(float... fa) {\n        float sum = 0.0f;\n        float c = 0.0f;\n        for (float f : fa) {\n            float y = f - c;\n            float t = sum + y;\n            c = (t - sum) - y;\n            sum = t;\n        }\n        return sum;\n    }\n\n    private static float epsilon() {\n        float eps = 1.0f;\n        while (1.0f + eps != 1.0f) eps /= 2.0f;\n        return eps;\n    }\n\n    public static void main(String[] args) {\n        float a = 1.0f;\n        float b = epsilon();\n        float c = -b;\n        System.out.println(\"Epsilon      = \" + b);\n        System.out.println(\"(a + b) + c  = \" + ((a + b) + c));\n        System.out.println(\"Kahan sum    = \" + kahanSum(a, b, c));\n    }\n}\n"}
{"id": 336228, "name": "Two identical strings", "source": "Translate Fortran to Java:       program IdentStr\n          implicit none\n          integer n, concat, bits\n          \n          n = 1\n  100     if (concat(n) .lt. 1000) then\n              write (*,'(I3,2X,I11)') concat(n), bits(concat(n))\n              n = n + 1\n              goto 100\n          end if\n          stop\n      end\n\nC     Concatenate binary representation of number with itself      \n      integer function concat(num)\n          integer num, sl, sr\n          sl = num\n          sr = num\n  100     if (sr .gt. 0) then\n              sl = sl * 2\n              sr = sr / 2\n              goto 100\n          end if\n          concat = num + sl\n      end\n\nC     Calculate binary representation of number\n      integer function bits(num)\n          integer num, n, bx\n          n = num\n          bits = 0\n          bx = 1\n  100     if (n .gt. 0) then\n              bits = bits + bx * mod(n,2)\n              bx = bx * 10\n              n = n / 2\n              goto 100\n          end if\n      end\n", "target": "public class TwoIdenticalStrings {\n    public static void main(String[] args) {\n        System.out.println(\"Decimal Binary\");\n        for (int i = 0; i < 1_000; i++) {\n            String binStr = Integer.toBinaryString(i);\n            if (binStr.length() % 2 == 0) {\n                int len = binStr.length() / 2;\n                if (binStr.substring(0, len).equals(binStr.substring(len))) {\n                    System.out.printf(\"%7d %s%n\", i, binStr);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 336229, "name": "Verify distribution uniformity_Chi-squared test", "source": "Translate Fortran to Java: module gsl_mini_bind_m\n\n    use iso_c_binding\n    implicit none\n    private\n\n    public :: p_value\n\n    interface\n        function gsl_cdf_chisq_q(x, nu) bind(c, name='gsl_cdf_chisq_Q')\n            import\n            real(c_double), value :: x\n            real(c_double), value :: nu\n            real(c_double) :: gsl_cdf_chisq_q\n        end function gsl_cdf_chisq_q\n    end interface\n\ncontains\n\n    \n    real function p_value(x, df)\n        real, intent(in) :: x\n        integer, intent(in) :: df\n\n        p_value = real(gsl_cdf_chisq_q(real(x, c_double), real(df, c_double)))\n\n    end function p_value\n\nend module gsl_mini_bind_m\n", "target": "import static java.lang.Math.pow;\nimport java.util.Arrays;\nimport static java.util.Arrays.stream;\nimport org.apache.commons.math3.special.Gamma;\n\npublic class Test {\n\n    static double x2Dist(double[] data) {\n        double avg = stream(data).sum() / data.length;\n        double sqs = stream(data).reduce(0, (a, b) -> a + pow((b - avg), 2));\n        return sqs / avg;\n    }\n\n    static double x2Prob(double dof, double distance) {\n        return Gamma.regularizedGammaQ(dof / 2, distance / 2);\n    }\n\n    static boolean x2IsUniform(double[] data, double significance) {\n        return x2Prob(data.length - 1.0, x2Dist(data)) > significance;\n    }\n\n    public static void main(String[] a) {\n        double[][] dataSets = {{199809, 200665, 199607, 200270, 199649},\n        {522573, 244456, 139979, 71531, 21461}};\n\n        System.out.printf(\" %4s %12s  %12s %8s   %s%n\",\n                \"dof\", \"distance\", \"probability\", \"Uniform?\", \"dataset\");\n\n        for (double[] ds : dataSets) {\n            int dof = ds.length - 1;\n            double dist = x2Dist(ds);\n            double prob = x2Prob(dof, dist);\n            System.out.printf(\"%4d %12.3f  %12.8f    %5s    %6s%n\",\n                    dof, dist, prob, x2IsUniform(ds, 0.05) ? \"YES\" : \"NO\",\n                    Arrays.toString(ds));\n        }\n    }\n}\n"}
{"id": 336230, "name": "CSV to HTML translation", "source": "Translate Fortran to Java:       SUBROUTINE CSVTEXT2HTML(FNAME,HEADED)\t\nConverts without checking field counts, or noting special characters.\n       CHARACTER*(*) FNAME\t\n       LOGICAL HEADED\t\t\n       INTEGER MANY\t\t\n       PARAMETER (MANY=666)\t\n       CHARACTER*(MANY) ALINE\t\n       INTEGER MARK(0:MANY + 1)\t\n       INTEGER I,L,N\t\t\n       CHARACTER*2 WOT(2)\t\n       PARAMETER (WOT = (/\"th\",\"td\"/))\t\n       INTEGER IT\t\t\n       INTEGER KBD,MSG,IN\t\t\n       COMMON /IOUNITS/ KBD,MSG,IN\t\n        OPEN(IN,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",ERR=661)\t\n        WRITE (MSG,1)\t\t\t\n    1   FORMAT (\"<Table border=1>\")\t\n        MARK(0) = 0\t\t\n        N = 0\t\t\t\n\n   10   READ (IN,11,END = 20) L,ALINE(1:MIN(L,MANY))\t\n   11   FORMAT (Q,A)\t\t\n        N = N + 1\t\t\n        IF (L.GT.MANY) THEN\t\n          WRITE (MSG,12) N,L,MANY\t\n   12     FORMAT (\"Line \",I0,\" has length \",I0,\"\n          L = MANY\t\t\t\n        END IF\t\t\t\n        IF (N.EQ.1 .AND. HEADED) THEN\t\n          WRITE (MSG,*) \"<tHead>\"\t\n          IT = 1\t\t\t\n         ELSE\t\t\t\t\n          IT = 2\t\t\t\n        END IF\t\t\t\n        NCOLS = 0\t\t\n        DO I = 1,L\t\t\n          IF (ICHAR(ALINE(I:I)).EQ.ICHAR(\",\")) THEN\t\n            NCOLS = NCOLS + 1\t\t\n            MARK(NCOLS) = I\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        NCOLS = NCOLS + 1\t\n        MARK(NCOLS) = L + 1\t\n        WRITE (MSG,13)\t\t\n     1   (WOT(IT),\t\t\t\t\n     2    ALINE(MARK(I - 1) + 1:MARK(I) - 1),\t\n     3    WOT(IT),\t\t\t\t\n     4    I = 1,NCOLS),\t\t\t\n     5   \"/tr\"\t\t\t\n   13   FORMAT (\" <tr>\",666(\"<\",A,\">\",A,\"</\",A,\">\"))\t\n        IF (N.EQ.1 .AND. HEADED) WRITE (MSG,*) \"</tHead>\"\t\n        GO TO 10\t\t\n\n   20   CLOSE (IN)\t\t\n        WRITE (MSG,21)\t\t\n   21   FORMAT (\"</Table>\")\t\n       RETURN\t\t\t\nConfusions.\n  661   WRITE (MSG,*) \"Can't open file \",FNAME\t\n      END\t\t\t\n\n      INTEGER KBD,MSG,IN\n      COMMON /IOUNITS/ KBD,MSG,IN\n      KBD = 5\t\n      MSG = 6\t\n      IN = 10\t\n\n      CALL CSVTEXT2HTML(\"Text.csv\",.FALSE.)\t\n      WRITE (MSG,*)\n      CALL CSVTEXT2HTML(\"Text.csv\",.TRUE.)\t\n      END\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 336231, "name": "CSV to HTML translation", "source": "Translate Fortran to Java:       SUBROUTINE CSVTEXT2HTML(FNAME,HEADED)\t\nConverts without checking field counts, or noting special characters.\n       CHARACTER*(*) FNAME\t\n       LOGICAL HEADED\t\t\n       INTEGER MANY\t\t\n       PARAMETER (MANY=666)\t\n       CHARACTER*(MANY) ALINE\t\n       INTEGER MARK(0:MANY + 1)\t\n       INTEGER I,L,N\t\t\n       CHARACTER*2 WOT(2)\t\n       PARAMETER (WOT = (/\"th\",\"td\"/))\t\n       INTEGER IT\t\t\n       INTEGER KBD,MSG,IN\t\t\n       COMMON /IOUNITS/ KBD,MSG,IN\t\n        OPEN(IN,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",ERR=661)\t\n        WRITE (MSG,1)\t\t\t\n    1   FORMAT (\"<Table border=1>\")\t\n        MARK(0) = 0\t\t\n        N = 0\t\t\t\n\n   10   READ (IN,11,END = 20) L,ALINE(1:MIN(L,MANY))\t\n   11   FORMAT (Q,A)\t\t\n        N = N + 1\t\t\n        IF (L.GT.MANY) THEN\t\n          WRITE (MSG,12) N,L,MANY\t\n   12     FORMAT (\"Line \",I0,\" has length \",I0,\"\n          L = MANY\t\t\t\n        END IF\t\t\t\n        IF (N.EQ.1 .AND. HEADED) THEN\t\n          WRITE (MSG,*) \"<tHead>\"\t\n          IT = 1\t\t\t\n         ELSE\t\t\t\t\n          IT = 2\t\t\t\n        END IF\t\t\t\n        NCOLS = 0\t\t\n        DO I = 1,L\t\t\n          IF (ICHAR(ALINE(I:I)).EQ.ICHAR(\",\")) THEN\t\n            NCOLS = NCOLS + 1\t\t\n            MARK(NCOLS) = I\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        NCOLS = NCOLS + 1\t\n        MARK(NCOLS) = L + 1\t\n        WRITE (MSG,13)\t\t\n     1   (WOT(IT),\t\t\t\t\n     2    ALINE(MARK(I - 1) + 1:MARK(I) - 1),\t\n     3    WOT(IT),\t\t\t\t\n     4    I = 1,NCOLS),\t\t\t\n     5   \"/tr\"\t\t\t\n   13   FORMAT (\" <tr>\",666(\"<\",A,\">\",A,\"</\",A,\">\"))\t\n        IF (N.EQ.1 .AND. HEADED) WRITE (MSG,*) \"</tHead>\"\t\n        GO TO 10\t\t\n\n   20   CLOSE (IN)\t\t\n        WRITE (MSG,21)\t\t\n   21   FORMAT (\"</Table>\")\t\n       RETURN\t\t\t\nConfusions.\n  661   WRITE (MSG,*) \"Can't open file \",FNAME\t\n      END\t\t\t\n\n      INTEGER KBD,MSG,IN\n      COMMON /IOUNITS/ KBD,MSG,IN\n      KBD = 5\t\n      MSG = 6\t\n      IN = 10\t\n\n      CALL CSVTEXT2HTML(\"Text.csv\",.FALSE.)\t\n      WRITE (MSG,*)\n      CALL CSVTEXT2HTML(\"Text.csv\",.TRUE.)\t\n      END\n", "target": "\n\ngrammar csv2html;\ndialog : {System.out.println(\"<HTML><Table>\");}header body+{System.out.println(\"</Table></HTML>\");} ;\nheader : {System.out.println(\"<THEAD align=\\\"center\\\"><TR bgcolor=\\\"blue\\\">\");}row{System.out.println(\"</TR></THEAD\");};\nbody   : {System.out.println(\"<TBODY><TR>\");}row{System.out.println(\"</TR></TBODY\");};\nrow    : field ',' field '\\r'? '\\n';\nfield  : Field{System.out.println(\"<TD>\" + $Field.text.replace(\"<\",\"&lt;\").replace(\">\",\"&gt;\") + \"</TD>\");};\nField  : ~[,\\n\\r]+;\n"}
{"id": 336232, "name": "Pythagorean triples", "source": "Translate Fortran to Java: module triples\n  implicit none\n  \n  integer :: max_peri, prim, total\n  integer :: u(9,3) = reshape((/ 1, -2, 2,  2, -1, 2,  2, -2, 3, &\n                                 1,  2, 2,  2,  1, 2,  2,  2, 3, &\n                                -1,  2, 2, -2,  1, 2, -2,  2, 3 /), &\n                                (/ 9, 3 /))\n                                \ncontains\n\nrecursive subroutine new_tri(in)\n  integer, intent(in) :: in(:)\n  integer :: i\n  integer :: t(3), p\n\n  p = sum(in)\n  if (p > max_peri) return\n\n  prim = prim + 1\n  total = total + max_peri / p\n  do i = 1, 3\n    t(1) = sum(u(1:3, i) * in)\n    t(2) = sum(u(4:6, i) * in)\n    t(3) = sum(u(7:9, i) * in)\n    call new_tri(t);\n  end do\nend subroutine new_tri\nend module triples\n\nprogram Pythagorean\n  use triples\n  implicit none\n\n  integer :: seed(3) = (/ 3, 4, 5 /)\n  \n  max_peri = 10\n  do\n    total = 0\n    prim = 0\n    call new_tri(seed)\n    write(*, \"(a, i10, 2(i10, a))\") \"Up to\", max_peri, total, \" triples\",  prim, \" primitives\"\n    if(max_peri == 100000000) exit\n    max_peri = max_peri * 10\n  end do\nend program Pythagorean\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 336233, "name": "Pythagorean triples", "source": "Translate Fortran to Java: module triples\n  implicit none\n  \n  integer :: max_peri, prim, total\n  integer :: u(9,3) = reshape((/ 1, -2, 2,  2, -1, 2,  2, -2, 3, &\n                                 1,  2, 2,  2,  1, 2,  2,  2, 3, &\n                                -1,  2, 2, -2,  1, 2, -2,  2, 3 /), &\n                                (/ 9, 3 /))\n                                \ncontains\n\nrecursive subroutine new_tri(in)\n  integer, intent(in) :: in(:)\n  integer :: i\n  integer :: t(3), p\n\n  p = sum(in)\n  if (p > max_peri) return\n\n  prim = prim + 1\n  total = total + max_peri / p\n  do i = 1, 3\n    t(1) = sum(u(1:3, i) * in)\n    t(2) = sum(u(4:6, i) * in)\n    t(3) = sum(u(7:9, i) * in)\n    call new_tri(t);\n  end do\nend subroutine new_tri\nend module triples\n\nprogram Pythagorean\n  use triples\n  implicit none\n\n  integer :: seed(3) = (/ 3, 4, 5 /)\n  \n  max_peri = 10\n  do\n    total = 0\n    prim = 0\n    call new_tri(seed)\n    write(*, \"(a, i10, 2(i10, a))\") \"Up to\", max_peri, total, \" triples\",  prim, \" primitives\"\n    if(max_peri == 100000000) exit\n    max_peri = max_peri * 10\n  end do\nend program Pythagorean\n", "target": "import java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        \n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    \n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    \n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        \n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n"}
{"id": 336234, "name": "Call a foreign-language function", "source": "Translate Fortran to Java: module c_api\n    use iso_c_binding\n    implicit none\n\n    interface\n        function strdup(ptr) bind(C)\n            import c_ptr\n            type(c_ptr), value :: ptr\n            type(c_ptr) :: strdup\n        end function\n    end interface\n    \n    interface\n        subroutine free(ptr) bind(C)\n            import c_ptr\n            type(c_ptr), value :: ptr\n        end subroutine\n    end interface\n    \n    interface\n        function puts(ptr) bind(C)\n            import c_ptr, c_int\n            type(c_ptr), value :: ptr\n            integer(c_int) :: puts\n        end function\n    end interface\nend module\n\nprogram c_example\n    use c_api\n    implicit none\n\n    character(20), target :: str = \"Hello, World\n    type(c_ptr) :: ptr\n    integer(c_int) :: res\n    \n    ptr = strdup(c_loc(str))\n    \n    res = puts(c_loc(str))\n    res = puts(ptr)\n    \n    print *, transfer(c_loc(str), 0_c_intptr_t), &\n             transfer(ptr, 0_c_intptr_t)\n    call free(ptr)\nend program\n", "target": "public class JNIDemo\n{\n  static\n  {  System.loadLibrary(\"JNIDemo\");  }\n  \n  public static void main(String[] args)\n  {\n    System.out.println(callStrdup(\"Hello World!\"));\n  }\n  \n  private static native String callStrdup(String s);\n}\n"}
{"id": 336235, "name": "Sorting algorithms_Patience sort", "source": "Translate Fortran to Java: module rosetta_code_patience_sort\n  implicit none\n  private\n\n  public :: patience_sort\n\n  interface\n     function binary_predicate (x, y) result (truth)\n       class(*), intent(in) :: x, y\n       logical :: truth\n     end function binary_predicate\n  end interface\n\ncontains\n\n  function patience_sort (less, ifirst, ilast, array) result (sorted)\n    procedure(binary_predicate) :: less\n    integer, intent(in) :: ifirst, ilast\n    class(*), intent(in) :: array(*)\n    integer, allocatable :: sorted(:)\n\n    \n    \n    \n\n    integer :: num_piles\n    integer, allocatable :: piles(:)\n    integer, allocatable :: links(:)\n\n    \n    \n    \n    \n    \n    allocate (piles(1 : ilast - ifirst + 1), source = 0)\n    allocate (links(1 : ilast - ifirst + 1), source = 0)\n\n    num_piles = 0\n    call deal (less, ifirst, ilast, array, num_piles, piles, links)\n\n    allocate (sorted(1 : ilast - ifirst + 1))\n\n    call k_way_merge (less, ifirst, ilast, array, num_piles, piles, &\n         &            links, sorted)\n\n  end function patience_sort\n\n  subroutine deal (less, ifirst, ilast, array, &\n       &           num_piles, piles, links)\n    procedure(binary_predicate) :: less\n    integer, intent(in) :: ifirst, ilast\n    class(*), intent(in) :: array(*)\n    integer, intent(inout) :: num_piles\n    integer, intent(inout) :: piles(1 : ilast - ifirst + 1)\n    integer, intent(inout) :: links(1 : ilast - ifirst + 1)\n\n    integer :: i, q\n\n    do q = 1, ilast - ifirst + 1\n       i = find_pile (q)\n       links(q) = piles(i)\n       piles(i) = q\n       num_piles = max (num_piles, i)\n    end do\n\n  contains\n\n    function find_pile (q) result (index)\n      integer, value :: q\n      integer :: index\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n\n      integer :: i, j, k\n\n      if (num_piles == 0) then\n         index = 1\n      else\n         j = 0\n         k = num_piles - 1\n         do while (j /= k)\n            i = (j + k) / 2\n            if (less (array(piles(j + 1) + ifirst - 1), &\n                 &    array(q + ifirst - 1))) then\n               j = i + 1\n            else\n               k = i\n            end if\n         end do\n         if (j == num_piles - 1) then\n            if (less (array(piles(j + 1) + ifirst - 1), &\n                 &    array(q + ifirst - 1))) then\n               \n               j = j + 1\n            end if\n         end if\n         index = j + 1\n      end if\n    end function find_pile\n\n  end subroutine deal\n\n  subroutine k_way_merge (less, ifirst, ilast, array, num_piles, &\n       &                  piles, links, sorted)\n    procedure(binary_predicate) :: less\n    integer, intent(in) :: ifirst, ilast\n    class(*), intent(in) :: array(*)\n    integer, intent(in) :: num_piles\n    integer, intent(inout) :: piles(1 : ilast - ifirst + 1)\n    integer, intent(inout) :: links(1 : ilast - ifirst + 1)\n    integer, intent(inout) :: sorted(1 : ilast - ifirst + 1)\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    integer :: total_external_nodes\n    integer :: total_nodes\n    integer :: winners(1:2, 1:(2 * next_power_of_two (num_piles)) - 1)\n    integer :: isorted, i, next\n\n    total_external_nodes = next_power_of_two (num_piles)\n    total_nodes = (2 * total_external_nodes) - 1\n\n    call build_tree\n\n    isorted = 0\n    do while (winners(1, 1) /= 0)\n       isorted = isorted + 1\n       sorted(isorted) = winners(1, 1) + ifirst - 1\n       i = winners(2, 1)\n       next = piles(i)          \n       if (next /= 0) piles(i) = links(next) \n       i = (total_nodes / 2) + i\n       winners(1, i) = next\n       call replay_games (i)\n    end do\n\n  contains\n\n    subroutine build_tree\n      integer :: i\n      integer :: istart\n      integer :: iwinner\n\n      winners = 0\n\n      do i = 1, total_external_nodes\n         \n         winners(2, total_external_nodes - 1 + i) = i\n      end do\n\n      \n      winners(1, total_external_nodes :                  &\n           &     total_external_nodes + num_piles - 1) = &\n           &  piles(1:num_piles)\n\n      do i = 1, num_piles\n         \n         piles(i) = links(piles(i))\n      end do\n\n      istart = total_external_nodes\n      do while (istart /= 1)\n         do i = istart, (2 * istart) - 1, 2\n            iwinner = play_game (i)\n            winners(:, i / 2) = winners(:, iwinner)\n         end do\n         istart = istart / 2\n      end do\n    end subroutine build_tree\n\n    subroutine replay_games (i)\n      integer, value :: i\n\n      integer :: iwinner\n\n      do while (i /= 1)\n         iwinner = play_game (i)\n         i = i / 2\n         winners(:, i) = winners(:, iwinner)\n      end do\n    end subroutine replay_games\n\n    function play_game (i) result (iwinner)\n      integer, value :: i\n      integer :: iwinner\n\n      integer :: j\n\n      j = ieor (i, 1)\n      if (winners(1, i) == 0) then\n         iwinner = j\n      else if (winners(1, j) == 0) then\n         iwinner = i\n      else if (less (array(winners(1, j) + ifirst - 1), &\n           &         array(winners(1, i) + ifirst - 1))) then\n         iwinner = j\n      else\n         iwinner = i\n      end if\n    end function play_game\n\n  end subroutine k_way_merge\n\n  elemental function next_power_of_two (n) result (pow2)\n    integer, value :: n\n    integer :: pow2\n\n    \n    pow2 = 1\n    do while (pow2 < n)\n       pow2 = pow2 + pow2\n    end do\n  end function next_power_of_two\n\nend module rosetta_code_patience_sort\n\nprogram patience_sort_task\n  use, non_intrinsic :: rosetta_code_patience_sort\n  implicit none\n\n  integer, parameter :: example_numbers(*) =               &\n       & (/ 22, 15, 98, 82, 22, 4, 58, 70, 80, 38, 49, 48, &\n       &    46, 54, 93, 8, 54, 2, 72, 84, 86, 76, 53, 37,  &\n       &    90 /)\n\n  integer :: i\n  integer, allocatable :: sorted(:)\n\n  sorted = patience_sort (less, &\n       &                  lbound (example_numbers, 1), &\n       &                  ubound (example_numbers, 1), &\n       &                  example_numbers)\n\n  write (*, '(\"unsorted  \")', advance = 'no')\n  do i = lbound (example_numbers, 1), ubound (example_numbers, 1)\n     write (*, '(1X, I0)', advance = 'no') example_numbers(i)\n  end do\n  write (*, '()')\n  write (*, '(\"sorted    \")', advance = 'no')\n  do i = lbound (sorted, 1), ubound (sorted, 1)\n     write (*, '(1X, I0)', advance = 'no') example_numbers(sorted(i))\n  end do\n  write (*, '()')\n\ncontains\n\n  function less (x, y) result (truth)\n    class(*), intent(in) :: x, y\n    logical :: truth\n\n    select type (x)\n    type is (integer)\n       select type (y)\n       type is (integer)\n          truth = (x < y)\n       class default\n          error stop\n       end select\n    class default\n       error stop\n    end select\n  end function less\n\nend program patience_sort_task\n", "target": "import java.util.*;\n\npublic class PatienceSort {\n    public static <E extends Comparable<? super E>> void sort (E[] n) {\n        List<Pile<E>> piles = new ArrayList<Pile<E>>();\n        \n        for (E x : n) {\n            Pile<E> newPile = new Pile<E>();\n            newPile.push(x);\n            int i = Collections.binarySearch(piles, newPile);\n            if (i < 0) i = ~i;\n            if (i != piles.size())\n                piles.get(i).push(x);\n            else\n                piles.add(newPile);\n        }\n \n        \n        PriorityQueue<Pile<E>> heap = new PriorityQueue<Pile<E>>(piles);\n        for (int c = 0; c < n.length; c++) {\n            Pile<E> smallPile = heap.poll();\n            n[c] = smallPile.pop();\n            if (!smallPile.isEmpty())\n                heap.offer(smallPile);\n        }\n        assert(heap.isEmpty());\n    }\n \n    private static class Pile<E extends Comparable<? super E>> extends Stack<E> implements Comparable<Pile<E>> {\n        public int compareTo(Pile<E> y) { return peek().compareTo(y.peek()); }\n    }\n\n    public static void main(String[] args) {\n\tInteger[] a = {4, 65, 2, -31, 0, 99, 83, 782, 1};\n\tsort(a);\n\tSystem.out.println(Arrays.toString(a));\n    }\n}\n"}
{"id": 336236, "name": "Extensible prime generator", "source": "Translate Fortran to Java:       DO WHILE(F*F <= LST)         \n      DO WHILE(F <= LST/F)                      \n      DO WHILE(F <= (IST + 2*(SBITS - 1))/F)    \n      DO WHILE(F <= IST/F + (MOD(IST,F) + 2*(SBITS - 1))/F) \n", "target": "import java.util.*;\n\npublic class PrimeGenerator {\n    private int limit_;\n    private int index_ = 0;\n    private int increment_;\n    private int count_ = 0;\n    private List<Integer> primes_ = new ArrayList<>();\n    private BitSet sieve_ = new BitSet();\n    private int sieveLimit_ = 0;\n\n    public PrimeGenerator(int initialLimit, int increment) {\n        limit_ = nextOddNumber(initialLimit);\n        increment_ = increment;\n        primes_.add(2);\n        findPrimes(3);\n    }\n\n    public int nextPrime() {\n        if (index_ == primes_.size()) {\n            if (Integer.MAX_VALUE - increment_ < limit_)\n                return 0;\n            int start = limit_ + 2;\n            limit_ = nextOddNumber(limit_ + increment_);\n            primes_.clear();\n            findPrimes(start);\n        }\n        ++count_;\n        return primes_.get(index_++);\n    }\n\n    public int count() {\n        return count_;\n    }\n\n    private void findPrimes(int start) {\n        index_ = 0;\n        int newLimit = sqrt(limit_);\n        for (int p = 3; p * p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((sieveLimit_ + p - 1)/p));\n            for (; q <= newLimit; q += 2*p)\n                sieve_.set(q/2 - 1, true);\n        }\n        sieveLimit_ = newLimit;\n        int count = (limit_ - start)/2 + 1;\n        BitSet composite = new BitSet(count);\n        for (int p = 3; p <= newLimit; p += 2) {\n            if (sieve_.get(p/2 - 1))\n                continue;\n            int q = p * Math.max(p, nextOddNumber((start + p - 1)/p)) - start;\n            q /= 2;\n            for (; q >= 0 && q < count; q += p)\n                composite.set(q, true);\n        }\n        for (int p = 0; p < count; ++p) {\n            if (!composite.get(p))\n                primes_.add(p * 2 + start);\n        }\n    }\n\n    private static int sqrt(int n) {\n        return nextOddNumber((int)Math.sqrt(n));\n    }\n\n    private static int nextOddNumber(int n) {\n        return 1 + 2 * (n/2);\n    }\n\n    public static void main(String[] args) {\n        PrimeGenerator pgen = new PrimeGenerator(20, 200000);\n        System.out.println(\"First 20 primes:\");\n        for (int i = 0; i < 20; ++i) {\n            if (i > 0)\n                System.out.print(\", \");\n            System.out.print(pgen.nextPrime());\n        }\n        System.out.println();\n        System.out.println(\"Primes between 100 and 150:\");\n        for (int i = 0; ; ) {\n            int prime = pgen.nextPrime();\n            if (prime > 150)\n                break;\n            if (prime >= 100) {\n                if (i++ != 0)\n                    System.out.print(\", \");\n                System.out.print(prime);\n            }\n        }\n        System.out.println();\n        int count = 0;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime > 8000)\n                break;\n            if (prime >= 7700)\n                ++count;\n        }\n        System.out.println(\"Number of primes between 7700 and 8000: \" + count);\n        int n = 10000;\n        for (;;) {\n            int prime = pgen.nextPrime();\n            if (prime == 0) {\n                System.out.println(\"Can't generate any more primes.\");\n                break;\n            }\n            if (pgen.count() == n) {\n                System.out.println(n + \"th prime: \" + prime);\n                n *= 10;\n            }\n        }\n    }\n}\n"}
{"id": 336237, "name": "Flipping bits game", "source": "Translate Fortran to Java: \nprogram flipping_bits\nimplicit none\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: N, i, j, io, seed(8), moves, input\nlogical, allocatable :: Brd(:,:), Trgt(:,:)\nlogical :: solved\ndouble precision :: r\n\ndo\n  write(*,*) 'Enter the number of squares (between 1 and 10) you would like: '\n  read(*,*,iostat=io) N\n  if(N.gt.0 .and. N.le.10 .and. io.eq.0) exit\n  write(*,*) 'Please, an integer between 1 and 10'\nend do\n\nallocate(Brd(N,N),Trgt(N,N))\ncall date_and_time(values=seed)\ncall srand(1000*seed(7)+seed(8)+60000*seed(6))\ndo i = 1,N\n  do j = 1,N\n    r = rand()\n    if(r.gt.0.5D0) then\n      Brd(i,j) = .TRUE.\n      Trgt(i,j) = .TRUE.\n    else\n      Brd(i,j) = .FALSE.\n      Trgt(i,j) = .FALSE.\n    end if\n  end do\nend do\n\nmoves = N\ndo i = 1,moves\n  r = 1+2.0D0*dble(N)*rand() - 1.0D-17 \n  if(floor(r).le.N) then\n    do j = 1,N\n      Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n    end do\n  else\n    r = r-N\n    do j = 1,N\n      Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n    end do\n  end if\nend do\n\n\ndo\n  input = N\n  call next_move(Brd,Trgt,N,input,solved)\n  call next_move(Brd,Trgt,N,input,solved)\n  if(solved) then\n    r = 1+2.0D0*dble(N)*rand() - 1.0D-17\n    if(floor(r).le.N) then\n      do j = 1,N\n        Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n      end do\n    else\n      r = r-N\n      do j = 1,N\n        Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n      end do\n    end if\n  else\n    exit\n  end if\nend do\n\nwrite(*,*) 'Welcome to the Flipping Bits game\nwrite(*,*) 'You have the current position'\n\nmoves = 0\ncall display(Brd,Trgt,N)\ninput = N\ndo\n  write(*,*) 'Number of moves so far:', moves\n  write(*,*) 'Select the column or row you wish to flip: '\n  read(*,*,iostat=io) input\n  if(io.eq.0 .and. input.gt.0 .and. input.le.(2*N)) then\n    moves = moves+1\n    write(*,*) 'Flipping ', input\n    call next_move(Brd,Trgt,N,input,solved)\n    call display(Brd,Trgt,N)\n    if(solved) exit\n  else\n    write(*,*) 'Please enter a valid column or row number. To quit, press Ctrl+C\n  end if\nend do\n\nwrite(*,*) 'Congratulations\nwrite(*,ifmt,advance='no') moves\nwrite(*,*) ' moves were taken by you\ndeallocate(Brd,Trgt)\nend program\n\nsubroutine display(Brd,Trgt,N)\nimplicit none\n\ninteger :: N\nlogical :: Brd(N,N), Trgt(N,N)\n\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: i, j\nwrite(*,*) 'Current Configuration: '\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Brd(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\n\nwrite(*,*)\nwrite(*,*)\n\nwrite(*,*) 'Target Configuration'\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Trgt(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\nwrite(*,*)\nwrite(*,*)\nend subroutine\n\nsubroutine next_move(Brd,Trgt,N,input,solved)\nimplicit none\n\ninteger :: N, input\nlogical :: Brd(N,N), Trgt(N,N), solved\n\ninteger :: i,j\n\nif(input.gt.N) then\n  input = input-N\n  do i = 1,N\n    Brd(input,i) = .not.Brd(input,i)\n  end do\nelse\n  do i = 1,N\n    Brd(i,input) = .not.Brd(i,input)\n  end do\nend if\nsolved = .TRUE.\ndo i = 1,N\n  do j = 1,N\n    if( (.not.Brd(i,j).and.Trgt(i,j)) .or. (Brd(i,j).and..not.Trgt(i,j)) ) then\n      solved = .FALSE.\n      exit\n    end if\n  end do\n  if(.not.solved) exit\nend do\nend subroutine\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 336238, "name": "Flipping bits game", "source": "Translate Fortran to Java: \nprogram flipping_bits\nimplicit none\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: N, i, j, io, seed(8), moves, input\nlogical, allocatable :: Brd(:,:), Trgt(:,:)\nlogical :: solved\ndouble precision :: r\n\ndo\n  write(*,*) 'Enter the number of squares (between 1 and 10) you would like: '\n  read(*,*,iostat=io) N\n  if(N.gt.0 .and. N.le.10 .and. io.eq.0) exit\n  write(*,*) 'Please, an integer between 1 and 10'\nend do\n\nallocate(Brd(N,N),Trgt(N,N))\ncall date_and_time(values=seed)\ncall srand(1000*seed(7)+seed(8)+60000*seed(6))\ndo i = 1,N\n  do j = 1,N\n    r = rand()\n    if(r.gt.0.5D0) then\n      Brd(i,j) = .TRUE.\n      Trgt(i,j) = .TRUE.\n    else\n      Brd(i,j) = .FALSE.\n      Trgt(i,j) = .FALSE.\n    end if\n  end do\nend do\n\nmoves = N\ndo i = 1,moves\n  r = 1+2.0D0*dble(N)*rand() - 1.0D-17 \n  if(floor(r).le.N) then\n    do j = 1,N\n      Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n    end do\n  else\n    r = r-N\n    do j = 1,N\n      Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n    end do\n  end if\nend do\n\n\ndo\n  input = N\n  call next_move(Brd,Trgt,N,input,solved)\n  call next_move(Brd,Trgt,N,input,solved)\n  if(solved) then\n    r = 1+2.0D0*dble(N)*rand() - 1.0D-17\n    if(floor(r).le.N) then\n      do j = 1,N\n        Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n      end do\n    else\n      r = r-N\n      do j = 1,N\n        Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n      end do\n    end if\n  else\n    exit\n  end if\nend do\n\nwrite(*,*) 'Welcome to the Flipping Bits game\nwrite(*,*) 'You have the current position'\n\nmoves = 0\ncall display(Brd,Trgt,N)\ninput = N\ndo\n  write(*,*) 'Number of moves so far:', moves\n  write(*,*) 'Select the column or row you wish to flip: '\n  read(*,*,iostat=io) input\n  if(io.eq.0 .and. input.gt.0 .and. input.le.(2*N)) then\n    moves = moves+1\n    write(*,*) 'Flipping ', input\n    call next_move(Brd,Trgt,N,input,solved)\n    call display(Brd,Trgt,N)\n    if(solved) exit\n  else\n    write(*,*) 'Please enter a valid column or row number. To quit, press Ctrl+C\n  end if\nend do\n\nwrite(*,*) 'Congratulations\nwrite(*,ifmt,advance='no') moves\nwrite(*,*) ' moves were taken by you\ndeallocate(Brd,Trgt)\nend program\n\nsubroutine display(Brd,Trgt,N)\nimplicit none\n\ninteger :: N\nlogical :: Brd(N,N), Trgt(N,N)\n\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: i, j\nwrite(*,*) 'Current Configuration: '\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Brd(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\n\nwrite(*,*)\nwrite(*,*)\n\nwrite(*,*) 'Target Configuration'\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Trgt(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\nwrite(*,*)\nwrite(*,*)\nend subroutine\n\nsubroutine next_move(Brd,Trgt,N,input,solved)\nimplicit none\n\ninteger :: N, input\nlogical :: Brd(N,N), Trgt(N,N), solved\n\ninteger :: i,j\n\nif(input.gt.N) then\n  input = input-N\n  do i = 1,N\n    Brd(input,i) = .not.Brd(input,i)\n  end do\nelse\n  do i = 1,N\n    Brd(i,input) = .not.Brd(i,input)\n  end do\nend if\nsolved = .TRUE.\ndo i = 1,N\n  do j = 1,N\n    if( (.not.Brd(i,j).and.Trgt(i,j)) .or. (Brd(i,j).and..not.Trgt(i,j)) ) then\n      solved = .FALSE.\n      exit\n    end if\n  end do\n  if(.not.solved) exit\nend do\nend subroutine\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\n\npublic class FlippingBitsGame extends JPanel {\n    final int maxLevel = 7;\n    final int minLevel = 3;\n\n    private Random rand = new Random();\n    private int[][] grid, target;\n    private Rectangle box;\n    private int n = maxLevel;\n    private boolean solved = true;\n\n    FlippingBitsGame() {\n        setPreferredSize(new Dimension(640, 640));\n        setBackground(Color.white);\n        setFont(new Font(\"SansSerif\", Font.PLAIN, 18));\n\n        box = new Rectangle(120, 90, 400, 400);\n\n        startNewGame();\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                if (solved) {\n                    startNewGame();\n                } else {\n                    int x = e.getX();\n                    int y = e.getY();\n\n                    if (box.contains(x, y))\n                        return;\n\n                    if (x > box.x && x < box.x + box.width) {\n                        flipCol((x - box.x) / (box.width / n));\n\n                    } else if (y > box.y && y < box.y + box.height)\n                        flipRow((y - box.y) / (box.height / n));\n\n                    if (solved(grid, target))\n                        solved = true;\n\n                    printGrid(solved ? \"Solved!\" : \"The board\", grid);\n                }\n                repaint();\n            }\n        });\n    }\n\n    void startNewGame() {\n        if (solved) {\n\n            n = (n == maxLevel) ? minLevel : n + 1;\n\n            grid = new int[n][n];\n            target = new int[n][n];\n\n            do {\n                shuffle();\n\n                for (int i = 0; i < n; i++)\n                    target[i] = Arrays.copyOf(grid[i], n);\n\n                shuffle();\n\n            } while (solved(grid, target));\n\n            solved = false;\n            printGrid(\"The target\", target);\n            printGrid(\"The board\", grid);\n        }\n    }\n\n    void printGrid(String msg, int[][] g) {\n        System.out.println(msg);\n        for (int[] row : g)\n            System.out.println(Arrays.toString(row));\n        System.out.println();\n    }\n\n    boolean solved(int[][] a, int[][] b) {\n        for (int i = 0; i < n; i++)\n            if (!Arrays.equals(a[i], b[i]))\n                return false;\n        return true;\n    }\n\n    void shuffle() {\n        for (int i = 0; i < n * n; i++) {\n            if (rand.nextBoolean())\n                flipRow(rand.nextInt(n));\n            else\n                flipCol(rand.nextInt(n));\n        }\n    }\n\n    void flipRow(int r) {\n        for (int c = 0; c < n; c++) {\n            grid[r][c] ^= 1;\n        }\n    }\n\n    void flipCol(int c) {\n        for (int[] row : grid) {\n            row[c] ^= 1;\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(getForeground());\n\n        if (solved)\n            g.drawString(\"Solved! Click here to play again.\", 180, 600);\n        else\n            g.drawString(\"Click next to a row or a column to flip.\", 170, 600);\n\n        int size = box.width / n;\n\n        for (int r = 0; r < n; r++)\n            for (int c = 0; c < n; c++) {\n                g.setColor(grid[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(getBackground());\n                g.drawRect(box.x + c * size, box.y + r * size, size, size);\n                g.setColor(target[r][c] == 1 ? Color.blue : Color.orange);\n                g.fillRect(7 + box.x + c * size, 7 + box.y + r * size, 10, 10);\n            }\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Flipping Bits Game\");\n            f.setResizable(false);\n            f.add(new FlippingBitsGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 336239, "name": "Gray code", "source": "Translate Fortran to Java:       PROGRAM GRAY\n      IMPLICIT NONE\n      INTEGER IGRAY,I,J,K\n      CHARACTER*5 A,B,C\n      DO 10 I=0,31\n      J=IGRAY(I,1)\n      K=IGRAY(J,-1)\n      CALL BINARY(A,I,5)\n      CALL BINARY(B,J,5)\n      CALL BINARY(C,K,5)\n      PRINT 99,I,A,B,C,K\n   10 CONTINUE\n   99 FORMAT(I2,3H : ,A5,4H => ,A5,4H => ,A5,3H : ,I2)\n      END\n\n      FUNCTION IGRAY(N,D)\n      IMPLICIT NONE\n      INTEGER D,K,N,IGRAY\n      IF(D.LT.0) GO TO 10\n      IGRAY=IEOR(N,ISHFT(N,-1))\n      RETURN\n   10 K=N\n      IGRAY=0\n   20 IGRAY=IEOR(IGRAY,K)\n      K=K/2\n      IF(K.NE.0) GO TO 20\n      END\n\n      SUBROUTINE BINARY(S,N,K)\n      IMPLICIT NONE\n      INTEGER I,K,L,N\n      CHARACTER*(*) S\n      L=LEN(S)\n      DO 10 I=0,K-1\nC The following line may replace the next block-if,\nC on machines using ASCII code :\nC     S(L-I:L-I)=CHAR(48+IAND(1,ISHFT(N,-I)))\nC On EBCDIC machines, use 240 instead of 48.\n      IF(BTEST(N,I)) THEN\n      S(L-I:L-I)='1'\n      ELSE\n      S(L-I:L-I)='0'\n      END IF\n   10 CONTINUE\n      S(1:L-K)=''\n      END\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 336240, "name": "Gray code", "source": "Translate Fortran to Java:       PROGRAM GRAY\n      IMPLICIT NONE\n      INTEGER IGRAY,I,J,K\n      CHARACTER*5 A,B,C\n      DO 10 I=0,31\n      J=IGRAY(I,1)\n      K=IGRAY(J,-1)\n      CALL BINARY(A,I,5)\n      CALL BINARY(B,J,5)\n      CALL BINARY(C,K,5)\n      PRINT 99,I,A,B,C,K\n   10 CONTINUE\n   99 FORMAT(I2,3H : ,A5,4H => ,A5,4H => ,A5,3H : ,I2)\n      END\n\n      FUNCTION IGRAY(N,D)\n      IMPLICIT NONE\n      INTEGER D,K,N,IGRAY\n      IF(D.LT.0) GO TO 10\n      IGRAY=IEOR(N,ISHFT(N,-1))\n      RETURN\n   10 K=N\n      IGRAY=0\n   20 IGRAY=IEOR(IGRAY,K)\n      K=K/2\n      IF(K.NE.0) GO TO 20\n      END\n\n      SUBROUTINE BINARY(S,N,K)\n      IMPLICIT NONE\n      INTEGER I,K,L,N\n      CHARACTER*(*) S\n      L=LEN(S)\n      DO 10 I=0,K-1\nC The following line may replace the next block-if,\nC on machines using ASCII code :\nC     S(L-I:L-I)=CHAR(48+IAND(1,ISHFT(N,-I)))\nC On EBCDIC machines, use 240 instead of 48.\n      IF(BTEST(N,I)) THEN\n      S(L-I:L-I)='1'\n      ELSE\n      S(L-I:L-I)='0'\n      END IF\n   10 CONTINUE\n      S(1:L-K)=''\n      END\n", "target": "public class Gray {\n\tpublic static long grayEncode(long n){\n\t\treturn n ^ (n >>> 1);\n\t}\n\t\n\tpublic static long grayDecode(long n) {\n\t\tlong p = n;\n\t\twhile ((n >>>= 1) != 0)\n\t\t\tp ^= n;\n\t\treturn p;\n\t}\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(\"i\\tBinary\\tGray\\tDecoded\");\n\t\tfor(int i = -1; i < 32;i++){\n\t\t\tSystem.out.print(i +\"\\t\");\n\t\t\tSystem.out.print(Integer.toBinaryString(i) + \"\\t\");\n\t\t\tSystem.out.print(Long.toBinaryString(grayEncode(i))+ \"\\t\");\n\t\t\tSystem.out.println(grayDecode(grayEncode(i)));\n\t\t}\n\t}\n}\n"}
{"id": 336241, "name": "File extension is in extensions list", "source": "Translate Fortran to Java:         IT = ICHAR(TEXT(I:I)) - ICHAR(\"a\")\t\n        IF (IT.GE.0 .AND. IT.LE.25) TEXT(I:I) = CHAR(IT + ICHAR(\"A\"))\t\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n"}
{"id": 336242, "name": "File extension is in extensions list", "source": "Translate Fortran to Java:         IT = ICHAR(TEXT(I:I)) - ICHAR(\"a\")\t\n        IF (IT.GE.0 .AND. IT.LE.25) TEXT(I:I) = CHAR(IT + ICHAR(\"A\"))\t\n", "target": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class FileExt{\n\tpublic static void main(String[] args){\n\t\tString[] tests = {\"text.txt\", \"text.TXT\", \"test.tar.gz\", \"test/test2.exe\", \"test\\\\test2.exe\", \"test\", \"a/b/c\\\\d/foo\"};\n\t\tString[] exts = {\".txt\",\".gz\",\"\",\".bat\"};\n\t\t\n\t\tSystem.out.println(\"Extensions: \" + Arrays.toString(exts) + \"\\n\");\n\t\t\n\t\tfor(String test:tests){\n\t\t\tSystem.out.println(test +\": \" + extIsIn(test, exts));\n\t\t}\n\t}\n\t\n\tpublic static boolean extIsIn(String test, String... exts){\n\t\tint lastSlash = Math.max(test.lastIndexOf('/'), test.lastIndexOf('\\\\')); \n\t\tString filename = test.substring(lastSlash + 1);\n\t\t\n\t\t\n\t\tint lastDot = filename.lastIndexOf('.') == -1 ? filename.length() : filename.lastIndexOf('.');\n\t\tString ext = filename.substring(lastDot);\n\t\t\n\t\tArrays.sort(exts);\n\t\t\n\t\treturn Arrays.binarySearch(exts, ext, new Comparator<String>() { \n\t\t\t@Override                                                \n\t\t\tpublic int compare(String o1, String o2) {\n\t\t\t\treturn o1.compareToIgnoreCase(o2);\n\t\t\t}\n\t\t}) >= 0;\n\t}\n}\n"}
{"id": 336243, "name": "Extreme floating point values", "source": "Translate Fortran to Java:        REAL*8\t\tBAD,NaN\t\t\t\n       PARAMETER (NaN = Z'FFFFFFFFFFFFFFFF')\t\n       PARAMETER (BAD = Z'FFFFFFFFFFFFFFFF')\t\n       CHARACTER*3\tBADASTEXT\t\t\n       DATA\t\tBADASTEXT/\"\u00a0? \"/\t\n       REAL*8\t\tPINF,NINF\t\t\n       PARAMETER (PINF = Z'7FF0000000000000')\t\n       PARAMETER (NINF = Z'FFF0000000000000')\t\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 336244, "name": "Extreme floating point values", "source": "Translate Fortran to Java:        REAL*8\t\tBAD,NaN\t\t\t\n       PARAMETER (NaN = Z'FFFFFFFFFFFFFFFF')\t\n       PARAMETER (BAD = Z'FFFFFFFFFFFFFFFF')\t\n       CHARACTER*3\tBADASTEXT\t\t\n       DATA\t\tBADASTEXT/\"\u00a0? \"/\t\n       REAL*8\t\tPINF,NINF\t\t\n       PARAMETER (PINF = Z'7FF0000000000000')\t\n       PARAMETER (NINF = Z'FFF0000000000000')\t\n", "target": "public class Extreme {\n    public static void main(String[] args) {\n        double negInf = -1.0 / 0.0; \n        double inf = 1.0 / 0.0; \n        double nan = 0.0 / 0.0; \n        double negZero = -2.0 / inf;\n\n        System.out.println(\"Negative inf: \" + negInf);\n        System.out.println(\"Positive inf: \" + inf);\n        System.out.println(\"NaN: \" + nan);\n        System.out.println(\"Negative 0: \" + negZero);\n        System.out.println(\"inf + -inf: \" + (inf + negInf));\n        System.out.println(\"0 * NaN: \" + (0 * nan));\n        System.out.println(\"NaN == NaN: \" + (nan == nan));\n    }\n}\n"}
{"id": 336245, "name": "Flow-control structures", "source": "Translate Fortran to Java:       ...\n      ASSIGN 1101 to WHENCE   \n      GO TO 1000              \n 1101 CONTINUE                \n      ... \n      ASSIGN 1102 to WHENCE   \n      GO TO 1000              \n 1102 CONTINUE                \n      ...\nCommon code, far away.\n 1000 do something            \n      GO TO WHENCE            \n", "target": "switch (xx) {\n  case 1:\n  case 2:\n    \n    ...\n    break;\n  case 4:\n    \n    ...\n    break;\n  case 5:\n    \n    ...\n    break;\n  default:\n    \n    break;\n}\n\nfor (int i = 0; i < 10; ++i) {\n  ...\n  if (some_condition) { break; }\n  ...\n}\n\n_Time_: do {\n  for (int i = 0; i < 10; ++i) {\n    ...\n    if (some_condition) { break _Time_; }\n    ...\n    }\n  ...\n} while (thisCondition);\n"}
{"id": 336246, "name": "Find if a point is within a triangle", "source": "Translate Fortran to Java: PROGRAM POINT_WITHIN_TRIANGLE\n\nIMPLICIT NONE\n\nREAL (KIND = SELECTED_REAL_KIND (8)) px, py, ax, ay, bx, by, cx, cy\n\npx = 0.0\npy = 0.0\nax = 1.5\nay = 2.4\nbx = 5.1\nby = -3.1\ncx = -3.8\ncy = 1.2\n\nIF (IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)) THEN\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\n  ELSE\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is not within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\nEND IF\n\nCONTAINS\n\n  \n  LOGICAL FUNCTION IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)\n\n    REAL (KIND = SELECTED_REAL_KIND (8)), INTENT (IN) :: px, py, ax, ay, bx, by, cx, cy\n    REAL (KIND = SELECTED_REAL_KIND (8)) :: vabx, vaby, vacx, vacy, a, b\n\n    vabx = bx - ax\n    vaby = by - ay\n    vacx = cx - ax\n    vacy = cy - ay\n\n    a = ((px * vacy - py * vacx) - (ax * vacy - ay * vacx)) / &\n        (vabx * vacy - vaby * vacx)\n    b = -((px * vaby - py * vabx) - (ax * vaby - ay * vabx)) / &\n        (vabx * vacy - vaby * vacx)\n\n    IF ((a .GT. 0) .AND. (b .GT. 0) .AND. (a + b < 1)) THEN\n\n        IS_P_IN_ABC = .TRUE.\n\n      ELSE\n\n        IS_P_IN_ABC = .FALSE.\n\n    END IF\n\n  END FUNCTION IS_P_IN_ABC\n\nEND PROGRAM POINT_WITHIN_TRIANGLE\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 336247, "name": "Find if a point is within a triangle", "source": "Translate Fortran to Java: PROGRAM POINT_WITHIN_TRIANGLE\n\nIMPLICIT NONE\n\nREAL (KIND = SELECTED_REAL_KIND (8)) px, py, ax, ay, bx, by, cx, cy\n\npx = 0.0\npy = 0.0\nax = 1.5\nay = 2.4\nbx = 5.1\nby = -3.1\ncx = -3.8\ncy = 1.2\n\nIF (IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)) THEN\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\n  ELSE\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is not within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\nEND IF\n\nCONTAINS\n\n  \n  LOGICAL FUNCTION IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)\n\n    REAL (KIND = SELECTED_REAL_KIND (8)), INTENT (IN) :: px, py, ax, ay, bx, by, cx, cy\n    REAL (KIND = SELECTED_REAL_KIND (8)) :: vabx, vaby, vacx, vacy, a, b\n\n    vabx = bx - ax\n    vaby = by - ay\n    vacx = cx - ax\n    vacy = cy - ay\n\n    a = ((px * vacy - py * vacx) - (ax * vacy - ay * vacx)) / &\n        (vabx * vacy - vaby * vacx)\n    b = -((px * vaby - py * vabx) - (ax * vaby - ay * vabx)) / &\n        (vabx * vacy - vaby * vacx)\n\n    IF ((a .GT. 0) .AND. (b .GT. 0) .AND. (a + b < 1)) THEN\n\n        IS_P_IN_ABC = .TRUE.\n\n      ELSE\n\n        IS_P_IN_ABC = .FALSE.\n\n    END IF\n\n  END FUNCTION IS_P_IN_ABC\n\nEND PROGRAM POINT_WITHIN_TRIANGLE\n", "target": "import java.util.Objects;\n\npublic class FindTriangle {\n    private static final double EPS = 0.001;\n    private static final double EPS_SQUARE = EPS * EPS;\n\n    public static class Point {\n        private final double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double getX() {\n            return x;\n        }\n\n        public double getY() {\n            return y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%f, %f)\", x, y);\n        }\n    }\n\n    public static class Triangle {\n        private final Point p1, p2, p3;\n\n        public Triangle(Point p1, Point p2, Point p3) {\n            this.p1 = Objects.requireNonNull(p1);\n            this.p2 = Objects.requireNonNull(p2);\n            this.p3 = Objects.requireNonNull(p3);\n        }\n\n        public Point getP1() {\n            return p1;\n        }\n\n        public Point getP2() {\n            return p2;\n        }\n\n        public Point getP3() {\n            return p3;\n        }\n\n        private boolean pointInTriangleBoundingBox(Point p) {\n            var xMin = Math.min(p1.getX(), Math.min(p2.getX(), p3.getX())) - EPS;\n            var xMax = Math.max(p1.getX(), Math.max(p2.getX(), p3.getX())) + EPS;\n            var yMin = Math.min(p1.getY(), Math.min(p2.getY(), p3.getY())) - EPS;\n            var yMax = Math.max(p1.getY(), Math.max(p2.getY(), p3.getY())) + EPS;\n            return !(p.getX() < xMin || xMax < p.getX() || p.getY() < yMin || yMax < p.getY());\n        }\n\n        private static double side(Point p1, Point p2, Point p) {\n            return (p2.getY() - p1.getY()) * (p.getX() - p1.getX()) + (-p2.getX() + p1.getX()) * (p.getY() - p1.getY());\n        }\n\n        private boolean nativePointInTriangle(Point p) {\n            boolean checkSide1 = side(p1, p2, p) >= 0;\n            boolean checkSide2 = side(p2, p3, p) >= 0;\n            boolean checkSide3 = side(p3, p1, p) >= 0;\n            return checkSide1 && checkSide2 && checkSide3;\n        }\n\n        private double distanceSquarePointToSegment(Point p1, Point p2, Point p) {\n            double p1_p2_squareLength = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n            double dotProduct = ((p.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p2.getY() - p1.getY())) / p1_p2_squareLength;\n            if (dotProduct < 0) {\n                return (p.getX() - p1.getX()) * (p.getX() - p1.getX()) + (p.getY() - p1.getY()) * (p.getY() - p1.getY());\n            }\n            if (dotProduct <= 1) {\n                double p_p1_squareLength = (p1.getX() - p.getX()) * (p1.getX() - p.getX()) + (p1.getY() - p.getY()) * (p1.getY() - p.getY());\n                return p_p1_squareLength - dotProduct * dotProduct * p1_p2_squareLength;\n            }\n            return (p.getX() - p2.getX()) * (p.getX() - p2.getX()) + (p.getY() - p2.getY()) * (p.getY() - p2.getY());\n        }\n\n        private boolean accuratePointInTriangle(Point p) {\n            if (!pointInTriangleBoundingBox(p)) {\n                return false;\n            }\n            if (nativePointInTriangle(p)) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p1, p2, p) <= EPS_SQUARE) {\n                return true;\n            }\n            if (distanceSquarePointToSegment(p2, p3, p) <= EPS_SQUARE) {\n                return true;\n            }\n            return distanceSquarePointToSegment(p3, p1, p) <= EPS_SQUARE;\n        }\n\n        public boolean within(Point p) {\n            Objects.requireNonNull(p);\n            return accuratePointInTriangle(p);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"Triangle[%s, %s, %s]\", p1, p2, p3);\n        }\n    }\n\n    private static void test(Triangle t, Point p) {\n        System.out.println(t);\n        System.out.printf(\"Point %s is within triangle? %s\\n\", p, t.within(p));\n    }\n\n    public static void main(String[] args) {\n        var p1 = new Point(1.5, 2.4);\n        var p2 = new Point(5.1, -3.1);\n        var p3 = new Point(-3.8, 1.2);\n        var tri = new Triangle(p1, p2, p3);\n        test(tri, new Point(0, 0));\n        test(tri, new Point(0, 1));\n        test(tri, new Point(3, 1));\n        System.out.println();\n\n        p1 = new Point(1.0 / 10, 1.0 / 9);\n        p2 = new Point(100.0 / 8, 100.0 / 3);\n        p3 = new Point(100.0 / 4, 100.0 / 9);\n        tri = new Triangle(p1, p2, p3);\n        var pt = new Point(p1.getX() + (3.0 / 7) * (p2.getX() - p1.getX()), p1.getY() + (3.0 / 7) * (p2.getY() - p1.getY()));\n        test(tri, pt);\n        System.out.println();\n\n        p3 = new Point(-100.0 / 8, 100.0 / 6);\n        tri = new Triangle(p1, p2, p3);\n        test(tri, pt);\n    }\n}\n"}
{"id": 336248, "name": "Return multiple values", "source": "Translate Fortran to Java: module multiple_values\nimplicit none\ntype res\n  integer :: p, m\nend type\n\ncontains\n\nfunction addsub(x,y) result(r)\n  integer :: x, y\n  type(res) :: r \n  r%p = x+y\n  r%m = x-y\nend function\nend module\n\nprogram main\n  use multiple_values \n  print *, addsub(33, 22)\nend program\n", "target": "import java.util.List;\nimport java.util.ArrayList;\nimport java.util.Map;\nimport java.util.HashMap;\n\n\npublic class RReturnMultipleVals {\n  public static final String K_lipsum = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\";\n  public static final Long   K_1024   = 1024L;\n  public static final String L        = \"L\";\n  public static final String R        = \"R\";\n\n  \n  public static void main(String[] args) throws NumberFormatException{\n    Long nv_;\n    String sv_;\n    switch (args.length) {\n      case 0:\n        nv_ = K_1024;\n        sv_ = K_lipsum;\n        break;\n      case 1:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = K_lipsum;\n        break;\n      case 2:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        break;\n      default:\n        nv_ = Long.parseLong(args[0]);\n        sv_ = args[1];\n        for (int ix = 2; ix < args.length; ++ix) {\n          sv_ = sv_ + \" \" + args[ix];\n        }\n        break;\n    }\n\n    RReturnMultipleVals lcl = new RReturnMultipleVals();\n\n    Pair<Long, String> rvp = lcl.getPairFromPair(nv_, sv_); \n    System.out.println(\"Results extracted from a composite object:\");\n    System.out.printf(\"%s, %s%n%n\", rvp.getLeftVal(), rvp.getRightVal());\n\n    List<Object> rvl = lcl.getPairFromList(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"List\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvl.get(0), rvl.get(1));\n\n    Map<String, Object> rvm = lcl.getPairFromMap(nv_, sv_); \n    System.out.println(\"Results extracted from a Java Colections \\\"Map\\\" object:\");\n    System.out.printf(\"%s, %s%n%n\", rvm.get(L), rvm.get(R));\n  }\n  \n  \n  \n  public <T, U> Pair<T, U> getPairFromPair(T vl_, U vr_) {\n    return new Pair<T, U>(vl_, vr_);\n  }\n  \n  \n  \n  public List<Object> getPairFromList(Object nv_, Object sv_) {\n    List<Object> rset = new ArrayList<Object>();\n    rset.add(nv_);\n    rset.add(sv_);\n    return rset;\n  }\n  \n  \n  \n  public Map<String, Object> getPairFromMap(Object nv_, Object sv_) {\n    Map<String, Object> rset = new HashMap<String, Object>();\n    rset.put(L, nv_);\n    rset.put(R, sv_);\n    return rset;\n  }\n\n  \n  private static class Pair<L, R> {\n    private L leftVal;\n    private R rightVal;\n\n    public Pair(L nv_, R sv_) {\n      setLeftVal(nv_);\n      setRightVal(sv_);\n    }\n    public void setLeftVal(L nv_) {\n      leftVal = nv_;\n    }\n    public L getLeftVal() {\n      return leftVal;\n    }\n    public void setRightVal(R sv_) {\n      rightVal = sv_;\n    }\n    public R getRightVal() {\n      return rightVal;\n    }\n  }\n}\n"}
{"id": 336249, "name": "Fractran", "source": "Translate Fortran to Java: C:\\Nicky\\RosettaCode\\FRACTRAN\\FRACTRAN.for(6) : Warning: This name has not been given an explicit type.   [M]\n       INTEGER P(M),Q(M)\n", "target": "import java.util.Vector;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class Fractran{\n\n   public static void main(String []args){ \n\n       new Fractran(\"17/91 78/85 19/51 23/38 29/33 77/29 95/23 77/19 1/17 11/13 13/11 15/14 15/2 55/1\", 2);\n   }\n   final int limit = 15;\n   \n\n   Vector<Integer> num = new Vector<>(); \n   Vector<Integer> den = new Vector<>(); \n   public Fractran(String prog, Integer val){\n      compile(prog);\n      dump();\n      exec(2);\n    }\n\n\n   void compile(String prog){\n      Pattern regexp = Pattern.compile(\"\\\\s*(\\\\d*)\\\\s*\\\\/\\\\s*(\\\\d*)\\\\s*(.*)\");\n      Matcher matcher = regexp.matcher(prog);\n      while(matcher.find()){\n         num.add(Integer.parseInt(matcher.group(1)));\n         den.add(Integer.parseInt(matcher.group(2)));\n         matcher = regexp.matcher(matcher.group(3));\n      }\n   }\n\n   void exec(Integer val){\n       int n = 0;\n       while(val != null && n<limit){\n           System.out.println(n+\": \"+val);\n           val = step(val);\n           n++;\n       }\n   }\n   Integer step(int val){\n       int i=0; \n       while(i<den.size() && val%den.get(i) != 0) i++;\n       if(i<den.size())\n           return num.get(i)*val/den.get(i);\n       return null;\n   }\n\n   void dump(){\n       for(int i=0; i<den.size(); i++)\n           System.out.print(num.get(i)+\"/\"+den.get(i)+\" \");\n       System.out.println();\n   }\n}\n"}
{"id": 336250, "name": "Substring_Top and tail", "source": "Translate Fortran to Java: program substring\n\n  character(len=5) :: string\n  string = \"Hello\"\n  \n  write (*,*) string\n  write (*,*) string(2:)\n  write (*,*) string( :len(string)-1)\n  write (*,*) string(2:len(string)-1)\n\nend program substring\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 336251, "name": "Substring_Top and tail", "source": "Translate Fortran to Java: program substring\n\n  character(len=5) :: string\n  string = \"Hello\"\n  \n  write (*,*) string\n  write (*,*) string(2:)\n  write (*,*) string( :len(string)-1)\n  write (*,*) string(2:len(string)-1)\n\nend program substring\n", "target": "String strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n"}
{"id": 336252, "name": "Boolean values", "source": "Translate Fortran to Java:       TYPE MIXED\n       LOGICAL*1 LIVE\n       REAL*8    VALUE\n      END TYPE MIXED\n      TYPE(MIXED) STUFF(100)\n", "target": "module GeorgeBoole\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Boolean f = False;\n        assert !f == True;\n\n        \n        \n        assert True.and(False) == True & False == False;\n        assert True.or(False)  == True | False == True;\n        assert True.xor(False) == True ^ False == True;\n        assert True.not() == ~True == False;\n\n        console.print($\"0==1 = {0==1}\");\n        console.print($\"!False = {!False}\");\n        }\n    }\n"}
{"id": 336253, "name": "Bitmap_Histogram", "source": "Translate Fortran to Java: module RCImageProcess\n  use RCImageBasic\n  implicit none\ncontains\n\n  subroutine get_histogram(img, histogram)\n    type(scimage), intent(in) :: img\n    integer, dimension(0:255), intent(out) :: histogram\n    \n    integer :: i\n\n    histogram = 0\n    do i = 0,255\n       histogram(i) = sum(img%channel, img%channel == i)\n    end do\n  end subroutine get_histogram\n\n  function histogram_median(histogram)\n    integer, dimension(0:255), intent(in) :: histogram\n    integer :: histogram_median\n    \n    integer :: from, to, left, right\n\n    from = 0\n    to = 255\n    left = histogram(from)\n    right = histogram(to)\n    do while ( from /= to )\n       if ( left < right ) then\n          from = from + 1\n          left = left + histogram(from)\n       else\n          to = to - 1\n          right = right + histogram(to)\n       end if\n    end do\n    histogram_median = from\n  end function histogram_median\n  \nend module RCImageProcess\n", "target": "import java.awt.image.BufferedImage;\nimport java.io.File;\nimport java.io.IOException;\nimport javax.imageio.ImageIO;\n\npublic enum ImageProcessing {\n    ;\n\n    public static void main(String[] args) throws IOException {\n        BufferedImage img = ImageIO.read(new File(\"example.png\"));\n\n        BufferedImage bwimg = toBlackAndWhite(img);\n\n        ImageIO.write(bwimg, \"png\", new File(\"example-bw.png\"));\n    }\n\n    private static int luminance(int rgb) {\n        int r = (rgb >> 16) & 0xFF;\n        int g = (rgb >> 8) & 0xFF;\n        int b = rgb & 0xFF;\n        return (r + b + g) / 3;\n    }\n\n    private static BufferedImage toBlackAndWhite(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = computeHistogram(img);\n\n        int median = getMedian(width * height, histo);\n\n        BufferedImage bwimg = new BufferedImage(width, height, img.getType());\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                bwimg.setRGB(x, y, luminance(img.getRGB(x, y)) >= median ? 0xFFFFFFFF : 0xFF000000);\n            }\n        }\n        return bwimg;\n    }\n\n    private static int[] computeHistogram(BufferedImage img) {\n        int width = img.getWidth();\n        int height = img.getHeight();\n\n        int[] histo = new int[256];\n        for (int y = 0; y < height; y++) {\n            for (int x = 0; x < width; x++) {\n                histo[luminance(img.getRGB(x, y))]++;\n            }\n        }\n        return histo;\n    }\n\n    private static int getMedian(int total, int[] histo) {\n        int median = 0;\n        int sum = 0;\n        for (int i = 0; i < histo.length && sum + histo[i] < total / 2; i++) {\n            sum += histo[i];\n            median++;\n        }\n        return median;\n    }\n}\n"}
{"id": 336254, "name": "LZW compression", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n      MODULE LZW_SHARED_PARAMETERS\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  COMPILER_INTEGER_SIZE = 32 , BITS = 12 , FILEIN = 66 ,     &\n                             & FILEOUT = 99 , MAX_VALUE = (2**BITS) - 1 ,                 &\n                             & MAX_CODE = MAX_VALUE - 1 , MAX_DICTIONARY_SIZE = 5021 ,    &\n                             & SYMBOL_SIZE = 8 , MISSING_BITS = COMPILER_INTEGER_SIZE -   &\n                             & SYMBOL_SIZE\n\n\n\n      INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  concatenatedsymbols\n      INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  prefixcodes\n      INTEGER  ::  the_status = 0\n\n\n \n      END MODULE LZW_SHARED_PARAMETERS\n\n\n\n\n\n\n\n\n\n\n      MODULE CODECIO\n      USE LZW_SHARED_PARAMETERS\n      IMPLICIT NONE\n\n      CONTAINS\n      SUBROUTINE SETOUTPUTCODE(Code)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Code\n      INTENT (IN) Code\n\n\n\n      INTEGER  ::  buffer\n      INTEGER  ::  outputbitbuffer = 0\n      INTEGER  ::  outputbitcount = 0\n      INTEGER  ::  shift\n      INTEGER  ::  shiftedsymbol\n\n      shift = COMPILER_INTEGER_SIZE - BITS - outputbitcount\n      shiftedsymbol = ISHFT(Code , shift)\n      outputbitbuffer = IOR(outputbitbuffer , shiftedsymbol)\n      outputbitcount = outputbitcount + BITS\n \n      DO WHILE(outputbitcount >= SYMBOL_SIZE)\n\n         buffer = ISHFT(outputbitbuffer , -MISSING_BITS)\n         CALL SETRAWBYTE(buffer)\n         outputbitbuffer = ISHFT(outputbitbuffer , SYMBOL_SIZE)\n         outputbitcount = outputbitcount - SYMBOL_SIZE\n      END DO\n      RETURN\n      END SUBROUTINE SETOUTPUTCODE\n \n \n      SUBROUTINE SETRAWBYTE(Symbol)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Symbol\n      INTENT (IN) Symbol\n\n \n      CALL FPUTC(FILEOUT , ACHAR(Symbol))\n      END SUBROUTINE SETRAWBYTE\n \n \n      FUNCTION GETRAWBYTE()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  GETRAWBYTE\n\n\n\n      CHARACTER  ::  bufferedbyte\n\n      CALL FGETC(FILEIN , bufferedbyte , THE_status)\n      GETRAWBYTE = IACHAR(bufferedbyte)\n      END FUNCTION GETRAWBYTE\n \n      FUNCTION GETINPUTCODE()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  GETINPUTCODE\n\n\n\n      INTEGER  ::  inputbitbuffer = 0\n      INTEGER  ::  inputbitcounter = 0\n      INTEGER  ::  integerinputbuff\n      INTEGER  ::  returnn\n      INTEGER  ::  shiftedbit\n\n      DO WHILE( inputbitcounter <= MISSING_BITS )\n\n         integerinputbuff = GETRAWBYTE()\n         shiftedbit = ISHFT(integerinputbuff , MISSING_BITS - inputbitcounter)\n         inputbitbuffer = IOR(inputbitbuffer , shiftedbit)\n         inputbitcounter = inputbitcounter + SYMBOL_SIZE\n      END DO\n \n      returnn = ISHFT(inputbitbuffer , BITS - COMPILER_INTEGER_SIZE)\n      inputbitbuffer = ISHFT(inputbitbuffer , BITS)\n      inputbitcounter = inputbitcounter - BITS\n      GETINPUTCODE = returnn\n      RETURN\n      END FUNCTION GETINPUTCODE\nend module codecIO\n\n\n\n\n\n\n\n\n\n      MODULE LZW_ENCODER\n      USE LZW_SHARED_PARAMETERS\n      USE CODECIO\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  HASH_SHIFT = BITS - SYMBOL_SIZE\n\n\n\n      INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  symbolvalues\n      CONTAINS\n      SUBROUTINE COMPRESS()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  codedsymbol\n      INTEGER  ::  my_index\n      INTEGER  ::  nextsymbol\n      INTEGER  ::  symbol\n      CHARACTER  ::  bufferedbyte\n\n      nextsymbol = COMPILER_INTEGER_SIZE*SYMBOL_SIZE\n      SYMbolvalues(:) = -1\n \n\n      CALL FGETC(FILEIN , bufferedbyte , THE_status)\n      codedsymbol = IACHAR(bufferedbyte)\n\n      DO WHILE(THE_status == 0)\n\n          CALL FGETC(FILEIN , bufferedbyte , THE_status)\n          symbol = IACHAR(bufferedbyte)\n         IF( THE_status/=0 )CYCLE\n \n         my_index = GETPOSITIONONDICTIONARY(codedsymbol , symbol)\n         IF( SYMbolvalues(my_index)/= - 1 )THEN\n            codedsymbol = SYMbolvalues(my_index)\n         ELSE\n            IF( nextsymbol<=MAX_CODE )THEN\n               SYMbolvalues(my_index) = nextsymbol\n               nextsymbol = nextsymbol + 1\n               PREfixcodes(my_index) = codedsymbol\n               CONcatenatedsymbols(my_index) = symbol\n            END IF\n            CALL SETOUTPUTCODE(codedsymbol)\n            codedsymbol = symbol\n         END IF\n      END DO\n      CALL SETOUTPUTCODE(codedsymbol)\n      CALL SETOUTPUTCODE(MAX_VALUE)\n      CALL SETOUTPUTCODE(0)\n      END SUBROUTINE COMPRESS\n \nfunction getPositionOnDictionary(hashPrefix, hashSymbol)\n      integer, intent(in) :: hashPrefix\n      integer, intent(in) :: hashSymbol\n      integer             :: getPositionOnDictionary\n      integer             :: index\n      integer             :: offset\n\n      index = ishft(hashSymbol, HASH_SHIFT)\n      index = ieor(index, hashPrefix)\n      if (index == 0) then\n        offset = 1\n      else\n        offset = MAX_DICTIONARY_SIZE - index\n      endif\n\n      do\n        if (symbolValues(index) == -1) then\n          getPositionOnDictionary = index\n          exit\n        endif\n\n        if (prefixCodes(index) == hashPrefix .and. &\n            & concatenatedSymbols(index) == hashSymbol) then\n          getPositionOnDictionary = index\n          exit\n        endif\n\n        index = index - offset\n        if (index < 0) then\n          index = index + MAX_DICTIONARY_SIZE\n        endif\n      end do\n      return\n    end function\n\nend module LZW_Encoder\n\n\n\n\n\n\n\n\n\n      MODULE LZW_DECODER\n      USE LZW_SHARED_PARAMETERS\n      USE CODECIO\n      IMPLICIT NONE\n\n\n\n      TYPE :: DECODE_BUFFER_STACK\n         INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  DECODERSTACK\n         INTEGER  ::  TOP\n      END TYPE DECODE_BUFFER_STACK\n\n\n\n      TYPE(DECODE_BUFFER_STACK)  ::  stack\n      CONTAINS\n\n\n      SUBROUTINE DECOMPRESS()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  newsymbol\n      INTEGER  ::  nextsymbol\n      INTEGER  ::  oldsymbol\n      INTEGER  ::  popedsymbol\n      INTEGER  ::  symbol\n\n      nextsymbol = COMPILER_INTEGER_SIZE*SYMBOL_SIZE\n      oldsymbol = GETINPUTCODE()\n      symbol = oldsymbol\n \n      CALL SETRAWBYTE(oldsymbol)\n \n      DO\n         newsymbol = GETINPUTCODE()\n \n         IF( newsymbol==MAX_VALUE )RETURN\n \n         IF( newsymbol>=nextsymbol )THEN\n            STAck%DECODERSTACK(0) = symbol\n            CALL DECODESYMBOL(STAck%DECODERSTACK(1:) , oldsymbol)\n         ELSE\n            CALL DECODESYMBOL(STAck%DECODERSTACK(:) , newsymbol)\n         END IF\n \n         symbol = STAck%DECODERSTACK(STAck%TOP)\n \n         DO WHILE ( STAck%TOP>=0 )\n            popedsymbol = STAck%DECODERSTACK(STAck%TOP)\n            CALL SETRAWBYTE(popedsymbol)\n            STAck%TOP = STAck%TOP - 1\n         END DO\n \n         IF( nextsymbol<=MAX_CODE )THEN\n            PREfixcodes(nextsymbol) = oldsymbol\n            CONcatenatedsymbols(nextsymbol) = symbol\n            nextsymbol = nextsymbol + 1\n         END IF\n         oldsymbol = newsymbol\n      END DO\n      RETURN\n      END SUBROUTINE DECOMPRESS\n  \n      SUBROUTINE DECODESYMBOL(Buffer , Code)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Code\n      INTEGER , DIMENSION(:)  ::  Buffer\n      INTENT (IN) Code\n      INTENT (INOUT) Buffer\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  symbol\n\n      j = 0\n      symbol = Code\n      STAck%TOP = 0\n      DO WHILE ( symbol>=COMPILER_INTEGER_SIZE*SYMBOL_SIZE )\n \n \n         IF( j>=MAX_CODE )THEN\n            PRINT * , \"Decoding error\"\n            STOP\n         END IF\n \n         i = STAck%TOP + 1\n         Buffer(i) = CONcatenatedsymbols(symbol)\n         symbol = PREfixcodes(symbol)\n         STAck%TOP = STAck%TOP + 1\n         j = j + 1\n      END DO\n      i = j + 1\n      Buffer(i) = symbol\n      END SUBROUTINE DECODESYMBOL\nend module LZW_Decoder\n\n\n\n\n\n\n\n\n\n \n      MODULE LZW\n      USE LZW_SHARED_PARAMETERS\n      USE LZW_ENCODER\n      USE LZW_DECODER\n      IMPLICIT NONE\n      CONTAINS\n      SUBROUTINE INIT(Input , Output , Operation , Filename)\n      IMPLICIT NONE\n\n\n\n      CHARACTER(100)  ::  Filename\n      CHARACTER(100)  ::  Input\n      CHARACTER(1)  ::  Operation\n      CHARACTER(100)  ::  Output\n      INTENT (IN) Filename , Input , Operation , Output\n\n      IF( Operation/='d' .AND. Operation/='e' )THEN\n         PRINT * , \"Usage: \" // TRIM(Filename) // \" <operation> input output\"\n         PRINT * , \"Possible operations: \"\n         PRINT * , \"    e -> encode (compress)\"\n         PRINT * , \"    d -> decode (inflate)\"\n         STOP\n      END IF\n \n      OPEN(UNIT = FILEIN , FILE = Input , ACTION = \"read\" , STATUS = \"old\" ,              &\n          &ACCESS = 'stream' , FORM = \"formatted\")\n      OPEN(UNIT = FILEOUT , FILE = Output , ACTION = \"write\" , STATUS = \"replace\" ,       &\n         & ACCESS = 'stream' , FORM = \"formatted\")\n \n      IF( Operation=='d' )THEN\n         PRINT * , \"Decoding...\"\n         CALL DECOMPRESS()\n      ELSE\n         PRINT * , \"Encoding...\"\n         CALL COMPRESS()\n      END IF\n \n      CLOSE(UNIT = FILEIN)\n      CLOSE(UNIT = FILEOUT)\n      END SUBROUTINE INIT\nend module LZW\n\n      PROGRAM MAIN\n      USE LZW\n      IMPLICIT NONE\n\n\n\n      CHARACTER(100)  ::  filename\n      REAL  ::  finish\n      CHARACTER(100)  ::  input\n      CHARACTER(1)  ::  operation\n      CHARACTER(100)  ::  output\n      REAL  ::  start\n\n      CALL GETARG(0 , filename)\n      CALL GETARG(1 , operation)\n      CALL GETARG(2 , input)\n      CALL GETARG(3 , output)\n      CALL CPU_TIME(start)\n      CALL INIT(input , output , operation , filename)\n      CALL CPU_TIME(finish)\n      PRINT '(\"Time = \",f6.3,\" seconds.\")' , finish - start\n      END PROGRAM MAIN\n", "target": "import java.util.*;\n\npublic class LZW {\n    \n    public static List<Integer> compress(String uncompressed) {\n        \n        int dictSize = 256;\n        Map<String,Integer> dictionary = new HashMap<String,Integer>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(\"\" + (char)i, i);\n        \n        String w = \"\";\n        List<Integer> result = new ArrayList<Integer>();\n        for (char c : uncompressed.toCharArray()) {\n            String wc = w + c;\n            if (dictionary.containsKey(wc))\n                w = wc;\n            else {\n                result.add(dictionary.get(w));\n                \n                dictionary.put(wc, dictSize++);\n                w = \"\" + c;\n            }\n        }\n \n        \n        if (!w.equals(\"\"))\n            result.add(dictionary.get(w));\n        return result;\n    }\n    \n    \n    public static String decompress(List<Integer> compressed) {\n        \n        int dictSize = 256;\n        Map<Integer,String> dictionary = new HashMap<Integer,String>();\n        for (int i = 0; i < 256; i++)\n            dictionary.put(i, \"\" + (char)i);\n        \n        String w = \"\" + (char)(int)compressed.remove(0);\n        StringBuffer result = new StringBuffer(w);\n        for (int k : compressed) {\n            String entry;\n            if (dictionary.containsKey(k))\n                entry = dictionary.get(k);\n            else if (k == dictSize)\n                entry = w + w.charAt(0);\n            else\n                throw new IllegalArgumentException(\"Bad compressed k: \" + k);\n            \n            result.append(entry);\n            \n            \n            dictionary.put(dictSize++, w + entry.charAt(0));\n            \n            w = entry;\n        }\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        List<Integer> compressed = compress(\"TOBEORNOTTOBEORTOBEORNOT\");\n        System.out.println(compressed);\n        String decompressed = decompress(compressed);\n        System.out.println(decompressed);\n    }\n}\n"}
{"id": 336255, "name": "Ulam spiral (for primes)", "source": "Translate Fortran to Java: program ulam\n  implicit none\n\n  integer, parameter :: nsize = 49\n  integer :: i, j, n, x, y\n  integer :: a(nsize*nsize) = (/ (i, i = 1, nsize*nsize) /)\n  character(1)  :: spiral(nsize, nsize) = \" \" \n  character(2)  :: sstr\n  character(10) :: fmt\n  \n  n = 1\n  x = nsize / 2 + 1\n  y = x\n  if(isprime(a(n))) spiral(x, y) = \"O\"\n  n = n + 1\n\n  do i = 1, nsize-1, 2\n    do j = 1, i\n      x = x + 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n\n    do j = 1, i\n      y = y - 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n\n    do j = 1, i+1\n      x = x - 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n\n    do j = 1, i+1\n      y = y + 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n  end do\n\n  do j = 1, nsize-1\n    x = x + 1\n    if(isprime(a(n))) spiral(x, y) = \"O\"\n    n = n + 1\n  end do\n\n  write(sstr, \"(i0)\") nsize\n  fmt = \"(\" // sstr // \"(a,1x))\"\n  do i = 1, nsize\n    write(*, fmt) spiral(:, i)\n  end do\n\ncontains\n\nfunction isprime(number)\n  logical :: isprime\n  integer, intent(in) :: number\n  integer :: i\n \n  if(number == 2) then\n    isprime = .true.\n  else if(number < 2 .or. mod(number,2) == 0) then\n    isprime = .false.\n  else\n    isprime = .true.\n    do i = 3, int(sqrt(real(number))), 2\n      if(mod(number,i) == 0) then\n        isprime = .false.\n        exit\n      end if\n    end do\n  end if\nend function\nend program\n", "target": "import java.util.Arrays;\n\npublic class Ulam{\n\tenum Direction{\n\t\tRIGHT, UP, LEFT, DOWN;\n\t}\n\t\n\tprivate static String[][] genUlam(int n){\n\t\treturn genUlam(n, 1);\n\t}\n\n\tprivate static String[][] genUlam(int n, int i){\n\t\tString[][] spiral = new String[n][n];\n\t\tDirection dir = Direction.RIGHT;\n\t\tint j = i;\n\t\tint y = n / 2;\n\t\tint x = (n % 2 == 0) ? y - 1 : y; \n\t\twhile(j <= ((n * n) - 1 + i)){\n\t\t\tspiral[y][x] = isPrime(j) ? String.format(\"%4d\", j) : \" ---\";\n\n\t\t\tswitch(dir){\n\t\t\tcase RIGHT:\n\t\t\t\tif(x <= (n - 1) && spiral[y - 1][x] == null && j > i) dir = Direction.UP; break;\n\t\t\tcase UP:\n\t\t\t\tif(spiral[y][x - 1] == null) dir = Direction.LEFT; break;\n\t\t\tcase LEFT:\n\t\t\t\tif(x == 0 || spiral[y + 1][x] == null) dir = Direction.DOWN; break;\n\t\t\tcase DOWN:\n\t\t\t\tif(spiral[y][x + 1] == null) dir = Direction.RIGHT; break;\n\t\t\t}\n\t\t\t\n\t\t\tswitch(dir){\n\t\t\t\tcase RIGHT:\tx++; break;\n\t\t\t\tcase UP: \ty--; break;\n\t\t\t\tcase LEFT:\tx--; break;\n\t\t\t\tcase DOWN:\ty++; break;\n\t\t\t}\n\t\t\tj++;\n\t\t}\n\t\treturn spiral;\n\t}\n\t\n\tpublic static boolean isPrime(int a){\n\t\t   if(a == 2) return true;\n\t\t   if(a <= 1 || a % 2 == 0) return false;\n\t\t   long max = (long)Math.sqrt(a);\n\t\t   for(long n = 3; n <= max; n += 2){\n\t\t      if(a % n == 0) return false;\n\t\t   }\n\t\t   return true;\n\t\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[][] ulam = genUlam(9);\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\",\", \"\"));\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(String[] row : ulam){\n\t\t\tSystem.out.println(Arrays.toString(row).replaceAll(\"\\\\[\\\\s+\\\\d+\", \"[  * \").replaceAll(\"\\\\s+\\\\d+\", \"   * \").replaceAll(\",\", \"\"));\n\t\t}\n\t}\n}\n"}
{"id": 336256, "name": "Text processing_1", "source": "Translate Fortran to Java: Crunches a set of hourly data. Starts with a date, then 24 pairs of value,indicator for that day, on one line.\n      INTEGER Y,M,D\t\t\n      INTEGER GOOD(24)\t\t\n      REAL*8 V(24),VTOT,T\t\n      INTEGER NV,N,NB\t\t\n      INTEGER I,NREC,HIC\t\n      INTEGER BI,BN,BBI,BBN\t\n      CHARACTER*10 BDATE,BBDATE\t\n      LOGICAL INGOOD\t\t\n      INTEGER IN,MSG\t\t\n      CHARACTER*666 ACARD\t\n      IN = 10\t\t\n      MSG = 6\t\t\n      OPEN (IN,FILE=\"Readings1.txt\", FORM=\"FORMATTED\",\t\n     1 STATUS =\"OLD\",ACTION=\"READ\")\t\t\t\n      NB = 0\t\t\n      NV = 0\t\t\n      VTOT = 0\t\t\n      NREC = 0\t\t\n      HIC = 0\t\t\n      INGOOD = .TRUE.\t\n      BBN = 0\t\t\nChew into the file.\n   10 READ (IN,11,END=100,ERR=666) L,ACARD(1:MIN(L,LEN(ACARD)))\t\n      NREC = NREC + 1\t\t\n   11 FORMAT (Q,A)\t\t\n      READ (ACARD,12,END=600,ERR=601) Y,M,D\t\n   12 FORMAT (I4,2(1X,I2))\t\t\t\t\n      READ (ACARD(11:L),*,END=600,ERR=601) (V(I),GOOD(I),I = 1,24)\t\nCalculations. Could use COUNT(array) and SUM(array), but each requires its own pass through the array.\n   20 T = 0\t\t\n      N = 0\t\t\n      DO I = 1,24\t\n        IF (GOOD(I).GT.0) THEN\t\n          N = N + 1\t\t\n          T = T + V(I)\t\t\n          IF (.NOT.INGOOD) THEN\t\n            INGOOD = .TRUE.\t\n            IF (BN.GT.BBN) THEN\t\n              BBN = BN\t\t\n              BBI = BI\t\t\n              BBDATE = BDATE\t\n            END IF\t\t\n          END IF\t\t\n         ELSE\t\t\n          IF (INGOOD) THEN\t\n            INGOOD = .FALSE.\t\n            BDATE = ACARD(1:10)\t\n            BI = I\t\t\n            BN = 0\t\t\n          END IF\t\t\n          BN = BN + 1\t\n        END IF\t\t\n      END DO\t\t\nCommentary for the day's data..\n      IF (N.LE.0) THEN\t\n        WRITE (MSG,21) NREC,ACARD(1:10)\t\n   21   FORMAT (\"Record\",I8,\" (\",A,\") has no good data\n       ELSE\t\t\t\n        WRITE(MSG,22) NREC,ACARD(1:10),N,T/N\t\n   22   FORMAT(\"Record\",I8,\" (\",A,\")\",I3,\" good, average\",F9.3)\t\n        NB = NB + 24 - N\t\n        NV = NV + N\t\t\n        VTOT = VTOT + T\t\t\n      END IF\t\t\t\n      GO TO 10\t\t\n\nComplaints. Should really distinguish between trouble in the date part and in the data part.\n  600 WRITE (MSG,*) '\"END\" declared - insufficient data?'\t\n      GO TO 602\t\t\t\t\n  601 WRITE (MSG,*) '\"ERR\" declared - improper number format?'\t\n  602 WRITE (MSG,603) NREC,L,ACARD(1:L)\t\n  603 FORMAT(\" Record \",I0,\", length \",I0,\" reads \",A)\t\n      HIC = HIC + 1\t\t\t\n      IF (HIC.LE.12) GO TO 10\t\t\n      STOP \"Enough distaste.\"\t\t\n  666 WRITE (MSG,101) NREC,\"format error\n      GO TO 900\t\t\t\t\n\nClosedown.\n  100 WRITE (MSG,101) NREC,\"then end-of-file\"\t\n  101 FORMAT (\" Record \",I0,\": \",A)\t\t\n      WRITE (MSG,102) NV,NB,VTOT/NV\t\t\n  102 FORMAT (I8,\" values, \",I0,\" bad. Average\",F9.4)\t\n      IF (BBN.LE.0) THEN\t\t\n        WRITE (MSG,*) \"No bad value presented, so no longest run.\"\t\n       ELSE\t\t\t\t\n        WRITE (MSG,103) BBN,BBI,BBDATE\t\n  103   FORMAT (\"Longest bad run: \",I0,\", starting hour \",I0,\" on \",A)\t\n      END IF\t\t\t\n  900 CLOSE(IN)\t\t\n      END\t\n", "target": "import java.io.File;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class TextProcessing1 {\n\n    public static void main(String[] args) throws Exception {\n        Locale.setDefault(new Locale(\"en\", \"US\"));\n        Metrics metrics = new Metrics();\n\n        int dataGap = 0;\n        String gapBeginDate = null;\n        try (Scanner lines = new Scanner(new File(\"readings.txt\"))) {\n            while (lines.hasNextLine()) {\n\n                double lineTotal = 0.0;\n                int linePairs = 0;\n                int lineInvalid = 0;\n                String lineDate;\n\n                try (Scanner line = new Scanner(lines.nextLine())) {\n\n                    lineDate = line.next();\n\n                    while (line.hasNext()) {\n                        final double value = line.nextDouble();\n                        if (line.nextInt() <= 0) {\n                            if (dataGap == 0)\n                                gapBeginDate = lineDate;\n                            dataGap++;\n                            lineInvalid++;\n                            continue;\n                        }\n                        lineTotal += value;\n                        linePairs++;\n\n                        metrics.addDataGap(dataGap, gapBeginDate, lineDate);\n                        dataGap = 0;\n                    }\n                }\n                metrics.addLine(lineTotal, linePairs);\n                metrics.lineResult(lineDate, lineInvalid, linePairs, lineTotal);\n            }\n            metrics.report();\n        }\n    }\n\n    private static class Metrics {\n        private List<String[]> gapDates;\n        private int maxDataGap = -1;\n        private double total;\n        private int pairs;\n        private int lineResultCount;\n\n        void addLine(double tot, double prs) {\n            total += tot;\n            pairs += prs;\n        }\n\n        void addDataGap(int gap, String begin, String end) {\n            if (gap > 0 && gap >= maxDataGap) {\n                if (gap > maxDataGap) {\n                    maxDataGap = gap;\n                    gapDates = new ArrayList<>();\n                }\n                gapDates.add(new String[]{begin, end});\n            }\n        }\n\n        void lineResult(String date, int invalid, int prs, double tot) {\n            if (lineResultCount >= 3)\n                return;\n            out.printf(\"%10s  out: %2d  in: %2d  tot: %10.3f  avg: %10.3f%n\",\n                    date, invalid, prs, tot, (prs > 0) ? tot / prs : 0.0);\n            lineResultCount++;\n        }\n\n        void report() {\n            out.printf(\"%ntotal    = %10.3f%n\", total);\n            out.printf(\"readings = %6d%n\", pairs);\n            out.printf(\"average  = %010.3f%n\", total / pairs);\n            out.printf(\"%nmaximum run(s) of %d invalid measurements: %n\",\n                    maxDataGap);\n            for (String[] dates : gapDates)\n                out.printf(\"begins at %s and ends at %s%n\", dates[0], dates[1]);\n\n        }\n    }\n}\n"}
{"id": 336257, "name": "Hello world_Line printer", "source": "Translate Fortran to Java:       WRITE (6,1)\n    1 FORMAT (\"+HELLO WORLD\n      END\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 336258, "name": "Hello world_Line printer", "source": "Translate Fortran to Java:       WRITE (6,1)\n    1 FORMAT (\"+HELLO WORLD\n      END\n", "target": "import java.io.FileWriter;\nimport java.io.IOException;\n \npublic class LinePrinter {\n  public static void main(String[] args) {\n    try {\n      FileWriter lp0 = new FileWriter(\"/dev/lp0\");\n      lp0.write(\"Hello World!\");\n      lp0.close();\n    } catch (IOException ioe) {\n      ioe.printStackTrace();\n    }\n  }\n}\n"}
{"id": 336259, "name": "Magic squares of odd order", "source": "Translate Fortran to Java: program Magic_Square\n  implicit none\n\n  integer, parameter :: order = 15\n  integer :: i, j\n \n  write(*, \"(a, i0)\") \"Magic Square Order: \", order\n  write(*, \"(a)\")     \"----------------------\"\n  do i = 1, order\n    do j = 1, order\n      write(*, \"(i4)\", advance = \"no\") f1(order, i, j)\n    end do\n    write(*,*)\n  end do\n  write(*, \"(a, i0)\") \"Magic number = \", f2(order)\n\ncontains\n\ninteger function f1(n, x, y)\n  integer, intent(in) :: n, x, y\n\n  f1 = n * mod(x + y - 1 + n/2, n) + mod(x + 2*y - 2, n) + 1\nend function\n\ninteger function f2(n)\n  integer, intent(in) :: n\n\n  f2 = n * (1 + n * n) / 2\nend function\nend program\n", "target": "public class MagicSquare {\n\n    public static void main(String[] args) {\n        int n = 5;\n        for (int[] row : magicSquareOdd(n)) {\n            for (int x : row)\n                System.out.format(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int base) {\n        if (base % 2 == 0 || base < 3)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int[][] grid = new int[base][base];\n        int r = 0, number = 0;\n        int size = base * base;\n\n        int c = base / 2;\n        while (number++ < size) {\n            grid[r][c] = number;\n            if (r == 0) {\n                if (c == base - 1) {\n                    r++;\n                } else {\n                    r = base - 1;\n                    c++;\n                }\n            } else {\n                if (c == base - 1) {\n                    r--;\n                    c = 0;\n                } else {\n                    if (grid[r - 1][c + 1] == 0) {\n                        r--;\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n            }\n        }\n        return grid;\n    }\n}\n"}
{"id": 336260, "name": "Magic squares of odd order", "source": "Translate Fortran to Java: program Magic_Square\n  implicit none\n\n  integer, parameter :: order = 15\n  integer :: i, j\n \n  write(*, \"(a, i0)\") \"Magic Square Order: \", order\n  write(*, \"(a)\")     \"----------------------\"\n  do i = 1, order\n    do j = 1, order\n      write(*, \"(i4)\", advance = \"no\") f1(order, i, j)\n    end do\n    write(*,*)\n  end do\n  write(*, \"(a, i0)\") \"Magic number = \", f2(order)\n\ncontains\n\ninteger function f1(n, x, y)\n  integer, intent(in) :: n, x, y\n\n  f1 = n * mod(x + y - 1 + n/2, n) + mod(x + 2*y - 2, n) + 1\nend function\n\ninteger function f2(n)\n  integer, intent(in) :: n\n\n  f2 = n * (1 + n * n) / 2\nend function\nend program\n", "target": "public class MagicSquare {\n\n    public static void main(String[] args) {\n        int n = 5;\n        for (int[] row : magicSquareOdd(n)) {\n            for (int x : row)\n                System.out.format(\"%2s \", x);\n            System.out.println();\n        }\n        System.out.printf(\"\\nMagic constant: %d \", (n * n + 1) * n / 2);\n    }\n\n    public static int[][] magicSquareOdd(final int base) {\n        if (base % 2 == 0 || base < 3)\n            throw new IllegalArgumentException(\"base must be odd and > 2\");\n\n        int[][] grid = new int[base][base];\n        int r = 0, number = 0;\n        int size = base * base;\n\n        int c = base / 2;\n        while (number++ < size) {\n            grid[r][c] = number;\n            if (r == 0) {\n                if (c == base - 1) {\n                    r++;\n                } else {\n                    r = base - 1;\n                    c++;\n                }\n            } else {\n                if (c == base - 1) {\n                    r--;\n                    c = 0;\n                } else {\n                    if (grid[r - 1][c + 1] == 0) {\n                        r--;\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n            }\n        }\n        return grid;\n    }\n}\n"}
{"id": 336261, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Fortran to Java: module SutherlandHodgmanUtil\n  \n\n  \n  type polygon\n    \n    \n    integer :: n\n    double precision, dimension(:,:), allocatable :: vertex\n  end type polygon\n  \n  contains \n  \n  \n  subroutine sutherlandHodgman( ref, clip, outputPolygon )\n    \n  \n    \n    type(polygon) :: ref, clip, outputPolygon\n  \n    \n    type(polygon) :: workPolygon               \n    double precision, dimension(2) :: y1,y2    \n    integer :: i  \n  \n    \n    \n    allocate(workPolygon%vertex( ref%n+clip%n , 2 ))\n    \n    \n    workPolygon%n = clip%n\n    workPolygon%vertex(1:workPolygon%n,:) = clip%vertex(1:workPolygon%n,:)\n\n    do i=1,ref%n-1 \n      y1(:) = ref%vertex(i,:)   \n      y2(:) = ref%vertex(i+1,:) \n  \n      \n      call edgeClipping( workPolygon, y1, y2, outputPolygon)\n      \n      workPolygon%n = outputPolygon%n\n      workPolygon%vertex(1:workPolygon%n,:) = outputPolygon%vertex(1:workPolygon%n,:)\n\n    end do \n    deallocate(workPolygon%vertex)\n  end subroutine sutherlandHodgman\n  \n  \n  subroutine edgeClipping( poly, y1, y2, outputPoly )\n    \n    \n    type(polygon) :: poly, outputPoly\n    double precision, dimension(2) :: y1, y2, x1, x2, intersecPoint\n    integer ::  i, c\n    \n    c = 0 \n    \n    do i=1,poly%n-1 \n      x1(:) = poly%vertex(i,:)   \n      x2(:) = poly%vertex(i+1,:) \n      \n      if ( inside(x1, y1, y2) ) then \n        if ( inside(x2, y1, y2) ) then \n          \n          c = c+1\n          outputPoly%vertex(c,:) = x2(:)\n\n        else \n          intersecPoint = intersection(x1, x2, y1,y2)\n          c = c+1\n          outputPoly%vertex(c,:) = intersecPoint(:)\n        end if\n      else \n        if ( inside(x2, y1, y2) ) then\n          intersecPoint = intersection(x1, x2, y1,y2)\n          c = c+1\n          outputPoly%vertex(c,:) = intersecPoint(:)\n          \n          c = c+1\n          outputPoly%vertex(c,:) = x2(:)\n        end if\n      end if\n    end do\n    \n    if (c .gt. 0) then\n      \n      if ( (outputPoly%vertex(1,1) .ne. outputPoly%vertex(c,1)) .or. & \n           (outputPoly%vertex(1,2) .ne. outputPoly%vertex(c,2)))  then\n        c=c+1\n        outputPoly%vertex(c,:) = outputPoly%vertex(1,:)\n      end if\n    end if\n    \n    outputPoly%n = c\n  end subroutine edgeClipping\n  \n  \n  function intersection( x1, x2, y1, y2)\n    \n    \n\n    \n    double precision, dimension(2) :: x1, x2, &  \n                                      y1, y2     \n    \n    double precision, dimension(2) :: intersection, vx, vy, x1y1 \n    double precision :: a\n  \n    vx(:) = x2(:) - x1(:) \n    vy(:) = y2(:) - y1(:)\n\n    \n    if ( crossProduct(vx,vy) .eq. 0.d0) then\n      x1y1(:) = y1(:) - x1(:)\n      \n      if ( crossProduct(x1y1,vx) .eq. 0.d0) then\n        \n        intersection(:) = x2(:)\n      end if\n    else \n      \n      \n      \n      \n      \n      \n      \n      \n     \n      x1y1(:) = y1(:) - x1(:) \n      \n      a = crossProduct(x1y1,vy)/crossProduct(vx,vy)\n      \n      if ( (a .gt. 1.d0) .or. (a .lt. 0)) then\n        \n      else\n        intersection(:) = x1(:) + a*vx(:)\n      end if\n    end if\n\n  end function intersection\n  \n  \n  \n  function inside( p, y1, y2)\n    \n    \n    double precision, dimension(2) :: p, y1, y2, v1, v2\n    logical :: inside\n    v1(:) = y2(:) -  y1(:)\n    v2(:) = p(:)  -  y1(:)  \n    if ( crossProduct(v1,v2) .ge. 0.d0) then\n      inside = .true.\n    else \n      inside = .false.\n    end if\n   \n   contains \n  end function inside\n\n  \n  function dotProduct( v1, v2)\n    \n    double precision, dimension(2) :: v1\n    double precision, dimension(2) :: v2\n    double precision :: dotProduct\n    dotProduct = v1(1)*v2(1) + v1(2)*v2(2)\n  end function dotProduct\n\n  \n  function crossProduct( v1, v2)\n    \n    double precision, dimension(2) :: v1\n    double precision, dimension(2) :: v2\n    double precision :: crossProduct\n    crossProduct = v1(1)*v2(2) - v1(2)*v2(1)\n  end function crossProduct\n\nend module SutherlandHodgmanUtil\n\nprogram main\n  \n  \n  use SutherlandHodgmanUtil, only : polygon, &\n                                    sutherlandHodgman, &\n                                    edgeClipping\n\n  type(polygon) :: p1, p2, res\n  integer :: c, n \n  double precision, dimension(2) :: y1, y2\n  \n  \n\n  \n  p1%n = 10\n  allocate(p1%vertex(p1%n,2))\n  p1%vertex(1,1)=50.d0\n  p1%vertex(1,2)=150.d0\n  \n  p1%vertex(2,1)=200.d0\n  p1%vertex(2,2)=50.d0\n  \n  p1%vertex(3,1)= 350.d0\n  p1%vertex(3,2)= 150.d0\n  \n  p1%vertex(4,1)= 350.d0\n  p1%vertex(4,2)= 300.d0\n  \n  p1%vertex(5,1)= 250.d0\n  p1%vertex(5,2)= 300.d0\n  \n  p1%vertex(6,1)= 200.d0\n  p1%vertex(6,2)= 250.d0\n  \n  p1%vertex(7,1)= 150.d0\n  p1%vertex(7,2)= 350.d0\n  \n  p1%vertex(8,1)= 100.d0\n  p1%vertex(8,2)= 250.d0\n  \n  p1%vertex(9,1)= 100.d0\n  p1%vertex(9,2)= 200.d0\n  \n  p1%vertex(10,1)=  50.d0\n  p1%vertex(10,2)= 150.d0\n \n  y1 = (/ 100.d0, 300.d0 /)\n  y2 = (/ 300.d0, 300.d0 /)\n  \n  \n  p2%n = 5\n  allocate(p2%vertex(p2%n,2))\n\n  p2%vertex(1,1)= 100.d0\n  p2%vertex(1,2)= 100.d0\n  \n  p2%vertex(2,1)= 300.d0\n  p2%vertex(2,2)= 100.d0\n  \n  p2%vertex(3,1)= 300.d0\n  p2%vertex(3,2)= 300.d0\n  \n  p2%vertex(4,1)= 100.d0\n  p2%vertex(4,2)= 300.d0\n  \n  p2%vertex(5,1)= 100.d0\n  p2%vertex(5,2)= 100.d0\n \n  allocate(res%vertex(p1%n+p2%n,2))\n  call sutherlandHodgman( p2, p1, res)\n  write(*,*) \"Suterland-Hodgman\"\n  do c=1, res%n\n    write(*,*) res%vertex(c,1), res%vertex(c,2)\n  end do\n  deallocate(res%vertex)\n\nend program main\n", "target": "import java.awt.*;\nimport java.awt.geom.Line2D;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\n\npublic class SutherlandHodgman extends JFrame {\n\n    SutherlandHodgmanPanel panel;\n\n    public static void main(String[] args) {\n        JFrame f = new SutherlandHodgman();\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setVisible(true);\n    }\n\n    public SutherlandHodgman() {\n        Container content = getContentPane();\n        content.setLayout(new BorderLayout());\n        panel = new SutherlandHodgmanPanel();\n        content.add(panel, BorderLayout.CENTER);\n        setTitle(\"SutherlandHodgman\");\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n\nclass SutherlandHodgmanPanel extends JPanel {\n    List<double[]> subject, clipper, result;\n\n    public SutherlandHodgmanPanel() {\n        setPreferredSize(new Dimension(600, 500));\n\n        \n        double[][] subjPoints = {{50, 150}, {200, 50}, {350, 150}, {350, 300},\n        {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}};\n\n        double[][] clipPoints = {{100, 100}, {300, 100}, {300, 300}, {100, 300}};\n\n        subject = new ArrayList<>(Arrays.asList(subjPoints));\n        result  = new ArrayList<>(subject);\n        clipper = new ArrayList<>(Arrays.asList(clipPoints));\n\n        clipPolygon();\n    }\n\n    private void clipPolygon() {\n        int len = clipper.size();\n        for (int i = 0; i < len; i++) {\n\n            int len2 = result.size();\n            List<double[]> input = result;\n            result = new ArrayList<>(len2);\n\n            double[] A = clipper.get((i + len - 1) % len);\n            double[] B = clipper.get(i);\n\n            for (int j = 0; j < len2; j++) {\n\n                double[] P = input.get((j + len2 - 1) % len2);\n                double[] Q = input.get(j);\n\n                if (isInside(A, B, Q)) {\n                    if (!isInside(A, B, P))\n                        result.add(intersection(A, B, P, Q));\n                    result.add(Q);\n                } else if (isInside(A, B, P))\n                    result.add(intersection(A, B, P, Q));\n            }\n        }\n    }\n\n    private boolean isInside(double[] a, double[] b, double[] c) {\n        return (a[0] - c[0]) * (b[1] - c[1]) > (a[1] - c[1]) * (b[0] - c[0]);\n    }\n\n    private double[] intersection(double[] a, double[] b, double[] p, double[] q) {\n        double A1 = b[1] - a[1];\n        double B1 = a[0] - b[0];\n        double C1 = A1 * a[0] + B1 * a[1];\n\n        double A2 = q[1] - p[1];\n        double B2 = p[0] - q[0];\n        double C2 = A2 * p[0] + B2 * p[1];\n\n        double det = A1 * B2 - A2 * B1;\n        double x = (B2 * C1 - B1 * C2) / det;\n        double y = (A1 * C2 - A2 * C1) / det;\n\n        return new double[]{x, y};\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        g2.translate(80, 60);\n        g2.setStroke(new BasicStroke(3));\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPolygon(g2, subject, Color.blue);\n        drawPolygon(g2, clipper, Color.red);\n        drawPolygon(g2, result, Color.green);\n    }\n\n    private void drawPolygon(Graphics2D g2, List<double[]> points, Color color) {\n        g2.setColor(color);\n        int len = points.size();\n        Line2D line = new Line2D.Double();\n        for (int i = 0; i < len; i++) {\n            double[] p1 = points.get(i);\n            double[] p2 = points.get((i + 1) % len);\n            line.setLine(p1[0], p1[1], p2[0], p2[1]);\n            g2.draw(line);\n        }\n    }\n}\n"}
{"id": 336262, "name": "Sorting algorithms_Pancake sort", "source": "Translate Fortran to Java: program Pancake_Demo\n  implicit none\n \n  integer :: list(8) = (/ 1, 4, 7, 2, 5, 8, 3, 6 /)\n \n  call Pancake_sort(list)\n \ncontains\n \nsubroutine Pancake_sort(a)\n  \n  integer, intent(in out) :: a(:)\n  integer :: i, maxpos\n  \n  write(*,*) a\n  do i = size(a), 2, -1\n     \n\n    maxpos = maxloc(a(1:i), 1)\n \n\n    if (maxpos == i) cycle\n \n\n    if (maxpos /= 1) then\n      a(1:maxpos) = a(maxpos:1:-1)\n      write(*,*) a\n    end if\n \n\n    a(1:i) = a(i:1:-1)\n    write(*,*) a\n  end do\n  \nend subroutine\n \nend program Pancake_Demo\n", "target": "public class PancakeSort\n{\n   int[] heap;\n\n   public String toString() {\n      String info = \"\";\n      for (int x: heap)\n         info += x + \" \";\n      return info;\n   }\n    \n   public void flip(int n) {\n      for (int i = 0; i < (n+1) / 2; ++i) {\n         int tmp = heap[i];\n         heap[i] = heap[n-i];\n         heap[n-i] = tmp;\n      }      \n      System.out.println(\"flip(0..\" + n + \"): \" + toString());\n   }\n   \n   public int[] minmax(int n) {\n      int xm, xM;\n      xm = xM = heap[0];\n      int posm = 0, posM = 0;\n      \n      for (int i = 1; i < n; ++i) {\n         if (heap[i] < xm) {\n            xm = heap[i];\n            posm = i;\n         }\n         else if (heap[i] > xM) {\n            xM = heap[i];\n            posM = i;\n         }\n      }\n      return new int[] {posm, posM};\n   }\n   \n   public void sort(int n, int dir) {\n      if (n == 0) return;\n         \n      int[] mM = minmax(n);\n      int bestXPos = mM[dir];\n      int altXPos = mM[1-dir];\n      boolean flipped = false;\n      \n      if (bestXPos == n-1) {\n         --n;\n      }\n      else if (bestXPos == 0) {\n         flip(n-1);\n         --n;\n      }\n      else if (altXPos == n-1) {\n         dir = 1-dir;\n         --n;\n         flipped = true;\n      }\n      else {\n         flip(bestXPos);\n      }\n      sort(n, dir);\n\n      if (flipped) {\n         flip(n);\n      }\n   }\n   \n   PancakeSort(int[] numbers) {\n      heap = numbers;\n      sort(numbers.length, 1);\n   } \n \n   public static void main(String[] args) {\n      int[] numbers = new int[args.length];\n      for (int i = 0; i < args.length; ++i)\n         numbers[i] = Integer.valueOf(args[i]);\n\n      PancakeSort pancakes = new PancakeSort(numbers);\n      System.out.println(pancakes);\n   }\n}\n"}
{"id": 336263, "name": "Call a function", "source": "Translate Fortran to Java: program main\nimplicit none\ninteger :: a\ninteger :: f, g\nlogical :: lresult\ninterface\n  integer function h(a,b,c)\n    integer :: a, b\n    integer, optional :: c\n  end function\nend interface\nwrite(*,*) 'no arguments: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'fixed arguments: ', g(5,8,lresult)\nwrite(*,*) '-----------------'\nwrite(*,*) 'optional arguments: ', h(5,8), h(5,8,4)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function with variable arguments: Does not apply\nwrite(*,*) 'An option is to pass arrays of variable lengths.'\nwrite(*,*) '-----------------'\nwrite(*,*) 'named arguments: ', h(c=4,b=8,a=5)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function in statement context: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Fortran passes memory location of variables as arguments.'\nwrite(*,*) 'So an argument can hold the return value.'\nwrite(*,*) 'function result: ', g(5,8,lresult) , ' function successful? ', lresult\nwrite(*,*) '-----------------'\nwrite(*,*) 'Distinguish between built-in and user-defined functions: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Calling a subroutine: '\na = 30\ncall sub(a)\nwrite(*,*) 'Function call: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'All variables are passed as pointers.'\nwrite(*,*) 'Problems can arise if instead of sub(a), one uses sub(10).'\nwrite(*,*) '-----------------'\nend program\n\n\ninteger function f()\nf = 10\nend function\n\n\ninteger function g(a, b, lresult)\ninteger :: a, b\nlogical :: lresult\ng = a+b\nlresult = .TRUE.\nend function\n\n\ninteger function h(a, b, c)\ninteger :: a, b\ninteger, optional :: c\n\nh = a+b\nif(present(c)) then\n  h = h+10*c\nend if\nend function\n\n\nsubroutine sub(a)\ninteger :: a\na = a*100\nwrite(*,*) 'Output of subroutine: ', a\nend subroutine\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 336264, "name": "Call a function", "source": "Translate Fortran to Java: program main\nimplicit none\ninteger :: a\ninteger :: f, g\nlogical :: lresult\ninterface\n  integer function h(a,b,c)\n    integer :: a, b\n    integer, optional :: c\n  end function\nend interface\nwrite(*,*) 'no arguments: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'fixed arguments: ', g(5,8,lresult)\nwrite(*,*) '-----------------'\nwrite(*,*) 'optional arguments: ', h(5,8), h(5,8,4)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function with variable arguments: Does not apply\nwrite(*,*) 'An option is to pass arrays of variable lengths.'\nwrite(*,*) '-----------------'\nwrite(*,*) 'named arguments: ', h(c=4,b=8,a=5)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function in statement context: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Fortran passes memory location of variables as arguments.'\nwrite(*,*) 'So an argument can hold the return value.'\nwrite(*,*) 'function result: ', g(5,8,lresult) , ' function successful? ', lresult\nwrite(*,*) '-----------------'\nwrite(*,*) 'Distinguish between built-in and user-defined functions: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Calling a subroutine: '\na = 30\ncall sub(a)\nwrite(*,*) 'Function call: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'All variables are passed as pointers.'\nwrite(*,*) 'Problems can arise if instead of sub(a), one uses sub(10).'\nwrite(*,*) '-----------------'\nend program\n\n\ninteger function f()\nf = 10\nend function\n\n\ninteger function g(a, b, lresult)\ninteger :: a, b\nlogical :: lresult\ng = a+b\nlresult = .TRUE.\nend function\n\n\ninteger function h(a, b, c)\ninteger :: a, b\ninteger, optional :: c\n\nh = a+b\nif(present(c)) then\n  h = h+10*c\nend if\nend function\n\n\nsubroutine sub(a)\ninteger :: a\na = a*100\nwrite(*,*) 'Output of subroutine: ', a\nend subroutine\n", "target": "foo();             \nInt x = bar();     \n"}
{"id": 336265, "name": "Extract file extension", "source": "Translate Fortran to Java:       MODULE TEXTGNASH\t\n       CHARACTER*10 DIGITS\t\t\n       CHARACTER*11 DDIGITS\t\t\n       CHARACTER*13 SDDIGITS\t\t\n       CHARACTER*4  EXPONENTISH\t\t\n       CHARACTER*17 NUMBERISH\t\t\n       CHARACTER*16 HEXLETTERS\t\t\n       CHARACTER*62 DIGILETTERS\t\t\n       CHARACTER*26 LITTLELETTERS,BIGLETTERS\t\n       CHARACTER*52 LETTERS\t\t\n       CHARACTER*66 NAMEISH\t\t\n       CHARACTER*3  ODDITIES\t\t\n       CHARACTER*1 CHARACTER(72)\t\n       EQUIVALENCE\t\t\t\n     1  (CHARACTER( 1),EXPONENTISH,NUMBERISH),\t\n     2  (CHARACTER( 5),SDDIGITS),\t\t\n     3  (CHARACTER( 7),DDIGITS,NAMEISH),\t\n     4  (CHARACTER( 8),DIGITS,HEXLETTERS,DIGILETTERS),\t\n     5  (CHARACTER(18),BIGLETTERS,LETTERS),\t\n     6  (CHARACTER(44),LITTLELETTERS),\t\t\n     7  (CHARACTER(70),ODDITIES)\t\t\n       DATA EXPONENTISH /\"eEdD\"/\t\n       DATA SDDIGITS /\"+-.0123456789\"/\t\n       DATA BIGLETTERS    /\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"/\t\n       DATA LITTLELETTERS /\"abcdefghijklmnopqrstuvwxyz\"/\t\n       DATA ODDITIES /\"_:#\"/\t\t\n\n       CHARACTER*62 GOODEXT\t\n       EQUIVALENCE (CHARACTER(8),GOODEXT)\nc       PARAMETER (GOODEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t\nc     1                    //\"abcdefghijklmnopqrstuvwxyz\"\t\nc     2                    //\"0123456789\")\t\t\t\n       INTEGER MEXT\t\t\n       PARAMETER (MEXT = 28)\t\n       CONTAINS\n        CHARACTER*(MEXT) FUNCTION FEXT(FNAME)\t\n         CHARACTER*(*) FNAME\t\n         INTEGER L1,L2\t\t\n          L2 = LEN(FNAME)\t\n          L1 = L2\t\t\n   10     IF (L1.GT.0) THEN\t\n            IF (INDEX(GOODEXT,FNAME(L1:L1)).GT.0) THEN\t\n              L1 = L1 - 1\t\t\n              GO TO 10\t\t\t\n            END IF\t\t\n            IF (FNAME(L1:L1).EQ.\".\") THEN\t\n              L1 = L1 - 1\t\t\t\n              GO TO 20\t\t\t\t\n            END IF\t\t\n          END IF\t\t\n          L1 = L2\t\t\n   20     FEXT = FNAME(L1 + 1:L2)\t\n        END FUNCTION FEXT\t\n      END MODULE TEXTGNASH\t\n\n      PROGRAM POKE\n      USE TEXTGNASH\n\n      WRITE (6,*) FEXT(\"Picture.jpg\")\n      WRITE (6,*) FEXT(\"http://mywebsite.com/picture/image.png\")\n      WRITE (6,*) FEXT(\"myuniquefile.longextension\")\n      WRITE (6,*) FEXT(\"IAmAFileWithoutExtension\")\n      WRITE (6,*) FEXT(\"/path/to.my/file\")\n      WRITE (6,*) FEXT(\"file.odd_one\")\n      WRITE (6,*)\n      WRITE (6,*) \"Now for the new test collection...\"\n      WRITE (6,*) FEXT(\"http://example.com/download.tar.gz\")\n      WRITE (6,*) FEXT(\"CharacterModel.3DS\")\n      WRITE (6,*) FEXT(\".desktop\")\n      WRITE (6,*) FEXT(\"document\")\n      WRITE (6,*) FEXT(\"document.txt_backup\")\n      WRITE (6,*) FEXT(\"/etc/pam.d/login\")\n      WRITE (6,*) \"Approved characters: \",GOODEXT\n      END\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 336266, "name": "Extract file extension", "source": "Translate Fortran to Java:       MODULE TEXTGNASH\t\n       CHARACTER*10 DIGITS\t\t\n       CHARACTER*11 DDIGITS\t\t\n       CHARACTER*13 SDDIGITS\t\t\n       CHARACTER*4  EXPONENTISH\t\t\n       CHARACTER*17 NUMBERISH\t\t\n       CHARACTER*16 HEXLETTERS\t\t\n       CHARACTER*62 DIGILETTERS\t\t\n       CHARACTER*26 LITTLELETTERS,BIGLETTERS\t\n       CHARACTER*52 LETTERS\t\t\n       CHARACTER*66 NAMEISH\t\t\n       CHARACTER*3  ODDITIES\t\t\n       CHARACTER*1 CHARACTER(72)\t\n       EQUIVALENCE\t\t\t\n     1  (CHARACTER( 1),EXPONENTISH,NUMBERISH),\t\n     2  (CHARACTER( 5),SDDIGITS),\t\t\n     3  (CHARACTER( 7),DDIGITS,NAMEISH),\t\n     4  (CHARACTER( 8),DIGITS,HEXLETTERS,DIGILETTERS),\t\n     5  (CHARACTER(18),BIGLETTERS,LETTERS),\t\n     6  (CHARACTER(44),LITTLELETTERS),\t\t\n     7  (CHARACTER(70),ODDITIES)\t\t\n       DATA EXPONENTISH /\"eEdD\"/\t\n       DATA SDDIGITS /\"+-.0123456789\"/\t\n       DATA BIGLETTERS    /\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"/\t\n       DATA LITTLELETTERS /\"abcdefghijklmnopqrstuvwxyz\"/\t\n       DATA ODDITIES /\"_:#\"/\t\t\n\n       CHARACTER*62 GOODEXT\t\n       EQUIVALENCE (CHARACTER(8),GOODEXT)\nc       PARAMETER (GOODEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t\nc     1                    //\"abcdefghijklmnopqrstuvwxyz\"\t\nc     2                    //\"0123456789\")\t\t\t\n       INTEGER MEXT\t\t\n       PARAMETER (MEXT = 28)\t\n       CONTAINS\n        CHARACTER*(MEXT) FUNCTION FEXT(FNAME)\t\n         CHARACTER*(*) FNAME\t\n         INTEGER L1,L2\t\t\n          L2 = LEN(FNAME)\t\n          L1 = L2\t\t\n   10     IF (L1.GT.0) THEN\t\n            IF (INDEX(GOODEXT,FNAME(L1:L1)).GT.0) THEN\t\n              L1 = L1 - 1\t\t\n              GO TO 10\t\t\t\n            END IF\t\t\n            IF (FNAME(L1:L1).EQ.\".\") THEN\t\n              L1 = L1 - 1\t\t\t\n              GO TO 20\t\t\t\t\n            END IF\t\t\n          END IF\t\t\n          L1 = L2\t\t\n   20     FEXT = FNAME(L1 + 1:L2)\t\n        END FUNCTION FEXT\t\n      END MODULE TEXTGNASH\t\n\n      PROGRAM POKE\n      USE TEXTGNASH\n\n      WRITE (6,*) FEXT(\"Picture.jpg\")\n      WRITE (6,*) FEXT(\"http://mywebsite.com/picture/image.png\")\n      WRITE (6,*) FEXT(\"myuniquefile.longextension\")\n      WRITE (6,*) FEXT(\"IAmAFileWithoutExtension\")\n      WRITE (6,*) FEXT(\"/path/to.my/file\")\n      WRITE (6,*) FEXT(\"file.odd_one\")\n      WRITE (6,*)\n      WRITE (6,*) \"Now for the new test collection...\"\n      WRITE (6,*) FEXT(\"http://example.com/download.tar.gz\")\n      WRITE (6,*) FEXT(\"CharacterModel.3DS\")\n      WRITE (6,*) FEXT(\".desktop\")\n      WRITE (6,*) FEXT(\"document\")\n      WRITE (6,*) FEXT(\"document.txt_backup\")\n      WRITE (6,*) FEXT(\"/etc/pam.d/login\")\n      WRITE (6,*) \"Approved characters: \",GOODEXT\n      END\n", "target": "public class Test {\n \n    public static void main(String[] args) {\n        String[] filenames = { \"http:\n                               \"CharacterModel.3DS\",\n                               \".desktop\",\n                               \"document\",\n                               \"document.txt_backup\",\n                               \"/etc/pam.d/login\"\n        };\n\n        for (String filename : filenames) {\n            String ext = \"null\";\n            int idx = filename.lastIndexOf('.');\n            if (idx != -1) {\n                String tmp = filename.substring(idx);\n                if (tmp.matches(\"\\\\.[a-zA-Z0-9]+\")) {\n                    ext = tmp;\n                }\n            }\n            System.out.println(filename + \" -> \" + ext);\n        }\n    }\n}\n"}
{"id": 336267, "name": "Solve the no connection puzzle", "source": "Translate Fortran to Java: \n\n\n\nprogram no_connection_puzzle\n\n  implicit none\n\n  \n  integer, parameter :: a = 1\n  integer, parameter :: b = 2\n  integer, parameter :: c = 3\n  integer, parameter :: d = 4\n  integer, parameter :: e = 5\n  integer, parameter :: f = 6\n  integer, parameter :: g = 7\n  integer, parameter :: h = 8\n\n  integer :: holes(a:h)\n\n  call find_solutions (holes, a)\n\ncontains\n\n  recursive subroutine find_solutions (holes, current_hole_index)\n    integer, intent(inout) :: holes(a:h)\n    integer, intent(in) :: current_hole_index\n\n    integer :: peg_number\n\n    \n    \n    do peg_number = 1, 8\n       holes(current_hole_index) = peg_number\n       if (satisfies_the_constraints (holes, current_hole_index)) then\n          if (current_hole_index == h) then\n             call print_solution (holes)\n             write (*, '()')\n          else\n             call find_solutions (holes, current_hole_index + 1)\n          end if\n       end if\n    end do\n  end subroutine find_solutions\n\n  function satisfies_the_constraints (holes, i) result (satisfies)\n    integer, intent(inout) :: holes(a:h)\n    integer, intent(in) :: i    \n    logical :: satisfies\n\n    integer :: j\n\n    \n    \n    satisfies = all (holes(a : i - 1) /= holes(i))\n\n    if (satisfies) then\n       \n       \n       do j = i + 1, h\n          holes(j) = 100 * j\n       end do\n\n       \n       satisfies = 1 < abs (holes(a) - holes(c)) .and.     &\n            &      1 < abs (holes(a) - holes(d)) .and.     &\n            &      1 < abs (holes(a) - holes(e)) .and.     &\n            &      1 < abs (holes(c) - holes(g)) .and.     &\n            &      1 < abs (holes(d) - holes(g)) .and.     &\n            &      1 < abs (holes(e) - holes(g)) .and.     &\n            &      1 < abs (holes(b) - holes(d)) .and.     &\n            &      1 < abs (holes(b) - holes(e)) .and.     &\n            &      1 < abs (holes(b) - holes(f)) .and.     &\n            &      1 < abs (holes(d) - holes(h)) .and.     &\n            &      1 < abs (holes(e) - holes(h)) .and.     &\n            &      1 < abs (holes(f) - holes(h)) .and.     &\n            &      1 < abs (holes(c) - holes(d)) .and.     &\n            &      1 < abs (holes(d) - holes(e)) .and.     &\n            &      1 < abs (holes(e) - holes(f))\n    end if\n  end function satisfies_the_constraints\n\n  subroutine print_solution (holes)\n    integer, intent(in) :: holes(a:h)\n\n    write (*, '(I5, I4)') holes(a), holes(b)\n    write (*, '(\"   /\u2502\\ /\u2502\\\")')\n    write (*, '(\"  / \u2502 X \u2502 \\\")')\n    write (*, '(\" /  \u2502/ \\\u2502  \\\")')\n    write (*, '(3(I1, \"\u2500\u2500\u2500\"), I1)') holes(c), holes(d), holes(e), holes(f)\n    write (*, '(\" \\  \u2502\\ /\u2502  /\")')\n    write (*, '(\"  \\ \u2502 X \u2502 /\")')\n    write (*, '(\"   \\\u2502/ \\\u2502/\")')\n    write (*, '(I5, I4)') holes(g), holes(h)\n  end subroutine print_solution\n\nend program no_connection_puzzle\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport static java.util.stream.Collectors.toList;\nimport static java.util.stream.IntStream.range;\n\npublic class NoConnection {\n\n    \n    static int[][] links = {\n        {2, 3, 4}, \n        {3, 4, 5}, \n        {2, 4},    \n        {5},       \n        {2, 3, 4}, \n        {3, 4, 5}, \n    };\n\n    static int[] pegs = new int[8];\n\n    public static void main(String[] args) {\n\n        List<Integer> vals = range(1, 9).mapToObj(i -> i).collect(toList());\n        do {\n            Collections.shuffle(vals);\n            for (int i = 0; i < pegs.length; i++)\n                pegs[i] = vals.get(i);\n\n        } while (!solved());\n\n        printResult();\n    }\n\n    static boolean solved() {\n        for (int i = 0; i < links.length; i++)\n            for (int peg : links[i])\n                if (abs(pegs[i] - peg) == 1)\n                    return false;\n        return true;\n    }\n\n    static void printResult() {\n        System.out.printf(\"  %s %s%n\", pegs[0], pegs[1]);\n        System.out.printf(\"%s %s %s %s%n\", pegs[2], pegs[3], pegs[4], pegs[5]);\n        System.out.printf(\"  %s %s%n\", pegs[6], pegs[7]);\n    }\n}\n"}
{"id": 336268, "name": "String comparison", "source": "Translate Fortran to Java:       PRINT 42,N\n   42 FORMAT (14HThe answer is ,I9)\n", "target": "public class Compare\n{\n\t\n    \n    public static void compare (String A, String B)\n    {\n        if (A.equals(B))\n            System.debug(A + ' and  ' + B + ' are lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not lexically equal.');\n\n        if (A.equalsIgnoreCase(B))\n            System.debug(A + ' and  ' + B + ' are case-insensitive lexically equal.');\n        else\n            System.debug(A + ' and  ' + B + ' are not case-insensitive lexically equal.');\n \n        if (A.compareTo(B) < 0)\n            System.debug(A + ' is lexically before ' + B);\n        else if (A.compareTo(B) > 0)\n            System.debug(A + ' is lexically after ' + B);\n \n        if (A.compareTo(B) >= 0)\n            System.debug(A + ' is not lexically before ' + B);\n        if (A.compareTo(B) <= 0)\n            System.debug(A + ' is not lexically after ' + B);\n \n        System.debug('The lexical relationship is: ' + A.compareTo(B));\n    }\n}\n"}
{"id": 336269, "name": "Verify distribution uniformity_Naive", "source": "Translate Fortran to Java: subroutine distcheck(randgen, n, delta)\n\n  interface\n    function randgen\n      integer :: randgen \n    end function randgen\n  end interface\n  \n  real, intent(in) :: delta\n  integer, intent(in) :: n\n  integer :: i, mval, lolim, hilim\n  integer, allocatable :: buckets(:)\n  integer, allocatable :: rnums(:)\n  logical :: skewed = .false.\n     \n  allocate(rnums(n))\n  \n  do i = 1, n\n    rnums(i) = randgen()\n  end do\n\n  mval = maxval(rnums)\n  allocate(buckets(mval))\n  buckets = 0\n  \n  do i = 1, n\n    buckets(rnums(i)) = buckets(rnums(i)) + 1\n  end do\n\n  lolim = n/mval - n/mval*delta\n  hilim = n/mval + n/mval*delta\n  \n  do i = 1, mval  \n    if(buckets(i) < lolim .or. buckets(i) > hilim) then\n      write(*,\"(a,i0,a,i0,a,i0)\") \"Distribution potentially skewed for bucket \", i, \"   Expected: \", &\n                                   n/mval, \"   Actual: \", buckets(i)\n      skewed = .true.\n    end if\n  end do \n\n  if (.not. skewed) write(*,\"(a)\") \"Distribution uniform\"\n  \n  deallocate(rnums)\n  deallocate(buckets)\n    \nend subroutine\n", "target": "import static java.lang.Math.abs;\nimport java.util.*;\nimport java.util.function.IntSupplier;\n\npublic class Test {\n\n    static void distCheck(IntSupplier f, int nRepeats, double delta) {\n        Map<Integer, Integer> counts = new HashMap<>();\n\n        for (int i = 0; i < nRepeats; i++)\n            counts.compute(f.getAsInt(), (k, v) -> v == null ? 1 : v + 1);\n\n        double target = nRepeats / (double) counts.size();\n        int deltaCount = (int) (delta / 100.0 * target);\n\n        counts.forEach((k, v) -> {\n            if (abs(target - v) >= deltaCount)\n                System.out.printf(\"distribution potentially skewed \"\n                        + \"for '%s': '%d'%n\", k, v);\n        });\n\n        counts.keySet().stream().sorted().forEach(k\n                -> System.out.printf(\"%d %d%n\", k, counts.get(k)));\n    }\n\n    public static void main(String[] a) {\n        distCheck(() -> (int) (Math.random() * 5) + 1, 1_000_000, 1);\n    }\n}\n"}
{"id": 336270, "name": "Use another language to call a function", "source": "Translate Fortran to Java: \n\n\nfunction  fortran_query(data, length) result(answer) bind(c, name='Query')\n   use, intrinsic  :: iso_c_binding, only: c_char, c_int, c_size_t, c_null_char\n   implicit none\n   character(len=1,kind=c_char), dimension(length),  intent(inout) ::  data\n   integer(c_size_t), intent(inout) :: length\n   integer(c_int) :: answer\n   answer = 0\n   if(length<10) return\n   data = transfer(\"Here I am\"//c_null_char, data)\n   length = 10_c_size_t\n   answer = 1\nend function fortran_query\n", "target": "\npublic class Query {\n    public static boolean call(byte[] data, int[] length)\n\tthrows java.io.UnsupportedEncodingException\n    {\n\tString message = \"Here am I\";\n\tbyte[] mb = message.getBytes(\"utf-8\");\n\tif (length[0] < mb.length)\n\t    return false;\n\tlength[0] = mb.length;\n\tSystem.arraycopy(mb, 0, data, 0, mb.length);\n\treturn true;\n    }\n}\n"}
{"id": 336271, "name": "Find first and last set bit of a long integer", "source": "Translate Fortran to Java: program bits\n    implicit none\n    integer :: n = 1, i\n\n    do i = 1, 6\n        print \"(B32,2(' ',I2))\", n, trailz(n), 31 - leadz(n)\n        n = 42 * n\n    end do\nend program\n", "target": "public class FirstAndLastBits {\n\n    public static long LSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn Long.numberOfTrailingZeros(aNumber);\n\t}\n\t\n\tpublic static long MSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn 63 - Long.numberOfLeadingZeros(aNumber);\n\t}\n\t\n\tpublic static long LSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.getLowestSetBit();\n\t}\n\t\n\tpublic static long MSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.bitLength() - 1;\n\t}\n\t\n\tpublic static void main(String[] aArgs) {\n\t\tLong powerOf42 = 1L;\t\t\n\t\tfor ( int i = 0; i <= 11; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-5s%-3s%s\", \"42 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", Long.toBinaryString(powerOf42)).replace(\" \", \"0\"));\n\t\t\tSystem.out.println(String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf42), \", MSB: \", MSB(powerOf42)));\n\t\t\tpowerOf42 *= 42;\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tBigInteger bigInteger1302 = BigInteger.valueOf(1302);\n\t\tBigInteger powerOf1302 = BigInteger.ONE;\t\t\n\t\tfor ( int i = 0; i <= 6; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-7s%s%s\", \"1302 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", powerOf1302.toString(2)).replace(\" \", \"0\"));\n\t\t\tString line = String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf1302), \", MSB: \", MSB(powerOf1302));\n\t\t\tSystem.out.println(line);\n\t\t\tpowerOf1302 = powerOf1302.multiply(bigInteger1302);\n\t\t}\n\t}\n\n}\n"}
{"id": 336272, "name": "Find first and last set bit of a long integer", "source": "Translate Fortran to Java: program bits\n    implicit none\n    integer :: n = 1, i\n\n    do i = 1, 6\n        print \"(B32,2(' ',I2))\", n, trailz(n), 31 - leadz(n)\n        n = 42 * n\n    end do\nend program\n", "target": "public class FirstAndLastBits {\n\n    public static long LSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn Long.numberOfTrailingZeros(aNumber);\n\t}\n\t\n\tpublic static long MSB(Long aNumber) {\n\t\tif ( aNumber <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn 63 - Long.numberOfLeadingZeros(aNumber);\n\t}\n\t\n\tpublic static long LSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.getLowestSetBit();\n\t}\n\t\n\tpublic static long MSB(BigInteger aNumber) {\n\t\tif ( aNumber.signum() <= 0 ) {\n\t\t\tthrow new IllegalArgumentException(\"Number must be positive\");\n\t\t}\t\t\n\t\treturn aNumber.bitLength() - 1;\n\t}\n\t\n\tpublic static void main(String[] aArgs) {\n\t\tLong powerOf42 = 1L;\t\t\n\t\tfor ( int i = 0; i <= 11; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-5s%-3s%s\", \"42 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", Long.toBinaryString(powerOf42)).replace(\" \", \"0\"));\n\t\t\tSystem.out.println(String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf42), \", MSB: \", MSB(powerOf42)));\n\t\t\tpowerOf42 *= 42;\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tBigInteger bigInteger1302 = BigInteger.valueOf(1302);\n\t\tBigInteger powerOf1302 = BigInteger.ONE;\t\t\n\t\tfor ( int i = 0; i <= 6; i++ ) {\n\t\t\tSystem.out.print(String.format(\"%-7s%s%s\", \"1302 ^ \", i, \" = \")); \n\t\t\tSystem.out.print(String.format(\"%1$\" + 64 + \"s\", powerOf1302.toString(2)).replace(\" \", \"0\"));\n\t\t\tString line = String.format(\"%s%-2s%s%-2s\", \" -> LSB: \", LSB(powerOf1302), \", MSB: \", MSB(powerOf1302));\n\t\t\tSystem.out.println(line);\n\t\t\tpowerOf1302 = powerOf1302.multiply(bigInteger1302);\n\t\t}\n\t}\n\n}\n"}
{"id": 336273, "name": "Ray-casting algorithm", "source": "Translate Fortran to Java: module Polygons\n  use Points_Module\n  implicit none\n\n  type polygon\n     type(point), dimension(:), allocatable :: points\n     integer, dimension(:), allocatable :: vertices\n  end type polygon\n\ncontains\n\n  function create_polygon(pts, vt)\n    type(polygon) :: create_polygon\n    type(point), dimension(:), intent(in) :: pts\n    integer, dimension(:), intent(in) :: vt\n\n    integer :: np, nv\n\n    np = size(pts,1)\n    nv = size(vt,1)\n\n    allocate(create_polygon%points(np), create_polygon%vertices(nv))\n    create_polygon%points = pts\n    create_polygon%vertices = vt\n\n  end function create_polygon\n\n  subroutine free_polygon(pol)\n    type(polygon), intent(inout) :: pol\n\n    deallocate(pol%points, pol%vertices)\n\n  end subroutine free_polygon\n\nend module Polygons\n", "target": "import static java.lang.Math.*;\n\npublic class RayCasting {\n\n    static boolean intersects(int[] A, int[] B, double[] P) {\n        if (A[1] > B[1])\n            return intersects(B, A, P);\n\n        if (P[1] == A[1] || P[1] == B[1])\n            P[1] += 0.0001;\n\n        if (P[1] > B[1] || P[1] < A[1] || P[0] >= max(A[0], B[0]))\n            return false;\n\n        if (P[0] < min(A[0], B[0]))\n            return true;\n\n        double red = (P[1] - A[1]) / (double) (P[0] - A[0]);\n        double blue = (B[1] - A[1]) / (double) (B[0] - A[0]);\n        return red >= blue;\n    }\n\n    static boolean contains(int[][] shape, double[] pnt) {\n        boolean inside = false;\n        int len = shape.length;\n        for (int i = 0; i < len; i++) {\n            if (intersects(shape[i], shape[(i + 1) % len], pnt))\n                inside = !inside;\n        }\n        return inside;\n    }\n\n    public static void main(String[] a) {\n        double[][] testPoints = {{10, 10}, {10, 16}, {-20, 10}, {0, 10},\n        {20, 10}, {16, 10}, {20, 20}};\n\n        for (int[][] shape : shapes) {\n            for (double[] pnt : testPoints)\n                System.out.printf(\"%7s \", contains(shape, pnt));\n            System.out.println();\n        }\n    }\n\n    final static int[][] square = {{0, 0}, {20, 0}, {20, 20}, {0, 20}};\n\n    final static int[][] squareHole = {{0, 0}, {20, 0}, {20, 20}, {0, 20},\n    {5, 5}, {15, 5}, {15, 15}, {5, 15}};\n\n    final static int[][] strange = {{0, 0}, {5, 5}, {0, 20}, {5, 15}, {15, 15},\n    {20, 20}, {20, 0}};\n\n    final static int[][] hexagon = {{6, 0}, {14, 0}, {20, 10}, {14, 20},\n    {6, 20}, {0, 10}};\n\n    final static int[][][] shapes = {square, squareHole, strange, hexagon};\n}\n"}
{"id": 347521, "name": "Pascal matrix generation", "source": "Translate Fortran to Python: module pascal\n\nimplicit none\n\ncontains\n    function pascal_lower(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(i, 1) = 1\n        end do\n        do i = 2, n\n            do j = 2, i\n                a(i, j) = a(i - 1, j) + a(i - 1, j - 1)\n            end do\n        end do\n    end function\n    \n    function pascal_upper(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(1, i) = 1\n        end do\n        do i = 2, n\n            do j = 2, i\n                a(j, i) = a(j, i - 1) + a(j - 1, i - 1)\n            end do\n        end do\n    end function\n\n    function pascal_symmetric(n) result(a)\n        integer :: n, i, j\n        integer, allocatable :: a(:, :)\n        allocate(a(n, n))\n        a = 0\n        do i = 1, n\n            a(i, 1) = 1\n            a(1, i) = 1\n        end do\n        do i = 2, n\n            do j = 2, n\n                a(i, j) = a(i - 1, j) + a(i, j - 1)\n            end do\n        end do\n    end function\n\n    subroutine print_matrix(a)\n        integer :: a(:, :)\n        integer :: n, i\n        n = ubound(a, 1)\n        do i = 1, n\n            print *, a(i, :)\n        end do\n    end subroutine\nend module\n\nprogram ex_pascal\n    use pascal\n    implicit none\n    integer :: n\n    integer, allocatable :: a(:, :)\n    print *, \"Size?\"\n    read *, n\n    print *, \"Lower Pascal Matrix\"\n    a = pascal_lower(n)\n    call print_matrix(a)\n    print *, \"Upper Pascal Matrix\"\n    a = pascal_upper(n)\n    call print_matrix(a)\n    print *, \"Symmetric Pascal Matrix\"\n    a = pascal_symmetric(n)\n    call print_matrix(a)\nend program\n", "target": "from pprint import pprint as pp\n\ndef pascal_upp(n):\n    s = [[0] * n for _ in range(n)]\n    s[0] = [1] * n\n    for i in range(1, n):\n        for j in range(i, n):\n            s[i][j] = s[i-1][j-1] + s[i][j-1]\n    return s\n\ndef pascal_low(n):\n    \n    return [list(x) for x in zip(*pascal_upp(n))]\n\ndef pascal_sym(n):\n    s = [[1] * n for _ in range(n)]\n    for i in range(1, n):\n        for j in range(1, n):\n            s[i][j] = s[i-1][j] + s[i][j-1]\n    return s\n    \n\nif __name__ == \"__main__\":\n    n = 5\n    print(\"\\nUpper:\")\n    pp(pascal_upp(n))\n    print(\"\\nLower:\")\n    pp(pascal_low(n))\n    print(\"\\nSymmetric:\")\n    pp(pascal_sym(n))\n"}
{"id": 347522, "name": "Mad Libs", "source": "Translate Fortran to Python:       MODULE MADLIB\t\n       INTEGER MSG,KBD,INF\t\t\n       DATA MSG,KBD,INF/6,5,10/\t\t\n       INTEGER LSTASH,NSTASH,MSTASH\t\n       PARAMETER (LSTASH = 246810, MSTASH = 6666)\t\n       CHARACTER*(LSTASH) STASH\t\t\n       INTEGER ISTASH(MSTASH + 1)\t\n       DATA NSTASH,ISTASH(1)/0,1/\t\n       INTEGER MANYLINES,MANYTESTS\t\n       PARAMETER (MANYLINES = 1234)\t\n       INTEGER NSTORY,STORY(MANYLINES)\t\n       PARAMETER (MANYTESTS = 1234)\t\n       INTEGER NTESTS,TARGET(MANYTESTS),REPLACEMENT(MANYTESTS)\t\n       DATA NSTORY,NTESTS/0,0/\t\t\n       INTEGER STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 28)\t\n\n       CONTAINS\n        SUBROUTINE CROAK(GASP)\t\n         CHARACTER*(*) GASP\t\n         WRITE (MSG,*) \"Oh dear.\"\t\n         WRITE (MSG,*) GASP\t\t\n         STOP \"How sad.\"\t\t\n        END SUBROUTINE CROAK\t\n\n        SUBROUTINE SHOWSTASH(BLAH,I)\t\n         CHARACTER*(*) BLAH\t\t\n         INTEGER I\t\t\t\n          WRITE (MSG,1) BLAH,I,STASH(ISTASH(I):ISTASH(I + 1) - 1)\t\n    1     FORMAT (A,': Text(',I0,')=\"',A,'\"')\t\n        END SUBROUTINE SHOWSTASH\t\n\n        INTEGER FUNCTION EATTEXT(IN)\t\nCo-opts the as-yet unused space in STASH as its scratchpad.\n         INTEGER IN\t\n         INTEGER I,N,L\t\n          I = ISTASH(NSTASH + 1)\n          N = LSTASH - I + 1\t\n          IF (N.LT.666) CALL CROAK(\"Insufficient STASH space remains\n          READ (IN,1,END = 66) L,STASH(I:I + MIN(L,N) - 1)\t\n    1     FORMAT (Q,A)\t\t\n          L = I + MIN(L,N) - 1\t\n   10     IF (L.LT.I) GO TO 66\t\n          IF (ICHAR(STASH(L:L)).LE.ICHAR(\" \")) THEN\t\n            L = L - 1\t\t\n            GO TO 10\t\t\n          END IF\t\t\n          IF (NSTASH.GE.MSTASH) CALL CROAK(\"Too many texts\n          NSTASH = NSTASH + 1\t\n          ISTASH(NSTASH + 1) = L + 1\t\n          EATTEXT = NSTASH\t\n         RETURN\t\t\t\n   66     EATTEXT = 0\t\t\n        END FUNCTION EATTEXT\t\n\n        INTEGER FUNCTION ADDSTASH(TEXT)\t\n         CHARACTER*(*) TEXT\t\n         INTEGER I\t\t\n          IF (NSTASH.GE.MSTASH) CALL CROAK(\"The text pool is crowded\n          I = ISTASH(NSTASH + 1)\t\n          IF (I + LEN(TEXT).GT.LSTASH) CALL CROAK(\"Overtexted\n          STASH(I:I + LEN(TEXT) - 1) = TEXT\t\n          NSTASH = NSTASH + 1\t\t\t\n          ISTASH(NSTASH + 1) = I + LEN(TEXT)\t\n          ADDSTASH = NSTASH\t\n        END FUNCTION ADDSTASH\t\n\n        INTEGER FUNCTION ANOTHER(TEXT)\t\nCollects TARGET REPLACEMENT pairs (increasing NTESTS) as directed by INSPECT.\n         CHARACTER*(*) TEXT\t\n         INTEGER I,IT\t\t\n          ANOTHER = 0\t\t\n          DO I = 1,NTESTS\t\n            IT = TARGET(I)\t\t\n            IF (TEXT.EQ.STASH(ISTASH(IT):ISTASH(IT + 1) - 1)) RETURN\t\n          END DO\t\t\n          IF (NTESTS.GE.MANYTESTS) CALL CROAK(\"Too many tests\n          NTESTS = NTESTS + 1\t\t\n          TARGET(NTESTS) = ADDSTASH(TEXT)\n          ANOTHER = NTESTS\t\t\n          WRITE (MSG,1) TEXT\t\t\n    1     FORMAT (\"Enter your text for \",A,\": \",$)\t\n          REPLACEMENT(NTESTS) = EATTEXT(KBD)\t\n        END FUNCTION ANOTHER\t\n\n        SUBROUTINE INSPECT(X)\t\nCalls for inspection of REPLACEMENT texts as well, should ANOTHER report a new entry.\n         INTEGER X\t\n         INTEGER MARK\t\n         INTEGER IT,NEW\t\n         INTEGER I\t\n         INTEGER SP,STACK(STACKLIMIT)\t\n          SP = 1\t\t\n          STACK(1) = X\t\t\n          DO WHILE(SP.GT.0)\t\n            IT = STACK(SP)\t\t\n            SP = SP - 1\t\t\t\n            MARK = 0\t\t\t\n            DO I = ISTASH(IT),ISTASH(IT + 1) - 1\n              IF (STASH(I:I).EQ.\"<\") THEN\t\n                MARK = I\t\t\t\n              ELSE IF (STASH(I:I).EQ.\">\") THEN\t\n                IF (MARK.LE.0) CALL CROAK(\"A > with no preceeding <\n                NEW = ANOTHER(STASH(MARK:I))\t\n                IF (NEW.GT.0) THEN\t\t\n                  IF (SP.GE.STACKLIMIT) CALL CROAK(\"Stack overflow\n                  SP = SP + 1\t\t\t\n                  STACK(SP) = REPLACEMENT(NEW)\t\n                END IF\t\t\t\n                MARK = 0\t\t\n              END IF\t\t\n            END DO\t\t\n          END DO\t\n        END SUBROUTINE INSPECT\t\n\n        SUBROUTINE READSTORY(IN)\n         INTEGER IN\t\t\n         INTEGER LINE\t\t\n   10    LINE = EATTEXT(IN)\t\n         IF (LINE.GT.0) THEN\t\n           NSTORY = NSTORY + 1\t\n           STORY(NSTORY) = LINE\t\n           CALL INSPECT(LINE)\t\n           GO TO 10\t\t\n         END IF\t\t\t\n        END SUBROUTINE READSTORY\n\n        SUBROUTINE WRITESTORY(WIDTH)\t\nCo-opts the as-yet unused space in STASH as its output scratchpad.\nCan't rely on changing the index and bounds of a DO-loop on the fly.\n         INTEGER WIDTH\n         INTEGER LINE,IT,I,J\t\n         INTEGER L,L0,N\t\t\n         INTEGER TAIL,MARK,LAST\t\n         INTEGER SP,STACKI(STACKLIMIT),STACKL(STACKLIMIT)\t\n          L0 = ISTASH(NSTASH + 1)\t\n          L = L0 - 1\t\t\t\n       LL:DO LINE = 1,NSTORY\t\t\n            SP = 0\t\t\t\n            IT = STORY(LINE)\t\t\n            LAST = ISTASH(IT + 1) - 1\t\n            I = ISTASH(IT)\t\t\n            TAIL = I - 1\t\t\n            IF (STASH(I:I).LE.\" \") THEN\t\n              CALL BURP\t\t\t\n            ELSE IF (LINE.GT.1) THEN\t\n              L = L + 1\t\t\t\n              STASH(L:L) = \" \"\t\t\n            END IF\t\t\t\n  666    II:DO WHILE(I.LE.LAST)\t\t\n              IF (STASH(I:I).EQ.\"<\") THEN\t\n                MARK = I\t\t\t\n              ELSE IF (STASH(I:I).EQ.\">\") THEN\t\n                CALL APPEND(TAIL + 1,MARK - 1)\t\n             JJ:DO J = 1,NTESTS\t\t\n                  IT = TARGET(J)\t\t\n                  IF (STASH(ISTASH(IT):ISTASH(IT + 1) - 1)\t\n     1            .EQ.STASH(MARK:I)) THEN\t\t\n                    IT = REPLACEMENT(J)\t\t\n                    IF (IT.GT.0) THEN\t\n                      IF (SP.GE.STACKLIMIT) CALL CROAK(\"StackOverflow\n                      SP = SP + 1\t\t\n                      STACKI(SP) = I\t\t\n                      STACKL(SP) = LAST\t\t\n                      I = ISTASH(IT) - 1\t\n                      LAST = ISTASH(IT + 1) - 1\t\n                    END IF\t\t\t\n                    EXIT JJ\t\t\n                  END IF\t\t\n                END DO JJ\t\t\n                TAIL = I\t\t\n              END IF\t\t\t\n              I = I + 1\t\t\t\n            END DO II\t\t\n            IF (SP.GT.0) THEN\t\n              CALL APPEND(TAIL + 1,LAST)\n              TAIL = STACKI(SP)\t\t\n              LAST = STACKL(SP)\t\t\n              SP = SP - 1\t\t\n              I = TAIL + 1\t\t\n              GO TO 666\t\t\t\n            END IF\t\t\n            CALL APPEND(TAIL + 1,LAST)\t\n          END DO LL\t\t\t\n          CALL BURP\t\t\n         CONTAINS\t\t\n          SUBROUTINE APPEND(IST,LST)\t\n           INTEGER IST,LST\t\t\n           INTEGER N\t\t\t\n            N = LST - IST + 1\t\t\n            IF (N.LE.0) RETURN\t\t\n            IF (L + N.GT.LSTASH) CALL CROAK(\"Out of stash\n            STASH(L + 1:L + N) = STASH(IST:LST)\t\n            L = L + N\t\t\t\n            IF (L - L0 + 1.GE.WIDTH) CALL BURP\t\n          END SUBROUTINE APPEND\t\t\n          SUBROUTINE BURP\t\t\n           INTEGER N,W,L1\t\t\n            N = L - L0 + 1\t\t\n            IF (N.LE.WIDTH) THEN\t\n              L1 = L\t\t\t\n             ELSE\t\t\t\n              W = L0 + WIDTH - 1\t\n              DO L1 = W,L0,-1\t\t\n                IF (STASH(L1:L1).LE.\" \") EXIT\t\n              END DO\t\t\t\n              IF (L1.LE.L0) L1 = W\t\n            END IF\t\t\t\n            WRITE (MSG,\"(A)\") STASH(L0:L1)\t\n            IF (N.LE.WIDTH) THEN\t\n              L = L0 - 1\t\t\n             ELSE\t\t\t\n              W = L0 + L - L1 - 1\t\n              STASH(L0:W) = STASH(L1 + 1:L)\t\n              L = W\t\t\t\n            END IF\t\t\t\n          END SUBROUTINE BURP\t\t\n        END SUBROUTINE WRITESTORY\t\n      END MODULE MADLIB\t\t\n\n      PROGRAM MADLIBBER\t\n      USE MADLIB\n      WRITE (MSG,1)\t\n    10FORMAT (\"Reads a story in template form, containing special \",\n     1 \"entries such as <dog's name> amongst the text.\",/,\n     2 \"You will be invited to supply a replacement text for each \"\n     3 \"such entry, as encountered,\",/,\n     4 \"after which the story will be presented with your \",\n     5 \"substitutions made.\",//,\n     6 \"Here goes... Reading file Madlib.txt\",/)\n      OPEN(INF,STATUS=\"OLD\",ACTION=\"READ\",FORM=\"FORMATTED\",\n     1 FILE = \"Madlib.txt\")\n      CALL READSTORY(INF)\n      CLOSE(INF)\n      WRITE (MSG,*)\n      WRITE (MSG,*) \"  Righto\n      WRITE (MSG,*)\n      CALL WRITESTORY(66)\n      END\n", "target": "import re\n\n\n\n\n\ntemplate = \n\ndef madlibs(template):\n    print('The story template is:\\n' + template)\n    fields = sorted(set( re.findall('<[^>]+>', template) ))\n    values = input('\\nInput a comma-separated list of words to replace the following items'\n                   '\\n  %s: ' % ','.join(fields)).split(',')\n    story = template\n    for f,v in zip(fields, values):\n        story = story.replace(f, v)\n    print('\\nThe story becomes:\\n\\n' + story)\n\nmadlibs(template)\n"}
{"id": 347523, "name": "Long year", "source": "Translate Fortran to Python: program longyear\n    use iso_fortran_env, only: output_unit, input_unit\n    implicit none\n\n    integer             :: start, ende, i, counter\n    integer, parameter  :: line_break=10\n\n    write(output_unit,*) \"Enter beginning of interval\"\n    read(input_unit,*) start\n    write(output_unit,*) \"Enter end of interval\"\n    read(input_unit,*) ende\n\n    if (start>=ende) error stop \"Last year must be after first year\n\n    counter = 0\n    do i = start, ende\n        if (is_long_year(i)) then\n            write(output_unit,'(I0,x)', advance=\"no\") i\n            counter = counter + 1\n            if (modulo(counter,line_break) == 0) write(output_unit,*)\n        end if\n    end do\ncontains\n    pure function p(year)\n        integer, intent(in) :: year\n        integer             :: p\n\n        p = modulo(year + year/4 - year/100 + year/400, 7)\n    end function p\n\n    pure function is_long_year(year)\n        integer, intent(in) :: year\n        logical             :: is_long_year\n\n        is_long_year = p(year) == 4 .or. p(year-1) == 3\n    end function is_long_year\nend program longyear\n", "target": "\n\nfrom datetime import date\n\n\n\ndef longYear(y):\n    \n    return 52 < date(y, 12, 28).isocalendar()[1]\n\n\n\n\ndef main():\n    \n    for year in [\n            x for x in range(2000, 1 + 2100)\n            if longYear(x)\n    ]:\n        print(year)\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 347524, "name": "Magic 8-ball", "source": "Translate Fortran to Python: PROGRAM EIGHT_BALL\n    CHARACTER(LEN=100) :: RESPONSE\n    CHARACTER(LEN=100) :: QUESTION\n    CHARACTER(LEN=100), DIMENSION(20) :: RESPONSES\n    REAL :: R\n\n    CALL RANDOM_SEED()\n\n    RESPONSES(1) = \"It is certain\" \n    RESPONSES(2) = \"It is decidedly so\"\n    RESPONSES(3) = \"Without a doubt\"\n    RESPONSES(4) = \"Yes, definitely\"\n    RESPONSES(5) = \"You may rely on it\"\n    RESPONSES(6) = \"As I see it, yes\"\n    RESPONSES(7) = \"Most likely\"\n    RESPONSES(8) = \"Outlook good\"\n    RESPONSES(9) = \"Signs point to yes\"\n    RESPONSES(10) = \"Yes\"\n    RESPONSES(11) = \"Reply hazy, try again\"\n    RESPONSES(12) = \"Ask again later\"\n    RESPONSES(13) = \"Better not tell you now\"\n    RESPONSES(14) = \"Cannot predict now\"\n    RESPONSES(15) = \"Concentrate and ask again\"\n    RESPONSES(16) = \"Don't bet on it\"\n    RESPONSES(17) = \"My reply is no\"\n    RESPONSES(18) = \"My sources say no\"\n    RESPONSES(19) = \"Outlook not so good\"\n    RESPONSES(20) = \"Very doubtful\"\n\n    WRITE(*,*) \"Welcome to 8 Ball\n    WRITE(*,*) \"you seek, type either 'quit' or 'q' to exit\", NEW_LINE('A')\n\n    DO WHILE(.TRUE.)\n        PRINT*, \"Ask your question: \"\n        READ(*,*) QUESTION\n        IF(QUESTION == \"q\" .OR. QUESTION == \"quit\") THEN\n            CALL EXIT(0)\n        ENDIF\n        CALL RANDOM_NUMBER(R)\n        PRINT*, \"Response: \", TRIM(RESPONSES(FLOOR(R*20))), NEW_LINE('A')\n    ENDDO\nEND PROGRAM EIGHT_BALL\n", "target": "import random\n\ns = ('It is certain', 'It is decidedly so', 'Without a doubt', 'Yes, definitely',\n 'You may rely on it', 'As I see it, yes', 'Most likely', 'Outlook good',\n 'Signs point to yes', 'Yes', 'Reply hazy, try again', 'Ask again later',\n 'Better not tell you now', 'Cannot predict now', 'Concentrate and ask again',\n \"Don't bet on it\", 'My reply is no', 'My sources say no', 'Outlook not so good',\n 'Very doubtful')\n\nq_and_a = {}\n\nwhile True:\n    question = input('Ask your question:')\n    if len(question) == 0: break\n        \n    if question in q_and_a:\n        print('Your question has already been answered')\n    else:\n        answer = random.choice(s)\n        q_and_a[question] = answer\n        print(answer)\n"}
{"id": 347525, "name": "Validate International Securities Identification Number", "source": "Translate Fortran to Python: program isin\n    use ctype\n    implicit none\n    character(20) :: test(7) = [\"US0378331005        \", &\n                                \"US0373831005        \", &\n                                \"U50378331005        \", &\n                                \"US03378331005       \", &\n                                \"AU0000XVGZA3        \", &\n                                \"AU0000VXGZA3        \", &\n                                \"FR0000988040        \"]\n    print *, check_isin(test)\ncontains\n    elemental logical function check_isin(a)\n        character(*), intent(in) :: a\n        integer :: s(24)\n        integer :: i, j, k, n, v\n\n        check_isin = .false.\n\n        n = len_trim(a)\n        if (n /= 12) return\n        \n        \n        j = 0\n        do i = 1, n\n            k = iachar(a(i:i))\n            if (k >= 48 .and. k <= 57) then\n                if (i < 3) return\n                k = k - 48\n                j = j + 1\n                s(j) = k\n            else if (k >= 65 .and. k <= 90) then\n                if (i == 12) return\n                k = k - 65 + 10\n                j = j + 1\n                s(j) = k / 10\n                j = j + 1\n                s(j) = mod(k, 10)\n            else\n                return\n            end if\n        end do\n\n        \n        v = 0\n        do i = j - 1, 1, -2\n            k = 2 * s(i)\n            if (k > 9) k = k - 9\n            v = v + k\n        end do\n        do i = j, 1, -2\n            v = v + s(i)\n        end do\n        \n        check_isin = 0 == mod(v, 10)\n    end function\nend program\n", "target": "def check_isin(a):\n    if len(a) != 12 or not all(c.isalpha() for c in a[:2]) or not all(c.isalnum() for c in a[2:]):\n        return False\n    s = \"\".join(str(int(c, 36)) for c in a)\n    return 0 == (sum(sum(divmod(2 * (ord(c) - 48), 10)) for c in s[-2::-2]) +\n                 sum(ord(c) - 48 for c in s[::-2])) % 10\n\n\ndef check_isin_alt(a):\n    if len(a) != 12:\n        return False\n    s = []\n    for i, c in enumerate(a):\n        if c.isdigit():\n            if i < 2:\n                return False\n            s.append(ord(c) - 48)\n        elif c.isupper():\n            if i == 11:\n                return False\n            s += divmod(ord(c) - 55, 10)\n        else:\n            return False\n    v = sum(s[::-2])\n    for k in s[-2::-2]:\n        k = 2 * k\n        v += k - 9 if k > 9 else k\n    return v % 10 == 0\n\n[check_isin(s) for s in [\"US0378331005\", \"US0373831005\", \"U50378331005\", \"US03378331005\",\n                         \"AU0000XVGZA3\", \"AU0000VXGZA3\", \"FR0000988040\"]]\n\n\n"}
{"id": 347526, "name": "Input_Output for pairs of numbers", "source": "Translate Fortran to Python: program i_o_pairs\n  implicit none\n\n  integer :: npairs\n  integer :: i\n  integer, allocatable :: pairs(:,:)\n\n  read(*,*) npairs\n  allocate(pairs(npairs,2))\n \n  do i = 1, npairs\n    read(*,*) pairs(i,:)\n  end do\n  write(*, \"(i0)\") sum(pairs, 2)\n\nend program\n", "target": "def do_stuff(a, b):\n\treturn a + b\n\nt = input()\nfor x in range(0, t):\n\ta, b = raw_input().strip().split()\n\tprint do_stuff(int(a), int(b))\n"}
{"id": 347527, "name": "Kahan summation", "source": "Translate Fortran to Python:       FUNCTION SUMC(A,N)\nCOMPENSATED SUMMATION. C WILL NOT STAY ZERO, DESPITE MATHEMATICS.\n       DIMENSION A(12345)\n        S = 0.0\n        C = 0.0\n        DO 1 I = 1,N\n          Y = A(I) - C\n          T = S + Y\n          C = (T - S) - Y\n          S = T\n    1   CONTINUE\n        SUMC = S\n      END\n      DIMENSION A(3)\n      A(1) = 10000.0\n      A(2) = 3.14159\n      A(3) = 2.71828\n      TYPE 1, A(1) + A(2) + A(3)\n      TYPE 1, SUMC(A,3)\n    1 FORMAT (6HSUM = ,F12.1)\n      END\n", "target": "epsilon = 1.0\nwhile 1.0 + epsilon != 1.0:\n    epsilon = epsilon / 2.0\n"}
{"id": 347528, "name": "Two identical strings", "source": "Translate Fortran to Python:       program IdentStr\n          implicit none\n          integer n, concat, bits\n          \n          n = 1\n  100     if (concat(n) .lt. 1000) then\n              write (*,'(I3,2X,I11)') concat(n), bits(concat(n))\n              n = n + 1\n              goto 100\n          end if\n          stop\n      end\n\nC     Concatenate binary representation of number with itself      \n      integer function concat(num)\n          integer num, sl, sr\n          sl = num\n          sr = num\n  100     if (sr .gt. 0) then\n              sl = sl * 2\n              sr = sr / 2\n              goto 100\n          end if\n          concat = num + sl\n      end\n\nC     Calculate binary representation of number\n      integer function bits(num)\n          integer num, n, bx\n          n = num\n          bits = 0\n          bx = 1\n  100     if (n .gt. 0) then\n              bits = bits + bx * mod(n,2)\n              bx = bx * 10\n              n = n / 2\n              goto 100\n          end if\n      end\n", "target": "def bits(n):\n    \n    r = 0\n    while n:\n        n >>= 1\n        r += 1\n    return r\n    \ndef concat(n):\n    \n    return n << bits(n) | n\n    \nn = 1\nwhile concat(n) <= 1000:\n    print(\"{0}: {0:b}\".format(concat(n)))\n    n += 1\n"}
{"id": 347529, "name": "Verify distribution uniformity_Chi-squared test", "source": "Translate Fortran to Python: module gsl_mini_bind_m\n\n    use iso_c_binding\n    implicit none\n    private\n\n    public :: p_value\n\n    interface\n        function gsl_cdf_chisq_q(x, nu) bind(c, name='gsl_cdf_chisq_Q')\n            import\n            real(c_double), value :: x\n            real(c_double), value :: nu\n            real(c_double) :: gsl_cdf_chisq_q\n        end function gsl_cdf_chisq_q\n    end interface\n\ncontains\n\n    \n    real function p_value(x, df)\n        real, intent(in) :: x\n        integer, intent(in) :: df\n\n        p_value = real(gsl_cdf_chisq_q(real(x, c_double), real(df, c_double)))\n\n    end function p_value\n\nend module gsl_mini_bind_m\n", "target": "import math\nimport random\n\ndef GammaInc_Q( a, x):\n    a1 = a-1\n    a2 = a-2\n    def f0( t ):\n        return t**a1*math.exp(-t)\n\n    def df0(t):\n        return (a1-t)*t**a2*math.exp(-t)\n    \n    y = a1\n    while f0(y)*(x-y) >2.0e-8 and y < x: y += .3\n    if y > x: y = x\n\n    h = 3.0e-4\n    n = int(y/h)\n    h = y/n\n    hh = 0.5*h\n    gamax = h * sum( f0(t)+hh*df0(t) for t in ( h*j for j in xrange(n-1, -1, -1)))\n\n    return gamax/gamma_spounge(a)\n\nc = None\ndef gamma_spounge( z):\n    global c\n    a = 12\n\n    if c is None:\n       k1_factrl = 1.0\n       c = []\n       c.append(math.sqrt(2.0*math.pi))\n       for k in range(1,a):\n          c.append( math.exp(a-k) * (a-k)**(k-0.5) / k1_factrl )\n          k1_factrl *= -k\n    \n    accm = c[0]\n    for k in range(1,a):\n        accm += c[k] / (z+k)\n    accm *= math.exp( -(z+a)) * (z+a)**(z+0.5)\n    return accm/z;\n\ndef chi2UniformDistance( dataSet ):\n    expected = sum(dataSet)*1.0/len(dataSet)\n    cntrd = (d-expected for d in dataSet)\n    return sum(x*x for x in cntrd)/expected\n\ndef chi2Probability(dof, distance):\n    return 1.0 - GammaInc_Q( 0.5*dof, 0.5*distance)\n\ndef chi2IsUniform(dataSet, significance):\n    dof = len(dataSet)-1\n    dist = chi2UniformDistance(dataSet)\n    return chi2Probability( dof, dist ) > significance\n\ndset1 = [ 199809, 200665, 199607, 200270, 199649 ]\ndset2 = [ 522573, 244456, 139979,  71531,  21461 ]\n\nfor ds in (dset1, dset2):\n    print \"Data set:\", ds\n    dof = len(ds)-1\n    distance =chi2UniformDistance(ds)\n    print \"dof: %d distance: %.4f\" % (dof, distance),\n    prob = chi2Probability( dof, distance)\n    print \"probability: %.4f\"%prob,\n    print \"uniform? \", \"Yes\"if chi2IsUniform(ds,0.05) else \"No\"\n"}
{"id": 347530, "name": "CSV to HTML translation", "source": "Translate Fortran to Python:       SUBROUTINE CSVTEXT2HTML(FNAME,HEADED)\t\nConverts without checking field counts, or noting special characters.\n       CHARACTER*(*) FNAME\t\n       LOGICAL HEADED\t\t\n       INTEGER MANY\t\t\n       PARAMETER (MANY=666)\t\n       CHARACTER*(MANY) ALINE\t\n       INTEGER MARK(0:MANY + 1)\t\n       INTEGER I,L,N\t\t\n       CHARACTER*2 WOT(2)\t\n       PARAMETER (WOT = (/\"th\",\"td\"/))\t\n       INTEGER IT\t\t\n       INTEGER KBD,MSG,IN\t\t\n       COMMON /IOUNITS/ KBD,MSG,IN\t\n        OPEN(IN,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",ERR=661)\t\n        WRITE (MSG,1)\t\t\t\n    1   FORMAT (\"<Table border=1>\")\t\n        MARK(0) = 0\t\t\n        N = 0\t\t\t\n\n   10   READ (IN,11,END = 20) L,ALINE(1:MIN(L,MANY))\t\n   11   FORMAT (Q,A)\t\t\n        N = N + 1\t\t\n        IF (L.GT.MANY) THEN\t\n          WRITE (MSG,12) N,L,MANY\t\n   12     FORMAT (\"Line \",I0,\" has length \",I0,\"\n          L = MANY\t\t\t\n        END IF\t\t\t\n        IF (N.EQ.1 .AND. HEADED) THEN\t\n          WRITE (MSG,*) \"<tHead>\"\t\n          IT = 1\t\t\t\n         ELSE\t\t\t\t\n          IT = 2\t\t\t\n        END IF\t\t\t\n        NCOLS = 0\t\t\n        DO I = 1,L\t\t\n          IF (ICHAR(ALINE(I:I)).EQ.ICHAR(\",\")) THEN\t\n            NCOLS = NCOLS + 1\t\t\n            MARK(NCOLS) = I\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        NCOLS = NCOLS + 1\t\n        MARK(NCOLS) = L + 1\t\n        WRITE (MSG,13)\t\t\n     1   (WOT(IT),\t\t\t\t\n     2    ALINE(MARK(I - 1) + 1:MARK(I) - 1),\t\n     3    WOT(IT),\t\t\t\t\n     4    I = 1,NCOLS),\t\t\t\n     5   \"/tr\"\t\t\t\n   13   FORMAT (\" <tr>\",666(\"<\",A,\">\",A,\"</\",A,\">\"))\t\n        IF (N.EQ.1 .AND. HEADED) WRITE (MSG,*) \"</tHead>\"\t\n        GO TO 10\t\t\n\n   20   CLOSE (IN)\t\t\n        WRITE (MSG,21)\t\t\n   21   FORMAT (\"</Table>\")\t\n       RETURN\t\t\t\nConfusions.\n  661   WRITE (MSG,*) \"Can't open file \",FNAME\t\n      END\t\t\t\n\n      INTEGER KBD,MSG,IN\n      COMMON /IOUNITS/ KBD,MSG,IN\n      KBD = 5\t\n      MSG = 6\t\n      IN = 10\t\n\n      CALL CSVTEXT2HTML(\"Text.csv\",.FALSE.)\t\n      WRITE (MSG,*)\n      CALL CSVTEXT2HTML(\"Text.csv\",.TRUE.)\t\n      END\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 347531, "name": "CSV to HTML translation", "source": "Translate Fortran to Python:       SUBROUTINE CSVTEXT2HTML(FNAME,HEADED)\t\nConverts without checking field counts, or noting special characters.\n       CHARACTER*(*) FNAME\t\n       LOGICAL HEADED\t\t\n       INTEGER MANY\t\t\n       PARAMETER (MANY=666)\t\n       CHARACTER*(MANY) ALINE\t\n       INTEGER MARK(0:MANY + 1)\t\n       INTEGER I,L,N\t\t\n       CHARACTER*2 WOT(2)\t\n       PARAMETER (WOT = (/\"th\",\"td\"/))\t\n       INTEGER IT\t\t\n       INTEGER KBD,MSG,IN\t\t\n       COMMON /IOUNITS/ KBD,MSG,IN\t\n        OPEN(IN,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READ\",ERR=661)\t\n        WRITE (MSG,1)\t\t\t\n    1   FORMAT (\"<Table border=1>\")\t\n        MARK(0) = 0\t\t\n        N = 0\t\t\t\n\n   10   READ (IN,11,END = 20) L,ALINE(1:MIN(L,MANY))\t\n   11   FORMAT (Q,A)\t\t\n        N = N + 1\t\t\n        IF (L.GT.MANY) THEN\t\n          WRITE (MSG,12) N,L,MANY\t\n   12     FORMAT (\"Line \",I0,\" has length \",I0,\"\n          L = MANY\t\t\t\n        END IF\t\t\t\n        IF (N.EQ.1 .AND. HEADED) THEN\t\n          WRITE (MSG,*) \"<tHead>\"\t\n          IT = 1\t\t\t\n         ELSE\t\t\t\t\n          IT = 2\t\t\t\n        END IF\t\t\t\n        NCOLS = 0\t\t\n        DO I = 1,L\t\t\n          IF (ICHAR(ALINE(I:I)).EQ.ICHAR(\",\")) THEN\t\n            NCOLS = NCOLS + 1\t\t\n            MARK(NCOLS) = I\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n        NCOLS = NCOLS + 1\t\n        MARK(NCOLS) = L + 1\t\n        WRITE (MSG,13)\t\t\n     1   (WOT(IT),\t\t\t\t\n     2    ALINE(MARK(I - 1) + 1:MARK(I) - 1),\t\n     3    WOT(IT),\t\t\t\t\n     4    I = 1,NCOLS),\t\t\t\n     5   \"/tr\"\t\t\t\n   13   FORMAT (\" <tr>\",666(\"<\",A,\">\",A,\"</\",A,\">\"))\t\n        IF (N.EQ.1 .AND. HEADED) WRITE (MSG,*) \"</tHead>\"\t\n        GO TO 10\t\t\n\n   20   CLOSE (IN)\t\t\n        WRITE (MSG,21)\t\t\n   21   FORMAT (\"</Table>\")\t\n       RETURN\t\t\t\nConfusions.\n  661   WRITE (MSG,*) \"Can't open file \",FNAME\t\n      END\t\t\t\n\n      INTEGER KBD,MSG,IN\n      COMMON /IOUNITS/ KBD,MSG,IN\n      KBD = 5\t\n      MSG = 6\t\n      IN = 10\t\n\n      CALL CSVTEXT2HTML(\"Text.csv\",.FALSE.)\t\n      WRITE (MSG,*)\n      CALL CSVTEXT2HTML(\"Text.csv\",.TRUE.)\t\n      END\n", "target": "csvtxt = \n\nfrom cgi import escape\n\ndef _row2tr(row, attr=None):\n    cols = escape(row).split(',')\n    return ('<TR>'\n            + ''.join('<TD>%s</TD>' % data for data in cols)\n            + '</TR>')\n\ndef csv2html(txt):\n    htmltxt = '<TABLE summary=\"csv2html program output\">\\n'\n    for rownum, row in enumerate(txt.split('\\n')):\n        htmlrow = _row2tr(row)\n        htmlrow = '  <TBODY>%s</TBODY>\\n' % htmlrow\n        htmltxt += htmlrow\n    htmltxt += '</TABLE>\\n'\n    return htmltxt\n\nhtmltxt = csv2html(csvtxt)\nprint(htmltxt)\n"}
{"id": 347532, "name": "Pythagorean triples", "source": "Translate Fortran to Python: module triples\n  implicit none\n  \n  integer :: max_peri, prim, total\n  integer :: u(9,3) = reshape((/ 1, -2, 2,  2, -1, 2,  2, -2, 3, &\n                                 1,  2, 2,  2,  1, 2,  2,  2, 3, &\n                                -1,  2, 2, -2,  1, 2, -2,  2, 3 /), &\n                                (/ 9, 3 /))\n                                \ncontains\n\nrecursive subroutine new_tri(in)\n  integer, intent(in) :: in(:)\n  integer :: i\n  integer :: t(3), p\n\n  p = sum(in)\n  if (p > max_peri) return\n\n  prim = prim + 1\n  total = total + max_peri / p\n  do i = 1, 3\n    t(1) = sum(u(1:3, i) * in)\n    t(2) = sum(u(4:6, i) * in)\n    t(3) = sum(u(7:9, i) * in)\n    call new_tri(t);\n  end do\nend subroutine new_tri\nend module triples\n\nprogram Pythagorean\n  use triples\n  implicit none\n\n  integer :: seed(3) = (/ 3, 4, 5 /)\n  \n  max_peri = 10\n  do\n    total = 0\n    prim = 0\n    call new_tri(seed)\n    write(*, \"(a, i10, 2(i10, a))\") \"Up to\", max_peri, total, \" triples\",  prim, \" primitives\"\n    if(max_peri == 100000000) exit\n    max_peri = max_peri * 10\n  end do\nend program Pythagorean\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 347533, "name": "Pythagorean triples", "source": "Translate Fortran to Python: module triples\n  implicit none\n  \n  integer :: max_peri, prim, total\n  integer :: u(9,3) = reshape((/ 1, -2, 2,  2, -1, 2,  2, -2, 3, &\n                                 1,  2, 2,  2,  1, 2,  2,  2, 3, &\n                                -1,  2, 2, -2,  1, 2, -2,  2, 3 /), &\n                                (/ 9, 3 /))\n                                \ncontains\n\nrecursive subroutine new_tri(in)\n  integer, intent(in) :: in(:)\n  integer :: i\n  integer :: t(3), p\n\n  p = sum(in)\n  if (p > max_peri) return\n\n  prim = prim + 1\n  total = total + max_peri / p\n  do i = 1, 3\n    t(1) = sum(u(1:3, i) * in)\n    t(2) = sum(u(4:6, i) * in)\n    t(3) = sum(u(7:9, i) * in)\n    call new_tri(t);\n  end do\nend subroutine new_tri\nend module triples\n\nprogram Pythagorean\n  use triples\n  implicit none\n\n  integer :: seed(3) = (/ 3, 4, 5 /)\n  \n  max_peri = 10\n  do\n    total = 0\n    prim = 0\n    call new_tri(seed)\n    write(*, \"(a, i10, 2(i10, a))\") \"Up to\", max_peri, total, \" triples\",  prim, \" primitives\"\n    if(max_peri == 100000000) exit\n    max_peri = max_peri * 10\n  end do\nend program Pythagorean\n", "target": "from fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    \n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    \n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    \n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n"}
{"id": 347534, "name": "Call a foreign-language function", "source": "Translate Fortran to Python: module c_api\n    use iso_c_binding\n    implicit none\n\n    interface\n        function strdup(ptr) bind(C)\n            import c_ptr\n            type(c_ptr), value :: ptr\n            type(c_ptr) :: strdup\n        end function\n    end interface\n    \n    interface\n        subroutine free(ptr) bind(C)\n            import c_ptr\n            type(c_ptr), value :: ptr\n        end subroutine\n    end interface\n    \n    interface\n        function puts(ptr) bind(C)\n            import c_ptr, c_int\n            type(c_ptr), value :: ptr\n            integer(c_int) :: puts\n        end function\n    end interface\nend module\n\nprogram c_example\n    use c_api\n    implicit none\n\n    character(20), target :: str = \"Hello, World\n    type(c_ptr) :: ptr\n    integer(c_int) :: res\n    \n    ptr = strdup(c_loc(str))\n    \n    res = puts(c_loc(str))\n    res = puts(ptr)\n    \n    print *, transfer(c_loc(str), 0_c_intptr_t), &\n             transfer(ptr, 0_c_intptr_t)\n    call free(ptr)\nend program\n", "target": "import ctypes\nlibc = ctypes.CDLL(\"/lib/libc.so.6\")\nlibc.strcmp(\"abc\", \"def\")     \nlibc.strcmp(\"hello\", \"hello\") \n"}
{"id": 347535, "name": "Sorting algorithms_Patience sort", "source": "Translate Fortran to Python: module rosetta_code_patience_sort\n  implicit none\n  private\n\n  public :: patience_sort\n\n  interface\n     function binary_predicate (x, y) result (truth)\n       class(*), intent(in) :: x, y\n       logical :: truth\n     end function binary_predicate\n  end interface\n\ncontains\n\n  function patience_sort (less, ifirst, ilast, array) result (sorted)\n    procedure(binary_predicate) :: less\n    integer, intent(in) :: ifirst, ilast\n    class(*), intent(in) :: array(*)\n    integer, allocatable :: sorted(:)\n\n    \n    \n    \n\n    integer :: num_piles\n    integer, allocatable :: piles(:)\n    integer, allocatable :: links(:)\n\n    \n    \n    \n    \n    \n    allocate (piles(1 : ilast - ifirst + 1), source = 0)\n    allocate (links(1 : ilast - ifirst + 1), source = 0)\n\n    num_piles = 0\n    call deal (less, ifirst, ilast, array, num_piles, piles, links)\n\n    allocate (sorted(1 : ilast - ifirst + 1))\n\n    call k_way_merge (less, ifirst, ilast, array, num_piles, piles, &\n         &            links, sorted)\n\n  end function patience_sort\n\n  subroutine deal (less, ifirst, ilast, array, &\n       &           num_piles, piles, links)\n    procedure(binary_predicate) :: less\n    integer, intent(in) :: ifirst, ilast\n    class(*), intent(in) :: array(*)\n    integer, intent(inout) :: num_piles\n    integer, intent(inout) :: piles(1 : ilast - ifirst + 1)\n    integer, intent(inout) :: links(1 : ilast - ifirst + 1)\n\n    integer :: i, q\n\n    do q = 1, ilast - ifirst + 1\n       i = find_pile (q)\n       links(q) = piles(i)\n       piles(i) = q\n       num_piles = max (num_piles, i)\n    end do\n\n  contains\n\n    function find_pile (q) result (index)\n      integer, value :: q\n      integer :: index\n\n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n      \n\n      integer :: i, j, k\n\n      if (num_piles == 0) then\n         index = 1\n      else\n         j = 0\n         k = num_piles - 1\n         do while (j /= k)\n            i = (j + k) / 2\n            if (less (array(piles(j + 1) + ifirst - 1), &\n                 &    array(q + ifirst - 1))) then\n               j = i + 1\n            else\n               k = i\n            end if\n         end do\n         if (j == num_piles - 1) then\n            if (less (array(piles(j + 1) + ifirst - 1), &\n                 &    array(q + ifirst - 1))) then\n               \n               j = j + 1\n            end if\n         end if\n         index = j + 1\n      end if\n    end function find_pile\n\n  end subroutine deal\n\n  subroutine k_way_merge (less, ifirst, ilast, array, num_piles, &\n       &                  piles, links, sorted)\n    procedure(binary_predicate) :: less\n    integer, intent(in) :: ifirst, ilast\n    class(*), intent(in) :: array(*)\n    integer, intent(in) :: num_piles\n    integer, intent(inout) :: piles(1 : ilast - ifirst + 1)\n    integer, intent(inout) :: links(1 : ilast - ifirst + 1)\n    integer, intent(inout) :: sorted(1 : ilast - ifirst + 1)\n\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\n    integer :: total_external_nodes\n    integer :: total_nodes\n    integer :: winners(1:2, 1:(2 * next_power_of_two (num_piles)) - 1)\n    integer :: isorted, i, next\n\n    total_external_nodes = next_power_of_two (num_piles)\n    total_nodes = (2 * total_external_nodes) - 1\n\n    call build_tree\n\n    isorted = 0\n    do while (winners(1, 1) /= 0)\n       isorted = isorted + 1\n       sorted(isorted) = winners(1, 1) + ifirst - 1\n       i = winners(2, 1)\n       next = piles(i)          \n       if (next /= 0) piles(i) = links(next) \n       i = (total_nodes / 2) + i\n       winners(1, i) = next\n       call replay_games (i)\n    end do\n\n  contains\n\n    subroutine build_tree\n      integer :: i\n      integer :: istart\n      integer :: iwinner\n\n      winners = 0\n\n      do i = 1, total_external_nodes\n         \n         winners(2, total_external_nodes - 1 + i) = i\n      end do\n\n      \n      winners(1, total_external_nodes :                  &\n           &     total_external_nodes + num_piles - 1) = &\n           &  piles(1:num_piles)\n\n      do i = 1, num_piles\n         \n         piles(i) = links(piles(i))\n      end do\n\n      istart = total_external_nodes\n      do while (istart /= 1)\n         do i = istart, (2 * istart) - 1, 2\n            iwinner = play_game (i)\n            winners(:, i / 2) = winners(:, iwinner)\n         end do\n         istart = istart / 2\n      end do\n    end subroutine build_tree\n\n    subroutine replay_games (i)\n      integer, value :: i\n\n      integer :: iwinner\n\n      do while (i /= 1)\n         iwinner = play_game (i)\n         i = i / 2\n         winners(:, i) = winners(:, iwinner)\n      end do\n    end subroutine replay_games\n\n    function play_game (i) result (iwinner)\n      integer, value :: i\n      integer :: iwinner\n\n      integer :: j\n\n      j = ieor (i, 1)\n      if (winners(1, i) == 0) then\n         iwinner = j\n      else if (winners(1, j) == 0) then\n         iwinner = i\n      else if (less (array(winners(1, j) + ifirst - 1), &\n           &         array(winners(1, i) + ifirst - 1))) then\n         iwinner = j\n      else\n         iwinner = i\n      end if\n    end function play_game\n\n  end subroutine k_way_merge\n\n  elemental function next_power_of_two (n) result (pow2)\n    integer, value :: n\n    integer :: pow2\n\n    \n    pow2 = 1\n    do while (pow2 < n)\n       pow2 = pow2 + pow2\n    end do\n  end function next_power_of_two\n\nend module rosetta_code_patience_sort\n\nprogram patience_sort_task\n  use, non_intrinsic :: rosetta_code_patience_sort\n  implicit none\n\n  integer, parameter :: example_numbers(*) =               &\n       & (/ 22, 15, 98, 82, 22, 4, 58, 70, 80, 38, 49, 48, &\n       &    46, 54, 93, 8, 54, 2, 72, 84, 86, 76, 53, 37,  &\n       &    90 /)\n\n  integer :: i\n  integer, allocatable :: sorted(:)\n\n  sorted = patience_sort (less, &\n       &                  lbound (example_numbers, 1), &\n       &                  ubound (example_numbers, 1), &\n       &                  example_numbers)\n\n  write (*, '(\"unsorted  \")', advance = 'no')\n  do i = lbound (example_numbers, 1), ubound (example_numbers, 1)\n     write (*, '(1X, I0)', advance = 'no') example_numbers(i)\n  end do\n  write (*, '()')\n  write (*, '(\"sorted    \")', advance = 'no')\n  do i = lbound (sorted, 1), ubound (sorted, 1)\n     write (*, '(1X, I0)', advance = 'no') example_numbers(sorted(i))\n  end do\n  write (*, '()')\n\ncontains\n\n  function less (x, y) result (truth)\n    class(*), intent(in) :: x, y\n    logical :: truth\n\n    select type (x)\n    type is (integer)\n       select type (y)\n       type is (integer)\n          truth = (x < y)\n       class default\n          error stop\n       end select\n    class default\n       error stop\n    end select\n  end function less\n\nend program patience_sort_task\n", "target": "from functools import total_ordering\nfrom bisect import bisect_left\nfrom heapq import merge\n\n@total_ordering\nclass Pile(list):\n    def __lt__(self, other): return self[-1] < other[-1]\n    def __eq__(self, other): return self[-1] == other[-1]\n\ndef patience_sort(n):\n    piles = []\n    \n    for x in n:\n        new_pile = Pile([x])\n        i = bisect_left(piles, new_pile)\n        if i != len(piles):\n            piles[i].append(x)\n        else:\n            piles.append(new_pile)\n\n    \n    n[:] = merge(*[reversed(pile) for pile in piles])\n\nif __name__ == \"__main__\":\n    a = [4, 65, 2, -31, 0, 99, 83, 782, 1]\n    patience_sort(a)\n    print a\n"}
{"id": 347536, "name": "Extensible prime generator", "source": "Translate Fortran to Python:       DO WHILE(F*F <= LST)         \n      DO WHILE(F <= LST/F)                      \n      DO WHILE(F <= (IST + 2*(SBITS - 1))/F)    \n      DO WHILE(F <= IST/F + (MOD(IST,F) + 2*(SBITS - 1))/F) \n", "target": "islice(count(7), 0, None, 2)\n"}
{"id": 347537, "name": "Flipping bits game", "source": "Translate Fortran to Python: \nprogram flipping_bits\nimplicit none\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: N, i, j, io, seed(8), moves, input\nlogical, allocatable :: Brd(:,:), Trgt(:,:)\nlogical :: solved\ndouble precision :: r\n\ndo\n  write(*,*) 'Enter the number of squares (between 1 and 10) you would like: '\n  read(*,*,iostat=io) N\n  if(N.gt.0 .and. N.le.10 .and. io.eq.0) exit\n  write(*,*) 'Please, an integer between 1 and 10'\nend do\n\nallocate(Brd(N,N),Trgt(N,N))\ncall date_and_time(values=seed)\ncall srand(1000*seed(7)+seed(8)+60000*seed(6))\ndo i = 1,N\n  do j = 1,N\n    r = rand()\n    if(r.gt.0.5D0) then\n      Brd(i,j) = .TRUE.\n      Trgt(i,j) = .TRUE.\n    else\n      Brd(i,j) = .FALSE.\n      Trgt(i,j) = .FALSE.\n    end if\n  end do\nend do\n\nmoves = N\ndo i = 1,moves\n  r = 1+2.0D0*dble(N)*rand() - 1.0D-17 \n  if(floor(r).le.N) then\n    do j = 1,N\n      Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n    end do\n  else\n    r = r-N\n    do j = 1,N\n      Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n    end do\n  end if\nend do\n\n\ndo\n  input = N\n  call next_move(Brd,Trgt,N,input,solved)\n  call next_move(Brd,Trgt,N,input,solved)\n  if(solved) then\n    r = 1+2.0D0*dble(N)*rand() - 1.0D-17\n    if(floor(r).le.N) then\n      do j = 1,N\n        Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n      end do\n    else\n      r = r-N\n      do j = 1,N\n        Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n      end do\n    end if\n  else\n    exit\n  end if\nend do\n\nwrite(*,*) 'Welcome to the Flipping Bits game\nwrite(*,*) 'You have the current position'\n\nmoves = 0\ncall display(Brd,Trgt,N)\ninput = N\ndo\n  write(*,*) 'Number of moves so far:', moves\n  write(*,*) 'Select the column or row you wish to flip: '\n  read(*,*,iostat=io) input\n  if(io.eq.0 .and. input.gt.0 .and. input.le.(2*N)) then\n    moves = moves+1\n    write(*,*) 'Flipping ', input\n    call next_move(Brd,Trgt,N,input,solved)\n    call display(Brd,Trgt,N)\n    if(solved) exit\n  else\n    write(*,*) 'Please enter a valid column or row number. To quit, press Ctrl+C\n  end if\nend do\n\nwrite(*,*) 'Congratulations\nwrite(*,ifmt,advance='no') moves\nwrite(*,*) ' moves were taken by you\ndeallocate(Brd,Trgt)\nend program\n\nsubroutine display(Brd,Trgt,N)\nimplicit none\n\ninteger :: N\nlogical :: Brd(N,N), Trgt(N,N)\n\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: i, j\nwrite(*,*) 'Current Configuration: '\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Brd(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\n\nwrite(*,*)\nwrite(*,*)\n\nwrite(*,*) 'Target Configuration'\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Trgt(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\nwrite(*,*)\nwrite(*,*)\nend subroutine\n\nsubroutine next_move(Brd,Trgt,N,input,solved)\nimplicit none\n\ninteger :: N, input\nlogical :: Brd(N,N), Trgt(N,N), solved\n\ninteger :: i,j\n\nif(input.gt.N) then\n  input = input-N\n  do i = 1,N\n    Brd(input,i) = .not.Brd(input,i)\n  end do\nelse\n  do i = 1,N\n    Brd(i,input) = .not.Brd(i,input)\n  end do\nend if\nsolved = .TRUE.\ndo i = 1,N\n  do j = 1,N\n    if( (.not.Brd(i,j).and.Trgt(i,j)) .or. (Brd(i,j).and..not.Trgt(i,j)) ) then\n      solved = .FALSE.\n      exit\n    end if\n  end do\n  if(.not.solved) exit\nend do\nend subroutine\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 347538, "name": "Flipping bits game", "source": "Translate Fortran to Python: \nprogram flipping_bits\nimplicit none\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: N, i, j, io, seed(8), moves, input\nlogical, allocatable :: Brd(:,:), Trgt(:,:)\nlogical :: solved\ndouble precision :: r\n\ndo\n  write(*,*) 'Enter the number of squares (between 1 and 10) you would like: '\n  read(*,*,iostat=io) N\n  if(N.gt.0 .and. N.le.10 .and. io.eq.0) exit\n  write(*,*) 'Please, an integer between 1 and 10'\nend do\n\nallocate(Brd(N,N),Trgt(N,N))\ncall date_and_time(values=seed)\ncall srand(1000*seed(7)+seed(8)+60000*seed(6))\ndo i = 1,N\n  do j = 1,N\n    r = rand()\n    if(r.gt.0.5D0) then\n      Brd(i,j) = .TRUE.\n      Trgt(i,j) = .TRUE.\n    else\n      Brd(i,j) = .FALSE.\n      Trgt(i,j) = .FALSE.\n    end if\n  end do\nend do\n\nmoves = N\ndo i = 1,moves\n  r = 1+2.0D0*dble(N)*rand() - 1.0D-17 \n  if(floor(r).le.N) then\n    do j = 1,N\n      Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n    end do\n  else\n    r = r-N\n    do j = 1,N\n      Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n    end do\n  end if\nend do\n\n\ndo\n  input = N\n  call next_move(Brd,Trgt,N,input,solved)\n  call next_move(Brd,Trgt,N,input,solved)\n  if(solved) then\n    r = 1+2.0D0*dble(N)*rand() - 1.0D-17\n    if(floor(r).le.N) then\n      do j = 1,N\n        Trgt(floor(r),j) = .NOT.Trgt(floor(r),j)\n      end do\n    else\n      r = r-N\n      do j = 1,N\n        Trgt(j,floor(r)) = .NOT.Trgt(j,floor(r))\n      end do\n    end if\n  else\n    exit\n  end if\nend do\n\nwrite(*,*) 'Welcome to the Flipping Bits game\nwrite(*,*) 'You have the current position'\n\nmoves = 0\ncall display(Brd,Trgt,N)\ninput = N\ndo\n  write(*,*) 'Number of moves so far:', moves\n  write(*,*) 'Select the column or row you wish to flip: '\n  read(*,*,iostat=io) input\n  if(io.eq.0 .and. input.gt.0 .and. input.le.(2*N)) then\n    moves = moves+1\n    write(*,*) 'Flipping ', input\n    call next_move(Brd,Trgt,N,input,solved)\n    call display(Brd,Trgt,N)\n    if(solved) exit\n  else\n    write(*,*) 'Please enter a valid column or row number. To quit, press Ctrl+C\n  end if\nend do\n\nwrite(*,*) 'Congratulations\nwrite(*,ifmt,advance='no') moves\nwrite(*,*) ' moves were taken by you\ndeallocate(Brd,Trgt)\nend program\n\nsubroutine display(Brd,Trgt,N)\nimplicit none\n\ninteger :: N\nlogical :: Brd(N,N), Trgt(N,N)\n\ncharacter(len=*), parameter :: cfmt = \"(A3)\", ifmt = \"(I3)\"\ninteger :: i, j\nwrite(*,*) 'Current Configuration: '\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Brd(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\n\nwrite(*,*)\nwrite(*,*)\n\nwrite(*,*) 'Target Configuration'\ndo i = 0,N\n  if(i.eq.0) then\n    write(*,cfmt,advance='no') 'R/C'\n    write(*,cfmt,advance='no') ' | '\n  else\n    write(*,ifmt,advance='no') i\n  end if\nend do\nwrite(*,*) \ndo i = 0,N\n  if(i.eq.0) then\n    do j = 0,N+2\n      write(*,cfmt,advance='no') '---'\n    end do\n  else\n    write(*,ifmt,advance='no') i+N\n    write(*,cfmt,advance='no') ' | '\n    do j = 1,N\n      if(Trgt(i,j)) then\n        write(*,ifmt,advance='no') 1\n      else\n        write(*,ifmt,advance='no') 0\n      end if\n    end do\n  end if\n  write(*,*)\nend do\nwrite(*,*)\nwrite(*,*)\nend subroutine\n\nsubroutine next_move(Brd,Trgt,N,input,solved)\nimplicit none\n\ninteger :: N, input\nlogical :: Brd(N,N), Trgt(N,N), solved\n\ninteger :: i,j\n\nif(input.gt.N) then\n  input = input-N\n  do i = 1,N\n    Brd(input,i) = .not.Brd(input,i)\n  end do\nelse\n  do i = 1,N\n    Brd(i,input) = .not.Brd(i,input)\n  end do\nend if\nsolved = .TRUE.\ndo i = 1,N\n  do j = 1,N\n    if( (.not.Brd(i,j).and.Trgt(i,j)) .or. (Brd(i,j).and..not.Trgt(i,j)) ) then\n      solved = .FALSE.\n      exit\n    end if\n  end do\n  if(.not.solved) exit\nend do\nend subroutine\n", "target": "\n\nfrom random import randrange\nfrom copy import deepcopy\nfrom string import ascii_lowercase\n\n\ntry:    \n    input = raw_input\nexcept:\n    pass\n\nN = 3   \n\nboard  = [[0]* N for i in range(N)]\n\ndef setbits(board, count=1):\n    for i in range(count):\n        board[randrange(N)][randrange(N)] ^= 1\n\ndef shuffle(board, count=1):\n    for i in range(count):\n        if randrange(0, 2):\n            fliprow(randrange(N))\n        else:\n            flipcol(randrange(N))\n\n\ndef pr(board, comment=''):\n    print(str(comment))\n    print('     ' + ' '.join(ascii_lowercase[i] for i in range(N)))\n    print('  ' + '\\n  '.join(' '.join(['%2s' % j] + [str(i) for i in line])\n                             for j, line in enumerate(board, 1)))\n\ndef init(board):\n    setbits(board, count=randrange(N)+1)\n    target = deepcopy(board)\n    while board == target:\n        shuffle(board, count=2 * N)\n    prompt = '  X, T, or 1-%i / %s-%s to flip: ' % (N, ascii_lowercase[0], \n                                                    ascii_lowercase[N-1])\n    return target, prompt\n\ndef fliprow(i):\n    board[i-1][:] = [x ^ 1 for x in board[i-1] ]\n    \ndef flipcol(i):\n    for row in board:\n        row[i] ^= 1\n\nif __name__ == '__main__':\n    print(__doc__ % (N, N))\n    target, prompt = init(board)\n    pr(target, 'Target configuration is:')\n    print('')\n    turns = 0\n    while board != target:\n        turns += 1\n        pr(board, '%i:' % turns)\n        ans = input(prompt).strip()\n        if (len(ans) == 1 \n            and ans in ascii_lowercase and ascii_lowercase.index(ans) < N):\n            flipcol(ascii_lowercase.index(ans))\n        elif ans and all(ch in '0123456789' for ch in ans) and 1 <= int(ans) <= N:\n            fliprow(int(ans))\n        elif ans == 'T':\n            pr(target, 'Target configuration is:')\n            turns -= 1\n        elif ans == 'X':\n            break\n        else:\n            print(\"  I don't understand %r... Try again. \"\n                  \"(X to exit or T to show target)\\n\" % ans[:9])\n            turns -= 1\n    else:\n        print('\\nWell done!\\nBye.')\n"}
{"id": 347539, "name": "Gray code", "source": "Translate Fortran to Python:       PROGRAM GRAY\n      IMPLICIT NONE\n      INTEGER IGRAY,I,J,K\n      CHARACTER*5 A,B,C\n      DO 10 I=0,31\n      J=IGRAY(I,1)\n      K=IGRAY(J,-1)\n      CALL BINARY(A,I,5)\n      CALL BINARY(B,J,5)\n      CALL BINARY(C,K,5)\n      PRINT 99,I,A,B,C,K\n   10 CONTINUE\n   99 FORMAT(I2,3H : ,A5,4H => ,A5,4H => ,A5,3H : ,I2)\n      END\n\n      FUNCTION IGRAY(N,D)\n      IMPLICIT NONE\n      INTEGER D,K,N,IGRAY\n      IF(D.LT.0) GO TO 10\n      IGRAY=IEOR(N,ISHFT(N,-1))\n      RETURN\n   10 K=N\n      IGRAY=0\n   20 IGRAY=IEOR(IGRAY,K)\n      K=K/2\n      IF(K.NE.0) GO TO 20\n      END\n\n      SUBROUTINE BINARY(S,N,K)\n      IMPLICIT NONE\n      INTEGER I,K,L,N\n      CHARACTER*(*) S\n      L=LEN(S)\n      DO 10 I=0,K-1\nC The following line may replace the next block-if,\nC on machines using ASCII code :\nC     S(L-I:L-I)=CHAR(48+IAND(1,ISHFT(N,-I)))\nC On EBCDIC machines, use 240 instead of 48.\n      IF(BTEST(N,I)) THEN\n      S(L-I:L-I)='1'\n      ELSE\n      S(L-I:L-I)='0'\n      END IF\n   10 CONTINUE\n      S(1:L-K)=''\n      END\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 347540, "name": "Gray code", "source": "Translate Fortran to Python:       PROGRAM GRAY\n      IMPLICIT NONE\n      INTEGER IGRAY,I,J,K\n      CHARACTER*5 A,B,C\n      DO 10 I=0,31\n      J=IGRAY(I,1)\n      K=IGRAY(J,-1)\n      CALL BINARY(A,I,5)\n      CALL BINARY(B,J,5)\n      CALL BINARY(C,K,5)\n      PRINT 99,I,A,B,C,K\n   10 CONTINUE\n   99 FORMAT(I2,3H : ,A5,4H => ,A5,4H => ,A5,3H : ,I2)\n      END\n\n      FUNCTION IGRAY(N,D)\n      IMPLICIT NONE\n      INTEGER D,K,N,IGRAY\n      IF(D.LT.0) GO TO 10\n      IGRAY=IEOR(N,ISHFT(N,-1))\n      RETURN\n   10 K=N\n      IGRAY=0\n   20 IGRAY=IEOR(IGRAY,K)\n      K=K/2\n      IF(K.NE.0) GO TO 20\n      END\n\n      SUBROUTINE BINARY(S,N,K)\n      IMPLICIT NONE\n      INTEGER I,K,L,N\n      CHARACTER*(*) S\n      L=LEN(S)\n      DO 10 I=0,K-1\nC The following line may replace the next block-if,\nC on machines using ASCII code :\nC     S(L-I:L-I)=CHAR(48+IAND(1,ISHFT(N,-I)))\nC On EBCDIC machines, use 240 instead of 48.\n      IF(BTEST(N,I)) THEN\n      S(L-I:L-I)='1'\n      ELSE\n      S(L-I:L-I)='0'\n      END IF\n   10 CONTINUE\n      S(1:L-K)=''\n      END\n", "target": ">>> def int2bin(n):\n\t'From positive integer to list of binary bits, msb at index 0'\n\tif n:\n\t\tbits = []\n\t\twhile n:\n\t\t\tn,remainder = divmod(n, 2)\n\t\t\tbits.insert(0, remainder)\n\t\treturn bits\n\telse: return [0]\n\n\t\n>>> def bin2int(bits):\n\t'From binary bits, msb at index 0 to integer'\n\ti = 0\n\tfor bit in bits:\n\t\ti = i * 2 + bit\n\treturn i\n"}
{"id": 347541, "name": "File extension is in extensions list", "source": "Translate Fortran to Python:         IT = ICHAR(TEXT(I:I)) - ICHAR(\"a\")\t\n        IF (IT.GE.0 .AND. IT.LE.25) TEXT(I:I) = CHAR(IT + ICHAR(\"A\"))\t\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 347542, "name": "File extension is in extensions list", "source": "Translate Fortran to Python:         IT = ICHAR(TEXT(I:I)) - ICHAR(\"a\")\t\n        IF (IT.GE.0 .AND. IT.LE.25) TEXT(I:I) = CHAR(IT + ICHAR(\"A\"))\t\n", "target": "def isExt(fileName, extensions):\n  return True in map(fileName.lower().endswith, (\".\" + e.lower() for e in extensions))\n"}
{"id": 347543, "name": "Extreme floating point values", "source": "Translate Fortran to Python:        REAL*8\t\tBAD,NaN\t\t\t\n       PARAMETER (NaN = Z'FFFFFFFFFFFFFFFF')\t\n       PARAMETER (BAD = Z'FFFFFFFFFFFFFFFF')\t\n       CHARACTER*3\tBADASTEXT\t\t\n       DATA\t\tBADASTEXT/\"\u00a0? \"/\t\n       REAL*8\t\tPINF,NINF\t\t\n       PARAMETER (PINF = Z'7FF0000000000000')\t\n       PARAMETER (NINF = Z'FFF0000000000000')\t\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 347544, "name": "Extreme floating point values", "source": "Translate Fortran to Python:        REAL*8\t\tBAD,NaN\t\t\t\n       PARAMETER (NaN = Z'FFFFFFFFFFFFFFFF')\t\n       PARAMETER (BAD = Z'FFFFFFFFFFFFFFFF')\t\n       CHARACTER*3\tBADASTEXT\t\t\n       DATA\t\tBADASTEXT/\"\u00a0? \"/\t\n       REAL*8\t\tPINF,NINF\t\t\n       PARAMETER (PINF = Z'7FF0000000000000')\t\n       PARAMETER (NINF = Z'FFF0000000000000')\t\n", "target": ">>> \n>>> inf = 1e234 * 1e234\n>>> _inf = 1e234 * -1e234\n>>> _zero = 1 / _inf\n>>> nan = inf + _inf\n>>> inf, _inf, _zero, nan\n(inf, -inf, -0.0, nan)\n>>> \n>>> for value in (inf, _inf, _zero, nan): print (value)\n\ninf\n-inf\n-0.0\nnan\n>>> \n>>> float('nan')\nnan\n>>> float('inf')\ninf\n>>> float('-inf')\n-inf\n>>> -0.\n-0.0\n>>> \n>>> nan == nan\nFalse\n>>> nan is nan\nTrue\n>>> 0. == -0.\nTrue\n>>> 0. is -0.\nFalse\n>>> inf + _inf\nnan\n>>> 0.0 * nan\nnan\n>>> nan * 0.0\nnan\n>>> 0.0 * inf\nnan\n>>> inf * 0.0\nnan\n"}
{"id": 347545, "name": "Conjugate transpose", "source": "Translate Fortran to Python: program conjugate_transpose\n\n  complex, dimension(3, 3) :: a\n  integer :: i\n  a = reshape((/ (i, i=1,9) /), shape(a))\n  call characterize(a)\n  a(:2,:2) = reshape((/cmplx(3,0),cmplx(2,-1),cmplx(2,1),cmplx(1,0)/),(/2,2/))\n  call characterize(a(:2,:2))\n  call characterize(cmplx(reshape((/1,0,1,1,1,0,0,1,1/),(/3,3/)),0))\n  a(3,:) = (/cmplx(0,0), cmplx(0,0), cmplx(0,1)/)*sqrt(2.0)\n  a(2,:) = (/cmplx(0,-1),cmplx(0,1),cmplx(0,0)/)\n  a(1,:) = (/1,1,0/)\n  a = a * sqrt(2.0)/2.0\n  call characterize(a)\n\ncontains\n\n  subroutine characterize(a)\n    complex, dimension(:,:), intent(in) :: a\n    integer :: i, j\n    do i=1, size(a,1)\n       print *,(a(i, j), j=1,size(a,1))\n    end do\n    print *,'Is Hermitian?  ',HermitianQ(a)\n    print *,'Is normal?  ',NormalQ(a)\n    print *,'Unitary?  ',UnitaryQ(a)\n    print '(/)'\n  end subroutine characterize\n\n  function ct(a) result(b) \n    complex, dimension(:,:), intent(in) :: a\n    complex, dimension(size(a,1),size(a,1)) :: b\n    b = conjg(transpose(a))\n  end function ct\n\n  function identity(n) result(b) \n    integer, intent(in) :: n\n    real, dimension(n,n) :: b\n    integer :: i\n    b = 0\n    do i=1, n\n       b(i,i) = 1\n    end do\n  end function identity\n\n  logical function HermitianQ(a)\n    complex, dimension(:,:), intent(in) :: a\n    HermitianQ = all(a .eq. ct(a))\n  end function HermitianQ\n\n  logical function NormalQ(a)\n    complex, dimension(:,:), intent(in) :: a\n    NormalQ = all(matmul(ct(a),a) .eq. matmul(a,ct(a)))\n  end function NormalQ\n\n  logical function UnitaryQ(a)\n    \n    \n    \n    complex, dimension(:,:), intent(in) :: a\n    UnitaryQ = all(abs(matmul(a,ct(a)) - identity(size(a,1))) .lt. 1e-6)\n  end function UnitaryQ\n\nend program conjugate_transpose\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 347546, "name": "Conjugate transpose", "source": "Translate Fortran to Python: program conjugate_transpose\n\n  complex, dimension(3, 3) :: a\n  integer :: i\n  a = reshape((/ (i, i=1,9) /), shape(a))\n  call characterize(a)\n  a(:2,:2) = reshape((/cmplx(3,0),cmplx(2,-1),cmplx(2,1),cmplx(1,0)/),(/2,2/))\n  call characterize(a(:2,:2))\n  call characterize(cmplx(reshape((/1,0,1,1,1,0,0,1,1/),(/3,3/)),0))\n  a(3,:) = (/cmplx(0,0), cmplx(0,0), cmplx(0,1)/)*sqrt(2.0)\n  a(2,:) = (/cmplx(0,-1),cmplx(0,1),cmplx(0,0)/)\n  a(1,:) = (/1,1,0/)\n  a = a * sqrt(2.0)/2.0\n  call characterize(a)\n\ncontains\n\n  subroutine characterize(a)\n    complex, dimension(:,:), intent(in) :: a\n    integer :: i, j\n    do i=1, size(a,1)\n       print *,(a(i, j), j=1,size(a,1))\n    end do\n    print *,'Is Hermitian?  ',HermitianQ(a)\n    print *,'Is normal?  ',NormalQ(a)\n    print *,'Unitary?  ',UnitaryQ(a)\n    print '(/)'\n  end subroutine characterize\n\n  function ct(a) result(b) \n    complex, dimension(:,:), intent(in) :: a\n    complex, dimension(size(a,1),size(a,1)) :: b\n    b = conjg(transpose(a))\n  end function ct\n\n  function identity(n) result(b) \n    integer, intent(in) :: n\n    real, dimension(n,n) :: b\n    integer :: i\n    b = 0\n    do i=1, n\n       b(i,i) = 1\n    end do\n  end function identity\n\n  logical function HermitianQ(a)\n    complex, dimension(:,:), intent(in) :: a\n    HermitianQ = all(a .eq. ct(a))\n  end function HermitianQ\n\n  logical function NormalQ(a)\n    complex, dimension(:,:), intent(in) :: a\n    NormalQ = all(matmul(ct(a),a) .eq. matmul(a,ct(a)))\n  end function NormalQ\n\n  logical function UnitaryQ(a)\n    \n    \n    \n    complex, dimension(:,:), intent(in) :: a\n    UnitaryQ = all(abs(matmul(a,ct(a)) - identity(size(a,1))) .lt. 1e-6)\n  end function UnitaryQ\n\nend program conjugate_transpose\n", "target": "def conjugate_transpose(m):\n    return tuple(tuple(n.conjugate() for n in row) for row in zip(*m))\n\ndef mmul( ma, mb):\n    return tuple(tuple(sum( ea*eb for ea,eb in zip(a,b)) for b in zip(*mb)) for a in ma)\n\ndef mi(size):\n    'Complex Identity matrix'\n    sz = range(size)\n    m = [[0 + 0j for i in sz] for j in sz]\n    for i in range(size):\n        m[i][i] = 1 + 0j\n    return tuple(tuple(row) for row in m)\n\ndef __allsame(vector):\n    first, rest = vector[0], vector[1:]\n    return all(i == first for i in rest)\n\ndef __allnearsame(vector, eps=1e-14):\n    first, rest = vector[0], vector[1:]\n    return all(abs(first.real - i.real) < eps and abs(first.imag - i.imag) < eps\n               for i in rest)\n\ndef isequal(matrices, eps=1e-14):\n    'Check any number of matrices for equality within eps'\n    x = [len(m) for m in matrices]\n    if not __allsame(x): return False\n    y = [len(m[0]) for m in matrices]\n    if not __allsame(y): return False\n    for s in range(x[0]):\n        for t in range(y[0]):\n            if not __allnearsame([m[s][t] for m in matrices], eps): return False\n    return True\n    \n\ndef ishermitian(m, ct):\n    return isequal([m, ct])\n\ndef isnormal(m, ct):\n    return isequal([mmul(m, ct), mmul(ct, m)])\n\ndef isunitary(m, ct):\n    mct, ctm = mmul(m, ct), mmul(ct, m)\n    mctx, mcty, cmx, ctmy = len(mct), len(mct[0]), len(ctm), len(ctm[0])\n    ident = mi(mctx)\n    return isequal([mct, ctm, ident])\n\ndef printm(comment, m):\n    print(comment)\n    fields = [['%g%+gj' % (f.real, f.imag) for f in row] for row in m]\n    width = max(max(len(f) for f in row) for row in fields)\n    lines = (', '.join('%*s' % (width, f) for f in row) for row in fields)\n    print('\\n'.join(lines))\n\nif __name__ == '__main__':\n    for matrix in [\n            ((( 3.000+0.000j), (+2.000+1.000j)), \n            (( 2.000-1.000j), (+1.000+0.000j))),\n\n            ((( 1.000+0.000j), (+1.000+0.000j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+1.000+0.000j), (+1.000+0.000j)), \n            (( 1.000+0.000j), (+0.000+0.000j), (+1.000+0.000j))),\n\n            ((( 2**0.5/2+0.000j), (+2**0.5/2+0.000j), (+0.000+0.000j)), \n            (( 0.000+2**0.5/2j), (+0.000-2**0.5/2j), (+0.000+0.000j)), \n            (( 0.000+0.000j), (+0.000+0.000j), (+0.000+1.000j)))]:\n        printm('\\nMatrix:', matrix)\n        ct = conjugate_transpose(matrix)\n        printm('Its conjugate transpose:', ct)\n        print('Hermitian? %s.' % ishermitian(matrix, ct))\n        print('Normal?    %s.' % isnormal(matrix, ct))\n        print('Unitary?   %s.' % isunitary(matrix, ct))\n"}
{"id": 347547, "name": "Flow-control structures", "source": "Translate Fortran to Python:       ...\n      ASSIGN 1101 to WHENCE   \n      GO TO 1000              \n 1101 CONTINUE                \n      ... \n      ASSIGN 1102 to WHENCE   \n      GO TO 1000              \n 1102 CONTINUE                \n      ...\nCommon code, far away.\n 1000 do something            \n      GO TO WHENCE            \n", "target": "\nfor i in range(n):\n    if (n%2) == 0:\n        continue\n    if (n%i) == 0:\n        result = i\n        break\nelse:\n    result = None\n    print \"No odd factors found\"\n"}
{"id": 347548, "name": "Find if a point is within a triangle", "source": "Translate Fortran to Python: PROGRAM POINT_WITHIN_TRIANGLE\n\nIMPLICIT NONE\n\nREAL (KIND = SELECTED_REAL_KIND (8)) px, py, ax, ay, bx, by, cx, cy\n\npx = 0.0\npy = 0.0\nax = 1.5\nay = 2.4\nbx = 5.1\nby = -3.1\ncx = -3.8\ncy = 1.2\n\nIF (IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)) THEN\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\n  ELSE\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is not within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\nEND IF\n\nCONTAINS\n\n  \n  LOGICAL FUNCTION IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)\n\n    REAL (KIND = SELECTED_REAL_KIND (8)), INTENT (IN) :: px, py, ax, ay, bx, by, cx, cy\n    REAL (KIND = SELECTED_REAL_KIND (8)) :: vabx, vaby, vacx, vacy, a, b\n\n    vabx = bx - ax\n    vaby = by - ay\n    vacx = cx - ax\n    vacy = cy - ay\n\n    a = ((px * vacy - py * vacx) - (ax * vacy - ay * vacx)) / &\n        (vabx * vacy - vaby * vacx)\n    b = -((px * vaby - py * vabx) - (ax * vaby - ay * vabx)) / &\n        (vabx * vacy - vaby * vacx)\n\n    IF ((a .GT. 0) .AND. (b .GT. 0) .AND. (a + b < 1)) THEN\n\n        IS_P_IN_ABC = .TRUE.\n\n      ELSE\n\n        IS_P_IN_ABC = .FALSE.\n\n    END IF\n\n  END FUNCTION IS_P_IN_ABC\n\nEND PROGRAM POINT_WITHIN_TRIANGLE\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 347549, "name": "Find if a point is within a triangle", "source": "Translate Fortran to Python: PROGRAM POINT_WITHIN_TRIANGLE\n\nIMPLICIT NONE\n\nREAL (KIND = SELECTED_REAL_KIND (8)) px, py, ax, ay, bx, by, cx, cy\n\npx = 0.0\npy = 0.0\nax = 1.5\nay = 2.4\nbx = 5.1\nby = -3.1\ncx = -3.8\ncy = 1.2\n\nIF (IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)) THEN\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\n  ELSE\n\n    WRITE (*, *) 'Point (', px, ', ', py, ') is not within triangle &\n        [(', ax, ', ', ay,'), (', bx, ', ', by, '), (', cx, ', ', cy, ')].'\n\nEND IF\n\nCONTAINS\n\n  \n  LOGICAL FUNCTION IS_P_IN_ABC (px, py, ax, ay, bx, by, cx, cy)\n\n    REAL (KIND = SELECTED_REAL_KIND (8)), INTENT (IN) :: px, py, ax, ay, bx, by, cx, cy\n    REAL (KIND = SELECTED_REAL_KIND (8)) :: vabx, vaby, vacx, vacy, a, b\n\n    vabx = bx - ax\n    vaby = by - ay\n    vacx = cx - ax\n    vacy = cy - ay\n\n    a = ((px * vacy - py * vacx) - (ax * vacy - ay * vacx)) / &\n        (vabx * vacy - vaby * vacx)\n    b = -((px * vaby - py * vabx) - (ax * vaby - ay * vabx)) / &\n        (vabx * vacy - vaby * vacx)\n\n    IF ((a .GT. 0) .AND. (b .GT. 0) .AND. (a + b < 1)) THEN\n\n        IS_P_IN_ABC = .TRUE.\n\n      ELSE\n\n        IS_P_IN_ABC = .FALSE.\n\n    END IF\n\n  END FUNCTION IS_P_IN_ABC\n\nEND PROGRAM POINT_WITHIN_TRIANGLE\n", "target": "\n\nfrom sympy.geometry import Point, Triangle\n\ndef sign(pt1, pt2, pt3):\n    \n    return (pt1.x - pt3.x) * (pt2.y - pt3.y) - (pt2.x - pt3.x) * (pt1.y - pt3.y)\n\n\ndef iswithin(point, pt1, pt2, pt3):\n    \n    zval1 = sign(point, pt1, pt2)\n    zval2 = sign(point, pt2, pt3)\n    zval3 = sign(point, pt3, pt1)\n    notanyneg = zval1 >= 0 and zval2 >= 0 and zval3 >= 0\n    notanypos = zval1 <= 0 and zval2 <= 0 and zval3 <= 0\n    return notanyneg or notanypos\n\nif __name__ == \"__main__\":\n    POINTS = [Point(0, 0)]\n    TRI = Triangle(Point(1.5, 2.4), Point(5.1, -3.1), Point(-3.8, 0.5))\n    for pnt in POINTS:\n        a, b, c = TRI.vertices\n        isornot = \"is\" if iswithin(pnt, a, b, c) else \"is not\"\n        print(\"Point\", pnt, isornot, \"within the triangle\", TRI)\n"}
{"id": 347550, "name": "Return multiple values", "source": "Translate Fortran to Python: module multiple_values\nimplicit none\ntype res\n  integer :: p, m\nend type\n\ncontains\n\nfunction addsub(x,y) result(r)\n  integer :: x, y\n  type(res) :: r \n  r%p = x+y\n  r%m = x-y\nend function\nend module\n\nprogram main\n  use multiple_values \n  print *, addsub(33, 22)\nend program\n", "target": "def addsub(x, y):\n  return x + y, x - y\n"}
{"id": 347551, "name": "Fractran", "source": "Translate Fortran to Python: C:\\Nicky\\RosettaCode\\FRACTRAN\\FRACTRAN.for(6) : Warning: This name has not been given an explicit type.   [M]\n       INTEGER P(M),Q(M)\n", "target": "from fractions import Fraction\n\ndef fractran(n, fstring='17 / 91, 78 / 85, 19 / 51, 23 / 38, 29 / 33,'\n                        '77 / 29, 95 / 23, 77 / 19, 1 / 17, 11 / 13,'\n                        '13 / 11, 15 / 14, 15 / 2, 55 / 1'):\n    flist = [Fraction(f) for f in fstring.replace(' ', '').split(',')]\n\n    n = Fraction(n)\n    while True:\n        yield n.numerator\n        for f in flist:\n            if (n * f).denominator == 1:\n                break\n        else:\n            break\n        n *= f\n    \nif __name__ == '__main__':\n    n, m = 2, 15\n    print('First %i members of fractran(%i):\\n  ' % (m, n) +\n          ', '.join(str(f) for f,i in zip(fractran(n), range(m))))\n"}
{"id": 347552, "name": "Substring_Top and tail", "source": "Translate Fortran to Python: program substring\n\n  character(len=5) :: string\n  string = \"Hello\"\n  \n  write (*,*) string\n  write (*,*) string(2:)\n  write (*,*) string( :len(string)-1)\n  write (*,*) string(2:len(string)-1)\n\nend program substring\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 347553, "name": "Substring_Top and tail", "source": "Translate Fortran to Python: program substring\n\n  character(len=5) :: string\n  string = \"Hello\"\n  \n  write (*,*) string\n  write (*,*) string(2:)\n  write (*,*) string( :len(string)-1)\n  write (*,*) string(2:len(string)-1)\n\nend program substring\n", "target": "print \"knight\"[1:]     \nprint \"socks\"[:-1]     \nprint \"brooms\"[1:-1]   \n"}
{"id": 347554, "name": "Boolean values", "source": "Translate Fortran to Python:       TYPE MIXED\n       LOGICAL*1 LIVE\n       REAL*8    VALUE\n      END TYPE MIXED\n      TYPE(MIXED) STUFF(100)\n", "target": ">>> True\nTrue\n>>> not True\nFalse\n>>> \n>>> False + 0\n0\n>>> True + 0\n1\n>>> False + 0j\n0j\n>>> True * 3.141\n3.141\n>>> \n>>> not 0\nTrue\n>>> not not 0\nFalse\n>>> not 1234\nFalse\n>>> bool(0.0)\nFalse\n>>> bool(0j)\nFalse\n>>> bool(1+2j)\nTrue\n>>> \n>>> bool([])\nFalse\n>>> bool([None])\nTrue\n>>> 'I contain something' if (None,) else 'I am empty'\n'I contain something'\n>>> bool({})\nFalse\n>>> bool(\"\")\nFalse\n>>> bool(\"False\")\nTrue\n"}
{"id": 347555, "name": "Bitmap_Histogram", "source": "Translate Fortran to Python: module RCImageProcess\n  use RCImageBasic\n  implicit none\ncontains\n\n  subroutine get_histogram(img, histogram)\n    type(scimage), intent(in) :: img\n    integer, dimension(0:255), intent(out) :: histogram\n    \n    integer :: i\n\n    histogram = 0\n    do i = 0,255\n       histogram(i) = sum(img%channel, img%channel == i)\n    end do\n  end subroutine get_histogram\n\n  function histogram_median(histogram)\n    integer, dimension(0:255), intent(in) :: histogram\n    integer :: histogram_median\n    \n    integer :: from, to, left, right\n\n    from = 0\n    to = 255\n    left = histogram(from)\n    right = histogram(to)\n    do while ( from /= to )\n       if ( left < right ) then\n          from = from + 1\n          left = left + histogram(from)\n       else\n          to = to - 1\n          right = right + histogram(to)\n       end if\n    end do\n    histogram_median = from\n  end function histogram_median\n  \nend module RCImageProcess\n", "target": "from PIL import Image\n\n\nimage = Image.open(\"lena.jpg\")\n\nwidth, height = image.size\n\namount = width * height\n\n\ntotal = 0\n\nbw_image = Image.new('L', (width, height), 0)\n\nbm_image = Image.new('1', (width, height), 0)\n\nfor h in range(0, height):\n    for w in range(0, width):\n        r, g, b = image.getpixel((w, h))\n\n        greyscale = int((r + g + b) / 3)\n        total += greyscale\n\n        bw_image.putpixel((w, h), gray_scale)\n\n\navg = total / amount\n\nblack = 0\nwhite = 1\n\nfor h in range(0, height):\n    for w in range(0, width):\n        v = bw_image.getpixel((w, h))\n\n        if v >= avg:\n            bm_image.putpixel((w, h), white)\n        else:\n            bm_image.putpixel((w, h), black)\n\nbw_image.show()\nbm_image.show()\n"}
{"id": 347556, "name": "LZW compression", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n      MODULE LZW_SHARED_PARAMETERS\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  COMPILER_INTEGER_SIZE = 32 , BITS = 12 , FILEIN = 66 ,     &\n                             & FILEOUT = 99 , MAX_VALUE = (2**BITS) - 1 ,                 &\n                             & MAX_CODE = MAX_VALUE - 1 , MAX_DICTIONARY_SIZE = 5021 ,    &\n                             & SYMBOL_SIZE = 8 , MISSING_BITS = COMPILER_INTEGER_SIZE -   &\n                             & SYMBOL_SIZE\n\n\n\n      INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  concatenatedsymbols\n      INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  prefixcodes\n      INTEGER  ::  the_status = 0\n\n\n \n      END MODULE LZW_SHARED_PARAMETERS\n\n\n\n\n\n\n\n\n\n\n      MODULE CODECIO\n      USE LZW_SHARED_PARAMETERS\n      IMPLICIT NONE\n\n      CONTAINS\n      SUBROUTINE SETOUTPUTCODE(Code)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Code\n      INTENT (IN) Code\n\n\n\n      INTEGER  ::  buffer\n      INTEGER  ::  outputbitbuffer = 0\n      INTEGER  ::  outputbitcount = 0\n      INTEGER  ::  shift\n      INTEGER  ::  shiftedsymbol\n\n      shift = COMPILER_INTEGER_SIZE - BITS - outputbitcount\n      shiftedsymbol = ISHFT(Code , shift)\n      outputbitbuffer = IOR(outputbitbuffer , shiftedsymbol)\n      outputbitcount = outputbitcount + BITS\n \n      DO WHILE(outputbitcount >= SYMBOL_SIZE)\n\n         buffer = ISHFT(outputbitbuffer , -MISSING_BITS)\n         CALL SETRAWBYTE(buffer)\n         outputbitbuffer = ISHFT(outputbitbuffer , SYMBOL_SIZE)\n         outputbitcount = outputbitcount - SYMBOL_SIZE\n      END DO\n      RETURN\n      END SUBROUTINE SETOUTPUTCODE\n \n \n      SUBROUTINE SETRAWBYTE(Symbol)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Symbol\n      INTENT (IN) Symbol\n\n \n      CALL FPUTC(FILEOUT , ACHAR(Symbol))\n      END SUBROUTINE SETRAWBYTE\n \n \n      FUNCTION GETRAWBYTE()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  GETRAWBYTE\n\n\n\n      CHARACTER  ::  bufferedbyte\n\n      CALL FGETC(FILEIN , bufferedbyte , THE_status)\n      GETRAWBYTE = IACHAR(bufferedbyte)\n      END FUNCTION GETRAWBYTE\n \n      FUNCTION GETINPUTCODE()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  GETINPUTCODE\n\n\n\n      INTEGER  ::  inputbitbuffer = 0\n      INTEGER  ::  inputbitcounter = 0\n      INTEGER  ::  integerinputbuff\n      INTEGER  ::  returnn\n      INTEGER  ::  shiftedbit\n\n      DO WHILE( inputbitcounter <= MISSING_BITS )\n\n         integerinputbuff = GETRAWBYTE()\n         shiftedbit = ISHFT(integerinputbuff , MISSING_BITS - inputbitcounter)\n         inputbitbuffer = IOR(inputbitbuffer , shiftedbit)\n         inputbitcounter = inputbitcounter + SYMBOL_SIZE\n      END DO\n \n      returnn = ISHFT(inputbitbuffer , BITS - COMPILER_INTEGER_SIZE)\n      inputbitbuffer = ISHFT(inputbitbuffer , BITS)\n      inputbitcounter = inputbitcounter - BITS\n      GETINPUTCODE = returnn\n      RETURN\n      END FUNCTION GETINPUTCODE\nend module codecIO\n\n\n\n\n\n\n\n\n\n      MODULE LZW_ENCODER\n      USE LZW_SHARED_PARAMETERS\n      USE CODECIO\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  HASH_SHIFT = BITS - SYMBOL_SIZE\n\n\n\n      INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  symbolvalues\n      CONTAINS\n      SUBROUTINE COMPRESS()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  codedsymbol\n      INTEGER  ::  my_index\n      INTEGER  ::  nextsymbol\n      INTEGER  ::  symbol\n      CHARACTER  ::  bufferedbyte\n\n      nextsymbol = COMPILER_INTEGER_SIZE*SYMBOL_SIZE\n      SYMbolvalues(:) = -1\n \n\n      CALL FGETC(FILEIN , bufferedbyte , THE_status)\n      codedsymbol = IACHAR(bufferedbyte)\n\n      DO WHILE(THE_status == 0)\n\n          CALL FGETC(FILEIN , bufferedbyte , THE_status)\n          symbol = IACHAR(bufferedbyte)\n         IF( THE_status/=0 )CYCLE\n \n         my_index = GETPOSITIONONDICTIONARY(codedsymbol , symbol)\n         IF( SYMbolvalues(my_index)/= - 1 )THEN\n            codedsymbol = SYMbolvalues(my_index)\n         ELSE\n            IF( nextsymbol<=MAX_CODE )THEN\n               SYMbolvalues(my_index) = nextsymbol\n               nextsymbol = nextsymbol + 1\n               PREfixcodes(my_index) = codedsymbol\n               CONcatenatedsymbols(my_index) = symbol\n            END IF\n            CALL SETOUTPUTCODE(codedsymbol)\n            codedsymbol = symbol\n         END IF\n      END DO\n      CALL SETOUTPUTCODE(codedsymbol)\n      CALL SETOUTPUTCODE(MAX_VALUE)\n      CALL SETOUTPUTCODE(0)\n      END SUBROUTINE COMPRESS\n \nfunction getPositionOnDictionary(hashPrefix, hashSymbol)\n      integer, intent(in) :: hashPrefix\n      integer, intent(in) :: hashSymbol\n      integer             :: getPositionOnDictionary\n      integer             :: index\n      integer             :: offset\n\n      index = ishft(hashSymbol, HASH_SHIFT)\n      index = ieor(index, hashPrefix)\n      if (index == 0) then\n        offset = 1\n      else\n        offset = MAX_DICTIONARY_SIZE - index\n      endif\n\n      do\n        if (symbolValues(index) == -1) then\n          getPositionOnDictionary = index\n          exit\n        endif\n\n        if (prefixCodes(index) == hashPrefix .and. &\n            & concatenatedSymbols(index) == hashSymbol) then\n          getPositionOnDictionary = index\n          exit\n        endif\n\n        index = index - offset\n        if (index < 0) then\n          index = index + MAX_DICTIONARY_SIZE\n        endif\n      end do\n      return\n    end function\n\nend module LZW_Encoder\n\n\n\n\n\n\n\n\n\n      MODULE LZW_DECODER\n      USE LZW_SHARED_PARAMETERS\n      USE CODECIO\n      IMPLICIT NONE\n\n\n\n      TYPE :: DECODE_BUFFER_STACK\n         INTEGER , DIMENSION(0:MAX_DICTIONARY_SIZE)  ::  DECODERSTACK\n         INTEGER  ::  TOP\n      END TYPE DECODE_BUFFER_STACK\n\n\n\n      TYPE(DECODE_BUFFER_STACK)  ::  stack\n      CONTAINS\n\n\n      SUBROUTINE DECOMPRESS()\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  newsymbol\n      INTEGER  ::  nextsymbol\n      INTEGER  ::  oldsymbol\n      INTEGER  ::  popedsymbol\n      INTEGER  ::  symbol\n\n      nextsymbol = COMPILER_INTEGER_SIZE*SYMBOL_SIZE\n      oldsymbol = GETINPUTCODE()\n      symbol = oldsymbol\n \n      CALL SETRAWBYTE(oldsymbol)\n \n      DO\n         newsymbol = GETINPUTCODE()\n \n         IF( newsymbol==MAX_VALUE )RETURN\n \n         IF( newsymbol>=nextsymbol )THEN\n            STAck%DECODERSTACK(0) = symbol\n            CALL DECODESYMBOL(STAck%DECODERSTACK(1:) , oldsymbol)\n         ELSE\n            CALL DECODESYMBOL(STAck%DECODERSTACK(:) , newsymbol)\n         END IF\n \n         symbol = STAck%DECODERSTACK(STAck%TOP)\n \n         DO WHILE ( STAck%TOP>=0 )\n            popedsymbol = STAck%DECODERSTACK(STAck%TOP)\n            CALL SETRAWBYTE(popedsymbol)\n            STAck%TOP = STAck%TOP - 1\n         END DO\n \n         IF( nextsymbol<=MAX_CODE )THEN\n            PREfixcodes(nextsymbol) = oldsymbol\n            CONcatenatedsymbols(nextsymbol) = symbol\n            nextsymbol = nextsymbol + 1\n         END IF\n         oldsymbol = newsymbol\n      END DO\n      RETURN\n      END SUBROUTINE DECOMPRESS\n  \n      SUBROUTINE DECODESYMBOL(Buffer , Code)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  Code\n      INTEGER , DIMENSION(:)  ::  Buffer\n      INTENT (IN) Code\n      INTENT (INOUT) Buffer\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  j\n      INTEGER  ::  symbol\n\n      j = 0\n      symbol = Code\n      STAck%TOP = 0\n      DO WHILE ( symbol>=COMPILER_INTEGER_SIZE*SYMBOL_SIZE )\n \n \n         IF( j>=MAX_CODE )THEN\n            PRINT * , \"Decoding error\"\n            STOP\n         END IF\n \n         i = STAck%TOP + 1\n         Buffer(i) = CONcatenatedsymbols(symbol)\n         symbol = PREfixcodes(symbol)\n         STAck%TOP = STAck%TOP + 1\n         j = j + 1\n      END DO\n      i = j + 1\n      Buffer(i) = symbol\n      END SUBROUTINE DECODESYMBOL\nend module LZW_Decoder\n\n\n\n\n\n\n\n\n\n \n      MODULE LZW\n      USE LZW_SHARED_PARAMETERS\n      USE LZW_ENCODER\n      USE LZW_DECODER\n      IMPLICIT NONE\n      CONTAINS\n      SUBROUTINE INIT(Input , Output , Operation , Filename)\n      IMPLICIT NONE\n\n\n\n      CHARACTER(100)  ::  Filename\n      CHARACTER(100)  ::  Input\n      CHARACTER(1)  ::  Operation\n      CHARACTER(100)  ::  Output\n      INTENT (IN) Filename , Input , Operation , Output\n\n      IF( Operation/='d' .AND. Operation/='e' )THEN\n         PRINT * , \"Usage: \" // TRIM(Filename) // \" <operation> input output\"\n         PRINT * , \"Possible operations: \"\n         PRINT * , \"    e -> encode (compress)\"\n         PRINT * , \"    d -> decode (inflate)\"\n         STOP\n      END IF\n \n      OPEN(UNIT = FILEIN , FILE = Input , ACTION = \"read\" , STATUS = \"old\" ,              &\n          &ACCESS = 'stream' , FORM = \"formatted\")\n      OPEN(UNIT = FILEOUT , FILE = Output , ACTION = \"write\" , STATUS = \"replace\" ,       &\n         & ACCESS = 'stream' , FORM = \"formatted\")\n \n      IF( Operation=='d' )THEN\n         PRINT * , \"Decoding...\"\n         CALL DECOMPRESS()\n      ELSE\n         PRINT * , \"Encoding...\"\n         CALL COMPRESS()\n      END IF\n \n      CLOSE(UNIT = FILEIN)\n      CLOSE(UNIT = FILEOUT)\n      END SUBROUTINE INIT\nend module LZW\n\n      PROGRAM MAIN\n      USE LZW\n      IMPLICIT NONE\n\n\n\n      CHARACTER(100)  ::  filename\n      REAL  ::  finish\n      CHARACTER(100)  ::  input\n      CHARACTER(1)  ::  operation\n      CHARACTER(100)  ::  output\n      REAL  ::  start\n\n      CALL GETARG(0 , filename)\n      CALL GETARG(1 , operation)\n      CALL GETARG(2 , input)\n      CALL GETARG(3 , output)\n      CALL CPU_TIME(start)\n      CALL INIT(input , output , operation , filename)\n      CALL CPU_TIME(finish)\n      PRINT '(\"Time = \",f6.3,\" seconds.\")' , finish - start\n      END PROGRAM MAIN\n", "target": "def compress(uncompressed):\n    \n\n    \n    dict_size = 256\n    dictionary = dict((chr(i), i) for i in range(dict_size))\n    \n\n    w = \"\"\n    result = []\n    for c in uncompressed:\n        wc = w + c\n        if wc in dictionary:\n            w = wc\n        else:\n            result.append(dictionary[w])\n            \n            dictionary[wc] = dict_size\n            dict_size += 1\n            w = c\n\n    \n    if w:\n        result.append(dictionary[w])\n    return result\n\n\ndef decompress(compressed):\n    \n    from io import StringIO\n\n    \n    dict_size = 256\n    dictionary = dict((i, chr(i)) for i in range(dict_size))\n    \n\n    \n    \n    result = StringIO()\n    w = chr(compressed.pop(0))\n    result.write(w)\n    for k in compressed:\n        if k in dictionary:\n            entry = dictionary[k]\n        elif k == dict_size:\n            entry = w + w[0]\n        else:\n            raise ValueError('Bad compressed k: %s' % k)\n        result.write(entry)\n\n        \n        dictionary[dict_size] = w + entry[0]\n        dict_size += 1\n\n        w = entry\n    return result.getvalue()\n\n\n\ncompressed = compress('TOBEORNOTTOBEORTOBEORNOT')\nprint (compressed)\ndecompressed = decompress(compressed)\nprint (decompressed)\n"}
{"id": 347557, "name": "Wireworld", "source": "Translate Fortran to Python: program Wireworld\n  implicit none\n \n  integer, parameter :: max_generations = 12\n  integer :: nrows = 0, ncols = 0, maxcols = 0\n  integer :: gen, ierr = 0\n  integer :: i, j\n  character(1), allocatable :: cells(:,:)\n  character(10) :: form, sub\n  character(80) :: buff\n\n\n  open(unit=8, file=\"wwinput.txt\")\n    \n\n  do \n    read(8, \"(a)\", iostat=ierr) buff\n    if(ierr /= 0) exit\n    nrows = nrows + 1\n    ncols = len_trim(buff)\n    if(ncols > maxcols) maxcols = ncols\n  end do\n\n\n  allocate(cells(0:nrows+1, 0:maxcols+1))\n  cells = \" \"\n\n\n  rewind(8)\n  do i = 1, nrows\n    read(8, \"(a)\", iostat=ierr) buff\n    if(ierr /= 0) exit\n    do j = 1, maxcols\n      cells(i, j) = buff(j:j)\n    end do\n  end do\n  close(8)\n\n\n  write(sub, \"(i8)\") maxcols\n  form = \"(\" // trim(adjustl(sub)) // \"a1)\"\n       \n  do gen = 0, max_generations\n    write(*, \"(/a, i0)\") \"Generation \", gen\n    do i = 1, nrows\n      write(*, form) cells(i, 1:maxcols)\n    end do\n    call nextgen(cells)\n  end do\n  deallocate(cells)\n  \n contains\n  \n  subroutine Nextgen(cells)\n    character, intent(in out) :: cells(0:,0:)\n    character :: buffer(0:size(cells, 1)-1, 0:size(cells, 2)-1)\n    integer :: i, j, h\n   \n     buffer = cells   \n     do i = 1, size(cells, 1)-2\n        do j = 1, size(cells, 2)-2\n          select case (buffer(i, j))\n            case(\" \")\n              \n                \n            case(\"H\")\n              \n              cells(i, j) = \"t\"\n   \n            case(\"t\")\n              \n              cells(i, j) = \".\"\n   \n            case (\".\")\n              \n              \n              \n              \n              h = sum(count(buffer(i-1:i+1, j-1:j+1) == \"H\", 1)) \n              if(h == 1 .or. h == 2) cells(i, j) = \"H\"\n          end select       \n        end do\n     end do\n  end subroutine Nextgen\nend program Wireworld\n", "target": "\n\nfrom io import StringIO\nfrom collections import namedtuple\nfrom pprint import pprint as pp\nimport copy\n\nWW = namedtuple('WW', 'world, w, h')\nhead, tail, conductor, empty = allstates = 'Ht. '\n\n\ninfile = StringIO()\n\ndef readfile(f):\n    \n    world  = [row.rstrip('\\r\\n') for row in f]\n    height = len(world)\n    width  = max(len(row) for row in world)\n    \n    nonrow = [ \" %*s \" % (-width, \"\") ]\n    world  = nonrow + \\\n               [ \" %*s \" % (-width, row) for row in world ] + \\\n               nonrow   \n    world = [list(row) for row in world]\n    return WW(world, width, height)\n\ndef newcell(currentworld, x, y):\n    istate = currentworld[y][x]\n    assert istate in allstates, 'Wireworld cell set to unknown value \"%s\"' % istate\n    if istate == head:\n        ostate = tail\n    elif istate == tail:\n        ostate = conductor\n    elif istate == empty:\n        ostate = empty\n    else: \n        n = sum( currentworld[y+dy][x+dx] == head\n                 for dx,dy in ( (-1,-1), (-1,+0), (-1,+1),\n                                (+0,-1),          (+0,+1),\n                                (+1,-1), (+1,+0), (+1,+1) ) )\n        ostate = head if 1 <= n <= 2 else conductor\n    return ostate\n\ndef nextgen(ww):\n    'compute next generation of wireworld'\n    world, width, height = ww\n    newworld = copy.deepcopy(world)\n    for x in range(1, width+1):\n        for y in range(1, height+1):\n            newworld[y][x] = newcell(world, x, y)\n    return WW(newworld, width, height)\n\ndef world2string(ww):\n    return '\\n'.join( ''.join(row[1:-1]).rstrip() for row in ww.world[1:-1] )\n\nww = readfile(infile)\ninfile.close()\n\nfor gen in range(10):\n    print ( (\"\\n%3i \" % gen) + '=' * (ww.w-4) + '\\n' )\n    print ( world2string(ww) )\n    ww = nextgen(ww)\n"}
{"id": 347558, "name": "Ulam spiral (for primes)", "source": "Translate Fortran to Python: program ulam\n  implicit none\n\n  integer, parameter :: nsize = 49\n  integer :: i, j, n, x, y\n  integer :: a(nsize*nsize) = (/ (i, i = 1, nsize*nsize) /)\n  character(1)  :: spiral(nsize, nsize) = \" \" \n  character(2)  :: sstr\n  character(10) :: fmt\n  \n  n = 1\n  x = nsize / 2 + 1\n  y = x\n  if(isprime(a(n))) spiral(x, y) = \"O\"\n  n = n + 1\n\n  do i = 1, nsize-1, 2\n    do j = 1, i\n      x = x + 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n\n    do j = 1, i\n      y = y - 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n\n    do j = 1, i+1\n      x = x - 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n\n    do j = 1, i+1\n      y = y + 1\n      if(isprime(a(n))) spiral(x, y) = \"O\"\n      n = n + 1\n    end do\n  end do\n\n  do j = 1, nsize-1\n    x = x + 1\n    if(isprime(a(n))) spiral(x, y) = \"O\"\n    n = n + 1\n  end do\n\n  write(sstr, \"(i0)\") nsize\n  fmt = \"(\" // sstr // \"(a,1x))\"\n  do i = 1, nsize\n    write(*, fmt) spiral(:, i)\n  end do\n\ncontains\n\nfunction isprime(number)\n  logical :: isprime\n  integer, intent(in) :: number\n  integer :: i\n \n  if(number == 2) then\n    isprime = .true.\n  else if(number < 2 .or. mod(number,2) == 0) then\n    isprime = .false.\n  else\n    isprime = .true.\n    do i = 3, int(sqrt(real(number))), 2\n      if(mod(number,i) == 0) then\n        isprime = .false.\n        exit\n      end if\n    end do\n  end if\nend function\nend program\n", "target": "\nfrom __future__ import print_function, division\nfrom math import sqrt\n\ndef cell(n, x, y, start=1):\n    d, y, x = 0, y - n//2, x - (n - 1)//2\n    l = 2*max(abs(x), abs(y))\n    d = (l*3 + x + y) if y >= x else (l - x - y)\n    return (l - 1)**2 + d + start - 1\n\ndef show_spiral(n, symbol='\n    top = start + n*n + 1\n    is_prime = [False,False,True] + [True,False]*(top//2)\n    for x in range(3, 1 + int(sqrt(top))):\n        if not is_prime[x]: continue\n        for i in range(x*x, top, x*2):\n            is_prime[i] = False\n\n    cell_str = lambda x: f(x) if is_prime[x] else space\n    f = lambda _: symbol \n\n    if space == None: space = ' '*len(symbol)\n\n    if not len(symbol): \n        max_str = len(str(n*n + start - 1))\n        if space == None: space = '.'*max_str + ' '\n        f = lambda x: ('%' + str(max_str) + 'd ')%x\n\n    for y in range(n):\n        print(''.join(cell_str(v) for v in [cell(n, x, y, start) for x in range(n)]))\n    print()\n\nshow_spiral(10, symbol=u'\u265e', space=u'\u2658') \nshow_spiral(9, symbol='', space=' - ')\n\n\n"}
{"id": 347559, "name": "Text processing_1", "source": "Translate Fortran to Python: Crunches a set of hourly data. Starts with a date, then 24 pairs of value,indicator for that day, on one line.\n      INTEGER Y,M,D\t\t\n      INTEGER GOOD(24)\t\t\n      REAL*8 V(24),VTOT,T\t\n      INTEGER NV,N,NB\t\t\n      INTEGER I,NREC,HIC\t\n      INTEGER BI,BN,BBI,BBN\t\n      CHARACTER*10 BDATE,BBDATE\t\n      LOGICAL INGOOD\t\t\n      INTEGER IN,MSG\t\t\n      CHARACTER*666 ACARD\t\n      IN = 10\t\t\n      MSG = 6\t\t\n      OPEN (IN,FILE=\"Readings1.txt\", FORM=\"FORMATTED\",\t\n     1 STATUS =\"OLD\",ACTION=\"READ\")\t\t\t\n      NB = 0\t\t\n      NV = 0\t\t\n      VTOT = 0\t\t\n      NREC = 0\t\t\n      HIC = 0\t\t\n      INGOOD = .TRUE.\t\n      BBN = 0\t\t\nChew into the file.\n   10 READ (IN,11,END=100,ERR=666) L,ACARD(1:MIN(L,LEN(ACARD)))\t\n      NREC = NREC + 1\t\t\n   11 FORMAT (Q,A)\t\t\n      READ (ACARD,12,END=600,ERR=601) Y,M,D\t\n   12 FORMAT (I4,2(1X,I2))\t\t\t\t\n      READ (ACARD(11:L),*,END=600,ERR=601) (V(I),GOOD(I),I = 1,24)\t\nCalculations. Could use COUNT(array) and SUM(array), but each requires its own pass through the array.\n   20 T = 0\t\t\n      N = 0\t\t\n      DO I = 1,24\t\n        IF (GOOD(I).GT.0) THEN\t\n          N = N + 1\t\t\n          T = T + V(I)\t\t\n          IF (.NOT.INGOOD) THEN\t\n            INGOOD = .TRUE.\t\n            IF (BN.GT.BBN) THEN\t\n              BBN = BN\t\t\n              BBI = BI\t\t\n              BBDATE = BDATE\t\n            END IF\t\t\n          END IF\t\t\n         ELSE\t\t\n          IF (INGOOD) THEN\t\n            INGOOD = .FALSE.\t\n            BDATE = ACARD(1:10)\t\n            BI = I\t\t\n            BN = 0\t\t\n          END IF\t\t\n          BN = BN + 1\t\n        END IF\t\t\n      END DO\t\t\nCommentary for the day's data..\n      IF (N.LE.0) THEN\t\n        WRITE (MSG,21) NREC,ACARD(1:10)\t\n   21   FORMAT (\"Record\",I8,\" (\",A,\") has no good data\n       ELSE\t\t\t\n        WRITE(MSG,22) NREC,ACARD(1:10),N,T/N\t\n   22   FORMAT(\"Record\",I8,\" (\",A,\")\",I3,\" good, average\",F9.3)\t\n        NB = NB + 24 - N\t\n        NV = NV + N\t\t\n        VTOT = VTOT + T\t\t\n      END IF\t\t\t\n      GO TO 10\t\t\n\nComplaints. Should really distinguish between trouble in the date part and in the data part.\n  600 WRITE (MSG,*) '\"END\" declared - insufficient data?'\t\n      GO TO 602\t\t\t\t\n  601 WRITE (MSG,*) '\"ERR\" declared - improper number format?'\t\n  602 WRITE (MSG,603) NREC,L,ACARD(1:L)\t\n  603 FORMAT(\" Record \",I0,\", length \",I0,\" reads \",A)\t\n      HIC = HIC + 1\t\t\t\n      IF (HIC.LE.12) GO TO 10\t\t\n      STOP \"Enough distaste.\"\t\t\n  666 WRITE (MSG,101) NREC,\"format error\n      GO TO 900\t\t\t\t\n\nClosedown.\n  100 WRITE (MSG,101) NREC,\"then end-of-file\"\t\n  101 FORMAT (\" Record \",I0,\": \",A)\t\t\n      WRITE (MSG,102) NV,NB,VTOT/NV\t\t\n  102 FORMAT (I8,\" values, \",I0,\" bad. Average\",F9.4)\t\n      IF (BBN.LE.0) THEN\t\t\n        WRITE (MSG,*) \"No bad value presented, so no longest run.\"\t\n       ELSE\t\t\t\t\n        WRITE (MSG,103) BBN,BBI,BBDATE\t\n  103   FORMAT (\"Longest bad run: \",I0,\", starting hour \",I0,\" on \",A)\t\n      END IF\t\t\t\n  900 CLOSE(IN)\t\t\n      END\t\n", "target": "import fileinput\nimport sys\n\nnodata = 0;             \nnodata_max=-1;          \nnodata_maxline=[];      \n\ntot_file = 0            \nnum_file = 0            \n\ninfiles = sys.argv[1:]\n\nfor line in fileinput.input():\n  tot_line=0;             \n  num_line=0;             \n\n  \n  field = line.split()\n  date  = field[0]\n  data  = [float(f) for f in field[1::2]]\n  flags = [int(f)   for f in field[2::2]]\n\n  for datum, flag in zip(data, flags):\n    if flag<1:\n      nodata += 1\n    else:\n      \n      if nodata_max==nodata and nodata>0:\n        nodata_maxline.append(date)\n      if nodata_max<nodata and nodata>0:\n        nodata_max=nodata\n        nodata_maxline=[date]\n      \n      nodata=0; \n      \n      tot_line += datum\n      num_line += 1\n\n  \n  tot_file += tot_line\n  num_file += num_line\n\n  print \"Line: %11s  Reject: %2i  Accept: %2i  Line_tot: %10.3f  Line_avg: %10.3f\" % (\n        date, \n        len(data) -num_line, \n        num_line, tot_line, \n        tot_line/num_line if (num_line>0) else 0)\n\nprint \"\"\nprint \"File(s)  = %s\" % (\", \".join(infiles),)\nprint \"Total    = %10.3f\" % (tot_file,)\nprint \"Readings = %6i\" % (num_file,)\nprint \"Average  = %10.3f\" % (tot_file / num_file,)\n\nprint \"\\nMaximum run(s) of %i consecutive false readings ends at line starting with date(s): %s\" % (\n    nodata_max, \", \".join(nodata_maxline))\n"}
{"id": 347560, "name": "Bitmap_B\u00e9zier curves_Cubic", "source": "Translate Fortran to Python: subroutine cubic_bezier(img, p1, p2, p3, p4, color)\n  type(rgbimage), intent(inout) :: img\n  type(point), intent(in) :: p1, p2, p3, p4\n  type(rgb), intent(in) :: color\n\n  integer :: i, j\n  real :: pts(0:N_SEG,0:1), t, a, b, c, d, x, y\n\n  do i = 0, N_SEG\n     t = real(i) / real(N_SEG)\n     a = (1.0 - t)**3.0\n     b = 3.0 * t * (1.0 - t)**2\n     c = 3.0 * (1.0 - t) * t**2\n     d = t**3.0\n     x = a * p1%x + b * p2%x + c * p3%x + d * p4%x\n     y = a * p1%y + b * p2%y + c * p3%y + d * p4%y\n     pts(i,0) = x\n     pts(i,1) = y\n  end do\n\n  do i = 0, N_SEG-1\n     j = i + 1\n     call draw_line(img, point(pts(i,0), pts(i,1)), &\n                    point(pts(j,0), pts(j,1)), color)\n  end do\n\nend subroutine cubic_bezier\n", "target": "def cubicbezier(self, x0, y0, x1, y1, x2, y2, x3, y3, n=20):\n    pts = []\n    for i in range(n+1):\n        t = i / n\n        a = (1. - t)**3\n        b = 3. * t * (1. - t)**2\n        c = 3.0 * t**2 * (1.0 - t)\n        d = t**3\n        \n        x = int(a * x0 + b * x1 + c * x2 + d * x3)\n        y = int(a * y0 + b * y1 + c * y2 + d * y3)\n        pts.append( (x, y) )\n    for i in range(n):\n        self.line(pts[i][0], pts[i][1], pts[i+1][0], pts[i+1][1])\nBitmap.cubicbezier = cubicbezier\n\nbitmap = Bitmap(17,17)\nbitmap.cubicbezier(16,1, 1,4, 3,16, 15,11)\nbitmap.chardisplay()\n\n\n\n"}
{"id": 347561, "name": "Hello world_Line printer", "source": "Translate Fortran to Python:       WRITE (6,1)\n    1 FORMAT (\"+HELLO WORLD\n      END\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 347562, "name": "Hello world_Line printer", "source": "Translate Fortran to Python:       WRITE (6,1)\n    1 FORMAT (\"+HELLO WORLD\n      END\n", "target": "lp = open(\"/dev/lp0\")\nlp.write(\"Hello World!\\n\")\nlp.close()\n"}
{"id": 347563, "name": "Magic squares of odd order", "source": "Translate Fortran to Python: program Magic_Square\n  implicit none\n\n  integer, parameter :: order = 15\n  integer :: i, j\n \n  write(*, \"(a, i0)\") \"Magic Square Order: \", order\n  write(*, \"(a)\")     \"----------------------\"\n  do i = 1, order\n    do j = 1, order\n      write(*, \"(i4)\", advance = \"no\") f1(order, i, j)\n    end do\n    write(*,*)\n  end do\n  write(*, \"(a, i0)\") \"Magic number = \", f2(order)\n\ncontains\n\ninteger function f1(n, x, y)\n  integer, intent(in) :: n, x, y\n\n  f1 = n * mod(x + y - 1 + n/2, n) + mod(x + 2*y - 2, n) + 1\nend function\n\ninteger function f2(n)\n  integer, intent(in) :: n\n\n  f2 = n * (1 + n * n) / 2\nend function\nend program\n", "target": ">>> def magic(n):\n    for row in range(1, n + 1):\n        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in\n                       (n * ((row + col - 1 + n // 2) % n) +\n                       ((row + 2 * col - 2) % n) + 1\n                       for col in range(1, n + 1))))\n    print('\\nAll sum to magic number %i' % ((n * n + 1) * n // 2))\n\n    \n>>> for n in (5, 3, 7):\n\tprint('\\nOrder %i\\n=======' % n)\n\tmagic(n)\n\n\t\n\nOrder 5\n=======\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9\n\nAll sum to magic number 65\n\nOrder 3\n=======\n8 1 6\n3 5 7\n4 9 2\n\nAll sum to magic number 15\n\nOrder 7\n=======\n30 39 48  1 10 19 28\n38 47  7  9 18 27 29\n46  6  8 17 26 35 37\n 5 14 16 25 34 36 45\n13 15 24 33 42 44  4\n21 23 32 41 43  3 12\n22 31 40 49  2 11 20\n\nAll sum to magic number 175\n>>>\n"}
{"id": 347564, "name": "Magic squares of odd order", "source": "Translate Fortran to Python: program Magic_Square\n  implicit none\n\n  integer, parameter :: order = 15\n  integer :: i, j\n \n  write(*, \"(a, i0)\") \"Magic Square Order: \", order\n  write(*, \"(a)\")     \"----------------------\"\n  do i = 1, order\n    do j = 1, order\n      write(*, \"(i4)\", advance = \"no\") f1(order, i, j)\n    end do\n    write(*,*)\n  end do\n  write(*, \"(a, i0)\") \"Magic number = \", f2(order)\n\ncontains\n\ninteger function f1(n, x, y)\n  integer, intent(in) :: n, x, y\n\n  f1 = n * mod(x + y - 1 + n/2, n) + mod(x + 2*y - 2, n) + 1\nend function\n\ninteger function f2(n)\n  integer, intent(in) :: n\n\n  f2 = n * (1 + n * n) / 2\nend function\nend program\n", "target": ">>> def magic(n):\n    for row in range(1, n + 1):\n        print(' '.join('%*i' % (len(str(n**2)), cell) for cell in\n                       (n * ((row + col - 1 + n // 2) % n) +\n                       ((row + 2 * col - 2) % n) + 1\n                       for col in range(1, n + 1))))\n    print('\\nAll sum to magic number %i' % ((n * n + 1) * n // 2))\n\n    \n>>> for n in (5, 3, 7):\n\tprint('\\nOrder %i\\n=======' % n)\n\tmagic(n)\n\n\t\n\nOrder 5\n=======\n17 24  1  8 15\n23  5  7 14 16\n 4  6 13 20 22\n10 12 19 21  3\n11 18 25  2  9\n\nAll sum to magic number 65\n\nOrder 3\n=======\n8 1 6\n3 5 7\n4 9 2\n\nAll sum to magic number 15\n\nOrder 7\n=======\n30 39 48  1 10 19 28\n38 47  7  9 18 27 29\n46  6  8 17 26 35 37\n 5 14 16 25 34 36 45\n13 15 24 33 42 44  4\n21 23 32 41 43  3 12\n22 31 40 49  2 11 20\n\nAll sum to magic number 175\n>>>\n"}
{"id": 347565, "name": "Sutherland-Hodgman polygon clipping", "source": "Translate Fortran to Python: module SutherlandHodgmanUtil\n  \n\n  \n  type polygon\n    \n    \n    integer :: n\n    double precision, dimension(:,:), allocatable :: vertex\n  end type polygon\n  \n  contains \n  \n  \n  subroutine sutherlandHodgman( ref, clip, outputPolygon )\n    \n  \n    \n    type(polygon) :: ref, clip, outputPolygon\n  \n    \n    type(polygon) :: workPolygon               \n    double precision, dimension(2) :: y1,y2    \n    integer :: i  \n  \n    \n    \n    allocate(workPolygon%vertex( ref%n+clip%n , 2 ))\n    \n    \n    workPolygon%n = clip%n\n    workPolygon%vertex(1:workPolygon%n,:) = clip%vertex(1:workPolygon%n,:)\n\n    do i=1,ref%n-1 \n      y1(:) = ref%vertex(i,:)   \n      y2(:) = ref%vertex(i+1,:) \n  \n      \n      call edgeClipping( workPolygon, y1, y2, outputPolygon)\n      \n      workPolygon%n = outputPolygon%n\n      workPolygon%vertex(1:workPolygon%n,:) = outputPolygon%vertex(1:workPolygon%n,:)\n\n    end do \n    deallocate(workPolygon%vertex)\n  end subroutine sutherlandHodgman\n  \n  \n  subroutine edgeClipping( poly, y1, y2, outputPoly )\n    \n    \n    type(polygon) :: poly, outputPoly\n    double precision, dimension(2) :: y1, y2, x1, x2, intersecPoint\n    integer ::  i, c\n    \n    c = 0 \n    \n    do i=1,poly%n-1 \n      x1(:) = poly%vertex(i,:)   \n      x2(:) = poly%vertex(i+1,:) \n      \n      if ( inside(x1, y1, y2) ) then \n        if ( inside(x2, y1, y2) ) then \n          \n          c = c+1\n          outputPoly%vertex(c,:) = x2(:)\n\n        else \n          intersecPoint = intersection(x1, x2, y1,y2)\n          c = c+1\n          outputPoly%vertex(c,:) = intersecPoint(:)\n        end if\n      else \n        if ( inside(x2, y1, y2) ) then\n          intersecPoint = intersection(x1, x2, y1,y2)\n          c = c+1\n          outputPoly%vertex(c,:) = intersecPoint(:)\n          \n          c = c+1\n          outputPoly%vertex(c,:) = x2(:)\n        end if\n      end if\n    end do\n    \n    if (c .gt. 0) then\n      \n      if ( (outputPoly%vertex(1,1) .ne. outputPoly%vertex(c,1)) .or. & \n           (outputPoly%vertex(1,2) .ne. outputPoly%vertex(c,2)))  then\n        c=c+1\n        outputPoly%vertex(c,:) = outputPoly%vertex(1,:)\n      end if\n    end if\n    \n    outputPoly%n = c\n  end subroutine edgeClipping\n  \n  \n  function intersection( x1, x2, y1, y2)\n    \n    \n\n    \n    double precision, dimension(2) :: x1, x2, &  \n                                      y1, y2     \n    \n    double precision, dimension(2) :: intersection, vx, vy, x1y1 \n    double precision :: a\n  \n    vx(:) = x2(:) - x1(:) \n    vy(:) = y2(:) - y1(:)\n\n    \n    if ( crossProduct(vx,vy) .eq. 0.d0) then\n      x1y1(:) = y1(:) - x1(:)\n      \n      if ( crossProduct(x1y1,vx) .eq. 0.d0) then\n        \n        intersection(:) = x2(:)\n      end if\n    else \n      \n      \n      \n      \n      \n      \n      \n      \n     \n      x1y1(:) = y1(:) - x1(:) \n      \n      a = crossProduct(x1y1,vy)/crossProduct(vx,vy)\n      \n      if ( (a .gt. 1.d0) .or. (a .lt. 0)) then\n        \n      else\n        intersection(:) = x1(:) + a*vx(:)\n      end if\n    end if\n\n  end function intersection\n  \n  \n  \n  function inside( p, y1, y2)\n    \n    \n    double precision, dimension(2) :: p, y1, y2, v1, v2\n    logical :: inside\n    v1(:) = y2(:) -  y1(:)\n    v2(:) = p(:)  -  y1(:)  \n    if ( crossProduct(v1,v2) .ge. 0.d0) then\n      inside = .true.\n    else \n      inside = .false.\n    end if\n   \n   contains \n  end function inside\n\n  \n  function dotProduct( v1, v2)\n    \n    double precision, dimension(2) :: v1\n    double precision, dimension(2) :: v2\n    double precision :: dotProduct\n    dotProduct = v1(1)*v2(1) + v1(2)*v2(2)\n  end function dotProduct\n\n  \n  function crossProduct( v1, v2)\n    \n    double precision, dimension(2) :: v1\n    double precision, dimension(2) :: v2\n    double precision :: crossProduct\n    crossProduct = v1(1)*v2(2) - v1(2)*v2(1)\n  end function crossProduct\n\nend module SutherlandHodgmanUtil\n\nprogram main\n  \n  \n  use SutherlandHodgmanUtil, only : polygon, &\n                                    sutherlandHodgman, &\n                                    edgeClipping\n\n  type(polygon) :: p1, p2, res\n  integer :: c, n \n  double precision, dimension(2) :: y1, y2\n  \n  \n\n  \n  p1%n = 10\n  allocate(p1%vertex(p1%n,2))\n  p1%vertex(1,1)=50.d0\n  p1%vertex(1,2)=150.d0\n  \n  p1%vertex(2,1)=200.d0\n  p1%vertex(2,2)=50.d0\n  \n  p1%vertex(3,1)= 350.d0\n  p1%vertex(3,2)= 150.d0\n  \n  p1%vertex(4,1)= 350.d0\n  p1%vertex(4,2)= 300.d0\n  \n  p1%vertex(5,1)= 250.d0\n  p1%vertex(5,2)= 300.d0\n  \n  p1%vertex(6,1)= 200.d0\n  p1%vertex(6,2)= 250.d0\n  \n  p1%vertex(7,1)= 150.d0\n  p1%vertex(7,2)= 350.d0\n  \n  p1%vertex(8,1)= 100.d0\n  p1%vertex(8,2)= 250.d0\n  \n  p1%vertex(9,1)= 100.d0\n  p1%vertex(9,2)= 200.d0\n  \n  p1%vertex(10,1)=  50.d0\n  p1%vertex(10,2)= 150.d0\n \n  y1 = (/ 100.d0, 300.d0 /)\n  y2 = (/ 300.d0, 300.d0 /)\n  \n  \n  p2%n = 5\n  allocate(p2%vertex(p2%n,2))\n\n  p2%vertex(1,1)= 100.d0\n  p2%vertex(1,2)= 100.d0\n  \n  p2%vertex(2,1)= 300.d0\n  p2%vertex(2,2)= 100.d0\n  \n  p2%vertex(3,1)= 300.d0\n  p2%vertex(3,2)= 300.d0\n  \n  p2%vertex(4,1)= 100.d0\n  p2%vertex(4,2)= 300.d0\n  \n  p2%vertex(5,1)= 100.d0\n  p2%vertex(5,2)= 100.d0\n \n  allocate(res%vertex(p1%n+p2%n,2))\n  call sutherlandHodgman( p2, p1, res)\n  write(*,*) \"Suterland-Hodgman\"\n  do c=1, res%n\n    write(*,*) res%vertex(c,1), res%vertex(c,2)\n  end do\n  deallocate(res%vertex)\n\nend program main\n", "target": "def clip(subjectPolygon, clipPolygon):\n   def inside(p):\n      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])\n      \n   def computeIntersection():\n      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]\n      dp = [ s[0] - e[0], s[1] - e[1] ]\n      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]\n      n2 = s[0] * e[1] - s[1] * e[0] \n      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])\n      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]\n\n   outputList = subjectPolygon\n   cp1 = clipPolygon[-1]\n   \n   for clipVertex in clipPolygon:\n      cp2 = clipVertex\n      inputList = outputList\n      outputList = []\n      s = inputList[-1]\n\n      for subjectVertex in inputList:\n         e = subjectVertex\n         if inside(e):\n            if not inside(s):\n               outputList.append(computeIntersection())\n            outputList.append(e)\n         elif inside(s):\n            outputList.append(computeIntersection())\n         s = e\n      cp1 = cp2\n   return(outputList)\n"}
{"id": 347566, "name": "Sorting algorithms_Pancake sort", "source": "Translate Fortran to Python: program Pancake_Demo\n  implicit none\n \n  integer :: list(8) = (/ 1, 4, 7, 2, 5, 8, 3, 6 /)\n \n  call Pancake_sort(list)\n \ncontains\n \nsubroutine Pancake_sort(a)\n  \n  integer, intent(in out) :: a(:)\n  integer :: i, maxpos\n  \n  write(*,*) a\n  do i = size(a), 2, -1\n     \n\n    maxpos = maxloc(a(1:i), 1)\n \n\n    if (maxpos == i) cycle\n \n\n    if (maxpos /= 1) then\n      a(1:maxpos) = a(maxpos:1:-1)\n      write(*,*) a\n    end if\n \n\n    a(1:i) = a(i:1:-1)\n    write(*,*) a\n  end do\n  \nend subroutine\n \nend program Pancake_Demo\n", "target": "tutor = False\n\ndef pancakesort(data):\n    if len(data) <= 1:\n        return data\n    if tutor: print()\n    for size in range(len(data), 1, -1):\n        maxindex = max(range(size), key=data.__getitem__)\n        if maxindex+1 != size:\n            \n            if maxindex != 0:\n                \n                if tutor: print('With: %r doflip  %i'\n                                % ( ' '.join(str(x) for x in data), maxindex+1 ))\n                data[:maxindex+1] = reversed(data[:maxindex+1])\n            \n            if tutor: print('With: %r  doflip %i'\n                                % ( ' '.join(str(x) for x in data), size ))\n            data[:size] = reversed(data[:size])\n    if tutor: print()\n"}
{"id": 347567, "name": "Call a function", "source": "Translate Fortran to Python: program main\nimplicit none\ninteger :: a\ninteger :: f, g\nlogical :: lresult\ninterface\n  integer function h(a,b,c)\n    integer :: a, b\n    integer, optional :: c\n  end function\nend interface\nwrite(*,*) 'no arguments: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'fixed arguments: ', g(5,8,lresult)\nwrite(*,*) '-----------------'\nwrite(*,*) 'optional arguments: ', h(5,8), h(5,8,4)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function with variable arguments: Does not apply\nwrite(*,*) 'An option is to pass arrays of variable lengths.'\nwrite(*,*) '-----------------'\nwrite(*,*) 'named arguments: ', h(c=4,b=8,a=5)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function in statement context: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Fortran passes memory location of variables as arguments.'\nwrite(*,*) 'So an argument can hold the return value.'\nwrite(*,*) 'function result: ', g(5,8,lresult) , ' function successful? ', lresult\nwrite(*,*) '-----------------'\nwrite(*,*) 'Distinguish between built-in and user-defined functions: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Calling a subroutine: '\na = 30\ncall sub(a)\nwrite(*,*) 'Function call: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'All variables are passed as pointers.'\nwrite(*,*) 'Problems can arise if instead of sub(a), one uses sub(10).'\nwrite(*,*) '-----------------'\nend program\n\n\ninteger function f()\nf = 10\nend function\n\n\ninteger function g(a, b, lresult)\ninteger :: a, b\nlogical :: lresult\ng = a+b\nlresult = .TRUE.\nend function\n\n\ninteger function h(a, b, c)\ninteger :: a, b\ninteger, optional :: c\n\nh = a+b\nif(present(c)) then\n  h = h+10*c\nend if\nend function\n\n\nsubroutine sub(a)\ninteger :: a\na = a*100\nwrite(*,*) 'Output of subroutine: ', a\nend subroutine\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 347568, "name": "Call a function", "source": "Translate Fortran to Python: program main\nimplicit none\ninteger :: a\ninteger :: f, g\nlogical :: lresult\ninterface\n  integer function h(a,b,c)\n    integer :: a, b\n    integer, optional :: c\n  end function\nend interface\nwrite(*,*) 'no arguments: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'fixed arguments: ', g(5,8,lresult)\nwrite(*,*) '-----------------'\nwrite(*,*) 'optional arguments: ', h(5,8), h(5,8,4)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function with variable arguments: Does not apply\nwrite(*,*) 'An option is to pass arrays of variable lengths.'\nwrite(*,*) '-----------------'\nwrite(*,*) 'named arguments: ', h(c=4,b=8,a=5)\nwrite(*,*) '-----------------'\nwrite(*,*) 'function in statement context: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Fortran passes memory location of variables as arguments.'\nwrite(*,*) 'So an argument can hold the return value.'\nwrite(*,*) 'function result: ', g(5,8,lresult) , ' function successful? ', lresult\nwrite(*,*) '-----------------'\nwrite(*,*) 'Distinguish between built-in and user-defined functions: Does not apply\nwrite(*,*) '-----------------'\nwrite(*,*) 'Calling a subroutine: '\na = 30\ncall sub(a)\nwrite(*,*) 'Function call: ', f()\nwrite(*,*) '-----------------'\nwrite(*,*) 'All variables are passed as pointers.'\nwrite(*,*) 'Problems can arise if instead of sub(a), one uses sub(10).'\nwrite(*,*) '-----------------'\nend program\n\n\ninteger function f()\nf = 10\nend function\n\n\ninteger function g(a, b, lresult)\ninteger :: a, b\nlogical :: lresult\ng = a+b\nlresult = .TRUE.\nend function\n\n\ninteger function h(a, b, c)\ninteger :: a, b\ninteger, optional :: c\n\nh = a+b\nif(present(c)) then\n  h = h+10*c\nend if\nend function\n\n\nsubroutine sub(a)\ninteger :: a\na = a*100\nwrite(*,*) 'Output of subroutine: ', a\nend subroutine\n", "target": "def no_args():\n    pass\n\nno_args()\n\ndef fixed_args(x, y):\n    print('x=%r, y=%r' % (x, y))\n\nfixed_args(1, 2)        \n\n\nfixed_args(y=2, x=1)\n\n\nmyargs=(1,2) \nfixed_args(*myargs)\n\ndef opt_args(x=1):\n    print(x)\n\nopt_args()              \nopt_args(3.141)         \n\ndef var_args(*v):\n    print(v)\n\nvar_args(1, 2, 3)       \nvar_args(1, (2,3))      \nvar_args()              \n\n\nfixed_args(y=2, x=1)    \n\n\nif 1:\n    no_args()\n\n\nassert no_args() is None\n\ndef return_something():\n    return 1\nx = return_something()\n\ndef is_builtin(x):\n\tprint(x.__name__ in dir(__builtins__))\n\nis_builtin(pow)         \nis_builtin(is_builtin)  \n\n\n\ndef takes_anything(*args, **kwargs):\n    for each in args:\n        print(each)\n    for key, value in sorted(kwargs.items()):\n        print(\"%s:%s\" % (key, value))\n    \n    wrapped_fn(*args, **kwargs)\n    \n    \n\n\n\n\n\n\n\n\n\n"}
{"id": 347569, "name": "Extract file extension", "source": "Translate Fortran to Python:       MODULE TEXTGNASH\t\n       CHARACTER*10 DIGITS\t\t\n       CHARACTER*11 DDIGITS\t\t\n       CHARACTER*13 SDDIGITS\t\t\n       CHARACTER*4  EXPONENTISH\t\t\n       CHARACTER*17 NUMBERISH\t\t\n       CHARACTER*16 HEXLETTERS\t\t\n       CHARACTER*62 DIGILETTERS\t\t\n       CHARACTER*26 LITTLELETTERS,BIGLETTERS\t\n       CHARACTER*52 LETTERS\t\t\n       CHARACTER*66 NAMEISH\t\t\n       CHARACTER*3  ODDITIES\t\t\n       CHARACTER*1 CHARACTER(72)\t\n       EQUIVALENCE\t\t\t\n     1  (CHARACTER( 1),EXPONENTISH,NUMBERISH),\t\n     2  (CHARACTER( 5),SDDIGITS),\t\t\n     3  (CHARACTER( 7),DDIGITS,NAMEISH),\t\n     4  (CHARACTER( 8),DIGITS,HEXLETTERS,DIGILETTERS),\t\n     5  (CHARACTER(18),BIGLETTERS,LETTERS),\t\n     6  (CHARACTER(44),LITTLELETTERS),\t\t\n     7  (CHARACTER(70),ODDITIES)\t\t\n       DATA EXPONENTISH /\"eEdD\"/\t\n       DATA SDDIGITS /\"+-.0123456789\"/\t\n       DATA BIGLETTERS    /\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"/\t\n       DATA LITTLELETTERS /\"abcdefghijklmnopqrstuvwxyz\"/\t\n       DATA ODDITIES /\"_:#\"/\t\t\n\n       CHARACTER*62 GOODEXT\t\n       EQUIVALENCE (CHARACTER(8),GOODEXT)\nc       PARAMETER (GOODEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t\nc     1                    //\"abcdefghijklmnopqrstuvwxyz\"\t\nc     2                    //\"0123456789\")\t\t\t\n       INTEGER MEXT\t\t\n       PARAMETER (MEXT = 28)\t\n       CONTAINS\n        CHARACTER*(MEXT) FUNCTION FEXT(FNAME)\t\n         CHARACTER*(*) FNAME\t\n         INTEGER L1,L2\t\t\n          L2 = LEN(FNAME)\t\n          L1 = L2\t\t\n   10     IF (L1.GT.0) THEN\t\n            IF (INDEX(GOODEXT,FNAME(L1:L1)).GT.0) THEN\t\n              L1 = L1 - 1\t\t\n              GO TO 10\t\t\t\n            END IF\t\t\n            IF (FNAME(L1:L1).EQ.\".\") THEN\t\n              L1 = L1 - 1\t\t\t\n              GO TO 20\t\t\t\t\n            END IF\t\t\n          END IF\t\t\n          L1 = L2\t\t\n   20     FEXT = FNAME(L1 + 1:L2)\t\n        END FUNCTION FEXT\t\n      END MODULE TEXTGNASH\t\n\n      PROGRAM POKE\n      USE TEXTGNASH\n\n      WRITE (6,*) FEXT(\"Picture.jpg\")\n      WRITE (6,*) FEXT(\"http://mywebsite.com/picture/image.png\")\n      WRITE (6,*) FEXT(\"myuniquefile.longextension\")\n      WRITE (6,*) FEXT(\"IAmAFileWithoutExtension\")\n      WRITE (6,*) FEXT(\"/path/to.my/file\")\n      WRITE (6,*) FEXT(\"file.odd_one\")\n      WRITE (6,*)\n      WRITE (6,*) \"Now for the new test collection...\"\n      WRITE (6,*) FEXT(\"http://example.com/download.tar.gz\")\n      WRITE (6,*) FEXT(\"CharacterModel.3DS\")\n      WRITE (6,*) FEXT(\".desktop\")\n      WRITE (6,*) FEXT(\"document\")\n      WRITE (6,*) FEXT(\"document.txt_backup\")\n      WRITE (6,*) FEXT(\"/etc/pam.d/login\")\n      WRITE (6,*) \"Approved characters: \",GOODEXT\n      END\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 347570, "name": "Extract file extension", "source": "Translate Fortran to Python:       MODULE TEXTGNASH\t\n       CHARACTER*10 DIGITS\t\t\n       CHARACTER*11 DDIGITS\t\t\n       CHARACTER*13 SDDIGITS\t\t\n       CHARACTER*4  EXPONENTISH\t\t\n       CHARACTER*17 NUMBERISH\t\t\n       CHARACTER*16 HEXLETTERS\t\t\n       CHARACTER*62 DIGILETTERS\t\t\n       CHARACTER*26 LITTLELETTERS,BIGLETTERS\t\n       CHARACTER*52 LETTERS\t\t\n       CHARACTER*66 NAMEISH\t\t\n       CHARACTER*3  ODDITIES\t\t\n       CHARACTER*1 CHARACTER(72)\t\n       EQUIVALENCE\t\t\t\n     1  (CHARACTER( 1),EXPONENTISH,NUMBERISH),\t\n     2  (CHARACTER( 5),SDDIGITS),\t\t\n     3  (CHARACTER( 7),DDIGITS,NAMEISH),\t\n     4  (CHARACTER( 8),DIGITS,HEXLETTERS,DIGILETTERS),\t\n     5  (CHARACTER(18),BIGLETTERS,LETTERS),\t\n     6  (CHARACTER(44),LITTLELETTERS),\t\t\n     7  (CHARACTER(70),ODDITIES)\t\t\n       DATA EXPONENTISH /\"eEdD\"/\t\n       DATA SDDIGITS /\"+-.0123456789\"/\t\n       DATA BIGLETTERS    /\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"/\t\n       DATA LITTLELETTERS /\"abcdefghijklmnopqrstuvwxyz\"/\t\n       DATA ODDITIES /\"_:#\"/\t\t\n\n       CHARACTER*62 GOODEXT\t\n       EQUIVALENCE (CHARACTER(8),GOODEXT)\nc       PARAMETER (GOODEXT = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\t\nc     1                    //\"abcdefghijklmnopqrstuvwxyz\"\t\nc     2                    //\"0123456789\")\t\t\t\n       INTEGER MEXT\t\t\n       PARAMETER (MEXT = 28)\t\n       CONTAINS\n        CHARACTER*(MEXT) FUNCTION FEXT(FNAME)\t\n         CHARACTER*(*) FNAME\t\n         INTEGER L1,L2\t\t\n          L2 = LEN(FNAME)\t\n          L1 = L2\t\t\n   10     IF (L1.GT.0) THEN\t\n            IF (INDEX(GOODEXT,FNAME(L1:L1)).GT.0) THEN\t\n              L1 = L1 - 1\t\t\n              GO TO 10\t\t\t\n            END IF\t\t\n            IF (FNAME(L1:L1).EQ.\".\") THEN\t\n              L1 = L1 - 1\t\t\t\n              GO TO 20\t\t\t\t\n            END IF\t\t\n          END IF\t\t\n          L1 = L2\t\t\n   20     FEXT = FNAME(L1 + 1:L2)\t\n        END FUNCTION FEXT\t\n      END MODULE TEXTGNASH\t\n\n      PROGRAM POKE\n      USE TEXTGNASH\n\n      WRITE (6,*) FEXT(\"Picture.jpg\")\n      WRITE (6,*) FEXT(\"http://mywebsite.com/picture/image.png\")\n      WRITE (6,*) FEXT(\"myuniquefile.longextension\")\n      WRITE (6,*) FEXT(\"IAmAFileWithoutExtension\")\n      WRITE (6,*) FEXT(\"/path/to.my/file\")\n      WRITE (6,*) FEXT(\"file.odd_one\")\n      WRITE (6,*)\n      WRITE (6,*) \"Now for the new test collection...\"\n      WRITE (6,*) FEXT(\"http://example.com/download.tar.gz\")\n      WRITE (6,*) FEXT(\"CharacterModel.3DS\")\n      WRITE (6,*) FEXT(\".desktop\")\n      WRITE (6,*) FEXT(\"document\")\n      WRITE (6,*) FEXT(\"document.txt_backup\")\n      WRITE (6,*) FEXT(\"/etc/pam.d/login\")\n      WRITE (6,*) \"Approved characters: \",GOODEXT\n      END\n", "target": "import re\ndef extractExt(url):\n  m = re.search(r'\\.[A-Za-z0-9]+$', url)\n  return m.group(0) if m else \"\"\n"}
{"id": 347571, "name": "Solve the no connection puzzle", "source": "Translate Fortran to Python: \n\n\n\nprogram no_connection_puzzle\n\n  implicit none\n\n  \n  integer, parameter :: a = 1\n  integer, parameter :: b = 2\n  integer, parameter :: c = 3\n  integer, parameter :: d = 4\n  integer, parameter :: e = 5\n  integer, parameter :: f = 6\n  integer, parameter :: g = 7\n  integer, parameter :: h = 8\n\n  integer :: holes(a:h)\n\n  call find_solutions (holes, a)\n\ncontains\n\n  recursive subroutine find_solutions (holes, current_hole_index)\n    integer, intent(inout) :: holes(a:h)\n    integer, intent(in) :: current_hole_index\n\n    integer :: peg_number\n\n    \n    \n    do peg_number = 1, 8\n       holes(current_hole_index) = peg_number\n       if (satisfies_the_constraints (holes, current_hole_index)) then\n          if (current_hole_index == h) then\n             call print_solution (holes)\n             write (*, '()')\n          else\n             call find_solutions (holes, current_hole_index + 1)\n          end if\n       end if\n    end do\n  end subroutine find_solutions\n\n  function satisfies_the_constraints (holes, i) result (satisfies)\n    integer, intent(inout) :: holes(a:h)\n    integer, intent(in) :: i    \n    logical :: satisfies\n\n    integer :: j\n\n    \n    \n    satisfies = all (holes(a : i - 1) /= holes(i))\n\n    if (satisfies) then\n       \n       \n       do j = i + 1, h\n          holes(j) = 100 * j\n       end do\n\n       \n       satisfies = 1 < abs (holes(a) - holes(c)) .and.     &\n            &      1 < abs (holes(a) - holes(d)) .and.     &\n            &      1 < abs (holes(a) - holes(e)) .and.     &\n            &      1 < abs (holes(c) - holes(g)) .and.     &\n            &      1 < abs (holes(d) - holes(g)) .and.     &\n            &      1 < abs (holes(e) - holes(g)) .and.     &\n            &      1 < abs (holes(b) - holes(d)) .and.     &\n            &      1 < abs (holes(b) - holes(e)) .and.     &\n            &      1 < abs (holes(b) - holes(f)) .and.     &\n            &      1 < abs (holes(d) - holes(h)) .and.     &\n            &      1 < abs (holes(e) - holes(h)) .and.     &\n            &      1 < abs (holes(f) - holes(h)) .and.     &\n            &      1 < abs (holes(c) - holes(d)) .and.     &\n            &      1 < abs (holes(d) - holes(e)) .and.     &\n            &      1 < abs (holes(e) - holes(f))\n    end if\n  end function satisfies_the_constraints\n\n  subroutine print_solution (holes)\n    integer, intent(in) :: holes(a:h)\n\n    write (*, '(I5, I4)') holes(a), holes(b)\n    write (*, '(\"   /\u2502\\ /\u2502\\\")')\n    write (*, '(\"  / \u2502 X \u2502 \\\")')\n    write (*, '(\" /  \u2502/ \\\u2502  \\\")')\n    write (*, '(3(I1, \"\u2500\u2500\u2500\"), I1)') holes(c), holes(d), holes(e), holes(f)\n    write (*, '(\" \\  \u2502\\ /\u2502  /\")')\n    write (*, '(\"  \\ \u2502 X \u2502 /\")')\n    write (*, '(\"   \\\u2502/ \\\u2502/\")')\n    write (*, '(I5, I4)') holes(g), holes(h)\n  end subroutine print_solution\n\nend program no_connection_puzzle\n", "target": "from __future__ import print_function\nfrom itertools import permutations\nfrom enum import Enum\n\nA, B, C, D, E, F, G, H = Enum('Peg', 'A, B, C, D, E, F, G, H')\n\nconnections = ((A, C), (A, D), (A, E),\n               (B, D), (B, E), (B, F),\n               (G, C), (G, D), (G, E),\n               (H, D), (H, E), (H, F),\n               (C, D), (D, E), (E, F))\n\n\ndef ok(conn, perm):\n    \n    this, that = (c.value - 1 for c in conn)\n    return abs(perm[this] - perm[that]) != 1\n\n\ndef solve():\n    return [perm for perm in permutations(range(1, 9))\n            if all(ok(conn, perm) for conn in connections)]\n\n\nif __name__ == '__main__':\n    solutions = solve()\n    print(\"A, B, C, D, E, F, G, H =\", ', '.join(str(i) for i in solutions[0]))\n"}
{"id": 347572, "name": "Copy a string", "source": "Translate Fortran to Python: str2 = str1\n", "target": ">>> src = \"hello\"\n>>> a = src\n>>> b = src[:]\n>>> import copy\n>>> c = copy.copy(src)\n>>> d = copy.deepcopy(src)\n>>> src is a is b is c is d\nTrue\n"}
{"id": 347573, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Fortran to Python:       CHARACTER*120 FUNCTION REPLY(QUERY)    \nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       CHARACTER*120 TEXT\t\n       INTEGER MSG,KEYS,LSTNB\t\n       COMMON /IOUNITS/ MSG,KEYS\n        WRITE (MSG,1) QUERY(1:LSTNB(QUERY)),\"?\"\n    1   FORMAT (2A,$)\t\t\n        READ (KEYS,1) TEXT\t\n        REPLY = TEXT\t\t\n       RETURN\t\t\t\n      END \t\t\t\n\n      REAL*8 FUNCTION REPLYN(QUERY)\t\nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       REAL X\t\t\t\n       INTEGER MSG,KEYS,LSTNB\t\n       COMMON /IOUNITS/ MSG,KEYS\n    1   WRITE (MSG,2) QUERY(1:LSTNB(QUERY))\t\n    2   FORMAT (A,$)\t\t\n        READ (KEYS,*,ERR = 3) X\t\n        REPLYN = X\t\t\n       RETURN\t\t\t\n    3   WRITE (MSG,4)\t\t\n    4   FORMAT ('Distasteful number. Try again...')\t\n        GO TO 1\t\t\t\n      END\t\t\t\n\n      LOGICAL FUNCTION YEA(QUERY)\t\nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       CHARACTER*120 WHAT,REPLY\t\n       CHARACTER*1 C\t\t\n       INTEGER MSG,KEYS\t\t\n       COMMON /IOUNITS/ MSG,KEYS\n       INTEGER L\t\t\n    1   WHAT = REPLY(QUERY)\t\n        DO L = 1,LEN(WHAT)\t\n          C = WHAT(L:L)\t\t\n          IF (C .NE. ' ') GO TO 10\t\n        END DO\t\t\t\n        WRITE (MSG,2)\t\t\n    2   FORMAT ('All blank?')\t\n    3   WRITE (MSG,4) \t\t\n    4   FORMAT ('I dig it not. Try Yes/Si/Da/Oui/Ja, or No')\n        GO TO 1\t\t\t\n   10   IF (INDEX('YySsDdOoJj',C) .GT. 0) THEN\t\n          YEA = .TRUE.\t\t\n        ELSE IF (INDEX('Nn',C) .GT. 0) THEN\t\n          YEA = .FALSE.\t\t\n        ELSE\t\t\t\n          GO TO 3\t\t\n        END IF\t\t\t\n       RETURN\t\t\t\n      END\t\t\t\n      LOGICAL FUNCTION NAY(QUERY)\t\nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       LOGICAL YEA\t\t\n        NAY = .NOT.YEA(QUERY)\t\n       RETURN\t\t\t\n      END\t\t\t\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 347574, "name": "Keyboard input_Obtain a Y or N response", "source": "Translate Fortran to Python:       CHARACTER*120 FUNCTION REPLY(QUERY)    \nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       CHARACTER*120 TEXT\t\n       INTEGER MSG,KEYS,LSTNB\t\n       COMMON /IOUNITS/ MSG,KEYS\n        WRITE (MSG,1) QUERY(1:LSTNB(QUERY)),\"?\"\n    1   FORMAT (2A,$)\t\t\n        READ (KEYS,1) TEXT\t\n        REPLY = TEXT\t\t\n       RETURN\t\t\t\n      END \t\t\t\n\n      REAL*8 FUNCTION REPLYN(QUERY)\t\nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       REAL X\t\t\t\n       INTEGER MSG,KEYS,LSTNB\t\n       COMMON /IOUNITS/ MSG,KEYS\n    1   WRITE (MSG,2) QUERY(1:LSTNB(QUERY))\t\n    2   FORMAT (A,$)\t\t\n        READ (KEYS,*,ERR = 3) X\t\n        REPLYN = X\t\t\n       RETURN\t\t\t\n    3   WRITE (MSG,4)\t\t\n    4   FORMAT ('Distasteful number. Try again...')\t\n        GO TO 1\t\t\t\n      END\t\t\t\n\n      LOGICAL FUNCTION YEA(QUERY)\t\nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       CHARACTER*120 WHAT,REPLY\t\n       CHARACTER*1 C\t\t\n       INTEGER MSG,KEYS\t\t\n       COMMON /IOUNITS/ MSG,KEYS\n       INTEGER L\t\t\n    1   WHAT = REPLY(QUERY)\t\n        DO L = 1,LEN(WHAT)\t\n          C = WHAT(L:L)\t\t\n          IF (C .NE. ' ') GO TO 10\t\n        END DO\t\t\t\n        WRITE (MSG,2)\t\t\n    2   FORMAT ('All blank?')\t\n    3   WRITE (MSG,4) \t\t\n    4   FORMAT ('I dig it not. Try Yes/Si/Da/Oui/Ja, or No')\n        GO TO 1\t\t\t\n   10   IF (INDEX('YySsDdOoJj',C) .GT. 0) THEN\t\n          YEA = .TRUE.\t\t\n        ELSE IF (INDEX('Nn',C) .GT. 0) THEN\t\n          YEA = .FALSE.\t\t\n        ELSE\t\t\t\n          GO TO 3\t\t\n        END IF\t\t\t\n       RETURN\t\t\t\n      END\t\t\t\n      LOGICAL FUNCTION NAY(QUERY)\t\nConcocted by R.N.McLean (whom God preserve), December MM.\n       CHARACTER*(*) QUERY\t\n       LOGICAL YEA\t\t\n        NAY = .NOT.YEA(QUERY)\t\n       RETURN\t\t\t\n      END\t\t\t\n", "target": "\n\ntry:\n    from msvcrt import getch\nexcept ImportError:\n    def getch():\n        import sys, tty, termios\n        fd = sys.stdin.fileno()\n        old_settings = termios.tcgetattr(fd)\n        try:\n            tty.setraw(sys.stdin.fileno())\n            ch = sys.stdin.read(1)\n        finally:\n            termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)\n        return ch\n\nprint \"Press Y or N to continue\"\nwhile True:\n    char = getch()\n    if char.lower() in (\"y\", \"n\"):\n        print char\n        break\n"}
{"id": 347575, "name": "String comparison", "source": "Translate Fortran to Python:       PRINT 42,N\n   42 FORMAT (14HThe answer is ,I9)\n", "target": "fun compare(a, b):\n    print(\"\\n$a is of type ${typeof(a)} and $b is of type ${typeof(b)}\")\n    if a < b: print(\"$a is strictly less than $b\")\n    if a <= b: print(\"$a is less than or equal to $b\")\n    if a >  b: print(\"$a is strictly greater than $b\")\n    if a >= b: print(\"$a is greater than or equal to $b\")\n    if a == b: print(\"$a is equal to $b\")\n    if a != b: print(\"$a is not equal to $b\")\n    if a is b: print(\"$a has object identity with $b\")\n    if a is not b: print(\"$a has negated object identity with $b\")\n\ncompare(\"YUP\", \"YUP\")\ncompare('a', 'z')\ncompare(\"24\", \"123\")\ncompare(24, 123)\ncompare(5.0, 5)\n"}

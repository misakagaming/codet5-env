{"id": 379471, "name": "Execute HQ9+", "source": "Translate Fortran to C#: \"bottle\" // IF (B.NE.1) THEN \"s\" FI // \" of beer\"\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{\n    static void RunCode(string code)\n    {\n        int accumulator = 0;\n        var opcodes = new Dictionary<char, Action>\n        {\n            {'H', () => Console.WriteLine(\"Hello, World!\"))},\n            {'Q', () => Console.WriteLine(code) },\n            {'9', () => Console.WriteLine(Enumerable.Range(1,100).Reverse().Select(n => string.Format(\"{0} bottles of beer on the wall\\n{0} bottles of beer\\nTake one down, pass it around\\n{1} bottles of beer on the wall\\n\", n, n-1)).Aggregate((a,b) => a + \"\\n\" + b))},\n            {'+', () => accumulator++ }\n        }\n\n        foreach(var c in code)\n            opcodes[c]();\n    }\n}\n"}
{"id": 379472, "name": "Playing cards", "source": "Translate Fortran to C#: MODULE Cards\n\nIMPLICIT NONE\n\n  TYPE Card\n    CHARACTER(5) :: value\n    CHARACTER(8) :: suit\n  END TYPE Card\n\n  TYPE(Card) :: deck(52), hand(52)\n  TYPE(Card) :: temp\n\n  CHARACTER(5) :: pip(13) = (/\"Two  \", \"Three\", \"Four \", \"Five \", \"Six  \", \"Seven\", \"Eight\", \"Nine \", \"Ten  \", &\n                              \"Jack \", \"Queen\", \"King \", \"Ace  \"/)\n  CHARACTER(8) :: suits(4) = (/\"Clubs   \", \"Diamonds\", \"Hearts  \", \"Spades  \"/)\n  INTEGER :: i, j, n, rand, dealt = 0\n  REAL :: x\n\nCONTAINS\n \n  SUBROUTINE Init_deck\n  \n    DO i = 1, 4\n      DO j = 1, 13\n        deck((i-1)*13+j) = Card(pip(j), suits(i))\n      END DO\n    END DO\n  END SUBROUTINE Init_deck\n \n  SUBROUTINE Shuffle_deck\n  \n    DO i = 52-dealt, 1, -1\n      CALL RANDOM_NUMBER(x)\n      rand = INT(x * i) + 1\n      temp = deck(rand)\n      deck(rand) = deck(i)\n      deck(i) = temp\n    END DO\n  END SUBROUTINE Shuffle_deck\n\n  SUBROUTINE Deal_hand(number)\n  \n    INTEGER :: number\n    DO i = 1, number\n      hand(i) = deck(dealt+1)\n      dealt = dealt + 1\n    END DO\n  END SUBROUTINE\n\n  SUBROUTINE Print_hand\n  \n    DO i = 1, dealt\n      WRITE (*, \"(3A)\") TRIM(deck(i)%value), \" of \", TRIM(deck(i)%suit)\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Print_hand\n \n  SUBROUTINE Print_deck\n  \n    DO i = dealt+1, 52\n      WRITE (*, \"(3A)\") TRIM(deck(i)%value), \" of \", TRIM(deck(i)%suit)\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Print_deck\n\nEND MODULE Cards\n", "target": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic struct Card\n{\n    public Card(string rank, string suit) : this()\n    {\n        Rank = rank;\n        Suit = suit;\n    }\n\n    public string Rank { get; }\n    public string Suit { get; }\n\n    public override string ToString() => $\"{Rank} of {Suit}\";\n}\n\npublic class Deck : IEnumerable<Card>\n{\n    static readonly string[] ranks = { \"Two\", \"Three\", \"Four\", \"Five\", \"Six\",\n        \"Seven\", \"Eight\", \"Nine\", \"Ten\", \"Jack\", \"Queen\", \"King\", \"Ace\" };\n    static readonly string[] suits = { \"Clubs\", \"Diamonds\", \"Hearts\", \"Spades\" };\n    readonly List<Card> cards;\n \n    public Deck() {\n        cards = (from suit in suits\n                from rank in ranks\n                select new Card(rank, suit)).ToList();\n    }\n\n    public int Count => cards.Count;\n\n    public void Shuffle() {\n        \n        var random = new Random();\n        for (int i = 0; i < cards.Count; i++) {\n            int r = random.Next(i, cards.Count);\n            var temp = cards[i];\n            cards[i] = cards[r];\n            cards[r] = temp;\n        }\n    }\n\n    public Card Deal() {\n        int last = cards.Count - 1;\n        Card card = cards[last];\n        \n        \n        cards.RemoveAt(last);\n        return card;\n    }\n\n    public IEnumerator<Card> GetEnumerator() {\n        \n        \n        for (int i = cards.Count - 1; i >= 0; i--)\n            yield return cards[i];\n    }\n\n    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() => GetEnumerator();\n}\n"}
{"id": 379473, "name": "Two sum", "source": "Translate Fortran to C#: program twosum\n  implicit none\n\n  integer, parameter, dimension(5) :: list = (/ 0, 2, 11, 19, 90/)\n  integer, parameter :: target_val = 21\n  integer :: nelem\n  integer :: i, j\n  logical :: success = .false.\n\n  nelem = size(list)\n  outer:do i = 1,nelem\n     do j = i+1,nelem\n        success = list(i) + list(j) == target_val\n        if (success) exit outer\n     end do\n  end do outer\n\n  if (success) then\n     \n     print('(\"(\",2(i3.1,1X),\")\",3(A1,i3.1))'), i,j, \":\", list(i), \"+\", list(j), \"=\", target_val\n  else\n     print*, \"Failed\"\n  end if\n\nend program twosum\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 379474, "name": "Two sum", "source": "Translate Fortran to C#: program twosum\n  implicit none\n\n  integer, parameter, dimension(5) :: list = (/ 0, 2, 11, 19, 90/)\n  integer, parameter :: target_val = 21\n  integer :: nelem\n  integer :: i, j\n  logical :: success = .false.\n\n  nelem = size(list)\n  outer:do i = 1,nelem\n     do j = i+1,nelem\n        success = list(i) + list(j) == target_val\n        if (success) exit outer\n     end do\n  end do outer\n\n  if (success) then\n     \n     print('(\"(\",2(i3.1,1X),\")\",3(A1,i3.1))'), i,j, \":\", list(i), \"+\", list(j), \"=\", target_val\n  else\n     print*, \"Failed\"\n  end if\n\nend program twosum\n", "target": "using System;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main(string[] args)\n    {\n        int[] arr = { 0, 2, 11, 19, 90 };\n        const int sum = 21;\n\n        var ts = TwoSum(arr, sum);\n        Console.WriteLine(ts != null ? $\"{ts[0]}, {ts[1]}\" : \"no result\");\n\n        Console.ReadLine();\n    }\n\n    public static int[] TwoSum(int[] numbers, int sum)\n    {\n        var map = new Dictionary<int, int>();\n        for (int i = 0; i < numbers.Length; i++)\n        {\n            \n            var key = sum - numbers[i];\n            if (map.ContainsKey(key))\n            {\n                return new[] { map[key], i };\n            }\n            map.Add(numbers[i], i);\n        }\n        return null;\n    }\n}\n"}
{"id": 379475, "name": "Find the last Sunday of each month", "source": "Translate Fortran to C#:       D = DAYNUM(Y,M,D)    \n      DAYNUM(Y,M,D) = D    \n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 379476, "name": "Find the last Sunday of each month", "source": "Translate Fortran to C#:       D = DAYNUM(Y,M,D)    \n      DAYNUM(Y,M,D) = D    \n", "target": "using System;\n\nnamespace LastSundayOfEachMonth\n{\n    class Program\n    {\n        static void Main()\n        {\n            Console.Write(\"Year to calculate: \");\n\n            string strYear = Console.ReadLine();\n            int year = Convert.ToInt32(strYear);\n\n            DateTime date;\n            for (int i = 1; i <= 12; i++)\n            {\n                date = new DateTime(year, i, DateTime.DaysInMonth(year, i), System.Globalization.CultureInfo.CurrentCulture.Calendar);\n                \n                \n                int daysOffset = date.DayOfWeek - dayOfWeek; \n                if (daysOffset < 0) daysOffset += 7; \n                date = date.AddDays(-daysOffset ); \n                Console.WriteLine(date.ToString(\"yyyy-MM-dd\"));\n            }\n        }\n    }\n}\n"}
{"id": 379477, "name": "Circles of given radius through two points", "source": "Translate Fortran to C#: \n\nprogram circles\nimplicit none\ndouble precision :: P1(2), P2(2), R\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0,0.2345d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.0d0, 2.0d0/)\nP2 = (/0.0d0,0.0d0/)\nR = 1.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0, 0.2345d0/)\nR = 0.5d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 0.0d0\ncall print_centers(P1,P2,R)\nend program circles\n\nsubroutine print_centers(P1,P2,R)\nimplicit none\ndouble precision :: P1(2), P2(2), R, Center(2,2)\ninteger :: Res\ncall test_inputs(P1,P2,R,Res)\nwrite(*,*)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point1 \u00a0: ', P1(1), ' ', P1(2)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point2 \u00a0: ', P2(1), ' ', P2(2)\nwrite(*,'(A10,F7.4)') 'Radius \u00a0: ', R\nif(Res.eq.1) then\n  write(*,*) 'Same point because P1=P2 and r=0.'\nelseif(Res.eq.2) then\n  write(*,*) 'No circles can be drawn because r=0.'\nelseif(Res.eq.3) then\n  write(*,*) 'Infinite circles because P1=P2 for non-zero radius.'\nelseif(Res.eq.4) then\n  write(*,*) 'No circles with given r can be drawn because points are far apart.'\nelseif(Res.eq.0) then\n  call find_center(P1,P2,R,Center)\n  if(Center(1,1).eq.Center(2,1) .and. Center(1,2).eq.Center(2,2)) then\n    write(*,*) 'Points lie on the diameter. A single circle can be drawn.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center \u00a0: ', Center(1,1), ' ', Center(1,2)\n  else\n    write(*,*) 'Two distinct circles found.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center1\u00a0: ', Center(1,1), ' ', Center(1,2)\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center2\u00a0: ', Center(2,1), ' ', Center(2,2)\n  end if\nelseif(Res.lt.0) then\n  write(*,*) 'Incorrect value for r.'\nend if\nwrite(*,*)\nend subroutine print_centers\n\nsubroutine test_inputs(P1,P2,R,Res)\nimplicit none\ndouble precision :: P1(2), P2(2), R, dist\ninteger :: Res\nif(R.lt.0.0d0) then\n  Res = -1\n  return\nelseif(R.eq.0.0d0 .and. P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 1\n  return\nelseif(R.eq.0.0d0) then\n  Res = 2\n  return\nelseif(P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 3\n  return\nelse\n  dist = sqrt( (P1(1)-P2(1))**2 + (P1(2)-P2(2))**2 )\n  if(dist.gt.2.0d0*R) then\n    Res = 4\n    return\n  else\n    Res = 0\n    return\n  end if\nend if\nend subroutine test_inputs\n\nsubroutine find_center(P1,P2,R,Center)\nimplicit none\ndouble precision :: P1(2), P2(2), MP(2), Center(2,2), R, dm, dd\nMP = (P1 + P2)/2.0d0\ndm = sqrt((P1(1) - P2(1))**2 + (P1(2) - P2(2))**2)\ndd = sqrt(R**2 - (dm/2.0d0)**2)\nCenter(1,1) = MP(1) - dd*(P2(2) - P1(2))/dm\nCenter(1,2) = MP(2) + dd*(P2(1) - P1(1))/dm\n\nCenter(2,1) = MP(1) + dd*(P2(2) - P1(2))/dm\nCenter(2,2) = MP(2) - dd*(P2(1) - P1(1))/dm\nend subroutine find_center\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 379478, "name": "Circles of given radius through two points", "source": "Translate Fortran to C#: \n\nprogram circles\nimplicit none\ndouble precision :: P1(2), P2(2), R\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0,0.2345d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.0d0, 2.0d0/)\nP2 = (/0.0d0,0.0d0/)\nR = 1.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0, 0.2345d0/)\nR = 0.5d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 0.0d0\ncall print_centers(P1,P2,R)\nend program circles\n\nsubroutine print_centers(P1,P2,R)\nimplicit none\ndouble precision :: P1(2), P2(2), R, Center(2,2)\ninteger :: Res\ncall test_inputs(P1,P2,R,Res)\nwrite(*,*)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point1 \u00a0: ', P1(1), ' ', P1(2)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point2 \u00a0: ', P2(1), ' ', P2(2)\nwrite(*,'(A10,F7.4)') 'Radius \u00a0: ', R\nif(Res.eq.1) then\n  write(*,*) 'Same point because P1=P2 and r=0.'\nelseif(Res.eq.2) then\n  write(*,*) 'No circles can be drawn because r=0.'\nelseif(Res.eq.3) then\n  write(*,*) 'Infinite circles because P1=P2 for non-zero radius.'\nelseif(Res.eq.4) then\n  write(*,*) 'No circles with given r can be drawn because points are far apart.'\nelseif(Res.eq.0) then\n  call find_center(P1,P2,R,Center)\n  if(Center(1,1).eq.Center(2,1) .and. Center(1,2).eq.Center(2,2)) then\n    write(*,*) 'Points lie on the diameter. A single circle can be drawn.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center \u00a0: ', Center(1,1), ' ', Center(1,2)\n  else\n    write(*,*) 'Two distinct circles found.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center1\u00a0: ', Center(1,1), ' ', Center(1,2)\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center2\u00a0: ', Center(2,1), ' ', Center(2,2)\n  end if\nelseif(Res.lt.0) then\n  write(*,*) 'Incorrect value for r.'\nend if\nwrite(*,*)\nend subroutine print_centers\n\nsubroutine test_inputs(P1,P2,R,Res)\nimplicit none\ndouble precision :: P1(2), P2(2), R, dist\ninteger :: Res\nif(R.lt.0.0d0) then\n  Res = -1\n  return\nelseif(R.eq.0.0d0 .and. P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 1\n  return\nelseif(R.eq.0.0d0) then\n  Res = 2\n  return\nelseif(P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 3\n  return\nelse\n  dist = sqrt( (P1(1)-P2(1))**2 + (P1(2)-P2(2))**2 )\n  if(dist.gt.2.0d0*R) then\n    Res = 4\n    return\n  else\n    Res = 0\n    return\n  end if\nend if\nend subroutine test_inputs\n\nsubroutine find_center(P1,P2,R,Center)\nimplicit none\ndouble precision :: P1(2), P2(2), MP(2), Center(2,2), R, dm, dd\nMP = (P1 + P2)/2.0d0\ndm = sqrt((P1(1) - P2(1))**2 + (P1(2) - P2(2))**2)\ndd = sqrt(R**2 - (dm/2.0d0)**2)\nCenter(1,1) = MP(1) - dd*(P2(2) - P1(2))/dm\nCenter(1,2) = MP(2) + dd*(P2(1) - P1(1))/dm\n\nCenter(2,1) = MP(1) + dd*(P2(2) - P1(2))/dm\nCenter(2,2) = MP(2) - dd*(P2(1) - P1(1))/dm\nend subroutine find_center\n", "target": "using System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n"}
{"id": 379479, "name": "I before E except after C", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram cia\n  implicit none\n  character (len=256) :: s\n  integer :: ie, ei, cie, cei\n  integer :: ios\n  data ie, ei, cie, cei/4*0/\n  do while (.true.)\n    read(5,*,iostat = ios)s\n    if (0 .ne. ios) then\n      exit\n    endif\n    call lower_case(s)\n    cie = cie + occurrences(s, 'cie')\n    cei = cei + occurrences(s, 'cei')\n    ie = ie + occurrences(s, 'ie')\n    ei = ei + occurrences(s, 'ei')\n  enddo\n  write(6,'(1x,4(a4,1x))') 'ie','ei','cie','cei'\n  write(6,'(1x,4(i4,1x))') ie,ei,cie,cei \n  write(6,'(1x,2(a,1x))') '        [^c]ie',plausibility(ie,ei)\n  write(6,'(1x,2(a,1x))') '           cei',plausibility(cei,cie)\n  write(6,'(1x,2(a,1x))') '([^c]ie)|(cei)',plausibility(ie+cei,ei+cie)\n\ncontains\n\n  subroutine lower_case(s)\n    character(len=*), intent(inout) :: s\n    integer :: i\n    do i=1, len_trim(s)\n      s(i:i) = achar(ior(iachar(s(i:i)),32))\n    enddo\n  end subroutine lower_case\n\n  integer function occurrences(a,b)\n    character(len=*), intent(in) :: a, b\n    integer :: i, j, n\n    n = 0\n    i = 0\n    j = index(a, b)\n    do while (0 .lt. j)\n      n = n+1\n      i = i+len(b)+j-1\n      j = index(a(i:), b)\n    end do\n    occurrences = n\n  end function occurrences\n\n  character*(32) function plausibility(da, nyet)\n    integer, intent(in) :: da, nyet\n    \n    if (nyet*2 .lt. da) then\n      plausibility = 'plausible'\n    else\n      plausibility = 'implausible'\n    endif\n  end function plausibility\nend program cia\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 379480, "name": "I before E except after C", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram cia\n  implicit none\n  character (len=256) :: s\n  integer :: ie, ei, cie, cei\n  integer :: ios\n  data ie, ei, cie, cei/4*0/\n  do while (.true.)\n    read(5,*,iostat = ios)s\n    if (0 .ne. ios) then\n      exit\n    endif\n    call lower_case(s)\n    cie = cie + occurrences(s, 'cie')\n    cei = cei + occurrences(s, 'cei')\n    ie = ie + occurrences(s, 'ie')\n    ei = ei + occurrences(s, 'ei')\n  enddo\n  write(6,'(1x,4(a4,1x))') 'ie','ei','cie','cei'\n  write(6,'(1x,4(i4,1x))') ie,ei,cie,cei \n  write(6,'(1x,2(a,1x))') '        [^c]ie',plausibility(ie,ei)\n  write(6,'(1x,2(a,1x))') '           cei',plausibility(cei,cie)\n  write(6,'(1x,2(a,1x))') '([^c]ie)|(cei)',plausibility(ie+cei,ei+cie)\n\ncontains\n\n  subroutine lower_case(s)\n    character(len=*), intent(inout) :: s\n    integer :: i\n    do i=1, len_trim(s)\n      s(i:i) = achar(ior(iachar(s(i:i)),32))\n    enddo\n  end subroutine lower_case\n\n  integer function occurrences(a,b)\n    character(len=*), intent(in) :: a, b\n    integer :: i, j, n\n    n = 0\n    i = 0\n    j = index(a, b)\n    do while (0 .lt. j)\n      n = n+1\n      i = i+len(b)+j-1\n      j = index(a(i:), b)\n    end do\n    occurrences = n\n  end function occurrences\n\n  character*(32) function plausibility(da, nyet)\n    integer, intent(in) :: da, nyet\n    \n    if (nyet*2 .lt. da) then\n      plausibility = 'plausible'\n    else\n      plausibility = 'implausible'\n    endif\n  end function plausibility\nend program cia\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.IO;\n\nnamespace IBeforeE {\n    class Program {\n        static bool IsOppPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ei\")) {\n                return true;\n            }\n            if (word.Contains(\"cie\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleWord(string word) {\n            if (!word.Contains(\"c\") && word.Contains(\"ie\")) {\n                return true;\n            }\n            if (word.Contains(\"cei\")) {\n                return true;\n            }\n            return false;\n        }\n\n        static bool IsPlausibleRule(string filename) {\n            IEnumerable<string> wordSource = File.ReadLines(filename);\n            int trueCount = 0;\n            int falseCount = 0;\n\n            foreach (string word in wordSource) {\n                if (IsPlausibleWord(word)) {\n                    trueCount++;\n                }\n                else if (IsOppPlausibleWord(word)) {\n                    falseCount++;\n                }\n            }\n\n            Console.WriteLine(\"Plausible count: {0}\", trueCount);\n            Console.WriteLine(\"Implausible count: {0}\", falseCount);\n            return trueCount > 2 * falseCount;\n        }\n\n        static void Main(string[] args) {\n            if (IsPlausibleRule(\"unixdict.txt\")) {\n                Console.WriteLine(\"Rule is plausible.\");\n            }\n            else {\n                Console.WriteLine(\"Rule is not plausible.\");\n            }\n        }\n    }\n}\n"}
{"id": 379481, "name": "Naming conventions", "source": "Translate Fortran to C#: IMPLICIT REAL(A-H,O-Z), INTEGER(I-M)\n", "target": "public enum Planet {\n    Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune\n}\n\n[Flags]\npublic enum Days {\n    None = 0,\n    Sunday = 1,\n    Monday = 2,\n    Tuesday = 4,\n    Wednesday = 8,\n    Thursday = 16,\n    Friday = 32,\n    Saturday = 64,\n    Workdays = Monday | Tuesday | Wednesday | Thursday | Friday\n    AllWeek = Sunday | Saturday | Workdays\n}\n"}
{"id": 379482, "name": "Mersenne primes", "source": "Translate Fortran to C#: program mersenne\n    use iso_fortran_env, only: output_unit, INT64\n    implicit none\n\n    integer, parameter  :: l=INT64\n    integer(kind=l)     :: base\n    integer             :: pow\n\n    base = 2\n\n    do pow = 1, 32\n        if (is_prime(base-1)) then\n            write(output_unit,'(A2,x,I0,x,A3)') \"2^\", pow, \"- 1\"\n        end if\n        base = base * 2\n    end do\ncontains\n    pure function is_prime(n)\n        integer(kind=l), intent(in) :: n\n        logical                     :: is_prime\n        integer(kind=l)             :: test\n\n        is_prime = .false.\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        test = 5\n        do\n            if (test**2 >= n) then\n                is_prime = .true.\n                return\n            end if\n\n            if (modulo(n, test) == 0) return\n            test = test + 2\n            if (modulo(n, test) == 0) return\n            test = test + 4\n        end do\n    end function is_prime\nend program mersenne\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 379483, "name": "Mersenne primes", "source": "Translate Fortran to C#: program mersenne\n    use iso_fortran_env, only: output_unit, INT64\n    implicit none\n\n    integer, parameter  :: l=INT64\n    integer(kind=l)     :: base\n    integer             :: pow\n\n    base = 2\n\n    do pow = 1, 32\n        if (is_prime(base-1)) then\n            write(output_unit,'(A2,x,I0,x,A3)') \"2^\", pow, \"- 1\"\n        end if\n        base = base * 2\n    end do\ncontains\n    pure function is_prime(n)\n        integer(kind=l), intent(in) :: n\n        logical                     :: is_prime\n        integer(kind=l)             :: test\n\n        is_prime = .false.\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        test = 5\n        do\n            if (test**2 >= n) then\n                is_prime = .true.\n                return\n            end if\n\n            if (modulo(n, test) == 0) return\n            test = test + 2\n            if (modulo(n, test) == 0) return\n            test = test + 4\n        end do\n    end function is_prime\nend program mersenne\n", "target": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"}
{"id": 379484, "name": "Taxicab numbers", "source": "Translate Fortran to C#: \n     PROGRAM POOKA\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  NVARS = 25\n\n\n\n      REAL  ::  f1\n      REAL  ::  f2\n      INTEGER  ::  hits\n      INTEGER  ::  s\n      INTEGER  ::  TAXICAB\n\n      hits = 0\n      s = 0\n      f1 = SECOND()\n      DO WHILE ( hits<NVARS )\n         s = s + 1\n         hits = hits + TAXICAB(s)\n      END DO\n      f2 = SECOND()\n      PRINT * , 'elapsed time = ' , f2 - f1 , 'For ' , NVARS , ' Variables'\n      STOP\n      END PROGRAM POOKA\n \n      FUNCTION TAXICAB(N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      INTEGER  ::  TAXICAB\n      INTENT (IN) N\n\n\n\n      INTEGER  ::  holder\n      INTEGER  ::  oldx\n      INTEGER  ::  oldy\n      INTEGER  ::  s\n      INTEGER  ::  x\n      INTEGER  ::  y\n      real*8,parameter :: xpon=(1.0D0/3.0D0)\n\n      x = 0\n      holder = 0\n      oldx = 0\n      oldy = 0\n      TAXICAB = 0\n      y = INT(N**xpon)\n      DO WHILE ( x<=y )\n         s = x**3 + y**3\n         IF( s<N )THEN\n            x = x + 1\n         ELSE IF( s>N )THEN\n            y = y - 1\n         ELSE\n            IF( holder==s )THEN \n               WRITE(6 , 34)s , '(' , x**3 , y**3 , ')' , '(' , oldx**3 , oldy**3 , ')'\n 34            FORMAT(1x , i12 , 10x , 1A1 , i12 , 2x , i12 , 1A1 , 10x , 1A1 , i12 , 2x ,&\n                    & i12 , 1A1)\n               TAXICAB = 1  \n            END IF\n            holder = s      \n            oldx = x       \n            oldy = y\n            x = x + 1       \n            y = y - 1\n         END IF\n      END DO\n      RETURN\n      END FUNCTION TAXICAB\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace TaxicabNumber\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            IDictionary<long, IList<Tuple<int, int>>> taxicabNumbers = GetTaxicabNumbers(2006);\n            PrintTaxicabNumbers(taxicabNumbers);\n            Console.ReadKey();\n        }\n\n        private static IDictionary<long, IList<Tuple<int, int>>> GetTaxicabNumbers(int length)\n        {\n            SortedList<long, IList<Tuple<int, int>>> sumsOfTwoCubes = new SortedList<long, IList<Tuple<int, int>>>();\n\n            for (int i = 1; i < int.MaxValue; i++)\n            {\n                for (int j = 1; j < int.MaxValue; j++)\n                {\n                    long sum = (long)(Math.Pow((double)i, 3) + Math.Pow((double)j, 3));\n\n                    if (!sumsOfTwoCubes.ContainsKey(sum))\n                    {\n                        sumsOfTwoCubes.Add(sum, new List<Tuple<int, int>>());\n                    }\n\n                    sumsOfTwoCubes[sum].Add(new Tuple<int, int>(i, j));\n\n                    if (j >= i)\n                    {\n                        break;\n                    }\n                }\n\n                \n                if (sumsOfTwoCubes.Count(t => t.Value.Count >= 2) >= length * 1.1)\n                {\n                    break;\n                }\n            }\n\n            IDictionary<long, IList<Tuple<int, int>>> values = (from t in sumsOfTwoCubes where t.Value.Count >= 2 select t)\n                .Take(2006)\n                .ToDictionary(u => u.Key, u => u.Value);\n\n            return values;\n        }\n\n        private static void PrintTaxicabNumbers(IDictionary<long, IList<Tuple<int, int>>> values)\n        {\n            int i = 1;\n\n            foreach (long taxicabNumber in values.Keys)\n            {\n                StringBuilder output = new StringBuilder().AppendFormat(\"{0,10}\\t{1,4}\", i, taxicabNumber);\n\n                foreach (Tuple<int, int> numbers in values[taxicabNumber])\n                {\n                    output.AppendFormat(\"\\t= {0}^3 + {1}^3\", numbers.Item1, numbers.Item2);\n                }\n\n                if (i <= 25 || (i >= 2000 && i <= 2006))\n                {\n                    Console.WriteLine(output.ToString());\n                }\n\n                i++;\n            }\n        }\n    }\n}\n"}
{"id": 379485, "name": "Left factorials", "source": "Translate Fortran to C#:       MODULE LAIROTCAF\t\n       CONTAINS\t\t\n        INTEGER*8 FUNCTION FACT(N)\t\n         INTEGER N\t\n         INTEGER I\t\n          FACT = 1\t\n          DO I = 2,N\t\t\n            FACT = FACT*I\t\t\n            IF (FACT.LE.0) STOP \"Factorial: Overflow\n          END DO\t\t\n        END FUNCTION FACT\t\n\n        INTEGER*8 FUNCTION LFACT(N)\t\n         INTEGER N\t\n         INTEGER K\t\n          LFACT = 0\t\n          DO K = 0,N - 1\t\n            LFACT = LFACT + FACT(K)\t\n            IF (LFACT.LE.0) STOP \"Lfact: Overflow\n          END DO\t\t\n        END FUNCTION LFACT\t\n      END MODULE LAIROTCAF\t\n\n      PROGRAM POKE\n      USE LAIROTCAF\n      INTEGER I\n\n      WRITE (6,*) \"Left factorials, from 0 to 10...\"\n      DO I = 0,10\n        WRITE (6,1) I,LFACT(I)\n    1   FORMAT (\"\n      END DO\n\n      WRITE (6,*) \"Left factorials, from 20 to 110 by tens...\"\n      DO I = 20,110,10\n        WRITE (6,1) I,LFACT(I)\n      END DO\n      END\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 379486, "name": "Left factorials", "source": "Translate Fortran to C#:       MODULE LAIROTCAF\t\n       CONTAINS\t\t\n        INTEGER*8 FUNCTION FACT(N)\t\n         INTEGER N\t\n         INTEGER I\t\n          FACT = 1\t\n          DO I = 2,N\t\t\n            FACT = FACT*I\t\t\n            IF (FACT.LE.0) STOP \"Factorial: Overflow\n          END DO\t\t\n        END FUNCTION FACT\t\n\n        INTEGER*8 FUNCTION LFACT(N)\t\n         INTEGER N\t\n         INTEGER K\t\n          LFACT = 0\t\n          DO K = 0,N - 1\t\n            LFACT = LFACT + FACT(K)\t\n            IF (LFACT.LE.0) STOP \"Lfact: Overflow\n          END DO\t\t\n        END FUNCTION LFACT\t\n      END MODULE LAIROTCAF\t\n\n      PROGRAM POKE\n      USE LAIROTCAF\n      INTEGER I\n\n      WRITE (6,*) \"Left factorials, from 0 to 10...\"\n      DO I = 0,10\n        WRITE (6,1) I,LFACT(I)\n    1   FORMAT (\"\n      END DO\n\n      WRITE (6,*) \"Left factorials, from 20 to 110 by tens...\"\n      DO I = 20,110,10\n        WRITE (6,1) I,LFACT(I)\n      END DO\n      END\n", "target": "using System;\nusing System.Numerics;\n\nnamespace LeftFactorial\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 0; i <= 10; i++)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", i, LeftFactorial(i)));\n            }\n\n            for (int j = 20; j <= 110; j += 10)\n            {\n                Console.WriteLine(string.Format(\"!{0} = {1}\", j, LeftFactorial(j)));\n            }\n\n            for (int k = 1000; k <= 10000; k += 1000)\n            {\n                Console.WriteLine(string.Format(\"!{0} has {1} digits\", k, LeftFactorial(k).ToString().Length));\n            }\n\n            Console.ReadKey();\n        }\n\n        private static BigInteger Factorial(int number)\n        {\n            BigInteger accumulator = 1;\n\n            for (int factor = 1; factor <= number; factor++)\n            {\n                accumulator *= factor;\n            }\n\n            return accumulator;\n        }\n\n        private static BigInteger LeftFactorial(int n)\n        {\n            BigInteger result = 0;\n\n            for (int i = 0; i < n; i++)\n            {\n                result += Factorial(i);\n            }\n\n            return result;\n        }\n    }\n}\n"}
{"id": 379487, "name": "Linux CPU utilization", "source": "Translate Fortran to C#: Program CPUusage\n    implicit none\n    integer :: ios, i\n    integer :: oldidle, oldsum, sumtimes = 0\n    real :: percent = 0.\n    character(len = 4) lineID \n    integer, dimension(9) :: times = 0\n\n    write(*, *) 'CPU Usage'\n    write(*, *) 'Press Ctrl<C> to end'\n    do while (.true.)\n        open(unit = 7, file = '/proc/stat', status = 'old', action = 'read', iostat = ios)\n        if (ios /= 0) then\n            print *, 'Error opening /proc/stat'\n            stop\n        else\n            read(unit = 7, fmt = *, iostat = ios) lineID, (times(i), i = 1, 9)\n            close(7)\n            if (lineID /= 'cpu ') then\n                print *, 'Error reading /proc/stat'\n                stop\n            end if\n            sumtimes = sum(times)\n            percent = (1. - real((times(4) - oldidle)) / real((sumtimes - oldsum))) * 100.\n            write(*, fmt = '(F6.2,A2)') percent, '%'\n            oldidle = times(4)\n            oldsum = sumtimes\n            call sleep(1)\n        end if\n    end do\nend program CPUusage\n", "target": "var prevIdle = 0f;\nvar prevTotal = 0f;\n\nwhile (true)\n{\n    var cpuLine = File\n        .ReadAllLines(\"/proc/stat\")\n        .First()\n        .Split(' ', StringSplitOptions.RemoveEmptyEntries)\n        .Skip(1)\n        .Select(float.Parse)\n        .ToArray();\n\n    var idle = cpuLine[3];\n    var total = cpuLine.Sum();\n\n    var percent = 100.0 * (1.0 - (idle - prevIdle) / (total - prevTotal));\n    Console.WriteLine($\"{percent:0.00}%\");\n\n    prevIdle = idle;\n    prevTotal = total;\n\n    Thread.Sleep(1000);\n}\n"}
{"id": 379488, "name": "Type detection", "source": "Translate Fortran to C#: program input_type_detection_demo\n  implicit none\n\n  type text_block_t\n     character(len = 10000), allocatable :: lines(:)\n  end type text_block_t\n\n  type(text_block_t) :: text_block\n  integer :: i\n\n  call print_text ('Print me.')\n\n  allocate (text_block%lines(1:10))\n  do i = 1, 10\n     write (text_block%lines(i), '(\"i = \", I0)') i\n  end do\n  call print_text (text_block)\n\n  open (100, file = 'type_detection-fortran.f90', action = 'read')\n  call print_text (100)\n  close (100)\n\ncontains\n\n  subroutine print_text (source)\n    class(*), intent(in) :: source\n\n    select type (source)\n\n    type is (character(len = *))\n       \n       write (*, '(A)') source\n\n    class is (text_block_t)\n       \n       block\n         integer :: i\n         do i = lbound (source%lines, 1), ubound (source%lines, 1)\n            write (*, '(A)') trim (source%lines(i))\n         end do\n       end block\n\n    type is (integer)\n       \n       block\n         character(len = 10000) :: line_buffer\n         integer :: stat\n         read (source, '(A)', iostat = stat) line_buffer\n         do while (stat == 0)\n            write (*, '(A)') trim (line_buffer)\n            read (source, '(A)', iostat = stat) line_buffer\n         end do\n       end block\n\n    class default\n       \n       error stop\n\n    end select\n  end subroutine print_text\n\nend program input_type_detection_demo\n", "target": "using System;\n\nnamespace TypeDetection {\n    class C { }\n    struct S { }\n    enum E {\n        NONE,\n    }\n\n    class Program {\n        static void ShowType<T>(T t) {\n            Console.WriteLine(\"The type of '{0}' is {1}\", t, t.GetType());\n        }\n\n        static void Main() {\n            ShowType(5);\n            ShowType(7.5);\n            ShowType('d');\n            ShowType(true);\n            ShowType(\"Rosetta\");\n            ShowType(new C());\n            ShowType(new S());\n            ShowType(E.NONE);\n            ShowType(new int[] { 1, 2, 3 });\n        }\n    }\n}\n"}
{"id": 379489, "name": "Find largest left truncatable prime in a given base", "source": "Translate Fortran to C#:       USE PRIMEBAG\t\nCalculates the largest \"left-truncatable\" digit sequence that is a prime number, in various bases.\n      INTEGER LBASE,MANY,ENUFF\t\n      PARAMETER (LBASE = 13, MANY = 66666, ENUFF = 66)\n      INTEGER NS,START(LBASE)\t\n      INTEGER NH,LH\t\t\n      INTEGER N,HORDEN(MANY)\t\t\n      INTEGER*1 HORDED(ENUFF,MANY)\t\n      INTEGER B,D,DB\t\n      INTEGER L\t\t\n      INTEGER P\t\t\n      INTEGER I\t\t\n\n      MSG = 6\t\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n      NS = 0\t\n      P = 1\t\n    1 P = NEXTPRIME(P)\t\n      IF (P.LE.LBASE) THEN\t\n        NS = NS + 1\t\t\n        START(NS) = P\t\t\n        GO TO 1\t\t\t\n      END IF\t\t\n      WRITE (MSG,2) LBASE,NS,START(1:NS)\t\n    2 FORMAT (\"Working in bases 3 to \",I0,\" there are \",I0,\t\n     * \" single-digit primes: \",666(I0:\", \"))\t\n      WRITE (MSG,3)\t\t\n    3 FORMAT (/\"Base Digits Count Max. Value = (in base)\")\n\n   10 DO B = 3,LBASE\t\n        NH = 0\t\t\t\n        DO I = 1,NS\t\t\n          IF (START(I).GE.B) EXIT\t\n          NH = NH + 1\t\t\t\n          HORDEN(NH) = START(I)\t\t\n          HORDED(1,NH) = START(I)\t\n        END DO\t\t\t\n        L = 0\t\n        DB = 1\t\n\n   20   L = L + 1\t\n        IF (L.GE.ENUFF) STOP \"Too many digits\n        DB = DB*B\t\n        IF (DB.LE.0) GO TO 29\t\n        LH = NH\t\t\n        DO I = 1,LH\t\n          N = HORDEN(I)\t\n          DO D = 1,B - 1\t\n            P = D*DB + N\t\t\n            IF (P.LE.0) GO TO 29\t\n            IF (ISPRIME(P)) THEN\t\n              IF (NH.GE.MANY) STOP \"Too many sequences\n              NH = NH + 1\t\t\t\n              HORDEN(NH) = P\t\t\t\n              HORDED(1:L,NH) = HORDED(1:L,I)\t\n              HORDED(L + 1,NH) = D\t\t\n            END IF\t\t\t\n          END DO\t\t\n        END DO\t\n\n        N = NH - LH\t\t\n        IF (N.GT.0) THEN\t\n          DO I = 1,MIN(LH,N)\t\t\n            HORDEN(I) = HORDEN(NH)\t\t\n            HORDED(1:L + 1,I) = HORDED(1:L + 1,NH)\t\n            NH = NH - 1\t\t\t\t\n          END DO\t\t\t\n          NH = N\t\t\t\n          LH = NH\t\t\t\n          GO TO 20\t\t\t\n        END IF\t\t\t\n        GO TO 30\t\t\n   29   WRITE (MSG,28) B,L,NH,DB,P\t\n   28   FORMAT (I4,I7,I6,28X,\"Integer overflow\n        CYCLE\t\t\t\n\n   30   I = MAXLOC(HORDEN(1:NH),DIM = 1)\t\n        WRITE (MSG,31) B,L,NH,HORDEN(I),HORDED(L:1:-1,I)\t\n   31   FORMAT (I4,I7,I6,I11,\" = \"666(I0:\".\"))\t\n\n      END DO\t\t\n      END\t\n", "target": "using Mpir.NET;  \nusing System;   \nusing System.Collections.Generic;\nclass MaxLftTrP_B   \n{\n    static void Main()\n    {\n        mpz_t p; var sw = System.Diagnostics.Stopwatch.StartNew(); L(3);\n        for (uint b = 3; b < 13; b++)\n        {\n            sw.Restart(); p = L(b);\n            Console.WriteLine(\"{0} {1,2} {2}\", sw.Elapsed, b, p);\n        }\n        Console.Read();\n    }\n\n    static mpz_t L(uint b)\n    {\n        var p = new List<mpz_t>(); mpz_t np = 0;\n        while ((np = nxtP(np)) < b) p.Add(np);\n        int i0 = 0, i = 0, i1 = p.Count - 1; mpz_t n0 = b, n, n1 = b * (b - 1);\n        for (; i < p.Count; n0 *= b, n1 *= b, i0 = i1 + 1, i1 = p.Count - 1)\n            for (n = n0; n <= n1; n += n0)\n                for (i = i0; i <= i1; i++)\n                    if (mpir.mpz_probab_prime_p(np = n + p[i], 15) > 0) p.Add(np);\n        return p[p.Count - 1];\n    }\n\n    static mpz_t nxtP(mpz_t n) { mpz_t p = 0; mpir.mpz_nextprime(p, n); return p; }\n}\n"}
{"id": 379490, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Fortran to C#: program CalcPi\n    \n    use iso_fortran_env, only: rf => real128\n    implicit none\n    real(rf) :: a,g,s,old_pi,new_pi\n    real(rf) :: a1,g1,s1\n    integer :: k,k1,i\n\n    old_pi = 0.0_rf;\n    a = 1.0_rf; g = 1.0_rf/sqrt(2.0_rf); s = 0.0_rf; k = 0\n\n    do i=1,100\n        call approx_pi_step(a,g,s,k,a1,g1,s1,k1)\n        new_pi = 4.0_rf * (a1**2.0_rf) / (1.0_rf - s1)\n        if (abs(new_pi - old_pi).lt.(2.0_rf*epsilon(new_pi))) then\n            \n            \n            exit\n        end if\n        write(*,*) 'Iteration:',k1,' Diff:',abs(new_pi - old_pi),' Pi:',new_pi\n        old_pi = new_pi\n        a = a1; g = g1; s = s1; k = k1\n    end do\n\n    contains\n\n    subroutine approx_pi_step(x,y,z,n,a,g,s,k)\n        real(rf), intent(in) :: x,y,z\n        integer, intent(in) :: n\n        real(rf), intent(out) :: a,g,s\n        integer, intent(out) :: k\n\n        a = 0.5_rf*(x+y)\n        g = sqrt(x*y)\n        k = n + 1\n        s = z + (2.0_rf)**(real(k)+1.0_rf) * (a**(2.0_rf) - g**(2.0_rf))\n    end subroutine\nend program CalcPi\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 379491, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Fortran to C#: program CalcPi\n    \n    use iso_fortran_env, only: rf => real128\n    implicit none\n    real(rf) :: a,g,s,old_pi,new_pi\n    real(rf) :: a1,g1,s1\n    integer :: k,k1,i\n\n    old_pi = 0.0_rf;\n    a = 1.0_rf; g = 1.0_rf/sqrt(2.0_rf); s = 0.0_rf; k = 0\n\n    do i=1,100\n        call approx_pi_step(a,g,s,k,a1,g1,s1,k1)\n        new_pi = 4.0_rf * (a1**2.0_rf) / (1.0_rf - s1)\n        if (abs(new_pi - old_pi).lt.(2.0_rf*epsilon(new_pi))) then\n            \n            \n            exit\n        end if\n        write(*,*) 'Iteration:',k1,' Diff:',abs(new_pi - old_pi),' Pi:',new_pi\n        old_pi = new_pi\n        a = a1; g = g1; s = s1; k = k1\n    end do\n\n    contains\n\n    subroutine approx_pi_step(x,y,z,n,a,g,s,k)\n        real(rf), intent(in) :: x,y,z\n        integer, intent(in) :: n\n        real(rf), intent(out) :: a,g,s\n        integer, intent(out) :: k\n\n        a = 0.5_rf*(x+y)\n        g = sqrt(x*y)\n        k = n + 1\n        s = z + (2.0_rf)**(real(k)+1.0_rf) * (a**(2.0_rf) - g**(2.0_rf))\n    end subroutine\nend program CalcPi\n", "target": "using System;\nusing System.Numerics;\n\nclass AgmPie\n{\n    static BigInteger IntSqRoot(BigInteger valu, BigInteger guess)\n    {\n        BigInteger term; do {\n            term = valu / guess; if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1;\n        } while (true); return guess;\n    }\n\n    static BigInteger ISR(BigInteger term, BigInteger guess)\n    {\n        BigInteger valu = term * guess; do {\n            if (BigInteger.Abs(term - guess) <= 1) break;\n            guess += term; guess >>= 1; term = valu / guess;\n        } while (true); return guess;\n    }\n\n    static BigInteger CalcAGM(BigInteger lam, BigInteger gm, ref BigInteger z,\n                              BigInteger ep)\n    {\n        BigInteger am, zi; ulong n = 1; do {\n            am = (lam + gm) >> 1; gm = ISR(lam, gm);\n            BigInteger v = am - lam; if ((zi = v * v * n) < ep) break;\n            z -= zi; n <<= 1; lam = am;\n        } while (true); return am;\n    }\n\n    static BigInteger BIP(int exp, ulong man = 1) \n    {\n        BigInteger rv = BigInteger.Pow(10, exp); return man == 1 ? rv : man * rv;\n    }\n\n    static void Main(string[] args)\n    {\n        int d = 25000;\n        if (args.Length > 0)\n        {\n            int.TryParse(args[0], out d);\n            if (d < 1 || d > 999999) d = 25000;\n        }\n        DateTime st = DateTime.Now;\n        BigInteger am = BIP(d),\n          gm = IntSqRoot(BIP(d + d - 1, 5),\n                             BIP(d - 15, (ulong)(Math.Sqrt(0.5) * 1e+15))),\n          z = BIP(d + d - 2, 25),\n          agm = CalcAGM(am, gm, ref z, BIP(d + 1)),\n          pi = agm * agm * BIP(d - 2) / z;\n        Console.WriteLine(\"Computation time: {0:0.0000} seconds \",\n                             (DateTime.Now - st).TotalMilliseconds / 1000);\n        string s = pi.ToString();\n        Console.WriteLine(\"{0}.{1}\", s[0], s.Substring(1));\n        if (System.Diagnostics.Debugger.IsAttached) Console.ReadKey();\n    }\n}\n"}
{"id": 379492, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Fortran to C#: \n\n\n\nprogram gauss\n  implicit none\n  integer, parameter :: p = 16 \n  integer            :: n = 10, k\n  real(kind=p), allocatable :: r(:,:)\n  real(kind=p)       :: z, a, b, exact\n  do n = 1,20\n    a = -3; b = 3\n    r = gaussquad(n)\n    z = (b-a)/2*dot_product(r(2,:),exp((a+b)/2+r(1,:)*(b-a)/2))\n    exact = exp(3.0_p)-exp(-3.0_p)\n    print \"(i0,1x,g0,1x,g10.2)\",n, z, z-exact\n  end do\n  \n  contains \n\n  function gaussquad(n) result(r)\n  integer                 :: n\n  real(kind=p), parameter :: pi = 4*atan(1._p)\n  real(kind=p)            :: r(2, n), x, f, df, dx\n  integer                 :: i,  iter\n  real(kind = p), allocatable :: p0(:), p1(:), tmp(:)\n  \n  p0 = [1._p]\n  p1 = [1._p, 0._p]\n  \n  do k = 2, n\n     tmp = ((2*k-1)*[p1,0._p]-(k-1)*[0._p, 0._p,p0])/k\n     p0 = p1; p1 = tmp\n  end do\n  do i = 1, n\n    x = cos(pi*(i-0.25_p)/(n+0.5_p))\n    do iter = 1, 10\n      f = p1(1); df = 0._p\n      do k = 2, size(p1)\n        df = f + x*df\n        f  = p1(k) + x * f\n      end do\n      dx =  f / df\n      x = x - dx\n      if (abs(dx)<10*epsilon(dx)) exit\n    end do\n    r(1,i) = x\n    r(2,i) = 2/((1-x**2)*df**2)\n  end do\n  end function\nend program\n", "target": "using System;\n\n\n                    \npublic class Program {\n\n    public static double[][] legeCoef(int N) {\n        \n        double[][] lcoef = new double[N+1][];\n        for (int i=0; i < lcoef.Length; ++i) \n            lcoef[i] = new double[N+1];\n\n\n        lcoef[0][0] = lcoef[1][1] = 1;\n        for (int n = 2; n <= N; n++) {\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n            for (int i = 1; i <= n; i++) \n                lcoef[n][i] = ((2*n - 1) * lcoef[n-1][i-1] \n                               - (n-1) * lcoef[n-2][i] ) / n;\n        }\n        return lcoef;\n    }\n\n\n    static double legeEval(double[][] lcoef, int N, double x) {\n        double s = lcoef[N][N];\n        for (int i = N; i > 0; --i)\n            s = s * x + lcoef[N][i-1];\n        return s;\n    }\n\n    static double legeDiff(double[][] lcoef, int N, double x) {\n        return N * (x * legeEval(lcoef, N, x) - legeEval(lcoef, N-1, x)) / (x*x - 1);\n    }\n\n    static void legeRoots(double[][] lcoef, int N, out double[] lroots,  out double[] weight) {\n        lroots = new double[N];\n        weight = new double[N];\n\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = Math.Cos(Math.PI * (i - 0.25) / (N + 0.5));\n            do { \n                x1 = x;\n                x -= legeEval(lcoef, N, x) / legeDiff(lcoef, N, x);\n            } \n            while (x != x1);\n            lroots[i-1] = x;\n\n            x1 = legeDiff(lcoef, N, x);\n            weight[i-1] = 2 / ((1 - x*x) * x1*x1);\n        }\n    }\n    \n    \n\n    static double legeInte(Func<Double, Double> f, int N, double[] weights, double[] lroots, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weights[i] * f.Invoke(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n    \n    \n    public static string Combine(double[] arrayD) {\n        return string.Join(\", \", arrayD);\t\n    }\n\n    public static void Main() {\n        int N = 5;\n        \n        var lcoeff = legeCoef(N);\n        \n        double[] roots;\n        double[] weights;\n        legeRoots(lcoeff, N, out roots, out weights);\n        \n        var integrateResult = legeInte(x=>Math.Exp(x), N, weights, roots, -3, 3);\n        \n        Console.WriteLine(\"Roots:   \" + Combine(roots));\n        Console.WriteLine(\"Weights: \" + Combine(weights)+ \"\\n\" );\n        Console.WriteLine(\"integral: \" + integrateResult );\n        Console.WriteLine(\"actual:   \" + (Math.Exp(3)-Math.Exp(-3)) );\n    }\n\n\n}\n"}
{"id": 379493, "name": "Chaos game", "source": "Translate Fortran to C#: PROGRAM CHAOS\n IMPLICIT NONE\n REAL, DIMENSION(3):: KA, KN \n REAL, DIMENSION(3):: DA, DB, DC \n INTEGER:: I, Z\n INTEGER, PARAMETER:: UT = 17\n \n DA = (/    0., 0.,   0. /)\n DB = (/  600., 0.,   0. /)\n DC = (/  500., 0., 400. /)\n \n KA = (/  500., 0., 100. /)\n OPEN (UNIT = UT, FILE = 'aus.csv')\n DO I=1, 1000000\n  Z = ZAHL()\n  WRITE (UT, '(3(F12.6, \";\"))') KA\n  SELECT CASE (Z)\n   CASE (1)\n    CALL MITTELP(KA, DA, KN)\n   CASE (2)\n    CALL MITTELP(KA, DB, KN)\n   CASE (3)\n    CALL MITTELP(KA, DC, KN)\n  END SELECT\n  KA = KN\n END DO\n CLOSE (UT)\n CONTAINS\n  \n  SUBROUTINE MITTELP(P1, P2, MP)\n   REAL, INTENT(IN), DIMENSION(3):: P1, P2\n   REAL, INTENT(OUT), DIMENSION(3):: MP\n   MP = (P1 + P2) / 2.\n  END SUBROUTINE MITTELP\n  \n  INTEGER FUNCTION ZAHL()\n   REAL:: ZZ\n   CALL RANDOM_NUMBER(ZZ)\n   ZZ = ZZ * 3.\n   ZAHL = FLOOR(ZZ) + 1\n   IF (ZAHL .GT. 3) ZAHL = 3\n  END FUNCTION ZAHL\nEND PROGRAM CHAOS\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 379494, "name": "Chaos game", "source": "Translate Fortran to C#: PROGRAM CHAOS\n IMPLICIT NONE\n REAL, DIMENSION(3):: KA, KN \n REAL, DIMENSION(3):: DA, DB, DC \n INTEGER:: I, Z\n INTEGER, PARAMETER:: UT = 17\n \n DA = (/    0., 0.,   0. /)\n DB = (/  600., 0.,   0. /)\n DC = (/  500., 0., 400. /)\n \n KA = (/  500., 0., 100. /)\n OPEN (UNIT = UT, FILE = 'aus.csv')\n DO I=1, 1000000\n  Z = ZAHL()\n  WRITE (UT, '(3(F12.6, \";\"))') KA\n  SELECT CASE (Z)\n   CASE (1)\n    CALL MITTELP(KA, DA, KN)\n   CASE (2)\n    CALL MITTELP(KA, DB, KN)\n   CASE (3)\n    CALL MITTELP(KA, DC, KN)\n  END SELECT\n  KA = KN\n END DO\n CLOSE (UT)\n CONTAINS\n  \n  SUBROUTINE MITTELP(P1, P2, MP)\n   REAL, INTENT(IN), DIMENSION(3):: P1, P2\n   REAL, INTENT(OUT), DIMENSION(3):: MP\n   MP = (P1 + P2) / 2.\n  END SUBROUTINE MITTELP\n  \n  INTEGER FUNCTION ZAHL()\n   REAL:: ZZ\n   CALL RANDOM_NUMBER(ZZ)\n   ZZ = ZZ * 3.\n   ZAHL = FLOOR(ZZ) + 1\n   IF (ZAHL .GT. 3) ZAHL = 3\n  END FUNCTION ZAHL\nEND PROGRAM CHAOS\n", "target": "using System.Diagnostics;\nusing System.Drawing;\n\nnamespace RosettaChaosGame\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var bm = new Bitmap(600, 600);\n\n            var referencePoints = new Point[] {\n                new Point(0, 600),\n                new Point(600, 600),\n                new Point(300, 81)\n            };\n            var r = new System.Random();\n            var p = new Point(r.Next(600), r.Next(600));\n            for (int count = 0; count < 10000; count++)\n            {\n                bm.SetPixel(p.X, p.Y, Color.Magenta);\n                int i = r.Next(3);\n                p.X = (p.X + referencePoints[i].X) / 2;\n                p.Y = (p.Y + referencePoints[i].Y) / 2;\n            }\n            const string filename = \"Chaos Game.png\";\n            bm.Save(filename);\n            Process.Start(filename);\n        }\n    }\n}\n"}
{"id": 379495, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Fortran to C#:       MODULE COMPILER\t\n       INTEGER KBD,MSG\t\t\n\n       INTEGER ENUFF\t\t\n       PARAMETER (ENUFF = 66)\t\n       CHARACTER*(ENUFF) RP\t\n       INTEGER LR\t\t\n\n       INTEGER\t\tOPSYMBOLS\t\t\n       PARAMETER\t(OPSYMBOLS = 11)\t\n       TYPE SYMB\t\t\n        CHARACTER*1\tIS\t\t\n        INTEGER*1\tPRECEDENCE\t\n        CHARACTER*48\tUSAGE\t\t\n       END TYPE SYMB\t\t\n       TYPE(SYMB) SYMBOL(0:OPSYMBOLS)\t\n       PARAMETER (SYMBOL =(/\t\n     o  SYMB(\" \", 0,\"Not recognised as an operator's symbol.\"),\n     1  SYMB(\" \", 1,\"separates symbols and aids legibility.\"),\n     2  SYMB(\")\", 4,\"opened with ( to bracket a sub-expression.\"),\n     3  SYMB(\"]\", 4,\"opened with [ to bracket a sub-expression.\"),\n     4  SYMB(\"}\", 4,\"opened with { to bracket a sub-expression.\"),\n     5  SYMB(\"+\",11,\"addition, and unary + to no effect.\"),\n     6  SYMB(\"-\",11,\"subtraction, and unary - for neg. numbers.\"),\n     7  SYMB(\"*\",12,\"multiplication.\"),\n     8  SYMB(\"\u00d7\",12,\"multiplication, if you can find this.\"),\n     9  SYMB(\"/\",12,\"division.\"),\n     o  SYMB(\"\u00f7\",12,\"division for those with a fancy keyboard.\"),\nC                13 is used so that stacked ^ will have lower priority than incoming ^, thus delivering right-to-left evaluation.\n     1  SYMB(\"^\",14,\"raise to power. Not recognised is **.\")/))\n       CHARACTER*3\tBRAOPEN,BRACLOSE\t\n       PARAMETER\t(BRAOPEN = \"([{\", BRACLOSE = \")]}\")\t\n       INTEGER\t\tBRALEVEL\t\t\n       INTEGER\t\tPRBRA,PRPOW\t\t\n       PARAMETER (PRBRA = SYMBOL( 3).PRECEDENCE)\t\n       PARAMETER (PRPOW = SYMBOL(11).PRECEDENCE)\t\n\n       CHARACTER*10 DIGIT\t\t\n       PARAMETER (DIGIT = \"0123456789\")\t\n\n       INTEGER STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 66)\t\n       TYPE DEFERRED\t\t\t\n        CHARACTER*1\tOPC\t\t\n        INTEGER*1\tPRECEDENCE\t\n       END TYPE DEFERRED\t\t\n       TYPE(DEFERRED) OPSTACK(0:STACKLIMIT)\t\n       INTEGER OSP\t\t\t\n\n       INTEGER INCOMING,TOKENTYPE,NOTHING,ANUMBER,OPENBRA,HUH\t\t\n       PARAMETER (NOTHING = 0, ANUMBER = -1, OPENBRA = -2, HUH = -3)\t\n       CONTAINS\t\n        SUBROUTINE EMIT(STUFF)\t\n         CHARACTER*(*) STUFF\t\n         INTEGER L\t\t\n          WRITE (MSG,1) STUFF\t\n    1     FORMAT (\"Emit  \",A)\t\n          IF (STUFF.EQ.\"\") RETURN\t\n          L = LEN(STUFF)\t\n          IF (LR + L.GE.ENUFF) STOP \"Too much RPN for RP\n          IF (LR.GT.0) THEN\t\n            LR = LR + 1\t\t\t\n            RP(LR:LR) = \" \"\t\t\n          END IF\t\t\n          RP(LR + 1:LR + L) = STUFF\t\n          LR = LR + L\t\t\t\n        END SUBROUTINE EMIT\t\n\n        SUBROUTINE STACKOP(C,P)\t\n         CHARACTER*1 C\t\n         INTEGER P\t\n          OSP = OSP + 1\t\t\n          IF (OSP.GT.STACKLIMIT) STOP \"OSP overtopped\n          OPSTACK(OSP).OPC = C\t\t\n          OPSTACK(OSP).PRECEDENCE = P\t\n          WRITE (MSG,1) C,OPSTACK(1:OSP)\t\n    1     FORMAT (\"Stack \",A1,9X,\",OpStk=\",33(A1,I2:\",\"))\n        END SUBROUTINE STACKOP\t\n\n        LOGICAL FUNCTION COMPILE(TEXT)\t\n         CHARACTER*(*) TEXT\t\n         INTEGER L1,L2\t\t\n         CHARACTER*1 C\t\t\n         INTEGER HAPPY\t\t\n          LR = 0\t\t\n          OSP = 0\t\t\n          OPSTACK(0).OPC = \"\"\t\t\n          OPSTACK(0).PRECEDENCE = 0\t\n          BRALEVEL = 0\t\t\n          HAPPY = +1\t\t\n          L2 = 1\t\t\nChew into an operand, possibly obstructed by an open bracket.\n  100     CALL FORASIGN\t\t\n          IF (TOKENTYPE.EQ.NOTHING) THEN\t\n            IF (OSP.GT.0) CALL GRUMP(\"Another operand or one of \"\t\n     1       //BRAOPEN//\" is expected.\")\t\t\t\t\n          ELSE IF (TOKENTYPE.EQ.ANUMBER) THEN\t\n            CALL EMIT(TEXT(L1:L2 - 1))\t\t\t\n          ELSE IF (TOKENTYPE.EQ.OPENBRA) THEN\t\n            CALL STACKOP(C,PRBRA - 1)\t\t\t\n            GO TO 100\t\t\t\t\t\nC         ELSE IF (TOKENTYPE.EQ.ANAME) THEN\t\nC           CALL EMIT(TEXT(L1:L2 - 1))\t\t\t\n          ELSE\t\t\t\t\t\n            CALL GRUMP(\"Huh? Unexpected \"//C)\t\t\n          END IF\t\t\t\t\nChase after an operator, possibly interrupted by a close bracket,.\n  200     CALL FORASIGN\t\t\n          IF (TOKENTYPE.LT.0) THEN\t\n            CALL GRUMP(\"Operator expected, not \"//C)\t\n           ELSE\t\t\t\n            WRITE (MSG,201) C,INCOMING,OPSTACK(1:OSP)\t\n  201       FORMAT (\"Oprn=>\",A1,\"< Prec=\",I2,\t\t\n     1       \",OpStk=\",33(A1,I2:\",\"))\t\t\t\n            DO WHILE(OPSTACK(OSP).PRECEDENCE .GE. INCOMING)\t\n              IF (OPSTACK(OSP).PRECEDENCE .EQ. PRBRA - 1)\t\t\n     1         CALL GRUMP(\"Unbalanced \"//OPSTACK(OSP).OPC)\t\t\n              CALL EMIT(OPSTACK(OSP).OPC)\t\t\t\t\n              OSP = OSP - 1\t\t\t\t\t\t\n            END DO\t\t\t\t\t\t\n            IF (TOKENTYPE.GT.NOTHING) THEN\t\n              IF (INCOMING.EQ.PRBRA) THEN\t\t\n                CALL BALANCEBRA(C)\t\t\t\n                BRALEVEL = BRALEVEL - 1\t\t\t\n                GO TO 200\t\t\t\t\n               ELSE\t\t\t\t\n                IF (C.EQ.\"^\") INCOMING = PRPOW - 1\t\n                CALL STACKOP(C,INCOMING)\t\t\n              END IF\t\t\t\n            END IF\t\t\t\n          END IF\t\t\nCarry on?\n          IF (HAPPY .GT. 0) GO TO 100 \t\nCompleted.\n          COMPILE = HAPPY.GE.0\t\n         CONTAINS\t\n          SUBROUTINE GRUMP(GROWL)\t\n           CHARACTER*(*) GROWL\t\n            WRITE (MSG,1) GROWL\t\n            IF (L1.GT. 1)        WRITE (MSG,1) \"Tasty:\",TEXT( 1:L1 - 1)\t\n            IF (L2.GT.L1)        WRITE (MSG,1) \"Nasty:\",TEXT(L1:L2 - 1)\t\n            IF (L2.LE.LEN(TEXT)) WRITE (MSG,1) \"Misty:\",TEXT(L2:)\t\n    1       FORMAT (4X,A,1X,A)\t\n            HAPPY = -1\t.\t\n          END SUBROUTINE GRUMP\t\n\n          SUBROUTINE BALANCEBRA(B)\t\n           CHARACTER*1 B\t\n           CHARACTER*1 O\t\n           INTEGER IT,L\t\t\n           CHARACTER*88 GROWL\t\n            O = OPSTACK(OSP).OPC\t\n            WRITE (MSG,1) O,B\t\t\n    1       FORMAT (\"Match \",2A)\t\n            IT = INDEX(BRAOPEN,O)\t\n            IF (IT .EQ. INDEX(BRACLOSE,B)) THEN\t\n              OSP = OSP - 1\t\t\t\n             ELSE\t\n              GROWL = \"Unbalanced {[(...)]} bracketing\n     1         //B//\" is unmatched.\"\t\t\t\t\n              IF (IT.GT.0) GROWL(62:) =  \"A \"//BRACLOSE(IT:IT)\t\n     1         //\" would be better.\"\t\t\n              CALL GRUMP(GROWL)\t\t\n            END IF\t\t\t\n          END SUBROUTINE BALANCEBRA\t\n\n          SUBROUTINE FORASIGN\t\n           INTEGER I\t\n            L1 = L2\t\t\n   10       IF (L1.GT.LEN(TEXT)) THEN\t\n              C = \"\"\t\t\t\n              L2 = L1\t\t\t\n              TOKENTYPE = NOTHING\t\n              INCOMING = SYMBOL(1).PRECEDENCE\t\n              HAPPY = 0\t\t\t\n             ELSE\t\nCheck for spaces and move past them.\n              C = TEXT(L1:L1)\t\n              IF (C.LE.\" \") THEN\t\n                L1 = L1 + 1\t\t\n                GO TO 10\t\t\n              END IF\t\t\nCaught something to inspect.\n              L2 = L1 + 1\t\t\n              IF (INDEX(DIGIT,C).GT.0) THEN\t\n                TOKENTYPE = ANUMBER \t\t\n   20           IF (L2.LE.LEN(TEXT)) THEN\t\n                  IF (INDEX(DIGIT,TEXT(L2:L2)).GT.0) THEN\t\n                    L2 = L2 + 1\t\t\t\n                    GO TO 20\t\t\t\n                  END IF\t\t\t\n                END IF\t\t\t\nC             ELSE IF (INDEX(LETTERS,C).GT.0) THEN\t\nC               advance L2 while in NAMEISH.\n              ELSE IF (INDEX(BRAOPEN,C).GT.0) THEN\t\n                TOKENTYPE = OPENBRA\t\t\t\n              ELSE\t\t\t\n                DO I = OPSYMBOLS,1,-1\t\n                  IF (SYMBOL(I).IS .EQ. C) EXIT\t\n                END DO\t\t\t\n                IF (I.LE.0) THEN\t\n                  TOKENTYPE = HUH\t\t\n                  INCOMING = SYMBOL(0).PRECEDENCE\t\n                 ELSE\t\t\t\n                  TOKENTYPE = I\t\t\t\n                  INCOMING = SYMBOL(I).PRECEDENCE\t\n                END IF\t\t\t\n              END IF\t\t\n            END IF\t\n            WRITE (MSG,30) C,INCOMING,TOKENTYPE\t\t\n   30       FORMAT (\"Next=>\",A1,\"< Prec=\",I2,\",Ttype=\",I2)\t\n          END SUBROUTINE FORASIGN\t\n        END FUNCTION COMPILE\t\n      END MODULE COMPILER\t\n\n      PROGRAM POKE\n      USE COMPILER\n      CHARACTER*66 TEXT\n      LOGICAL HIC\n      MSG = 6\n      KBD = 5\n      WRITE (MSG,1)\n    1 FORMAT (\"Produce RPN from infix...\",/)\n\n   10 WRITE (MSG,11)\n   11 FORMAT(\"Infix: \",$)\n      READ(KBD,12) TEXT\n   12 FORMAT (A)\n      IF (TEXT.EQ.\"\") STOP \"Enough.\"\n      HIC = COMPILE(TEXT)\n      WRITE (MSG,13) HIC,RP(1:LR)\n   13 FORMAT (L6,\" RPN: >\",A,\"<\")\n      GO TO 10\n      END\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        string infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        Console.WriteLine(infix.ToPostfix());\n    }\n}\n\npublic static class ShuntingYard\n{\n    private static readonly Dictionary<string, (string symbol, int precedence, bool rightAssociative)> operators\n        = new (string symbol, int precedence, bool rightAssociative) [] {\n            (\"^\", 4, true),\n            (\"*\", 3, false),\n            (\"/\", 3, false),\n            (\"+\", 2, false),\n            (\"-\", 2, false)\n    }.ToDictionary(op => op.symbol);\n\n    public static string ToPostfix(this string infix) {\n        string[] tokens = infix.Split(' ');\n        var stack = new Stack<string>();\n        var output = new List<string>();\n        foreach (string token in tokens) {\n            if (int.TryParse(token, out _)) {\n                output.Add(token);\n                Print(token);\n            } else if (operators.TryGetValue(token, out var op1)) {\n                while (stack.Count > 0 && operators.TryGetValue(stack.Peek(), out var op2)) {\n                    int c = op1.precedence.CompareTo(op2.precedence);\n                    if (c < 0 || !op1.rightAssociative && c <= 0) {\n                        output.Add(stack.Pop());\n                    } else {\n                        break;\n                    }\n                }\n                stack.Push(token);\n                Print(token);\n            } else if (token == \"(\") {\n                stack.Push(token);\n                Print(token);\n            } else if (token == \")\") {\n                string top = \"\";\n                while (stack.Count > 0 && (top = stack.Pop()) != \"(\") {\n                    output.Add(top);\n                }\n                if (top != \"(\") throw new ArgumentException(\"No matching left parenthesis.\");\n                Print(token);\n            }\n        }\n        while (stack.Count > 0) {\n            var top = stack.Pop();\n            if (!operators.ContainsKey(top)) throw new ArgumentException(\"No matching right parenthesis.\");\n            output.Add(top);\n        }\n        Print(\"pop\");\n        return string.Join(\" \", output);\n        \n        \n        void Print(string action) => Console.WriteLine($\"{action + \":\",-4} {$\"stack[ {string.Join(\" \", stack.Reverse())} ]\",-18} {$\"out[ {string.Join(\" \", output)} ]\"}\");\n        \n        void Print(string action) => Console.WriteLine(\"{0,-4} {1,-18} {2}\", action + \":\", $\"stack[ {string.Join(\" \", stack.Reverse())} ]\", $\"out[ {string.Join(\" \", output)} ]\");\n    }\n}\n"}
{"id": 379496, "name": "Vector", "source": "Translate Fortran to C#: MODULE ROSETTA_VECTOR\n    IMPLICIT NONE\n\n    TYPE VECTOR\n        REAL :: X, Y\n    END TYPE VECTOR\n\n\n    INTERFACE OPERATOR(+)\n       MODULE PROCEDURE VECTOR_ADD\n    END INTERFACE\n\n    INTERFACE OPERATOR(-)\n       MODULE PROCEDURE VECTOR_SUB\n    END INTERFACE\n\n    INTERFACE OPERATOR(/)\n       MODULE PROCEDURE VECTOR_DIV\n    END INTERFACE\n\n    INTERFACE OPERATOR(*)\n       MODULE PROCEDURE VECTOR_MULT\n    END INTERFACE\n\n    CONTAINS\n\n    FUNCTION VECTOR_ADD(VECTOR_1, VECTOR_2)\n        TYPE(VECTOR), INTENT(IN) :: VECTOR_1, VECTOR_2\n        TYPE(VECTOR) :: VECTOR_ADD\n        VECTOR_ADD%X = VECTOR_1%X+VECTOR_2%X\n        VECTOR_ADD%Y = VECTOR_1%Y+VECTOR_2%Y\n    END FUNCTION VECTOR_ADD\n\n    FUNCTION VECTOR_SUB(VECTOR_1, VECTOR_2)\n        TYPE(VECTOR), INTENT(IN) :: VECTOR_1, VECTOR_2\n        TYPE(VECTOR) :: VECTOR_SUB\n        VECTOR_SUB%X = VECTOR_1%X-VECTOR_2%X\n        VECTOR_SUB%Y = VECTOR_1%Y-VECTOR_2%Y\n    END FUNCTION VECTOR_SUB\n\n    FUNCTION VECTOR_DIV(VEC, SCALAR)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        REAL, INTENT(IN) :: SCALAR\n        TYPE(VECTOR) :: VECTOR_DIV\n        VECTOR_DIV%X = VEC%X/SCALAR\n        VECTOR_DIV%Y = VEC%Y/SCALAR\n    END FUNCTION VECTOR_DIV\n\n    FUNCTION VECTOR_MULT(VEC, SCALAR)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        REAL, INTENT(IN) :: SCALAR\n        TYPE(VECTOR) :: VECTOR_MULT\n        VECTOR_MULT%X = VEC%X*SCALAR\n        VECTOR_MULT%Y = VEC%Y*SCALAR\n    END FUNCTION VECTOR_MULT\n\n    FUNCTION FROM_RTHETA(R, THETA)\n        REAL :: R, THETA\n        TYPE(VECTOR) :: FROM_RTHETA\n        FROM_RTHETA%X = R*SIN(THETA)\n        FROM_RTHETA%Y = R*COS(THETA)\n    END FUNCTION FROM_RTHETA\n\n    FUNCTION FROM_XY(X, Y)\n        REAL :: X, Y\n        TYPE(VECTOR) :: FROM_XY\n        FROM_XY%X = X\n        FROM_XY%Y = Y\n    END FUNCTION FROM_XY\n\n    FUNCTION PRETTY_PRINT(VEC)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        CHARACTER(LEN=100) PRETTY_PRINT\n        WRITE(PRETTY_PRINT,\"(A, F0.5, A, F0.5, A)\") \"[\", VEC%X, \", \", VEC%Y, \"]\"\n    END FUNCTION PRETTY_PRINT\nEND MODULE ROSETTA_VECTOR\n\nPROGRAM VECTOR_DEMO\n    USE ROSETTA_VECTOR\n    IMPLICIT NONE\n\n    TYPE(VECTOR) :: VECTOR_1, VECTOR_2\n    REAL, PARAMETER :: PI = 4*ATAN(1.0)\n    REAL :: SCALAR\n\n    SCALAR = 2.0\n\n    VECTOR_1 = FROM_XY(2.0, 3.0)\n    VECTOR_2 = FROM_RTHETA(2.0, PI/6.0)\n\n    WRITE(*,*) \"VECTOR_1 (X: 2.0, Y: 3.0)     \u00a0: \", PRETTY_PRINT(VECTOR_1)\n    WRITE(*,*) \"VECTOR_2 (R: 2.0, THETA: PI/6)\u00a0: \", PRETTY_PRINT(VECTOR_2)\n    WRITE(*,*) NEW_LINE('A')\n    WRITE(*,*) \"VECTOR_1  +  VECTOR_2          = \", PRETTY_PRINT(VECTOR_1+VECTOR_2)\n    WRITE(*,*) \"VECTOR_1  -  VECTOR_2          = \", PRETTY_PRINT(VECTOR_1-VECTOR_2)\n    WRITE(*,*) \"VECTOR_1  /  2.0               = \", PRETTY_PRINT(VECTOR_1/SCALAR)\n    WRITE(*,*) \"VECTOR_1  *  2.0               = \", PRETTY_PRINT(VECTOR_1*SCALAR)\nEND PROGRAM VECTOR_DEMO\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RosettaVectors\n{\n    public class Vector\n    {\n        public double[] store;\n        public Vector(IEnumerable<double> init)\n        {\n            store = init.ToArray();\n        }\n        public Vector(double x, double y)\n        {\n            store = new double[] { x, y };\n        }\n        static public Vector operator+(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a + b));\n        }\n        static public Vector operator -(Vector v1, Vector v2)\n        {\n            return new Vector(v1.store.Zip(v2.store, (a, b) => a - b));\n        }\n        static public Vector operator *(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x * scalar));\n        }\n        static public Vector operator /(Vector v1, double scalar)\n        {\n            return new Vector(v1.store.Select(x => x / scalar));\n        }\n        public override string ToString()\n        {\n            return string.Format(\"[{0}]\", string.Join(\",\", store));\n        }\n    }\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var v1 = new Vector(5, 7);\n            var v2 = new Vector(2, 3);\n            Console.WriteLine(v1 + v2);\n            Console.WriteLine(v1 - v2);\n            Console.WriteLine(v1 * 11);\n            Console.WriteLine(v1 / 2);\n            \n            var lostVector = new Vector(new double[] { 4, 8, 15, 16, 23, 42 });\n            Console.WriteLine(lostVector * 7);\n            Console.ReadLine();\n        }\n    }\n}\n"}
{"id": 379497, "name": "Prime conspiracy", "source": "Translate Fortran to C#:       PROGRAM INHERIT\t\n      USE PRIMEBAG\t\n      INTEGER MBASE,P0,NHIC\t\n      PARAMETER (MBASE = 13, P0 = 2, NHIC = 100000000)\t\n      INTEGER N(0:MBASE - 1,0:MBASE - 1,2:MBASE)\t\n      INTEGER I,B,D1,D2\t\n      INTEGER P,PP\t\n\n      MSG = 6\t\t\n      WRITE (MSG,1) MBASE,P0,NHIC\t\n    1 FORMAT (\"Working in base 2 to \",I0,\" count the transitions \"\n     1 \"from the low-order digit of one prime number \",/,\n     2 \"to the low-order digit of its successor. Starting with \",I0,\n     3 \" and making \",I0,\" advances.\")\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\nChug through the primes.\n   10 N = 0\t\n      P = P0\t\n      DO I = 1,NHIC\t\n        PP = P\t\t\t\n        P = NEXTPRIME(P)\t\n        DO B = 2,MBASE\t\t\n          D1 = MOD(PP,B)\t\t\n          D2 = MOD(P,B)\t\t\t\n          N(D1,D2,B) = N(D1,D2,B) + 1\t\n        END DO\t\t\t\n      END DO\t\t\n      WRITE (MSG,11) P\t\n   11 FORMAT (\"Ending with \",I0)\t\n\nCast forth the results.\n   20 DO B = 2,MBASE\t\n        WRITE (MSG,21) B\t\t\n   21   FORMAT (/,\"For base \",I0)\t\n        WRITE (MSG,22) (D1, D1 = 0,B - 1)\t\n   22   FORMAT (\" Last digit ending  \",I2,66I9)\t\n        DO D2 = 0,B - 1\t\t\n          IF (ALL(N(0:B - 1,D2,B).EQ.0)) CYCLE\t\n          WRITE (MSG,23) D2,N(0:B - 1,D2,B)\t\n   23     FORMAT (\" next prime ends\",I3,\":\",I2,66I9)\t\n        END DO\t\t\t\n      END DO\t\t\n      END\t\n", "target": "using System;\n\nnamespace PrimeConspiracy {\n    class Program {\n        static void Main(string[] args) {\n            const int limit = 1_000_000;\n            const int sieveLimit = 15_500_000;\n\n            int[,] buckets = new int[10, 10];\n            int prevDigit = 2;\n            bool[] notPrime = Sieve(sieveLimit);\n\n            for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n                if (notPrime[n]) continue;\n\n                int digit = n % 10;\n                buckets[prevDigit, digit]++;\n                prevDigit = digit;\n                primeCount++;\n            }\n\n            for (int i = 0; i < 10; i++) {\n                for (int j = 0; j < 10; j++) {\n                    if (buckets[i, j] != 0) {\n                        Console.WriteLine(\"{0} -> {1}  count: {2,5:d}  frequency\u00a0: {3,6:0.00%}\", i, j, buckets[i, j], 1.0 * buckets[i, j] / limit);\n                    }\n                }\n            }\n        }\n\n        public static bool[] Sieve(int limit) {\n            bool[] composite = new bool[limit];\n            composite[0] = composite[1] = true;\n\n            int max = (int)Math.Sqrt(limit);\n            for (int n = 2; n <= max; n++) {\n                if (!composite[n]) {\n                    for (int k = n * n; k < limit; k += n) {\n                        composite[k] = true;\n                    }\n                }\n            }\n\n            return composite;\n        }\n    }\n}\n"}
{"id": 379498, "name": "Statistics_Normal distribution", "source": "Translate Fortran to C#: program Normal_Distribution\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: r64 = selected_real_kind(15)\n  integer(i64), parameter :: samples = 1000000_i64\n  real(r64) :: mean, stddev\n  real(r64) :: sumn = 0, sumnsq = 0\n  integer(i64) :: n = 0 \n  integer(i64) :: bin(-50:50) = 0\n  integer :: i, ind\n  real(r64) :: ur1, ur2, nr1, nr2, s\n  \n  n = 0\n  do while(n <= samples)\n    call random_number(ur1)\n    call random_number(ur2)\n    ur1 = ur1 * 2.0 - 1.0\n    ur2 = ur2 * 2.0 - 1.0\n    \n    s = ur1*ur1 + ur2*ur2  \n    if(s >= 1.0_r64) cycle\n      \n    nr1 = ur1 * sqrt(-2.0*log(s)/s)\n    ind = floor(5.0*nr1)\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + nr1\n    sumnsq = sumnsq + nr1*nr1\n    \n    nr2 = ur2 * sqrt(-2.0*log(s)/s)\n    ind = floor(5.0*nr2)\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + nr2\n    sumnsq = sumnsq + nr2*nr2\n    n = n + 2_i64\n  end do\n \n  mean = sumn / n\n  stddev = sqrt(sumnsq/n - mean*mean)\n  \n  write(*, \"(a, i0)\") \"sample size = \", samples\n  write(*, \"(a, f17.15)\") \"Mean\u00a0:   \", mean,\n  write(*, \"(a, f17.15)\") \"Stddev\u00a0: \", stddev\n  \n  do i = -15, 15 \n    write(*, \"(f4.1, a, a)\") real(i)/5.0, \": \", repeat(\"=\", int(bin(i)*500/samples))\n  end do\n       \nend program\n", "target": "using System;\nusing MathNet.Numerics.Distributions;\nusing MathNet.Numerics.Statistics;\n\nclass Program\n{\n    static void RunNormal(int sampleSize)\n    {\n        double[] X = new double[sampleSize];\n        var norm = new Normal(new Random());\n        norm.Samples(X);\n\n        const int numBuckets = 10;\n        var histogram = new Histogram(X, numBuckets);\n        Console.WriteLine(\"Sample size: {0:N0}\", sampleSize);\n        for (int i = 0; i < numBuckets; i++)\n        {\n            string bar = new String('#', (int)(histogram[i].Count * 360 / sampleSize));\n            Console.WriteLine(\" {0:0.00}\u00a0: {1}\", histogram[i].LowerBound, bar);\n        }\n        var statistics = new DescriptiveStatistics(X);\n        Console.WriteLine(\"  Mean: \" + statistics.Mean);\n        Console.WriteLine(\"StdDev: \" + statistics.StandardDeviation);\n        Console.WriteLine();\n    }\n    static void Main(string[] args)\n    {\n        RunNormal(100);\n        RunNormal(1000);\n        RunNormal(10000);\n    }\n}\n"}
{"id": 379499, "name": "The sieve of Sundaram", "source": "Translate Fortran to C#:       PROGRAM SUNDARAM\n      IMPLICIT NONE\n\n\n\n      INTEGER(8)  ::  curr_index\n      INTEGER(8)  ::  i\n      INTEGER(8)  ::  j\n      INTEGER  ::  lim\n      INTEGER(8)  ::  mid\n      INTEGER  ::  primcount\n      LOGICAL*1 , ALLOCATABLE , DIMENSION(:)  ::  primes \n      lim = 10000000 \n      ALLOCATE(primes(lim))\n      primes(1:lim) = .TRUE.\n                        \n      mid = lim/2\n \n\n      DO j = 1 , mid\n         DO i = 1 , j\n            curr_index = i + j + (2*i*j)\n            IF( curr_index>lim )EXIT        \n            primes(curr_index) = .FALSE.    \n         END DO\n      END DO\n\n      i = 0\n      j = 0\n      WRITE(6 , *)'The first 100 primes:'\n      DO WHILE ( i < 100 )\n         j = j + 1\n         IF( primes(j) )THEN\n            WRITE(6 , 34 , ADVANCE = 'no')j*2 + 1   \n 34         FORMAT(I0 , 1x)\n            i = i + 1                       \n            IF( MOD(i,10)==0 )WRITE(6 , *)' '\n         END IF\n      END DO\n\n      primcount = 0\n      DO i = 1 , lim\n         IF( primes(i) )THEN\n            primcount = primcount + 1\n            IF( primcount==1000000 )THEN\n               WRITE(6 , 35)'1 millionth Prime Found: ' , (i*2) + 1\n 35            FORMAT(/ , a , i0)\n               EXIT\n            END IF\n         END IF\n      END DO\n      DEALLOCATE(primes)\n      STOP\n      END PROGRAM SUNDARAM\n", "target": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nclass Program\n{\n    static string fmt(int[] a)\n    {\n        var sb = new System.Text.StringBuilder();\n        for (int i = 0; i < a.Length; i++)\n            sb.Append(string.Format(\"{0,5}{1}\",\n              a[i], i % 10 == 9 ? \"\\n\" : \" \"));\n        return sb.ToString();\n    }\n\n    static void Main(string[] args)\n    {\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        var pr = PG.Sundaram(15_500_000).Take(1_000_000).ToArray();\n        sw.Stop();\n        Write(\"The first 100 odd prime numbers:\\n{0}\\n\",\n          fmt(pr.Take(100).ToArray()));\n        Write(\"The millionth odd prime number: {0}\", pr.Last());\n        Write(\"\\n{0} ms\", sw.Elapsed.TotalMilliseconds);\n    }\n}\n\nclass PG\n{\n    public static IEnumerable<int> Sundaram(int n)\n    {\n        \n        int i = 1, k = (n + 1) >> 1, t = 1, v = 1, d = 1, s = 1;\n        var comps = new bool[k + 1];\n        for (; t < k; t = ((++i + (s += d += 2)) << 1) - d - 2)\n            while ((t += d + 2) < k)\n                comps[t] = true;\n        for (; v < k; v++)\n            if (!comps[v])\n                yield return (v << 1) + 1;\n    }\n}\n"}
{"id": 379500, "name": "Singly-linked list_Element removal", "source": "Translate Fortran to C#:       MODULE SIMPLELINKEDLIST\t\n       CONTAINS\t\t\t\n        SUBROUTINE LLREMOVE(LINK,X)\t\n         INTEGER LINK(0:)\t\n         INTEGER X\t\t\n         INTEGER IT\t\t\n          IT = 0\t\t\n          DO WHILE(LINK(IT).GT.0)\t\n            IF (LINK(IT).EQ.X) THEN\t\t\n              LINK(IT) = LINK(LINK(IT))\t\t\n              RETURN\t\t\t\t\n            END IF\t\t\t\n            IT = LINK(IT)\t\t\n          END DO\t\t\n        END SUBROUTINE LLREMOVE\t\n\n        SUBROUTINE LLFOLLOW(LINK)\t\n         INTEGER LINK(0:)\t\n          IT = 0\t\t\t\n          WRITE (6,1) \"Head\",IT,LINK(IT)\t\n    1     FORMAT (A6,I3,\" -->\",I3)\t\t\n    2     IT = LINK(IT)\t\t\n          IF (IT.LE.0) RETURN\t\t\n          WRITE (6,1) \"at\",IT,LINK(IT)\t\n          GO TO 2\t\t\t\n        END SUBROUTINE LLFOLLOW\t\n      END MODULE SIMPLELINKEDLIST\t\n\n      PROGRAM POKE\n      USE SIMPLELINKEDLIST\t\n      INTEGER LINK(0:5)\t\t\n      DATA LINK/3, 2,4,1,5,0/\t\n\n      WRITE (6,*) \"A linked-list, no cargo.\"\n      CALL LLFOLLOW(LINK)\n\n      WRITE (6,*) \"The element at one suffers disfavour.\"\n      CALL LLREMOVE(LINK,1)\n      CALL LLFOLLOW(LINK)\n\n      WRITE (6,*) \"Off with the head\n      CALL LLREMOVE(LINK,LINK(0))\t\n      CALL LLFOLLOW(LINK)\n\n      WRITE (6,*) \"And off with the tail.\"\n      CALL LLREMOVE(LINK,5)\t\t\n      CALL LLFOLLOW(LINK)\t\t\n\n      END\n", "target": "using System;\nusing System.Runtime.InteropServices;\n\nstatic unsafe class Program\n{\n    ref struct LinkedListNode\n    {\n        public int Value;\n        public LinkedListNode* Next;\n        public override string ToString() => this.Value + (this.Next == null ? string.Empty : \" -> \" + this.Next->ToString());\n    }\n\n    static void Remove(LinkedListNode** head, LinkedListNode* entry)\n    {\n        \n        \n\n        LinkedListNode** indirect = head;\n\n        \n        \n\n        while (*indirect != entry)\n            indirect = &(*indirect)->Next;\n\n        \n        *indirect = entry->Next;\n    }\n\n    static void Main()\n    {\n        \n        var head = (LinkedListNode*)Marshal.AllocHGlobal(sizeof(LinkedListNode));\n        head->Value = 1;\n        head->Next = (LinkedListNode*)Marshal.AllocHGlobal(sizeof(LinkedListNode));\n        head->Next->Value = 2;\n        head->Next->Next = null;\n\n        LinkedListNode copy = *head;\n\n        Console.WriteLine(\"original:                    \" + head->ToString());\n\n        Remove(&head, head);\n        Console.WriteLine(\"after removing head:         \" + head->ToString());\n\n        head = &copy;\n        Console.WriteLine(\"restored from copy:          \" + head->ToString());\n\n        Remove(&head, head->Next);\n        Console.WriteLine(\"after removing second node:  \" + head->ToString());\n    }\n}\n"}
{"id": 379501, "name": "Gauss-Jordan matrix inversion", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n      SUBROUTINE GJINV (A, LDA, N, B, LDB, IERR)\n       IMPLICIT NONE\n       INTEGER LDA, N, LDB, IERR\n       REAL A(LDA,N), B(LDB,N)\n\n       REAL EPS                                  \n       PARAMETER (EPS = 1.1920929E-07)\n       INTEGER I, J, K, P                        \n       REAL F, TOL\n\n\n\n\n       IF (N < 1) THEN            \n         IERR = -1\n         RETURN\n       ELSE IF (N > LDA .OR. N > LDB) THEN\n         IERR = -2\n         RETURN\n       END IF\n       IERR = 0\n\n       F = 0.                     \n       DO J = 1, N\n         DO I = 1, N\n           F = F + A(I,J)**2\n         END DO\n       END DO\n       F = SQRT(F)\n       TOL = F * EPS\n\n       DO J = 1, N                \n         DO I = 1, N\n           IF (I .EQ. J) THEN\n             B(I,J) = 1.\n           ELSE\n             B(I,J) = 0.\n           END IF\n         END DO\n       END DO\n\n\n       DO K = 1, N\n         F = ABS(A(K,K))          \n         P = K\n         DO I = K+1, N\n           IF (ABS(A(I,K)) > F) THEN\n             F = ABS(A(I,K))\n             P = I\n           END IF\n         END DO\n\n         IF (F < TOL) THEN        \n           IERR = 1\n           RETURN\n         END IF\n\n         IF (P .NE. K) THEN       \n           DO J = K, N\n             F = A(K,J)\n             A(K,J) = A(P,J)\n             A(P,J) = F\n           END DO\n           DO J = 1, N\n             F = B(K,J)\n             B(K,J) = B(P,J)\n             B(P,J) = F\n           END DO\n         END IF\n\n         F = 1. / A(K,K)          \n         DO J = K, N\n           A(K,J) = A(K,J) * F\n         END DO\n         DO J = 1, N\n           B(K,J) = B(K,J) * F\n         END DO\n\n         DO 10 I = 1, N           \n           IF (I .EQ. K) GO TO 10\n           F = A(I,K)\n           DO J = K, N\n             A(I,J) = A(I,J) - A(K,J) * F\n           END DO\n           DO J = 1, N\n             B(I,J) = B(I,J) - B(K,J) * F\n           END DO\n  10     CONTINUE\n       END DO\n\n       RETURN\n      END  \n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 379502, "name": "Gauss-Jordan matrix inversion", "source": "Translate Fortran to C#: \n\n\n\n\n\n\n\n\n\n\n\n\n      SUBROUTINE GJINV (A, LDA, N, B, LDB, IERR)\n       IMPLICIT NONE\n       INTEGER LDA, N, LDB, IERR\n       REAL A(LDA,N), B(LDB,N)\n\n       REAL EPS                                  \n       PARAMETER (EPS = 1.1920929E-07)\n       INTEGER I, J, K, P                        \n       REAL F, TOL\n\n\n\n\n       IF (N < 1) THEN            \n         IERR = -1\n         RETURN\n       ELSE IF (N > LDA .OR. N > LDB) THEN\n         IERR = -2\n         RETURN\n       END IF\n       IERR = 0\n\n       F = 0.                     \n       DO J = 1, N\n         DO I = 1, N\n           F = F + A(I,J)**2\n         END DO\n       END DO\n       F = SQRT(F)\n       TOL = F * EPS\n\n       DO J = 1, N                \n         DO I = 1, N\n           IF (I .EQ. J) THEN\n             B(I,J) = 1.\n           ELSE\n             B(I,J) = 0.\n           END IF\n         END DO\n       END DO\n\n\n       DO K = 1, N\n         F = ABS(A(K,K))          \n         P = K\n         DO I = K+1, N\n           IF (ABS(A(I,K)) > F) THEN\n             F = ABS(A(I,K))\n             P = I\n           END IF\n         END DO\n\n         IF (F < TOL) THEN        \n           IERR = 1\n           RETURN\n         END IF\n\n         IF (P .NE. K) THEN       \n           DO J = K, N\n             F = A(K,J)\n             A(K,J) = A(P,J)\n             A(P,J) = F\n           END DO\n           DO J = 1, N\n             F = B(K,J)\n             B(K,J) = B(P,J)\n             B(P,J) = F\n           END DO\n         END IF\n\n         F = 1. / A(K,K)          \n         DO J = K, N\n           A(K,J) = A(K,J) * F\n         END DO\n         DO J = 1, N\n           B(K,J) = B(K,J) * F\n         END DO\n\n         DO 10 I = 1, N           \n           IF (I .EQ. K) GO TO 10\n           F = A(I,K)\n           DO J = K, N\n             A(I,J) = A(I,J) - A(K,J) * F\n           END DO\n           DO J = 1, N\n             B(I,J) = B(I,J) - B(K,J) * F\n           END DO\n  10     CONTINUE\n       END DO\n\n       RETURN\n      END  \n", "target": "using System;\n\nnamespace Rosetta\n{\n    internal class Vector\n    {\n        private double[] b;\n        internal readonly int rows;\n\n        internal Vector(int rows)\n        {\n            this.rows = rows;\n            b = new double[rows];\n        }\n\n        internal Vector(double[] initArray)\n        {\n            b = (double[])initArray.Clone();\n            rows = b.Length;\n        }\n\n        internal Vector Clone()\n        {\n            Vector v = new Vector(b);\n            return v;\n        }\n\n        internal double this[int row]\n        {\n            get { return b[row]; }\n            set { b[row] = value; }\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            double tmp = b[r1];\n            b[r1] = b[r2];\n            b[r2] = tmp;\n        }\n\n        internal double norm(double[] weights)\n        {\n            double sum = 0;\n            for (int i = 0; i < rows; i++)\n            {\n                double d = b[i] * weights[i];\n                sum +=  d*d;\n            }\n            return Math.Sqrt(sum);\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n                Console.WriteLine(b[i]);\n            Console.WriteLine();\n        }\n\n        public static Vector operator-(Vector lhs, Vector rhs)\n        {\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n                v[i] = lhs[i] - rhs[i];\n            return v;\n        }\n    }\n\n    class Matrix\n    {\n        private double[] b;\n        internal readonly int rows, cols;\n\n        internal Matrix(int rows, int cols)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = new double[rows * cols];            \n        }\n\n        internal Matrix(int size)\n        {\n            this.rows = size;\n            this.cols = size;\n            b = new double[rows * cols];\n            for (int i = 0; i < size; i++)\n                this[i, i] = 1;\n        }\n\n        internal Matrix(int rows, int cols, double[] initArray)\n        {\n            this.rows = rows;\n            this.cols = cols;\n            b = (double[])initArray.Clone();\n            if (b.Length != rows * cols) throw new Exception(\"bad init array\");\n        }\n\n        internal double this[int row, int col]\n        {\n            get { return b[row * cols + col]; }\n            set { b[row * cols + col] = value; }\n        }        \n        \n        public static Vector operator*(Matrix lhs, Vector rhs)\n        {\n            if (lhs.cols != rhs.rows) throw new Exception(\"I can't multiply matrix by vector\");\n            Vector v = new Vector(lhs.rows);\n            for (int i = 0; i < lhs.rows; i++)\n            {\n                double sum = 0;\n                for (int j = 0; j < rhs.rows; j++)\n                    sum += lhs[i,j]*rhs[j];\n                v[i] = sum;\n            }\n            return v;\n        }\n\n        internal void SwapRows(int r1, int r2)\n        {\n            if (r1 == r2) return;\n            int firstR1 = r1 * cols;\n            int firstR2 = r2 * cols;\n            for (int i = 0; i < cols; i++)\n            {\n                double tmp = b[firstR1 + i];\n                b[firstR1 + i] = b[firstR2 + i];\n                b[firstR2 + i] = tmp;\n            }\n        }\n\n        \n        internal bool InvPartial()\n        {\n            const double Eps = 1e-12;\n            if (rows != cols) throw new Exception(\"rows\u00a0!= cols for Inv\");\n            Matrix M = new Matrix(rows); \n            for (int diag = 0; diag < rows; diag++)\n            {\n                int max_row = diag;\n                double max_val = Math.Abs(this[diag, diag]);\n                double d;\n                for (int row = diag + 1; row < rows; row++)\n                    if ((d = Math.Abs(this[row, diag])) > max_val)\n                    {\n                        max_row = row;\n                        max_val = d;\n                    }\n                if (max_val <= Eps) return false;\n                SwapRows(diag, max_row);\n                M.SwapRows(diag, max_row);\n                double invd = 1 / this[diag, diag];\n                for (int col = diag; col < cols; col++)\n                {\n                    this[diag, col] *= invd;\n                }\n                for (int col = 0; col < cols; col++)\n                {\n                    M[diag, col] *= invd;\n                }\n                for (int row = 0; row < rows; row++)\n                {\n                    d = this[row, diag];\n                    if (row != diag)\n                    {\n                        for (int col = diag; col < this.cols; col++)\n                        {\n                            this[row, col] -= d * this[diag, col];\n                        }\n                        for (int col = 0; col < this.cols; col++)\n                        {\n                            M[row, col] -= d * M[diag, col];\n                        }\n                    }\n                }\n            }\n            b = M.b;\n            return true;\n        }\n\n        internal void print()\n        {\n            for (int i = 0; i < rows; i++)\n            {\n                for (int j = 0; j < cols; j++)\n                    Console.Write(this[i,j].ToString()+\"  \");\n                Console.WriteLine();\n            }\n        }\n    }\n}\n"}
{"id": 388631, "name": "24 game", "source": "Translate Fortran to Java: program game_24\n  implicit none\n  real               :: vector(4), reals(11), result, a, b, c, d\n  integer            :: numbers(4), ascii(11), i\n  character(len=11)  :: expression\n  character          :: syntax(11)\n  \n  character, parameter :: one(11)   = (/ '(','(','1','x','1',')','x','1',')','x','1' /)\n  character, parameter :: two(11)   = (/ '(','1','x','(','1','x','1',')',')','x','1' /)\n  character, parameter :: three(11) = (/ '1','x','(','(','1','x','1',')','x','1',')' /)\n  character, parameter :: four(11)  = (/ '1','x','(','1','x','(','1','x','1',')',')' /)\n  character, parameter :: five(11)  = (/ '(','1','x','1',')','x','(','1','x','1',')' /)\n  \n  do\n    call random_number(vector)\n    numbers = 9 * vector + 1\n    write (*,*) 'Digits: ',numbers\n    write (*,'(a)',advance='no') 'Your expression: '\n    read (*,'(a11)') expression\n\n    forall (i=1:11) syntax(i) = expression(i:i)\n    ascii = iachar(syntax)\n    where (syntax >= '0' .and. syntax <= '9')\n      syntax = '1'  \n    elsewhere (syntax == '+' .or. syntax == '-' .or. syntax == '*' .or. syntax == '/')\n      syntax = 'x'  \n    elsewhere (syntax /= '(' .and. syntax /= ')')\n      syntax = '-'  \n    end where\n\n    reals = real(ascii-48)\n    if ( all(syntax == one) ) then\n      a = reals(3); b = reals(5); c = reals(8); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(op(a,4,b),7,c),10,d)\n    else if ( all(syntax == two) ) then\n      a = reals(2); b = reals(5); c = reals(7); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,op(b,6,c)),10,d)\n    else if ( all(syntax == three) ) then\n      a = reals(1); b = reals(5); c = reals(7); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(op(b,6,c),9,d))\n    else if ( all(syntax == four) ) then\n      a = reals(1); b = reals(4); c = reals(7); d = reals(9)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(b,5,op(c,8,d)))\n    else if ( all(syntax == five) ) then\n      a = reals(2); b = reals(4); c = reals(8); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,b),6,op(c,9,d))\n    else\n      stop 'Input string: incorrect syntax.'\n    end if\n\n    if ( abs(result-24.0) < epsilon(1.0) ) then\n      write (*,*) 'You won\n    else\n      write (*,*) 'Your result (',result,') is incorrect\n    end if\n  \n    write (*,'(a)',advance='no') 'Another one? [y/n] '\n    read (*,'(a1)') expression\n    if ( expression(1:1) == 'n' .or. expression(1:1) == 'N' ) then\n      stop\n    end if  \n  end do\n  \ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in) :: x,y\n    select case ( char(ascii(c)) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n  \n  subroutine check_numbers(a,b,c,d)\n    real, intent(in) :: a,b,c,d\n    integer          :: test(4)\n    test = (/ nint(a),nint(b),nint(c),nint(d) /)\n    call Insertion_Sort(numbers)\n    call Insertion_Sort(test)\n    if ( any(test /= numbers) ) then\n      stop 'You cheat\u00a0;-) (Incorrect numbers)'\n    end if\n  end subroutine check_numbers\n  \n  pure subroutine Insertion_Sort(a)\n    integer, intent(inout) :: a(:)\n    integer                :: temp, i, j\n    do i=2,size(a)\n      j = i-1\n      temp = a(i)\n      do while ( j>=1 .and. a(j)>temp )\n        a(j+1) = a(j)\n        j = j - 1\n      end do\n      a(j+1) = temp\n    end do\n  end subroutine Insertion_Sort\n\nend program game_24\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 388632, "name": "24 game", "source": "Translate Fortran to Java: program game_24\n  implicit none\n  real               :: vector(4), reals(11), result, a, b, c, d\n  integer            :: numbers(4), ascii(11), i\n  character(len=11)  :: expression\n  character          :: syntax(11)\n  \n  character, parameter :: one(11)   = (/ '(','(','1','x','1',')','x','1',')','x','1' /)\n  character, parameter :: two(11)   = (/ '(','1','x','(','1','x','1',')',')','x','1' /)\n  character, parameter :: three(11) = (/ '1','x','(','(','1','x','1',')','x','1',')' /)\n  character, parameter :: four(11)  = (/ '1','x','(','1','x','(','1','x','1',')',')' /)\n  character, parameter :: five(11)  = (/ '(','1','x','1',')','x','(','1','x','1',')' /)\n  \n  do\n    call random_number(vector)\n    numbers = 9 * vector + 1\n    write (*,*) 'Digits: ',numbers\n    write (*,'(a)',advance='no') 'Your expression: '\n    read (*,'(a11)') expression\n\n    forall (i=1:11) syntax(i) = expression(i:i)\n    ascii = iachar(syntax)\n    where (syntax >= '0' .and. syntax <= '9')\n      syntax = '1'  \n    elsewhere (syntax == '+' .or. syntax == '-' .or. syntax == '*' .or. syntax == '/')\n      syntax = 'x'  \n    elsewhere (syntax /= '(' .and. syntax /= ')')\n      syntax = '-'  \n    end where\n\n    reals = real(ascii-48)\n    if ( all(syntax == one) ) then\n      a = reals(3); b = reals(5); c = reals(8); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(op(a,4,b),7,c),10,d)\n    else if ( all(syntax == two) ) then\n      a = reals(2); b = reals(5); c = reals(7); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,op(b,6,c)),10,d)\n    else if ( all(syntax == three) ) then\n      a = reals(1); b = reals(5); c = reals(7); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(op(b,6,c),9,d))\n    else if ( all(syntax == four) ) then\n      a = reals(1); b = reals(4); c = reals(7); d = reals(9)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(b,5,op(c,8,d)))\n    else if ( all(syntax == five) ) then\n      a = reals(2); b = reals(4); c = reals(8); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,b),6,op(c,9,d))\n    else\n      stop 'Input string: incorrect syntax.'\n    end if\n\n    if ( abs(result-24.0) < epsilon(1.0) ) then\n      write (*,*) 'You won\n    else\n      write (*,*) 'Your result (',result,') is incorrect\n    end if\n  \n    write (*,'(a)',advance='no') 'Another one? [y/n] '\n    read (*,'(a1)') expression\n    if ( expression(1:1) == 'n' .or. expression(1:1) == 'N' ) then\n      stop\n    end if  \n  end do\n  \ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in) :: x,y\n    select case ( char(ascii(c)) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n  \n  subroutine check_numbers(a,b,c,d)\n    real, intent(in) :: a,b,c,d\n    integer          :: test(4)\n    test = (/ nint(a),nint(b),nint(c),nint(d) /)\n    call Insertion_Sort(numbers)\n    call Insertion_Sort(test)\n    if ( any(test /= numbers) ) then\n      stop 'You cheat\u00a0;-) (Incorrect numbers)'\n    end if\n  end subroutine check_numbers\n  \n  pure subroutine Insertion_Sort(a)\n    integer, intent(inout) :: a(:)\n    integer                :: temp, i, j\n    do i=2,size(a)\n      j = i-1\n      temp = a(i)\n      do while ( j>=1 .and. a(j)>temp )\n        a(j+1) = a(j)\n        j = j - 1\n      end do\n      a(j+1) = temp\n    end do\n  end subroutine Insertion_Sort\n\nend program game_24\n", "target": "import java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n"}
{"id": 388633, "name": "Enforced immutability", "source": "Translate Fortran to Java: real, parameter :: pi = 3.141593\n", "target": "final int immutableInt = 4;\nint mutableInt = 4;\nmutableInt = 6; \nimmutableInt = 6; \n"}
{"id": 388634, "name": "Hofstadter Q sequence", "source": "Translate Fortran to Java: Calculate the Hofstadter Q-sequence, using a big array rather than recursion.\n      INTEGER ENUFF\n      PARAMETER (ENUFF = 100000)\n      INTEGER Q(ENUFF)\t\n\n      Q(1) = 1\t\t\n      Q(2) = 1\n      Q(3:) = -123456789\n      DO I = 3,ENUFF\t\n        Q(I) = Q(I - Q(I - 1)) + Q(I - Q(I - 2))\t\n      END DO\nCast forth results as per the specification.\n      WRITE (6,1) Q(1:10)\t\t\n    1 FORMAT (\"First ten values:\",10I2)\t\n      WRITE (6,*) \"Q(1000) =\",Q(1000)\t\n      WRITE (6,3) ENUFF,COUNT(Q(2:ENUFF) < Q(1:ENUFF - 1))\t\n    3 FORMAT (\"Count of those elements 2:\",I0,\n     1 \" which are less than their predecessor: \",I0)\t\nCurry favour by allowing enquiries.\n   10 WRITE (6,11) ENUFF\n   11 FORMAT (\"Nominate an index (in 1:\",I0,\"): \",$)\t\n      READ (5,*,END = 999, ERR = 999) I\t\n      IF (I.GT.0 .AND. I.LE.ENUFF) THEN\t\n        WRITE (6,12) I,Q(I)\t\t\n   12   FORMAT (\"Q(\",I0,\") = \",I0)\t\n        GO TO 10\t\t\t\n      END IF\t\t\nClosedown.\n  999 WRITE (6,*) \"Bye.\"\n      END\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 388635, "name": "Hofstadter Q sequence", "source": "Translate Fortran to Java: Calculate the Hofstadter Q-sequence, using a big array rather than recursion.\n      INTEGER ENUFF\n      PARAMETER (ENUFF = 100000)\n      INTEGER Q(ENUFF)\t\n\n      Q(1) = 1\t\t\n      Q(2) = 1\n      Q(3:) = -123456789\n      DO I = 3,ENUFF\t\n        Q(I) = Q(I - Q(I - 1)) + Q(I - Q(I - 2))\t\n      END DO\nCast forth results as per the specification.\n      WRITE (6,1) Q(1:10)\t\t\n    1 FORMAT (\"First ten values:\",10I2)\t\n      WRITE (6,*) \"Q(1000) =\",Q(1000)\t\n      WRITE (6,3) ENUFF,COUNT(Q(2:ENUFF) < Q(1:ENUFF - 1))\t\n    3 FORMAT (\"Count of those elements 2:\",I0,\n     1 \" which are less than their predecessor: \",I0)\t\nCurry favour by allowing enquiries.\n   10 WRITE (6,11) ENUFF\n   11 FORMAT (\"Nominate an index (in 1:\",I0,\"): \",$)\t\n      READ (5,*,END = 999, ERR = 999) I\t\n      IF (I.GT.0 .AND. I.LE.ENUFF) THEN\t\n        WRITE (6,12) I,Q(I)\t\t\n   12   FORMAT (\"Q(\",I0,\") = \",I0)\t\n        GO TO 10\t\t\t\n      END IF\t\t\nClosedown.\n  999 WRITE (6,*) \"Bye.\"\n      END\n", "target": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class HofQ {\n\tprivate static Map<Integer, Integer> q = new HashMap<Integer, Integer>(){{\n\t\tput(1, 1);\n\t\tput(2, 1);\n\t}};\n\t\n\tprivate static int[] nUses = new int[100001];\n\t\n\tpublic static int Q(int n){\n\t\tnUses[n]++;\n\t\tif(q.containsKey(n)){\n\t\t\treturn q.get(n);\n\t\t}\n\t\tint ans = Q(n - Q(n - 1)) + Q(n - Q(n - 2));\n\t\tq.put(n, ans);\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 1; i <= 10; i++){\n\t\t\tSystem.out.println(\"Q(\" + i + \") = \" + Q(i));\n\t\t}\n\t\tint last = 6;\n\t\tint count = 0;\n\t\tfor(int i = 11; i <= 100000; i++){\n\t\t\tint curr = Q(i);\n\t\t\tif(curr < last) count++;\n\t\t\tlast = curr;\n\t\t\tif(i == 1000) System.out.println(\"Q(1000) = \" + curr);\n\t\t}\n\t\tSystem.out.println(\"Q(i) is less than Q(i-1) for i <= 100000 \" + count + \" times\");\n\t\t\n\t\t\n\t\tint maxUses = 0, maxN = 0;\n\t\tfor(int i = 1; i<nUses.length;i++){\n\t\t\tif(nUses[i] > maxUses){\n\t\t\t\tmaxUses = nUses[i];\n\t\t\t\tmaxN = i;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"Q(\" + maxN + \") was called the most with \" + maxUses + \" calls\");\n\t}\n}\n"}
{"id": 388636, "name": "Count occurrences of a substring", "source": "Translate Fortran to Java: program Example\n  implicit none\n  integer :: n\n  \n  n = countsubstring(\"the three truths\", \"th\")\n  write(*,*) n\n  n = countsubstring(\"ababababab\", \"abab\")\n  write(*,*) n\n  n = countsubstring(\"abaabba*bbaba*bbab\", \"a*b\")\n  write(*,*) n\n \ncontains\n\nfunction countsubstring(s1, s2) result(c)\n  character(*), intent(in) :: s1, s2\n  integer :: c, p, posn\n \n  c = 0\n  if(len(s2) == 0) return\n  p = 1\n  do \n    posn = index(s1(p:), s2)\n    if(posn == 0) return\n    c = c + 1\n    p = p + posn + len(s2) - 1\n  end do\nend function\nend program\n", "target": "public class CountSubstring {\n\tpublic static int countSubstring(String subStr, String str){\n\t\treturn (str.length() - str.replace(subStr, \"\").length()) / subStr.length();\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tSystem.out.println(countSubstring(\"th\", \"the three truths\"));\n\t\tSystem.out.println(countSubstring(\"abab\", \"ababababab\"));\n\t\tSystem.out.println(countSubstring(\"a*b\", \"abaabba*bbaba*bbab\"));\n\t}\n}\n"}
{"id": 388637, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Fortran to Java:       LOGICAL FUNCTION ISPRIME(N)\t\n       INTEGER N\t\t\t\n       INTEGER F\t\t\t\n        ISPRIME = .FALSE.\t\t\n        DO F = 2,SQRT(DFLOAT(N))\t\n          IF (MOD(N,F).EQ.0) RETURN\t\n        END DO\t\t\t\t\n        ISPRIME = .TRUE.\t\t\n      END FUNCTION ISPRIME\t\t\n\n      PROGRAM CHASE\n      INTEGER P1,P2,P3\t\n      INTEGER H3,D\t\n      INTEGER MSG\t\n      MSG = 6\t\t\n      WRITE (MSG,1)\t\n    1 FORMAT (\"Carmichael numbers that are the product of three primes:\"\n     & /\"    P1  x P2  x P3 =\",9X,\"C\")\n      DO P1 = 2,61\t\n        IF (ISPRIME(P1)) THEN\t\n          DO H3 = 2,P1 - 1\t\t\n            DO D = 1,H3 + P1 - 1\t\t\n              IF (MOD((H3 + P1)*(P1 - 1),D).EQ.0\t\n     &        .AND. (MOD(H3 + MOD(-P1**2,H3),H3) .EQ. MOD(D,H3))) THEN\t\n                P2 = 1 + (P1 - 1)*(H3 + P1)/D\t\n                IF (ISPRIME(P2)) THEN\t\t\n                  P3 = 1 + P1*P2/H3\t\t\t\n                  IF (ISPRIME(P3)) THEN\t\t\t\n                    IF (MOD(P2*P3,P1 - 1).EQ.1) THEN\t\t\n                      WRITE (MSG,2) P1,P2,P3, INT8(P1)*P2*P3\t\t\n    2                 FORMAT (3I6,I12)\n                    END IF\n                  END IF\n                END IF\n              END IF\n            END DO\n          END DO\n        END IF\n      END DO\n      END\n", "target": "public class Test {\n\n    static int mod(int n, int m) {\n        return ((n % m) + m) % m;\n    }\n\n    static boolean isPrime(int n) {\n        if (n == 2 || n == 3)\n            return true;\n        else if (n < 2 || n % 2 == 0 || n % 3 == 0)\n            return false;\n        for (int div = 5, inc = 2; Math.pow(div, 2) <= n;\n                div += inc, inc = 6 - inc)\n            if (n % div == 0)\n                return false;\n        return true;\n    }\n\n    public static void main(String[] args) {\n        for (int p = 2; p < 62; p++) {\n            if (!isPrime(p))\n                continue;\n            for (int h3 = 2; h3 < p; h3++) {\n                int g = h3 + p;\n                for (int d = 1; d < g; d++) {\n                    if ((g * (p - 1)) % d != 0 || mod(-p * p, h3) != d % h3)\n                        continue;\n                    int q = 1 + (p - 1) * g / d;\n                    if (!isPrime(q))\n                        continue;\n                    int r = 1 + (p * q / h3);\n                    if (!isPrime(r) || (q * r) % (p - 1) != 1)\n                        continue;\n                    System.out.printf(\"%d x %d x %d%n\", p, q, r);\n                }\n            }\n        }\n    }\n}\n"}
{"id": 388638, "name": "Rock-paper-scissors", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram rpsgame\n\n  integer, parameter :: COMPUTER=1, HAPLESSUSER=2\n  integer, dimension(3) :: rps = (/1,1,1/)\n  real, dimension(3) :: p\n  character :: answer, cc \n  integer :: exhaustion, i\n  real, dimension(2) :: score = (/0, 0/)\n  character(len=8), dimension(3) :: choices = (/'rock    ','paper   ','scissors'/)\n  real :: harvest\n  do exhaustion = 1, 30\n    p = rps/real(sum(rps))\n    p(2) = p(2) + p(1)\n    p(3) = p(3) + p(2)\n    call random_number(harvest)\n    i = sum(merge(1,0,harvest.le.p)) \n    cc = 'rsp'(i:i)\n    write(6, \"(2(A,', '),A,'?  ')\", advance='no')(trim(choices(i)),i=1,size(choices))\n    read(5, *) answer\n    write(6, \"('scoring computer choice (',A,') and your choice (',A,')')\")cc,answer\n    if (answer.eq.cc) then\n      score = score + 0.5\n    else\n      i = HAPLESSUSER\n      if (answer.eq.'r') then\n        if (cc.eq.'p') i = COMPUTER\n      else if (answer.eq.'p') then\n        if (cc.eq.'s') i = COMPUTER\n      else if (answer.eq.'s') then\n        if (cc.eq.'r') i = COMPUTER\n      else\n        exit\n      endif\n      score(i) = score(i) + 1\n    end if\n    i = scan('rps',answer)\n    rps(i) = rps(i) + 1\n  end do\n  if (25 .lt. exhaustion) write(6, *) \"I'm bored out of my skull\"\n  write(6, *)\"Who's keeping score anyway???\"\n  write(6, '(2f5.1)') score\n  if (score(COMPUTER) .lt. score(HAPLESSUSER)) print*,'you won\nend program rpsgame\n", "target": "import java.util.Arrays;\nimport java.util.EnumMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Random;\n\npublic class RPS {\n\tpublic enum Item{\n\t\tROCK, PAPER, SCISSORS, ;\n\t\tpublic List<Item> losesToList;\n\t\tpublic boolean losesTo(Item other) {\n\t\t\treturn losesToList.contains(other);\n\t\t}\n\t\tstatic {\n\t\t\tSCISSORS.losesToList = Arrays.asList(ROCK);\n\t\t\tROCK.losesToList = Arrays.asList(PAPER);\n\t\t\tPAPER.losesToList = Arrays.asList(SCISSORS);\n\t\t\t\n                }\n\t}\n\t\n\tpublic final Map<Item, Integer> counts = new EnumMap<Item, Integer>(Item.class){{\n\t\tfor(Item item:Item.values())\n\t\t\tput(item, 1);\n\t}};\n\n\tprivate int totalThrows = Item.values().length;\n\n\tpublic static void main(String[] args){\n\t\tRPS rps = new RPS();\n\t\trps.run();\n\t}\n\n\tpublic void run() {\n\t\tScanner in = new Scanner(System.in);\n\t\tSystem.out.print(\"Make your choice: \");\n\t\twhile(in.hasNextLine()){\n\t\t\tItem aiChoice = getAIChoice();\n\t\t\tString input = in.nextLine();\n\t\t\tItem choice;\n\t\t\ttry{\n\t\t\t\tchoice = Item.valueOf(input.toUpperCase());\n\t\t\t}catch (IllegalArgumentException ex){\n\t\t\t\tSystem.out.println(\"Invalid choice\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcounts.put(choice, counts.get(choice) + 1);\n\t\t\ttotalThrows++;\n\t\t\tSystem.out.println(\"Computer chose: \" + aiChoice);\n\t\t\tif(aiChoice == choice){\n\t\t\t\tSystem.out.println(\"Tie!\");\n\t\t\t}else if(aiChoice.losesTo(choice)){\n\t\t\t\tSystem.out.println(\"You chose...wisely. You win!\");\n\t\t\t}else{\n\t\t\t\tSystem.out.println(\"You chose...poorly. You lose!\");\n\t\t\t}\n\t\t\tSystem.out.print(\"Make your choice: \");\n\t\t}\n\t}\n\n\tprivate static final Random rng = new Random();\n\tprivate Item getAIChoice() {\n\t\tint rand = rng.nextInt(totalThrows);\n\t\tfor(Map.Entry<Item, Integer> entry:counts.entrySet()){\n\t\t\tItem item = entry.getKey();\n\t\t\tint count = entry.getValue();\n\t\t\tif(rand < count){\n\t\t\t\tList<Item> losesTo = item.losesToList;\n\t\t\t\treturn losesTo.get(rng.nextInt(losesTo.size()));\n\t\t\t}\n\t\t\trand -= count;\n\t\t}\n\t\treturn null;\n\t}\n}\n"}
{"id": 388639, "name": "Benford's law", "source": "Translate Fortran to Java: -*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 01:13:00\n\na=./f && make $a && $a\nf95 -Wall -ffree-form f.F -o f\n  0.301030010      0.176091254      0.124938756       9.69100147E-02   7.91812614E-02   6.69467747E-02   5.79919666E-02   5.11525236E-02   4.57575098E-02 THE LAW\n  0.300999999      0.177000001      0.125000000       9.60000008E-02   7.99999982E-02   6.70000017E-02   5.70000000E-02   5.29999994E-02   4.50000018E-02 LEADING FIBONACCI DIGIT\n\nCompilation finished at Sat May 18 01:13:00\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 388640, "name": "Benford's law", "source": "Translate Fortran to Java: -*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 01:13:00\n\na=./f && make $a && $a\nf95 -Wall -ffree-form f.F -o f\n  0.301030010      0.176091254      0.124938756       9.69100147E-02   7.91812614E-02   6.69467747E-02   5.79919666E-02   5.11525236E-02   4.57575098E-02 THE LAW\n  0.300999999      0.177000001      0.125000000       9.60000008E-02   7.99999982E-02   6.70000017E-02   5.70000000E-02   5.29999994E-02   4.50000018E-02 LEADING FIBONACCI DIGIT\n\nCompilation finished at Sat May 18 01:13:00\n", "target": "import java.math.BigInteger;\nimport java.util.Locale;\n\npublic class BenfordsLaw {\n\n    private static BigInteger[] generateFibonacci(int n) {\n        BigInteger[] fib = new BigInteger[n];\n        fib[0] = BigInteger.ONE;\n        fib[1] = BigInteger.ONE;\n        for (int i = 2; i < fib.length; i++) {\n            fib[i] = fib[i - 2].add(fib[i - 1]);\n        }\n        return fib;\n    }\n\n    public static void main(String[] args) {\n        BigInteger[] numbers = generateFibonacci(1000);\n\n        int[] firstDigits = new int[10];\n        for (BigInteger number : numbers) {\n            firstDigits[Integer.valueOf(number.toString().substring(0, 1))]++;\n        }\n\n        for (int i = 1; i < firstDigits.length; i++) {\n            System.out.printf(Locale.ROOT, \"%d %10.6f %10.6f%n\",\n                    i, (double) firstDigits[i] / numbers.length, Math.log10(1.0 + 1.0 / i));\n        }\n    }\n}\n"}
{"id": 388641, "name": "Hickerson series of almost integers", "source": "Translate Fortran to Java: program hickerson\n    implicit none\n    integer, parameter :: q = selected_real_kind(30)\n    integer, parameter :: l = selected_int_kind(15)\n    real(q) :: s, l2\n    integer :: i, n, k\n\n    l2 = log(2.0_q)\n    do n = 1, 17\n        s = 0.5_q / l2\n        do i = 1, n\n            s = (s * i) / l2\n        end do\n\n        k = floor((s - floor(s, l)) * 10)\n        if (k == 0 .or. k == 9) then\n            print 1, n, s, \"\"\n        else\n            print 1, n, s, \" NOT\"\n        endif\n    end do\n  1 format('h(',I2,') = ',F23.3,' is',A,' an almost-integer')\nend program\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 388642, "name": "Hickerson series of almost integers", "source": "Translate Fortran to Java: program hickerson\n    implicit none\n    integer, parameter :: q = selected_real_kind(30)\n    integer, parameter :: l = selected_int_kind(15)\n    real(q) :: s, l2\n    integer :: i, n, k\n\n    l2 = log(2.0_q)\n    do n = 1, 17\n        s = 0.5_q / l2\n        do i = 1, n\n            s = (s * i) / l2\n        end do\n\n        k = floor((s - floor(s, l)) * 10)\n        if (k == 0 .or. k == 9) then\n            print 1, n, s, \"\"\n        else\n            print 1, n, s, \" NOT\"\n        endif\n    end do\n  1 format('h(',I2,') = ',F23.3,' is',A,' an almost-integer')\nend program\n", "target": "import java.math.*;\n\npublic class Hickerson {\n\n    final static String LN2 = \"0.693147180559945309417232121458\";\n\n    public static void main(String[] args) {\n        for (int n = 1; n <= 17; n++)\n            System.out.printf(\"%2s is almost integer: %s%n\", n, almostInteger(n));\n    }\n\n    static boolean almostInteger(int n) {\n        BigDecimal a = new BigDecimal(LN2);\n        a = a.pow(n + 1).multiply(BigDecimal.valueOf(2));\n\n        long f = n;\n        while (--n > 1)\n            f *= n;\n\n        BigDecimal b = new BigDecimal(f);\n        b = b.divide(a, MathContext.DECIMAL128);\n\n        BigInteger c = b.movePointRight(1).toBigInteger().mod(BigInteger.TEN);\n\n        return c.toString().matches(\"0|9\");\n    }\n}\n"}
{"id": 388643, "name": "Read a configuration file", "source": "Translate Fortran to Java: program readconfig\n  implicit none\n  integer, parameter    :: strlen = 100\n  logical               :: needspeeling = .false., seedsremoved =.false.\n  character(len=strlen) :: favouritefruit = \"\", fullname = \"\", fst, snd\n  character(len=strlen), allocatable :: otherfamily(:), tmp(:)\n  character(len=1000)   :: line\n  integer               :: lun, stat,  j, j0, j1, ii = 1, z\n  integer, parameter    :: state_begin=1, state_in_fst=2, state_in_sep=3\n\n  open(newunit=lun, file=\"config.ini\", status=\"old\")\n  \n  do \n    read(lun, \"(a)\", iostat=stat) line\n    if (stat<0) exit\n    if ((line(1:1) == \"#\") .or. &\n        (line(1:1) == \";\") .or. &\n        (len_trim(line)==0)) then\n      cycle\n    end if\n    z = state_begin\n    do j = 1, len_trim(line)\n      if (z == state_begin) then\n        if (line(j:j)/=\" \") then\n          j0 = j\n          z = state_in_fst\n        end if\n      elseif (z == state_in_fst) then\n        if (index(\"= \",line(j:j))>0) then\n          fst = lower(line(j0:j-1))\n          z = state_in_sep\n        end if\n      elseif (z == state_in_sep) then\n        if (index(\" =\",line(j:j)) == 0) then\n          snd = line(j:)\n          exit\n        end if\n      else\n         stop \"not possible to be here\"\n      end if\n    end do\n    if (z == state_in_fst) then\n      fst = lower(line(j0:))\n    elseif (z == state_begin) then\n      cycle\n    end if\n\n    if (fst==\"fullname\") then\n      read(snd,\"(a)\") fullname\n    elseif (fst==\"favouritefruit\") then\n      read(snd,\"(a)\") favouritefruit\n    elseif (fst==\"seedsremoved\") then\n      seedsremoved = .true.\n    elseif (fst==\"needspeeling\") then\n      needspeeling = .true.\n    elseif (fst==\"otherfamily\") then\n      j = 1; ii = 1\n      do while (len_trim(snd(j:)) >0)\n        j1  = index(snd(j:),\",\")\n        if (j1==0) then\n          j1 = len_trim(snd)\n        else\n          j1 = j + j1 - 2\n        end if\n        do \n          if (j>len_trim(snd)) exit\n          if (snd(j:j) /= \" \") exit\n          j = j +1\n        end do\n        allocate(tmp(ii)) \n        tmp(1:ii-1) = otherfamily\n        call move_alloc(tmp, otherfamily)\n        read(snd(j:j1),\"(a)\"), otherfamily(ii)\n        j = j1 + 2 \n        ii = ii + 1\n      end do\n    else \n      print *, \"unknown option '\"//trim(fst)//\"'\"; stop\n    end if\n  end do\n  close(lun)\n\n  print \"(a,a)\",\"fullname = \",       trim(fullname)\n  print \"(a,a)\",\"favouritefruit = \", trim(favouritefruit)\n  print \"(a,l)\",\"needspeeling = \",   needspeeling\n  print \"(a,l)\",\"seedsremoved = \",   seedsremoved\n  print \"(a,*(a,:,', '))\", \"otherfamily = \", &\n         (trim(otherfamily(j)), j=1,size(otherfamily))\n\ncontains\n\npure function lower (str) result (string)\n    implicit none\n    character(*), intent(In) :: str\n    character(len(str))      :: string\n    Integer :: ic, i\n\n    character(26), parameter :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n\n    string = str\n    do i = 1, len_trim(str)\n        ic = index(cap, str(i:i))\n        if (ic > 0) string(i:i) = low(ic:ic)\n    end do\nend function \n\nend program\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n         BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}\n"}
{"id": 388644, "name": "Kronecker product based fractals", "source": "Translate Fortran to Java: program Kron_frac\n  implicit none\n\n  interface\n    function matkronpow(M, n) result(Mpowern)\n      integer, dimension(:,:), intent(in) :: M\n      integer, intent(in) :: n\n      integer, dimension(size(M, 1)**n, size(M,2)**n) :: Mpowern\n    end function matkronpow\n\n    function kron(A, B) result(M)\n      integer, dimension(:,:), intent(in) :: A, B\n      integer, dimension(size(A,1)*size(B,1), size(A,2)*size(B,2)) :: M\n    end function kron\n\n    subroutine write2file(M, filename)\n      integer, dimension(:,:), intent(in) :: M\n      character(*), intent(in) :: filename\n    end subroutine write2file\n  end interface\n\n  integer, parameter :: n = 4\n  integer, dimension(3,3) :: Vicsek, Sierpinski\n  integer, dimension(4,4) :: Hadamard\n  integer, dimension(3**n, 3**n) :: fracV, fracS\n  integer, dimension(4**n, 4**n) :: fracH\n\n  Vicsek = reshape( (/0, 1, 0,&\n                      1, 1, 1,&\n                      0, 1, 0/),&\n                    (/3,3/) )\n\n  Sierpinski = reshape( (/1, 1, 1,&\n                          1, 0, 1,&\n                          1, 1, 1/),&\n                          (/3,3/) )\n\n  Hadamard = transpose(reshape( (/ 1, 0, 1, 0,&\n                         1, 0, 0, 1,&\n                         1, 1, 0, 0,&\n                         1, 1, 1, 1/),&\n                         (/4,4/) ))\n\n  fracV = matkronpow(Vicsek, n)\n  fracS = matkronpow(Sierpinski, n)\n  fracH = matkronpow(Hadamard, n)\n\n  call write2file(fracV, 'Viczek.txt')\n  call write2file(fracS, 'Sierpinski.txt')\n  call write2file(fracH, 'Hadamard.txt')\n\nend program\n\nfunction matkronpow(M, n) result(Mpowern)\ninterface\nfunction kron(A, B) result(M)\n  integer, dimension(:,:), intent(in) :: A, B\n  integer, dimension(size(A,1)*size(B,1), size(A,2)*size(B,2)) :: M\n  end function kron\nend interface\n\n  integer, dimension(:,:), intent(in) :: M\n  integer, intent(in) :: n\n  integer, dimension(size(M, 1)**n, size(M,2)**n) :: Mpowern\n  integer, dimension(:,:), allocatable :: work1, work2\n  integer :: icount\n\n  if (n <= 1) then\n     Mpowern = M\n  else\n    allocate(work1(size(M,1), size(M,2)))\n    work1 = M\n    do icount = 2,n\n      allocate(work2(size(M,1)**icount, size(M,2)**icount))\n      work2 = kron(work1, M)\n      deallocate(work1)\n      allocate(work1(size(M,1)**icount, size(M,2)**icount))\n      work1 = work2\n      deallocate(work2)\n    end do\n    Mpowern = work1\n    deallocate(work1)\n  end if\n\nend function matkronpow\n\nfunction kron(A, B) result(M)\n  integer, dimension(:,:), intent(in) :: A, B\n  integer, dimension(size(A,1)*size(B,1), size(A,2)*size(B,2)) :: M\n  integer :: ia, ja, ib, jb, im, jm\n\n  do ja = 1, size(A, 2)\n    do ia = 1, size(A, 1)\n      do jb = 1, size(B, 2)\n        do ib = 1, size(B, 1)\n          im = (ia - 1)*size(B, 1) + ib\n          jm = (ja - 1)*size(B, 2) + jb\n          M(im, jm) = A(ia, ja) * B(ib, jb)\n        end do\n      end do\n    end do\n  end do\n\nend function kron\n\nsubroutine write2file(M, filename)\n  integer, dimension(:,:), intent(in) :: M\n  character(*), intent(in) :: filename\n  integer :: ii, jj\n  integer, parameter :: fi = 10\n\n  open(fi, file=filename, status='replace')\n\n  do ii = 1,size(M, 1)\n    do jj = 1,size(M,2)\n      if (M(ii,jj) == 0) then\n        write(fi, '(A)', advance='no') ' '\n      else\n        write(fi, '(A)', advance='no') '*'\n      end if\n    end do\n    write(fi, '(A)') ' '\n  end do\n\n  close(fi)\n\nend subroutine write2file\n", "target": "package kronecker;\n\n\npublic class ProductFractals {\n  \n  public static int[][] product(final int[][] a, final int[][] b) {\n    \n    \n    final int[][] c = new int[a.length*b.length][];\n    \n    \n    for (int ix = 0; ix < c.length; ix++) {\n      final int num_cols = a[0].length*b[0].length;\n      c[ix] = new int[num_cols];\n    }\n    \n    \n    for (int ia = 0; ia < a.length; ia++) {\n      for (int ja = 0; ja < a[ia].length; ja++) {\n        \n        for (int ib = 0; ib < b.length; ib++) {\n          for (int jb = 0; jb < b[ib].length; jb++) {\n             c[b.length*ia+ib][b[ib].length*ja+jb] = a[ia][ja] * b[ib][jb];\n          }\n        }\n      }\n    }\n\n    \n    return c;\n  }\n\n  \n  public static void show_matrix(final int[][] m, final char nz, final char z) {\n    for (int im = 0; im < m.length; im++) {\n      for (int jm = 0; jm < m[im].length; jm++) {\n        System.out.print(m[im][jm] == 0 ? z : nz);\n      }\n      System.out.println();\n    }\n  }\n\n  \n  public static int[][] power(final int[][] m, final int n) {\n    \n    int[][] m_pow = m;\n    \n    \n    for (int ix = 1; ix < n; ix++) {\n      m_pow = product(m, m_pow);\n    }\n    return m_pow;\n  }\n\n  \n  private static void test(final int[][] m, final int n) {\n    System.out.println(\"Test matrix\");\n    show_matrix(m, '*', ' ');\n    final int[][] m_pow = power(m, n);\n    System.out.println(\"Matrix power \" + n);\n    show_matrix(m_pow, '*', ' ');\n  }\n\n  \n  private static void test1() {\n    \n    final int[][] m = {{0, 1, 0},\n                       {1, 1, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test2() {\n    \n    final int[][] m = {{1, 1, 1},\n                       {1, 0, 1},\n                       {1, 1, 1}};\n    \n    test(m, 4);\n  }\n\n  \n  private static void test3() {\n    \n    final int[][] m = {{1, 0, 1},\n                       {1, 0, 1},\n                       {0, 1, 0}};\n    \n    test(m, 4);\n  }\n\n  \n  public static void main(final String[] args) {\n    \n    test1();\n    test2();\n    test3();\n  }\n\n}\n"}
{"id": 388645, "name": "Case-sensitivity of identifiers", "source": "Translate Fortran to Java: program Example\n  implicit none\n\n  character(8) :: dog, Dog, DOG\n\n  dog = \"Benjamin\"\n  Dog = \"Samba\"\n  DOG = \"Bernie\"\n\n  if (dog == DOG) then\n    write(*,*) \"There is just one dog named \", dog\n  else\n    write(*,*) \"The three dogs are named \", dog, Dog, \" and \", DOG\n  end if\n\nend program Example\n", "target": "String dog = \"Benjamin\"; \nString Dog = \"Samba\";    \nString DOG = \"Bernie\";   \n@Inject Console console;\nconsole.print($\"There are three dogs named {dog}, {Dog}, and {DOG}\");\n"}
{"id": 388646, "name": "Sorting algorithms_Stooge sort", "source": "Translate Fortran to Java: program Stooge\n  implicit none\n\n  integer :: i\n  integer :: array(50) = (/ (i, i = 50, 1, -1) /) \n  \n  call Stoogesort(array)\n  write(*,\"(10i5)\") array\n\ncontains\n\nrecursive subroutine Stoogesort(a)\n  integer, intent(in out) :: a(:)\n  integer :: j, t, temp\n \n   j = size(a)\n   if(a(j) < a(1)) then\n     temp = a(j)\n     a(j) = a(1)\n     a(1) = temp\n   end if\n\n  if(j > 2) then\n    t = j / 3\n    call Stoogesort(a(1:j-t))\n    call Stoogesort(a(1+t:j))\n    call Stoogesort(a(1:j-t)) \n  end if\n\nend subroutine\nend program\n", "target": "import java.util.Arrays;\n\npublic class Stooge {\n    public static void main(String[] args) {\n        int[] nums = {1, 4, 5, 3, -6, 3, 7, 10, -2, -5};\n        stoogeSort(nums);\n        System.out.println(Arrays.toString(nums));\n    }\n\n    public static void stoogeSort(int[] L) {\n        stoogeSort(L, 0, L.length - 1);\n    }\n\n    public static void stoogeSort(int[] L, int i, int j) {\n        if (L[j] < L[i]) {\n            int tmp = L[i];\n            L[i] = L[j];\n            L[j] = tmp;\n        }\n        if (j - i > 1) {\n            int t = (j - i + 1) / 3;\n            stoogeSort(L, i, j - t);\n            stoogeSort(L, i + t, j);\n            stoogeSort(L, i, j - t);\n        }\n    }\n}\n"}
{"id": 388647, "name": "Truncate a file", "source": "Translate Fortran to Java:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,NB)\n       CHARACTER*(*) FNAME\t\n       INTEGER NB\t\t\n       INTEGER L\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\t\t\n       CHARACTER*1 B\t\t\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (NB.LE.0)     CALL CROAK(\"Chop must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\",\t\n     1   FORM=\"UNFORMATTED\",RECL=1,ACCESS=\"DIRECT\")\t\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"UNFORMATTED\",RECL=1)\t\n\nCopy the desired \"records\" to the temporary file.\n   10   DO L = 1,NB\t\n          READ  (F,REC = L,ERR = 20) B\t\n          WRITE (T) B\t\t\t\n        END DO\t\t\n   20   IF (L.LE.NB) CALL CROAK(\"Short file\nConvert from input to output...\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n        DO L = 1,NB\t\n          READ  (T) B\t\t\n          WRITE (F,\"(A1,$)\") B\t\n        END DO\t\t\nCompleted.\n   30   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",12)\n      END\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\npublic class TruncFile {\n\tpublic static void main(String[] args) throws IOException{\n\t\tif(args.length < 2){\n\t\t\tSystem.out.println(\"Usage: java TruncFile fileName newSize\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tFileChannel outChan = new FileOutputStream(args[0], true).getChannel();\n\t\tlong newSize = Long.parseLong(args[1]);\n\t\toutChan.truncate(newSize);\n\t\toutChan.close();\n\t}\n}\n"}
{"id": 388648, "name": "Truncate a file", "source": "Translate Fortran to Java:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,NB)\n       CHARACTER*(*) FNAME\t\n       INTEGER NB\t\t\n       INTEGER L\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\t\t\n       CHARACTER*1 B\t\t\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (NB.LE.0)     CALL CROAK(\"Chop must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\",\t\n     1   FORM=\"UNFORMATTED\",RECL=1,ACCESS=\"DIRECT\")\t\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"UNFORMATTED\",RECL=1)\t\n\nCopy the desired \"records\" to the temporary file.\n   10   DO L = 1,NB\t\n          READ  (F,REC = L,ERR = 20) B\t\n          WRITE (T) B\t\t\t\n        END DO\t\t\n   20   IF (L.LE.NB) CALL CROAK(\"Short file\nConvert from input to output...\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n        DO L = 1,NB\t\n          READ  (T) B\t\t\n          WRITE (F,\"(A1,$)\") B\t\n        END DO\t\t\nCompleted.\n   30   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",12)\n      END\n", "target": "import java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.nio.channels.FileChannel;\n\npublic class TruncFile {\n\tpublic static void main(String[] args) throws IOException{\n\t\tif(args.length < 2){\n\t\t\tSystem.out.println(\"Usage: java TruncFile fileName newSize\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tFileChannel outChan = new FileOutputStream(args[0], true).getChannel();\n\t\tlong newSize = Long.parseLong(args[1]);\n\t\toutChan.truncate(newSize);\n\t\toutChan.close();\n\t}\n}\n"}
{"id": 388649, "name": "Sorting algorithms_Shell sort", "source": "Translate Fortran to Java: MODULE sort\n\nCONTAINS\n\nSUBROUTINE Shell_Sort(a)\n\n  IMPLICIT NONE\n  INTEGER :: i, j, increment\n  REAL :: temp\n  REAL, INTENT(in out) :: a(:)\n\t\n  increment = SIZE(a) / 2\n  DO WHILE (increment > 0)\n      DO i = increment+1, SIZE(a)\n         j = i\n         temp = a(i)\n         DO WHILE (j >= increment+1 .AND. a(j-increment) > temp)\n            a(j) = a(j-increment)\n            j = j - increment\n         END DO\n         a(j) = temp\n      END DO\n      IF (increment == 2) THEN\n   \t  increment = 1\n      ELSE\n         increment = increment * 5 / 11\n      END IF      \n  END DO\n \nEND SUBROUTINE Shell_Sort\n\nEND MODULE sort\n\nPROGRAM Shellsort\n\nUSE sort\n\n  IMPLICIT NONE\n  REAL :: array(1000)\n     \n  CALL RANDOM_SEED\n  CALL RANDOM_NUMBER(array)\n \n  WRITE (*,*) \"Unsorted array\"\n  WRITE (*,*) array\n  WRITE (*,*) \n  CALL Shell_Sort(array)\n  WRITE (*,*) \"Sorted array\"\n  WRITE (*,*) array\n  \nEND PROGRAM Shellsort\n", "target": "public static void shell(int[] a) {\n\tint increment = a.length / 2;\n\twhile (increment > 0) {\n\t\tfor (int i = increment; i < a.length; i++) {\n\t\t\tint j = i;\n\t\t\tint temp = a[i];\n\t\t\twhile (j >= increment && a[j - increment] > temp) {\n\t\t\t\ta[j] = a[j - increment];\n\t\t\t\tj = j - increment;\n\t\t\t}\n\t\t\ta[j] = temp;\n\t\t}\n\t\tif (increment == 2) {\n\t\t\tincrement = 1;\n\t\t} else {\n\t\t\tincrement *= (5.0 / 11);\n\t\t}\n\t}\n}\n"}
{"id": 388650, "name": "Deconvolution_1D", "source": "Translate Fortran to Java: \n\n\n\nprogram deconv\n  \n  use mkl95_lapack, only : gelsd\n\n  implicit none\n  real(8), allocatable :: g(:), href(:), A(:,:), f(:)\n  real(8), pointer     :: h(:), r(:)\n  integer              :: N\n  character(len=16)    :: cbuff\n  integer              :: i\n  intrinsic            :: nint\n\n  \n  allocate(g(21),f(16))\n  g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\n  f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\n\n  \n  h => deco(f, g)\n\n  \n  N = size(h)\n  allocate(href(N))\n  href = [-8,-9,-3,-1,-6,7]\n  cbuff = ' '\n  write(cbuff,'(a,i0,a)') '(a,',N,'(i0,a),i0)'\n  if (any(abs(h-href) > 1.0d-4)) then\n     write(*,'(a)') 'deconv(f, g) - FAILED'\n  else\n     write(*,cbuff) 'deconv(f, g) = ',(nint(h(i)),', ',i=1,N-1),nint(h(N))\n  end if\n\n  \n  r => deco(h, g)\n\n  cbuff = ' '\n  N = size(r)\n  write(cbuff,'(a,i0,a)') '(a,',N,'(i0,a),i0)'\n  if (any(abs(r-f) > 1.0d-4)) then\n     write(*,'(a)') 'deconv(h, g) - FAILED'\n  else\n     write(*,cbuff) 'deconv(h, g) = ',(nint(r(i)),', ',i=1,N-1),nint(r(N))\n  end if\n\ncontains\n  function deco(p, q)\n    real(8), pointer    :: deco(:)\n    real(8), intent(in) :: p(:), q(:)\n\n    real(8), allocatable, target :: r(:)\n    real(8), allocatable         :: A(:,:)\n    integer :: N\n\n    \n    N = size(q) - size(p) + 1\n    allocate(A(size(q),N),r(size(q)))\n    A = 0.0d0\n    do i=1,N\n       A(i:i+size(p)-1,i) = p\n    end do\n    \n    \n    r = q\n    call gelsd(A, r)\n\n    deco => r(1:N)\n  end function deco\n\nend program deconv\n", "target": "import java.util.Arrays;\n\npublic class Deconvolution1D {\n    public static int[] deconv(int[] g, int[] f) {\n        int[] h = new int[g.length - f.length + 1];\n        for (int n = 0; n < h.length; n++) {\n            h[n] = g[n];\n            int lower = Math.max(n - f.length + 1, 0);\n            for (int i = lower; i < n; i++)\n                h[n] -= h[i] * f[n - i];\n            h[n] /= f[0];\n        }\n        return h;\n    }\n\n    public static void main(String[] args) {\n        int[] h = { -8, -9, -3, -1, -6, 7 };\n        int[] f = { -3, -6, -1, 8, -6, 3, -1, -9, -9, 3, -2, 5, 2, -2, -7, -1 };\n        int[] g = { 24, 75, 71, -34, 3, 22, -45, 23, 245, 25, 52, 25, -67, -96,\n                96, 31, 55, 36, 29, -43, -7 };\n\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"h = \" + Arrays.toString(h) + \"\\n\");\n        sb.append(\"deconv(g, f) = \" + Arrays.toString(deconv(g, f)) + \"\\n\");\n        sb.append(\"f = \" + Arrays.toString(f) + \"\\n\");\n        sb.append(\"deconv(g, h) = \" + Arrays.toString(deconv(g, h)) + \"\\n\");\n        System.out.println(sb.toString());\n    }\n}\n"}
{"id": 388651, "name": "Read a specific line from a file", "source": "Translate Fortran to Java:       MODULE SAMPLER    \n       CONTAINS                                                         SAM00200\n        CHARACTER*20 FUNCTION GETREC(N,F,IS)    \nCareful. Some compilers get confused over the function name's usage.    SAM00400\n         INTEGER N              \n         INTEGER F              \n         CHARACTER*(*) IS       \n         INTEGER I,L            \n          IS = \"\"               \n          IF (N.LE.0) THEN      \n            WRITE (GETREC,1) \"\n    1       FORMAT (A,1X,I0)                    \n          ELSE IF (F.LE.0) THEN                 \n            WRITE (GETREC,1) \"\n          ELSE IF (LEN(IS).LE.0) THEN           \n            WRITE (GETREC,1) \"\n          ELSE                  \n            REWIND (F)          \n            DO I = 1,N - 1      \n              READ (F,2,END=3)  \n            END DO              \n            READ (F,2,END = 3) L,IS(1:MIN(L,LEN(IS)))    \n    2       FORMAT (Q,A)        \n            IF (L.LT.LEN(IS)) IS(L + 1:) = \"\"   \n            IF (L.GT.LEN(IS)) THEN              \n              WRITE (GETREC,1) \"+Length\",L      \n            ELSE IF (L.LE.0) THEN               \n              WRITE (GETREC,1) \"+Null\"          \n            ELSE IF (IS.EQ.\"\") THEN             \n              WRITE (GETREC,1) \"+Blank\",L       \n            ELSE                                \n              WRITE (GETREC,1) \" Length\",L      \n            END IF              \n          END IF                \n          RETURN                \n    3     WRITE (GETREC,1) \"\n        END FUNCTION GETREC     \n      END MODULE SAMPLER        \n                                                                        SAM03900\n      PROGRAM POKE                                                      POK00100\n      USE SAMPLER                                                       POK00200\n      INTEGER ENUFF     \n      PARAMETER (ENUFF = 666)   \n      CHARACTER*(ENUFF) STUFF   \n      CHARACTER*20 RESULT                                               POK00600\n      INTEGER MSG,F     \n      MSG = 6           \n      F = 10            \n      WRITE (MSG,*) \"      To select record 7 from a disc file.\"        POK01000\n                                                                        POK01100\n      WRITE (MSG,*) \"As a FORMATTED file.\"                              POK01200\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\")         POK01300\n      RESULT = GETREC(7,F,STUFF)                                        POK01400\n      WRITE (MSG,1) \"Result\",RESULT                                     POK01500\n      WRITE (MSG,1) \"Record\",STUFF                                      POK01600\n    1 FORMAT (A,\":\",A)                                                  POK01700\n                                                                        POK01800\n      CLOSE (F)                                                         POK01900\n      WRITE (MSG,*) \"As a random-access unformatted file.\"              POK02000\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\",         POK02100\n     1 ACCESS=\"DIRECT\",FORM=\"UNFORMATTED\",RECL=82)      \n      STUFF = \"Cleared.\"                                                POK02300\n      READ (F,REC = 7,ERR = 666) STUFF(1:80)                            POK02400\n      WRITE (MSG,1) \"Record\",STUFF(1:80)                                POK02500\n      STOP                                                              POK02600\n  666 WRITE (MSG,*) \"Can't get the record\n      END       \n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 388652, "name": "Read a specific line from a file", "source": "Translate Fortran to Java:       MODULE SAMPLER    \n       CONTAINS                                                         SAM00200\n        CHARACTER*20 FUNCTION GETREC(N,F,IS)    \nCareful. Some compilers get confused over the function name's usage.    SAM00400\n         INTEGER N              \n         INTEGER F              \n         CHARACTER*(*) IS       \n         INTEGER I,L            \n          IS = \"\"               \n          IF (N.LE.0) THEN      \n            WRITE (GETREC,1) \"\n    1       FORMAT (A,1X,I0)                    \n          ELSE IF (F.LE.0) THEN                 \n            WRITE (GETREC,1) \"\n          ELSE IF (LEN(IS).LE.0) THEN           \n            WRITE (GETREC,1) \"\n          ELSE                  \n            REWIND (F)          \n            DO I = 1,N - 1      \n              READ (F,2,END=3)  \n            END DO              \n            READ (F,2,END = 3) L,IS(1:MIN(L,LEN(IS)))    \n    2       FORMAT (Q,A)        \n            IF (L.LT.LEN(IS)) IS(L + 1:) = \"\"   \n            IF (L.GT.LEN(IS)) THEN              \n              WRITE (GETREC,1) \"+Length\",L      \n            ELSE IF (L.LE.0) THEN               \n              WRITE (GETREC,1) \"+Null\"          \n            ELSE IF (IS.EQ.\"\") THEN             \n              WRITE (GETREC,1) \"+Blank\",L       \n            ELSE                                \n              WRITE (GETREC,1) \" Length\",L      \n            END IF              \n          END IF                \n          RETURN                \n    3     WRITE (GETREC,1) \"\n        END FUNCTION GETREC     \n      END MODULE SAMPLER        \n                                                                        SAM03900\n      PROGRAM POKE                                                      POK00100\n      USE SAMPLER                                                       POK00200\n      INTEGER ENUFF     \n      PARAMETER (ENUFF = 666)   \n      CHARACTER*(ENUFF) STUFF   \n      CHARACTER*20 RESULT                                               POK00600\n      INTEGER MSG,F     \n      MSG = 6           \n      F = 10            \n      WRITE (MSG,*) \"      To select record 7 from a disc file.\"        POK01000\n                                                                        POK01100\n      WRITE (MSG,*) \"As a FORMATTED file.\"                              POK01200\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\")         POK01300\n      RESULT = GETREC(7,F,STUFF)                                        POK01400\n      WRITE (MSG,1) \"Result\",RESULT                                     POK01500\n      WRITE (MSG,1) \"Record\",STUFF                                      POK01600\n    1 FORMAT (A,\":\",A)                                                  POK01700\n                                                                        POK01800\n      CLOSE (F)                                                         POK01900\n      WRITE (MSG,*) \"As a random-access unformatted file.\"              POK02000\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\",         POK02100\n     1 ACCESS=\"DIRECT\",FORM=\"UNFORMATTED\",RECL=82)      \n      STUFF = \"Cleared.\"                                                POK02300\n      READ (F,REC = 7,ERR = 666) STUFF(1:80)                            POK02400\n      WRITE (MSG,1) \"Record\",STUFF(1:80)                                POK02500\n      STOP                                                              POK02600\n  666 WRITE (MSG,*) \"Can't get the record\n      END       \n", "target": "package linenbr7;\n\nimport java.io.*;\n\npublic class LineNbr7 {\n\n    public static void main(String[] args) throws Exception {\n        File f = new File(args[0]);\n        if (!f.isFile() || !f.canRead())\n            throw new IOException(\"can't read \" + args[0]);\n\n        BufferedReader br = new BufferedReader(new FileReader(f));\n        try (LineNumberReader lnr = new LineNumberReader(br)) {\n            String line = null;\n            int lnum = 0;\n            while ((line = lnr.readLine()) != null\n                    && (lnum = lnr.getLineNumber()) < 7) {\n            }\n\n            switch (lnum) {\n                case 0:\n                    System.out.println(\"the file has zero length\");\n                    break;\n                case 7:\n                    boolean empty = \"\".equals(line);\n                    System.out.println(\"line 7: \" + (empty ? \"empty\" : line));\n                    break;\n                default:\n                    System.out.println(\"the file has only \" + lnum + \" line(s)\");\n            }\n        }\n    }\n}\n"}
{"id": 388653, "name": "LU decomposition", "source": "Translate Fortran to Java: program lu1\n  implicit none\n  call check( reshape([real(8)::1,2,1,3,4,1,5,7,0                  ],[3,3]) )\n  call check( reshape([real(8)::11,1,3,2,9,5,17,5,24,2,18,7,2,6,1,1],[4,4]) )\n \ncontains\n \n  subroutine check(a)\n    real(8), intent(in)   :: a(:,:)\n    integer               :: i,j,n\n    real(8), allocatable  :: aa(:,:),l(:,:),u(:,:)\n    integer, allocatable  :: p(:,:)\n    integer, allocatable  :: ipiv(:)\n    n = size(a,1)\n    allocate(aa(n,n),l(n,n),u(n,n),p(n,n),ipiv(n))\n    forall (j=1:n,i=1:n)\n      aa(i,j) = a(i,j)\n      u (i,j) = 0d0\n      p (i,j) = merge(1  ,0  ,i.eq.j)\n      l (i,j) = merge(1d0,0d0,i.eq.j)\n    end forall\n    call lu(aa, ipiv)\n    do i = 1,n\n       l(i, :i-1) = aa(i, :i-1)\n       u(i,i:   ) = aa(i,i:   )\n    end do\n    p(ipiv,:) = p\n    call mat_print('a',a)\n    call mat_print('p',p)\n    call mat_print('l',l)\n    call mat_print('u',u)\n    print *, \"residual\"\n    print *, \"|| P.A - L.U || =  \", maxval(abs(matmul(p,a)-matmul(l,u)))\n  end subroutine\n \n  subroutine lu(a,p)\n\n    real(8), intent(inout) :: a(:,:)\n    integer, intent(out  ) :: p(:)\n    integer                :: n, i,j,k,kmax\n    n = size(a,1)\n    p = [ ( i, i=1,n ) ]\n    do k = 1,n-1\n        kmax = maxloc(abs(a(p(k:),k)),1) + k-1\n        if (kmax /= k ) then\n            p([k, kmax]) = p([kmax, k])\n            a([k, kmax],:) = a([kmax, k],:)\n        end if\n        a(k+1:,k) = a(k+1:,k) / a(k,k)\n        forall (j=k+1:n) a(k+1:,j) = a(k+1:,j) - a(k,j)*a(k+1:,k)\n    end do\n  end subroutine\n\n  subroutine mat_print(amsg,a)\n    character(*), intent(in) :: amsg\n    class    (*), intent(in) :: a(:,:)\n    integer                  :: i\n    print*,' '\n    print*,amsg\n    do i=1,size(a,1)\n      select type (a)\n        type is (real(8)) ; print'(100f8.2)',a(i,:)\n        type is (integer) ; print'(100i8  )',a(i,:)\n      end select\n    end do\n    print*,' '\n  end subroutine\n\nend program\n", "target": "import static java.util.Arrays.stream;\nimport java.util.Locale;\nimport static java.util.stream.IntStream.range;\n\npublic class Test {\n\n    static double dotProduct(double[] a, double[] b) {\n        return range(0, a.length).mapToDouble(i -> a[i] * b[i]).sum();\n    }\n\n    static double[][] matrixMul(double[][] A, double[][] B) {\n        double[][] result = new double[A.length][B[0].length];\n        double[] aux = new double[B.length];\n\n        for (int j = 0; j < B[0].length; j++) {\n\n            for (int k = 0; k < B.length; k++)\n                aux[k] = B[k][j];\n\n            for (int i = 0; i < A.length; i++)\n                result[i][j] = dotProduct(A[i], aux);\n        }\n        return result;\n    }\n\n    static double[][] pivotize(double[][] m) {\n        int n = m.length;\n        double[][] id = range(0, n).mapToObj(j -> range(0, n)\n                .mapToDouble(i -> i == j ? 1 : 0).toArray())\n                .toArray(double[][]::new);\n\n        for (int i = 0; i < n; i++) {\n            double maxm = m[i][i];\n            int row = i;\n            for (int j = i; j < n; j++)\n                if (m[j][i] > maxm) {\n                    maxm = m[j][i];\n                    row = j;\n                }\n\n            if (i != row) {\n                double[] tmp = id[i];\n                id[i] = id[row];\n                id[row] = tmp;\n            }\n        }\n        return id;\n    }\n\n    static double[][][] lu(double[][] A) {\n        int n = A.length;\n        double[][] L = new double[n][n];\n        double[][] U = new double[n][n];\n        double[][] P = pivotize(A);\n        double[][] A2 = matrixMul(P, A);\n\n        for (int j = 0; j < n; j++) {\n            L[j][j] = 1;\n            for (int i = 0; i < j + 1; i++) {\n                double s1 = 0;\n                for (int k = 0; k < i; k++)\n                    s1 += U[k][j] * L[i][k];\n                U[i][j] = A2[i][j] - s1;\n            }\n            for (int i = j; i < n; i++) {\n                double s2 = 0;\n                for (int k = 0; k < j; k++)\n                    s2 += U[k][j] * L[i][k];\n                L[i][j] = (A2[i][j] - s2) / U[j][j];\n            }\n        }\n        return new double[][][]{L, U, P};\n    }\n\n    static void print(double[][] m) {\n        stream(m).forEach(a -> {\n            stream(a).forEach(n -> System.out.printf(Locale.US, \"%5.1f \", n));\n            System.out.println();\n        });\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        double[][] a = {{1.0, 3, 5}, {2.0, 4, 7}, {1.0, 1, 0}};\n\n        double[][] b = {{11.0, 9, 24, 2}, {1.0, 5, 2, 6}, {3.0, 17, 18, 1},\n        {2.0, 5, 7, 1}};\n\n        for (double[][] m : lu(a))\n            print(m);\n\n        System.out.println();\n\n        for (double[][] m : lu(b))\n            print(m);\n    }\n}\n"}
{"id": 388654, "name": "Optional parameters", "source": "Translate Fortran to Java: module ExampleOptionalParameter\n  \n  \n  implicit none\ncontains\n\n  subroutine sort_table(table, ordering, column, reverse)\n    type(table_type), intent(inout) :: table\n    integer, optional :: column\n    logical, optional :: reverse\n    optional :: ordering\n    interface\n       integer function ordering(a, b)\n         type(table_element), intent(in) :: a, b\n       end function ordering\n    end interface\n\n    integer :: the_column, i\n    logical :: reversing\n    type(table_row) :: rowA, rowB\n\n    if ( present(column) ) then\n       if ( column > get_num_of_columns(table) ) then\n          \n       else\n          the_column = column\n       end if\n    else\n       the_column = 1   \n    end if\n\n    reversing = .false.  \n    if ( present(reverse) ) reversing = reverse\n\n    do\n       \n       \n       \n       \n       ea = get_element(rowA, the_column)\n       eb = get_element(rowB, the_column)\n       if ( present(ordering) ) then\n          if ( .not. reversing ) then\n             if ( ordering(ea, eb) > 0 ) then\n                \n             end if\n          else   \n             if ( ordering(ea, eb) < 0 ) then\n                \n             end if\n          end if\n       else\n          if ( .not. reversing ) then\n             if ( lexinternal(ea, eb) > 0 ) then\n                \n             end if\n          else   \n             if ( lexinternal(ea, eb) < 0 ) then\n                \n             end if\n          end if\n       end if\n       \n       \n    end do\n\n  end subroutine sort_table\n\nend module ExampleOptionalParameter\n", "target": "module OptionalParameters\n    {\n    typedef Type<String  >.Orderer as ColumnOrderer;\n    typedef Type<String[]>.Orderer as RowOrderer;\n\n    static String[][] sort(String[][]     table,\n                           ColumnOrderer? orderer = Null,\n                           Int            column  = 0,\n                           Boolean        reverse = False,\n                          )\n        {\n        \n        orderer ?:= (s1, s2) -> s1 <=> s2;\n\n        \n        ColumnOrderer byString = reverse\n                ? ((s1, s2) -> orderer(s1, s2).reversed)\n                : orderer;\n\n        \n        RowOrderer byColumn = (row1, row2) -> byString(row1[column], row2[column]);\n\n        return table.sorted(byColumn);\n        }\n\n    void run()\n        {\n        String[][] table =\n            [\n            [\"c\", \"x\", \"i\"],\n            [\"a\", \"y\", \"p\"],\n            [\"b\", \"z\", \"a\"],\n            ];\n\n        show(\"original input\", table);\n        show(\"by default sort on column 0\", sort(table));\n        show(\"by column 2\", sort(table, column=2));\n        show(\"by column 2 reversed\", sort(table, column=2, reverse=True));\n        }\n\n    void show(String title, String[][] table)\n        {\n        @Inject Console console;\n        console.print($\"{title}:\");\n        for (val row : table)\n            {\n            console.print($\"  {row}\");\n            }\n        console.print();\n        }\n    }\n"}
{"id": 388655, "name": "Numeric error propagation", "source": "Translate Fortran to Java:       PROGRAM CALCULATE\t\n      REAL X1, Y1, X2, Y2\t\n      REAL X1E,Y1E,X2E,Y2E\t\n      DATA X1, Y1 ,X2, Y2 /100., 50., 200.,100./\t\n      DATA X1E,Y1E,X2E,Y2E/  1.1, 1.2,  2.2, 2.3/\t\n      REAL DX,DY,D2,D,DXE,DYE,E\t\n      CHARACTER*1 C\t\t\t\n      PARAMETER (C = CHAR(241))\t\t\n      REAL SD\t\n      SD(X,P,S) = P*ABS(X)**(P - 1)*S\t\n      WRITE (6,1) X1,C,X1E,Y1,C,Y1E,\t\n     1            X2,C,X2E,Y2,C,Y2E\t\n    1 FORMAT (\"Euclidean distance between two points:\"/\t\n     1 (\"(\",F5.1,A1,F3.1,\",\",F5.1,A1,F3.1,\")\"))\t\t\n      DX = (X1 - X2)\t\t\t\n      DXE = SQRT(X1E**2 + X2E**2)\t\n      DY = (Y1 - Y2)\t\t\t\n      DYE = SQRT(Y1E**2 + Y2E**2)\t\n      D2 = DX**2 + DY**2\t\t\n      DXE = SD(DX,2,DXE)\t\t\n      DYE = SD(DY,2,DYE)\t\t\n      E = SQRT(DXE**2 + DYE**2)\t\t\n      D = SQRT(D2)\t\t\t\n      E = SD(D2,0.5,E)\t\t\t\n      WRITE (6,2) D,C,E\t\t\t\n    2 FORMAT (\"Distance\",F6.1,A1,F4.2)\t\n      END\t\n", "target": "public class Approx {\n    private double value;\n    private double error;\n    \n    public Approx(){this.value = this.error = 0;}\n    \n    public Approx(Approx b){\n        this.value = b.value;\n        this.error = b.error;\n    }\n    \n    public Approx(double value, double error){\n        this.value = value;\n        this.error = error;\n    }\n    \n    public Approx add(Approx b){\n        value+= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx add(double b){\n        value+= b;\n        return this;\n    }\n    \n    public Approx sub(Approx b){\n        value-= b.value;\n        error = Math.sqrt(error * error + b.error * b.error);\n        return this;\n    }\n    \n    public Approx sub(double b){\n        value-= b;\n        return this;\n    }\n    \n    public Approx mult(Approx b){\n        double oldVal = value;\n        value*= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx mult(double b){\n        value*= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx div(Approx b){\n        double oldVal = value;\n        value/= b.value;\n        error = Math.sqrt(value * value * (error*error) / (oldVal*oldVal) +\n                                  (b.error*b.error) / (b.value*b.value));\n        return this;\n    }\n\n    public Approx div(double b){\n        value/= b;\n        error = Math.abs(b * error);\n        return this;\n    }\n    \n    public Approx pow(double b){\n        double oldVal = value;\n        value = Math.pow(value, b);\n        error = Math.abs(value * b * (error / oldVal));\n        return this;\n    }\n    \n    @Override\n    public String toString(){return value+\"\u00b1\"+error;}\n    \n    public static void main(String[] args){\n        Approx x1 = new Approx(100, 1.1);\n        Approx y1 = new Approx(50, 1.2);\n        Approx x2 = new Approx(200, 2.2);\n        Approx y2 = new Approx(100, 2.3);\n        \n        x1.sub(x2).pow(2).add(y1.sub(y2).pow(2)).pow(0.5);\n        \n        System.out.println(x1);\n    }\n}\n"}
{"id": 388656, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Fortran to Java: program tpk\n  implicit none\n  \n  real, parameter :: overflow = 400.0\n  real :: a(11), res\n  integer :: i\n \n  write(*,*) \"Input eleven numbers:\"\n  read(*,*) a\n \n  a = a(11:1:-1)\n  do i = 1, 11\n    res = f(a(i))\n    write(*, \"(a, f0.3, a)\", advance = \"no\") \"f(\", a(i), \") = \"\n    if(res > overflow) then\n      write(*, \"(a)\") \"overflow\n    else\n       write(*, \"(f0.3)\") res\n    end if\n  end do  \n      \ncontains\n\nreal function f(x)\n  real, intent(in) :: x\n  \n  f = sqrt(abs(x)) + 5.0*x**3\n\nend function  \nend program\n", "target": "\nimport java.util.*;\nimport java.io.*; \n\npublic class TPKA {\n\tpublic static void main(String... args) {\n\t\tdouble[] input = new double[11];\n\t\tdouble userInput = 0.0;\n\t\tScanner in = new Scanner(System.in);\n\t\tfor(int i = 0; i < 11; i++) {\n\t\t\tSystem.out.print(\"Please enter a number: \");\n\t\t\tString s = in.nextLine();\n\t\t\ttry {\n\t\t\t\tuserInput = Double.parseDouble(s);\n\t\t\t} catch (NumberFormatException e) { \n\t\t\t\tSystem.out.println(\"You entered invalid input, exiting\");\n\t\t\t\tSystem.exit(1);\n\t\t\t}\n\t\t\tinput[i] = userInput;\n\t\t}\n\t\tfor(int j = 10; j >= 0; j--) {\n\t\t\tdouble x = input[j]; double y = f(x);\n\t\t\tif( y < 400.0) {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) =\u00a0%.2f\\n\", x, y);\n\t\t\t} else {\n\t\t\t\tSystem.out.printf(\"f(\u00a0%.2f ) = %s\\n\", x, \"TOO LARGE\");\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static double f(double x) {\n\t\treturn Math.pow(Math.abs(x), 0.5) + (5*(Math.pow(x, 3)));\n\t}\n}\n"}
{"id": 388657, "name": "Rate counter", "source": "Translate Fortran to Java:       DO I = FIRST,LAST\n        IF (PROGRESSNOTE((I - FIRST)/(LAST - FIRST + 1.0))) WRITE (6,*) \"Reached \",I,\", towards \",LAST\n        ...much computation...\n      END DO\n", "target": "import java.util.function.Consumer;\n\npublic class RateCounter {\n\n    public static void main(String[] args) {\n        for (double d : benchmark(10, x -> System.out.print(\"\"), 10))\n            System.out.println(d);\n    }\n\n    static double[] benchmark(int n, Consumer<Integer> f, int arg) {\n        double[] timings = new double[n];\n        for (int i = 0; i < n; i++) {\n            long time = System.nanoTime();\n            f.accept(arg);\n            timings[i] = System.nanoTime() - time;\n        }\n        return timings;\n    }\n}\n"}
{"id": 388658, "name": "Topswops", "source": "Translate Fortran to Java: module top\nimplicit none\ncontains \nrecursive function f(x) result(m)\n  integer :: n, m, x(:),y(size(x)), fst\n  fst = x(1)\n  if (fst == 1) then\n    m = 0\n  else\n    y(1:fst) = x(fst:1:-1)\n    y(fst+1:) = x(fst+1:)\n    m = 1 + f(y)\n  end if\nend function\n\nrecursive function perms(x) result(p)\ninteger, pointer     :: p(:,:), q(:,:)\ninteger              :: x(:), n, k, i\nn = size(x)\nif (n == 1) then\n  allocate(p(1,1))\n  p(1,:) = x\nelse\n  q => perms(x(2:n))\n  k = ubound(q,1)\n  allocate(p(k*n,n))\n  p = 0\n  do i = 1,n\n    p(1+k*(i-1):k*i,1:i-1) = q(:,1:i-1)\n    p(1+k*(i-1):k*i,i) = x(1)\n    p(1+k*(i-1):k*i,i+1:) = q(:,i:)\n  end do\nend if\nend function\nend module\n\nprogram topswort\nuse top\nimplicit none\ninteger :: x(10)\ninteger, pointer  :: p(:,:)\ninteger :: i, j, m\n\nforall(i=1:10)\n  x(i) = i\nend forall\n\ndo i = 1,10\n  p=>perms(x(1:i))\n  m = 0\n  do j = 1, ubound(p,1)\n    m = max(m, f(p(j,:)))\n  end do\n  print \"(i3,a,i3)\", i,\": \",m\nend do  \nend program\n", "target": "public class Topswops {\n    static final int maxBest = 32;\n    static int[] best;\n\n    static private void trySwaps(int[] deck, int f, int d, int n) {\n        if (d > best[n])\n            best[n] = d;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (deck[i] == -1 || deck[i] == i)\n                break;\n            if (d + best[i] <= best[n])\n                return;\n        }\n\n        int[] deck2 = deck.clone();\n        for (int i = 1; i < n; i++) {\n            final int k = 1 << i;\n            if (deck2[i] == -1) {\n                if ((f & k) != 0)\n                    continue;\n            } else if (deck2[i] != i)\n                continue;\n\n            deck2[0] = i;\n            for (int j = i - 1; j >= 0; j--)\n                deck2[i - j] = deck[j]; \n            trySwaps(deck2, f | k, d + 1, n);\n        }\n    }\n\n    static int topswops(int n) {\n        assert(n > 0 && n < maxBest);\n        best[n] = 0;\n        int[] deck0 = new int[n + 1];\n        for (int i = 1; i < n; i++)\n            deck0[i] = -1;\n        trySwaps(deck0, 1, 0, n);\n        return best[n];\n    }\n\n    public static void main(String[] args) {\n        best = new int[maxBest];\n        for (int i = 1; i < 11; i++)\n            System.out.println(i + \": \" + topswops(i));\n    }\n}\n"}
{"id": 388659, "name": "Odd word problem", "source": "Translate Fortran to Java:       MODULE ELUDOM\t\n       INTEGER MSG,INF\t\n       LOGICAL DEFER\t\n       CONTAINS\n        CHARACTER*1 RECURSIVE FUNCTION GET(IN)\t\n         INTEGER IN\t\n         CHARACTER*1 C\t\n          READ (IN,1,ADVANCE=\"NO\",EOR=3,END=4) C\t\n    1     FORMAT (A1,$)\t\n    2     IF ((\"A\"<=C .AND. C<=\"Z\").OR.(\"a\"<=C .AND. C<=\"z\")) THEN\t\n            IF (DEFER) THEN\t\n              GET = GET(IN)\t\n              WRITE (MSG,1) C\t\n              RETURN\t\t\n            END IF\t\t\n           ELSE\t\t\n            DEFER = .NOT. DEFER\t\n          END IF\t\n    3     GET = C\t\n          RETURN\t\n    4     GET = CHAR(0)\t\n        END FUNCTION GET\n      END MODULE ELUDOM\t\n\n      PROGRAM CONFUSED\t\n      USE ELUDOM\t\n      CHARACTER*1 C\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,NAME = \"Confused.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n\nChew through the input. A full stop marks the end.\n   10 DEFER = .FALSE.\t\n   11 C = GET(INF)\t\t\n      IF (ICHAR(C).LE.0) STOP\t\t\n      IF (C.NE.\" \") WRITE (MSG,12) C\t\n   12 FORMAT (A1,$)\t\t\t\n      IF (C.NE.\".\") GO TO 11\t\n      WRITE (MSG,\"('')\")\t\n      GO TO 10\t\t\n      END\t\n", "target": "public class OddWord {\n    interface CharHandler {\n\tCharHandler handle(char c) throws Exception;\n    }\n    final CharHandler fwd = new CharHandler() {\n\tpublic CharHandler handle(char c) {\n\t    System.out.print(c);\n\t    return (Character.isLetter(c) ? fwd : rev);\n\t}\n    };\n    class Reverser extends Thread implements CharHandler {\n\tReverser() {\n\t    setDaemon(true);\n\t    start();\n\t}\n\tprivate Character ch; \n\tprivate char recur() throws Exception {\n\t    notify();\n\t    while (ch == null) wait();\n\t    char c = ch, ret = c;\n\t    ch = null;\n\t    if (Character.isLetter(c)) {\n\t\tret = recur();\n\t\tSystem.out.print(c);\n\t    }\n\t    return ret;\n\t}\n\tpublic synchronized void run() {\n\t    try {\n\t\twhile (true) {\n\t\t    System.out.print(recur());\n\t\t    notify();\n\t\t}\n\t    } catch (Exception e) {}\n\t}\n\tpublic synchronized CharHandler handle(char c) throws Exception {\n\t    while (ch != null) wait();\n\t    ch = c;\n\t    notify();\n\t    while (ch != null) wait();\n\t    return (Character.isLetter(c) ? rev : fwd);\n\t}\n    }\n    final CharHandler rev = new Reverser();\n\n    public void loop() throws Exception {\n\tCharHandler handler = fwd;\n\tint c;\n\twhile ((c = System.in.read()) >= 0) {\n\t    handler = handler.handle((char) c);\n\t}\n    }\n\n    public static void main(String[] args) throws Exception {\n\tnew OddWord().loop();\n    }\n}\n"}
{"id": 388660, "name": "Numbers with equal rises and falls", "source": "Translate Fortran to Java:       PROGRAM A296712\n          INTEGER IDX, NUM, I\n*         Index and number start out at zero\n          IDX = 0\n          NUM = 0 \n*         Find and write the first 200 numbers\n          WRITE (*,'(A)') 'The first 200 numbers are: '\n          DO 100 I = 1, 200\n              CALL NEXT NUM(IDX, NUM)\n              WRITE (*,'(I4)',ADVANCE='NO') NUM\n              IF (MOD(I,20).EQ.0) WRITE (*,*)\n  100     CONTINUE\n*         Find the 10,000,000th number\n          WRITE (*,*)\n          WRITE (*,'(A)',ADVANCE='NO') 'The 10,000,000th number is: '\n  200     CALL NEXT NUM(IDX, NUM)\n          IF (IDX.NE.10000000) GOTO 200\n          WRITE (*,'(I8)') NUM\n          STOP\n      END    \n\n*     Given index and current number, retrieve the next number\n*     in the sequence.\n      SUBROUTINE NEXT NUM(IDX, NUM) \n          INTEGER IDX, NUM\n          LOGICAL IN SEQ\n  100     NUM = NUM + 1\n          IF (.NOT. IN SEQ(NUM)) GOTO 100\n          IDX = IDX + 1           \n      END\n    \n*     See whether N is in the sequence\n      LOGICAL FUNCTION IN SEQ(N)\n          INTEGER N, DL, DR, VAL, HEIGHT\n*         Get first digit and divide value by 10\n          DL = MOD(N, 10)\n          VAL = N / 10\n          HEIGHT = 0\n  100     IF (VAL.NE.0) THEN\n*             Retrieve digits by modulo and division\n              DR = DL\n              DL = MOD(VAL, 10)\n              VAL = VAL / 10\n*             Record rise or fall\n              IF (DL.LT.DR) HEIGHT = HEIGHT + 1\n              IF (DL.GT.DR) HEIGHT = HEIGHT - 1\n              GOTO 100\n          END IF\n*         N is in the sequence if the final height is 0\n          IN SEQ = HEIGHT.EQ.0\n          RETURN\n      END\n", "target": "public class EqualRisesFalls {\n    public static void main(String[] args) {\n        final int limit1 = 200;\n        final int limit2 = 10000000;\n        System.out.printf(\"The first %d numbers in the sequence are:\\n\", limit1);\n        int n = 0;\n        for (int count = 0; count < limit2; ) {\n            if (equalRisesAndFalls(++n)) {\n                ++count;\n                if (count <= limit1)\n                    System.out.printf(\"%3d%c\", n, count % 20 == 0 ? '\\n' : ' ');\n            }\n        }\n        System.out.printf(\"\\nThe %dth number in the sequence is %d.\\n\", limit2, n);\n    }\n\n    private static boolean equalRisesAndFalls(int n) {\n        int total = 0;\n        for (int previousDigit = -1; n > 0; n /= 10) {\n            int digit = n % 10;\n            if (previousDigit > digit)\n                ++total;\n            else if (previousDigit >= 0 && previousDigit < digit)\n                --total;\n            previousDigit = digit;\n        }\n        return total == 0;\n    }\n}\n"}
{"id": 388661, "name": "Length of an arc between two angles", "source": "Translate Fortran to Java: *-----------------------------------------------------------------------\n* given:  polar coordinates of two points on a circle of known radius\n* find:  length of the major arc between these points\n*\n*___Name_____Type___I/O___Description___________________________________\n*   RAD      Real   In    Radius of circle, any unit of measure\n*   ANG1     Real   In    Angle of first point, degrees\n*   ANG2     Real   In    Angle of second point, degrees\n*   MAJARC   Real   Out   Length of major arc, same units as RAD\n*-----------------------------------------------------------------------\n      FUNCTION MAJARC (RAD, ANG1, ANG2)\n       IMPLICIT NONE\n       REAL RAD, ANG1, ANG2, MAJARC\n\n       REAL FACT                          \n       PARAMETER (FACT = 3.1415926536 / 180.)\n       REAL DIF\n\n*       Begin\n       MAJARC = 0.\n       IF (RAD .LE. 0.) RETURN\n       DIF = MOD(ABS(ANG1 - ANG2), 360.)   \n       DIF = MAX(DIF, 360. - DIF)          \n       MAJARC = RAD * DIF * FACT           \n       RETURN\n      END  \n\n*-----------------------------------------------------------------------\n      PROGRAM TMA\n       IMPLICIT NONE\n       INTEGER J\n       REAL ANG1, ANG2, RAD, MAJARC, ALENG\n       REAL DATARR(3,3)     \n       DATA DATARR / 120.,  10., 10.,\n     $                10., 120., 10.,\n     $               180., 270., 10. /\n\n       DO J = 1, 3\n         ANG1 = DATARR(1,J)\n         ANG2 = DATARR(2,J)\n         RAD = DATARR(3,J)\n         ALENG = MAJARC (RAD, ANG1, ANG2)        \n         PRINT *, 'first angle: ', ANG1, ' second angle: ', ANG2, \n     $     ' radius: ', RAD, ' Length of major arc: ', ALENG\n       END DO\n      END\n", "target": "public static double arcLength(double r, double a1, double a2){\n    return (360.0 - Math.abs(a2-a1))*Math.PI/180.0 * r;\n}\n"}
{"id": 388662, "name": "Matrix with two diagonals", "source": "Translate Fortran to Java: program prog\n\n    dimension a(100, 100)\n\n    n = 7\n\t\n    j1 = 1\n    j2 = n\n    do i = 1, n\n        do j = 1, n\n            a(i, j) = 0.\n        end do\n        a(i, j1) = 1\n        a(i, j2) = 1\n        j1 = j1 + 1\n        j2 = j2 - 1\n    end do\n\n    do i = 1, n\n        print *, (a(i, j), j=1,n)\n    end do\n\nend\n", "target": "package example.diagdiag;\n\npublic class Program {\n\n    public static void main(String[] args) {\n        DiagonalDiagonalMatrix A = new DiagonalDiagonalMatrix(7);\n        System.out.println(A);\n    }\n\n}\n\nclass DiagonalDiagonalMatrix {\n\n    final int n;\n    private double[][] a = null;\n\n    public Matrix(int n) {\n        this.n = n;\n    }\n\n    public double get(int i, int j) {\n        if (a == null) {\n            return (i == j || i == n - j + 1) ? 1.0 : 0.0;\n        } else {\n            return a[i - 1][j - 1];\n        }\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 1; i <= n; i++) {\n            for (int j = 1; j <= n; j++) {\n                sb.append('\\t');\n                sb.append(get(i, j));\n            }\n            sb.append('\\n');\n        }\n        return sb.toString();\n    }\n\n}\n"}
{"id": 388663, "name": "Here document", "source": "Translate Fortran to Java:       INTEGER I         \n      CHARACTER*666 I AM    \n      I AM =                                                           \"<col72\nC              111111111122222222223333333333444444444455555555556666666666\nC     123456789012345678901234567890123456789012345678901234567890123456789\n     1                                                                  <col72\n     2              I AM                                                <col72\n     3                                                                  <col72\n     4           THAT I AM                                              <col72\n     5\"\n\nChug through the text blob.\n      DO I = 0,600,66   \n        WRITE (6,1) I AM(I + 1:I + 66)  \n    1   FORMAT (A66)            \n      END DO                \n      END\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 388664, "name": "Here document", "source": "Translate Fortran to Java:       INTEGER I         \n      CHARACTER*666 I AM    \n      I AM =                                                           \"<col72\nC              111111111122222222223333333333444444444455555555556666666666\nC     123456789012345678901234567890123456789012345678901234567890123456789\n     1                                                                  <col72\n     2              I AM                                                <col72\n     3                                                                  <col72\n     4           THAT I AM                                              <col72\n     5\"\n\nChug through the text blob.\n      DO I = 0,600,66   \n        WRITE (6,1) I AM(I + 1:I + 66)  \n    1   FORMAT (A66)            \n      END DO                \n      END\n", "target": "package rosettacode.heredoc;\npublic class MainApp {\n\tpublic static void main(String[] args) {\n\t\tString hereDoc = \"\"\"\n\t\t\t\tThis is a multiline string.\n\t\t\t\tIt includes all of this text,\n\t\t\t\tbut on separate lines in the code.\n\t\t\t\t \"\"\";\n\t\tSystem.out.println(hereDoc);\n\t}\n}\n"}
{"id": 388665, "name": "2048", "source": "Translate Fortran to Java:         WRITE (MSG,1)\t\t\n    1   FORMAT (\"|\",<NC>(<W>(\"-\"),\"|\"))\t\n    2     FORMAT (\"|\",<NC>(<W>(\" \"),\"|\"))\t\n          WRITE (MSG,22) ((\" \",L1  = 1,W),\"|\",C = 1,NC)\t\n   22     FORMAT (\"|\",666A1)\t\t\t\t\n    4     FORMAT (\"|\",<NC - 1>(<W>(\"-\"),\"+\"),<W>(\"-\"),\"|\")\t\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.Random;\nimport javax.swing.*;\n\npublic class Game2048 extends JPanel {\n\n    enum State {\n        start, won, running, over\n    }\n\n    final Color[] colorTable = {\n        new Color(0x701710), new Color(0xFFE4C3), new Color(0xfff4d3),\n        new Color(0xffdac3), new Color(0xe7b08e), new Color(0xe7bf8e),\n        new Color(0xffc4c3), new Color(0xE7948e), new Color(0xbe7e56),\n        new Color(0xbe5e56), new Color(0x9c3931), new Color(0x701710)};\n\n    final static int target = 2048;\n\n    static int highest;\n    static int score;\n\n    private Color gridColor = new Color(0xBBADA0);\n    private Color emptyColor = new Color(0xCDC1B4);\n    private Color startColor = new Color(0xFFEBCD);\n\n    private Random rand = new Random();\n\n    private Tile[][] tiles;\n    private int side = 4;\n    private State gamestate = State.start;\n    private boolean checkingAvailableMoves;\n\n    public Game2048() {\n        setPreferredSize(new Dimension(900, 700));\n        setBackground(new Color(0xFAF8EF));\n        setFont(new Font(\"SansSerif\", Font.BOLD, 48));\n        setFocusable(true);\n\n        addMouseListener(new MouseAdapter() {\n            @Override\n            public void mousePressed(MouseEvent e) {\n                startGame();\n                repaint();\n            }\n        });\n\n        addKeyListener(new KeyAdapter() {\n            @Override\n            public void keyPressed(KeyEvent e) {\n                switch (e.getKeyCode()) {\n                    case KeyEvent.VK_UP:\n                        moveUp();\n                        break;\n                    case KeyEvent.VK_DOWN:\n                        moveDown();\n                        break;\n                    case KeyEvent.VK_LEFT:\n                        moveLeft();\n                        break;\n                    case KeyEvent.VK_RIGHT:\n                        moveRight();\n                        break;\n                }\n                repaint();\n            }\n        });\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawGrid(g);\n    }\n\n    void startGame() {\n        if (gamestate != State.running) {\n            score = 0;\n            highest = 0;\n            gamestate = State.running;\n            tiles = new Tile[side][side];\n            addRandomTile();\n            addRandomTile();\n        }\n    }\n\n    void drawGrid(Graphics2D g) {\n        g.setColor(gridColor);\n        g.fillRoundRect(200, 100, 499, 499, 15, 15);\n\n        if (gamestate == State.running) {\n\n            for (int r = 0; r < side; r++) {\n                for (int c = 0; c < side; c++) {\n                    if (tiles[r][c] == null) {\n                        g.setColor(emptyColor);\n                        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\n                    } else {\n                        drawTile(g, r, c);\n                    }\n                }\n            }\n        } else {\n            g.setColor(startColor);\n            g.fillRoundRect(215, 115, 469, 469, 7, 7);\n\n            g.setColor(gridColor.darker());\n            g.setFont(new Font(\"SansSerif\", Font.BOLD, 128));\n            g.drawString(\"2048\", 310, 270);\n\n            g.setFont(new Font(\"SansSerif\", Font.BOLD, 20));\n\n            if (gamestate == State.won) {\n                g.drawString(\"you made it!\", 390, 350);\n\n            } else if (gamestate == State.over)\n                g.drawString(\"game over\", 400, 350);\n\n            g.setColor(gridColor);\n            g.drawString(\"click to start a new game\", 330, 470);\n            g.drawString(\"(use arrow keys to move tiles)\", 310, 530);\n        }\n    }\n\n    void drawTile(Graphics2D g, int r, int c) {\n        int value = tiles[r][c].getValue();\n\n        g.setColor(colorTable[(int) (Math.log(value) / Math.log(2)) + 1]);\n        g.fillRoundRect(215 + c * 121, 115 + r * 121, 106, 106, 7, 7);\n        String s = String.valueOf(value);\n\n        g.setColor(value < 128 ? colorTable[0] : colorTable[1]);\n\n        FontMetrics fm = g.getFontMetrics();\n        int asc = fm.getAscent();\n        int dec = fm.getDescent();\n\n        int x = 215 + c * 121 + (106 - fm.stringWidth(s)) / 2;\n        int y = 115 + r * 121 + (asc + (106 - (asc + dec)) / 2);\n\n        g.drawString(s, x, y);\n    }\n\n\n    private void addRandomTile() {\n        int pos = rand.nextInt(side * side);\n        int row, col;\n        do {\n            pos = (pos + 1) % (side * side);\n            row = pos / side;\n            col = pos % side;\n        } while (tiles[row][col] != null);\n\n        int val = rand.nextInt(10) == 0 ? 4 : 2;\n        tiles[row][col] = new Tile(val);\n    }\n\n    private boolean move(int countDownFrom, int yIncr, int xIncr) {\n        boolean moved = false;\n\n        for (int i = 0; i < side * side; i++) {\n            int j = Math.abs(countDownFrom - i);\n\n            int r = j / side;\n            int c = j % side;\n\n            if (tiles[r][c] == null)\n                continue;\n\n            int nextR = r + yIncr;\n            int nextC = c + xIncr;\n\n            while (nextR >= 0 && nextR < side && nextC >= 0 && nextC < side) {\n\n                Tile next = tiles[nextR][nextC];\n                Tile curr = tiles[r][c];\n\n                if (next == null) {\n\n                    if (checkingAvailableMoves)\n                        return true;\n\n                    tiles[nextR][nextC] = curr;\n                    tiles[r][c] = null;\n                    r = nextR;\n                    c = nextC;\n                    nextR += yIncr;\n                    nextC += xIncr;\n                    moved = true;\n\n                } else if (next.canMergeWith(curr)) {\n\n                    if (checkingAvailableMoves)\n                        return true;\n\n                    int value = next.mergeWith(curr);\n                    if (value > highest)\n                        highest = value;\n                    score += value;\n                    tiles[r][c] = null;\n                    moved = true;\n                    break;\n                } else\n                    break;\n            }\n        }\n\n        if (moved) {\n            if (highest < target) {\n                clearMerged();\n                addRandomTile();\n                if (!movesAvailable()) {\n                    gamestate = State.over;\n                }\n            } else if (highest == target)\n                gamestate = State.won;\n        }\n\n        return moved;\n    }\n\n    boolean moveUp() {\n        return move(0, -1, 0);\n    }\n\n    boolean moveDown() {\n        return move(side * side - 1, 1, 0);\n    }\n\n    boolean moveLeft() {\n        return move(0, 0, -1);\n    }\n\n    boolean moveRight() {\n        return move(side * side - 1, 0, 1);\n    }\n\n    void clearMerged() {\n        for (Tile[] row : tiles)\n            for (Tile tile : row)\n                if (tile != null)\n                    tile.setMerged(false);\n    }\n\n    boolean movesAvailable() {\n        checkingAvailableMoves = true;\n        boolean hasMoves = moveUp() || moveDown() || moveLeft() || moveRight();\n        checkingAvailableMoves = false;\n        return hasMoves;\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"2048\");\n            f.setResizable(true);\n            f.add(new Game2048(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n\nclass Tile {\n    private boolean merged;\n    private int value;\n\n    Tile(int val) {\n        value = val;\n    }\n\n    int getValue() {\n        return value;\n    }\n\n    void setMerged(boolean m) {\n        merged = m;\n    }\n\n    boolean canMergeWith(Tile other) {\n        return !merged && other != null && !other.merged && value == other.getValue();\n    }\n\n    int mergeWith(Tile other) {\n        if (canMergeWith(other)) {\n            value *= 2;\n            merged = true;\n            return value;\n        }\n        return -1;\n    }\n}\n"}
{"id": 388666, "name": "Loops_Infinite", "source": "Translate Fortran to Java:       \n   10 WRITE(*,*) 'SPAM'\n      GO TO 10\n      END\n", "target": "while (true) {\n   System.out.println(\"SPAM\");\n}\n"}
{"id": 388667, "name": "Assertions in design by contract", "source": "Translate Fortran to Java:       SUBROUTINE AFFIRM(CONDITION,MESSAGE)\n        LOGICAL CONDITION\n        CHARACTER*(*) MESSAGE\n         IF (CONDITION) RETURN      \n         WRITE (6,*) MESSAGE\n         STOP \"Oops. Confusion\n       END\n", "target": "(...)\nint feedForward(double[] inputs) {\n    assert inputs.length == weights.length : \"weights and input length mismatch\";\n\n    double sum = 0;\n    for (int i = 0; i < weights.length; i++) {\n        sum += inputs[i] * weights[i];\n    }\n    return activate(sum);\n}\n(...)\n"}
{"id": 388668, "name": "Assertions in design by contract", "source": "Translate Fortran to Java:       SUBROUTINE AFFIRM(CONDITION,MESSAGE)\n        LOGICAL CONDITION\n        CHARACTER*(*) MESSAGE\n         IF (CONDITION) RETURN      \n         WRITE (6,*) MESSAGE\n         STOP \"Oops. Confusion\n       END\n", "target": "(...)\nint feedForward(double[] inputs) {\n    assert inputs.length == weights.length : \"weights and input length mismatch\";\n\n    double sum = 0;\n    for (int i = 0; i < weights.length; i++) {\n        sum += inputs[i] * weights[i];\n    }\n    return activate(sum);\n}\n(...)\n"}
{"id": 388669, "name": "Function definition", "source": "Translate Fortran to Java:      XMULTF(X,Y)=X*Y\n", "target": "module MultiplyExample\n    {\n    static <Value extends Number> Value multiply(Value n1, Value n2)\n        {\n        return n1 * n2;\n        }\n\n    void run()\n        {\n        (Int i1, Int i2) = (7, 3);\n        Int i3 = multiply(i1, i2);\n        (Double d1, Double d2) = (2.7182818, 3.1415);\n        Double d3 = multiply(d1, d2);\n        @Inject Console console;\n        console.print($\"{i1}*{i2}={i3}, {d1}*{d2}={d3}\");\n        }\n    }\n"}
{"id": 388670, "name": "Determinant and permanent", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  real, dimension(3,3) :: j, m\n  data j/ 2,-1, 1,-1,-2, 1,-1,-1,-1/\n  data m/2, 9, 4, 7, 5, 3, 6, 1, 8/\n  write(6,*) 'j example, determinant: ',det(j,3,-1)\n  write(6,*) 'j example, permanent:   ',det(j,3,1)\n  write(6,*) 'maxima, determinant:    ',det(m,3,-1)\n  write(6,*) 'maxima, permanent:      ',det(m,3,1)\n\ncontains\n\n  recursive function det(a,n,permanent) result(accumulation)\n    \n    \n    real, dimension(n,n), intent(in) :: a\n    integer, intent(in) :: n, permanent\n    real, dimension(n-1, n-1) :: b\n    real :: accumulation\n    integer :: i, sgn\n    if (n .eq. 1) then\n      accumulation = a(1,1)\n    else\n      accumulation = 0\n      sgn = 1\n      do i=1, n\n        b(:, :(i-1)) = a(2:, :i-1)\n        b(:, i:) = a(2:, i+1:)\n        accumulation = accumulation + sgn * a(1, i) * det(b, n-1, permanent)\n        sgn = sgn * permanent\n      enddo\n    endif\n  end function det\n\nend program f\n", "target": "import java.util.Scanner;\n\npublic class MatrixArithmetic {\n\tpublic static double[][] minor(double[][] a, int x, int y){\n\t\tint length = a.length-1;\n\t\tdouble[][] result = new double[length][length];\n\t\tfor(int i=0;i<length;i++) for(int j=0;j<length;j++){\n\t\t\tif(i<x && j<y){\n\t\t\t\tresult[i][j] = a[i][j];\n\t\t\t}else if(i>=x && j<y){\n\t\t\t\tresult[i][j] = a[i+1][j];\n\t\t\t}else if(i<x && j>=y){\n\t\t\t\tresult[i][j] = a[i][j+1];\n\t\t\t}else{ \n\t\t\t\tresult[i][j] = a[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static double det(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tint sign = 1;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += sign * a[0][i] * det(minor(a,0,i));\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static double perm(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += a[0][i] * perm(minor(a,0,i));\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint size = sc.nextInt();\n\t\tdouble[][] a = new double[size][size];\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<size;j++){\n\t\t\ta[i][j] = sc.nextDouble();\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(\"Determinant: \"+det(a));\n\t\tSystem.out.println(\"Permanent: \"+perm(a));\n\t}\n}\n"}
{"id": 388671, "name": "Determinant and permanent", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  real, dimension(3,3) :: j, m\n  data j/ 2,-1, 1,-1,-2, 1,-1,-1,-1/\n  data m/2, 9, 4, 7, 5, 3, 6, 1, 8/\n  write(6,*) 'j example, determinant: ',det(j,3,-1)\n  write(6,*) 'j example, permanent:   ',det(j,3,1)\n  write(6,*) 'maxima, determinant:    ',det(m,3,-1)\n  write(6,*) 'maxima, permanent:      ',det(m,3,1)\n\ncontains\n\n  recursive function det(a,n,permanent) result(accumulation)\n    \n    \n    real, dimension(n,n), intent(in) :: a\n    integer, intent(in) :: n, permanent\n    real, dimension(n-1, n-1) :: b\n    real :: accumulation\n    integer :: i, sgn\n    if (n .eq. 1) then\n      accumulation = a(1,1)\n    else\n      accumulation = 0\n      sgn = 1\n      do i=1, n\n        b(:, :(i-1)) = a(2:, :i-1)\n        b(:, i:) = a(2:, i+1:)\n        accumulation = accumulation + sgn * a(1, i) * det(b, n-1, permanent)\n        sgn = sgn * permanent\n      enddo\n    endif\n  end function det\n\nend program f\n", "target": "import java.util.Scanner;\n\npublic class MatrixArithmetic {\n\tpublic static double[][] minor(double[][] a, int x, int y){\n\t\tint length = a.length-1;\n\t\tdouble[][] result = new double[length][length];\n\t\tfor(int i=0;i<length;i++) for(int j=0;j<length;j++){\n\t\t\tif(i<x && j<y){\n\t\t\t\tresult[i][j] = a[i][j];\n\t\t\t}else if(i>=x && j<y){\n\t\t\t\tresult[i][j] = a[i+1][j];\n\t\t\t}else if(i<x && j>=y){\n\t\t\t\tresult[i][j] = a[i][j+1];\n\t\t\t}else{ \n\t\t\t\tresult[i][j] = a[i+1][j+1];\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\tpublic static double det(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tint sign = 1;\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += sign * a[0][i] * det(minor(a,0,i));\n\t\t\t\tsign *= -1;\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static double perm(double[][] a){\n\t\tif(a.length == 1){\n\t\t\treturn a[0][0];\n\t\t}else{\n\t\t\tdouble sum = 0;\n\t\t\tfor(int i=0;i<a.length;i++){\n\t\t\t\tsum += a[0][i] * perm(minor(a,0,i));\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t}\n\tpublic static void main(String args[]){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint size = sc.nextInt();\n\t\tdouble[][] a = new double[size][size];\n\t\tfor(int i=0;i<size;i++) for(int j=0;j<size;j++){\n\t\t\ta[i][j] = sc.nextDouble();\n\t\t}\n\t\tsc.close();\n\t\tSystem.out.println(\"Determinant: \"+det(a));\n\t\tSystem.out.println(\"Permanent: \"+perm(a));\n\t}\n}\n"}
{"id": 388672, "name": "Brazilian numbers", "source": "Translate Fortran to Java: \n\n      PROGRAM BRAZILIAN\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  MAX_NUMBER = 2000000 , NUMVARS = 20\n\n\n\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  b\n      INTEGER  ::  bcount\n      INTEGER  ::  bpos\n      CHARACTER(15)  ::  holder\n      CHARACTER(100)  ::  outline\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  p\n\n\n\n\n\n\n      CALL BRAZILIANSIEVE(b , MAX_NUMBER)\n      WRITE(6 , 34)\"The first 20 Brazilian numbers:\"\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n \n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 odd Brazilian numbers:\"\n      outline = ''\n      holder = ''\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 2\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 prime Brazilian numbers:\"\n      CALL ERATOSTHENES(p , MAX_NUMBER)\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) .AND. p(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"Various Brazilian numbers:\"\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<1000000 )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            IF( (bcount==100) .OR. (bcount==1000) .OR. (bcount==10000) .OR.               &\n              & (bcount==100000) .OR. (bcount==1000000) )WRITE(* , *)bcount ,             &\n               &\"th Brazilian number: \" , bpos\n         END IF\n         bpos = bpos + 1\n      END DO\n      STOP\n 34   FORMAT(/ , a)\n      END PROGRAM BRAZILIAN\n\n      SUBROUTINE BRAZILIANSIEVE(B , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  B\n      INTENT (IN) N\n      INTENT (OUT) B\n\n\n\n      INTEGER  ::  b11\n      INTEGER  ::  base\n      INTEGER  ::  bn\n      INTEGER  ::  bnn\n      INTEGER  ::  bpower\n      INTEGER  ::  digit\n      INTEGER  ::  i\n      LOGICAL  ::  iseven\n      INTEGER  ::  powermax\n\n      iseven = .FALSE.\n      B(1:6) = .FALSE.                 \n      DO i = 7 , N\n         B(i) = iseven\n         iseven = .NOT.iseven\n      END DO\n      DO base = 2 , (N/2)\n         b11 = base + 1\n         bnn = b11\n         DO digit = 3 , base - 1 , 2\n            bnn = bnn + b11 + b11\n            IF( bnn>N )EXIT\n            B(bnn) = .TRUE.\n         END DO\n      END DO\n      DO base = 2 , INT(SQRT(FLOAT(N)))\n         powermax = HUGE(powermax)/base             \n         IF( powermax>N )powermax = N               \n         DO digit = 1 , base - 1 , 2\n            bpower = base*base\n            bn = digit*(bpower + base + 1)\n            DO WHILE ( (bn<=N) .AND. (bpower<=powermax) )\n               IF( bn<=N )B(bn) = .TRUE.\n               bpower = bpower*base\n               bn = bn + (digit*bpower)\n            END DO\n         END DO\n      END DO\n      RETURN\n      END SUBROUTINE BRAZILIANSIEVE\n\n      SUBROUTINE ERATOSTHENES(P , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  P\n      INTENT (IN) N\n      INTENT (INOUT) P\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  ii\n      LOGICAL  ::  oddeven\n      INTEGER  ::  pr\n\n      P(1) = .FALSE.\n      P(2) = .TRUE.\n      oddeven = .TRUE.\n      DO i = 3 , N\n         P(i) = oddeven\n         oddeven = .NOT.oddeven\n      END DO\n      DO i = 2 , INT(SQRT(FLOAT(N)))\n         ii = i + i\n         IF( P(i) )THEN\n            DO pr = i*i , N , ii\n               P(pr) = .FALSE.\n            END DO\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE ERATOSTHENES\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 388673, "name": "Brazilian numbers", "source": "Translate Fortran to Java: \n\n      PROGRAM BRAZILIAN\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  MAX_NUMBER = 2000000 , NUMVARS = 20\n\n\n\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  b\n      INTEGER  ::  bcount\n      INTEGER  ::  bpos\n      CHARACTER(15)  ::  holder\n      CHARACTER(100)  ::  outline\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  p\n\n\n\n\n\n\n      CALL BRAZILIANSIEVE(b , MAX_NUMBER)\n      WRITE(6 , 34)\"The first 20 Brazilian numbers:\"\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n \n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 odd Brazilian numbers:\"\n      outline = ''\n      holder = ''\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 2\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 prime Brazilian numbers:\"\n      CALL ERATOSTHENES(p , MAX_NUMBER)\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) .AND. p(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"Various Brazilian numbers:\"\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<1000000 )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            IF( (bcount==100) .OR. (bcount==1000) .OR. (bcount==10000) .OR.               &\n              & (bcount==100000) .OR. (bcount==1000000) )WRITE(* , *)bcount ,             &\n               &\"th Brazilian number: \" , bpos\n         END IF\n         bpos = bpos + 1\n      END DO\n      STOP\n 34   FORMAT(/ , a)\n      END PROGRAM BRAZILIAN\n\n      SUBROUTINE BRAZILIANSIEVE(B , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  B\n      INTENT (IN) N\n      INTENT (OUT) B\n\n\n\n      INTEGER  ::  b11\n      INTEGER  ::  base\n      INTEGER  ::  bn\n      INTEGER  ::  bnn\n      INTEGER  ::  bpower\n      INTEGER  ::  digit\n      INTEGER  ::  i\n      LOGICAL  ::  iseven\n      INTEGER  ::  powermax\n\n      iseven = .FALSE.\n      B(1:6) = .FALSE.                 \n      DO i = 7 , N\n         B(i) = iseven\n         iseven = .NOT.iseven\n      END DO\n      DO base = 2 , (N/2)\n         b11 = base + 1\n         bnn = b11\n         DO digit = 3 , base - 1 , 2\n            bnn = bnn + b11 + b11\n            IF( bnn>N )EXIT\n            B(bnn) = .TRUE.\n         END DO\n      END DO\n      DO base = 2 , INT(SQRT(FLOAT(N)))\n         powermax = HUGE(powermax)/base             \n         IF( powermax>N )powermax = N               \n         DO digit = 1 , base - 1 , 2\n            bpower = base*base\n            bn = digit*(bpower + base + 1)\n            DO WHILE ( (bn<=N) .AND. (bpower<=powermax) )\n               IF( bn<=N )B(bn) = .TRUE.\n               bpower = bpower*base\n               bn = bn + (digit*bpower)\n            END DO\n         END DO\n      END DO\n      RETURN\n      END SUBROUTINE BRAZILIANSIEVE\n\n      SUBROUTINE ERATOSTHENES(P , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  P\n      INTENT (IN) N\n      INTENT (INOUT) P\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  ii\n      LOGICAL  ::  oddeven\n      INTEGER  ::  pr\n\n      P(1) = .FALSE.\n      P(2) = .TRUE.\n      oddeven = .TRUE.\n      DO i = 3 , N\n         P(i) = oddeven\n         oddeven = .NOT.oddeven\n      END DO\n      DO i = 2 , INT(SQRT(FLOAT(N)))\n         ii = i + i\n         IF( P(i) )THEN\n            DO pr = i*i , N , ii\n               P(pr) = .FALSE.\n            END DO\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE ERATOSTHENES\n", "target": "import java.math.BigInteger;\nimport java.util.List;\n\npublic class Brazilian {\n    private static final List<Integer> primeList = List.of(\n        2, 3, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89,\n        97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 169, 173, 179, 181,\n        191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 247, 251, 257, 263, 269, 271, 277, 281,\n        283, 293, 299, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 377, 379, 383, 389,\n        397, 401, 403, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 481, 487, 491,\n        499, 503, 509, 521, 523, 533, 541, 547, 557, 559, 563, 569, 571, 577, 587, 593, 599, 601, 607,\n        611, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 689, 691, 701, 709, 719,\n        727, 733, 739, 743, 751, 757, 761, 767, 769, 773, 787, 793, 797, 809, 811, 821, 823, 827, 829,\n        839, 853, 857, 859, 863, 871, 877, 881, 883, 887, 907, 911, 919, 923, 929, 937, 941, 947, 949,\n        953, 967, 971, 977, 983, 991, 997\n    );\n\n    public static boolean isPrime(int n) {\n        if (n < 2) {\n            return false;\n        }\n\n        for (Integer prime : primeList) {\n            if (n == prime) {\n                return true;\n            }\n            if (n % prime == 0) {\n                return false;\n            }\n            if (prime * prime > n) {\n                return true;\n            }\n        }\n\n        BigInteger bi = BigInteger.valueOf(n);\n        return bi.isProbablePrime(10);\n    }\n\n    private static boolean sameDigits(int n, int b) {\n        int f = n % b;\n        while ((n /= b) > 0) {\n            if (n % b != f) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isBrazilian(int n) {\n        if (n < 7) return false;\n        if (n % 2 == 0) return true;\n        for (int b = 2; b < n - 1; ++b) {\n            if (sameDigits(n, b)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    public static void main(String[] args) {\n        for (String kind : List.of(\"\", \"odd \", \"prime \")) {\n            boolean quiet = false;\n            int bigLim = 99_999;\n            int limit = 20;\n            System.out.printf(\"First %d %sBrazilian numbers:\\n\", limit, kind);\n            int c = 0;\n            int n = 7;\n            while (c < bigLim) {\n                if (isBrazilian(n)) {\n                    if (!quiet) System.out.printf(\"%d \", n);\n                    if (++c == limit) {\n                        System.out.println(\"\\n\");\n                        quiet = true;\n                    }\n                }\n                if (quiet && !\"\".equals(kind)) continue;\n                switch (kind) {\n                    case \"\":\n                        n++;\n                        break;\n                    case \"odd \":\n                        n += 2;\n                        break;\n                    case \"prime \":\n                        do {\n                            n += 2;\n                        } while (!isPrime(n));\n                        break;\n                    default:\n                        throw new AssertionError(\"Oops\");\n                }\n            }\n            if (\"\".equals(kind)) {\n                System.out.printf(\"The %dth Brazilian number is: %d\\n\\n\", bigLim + 1, n);\n            }\n        }\n    }\n}\n"}
{"id": 388674, "name": "Sum of divisors", "source": "Translate Fortran to Java:        program DivSum\n       implicit none\n       integer i, j, col, divs(100)\n       \n       do 10 i=1, 100, 1\n 10        divs(i) = 1\n \n       do 20 i=2, 100, 1\n           do 20 j=i, 100, i\n 20            divs(j) = divs(j) + i\n \n       col = 0\n       do 30 i=1, 100, 1\n           write (*,'(I4)',advance='no') divs(i)\n           col = col + 1\n           if (col .eq. 10) then\n               col = 0\n               write (*,*)\n           end if\n 30    continue\n       end program\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388675, "name": "Sum of divisors", "source": "Translate Fortran to Java:        program DivSum\n       implicit none\n       integer i, j, col, divs(100)\n       \n       do 10 i=1, 100, 1\n 10        divs(i) = 1\n \n       do 20 i=2, 100, 1\n           do 20 j=i, 100, i\n 20            divs(j) = divs(j) + i\n \n       col = 0\n       do 30 i=1, 100, 1\n           write (*,'(I4)',advance='no') divs(i)\n           col = col + 1\n           if (col .eq. 10) then\n               col = 0\n               write (*,*)\n           end if\n 30    continue\n       end program\n", "target": "public class DivisorSum {\n    private static long divisorSum(long n) {\n        var total = 1L;\n        var power = 2L;\n        \n        for (; (n & 1) == 0; power <<= 1, n >>= 1) {\n            total += power;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long sum = 1;\n            for (power = p; n % p == 0; power *= p, n /= p) {\n                sum += power;\n            }\n            total *= sum;\n        }\n        \n        if (n > 1) {\n            total *= n + 1;\n        }\n        return total;\n    }\n\n    public static void main(String[] args) {\n        final long limit = 100;\n        System.out.printf(\"Sum of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; ++n) {\n            System.out.printf(\"%4d\", divisorSum(n));\n            if (n % 10 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388676, "name": "Sorting algorithms_Bead sort", "source": "Translate Fortran to Java: program BeadSortTest\n  use iso_fortran_env \n  \n  \n  \n  \n\n  integer, dimension(7) :: a = (/ 7, 3, 5, 1, 2, 1, 20 /)\n\n  call beadsort(a)\n  print *, a\n\ncontains\n\n  subroutine beadsort(a)\n    integer, dimension(:), intent(inout) :: a\n\n    integer, dimension(maxval(a), maxval(a)) :: t\n    integer, dimension(maxval(a)) :: s\n    integer :: i, m\n\n    m = maxval(a)\n    \n    if ( any(a < 0) ) then\n       write(ERROR_UNIT,*) \"can't sort\"\n       return\n    end if\n\n    t = 0\n    forall(i=1:size(a)) t(i, 1:a(i)) = 1  \n    forall(i=1:m)             \n       s(i) = sum(t(:, i))    \n       t(:, i) = 0            \n       t(1:s(i), i) = 1       \n    end forall\n    \n    forall(i=1:size(a)) a(i) = sum(t(i,:))\n    \n  end subroutine beadsort\n\nend program BeadSortTest\n", "target": "public class BeadSort \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tBeadSort now=new BeadSort();\n\t\tint[] arr=new int[(int)(Math.random()*11)+5];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tarr[i]=(int)(Math.random()*10);\n\t\tSystem.out.print(\"Unsorted: \");\n\t\tnow.display1D(arr);\n\t\t\n\t\tint[] sort=now.beadSort(arr);\n\t\tSystem.out.print(\"Sorted: \");\n\t\tnow.display1D(sort);\n\t}\n\tint[] beadSort(int[] arr)\n\t{\n\t\tint max=a[0];\n\t\tfor(int i=1;i<arr.length;i++)\n\t\t\tif(arr[i]>max)\n\t\t\t\tmax=arr[i];\n\t\t\n\t\t\n\t\tchar[][] grid=new char[arr.length][max];\n\t\tint[] levelcount=new int[max];\n\t\tfor(int i=0;i<max;i++)\n\t\t{\n\t\t\tlevelcount[i]=0;\n\t\t\tfor(int j=0;j<arr.length;j++)\n\t\t\t\tgrid[j][i]='_';\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint num=arr[i];\n\t\t\tfor(int j=0;num>0;j++)\n\t\t\t{\n\t\t\t\tgrid[levelcount[j]++][j]='*';\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println();\n\t\tdisplay2D(grid);\n\t\t\n\t\tint[] sorted=new int[arr.length];\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t{\n\t\t\tint putt=0;\n\t\t\tfor(int j=0;j<max&&grid[arr.length-1-i][j]=='*';j++)\n\t\t\t\tputt++;\n\t\t\tsorted[i]=putt;\n\t\t}\n\t\t\n\t\treturn sorted;\n\t}\n\tvoid display1D(int[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display1D(char[] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tvoid display2D(char[][] arr)\n\t{\n\t\tfor(int i=0;i<arr.length;i++)\n\t\t\tdisplay1D(arr[i]);\n\t\tSystem.out.println();\n\t}\n}\n"}
{"id": 388677, "name": "M\u00f6bius function", "source": "Translate Fortran to Java: program moebius\n    use iso_fortran_env, only: output_unit\n\n    integer, parameter          :: mu_max=1000000, line_break=20\n    integer, parameter          :: sqroot=int(sqrt(real(mu_max)))\n    integer                     :: i, j\n    integer, dimension(mu_max)  :: mu\n\n    mu = 1\n\n    do i = 2, sqroot\n        if (mu(i) == 1) then\n            do j = i, mu_max, i\n                mu(j) = mu(j) * (-i)\n            end do\n\n            do j = i**2, mu_max, i**2\n                mu(j) = 0\n            end do\n        end if\n    end do\n\n    do i = 2, mu_max\n        if (mu(i) == i) then\n            mu(i) = 1\n        else if (mu(i) == -i) then\n            mu(i) = -1\n        else if (mu(i) < 0) then\n            mu(i) = 1\n        else if (mu(i) > 0) then\n            mu(i) = -1\n        end if\n    end do\n\n    write(output_unit,*) \"The first 199 terms of the M\u00f6bius sequence are:\"\n    write(output_unit,'(3x)', advance=\"no\") \n    do i = 1, 199\n        write(output_unit,'(I2,x)', advance=\"no\") mu(i)\n        if (modulo(i+1, line_break) == 0) write(output_unit,*)\n    end do\nend program moebius\n", "target": "public class M\u00f6biusFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the m\u00f6bius function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", m\u00f6biusFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n    }\n    \n    private static int MU_MAX = 1_000_000;\n    private static int[] MU = null;\n    \n    \n    private static int m\u00f6biusFunction(int n) {\n        if ( MU != null ) {\n            return MU[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n        }\n        return MU[n];\n    }\n\n}\n"}
{"id": 388678, "name": "Execute Brain____", "source": "Translate Fortran to Java:       MODULE BRAIN\t\n       INTEGER MSG,KBD\n       CONTAINS\t\t\n        SUBROUTINE RUN(PROG,STORE)\t\n         CHARACTER*(*) PROG\t\n         CHARACTER*(1) STORE(:)\t\n         CHARACTER*1 C\t\t\n         INTEGER I,D\t\t\n          D = 1\t\t\n          I = 1\t\t\n\n          DO WHILE(I.LE.LEN(PROG))\t\n            C = PROG(I:I)\t\t\t\n            I = I + 1\t\t\t\t\n            SELECT CASE(C)\t\t\t\n             CASE(\">\"); D = D + 1\t\t\t\t\n             CASE(\"<\"); D = D - 1\t\t\t\t\n             CASE(\"+\"); STORE(D) = CHAR(ICHAR(STORE(D)) + 1)\t\n             CASE(\"-\"); STORE(D) = CHAR(ICHAR(STORE(D)) - 1)\t\n             CASE(\".\"); WRITE (MSG,1) STORE(D)\t\t\t\n             CASE(\",\"); READ (KBD,1) STORE(D)\t\t\t\n             CASE(\"[\"); IF (ICHAR(STORE(D)).EQ.0) CALL SEEK(+1)\t\n             CASE(\"]\"); IF (ICHAR(STORE(D)).NE.0) CALL SEEK(-1)\t\n             CASE DEFAULT\t\t\t\t\n\t\t  \t\t\t\t\t\t\n            END SELECT\t\t\t\t\n          END DO\t\t\t\n\n    1     FORMAT (A1,$)\t\n         CONTAINS\t\n          SUBROUTINE SEEK(WAY)\t\n           INTEGER WAY\t\t\n           CHARACTER*1 AB,BA\t\n           INTEGER INDEEP\t\n            INDEEP = 0\t\t\n            I = I - 1\t\t\n            AB = PROG(I:I)\t\n            BA = \"[ ]\"(WAY + 2:WAY + 2)\t\n    1       IF (I.GT.LEN(PROG)) STOP \"Out of code\n            IF (PROG(I:I).EQ.AB) THEN\t\t\n              INDEEP = INDEEP + 1\t\t\t\n            ELSE IF (PROG(I:I).EQ.BA) THEN\t\n              INDEEP = INDEEP - 1\t\t\t\n            END IF\t\t\t\t\n            IF (INDEEP.GT.0) THEN\t\n              I = I + WAY\t\t\t\n              IF (I.GT.0) GO TO 1\t\t\n              STOP \"Back to 0\n            END IF\t\t\t\n            I = I + 1\t\t\t\n          END SUBROUTINE SEEK\t\n        END SUBROUTINE RUN\t\n      END MODULE BRAIN\t\n\n      PROGRAM POKE\t\n      USE BRAIN\t\t\n      CHARACTER*1 STORE(30000)\t\n      CHARACTER*(*) HELLOWORLD\t\n      PARAMETER (HELLOWORLD = \"++++++++[>++++[>++>+++>+++>+<<<<-]\"\n     1 //\" >+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------\"\n     2 //\".--------.>>+.>++.\")\n      KBD = 5\t\t\n      MSG = 6\t\t\n      STORE = CHAR(0)\t\n\n      CALL RUN(HELLOWORLD,STORE)\t\n\n      END\t\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 388679, "name": "Execute Brain____", "source": "Translate Fortran to Java:       MODULE BRAIN\t\n       INTEGER MSG,KBD\n       CONTAINS\t\t\n        SUBROUTINE RUN(PROG,STORE)\t\n         CHARACTER*(*) PROG\t\n         CHARACTER*(1) STORE(:)\t\n         CHARACTER*1 C\t\t\n         INTEGER I,D\t\t\n          D = 1\t\t\n          I = 1\t\t\n\n          DO WHILE(I.LE.LEN(PROG))\t\n            C = PROG(I:I)\t\t\t\n            I = I + 1\t\t\t\t\n            SELECT CASE(C)\t\t\t\n             CASE(\">\"); D = D + 1\t\t\t\t\n             CASE(\"<\"); D = D - 1\t\t\t\t\n             CASE(\"+\"); STORE(D) = CHAR(ICHAR(STORE(D)) + 1)\t\n             CASE(\"-\"); STORE(D) = CHAR(ICHAR(STORE(D)) - 1)\t\n             CASE(\".\"); WRITE (MSG,1) STORE(D)\t\t\t\n             CASE(\",\"); READ (KBD,1) STORE(D)\t\t\t\n             CASE(\"[\"); IF (ICHAR(STORE(D)).EQ.0) CALL SEEK(+1)\t\n             CASE(\"]\"); IF (ICHAR(STORE(D)).NE.0) CALL SEEK(-1)\t\n             CASE DEFAULT\t\t\t\t\n\t\t  \t\t\t\t\t\t\n            END SELECT\t\t\t\t\n          END DO\t\t\t\n\n    1     FORMAT (A1,$)\t\n         CONTAINS\t\n          SUBROUTINE SEEK(WAY)\t\n           INTEGER WAY\t\t\n           CHARACTER*1 AB,BA\t\n           INTEGER INDEEP\t\n            INDEEP = 0\t\t\n            I = I - 1\t\t\n            AB = PROG(I:I)\t\n            BA = \"[ ]\"(WAY + 2:WAY + 2)\t\n    1       IF (I.GT.LEN(PROG)) STOP \"Out of code\n            IF (PROG(I:I).EQ.AB) THEN\t\t\n              INDEEP = INDEEP + 1\t\t\t\n            ELSE IF (PROG(I:I).EQ.BA) THEN\t\n              INDEEP = INDEEP - 1\t\t\t\n            END IF\t\t\t\t\n            IF (INDEEP.GT.0) THEN\t\n              I = I + WAY\t\t\t\n              IF (I.GT.0) GO TO 1\t\t\n              STOP \"Back to 0\n            END IF\t\t\t\n            I = I + 1\t\t\t\n          END SUBROUTINE SEEK\t\n        END SUBROUTINE RUN\t\n      END MODULE BRAIN\t\n\n      PROGRAM POKE\t\n      USE BRAIN\t\t\n      CHARACTER*1 STORE(30000)\t\n      CHARACTER*(*) HELLOWORLD\t\n      PARAMETER (HELLOWORLD = \"++++++++[>++++[>++>+++>+++>+<<<<-]\"\n     1 //\" >+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------\"\n     2 //\".--------.>>+.>++.\")\n      KBD = 5\t\t\n      MSG = 6\t\t\n      STORE = CHAR(0)\t\n\n      CALL RUN(HELLOWORLD,STORE)\t\n\n      END\t\n", "target": "import java.io.IOException;\n\npublic class Interpreter {\n\n    public final static int MEMORY_SIZE = 65536;\n\n    private final char[] memory = new char[MEMORY_SIZE];\n    private int dp;\n    private int ip;\n    private int border;\n\n    private void reset() {\n\n        for (int i = 0; i < MEMORY_SIZE; i++) {\n            memory[i] = 0;\n        }\n        ip = 0;\n        dp = 0;\n    }\n\n    private void load(String program) {\n\n        if (program.length() > MEMORY_SIZE - 2) {\n            throw new RuntimeException(\"Not enough memory.\");\n        }\n\n        reset();\n\n        for (; dp < program.length(); dp++) {\n            memory[dp] = program.charAt(dp);\n        }\n\n        \n        \n        border = dp;\n\n        dp += 1;\n    }\n\n    public void execute(String program) {\n\n        load(program);\n        char instruction = memory[ip];\n\n        while (instruction != 0) {\n\n            switch (instruction) {\n                case '>':\n                    dp++;\n                    if (dp == MEMORY_SIZE) {\n                        throw new RuntimeException(\"Out of memory.\");\n                    }\n                    break;\n                case '<':\n                    dp--;\n                    if (dp == border) {\n                        throw new RuntimeException(\"Invalid data pointer.\");\n                    }\n                    break;\n                case '+':\n                    memory[dp]++;\n                    break;\n                case '-':\n                    memory[dp]--;\n                    break;\n                case '.':\n                    System.out.print(memory[dp]);\n                    break;\n                case ',':\n                    try {\n                        \n                        memory[dp] = (char) System.in.read();\n                    } catch (IOException e) {\n                        throw new RuntimeException(e);\n                    }\n                    break;\n                case '[':\n                    if (memory[dp] == 0) {\n                        skipLoop();\n                    }\n                    break;\n                case ']':\n                    if (memory[dp] != 0) {\n                        loop();\n                    }\n                    break;\n                default:\n                    throw new RuntimeException(\"Unknown instruction.\");\n            }\n\n            instruction = memory[++ip];\n        }\n    }\n\n    private void skipLoop() {\n\n        int loopCount = 0;\n\n        while (memory[ip] != 0) {\n            if (memory[ip] == '[') {\n                loopCount++;\n            } else if (memory[ip] == ']') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip++;\n        }\n\n        if (memory[ip] == 0) {\n            throw new RuntimeException(\"Unable to find a matching ']'.\");\n        }\n    }\n\n    private void loop() {\n\n        int loopCount = 0;\n\n        while (ip >= 0) {\n            if (memory[ip] == ']') {\n                loopCount++;\n            } else if (memory[ip] == '[') {\n                loopCount--;\n                if (loopCount == 0) {\n                    return;\n                }\n            }\n            ip--;\n        }\n\n        if (ip == -1) {\n            throw new RuntimeException(\"Unable to find a matching '['.\");\n        }\n    }\n\n    public static void main(String[] args) {\n\n        Interpreter interpreter = new Interpreter();\n        interpreter.execute(\">++++++++[-<+++++++++>]<.>>+>-[+]++>++>+++[>[->+++<<+++>]<<]>-----.>->+++..+++.>-.<<+[>[+>+]>>]<--------------.>>.+++.------.--------.>+.>+.\");\n    }\n}\n"}
{"id": 388680, "name": "Mertens function", "source": "Translate Fortran to Java:       program Mertens\n      implicit none\n      integer M(1000), n, k, zero, cross\n       \nC     Generate Mertens numbers       \n      M(1) = 1\n      do 10 n=2, 1000\n          M(n) = 1\n          do 10 k=2, n\n              M(n) = M(n) - M(n/k)\n 10   continue \n\nC     Print table\n      write (*,\"('The first 99 Mertens numbers are:')\")\n      write (*,\"('   ')\",advance='no')\n      k = 9\n      do 20 n=1, 99\n          write (*,'(I3)',advance='no') M(n)\n          k = k-1\n          if (k .EQ. 0) then\n              k=10\n              write (*,*)\n          end if\n 20   continue\n \nC     Calculate zeroes and crossings\n      zero = 0\n      cross = 0\n      do 30 n=2, 1000\n          if (M(n) .EQ. 0) then\n              zero = zero + 1\n              if (M(n-1) .NE. 0) cross = cross+1\n          end if    \n 30   continue \n \n 40   format(\"M(N) is zero \",I2,\" times.\")\n      write (*,40) zero\n 50   format(\"M(N) crosses zero \",I2,\" times.\")\n      write (*,50) cross\n      end program\n", "target": "public class MertensFunction {\n\n    public static void main(String[] args) {\n        System.out.printf(\"First 199 terms of the merten function are as follows:%n    \");\n        for ( int n = 1 ; n < 200 ; n++ ) {\n            System.out.printf(\"%2d  \", mertenFunction(n));\n            if ( (n+1) % 20 == 0 ) {\n                System.out.printf(\"%n\");\n            }\n        }\n        \n        for ( int exponent = 3 ; exponent<= 8 ; exponent++ ) {\n            int zeroCount = 0;\n            int zeroCrossingCount = 0;\n            int positiveCount = 0;\n            int negativeCount = 0;\n            int mSum = 0;\n            int mMin = Integer.MAX_VALUE;\n            int mMinIndex = 0;\n            int mMax = Integer.MIN_VALUE;\n            int mMaxIndex = 0;\n            int nMax = (int) Math.pow(10, exponent);\n            for ( int n = 1 ; n <= nMax ; n++ ) {\n                int m = mertenFunction(n);\n                mSum += m;\n                if ( m < mMin ) {\n                    mMin = m;\n                    mMinIndex = n;\n                }\n                if ( m > mMax ) {\n                    mMax = m;\n                    mMaxIndex = n;\n                }\n                if ( m > 0 ) {\n                    positiveCount++;\n                }\n                if ( m < 0 ) {\n                    negativeCount++;\n                }\n                if ( m == 0 ) {\n                    zeroCount++;\n                }\n                if ( m == 0 && mertenFunction(n - 1) != 0 ) {\n                    zeroCrossingCount++;\n                }\n            }\n            System.out.printf(\"%nFor M(x) with x from 1 to\u00a0%,d%n\", nMax);        \n            System.out.printf(\"The maximum of M(x) is M(%,d) =\u00a0%,d.%n\", mMaxIndex, mMax);\n            System.out.printf(\"The minimum of M(x) is M(%,d) =\u00a0%,d.%n\", mMinIndex, mMin);\n            System.out.printf(\"The sum of M(x) is\u00a0%,d.%n\", mSum);\n            System.out.printf(\"The count of positive M(x) is\u00a0%,d, count of negative M(x) is\u00a0%,d.%n\", positiveCount, negativeCount);\n            System.out.printf(\"M(x) has\u00a0%,d zeroes in the interval.%n\", zeroCount);\n            System.out.printf(\"M(x) has\u00a0%,d crossings in the interval.%n\", zeroCrossingCount);\n        }\n    }\n    \n    private static int MU_MAX = 100_000_000;\n    private static int[] MU = null;\n    private static int[] MERTEN = null;\n        \n    \n    private static int mertenFunction(int n) {\n        if ( MERTEN != null ) {\n            return MERTEN[n];\n        }\n        \n        \n        MU = new int[MU_MAX+1];\n        MERTEN = new int[MU_MAX+1];\n        MERTEN[1] = 1;\n        int sqrt = (int) Math.sqrt(MU_MAX);\n        for ( int i = 0 ; i < MU_MAX ; i++ ) {\n            MU[i] = 1;\n        }\n        \n        for ( int i = 2 ; i <= sqrt ; i++ ) {\n            if ( MU[i] == 1 ) {\n                \n                for ( int j = i ; j <= MU_MAX ; j += i ) {\n                    MU[j] *= -i;\n                }\n                \n                for ( int j = i*i ; j <= MU_MAX ; j += i*i ) {\n                    MU[j] = 0;\n                }\n            }\n        }\n        \n        int sum = 1;\n        for ( int i = 2 ; i <= MU_MAX ; i++ ) {\n            if ( MU[i] == i ) {\n                MU[i] = 1;\n            }\n            else if ( MU[i] == -i ) {\n                MU[i] = -1;\n            }\n            else if ( MU[i] < 0 ) {\n                MU[i] = 1;               \n            }\n            else if ( MU[i] > 0 ) {\n                MU[i] = -1;\n            }\n            sum += MU[i];\n            MERTEN[i] = sum;\n        }\n        return MERTEN[n];\n    }\n\n}\n"}
{"id": 388681, "name": "Product of divisors", "source": "Translate Fortran to Java:        program divprod\n       implicit none\n       integer divis(50), i, j\n       do 10 i=1, 50\n 10        divis(i) = 1\n       do 20 i=1, 50\n           do 20 j=i, 50, i\n 20            divis(j) = divis(j)*i\n       do 30 i=1, 50\n           write (*,'(I10)',advance='no') divis(i)\n 30        if (i/5 .ne. (i-1)/5) write (*,*)            \n       end program\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388682, "name": "Product of divisors", "source": "Translate Fortran to Java:        program divprod\n       implicit none\n       integer divis(50), i, j\n       do 10 i=1, 50\n 10        divis(i) = 1\n       do 20 i=1, 50\n           do 20 j=i, 50, i\n 20            divis(j) = divis(j)*i\n       do 30 i=1, 50\n           write (*,'(I10)',advance='no') divis(i)\n 30        if (i/5 .ne. (i-1)/5) write (*,*)            \n       end program\n", "target": "public class ProductOfDivisors {\n    private static long divisorCount(long n) {\n        long total = 1;\n        \n        for (; (n & 1) == 0; n >>= 1) {\n            ++total;\n        }\n        \n        for (long p = 3; p * p <= n; p += 2) {\n            long count = 1;\n            for (; n % p == 0; n /= p) {\n                ++count;\n            }\n            total *= count;\n        }\n        \n        if (n > 1) {\n            total *= 2;\n        }\n        return total;\n    }\n\n    private static long divisorProduct(long n) {\n        return (long) Math.pow(n, divisorCount(n) / 2.0);\n    }\n\n    public static void main(String[] args) {\n        final long limit = 50;\n        System.out.printf(\"Product of divisors for the first %d positive integers:%n\", limit);\n        for (long n = 1; n <= limit; n++) {\n            System.out.printf(\"%11d\", divisorProduct(n));\n            if (n % 5 == 0) {\n                System.out.println();\n            }\n        }\n    }\n}\n"}
{"id": 388683, "name": "Playing cards", "source": "Translate Fortran to Java: MODULE Cards\n\nIMPLICIT NONE\n\n  TYPE Card\n    CHARACTER(5) :: value\n    CHARACTER(8) :: suit\n  END TYPE Card\n\n  TYPE(Card) :: deck(52), hand(52)\n  TYPE(Card) :: temp\n\n  CHARACTER(5) :: pip(13) = (/\"Two  \", \"Three\", \"Four \", \"Five \", \"Six  \", \"Seven\", \"Eight\", \"Nine \", \"Ten  \", &\n                              \"Jack \", \"Queen\", \"King \", \"Ace  \"/)\n  CHARACTER(8) :: suits(4) = (/\"Clubs   \", \"Diamonds\", \"Hearts  \", \"Spades  \"/)\n  INTEGER :: i, j, n, rand, dealt = 0\n  REAL :: x\n\nCONTAINS\n \n  SUBROUTINE Init_deck\n  \n    DO i = 1, 4\n      DO j = 1, 13\n        deck((i-1)*13+j) = Card(pip(j), suits(i))\n      END DO\n    END DO\n  END SUBROUTINE Init_deck\n \n  SUBROUTINE Shuffle_deck\n  \n    DO i = 52-dealt, 1, -1\n      CALL RANDOM_NUMBER(x)\n      rand = INT(x * i) + 1\n      temp = deck(rand)\n      deck(rand) = deck(i)\n      deck(i) = temp\n    END DO\n  END SUBROUTINE Shuffle_deck\n\n  SUBROUTINE Deal_hand(number)\n  \n    INTEGER :: number\n    DO i = 1, number\n      hand(i) = deck(dealt+1)\n      dealt = dealt + 1\n    END DO\n  END SUBROUTINE\n\n  SUBROUTINE Print_hand\n  \n    DO i = 1, dealt\n      WRITE (*, \"(3A)\") TRIM(deck(i)%value), \" of \", TRIM(deck(i)%suit)\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Print_hand\n \n  SUBROUTINE Print_deck\n  \n    DO i = dealt+1, 52\n      WRITE (*, \"(3A)\") TRIM(deck(i)%value), \" of \", TRIM(deck(i)%suit)\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Print_deck\n\nEND MODULE Cards\n", "target": "public enum Pip { Two, Three, Four, Five, Six, Seven, \n    Eight, Nine, Ten, Jack, Queen, King, Ace }\n"}
{"id": 388684, "name": "Two sum", "source": "Translate Fortran to Java: program twosum\n  implicit none\n\n  integer, parameter, dimension(5) :: list = (/ 0, 2, 11, 19, 90/)\n  integer, parameter :: target_val = 21\n  integer :: nelem\n  integer :: i, j\n  logical :: success = .false.\n\n  nelem = size(list)\n  outer:do i = 1,nelem\n     do j = i+1,nelem\n        success = list(i) + list(j) == target_val\n        if (success) exit outer\n     end do\n  end do outer\n\n  if (success) then\n     \n     print('(\"(\",2(i3.1,1X),\")\",3(A1,i3.1))'), i,j, \":\", list(i), \"+\", list(j), \"=\", target_val\n  else\n     print*, \"Failed\"\n  end if\n\nend program twosum\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 388685, "name": "Two sum", "source": "Translate Fortran to Java: program twosum\n  implicit none\n\n  integer, parameter, dimension(5) :: list = (/ 0, 2, 11, 19, 90/)\n  integer, parameter :: target_val = 21\n  integer :: nelem\n  integer :: i, j\n  logical :: success = .false.\n\n  nelem = size(list)\n  outer:do i = 1,nelem\n     do j = i+1,nelem\n        success = list(i) + list(j) == target_val\n        if (success) exit outer\n     end do\n  end do outer\n\n  if (success) then\n     \n     print('(\"(\",2(i3.1,1X),\")\",3(A1,i3.1))'), i,j, \":\", list(i), \"+\", list(j), \"=\", target_val\n  else\n     print*, \"Failed\"\n  end if\n\nend program twosum\n", "target": "import java.util.Arrays;\n\npublic class TwoSum {\n\n    public static void main(String[] args) {\n        long sum = 21;\n        int[] arr = {0, 2, 11, 19, 90};\n\n        System.out.println(Arrays.toString(twoSum(arr, sum)));\n    }\n\n    public static int[] twoSum(int[] a, long target) {\n        int i = 0, j = a.length - 1;\n        while (i < j) {\n            long sum = a[i] + a[j];\n            if (sum == target)\n                return new int[]{i, j};\n            if (sum < target) i++;\n            else j--;\n        }\n        return null;\n    }\n}\n"}
{"id": 388686, "name": "Find the last Sunday of each month", "source": "Translate Fortran to Java:       D = DAYNUM(Y,M,D)    \n      DAYNUM(Y,M,D) = D    \n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 388687, "name": "Find the last Sunday of each month", "source": "Translate Fortran to Java:       D = DAYNUM(Y,M,D)    \n      DAYNUM(Y,M,D) = D    \n", "target": "import java.util.Scanner;\n\npublic class LastSunday \n{\n\tstatic final String[] months={\"January\",\"February\",\"March\",\"April\",\"May\",\"June\",\"July\",\"August\",\"September\",\"October\",\"November\",\"December\"};\n\t\n\tpublic static int[] findLastSunday(int year)\n\t{\n\t\tboolean isLeap = isLeapYear(year);\n\t\t\n\t\tint[] days={31,isLeap?29:28,31,30,31,30,31,31,30,31,30,31};\n\t\tint[] lastDay=new int[12];\n\t\t\n\t\tfor(int m=0;i<12;i++)\n\t\t{\n\t\t\tint d;\n\t\t\tfor(d=days[m]; getWeekDay(year,m,d)!=0; d--)\n\t\t\t\t;\n\t\t\tlastDay[m]=d;\n\t\t}\n\t\t\n\t\treturn lastDay;\n\t}\n\t\n\tprivate static boolean isLeapYear(int year)\n\t{\n\t\tif(year%4==0)\n\t\t{\n\t\t\tif(year%100!=0)\n\t\t\t\treturn true;\n\t\t\telse if (year%400==0)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\t\n\tprivate static int getWeekDay(int y, int m, int d)\n\t{\n\t\tint f=y+d+3*m-1;\n\t\tm++;\n\t\t\n\t\tif(m<3)\n\t\t\ty--;\n\t\telse\n\t\t\tf-=(int)(0.4*m+2.3);\n\t\t\n\t\tf+=(int)(y/4)-(int)((y/100+1)*0.75);\n\t\tf%=7;\n\t\t\n\t\treturn f;\n\t}\n\t\n\tprivate static void display(int year, int[] lastDay)\n\t{\n\t\tSystem.out.println(\"\\nYEAR: \"+year);\n\t\tfor(int m=0;i<12;i++)\n\t\t\tSystem.out.println(months[m]+\": \"+lastDay[m]);\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tSystem.out.print(\"Enter year: \");\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tint y=Integer.parseInt(s.next());\n\t\t\n\t\tint[] lastDay = findLastSunday(y);\n\t\tdisplay(y, lastDay);\n\t\t\n\t\ts.close();\n\t}\n}\n"}
{"id": 388688, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Fortran to Java: \nmodule circlesort\n\n\n\n\n\n\n  implicit none\n  logical, private :: csr\n  public :: circle_sort\n \ncontains\n \n  recursive logical function csr(a, left, right,n) result(swapped)\n    implicit none\n    integer, intent(in) :: left, right,n\n    integer, intent(inout) :: a(n)\n    integer :: lo, hi, mid\n    integer :: temp\n    logical :: lefthalf,righthalf\n\n    swapped = .FALSE.\n    if (right <= left) return\n    lo = left   \n    hi = right  \n\n    do while (lo < hi)\n\n       if (a(hi) < a(lo)) then\n          swapped = .TRUE.\n          temp = a(lo)\n          a(lo) = a(hi)\n          a(hi) = temp\n       endif\n       lo = lo + 1\n       hi = hi - 1\n    end do\n\n    if (lo == hi)then\n       if(a(hi+1) .lt. a(lo))then\n           swapped = .TRUE.\n           temp = a(hi+1)\n           a(hi+1) = a(lo)\n           a(lo) = temp\n       endif\n    endif\n    mid = (left + right) / 2 \n    lefthalf = csr(a, left, mid,n)\n    righthalf = csr(a, mid + 1, right,n)\n    swapped = swapped .or. lefthalf .or. righthalf\n  end function csr\n\n  subroutine circle_sort(a, n)\n    use iso_c_binding, only: c_ptr, c_loc\n    implicit none\n    integer, intent(in) :: n\n    integer, target,intent(inout) :: a(n)\n\n    do while ( csr(a, 1, n,n))\n\n\n\n    end do\n  end subroutine circle_sort\n \nend module circlesort\nprogram sort\n  use circlesort\n  implicit none\n  integer :: a(9)\n  data a/6,7,8,9,2,5,3,4,1/\n  call circle_sort(a, size(a))\n  print *, a\nend program sort\n", "target": "import java.util.Arrays;\n\npublic class CircleSort {\n\n    public static void main(String[] args) {\n        circleSort(new int[]{2, 14, 4, 6, 8, 1, 3, 5, 7, 11, 0, 13, 12, -1});\n    }\n\n    public static void circleSort(int[] arr) {\n        if (arr.length > 0)\n            do {\n                System.out.println(Arrays.toString(arr));\n            } while (circleSortR(arr, 0, arr.length - 1, 0) != 0);\n    }\n\n    private static int circleSortR(int[] arr, int lo, int hi, int numSwaps) {\n        if (lo == hi)\n            return numSwaps;\n\n        int high = hi;\n        int low = lo;\n        int mid = (hi - lo) / 2;\n\n        while (lo < hi) {\n            if (arr[lo] > arr[hi]) {\n                swap(arr, lo, hi);\n                numSwaps++;\n            }\n            lo++;\n            hi--;\n        }\n\n        if (lo == hi && arr[lo] > arr[hi + 1]) {\n            swap(arr, lo, hi + 1);\n            numSwaps++;\n        }\n\n        numSwaps = circleSortR(arr, low, low + mid, numSwaps);\n        numSwaps = circleSortR(arr, low + mid + 1, high, numSwaps);\n\n        return numSwaps;\n    }\n\n    private static void swap(int[] arr, int idx1, int idx2) {\n        int tmp = arr[idx1];\n        arr[idx1] = arr[idx2];\n        arr[idx2] = tmp;\n    }\n}\n"}
{"id": 388689, "name": "Circles of given radius through two points", "source": "Translate Fortran to Java: \n\nprogram circles\nimplicit none\ndouble precision :: P1(2), P2(2), R\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0,0.2345d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.0d0, 2.0d0/)\nP2 = (/0.0d0,0.0d0/)\nR = 1.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0, 0.2345d0/)\nR = 0.5d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 0.0d0\ncall print_centers(P1,P2,R)\nend program circles\n\nsubroutine print_centers(P1,P2,R)\nimplicit none\ndouble precision :: P1(2), P2(2), R, Center(2,2)\ninteger :: Res\ncall test_inputs(P1,P2,R,Res)\nwrite(*,*)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point1 \u00a0: ', P1(1), ' ', P1(2)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point2 \u00a0: ', P2(1), ' ', P2(2)\nwrite(*,'(A10,F7.4)') 'Radius \u00a0: ', R\nif(Res.eq.1) then\n  write(*,*) 'Same point because P1=P2 and r=0.'\nelseif(Res.eq.2) then\n  write(*,*) 'No circles can be drawn because r=0.'\nelseif(Res.eq.3) then\n  write(*,*) 'Infinite circles because P1=P2 for non-zero radius.'\nelseif(Res.eq.4) then\n  write(*,*) 'No circles with given r can be drawn because points are far apart.'\nelseif(Res.eq.0) then\n  call find_center(P1,P2,R,Center)\n  if(Center(1,1).eq.Center(2,1) .and. Center(1,2).eq.Center(2,2)) then\n    write(*,*) 'Points lie on the diameter. A single circle can be drawn.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center \u00a0: ', Center(1,1), ' ', Center(1,2)\n  else\n    write(*,*) 'Two distinct circles found.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center1\u00a0: ', Center(1,1), ' ', Center(1,2)\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center2\u00a0: ', Center(2,1), ' ', Center(2,2)\n  end if\nelseif(Res.lt.0) then\n  write(*,*) 'Incorrect value for r.'\nend if\nwrite(*,*)\nend subroutine print_centers\n\nsubroutine test_inputs(P1,P2,R,Res)\nimplicit none\ndouble precision :: P1(2), P2(2), R, dist\ninteger :: Res\nif(R.lt.0.0d0) then\n  Res = -1\n  return\nelseif(R.eq.0.0d0 .and. P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 1\n  return\nelseif(R.eq.0.0d0) then\n  Res = 2\n  return\nelseif(P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 3\n  return\nelse\n  dist = sqrt( (P1(1)-P2(1))**2 + (P1(2)-P2(2))**2 )\n  if(dist.gt.2.0d0*R) then\n    Res = 4\n    return\n  else\n    Res = 0\n    return\n  end if\nend if\nend subroutine test_inputs\n\nsubroutine find_center(P1,P2,R,Center)\nimplicit none\ndouble precision :: P1(2), P2(2), MP(2), Center(2,2), R, dm, dd\nMP = (P1 + P2)/2.0d0\ndm = sqrt((P1(1) - P2(1))**2 + (P1(2) - P2(2))**2)\ndd = sqrt(R**2 - (dm/2.0d0)**2)\nCenter(1,1) = MP(1) - dd*(P2(2) - P1(2))/dm\nCenter(1,2) = MP(2) + dd*(P2(1) - P1(1))/dm\n\nCenter(2,1) = MP(1) + dd*(P2(2) - P1(2))/dm\nCenter(2,2) = MP(2) - dd*(P2(1) - P1(1))/dm\nend subroutine find_center\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 388690, "name": "Circles of given radius through two points", "source": "Translate Fortran to Java: \n\nprogram circles\nimplicit none\ndouble precision :: P1(2), P2(2), R\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0,0.2345d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.0d0, 2.0d0/)\nP2 = (/0.0d0,0.0d0/)\nR = 1.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0, 0.2345d0/)\nR = 0.5d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 0.0d0\ncall print_centers(P1,P2,R)\nend program circles\n\nsubroutine print_centers(P1,P2,R)\nimplicit none\ndouble precision :: P1(2), P2(2), R, Center(2,2)\ninteger :: Res\ncall test_inputs(P1,P2,R,Res)\nwrite(*,*)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point1 \u00a0: ', P1(1), ' ', P1(2)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point2 \u00a0: ', P2(1), ' ', P2(2)\nwrite(*,'(A10,F7.4)') 'Radius \u00a0: ', R\nif(Res.eq.1) then\n  write(*,*) 'Same point because P1=P2 and r=0.'\nelseif(Res.eq.2) then\n  write(*,*) 'No circles can be drawn because r=0.'\nelseif(Res.eq.3) then\n  write(*,*) 'Infinite circles because P1=P2 for non-zero radius.'\nelseif(Res.eq.4) then\n  write(*,*) 'No circles with given r can be drawn because points are far apart.'\nelseif(Res.eq.0) then\n  call find_center(P1,P2,R,Center)\n  if(Center(1,1).eq.Center(2,1) .and. Center(1,2).eq.Center(2,2)) then\n    write(*,*) 'Points lie on the diameter. A single circle can be drawn.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center \u00a0: ', Center(1,1), ' ', Center(1,2)\n  else\n    write(*,*) 'Two distinct circles found.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center1\u00a0: ', Center(1,1), ' ', Center(1,2)\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center2\u00a0: ', Center(2,1), ' ', Center(2,2)\n  end if\nelseif(Res.lt.0) then\n  write(*,*) 'Incorrect value for r.'\nend if\nwrite(*,*)\nend subroutine print_centers\n\nsubroutine test_inputs(P1,P2,R,Res)\nimplicit none\ndouble precision :: P1(2), P2(2), R, dist\ninteger :: Res\nif(R.lt.0.0d0) then\n  Res = -1\n  return\nelseif(R.eq.0.0d0 .and. P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 1\n  return\nelseif(R.eq.0.0d0) then\n  Res = 2\n  return\nelseif(P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 3\n  return\nelse\n  dist = sqrt( (P1(1)-P2(1))**2 + (P1(2)-P2(2))**2 )\n  if(dist.gt.2.0d0*R) then\n    Res = 4\n    return\n  else\n    Res = 0\n    return\n  end if\nend if\nend subroutine test_inputs\n\nsubroutine find_center(P1,P2,R,Center)\nimplicit none\ndouble precision :: P1(2), P2(2), MP(2), Center(2,2), R, dm, dd\nMP = (P1 + P2)/2.0d0\ndm = sqrt((P1(1) - P2(1))**2 + (P1(2) - P2(2))**2)\ndd = sqrt(R**2 - (dm/2.0d0)**2)\nCenter(1,1) = MP(1) - dd*(P2(2) - P1(2))/dm\nCenter(1,2) = MP(2) + dd*(P2(1) - P1(1))/dm\n\nCenter(2,1) = MP(1) + dd*(P2(2) - P1(2))/dm\nCenter(2,2) = MP(2) - dd*(P2(1) - P1(1))/dm\nend subroutine find_center\n", "target": "import java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n"}
{"id": 388691, "name": "Update a configuration file", "source": "Translate Fortran to Java:       PROGRAM TEST\t\n      CHARACTER*28 FAVOURITEFRUIT\n      LOGICAL NEEDSPEELING\n      LOGICAL SEEDSREMOVED\n      INTEGER NUMBEROFBANANAS\n      NAMELIST /FRUIT/ FAVOURITEFRUIT,NEEDSPEELING,SEEDSREMOVED,\n     1 NUMBEROFBANANAS\n      INTEGER F\t\n      F = 10\t\n\nCreate an example file to show its format.\n      OPEN(F,FILE=\"Basket.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\t\n     1 DELIM=\"QUOTE\")\t\n      FAVOURITEFRUIT = \"Banana\"\n      NEEDSPEELING = .TRUE.\n      SEEDSREMOVED = .FALSE.\n      NUMBEROFBANANAS = 48\n      WRITE (F,FRUIT)\t\t\n      CLOSE (F)\t\t\t\nCan now read from the file.\n      OPEN(F,FILE=\"Basket.txt\",STATUS=\"OLD\",ACTION=\"READ\",\t\n     1 DELIM=\"QUOTE\")\n      READ (F,FRUIT)\t\t\t\n      WRITE (6,FRUIT)\n      END\n", "target": "import java.io.*;\nimport java.util.*;\nimport java.util.regex.*;\n\npublic class UpdateConfig {\n\n    public static void main(String[] args) {\n        if (args[0] == null) {\n            System.out.println(\"filename required\");\n\n        } else if (readConfig(args[0])) {\n            enableOption(\"seedsremoved\");\n            disableOption(\"needspeeling\");\n            setOption(\"numberofbananas\", \"1024\");\n            addOption(\"numberofstrawberries\", \"62000\");\n            store();\n        }\n    }\n\n    private enum EntryType {\n        EMPTY, ENABLED, DISABLED, COMMENT\n    }\n\n    private static class Entry {\n        EntryType type;\n        String name, value;\n\n        Entry(EntryType t, String n, String v) {\n            type = t;\n            name = n;\n            value = v;\n        }\n    }\n\n    private static Map<String, Entry> entries = new LinkedHashMap<>();\n    private static String path;\n\n    private static boolean readConfig(String p) {\n        path = p;\n\n        File f = new File(path);\n        if (!f.exists() || f.isDirectory())\n            return false;\n\n        String regexString = \"^(;*)\\\\s*([A-Za-z0-9]+)\\\\s*([A-Za-z0-9]*)\";\n        Pattern regex = Pattern.compile(regexString);\n\n        try (Scanner sc = new Scanner(new FileReader(f))){\n            int emptyLines = 0;\n            String line;\n            while (sc.hasNext()) {\n                line = sc.nextLine().trim();\n\n                if (line.isEmpty()) {\n                    addOption(\"\" + emptyLines++, null, EntryType.EMPTY);\n\n                } else if (line.charAt(0) == '#') {\n                    entries.put(line, new Entry(EntryType.COMMENT, line, null));\n\n                } else {\n                    line = line.replaceAll(\"[^a-zA-Z0-9\\\\x20;]\", \"\");\n                    Matcher m = regex.matcher(line);\n\n                    if (m.find() && !m.group(2).isEmpty()) {\n\n                        EntryType t = EntryType.ENABLED;\n                        if (!m.group(1).isEmpty())\n                            t = EntryType.DISABLED;\n\n                        addOption(m.group(2), m.group(3), t);\n                    }\n                }\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n        return true;\n    }\n\n    private static void addOption(String name, String value) {\n        addOption(name, value, EntryType.ENABLED);\n    }\n\n    private static void addOption(String name, String value, EntryType t) {\n        name = name.toUpperCase();\n        entries.put(name, new Entry(t, name, value));\n    }\n\n    private static void enableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.ENABLED;\n    }\n\n    private static void disableOption(String name) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.type = EntryType.DISABLED;\n    }\n\n    private static void setOption(String name, String value) {\n        Entry e = entries.get(name.toUpperCase());\n        if (e != null)\n            e.value = value;\n    }\n\n    private static void store() {\n        try (PrintWriter pw = new PrintWriter(path)) {\n            for (Entry e : entries.values()) {\n                switch (e.type) {\n                    case EMPTY:\n                        pw.println();\n                        break;\n                    case ENABLED:\n                        pw.format(\"%s %s%n\", e.name, e.value);\n                        break;\n                    case DISABLED:\n                        pw.format(\"; %s %s%n\", e.name, e.value);\n                        break;\n                    case COMMENT:\n                        pw.println(e.name);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (pw.checkError()) {\n                throw new IOException(\"writing to file failed\");\n            }\n        } catch (IOException e) {\n            System.out.println(e);\n        }\n    }\n}\n"}
{"id": 388692, "name": "I before E except after C", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram cia\n  implicit none\n  character (len=256) :: s\n  integer :: ie, ei, cie, cei\n  integer :: ios\n  data ie, ei, cie, cei/4*0/\n  do while (.true.)\n    read(5,*,iostat = ios)s\n    if (0 .ne. ios) then\n      exit\n    endif\n    call lower_case(s)\n    cie = cie + occurrences(s, 'cie')\n    cei = cei + occurrences(s, 'cei')\n    ie = ie + occurrences(s, 'ie')\n    ei = ei + occurrences(s, 'ei')\n  enddo\n  write(6,'(1x,4(a4,1x))') 'ie','ei','cie','cei'\n  write(6,'(1x,4(i4,1x))') ie,ei,cie,cei \n  write(6,'(1x,2(a,1x))') '        [^c]ie',plausibility(ie,ei)\n  write(6,'(1x,2(a,1x))') '           cei',plausibility(cei,cie)\n  write(6,'(1x,2(a,1x))') '([^c]ie)|(cei)',plausibility(ie+cei,ei+cie)\n\ncontains\n\n  subroutine lower_case(s)\n    character(len=*), intent(inout) :: s\n    integer :: i\n    do i=1, len_trim(s)\n      s(i:i) = achar(ior(iachar(s(i:i)),32))\n    enddo\n  end subroutine lower_case\n\n  integer function occurrences(a,b)\n    character(len=*), intent(in) :: a, b\n    integer :: i, j, n\n    n = 0\n    i = 0\n    j = index(a, b)\n    do while (0 .lt. j)\n      n = n+1\n      i = i+len(b)+j-1\n      j = index(a(i:), b)\n    end do\n    occurrences = n\n  end function occurrences\n\n  character*(32) function plausibility(da, nyet)\n    integer, intent(in) :: da, nyet\n    \n    if (nyet*2 .lt. da) then\n      plausibility = 'plausible'\n    else\n      plausibility = 'implausible'\n    endif\n  end function plausibility\nend program cia\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 388693, "name": "I before E except after C", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram cia\n  implicit none\n  character (len=256) :: s\n  integer :: ie, ei, cie, cei\n  integer :: ios\n  data ie, ei, cie, cei/4*0/\n  do while (.true.)\n    read(5,*,iostat = ios)s\n    if (0 .ne. ios) then\n      exit\n    endif\n    call lower_case(s)\n    cie = cie + occurrences(s, 'cie')\n    cei = cei + occurrences(s, 'cei')\n    ie = ie + occurrences(s, 'ie')\n    ei = ei + occurrences(s, 'ei')\n  enddo\n  write(6,'(1x,4(a4,1x))') 'ie','ei','cie','cei'\n  write(6,'(1x,4(i4,1x))') ie,ei,cie,cei \n  write(6,'(1x,2(a,1x))') '        [^c]ie',plausibility(ie,ei)\n  write(6,'(1x,2(a,1x))') '           cei',plausibility(cei,cie)\n  write(6,'(1x,2(a,1x))') '([^c]ie)|(cei)',plausibility(ie+cei,ei+cie)\n\ncontains\n\n  subroutine lower_case(s)\n    character(len=*), intent(inout) :: s\n    integer :: i\n    do i=1, len_trim(s)\n      s(i:i) = achar(ior(iachar(s(i:i)),32))\n    enddo\n  end subroutine lower_case\n\n  integer function occurrences(a,b)\n    character(len=*), intent(in) :: a, b\n    integer :: i, j, n\n    n = 0\n    i = 0\n    j = index(a, b)\n    do while (0 .lt. j)\n      n = n+1\n      i = i+len(b)+j-1\n      j = index(a(i:), b)\n    end do\n    occurrences = n\n  end function occurrences\n\n  character*(32) function plausibility(da, nyet)\n    integer, intent(in) :: da, nyet\n    \n    if (nyet*2 .lt. da) then\n      plausibility = 'plausible'\n    else\n      plausibility = 'implausible'\n    endif\n  end function plausibility\nend program cia\n", "target": "import java.io.BufferedReader;\nimport java.io.FileReader;\n\npublic class IbeforeE \n{\n\tpublic static void main(String[] args)\n\t{\n\t\tIbeforeE now=new IbeforeE();\n\t\tString wordlist=\"unixdict.txt\";\n\t\tif(now.isPlausibleRule(wordlist))\n\t\t\tSystem.out.println(\"Rule is plausible.\");\n\t\telse\n\t\t\tSystem.out.println(\"Rule is not plausible.\");\n\t}\n\tboolean isPlausibleRule(String filename)\n\t{\n\t\tint truecount=0,falsecount=0;\n\t\ttry\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new FileReader(filename));\n\t\t\tString word;\n\t\t\twhile((word=br.readLine())!=null)\n\t\t\t{\n\t\t\t\tif(isPlausibleWord(word))\n\t\t\t\t\ttruecount++;\n\t\t\t\telse if(isOppPlausibleWord(word))\n\t\t\t\t\tfalsecount++;\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch(Exception e)\n\t\t{\n\t\t\tSystem.out.println(\"Something went horribly wrong: \"+e.getMessage());\n\t\t}\n\t\t\n\t\tSystem.out.println(\"Plausible count: \"+truecount);\n\t\tSystem.out.println(\"Implausible count: \"+falsecount);\n\t\tif(truecount>2*falsecount)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ie\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cei\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tboolean isOppPlausibleWord(String word)\n\t{\n\t\tif(!word.contains(\"c\")&&word.contains(\"ei\"))\n\t\t\treturn true;\n\t\telse if(word.contains(\"cie\"))\n\t\t\treturn true;\n\t\treturn false;\n\t}\n}\n"}
{"id": 388694, "name": "Abelian sandpile model", "source": "Translate Fortran to Java: module abelian_sandpile_m\n\n  implicit none\n\n  private\n  public :: pile\n\n  type :: pile\n    \n    \n    \n\n    integer, allocatable :: grid(:,:)\n    integer              :: n(2)\n\n  contains\n    procedure :: init\n    procedure :: run\n\n    procedure, private :: process_node\n    procedure, private :: inside\n  end type\n\ncontains\n\n  logical function inside(this, i)\n    class(pile), intent(in) :: this\n    integer,     intent(in) :: i(2)\n\n    inside = ((i(1) > 0) .and. (i(1) <= this%n(1)) .and. (i(2) > 0) .and. (i(2) <= this%n(2)) )\n  end function\n\n  recursive subroutine process_node(this, i)\n    \n\n    class(pile), intent(inout) :: this\n    integer,     intent(in)    :: i(2)\n      \n\n    integer :: i0(2,2), j(2), d, k\n\n    \n    if (this%grid(i(1),i(2)) >= 4) then\n      \n      i0 = reshape([1,0,0,1], [2,2])\n\n      \n      this%grid(i(1),i(2)) = this%grid(i(1),i(2))-4\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) this%grid(j(1),j(2)) = this%grid(j(1),j(2)) + 1\n        end do\n      end do\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) call this%process_node(j)\n        end do\n      end do\n\n      \n      call this%process_node(i)\n    end if\n  end subroutine\n\n  subroutine run(this)\n    \n\n    class(pile), intent(inout) :: this\n\n    \n    call this%process_node(this%n/2)\n  end subroutine\n\n  subroutine init(this, nx, ny, h)\n    class(pile), intent(out) :: this\n    integer,     intent(in)  :: nx, ny\n      \n    integer,     intent(in)  :: h\n      \n\n    this%n = [nx, ny]\n    allocate (this%grid(nx,ny), source=0)\n    this%grid(nx/2, ny/2) = h\n  end subroutine\n\nend module\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AbelianSandpile {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                Frame frame = new Frame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class Frame extends JFrame {\n        private Frame() {\n            super(\"Abelian Sandpile Model\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            Container contentPane = getContentPane();\n            JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n            JButton start = new JButton(\"Restart Simulation\");\n            start.addActionListener(e -> restartSimulation());\n            JButton stop = new JButton(\"Stop Simulation\");\n            stop.addActionListener(e -> stopSimulation());\n            controlPanel.add(start);\n            controlPanel.add(stop);\n            contentPane.add(controlPanel, BorderLayout.NORTH);\n            contentPane.add(canvas = new Canvas(), BorderLayout.CENTER);\n            timer = new Timer(100, e -> canvas.runAndDraw());\n            timer.start();\n            pack();\n        }\n\n        private void restartSimulation() {\n            timer.stop();\n            canvas.initGrid();\n            timer.start();\n        }\n\n        private void stopSimulation() {\n            timer.stop();\n        }\n\n        private Timer timer;\n        private Canvas canvas;\n    }\n\n    private static class Canvas extends JComponent {\n        private Canvas() {\n            setBorder(BorderFactory.createEtchedBorder());\n            setPreferredSize(new Dimension(600, 600));\n        }\n\n        public void paintComponent(Graphics g) {\n            int width = getWidth();\n            int height = getHeight();\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, width, height);\n            int cellWidth = width/GRID_LENGTH;\n            int cellHeight = height/GRID_LENGTH;\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    if (grid[i][j] > 0) {\n                        g.setColor(COLORS[grid[i][j]]);\n                        g.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);\n                    }\n                }\n            }\n        }\n\n        private void initGrid() {\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    grid[i][j] = 0;\n                }\n            }\n        }\n\n        private void runAndDraw() {\n            for (int i = 0; i < 100; ++i)\n                addSand(GRID_LENGTH/2, GRID_LENGTH/2);\n            repaint();\n        }\n\n        private void addSand(int i, int j) {\n            int grains = grid[i][j];\n            if (grains < 3) {\n                grid[i][j]++;\n            }\n            else {\n                grid[i][j] = grains - 3;\n                if (i > 0)\n                    addSand(i - 1, j);\n                if (i < GRID_LENGTH - 1)\n                    addSand(i + 1, j);\n                if (j > 0)\n                    addSand(i, j - 1);\n                if (j < GRID_LENGTH - 1)\n                    addSand(i, j + 1);\n            }\n        }\n\n        private int[][] grid = new int[GRID_LENGTH][GRID_LENGTH];\n    }\n\n    private static final Color[] COLORS = {\n        Color.WHITE,\n        new Color(0x00, 0xbf, 0xff),\n        new Color(0xff, 0xd7, 0x00),\n        new Color(0xb0, 0x30, 0x60)\n    };\n    private static final int GRID_LENGTH = 300;\n}\n"}
{"id": 388695, "name": "Abelian sandpile model", "source": "Translate Fortran to Java: module abelian_sandpile_m\n\n  implicit none\n\n  private\n  public :: pile\n\n  type :: pile\n    \n    \n    \n\n    integer, allocatable :: grid(:,:)\n    integer              :: n(2)\n\n  contains\n    procedure :: init\n    procedure :: run\n\n    procedure, private :: process_node\n    procedure, private :: inside\n  end type\n\ncontains\n\n  logical function inside(this, i)\n    class(pile), intent(in) :: this\n    integer,     intent(in) :: i(2)\n\n    inside = ((i(1) > 0) .and. (i(1) <= this%n(1)) .and. (i(2) > 0) .and. (i(2) <= this%n(2)) )\n  end function\n\n  recursive subroutine process_node(this, i)\n    \n\n    class(pile), intent(inout) :: this\n    integer,     intent(in)    :: i(2)\n      \n\n    integer :: i0(2,2), j(2), d, k\n\n    \n    if (this%grid(i(1),i(2)) >= 4) then\n      \n      i0 = reshape([1,0,0,1], [2,2])\n\n      \n      this%grid(i(1),i(2)) = this%grid(i(1),i(2))-4\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) this%grid(j(1),j(2)) = this%grid(j(1),j(2)) + 1\n        end do\n      end do\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) call this%process_node(j)\n        end do\n      end do\n\n      \n      call this%process_node(i)\n    end if\n  end subroutine\n\n  subroutine run(this)\n    \n\n    class(pile), intent(inout) :: this\n\n    \n    call this%process_node(this%n/2)\n  end subroutine\n\n  subroutine init(this, nx, ny, h)\n    class(pile), intent(out) :: this\n    integer,     intent(in)  :: nx, ny\n      \n    integer,     intent(in)  :: h\n      \n\n    this%n = [nx, ny]\n    allocate (this%grid(nx,ny), source=0)\n    this%grid(nx/2, ny/2) = h\n  end subroutine\n\nend module\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport javax.swing.*;\n\npublic class AbelianSandpile {\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Runnable() {\n            public void run() {\n                Frame frame = new Frame();\n                frame.setVisible(true);\n            }\n        });\n    }\n\n    private static class Frame extends JFrame {\n        private Frame() {\n            super(\"Abelian Sandpile Model\");\n            setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            Container contentPane = getContentPane();\n            JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));\n            JButton start = new JButton(\"Restart Simulation\");\n            start.addActionListener(e -> restartSimulation());\n            JButton stop = new JButton(\"Stop Simulation\");\n            stop.addActionListener(e -> stopSimulation());\n            controlPanel.add(start);\n            controlPanel.add(stop);\n            contentPane.add(controlPanel, BorderLayout.NORTH);\n            contentPane.add(canvas = new Canvas(), BorderLayout.CENTER);\n            timer = new Timer(100, e -> canvas.runAndDraw());\n            timer.start();\n            pack();\n        }\n\n        private void restartSimulation() {\n            timer.stop();\n            canvas.initGrid();\n            timer.start();\n        }\n\n        private void stopSimulation() {\n            timer.stop();\n        }\n\n        private Timer timer;\n        private Canvas canvas;\n    }\n\n    private static class Canvas extends JComponent {\n        private Canvas() {\n            setBorder(BorderFactory.createEtchedBorder());\n            setPreferredSize(new Dimension(600, 600));\n        }\n\n        public void paintComponent(Graphics g) {\n            int width = getWidth();\n            int height = getHeight();\n            g.setColor(Color.WHITE);\n            g.fillRect(0, 0, width, height);\n            int cellWidth = width/GRID_LENGTH;\n            int cellHeight = height/GRID_LENGTH;\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    if (grid[i][j] > 0) {\n                        g.setColor(COLORS[grid[i][j]]);\n                        g.fillRect(i * cellWidth, j * cellHeight, cellWidth, cellHeight);\n                    }\n                }\n            }\n        }\n\n        private void initGrid() {\n            for (int i = 0; i < GRID_LENGTH; ++i) {\n                for (int j = 0; j < GRID_LENGTH; ++j) {\n                    grid[i][j] = 0;\n                }\n            }\n        }\n\n        private void runAndDraw() {\n            for (int i = 0; i < 100; ++i)\n                addSand(GRID_LENGTH/2, GRID_LENGTH/2);\n            repaint();\n        }\n\n        private void addSand(int i, int j) {\n            int grains = grid[i][j];\n            if (grains < 3) {\n                grid[i][j]++;\n            }\n            else {\n                grid[i][j] = grains - 3;\n                if (i > 0)\n                    addSand(i - 1, j);\n                if (i < GRID_LENGTH - 1)\n                    addSand(i + 1, j);\n                if (j > 0)\n                    addSand(i, j - 1);\n                if (j < GRID_LENGTH - 1)\n                    addSand(i, j + 1);\n            }\n        }\n\n        private int[][] grid = new int[GRID_LENGTH][GRID_LENGTH];\n    }\n\n    private static final Color[] COLORS = {\n        Color.WHITE,\n        new Color(0x00, 0xbf, 0xff),\n        new Color(0xff, 0xd7, 0x00),\n        new Color(0xb0, 0x30, 0x60)\n    };\n    private static final int GRID_LENGTH = 300;\n}\n"}
{"id": 388696, "name": "Four is magic", "source": "Translate Fortran to Java: MODULE FOUR_IS_MAGIC\n    IMPLICIT NONE\n    CHARACTER(8), DIMENSION(20) :: SMALL_NUMS\n    CHARACTER(7), DIMENSION(8) :: TENS\n    CHARACTER(7) :: HUNDRED\n    CHARACTER(8) :: THOUSAND\n    CHARACTER(8) :: MILLION\n    CHARACTER(8) :: BILLION\n    CHARACTER(9) :: TRILLION\n    CHARACTER(11) :: QUADRILLION\n    CHARACTER(11) :: QUINTILLION\n    CHARACTER(1) :: SEPARATOR\n    CHARACTER(1) :: SPACE\n\n\n    CONTAINS\n\n    SUBROUTINE INIT_ARRAYS\n\n        SMALL_NUMS(1) = \"zero\"\n        SMALL_NUMS(2) = \"one\"\n        SMALL_NUMS(3) = \"two\"\n        SMALL_NUMS(4) = \"three\"\n        SMALL_NUMS(5) = \"four\"\n        SMALL_NUMS(6) = \"five\"\n        SMALL_NUMS(7) = \"six\"\n        SMALL_NUMS(8) = \"seven\"\n        SMALL_NUMS(9) = \"eight\"\n        SMALL_NUMS(10) = \"nine\"\n        SMALL_NUMS(11) = \"ten\"\n        SMALL_NUMS(12) = \"eleven\"\n        SMALL_NUMS(13) = \"twelve\"\n        SMALL_NUMS(14) = \"thirteen\"\n        SMALL_NUMS(15) = \"fourteen\"\n        SMALL_NUMS(16) = \"fifteen\"\n        SMALL_NUMS(17) = \"sixteen\"\n        SMALL_NUMS(18) = \"seventeen\"\n        SMALL_NUMS(19) = \"eighteen\"\n        SMALL_NUMS(20) = \"nineteen\"\n\n        TENS(1) = \"twenty\"\n        TENS(2) = \"thirty\"\n        TENS(3) = \"forty\"\n        TENS(4) = \"fifty\"\n        TENS(5) = \"sixty\"\n        TENS(6) = \"seventy\"\n        TENS(7) = \"eight\"\n        TENS(8) = \"ninety\"\n\n        HUNDRED = \"hundred\"\n        THOUSAND = \"thousand\"\n        MILLION = \"million\"\n        BILLION = \"billion\"\n        TRILLION = \"trillion\"\n        QUADRILLION = \"quadrillion\"\n        QUINTILLION = \"quintillion\"\n        SEPARATOR = \"-\"\n        SPACE = \" \"\n\n    END SUBROUTINE INIT_ARRAYS\n\n    RECURSIVE FUNCTION STRING_REPRESENTATION(NUM) RESULT(NUM_AS_STR)\n        INTEGER(16), INTENT(IN) :: NUM\n        CHARACTER(1000) :: NUM_AS_STR\n        INTEGER(16), DIMENSION(9) :: COMPONENTS\n\n        CALL INIT_ARRAYS()\n\n        COMPONENTS = GET_COMPONENTS(NUM)\n\n        NUM_AS_STR = TRIM(ADJUSTL(GET_SUBSET(COMPONENTS(9), QUINTILLION)))\n        NUM_AS_STR = TRIM(NUM_AS_STR) // SPACE // TRIM(ADJUSTL(GET_SUBSET(COMPONENTS(8), QUADRILLION)))\n        NUM_AS_STR = TRIM(NUM_AS_STR) // SPACE // TRIM(ADJUSTL(GET_SUBSET(COMPONENTS(7), TRILLION)))\n        NUM_AS_STR = TRIM(NUM_AS_STR) // SPACE // TRIM(ADJUSTL(GET_SUBSET(COMPONENTS(6), BILLION)))\n        NUM_AS_STR = TRIM(NUM_AS_STR) // SPACE // TRIM(ADJUSTL(GET_SUBSET(COMPONENTS(5), MILLION)))\n        NUM_AS_STR = TRIM(NUM_AS_STR) // SPACE // TRIM(ADJUSTL(GET_SUBSET(COMPONENTS(4), THOUSAND)))\n        NUM_AS_STR = TRIM(NUM_AS_STR) // SPACE // TRIM(ADJUSTL(GET_SUBSET(COMPONENTS(3), HUNDRED)))\n\n\n        IF (COMPONENTS(2) .EQ. 1) THEN\n            NUM_AS_STR = TRIM(ADJUSTL(NUM_AS_STR)) // SPACE // TRIM(ADJUSTL(SMALL_NUMS(10 + COMPONENTS(1) + 1)))\n        ELSE\n\n            IF (COMPONENTS(1) .GT. 0) THEN\n                IF (COMPONENTS(2) .GT. 0) THEN\n                    NUM_AS_STR = TRIM(ADJUSTL(NUM_AS_STR)) // SPACE // TRIM(ADJUSTL(TENS(COMPONENTS(2) - 1))) // SEPARATOR\n                    NUM_AS_STR = TRIM(ADJUSTL(NUM_AS_STR)) // TRIM(ADJUSTL(SMALL_NUMS(COMPONENTS(1) + 1)))\n                ELSE\n                    NUM_AS_STR = TRIM(ADJUSTL(NUM_AS_STR)) // SPACE // TRIM(ADJUSTL(SMALL_NUMS(COMPONENTS(1) + 1)))\n                ENDIF\n            ELSE IF (COMPONENTS(2) .GT. 0) THEN\n                NUM_AS_STR = TRIM(ADJUSTL(NUM_AS_STR)) // SPACE // TRIM(ADJUSTL(TENS(COMPONENTS(2) - 1)))\n            ENDIF\n        ENDIF\n\n    END FUNCTION STRING_REPRESENTATION\n\n    FUNCTION GET_COMPONENTS(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16), DIMENSION(9) :: GET_COMPONENTS\n        INTEGER(16) :: I_UNITS\n        INTEGER(16) :: I_TENS\n        INTEGER(16) :: I_HUNDREDS\n        INTEGER(16) :: I_THOUSANDS\n        INTEGER(16) :: I_MILLIONS\n        INTEGER(16) :: I_BILLIONS\n        INTEGER(16) :: I_TRILLIONS\n        INTEGER(16) :: I_QUADRILLIONS\n        INTEGER(16) :: I_QUINTILLIONS\n        REAL(16) DIVIDE_TEMP\n\n        I_UNITS = NUM\n\n        DIVIDE_TEMP = (I_UNITS - MOD(I_UNITS, 1000000000000000000))/1000000000000000000\n        I_QUINTILLIONS = FLOOR(DIVIDE_TEMP)\n\n        IF (I_QUINTILLIONS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_QUINTILLIONS*1000000000000000000\n        ENDIF\n\n\n        DIVIDE_TEMP = (I_UNITS - MOD(I_UNITS, 1000000000000000))/1000000000000000\n        I_QUADRILLIONS = FLOOR(DIVIDE_TEMP)\n\n        IF (I_QUADRILLIONS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_QUADRILLIONS*1000000000000000\n        ENDIF\n\n        DIVIDE_TEMP = (I_UNITS - MOD(I_UNITS, 1000000000000))/1000000000000\n        I_TRILLIONS = FLOOR(DIVIDE_TEMP)\n\n        IF (I_TRILLIONS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_TRILLIONS*1000000000000\n        ENDIF\n\n        DIVIDE_TEMP = (I_UNITS - MOD(I_UNITS, 1000000000))/1000000000\n        I_BILLIONS = FLOOR(DIVIDE_TEMP)\n\n        IF (I_BILLIONS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_BILLIONS*1000000000\n        ENDIF\n\n        DIVIDE_TEMP = (I_UNITS - MOD(I_UNITS, 1000000))/1000000\n        \n        I_MILLIONS = FLOOR(DIVIDE_TEMP)\n\n        IF (I_MILLIONS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_MILLIONS*1000000\n        ENDIF\n\n        DIVIDE_TEMP = (I_UNITS - MOD(I_UNITS, 1000))/1000\n\n        I_THOUSANDS = FLOOR(DIVIDE_TEMP)\n\n        IF (I_THOUSANDS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_THOUSANDS*1000\n        ENDIF\n\n        DIVIDE_TEMP = I_UNITS/1E2\n        I_HUNDREDS = FLOOR(DIVIDE_TEMP)\n\n        IF (I_HUNDREDS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_HUNDREDS*1E2\n        ENDIF\n\n        DIVIDE_TEMP = I_UNITS/10.\n        I_TENS =  FLOOR(DIVIDE_TEMP)\n\n        IF (I_TENS .NE. 0) THEN\n           I_UNITS = I_UNITS - I_TENS*10\n        ENDIF\n\n        GET_COMPONENTS(1) = I_UNITS\n        GET_COMPONENTS(2) = I_TENS\n        GET_COMPONENTS(3) = I_HUNDREDS\n        GET_COMPONENTS(4) = I_THOUSANDS\n        GET_COMPONENTS(5) = I_MILLIONS\n        GET_COMPONENTS(6) = I_BILLIONS\n        GET_COMPONENTS(7) = I_TRILLIONS\n        GET_COMPONENTS(8) = I_QUADRILLIONS\n        GET_COMPONENTS(9) = I_QUINTILLIONS\n\n    END FUNCTION GET_COMPONENTS\n\n    FUNCTION GET_SUBSET(COUNTER, LABEL) RESULT(OUT_STR)\n        CHARACTER(*), INTENT(IN) :: LABEL\n        INTEGER(16), INTENT(IN) :: COUNTER\n        CHARACTER(100) :: OUT_STR\n\n        OUT_STR = \"\"\n\n        IF (COUNTER .GT. 0) THEN\n            IF (COUNTER .LT. 20) THEN\n                OUT_STR = SPACE // TRIM(ADJUSTL(SMALL_NUMS(COUNTER + 1)))\n            ELSE\n                OUT_STR = SPACE // TRIM(ADJUSTL(STRING_REPRESENTATION(COUNTER)))\n            ENDIF\n            OUT_STR = TRIM(ADJUSTL(OUT_STR)) // SPACE // TRIM(LABEL)\n        ENDIF\n\n    END FUNCTION GET_SUBSET\n\n\n    SUBROUTINE FIND_MAGIC(NUM)\n        INTEGER(16), INTENT(IN) :: NUM\n        INTEGER(16) :: CURRENT, LEN_SIZE\n        CHARACTER(1000) :: CURRENT_STR, CURRENT_STR_LEN\n        CHARACTER(1000) :: OUT_STR\n\n        CURRENT = NUM\n        OUT_STR = \"\"\n\n        DO WHILE (CURRENT .NE. 4)\n            CURRENT_STR = STRING_REPRESENTATION(CURRENT)\n            LEN_SIZE = LEN_TRIM(ADJUSTL(CURRENT_STR))\n            CURRENT_STR_LEN = STRING_REPRESENTATION(LEN_SIZE)\n            OUT_STR = TRIM(ADJUSTL(OUT_STR)) // SPACE // TRIM(ADJUSTL(CURRENT_STR))\n            OUT_STR = TRIM(ADJUSTL(OUT_STR)) // \" is \" // TRIM(ADJUSTL(CURRENT_STR_LEN)) // \",\"\n            CURRENT = LEN_SIZE\n        ENDDO\n\n        WRITE(*,*) TRIM(ADJUSTL(OUT_STR)) // SPACE // \"four is magic.\"\n    END SUBROUTINE FIND_MAGIC\n        \n\nEND MODULE FOUR_IS_MAGIC\n\nPROGRAM TEST_NUM_NAME\n        USE FOUR_IS_MAGIC\n        IMPLICIT NONE\n\n        INTEGER(2) I\n        INTEGER(16), DIMENSION(10) :: TEST_NUMS = (/5, 13, 78, 797, 2739, 4000, 7893, 93497412, 2673497412, 10344658531277200972/)\n        CHARACTER(1000) :: NUM_NAME\n\n        DO I=1, SIZE(TEST_NUMS)\n            CALL FIND_MAGIC(TEST_NUMS(I))\n        ENDDO\nEND PROGRAM\n", "target": "public class FourIsMagic {\n\n    public static void main(String[] args) {\n        for ( long n : new long[] {6, 60, 89, 300, 670, 2000, 2467, 20000, 24500,200000, 230000, 246571, 2300000, 2465712, 20000000, 24657123, 230000000, 245000000, -246570000, 123456789712345l, 8777777777777777777L, Long.MAX_VALUE}) {\n            String magic = fourIsMagic(n);\n            System.out.printf(\"%d = %s%n\", n, toSentence(magic));\n        }\n    }\n    \n    private static final String toSentence(String s) {\n        return s.substring(0,1).toUpperCase() + s.substring(1) + \".\";\n    }\n    \n    private static final String[] nums = new String[] {\n            \"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\", \"nine\", \n            \"ten\", \"eleven\", \"twelve\", \"thirteen\", \"fourteen\", \"fifteen\", \"sixteen\", \"seventeen\", \"eighteen\", \"nineteen\"\n    };\n    \n    private static final String[] tens = new String[] {\"zero\", \"ten\", \"twenty\", \"thirty\", \"forty\", \"fifty\", \"sixty\", \"seventy\", \"eighty\", \"ninety\"};\n\n    private static final String fourIsMagic(long n) {\n        if ( n == 4 ) {\n            return numToString(n) + \" is magic\";\n        }\n        String result = numToString(n);\n        return result + \" is \" + numToString(result.length()) + \", \" + fourIsMagic(result.length());\n    }\n    \n    private static final String numToString(long n) {\n        if ( n < 0 ) { \n            return \"negative \" + numToString(-n);\n        }\n        int index = (int) n;\n        if ( n <= 19 ) {\n            return nums[index];\n        }\n        if ( n <= 99 ) {\n            return tens[index/10] + (n % 10 > 0 ? \" \" + numToString(n % 10) : \"\");\n        }\n        String label = null;\n        long factor = 0;\n        if ( n <= 999 ) {\n            label = \"hundred\";\n            factor = 100;\n        }\n        else if ( n <= 999999) {\n            label = \"thousand\";\n            factor = 1000;\n        }\n        else if ( n <= 999999999) {\n            label = \"million\";\n            factor = 1000000;\n        }\n        else if ( n <= 999999999999L) {\n            label = \"billion\";\n            factor = 1000000000;\n        }\n        else if ( n <= 999999999999999L) {\n            label = \"trillion\";\n            factor = 1000000000000L;\n        }\n        else if ( n <= 999999999999999999L) {\n            label = \"quadrillion\";\n            factor = 1000000000000000L;\n        }\n        else {\n            label = \"quintillion\";\n            factor = 1000000000000000000L;\n        }\n        return numToString(n / factor) + \" \" + label + (n % factor > 0 ? \" \" + numToString(n % factor ) : \"\");\n    }\n\n}\n"}
{"id": 388697, "name": "Zhang-Suen thinning algorithm", "source": "Translate Fortran to Java: A(2:N - 1) = (A(1:N - 2) + A(2:N - 1) + A(3:N))/3\n", "target": "import java.awt.Point;\nimport java.util.*;\n\npublic class ZhangSuen {\n\n    final static String[] image = {\n        \"                                                          \",\n        \" #################                   #############        \",\n        \" ##################               ################        \",\n        \" ###################            ##################        \",\n        \" ########     #######          ###################        \",\n        \"   ######     #######         #######       ######        \",\n        \"   ######     #######        #######                      \",\n        \"   #################         #######                      \",\n        \"   ################          #######                      \",\n        \"   #################         #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######        #######                      \",\n        \"   ######     #######         #######       ######        \",\n        \" ########     #######          ###################        \",\n        \" ########     ####### ######    ################## ###### \",\n        \" ########     ####### ######      ################ ###### \",\n        \" ########     ####### ######         ############# ###### \",\n        \"                                                          \"};\n\n    final static int[][] nbrs = {{0, -1}, {1, -1}, {1, 0}, {1, 1}, {0, 1},\n        {-1, 1}, {-1, 0}, {-1, -1}, {0, -1}};\n\n    final static int[][][] nbrGroups = {{{0, 2, 4}, {2, 4, 6}}, {{0, 2, 6},\n        {0, 4, 6}}};\n\n    static List<Point> toWhite = new ArrayList<>();\n    static char[][] grid;\n\n    public static void main(String[] args) {\n        grid = new char[image.length][];\n        for (int r = 0; r < image.length; r++)\n            grid[r] = image[r].toCharArray();\n\n        thinImage();\n    }\n\n    static void thinImage() {\n        boolean firstStep = false;\n        boolean hasChanged;\n\n        do {\n            hasChanged = false;\n            firstStep = !firstStep;\n\n            for (int r = 1; r < grid.length - 1; r++) {\n                for (int c = 1; c < grid[0].length - 1; c++) {\n\n                    if (grid[r][c] != '#')\n                        continue;\n\n                    int nn = numNeighbors(r, c);\n                    if (nn < 2 || nn > 6)\n                        continue;\n\n                    if (numTransitions(r, c) != 1)\n                        continue;\n\n                    if (!atLeastOneIsWhite(r, c, firstStep ? 0 : 1))\n                        continue;\n\n                    toWhite.add(new Point(c, r));\n                    hasChanged = true;\n                }\n            }\n\n            for (Point p : toWhite)\n                grid[p.y][p.x] = ' ';\n            toWhite.clear();\n\n        } while (firstStep || hasChanged);\n\n        printResult();\n    }\n\n    static int numNeighbors(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == '#')\n                count++;\n        return count;\n    }\n\n    static int numTransitions(int r, int c) {\n        int count = 0;\n        for (int i = 0; i < nbrs.length - 1; i++)\n            if (grid[r + nbrs[i][1]][c + nbrs[i][0]] == ' ') {\n                if (grid[r + nbrs[i + 1][1]][c + nbrs[i + 1][0]] == '#')\n                    count++;\n            }\n        return count;\n    }\n\n    static boolean atLeastOneIsWhite(int r, int c, int step) {\n        int count = 0;\n        int[][] group = nbrGroups[step];\n        for (int i = 0; i < 2; i++)\n            for (int j = 0; j < group[i].length; j++) {\n                int[] nbr = nbrs[group[i][j]];\n                if (grid[r + nbr[1]][c + nbr[0]] == ' ') {\n                    count++;\n                    break;\n                }\n            }\n        return count > 1;\n    }\n\n    static void printResult() {\n        for (char[] row : grid)\n            System.out.println(row);\n    }\n}\n"}
{"id": 388698, "name": "Generate Chess960 starting position", "source": "Translate Fortran to Java: program chess960\n    implicit none\n    \n    integer, pointer  :: a,b,c,d,e,f,g,h\n    integer, target   :: p(8)\n    a => p(1)\n    b => p(2)\n    c => p(3)\n    d => p(4)\n    e => p(5)\n    f => p(6)\n    g => p(7)\n    h => p(8)\n\n    king: do a=2,7                                        \n        r1: do b=1,a-1                                    \n            r2: do c=a+1,8                                \n                b1: do d=1,7,2                            \n                    if (skip_pos(d,4)) cycle\n                    b2: do e=2,8,2                        \n                        if (skip_pos(e,5)) cycle\n                        queen: do f=1,8                   \n                            if (skip_pos(f,6)) cycle\n                            n1: do g=1,7                  \n                                if (skip_pos(g,7)) cycle\n                                n2: do h=g+1,8            \n                                    if (skip_pos(h,8)) cycle\n                                    if (sum(p) /= 36) stop 'Loop error'  \n                                    call write_position\n                                end do n2\n                            end do n1\n                        end do queen\n                    end do b2\n                end do b1\n            end do r2\n        end do r1\n    end do king\n    \ncontains\n\n    logical function skip_pos(i, n)\n        integer, intent(in) :: i, n\n        skip_pos = any(p(1:n-1) == i)\n    end function skip_pos\n\n    subroutine write_position\n        integer           :: i, j\n        character(len=15) :: position = ' '\n        character(len=1), parameter  :: names(8) = ['K','R','R','B','B','Q','N','N']\n        do i=1,8\n            j = 2*p(i)-1\n            position(j:j) = names(i)\n        end do\n        write(*,'(a)') position\n    end subroutine write_position\n    \nend program chess960\n", "target": "import java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Chess960{\n\tprivate static List<Character> pieces = Arrays.asList('R','B','N','Q','K','N','B','R');\n\n\tpublic static List<Character> generateFirstRank(){\n\t\tdo{\n\t\t\tCollections.shuffle(pieces);\n\t\t}while(!check(pieces.toString().replaceAll(\"[^\\\\p{Upper}]\", \"\"))); \n\t\t\n\t\treturn pieces;\n\t}\n\n\tprivate static boolean check(String rank){\n\t\tif(!rank.matches(\".*R.*K.*R.*\")) return false;\t\t\t\n\t\tif(!rank.matches(\".*B(..|....|......|)B.*\")) return false;\t\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tSystem.out.println(generateFirstRank());\n\t\t}\n\t}\n}\n"}
{"id": 388699, "name": "Naming conventions", "source": "Translate Fortran to Java: IMPLICIT REAL(A-H,O-Z), INTEGER(I-M)\n", "target": "\n\nmodule shop.acme.com\n    {\n    \n    const Point(Int x, Int y);\n    enum Color {Red, Green, Blue}\n    interface Callback\n        {\n        \n        Boolean active;\n        void onEvent(String event);\n        void onError(Exception e);\n        }\n\n    \n    String DefaultLogin = \"guest\";\n    Int    MAX_QUANTITY = 100;\n\n    \n    interface Bag<Element>\n            extends Iterable<Element>\n        {\n        void add(Element e);\n        }\n    }\n"}
{"id": 388700, "name": "Aliquot sequence classifications", "source": "Translate Fortran to Java:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\nc       INTEGER*4 I4LIMIT\nc       PARAMETER (I4LIMIT = 2147483647)\n       INTEGER*8 TOOBIG\t\t\n       PARAMETER (TOOBIG = 2**47)\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 10000)\t\n       INTEGER*8 KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\t\n        INTEGER*8 FUNCTION SUMF(N)\t\n         INTEGER*8 N\t\t\t\n         INTEGER*8 F,F2\t\t\n         INTEGER*8 S,INC,BOOST\t\t\n          IF (N.LE.LOTS) THEN\t\t\n            SUMF = KNOWNSUM(N)\t\t\t\n           ELSE\t\t\t\nCould use SUMF in place of S, but some compilers have been confused by such usage.\n            S = 1\t\t\t\n            F = 1\t\t\t\n            INC = 1\t\t\t\n            IF (MOD(N,2) .EQ. 1) INC = 2\n    1       F = F + INC\t\t\t\n            F2 = F*F\t\t\t\t\n            IF (F2 .LT. N) THEN\t\t\t\n              IF (MOD(N,F) .EQ. 0) THEN\t\t\n                BOOST = F + N/F\t\t\t\n                IF (S .GT. TOOBIG - BOOST) GO TO 666\t\n                S = S + BOOST\t\t\t\n              END IF\t\t\t\t\n              GO TO 1\t\t\t\t\n            END IF\t\t\t\n            IF (F2 .EQ. N) THEN\t\n              IF (S .GT. TOOBIG - F) GO TO 666\t\n              S = S + F\t\t\t\n            END IF\t\t\t\n            SUMF = S\t\t\t\n          END IF\t\t\t\n         RETURN\t\t\t\nCannot calculate the sum, because it exceeds the INTEGER*8 limit.\n  666     SUMF = -666\t\t\n        END FUNCTION SUMF\t\n         SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER*8 F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         SUBROUTINE CLASSIFY(N)\t\n         INTEGER*8 N\t\t\n         INTEGER ROPE\t\t\n         PARAMETER(ROPE = 16)\t\n         INTEGER*8 TRAIL(ROPE)\t\n         INTEGER*8 SF\t\t\n         INTEGER I,L\t\t\n         CHARACTER*28 THIS\t\n          L = 1\t\t\n          TRAIL(1) = N\t\t\n          SF = N\t\t\n   10     SF = SUMF(SF)\t\t\n          IF (SF .LT. 0) THEN\t\t\n            WRITE (THIS,11) L,\"overflows\n   11       FORMAT (\"After \",I0,\", \",A)\t\t\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (SF .EQ. 0) THEN\t\t\n            WRITE (THIS,11) L,\"terminates\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (ANY(TRAIL(1:L) .EQ. SF)) THEN\t\n            IF (L .EQ. 1) THEN\t\t\t\t\n              CALL REPORT(\"Perfect\n            ELSE IF (L .EQ. 2) THEN\t\t\t\n              CALL REPORT(\"Amicable:\")\t\t\t\n            ELSE\t\t\t\t\t\n              I = MINLOC(ABS(TRAIL(1:L) - SF),DIM=1)\t\n              IF (I .EQ. 1) THEN\t\t\n                WRITE (THIS,12) L\t\t\n   12           FORMAT (\"Sociable \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              ELSE IF (I .EQ. L) THEN\t\t\n                CALL REPORT(\"Aspiring:\")\t\n              ELSE\t\t\t\t\n                WRITE (THIS,13) L - I + 1,SF\t\n   13           FORMAT (\"Cyclic end \",I0,\", to \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              END IF\t\t\t\t\n            END IF\t\t\t\n          ELSE\t\t\t\t\n            IF (L .GE. ROPE) THEN\t\t\n              WRITE (THIS,11) L,\"non-terminating?\"\t\n              CALL REPORT(ADJUSTR(THIS))\t\t\n             ELSE\t\t\t\t\n              L = L + 1\t\t\t\n              TRAIL(L) = SF\t\t\t\n              GO TO 10\t\t\t\t\n            END IF\t\t\t\n          END IF\t\t\n         RETURN\t\t\n         CONTAINS\t\t\n          SUBROUTINE REPORT(WHAT)\t\n           CHARACTER*(*) WHAT\t\t\n            WRITE (6,1) WHAT,TRAIL(1:L)\n    1       FORMAT (A28,1X,12(I0:\",\"))\t\n          END SUBROUTINE REPORT\t\n        END SUBROUTINE CLASSIFY\t\n       END MODULE FACTORSTUFF\t\n       PROGRAM CLASSIFYTHEM\t\n       USE FACTORSTUFF\t\t\n       INTEGER*8 I,N\t\t\n       INTEGER*8 THIS(14)\t\n       DATA THIS/11,12,28,496,220,1184,12496,1264460,790,909,     \n     1  562,1064,1488,15355717786080/\t\n         CALL PREPARESUMF\t\t\n         DO I = 1,10\t\t\t\n          CALL CLASSIFY(I)\n        END DO\n         DO I = 1,SIZE(THIS)\t\t\n          CALL CLASSIFY(THIS(I))\n        END DO\n       END\t\t\t\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 388701, "name": "Aliquot sequence classifications", "source": "Translate Fortran to Java:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\nc       INTEGER*4 I4LIMIT\nc       PARAMETER (I4LIMIT = 2147483647)\n       INTEGER*8 TOOBIG\t\t\n       PARAMETER (TOOBIG = 2**47)\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 10000)\t\n       INTEGER*8 KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\t\n        INTEGER*8 FUNCTION SUMF(N)\t\n         INTEGER*8 N\t\t\t\n         INTEGER*8 F,F2\t\t\n         INTEGER*8 S,INC,BOOST\t\t\n          IF (N.LE.LOTS) THEN\t\t\n            SUMF = KNOWNSUM(N)\t\t\t\n           ELSE\t\t\t\nCould use SUMF in place of S, but some compilers have been confused by such usage.\n            S = 1\t\t\t\n            F = 1\t\t\t\n            INC = 1\t\t\t\n            IF (MOD(N,2) .EQ. 1) INC = 2\n    1       F = F + INC\t\t\t\n            F2 = F*F\t\t\t\t\n            IF (F2 .LT. N) THEN\t\t\t\n              IF (MOD(N,F) .EQ. 0) THEN\t\t\n                BOOST = F + N/F\t\t\t\n                IF (S .GT. TOOBIG - BOOST) GO TO 666\t\n                S = S + BOOST\t\t\t\n              END IF\t\t\t\t\n              GO TO 1\t\t\t\t\n            END IF\t\t\t\n            IF (F2 .EQ. N) THEN\t\n              IF (S .GT. TOOBIG - F) GO TO 666\t\n              S = S + F\t\t\t\n            END IF\t\t\t\n            SUMF = S\t\t\t\n          END IF\t\t\t\n         RETURN\t\t\t\nCannot calculate the sum, because it exceeds the INTEGER*8 limit.\n  666     SUMF = -666\t\t\n        END FUNCTION SUMF\t\n         SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER*8 F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         SUBROUTINE CLASSIFY(N)\t\n         INTEGER*8 N\t\t\n         INTEGER ROPE\t\t\n         PARAMETER(ROPE = 16)\t\n         INTEGER*8 TRAIL(ROPE)\t\n         INTEGER*8 SF\t\t\n         INTEGER I,L\t\t\n         CHARACTER*28 THIS\t\n          L = 1\t\t\n          TRAIL(1) = N\t\t\n          SF = N\t\t\n   10     SF = SUMF(SF)\t\t\n          IF (SF .LT. 0) THEN\t\t\n            WRITE (THIS,11) L,\"overflows\n   11       FORMAT (\"After \",I0,\", \",A)\t\t\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (SF .EQ. 0) THEN\t\t\n            WRITE (THIS,11) L,\"terminates\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (ANY(TRAIL(1:L) .EQ. SF)) THEN\t\n            IF (L .EQ. 1) THEN\t\t\t\t\n              CALL REPORT(\"Perfect\n            ELSE IF (L .EQ. 2) THEN\t\t\t\n              CALL REPORT(\"Amicable:\")\t\t\t\n            ELSE\t\t\t\t\t\n              I = MINLOC(ABS(TRAIL(1:L) - SF),DIM=1)\t\n              IF (I .EQ. 1) THEN\t\t\n                WRITE (THIS,12) L\t\t\n   12           FORMAT (\"Sociable \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              ELSE IF (I .EQ. L) THEN\t\t\n                CALL REPORT(\"Aspiring:\")\t\n              ELSE\t\t\t\t\n                WRITE (THIS,13) L - I + 1,SF\t\n   13           FORMAT (\"Cyclic end \",I0,\", to \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              END IF\t\t\t\t\n            END IF\t\t\t\n          ELSE\t\t\t\t\n            IF (L .GE. ROPE) THEN\t\t\n              WRITE (THIS,11) L,\"non-terminating?\"\t\n              CALL REPORT(ADJUSTR(THIS))\t\t\n             ELSE\t\t\t\t\n              L = L + 1\t\t\t\n              TRAIL(L) = SF\t\t\t\n              GO TO 10\t\t\t\t\n            END IF\t\t\t\n          END IF\t\t\n         RETURN\t\t\n         CONTAINS\t\t\n          SUBROUTINE REPORT(WHAT)\t\n           CHARACTER*(*) WHAT\t\t\n            WRITE (6,1) WHAT,TRAIL(1:L)\n    1       FORMAT (A28,1X,12(I0:\",\"))\t\n          END SUBROUTINE REPORT\t\n        END SUBROUTINE CLASSIFY\t\n       END MODULE FACTORSTUFF\t\n       PROGRAM CLASSIFYTHEM\t\n       USE FACTORSTUFF\t\t\n       INTEGER*8 I,N\t\t\n       INTEGER*8 THIS(14)\t\n       DATA THIS/11,12,28,496,220,1184,12496,1264460,790,909,     \n     1  562,1064,1488,15355717786080/\t\n         CALL PREPARESUMF\t\t\n         DO I = 1,10\t\t\t\n          CALL CLASSIFY(I)\n        END DO\n         DO I = 1,SIZE(THIS)\t\t\n          CALL CLASSIFY(THIS(I))\n        END DO\n       END\t\t\t\n", "target": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.LongStream;\n\npublic class AliquotSequenceClassifications {\n\n    private static Long properDivsSum(long n) {\n        return LongStream.rangeClosed(1, (n + 1) / 2).filter(i -> n % i == 0 && n != i).sum();\n    }\n\n    static boolean aliquot(long n, int maxLen, long maxTerm) {\n        List<Long> s = new ArrayList<>(maxLen);\n        s.add(n);\n        long newN = n;\n\n        while (s.size() <= maxLen && newN < maxTerm) {\n\n            newN = properDivsSum(s.get(s.size() - 1));\n\n            if (s.contains(newN)) {\n\n                if (s.get(0) == newN) {\n\n                    switch (s.size()) {\n                        case 1:\n                            return report(\"Perfect\", s);\n                        case 2:\n                            return report(\"Amicable\", s);\n                        default:\n                            return report(\"Sociable of length \" + s.size(), s);\n                    }\n\n                } else if (s.get(s.size() - 1) == newN) {\n                    return report(\"Aspiring\", s);\n\n                } else\n                    return report(\"Cyclic back to \" + newN, s);\n\n            } else {\n                s.add(newN);\n                if (newN == 0)\n                    return report(\"Terminating\", s);\n            }\n        }\n\n        return report(\"Non-terminating\", s);\n    }\n\n    static boolean report(String msg, List<Long> result) {\n        System.out.println(msg + \": \" + result);\n        return false;\n    }\n\n    public static void main(String[] args) {\n        long[] arr = {\n                11, 12, 28, 496, 220, 1184, 12496, 1264460,\n                790, 909, 562, 1064, 1488};\n\n        LongStream.rangeClosed(1, 10).forEach(n -> aliquot(n, 16, 1L << 47));\n        System.out.println();\n        Arrays.stream(arr).forEach(n -> aliquot(n, 16, 1L << 47));\n    }\n}\n"}
{"id": 388702, "name": "Mersenne primes", "source": "Translate Fortran to Java: program mersenne\n    use iso_fortran_env, only: output_unit, INT64\n    implicit none\n\n    integer, parameter  :: l=INT64\n    integer(kind=l)     :: base\n    integer             :: pow\n\n    base = 2\n\n    do pow = 1, 32\n        if (is_prime(base-1)) then\n            write(output_unit,'(A2,x,I0,x,A3)') \"2^\", pow, \"- 1\"\n        end if\n        base = base * 2\n    end do\ncontains\n    pure function is_prime(n)\n        integer(kind=l), intent(in) :: n\n        logical                     :: is_prime\n        integer(kind=l)             :: test\n\n        is_prime = .false.\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        test = 5\n        do\n            if (test**2 >= n) then\n                is_prime = .true.\n                return\n            end if\n\n            if (modulo(n, test) == 0) return\n            test = test + 2\n            if (modulo(n, test) == 0) return\n            test = test + 4\n        end do\n    end function is_prime\nend program mersenne\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 388703, "name": "Mersenne primes", "source": "Translate Fortran to Java: program mersenne\n    use iso_fortran_env, only: output_unit, INT64\n    implicit none\n\n    integer, parameter  :: l=INT64\n    integer(kind=l)     :: base\n    integer             :: pow\n\n    base = 2\n\n    do pow = 1, 32\n        if (is_prime(base-1)) then\n            write(output_unit,'(A2,x,I0,x,A3)') \"2^\", pow, \"- 1\"\n        end if\n        base = base * 2\n    end do\ncontains\n    pure function is_prime(n)\n        integer(kind=l), intent(in) :: n\n        logical                     :: is_prime\n        integer(kind=l)             :: test\n\n        is_prime = .false.\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        test = 5\n        do\n            if (test**2 >= n) then\n                is_prime = .true.\n                return\n            end if\n\n            if (modulo(n, test) == 0) return\n            test = test + 2\n            if (modulo(n, test) == 0) return\n            test = test + 4\n        end do\n    end function is_prime\nend program mersenne\n", "target": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n"}
{"id": 388704, "name": "Taxicab numbers", "source": "Translate Fortran to Java: \n     PROGRAM POOKA\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  NVARS = 25\n\n\n\n      REAL  ::  f1\n      REAL  ::  f2\n      INTEGER  ::  hits\n      INTEGER  ::  s\n      INTEGER  ::  TAXICAB\n\n      hits = 0\n      s = 0\n      f1 = SECOND()\n      DO WHILE ( hits<NVARS )\n         s = s + 1\n         hits = hits + TAXICAB(s)\n      END DO\n      f2 = SECOND()\n      PRINT * , 'elapsed time = ' , f2 - f1 , 'For ' , NVARS , ' Variables'\n      STOP\n      END PROGRAM POOKA\n \n      FUNCTION TAXICAB(N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      INTEGER  ::  TAXICAB\n      INTENT (IN) N\n\n\n\n      INTEGER  ::  holder\n      INTEGER  ::  oldx\n      INTEGER  ::  oldy\n      INTEGER  ::  s\n      INTEGER  ::  x\n      INTEGER  ::  y\n      real*8,parameter :: xpon=(1.0D0/3.0D0)\n\n      x = 0\n      holder = 0\n      oldx = 0\n      oldy = 0\n      TAXICAB = 0\n      y = INT(N**xpon)\n      DO WHILE ( x<=y )\n         s = x**3 + y**3\n         IF( s<N )THEN\n            x = x + 1\n         ELSE IF( s>N )THEN\n            y = y - 1\n         ELSE\n            IF( holder==s )THEN \n               WRITE(6 , 34)s , '(' , x**3 , y**3 , ')' , '(' , oldx**3 , oldy**3 , ')'\n 34            FORMAT(1x , i12 , 10x , 1A1 , i12 , 2x , i12 , 1A1 , 10x , 1A1 , i12 , 2x ,&\n                    & i12 , 1A1)\n               TAXICAB = 1  \n            END IF\n            holder = s      \n            oldx = x       \n            oldy = y\n            x = x + 1       \n            y = y - 1\n         END IF\n      END DO\n      RETURN\n      END FUNCTION TAXICAB\n", "target": "import java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Iterator;\n\nclass CubeSum implements Comparable<CubeSum> {\n\tpublic long x, y, value;\n\n\tpublic CubeSum(long x, long y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tthis.value = x*x*x + y*y*y;\n\t}\n\n\tpublic String toString() {\n\t\treturn String.format(\"%4d^3 + %4d^3\", x, y);\n\t}\n\n\tpublic int compareTo(CubeSum that) {\n\t\treturn value < that.value ? -1 : value > that.value ? 1 : 0;\n\t}\n}\n\nclass SumIterator implements Iterator<CubeSum> {\n\tPriorityQueue<CubeSum> pq = new PriorityQueue<CubeSum>();\n\tlong n = 0;\n\n\tpublic boolean hasNext() { return true; }\n\tpublic CubeSum next() {\n\t\twhile (pq.size() == 0 || pq.peek().value >= n*n*n)\n\t\t\tpq.add(new CubeSum(++n, 1));\n\n\t\tCubeSum s = pq.remove();\n\t\tif (s.x > s.y + 1) pq.add(new CubeSum(s.x, s.y+1));\n\n\t\treturn s;\n\t}\n}\n\nclass TaxiIterator implements Iterator<List<CubeSum>> {\n\tIterator<CubeSum> sumIterator = new SumIterator();\n\tCubeSum last = sumIterator.next();\n\n\tpublic boolean hasNext() { return true; }\n\tpublic List<CubeSum> next() {\n\t\tCubeSum s;\n\t\tList<CubeSum> train = new ArrayList<CubeSum>();\n\n\t\twhile ((s = sumIterator.next()).value != last.value)\n\t\t\tlast = s;\n\n\t\ttrain.add(last);\n\n\t\tdo { train.add(s); } while ((s = sumIterator.next()).value == last.value);\n\t\tlast = s;\n\n\t\treturn train;\n\t}\n}\n\t\npublic class Taxi {\n\tpublic static final void main(String[] args) {\n\t\tIterator<List<CubeSum>> taxi = new TaxiIterator();\n\n\t\tfor (int i = 1; i <= 2006; i++) {\n\t\t\tList<CubeSum> t = taxi.next();\n\t\t\tif (i > 25 && i < 2000) continue;\n\n\t\t\tSystem.out.printf(\"%4d: %10d\", i, t.get(0).value);\n\t\t\tfor (CubeSum s: t)\n\t\t\t\tSystem.out.print(\" = \" + s);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n"}
{"id": 388705, "name": "Left factorials", "source": "Translate Fortran to Java:       MODULE LAIROTCAF\t\n       CONTAINS\t\t\n        INTEGER*8 FUNCTION FACT(N)\t\n         INTEGER N\t\n         INTEGER I\t\n          FACT = 1\t\n          DO I = 2,N\t\t\n            FACT = FACT*I\t\t\n            IF (FACT.LE.0) STOP \"Factorial: Overflow\n          END DO\t\t\n        END FUNCTION FACT\t\n\n        INTEGER*8 FUNCTION LFACT(N)\t\n         INTEGER N\t\n         INTEGER K\t\n          LFACT = 0\t\n          DO K = 0,N - 1\t\n            LFACT = LFACT + FACT(K)\t\n            IF (LFACT.LE.0) STOP \"Lfact: Overflow\n          END DO\t\t\n        END FUNCTION LFACT\t\n      END MODULE LAIROTCAF\t\n\n      PROGRAM POKE\n      USE LAIROTCAF\n      INTEGER I\n\n      WRITE (6,*) \"Left factorials, from 0 to 10...\"\n      DO I = 0,10\n        WRITE (6,1) I,LFACT(I)\n    1   FORMAT (\"\n      END DO\n\n      WRITE (6,*) \"Left factorials, from 20 to 110 by tens...\"\n      DO I = 20,110,10\n        WRITE (6,1) I,LFACT(I)\n      END DO\n      END\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 388706, "name": "Left factorials", "source": "Translate Fortran to Java:       MODULE LAIROTCAF\t\n       CONTAINS\t\t\n        INTEGER*8 FUNCTION FACT(N)\t\n         INTEGER N\t\n         INTEGER I\t\n          FACT = 1\t\n          DO I = 2,N\t\t\n            FACT = FACT*I\t\t\n            IF (FACT.LE.0) STOP \"Factorial: Overflow\n          END DO\t\t\n        END FUNCTION FACT\t\n\n        INTEGER*8 FUNCTION LFACT(N)\t\n         INTEGER N\t\n         INTEGER K\t\n          LFACT = 0\t\n          DO K = 0,N - 1\t\n            LFACT = LFACT + FACT(K)\t\n            IF (LFACT.LE.0) STOP \"Lfact: Overflow\n          END DO\t\t\n        END FUNCTION LFACT\t\n      END MODULE LAIROTCAF\t\n\n      PROGRAM POKE\n      USE LAIROTCAF\n      INTEGER I\n\n      WRITE (6,*) \"Left factorials, from 0 to 10...\"\n      DO I = 0,10\n        WRITE (6,1) I,LFACT(I)\n    1   FORMAT (\"\n      END DO\n\n      WRITE (6,*) \"Left factorials, from 20 to 110 by tens...\"\n      DO I = 20,110,10\n        WRITE (6,1) I,LFACT(I)\n      END DO\n      END\n", "target": "import java.math.BigInteger;\n\npublic class LeftFac{\n\tpublic static BigInteger factorial(BigInteger n){\n\t\tBigInteger ans = BigInteger.ONE;\n\t\tfor(BigInteger x = BigInteger.ONE; x.compareTo(n) <= 0; x = x.add(BigInteger.ONE)){\n\t\t\tans = ans.multiply(x);\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static BigInteger leftFact(BigInteger n){\n\t\tBigInteger ans = BigInteger.ZERO;\n\t\tfor(BigInteger k = BigInteger.ZERO; k.compareTo(n.subtract(BigInteger.ONE)) <= 0; k = k.add(BigInteger.ONE)){\n\t\t\tans = ans.add(factorial(k));\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tfor(int i = 0; i <= 10; i++){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 20; i <= 110; i += 10){\n\t\t\tSystem.out.println(\"!\" + i + \" = \" + leftFact(BigInteger.valueOf(i)));\n\t\t}\n\t\t\n\t\tfor(int i = 1000; i <= 10000; i += 1000){\n\t\t\tSystem.out.println(\"!\" + i + \" has \" + leftFact(BigInteger.valueOf(i)).toString().length() + \" digits\");\n\t\t}\n\t}\n}\n"}
{"id": 388707, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Fortran to Java:        program nivengaps      \n       implicit none\n       integer*8 prev /1/, gap /0/, sum /0/\n       integer*8 nividx /0/, niven /1/\n       integer gapidx /1/\n       \n       character*13 idxfmt\n       character*14 nivfmt\n       write (*,*) 'Gap no  Gap   Niven index    Niven number '\n       write (*,*) '------  ---  -------------  --------------'\n       \n 10    call divsum(niven, sum)\n       if (mod(niven, sum) .EQ. 0) then\n          if (niven .GT. prev + gap) then\n             gap = niven - prev\n             call fmtint(nividx,13,idxfmt)\n             call fmtint(prev,14,nivfmt)\n             write (*,20) gapidx,gap,idxfmt,nivfmt\n             gapidx = gapidx + 1\n          end if\n          prev = niven\n          nividx = nividx + 1\n       end if          \n       niven = niven + 1\n       if (gapidx .LE. 32) go to 10\n       \n       stop\n 20    format (i7,'  ',i3,'  ',a13,'  ',a14)       \n       end program\n\nC      Sum of divisors of NN, given the sum of divisors of NN-1       \n       subroutine divsum(nn,sum)\n          implicit none\n          integer*8 n,nn,sum\n          n = nn          \n          sum = sum + 1\n 30       if (n.GT.0 .AND. mod(n,10).EQ.0) then\n             sum = sum - 9\n             n = n / 10\n             go to 30\n          end if\n       end subroutine  \n \n       integer*8 function mod(a,b)\n          implicit none\n          integer*8 a,b\n          mod = a - a/b * b\n       end function\n\nC      Format a positive integer with ',' as the thousands separator.\n       subroutine fmtint(num, len, str)\n          implicit none \n          integer*8 n, num\n          integer pos, len, th\n          character(*) str\n          n=num\n          pos=len\n          th=2\n 40       if (pos.GT.0) then\n             if (n.EQ.0) then\n                str(pos:pos) = ' '\n             else\n                str(pos:pos) = achar(mod(n,10) + iachar('0'))\n                if (th.EQ.0 .AND. n.GE.10 .AND. pos.GT.1) then\n                    th = 2\n                    pos = pos-1\n                    str(pos:pos) = ','\n                else\n                    th = th-1\n                end if\n            end if\n            pos = pos - 1\n            n = n/10\n            go to 40\n          end if    \n       end subroutine\n", "target": "public class NivenNumberGaps {\n\n    \n    \n    public static void main(String[] args) {\n        long prevGap = 0;\n        long prevN = 1;\n        long index = 0;\n        System.out.println(\"Gap      Gap Index   Starting Niven\");\n        for ( long n = 2 ; n < 20_000_000_000l ; n++ ) {\n            if ( isNiven(n) ) {\n                index++;\n                long curGap = n - prevN;\n                if ( curGap > prevGap ) {\n                    System.out.printf(\"%3d \u00a0%,13d \u00a0%,15d%n\", curGap, index, prevN);\n                    prevGap = curGap;\n                }\n                prevN = n;\n            }\n        }\n    }\n    \n    public static boolean isNiven(long n) {\n        long sum = 0;\n        long nSave = n;\n        while ( n > 0 ) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return nSave % sum == 0;\n    }\n\n}\n"}
{"id": 388708, "name": "Old Russian measure of length", "source": "Translate Fortran to Java: PROGRAM RUS\n IMPLICIT NONE\n REAL, PARAMETER:: E_m = 1.\n REAL, PARAMETER:: E_mm = 1.E-3\n REAL, PARAMETER:: E_km = 1.E+3\n REAL, PARAMETER:: E_cm = 1.E-2\n REAL, PARAMETER:: E_arshin = 71.12 * E_cm\n REAL, PARAMETER:: E_fut = 3./7. * E_arshin\n REAL, PARAMETER:: E_piad = 1./4. * E_arshin\n REAL, PARAMETER:: E_vershok = 1./16. * E_arshin\n REAL, PARAMETER:: E_dyuim = 1./28. * E_arshin\n REAL, PARAMETER:: E_liniya = 1./280. * E_arshin\n REAL, PARAMETER:: E_tochka = 1./2800. * E_arshin\n REAL, PARAMETER:: E_ladon = 7.5 * E_cm\n REAL, PARAMETER:: E_lokot = 45 * E_cm\n REAL, PARAMETER:: E_sazhen = 3. * E_arshin\n REAL, PARAMETER:: E_versta = 1500. * E_arshin\n REAL, PARAMETER:: E_milya = 10500. * E_arshin\n INTEGER, PARAMETER:: N = 16\n CHARACTER(LEN=7), DIMENSION(N):: nam = (/&\n  &'m      ', 'mm     ', 'km     ', 'cm     ',&\n  &'arshin ', 'fut    ', 'piad   ', 'vershok',&\n  &'dyuim  ', 'liniya ', 'tochka ', 'ladon  ',&\n  &'lokot  ', 'sazhen ', 'versta ', 'milya  ' /)\n REAL, DIMENSION(N):: wert = (/ &\n  &1., E_mm, E_km, E_cm,&\n  &E_arshin, E_fut, E_piad, E_vershok,&\n  &E_dyuim, E_liniya, E_tochka, E_ladon,&\n  &E_lokot, E_sazhen, E_versta, E_milya /)\n CHARACTER(LEN=7):: RD_U\n REAL:: RD_V\n INTEGER:: I, J\n DO I=1, N\n  WRITE(*, '(A, \" \")', ADVANCE='NO')  nam(I)\n END DO\n WRITE (*, *)\n WRITE(*, '(A)', ADVANCE='NO') 'value unit -> '\n READ(*, *) RD_V, RD_U\n RD_U = ADJUSTL(RD_U)\n J = 1\n DO WHILE (NAM(J) .NE. RD_U)\n  J = J + 1\n  IF (J .GT. N) STOP \"Unit not known: \"//RD_U\n END DO\n RD_V = RD_V * wert(J)\n DO I=1, N\n  J = J + 1\n  IF (J .GT. N) J = 1\n  WRITE (*, '(F20.3, \" \", A)') RD_V / wert(J), nam(J)\n END DO\nEND PROGRAM RUS\n", "target": "public class OldRussianMeasures {\n\n    final static String[] keys = {\"tochka\", \"liniya\", \"centimeter\", \"diuym\",\n        \"vershok\", \"piad\", \"fut\", \"arshin\", \"meter\", \"sazhen\", \"kilometer\",\n        \"versta\", \"milia\"};\n\n    final static double[] values = {0.000254, 0.00254, 0.01,0.0254,\n        0.04445, 0.1778, 0.3048, 0.7112, 1.0, 2.1336, 1000.0,\n        1066.8, 7467.6};\n\n    public static void main(String[] a) {\n        if (a.length == 2 && a[0].matches(\"[+-]?\\\\d*(\\\\.\\\\d+)?\")) {\n            double inputVal = lookup(a[1]);\n            if (!Double.isNaN(inputVal)) {\n                double magnitude = Double.parseDouble(a[0]);\n                double meters = magnitude * inputVal;\n                System.out.printf(\"%s %s to: %n%n\", a[0], a[1]);\n                for (String k: keys)\n                    System.out.printf(\"%10s: %g%n\", k, meters / lookup(k));\n                return;\n            }\n        }\n        System.out.println(\"Please provide a number and unit\");\n\n    }\n\n    public static double lookup(String key) {\n        for (int i = 0; i < keys.length; i++)\n            if (keys[i].equals(key))\n                return values[i];\n        return Double.NaN;\n    }\n}\n"}
{"id": 388709, "name": "Test integerness", "source": "Translate Fortran to Java:       MODULE ZERMELO\t\n       CONTAINS\n        LOGICAL FUNCTION ISINTEGRAL(X)\t\n         REAL*8 X\t\n         INTEGER*8 N\t\n          IF (ISNAN(X)) THEN\t\n            ISINTEGRAL = .FALSE.\t\n          ELSE\t\t\t\n            N = KIDINT(X)\t\t\n            ISINTEGRAL = N .EQ. X\t\n          END IF\t\t\n        END FUNCTION ISINTEGRAL\t\n\n        LOGICAL FUNCTION ISINTEGRALZ(Z)\t\n         DOUBLE COMPLEX Z\t\n          ISINTEGRALZ = ISINTEGRAL(DBLE(Z)) .AND. ISINTEGRAL(DIMAG(Z))\t\n        END FUNCTION ISINTEGRALZ\n      END MODULE ZERMELO\t\n\n      PROGRAM TEST\n      USE ZERMELO\n      DOUBLE COMPLEX Z\n\n      WRITE (6,*) \"See if some numbers are integral...\"\n      WRITE (6,*) ISINTEGRAL(666D0),666D0\n      Z = DCMPLX(-3D0,4*ATAN(1D0))\n      WRITE (6,*) ISINTEGRALZ(Z),Z\n      END\n", "target": "import java.math.BigDecimal;\nimport java.util.List;\n\npublic class TestIntegerness {\n    private static boolean isLong(double d) {\n        return isLong(d, 0.0);\n    }\n\n    private static boolean isLong(double d, double tolerance) {\n        return (d - Math.floor(d)) <= tolerance || (Math.ceil(d) - d) <= tolerance;\n    }\n\n    @SuppressWarnings(\"ResultOfMethodCallIgnored\")\n    private static boolean isBigInteger(BigDecimal bd) {\n        try {\n            bd.toBigIntegerExact();\n            return true;\n        } catch (ArithmeticException ex) {\n            return false;\n        }\n    }\n\n    private static class Rational {\n        long num;\n        long denom;\n\n        Rational(int num, int denom) {\n            this.num = num;\n            this.denom = denom;\n        }\n\n        boolean isLong() {\n            return num % denom == 0;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"%s/%s\", num, denom);\n        }\n    }\n\n    private static class Complex {\n        double real;\n        double imag;\n\n        Complex(double real, double imag) {\n            this.real = real;\n            this.imag = imag;\n        }\n\n        boolean isLong() {\n            return TestIntegerness.isLong(real) && imag == 0.0;\n        }\n\n        @Override\n        public String toString() {\n            if (imag >= 0.0) {\n                return String.format(\"%s + %si\", real, imag);\n            }\n            return String.format(\"%s - %si\", real, imag);\n        }\n    }\n\n    public static void main(String[] args) {\n        List<Double> da = List.of(25.000000, 24.999999, 25.000100);\n        for (Double d : da) {\n            boolean exact = isLong(d);\n            System.out.printf(\"%.6f is %s integer%n\", d, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        double tolerance = 0.00001;\n        System.out.printf(\"With a tolerance of\u00a0%.5f:%n\", tolerance);\n        for (Double d : da) {\n            boolean fuzzy = isLong(d, tolerance);\n            System.out.printf(\"%.6f is %s integer%n\", d, fuzzy ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Double> fa = List.of(-2.1e120, -5e-2, Double.NaN, Double.POSITIVE_INFINITY);\n        for (Double f : fa) {\n            boolean exact = !f.isNaN() && !f.isInfinite() && isBigInteger(new BigDecimal(f.toString()));\n            System.out.printf(\"%s is %s integer%n\", f, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Complex> ca = List.of(new Complex(5.0, 0.0), new Complex(5.0, -5.0));\n        for (Complex c : ca) {\n            boolean exact = c.isLong();\n            System.out.printf(\"%s is %s integer%n\", c, exact ? \"an\" : \"not an\");\n        }\n        System.out.println();\n\n        List<Rational> ra = List.of(new Rational(24, 8), new Rational(-5, 1), new Rational(17, 2));\n        for (Rational r : ra) {\n            boolean exact = r.isLong();\n            System.out.printf(\"%s is %s integer%n\", r, exact ? \"an\" : \"not an\");\n        }\n    }\n}\n"}
{"id": 388710, "name": "Linux CPU utilization", "source": "Translate Fortran to Java: Program CPUusage\n    implicit none\n    integer :: ios, i\n    integer :: oldidle, oldsum, sumtimes = 0\n    real :: percent = 0.\n    character(len = 4) lineID \n    integer, dimension(9) :: times = 0\n\n    write(*, *) 'CPU Usage'\n    write(*, *) 'Press Ctrl<C> to end'\n    do while (.true.)\n        open(unit = 7, file = '/proc/stat', status = 'old', action = 'read', iostat = ios)\n        if (ios /= 0) then\n            print *, 'Error opening /proc/stat'\n            stop\n        else\n            read(unit = 7, fmt = *, iostat = ios) lineID, (times(i), i = 1, 9)\n            close(7)\n            if (lineID /= 'cpu ') then\n                print *, 'Error reading /proc/stat'\n                stop\n            end if\n            sumtimes = sum(times)\n            percent = (1. - real((times(4) - oldidle)) / real((sumtimes - oldsum))) * 100.\n            write(*, fmt = '(F6.2,A2)') percent, '%'\n            oldidle = times(4)\n            oldsum = sumtimes\n            call sleep(1)\n        end if\n    end do\nend program CPUusage\n", "target": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.io.RandomAccessFile;\nimport java.text.NumberFormat;\nimport java.time.Duration;\nimport java.util.Timer;\nimport java.util.TimerTask;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws FileNotFoundException {\n        \n        final var period = Duration.ofSeconds(1);\n        new Timer().schedule(new CpuUtilizationTask(), 0, period.toMillis());\n    }\n\n    \n    static class CpuUtilizationTask extends TimerTask {\n\n        private final String STAT_FILE_HEADER = \"cpu  \";\n        private final NumberFormat percentFormatter;\n        private final RandomAccessFile statPointer;\n        long previousIdleTime = 0, previousTotalTime = 0;\n\n        public CpuUtilizationTask() throws FileNotFoundException {\n            this.percentFormatter = NumberFormat.getPercentInstance();\n            percentFormatter.setMaximumFractionDigits(2);\n            var statFile = new File(\"/proc/stat\");\n            \n            this.statPointer = new RandomAccessFile(statFile, \"r\");\n        }\n\n        @Override\n        public void run() {\n\n            try {\n                var values = statPointer.readLine()\n                        .substring(STAT_FILE_HEADER.length())\n                        .split(\" \");\n\n                \n                var idleTime = Long.parseUnsignedLong(values[3]);\n                var totalTime = 0L;\n                for (String value : values) {\n                    totalTime += Long.parseUnsignedLong(value);\n                }\n\n                var idleTimeDelta = idleTime - previousIdleTime;\n                var totalTimeDelta = totalTime - previousTotalTime;\n                var utilization = 1 - ((double) idleTimeDelta) / totalTimeDelta;\n\n                \n                System.out.println(percentFormatter.format(utilization));\n\n                previousIdleTime = idleTime;\n                previousTotalTime = totalTime;\n\n                \n                statPointer.seek(0);\n            } catch (IOException ioException) {\n                ioException.printStackTrace();\n            }\n        }\n\n    }\n}\n"}
{"id": 388711, "name": "Type detection", "source": "Translate Fortran to Java: program input_type_detection_demo\n  implicit none\n\n  type text_block_t\n     character(len = 10000), allocatable :: lines(:)\n  end type text_block_t\n\n  type(text_block_t) :: text_block\n  integer :: i\n\n  call print_text ('Print me.')\n\n  allocate (text_block%lines(1:10))\n  do i = 1, 10\n     write (text_block%lines(i), '(\"i = \", I0)') i\n  end do\n  call print_text (text_block)\n\n  open (100, file = 'type_detection-fortran.f90', action = 'read')\n  call print_text (100)\n  close (100)\n\ncontains\n\n  subroutine print_text (source)\n    class(*), intent(in) :: source\n\n    select type (source)\n\n    type is (character(len = *))\n       \n       write (*, '(A)') source\n\n    class is (text_block_t)\n       \n       block\n         integer :: i\n         do i = lbound (source%lines, 1), ubound (source%lines, 1)\n            write (*, '(A)') trim (source%lines(i))\n         end do\n       end block\n\n    type is (integer)\n       \n       block\n         character(len = 10000) :: line_buffer\n         integer :: stat\n         read (source, '(A)', iostat = stat) line_buffer\n         do while (stat == 0)\n            write (*, '(A)') trim (line_buffer)\n            read (source, '(A)', iostat = stat) line_buffer\n         end do\n       end block\n\n    class default\n       \n       error stop\n\n    end select\n  end subroutine print_text\n\nend program input_type_detection_demo\n", "target": "public class TypeDetection {\n    private static void showType(Object a) {\n        if (a instanceof Integer) {\n            System.out.printf(\"'%s' is an integer\\n\", a);\n        } else if (a instanceof Double) {\n            System.out.printf(\"'%s' is a double\\n\", a);\n        } else if (a instanceof Character) {\n            System.out.printf(\"'%s' is a character\\n\", a);\n        } else {\n            System.out.printf(\"'%s' is some other type\\n\", a);\n        }\n    }\n\n    public static void main(String[] args) {\n        showType(5);\n        showType(7.5);\n        showType('d');\n        showType(true);\n    }\n}\n"}
{"id": 388712, "name": "Selective file copy", "source": "Translate Fortran to Java:       PROGRAM TEST\t\n      TYPE PLACE\n       INTEGER\t\tN\n       CHARACTER*28\tPLACENAME\n       REAL\t\tALTITUDE\n       COMPLEX\t\tLATLONG\n      END TYPE PLACE\n      TYPE HOME\n       CHARACTER*28\tPLACENAME\n       COMPLEX\t\tLATLONG\n      END TYPE HOME\n      TYPE (PLACE) HERE,THERE\t\n      TYPE (HOME) IS\t\t\n      NAMELIST /STUFF/ HERE,THERE,IS\t\n      INTEGER F\t\n      F = 10\t\n\nCreate an example file to show its format.\n      OPEN(F,FILE=\"Test.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\t\n     1 DELIM=\"QUOTE\")\t\n      HERE = PLACE(1,\"Mt. Cook trig.\",20.0,(-41.29980555,174.77629))\t\n      THERE = HERE\t\t\n      THERE.N = 2\t\t\n      IS.PLACENAME = \"Taipou.\"\t\n      IS.LATLONG = (0,0)\t\n      WRITE (F,STUFF)\t\t\n      CLOSE (F)\t\t\t\n      HERE = PLACE(0,\"\",0,(0,0))\n      THERE = HERE\n      IS = HOME(\"\",(0,0))\nCan now read from the file.\n      OPEN(F,FILE=\"Test.txt\",STATUS=\"OLD\",ACTION=\"READ\",\t\n     1 DELIM=\"QUOTE\")\t\n      READ (F,STUFF)\t\t\t\n      IS.PLACENAME = HERE.PLACENAME\t\n      IS.LATLONG = HERE.LATLONG\t\t\n      WRITE (6,*) IS\t\t\t\n      END\n", "target": "import java.io.BufferedWriter;\nimport java.io.FileWriter;\nimport java.io.File;\nimport java.io.IOException;\nimport java.util.Scanner;\n\nclass CopysJ {\n\n  public static void main(String[] args) {\n    String ddname_IN  = \"copys.in.txt\";\n    String ddname_OUT = \"copys.out.txt\";\n    if (args.length >= 1) { ddname_IN  = args[0].length() > 0 ? args[0] : ddname_IN; }\n    if (args.length >= 2) { ddname_OUT = args[1].length() > 0 ? args[1] : ddname_OUT; }\n\n    File dd_IN = new File(ddname_IN);\n    File dd_OUT = new File(ddname_OUT);\n\n    try (\n      Scanner scanner_IN = new Scanner(dd_IN);\n      BufferedWriter writer_OUT = new BufferedWriter(new FileWriter(dd_OUT))\n      ) {\n      String a;\n      String b;\n      String c;\n      String d;\n      String c1;\n      String x = \"XXXXX\";\n      String data_IN;\n      String data_OUT;\n      int ib;\n\n      while (scanner_IN.hasNextLine()) {\n        data_IN = scanner_IN.nextLine();\n        ib = 0;\n        a = data_IN.substring(ib, ib += 5);\n        b = data_IN.substring(ib, ib += 5);\n        c = data_IN.substring(ib, ib += 4);\n        c1=Integer.toHexString(new Byte((c.getBytes())[0]).intValue());\n        if (c1.length()<2) { c1=\"0\" + c1; }\n        data_OUT = a + c1 + x;\n        writer_OUT.write(data_OUT);\n        writer_OUT.newLine();\n        System.out.println(data_IN);\n        System.out.println(data_OUT);\n        System.out.println();\n      }\n    }\n    catch (IOException ex) {\n      ex.printStackTrace();\n    }\n    return;\n  }\n}\n"}
{"id": 388713, "name": "Find largest left truncatable prime in a given base", "source": "Translate Fortran to Java:       USE PRIMEBAG\t\nCalculates the largest \"left-truncatable\" digit sequence that is a prime number, in various bases.\n      INTEGER LBASE,MANY,ENUFF\t\n      PARAMETER (LBASE = 13, MANY = 66666, ENUFF = 66)\n      INTEGER NS,START(LBASE)\t\n      INTEGER NH,LH\t\t\n      INTEGER N,HORDEN(MANY)\t\t\n      INTEGER*1 HORDED(ENUFF,MANY)\t\n      INTEGER B,D,DB\t\n      INTEGER L\t\t\n      INTEGER P\t\t\n      INTEGER I\t\t\n\n      MSG = 6\t\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n      NS = 0\t\n      P = 1\t\n    1 P = NEXTPRIME(P)\t\n      IF (P.LE.LBASE) THEN\t\n        NS = NS + 1\t\t\n        START(NS) = P\t\t\n        GO TO 1\t\t\t\n      END IF\t\t\n      WRITE (MSG,2) LBASE,NS,START(1:NS)\t\n    2 FORMAT (\"Working in bases 3 to \",I0,\" there are \",I0,\t\n     * \" single-digit primes: \",666(I0:\", \"))\t\n      WRITE (MSG,3)\t\t\n    3 FORMAT (/\"Base Digits Count Max. Value = (in base)\")\n\n   10 DO B = 3,LBASE\t\n        NH = 0\t\t\t\n        DO I = 1,NS\t\t\n          IF (START(I).GE.B) EXIT\t\n          NH = NH + 1\t\t\t\n          HORDEN(NH) = START(I)\t\t\n          HORDED(1,NH) = START(I)\t\n        END DO\t\t\t\n        L = 0\t\n        DB = 1\t\n\n   20   L = L + 1\t\n        IF (L.GE.ENUFF) STOP \"Too many digits\n        DB = DB*B\t\n        IF (DB.LE.0) GO TO 29\t\n        LH = NH\t\t\n        DO I = 1,LH\t\n          N = HORDEN(I)\t\n          DO D = 1,B - 1\t\n            P = D*DB + N\t\t\n            IF (P.LE.0) GO TO 29\t\n            IF (ISPRIME(P)) THEN\t\n              IF (NH.GE.MANY) STOP \"Too many sequences\n              NH = NH + 1\t\t\t\n              HORDEN(NH) = P\t\t\t\n              HORDED(1:L,NH) = HORDED(1:L,I)\t\n              HORDED(L + 1,NH) = D\t\t\n            END IF\t\t\t\n          END DO\t\t\n        END DO\t\n\n        N = NH - LH\t\t\n        IF (N.GT.0) THEN\t\n          DO I = 1,MIN(LH,N)\t\t\n            HORDEN(I) = HORDEN(NH)\t\t\n            HORDED(1:L + 1,I) = HORDED(1:L + 1,NH)\t\n            NH = NH - 1\t\t\t\t\n          END DO\t\t\t\n          NH = N\t\t\t\n          LH = NH\t\t\t\n          GO TO 20\t\t\t\n        END IF\t\t\t\n        GO TO 30\t\t\n   29   WRITE (MSG,28) B,L,NH,DB,P\t\n   28   FORMAT (I4,I7,I6,28X,\"Integer overflow\n        CYCLE\t\t\t\n\n   30   I = MAXLOC(HORDEN(1:NH),DIM = 1)\t\n        WRITE (MSG,31) B,L,NH,HORDEN(I),HORDED(L:1:-1,I)\t\n   31   FORMAT (I4,I7,I6,I11,\" = \"666(I0:\".\"))\t\n\n      END DO\t\t\n      END\t\n", "target": "import java.math.BigInteger;\nimport java.util.*;\n\nclass LeftTruncatablePrime\n{\n  private static List<BigInteger> getNextLeftTruncatablePrimes(BigInteger n, int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> probablePrimes = new ArrayList<BigInteger>();\n    String baseString = n.equals(BigInteger.ZERO) ? \"\" : n.toString(radix);\n    for (int i = 1; i < radix; i++)\n    {\n      BigInteger p = new BigInteger(Integer.toString(i, radix) + baseString, radix);\n      if (p.isProbablePrime(millerRabinCertainty))\n        probablePrimes.add(p);\n    }\n    return probablePrimes;\n  }\n  \n  public static BigInteger getLargestLeftTruncatablePrime(int radix, int millerRabinCertainty)\n  {\n    List<BigInteger> lastList = null;\n    List<BigInteger> list = getNextLeftTruncatablePrimes(BigInteger.ZERO, radix, millerRabinCertainty);\n    while (!list.isEmpty())\n    {\n      lastList = list;\n      list = new ArrayList<BigInteger>();\n      for (BigInteger n : lastList)\n        list.addAll(getNextLeftTruncatablePrimes(n, radix, millerRabinCertainty));\n    }\n    if (lastList == null)\n      return null;\n    Collections.sort(lastList);\n    return lastList.get(lastList.size() - 1);\n  }\n  \n  public static void main(String[] args)\n  {\n    if (args.length != 2) {\n      System.err.println(\"There must be exactly two command line arguments.\");\n      return;\n    }\n    int maxRadix;\n    try {\n      maxRadix = Integer.parseInt(args[0]);\n      if (maxRadix < 3) throw new NumberFormatException(); \n    } catch (NumberFormatException e) {\n      System.err.println(\"Radix must be an integer greater than 2.\");\n      return;\n    }\n    int millerRabinCertainty;\n    try {\n      millerRabinCertainty = Integer.parseInt(args[1]);\n    } catch (NumberFormatException e) {\n      System.err.println(\"Miiller-Rabin Certainty must be an integer.\");\n      return;\n    }  \n    for (int radix = 3; radix <= maxRadix; radix++)\n    {\n      BigInteger largest = getLargestLeftTruncatablePrime(radix, millerRabinCertainty);\n      System.out.print(\"n=\" + radix + \": \");\n      if (largest == null)\n        System.out.println(\"No left-truncatable prime\");\n      else\n        System.out.println(largest + \" (in base \" + radix + \"): \" + largest.toString(radix));\n    }\n  }\n  \n}\n"}
{"id": 388714, "name": "24 game_Solve", "source": "Translate Fortran to Java: program solve_24\n  use helpers\n  implicit none\n  real                 :: vector(4), reals(4), p, q, r, s\n  integer              :: numbers(4), n, i, j, k, a, b, c, d\n  character, parameter :: ops(4) = (/ '+', '-', '*', '/' /)\n  logical              :: last\n  real,parameter       :: eps = epsilon(1.0)\n\n  do n=1,12\n    call random_number(vector)\n    reals   = 9 * vector + 1\n    numbers = int(reals)\n    call Insertion_Sort(numbers)\n    \n    permutations: do\n      a = numbers(1); b = numbers(2); c = numbers(3); d = numbers(4)\n      reals = real(numbers)\n      p = reals(1);   q = reals(2);   r = reals(3);   s = reals(4)\n      \n      do i=1,4\n        do j=1,4\n          do k=1,4\n            if      ( abs(op(op(op(p,i,q),j,r),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '((',a,ops(i),b,')',ops(j),c,')',ops(k),d\n              exit permutations\n            else if ( abs(op(op(p,i,op(q,j,r)),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),'(',b,ops(j),c,'))',ops(k),d\n              exit permutations\n            else if ( abs(op(p,i,op(op(q,j,r),k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'((',b,ops(j),c,')',ops(k),d,')'\n              exit permutations\n            else if ( abs(op(p,i,op(q,j,op(r,k,s)))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'(',b,ops(j),'(',c,ops(k),d,'))'\n              exit permutations\n            else if ( abs(op(op(p,i,q),j,op(r,k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),b,')',ops(j),'(',c,ops(k),d,')'\n              exit permutations\n            end if\n          end do\n        end do\n      end do\n      call nextpermutation(numbers,last)  \n      if ( last ) then\n        write (*,*) numbers, '\u00a0: no solution.'\n        exit permutations\n      end if\n    end do permutations\n\n  end do\n\ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in)    :: x,y\n    select case ( ops(c) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n\nend program solve_24\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 388715, "name": "24 game_Solve", "source": "Translate Fortran to Java: program solve_24\n  use helpers\n  implicit none\n  real                 :: vector(4), reals(4), p, q, r, s\n  integer              :: numbers(4), n, i, j, k, a, b, c, d\n  character, parameter :: ops(4) = (/ '+', '-', '*', '/' /)\n  logical              :: last\n  real,parameter       :: eps = epsilon(1.0)\n\n  do n=1,12\n    call random_number(vector)\n    reals   = 9 * vector + 1\n    numbers = int(reals)\n    call Insertion_Sort(numbers)\n    \n    permutations: do\n      a = numbers(1); b = numbers(2); c = numbers(3); d = numbers(4)\n      reals = real(numbers)\n      p = reals(1);   q = reals(2);   r = reals(3);   s = reals(4)\n      \n      do i=1,4\n        do j=1,4\n          do k=1,4\n            if      ( abs(op(op(op(p,i,q),j,r),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '((',a,ops(i),b,')',ops(j),c,')',ops(k),d\n              exit permutations\n            else if ( abs(op(op(p,i,op(q,j,r)),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),'(',b,ops(j),c,'))',ops(k),d\n              exit permutations\n            else if ( abs(op(p,i,op(op(q,j,r),k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'((',b,ops(j),c,')',ops(k),d,')'\n              exit permutations\n            else if ( abs(op(p,i,op(q,j,op(r,k,s)))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'(',b,ops(j),'(',c,ops(k),d,'))'\n              exit permutations\n            else if ( abs(op(op(p,i,q),j,op(r,k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),b,')',ops(j),'(',c,ops(k),d,')'\n              exit permutations\n            end if\n          end do\n        end do\n      end do\n      call nextpermutation(numbers,last)  \n      if ( last ) then\n        write (*,*) numbers, '\u00a0: no solution.'\n        exit permutations\n      end if\n    end do permutations\n\n  end do\n\ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in)    :: x,y\n    select case ( ops(c) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n\nend program solve_24\n", "target": "import java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n"}
{"id": 388716, "name": "Doubly-linked list_Definition", "source": "Translate Fortran to Java: module dlist\n  implicit none\n  type node\n     type(node), pointer :: next => null()\n     type(node), pointer :: prev => null()\n     integer :: data\n  end type node\n\n  type dll\n     type(node), pointer :: head => null()\n     type(node), pointer :: tail => null()\n     integer :: num_nodes = 0\n  end type dll\n\n  public  :: node, dll, append, prepend, insert, dump, reverse_dump, tidy\n  private :: init\n\ncontains\n  \n  elemental type(dll) function new_dll()\n    new_dll = dll(null(),null(),0)\n    return\n  end function new_dll\n\n  \n  elemental subroutine append(dl2, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: value\n\n    type(node), pointer :: np\n\n    \n    if (dl2%num_nodes == 0) then\n       call init(dl2, value)\n       return\n    end if\n\n    \n    dl2%num_nodes = dl2%num_nodes + 1\n    np => dl2%tail\n    allocate(dl2%tail)\n    dl2%tail%data = value\n    dl2%tail%prev => np\n    dl2%tail%prev%next => dl2%tail\n  end subroutine append\n\n  \n  elemental subroutine prepend(dl2, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: value\n\n    type(node), pointer :: np\n\n    if (dl2%num_nodes == 0) then\n       call init(dl2, value)\n       return\n    end if\n\n    dl2%num_nodes = dl2%num_nodes + 1\n    np => dl2%head\n    allocate(dl2%head)\n    dl2%head%data = value\n    dl2%head%next => np\n    dl2%head%next%prev => dl2%head\n  end subroutine prepend\n\n  \n  elemental subroutine insert(dl2, index, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: index\n    integer, intent(in)      :: value\n\n    type(node), pointer :: element\n    type(node), pointer :: np1, np2\n    integer             :: i\n\n    if (dl2%num_nodes == 0) then\n       call init(dl2, value)\n       return\n    end if\n\n    \n    if (index > dl2%num_nodes) then\n       call append(dl2, value)\n       return\n    end if\n\n    \n    if (index <= 1) then\n       call prepend(dl2, value)\n       return\n    end if\n\n    \n    np1 => dl2%head\n    do i=1, index-2\n       np1 => np1%next\n    end do\n    np2 => np1%next\n\n    \n    allocate(element)\n    element%data = value\n\n    \n    element%prev => np1\n    element%next => np2\n    np1%next => element\n    np2%prev => element\n    dl2%num_nodes = dl2%num_nodes + 1\n  end subroutine insert\n\n  subroutine dump(dl2)\n    type(dll), intent(in) :: dl2\n    type(node), pointer :: current\n    integer :: i\n\n    write(*,fmt='(a,i0,a)',advance='no') 'Doubly-linked list has ',dl2%num_nodes,' element - fwd = '\n    current => dl2%head\n    i = 1\n    write(*,fmt='(i0,a)',advance='no') current%data,', '\n    do\n       current => current%next\n       if (.not. associated(current)) then\n          exit\n       end if\n       i = i + 1\n       if (i == dl2%num_nodes) then\n          write(*,'(i0)') current%data\n       else\n          write(*,fmt='(i0,a)',advance='no') current%data,', '\n       end if\n    end do\n  end subroutine dump\n\n  subroutine reverse_dump(dl2)\n    type(dll), intent(in) :: dl2\n    type(node), pointer :: current\n    integer :: i\n\n    write(*,fmt='(a,i0,a)',advance='no') 'Doubly-linked list has ',dl2%num_nodes,' element - bwd = '\n    current => dl2%tail\n    write(*,fmt='(i0,a)',advance='no') current%data,', '\n    i = 1\n    do\n       current => current%prev\n       if (.not. associated(current)) then\n          exit\n       end if\n       i = i + 1\n       if (i == dl2%num_nodes) then\n          write(*,'(i0)') current%data\n       else\n          write(*,fmt='(i0,a)',advance='no') current%data,', '\n       end if\n    end do\n  end subroutine reverse_dump\n\n  \n  elemental subroutine tidy(dl2)\n    type(dll), intent(inout) :: dl2\n    type(node), pointer :: current, last\n\n    current => dl2%head\n    do\n       last => current\n       current => current%next\n       if (associated(last)) then\n          deallocate(last)\n       end if\n       if (associated(current, dl2%tail)) then\n          deallocate(current)\n          exit\n       end if\n    end do\n  end subroutine tidy\n\n  elemental subroutine init(dl2, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: value\n    allocate(dl2%head)\n    dl2%tail => dl2%head\n    dl2%tail%data = value\n    dl2%num_nodes = 1\n    return\n  end subroutine init\n\nend module dlist\n\nprogram dl\n  use dlist\n  implicit none\n\n  type(dll) :: mydll\n\n  mydll = new_dll()\n  call append(mydll, 5)\n  call append(mydll, 7)\n  call prepend(mydll, 3)\n  call prepend(mydll, 1)\n  call insert(mydll, 3, 4)\n  call dump(mydll)\n\n  call reverse_dump(mydll)\n\n  call tidy(mydll)\nend program dl\n", "target": "import java.util.LinkedList;\n\npublic class DoublyLinkedList {\n   \n    public static void main(String[] args) {\n        LinkedList<String> list = new LinkedList<String>();\n        list.addFirst(\"Add First\");\n        list.addLast(\"Add Last 1\");\n        list.addLast(\"Add Last 2\");\n        list.addLast(\"Add Last 1\");\n        traverseList(list);\n        \n        list.removeFirstOccurrence(\"Add Last 1\");\n        traverseList(list);\n    }\n    \n    private static void traverseList(LinkedList<String> list) {\n        System.out.println(\"Traverse List:\");\n        for ( int i = 0 ; i < list.size() ; i++ ) {\n            System.out.printf(\"Element number %d - Element value = '%s'%n\", i, list.get(i));\n        }\n        System.out.println();\n    }\n    \n}\n"}
{"id": 388717, "name": "Special variables", "source": "Translate Fortran to Java:            INQUIRE(FILE = FILENAME(1:L),EXIST = EXIST,\t\n     1      ERR = 666,IOSTAT = IOSTAT) \t\t\n           IF (EXIST) THEN\t\n           ...etc.\n", "target": "import java.util.Arrays;\n\npublic class SpecialVariables {\n\n    public static void main(String[] args) {\n\n        \n        \n        System.out.println(Arrays.toString(args));\n\n        \n        \n        System.out.println(SpecialVariables.class);\n\n\n        \n\n        \n        System.out.println(System.getenv());\n\n        \n        \n        System.out.println(System.getProperties());\n\n        \n        \n        System.out.println(Runtime.getRuntime().availableProcessors());\n\n    }\n}\n"}
{"id": 388718, "name": "Sequence of primorial primes", "source": "Translate Fortran to Java:       PROGRAM PRIMORIALP\t\n      USE PRIMEBAG\t\t\n      USE BIGNUMBERS\t\t\n      TYPE(BIGNUM) B\t\t\n      INTEGER MAXF\t\t\n      PARAMETER (MAXF = 18000000)\t\n      INTEGER I\t\t\t\n      INTEGER FU,FD\t\t\n      INTEGER NHIT,HIT(666)\t\n      CHARACTER*4 WOT\t\t\n      CHARACTER*66 ALINE\t\n      REAL T0,T1\t\t\n      MSG = 6\t\n      WRITE (MSG,1) BIGLIMIT,BIGBASE,HUGE(I)\t\n    1 FORMAT ('Calculates primorial \"primes\"',/,\n     1 \"A primorial prime is a value N such that\",/,\n     2 \"    Primorial(N) - 1 is prime, OR\",/,\n     3 \"    Primorial(N) + 1 is prime, or both.\",/,\n     4 \"and Primorial(N) is the product of the first N prime numbers.\",/\n     5 \"Working with up to \",I0,\" digits in base \",I0,\".\"/\n     6 \"The integer limit is \",I0,/)\n\nc      CALL PREPARE PRIMES\t\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n      WRITE (MSG,2)\n    2 FORMAT (\"Primorial#\",3X,\"Approx.\",8X,\" -1 Factor +1 Factor Hit\")\n\nCommence prime mashing.\n  100 NHIT = 0\t\t\n      B.LAST = 1\t\n      B.DIGIT(1) = 1\t\n      CALL CPU_TIME(T0)\t\n      DO I = 1,30\t\n        CALL BIGMULTN(B,PRIME(I))\t\nc        WRITE (MSG,101) I,PRIME(I),I,B.DIGIT(B.LAST:1:-1)\t\n  101   FORMAT (\"Prime(\",I0,\") = \",I0,\", Primorial(\",I0,\") = \",\t\n     1   I0,9I<BIGORDER>.<BIGORDER>,/,(10I<BIGORDER>.<BIGORDER>))\t\n        FU = -1\t\t\n        FD = -1\t\t\n        CALL BIGADDN(B,+1)\t\n        FU = BIGFACTOR(B,MAXF)\t\n        CALL BIGADDN(B,-2)\t\n        IF (FU.NE.1) FD = BIGFACTOR(B,MAXF)\t\n        IF (FU.EQ.1 .OR. FD.EQ.1) THEN\t\n          WOT = \"Yes\n          NHIT = NHIT + 1\t\t\t\n          HIT(NHIT) = I\t\t\t\t\n        ELSE IF (FU.GT.1 .AND. FD.GT.1) THEN\t\n          WOT = \"No.\"\t\t\t\t\n        ELSE\t\t\t\t\n          WOT = \"?\"\t\t\t\t\n        END IF\t\t\t\t\n        CALL BIGADDN(B,1)\t\t\n        WRITE (ALINE,102) I,BIGVALUE(B),FD,FU,WOT\t\n  102   FORMAT (I10,1PE18.10,I10,I10,1X,A)\t\n        IF (FD.EQ.-1) ALINE(37:38) = \"\"\t\t\n        IF (FD.EQ. 0) ALINE(38:38) = \"?\"\t\n        IF (FU.EQ. 0) ALINE(48:48) = \"?\"\t\n        WRITE (MSG,\"(A)\") ALINE\t\t\n      END DO\t\t\n      CALL CPU_TIME(T1)\t\n\nCast forth some pearls.\n      WRITE (MSG,201) HIT(1:NHIT)\t\n  201 FORMAT (/,\"Hit list: \",I0,666(\",\",I0:))\t\n      WRITE (MSG,*) \"CPU time:\",T1 - T0\t\n      END\t\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialPrimes {\n\n    final static int sieveLimit = 1550_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n\n        int count = 0;\n        for (int i = 1; i < 1000_000 && count < 20; i++) {\n            BigInteger b = primorial(i);\n            if (b.add(BigInteger.ONE).isProbablePrime(1)\n                    || b.subtract(BigInteger.ONE).isProbablePrime(1)) {\n                System.out.printf(\"%d \", i);\n                count++;\n            }\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 388719, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Fortran to Java: program CalcPi\n    \n    use iso_fortran_env, only: rf => real128\n    implicit none\n    real(rf) :: a,g,s,old_pi,new_pi\n    real(rf) :: a1,g1,s1\n    integer :: k,k1,i\n\n    old_pi = 0.0_rf;\n    a = 1.0_rf; g = 1.0_rf/sqrt(2.0_rf); s = 0.0_rf; k = 0\n\n    do i=1,100\n        call approx_pi_step(a,g,s,k,a1,g1,s1,k1)\n        new_pi = 4.0_rf * (a1**2.0_rf) / (1.0_rf - s1)\n        if (abs(new_pi - old_pi).lt.(2.0_rf*epsilon(new_pi))) then\n            \n            \n            exit\n        end if\n        write(*,*) 'Iteration:',k1,' Diff:',abs(new_pi - old_pi),' Pi:',new_pi\n        old_pi = new_pi\n        a = a1; g = g1; s = s1; k = k1\n    end do\n\n    contains\n\n    subroutine approx_pi_step(x,y,z,n,a,g,s,k)\n        real(rf), intent(in) :: x,y,z\n        integer, intent(in) :: n\n        real(rf), intent(out) :: a,g,s\n        integer, intent(out) :: k\n\n        a = 0.5_rf*(x+y)\n        g = sqrt(x*y)\n        k = n + 1\n        s = z + (2.0_rf)**(real(k)+1.0_rf) * (a**(2.0_rf) - g**(2.0_rf))\n    end subroutine\nend program CalcPi\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 388720, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Fortran to Java: program CalcPi\n    \n    use iso_fortran_env, only: rf => real128\n    implicit none\n    real(rf) :: a,g,s,old_pi,new_pi\n    real(rf) :: a1,g1,s1\n    integer :: k,k1,i\n\n    old_pi = 0.0_rf;\n    a = 1.0_rf; g = 1.0_rf/sqrt(2.0_rf); s = 0.0_rf; k = 0\n\n    do i=1,100\n        call approx_pi_step(a,g,s,k,a1,g1,s1,k1)\n        new_pi = 4.0_rf * (a1**2.0_rf) / (1.0_rf - s1)\n        if (abs(new_pi - old_pi).lt.(2.0_rf*epsilon(new_pi))) then\n            \n            \n            exit\n        end if\n        write(*,*) 'Iteration:',k1,' Diff:',abs(new_pi - old_pi),' Pi:',new_pi\n        old_pi = new_pi\n        a = a1; g = g1; s = s1; k = k1\n    end do\n\n    contains\n\n    subroutine approx_pi_step(x,y,z,n,a,g,s,k)\n        real(rf), intent(in) :: x,y,z\n        integer, intent(in) :: n\n        real(rf), intent(out) :: a,g,s\n        integer, intent(out) :: k\n\n        a = 0.5_rf*(x+y)\n        g = sqrt(x*y)\n        k = n + 1\n        s = z + (2.0_rf)**(real(k)+1.0_rf) * (a**(2.0_rf) - g**(2.0_rf))\n    end subroutine\nend program CalcPi\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.util.Objects;\n\npublic class Calculate_Pi {\n    private static final MathContext con1024 = new MathContext(1024);\n    private static final BigDecimal bigTwo = new BigDecimal(2);\n    private static final BigDecimal bigFour = new BigDecimal(4);\n\n    private static BigDecimal bigSqrt(BigDecimal bd, MathContext con) {\n        BigDecimal x0 = BigDecimal.ZERO;\n        BigDecimal x1 = BigDecimal.valueOf(Math.sqrt(bd.doubleValue()));\n        while (!Objects.equals(x0, x1)) {\n            x0 = x1;\n            x1 = bd.divide(x0, con).add(x0).divide(bigTwo, con);\n        }\n        return x1;\n    }\n\n    public static void main(String[] args) {\n        BigDecimal a = BigDecimal.ONE;\n        BigDecimal g = a.divide(bigSqrt(bigTwo, con1024), con1024);\n        BigDecimal t;\n        BigDecimal sum = BigDecimal.ZERO;\n        BigDecimal pow = bigTwo;\n        while (!Objects.equals(a, g)) {\n            t = a.add(g).divide(bigTwo, con1024);\n            g = bigSqrt(a.multiply(g), con1024);\n            a = t;\n            pow = pow.multiply(bigTwo);\n            sum = sum.add(a.multiply(a).subtract(g.multiply(g)).multiply(pow));\n        }\n        BigDecimal pi = bigFour.multiply(a.multiply(a)).divide(BigDecimal.ONE.subtract(sum), con1024);\n        System.out.println(pi);\n    }\n}\n"}
{"id": 388721, "name": "Primorial numbers", "source": "Translate Fortran to Java:       B.DIGIT(I) = MOD(D,BIGBASE)\n      C = D/BIGBASE\n", "target": "import java.math.BigInteger;\n\npublic class PrimorialNumbers {\n    final static int sieveLimit = 1300_000;\n    static boolean[] notPrime = sieve(sieveLimit);\n\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++)\n            System.out.printf(\"primorial(%d): %d%n\", i, primorial(i));\n\n        for (int i = 1; i < 6; i++) {\n            int len = primorial((int) Math.pow(10, i)).toString().length();\n            System.out.printf(\"primorial(10^%d) has length %d%n\", i, len);\n        }\n    }\n\n    static BigInteger primorial(int n) {\n        if (n == 0)\n            return BigInteger.ONE;\n\n        BigInteger result = BigInteger.ONE;\n        for (int i = 0; i < sieveLimit && n > 0; i++) {\n            if (notPrime[i])\n                continue;\n            result = result.multiply(BigInteger.valueOf(i));\n            n--;\n        }\n        return result;\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 388722, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Fortran to Java: \n\n\n\nprogram gauss\n  implicit none\n  integer, parameter :: p = 16 \n  integer            :: n = 10, k\n  real(kind=p), allocatable :: r(:,:)\n  real(kind=p)       :: z, a, b, exact\n  do n = 1,20\n    a = -3; b = 3\n    r = gaussquad(n)\n    z = (b-a)/2*dot_product(r(2,:),exp((a+b)/2+r(1,:)*(b-a)/2))\n    exact = exp(3.0_p)-exp(-3.0_p)\n    print \"(i0,1x,g0,1x,g10.2)\",n, z, z-exact\n  end do\n  \n  contains \n\n  function gaussquad(n) result(r)\n  integer                 :: n\n  real(kind=p), parameter :: pi = 4*atan(1._p)\n  real(kind=p)            :: r(2, n), x, f, df, dx\n  integer                 :: i,  iter\n  real(kind = p), allocatable :: p0(:), p1(:), tmp(:)\n  \n  p0 = [1._p]\n  p1 = [1._p, 0._p]\n  \n  do k = 2, n\n     tmp = ((2*k-1)*[p1,0._p]-(k-1)*[0._p, 0._p,p0])/k\n     p0 = p1; p1 = tmp\n  end do\n  do i = 1, n\n    x = cos(pi*(i-0.25_p)/(n+0.5_p))\n    do iter = 1, 10\n      f = p1(1); df = 0._p\n      do k = 2, size(p1)\n        df = f + x*df\n        f  = p1(k) + x * f\n      end do\n      dx =  f / df\n      x = x - dx\n      if (abs(dx)<10*epsilon(dx)) exit\n    end do\n    r(1,i) = x\n    r(2,i) = 2/((1-x**2)*df**2)\n  end do\n  end function\nend program\n", "target": "import static java.lang.Math.*;\nimport java.util.function.Function;\n\npublic class Test {\n    final static int N = 5;\n\n    static double[] lroots = new double[N];\n    static double[] weight = new double[N];\n    static double[][] lcoef = new double[N + 1][N + 1];\n\n    static void legeCoef() {\n        lcoef[0][0] = lcoef[1][1] = 1;\n\n        for (int n = 2; n <= N; n++) {\n\n            lcoef[n][0] = -(n - 1) * lcoef[n - 2][0] / n;\n\n            for (int i = 1; i <= n; i++) {\n                lcoef[n][i] = ((2 * n - 1) * lcoef[n - 1][i - 1]\n                        - (n - 1) * lcoef[n - 2][i]) / n;\n            }\n        }\n    }\n\n    static double legeEval(int n, double x) {\n        double s = lcoef[n][n];\n        for (int i = n; i > 0; i--)\n            s = s * x + lcoef[n][i - 1];\n        return s;\n    }\n\n    static double legeDiff(int n, double x) {\n        return n * (x * legeEval(n, x) - legeEval(n - 1, x)) / (x * x - 1);\n    }\n\n    static void legeRoots() {\n        double x, x1;\n        for (int i = 1; i <= N; i++) {\n            x = cos(PI * (i - 0.25) / (N + 0.5));\n            do {\n                x1 = x;\n                x -= legeEval(N, x) / legeDiff(N, x);\n            } while (x != x1);\n\n            lroots[i - 1] = x;\n\n            x1 = legeDiff(N, x);\n            weight[i - 1] = 2 / ((1 - x * x) * x1 * x1);\n        }\n    }\n\n    static double legeInte(Function<Double, Double> f, double a, double b) {\n        double c1 = (b - a) / 2, c2 = (b + a) / 2, sum = 0;\n        for (int i = 0; i < N; i++)\n            sum += weight[i] * f.apply(c1 * lroots[i] + c2);\n        return c1 * sum;\n    }\n\n    public static void main(String[] args) {\n        legeCoef();\n        legeRoots();\n\n        System.out.print(\"Roots: \");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", lroots[i]);\n\n        System.out.print(\"\\nWeight:\");\n        for (int i = 0; i < N; i++)\n            System.out.printf(\" %f\", weight[i]);\n\n        System.out.printf(\"%nintegrating Exp(x) over [-3, 3]:%n\\t%10.8f,%n\"\n                + \"compared to actual%n\\t%10.8f%n\",\n                legeInte(x -> exp(x), -3, 3), exp(3) - exp(-3));\n    }\n}\n"}
{"id": 388723, "name": "Chaos game", "source": "Translate Fortran to Java: PROGRAM CHAOS\n IMPLICIT NONE\n REAL, DIMENSION(3):: KA, KN \n REAL, DIMENSION(3):: DA, DB, DC \n INTEGER:: I, Z\n INTEGER, PARAMETER:: UT = 17\n \n DA = (/    0., 0.,   0. /)\n DB = (/  600., 0.,   0. /)\n DC = (/  500., 0., 400. /)\n \n KA = (/  500., 0., 100. /)\n OPEN (UNIT = UT, FILE = 'aus.csv')\n DO I=1, 1000000\n  Z = ZAHL()\n  WRITE (UT, '(3(F12.6, \";\"))') KA\n  SELECT CASE (Z)\n   CASE (1)\n    CALL MITTELP(KA, DA, KN)\n   CASE (2)\n    CALL MITTELP(KA, DB, KN)\n   CASE (3)\n    CALL MITTELP(KA, DC, KN)\n  END SELECT\n  KA = KN\n END DO\n CLOSE (UT)\n CONTAINS\n  \n  SUBROUTINE MITTELP(P1, P2, MP)\n   REAL, INTENT(IN), DIMENSION(3):: P1, P2\n   REAL, INTENT(OUT), DIMENSION(3):: MP\n   MP = (P1 + P2) / 2.\n  END SUBROUTINE MITTELP\n  \n  INTEGER FUNCTION ZAHL()\n   REAL:: ZZ\n   CALL RANDOM_NUMBER(ZZ)\n   ZZ = ZZ * 3.\n   ZAHL = FLOOR(ZZ) + 1\n   IF (ZAHL .GT. 3) ZAHL = 3\n  END FUNCTION ZAHL\nEND PROGRAM CHAOS\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 388724, "name": "Chaos game", "source": "Translate Fortran to Java: PROGRAM CHAOS\n IMPLICIT NONE\n REAL, DIMENSION(3):: KA, KN \n REAL, DIMENSION(3):: DA, DB, DC \n INTEGER:: I, Z\n INTEGER, PARAMETER:: UT = 17\n \n DA = (/    0., 0.,   0. /)\n DB = (/  600., 0.,   0. /)\n DC = (/  500., 0., 400. /)\n \n KA = (/  500., 0., 100. /)\n OPEN (UNIT = UT, FILE = 'aus.csv')\n DO I=1, 1000000\n  Z = ZAHL()\n  WRITE (UT, '(3(F12.6, \";\"))') KA\n  SELECT CASE (Z)\n   CASE (1)\n    CALL MITTELP(KA, DA, KN)\n   CASE (2)\n    CALL MITTELP(KA, DB, KN)\n   CASE (3)\n    CALL MITTELP(KA, DC, KN)\n  END SELECT\n  KA = KN\n END DO\n CLOSE (UT)\n CONTAINS\n  \n  SUBROUTINE MITTELP(P1, P2, MP)\n   REAL, INTENT(IN), DIMENSION(3):: P1, P2\n   REAL, INTENT(OUT), DIMENSION(3):: MP\n   MP = (P1 + P2) / 2.\n  END SUBROUTINE MITTELP\n  \n  INTEGER FUNCTION ZAHL()\n   REAL:: ZZ\n   CALL RANDOM_NUMBER(ZZ)\n   ZZ = ZZ * 3.\n   ZAHL = FLOOR(ZZ) + 1\n   IF (ZAHL .GT. 3) ZAHL = 3\n  END FUNCTION ZAHL\nEND PROGRAM CHAOS\n", "target": "import java.awt.*;\nimport java.awt.event.*;\nimport java.util.*;\nimport javax.swing.*;\nimport javax.swing.Timer;\n\npublic class ChaosGame extends JPanel {\n    static class ColoredPoint extends Point {\n        int colorIndex;\n\n        ColoredPoint(int x, int y, int idx) {\n            super(x, y);\n            colorIndex = idx;\n        }\n    }\n\n    Stack<ColoredPoint> stack = new Stack<>();\n    Point[] points = new Point[3];\n    Color[] colors = {Color.red, Color.green, Color.blue};\n    Random r = new Random();\n\n    public ChaosGame() {\n        Dimension dim = new Dimension(640, 640);\n        setPreferredSize(dim);\n        setBackground(Color.white);\n\n        int margin = 60;\n        int size = dim.width - 2 * margin;\n\n        points[0] = new Point(dim.width / 2, margin);\n        points[1] = new Point(margin, size);\n        points[2] = new Point(margin + size, size);\n\n        stack.push(new ColoredPoint(-1, -1, 0));\n\n        new Timer(10, (ActionEvent e) -> {\n            if (stack.size() < 50_000) {\n                for (int i = 0; i < 1000; i++)\n                    addPoint();\n                repaint();\n            }\n        }).start();\n    }\n\n    private void addPoint() {\n        try {\n            int colorIndex = r.nextInt(3);\n            Point p1 = stack.peek();\n            Point p2 = points[colorIndex];\n            stack.add(halfwayPoint(p1, p2, colorIndex));\n        } catch (EmptyStackException e) {\n            e.printStackTrace();\n        }\n    }\n\n    void drawPoints(Graphics2D g) {\n        for (ColoredPoint p : stack) {\n            g.setColor(colors[p.colorIndex]);\n            g.fillOval(p.x, p.y, 1, 1);\n        }\n    }\n\n    ColoredPoint halfwayPoint(Point a, Point b, int idx) {\n        return new ColoredPoint((a.x + b.x) / 2, (a.y + b.y) / 2, idx);\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPoints(g);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Chaos Game\");\n            f.setResizable(false);\n            f.add(new ChaosGame(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n"}
{"id": 388725, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Fortran to Java:       MODULE COMPILER\t\n       INTEGER KBD,MSG\t\t\n\n       INTEGER ENUFF\t\t\n       PARAMETER (ENUFF = 66)\t\n       CHARACTER*(ENUFF) RP\t\n       INTEGER LR\t\t\n\n       INTEGER\t\tOPSYMBOLS\t\t\n       PARAMETER\t(OPSYMBOLS = 11)\t\n       TYPE SYMB\t\t\n        CHARACTER*1\tIS\t\t\n        INTEGER*1\tPRECEDENCE\t\n        CHARACTER*48\tUSAGE\t\t\n       END TYPE SYMB\t\t\n       TYPE(SYMB) SYMBOL(0:OPSYMBOLS)\t\n       PARAMETER (SYMBOL =(/\t\n     o  SYMB(\" \", 0,\"Not recognised as an operator's symbol.\"),\n     1  SYMB(\" \", 1,\"separates symbols and aids legibility.\"),\n     2  SYMB(\")\", 4,\"opened with ( to bracket a sub-expression.\"),\n     3  SYMB(\"]\", 4,\"opened with [ to bracket a sub-expression.\"),\n     4  SYMB(\"}\", 4,\"opened with { to bracket a sub-expression.\"),\n     5  SYMB(\"+\",11,\"addition, and unary + to no effect.\"),\n     6  SYMB(\"-\",11,\"subtraction, and unary - for neg. numbers.\"),\n     7  SYMB(\"*\",12,\"multiplication.\"),\n     8  SYMB(\"\u00d7\",12,\"multiplication, if you can find this.\"),\n     9  SYMB(\"/\",12,\"division.\"),\n     o  SYMB(\"\u00f7\",12,\"division for those with a fancy keyboard.\"),\nC                13 is used so that stacked ^ will have lower priority than incoming ^, thus delivering right-to-left evaluation.\n     1  SYMB(\"^\",14,\"raise to power. Not recognised is **.\")/))\n       CHARACTER*3\tBRAOPEN,BRACLOSE\t\n       PARAMETER\t(BRAOPEN = \"([{\", BRACLOSE = \")]}\")\t\n       INTEGER\t\tBRALEVEL\t\t\n       INTEGER\t\tPRBRA,PRPOW\t\t\n       PARAMETER (PRBRA = SYMBOL( 3).PRECEDENCE)\t\n       PARAMETER (PRPOW = SYMBOL(11).PRECEDENCE)\t\n\n       CHARACTER*10 DIGIT\t\t\n       PARAMETER (DIGIT = \"0123456789\")\t\n\n       INTEGER STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 66)\t\n       TYPE DEFERRED\t\t\t\n        CHARACTER*1\tOPC\t\t\n        INTEGER*1\tPRECEDENCE\t\n       END TYPE DEFERRED\t\t\n       TYPE(DEFERRED) OPSTACK(0:STACKLIMIT)\t\n       INTEGER OSP\t\t\t\n\n       INTEGER INCOMING,TOKENTYPE,NOTHING,ANUMBER,OPENBRA,HUH\t\t\n       PARAMETER (NOTHING = 0, ANUMBER = -1, OPENBRA = -2, HUH = -3)\t\n       CONTAINS\t\n        SUBROUTINE EMIT(STUFF)\t\n         CHARACTER*(*) STUFF\t\n         INTEGER L\t\t\n          WRITE (MSG,1) STUFF\t\n    1     FORMAT (\"Emit  \",A)\t\n          IF (STUFF.EQ.\"\") RETURN\t\n          L = LEN(STUFF)\t\n          IF (LR + L.GE.ENUFF) STOP \"Too much RPN for RP\n          IF (LR.GT.0) THEN\t\n            LR = LR + 1\t\t\t\n            RP(LR:LR) = \" \"\t\t\n          END IF\t\t\n          RP(LR + 1:LR + L) = STUFF\t\n          LR = LR + L\t\t\t\n        END SUBROUTINE EMIT\t\n\n        SUBROUTINE STACKOP(C,P)\t\n         CHARACTER*1 C\t\n         INTEGER P\t\n          OSP = OSP + 1\t\t\n          IF (OSP.GT.STACKLIMIT) STOP \"OSP overtopped\n          OPSTACK(OSP).OPC = C\t\t\n          OPSTACK(OSP).PRECEDENCE = P\t\n          WRITE (MSG,1) C,OPSTACK(1:OSP)\t\n    1     FORMAT (\"Stack \",A1,9X,\",OpStk=\",33(A1,I2:\",\"))\n        END SUBROUTINE STACKOP\t\n\n        LOGICAL FUNCTION COMPILE(TEXT)\t\n         CHARACTER*(*) TEXT\t\n         INTEGER L1,L2\t\t\n         CHARACTER*1 C\t\t\n         INTEGER HAPPY\t\t\n          LR = 0\t\t\n          OSP = 0\t\t\n          OPSTACK(0).OPC = \"\"\t\t\n          OPSTACK(0).PRECEDENCE = 0\t\n          BRALEVEL = 0\t\t\n          HAPPY = +1\t\t\n          L2 = 1\t\t\nChew into an operand, possibly obstructed by an open bracket.\n  100     CALL FORASIGN\t\t\n          IF (TOKENTYPE.EQ.NOTHING) THEN\t\n            IF (OSP.GT.0) CALL GRUMP(\"Another operand or one of \"\t\n     1       //BRAOPEN//\" is expected.\")\t\t\t\t\n          ELSE IF (TOKENTYPE.EQ.ANUMBER) THEN\t\n            CALL EMIT(TEXT(L1:L2 - 1))\t\t\t\n          ELSE IF (TOKENTYPE.EQ.OPENBRA) THEN\t\n            CALL STACKOP(C,PRBRA - 1)\t\t\t\n            GO TO 100\t\t\t\t\t\nC         ELSE IF (TOKENTYPE.EQ.ANAME) THEN\t\nC           CALL EMIT(TEXT(L1:L2 - 1))\t\t\t\n          ELSE\t\t\t\t\t\n            CALL GRUMP(\"Huh? Unexpected \"//C)\t\t\n          END IF\t\t\t\t\nChase after an operator, possibly interrupted by a close bracket,.\n  200     CALL FORASIGN\t\t\n          IF (TOKENTYPE.LT.0) THEN\t\n            CALL GRUMP(\"Operator expected, not \"//C)\t\n           ELSE\t\t\t\n            WRITE (MSG,201) C,INCOMING,OPSTACK(1:OSP)\t\n  201       FORMAT (\"Oprn=>\",A1,\"< Prec=\",I2,\t\t\n     1       \",OpStk=\",33(A1,I2:\",\"))\t\t\t\n            DO WHILE(OPSTACK(OSP).PRECEDENCE .GE. INCOMING)\t\n              IF (OPSTACK(OSP).PRECEDENCE .EQ. PRBRA - 1)\t\t\n     1         CALL GRUMP(\"Unbalanced \"//OPSTACK(OSP).OPC)\t\t\n              CALL EMIT(OPSTACK(OSP).OPC)\t\t\t\t\n              OSP = OSP - 1\t\t\t\t\t\t\n            END DO\t\t\t\t\t\t\n            IF (TOKENTYPE.GT.NOTHING) THEN\t\n              IF (INCOMING.EQ.PRBRA) THEN\t\t\n                CALL BALANCEBRA(C)\t\t\t\n                BRALEVEL = BRALEVEL - 1\t\t\t\n                GO TO 200\t\t\t\t\n               ELSE\t\t\t\t\n                IF (C.EQ.\"^\") INCOMING = PRPOW - 1\t\n                CALL STACKOP(C,INCOMING)\t\t\n              END IF\t\t\t\n            END IF\t\t\t\n          END IF\t\t\nCarry on?\n          IF (HAPPY .GT. 0) GO TO 100 \t\nCompleted.\n          COMPILE = HAPPY.GE.0\t\n         CONTAINS\t\n          SUBROUTINE GRUMP(GROWL)\t\n           CHARACTER*(*) GROWL\t\n            WRITE (MSG,1) GROWL\t\n            IF (L1.GT. 1)        WRITE (MSG,1) \"Tasty:\",TEXT( 1:L1 - 1)\t\n            IF (L2.GT.L1)        WRITE (MSG,1) \"Nasty:\",TEXT(L1:L2 - 1)\t\n            IF (L2.LE.LEN(TEXT)) WRITE (MSG,1) \"Misty:\",TEXT(L2:)\t\n    1       FORMAT (4X,A,1X,A)\t\n            HAPPY = -1\t.\t\n          END SUBROUTINE GRUMP\t\n\n          SUBROUTINE BALANCEBRA(B)\t\n           CHARACTER*1 B\t\n           CHARACTER*1 O\t\n           INTEGER IT,L\t\t\n           CHARACTER*88 GROWL\t\n            O = OPSTACK(OSP).OPC\t\n            WRITE (MSG,1) O,B\t\t\n    1       FORMAT (\"Match \",2A)\t\n            IT = INDEX(BRAOPEN,O)\t\n            IF (IT .EQ. INDEX(BRACLOSE,B)) THEN\t\n              OSP = OSP - 1\t\t\t\n             ELSE\t\n              GROWL = \"Unbalanced {[(...)]} bracketing\n     1         //B//\" is unmatched.\"\t\t\t\t\n              IF (IT.GT.0) GROWL(62:) =  \"A \"//BRACLOSE(IT:IT)\t\n     1         //\" would be better.\"\t\t\n              CALL GRUMP(GROWL)\t\t\n            END IF\t\t\t\n          END SUBROUTINE BALANCEBRA\t\n\n          SUBROUTINE FORASIGN\t\n           INTEGER I\t\n            L1 = L2\t\t\n   10       IF (L1.GT.LEN(TEXT)) THEN\t\n              C = \"\"\t\t\t\n              L2 = L1\t\t\t\n              TOKENTYPE = NOTHING\t\n              INCOMING = SYMBOL(1).PRECEDENCE\t\n              HAPPY = 0\t\t\t\n             ELSE\t\nCheck for spaces and move past them.\n              C = TEXT(L1:L1)\t\n              IF (C.LE.\" \") THEN\t\n                L1 = L1 + 1\t\t\n                GO TO 10\t\t\n              END IF\t\t\nCaught something to inspect.\n              L2 = L1 + 1\t\t\n              IF (INDEX(DIGIT,C).GT.0) THEN\t\n                TOKENTYPE = ANUMBER \t\t\n   20           IF (L2.LE.LEN(TEXT)) THEN\t\n                  IF (INDEX(DIGIT,TEXT(L2:L2)).GT.0) THEN\t\n                    L2 = L2 + 1\t\t\t\n                    GO TO 20\t\t\t\n                  END IF\t\t\t\n                END IF\t\t\t\nC             ELSE IF (INDEX(LETTERS,C).GT.0) THEN\t\nC               advance L2 while in NAMEISH.\n              ELSE IF (INDEX(BRAOPEN,C).GT.0) THEN\t\n                TOKENTYPE = OPENBRA\t\t\t\n              ELSE\t\t\t\n                DO I = OPSYMBOLS,1,-1\t\n                  IF (SYMBOL(I).IS .EQ. C) EXIT\t\n                END DO\t\t\t\n                IF (I.LE.0) THEN\t\n                  TOKENTYPE = HUH\t\t\n                  INCOMING = SYMBOL(0).PRECEDENCE\t\n                 ELSE\t\t\t\n                  TOKENTYPE = I\t\t\t\n                  INCOMING = SYMBOL(I).PRECEDENCE\t\n                END IF\t\t\t\n              END IF\t\t\n            END IF\t\n            WRITE (MSG,30) C,INCOMING,TOKENTYPE\t\t\n   30       FORMAT (\"Next=>\",A1,\"< Prec=\",I2,\",Ttype=\",I2)\t\n          END SUBROUTINE FORASIGN\t\n        END FUNCTION COMPILE\t\n      END MODULE COMPILER\t\n\n      PROGRAM POKE\n      USE COMPILER\n      CHARACTER*66 TEXT\n      LOGICAL HIC\n      MSG = 6\n      KBD = 5\n      WRITE (MSG,1)\n    1 FORMAT (\"Produce RPN from infix...\",/)\n\n   10 WRITE (MSG,11)\n   11 FORMAT(\"Infix: \",$)\n      READ(KBD,12) TEXT\n   12 FORMAT (A)\n      IF (TEXT.EQ.\"\") STOP \"Enough.\"\n      HIC = COMPILE(TEXT)\n      WRITE (MSG,13) HIC,RP(1:LR)\n   13 FORMAT (L6,\" RPN: >\",A,\"<\")\n      GO TO 10\n      END\n", "target": "import java.util.Stack;\n\npublic class ShuntingYard {\n\n    public static void main(String[] args) {\n        String infix = \"3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3\";\n        System.out.printf(\"infix:   %s%n\", infix);\n        System.out.printf(\"postfix: %s%n\", infixToPostfix(infix));\n    }\n\n    static String infixToPostfix(String infix) {\n        \n        final String ops = \"-+/*^\";\n\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n\n        for (String token : infix.split(\"\\\\s\")) {\n            if (token.isEmpty())\n                continue;\n            char c = token.charAt(0);\n            int idx = ops.indexOf(c);\n\n            \n            if (idx != -1) {\n                if (s.isEmpty())\n                    s.push(idx);\n          \n                else {\n                    while (!s.isEmpty()) {\n                        int prec2 = s.peek() / 2;\n                        int prec1 = idx / 2;\n                        if (prec2 > prec1 || (prec2 == prec1 && c != '^'))\n                            sb.append(ops.charAt(s.pop())).append(' ');\n                        else break;\n                    }\n                    s.push(idx);\n                }\n            } \n            else if (c == '(') {\n                s.push(-2); \n            } \n            else if (c == ')') {\n                \n                while (s.peek() != -2)\n                    sb.append(ops.charAt(s.pop())).append(' ');\n                s.pop();\n            }\n            else {\n                sb.append(token).append(' ');\n            }\n        }\n        while (!s.isEmpty())\n            sb.append(ops.charAt(s.pop())).append(' ');\n        return sb.toString();\n    }\n}\n"}
{"id": 388726, "name": "Perlin noise", "source": "Translate Fortran to Java: PROGRAM PERLIN\nIMPLICIT NONE\nINTEGER :: i\nINTEGER, DIMENSION(0:511) :: p\nINTEGER, DIMENSION(0:255), PARAMETER :: permutation = (/151,160,137,91,90,15,    &\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23, &\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33, &\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166, &\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244, &\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196, &\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123, &\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42, &\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, &\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228, &\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107, &\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254, &\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180/)\n\nDO i=0, 255\n    p(i) = permutation(i)\n    p(256+i) = permutation(i)\nEND DO\n\nWRITE(*,\"(F19.17)\") NOISE(3.14d0, 42d0, 7d0)\n\nCONTAINS\n\nDOUBLE PRECISION FUNCTION NOISE(x_in, y_in, z_in)\n    DOUBLE PRECISION, INTENT(IN) :: x_in, y_in, z_in\n    DOUBLE PRECISION :: x, y, z\n    INTEGER :: xx, yy, zz, a, aa, ab, b, ba, bb\n    DOUBLE PRECISION :: u, v, w\n\n    x = x_in\n    y = y_in\n    z = z_in\n\n    xx = IAND(FLOOR(x), 255)\n    yy = IAND(FLOOR(y), 255)\n    zz = IAND(FLOOR(z), 255)\n\n    x = x - FLOOR(x)\n    y = y - FLOOR(y)\n    z = z - FLOOR(z)\n\n    u = FADE(x)\n    v = FADE(y)\n    w = FADE(z)\n\n    a  = p(xx)   + yy\n    aa = p(a)    + zz\n    ab = p(a+1)  + zz\n    b  = p(xx+1) + yy\n    ba = p(b)    + zz\n    bb = p(b+1)  + zz\n\n    NOISE = LERP(w, LERP(v, LERP(u, GRAD(p(aa),   x,   y,   z),     &\n                                    GRAD(p(ba),   x-1, y,   z)),    &\n                            LERP(u, GRAD(p(ab),   x,   y-1, z),     &\n                                    GRAD(p(bb),   x-1, y-1, z))),   &\n                    LERP(v, LERP(u, GRAD(p(aa+1), x,   y,   z-1),   &\n                                    GRAD(p(ba+1), x-1, y,   z-1)),  &\n                            LERP(u, GRAD(p(ab+1), x,   y-1, z-1),   &\n                                    GRAD(p(bb+1), x-1, y-1, z-1))))\nEND FUNCTION\n\n\nDOUBLE PRECISION FUNCTION FADE(t)\n    DOUBLE PRECISION, INTENT(IN) :: t\n\n    FADE = t ** 3 * (t * ( t * 6 - 15) + 10)\nEND FUNCTION\n\n\nDOUBLE PRECISION FUNCTION LERP(t, a, b)\n    DOUBLE PRECISION, INTENT(IN) :: t, a, b\n\n    LERP = a + t * (b - a)\nEND FUNCTION\n\n\nDOUBLE PRECISION FUNCTION GRAD(hash, x, y, z)\n    INTEGER, INTENT(IN) :: hash\n    DOUBLE PRECISION, INTENT(IN) :: x, y, z\n    INTEGER :: h\n    DOUBLE PRECISION :: u, v\n\n    h = IAND(hash, 15)\n\n    u = MERGE(x, y, h < 8)\n\n    v = MERGE(y, MERGE(x, z, h == 12 .OR. h == 14), h < 4)\n\n    GRAD = MERGE(u, -u, IAND(h, 1) == 0) + MERGE(v, -v, IAND(h, 2) == 0)\nEND FUNCTION\n\n\nEND PROGRAM\n", "target": "\n\npublic final class ImprovedNoise {\n   static public double noise(double x, double y, double z) {\n      int X = (int)Math.floor(x) & 255,                  \n          Y = (int)Math.floor(y) & 255,                  \n          Z = (int)Math.floor(z) & 255;\n      x -= Math.floor(x);                                \n      y -= Math.floor(y);                                \n      z -= Math.floor(z);\n      double u = fade(x),                                \n             v = fade(y),                                \n             w = fade(z);\n      int A = p[X  ]+Y, AA = p[A]+Z, AB = p[A+1]+Z,      \n          B = p[X+1]+Y, BA = p[B]+Z, BB = p[B+1]+Z;      \n\n      return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                     grad(p[BA  ], x-1, y  , z   )), \n                             lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                     grad(p[BB  ], x-1, y-1, z   ))),\n                     lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                     grad(p[BA+1], x-1, y  , z-1 )), \n                             lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                     grad(p[BB+1], x-1, y-1, z-1 ))));\n   }\n   static double fade(double t) { return t * t * t * (t * (t * 6 - 15) + 10); }\n   static double lerp(double t, double a, double b) { return a + t * (b - a); }\n   static double grad(int hash, double x, double y, double z) {\n      int h = hash & 15;                      \n      double u = h<8 ? x : y,                 \n             v = h<4 ? y : h==12||h==14 ? x : z;\n      return ((h&1) == 0 ? u : -u) + ((h&2) == 0 ? v : -v);\n   }\n   static final int p[] = new int[512], permutation[] = { 151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180\n   };\n   static { for (int i=0; i < 256 ; i++) p[256+i] = p[i] = permutation[i]; }\n}\n"}
{"id": 388727, "name": "Vector", "source": "Translate Fortran to Java: MODULE ROSETTA_VECTOR\n    IMPLICIT NONE\n\n    TYPE VECTOR\n        REAL :: X, Y\n    END TYPE VECTOR\n\n\n    INTERFACE OPERATOR(+)\n       MODULE PROCEDURE VECTOR_ADD\n    END INTERFACE\n\n    INTERFACE OPERATOR(-)\n       MODULE PROCEDURE VECTOR_SUB\n    END INTERFACE\n\n    INTERFACE OPERATOR(/)\n       MODULE PROCEDURE VECTOR_DIV\n    END INTERFACE\n\n    INTERFACE OPERATOR(*)\n       MODULE PROCEDURE VECTOR_MULT\n    END INTERFACE\n\n    CONTAINS\n\n    FUNCTION VECTOR_ADD(VECTOR_1, VECTOR_2)\n        TYPE(VECTOR), INTENT(IN) :: VECTOR_1, VECTOR_2\n        TYPE(VECTOR) :: VECTOR_ADD\n        VECTOR_ADD%X = VECTOR_1%X+VECTOR_2%X\n        VECTOR_ADD%Y = VECTOR_1%Y+VECTOR_2%Y\n    END FUNCTION VECTOR_ADD\n\n    FUNCTION VECTOR_SUB(VECTOR_1, VECTOR_2)\n        TYPE(VECTOR), INTENT(IN) :: VECTOR_1, VECTOR_2\n        TYPE(VECTOR) :: VECTOR_SUB\n        VECTOR_SUB%X = VECTOR_1%X-VECTOR_2%X\n        VECTOR_SUB%Y = VECTOR_1%Y-VECTOR_2%Y\n    END FUNCTION VECTOR_SUB\n\n    FUNCTION VECTOR_DIV(VEC, SCALAR)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        REAL, INTENT(IN) :: SCALAR\n        TYPE(VECTOR) :: VECTOR_DIV\n        VECTOR_DIV%X = VEC%X/SCALAR\n        VECTOR_DIV%Y = VEC%Y/SCALAR\n    END FUNCTION VECTOR_DIV\n\n    FUNCTION VECTOR_MULT(VEC, SCALAR)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        REAL, INTENT(IN) :: SCALAR\n        TYPE(VECTOR) :: VECTOR_MULT\n        VECTOR_MULT%X = VEC%X*SCALAR\n        VECTOR_MULT%Y = VEC%Y*SCALAR\n    END FUNCTION VECTOR_MULT\n\n    FUNCTION FROM_RTHETA(R, THETA)\n        REAL :: R, THETA\n        TYPE(VECTOR) :: FROM_RTHETA\n        FROM_RTHETA%X = R*SIN(THETA)\n        FROM_RTHETA%Y = R*COS(THETA)\n    END FUNCTION FROM_RTHETA\n\n    FUNCTION FROM_XY(X, Y)\n        REAL :: X, Y\n        TYPE(VECTOR) :: FROM_XY\n        FROM_XY%X = X\n        FROM_XY%Y = Y\n    END FUNCTION FROM_XY\n\n    FUNCTION PRETTY_PRINT(VEC)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        CHARACTER(LEN=100) PRETTY_PRINT\n        WRITE(PRETTY_PRINT,\"(A, F0.5, A, F0.5, A)\") \"[\", VEC%X, \", \", VEC%Y, \"]\"\n    END FUNCTION PRETTY_PRINT\nEND MODULE ROSETTA_VECTOR\n\nPROGRAM VECTOR_DEMO\n    USE ROSETTA_VECTOR\n    IMPLICIT NONE\n\n    TYPE(VECTOR) :: VECTOR_1, VECTOR_2\n    REAL, PARAMETER :: PI = 4*ATAN(1.0)\n    REAL :: SCALAR\n\n    SCALAR = 2.0\n\n    VECTOR_1 = FROM_XY(2.0, 3.0)\n    VECTOR_2 = FROM_RTHETA(2.0, PI/6.0)\n\n    WRITE(*,*) \"VECTOR_1 (X: 2.0, Y: 3.0)     \u00a0: \", PRETTY_PRINT(VECTOR_1)\n    WRITE(*,*) \"VECTOR_2 (R: 2.0, THETA: PI/6)\u00a0: \", PRETTY_PRINT(VECTOR_2)\n    WRITE(*,*) NEW_LINE('A')\n    WRITE(*,*) \"VECTOR_1  +  VECTOR_2          = \", PRETTY_PRINT(VECTOR_1+VECTOR_2)\n    WRITE(*,*) \"VECTOR_1  -  VECTOR_2          = \", PRETTY_PRINT(VECTOR_1-VECTOR_2)\n    WRITE(*,*) \"VECTOR_1  /  2.0               = \", PRETTY_PRINT(VECTOR_1/SCALAR)\n    WRITE(*,*) \"VECTOR_1  *  2.0               = \", PRETTY_PRINT(VECTOR_1*SCALAR)\nEND PROGRAM VECTOR_DEMO\n", "target": "import java.util.Locale;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        System.out.println(new Vec2(5, 7).add(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).sub(new Vec2(2, 3)));\n        System.out.println(new Vec2(5, 7).mult(11));\n        System.out.println(new Vec2(5, 7).div(2));\n    }\n}\n\nclass Vec2 {\n    final double x, y;\n\n    Vec2(double x, double y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    Vec2 add(Vec2 v) {\n        return new Vec2(x + v.x, y + v.y);\n    }\n\n    Vec2 sub(Vec2 v) {\n        return new Vec2(x - v.x, y - v.y);\n    }\n\n    Vec2 div(double val) {\n        return new Vec2(x / val, y / val);\n    }\n\n    Vec2 mult(double val) {\n        return new Vec2(x * val, y * val);\n    }\n\n    @Override\n    public String toString() {\n        return String.format(Locale.US, \"[%s, %s]\", x, y);\n    }\n}\n"}
{"id": 388728, "name": "Prime conspiracy", "source": "Translate Fortran to Java:       PROGRAM INHERIT\t\n      USE PRIMEBAG\t\n      INTEGER MBASE,P0,NHIC\t\n      PARAMETER (MBASE = 13, P0 = 2, NHIC = 100000000)\t\n      INTEGER N(0:MBASE - 1,0:MBASE - 1,2:MBASE)\t\n      INTEGER I,B,D1,D2\t\n      INTEGER P,PP\t\n\n      MSG = 6\t\t\n      WRITE (MSG,1) MBASE,P0,NHIC\t\n    1 FORMAT (\"Working in base 2 to \",I0,\" count the transitions \"\n     1 \"from the low-order digit of one prime number \",/,\n     2 \"to the low-order digit of its successor. Starting with \",I0,\n     3 \" and making \",I0,\" advances.\")\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\nChug through the primes.\n   10 N = 0\t\n      P = P0\t\n      DO I = 1,NHIC\t\n        PP = P\t\t\t\n        P = NEXTPRIME(P)\t\n        DO B = 2,MBASE\t\t\n          D1 = MOD(PP,B)\t\t\n          D2 = MOD(P,B)\t\t\t\n          N(D1,D2,B) = N(D1,D2,B) + 1\t\n        END DO\t\t\t\n      END DO\t\t\n      WRITE (MSG,11) P\t\n   11 FORMAT (\"Ending with \",I0)\t\n\nCast forth the results.\n   20 DO B = 2,MBASE\t\n        WRITE (MSG,21) B\t\t\n   21   FORMAT (/,\"For base \",I0)\t\n        WRITE (MSG,22) (D1, D1 = 0,B - 1)\t\n   22   FORMAT (\" Last digit ending  \",I2,66I9)\t\n        DO D2 = 0,B - 1\t\t\n          IF (ALL(N(0:B - 1,D2,B).EQ.0)) CYCLE\t\n          WRITE (MSG,23) D2,N(0:B - 1,D2,B)\t\n   23     FORMAT (\" next prime ends\",I3,\":\",I2,66I9)\t\n        END DO\t\t\t\n      END DO\t\t\n      END\t\n", "target": "public class PrimeConspiracy {\n\n    public static void main(String[] args) {\n        final int limit = 1000_000;\n        final int sieveLimit = 15_500_000;\n\n        int[][] buckets = new int[10][10];\n        int prevDigit = 2;\n        boolean[] notPrime = sieve(sieveLimit);\n\n        for (int n = 3, primeCount = 1; primeCount < limit; n++) {\n            if (notPrime[n])\n                continue;\n\n            int digit = n % 10;\n            buckets[prevDigit][digit]++;\n            prevDigit = digit;\n            primeCount++;\n        }\n\n        for (int i = 0; i < 10; i++) {\n            for (int j = 0; j < 10; j++) {\n                if (buckets[i][j] != 0) {\n                    System.out.printf(\"%d -> %d\u00a0: %2f%n\", i,\n                            j, buckets[i][j] / (limit / 100.0));\n                }\n            }\n        }\n    }\n\n    public static boolean[] sieve(int limit) {\n        boolean[] composite = new boolean[limit];\n        composite[0] = composite[1] = true;\n\n        int max = (int) Math.sqrt(limit);\n        for (int n = 2; n <= max; n++) {\n            if (!composite[n]) {\n                for (int k = n * n; k < limit; k += n) {\n                    composite[k] = true;\n                }\n            }\n        }\n        return composite;\n    }\n}\n"}
{"id": 388729, "name": "Statistics_Normal distribution", "source": "Translate Fortran to Java: program Normal_Distribution\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: r64 = selected_real_kind(15)\n  integer(i64), parameter :: samples = 1000000_i64\n  real(r64) :: mean, stddev\n  real(r64) :: sumn = 0, sumnsq = 0\n  integer(i64) :: n = 0 \n  integer(i64) :: bin(-50:50) = 0\n  integer :: i, ind\n  real(r64) :: ur1, ur2, nr1, nr2, s\n  \n  n = 0\n  do while(n <= samples)\n    call random_number(ur1)\n    call random_number(ur2)\n    ur1 = ur1 * 2.0 - 1.0\n    ur2 = ur2 * 2.0 - 1.0\n    \n    s = ur1*ur1 + ur2*ur2  \n    if(s >= 1.0_r64) cycle\n      \n    nr1 = ur1 * sqrt(-2.0*log(s)/s)\n    ind = floor(5.0*nr1)\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + nr1\n    sumnsq = sumnsq + nr1*nr1\n    \n    nr2 = ur2 * sqrt(-2.0*log(s)/s)\n    ind = floor(5.0*nr2)\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + nr2\n    sumnsq = sumnsq + nr2*nr2\n    n = n + 2_i64\n  end do\n \n  mean = sumn / n\n  stddev = sqrt(sumnsq/n - mean*mean)\n  \n  write(*, \"(a, i0)\") \"sample size = \", samples\n  write(*, \"(a, f17.15)\") \"Mean\u00a0:   \", mean,\n  write(*, \"(a, f17.15)\") \"Stddev\u00a0: \", stddev\n  \n  do i = -15, 15 \n    write(*, \"(f4.1, a, a)\") real(i)/5.0, \": \", repeat(\"=\", int(bin(i)*500/samples))\n  end do\n       \nend program\n", "target": "import static java.lang.Math.*;\nimport static java.util.Arrays.stream;\nimport java.util.Locale;\nimport java.util.function.DoubleSupplier;\nimport static java.util.stream.Collectors.joining;\nimport java.util.stream.DoubleStream;\nimport static java.util.stream.IntStream.range;\n\npublic class Test implements DoubleSupplier {\n\n    private double mu, sigma;\n    private double[] state = new double[2];\n    private int index = state.length;\n\n    Test(double m, double s) {\n        mu = m;\n        sigma = s;\n    }\n\n    static double[] meanStdDev(double[] numbers) {\n        if (numbers.length == 0)\n            return new double[]{0.0, 0.0};\n\n        double sx = 0.0, sxx = 0.0;\n        long n = 0;\n        for (double x : numbers) {\n            sx += x;\n            sxx += pow(x, 2);\n            n++;\n        }\n\n        return new double[]{sx / n, pow((n * sxx - pow(sx, 2)), 0.5) / n};\n    }\n\n    static String replicate(int n, String s) {\n        return range(0, n + 1).mapToObj(i -> s).collect(joining());\n    }\n\n    static void showHistogram01(double[] numbers) {\n        final int maxWidth = 50;\n        long[] bins = new long[10];\n\n        for (double x : numbers)\n            bins[(int) (x * bins.length)]++;\n\n        double maxFreq = stream(bins).max().getAsLong();\n\n        for (int i = 0; i < bins.length; i++)\n            System.out.printf(\" %3.1f: %s%n\", i / (double) bins.length,\n                    replicate((int) (bins[i] / maxFreq * maxWidth), \"*\"));\n        System.out.println();\n    }\n\n    @Override\n    public double getAsDouble() {\n        index++;\n        if (index >= state.length) {\n            double r = sqrt(-2 * log(random())) * sigma;\n            double x = 2 * PI * random();\n            state = new double[]{mu + r * sin(x), mu + r * cos(x)};\n            index = 0;\n        }\n        return state[index];\n\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.US);\n        double[] data = DoubleStream.generate(new Test(0.0, 0.5)).limit(100_000)\n                .toArray();\n\n        double[] res = meanStdDev(data);\n        System.out.printf(\"Mean: %8.6f, SD: %8.6f%n\", res[0], res[1]);\n\n        showHistogram01(stream(data).map(a -> max(0.0, min(0.9999, a / 3 + 0.5)))\n                .toArray());\n    }\n}\n"}
{"id": 388730, "name": "K-means++ clustering", "source": "Translate Fortran to Java: ***********************************************************************\n* KMPP - K-Means++ - Traditional data clustering with a special initialization\n* Public Domain - This program may be used by any person for any purpose.\n*\n* Origin:\n*    Hugo Steinhaus, 1956\n*\n* Refer to:\n*    \"kmeans++: the advantages of careful seeding\"\n*    David Arthur and Sergei Vassilvitskii\n*    Proceedings of the eighteenth annual ACM-SIAM symposium \n*      on Discrete algorithms, 2007\n*\n*____Variable_______I/O_______Description___________________Type_______\n*    X(P,N)         In        Data points                   Real\n*    P              In        Dimension of the data         Integer\n*    N              In        Number of points              Integer\n*    K              In        # clusters                    Integer\n*    C(P,K)         Out       Center points of clusters     Real\n*    Z(N)           Out       What cluster a point is in    Integer\n*    WORK(N)        Neither                                 Real\n*    IFAULT         Out       Error code                    Integer\n************************************************************************\n      SUBROUTINE KMPP (X, P, N, K, C, Z, WORK, IFAULT)\n       \n       IMPLICIT NONE\n       INTEGER P, N, K, Z, IFAULT\n       REAL X, C, WORK\n       DIMENSION X(P,N), C(P,K), Z(N), WORK(N)\n  \n*               constants\n       INTEGER ITER                 \n       REAL BIG                     \n       PARAMETER (ITER = 1000,\n     $            BIG = 1E33)\n                 \n*                local variables\n       INTEGER \n     $         H,          \n     $         I,          \n     $         I1,         \n     $         J,          \n     $         L,          \n     $         L0,         \n     $         L1          \n     \n       REAL \n     $      BEST,                 \n     $      D2,                   \n     $      TOT,                  \n     $      W                     \n     \n       LOGICAL CHANGE             \n\n************************************************************************\n*           Begin.\n************************************************************************\n       IFAULT = 0\n       IF (K < 1 .OR. K > N) THEN       \n         IFAULT = 3\n         RETURN\n       END IF\n       DO I = 1, N                       \n         Z(I) = 0\n       END DO\n        \n************************************************************************\n*        initial centers\n************************************************************************\n       DO I = 1, N\n         WORK(I) = BIG\n       END DO\n\n       CALL RANDOM_NUMBER (W)\n       I1 = MIN(INT(W * FLOAT(N)) + 1, N)  \n       DO J = 1, P\n         C(J,1) = X(J,I1)\n       END DO\n       \n       DO L = 2, K                    \n         TOT = 0.\n         DO I = 1, N                     \n           BEST = WORK(I)\n           D2 = 0.                         \n           DO J = 1, P\n             D2 = D2 + (X(J,I) - C(J,L-1)) **2  \n             IF (D2 .GE. BEST) GO TO 10               \n           END DO                          \n           IF (D2 < BEST) BEST = D2          \n           WORK(I) = BEST \n  10       TOT = TOT + BEST             \n         END DO                      \n         \n************************************************************************\n* Choose center with probability proportional to its squared distance\n*     from existing centers.\n************************************************************************\n         CALL RANDOM_NUMBER (W)\n         W = W * TOT    \n         TOT = 0.\n         DO I = 1, N\n           I1 = I\n           TOT = TOT + WORK(I)\n           IF (TOT > W) GO TO 20\n         END DO                \n  20     CONTINUE\n         DO J = 1, P         \n           C(J,L) = X(J,I1)\n         END DO\n       END DO               \n\n************************************************************************\n*                      main loop\n************************************************************************\n       DO H = 1, ITER\n         CHANGE = .FALSE.\n\n*             find nearest center for each point \n         DO I = 1, N\n           L0 = Z(I)\n           L1 = 0\n           BEST = BIG\n           DO L = 1, K\n             D2 = 0.\n             DO J = 1, P\n               D2 = D2 + (X(J,I) - C(J,L)) **2\n               IF (D2 .GE. BEST) GO TO 30\n             END DO\n  30         CONTINUE\n             IF (D2 < BEST) THEN           \n               BEST = D2\n               L1 = L\n             END IF             \n           END DO        \n        \n           IF (L0 .NE. L1) THEN\n             Z(I) = L1                   \n             CHANGE = .TRUE.\n           END IF\n         END DO         \n         IF (.NOT. CHANGE) RETURN      \n\n************************************************************************\n*           find cluster centers\n************************************************************************\n         DO L = 1, K              \n           WORK(L) = 0.\n         END DO\n         DO L = 1, K               \n           DO J = 1, P\n             C(J,L) = 0.\n           END DO\n         END DO\n\n         DO I = 1, N\n           L = Z(I)\n           WORK(L) = WORK(L) + 1.             \n           DO J = 1, P\n             C(J,L) = C(J,L) + X(J,I)         \n           END DO\n         END DO\n           \n         DO L = 1, K\n           IF (WORK(L) < 0.5) THEN          \n             IFAULT = 1                     \n             RETURN\n           END IF\n           W = 1. / WORK(L)\n           DO J = 1, P\n             C(J,L) = C(J,L) * W     \n           END DO\n         END DO\n             \n       END DO                   \n       IFAULT = 2                \n       RETURN\n    \n      END  \n\n\n************************************************************************\n*             test program (extra credit #1)\n************************************************************************\n      PROGRAM TPEC1\n       IMPLICIT NONE\n       INTEGER N, P, K\n       REAL TWOPI\n       PARAMETER (N = 30 000,\n     $            P = 2,\n     $            K = 6,\n     $            TWOPI = 6.2831853)\n       INTEGER I, L, Z(N), IFAULT\n       REAL X(P,N), C(P,K), R, THETA, W, WORK(N)\n\n*             Begin\n       CALL RANDOM_SEED()\n       DO I = 1, N                      \n         CALL RANDOM_NUMBER (W)\n         R = SQRT(W)                      \n         CALL RANDOM_NUMBER (W)\n         THETA = W * TWOPI                \n         X(1,I) = R * COS(THETA)          \n         X(2,I) = R * SIN(THETA)\n       END DO\n       \n*             Call subroutine\n       CALL KMPP (X, P, N, K, C, Z, WORK, IFAULT)\n       PRINT *, 'kmpp returns with error code ', IFAULT\n       \n*            Print lists of points in each cluster\n       DO L = 1, K\n         PRINT *, 'Cluster ', L, ' contains points: '\n  10     FORMAT (I6, $)\n  20     FORMAT ()\n         DO I = 1, N\n           IF (Z(I) .EQ. L) PRINT 10, I\n         END DO\n         PRINT 20\n       END DO\n       \n*         Write CSV file with Y-coordinates in different columns by cluster\n       OPEN (UNIT=1, FILE='tpec1.csv', STATUS='NEW', IOSTAT=IFAULT)\n       IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble opening file'\n  30   FORMAT (F8.4, $)\n  40   FORMAT (',', $)\n  50   FORMAT (F8.4)\n       DO I = 1, N\n         WRITE (UNIT=1, FMT=30, IOSTAT=IFAULT) X(1,I)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing X-coord'\n         DO L = 1, Z(I)                     \n           WRITE (UNIT=1, FMT=40, IOSTAT=IFAULT)\n           IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing comma'\n         END DO\n         WRITE (UNIT=1, FMT=50, IOSTAT=IFAULT) X(2,I)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing Y-coord'\n       END DO\n       \n*           Write the centroids in the far column\n       DO L = 1, K\n         WRITE (UNIT=1, FMT=30, IOSTAT=IFAULT) C(1,L)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing X-coord'\n         DO I = 1, K+1\n           WRITE (UNIT=1, FMT=40, IOSTAT=IFAULT)\n           IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing comma'\n         END DO\n         WRITE (UNIT=1, FMT=50, IOSTAT=IFAULT) C(2,L)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing Y-coord'\n       END DO\n       CLOSE (UNIT=1)\n       \n      END  \n", "target": "import java.util.Random;\n\npublic class KMeansWithKpp{\n\t\t\n\t\tpublic Point[] points;\n\t\tpublic Point[] centroids;\n\t\tRandom rand;\n\t\tpublic int n;\n\t\tpublic int k;\n\n\t\t\n\t\tprivate KMeansWithKpp(){\n\t\t}\n\n\t\tKMeansWithKpp(Point[] p, int clusters){\n\t\t\t\tpoints = p;\n\t\t\t\tn = p.length;\n\t\t\t\tk = Math.max(1, clusters);\n\t\t\t\tcentroids = new Point[k];\n\t\t\t\trand = new Random();\n\t\t}\n\n\n\t\tprivate static double distance(Point a, Point b){\n\t\t\t\treturn (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n\t\t}\n\n\t\tprivate static int nearest(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tint index = pt.group;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn index;\n\t\t}\n\n\t\tprivate static double nearestDistance(Point pt, Point[] others, int len){\n\t\t\t\tdouble minD = Double.MAX_VALUE;\n\t\t\t\tlen = Math.min(others.length, len);\n\t\t\t\tdouble dist;\n\t\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\t\t\tif (minD > (dist = distance(pt, others[i]))) {\n\t\t\t\t\t\t\t\tminD = dist;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn minD;\n\t\t}\n\n\t\tprivate void kpp(){\n\t\t\t\tcentroids[0] = points[rand.nextInt(n)];\n\t\t\t\tdouble[] dist = new double[n];\n\t\t\t\tdouble sum = 0;\n\t\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tdist[j] = nearestDistance(points[j], centroids, i);\n\t\t\t\t\t\t\t\tsum += dist[j];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsum = (sum * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\t\tif ((sum -= dist[j]) > 0)\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\tcentroids[i].x = points[j].x;\n\t\t\t\t\t\t\t\tcentroids[i].y = points[j].y;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tpoints[i].group = nearest(points[i], centroids, k);\n\t\t\t\t}\n\t\t}\n\n\t\tpublic void kMeans(int maxTimes){\n\t\t\t\tif (k == 1 || n <= 0) {\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(k >= n){\n\t\t\t\t\t\tfor(int i =0; i < n; i++){\n\t\t\t\t\t\t\t\tpoints[i].group = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tmaxTimes = Math.max(1, maxTimes);\n\t\t\t\tint changed;\n\t\t\t\tint bestPercent = n/1000;\n\t\t\t\tint minIndex;\n\t\t\t\tkpp();\n\t\t\t\tdo {\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x = 0.0;\n\t\t\t\t\t\t\t\tc.y = 0.0;\n\t\t\t\t\t\t\t\tc.group = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tif(pt.group < 0 || pt.group > centroids.length){\n\t\t\t\t\t\t\t\t\t\tpt.group = rand.nextInt(centroids.length);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcentroids[pt.group].x += pt.x;\n\t\t\t\t\t\t\t\tcentroids[pt.group].y = pt.y;\n\t\t\t\t\t\t\t\tcentroids[pt.group].group++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (Point c : centroids) {\n\t\t\t\t\t\t\t\tc.x /= c.group;\n\t\t\t\t\t\t\t\tc.y /= c.group;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchanged = 0;\n\t\t\t\t\t\tfor (Point pt : points) {\n\t\t\t\t\t\t\t\tminIndex = nearest(pt, centroids, k);\n\t\t\t\t\t\t\t\tif (k != pt.group) {\n\t\t\t\t\t\t\t\t\t\tchanged++;\n\t\t\t\t\t\t\t\t\t\tpt.group = minIndex;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmaxTimes--;\n\t\t\t\t} while (changed > bestPercent && maxTimes > 0);\n\t\t}\n}\n\n\n\n\nclass Point{\n\t\tpublic double x;\n\t\tpublic double y;\n\t\tpublic int group;\n\n\t\tPoint(){\n\t\t\t\tx = y = 0.0;\n\t\t\t\tgroup = 0;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPlaneData(double minX, double maxX, double minY, double maxY, int size){\n\t\t\t\tif (size <= 0)\n\t\t\t\t\t\treturn null;\n\t\t\t\tdouble xdiff, ydiff;\n\t\t\t\txdiff = maxX - minX;\n\t\t\t\tydiff = maxY - minY;\n\t\t\t\tif (minX > maxX) {\n\t\t\t\t\t\txdiff = minX - maxX;\n\t\t\t\t\t\tminX = maxX;\n\t\t\t\t}\n\t\t\t\tif (maxY < minY) {\n\t\t\t\t\t\tydiff = minY - maxY;\n\t\t\t\t\t\tminY = maxY;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tdata[i].x = minX + (xdiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].y = minY + (ydiff * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\n\t\t\n\t\tpublic Point[] getRandomPolarData(double radius, int size){\n\t\t\t\tif (size <= 0) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t}\n\t\t\t\tPoint[] data = new Point[size];\n\t\t\t\tdouble radi, arg;\n\t\t\t\tRandom rand = new Random();\n\t\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\t\t\tradi = (radius * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\targ = (2 * Math.PI * rand.nextInt(Integer.MAX_VALUE)) / Integer.MAX_VALUE;\n\t\t\t\t\t\tdata[i].x = radi * Math.cos(arg);\n\t\t\t\t\t\tdata[i].y = radi * Math.sin(arg);\n\t\t\t\t}\n\t\t\t\treturn data;\n\t\t}\n\t\t\n}\n"}
{"id": 388731, "name": "Decimal floating point number to binary", "source": "Translate Fortran to Java:       MODULE REBASE\t\n       CHARACTER*36 DIGIT\t\n       PARAMETER (DIGIT = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\t\n       CONTAINS\t\t\n        LOGICAL FUNCTION EATNUM(ACARD,BASE,V)\t\nChews into the likes of 666, -666.666, .666 with their variations.\nCompletes with the value in V, success as the result.\nCould check that no digit exceeds the specified BASE usage, but that would mean an error message...\nConcocted by R.N.McLean (whom God preserve) May XXMM.\nClunky usage of ICHAR encourages the compaq compiler to employ single-character-at-a-time usage.\n         CHARACTER*(*) ACARD\t\n         INTEGER BASE\t\t\n         DOUBLE PRECISION V\t\n         DOUBLE PRECISION X\t\n         INTEGER D,DD\t\t\n         INTEGER L2,LC\t\t\n         INTEGER*1 C\t\t\n         LOGICAL ADIGIT,XNEG\t\n          ADIGIT = .FALSE.\t\n          XNEG = .FALSE.\t\n          DD = 0\t\t\n          X = 0\t\t\t\n          L2 = 1\t\t\n          LC = LEN(ACARD)\t\n          IF (L2.GT.LC) GO TO 20\t\nChew into the number. Admit a possible leading sign, then digits.\n          C = ICHAR(ACARD(L2:L2))\t\n          IF (C.EQ.ICHAR(\"+\")) GO TO 1\t\n          IF (C.NE.ICHAR(\"-\")) GO TO 2\t\n          XNEG = .TRUE.\t\t\n    1     L2 = L2 + 1\t\t\n          IF (L2.GT.LC) GO TO 20\t\n    2     D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 10\t\n          X = D\t\t\t\t\n          ADIGIT = .TRUE.\t\t\n    3     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D .LT. 0) GO TO 10\t\n          X = X*BASE + D\t\t\n          GO TO 3\t\t\t\nConsider any decimal digits, introduced by a decimal point.\n   10     IF (ICHAR(ACARD(L2:L2)).EQ.ICHAR(\".\")) GO TO 11\t\n          IF (ICHAR(ACARD(L2:L2)).NE.ICHAR(\"\u00b7\")) GO TO 20\t\n   11     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 20\t\n          X = X*BASE + D\t\t\n          DD = 1\t\t\t\n          ADIGIT = .TRUE.\t\t\n   12     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D < 0 .OR. 9 < D) GO TO 20\t\n          X = X*BASE + D\t\t\t\n          DD = DD + 1\t\t\t\n          GO TO 12\t\t\t\nCan't consider any exponent part, started by an \"E\" or \"D\", as these may be possible digit symbols.\n   20     IF (DD .GT. 0) X = X/BASE**DD\t\n          IF (XNEG) X = -X\t\t\n          V = X\t\t\t\t\n          EATNUM = ADIGIT\t\t\n        END FUNCTION EATNUM\t\n\n        SUBROUTINE FP8DIGITS(X,BASE,TEXT,L)\t\nConverts a number X to a specified BASE. For integers, successive division by BASE, for fractions, successive multiplication.\n         REAL*8 X,T\t\t\n         INTEGER BASE\t\t\n         CHARACTER*(*) TEXT\t\n         INTEGER L\t\t\n         INTEGER N,ND\t\t\n         INTEGER D\t\t\n         LOGICAL NEG\t\t\n          IF (BASE.LE.1 .OR. BASE.GT.LEN(DIGIT)) BASE = 10\t\n          WRITE (TEXT,1) BASE\t\n    1     FORMAT (\"Base\",I3)\t\n          T = X\t\t\t\n          N = T\t\t\t\n          T = ABS(T - N)\t\n          NEG = N .LT. 0\t\n          IF (NEG) N = -N\t\n          L = LEN(TEXT)\t\t\n          ND = 0\t\t\nCrunch the integer part. Use the tail end of TEXT as a scratchpad, as the size of N is unassessed.\n   10     D = MOD(N,BASE)\t\t\n          TEXT(L:L) = DIGIT(D+1:D+1)\t\n          ND = ND + 1\t\t\t\n          N = N/BASE\t\t\t\n          L = L - 1\t\t\t\n          IF (L.LE.0) THEN\t\t\n            TEXT = \"Overflow\n            L = MIN(9,LEN(TEXT))\t\n           RETURN\t\t\t\n          END IF\t\t\t\n          IF (N.GT.0) GO TO 10\t\t\n          IF (NEG) THEN\t\t\t\n            TEXT(L:L) = \"-\"\t\t\n            L = L - 1\t\t\t\n          END IF\t\t\t\n          N = LEN(TEXT) - L\t\t\n          TEXT(9:9 + N - 1) = TEXT(L + 1:)\t\n          L = 9 + N\t\t\t\n          TEXT(L:L) = \".\"\t\t\nCrunch through the fractional part until nothing remains.\n          DO WHILE(T.GT.0)\t\n            IF (L.GE.LEN(TEXT)) THEN\t\n              L = LEN(TEXT)\t\t\n              TEXT(L:L) = \"~\"\t\t\n             RETURN\t\t\n            END IF\t\t\n            T = T*BASE\t\t\n            N = T\t\t\n            T = T - N\t\t\n            L = L + 1\t\t\n            TEXT(L:L) = DIGIT(N+1:N+1)\t\n            ND = ND + 1\t\t\n          END DO\t\t\nCast forth an addendum, to save the reader from mumbling while counting long strings of digits.\n          IF (LEN(TEXT) - L .GT. 11) THEN\t\n            WRITE (TEXT(L + 2:),11) ND\t\t\n   11       FORMAT (\"Digits:\",I3)\t\t\n            L = L + 1 + 10\t\t\t\n          END IF\t\t\t\t\n        END SUBROUTINE FP8DIGITS\t\n      END MODULE REBASE\t\n\n      PROGRAM TESTSOME\nCheck some conversions from one base to another.\n      USE REBASE\n      INTEGER N\t\t\n      PARAMETER (N = 5)\t\t\n      CHARACTER*12 TEXT(N)\t\n      DATA TEXT/\"23.34375\",\"10111.01011\",\"1011.1101\",\"11.90625\",\"-666\"/\t\n      DOUBLE PRECISION V\t\n      INTEGER I,L,BASE\t\t\n      CHARACTER*88 BACK\t\t\n\n      WRITE (6,1)\t\n    1 FORMAT (\"Test text in base\",3X,\"Value in base 10\")\nChug through the tests.\n      DO BASE = 10,2,-8\t\n        DO I = 1,N\t\t\n          WRITE (6,11) TEXT(I),BASE\t\n   11     FORMAT (A,I5,$)\t\t\n          IF (.NOT.EATNUM(TEXT(I),BASE,V)) THEN\t\n            WRITE (6,*) \"Not a good number\n           ELSE\t\t\t\t\n            WRITE (BACK,*) V\t\t\t\n            WRITE (6,12) BACK(1:20)\t\t\n   12       FORMAT (A,$)\t\t\t\n            CALL FP8DIGITS(V,2,BACK,L)\t\t\n            WRITE (6,13) BACK(1:L)\t\t\n   13       FORMAT (A)\t\t\t\t\n            CALL FP8DIGITS(V,10,BACK,L)\t\t\n            WRITE (6,14) BACK(1:L)\t\t\n   14       FORMAT (37X,A)\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n      END DO\t\t\n      END\t\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 388732, "name": "Decimal floating point number to binary", "source": "Translate Fortran to Java:       MODULE REBASE\t\n       CHARACTER*36 DIGIT\t\n       PARAMETER (DIGIT = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\t\n       CONTAINS\t\t\n        LOGICAL FUNCTION EATNUM(ACARD,BASE,V)\t\nChews into the likes of 666, -666.666, .666 with their variations.\nCompletes with the value in V, success as the result.\nCould check that no digit exceeds the specified BASE usage, but that would mean an error message...\nConcocted by R.N.McLean (whom God preserve) May XXMM.\nClunky usage of ICHAR encourages the compaq compiler to employ single-character-at-a-time usage.\n         CHARACTER*(*) ACARD\t\n         INTEGER BASE\t\t\n         DOUBLE PRECISION V\t\n         DOUBLE PRECISION X\t\n         INTEGER D,DD\t\t\n         INTEGER L2,LC\t\t\n         INTEGER*1 C\t\t\n         LOGICAL ADIGIT,XNEG\t\n          ADIGIT = .FALSE.\t\n          XNEG = .FALSE.\t\n          DD = 0\t\t\n          X = 0\t\t\t\n          L2 = 1\t\t\n          LC = LEN(ACARD)\t\n          IF (L2.GT.LC) GO TO 20\t\nChew into the number. Admit a possible leading sign, then digits.\n          C = ICHAR(ACARD(L2:L2))\t\n          IF (C.EQ.ICHAR(\"+\")) GO TO 1\t\n          IF (C.NE.ICHAR(\"-\")) GO TO 2\t\n          XNEG = .TRUE.\t\t\n    1     L2 = L2 + 1\t\t\n          IF (L2.GT.LC) GO TO 20\t\n    2     D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 10\t\n          X = D\t\t\t\t\n          ADIGIT = .TRUE.\t\t\n    3     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D .LT. 0) GO TO 10\t\n          X = X*BASE + D\t\t\n          GO TO 3\t\t\t\nConsider any decimal digits, introduced by a decimal point.\n   10     IF (ICHAR(ACARD(L2:L2)).EQ.ICHAR(\".\")) GO TO 11\t\n          IF (ICHAR(ACARD(L2:L2)).NE.ICHAR(\"\u00b7\")) GO TO 20\t\n   11     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 20\t\n          X = X*BASE + D\t\t\n          DD = 1\t\t\t\n          ADIGIT = .TRUE.\t\t\n   12     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D < 0 .OR. 9 < D) GO TO 20\t\n          X = X*BASE + D\t\t\t\n          DD = DD + 1\t\t\t\n          GO TO 12\t\t\t\nCan't consider any exponent part, started by an \"E\" or \"D\", as these may be possible digit symbols.\n   20     IF (DD .GT. 0) X = X/BASE**DD\t\n          IF (XNEG) X = -X\t\t\n          V = X\t\t\t\t\n          EATNUM = ADIGIT\t\t\n        END FUNCTION EATNUM\t\n\n        SUBROUTINE FP8DIGITS(X,BASE,TEXT,L)\t\nConverts a number X to a specified BASE. For integers, successive division by BASE, for fractions, successive multiplication.\n         REAL*8 X,T\t\t\n         INTEGER BASE\t\t\n         CHARACTER*(*) TEXT\t\n         INTEGER L\t\t\n         INTEGER N,ND\t\t\n         INTEGER D\t\t\n         LOGICAL NEG\t\t\n          IF (BASE.LE.1 .OR. BASE.GT.LEN(DIGIT)) BASE = 10\t\n          WRITE (TEXT,1) BASE\t\n    1     FORMAT (\"Base\",I3)\t\n          T = X\t\t\t\n          N = T\t\t\t\n          T = ABS(T - N)\t\n          NEG = N .LT. 0\t\n          IF (NEG) N = -N\t\n          L = LEN(TEXT)\t\t\n          ND = 0\t\t\nCrunch the integer part. Use the tail end of TEXT as a scratchpad, as the size of N is unassessed.\n   10     D = MOD(N,BASE)\t\t\n          TEXT(L:L) = DIGIT(D+1:D+1)\t\n          ND = ND + 1\t\t\t\n          N = N/BASE\t\t\t\n          L = L - 1\t\t\t\n          IF (L.LE.0) THEN\t\t\n            TEXT = \"Overflow\n            L = MIN(9,LEN(TEXT))\t\n           RETURN\t\t\t\n          END IF\t\t\t\n          IF (N.GT.0) GO TO 10\t\t\n          IF (NEG) THEN\t\t\t\n            TEXT(L:L) = \"-\"\t\t\n            L = L - 1\t\t\t\n          END IF\t\t\t\n          N = LEN(TEXT) - L\t\t\n          TEXT(9:9 + N - 1) = TEXT(L + 1:)\t\n          L = 9 + N\t\t\t\n          TEXT(L:L) = \".\"\t\t\nCrunch through the fractional part until nothing remains.\n          DO WHILE(T.GT.0)\t\n            IF (L.GE.LEN(TEXT)) THEN\t\n              L = LEN(TEXT)\t\t\n              TEXT(L:L) = \"~\"\t\t\n             RETURN\t\t\n            END IF\t\t\n            T = T*BASE\t\t\n            N = T\t\t\n            T = T - N\t\t\n            L = L + 1\t\t\n            TEXT(L:L) = DIGIT(N+1:N+1)\t\n            ND = ND + 1\t\t\n          END DO\t\t\nCast forth an addendum, to save the reader from mumbling while counting long strings of digits.\n          IF (LEN(TEXT) - L .GT. 11) THEN\t\n            WRITE (TEXT(L + 2:),11) ND\t\t\n   11       FORMAT (\"Digits:\",I3)\t\t\n            L = L + 1 + 10\t\t\t\n          END IF\t\t\t\t\n        END SUBROUTINE FP8DIGITS\t\n      END MODULE REBASE\t\n\n      PROGRAM TESTSOME\nCheck some conversions from one base to another.\n      USE REBASE\n      INTEGER N\t\t\n      PARAMETER (N = 5)\t\t\n      CHARACTER*12 TEXT(N)\t\n      DATA TEXT/\"23.34375\",\"10111.01011\",\"1011.1101\",\"11.90625\",\"-666\"/\t\n      DOUBLE PRECISION V\t\n      INTEGER I,L,BASE\t\t\n      CHARACTER*88 BACK\t\t\n\n      WRITE (6,1)\t\n    1 FORMAT (\"Test text in base\",3X,\"Value in base 10\")\nChug through the tests.\n      DO BASE = 10,2,-8\t\n        DO I = 1,N\t\t\n          WRITE (6,11) TEXT(I),BASE\t\n   11     FORMAT (A,I5,$)\t\t\n          IF (.NOT.EATNUM(TEXT(I),BASE,V)) THEN\t\n            WRITE (6,*) \"Not a good number\n           ELSE\t\t\t\t\n            WRITE (BACK,*) V\t\t\t\n            WRITE (6,12) BACK(1:20)\t\t\n   12       FORMAT (A,$)\t\t\t\n            CALL FP8DIGITS(V,2,BACK,L)\t\t\n            WRITE (6,13) BACK(1:L)\t\t\n   13       FORMAT (A)\t\t\t\t\n            CALL FP8DIGITS(V,10,BACK,L)\t\t\n            WRITE (6,14) BACK(1:L)\t\t\n   14       FORMAT (37X,A)\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n      END DO\t\t\n      END\t\n", "target": "import java.math.BigDecimal;\nimport java.math.MathContext;\nimport java.math.RoundingMode;\n\npublic class DecimalToBinary {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\"23.34375\", \".1\", \"3.1415926535897932\"} ) {\n            String binary = decimalToBinary(new BigDecimal(s));\n            System.out.printf(\"%s => %s%n\", s, binary);\n            System.out.printf(\"%s => %s%n\", binary, binaryToDecimal(binary));\n        }\n    }\n\n    private static BigDecimal binaryToDecimal(String binary) {        \n        return binaryToDecimal(binary, 50);\n    }\n\n    private static BigDecimal binaryToDecimal(String binary, int digits) {\n        int decimalPosition = binary.indexOf(\".\");\n        String integer = decimalPosition >= 0 ? binary.substring(0, decimalPosition) : binary;\n        String fractional = decimalPosition >= 0 ? binary.substring(decimalPosition+1) : \"\";\n\n        \n        BigDecimal result = BigDecimal.ZERO;\n        BigDecimal powTwo = BigDecimal.ONE;\n        BigDecimal two = BigDecimal.valueOf(2);\n        for ( char c : new StringBuilder(integer).reverse().toString().toCharArray() ) {\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')));\n            powTwo = powTwo.multiply(two);\n        }\n        \n        \n        MathContext mc = new MathContext(digits);\n        powTwo = BigDecimal.ONE;\n        for ( char c : fractional.toCharArray() ) {\n            powTwo = powTwo.divide(two);\n            result = result.add(powTwo.multiply(BigDecimal.valueOf(c - '0')), mc);\n        }\n        \n        return result;\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal) {\n        return decimalToBinary(decimal, 50);\n    }\n    \n    private static String decimalToBinary(BigDecimal decimal, int digits) {\n        BigDecimal integer = decimal.setScale(0, RoundingMode.FLOOR);\n        BigDecimal fractional = decimal.subtract(integer);\n        \n        StringBuilder sb = new StringBuilder();\n\n        \n        BigDecimal two = BigDecimal.valueOf(2);\n        BigDecimal zero = BigDecimal.ZERO;\n        while ( integer.compareTo(zero) > 0 ) {\n            BigDecimal[] result = integer.divideAndRemainder(two);\n            sb.append(result[1]);\n            integer = result[0];\n        }\n        sb.reverse();\n        \n        \n        int count = 0;\n        if ( fractional.compareTo(zero) != 0 ) {\n            sb.append(\".\");\n        }\n        while ( fractional.compareTo(zero) != 0 ) {\n            count++;\n            fractional = fractional.multiply(two);\n            sb.append(fractional.setScale(0, RoundingMode.FLOOR));\n            if ( fractional.compareTo(BigDecimal.ONE) >= 0 ) {\n                fractional = fractional.subtract(BigDecimal.ONE);\n            }\n            if ( count >= digits ) {\n                break;\n            }\n        }\n        \n        return sb.toString();\n    }\n\n}\n"}
{"id": 388733, "name": "Gauss-Jordan matrix inversion", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n      SUBROUTINE GJINV (A, LDA, N, B, LDB, IERR)\n       IMPLICIT NONE\n       INTEGER LDA, N, LDB, IERR\n       REAL A(LDA,N), B(LDB,N)\n\n       REAL EPS                                  \n       PARAMETER (EPS = 1.1920929E-07)\n       INTEGER I, J, K, P                        \n       REAL F, TOL\n\n\n\n\n       IF (N < 1) THEN            \n         IERR = -1\n         RETURN\n       ELSE IF (N > LDA .OR. N > LDB) THEN\n         IERR = -2\n         RETURN\n       END IF\n       IERR = 0\n\n       F = 0.                     \n       DO J = 1, N\n         DO I = 1, N\n           F = F + A(I,J)**2\n         END DO\n       END DO\n       F = SQRT(F)\n       TOL = F * EPS\n\n       DO J = 1, N                \n         DO I = 1, N\n           IF (I .EQ. J) THEN\n             B(I,J) = 1.\n           ELSE\n             B(I,J) = 0.\n           END IF\n         END DO\n       END DO\n\n\n       DO K = 1, N\n         F = ABS(A(K,K))          \n         P = K\n         DO I = K+1, N\n           IF (ABS(A(I,K)) > F) THEN\n             F = ABS(A(I,K))\n             P = I\n           END IF\n         END DO\n\n         IF (F < TOL) THEN        \n           IERR = 1\n           RETURN\n         END IF\n\n         IF (P .NE. K) THEN       \n           DO J = K, N\n             F = A(K,J)\n             A(K,J) = A(P,J)\n             A(P,J) = F\n           END DO\n           DO J = 1, N\n             F = B(K,J)\n             B(K,J) = B(P,J)\n             B(P,J) = F\n           END DO\n         END IF\n\n         F = 1. / A(K,K)          \n         DO J = K, N\n           A(K,J) = A(K,J) * F\n         END DO\n         DO J = 1, N\n           B(K,J) = B(K,J) * F\n         END DO\n\n         DO 10 I = 1, N           \n           IF (I .EQ. K) GO TO 10\n           F = A(I,K)\n           DO J = K, N\n             A(I,J) = A(I,J) - A(K,J) * F\n           END DO\n           DO J = 1, N\n             B(I,J) = B(I,J) - B(K,J) * F\n           END DO\n  10     CONTINUE\n       END DO\n\n       RETURN\n      END  \n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 388734, "name": "Gauss-Jordan matrix inversion", "source": "Translate Fortran to Java: \n\n\n\n\n\n\n\n\n\n\n\n\n      SUBROUTINE GJINV (A, LDA, N, B, LDB, IERR)\n       IMPLICIT NONE\n       INTEGER LDA, N, LDB, IERR\n       REAL A(LDA,N), B(LDB,N)\n\n       REAL EPS                                  \n       PARAMETER (EPS = 1.1920929E-07)\n       INTEGER I, J, K, P                        \n       REAL F, TOL\n\n\n\n\n       IF (N < 1) THEN            \n         IERR = -1\n         RETURN\n       ELSE IF (N > LDA .OR. N > LDB) THEN\n         IERR = -2\n         RETURN\n       END IF\n       IERR = 0\n\n       F = 0.                     \n       DO J = 1, N\n         DO I = 1, N\n           F = F + A(I,J)**2\n         END DO\n       END DO\n       F = SQRT(F)\n       TOL = F * EPS\n\n       DO J = 1, N                \n         DO I = 1, N\n           IF (I .EQ. J) THEN\n             B(I,J) = 1.\n           ELSE\n             B(I,J) = 0.\n           END IF\n         END DO\n       END DO\n\n\n       DO K = 1, N\n         F = ABS(A(K,K))          \n         P = K\n         DO I = K+1, N\n           IF (ABS(A(I,K)) > F) THEN\n             F = ABS(A(I,K))\n             P = I\n           END IF\n         END DO\n\n         IF (F < TOL) THEN        \n           IERR = 1\n           RETURN\n         END IF\n\n         IF (P .NE. K) THEN       \n           DO J = K, N\n             F = A(K,J)\n             A(K,J) = A(P,J)\n             A(P,J) = F\n           END DO\n           DO J = 1, N\n             F = B(K,J)\n             B(K,J) = B(P,J)\n             B(P,J) = F\n           END DO\n         END IF\n\n         F = 1. / A(K,K)          \n         DO J = K, N\n           A(K,J) = A(K,J) * F\n         END DO\n         DO J = 1, N\n           B(K,J) = B(K,J) * F\n         END DO\n\n         DO 10 I = 1, N           \n           IF (I .EQ. K) GO TO 10\n           F = A(I,K)\n           DO J = K, N\n             A(I,J) = A(I,J) - A(K,J) * F\n           END DO\n           DO J = 1, N\n             B(I,J) = B(I,J) - B(K,J) * F\n           END DO\n  10     CONTINUE\n       END DO\n\n       RETURN\n      END  \n", "target": "\n\nimport java.util.Random;\n\npublic class GaussJordan {\n    public static void main(String[] args) {\n        int rows = 5;\n        Matrix m = new Matrix(rows, rows);\n        Random r = new Random();\n        for (int row = 0; row < rows; ++row) {\n            for (int column = 0; column < rows; ++column)\n                m.set(row, column, r.nextDouble());\n        }\n        System.out.println(\"Matrix:\");\n        m.print();\n        System.out.println(\"Inverse:\");\n        Matrix inv = m.inverse();\n        inv.print();\n        System.out.println(\"Product of matrix and inverse:\");\n        Matrix.product(m, inv).print();\n    }\n}\n"}
{"id": 388735, "name": "Welch's t-test", "source": "Translate Fortran to Java: subroutine welch_ttest(n1, x1, n2, x2, t, df, p)\n    use tdf_int\n    implicit none\n    integer :: n1, n2\n    double precision :: x1(n1), x2(n2)\n    double precision :: m1, m2, v1, v2, t, df, p\n    m1 = sum(x1) / n1\n    m2 = sum(x2) / n2\n    v1 = sum((x1 - m1)**2) / (n1 - 1)\n    v2 = sum((x2 - m2)**2) / (n2 - 1)\n    t = (m1 - m2) / sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / &\n         (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2d0 * tdf(-abs(t), df)\nend subroutine\n\nprogram pvalue\n    use betai_int\n    implicit none\n    double precision :: x(4) = [3d0, 4d0, 1d0, 2.1d0]\n    double precision :: y(3) = [490.2d0, 340.0d0, 433.9d0]\n    double precision :: t, df, p\n    call welch_ttest(4, x, 3, y, t, df, p)\n    print *, t, df, p\n    print *, betai(df / (t**2 + df), 0.5d0 * df, 0.5d0)\nend program\n", "target": "import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n"}
{"id": 388736, "name": "Welch's t-test", "source": "Translate Fortran to Java: subroutine welch_ttest(n1, x1, n2, x2, t, df, p)\n    use tdf_int\n    implicit none\n    integer :: n1, n2\n    double precision :: x1(n1), x2(n2)\n    double precision :: m1, m2, v1, v2, t, df, p\n    m1 = sum(x1) / n1\n    m2 = sum(x2) / n2\n    v1 = sum((x1 - m1)**2) / (n1 - 1)\n    v2 = sum((x2 - m2)**2) / (n2 - 1)\n    t = (m1 - m2) / sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / &\n         (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2d0 * tdf(-abs(t), df)\nend subroutine\n\nprogram pvalue\n    use betai_int\n    implicit none\n    double precision :: x(4) = [3d0, 4d0, 1d0, 2.1d0]\n    double precision :: y(3) = [490.2d0, 340.0d0, 433.9d0]\n    double precision :: t, df, p\n    call welch_ttest(4, x, 3, y, t, df, p)\n    print *, t, df, p\n    print *, betai(df / (t**2 + df), 0.5d0 * df, 0.5d0)\nend program\n", "target": "import org.apache.commons.math3.distribution.TDistribution;\n\npublic class WelchTTest {\n    public static double[] meanvar(double[] a) {\n        double m = 0.0, v = 0.0;\n        int n = a.length;\n        \n        for (double x: a) {\n            m += x;\n        }\n        m /= n;\n        \n        for (double x: a) {\n            v += (x - m) * (x - m);\n        }\n        v /= (n - 1);\n        \n        return new double[] {m, v};\n    \n    }\n    \n    public static double[] welch_ttest(double[] x, double[] y) {\n        double mx, my, vx, vy, t, df, p;\n        double[] res;\n        int nx = x.length, ny = y.length;\n        \n        res = meanvar(x);\n        mx = res[0];\n        vx = res[1];\n        \n        res = meanvar(y);\n        my = res[0];\n        vy = res[1];\n        \n        t = (mx-my)/Math.sqrt(vx/nx+vy/ny);\n        df = Math.pow(vx/nx+vy/ny, 2)/(vx*vx/(nx*nx*(nx-1))+vy*vy/(ny*ny*(ny-1)));\n        TDistribution dist = new TDistribution(df);\n        p = 2.0*dist.cumulativeProbability(-Math.abs(t));\n        return new double[] {t, df, p};\n    }\n\n    public static void main(String[] args) {\n        double x[] = {3.0, 4.0, 1.0, 2.1};\n        double y[] = {490.2, 340.0, 433.9};\n        double res[] = welch_ttest(x, y);\n        System.out.println(\"t = \" + res[0]);\n        System.out.println(\"df = \" + res[1]);\n        System.out.println(\"p = \" + res[2]);\n    }\n}\n"}
{"id": 411496, "name": "Verify distribution uniformity_Naive", "source": "Translate Fortran to Python: subroutine distcheck(randgen, n, delta)\n\n  interface\n    function randgen\n      integer :: randgen \n    end function randgen\n  end interface\n  \n  real, intent(in) :: delta\n  integer, intent(in) :: n\n  integer :: i, mval, lolim, hilim\n  integer, allocatable :: buckets(:)\n  integer, allocatable :: rnums(:)\n  logical :: skewed = .false.\n     \n  allocate(rnums(n))\n  \n  do i = 1, n\n    rnums(i) = randgen()\n  end do\n\n  mval = maxval(rnums)\n  allocate(buckets(mval))\n  buckets = 0\n  \n  do i = 1, n\n    buckets(rnums(i)) = buckets(rnums(i)) + 1\n  end do\n\n  lolim = n/mval - n/mval*delta\n  hilim = n/mval + n/mval*delta\n  \n  do i = 1, mval  \n    if(buckets(i) < lolim .or. buckets(i) > hilim) then\n      write(*,\"(a,i0,a,i0,a,i0)\") \"Distribution potentially skewed for bucket \", i, \"   Expected: \", &\n                                   n/mval, \"   Actual: \", buckets(i)\n      skewed = .true.\n    end if\n  end do \n\n  if (.not. skewed) write(*,\"(a)\") \"Distribution uniform\"\n  \n  deallocate(rnums)\n  deallocate(buckets)\n    \nend subroutine\n", "target": "from collections import Counter\nfrom pprint import pprint as pp\n\ndef distcheck(fn, repeats, delta):\n    \n    bin = Counter(fn() for i in range(repeats))\n    target = repeats // len(bin)\n    deltacount = int(delta / 100. * target)\n    assert all( abs(target - count) < deltacount\n                for count in bin.values() ), \"Bin distribution skewed from %i +/- %i: %s\" % (\n                    target, deltacount, [ (key, target - count)\n                                          for key, count in sorted(bin.items()) ]\n                    )\n    pp(dict(bin))\n"}
{"id": 411497, "name": "Use another language to call a function", "source": "Translate Fortran to Python: \n\n\nfunction  fortran_query(data, length) result(answer) bind(c, name='Query')\n   use, intrinsic  :: iso_c_binding, only: c_char, c_int, c_size_t, c_null_char\n   implicit none\n   character(len=1,kind=c_char), dimension(length),  intent(inout) ::  data\n   integer(c_size_t), intent(inout) :: length\n   integer(c_int) :: answer\n   answer = 0\n   if(length<10) return\n   data = transfer(\"Here I am\"//c_null_char, data)\n   length = 10_c_size_t\n   answer = 1\nend function fortran_query\n", "target": "\n\ndef query(buffer_length):\n    message = b'Here am I'\n    L = len(message)\n    return message[0:L*(L <= buffer_length)]\n"}
{"id": 411498, "name": "Find first and last set bit of a long integer", "source": "Translate Fortran to Python: program bits\n    implicit none\n    integer :: n = 1, i\n\n    do i = 1, 6\n        print \"(B32,2(' ',I2))\", n, trailz(n), 31 - leadz(n)\n        n = 42 * n\n    end do\nend program\n", "target": "def msb(x):\n    return x.bit_length() - 1\n\ndef lsb(x):\n    return msb(x & -x)\n\nfor i in range(6):\n    x = 42 ** i\n    print(\"%10d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n\nfor i in range(6):\n    x = 1302 ** i\n    print(\"%20d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n"}
{"id": 411499, "name": "Find first and last set bit of a long integer", "source": "Translate Fortran to Python: program bits\n    implicit none\n    integer :: n = 1, i\n\n    do i = 1, 6\n        print \"(B32,2(' ',I2))\", n, trailz(n), 31 - leadz(n)\n        n = 42 * n\n    end do\nend program\n", "target": "def msb(x):\n    return x.bit_length() - 1\n\ndef lsb(x):\n    return msb(x & -x)\n\nfor i in range(6):\n    x = 42 ** i\n    print(\"%10d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n\nfor i in range(6):\n    x = 1302 ** i\n    print(\"%20d MSB: %2d LSB: %2d\" % (x, msb(x), lsb(x)))\n"}
{"id": 411500, "name": "Ray-casting algorithm", "source": "Translate Fortran to Python: module Polygons\n  use Points_Module\n  implicit none\n\n  type polygon\n     type(point), dimension(:), allocatable :: points\n     integer, dimension(:), allocatable :: vertices\n  end type polygon\n\ncontains\n\n  function create_polygon(pts, vt)\n    type(polygon) :: create_polygon\n    type(point), dimension(:), intent(in) :: pts\n    integer, dimension(:), intent(in) :: vt\n\n    integer :: np, nv\n\n    np = size(pts,1)\n    nv = size(vt,1)\n\n    allocate(create_polygon%points(np), create_polygon%vertices(nv))\n    create_polygon%points = pts\n    create_polygon%vertices = vt\n\n  end function create_polygon\n\n  subroutine free_polygon(pol)\n    type(polygon), intent(inout) :: pol\n\n    deallocate(pol%points, pol%vertices)\n\n  end subroutine free_polygon\n\nend module Polygons\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\nimport sys\n\nPt = namedtuple('Pt', 'x, y')               \nEdge = namedtuple('Edge', 'a, b')           \nPoly = namedtuple('Poly', 'name, edges')    \n\n_eps = 0.00001\n_huge = sys.float_info.max\n_tiny = sys.float_info.min\n\ndef rayintersectseg(p, edge):\n    \n    a,b = edge\n    if a.y > b.y:\n        a,b = b,a\n    if p.y == a.y or p.y == b.y:\n        p = Pt(p.x, p.y + _eps)\n\n    intersect = False\n\n    if (p.y > b.y or p.y < a.y) or (\n        p.x > max(a.x, b.x)):\n        return False\n\n    if p.x < min(a.x, b.x):\n        intersect = True\n    else:\n        if abs(a.x - b.x) > _tiny:\n            m_red = (b.y - a.y) / float(b.x - a.x)\n        else:\n            m_red = _huge\n        if abs(a.x - p.x) > _tiny:\n            m_blue = (p.y - a.y) / float(p.x - a.x)\n        else:\n            m_blue = _huge\n        intersect = m_blue >= m_red\n    return intersect\n\ndef _odd(x): return x%2 == 1\n\ndef ispointinside(p, poly):\n    ln = len(poly)\n    return _odd(sum(rayintersectseg(p, edge)\n                    for edge in poly.edges ))\n\ndef polypp(poly):\n    print (\"\\n  Polygon(name='%s', edges=(\" % poly.name)\n    print ('   ', ',\\n    '.join(str(e) for e in poly.edges) + '\\n    ))')\n\nif __name__ == '__main__':\n    polys = [\n      Poly(name='square', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0))\n        )),\n      Poly(name='square_hole', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=0, y=0)),\n        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=7.5, y=2.5)),\n        Edge(a=Pt(x=7.5, y=2.5), b=Pt(x=7.5, y=7.5)),\n        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=2.5, y=7.5)),\n        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=2.5, y=2.5))\n        )),\n      Poly(name='strange', edges=(\n        Edge(a=Pt(x=0, y=0), b=Pt(x=2.5, y=2.5)),\n        Edge(a=Pt(x=2.5, y=2.5), b=Pt(x=0, y=10)),\n        Edge(a=Pt(x=0, y=10), b=Pt(x=2.5, y=7.5)),\n        Edge(a=Pt(x=2.5, y=7.5), b=Pt(x=7.5, y=7.5)),\n        Edge(a=Pt(x=7.5, y=7.5), b=Pt(x=10, y=10)),\n        Edge(a=Pt(x=10, y=10), b=Pt(x=10, y=0)),\n        Edge(a=Pt(x=10, y=0), b=Pt(x=2.5, y=2.5))\n        )),\n      Poly(name='exagon', edges=(\n        Edge(a=Pt(x=3, y=0), b=Pt(x=7, y=0)),\n        Edge(a=Pt(x=7, y=0), b=Pt(x=10, y=5)),\n        Edge(a=Pt(x=10, y=5), b=Pt(x=7, y=10)),\n        Edge(a=Pt(x=7, y=10), b=Pt(x=3, y=10)),\n        Edge(a=Pt(x=3, y=10), b=Pt(x=0, y=5)),\n        Edge(a=Pt(x=0, y=5), b=Pt(x=3, y=0))\n        )),\n      ]\n    testpoints = (Pt(x=5, y=5), Pt(x=5, y=8),\n                  Pt(x=-10, y=5), Pt(x=0, y=5),\n                  Pt(x=10, y=5), Pt(x=8, y=5),\n                  Pt(x=10, y=10))\n    \n    print (\"\\n TESTING WHETHER POINTS ARE WITHIN POLYGONS\")\n    for poly in polys:\n        polypp(poly)\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[:3]))\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[3:6]))\n        print ('   ', '\\t'.join(\"%s: %s\" % (p, ispointinside(p, poly))\n                               for p in testpoints[6:]))\n"}
{"id": 411501, "name": "24 game", "source": "Translate Fortran to Python: program game_24\n  implicit none\n  real               :: vector(4), reals(11), result, a, b, c, d\n  integer            :: numbers(4), ascii(11), i\n  character(len=11)  :: expression\n  character          :: syntax(11)\n  \n  character, parameter :: one(11)   = (/ '(','(','1','x','1',')','x','1',')','x','1' /)\n  character, parameter :: two(11)   = (/ '(','1','x','(','1','x','1',')',')','x','1' /)\n  character, parameter :: three(11) = (/ '1','x','(','(','1','x','1',')','x','1',')' /)\n  character, parameter :: four(11)  = (/ '1','x','(','1','x','(','1','x','1',')',')' /)\n  character, parameter :: five(11)  = (/ '(','1','x','1',')','x','(','1','x','1',')' /)\n  \n  do\n    call random_number(vector)\n    numbers = 9 * vector + 1\n    write (*,*) 'Digits: ',numbers\n    write (*,'(a)',advance='no') 'Your expression: '\n    read (*,'(a11)') expression\n\n    forall (i=1:11) syntax(i) = expression(i:i)\n    ascii = iachar(syntax)\n    where (syntax >= '0' .and. syntax <= '9')\n      syntax = '1'  \n    elsewhere (syntax == '+' .or. syntax == '-' .or. syntax == '*' .or. syntax == '/')\n      syntax = 'x'  \n    elsewhere (syntax /= '(' .and. syntax /= ')')\n      syntax = '-'  \n    end where\n\n    reals = real(ascii-48)\n    if ( all(syntax == one) ) then\n      a = reals(3); b = reals(5); c = reals(8); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(op(a,4,b),7,c),10,d)\n    else if ( all(syntax == two) ) then\n      a = reals(2); b = reals(5); c = reals(7); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,op(b,6,c)),10,d)\n    else if ( all(syntax == three) ) then\n      a = reals(1); b = reals(5); c = reals(7); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(op(b,6,c),9,d))\n    else if ( all(syntax == four) ) then\n      a = reals(1); b = reals(4); c = reals(7); d = reals(9)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(b,5,op(c,8,d)))\n    else if ( all(syntax == five) ) then\n      a = reals(2); b = reals(4); c = reals(8); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,b),6,op(c,9,d))\n    else\n      stop 'Input string: incorrect syntax.'\n    end if\n\n    if ( abs(result-24.0) < epsilon(1.0) ) then\n      write (*,*) 'You won\n    else\n      write (*,*) 'Your result (',result,') is incorrect\n    end if\n  \n    write (*,'(a)',advance='no') 'Another one? [y/n] '\n    read (*,'(a1)') expression\n    if ( expression(1:1) == 'n' .or. expression(1:1) == 'N' ) then\n      stop\n    end if  \n  end do\n  \ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in) :: x,y\n    select case ( char(ascii(c)) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n  \n  subroutine check_numbers(a,b,c,d)\n    real, intent(in) :: a,b,c,d\n    integer          :: test(4)\n    test = (/ nint(a),nint(b),nint(c),nint(d) /)\n    call Insertion_Sort(numbers)\n    call Insertion_Sort(test)\n    if ( any(test /= numbers) ) then\n      stop 'You cheat\u00a0;-) (Incorrect numbers)'\n    end if\n  end subroutine check_numbers\n  \n  pure subroutine Insertion_Sort(a)\n    integer, intent(inout) :: a(:)\n    integer                :: temp, i, j\n    do i=2,size(a)\n      j = i-1\n      temp = a(i)\n      do while ( j>=1 .and. a(j)>temp )\n        a(j+1) = a(j)\n        j = j - 1\n      end do\n      a(j+1) = temp\n    end do\n  end subroutine Insertion_Sort\n\nend program game_24\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 411502, "name": "24 game", "source": "Translate Fortran to Python: program game_24\n  implicit none\n  real               :: vector(4), reals(11), result, a, b, c, d\n  integer            :: numbers(4), ascii(11), i\n  character(len=11)  :: expression\n  character          :: syntax(11)\n  \n  character, parameter :: one(11)   = (/ '(','(','1','x','1',')','x','1',')','x','1' /)\n  character, parameter :: two(11)   = (/ '(','1','x','(','1','x','1',')',')','x','1' /)\n  character, parameter :: three(11) = (/ '1','x','(','(','1','x','1',')','x','1',')' /)\n  character, parameter :: four(11)  = (/ '1','x','(','1','x','(','1','x','1',')',')' /)\n  character, parameter :: five(11)  = (/ '(','1','x','1',')','x','(','1','x','1',')' /)\n  \n  do\n    call random_number(vector)\n    numbers = 9 * vector + 1\n    write (*,*) 'Digits: ',numbers\n    write (*,'(a)',advance='no') 'Your expression: '\n    read (*,'(a11)') expression\n\n    forall (i=1:11) syntax(i) = expression(i:i)\n    ascii = iachar(syntax)\n    where (syntax >= '0' .and. syntax <= '9')\n      syntax = '1'  \n    elsewhere (syntax == '+' .or. syntax == '-' .or. syntax == '*' .or. syntax == '/')\n      syntax = 'x'  \n    elsewhere (syntax /= '(' .and. syntax /= ')')\n      syntax = '-'  \n    end where\n\n    reals = real(ascii-48)\n    if ( all(syntax == one) ) then\n      a = reals(3); b = reals(5); c = reals(8); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(op(a,4,b),7,c),10,d)\n    else if ( all(syntax == two) ) then\n      a = reals(2); b = reals(5); c = reals(7); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,op(b,6,c)),10,d)\n    else if ( all(syntax == three) ) then\n      a = reals(1); b = reals(5); c = reals(7); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(op(b,6,c),9,d))\n    else if ( all(syntax == four) ) then\n      a = reals(1); b = reals(4); c = reals(7); d = reals(9)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(b,5,op(c,8,d)))\n    else if ( all(syntax == five) ) then\n      a = reals(2); b = reals(4); c = reals(8); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,b),6,op(c,9,d))\n    else\n      stop 'Input string: incorrect syntax.'\n    end if\n\n    if ( abs(result-24.0) < epsilon(1.0) ) then\n      write (*,*) 'You won\n    else\n      write (*,*) 'Your result (',result,') is incorrect\n    end if\n  \n    write (*,'(a)',advance='no') 'Another one? [y/n] '\n    read (*,'(a1)') expression\n    if ( expression(1:1) == 'n' .or. expression(1:1) == 'N' ) then\n      stop\n    end if  \n  end do\n  \ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in) :: x,y\n    select case ( char(ascii(c)) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n  \n  subroutine check_numbers(a,b,c,d)\n    real, intent(in) :: a,b,c,d\n    integer          :: test(4)\n    test = (/ nint(a),nint(b),nint(c),nint(d) /)\n    call Insertion_Sort(numbers)\n    call Insertion_Sort(test)\n    if ( any(test /= numbers) ) then\n      stop 'You cheat\u00a0;-) (Incorrect numbers)'\n    end if\n  end subroutine check_numbers\n  \n  pure subroutine Insertion_Sort(a)\n    integer, intent(inout) :: a(:)\n    integer                :: temp, i, j\n    do i=2,size(a)\n      j = i-1\n      temp = a(i)\n      do while ( j>=1 .and. a(j)>temp )\n        a(j+1) = a(j)\n        j = j - 1\n      end do\n      a(j+1) = temp\n    end do\n  end subroutine Insertion_Sort\n\nend program game_24\n", "target": "\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n"}
{"id": 411503, "name": "Hofstadter Q sequence", "source": "Translate Fortran to Python: Calculate the Hofstadter Q-sequence, using a big array rather than recursion.\n      INTEGER ENUFF\n      PARAMETER (ENUFF = 100000)\n      INTEGER Q(ENUFF)\t\n\n      Q(1) = 1\t\t\n      Q(2) = 1\n      Q(3:) = -123456789\n      DO I = 3,ENUFF\t\n        Q(I) = Q(I - Q(I - 1)) + Q(I - Q(I - 2))\t\n      END DO\nCast forth results as per the specification.\n      WRITE (6,1) Q(1:10)\t\t\n    1 FORMAT (\"First ten values:\",10I2)\t\n      WRITE (6,*) \"Q(1000) =\",Q(1000)\t\n      WRITE (6,3) ENUFF,COUNT(Q(2:ENUFF) < Q(1:ENUFF - 1))\t\n    3 FORMAT (\"Count of those elements 2:\",I0,\n     1 \" which are less than their predecessor: \",I0)\t\nCurry favour by allowing enquiries.\n   10 WRITE (6,11) ENUFF\n   11 FORMAT (\"Nominate an index (in 1:\",I0,\"): \",$)\t\n      READ (5,*,END = 999, ERR = 999) I\t\n      IF (I.GT.0 .AND. I.LE.ENUFF) THEN\t\n        WRITE (6,12) I,Q(I)\t\t\n   12   FORMAT (\"Q(\",I0,\") = \",I0)\t\n        GO TO 10\t\t\t\n      END IF\t\t\nClosedown.\n  999 WRITE (6,*) \"Bye.\"\n      END\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 411504, "name": "Hofstadter Q sequence", "source": "Translate Fortran to Python: Calculate the Hofstadter Q-sequence, using a big array rather than recursion.\n      INTEGER ENUFF\n      PARAMETER (ENUFF = 100000)\n      INTEGER Q(ENUFF)\t\n\n      Q(1) = 1\t\t\n      Q(2) = 1\n      Q(3:) = -123456789\n      DO I = 3,ENUFF\t\n        Q(I) = Q(I - Q(I - 1)) + Q(I - Q(I - 2))\t\n      END DO\nCast forth results as per the specification.\n      WRITE (6,1) Q(1:10)\t\t\n    1 FORMAT (\"First ten values:\",10I2)\t\n      WRITE (6,*) \"Q(1000) =\",Q(1000)\t\n      WRITE (6,3) ENUFF,COUNT(Q(2:ENUFF) < Q(1:ENUFF - 1))\t\n    3 FORMAT (\"Count of those elements 2:\",I0,\n     1 \" which are less than their predecessor: \",I0)\t\nCurry favour by allowing enquiries.\n   10 WRITE (6,11) ENUFF\n   11 FORMAT (\"Nominate an index (in 1:\",I0,\"): \",$)\t\n      READ (5,*,END = 999, ERR = 999) I\t\n      IF (I.GT.0 .AND. I.LE.ENUFF) THEN\t\n        WRITE (6,12) I,Q(I)\t\t\n   12   FORMAT (\"Q(\",I0,\") = \",I0)\t\n        GO TO 10\t\t\t\n      END IF\t\t\nClosedown.\n  999 WRITE (6,*) \"Bye.\"\n      END\n", "target": "def q(n):\n    if n < 1 or type(n) != int: raise ValueError(\"n must be an int >= 1\")\n    try:\n        return q.seq[n]\n    except IndexError:\n        ans = q(n - q(n - 1)) + q(n - q(n - 2))\n        q.seq.append(ans)\n        return ans\nq.seq = [None, 1, 1]\n\nif __name__ == '__main__':\n    first10 = [q(i) for i in range(1,11)]\n    assert first10 == [1, 1, 2, 3, 3, 4, 5, 5, 6, 6], \"Q() value error(s)\"\n    print(\"Q(n) for n = [1..10] is:\", ', '.join(str(i) for i in first10))\n    assert q(1000) == 502, \"Q(1000) value error\"\n    print(\"Q(1000) =\", q(1000))\n"}
{"id": 411505, "name": "Count occurrences of a substring", "source": "Translate Fortran to Python: program Example\n  implicit none\n  integer :: n\n  \n  n = countsubstring(\"the three truths\", \"th\")\n  write(*,*) n\n  n = countsubstring(\"ababababab\", \"abab\")\n  write(*,*) n\n  n = countsubstring(\"abaabba*bbaba*bbab\", \"a*b\")\n  write(*,*) n\n \ncontains\n\nfunction countsubstring(s1, s2) result(c)\n  character(*), intent(in) :: s1, s2\n  integer :: c, p, posn\n \n  c = 0\n  if(len(s2) == 0) return\n  p = 1\n  do \n    posn = index(s1(p:), s2)\n    if(posn == 0) return\n    c = c + 1\n    p = p + posn + len(s2) - 1\n  end do\nend function\nend program\n", "target": ">>> \"the three truths\".count(\"th\")\n3\n>>> \"ababababab\".count(\"abab\")\n2\n"}
{"id": 411506, "name": "Carmichael 3 strong pseudoprimes", "source": "Translate Fortran to Python:       LOGICAL FUNCTION ISPRIME(N)\t\n       INTEGER N\t\t\t\n       INTEGER F\t\t\t\n        ISPRIME = .FALSE.\t\t\n        DO F = 2,SQRT(DFLOAT(N))\t\n          IF (MOD(N,F).EQ.0) RETURN\t\n        END DO\t\t\t\t\n        ISPRIME = .TRUE.\t\t\n      END FUNCTION ISPRIME\t\t\n\n      PROGRAM CHASE\n      INTEGER P1,P2,P3\t\n      INTEGER H3,D\t\n      INTEGER MSG\t\n      MSG = 6\t\t\n      WRITE (MSG,1)\t\n    1 FORMAT (\"Carmichael numbers that are the product of three primes:\"\n     & /\"    P1  x P2  x P3 =\",9X,\"C\")\n      DO P1 = 2,61\t\n        IF (ISPRIME(P1)) THEN\t\n          DO H3 = 2,P1 - 1\t\t\n            DO D = 1,H3 + P1 - 1\t\t\n              IF (MOD((H3 + P1)*(P1 - 1),D).EQ.0\t\n     &        .AND. (MOD(H3 + MOD(-P1**2,H3),H3) .EQ. MOD(D,H3))) THEN\t\n                P2 = 1 + (P1 - 1)*(H3 + P1)/D\t\n                IF (ISPRIME(P2)) THEN\t\t\n                  P3 = 1 + P1*P2/H3\t\t\t\n                  IF (ISPRIME(P3)) THEN\t\t\t\n                    IF (MOD(P2*P3,P1 - 1).EQ.1) THEN\t\t\n                      WRITE (MSG,2) P1,P2,P3, INT8(P1)*P2*P3\t\t\n    2                 FORMAT (3I6,I12)\n                    END IF\n                  END IF\n                END IF\n              END IF\n            END DO\n          END DO\n        END IF\n      END DO\n      END\n", "target": "class Isprime():\n    \n    multiples = {2}\n    primes = [2]\n    nmax = 2\n    \n    def __init__(self, nmax):\n        if nmax > self.nmax:\n            self.check(nmax)\n\n    def check(self, n):\n        if type(n) == float:\n            if not n.is_integer(): return False\n            n = int(n)\n        multiples = self.multiples\n        if n <= self.nmax:\n            return n not in multiples\n        else:\n            \n            primes, nmax = self.primes, self.nmax\n            newmax = max(nmax*2, n)\n            for p in primes:\n                multiples.update(range(p*((nmax + p + 1) // p), newmax+1, p))\n            for i in range(nmax+1, newmax+1):\n                if i not in multiples:\n                    primes.append(i)\n                    multiples.update(range(i*2, newmax+1, i))\n            self.nmax = newmax\n            return n not in multiples\n\n    __call__ = check\n            \n        \ndef carmichael(p1):\n    ans = []\n    if isprime(p1):\n        for h3 in range(2, p1):\n            g = h3 + p1\n            for d in range(1, g):\n                if (g * (p1 - 1)) % d == 0 and (-p1 * p1) % h3 == d % h3:\n                    p2 = 1 + ((p1 - 1)* g // d)\n                    if isprime(p2):\n                        p3 = 1 + (p1 * p2 // h3)\n                        if isprime(p3):\n                            if (p2 * p3) % (p1 - 1) == 1:\n                                \n                                ans += [tuple(sorted((p1, p2, p3)))]\n    return ans\n                \nisprime = Isprime(2)\n \nans = sorted(sum((carmichael(n) for n in range(62) if isprime(n)), []))\nprint(',\\n'.join(repr(ans[i:i+5])[1:-1] for i in range(0, len(ans)+1, 5)))\n"}
{"id": 411507, "name": "Rock-paper-scissors", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram rpsgame\n\n  integer, parameter :: COMPUTER=1, HAPLESSUSER=2\n  integer, dimension(3) :: rps = (/1,1,1/)\n  real, dimension(3) :: p\n  character :: answer, cc \n  integer :: exhaustion, i\n  real, dimension(2) :: score = (/0, 0/)\n  character(len=8), dimension(3) :: choices = (/'rock    ','paper   ','scissors'/)\n  real :: harvest\n  do exhaustion = 1, 30\n    p = rps/real(sum(rps))\n    p(2) = p(2) + p(1)\n    p(3) = p(3) + p(2)\n    call random_number(harvest)\n    i = sum(merge(1,0,harvest.le.p)) \n    cc = 'rsp'(i:i)\n    write(6, \"(2(A,', '),A,'?  ')\", advance='no')(trim(choices(i)),i=1,size(choices))\n    read(5, *) answer\n    write(6, \"('scoring computer choice (',A,') and your choice (',A,')')\")cc,answer\n    if (answer.eq.cc) then\n      score = score + 0.5\n    else\n      i = HAPLESSUSER\n      if (answer.eq.'r') then\n        if (cc.eq.'p') i = COMPUTER\n      else if (answer.eq.'p') then\n        if (cc.eq.'s') i = COMPUTER\n      else if (answer.eq.'s') then\n        if (cc.eq.'r') i = COMPUTER\n      else\n        exit\n      endif\n      score(i) = score(i) + 1\n    end if\n    i = scan('rps',answer)\n    rps(i) = rps(i) + 1\n  end do\n  if (25 .lt. exhaustion) write(6, *) \"I'm bored out of my skull\"\n  write(6, *)\"Who's keeping score anyway???\"\n  write(6, '(2f5.1)') score\n  if (score(COMPUTER) .lt. score(HAPLESSUSER)) print*,'you won\nend program rpsgame\n", "target": "from random import choice\n\nrules = {'rock': 'paper', 'scissors': 'rock', 'paper': 'scissors'}\nprevious = ['rock', 'paper', 'scissors']\n\nwhile True:\n    human = input('\\nchoose your weapon: ')\n    computer = rules[choice(previous)]  \n\n    if human in ('quit', 'exit'): break\n\n    elif human in rules:\n        previous.append(human)\n        print('the computer played', computer, end='; ')\n\n        if rules[computer] == human:  \n            print('yay you win!')\n        elif rules[human] == computer:  \n            print('the computer beat you...\u00a0:(')\n        else: print(\"it's a tie!\")\n\n    else: print(\"that's not a valid choice\")\n"}
{"id": 411508, "name": "Benford's law", "source": "Translate Fortran to Python: -*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 01:13:00\n\na=./f && make $a && $a\nf95 -Wall -ffree-form f.F -o f\n  0.301030010      0.176091254      0.124938756       9.69100147E-02   7.91812614E-02   6.69467747E-02   5.79919666E-02   5.11525236E-02   4.57575098E-02 THE LAW\n  0.300999999      0.177000001      0.125000000       9.60000008E-02   7.99999982E-02   6.70000017E-02   5.70000000E-02   5.29999994E-02   4.50000018E-02 LEADING FIBONACCI DIGIT\n\nCompilation finished at Sat May 18 01:13:00\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 411509, "name": "Benford's law", "source": "Translate Fortran to Python: -*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 01:13:00\n\na=./f && make $a && $a\nf95 -Wall -ffree-form f.F -o f\n  0.301030010      0.176091254      0.124938756       9.69100147E-02   7.91812614E-02   6.69467747E-02   5.79919666E-02   5.11525236E-02   4.57575098E-02 THE LAW\n  0.300999999      0.177000001      0.125000000       9.60000008E-02   7.99999982E-02   6.70000017E-02   5.70000000E-02   5.29999994E-02   4.50000018E-02 LEADING FIBONACCI DIGIT\n\nCompilation finished at Sat May 18 01:13:00\n", "target": "from __future__ import division\nfrom itertools import islice, count\nfrom collections import Counter\nfrom math import log10\nfrom random import randint\n\nexpected = [log10(1+1/d) for d in range(1,10)]\n\ndef fib():\n    a,b = 1,1\n    while True:\n        yield a\n        a,b = b,a+b\n\n\ndef power_of_threes():\n    return (3**k for k in count(0))\n\ndef heads(s):\n    for a in s: yield int(str(a)[0])\n\ndef show_dist(title, s):\n    c = Counter(s)\n    size = sum(c.values())\n    res = [c[d]/size for d in range(1,10)]\n\n    print(\"\\n%s Benfords deviation\" % title)\n    for r, e in zip(res, expected):\n        print(\"%5.1f%% %5.1f%%  %5.1f%%\" % (r*100., e*100., abs(r - e)*100.))\n\ndef rand1000():\n    while True: yield randint(1,9999)\n\nif __name__ == '__main__':\n    show_dist(\"fibbed\", islice(heads(fib()), 1000))\n    show_dist(\"threes\", islice(heads(power_of_threes()), 1000))\n\n    \n    show_dist(\"random\", islice(heads(rand1000()), 10000))\n"}
{"id": 411510, "name": "Hickerson series of almost integers", "source": "Translate Fortran to Python: program hickerson\n    implicit none\n    integer, parameter :: q = selected_real_kind(30)\n    integer, parameter :: l = selected_int_kind(15)\n    real(q) :: s, l2\n    integer :: i, n, k\n\n    l2 = log(2.0_q)\n    do n = 1, 17\n        s = 0.5_q / l2\n        do i = 1, n\n            s = (s * i) / l2\n        end do\n\n        k = floor((s - floor(s, l)) * 10)\n        if (k == 0 .or. k == 9) then\n            print 1, n, s, \"\"\n        else\n            print 1, n, s, \" NOT\"\n        endif\n    end do\n  1 format('h(',I2,') = ',F23.3,' is',A,' an almost-integer')\nend program\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 411511, "name": "Hickerson series of almost integers", "source": "Translate Fortran to Python: program hickerson\n    implicit none\n    integer, parameter :: q = selected_real_kind(30)\n    integer, parameter :: l = selected_int_kind(15)\n    real(q) :: s, l2\n    integer :: i, n, k\n\n    l2 = log(2.0_q)\n    do n = 1, 17\n        s = 0.5_q / l2\n        do i = 1, n\n            s = (s * i) / l2\n        end do\n\n        k = floor((s - floor(s, l)) * 10)\n        if (k == 0 .or. k == 9) then\n            print 1, n, s, \"\"\n        else\n            print 1, n, s, \" NOT\"\n        endif\n    end do\n  1 format('h(',I2,') = ',F23.3,' is',A,' an almost-integer')\nend program\n", "target": "from decimal import Decimal\nimport math\n\ndef h(n):\n    'Simple, reduced precision calculation'\n    return math.factorial(n) / (2 * math.log(2) ** (n + 1))\n    \ndef h2(n):\n    'Extended precision Hickerson function'\n    return Decimal(math.factorial(n)) / (2 * Decimal(2).ln() ** (n + 1))\n\nfor n in range(18):\n    x = h2(n)\n    norm = str(x.normalize())\n    almostinteger = (' Nearly integer' \n                     if 'E' not in norm and ('.0' in norm or '.9' in norm) \n                     else ' NOT nearly integer!')\n    print('n:%2i h:%s%s' % (n, norm, almostinteger))\n"}
{"id": 411512, "name": "Read a configuration file", "source": "Translate Fortran to Python: program readconfig\n  implicit none\n  integer, parameter    :: strlen = 100\n  logical               :: needspeeling = .false., seedsremoved =.false.\n  character(len=strlen) :: favouritefruit = \"\", fullname = \"\", fst, snd\n  character(len=strlen), allocatable :: otherfamily(:), tmp(:)\n  character(len=1000)   :: line\n  integer               :: lun, stat,  j, j0, j1, ii = 1, z\n  integer, parameter    :: state_begin=1, state_in_fst=2, state_in_sep=3\n\n  open(newunit=lun, file=\"config.ini\", status=\"old\")\n  \n  do \n    read(lun, \"(a)\", iostat=stat) line\n    if (stat<0) exit\n    if ((line(1:1) == \"#\") .or. &\n        (line(1:1) == \";\") .or. &\n        (len_trim(line)==0)) then\n      cycle\n    end if\n    z = state_begin\n    do j = 1, len_trim(line)\n      if (z == state_begin) then\n        if (line(j:j)/=\" \") then\n          j0 = j\n          z = state_in_fst\n        end if\n      elseif (z == state_in_fst) then\n        if (index(\"= \",line(j:j))>0) then\n          fst = lower(line(j0:j-1))\n          z = state_in_sep\n        end if\n      elseif (z == state_in_sep) then\n        if (index(\" =\",line(j:j)) == 0) then\n          snd = line(j:)\n          exit\n        end if\n      else\n         stop \"not possible to be here\"\n      end if\n    end do\n    if (z == state_in_fst) then\n      fst = lower(line(j0:))\n    elseif (z == state_begin) then\n      cycle\n    end if\n\n    if (fst==\"fullname\") then\n      read(snd,\"(a)\") fullname\n    elseif (fst==\"favouritefruit\") then\n      read(snd,\"(a)\") favouritefruit\n    elseif (fst==\"seedsremoved\") then\n      seedsremoved = .true.\n    elseif (fst==\"needspeeling\") then\n      needspeeling = .true.\n    elseif (fst==\"otherfamily\") then\n      j = 1; ii = 1\n      do while (len_trim(snd(j:)) >0)\n        j1  = index(snd(j:),\",\")\n        if (j1==0) then\n          j1 = len_trim(snd)\n        else\n          j1 = j + j1 - 2\n        end if\n        do \n          if (j>len_trim(snd)) exit\n          if (snd(j:j) /= \" \") exit\n          j = j +1\n        end do\n        allocate(tmp(ii)) \n        tmp(1:ii-1) = otherfamily\n        call move_alloc(tmp, otherfamily)\n        read(snd(j:j1),\"(a)\"), otherfamily(ii)\n        j = j1 + 2 \n        ii = ii + 1\n      end do\n    else \n      print *, \"unknown option '\"//trim(fst)//\"'\"; stop\n    end if\n  end do\n  close(lun)\n\n  print \"(a,a)\",\"fullname = \",       trim(fullname)\n  print \"(a,a)\",\"favouritefruit = \", trim(favouritefruit)\n  print \"(a,l)\",\"needspeeling = \",   needspeeling\n  print \"(a,l)\",\"seedsremoved = \",   seedsremoved\n  print \"(a,*(a,:,', '))\", \"otherfamily = \", &\n         (trim(otherfamily(j)), j=1,size(otherfamily))\n\ncontains\n\npure function lower (str) result (string)\n    implicit none\n    character(*), intent(In) :: str\n    character(len(str))      :: string\n    Integer :: ic, i\n\n    character(26), parameter :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n\n    string = str\n    do i = 1, len_trim(str)\n        ic = index(cap, str(i:i))\n        if (ic > 0) string(i:i) = low(ic:ic)\n    end do\nend function \n\nend program\n", "target": "def readconf(fn):\n    ret = {}\n    with file(fn) as fp:\n        for line in fp:\n            \n            line = line.strip()\n            if not line or line.startswith('\n            \n            boolval = True\n            \n            if line.startswith(';'):\n                \n                line = line.lstrip(';')\n                \n                if len(line.split()) != 1: continue\n                boolval = False\n            \n            bits = line.split(None, 1)\n            if len(bits) == 1:\n                \n                k = bits[0]\n                v = boolval\n            else:\n                \n                k, v = bits\n            ret[k.lower()] = v\n    return ret\n\n\nif __name__ == '__main__':\n    import sys\n    conf = readconf(sys.argv[1])\n    for k, v in sorted(conf.items()):\n        print k, '=', v\n"}
{"id": 411513, "name": "Kronecker product based fractals", "source": "Translate Fortran to Python: program Kron_frac\n  implicit none\n\n  interface\n    function matkronpow(M, n) result(Mpowern)\n      integer, dimension(:,:), intent(in) :: M\n      integer, intent(in) :: n\n      integer, dimension(size(M, 1)**n, size(M,2)**n) :: Mpowern\n    end function matkronpow\n\n    function kron(A, B) result(M)\n      integer, dimension(:,:), intent(in) :: A, B\n      integer, dimension(size(A,1)*size(B,1), size(A,2)*size(B,2)) :: M\n    end function kron\n\n    subroutine write2file(M, filename)\n      integer, dimension(:,:), intent(in) :: M\n      character(*), intent(in) :: filename\n    end subroutine write2file\n  end interface\n\n  integer, parameter :: n = 4\n  integer, dimension(3,3) :: Vicsek, Sierpinski\n  integer, dimension(4,4) :: Hadamard\n  integer, dimension(3**n, 3**n) :: fracV, fracS\n  integer, dimension(4**n, 4**n) :: fracH\n\n  Vicsek = reshape( (/0, 1, 0,&\n                      1, 1, 1,&\n                      0, 1, 0/),&\n                    (/3,3/) )\n\n  Sierpinski = reshape( (/1, 1, 1,&\n                          1, 0, 1,&\n                          1, 1, 1/),&\n                          (/3,3/) )\n\n  Hadamard = transpose(reshape( (/ 1, 0, 1, 0,&\n                         1, 0, 0, 1,&\n                         1, 1, 0, 0,&\n                         1, 1, 1, 1/),&\n                         (/4,4/) ))\n\n  fracV = matkronpow(Vicsek, n)\n  fracS = matkronpow(Sierpinski, n)\n  fracH = matkronpow(Hadamard, n)\n\n  call write2file(fracV, 'Viczek.txt')\n  call write2file(fracS, 'Sierpinski.txt')\n  call write2file(fracH, 'Hadamard.txt')\n\nend program\n\nfunction matkronpow(M, n) result(Mpowern)\ninterface\nfunction kron(A, B) result(M)\n  integer, dimension(:,:), intent(in) :: A, B\n  integer, dimension(size(A,1)*size(B,1), size(A,2)*size(B,2)) :: M\n  end function kron\nend interface\n\n  integer, dimension(:,:), intent(in) :: M\n  integer, intent(in) :: n\n  integer, dimension(size(M, 1)**n, size(M,2)**n) :: Mpowern\n  integer, dimension(:,:), allocatable :: work1, work2\n  integer :: icount\n\n  if (n <= 1) then\n     Mpowern = M\n  else\n    allocate(work1(size(M,1), size(M,2)))\n    work1 = M\n    do icount = 2,n\n      allocate(work2(size(M,1)**icount, size(M,2)**icount))\n      work2 = kron(work1, M)\n      deallocate(work1)\n      allocate(work1(size(M,1)**icount, size(M,2)**icount))\n      work1 = work2\n      deallocate(work2)\n    end do\n    Mpowern = work1\n    deallocate(work1)\n  end if\n\nend function matkronpow\n\nfunction kron(A, B) result(M)\n  integer, dimension(:,:), intent(in) :: A, B\n  integer, dimension(size(A,1)*size(B,1), size(A,2)*size(B,2)) :: M\n  integer :: ia, ja, ib, jb, im, jm\n\n  do ja = 1, size(A, 2)\n    do ia = 1, size(A, 1)\n      do jb = 1, size(B, 2)\n        do ib = 1, size(B, 1)\n          im = (ia - 1)*size(B, 1) + ib\n          jm = (ja - 1)*size(B, 2) + jb\n          M(im, jm) = A(ia, ja) * B(ib, jb)\n        end do\n      end do\n    end do\n  end do\n\nend function kron\n\nsubroutine write2file(M, filename)\n  integer, dimension(:,:), intent(in) :: M\n  character(*), intent(in) :: filename\n  integer :: ii, jj\n  integer, parameter :: fi = 10\n\n  open(fi, file=filename, status='replace')\n\n  do ii = 1,size(M, 1)\n    do jj = 1,size(M,2)\n      if (M(ii,jj) == 0) then\n        write(fi, '(A)', advance='no') ' '\n      else\n        write(fi, '(A)', advance='no') '*'\n      end if\n    end do\n    write(fi, '(A)') ' '\n  end do\n\n  close(fi)\n\nend subroutine write2file\n", "target": "import os\nfrom PIL import Image\n\n\ndef imgsave(path, arr):\n    w, h = len(arr), len(arr[0])\n    img = Image.new('1', (w, h))\n    for x in range(w):\n        for y in range(h):\n            img.putpixel((x, y), arr[x][y])\n    img.save(path)\n\n\ndef get_shape(mat):\n    return len(mat), len(mat[0])\n\n\ndef kron(matrix1, matrix2):\n    \n    final_list = []\n\n    count = len(matrix2)\n\n    for elem1 in matrix1:\n        for i in range(count):\n            sub_list = []\n            for num1 in elem1:\n                for num2 in matrix2[i]:\n                    sub_list.append(num1 * num2)\n            final_list.append(sub_list)\n\n    return final_list\n\n\ndef kronpow(mat):\n    \n    matrix = mat\n    while True:\n        yield matrix\n        matrix = kron(mat, matrix)\n\n\ndef fractal(name, mat, order=6):\n    \n    path = os.path.join('fractals', name)\n    os.makedirs(path, exist_ok=True)\n\n    fgen = kronpow(mat)\n    print(name)\n    for i in range(order):\n        p = os.path.join(path, f'{i}.jpg')\n        print('Calculating n =', i, end='\\t', flush=True)\n\n        mat = next(fgen)\n        imgsave(p, mat)\n\n        x, y = get_shape(mat)\n        print('Saved as', x, 'x', y, 'image', p)\n\n\ntest1 = [\n    [0, 1, 0],\n    [1, 1, 1],\n    [0, 1, 0]\n]\n\ntest2 = [\n    [1, 1, 1],\n    [1, 0, 1],\n    [1, 1, 1]\n]\n\ntest3 = [\n    [1, 0, 1],\n    [0, 1, 0],\n    [1, 0, 1]\n]\n\nfractal('test1', test1)\nfractal('test2', test2)\nfractal('test3', test3)\n"}
{"id": 411514, "name": "Case-sensitivity of identifiers", "source": "Translate Fortran to Python: program Example\n  implicit none\n\n  character(8) :: dog, Dog, DOG\n\n  dog = \"Benjamin\"\n  Dog = \"Samba\"\n  DOG = \"Bernie\"\n\n  if (dog == DOG) then\n    write(*,*) \"There is just one dog named \", dog\n  else\n    write(*,*) \"The three dogs are named \", dog, Dog, \" and \", DOG\n  end if\n\nend program Example\n", "target": ">>> dog = 'Benjamin'; Dog = 'Samba'; DOG = 'Bernie'\n>>> print ('The three dogs are named ',dog,', ',Dog,', and ',DOG)\nThe three dogs are named  Benjamin ,  Samba , and  Bernie\n>>>\n"}
{"id": 411515, "name": "Sorting algorithms_Stooge sort", "source": "Translate Fortran to Python: program Stooge\n  implicit none\n\n  integer :: i\n  integer :: array(50) = (/ (i, i = 50, 1, -1) /) \n  \n  call Stoogesort(array)\n  write(*,\"(10i5)\") array\n\ncontains\n\nrecursive subroutine Stoogesort(a)\n  integer, intent(in out) :: a(:)\n  integer :: j, t, temp\n \n   j = size(a)\n   if(a(j) < a(1)) then\n     temp = a(j)\n     a(j) = a(1)\n     a(1) = temp\n   end if\n\n  if(j > 2) then\n    t = j / 3\n    call Stoogesort(a(1:j-t))\n    call Stoogesort(a(1+t:j))\n    call Stoogesort(a(1:j-t)) \n  end if\n\nend subroutine\nend program\n", "target": ">>> data = [1, 4, 5, 3, -6, 3, 7, 10, -2, -5, 7, 5, 9, -3, 7]\n>>> def stoogesort(L, i=0, j=None):\n\tif j is None:\n\t\tj = len(L) - 1\n\tif L[j] < L[i]:\n\t\tL[i], L[j] = L[j], L[i]\n\tif j - i > 1:\n\t\tt = (j - i + 1) // 3\n\t\tstoogesort(L, i  , j-t)\n\t\tstoogesort(L, i+t, j  )\n\t\tstoogesort(L, i  , j-t)\n\treturn L\n\n>>> stoogesort(data)\n[-6, -5, -3, -2, 1, 3, 3, 4, 5, 5, 7, 7, 7, 9, 10]\n"}
{"id": 411516, "name": "Truncate a file", "source": "Translate Fortran to Python:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,NB)\n       CHARACTER*(*) FNAME\t\n       INTEGER NB\t\t\n       INTEGER L\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\t\t\n       CHARACTER*1 B\t\t\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (NB.LE.0)     CALL CROAK(\"Chop must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\",\t\n     1   FORM=\"UNFORMATTED\",RECL=1,ACCESS=\"DIRECT\")\t\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"UNFORMATTED\",RECL=1)\t\n\nCopy the desired \"records\" to the temporary file.\n   10   DO L = 1,NB\t\n          READ  (F,REC = L,ERR = 20) B\t\n          WRITE (T) B\t\t\t\n        END DO\t\t\n   20   IF (L.LE.NB) CALL CROAK(\"Short file\nConvert from input to output...\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n        DO L = 1,NB\t\n          READ  (T) B\t\t\n          WRITE (F,\"(A1,$)\") B\t\n        END DO\t\t\nCompleted.\n   30   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",12)\n      END\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 411517, "name": "Truncate a file", "source": "Translate Fortran to Python:       SUBROUTINE CROAK(GASP)\t\n       CHARACTER*(*) GASP\t\n        WRITE (6,*) \"Oh dear. \",GASP\t\n        STOP \"++ungood.\"\t\n      END\t\t\t\n\n      SUBROUTINE FILEHACK(FNAME,NB)\n       CHARACTER*(*) FNAME\t\n       INTEGER NB\t\t\n       INTEGER L\t\t\n       INTEGER F,T\t\t\n       PARAMETER (F=66,T=67)\t\n       LOGICAL EXIST\t\t\n       CHARACTER*1 B\t\t\n        IF (FNAME.EQ.\"\") CALL CROAK(\"Blank file name\n        IF (NB.LE.0)     CALL CROAK(\"Chop must be positive\n        INQUIRE(FILE = FNAME, EXIST = EXIST)\t\n        IF (.NOT.EXIST) CALL CROAK(\"Can't find a file called \"//FNAME)\t\n        OPEN (F,FILE=FNAME,STATUS=\"OLD\",ACTION=\"READWRITE\",\t\n     1   FORM=\"UNFORMATTED\",RECL=1,ACCESS=\"DIRECT\")\t\t\n        OPEN (T,STATUS=\"SCRATCH\",FORM=\"UNFORMATTED\",RECL=1)\t\n\nCopy the desired \"records\" to the temporary file.\n   10   DO L = 1,NB\t\n          READ  (F,REC = L,ERR = 20) B\t\n          WRITE (T) B\t\t\t\n        END DO\t\t\n   20   IF (L.LE.NB) CALL CROAK(\"Short file\nConvert from input to output...\n        REWIND T\t\t\n        CLOSE(F)\t\t\n        OPEN (F,FILE=FNAME,FORM=\"FORMATTED\",\t\n     1   ACTION=\"WRITE\",STATUS=\"REPLACE\")\t\nCopy from the temporary file.\n        DO L = 1,NB\t\n          READ  (T) B\t\t\n          WRITE (F,\"(A1,$)\") B\t\n        END DO\t\t\nCompleted.\n   30   CLOSE(T)\t\n        CLOSE(F)\t\n      END\t\t\n\n      PROGRAM CHOPPER\n       CALL FILEHACK(\"foobar.txt\",12)\n      END\n", "target": "def truncate_file(name, length):\n    if not os.path.isfile(name):\n        return False\n    if length >= os.path.getsize(name):\n        return False\n    with open(name, 'ab') as f:\n        f.truncate(length)\n    return True\n"}
{"id": 411518, "name": "Sorting algorithms_Shell sort", "source": "Translate Fortran to Python: MODULE sort\n\nCONTAINS\n\nSUBROUTINE Shell_Sort(a)\n\n  IMPLICIT NONE\n  INTEGER :: i, j, increment\n  REAL :: temp\n  REAL, INTENT(in out) :: a(:)\n\t\n  increment = SIZE(a) / 2\n  DO WHILE (increment > 0)\n      DO i = increment+1, SIZE(a)\n         j = i\n         temp = a(i)\n         DO WHILE (j >= increment+1 .AND. a(j-increment) > temp)\n            a(j) = a(j-increment)\n            j = j - increment\n         END DO\n         a(j) = temp\n      END DO\n      IF (increment == 2) THEN\n   \t  increment = 1\n      ELSE\n         increment = increment * 5 / 11\n      END IF      \n  END DO\n \nEND SUBROUTINE Shell_Sort\n\nEND MODULE sort\n\nPROGRAM Shellsort\n\nUSE sort\n\n  IMPLICIT NONE\n  REAL :: array(1000)\n     \n  CALL RANDOM_SEED\n  CALL RANDOM_NUMBER(array)\n \n  WRITE (*,*) \"Unsorted array\"\n  WRITE (*,*) array\n  WRITE (*,*) \n  CALL Shell_Sort(array)\n  WRITE (*,*) \"Sorted array\"\n  WRITE (*,*) array\n  \nEND PROGRAM Shellsort\n", "target": "def shell(seq):\n    inc = len(seq) // 2\n    while inc:\n        for i, el in enumerate(seq[inc:], inc):\n            while i >= inc and seq[i - inc] > el:\n                seq[i] = seq[i - inc]\n                i -= inc\n            seq[i] = el\n        inc = 1 if inc == 2 else inc * 5 // 11\n"}
{"id": 411519, "name": "Deconvolution_1D", "source": "Translate Fortran to Python: \n\n\n\nprogram deconv\n  \n  use mkl95_lapack, only : gelsd\n\n  implicit none\n  real(8), allocatable :: g(:), href(:), A(:,:), f(:)\n  real(8), pointer     :: h(:), r(:)\n  integer              :: N\n  character(len=16)    :: cbuff\n  integer              :: i\n  intrinsic            :: nint\n\n  \n  allocate(g(21),f(16))\n  g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\n  f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\n\n  \n  h => deco(f, g)\n\n  \n  N = size(h)\n  allocate(href(N))\n  href = [-8,-9,-3,-1,-6,7]\n  cbuff = ' '\n  write(cbuff,'(a,i0,a)') '(a,',N,'(i0,a),i0)'\n  if (any(abs(h-href) > 1.0d-4)) then\n     write(*,'(a)') 'deconv(f, g) - FAILED'\n  else\n     write(*,cbuff) 'deconv(f, g) = ',(nint(h(i)),', ',i=1,N-1),nint(h(N))\n  end if\n\n  \n  r => deco(h, g)\n\n  cbuff = ' '\n  N = size(r)\n  write(cbuff,'(a,i0,a)') '(a,',N,'(i0,a),i0)'\n  if (any(abs(r-f) > 1.0d-4)) then\n     write(*,'(a)') 'deconv(h, g) - FAILED'\n  else\n     write(*,cbuff) 'deconv(h, g) = ',(nint(r(i)),', ',i=1,N-1),nint(r(N))\n  end if\n\ncontains\n  function deco(p, q)\n    real(8), pointer    :: deco(:)\n    real(8), intent(in) :: p(:), q(:)\n\n    real(8), allocatable, target :: r(:)\n    real(8), allocatable         :: A(:,:)\n    integer :: N\n\n    \n    N = size(q) - size(p) + 1\n    allocate(A(size(q),N),r(size(q)))\n    A = 0.0d0\n    do i=1,N\n       A(i:i+size(p)-1,i) = p\n    end do\n    \n    \n    r = q\n    call gelsd(A, r)\n\n    deco => r(1:N)\n  end function deco\n\nend program deconv\n", "target": "def ToReducedRowEchelonForm( M ):\n    if not M: return\n    lead = 0\n    rowCount = len(M)\n    columnCount = len(M[0])\n    for r in range(rowCount):\n        if lead >= columnCount:\n            return\n        i = r\n        while M[i][lead] == 0:\n            i += 1\n            if i == rowCount:\n                i = r\n                lead += 1\n                if columnCount == lead:\n                    return\n        M[i],M[r] = M[r],M[i]\n        lv = M[r][lead]\n        M[r] = [ mrx / lv for mrx in M[r]]\n        for i in range(rowCount):\n            if i != r:\n                lv = M[i][lead]\n                M[i] = [ iv - lv*rv for rv,iv in zip(M[r],M[i])]\n        lead += 1\n    return M\n \ndef pmtx(mtx):\n    print ('\\n'.join(''.join(' %4s' % col for col in row) for row in mtx))\n \ndef convolve(f, h):\n    g = [0] * (len(f) + len(h) - 1)\n    for hindex, hval in enumerate(h):\n        for findex, fval in enumerate(f):\n            g[hindex + findex] += fval * hval\n    return g\n\ndef deconvolve(g, f):\n    lenh = len(g) - len(f) + 1\n    mtx = [[0 for x in range(lenh+1)] for y in g]\n    for hindex in range(lenh):\n        for findex, fval in enumerate(f):\n            gindex = hindex + findex\n            mtx[gindex][hindex] = fval\n    for gindex, gval in enumerate(g):        \n        mtx[gindex][lenh] = gval\n    ToReducedRowEchelonForm( mtx )\n    return [mtx[i][lenh] for i in range(lenh)]  \n\nif __name__ == '__main__':\n    h = [-8,-9,-3,-1,-6,7]\n    f = [-3,-6,-1,8,-6,3,-1,-9,-9,3,-2,5,2,-2,-7,-1]\n    g = [24,75,71,-34,3,22,-45,23,245,25,52,25,-67,-96,96,31,55,36,29,-43,-7]\n    assert convolve(f,h) == g\n    assert deconvolve(g, f) == h\n"}
{"id": 411520, "name": "Read a specific line from a file", "source": "Translate Fortran to Python:       MODULE SAMPLER    \n       CONTAINS                                                         SAM00200\n        CHARACTER*20 FUNCTION GETREC(N,F,IS)    \nCareful. Some compilers get confused over the function name's usage.    SAM00400\n         INTEGER N              \n         INTEGER F              \n         CHARACTER*(*) IS       \n         INTEGER I,L            \n          IS = \"\"               \n          IF (N.LE.0) THEN      \n            WRITE (GETREC,1) \"\n    1       FORMAT (A,1X,I0)                    \n          ELSE IF (F.LE.0) THEN                 \n            WRITE (GETREC,1) \"\n          ELSE IF (LEN(IS).LE.0) THEN           \n            WRITE (GETREC,1) \"\n          ELSE                  \n            REWIND (F)          \n            DO I = 1,N - 1      \n              READ (F,2,END=3)  \n            END DO              \n            READ (F,2,END = 3) L,IS(1:MIN(L,LEN(IS)))    \n    2       FORMAT (Q,A)        \n            IF (L.LT.LEN(IS)) IS(L + 1:) = \"\"   \n            IF (L.GT.LEN(IS)) THEN              \n              WRITE (GETREC,1) \"+Length\",L      \n            ELSE IF (L.LE.0) THEN               \n              WRITE (GETREC,1) \"+Null\"          \n            ELSE IF (IS.EQ.\"\") THEN             \n              WRITE (GETREC,1) \"+Blank\",L       \n            ELSE                                \n              WRITE (GETREC,1) \" Length\",L      \n            END IF              \n          END IF                \n          RETURN                \n    3     WRITE (GETREC,1) \"\n        END FUNCTION GETREC     \n      END MODULE SAMPLER        \n                                                                        SAM03900\n      PROGRAM POKE                                                      POK00100\n      USE SAMPLER                                                       POK00200\n      INTEGER ENUFF     \n      PARAMETER (ENUFF = 666)   \n      CHARACTER*(ENUFF) STUFF   \n      CHARACTER*20 RESULT                                               POK00600\n      INTEGER MSG,F     \n      MSG = 6           \n      F = 10            \n      WRITE (MSG,*) \"      To select record 7 from a disc file.\"        POK01000\n                                                                        POK01100\n      WRITE (MSG,*) \"As a FORMATTED file.\"                              POK01200\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\")         POK01300\n      RESULT = GETREC(7,F,STUFF)                                        POK01400\n      WRITE (MSG,1) \"Result\",RESULT                                     POK01500\n      WRITE (MSG,1) \"Record\",STUFF                                      POK01600\n    1 FORMAT (A,\":\",A)                                                  POK01700\n                                                                        POK01800\n      CLOSE (F)                                                         POK01900\n      WRITE (MSG,*) \"As a random-access unformatted file.\"              POK02000\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\",         POK02100\n     1 ACCESS=\"DIRECT\",FORM=\"UNFORMATTED\",RECL=82)      \n      STUFF = \"Cleared.\"                                                POK02300\n      READ (F,REC = 7,ERR = 666) STUFF(1:80)                            POK02400\n      WRITE (MSG,1) \"Record\",STUFF(1:80)                                POK02500\n      STOP                                                              POK02600\n  666 WRITE (MSG,*) \"Can't get the record\n      END       \n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 411521, "name": "Read a specific line from a file", "source": "Translate Fortran to Python:       MODULE SAMPLER    \n       CONTAINS                                                         SAM00200\n        CHARACTER*20 FUNCTION GETREC(N,F,IS)    \nCareful. Some compilers get confused over the function name's usage.    SAM00400\n         INTEGER N              \n         INTEGER F              \n         CHARACTER*(*) IS       \n         INTEGER I,L            \n          IS = \"\"               \n          IF (N.LE.0) THEN      \n            WRITE (GETREC,1) \"\n    1       FORMAT (A,1X,I0)                    \n          ELSE IF (F.LE.0) THEN                 \n            WRITE (GETREC,1) \"\n          ELSE IF (LEN(IS).LE.0) THEN           \n            WRITE (GETREC,1) \"\n          ELSE                  \n            REWIND (F)          \n            DO I = 1,N - 1      \n              READ (F,2,END=3)  \n            END DO              \n            READ (F,2,END = 3) L,IS(1:MIN(L,LEN(IS)))    \n    2       FORMAT (Q,A)        \n            IF (L.LT.LEN(IS)) IS(L + 1:) = \"\"   \n            IF (L.GT.LEN(IS)) THEN              \n              WRITE (GETREC,1) \"+Length\",L      \n            ELSE IF (L.LE.0) THEN               \n              WRITE (GETREC,1) \"+Null\"          \n            ELSE IF (IS.EQ.\"\") THEN             \n              WRITE (GETREC,1) \"+Blank\",L       \n            ELSE                                \n              WRITE (GETREC,1) \" Length\",L      \n            END IF              \n          END IF                \n          RETURN                \n    3     WRITE (GETREC,1) \"\n        END FUNCTION GETREC     \n      END MODULE SAMPLER        \n                                                                        SAM03900\n      PROGRAM POKE                                                      POK00100\n      USE SAMPLER                                                       POK00200\n      INTEGER ENUFF     \n      PARAMETER (ENUFF = 666)   \n      CHARACTER*(ENUFF) STUFF   \n      CHARACTER*20 RESULT                                               POK00600\n      INTEGER MSG,F     \n      MSG = 6           \n      F = 10            \n      WRITE (MSG,*) \"      To select record 7 from a disc file.\"        POK01000\n                                                                        POK01100\n      WRITE (MSG,*) \"As a FORMATTED file.\"                              POK01200\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\")         POK01300\n      RESULT = GETREC(7,F,STUFF)                                        POK01400\n      WRITE (MSG,1) \"Result\",RESULT                                     POK01500\n      WRITE (MSG,1) \"Record\",STUFF                                      POK01600\n    1 FORMAT (A,\":\",A)                                                  POK01700\n                                                                        POK01800\n      CLOSE (F)                                                         POK01900\n      WRITE (MSG,*) \"As a random-access unformatted file.\"              POK02000\n      OPEN (F,FILE=\"FileSlurpN.for\",STATUS=\"OLD\",ACTION=\"READ\",         POK02100\n     1 ACCESS=\"DIRECT\",FORM=\"UNFORMATTED\",RECL=82)      \n      STUFF = \"Cleared.\"                                                POK02300\n      READ (F,REC = 7,ERR = 666) STUFF(1:80)                            POK02400\n      WRITE (MSG,1) \"Record\",STUFF(1:80)                                POK02500\n      STOP                                                              POK02600\n  666 WRITE (MSG,*) \"Can't get the record\n      END       \n", "target": "with open('xxx.txt') as f:\n    for i, line in enumerate(f):\n        if i == 6:\n            break\n    else:\n        print('Not 7 lines in file')\n        line = None\n"}
{"id": 411522, "name": "Inverted syntax", "source": "Translate Fortran to Python:       INQUIRE(FILE = FILENAME(1:L), EXIST = MAYBE, ERR = 666, IOSTAT = RESULT)\n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 411523, "name": "Inverted syntax", "source": "Translate Fortran to Python:       INQUIRE(FILE = FILENAME(1:L), EXIST = MAYBE, ERR = 666, IOSTAT = RESULT)\n", "target": "x = truevalue if condition else falsevalue\n"}
{"id": 411524, "name": "LU decomposition", "source": "Translate Fortran to Python: program lu1\n  implicit none\n  call check( reshape([real(8)::1,2,1,3,4,1,5,7,0                  ],[3,3]) )\n  call check( reshape([real(8)::11,1,3,2,9,5,17,5,24,2,18,7,2,6,1,1],[4,4]) )\n \ncontains\n \n  subroutine check(a)\n    real(8), intent(in)   :: a(:,:)\n    integer               :: i,j,n\n    real(8), allocatable  :: aa(:,:),l(:,:),u(:,:)\n    integer, allocatable  :: p(:,:)\n    integer, allocatable  :: ipiv(:)\n    n = size(a,1)\n    allocate(aa(n,n),l(n,n),u(n,n),p(n,n),ipiv(n))\n    forall (j=1:n,i=1:n)\n      aa(i,j) = a(i,j)\n      u (i,j) = 0d0\n      p (i,j) = merge(1  ,0  ,i.eq.j)\n      l (i,j) = merge(1d0,0d0,i.eq.j)\n    end forall\n    call lu(aa, ipiv)\n    do i = 1,n\n       l(i, :i-1) = aa(i, :i-1)\n       u(i,i:   ) = aa(i,i:   )\n    end do\n    p(ipiv,:) = p\n    call mat_print('a',a)\n    call mat_print('p',p)\n    call mat_print('l',l)\n    call mat_print('u',u)\n    print *, \"residual\"\n    print *, \"|| P.A - L.U || =  \", maxval(abs(matmul(p,a)-matmul(l,u)))\n  end subroutine\n \n  subroutine lu(a,p)\n\n    real(8), intent(inout) :: a(:,:)\n    integer, intent(out  ) :: p(:)\n    integer                :: n, i,j,k,kmax\n    n = size(a,1)\n    p = [ ( i, i=1,n ) ]\n    do k = 1,n-1\n        kmax = maxloc(abs(a(p(k:),k)),1) + k-1\n        if (kmax /= k ) then\n            p([k, kmax]) = p([kmax, k])\n            a([k, kmax],:) = a([kmax, k],:)\n        end if\n        a(k+1:,k) = a(k+1:,k) / a(k,k)\n        forall (j=k+1:n) a(k+1:,j) = a(k+1:,j) - a(k,j)*a(k+1:,k)\n    end do\n  end subroutine\n\n  subroutine mat_print(amsg,a)\n    character(*), intent(in) :: amsg\n    class    (*), intent(in) :: a(:,:)\n    integer                  :: i\n    print*,' '\n    print*,amsg\n    do i=1,size(a,1)\n      select type (a)\n        type is (real(8)) ; print'(100f8.2)',a(i,:)\n        type is (integer) ; print'(100i8  )',a(i,:)\n      end select\n    end do\n    print*,' '\n  end subroutine\n\nend program\n", "target": "from pprint import pprint\n\ndef matrixMul(A, B):\n    TB = zip(*B)\n    return [[sum(ea*eb for ea,eb in zip(a,b)) for b in TB] for a in A]\n\ndef pivotize(m):\n    \n    n = len(m)\n    ID = [[float(i == j) for i in xrange(n)] for j in xrange(n)]\n    for j in xrange(n):\n        row = max(xrange(j, n), key=lambda i: abs(m[i][j]))\n        if j != row:\n            ID[j], ID[row] = ID[row], ID[j]\n    return ID\n\ndef lu(A):\n    \n    n = len(A)\n    L = [[0.0] * n for i in xrange(n)]\n    U = [[0.0] * n for i in xrange(n)]\n    P = pivotize(A)\n    A2 = matrixMul(P, A)\n    for j in xrange(n):\n        L[j][j] = 1.0\n        for i in xrange(j+1):\n            s1 = sum(U[k][j] * L[i][k] for k in xrange(i))\n            U[i][j] = A2[i][j] - s1\n        for i in xrange(j, n):\n            s2 = sum(U[k][j] * L[i][k] for k in xrange(j))\n            L[i][j] = (A2[i][j] - s2) / U[j][j]\n    return (L, U, P)\n\na = [[1, 3, 5], [2, 4, 7], [1, 1, 0]]\nfor part in lu(a):\n    pprint(part, width=19)\n    print\nprint\nb = [[11,9,24,2],[1,5,2,6],[3,17,18,1],[2,5,7,1]]\nfor part in lu(b):\n    pprint(part)\n    print\n"}
{"id": 411525, "name": "Optional parameters", "source": "Translate Fortran to Python: module ExampleOptionalParameter\n  \n  \n  implicit none\ncontains\n\n  subroutine sort_table(table, ordering, column, reverse)\n    type(table_type), intent(inout) :: table\n    integer, optional :: column\n    logical, optional :: reverse\n    optional :: ordering\n    interface\n       integer function ordering(a, b)\n         type(table_element), intent(in) :: a, b\n       end function ordering\n    end interface\n\n    integer :: the_column, i\n    logical :: reversing\n    type(table_row) :: rowA, rowB\n\n    if ( present(column) ) then\n       if ( column > get_num_of_columns(table) ) then\n          \n       else\n          the_column = column\n       end if\n    else\n       the_column = 1   \n    end if\n\n    reversing = .false.  \n    if ( present(reverse) ) reversing = reverse\n\n    do\n       \n       \n       \n       \n       ea = get_element(rowA, the_column)\n       eb = get_element(rowB, the_column)\n       if ( present(ordering) ) then\n          if ( .not. reversing ) then\n             if ( ordering(ea, eb) > 0 ) then\n                \n             end if\n          else   \n             if ( ordering(ea, eb) < 0 ) then\n                \n             end if\n          end if\n       else\n          if ( .not. reversing ) then\n             if ( lexinternal(ea, eb) > 0 ) then\n                \n             end if\n          else   \n             if ( lexinternal(ea, eb) < 0 ) then\n                \n             end if\n          end if\n       end if\n       \n       \n    end do\n\n  end subroutine sort_table\n\nend module ExampleOptionalParameter\n", "target": ">>> def printtable(data):\n    for row in data:\n        print ' '.join('%-5s' % ('\"%s\"' % cell) for cell in row)\n\n        \n>>> import operator\n>>> def sorttable(table, ordering=None, column=0, reverse=False):\n    return sorted(table, cmp=ordering, key=operator.itemgetter(column), reverse=reverse)\n\n>>> data = [[\"a\", \"b\", \"c\"], [\"\", \"q\", \"z\"], [\"zap\", \"zip\", \"Zot\"]]\n>>> printtable(data)\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data) )\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=2) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>> printtable( sorttable(data, column=1) )\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n\"zap\" \"zip\" \"Zot\"\n>>> printtable( sorttable(data, column=1, reverse=True) )\n\"zap\" \"zip\" \"Zot\"\n\"\"    \"q\"   \"z\"  \n\"a\"   \"b\"   \"c\"  \n>>> printtable( sorttable(data, ordering=lambda a,b: cmp(len(b),len(a))) )\n\"zap\" \"zip\" \"Zot\"\n\"a\"   \"b\"   \"c\"  \n\"\"    \"q\"   \"z\"  \n>>>\n"}
{"id": 411526, "name": "Numeric error propagation", "source": "Translate Fortran to Python:       PROGRAM CALCULATE\t\n      REAL X1, Y1, X2, Y2\t\n      REAL X1E,Y1E,X2E,Y2E\t\n      DATA X1, Y1 ,X2, Y2 /100., 50., 200.,100./\t\n      DATA X1E,Y1E,X2E,Y2E/  1.1, 1.2,  2.2, 2.3/\t\n      REAL DX,DY,D2,D,DXE,DYE,E\t\n      CHARACTER*1 C\t\t\t\n      PARAMETER (C = CHAR(241))\t\t\n      REAL SD\t\n      SD(X,P,S) = P*ABS(X)**(P - 1)*S\t\n      WRITE (6,1) X1,C,X1E,Y1,C,Y1E,\t\n     1            X2,C,X2E,Y2,C,Y2E\t\n    1 FORMAT (\"Euclidean distance between two points:\"/\t\n     1 (\"(\",F5.1,A1,F3.1,\",\",F5.1,A1,F3.1,\")\"))\t\t\n      DX = (X1 - X2)\t\t\t\n      DXE = SQRT(X1E**2 + X2E**2)\t\n      DY = (Y1 - Y2)\t\t\t\n      DYE = SQRT(Y1E**2 + Y2E**2)\t\n      D2 = DX**2 + DY**2\t\t\n      DXE = SD(DX,2,DXE)\t\t\n      DYE = SD(DY,2,DYE)\t\t\n      E = SQRT(DXE**2 + DYE**2)\t\t\n      D = SQRT(D2)\t\t\t\n      E = SD(D2,0.5,E)\t\t\t\n      WRITE (6,2) D,C,E\t\t\t\n    2 FORMAT (\"Distance\",F6.1,A1,F4.2)\t\n      END\t\n", "target": "from collections import namedtuple\nimport math\n \nclass I(namedtuple('Imprecise', 'value, delta')):\n    'Imprecise type: I(value=0.0, delta=0.0)' \n \n    __slots__ = () \n \n    def __new__(_cls, value=0.0, delta=0.0):\n        'Defaults to 0.0 \u00b1 delta'\n        return super().__new__(_cls, float(value), abs(float(delta)))\n \n    def reciprocal(self):\n        return I(1. / self.value, self.delta / (self.value**2)) \n \n    def __str__(self):\n        'Shorter form of Imprecise as string'\n        return 'I(%g, %g)' % self\n \n    def __neg__(self):\n        return I(-self.value, self.delta)\n \n    def __add__(self, other):\n        if type(other) == I:\n            return I( self.value + other.value, (self.delta**2 + other.delta**2)**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value + c, self.delta)\n\n    def __sub__(self, other):\n        return self + (-other)\n \n    def __radd__(self, other):\n        return I.__add__(self, other)\n \n    def __mul__(self, other):\n        if type(other) == I:\n            \n            \n            a1,b1 = self\n            a2,b2 = other\n            f = a1 * a2\n            return I( f, f * ( (b1 / a1)**2 + (b2 / a2)**2 )**0.5 )\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value * c, self.delta * c)\n \n    def __pow__(self, other):\n        if type(other) == I:\n            return NotImplemented\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        f = self.value ** c\n        return I(f, f * c * (self.delta / self.value))\n \n    def __rmul__(self, other):\n        return I.__mul__(self, other)\n \n    def __truediv__(self, other):\n        if type(other) == I:\n            return self.__mul__(other.reciprocal())\n        try:\n            c = float(other)\n        except:\n            return NotImplemented\n        return I(self.value / c, self.delta / c)\n \n    def __rtruediv__(self, other):\n        return other * self.reciprocal()\n \n    __div__, __rdiv__ = __truediv__, __rtruediv__\n \nImprecise = I\n\ndef distance(p1, p2):\n    x1, y1 = p1\n    x2, y2 = p2\n    return ((x1 - x2)**2 + (y1 - y2)**2)**0.5\n \nx1 = I(100, 1.1)\nx2 = I(200, 2.2)\ny1 = I( 50, 1.2)\ny2 = I(100, 2.3)\n\np1, p2 = (x1, y1), (x2, y2)\nprint(\"Distance between points\\n  p1: %s\\n  and p2: %s\\n  = %r\" % (\n      p1, p2, distance(p1, p2)))\n"}
{"id": 411527, "name": "Trabb Pardo\u2013Knuth algorithm", "source": "Translate Fortran to Python: program tpk\n  implicit none\n  \n  real, parameter :: overflow = 400.0\n  real :: a(11), res\n  integer :: i\n \n  write(*,*) \"Input eleven numbers:\"\n  read(*,*) a\n \n  a = a(11:1:-1)\n  do i = 1, 11\n    res = f(a(i))\n    write(*, \"(a, f0.3, a)\", advance = \"no\") \"f(\", a(i), \") = \"\n    if(res > overflow) then\n      write(*, \"(a)\") \"overflow\n    else\n       write(*, \"(f0.3)\") res\n    end if\n  end do  \n      \ncontains\n\nreal function f(x)\n  real, intent(in) :: x\n  \n  f = sqrt(abs(x)) + 5.0*x**3\n\nend function  \nend program\n", "target": "Python 3.2.2 (default, Sep  4 2011, 09:51:08) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> def f(x): return abs(x) ** 0.5 + 5 * x**3\n\n>>> print(', '.join('%s:%s' % (x, v if v<=400 else \"TOO LARGE!\")\n\t           for x,v in ((y, f(float(y))) for y in input('\\nnumbers: ').strip().split()[:11][::-1])))\n\n11 numbers: 1 2 3 4 5 6 7 8 9 10 11\n11:TOO LARGE!, 10:TOO LARGE!, 9:TOO LARGE!, 8:TOO LARGE!, 7:TOO LARGE!, 6:TOO LARGE!, 5:TOO LARGE!, 4:322.0, 3:136.73205080756887, 2:41.41421356237309, 1:6.0\n>>>\n"}
{"id": 411528, "name": "Rate counter", "source": "Translate Fortran to Python:       DO I = FIRST,LAST\n        IF (PROGRESSNOTE((I - FIRST)/(LAST - FIRST + 1.0))) WRITE (6,*) \"Reached \",I,\", towards \",LAST\n        ...much computation...\n      END DO\n", "target": "import subprocess\nimport time\n\nclass Tlogger(object):\n    def __init__(self):\n        self.counts = 0\n        self.tottime = 0.0\n        self.laststart = 0.0\n        self.lastreport = time.time()\n\n    def logstart(self):\n        self.laststart = time.time()\n\n    def logend(self):\n        self.counts +=1\n        self.tottime += (time.time()-self.laststart)\n        if (time.time()-self.lastreport)>5.0:   \n           self.report()\n\n    def report(self):\n        if ( self.counts > 4*self.tottime):\n            print \"Subtask execution rate: %f times/second\"% (self.counts/self.tottime);\n        else:\n            print \"Average execution time: %f seconds\"%(self.tottime/self.counts);\n        self.lastreport = time.time()\n\n\ndef taskTimer( n, subproc_args ):\n    logger = Tlogger()\n\n    for x in range(n):\n        logger.logstart()\n        p = subprocess.Popen(subproc_args)\n        p.wait()\n        logger.logend()\n    logger.report()\n\n\nimport timeit\nimport sys\n\ndef main( ):\n\n    \n    s = \n    timer = timeit.Timer(s)\n    rzlts = timer.repeat(5, 5000)\n    for t in rzlts:\n        print \"Time for 5000 executions of statement = \",t\n    \n    \n    print \"\n    print \"Command:\",sys.argv[2:]\n    print \"\"\n    for k in range(3):\n       taskTimer( int(sys.argv[1]), sys.argv[2:])\n\nmain()\n"}
{"id": 411529, "name": "Topswops", "source": "Translate Fortran to Python: module top\nimplicit none\ncontains \nrecursive function f(x) result(m)\n  integer :: n, m, x(:),y(size(x)), fst\n  fst = x(1)\n  if (fst == 1) then\n    m = 0\n  else\n    y(1:fst) = x(fst:1:-1)\n    y(fst+1:) = x(fst+1:)\n    m = 1 + f(y)\n  end if\nend function\n\nrecursive function perms(x) result(p)\ninteger, pointer     :: p(:,:), q(:,:)\ninteger              :: x(:), n, k, i\nn = size(x)\nif (n == 1) then\n  allocate(p(1,1))\n  p(1,:) = x\nelse\n  q => perms(x(2:n))\n  k = ubound(q,1)\n  allocate(p(k*n,n))\n  p = 0\n  do i = 1,n\n    p(1+k*(i-1):k*i,1:i-1) = q(:,1:i-1)\n    p(1+k*(i-1):k*i,i) = x(1)\n    p(1+k*(i-1):k*i,i+1:) = q(:,i:)\n  end do\nend if\nend function\nend module\n\nprogram topswort\nuse top\nimplicit none\ninteger :: x(10)\ninteger, pointer  :: p(:,:)\ninteger :: i, j, m\n\nforall(i=1:10)\n  x(i) = i\nend forall\n\ndo i = 1,10\n  p=>perms(x(1:i))\n  m = 0\n  do j = 1, ubound(p,1)\n    m = max(m, f(p(j,:)))\n  end do\n  print \"(i3,a,i3)\", i,\": \",m\nend do  \nend program\n", "target": ">>> from itertools import permutations\n>>> def f1(p):\n\ti = 0\n\twhile True:\n\t\tp0  = p[0]\n\t\tif p0 == 1: break\n\t\tp[:p0] = p[:p0][::-1]\n\t\ti  += 1\n\treturn i\n\n>>> def fannkuch(n):\n\treturn max(f1(list(p)) for p in permutations(range(1, n+1)))\n\n>>> for n in range(1, 11): print(n,fannkuch(n))\n\n1 0\n2 1\n3 2\n4 4\n5 7\n6 10\n7 16\n8 22\n9 30\n10 38\n>>>\n"}
{"id": 411530, "name": "Odd word problem", "source": "Translate Fortran to Python:       MODULE ELUDOM\t\n       INTEGER MSG,INF\t\n       LOGICAL DEFER\t\n       CONTAINS\n        CHARACTER*1 RECURSIVE FUNCTION GET(IN)\t\n         INTEGER IN\t\n         CHARACTER*1 C\t\n          READ (IN,1,ADVANCE=\"NO\",EOR=3,END=4) C\t\n    1     FORMAT (A1,$)\t\n    2     IF ((\"A\"<=C .AND. C<=\"Z\").OR.(\"a\"<=C .AND. C<=\"z\")) THEN\t\n            IF (DEFER) THEN\t\n              GET = GET(IN)\t\n              WRITE (MSG,1) C\t\n              RETURN\t\t\n            END IF\t\t\n           ELSE\t\t\n            DEFER = .NOT. DEFER\t\n          END IF\t\n    3     GET = C\t\n          RETURN\t\n    4     GET = CHAR(0)\t\n        END FUNCTION GET\n      END MODULE ELUDOM\t\n\n      PROGRAM CONFUSED\t\n      USE ELUDOM\t\n      CHARACTER*1 C\t\n      MSG = 6\t\n      INF = 10\t\n      OPEN (INF,NAME = \"Confused.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t\n\nChew through the input. A full stop marks the end.\n   10 DEFER = .FALSE.\t\n   11 C = GET(INF)\t\t\n      IF (ICHAR(C).LE.0) STOP\t\t\n      IF (C.NE.\" \") WRITE (MSG,12) C\t\n   12 FORMAT (A1,$)\t\t\t\n      IF (C.NE.\".\") GO TO 11\t\n      WRITE (MSG,\"('')\")\t\n      GO TO 10\t\t\n      END\t\n", "target": "from sys import stdin, stdout\n\ndef char_in(): return stdin.read(1)\ndef char_out(c): stdout.write(c)\n\ndef odd(prev = lambda: None):\n\ta = char_in()\n\tif not a.isalpha():\n\t\tprev()\n\t\tchar_out(a)\n\t\treturn a != '.'\n\n\t\n\tdef clos():\n\t\tchar_out(a)\n\t\tprev()\n\n\treturn odd(clos)\n\ndef even():\n\twhile True:\n\t\tc = char_in()\n\t\tchar_out(c)\n\t\tif not c.isalpha(): return c != '.'\n\ne = False\nwhile odd() if e else even():\n\te = not e\n"}
{"id": 411531, "name": "Memory layout of a data structure", "source": "Translate Fortran to Python:        TYPE RS232PIN9\n        LOGICAL CARRIER_DETECT\t\t\n        LOGICAL RECEIVED_DATA\t\t\n        LOGICAL TRANSMITTED_DATA\t\n        LOGICAL DATA_TERMINAL_READY\t\n        LOGICAL SIGNAL_GROUND\t\t\n        LOGICAL DATA_SET_READY\t\t\n        LOGICAL REQUEST_TO_SEND\t\t\n        LOGICAL CLEAR_TO_SEND\t\t\n        LOGICAL RING_INDICATOR\t\t\n       END TYPE RS232PIN9\n", "target": "from ctypes import Structure, c_int\n\nrs232_9pin  = \"_0 CD RD TD DTR SG DSR RTS CTS RI\".split()\nrs232_25pin = ( \"_0  PG  TD  RD  RTS CTS DSR SG  CD  pos neg\"\n                \"_11 SCD SCS STD TC  SRD RC\"\n                \"_18 SRS DTR SQD RI DRS XTC\" ).split()\n\nclass RS232_9pin(Structure):\n    _fields_ = [(__, c_int, 1) for __ in rs232_9pin]\n\n\t\nclass RS232_25pin(Structure):\n    _fields_ = [(__, c_int, 1) for __ in rs232_25pin]\n"}
{"id": 411532, "name": "Largest proper divisor of n", "source": "Translate Fortran to Python:        program LargestProperDivisors\n       implicit none\n       integer i, lpd\n       do 10 i=1, 100\n           write (*,'(I3)',advance='no') lpd(i)\n 10        if (i/10*10 .eq. i) write (*,*)       \n       end program\n       \n       integer function lpd(n)\n       implicit none\n       integer n, i\n       if (n .le. 1) then\n           lpd = 1\n       else\n           do 10 i=n-1, 1, -1\n 10            if (n/i*i .eq. n) goto 20\n 20        lpd = i\n       end if\n       end function\n", "target": "def lpd(n):\n    for i in range(n-1,0,-1):\n        if n%i==0: return i\n    return 1\n\nfor i in range(1,101):\n    print(\"{:3}\".format(lpd(i)), end=i%10==0 and '\\n' or '')\n"}
{"id": 411533, "name": "Numbers with equal rises and falls", "source": "Translate Fortran to Python:       PROGRAM A296712\n          INTEGER IDX, NUM, I\n*         Index and number start out at zero\n          IDX = 0\n          NUM = 0 \n*         Find and write the first 200 numbers\n          WRITE (*,'(A)') 'The first 200 numbers are: '\n          DO 100 I = 1, 200\n              CALL NEXT NUM(IDX, NUM)\n              WRITE (*,'(I4)',ADVANCE='NO') NUM\n              IF (MOD(I,20).EQ.0) WRITE (*,*)\n  100     CONTINUE\n*         Find the 10,000,000th number\n          WRITE (*,*)\n          WRITE (*,'(A)',ADVANCE='NO') 'The 10,000,000th number is: '\n  200     CALL NEXT NUM(IDX, NUM)\n          IF (IDX.NE.10000000) GOTO 200\n          WRITE (*,'(I8)') NUM\n          STOP\n      END    \n\n*     Given index and current number, retrieve the next number\n*     in the sequence.\n      SUBROUTINE NEXT NUM(IDX, NUM) \n          INTEGER IDX, NUM\n          LOGICAL IN SEQ\n  100     NUM = NUM + 1\n          IF (.NOT. IN SEQ(NUM)) GOTO 100\n          IDX = IDX + 1           \n      END\n    \n*     See whether N is in the sequence\n      LOGICAL FUNCTION IN SEQ(N)\n          INTEGER N, DL, DR, VAL, HEIGHT\n*         Get first digit and divide value by 10\n          DL = MOD(N, 10)\n          VAL = N / 10\n          HEIGHT = 0\n  100     IF (VAL.NE.0) THEN\n*             Retrieve digits by modulo and division\n              DR = DL\n              DL = MOD(VAL, 10)\n              VAL = VAL / 10\n*             Record rise or fall\n              IF (DL.LT.DR) HEIGHT = HEIGHT + 1\n              IF (DL.GT.DR) HEIGHT = HEIGHT - 1\n              GOTO 100\n          END IF\n*         N is in the sequence if the final height is 0\n          IN SEQ = HEIGHT.EQ.0\n          RETURN\n      END\n", "target": "import itertools\n\ndef riseEqFall(num):\n    \n    height = 0\n    d1 = num % 10\n    num //= 10\n    while num:\n        d2 = num % 10\n        height += (d1<d2) - (d1>d2)\n        d1 = d2\n        num //= 10\n    return height == 0\n    \ndef sequence(start, fn):\n    \n    num=start-1\n    while True:\n        num += 1\n        while not fn(num): num += 1\n        yield num\n\na296712 = sequence(1, riseEqFall)\n\n\nprint(\"The first 200 numbers are:\")\nprint(*itertools.islice(a296712, 200))\n\n\nprint(\"The 10,000,000th number is:\")\nprint(*itertools.islice(a296712, 10000000-200-1, 10000000-200))\n\n\n"}
{"id": 411534, "name": "Length of an arc between two angles", "source": "Translate Fortran to Python: *-----------------------------------------------------------------------\n* given:  polar coordinates of two points on a circle of known radius\n* find:  length of the major arc between these points\n*\n*___Name_____Type___I/O___Description___________________________________\n*   RAD      Real   In    Radius of circle, any unit of measure\n*   ANG1     Real   In    Angle of first point, degrees\n*   ANG2     Real   In    Angle of second point, degrees\n*   MAJARC   Real   Out   Length of major arc, same units as RAD\n*-----------------------------------------------------------------------\n      FUNCTION MAJARC (RAD, ANG1, ANG2)\n       IMPLICIT NONE\n       REAL RAD, ANG1, ANG2, MAJARC\n\n       REAL FACT                          \n       PARAMETER (FACT = 3.1415926536 / 180.)\n       REAL DIF\n\n*       Begin\n       MAJARC = 0.\n       IF (RAD .LE. 0.) RETURN\n       DIF = MOD(ABS(ANG1 - ANG2), 360.)   \n       DIF = MAX(DIF, 360. - DIF)          \n       MAJARC = RAD * DIF * FACT           \n       RETURN\n      END  \n\n*-----------------------------------------------------------------------\n      PROGRAM TMA\n       IMPLICIT NONE\n       INTEGER J\n       REAL ANG1, ANG2, RAD, MAJARC, ALENG\n       REAL DATARR(3,3)     \n       DATA DATARR / 120.,  10., 10.,\n     $                10., 120., 10.,\n     $               180., 270., 10. /\n\n       DO J = 1, 3\n         ANG1 = DATARR(1,J)\n         ANG2 = DATARR(2,J)\n         RAD = DATARR(3,J)\n         ALENG = MAJARC (RAD, ANG1, ANG2)        \n         PRINT *, 'first angle: ', ANG1, ' second angle: ', ANG2, \n     $     ' radius: ', RAD, ' Length of major arc: ', ALENG\n       END DO\n      END\n", "target": "import math\n\ndef arc_length(r, angleA, angleB):\n    return (360.0 - abs(angleB - angleA)) * math.pi * r / 180.0\n"}
{"id": 411535, "name": "Matrix with two diagonals", "source": "Translate Fortran to Python: program prog\n\n    dimension a(100, 100)\n\n    n = 7\n\t\n    j1 = 1\n    j2 = n\n    do i = 1, n\n        do j = 1, n\n            a(i, j) = 0.\n        end do\n        a(i, j1) = 1\n        a(i, j2) = 1\n        j1 = j1 + 1\n        j2 = j2 - 1\n    end do\n\n    do i = 1, n\n        print *, (a(i, j), j=1,n)\n    end do\n\nend\n", "target": "\n\n\n\ndef twoDiagonalMatrix(n):\n    \n    return matrix(\n        n, n, lambda row, col: int(\n            row in (col, 1 + (n - col))\n        )\n    )\n\n\n\n\ndef main():\n    \n    for n in [7, 8]:\n        print(\n            showMatrix(\n                twoDiagonalMatrix(n)\n            ) + '\\n'\n        )\n\n\n\n\n\ndef matrix(nRows, nCols, f):\n    \n    return [\n        [f(y, x) for x in range(1, 1 + nCols)]\n        for y in range(1, 1 + nRows)\n    ]\n\n\n\ndef showMatrix(rows):\n    \n    return '\\n'.join([\n        ' '.join([str(x) for x in y]) for y in rows\n    ])\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 411536, "name": "Words containing _the_ substring", "source": "Translate Fortran to Python: program main\nimplicit none\ninteger :: lun\ncharacter(len=256) :: line\ninteger :: ios\n   open(file='unixdict.txt',newunit=lun)\n   do\n      read(lun,'(a)',iostat=ios)line\n      if(ios /= 0)exit\n      if( index(line,'the') /= 0 .and. len_trim(line) > 11 ) then\n         write(*,'(a)')trim(line)\n      endif\n   enddo\nend program main\n", "target": "import urllib.request as request\n\nwith request.urlopen(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\") as f:\n    a = f.read().decode(\"ASCII\").split()\n\nfor s in a:\n    if len(s) > 11 and \"the\" in s:\n        print(s)\n"}
{"id": 411537, "name": "Here document", "source": "Translate Fortran to Python:       INTEGER I         \n      CHARACTER*666 I AM    \n      I AM =                                                           \"<col72\nC              111111111122222222223333333333444444444455555555556666666666\nC     123456789012345678901234567890123456789012345678901234567890123456789\n     1                                                                  <col72\n     2              I AM                                                <col72\n     3                                                                  <col72\n     4           THAT I AM                                              <col72\n     5\"\n\nChug through the text blob.\n      DO I = 0,600,66   \n        WRITE (6,1) I AM(I + 1:I + 66)  \n    1   FORMAT (A66)            \n      END DO                \n      END\n", "target": "print()\n"}
{"id": 411538, "name": "Here document", "source": "Translate Fortran to Python:       INTEGER I         \n      CHARACTER*666 I AM    \n      I AM =                                                           \"<col72\nC              111111111122222222223333333333444444444455555555556666666666\nC     123456789012345678901234567890123456789012345678901234567890123456789\n     1                                                                  <col72\n     2              I AM                                                <col72\n     3                                                                  <col72\n     4           THAT I AM                                              <col72\n     5\"\n\nChug through the text blob.\n      DO I = 0,600,66   \n        WRITE (6,1) I AM(I + 1:I + 66)  \n    1   FORMAT (A66)            \n      END DO                \n      END\n", "target": "print()\n"}
{"id": 411539, "name": "15 puzzle solver", "source": "Translate Fortran to Python: IF (NR.EQ.4) THEN\n code specialised for NR = 4\nELSE IF (NR.EQ.3) THEN\n code specialised for NR = 3\nEND IF\n", "target": "import random\n\n\nclass IDAStar:\n    def __init__(self, h, neighbours):\n        \n\n        self.h = h\n        self.neighbours = neighbours\n        self.FOUND = object()\n\n\n    def solve(self, root, is_goal, max_cost=None):\n        \n\n        self.is_goal = is_goal\n        self.path = [root]\n        self.is_in_path = {root}\n        self.path_descrs = []\n        self.nodes_evaluated = 0\n\n        bound = self.h(root)\n\n        while True:\n            t = self._search(0, bound)\n            if t is self.FOUND: return self.path, self.path_descrs, bound, self.nodes_evaluated\n            if t is None: return None\n            bound = t\n\n    def _search(self, g, bound):\n        self.nodes_evaluated += 1\n\n        node = self.path[-1]\n        f = g + self.h(node)\n        if f > bound: return f\n        if self.is_goal(node): return self.FOUND\n\n        m = None \n        for cost, n, descr in self.neighbours(node):\n            if n in self.is_in_path: continue\n\n            self.path.append(n)\n            self.is_in_path.add(n)\n            self.path_descrs.append(descr)\n            t = self._search(g + cost, bound)\n\n            if t == self.FOUND: return self.FOUND\n            if m is None or (t is not None and t < m): m = t\n\n            self.path.pop()\n            self.path_descrs.pop()\n            self.is_in_path.remove(n)\n\n        return m\n\n\ndef slide_solved_state(n):\n    return tuple(i % (n*n) for i in range(1, n*n+1))\n\ndef slide_randomize(p, neighbours):\n    for _ in range(len(p) ** 2):\n        _, p, _ = random.choice(list(neighbours(p)))\n    return p\n\ndef slide_neighbours(n):\n    movelist = []\n    for gap in range(n*n):\n        x, y = gap % n, gap // n\n        moves = []\n        if x > 0: moves.append(-1)    \n        if x < n-1: moves.append(+1)  \n        if y > 0: moves.append(-n)    \n        if y < n-1: moves.append(+n)  \n        movelist.append(moves)\n\n    def neighbours(p):\n        gap = p.index(0)\n        l = list(p)\n\n        for m in movelist[gap]:\n            l[gap] = l[gap + m]\n            l[gap + m] = 0\n            yield (1, tuple(l), (l[gap], m))\n            l[gap + m] = l[gap]\n            l[gap] = 0\n\n    return neighbours\n\ndef slide_print(p):\n    n = int(round(len(p) ** 0.5))\n    l = len(str(n*n))\n    for i in range(0, len(p), n):\n        print(\" \".join(\"{:>{}}\".format(x, l) for x in p[i:i+n]))\n\ndef encode_cfg(cfg, n):\n    r = 0\n    b = n.bit_length()\n    for i in range(len(cfg)):\n        r |= cfg[i] << (b*i)\n    return r\n\n\ndef gen_wd_table(n):\n    goal = [[0] * i + [n] + [0] * (n - 1 - i) for i in range(n)]\n    goal[-1][-1] = n - 1\n    goal = tuple(sum(goal, []))\n\n    table = {}\n    to_visit = [(goal, 0, n-1)]\n    while to_visit:\n        cfg, cost, e = to_visit.pop(0)\n        enccfg = encode_cfg(cfg, n)\n        if enccfg in table: continue\n        table[enccfg] = cost\n\n        for d in [-1, 1]:\n            if 0 <= e + d < n:\n                for c in range(n):\n                    if cfg[n*(e+d) + c] > 0:\n                        ncfg = list(cfg)\n                        ncfg[n*(e+d) + c] -= 1\n                        ncfg[n*e + c] += 1\n                        to_visit.append((tuple(ncfg), cost + 1, e+d))\n\n    return table\n\ndef slide_wd(n, goal):\n    wd = gen_wd_table(n)\n    goals = {i : goal.index(i) for i in goal}\n    b = n.bit_length()\n\n    def h(p):\n        ht = 0 \n        vt = 0 \n        d = 0\n        for i, c in enumerate(p):\n            if c == 0: continue\n            g = goals[c]\n            xi, yi = i % n, i // n\n            xg, yg = g % n, g // n\n            ht += 1 << (b*(n*yi+yg))\n            vt += 1 << (b*(n*xi+xg))\n\n            if yg == yi:\n                for k in range(i + 1, i - i%n + n): \n                    if p[k] and goals[p[k]] // n == yi and goals[p[k]] < g:\n                        d += 2\n\n            if xg == xi:\n                for k in range(i + n, n * n, n): \n                    if p[k] and goals[p[k]] % n == xi and goals[p[k]] < g:\n                        d += 2\n\n        d += wd[ht] + wd[vt]\n\n        return d\n    return h\n\n\n\n\nif __name__ == \"__main__\":\n    solved_state = slide_solved_state(4)\n    neighbours = slide_neighbours(4)\n    is_goal = lambda p: p == solved_state\n\n    tests = [\n        (15, 14, 1, 6, 9, 11, 4, 12, 0, 10, 7, 3, 13, 8, 5, 2),\n    ]\n\n    slide_solver = IDAStar(slide_wd(4, solved_state), neighbours)\n\n    for p in tests:\n        path, moves, cost, num_eval = slide_solver.solve(p, is_goal, 80)\n        slide_print(p)\n        print(\", \".join({-1: \"Left\", 1: \"Right\", -4: \"Up\", 4: \"Down\"}[move[1]] for move in moves))\n        print(cost, num_eval)\n"}
{"id": 411540, "name": "Address of a variable", "source": "Translate Fortran to Python: program test_loc\n  implicit none\n\n  integer :: i\n  real    :: r\n\n  i = loc(r)\n  print *, i\nend program\n", "target": "var num = 12\nvar pointer = ptr(num) \n\nprint pointer \n\n@unsafe \npointer.addr = 0xFFFE \n"}
{"id": 411541, "name": "2048", "source": "Translate Fortran to Python:         WRITE (MSG,1)\t\t\n    1   FORMAT (\"|\",<NC>(<W>(\"-\"),\"|\"))\t\n    2     FORMAT (\"|\",<NC>(<W>(\" \"),\"|\"))\t\n          WRITE (MSG,22) ((\" \",L1  = 1,W),\"|\",C = 1,NC)\t\n   22     FORMAT (\"|\",666A1)\t\t\t\t\n    4     FORMAT (\"|\",<NC - 1>(<W>(\"-\"),\"+\"),<W>(\"-\"),\"|\")\t\n", "target": "\n\nimport curses\nfrom random import randrange, choice \nfrom collections import defaultdict\n\nletter_codes = [ord(ch) for ch in 'WASDRQwasdrq']\nactions = ['Up', 'Left', 'Down', 'Right', 'Restart', 'Exit']\nactions_dict = dict(zip(letter_codes, actions * 2))\n\ndef get_user_action(keyboard):    \n\tchar = \"N\"\n\twhile char not in actions_dict:    \n\t\tchar = keyboard.getch()\n\treturn actions_dict[char]\n\ndef transpose(field):\n\treturn [list(row) for row in zip(*field)]\n\ndef invert(field):\n\treturn [row[::-1] for row in field]\n\nclass GameField(object):\n\tdef __init__(self, height=4, width=4, win=2048):\n\t\tself.height = height\n\t\tself.width = width\n\t\tself.win_value = win\n\t\tself.score = 0\n\t\tself.highscore = 0\n\t\tself.reset()\n\n\tdef reset(self):\n\t\tif self.score > self.highscore:\n\t\t\tself.highscore = self.score\n\t\tself.score = 0\n\t\tself.field = [[0 for i in range(self.width)] for j in range(self.height)]\n\t\tself.spawn()\n\t\tself.spawn()\n\n\tdef move(self, direction):\n\t\tdef move_row_left(row):\n\t\t\tdef tighten(row): \n\t\t\t\tnew_row = [i for i in row if i != 0]\n\t\t\t\tnew_row += [0 for i in range(len(row) - len(new_row))]\n\t\t\t\treturn new_row\n\n\t\t\tdef merge(row):\n\t\t\t\tpair = False\n\t\t\t\tnew_row = []\n\t\t\t\tfor i in range(len(row)):\n\t\t\t\t\tif pair:\n\t\t\t\t\t\tnew_row.append(2 * row[i])\n\t\t\t\t\t\tself.score += 2 * row[i]\n\t\t\t\t\t\tpair = False\n\t\t\t\t\telse:\n\t\t\t\t\t\tif i + 1 < len(row) and row[i] == row[i + 1]:\n\t\t\t\t\t\t\tpair = True\n\t\t\t\t\t\t\tnew_row.append(0)\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tnew_row.append(row[i])\n\t\t\t\tassert len(new_row) == len(row)\n\t\t\t\treturn new_row\n\t\t\treturn tighten(merge(tighten(row)))\n\n\t\tmoves = {}\n\t\tmoves['Left']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\t[move_row_left(row) for row in field]\n\t\tmoves['Right'] = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tinvert(moves['Left'](invert(field)))\n\t\tmoves['Up']    = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\ttranspose(moves['Left'](transpose(field)))\n\t\tmoves['Down']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\ttranspose(moves['Right'](transpose(field)))\n\n\t\tif direction in moves:\n\t\t\tif self.move_is_possible(direction):\n\t\t\t\tself.field = moves[direction](self.field)\n\t\t\t\tself.spawn()\n\t\t\t\treturn True\n\t\t\telse:\n\t\t\t\treturn False\n\n\tdef is_win(self):\n\t\treturn any(any(i >= self.win_value for i in row) for row in self.field)\n\n\tdef is_gameover(self):\n\t\treturn not any(self.move_is_possible(move) for move in actions)\n\n\tdef draw(self, screen):\n\t\thelp_string1 = '(W)Up (S)Down (A)Left (D)Right'\n\t\thelp_string2 = '     (R)Restart (Q)Exit'\n\t\tgameover_string = '           GAME OVER'\n\t\twin_string = '          YOU WIN!'\n\t\tdef cast(string):\n\t\t\tscreen.addstr(string + '\\n')\n\n\t\tdef draw_hor_separator():\n\t\t\ttop = '\u250c' + ('\u252c\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2510')[1:]\n\t\t\tmid = '\u251c' + ('\u253c\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2524')[1:]\n\t\t\tbot = '\u2514' + ('\u2534\u2500\u2500\u2500\u2500\u2500\u2500' * self.width + '\u2518')[1:]\n\t\t\tseparator = defaultdict(lambda: mid)\n\t\t\tseparator[0], separator[self.height] = top, bot\n\t\t\tif not hasattr(draw_hor_separator, \"counter\"):\n\t\t\t\tdraw_hor_separator.counter = 0\n\t\t\tcast(separator[draw_hor_separator.counter])\n\t\t\tdraw_hor_separator.counter += 1\n\n\t\tdef draw_row(row):\n\t\t\tcast(''.join('\u2502{: ^5} '.format(num) if num > 0 else '|      ' for num in row) + '\u2502')\n\n\t\tscreen.clear()\n\t\tcast('SCORE: ' + str(self.score))\n\t\tif 0 != self.highscore:\n\t\t\tcast('HIGHSCORE: ' + str(self.highscore))\n\t\tfor row in self.field:\n\t\t\tdraw_hor_separator()\n\t\t\tdraw_row(row)\n\t\tdraw_hor_separator()\n\t\tif self.is_win():\n\t\t\tcast(win_string)\n\t\telse:\n\t\t\tif self.is_gameover():\n\t\t\t\tcast(gameover_string)\n\t\t\telse:\n\t\t\t\tcast(help_string1)\n\t\tcast(help_string2)\n\n\tdef spawn(self):\n\t\tnew_element = 4 if randrange(100) > 89 else 2\n\t\t(i,j) = choice([(i,j) for i in range(self.width) for j in range(self.height) if self.field[i][j] == 0])\n\t\tself.field[i][j] = new_element\n\n\tdef move_is_possible(self, direction):\n\t\tdef row_is_left_movable(row): \n\t\t\tdef change(i): \n\t\t\t\tif row[i] == 0 and row[i + 1] != 0: \n\t\t\t\t\treturn True\n\t\t\t\tif row[i] != 0 and row[i + 1] == row[i]: \n\t\t\t\t\treturn True\n\t\t\t\treturn False\n\t\t\treturn any(change(i) for i in range(len(row) - 1))\n\n\t\tcheck = {}\n\t\tcheck['Left']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tany(row_is_left_movable(row) for row in field)\n\n\t\tcheck['Right'] = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\t check['Left'](invert(field))\n\n\t\tcheck['Up']    = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tcheck['Left'](transpose(field))\n\n\t\tcheck['Down']  = lambda field:\t\t\t\t\t\t\t\t\\\n\t\t\t\tcheck['Right'](transpose(field))\n\n\t\tif direction in check:\n\t\t\treturn check[direction](self.field)\n\t\telse:\n\t\t\treturn False\n\ndef main(stdscr):\n\tcurses.use_default_colors()\n\tgame_field = GameField(win=32)\n\tstate_actions = {} \n\tdef init():\n\t\tgame_field.reset()\n\t\treturn 'Game'\n\n\tstate_actions['Init'] = init\n\n\tdef not_game(state):\n\t\tgame_field.draw(stdscr)\n\t\taction = get_user_action(stdscr)\n\t\tresponses = defaultdict(lambda: state)\n\t\tresponses['Restart'], responses['Exit'] = 'Init', 'Exit'\n\t\treturn responses[action]\n\n\tstate_actions['Win'] = lambda: not_game('Win')\n\tstate_actions['Gameover'] = lambda: not_game('Gameover')\n\n\tdef game():\n\t\tgame_field.draw(stdscr)\n\t\taction = get_user_action(stdscr)\n\t\tif action == 'Restart':\n\t\t\treturn 'Init'\n\t\tif action == 'Exit':\n\t\t\treturn 'Exit'\n\t\tif game_field.move(action): \n\t\t\tif game_field.is_win():\n\t\t\t\treturn 'Win'\n\t\t\tif game_field.is_gameover():\n\t\t\t\treturn 'Gameover'\n\t\treturn 'Game'\n\t\t\n\tstate_actions['Game'] = game\n\n\tstate = 'Init'\n\twhile state != 'Exit':\n\t\tstate = state_actions[state]()\n\ncurses.wrapper(main)\n"}
{"id": 411542, "name": "Determinant and permanent", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  real, dimension(3,3) :: j, m\n  data j/ 2,-1, 1,-1,-2, 1,-1,-1,-1/\n  data m/2, 9, 4, 7, 5, 3, 6, 1, 8/\n  write(6,*) 'j example, determinant: ',det(j,3,-1)\n  write(6,*) 'j example, permanent:   ',det(j,3,1)\n  write(6,*) 'maxima, determinant:    ',det(m,3,-1)\n  write(6,*) 'maxima, permanent:      ',det(m,3,1)\n\ncontains\n\n  recursive function det(a,n,permanent) result(accumulation)\n    \n    \n    real, dimension(n,n), intent(in) :: a\n    integer, intent(in) :: n, permanent\n    real, dimension(n-1, n-1) :: b\n    real :: accumulation\n    integer :: i, sgn\n    if (n .eq. 1) then\n      accumulation = a(1,1)\n    else\n      accumulation = 0\n      sgn = 1\n      do i=1, n\n        b(:, :(i-1)) = a(2:, :i-1)\n        b(:, i:) = a(2:, i+1:)\n        accumulation = accumulation + sgn * a(1, i) * det(b, n-1, permanent)\n        sgn = sgn * permanent\n      enddo\n    endif\n  end function det\n\nend program f\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 411543, "name": "Determinant and permanent", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram f\n  implicit none\n  real, dimension(3,3) :: j, m\n  data j/ 2,-1, 1,-1,-2, 1,-1,-1,-1/\n  data m/2, 9, 4, 7, 5, 3, 6, 1, 8/\n  write(6,*) 'j example, determinant: ',det(j,3,-1)\n  write(6,*) 'j example, permanent:   ',det(j,3,1)\n  write(6,*) 'maxima, determinant:    ',det(m,3,-1)\n  write(6,*) 'maxima, permanent:      ',det(m,3,1)\n\ncontains\n\n  recursive function det(a,n,permanent) result(accumulation)\n    \n    \n    real, dimension(n,n), intent(in) :: a\n    integer, intent(in) :: n, permanent\n    real, dimension(n-1, n-1) :: b\n    real :: accumulation\n    integer :: i, sgn\n    if (n .eq. 1) then\n      accumulation = a(1,1)\n    else\n      accumulation = 0\n      sgn = 1\n      do i=1, n\n        b(:, :(i-1)) = a(2:, :i-1)\n        b(:, i:) = a(2:, i+1:)\n        accumulation = accumulation + sgn * a(1, i) * det(b, n-1, permanent)\n        sgn = sgn * permanent\n      enddo\n    endif\n  end function det\n\nend program f\n", "target": "from itertools import permutations\nfrom operator import mul\nfrom math import fsum\nfrom spermutations import spermutations\n\ndef prod(lst):\n    return reduce(mul, lst, 1)\n\ndef perm(a):\n    n = len(a)\n    r = range(n)\n    s = permutations(r)\n    return fsum(prod(a[i][sigma[i]] for i in r) for sigma in s)\n\ndef det(a):\n    n = len(a)\n    r = range(n)\n    s = spermutations(n)\n    return fsum(sign * prod(a[i][sigma[i]] for i in r)\n                for sigma, sign in s)\n\nif __name__ == '__main__':\n    from pprint import pprint as pp\n\n    for a in ( \n            [\n             [1, 2], \n             [3, 4]], \n\n            [\n             [1, 2, 3, 4],\n             [4, 5, 6, 7],\n             [7, 8, 9, 10],\n             [10, 11, 12, 13]],        \n\n            [\n             [ 0,  1,  2,  3,  4],\n             [ 5,  6,  7,  8,  9],\n             [10, 11, 12, 13, 14],\n             [15, 16, 17, 18, 19],\n             [20, 21, 22, 23, 24]],\n        ):\n        print('')\n        pp(a)\n        print('Perm: %s Det: %s' % (perm(a), det(a)))\n"}
{"id": 411544, "name": "Brazilian numbers", "source": "Translate Fortran to Python: \n\n      PROGRAM BRAZILIAN\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  MAX_NUMBER = 2000000 , NUMVARS = 20\n\n\n\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  b\n      INTEGER  ::  bcount\n      INTEGER  ::  bpos\n      CHARACTER(15)  ::  holder\n      CHARACTER(100)  ::  outline\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  p\n\n\n\n\n\n\n      CALL BRAZILIANSIEVE(b , MAX_NUMBER)\n      WRITE(6 , 34)\"The first 20 Brazilian numbers:\"\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n \n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 odd Brazilian numbers:\"\n      outline = ''\n      holder = ''\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 2\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 prime Brazilian numbers:\"\n      CALL ERATOSTHENES(p , MAX_NUMBER)\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) .AND. p(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"Various Brazilian numbers:\"\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<1000000 )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            IF( (bcount==100) .OR. (bcount==1000) .OR. (bcount==10000) .OR.               &\n              & (bcount==100000) .OR. (bcount==1000000) )WRITE(* , *)bcount ,             &\n               &\"th Brazilian number: \" , bpos\n         END IF\n         bpos = bpos + 1\n      END DO\n      STOP\n 34   FORMAT(/ , a)\n      END PROGRAM BRAZILIAN\n\n      SUBROUTINE BRAZILIANSIEVE(B , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  B\n      INTENT (IN) N\n      INTENT (OUT) B\n\n\n\n      INTEGER  ::  b11\n      INTEGER  ::  base\n      INTEGER  ::  bn\n      INTEGER  ::  bnn\n      INTEGER  ::  bpower\n      INTEGER  ::  digit\n      INTEGER  ::  i\n      LOGICAL  ::  iseven\n      INTEGER  ::  powermax\n\n      iseven = .FALSE.\n      B(1:6) = .FALSE.                 \n      DO i = 7 , N\n         B(i) = iseven\n         iseven = .NOT.iseven\n      END DO\n      DO base = 2 , (N/2)\n         b11 = base + 1\n         bnn = b11\n         DO digit = 3 , base - 1 , 2\n            bnn = bnn + b11 + b11\n            IF( bnn>N )EXIT\n            B(bnn) = .TRUE.\n         END DO\n      END DO\n      DO base = 2 , INT(SQRT(FLOAT(N)))\n         powermax = HUGE(powermax)/base             \n         IF( powermax>N )powermax = N               \n         DO digit = 1 , base - 1 , 2\n            bpower = base*base\n            bn = digit*(bpower + base + 1)\n            DO WHILE ( (bn<=N) .AND. (bpower<=powermax) )\n               IF( bn<=N )B(bn) = .TRUE.\n               bpower = bpower*base\n               bn = bn + (digit*bpower)\n            END DO\n         END DO\n      END DO\n      RETURN\n      END SUBROUTINE BRAZILIANSIEVE\n\n      SUBROUTINE ERATOSTHENES(P , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  P\n      INTENT (IN) N\n      INTENT (INOUT) P\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  ii\n      LOGICAL  ::  oddeven\n      INTEGER  ::  pr\n\n      P(1) = .FALSE.\n      P(2) = .TRUE.\n      oddeven = .TRUE.\n      DO i = 3 , N\n         P(i) = oddeven\n         oddeven = .NOT.oddeven\n      END DO\n      DO i = 2 , INT(SQRT(FLOAT(N)))\n         ii = i + i\n         IF( P(i) )THEN\n            DO pr = i*i , N , ii\n               P(pr) = .FALSE.\n            END DO\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE ERATOSTHENES\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 411545, "name": "Brazilian numbers", "source": "Translate Fortran to Python: \n\n      PROGRAM BRAZILIAN\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  MAX_NUMBER = 2000000 , NUMVARS = 20\n\n\n\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  b\n      INTEGER  ::  bcount\n      INTEGER  ::  bpos\n      CHARACTER(15)  ::  holder\n      CHARACTER(100)  ::  outline\n      LOGICAL , DIMENSION(1:MAX_NUMBER)  ::  p\n\n\n\n\n\n\n      CALL BRAZILIANSIEVE(b , MAX_NUMBER)\n      WRITE(6 , 34)\"The first 20 Brazilian numbers:\"\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n \n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 odd Brazilian numbers:\"\n      outline = ''\n      holder = ''\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 2\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"The first 20 prime Brazilian numbers:\"\n      CALL ERATOSTHENES(p , MAX_NUMBER)\n      bcount = 0\n      outline = ''\n      holder = ''\n      bpos = 1\n      DO WHILE ( bcount<NUMVARS )\n         IF( b(bpos) .AND. p(bpos) )THEN\n            bcount = bcount + 1\n            WRITE(holder , *)bpos\n            outline = TRIM(outline) // \" \" // ADJUSTL(holder)\n         END IF\n         bpos = bpos + 1\n      END DO\n      WRITE(6 , 34)outline\n      WRITE(6 , 34)\"Various Brazilian numbers:\"\n      bcount = 0\n      bpos = 1\n      DO WHILE ( bcount<1000000 )\n         IF( b(bpos) )THEN\n            bcount = bcount + 1\n            IF( (bcount==100) .OR. (bcount==1000) .OR. (bcount==10000) .OR.               &\n              & (bcount==100000) .OR. (bcount==1000000) )WRITE(* , *)bcount ,             &\n               &\"th Brazilian number: \" , bpos\n         END IF\n         bpos = bpos + 1\n      END DO\n      STOP\n 34   FORMAT(/ , a)\n      END PROGRAM BRAZILIAN\n\n      SUBROUTINE BRAZILIANSIEVE(B , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  B\n      INTENT (IN) N\n      INTENT (OUT) B\n\n\n\n      INTEGER  ::  b11\n      INTEGER  ::  base\n      INTEGER  ::  bn\n      INTEGER  ::  bnn\n      INTEGER  ::  bpower\n      INTEGER  ::  digit\n      INTEGER  ::  i\n      LOGICAL  ::  iseven\n      INTEGER  ::  powermax\n\n      iseven = .FALSE.\n      B(1:6) = .FALSE.                 \n      DO i = 7 , N\n         B(i) = iseven\n         iseven = .NOT.iseven\n      END DO\n      DO base = 2 , (N/2)\n         b11 = base + 1\n         bnn = b11\n         DO digit = 3 , base - 1 , 2\n            bnn = bnn + b11 + b11\n            IF( bnn>N )EXIT\n            B(bnn) = .TRUE.\n         END DO\n      END DO\n      DO base = 2 , INT(SQRT(FLOAT(N)))\n         powermax = HUGE(powermax)/base             \n         IF( powermax>N )powermax = N               \n         DO digit = 1 , base - 1 , 2\n            bpower = base*base\n            bn = digit*(bpower + base + 1)\n            DO WHILE ( (bn<=N) .AND. (bpower<=powermax) )\n               IF( bn<=N )B(bn) = .TRUE.\n               bpower = bpower*base\n               bn = bn + (digit*bpower)\n            END DO\n         END DO\n      END DO\n      RETURN\n      END SUBROUTINE BRAZILIANSIEVE\n\n      SUBROUTINE ERATOSTHENES(P , N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      LOGICAL , DIMENSION(*)  ::  P\n      INTENT (IN) N\n      INTENT (INOUT) P\n\n\n\n      INTEGER  ::  i\n      INTEGER  ::  ii\n      LOGICAL  ::  oddeven\n      INTEGER  ::  pr\n\n      P(1) = .FALSE.\n      P(2) = .TRUE.\n      oddeven = .TRUE.\n      DO i = 3 , N\n         P(i) = oddeven\n         oddeven = .NOT.oddeven\n      END DO\n      DO i = 2 , INT(SQRT(FLOAT(N)))\n         ii = i + i\n         IF( P(i) )THEN\n            DO pr = i*i , N , ii\n               P(pr) = .FALSE.\n            END DO\n         END IF\n      END DO\n      RETURN\n      END SUBROUTINE ERATOSTHENES\n", "target": "\n\nfrom itertools import count, islice\n\n\n\ndef isBrazil(n):\n    \n    return 7 <= n and (\n        0 == n % 2 or any(\n            map(monoDigit(n), range(2, n - 1))\n        )\n    )\n\n\n\ndef monoDigit(n):\n    \n    def go(base):\n        def g(b, n):\n            (q, d) = divmod(n, b)\n\n            def p(qr):\n                return d != qr[1] or 0 == qr[0]\n\n            def f(qr):\n                return divmod(qr[0], b)\n            return d == until(p)(f)(\n                (q, d)\n            )[1]\n        return g(base, n)\n    return go\n\n\n\n\ndef main():\n    \n    for kxs in ([\n            (' ', count(1)),\n            (' odd ', count(1, 2)),\n            (' prime ', primes())\n    ]):\n        print(\n            'First 20' + kxs[0] + 'Brazilians:\\n' +\n            showList(take(20)(filter(isBrazil, kxs[1]))) + '\\n'\n        )\n\n\n\n\n\ndef primes():\n    \n    n = 2\n    dct = {}\n    while True:\n        if n in dct:\n            for p in dct[n]:\n                dct.setdefault(n + p, []).append(p)\n            del dct[n]\n        else:\n            yield n\n            dct[n * n] = [n]\n        n = 1 + n\n\n\n\ndef showList(xs):\n    \n    return '[' + ','.join(str(x) for x in xs) + ']'\n\n\n\n\ndef take(n):\n    \n    def go(xs):\n        return (\n            xs[0:n]\n            if isinstance(xs, (list, tuple))\n            else list(islice(xs, n))\n        )\n    return go\n\n\n\ndef until(p):\n    \n    def go(f):\n        def g(x):\n            v = x\n            while not p(v):\n                v = f(v)\n            return v\n        return g\n    return go\n\n\n\nif __name__ == '__main__':\n    main()\n"}
{"id": 411546, "name": "Sum of divisors", "source": "Translate Fortran to Python:        program DivSum\n       implicit none\n       integer i, j, col, divs(100)\n       \n       do 10 i=1, 100, 1\n 10        divs(i) = 1\n \n       do 20 i=2, 100, 1\n           do 20 j=i, 100, i\n 20            divs(j) = divs(j) + i\n \n       col = 0\n       do 30 i=1, 100, 1\n           write (*,'(I4)',advance='no') divs(i)\n           col = col + 1\n           if (col .eq. 10) then\n               col = 0\n               write (*,*)\n           end if\n 30    continue\n       end program\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 411547, "name": "Sum of divisors", "source": "Translate Fortran to Python:        program DivSum\n       implicit none\n       integer i, j, col, divs(100)\n       \n       do 10 i=1, 100, 1\n 10        divs(i) = 1\n \n       do 20 i=2, 100, 1\n           do 20 j=i, 100, i\n 20            divs(j) = divs(j) + i\n \n       col = 0\n       do 30 i=1, 100, 1\n           write (*,'(I4)',advance='no') divs(i)\n           col = col + 1\n           if (col .eq. 10) then\n               col = 0\n               write (*,*)\n           end if\n 30    continue\n       end program\n", "target": "def factorize(n):\n    assert(isinstance(n, int))\n    if n < 0: \n        n = -n \n    if n < 2: \n        return \n    k = 0 \n    while 0 == n%2: \n        k += 1 \n        n //= 2 \n    if 0 < k: \n        yield (2,k) \n    p = 3 \n    while p*p <= n: \n        k = 0 \n        while 0 == n%p: \n            k += 1 \n            n //= p \n        if 0 < k: \n            yield (p,k)\n        p += 2 \n    if 1 < n: \n        yield (n,1) \n\ndef sum_of_divisors(n): \n    assert(n != 0) \n    ans = 1 \n    for (p,k) in factorize(n): \n        ans *= (pow(p,k+1) - 1)//(p-1) \n    return ans \n    \nif __name__ == \"__main__\":\n    print([sum_of_divisors(n) for n in range(1,101)])\n"}
{"id": 411548, "name": "Sorting algorithms_Bead sort", "source": "Translate Fortran to Python: program BeadSortTest\n  use iso_fortran_env \n  \n  \n  \n  \n\n  integer, dimension(7) :: a = (/ 7, 3, 5, 1, 2, 1, 20 /)\n\n  call beadsort(a)\n  print *, a\n\ncontains\n\n  subroutine beadsort(a)\n    integer, dimension(:), intent(inout) :: a\n\n    integer, dimension(maxval(a), maxval(a)) :: t\n    integer, dimension(maxval(a)) :: s\n    integer :: i, m\n\n    m = maxval(a)\n    \n    if ( any(a < 0) ) then\n       write(ERROR_UNIT,*) \"can't sort\"\n       return\n    end if\n\n    t = 0\n    forall(i=1:size(a)) t(i, 1:a(i)) = 1  \n    forall(i=1:m)             \n       s(i) = sum(t(:, i))    \n       t(:, i) = 0            \n       t(1:s(i), i) = 1       \n    end forall\n    \n    forall(i=1:size(a)) a(i) = sum(t(i,:))\n    \n  end subroutine beadsort\n\nend program BeadSortTest\n", "target": "\nfrom itertools import zip_longest\n\n\ndef beadsort(l):\n    return list(map(sum, zip_longest(*[[1] * e for e in l], fillvalue=0)))\n\n\n\nprint(beadsort([5,3,1,7,4,1,1]))\n"}
{"id": 411549, "name": "M\u00f6bius function", "source": "Translate Fortran to Python: program moebius\n    use iso_fortran_env, only: output_unit\n\n    integer, parameter          :: mu_max=1000000, line_break=20\n    integer, parameter          :: sqroot=int(sqrt(real(mu_max)))\n    integer                     :: i, j\n    integer, dimension(mu_max)  :: mu\n\n    mu = 1\n\n    do i = 2, sqroot\n        if (mu(i) == 1) then\n            do j = i, mu_max, i\n                mu(j) = mu(j) * (-i)\n            end do\n\n            do j = i**2, mu_max, i**2\n                mu(j) = 0\n            end do\n        end if\n    end do\n\n    do i = 2, mu_max\n        if (mu(i) == i) then\n            mu(i) = 1\n        else if (mu(i) == -i) then\n            mu(i) = -1\n        else if (mu(i) < 0) then\n            mu(i) = 1\n        else if (mu(i) > 0) then\n            mu(i) = -1\n        end if\n    end do\n\n    write(output_unit,*) \"The first 199 terms of the M\u00f6bius sequence are:\"\n    write(output_unit,'(3x)', advance=\"no\") \n    do i = 1, 199\n        write(output_unit,'(I2,x)', advance=\"no\") mu(i)\n        if (modulo(i+1, line_break) == 0) write(output_unit,*)\n    end do\nend program moebius\n", "target": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\ndef isPrime(n) :\n \n    if (n < 2) :\n        return False\n    for i in range(2, n + 1) :\n        if (i * i <= n and n % i == 0) :\n            return False\n    return True\n \ndef mobius(N) :\n     \n    \n    if (N == 1) :\n        return 1\n \n    \n    \n    \n    p = 0\n    for i in range(1, N + 1) :\n        if (N % i == 0 and\n                isPrime(i)) :\n \n            \n            \n            if (N % (i * i) == 0) :\n                return 0\n            else :\n \n                \n                \n                p = p + 1\n \n    \n    \n    \n    \n    if(p % 2 != 0) :\n        return -1\n    else :\n        return 1\n \n\nprint(\"Mobius numbers from 1..99:\")\n      \nfor i in range(1, 100):\n  print(f\"{mobius(i):>4}\", end = '')\n\n  if i % 20 == 0: print()\n\n\n"}
{"id": 411550, "name": "Mertens function", "source": "Translate Fortran to Python:       program Mertens\n      implicit none\n      integer M(1000), n, k, zero, cross\n       \nC     Generate Mertens numbers       \n      M(1) = 1\n      do 10 n=2, 1000\n          M(n) = 1\n          do 10 k=2, n\n              M(n) = M(n) - M(n/k)\n 10   continue \n\nC     Print table\n      write (*,\"('The first 99 Mertens numbers are:')\")\n      write (*,\"('   ')\",advance='no')\n      k = 9\n      do 20 n=1, 99\n          write (*,'(I3)',advance='no') M(n)\n          k = k-1\n          if (k .EQ. 0) then\n              k=10\n              write (*,*)\n          end if\n 20   continue\n \nC     Calculate zeroes and crossings\n      zero = 0\n      cross = 0\n      do 30 n=2, 1000\n          if (M(n) .EQ. 0) then\n              zero = zero + 1\n              if (M(n-1) .NE. 0) cross = cross+1\n          end if    \n 30   continue \n \n 40   format(\"M(N) is zero \",I2,\" times.\")\n      write (*,40) zero\n 50   format(\"M(N) crosses zero \",I2,\" times.\")\n      write (*,50) cross\n      end program\n", "target": "def mertens(count):\n    \n    m = [None, 1]\n    for n in range(2, count+1):\n        m.append(1)\n        for k in range(2, n+1):\n            m[n] -= m[n//k]\n    return m\n    \n\nms = mertens(1000)\n\nprint(\"The first 99 Mertens numbers are:\")\nprint(\"  \", end=' ')\ncol = 1\nfor n in ms[1:100]:\n    print(\"{:2d}\".format(n), end=' ')\n    col += 1\n    if col == 10:\n        print()\n        col = 0\n        \nzeroes = sum(x==0 for x in ms)\ncrosses = sum(a!=0 and b==0 for a,b in zip(ms, ms[1:]))\nprint(\"M(N) equals zero {} times.\".format(zeroes))\nprint(\"M(N) crosses zero {} times.\".format(crosses))\n"}
{"id": 411551, "name": "Product of divisors", "source": "Translate Fortran to Python:        program divprod\n       implicit none\n       integer divis(50), i, j\n       do 10 i=1, 50\n 10        divis(i) = 1\n       do 20 i=1, 50\n           do 20 j=i, 50, i\n 20            divis(j) = divis(j)*i\n       do 30 i=1, 50\n           write (*,'(I10)',advance='no') divis(i)\n 30        if (i/5 .ne. (i-1)/5) write (*,*)            \n       end program\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 411552, "name": "Product of divisors", "source": "Translate Fortran to Python:        program divprod\n       implicit none\n       integer divis(50), i, j\n       do 10 i=1, 50\n 10        divis(i) = 1\n       do 20 i=1, 50\n           do 20 j=i, 50, i\n 20            divis(j) = divis(j)*i\n       do 30 i=1, 50\n           write (*,'(I10)',advance='no') divis(i)\n 30        if (i/5 .ne. (i-1)/5) write (*,*)            \n       end program\n", "target": "def product_of_divisors(n):\n    assert(isinstance(n, int) and 0 < n)\n    ans = i = j = 1\n    while i*i <= n:\n        if 0 == n%i:\n            ans *= i\n            j = n//i\n            if j != i:\n                ans *= j\n        i += 1\n    return ans\n    \nif __name__ == \"__main__\":\n    print([product_of_divisors(n) for n in range(1,51)])\n"}
{"id": 411553, "name": "Playing cards", "source": "Translate Fortran to Python: MODULE Cards\n\nIMPLICIT NONE\n\n  TYPE Card\n    CHARACTER(5) :: value\n    CHARACTER(8) :: suit\n  END TYPE Card\n\n  TYPE(Card) :: deck(52), hand(52)\n  TYPE(Card) :: temp\n\n  CHARACTER(5) :: pip(13) = (/\"Two  \", \"Three\", \"Four \", \"Five \", \"Six  \", \"Seven\", \"Eight\", \"Nine \", \"Ten  \", &\n                              \"Jack \", \"Queen\", \"King \", \"Ace  \"/)\n  CHARACTER(8) :: suits(4) = (/\"Clubs   \", \"Diamonds\", \"Hearts  \", \"Spades  \"/)\n  INTEGER :: i, j, n, rand, dealt = 0\n  REAL :: x\n\nCONTAINS\n \n  SUBROUTINE Init_deck\n  \n    DO i = 1, 4\n      DO j = 1, 13\n        deck((i-1)*13+j) = Card(pip(j), suits(i))\n      END DO\n    END DO\n  END SUBROUTINE Init_deck\n \n  SUBROUTINE Shuffle_deck\n  \n    DO i = 52-dealt, 1, -1\n      CALL RANDOM_NUMBER(x)\n      rand = INT(x * i) + 1\n      temp = deck(rand)\n      deck(rand) = deck(i)\n      deck(i) = temp\n    END DO\n  END SUBROUTINE Shuffle_deck\n\n  SUBROUTINE Deal_hand(number)\n  \n    INTEGER :: number\n    DO i = 1, number\n      hand(i) = deck(dealt+1)\n      dealt = dealt + 1\n    END DO\n  END SUBROUTINE\n\n  SUBROUTINE Print_hand\n  \n    DO i = 1, dealt\n      WRITE (*, \"(3A)\") TRIM(deck(i)%value), \" of \", TRIM(deck(i)%suit)\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Print_hand\n \n  SUBROUTINE Print_deck\n  \n    DO i = dealt+1, 52\n      WRITE (*, \"(3A)\") TRIM(deck(i)%value), \" of \", TRIM(deck(i)%suit)\n    END DO\n    WRITE(*,*)\n  END SUBROUTINE Print_deck\n\nEND MODULE Cards\n", "target": "import random\n\nclass Card(object):\n    suits = (\"Clubs\",\"Hearts\",\"Spades\",\"Diamonds\")\n    pips = (\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"Jack\",\"Queen\",\"King\",\"Ace\")\n\n    def __init__(self, pip,suit):\n        self.pip=pip\n        self.suit=suit\n\n    def __str__(self):\n        return \"%s %s\"%(self.pip,self.suit)\n\nclass Deck(object):\n    def __init__(self):\n        self.deck = [Card(pip,suit) for suit in Card.suits for pip in Card.pips]\n\n    def __str__(self):\n        return \"[%s]\"%\", \".join( (str(card) for card in self.deck))\n\n    def shuffle(self):\n        random.shuffle(self.deck)\n\n    def deal(self):\n        self.shuffle()  \n        return self.deck.pop(0)\n"}
{"id": 411554, "name": "Two sum", "source": "Translate Fortran to Python: program twosum\n  implicit none\n\n  integer, parameter, dimension(5) :: list = (/ 0, 2, 11, 19, 90/)\n  integer, parameter :: target_val = 21\n  integer :: nelem\n  integer :: i, j\n  logical :: success = .false.\n\n  nelem = size(list)\n  outer:do i = 1,nelem\n     do j = i+1,nelem\n        success = list(i) + list(j) == target_val\n        if (success) exit outer\n     end do\n  end do outer\n\n  if (success) then\n     \n     print('(\"(\",2(i3.1,1X),\")\",3(A1,i3.1))'), i,j, \":\", list(i), \"+\", list(j), \"=\", target_val\n  else\n     print*, \"Failed\"\n  end if\n\nend program twosum\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 411555, "name": "Two sum", "source": "Translate Fortran to Python: program twosum\n  implicit none\n\n  integer, parameter, dimension(5) :: list = (/ 0, 2, 11, 19, 90/)\n  integer, parameter :: target_val = 21\n  integer :: nelem\n  integer :: i, j\n  logical :: success = .false.\n\n  nelem = size(list)\n  outer:do i = 1,nelem\n     do j = i+1,nelem\n        success = list(i) + list(j) == target_val\n        if (success) exit outer\n     end do\n  end do outer\n\n  if (success) then\n     \n     print('(\"(\",2(i3.1,1X),\")\",3(A1,i3.1))'), i,j, \":\", list(i), \"+\", list(j), \"=\", target_val\n  else\n     print*, \"Failed\"\n  end if\n\nend program twosum\n", "target": "def two_sum(arr, num):\n    i = 0\n    j = len(arr) - 1\n    while i < j:\n        if arr[i] + arr[j] == num:\n            return (i, j)\n        if arr[i] + arr[j] < num:\n            i += 1\n        else:\n            j -= 1\n    return None\n\n\nnumbers = [0, 2, 11, 19, 90]\nprint(two_sum(numbers, 21))\nprint(two_sum(numbers, 25))\n"}
{"id": 411556, "name": "Find the last Sunday of each month", "source": "Translate Fortran to Python:       D = DAYNUM(Y,M,D)    \n      DAYNUM(Y,M,D) = D    \n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 411557, "name": "Find the last Sunday of each month", "source": "Translate Fortran to Python:       D = DAYNUM(Y,M,D)    \n      DAYNUM(Y,M,D) = D    \n", "target": "import sys\nimport calendar\n\nyear = 2013\nif len(sys.argv) > 1:\n    try:\n        year = int(sys.argv[-1])\n    except ValueError:\n        pass\n\nfor month in range(1, 13):\n    last_sunday = max(week[-1] for week in calendar.monthcalendar(year, month))\n    print('{}-{}-{:2}'.format(year, calendar.month_abbr[month], last_sunday))\n"}
{"id": 411558, "name": "Comments", "source": "Translate Fortran to Python: C     This would be some kind of comment\nC     Usually one would avoid columns 2-6 even in a comment.\n", "target": "\n\nvar x = 0 \n\nvar y = 0 \n\n\nThere are also multi-line comments\nEverything inside of \n]\n\n\n\ndiscard \n"}
{"id": 411559, "name": "Sorting Algorithms_Circle Sort", "source": "Translate Fortran to Python: \nmodule circlesort\n\n\n\n\n\n\n  implicit none\n  logical, private :: csr\n  public :: circle_sort\n \ncontains\n \n  recursive logical function csr(a, left, right,n) result(swapped)\n    implicit none\n    integer, intent(in) :: left, right,n\n    integer, intent(inout) :: a(n)\n    integer :: lo, hi, mid\n    integer :: temp\n    logical :: lefthalf,righthalf\n\n    swapped = .FALSE.\n    if (right <= left) return\n    lo = left   \n    hi = right  \n\n    do while (lo < hi)\n\n       if (a(hi) < a(lo)) then\n          swapped = .TRUE.\n          temp = a(lo)\n          a(lo) = a(hi)\n          a(hi) = temp\n       endif\n       lo = lo + 1\n       hi = hi - 1\n    end do\n\n    if (lo == hi)then\n       if(a(hi+1) .lt. a(lo))then\n           swapped = .TRUE.\n           temp = a(hi+1)\n           a(hi+1) = a(lo)\n           a(lo) = temp\n       endif\n    endif\n    mid = (left + right) / 2 \n    lefthalf = csr(a, left, mid,n)\n    righthalf = csr(a, mid + 1, right,n)\n    swapped = swapped .or. lefthalf .or. righthalf\n  end function csr\n\n  subroutine circle_sort(a, n)\n    use iso_c_binding, only: c_ptr, c_loc\n    implicit none\n    integer, intent(in) :: n\n    integer, target,intent(inout) :: a(n)\n\n    do while ( csr(a, 1, n,n))\n\n\n\n    end do\n  end subroutine circle_sort\n \nend module circlesort\nprogram sort\n  use circlesort\n  implicit none\n  integer :: a(9)\n  data a/6,7,8,9,2,5,3,4,1/\n  call circle_sort(a, size(a))\n  print *, a\nend program sort\n", "target": "\n\n\n\n\ndef circle_sort_backend(A:list, L:int, R:int)->'sort A in place, returning the number of swaps':\n    \n    n = R-L\n    if n < 2:\n        return 0\n    swaps = 0\n    m = n//2\n    for i in range(m):\n        if A[R-(i+1)] < A[L+i]:\n            (A[R-(i+1)], A[L+i],) = (A[L+i], A[R-(i+1)],)\n            swaps += 1\n    if (n & 1) and (A[L+m] < A[L+m-1]):\n        (A[L+m-1], A[L+m],) = (A[L+m], A[L+m-1],)\n        swaps += 1\n    return swaps + circle_sort_backend(A, L, L+m) + circle_sort_backend(A, L+m, R)\n\ndef circle_sort(L:list)->'sort A in place, returning the number of swaps':\n    swaps = 0\n    s = 1\n    while s:\n        s = circle_sort_backend(L, 0, len(L))\n        swaps += s\n    return swaps\n\n\nif __name__ == '__main__':\n    from random import shuffle\n    for i in range(309):\n        L = list(range(i))\n        M = L[:]\n        shuffle(L)\n        N = L[:]\n        circle_sort(L)\n        if L != M:\n            print(len(L))\n            print(N)\n            print(L)\n"}
{"id": 411560, "name": "Circles of given radius through two points", "source": "Translate Fortran to Python: \n\nprogram circles\nimplicit none\ndouble precision :: P1(2), P2(2), R\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0,0.2345d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.0d0, 2.0d0/)\nP2 = (/0.0d0,0.0d0/)\nR = 1.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0, 0.2345d0/)\nR = 0.5d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 0.0d0\ncall print_centers(P1,P2,R)\nend program circles\n\nsubroutine print_centers(P1,P2,R)\nimplicit none\ndouble precision :: P1(2), P2(2), R, Center(2,2)\ninteger :: Res\ncall test_inputs(P1,P2,R,Res)\nwrite(*,*)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point1 \u00a0: ', P1(1), ' ', P1(2)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point2 \u00a0: ', P2(1), ' ', P2(2)\nwrite(*,'(A10,F7.4)') 'Radius \u00a0: ', R\nif(Res.eq.1) then\n  write(*,*) 'Same point because P1=P2 and r=0.'\nelseif(Res.eq.2) then\n  write(*,*) 'No circles can be drawn because r=0.'\nelseif(Res.eq.3) then\n  write(*,*) 'Infinite circles because P1=P2 for non-zero radius.'\nelseif(Res.eq.4) then\n  write(*,*) 'No circles with given r can be drawn because points are far apart.'\nelseif(Res.eq.0) then\n  call find_center(P1,P2,R,Center)\n  if(Center(1,1).eq.Center(2,1) .and. Center(1,2).eq.Center(2,2)) then\n    write(*,*) 'Points lie on the diameter. A single circle can be drawn.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center \u00a0: ', Center(1,1), ' ', Center(1,2)\n  else\n    write(*,*) 'Two distinct circles found.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center1\u00a0: ', Center(1,1), ' ', Center(1,2)\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center2\u00a0: ', Center(2,1), ' ', Center(2,2)\n  end if\nelseif(Res.lt.0) then\n  write(*,*) 'Incorrect value for r.'\nend if\nwrite(*,*)\nend subroutine print_centers\n\nsubroutine test_inputs(P1,P2,R,Res)\nimplicit none\ndouble precision :: P1(2), P2(2), R, dist\ninteger :: Res\nif(R.lt.0.0d0) then\n  Res = -1\n  return\nelseif(R.eq.0.0d0 .and. P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 1\n  return\nelseif(R.eq.0.0d0) then\n  Res = 2\n  return\nelseif(P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 3\n  return\nelse\n  dist = sqrt( (P1(1)-P2(1))**2 + (P1(2)-P2(2))**2 )\n  if(dist.gt.2.0d0*R) then\n    Res = 4\n    return\n  else\n    Res = 0\n    return\n  end if\nend if\nend subroutine test_inputs\n\nsubroutine find_center(P1,P2,R,Center)\nimplicit none\ndouble precision :: P1(2), P2(2), MP(2), Center(2,2), R, dm, dd\nMP = (P1 + P2)/2.0d0\ndm = sqrt((P1(1) - P2(1))**2 + (P1(2) - P2(2))**2)\ndd = sqrt(R**2 - (dm/2.0d0)**2)\nCenter(1,1) = MP(1) - dd*(P2(2) - P1(2))/dm\nCenter(1,2) = MP(2) + dd*(P2(1) - P1(1))/dm\n\nCenter(2,1) = MP(1) + dd*(P2(2) - P1(2))/dm\nCenter(2,2) = MP(2) - dd*(P2(1) - P1(1))/dm\nend subroutine find_center\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 411561, "name": "Circles of given radius through two points", "source": "Translate Fortran to Python: \n\nprogram circles\nimplicit none\ndouble precision :: P1(2), P2(2), R\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0,0.2345d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.0d0, 2.0d0/)\nP2 = (/0.0d0,0.0d0/)\nR = 1.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0, 0.2345d0/)\nR = 0.5d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 0.0d0\ncall print_centers(P1,P2,R)\nend program circles\n\nsubroutine print_centers(P1,P2,R)\nimplicit none\ndouble precision :: P1(2), P2(2), R, Center(2,2)\ninteger :: Res\ncall test_inputs(P1,P2,R,Res)\nwrite(*,*)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point1 \u00a0: ', P1(1), ' ', P1(2)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point2 \u00a0: ', P2(1), ' ', P2(2)\nwrite(*,'(A10,F7.4)') 'Radius \u00a0: ', R\nif(Res.eq.1) then\n  write(*,*) 'Same point because P1=P2 and r=0.'\nelseif(Res.eq.2) then\n  write(*,*) 'No circles can be drawn because r=0.'\nelseif(Res.eq.3) then\n  write(*,*) 'Infinite circles because P1=P2 for non-zero radius.'\nelseif(Res.eq.4) then\n  write(*,*) 'No circles with given r can be drawn because points are far apart.'\nelseif(Res.eq.0) then\n  call find_center(P1,P2,R,Center)\n  if(Center(1,1).eq.Center(2,1) .and. Center(1,2).eq.Center(2,2)) then\n    write(*,*) 'Points lie on the diameter. A single circle can be drawn.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center \u00a0: ', Center(1,1), ' ', Center(1,2)\n  else\n    write(*,*) 'Two distinct circles found.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center1\u00a0: ', Center(1,1), ' ', Center(1,2)\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center2\u00a0: ', Center(2,1), ' ', Center(2,2)\n  end if\nelseif(Res.lt.0) then\n  write(*,*) 'Incorrect value for r.'\nend if\nwrite(*,*)\nend subroutine print_centers\n\nsubroutine test_inputs(P1,P2,R,Res)\nimplicit none\ndouble precision :: P1(2), P2(2), R, dist\ninteger :: Res\nif(R.lt.0.0d0) then\n  Res = -1\n  return\nelseif(R.eq.0.0d0 .and. P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 1\n  return\nelseif(R.eq.0.0d0) then\n  Res = 2\n  return\nelseif(P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 3\n  return\nelse\n  dist = sqrt( (P1(1)-P2(1))**2 + (P1(2)-P2(2))**2 )\n  if(dist.gt.2.0d0*R) then\n    Res = 4\n    return\n  else\n    Res = 0\n    return\n  end if\nend if\nend subroutine test_inputs\n\nsubroutine find_center(P1,P2,R,Center)\nimplicit none\ndouble precision :: P1(2), P2(2), MP(2), Center(2,2), R, dm, dd\nMP = (P1 + P2)/2.0d0\ndm = sqrt((P1(1) - P2(1))**2 + (P1(2) - P2(2))**2)\ndd = sqrt(R**2 - (dm/2.0d0)**2)\nCenter(1,1) = MP(1) - dd*(P2(2) - P1(2))/dm\nCenter(1,2) = MP(2) + dd*(P2(1) - P1(1))/dm\n\nCenter(2,1) = MP(1) + dd*(P2(2) - P1(2))/dm\nCenter(2,2) = MP(2) - dd*(P2(1) - P1(1))/dm\nend subroutine find_center\n", "target": "from collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    \n    dx, dy = x2 - x1, y2 - y1\n    \n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    \n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    \n    d = sqrt(r**2-(q/2)**2)\n    \n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    \n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n"}
{"id": 411562, "name": "Update a configuration file", "source": "Translate Fortran to Python:       PROGRAM TEST\t\n      CHARACTER*28 FAVOURITEFRUIT\n      LOGICAL NEEDSPEELING\n      LOGICAL SEEDSREMOVED\n      INTEGER NUMBEROFBANANAS\n      NAMELIST /FRUIT/ FAVOURITEFRUIT,NEEDSPEELING,SEEDSREMOVED,\n     1 NUMBEROFBANANAS\n      INTEGER F\t\n      F = 10\t\n\nCreate an example file to show its format.\n      OPEN(F,FILE=\"Basket.txt\",STATUS=\"REPLACE\",ACTION=\"WRITE\",\t\n     1 DELIM=\"QUOTE\")\t\n      FAVOURITEFRUIT = \"Banana\"\n      NEEDSPEELING = .TRUE.\n      SEEDSREMOVED = .FALSE.\n      NUMBEROFBANANAS = 48\n      WRITE (F,FRUIT)\t\t\n      CLOSE (F)\t\t\t\nCan now read from the file.\n      OPEN(F,FILE=\"Basket.txt\",STATUS=\"OLD\",ACTION=\"READ\",\t\n     1 DELIM=\"QUOTE\")\n      READ (F,FRUIT)\t\t\t\n      WRITE (6,FRUIT)\n      END\n", "target": "\n\n\n\n\nimport re\nimport string\n\n\n\n\n\nDISABLED_PREFIX = ';'\n\n\n\n\n\nclass Option(object):\n    \n\n    \n    def __init__(self, name, value=None, disabled=False,\n                 disabled_prefix=DISABLED_PREFIX):\n        \n        self.name = str(name)\n        self.value = value\n        self.disabled = bool(disabled)\n        self.disabled_prefix = disabled_prefix\n\n    \n    def __str__(self):\n        \n        disabled = ('', '%s ' % self.disabled_prefix)[self.disabled]\n        value = (' %s' % self.value, '')[self.value is None]\n        return ''.join((disabled, self.name, value))\n\n    \n    def get(self):\n        \n        enabled = not bool(self.disabled)\n        if self.value is None:\n            value = enabled\n        else:\n            value = enabled and self.value\n        return value\n\n    \n\n\n\nclass Config(object):\n    \n    \n    reOPTION = r'^\\s*(?P<disabled>%s*)\\s*(?P<name>\\w+)(?:\\s+(?P<value>.+?))?\\s*$'\n\n    \n    def __init__(self, fname=None, disabled_prefix=DISABLED_PREFIX):\n        \n        self.disabled_prefix = disabled_prefix\n        self.contents = []          \n        self.options = {}           \n        self.creOPTION = re.compile(self.reOPTION % self.disabled_prefix)\n        if fname:\n            self.parse_file(fname)\n\n    \n    def __str__(self):\n        \n        return '\\n'.join(map(str, self.contents))\n\n    \n    def parse_file(self, fname):\n        \n        with open(fname) as f:\n            self.parse_lines(f)\n        return self\n\n    \n    def parse_lines(self, lines):\n        \n        for line in lines:\n            self.parse_line(line)\n        return self\n\n    \n    def parse_line(self, line):\n        \n        s = ''.join(c for c in line.strip() if c in string.printable) \n        moOPTION = self.creOPTION.match(s)\n        if moOPTION:\n            name = moOPTION.group('name').upper()\n            if not name in self.options:\n                self.add_option(name, moOPTION.group('value'),\n                                moOPTION.group('disabled'))\n        else:\n            if not s.startswith(self.disabled_prefix):\n                self.contents.append(line.rstrip())\n        return self\n\n    \n    def add_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = Option(name, value, disabled)\n        self.options[name] = opt\n        self.contents.append(opt)\n        return opt\n\n    \n    def set_option(self, name, value=None, disabled=False):\n        \n        name = name.upper()\n        opt = self.options.get(name)\n        if opt:\n            opt.value = value\n            opt.disabled = disabled\n        else:\n            opt = self.add_option(name, value, disabled)\n        return opt\n\n    \n    def enable_option(self, name, value=None):\n        \n        return self.set_option(name, value, False)\n\n    \n    def disable_option(self, name, value=None):\n        \n        return self.set_option(name, value, True)\n\n    \n    def get_option(self, name):\n        \n        opt = self.options.get(name.upper())\n        value = opt.get() if opt else None\n        return value\n\n\n\n\n\nif __name__ == '__main__':\n    import sys\n    cfg = Config(sys.argv[1] if len(sys.argv) > 1 else None)\n    cfg.disable_option('needspeeling')\n    cfg.enable_option('seedsremoved')\n    cfg.enable_option('numberofbananas', 1024)\n    cfg.enable_option('numberofstrawberries', 62000)\n    print cfg\n"}
{"id": 411563, "name": "I before E except after C", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram cia\n  implicit none\n  character (len=256) :: s\n  integer :: ie, ei, cie, cei\n  integer :: ios\n  data ie, ei, cie, cei/4*0/\n  do while (.true.)\n    read(5,*,iostat = ios)s\n    if (0 .ne. ios) then\n      exit\n    endif\n    call lower_case(s)\n    cie = cie + occurrences(s, 'cie')\n    cei = cei + occurrences(s, 'cei')\n    ie = ie + occurrences(s, 'ie')\n    ei = ei + occurrences(s, 'ei')\n  enddo\n  write(6,'(1x,4(a4,1x))') 'ie','ei','cie','cei'\n  write(6,'(1x,4(i4,1x))') ie,ei,cie,cei \n  write(6,'(1x,2(a,1x))') '        [^c]ie',plausibility(ie,ei)\n  write(6,'(1x,2(a,1x))') '           cei',plausibility(cei,cie)\n  write(6,'(1x,2(a,1x))') '([^c]ie)|(cei)',plausibility(ie+cei,ei+cie)\n\ncontains\n\n  subroutine lower_case(s)\n    character(len=*), intent(inout) :: s\n    integer :: i\n    do i=1, len_trim(s)\n      s(i:i) = achar(ior(iachar(s(i:i)),32))\n    enddo\n  end subroutine lower_case\n\n  integer function occurrences(a,b)\n    character(len=*), intent(in) :: a, b\n    integer :: i, j, n\n    n = 0\n    i = 0\n    j = index(a, b)\n    do while (0 .lt. j)\n      n = n+1\n      i = i+len(b)+j-1\n      j = index(a(i:), b)\n    end do\n    occurrences = n\n  end function occurrences\n\n  character*(32) function plausibility(da, nyet)\n    integer, intent(in) :: da, nyet\n    \n    if (nyet*2 .lt. da) then\n      plausibility = 'plausible'\n    else\n      plausibility = 'implausible'\n    endif\n  end function plausibility\nend program cia\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 411564, "name": "I before E except after C", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n\nprogram cia\n  implicit none\n  character (len=256) :: s\n  integer :: ie, ei, cie, cei\n  integer :: ios\n  data ie, ei, cie, cei/4*0/\n  do while (.true.)\n    read(5,*,iostat = ios)s\n    if (0 .ne. ios) then\n      exit\n    endif\n    call lower_case(s)\n    cie = cie + occurrences(s, 'cie')\n    cei = cei + occurrences(s, 'cei')\n    ie = ie + occurrences(s, 'ie')\n    ei = ei + occurrences(s, 'ei')\n  enddo\n  write(6,'(1x,4(a4,1x))') 'ie','ei','cie','cei'\n  write(6,'(1x,4(i4,1x))') ie,ei,cie,cei \n  write(6,'(1x,2(a,1x))') '        [^c]ie',plausibility(ie,ei)\n  write(6,'(1x,2(a,1x))') '           cei',plausibility(cei,cie)\n  write(6,'(1x,2(a,1x))') '([^c]ie)|(cei)',plausibility(ie+cei,ei+cie)\n\ncontains\n\n  subroutine lower_case(s)\n    character(len=*), intent(inout) :: s\n    integer :: i\n    do i=1, len_trim(s)\n      s(i:i) = achar(ior(iachar(s(i:i)),32))\n    enddo\n  end subroutine lower_case\n\n  integer function occurrences(a,b)\n    character(len=*), intent(in) :: a, b\n    integer :: i, j, n\n    n = 0\n    i = 0\n    j = index(a, b)\n    do while (0 .lt. j)\n      n = n+1\n      i = i+len(b)+j-1\n      j = index(a(i:), b)\n    end do\n    occurrences = n\n  end function occurrences\n\n  character*(32) function plausibility(da, nyet)\n    integer, intent(in) :: da, nyet\n    \n    if (nyet*2 .lt. da) then\n      plausibility = 'plausible'\n    else\n      plausibility = 'implausible'\n    endif\n  end function plausibility\nend program cia\n", "target": "import urllib.request\nimport re\n\nPLAUSIBILITY_RATIO = 2\n\ndef plausibility_check(comment, x, y):\n    print('\\n  Checking plausibility of: %s' % comment)\n    if x > PLAUSIBILITY_RATIO * y:\n        print('    PLAUSIBLE. As we have counts of %i vs %i, a ratio of %4.1f times'\n              % (x, y, x / y))\n    else:\n        if x > y:\n            print('    IMPLAUSIBLE. As although we have counts of %i vs %i, a ratio of %4.1f times does not make it plausible'\n                  % (x, y, x / y))\n        else:\n            print('    IMPLAUSIBLE, probably contra-indicated. As we have counts of %i vs %i, a ratio of %4.1f times'\n                  % (x, y, x / y))\n    return x > PLAUSIBILITY_RATIO * y\n\ndef simple_stats(url='http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'):\n    words = urllib.request.urlopen(url).read().decode().lower().split()\n    cie = len({word for word in words if 'cie' in word})\n    cei = len({word for word in words if 'cei' in word})\n    not_c_ie = len({word for word in words if re.search(r'(^ie|[^c]ie)', word)})\n    not_c_ei = len({word for word in words if re.search(r'(^ei|[^c]ei)', word)})\n    return cei, cie, not_c_ie, not_c_ei\n\ndef print_result(cei, cie, not_c_ie, not_c_ei):\n    if ( plausibility_check('I before E when not preceded by C', not_c_ie, not_c_ei)\n         & plausibility_check('E before I when preceded by C', cei, cie) ):\n        print('\\nOVERALL IT IS PLAUSIBLE!')\n    else:\n        print('\\nOVERALL IT IS IMPLAUSIBLE!')\n    print('(To be plausible, one count must exceed another by %i times)' % PLAUSIBILITY_RATIO)\n\nprint('Checking plausibility of \"I before E except after C\":')\nprint_result(*simple_stats())\n"}
{"id": 411565, "name": "Abelian sandpile model", "source": "Translate Fortran to Python: module abelian_sandpile_m\n\n  implicit none\n\n  private\n  public :: pile\n\n  type :: pile\n    \n    \n    \n\n    integer, allocatable :: grid(:,:)\n    integer              :: n(2)\n\n  contains\n    procedure :: init\n    procedure :: run\n\n    procedure, private :: process_node\n    procedure, private :: inside\n  end type\n\ncontains\n\n  logical function inside(this, i)\n    class(pile), intent(in) :: this\n    integer,     intent(in) :: i(2)\n\n    inside = ((i(1) > 0) .and. (i(1) <= this%n(1)) .and. (i(2) > 0) .and. (i(2) <= this%n(2)) )\n  end function\n\n  recursive subroutine process_node(this, i)\n    \n\n    class(pile), intent(inout) :: this\n    integer,     intent(in)    :: i(2)\n      \n\n    integer :: i0(2,2), j(2), d, k\n\n    \n    if (this%grid(i(1),i(2)) >= 4) then\n      \n      i0 = reshape([1,0,0,1], [2,2])\n\n      \n      this%grid(i(1),i(2)) = this%grid(i(1),i(2))-4\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) this%grid(j(1),j(2)) = this%grid(j(1),j(2)) + 1\n        end do\n      end do\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) call this%process_node(j)\n        end do\n      end do\n\n      \n      call this%process_node(i)\n    end if\n  end subroutine\n\n  subroutine run(this)\n    \n\n    class(pile), intent(inout) :: this\n\n    \n    call this%process_node(this%n/2)\n  end subroutine\n\n  subroutine init(this, nx, ny, h)\n    class(pile), intent(out) :: this\n    integer,     intent(in)  :: nx, ny\n      \n    integer,     intent(in)  :: h\n      \n\n    this%n = [nx, ny]\n    allocate (this%grid(nx,ny), source=0)\n    this%grid(nx/2, ny/2) = h\n  end subroutine\n\nend module\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"}
{"id": 411566, "name": "Abelian sandpile model", "source": "Translate Fortran to Python: module abelian_sandpile_m\n\n  implicit none\n\n  private\n  public :: pile\n\n  type :: pile\n    \n    \n    \n\n    integer, allocatable :: grid(:,:)\n    integer              :: n(2)\n\n  contains\n    procedure :: init\n    procedure :: run\n\n    procedure, private :: process_node\n    procedure, private :: inside\n  end type\n\ncontains\n\n  logical function inside(this, i)\n    class(pile), intent(in) :: this\n    integer,     intent(in) :: i(2)\n\n    inside = ((i(1) > 0) .and. (i(1) <= this%n(1)) .and. (i(2) > 0) .and. (i(2) <= this%n(2)) )\n  end function\n\n  recursive subroutine process_node(this, i)\n    \n\n    class(pile), intent(inout) :: this\n    integer,     intent(in)    :: i(2)\n      \n\n    integer :: i0(2,2), j(2), d, k\n\n    \n    if (this%grid(i(1),i(2)) >= 4) then\n      \n      i0 = reshape([1,0,0,1], [2,2])\n\n      \n      this%grid(i(1),i(2)) = this%grid(i(1),i(2))-4\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) this%grid(j(1),j(2)) = this%grid(j(1),j(2)) + 1\n        end do\n      end do\n\n      \n      do d = 1, 2               \n        do k = -1, 1, 2         \n          j = i+k*i0(:,d)       \n          if (this%inside(j)) call this%process_node(j)\n        end do\n      end do\n\n      \n      call this%process_node(i)\n    end if\n  end subroutine\n\n  subroutine run(this)\n    \n\n    class(pile), intent(inout) :: this\n\n    \n    call this%process_node(this%n/2)\n  end subroutine\n\n  subroutine init(this, nx, ny, h)\n    class(pile), intent(out) :: this\n    integer,     intent(in)  :: nx, ny\n      \n    integer,     intent(in)  :: h\n      \n\n    this%n = [nx, ny]\n    allocate (this%grid(nx,ny), source=0)\n    this%grid(nx/2, ny/2) = h\n  end subroutine\n\nend module\n", "target": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef iterate(grid):\n    changed = False\n    for ii, arr in enumerate(grid):\n        for jj, val in enumerate(arr):\n            if val > 3:\n                grid[ii, jj] -= 4\n                if ii > 0:\n                    grid[ii - 1, jj] += 1\n                if ii < len(grid)-1:\n                    grid[ii + 1, jj] += 1\n                if jj > 0:\n                    grid[ii, jj - 1] += 1\n                if jj < len(grid)-1:\n                    grid[ii, jj + 1] += 1\n                changed = True\n    return grid, changed\n\n\ndef simulate(grid):\n    while True:\n        grid, changed = iterate(grid)\n        if not changed:\n            return grid\n\n\nif __name__ == '__main__':\n    start_grid = np.zeros((10, 10))\n    start_grid[4:5, 4:5] = 64\n    final_grid = simulate(start_grid.copy())\n    plt.figure()\n    plt.gray()\n    plt.imshow(start_grid)\n    plt.figure()\n    plt.gray()\n    plt.imshow(final_grid)\n"}
{"id": 411567, "name": "Zhang-Suen thinning algorithm", "source": "Translate Fortran to Python: A(2:N - 1) = (A(1:N - 2) + A(2:N - 1) + A(3:N))/3\n", "target": "\n\n\nbeforeTxt = \n\n\nsmallrc01 = \n\nrc01 = \n\ndef intarray(binstring):\n    \n    return [[1 if ch == '1' else 0 for ch in line] \n            for line in binstring.strip().split()]\n\ndef chararray(intmatrix):\n    \n    return '\\n'.join(''.join(str(p) for p in row) for row in intmatrix)\n\ndef toTxt(intmatrix):\n    Return 8-neighbours of point p1 of picture, in order'''\n    i = image\n    x1, y1, x_1, y_1 = x+1, y-1, x-1, y+1\n    \n    return [i[y1][x],  i[y1][x1],   i[y][x1],  i[y_1][x1],  \n            i[y_1][x], i[y_1][x_1], i[y][x_1], i[y1][x_1]]  \n\ndef transitions(neighbours):\n    n = neighbours + neighbours[0:1]    \n    return sum((n1, n2) == (0, 1) for n1, n2 in zip(n, n[1:]))\n\ndef zhangSuen(image):\n    changing1 = changing2 = [(-1, -1)]\n    while changing1 or changing2:\n        \n        changing1 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P4 * P6 * P8 == 0 and   \n                    P2 * P4 * P6 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing1.append((x,y))\n        for x, y in changing1: image[y][x] = 0\n        \n        changing2 = []\n        for y in range(1, len(image) - 1):\n            for x in range(1, len(image[0]) - 1):\n                P2,P3,P4,P5,P6,P7,P8,P9 = n = neighbours(x, y, image)\n                if (image[y][x] == 1 and    \n                    P2 * P6 * P8 == 0 and   \n                    P2 * P4 * P8 == 0 and   \n                    transitions(n) == 1 and \n                    2 <= sum(n) <= 6):      \n                    changing2.append((x,y))\n        for x, y in changing2: image[y][x] = 0\n        \n        \n    return image\n            \n\nif __name__ == '__main__':\n    for picture in (beforeTxt, smallrc01, rc01):\n        image = intarray(picture)\n        print('\\nFrom:\\n%s' % toTxt(image))\n        after = zhangSuen(image)\n        print('\\nTo thinned:\\n%s' % toTxt(after))\n"}
{"id": 411568, "name": "Generate Chess960 starting position", "source": "Translate Fortran to Python: program chess960\n    implicit none\n    \n    integer, pointer  :: a,b,c,d,e,f,g,h\n    integer, target   :: p(8)\n    a => p(1)\n    b => p(2)\n    c => p(3)\n    d => p(4)\n    e => p(5)\n    f => p(6)\n    g => p(7)\n    h => p(8)\n\n    king: do a=2,7                                        \n        r1: do b=1,a-1                                    \n            r2: do c=a+1,8                                \n                b1: do d=1,7,2                            \n                    if (skip_pos(d,4)) cycle\n                    b2: do e=2,8,2                        \n                        if (skip_pos(e,5)) cycle\n                        queen: do f=1,8                   \n                            if (skip_pos(f,6)) cycle\n                            n1: do g=1,7                  \n                                if (skip_pos(g,7)) cycle\n                                n2: do h=g+1,8            \n                                    if (skip_pos(h,8)) cycle\n                                    if (sum(p) /= 36) stop 'Loop error'  \n                                    call write_position\n                                end do n2\n                            end do n1\n                        end do queen\n                    end do b2\n                end do b1\n            end do r2\n        end do r1\n    end do king\n    \ncontains\n\n    logical function skip_pos(i, n)\n        integer, intent(in) :: i, n\n        skip_pos = any(p(1:n-1) == i)\n    end function skip_pos\n\n    subroutine write_position\n        integer           :: i, j\n        character(len=15) :: position = ' '\n        character(len=1), parameter  :: names(8) = ['K','R','R','B','B','Q','N','N']\n        do i=1,8\n            j = 2*p(i)-1\n            position(j:j) = names(i)\n        end do\n        write(*,'(a)') position\n    end subroutine write_position\n    \nend program chess960\n", "target": ">>> from itertools import permutations\n>>> pieces = 'KQRrBbNN'\n>>> starts = {''.join(p).upper() for p in permutations(pieces)\n                     if p.index('B') % 2 != p.index('b') % 2 \t\t\n                     and ( p.index('r') < p.index('K') < p.index('R')\t\n                           or p.index('R') < p.index('K') < p.index('r') ) }\n>>> len(starts)\n960\n>>> starts.pop()\n'QNBRNKRB'\n>>>\n"}
{"id": 411569, "name": "Aliquot sequence classifications", "source": "Translate Fortran to Python:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\nc       INTEGER*4 I4LIMIT\nc       PARAMETER (I4LIMIT = 2147483647)\n       INTEGER*8 TOOBIG\t\t\n       PARAMETER (TOOBIG = 2**47)\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 10000)\t\n       INTEGER*8 KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\t\n        INTEGER*8 FUNCTION SUMF(N)\t\n         INTEGER*8 N\t\t\t\n         INTEGER*8 F,F2\t\t\n         INTEGER*8 S,INC,BOOST\t\t\n          IF (N.LE.LOTS) THEN\t\t\n            SUMF = KNOWNSUM(N)\t\t\t\n           ELSE\t\t\t\nCould use SUMF in place of S, but some compilers have been confused by such usage.\n            S = 1\t\t\t\n            F = 1\t\t\t\n            INC = 1\t\t\t\n            IF (MOD(N,2) .EQ. 1) INC = 2\n    1       F = F + INC\t\t\t\n            F2 = F*F\t\t\t\t\n            IF (F2 .LT. N) THEN\t\t\t\n              IF (MOD(N,F) .EQ. 0) THEN\t\t\n                BOOST = F + N/F\t\t\t\n                IF (S .GT. TOOBIG - BOOST) GO TO 666\t\n                S = S + BOOST\t\t\t\n              END IF\t\t\t\t\n              GO TO 1\t\t\t\t\n            END IF\t\t\t\n            IF (F2 .EQ. N) THEN\t\n              IF (S .GT. TOOBIG - F) GO TO 666\t\n              S = S + F\t\t\t\n            END IF\t\t\t\n            SUMF = S\t\t\t\n          END IF\t\t\t\n         RETURN\t\t\t\nCannot calculate the sum, because it exceeds the INTEGER*8 limit.\n  666     SUMF = -666\t\t\n        END FUNCTION SUMF\t\n         SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER*8 F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         SUBROUTINE CLASSIFY(N)\t\n         INTEGER*8 N\t\t\n         INTEGER ROPE\t\t\n         PARAMETER(ROPE = 16)\t\n         INTEGER*8 TRAIL(ROPE)\t\n         INTEGER*8 SF\t\t\n         INTEGER I,L\t\t\n         CHARACTER*28 THIS\t\n          L = 1\t\t\n          TRAIL(1) = N\t\t\n          SF = N\t\t\n   10     SF = SUMF(SF)\t\t\n          IF (SF .LT. 0) THEN\t\t\n            WRITE (THIS,11) L,\"overflows\n   11       FORMAT (\"After \",I0,\", \",A)\t\t\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (SF .EQ. 0) THEN\t\t\n            WRITE (THIS,11) L,\"terminates\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (ANY(TRAIL(1:L) .EQ. SF)) THEN\t\n            IF (L .EQ. 1) THEN\t\t\t\t\n              CALL REPORT(\"Perfect\n            ELSE IF (L .EQ. 2) THEN\t\t\t\n              CALL REPORT(\"Amicable:\")\t\t\t\n            ELSE\t\t\t\t\t\n              I = MINLOC(ABS(TRAIL(1:L) - SF),DIM=1)\t\n              IF (I .EQ. 1) THEN\t\t\n                WRITE (THIS,12) L\t\t\n   12           FORMAT (\"Sociable \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              ELSE IF (I .EQ. L) THEN\t\t\n                CALL REPORT(\"Aspiring:\")\t\n              ELSE\t\t\t\t\n                WRITE (THIS,13) L - I + 1,SF\t\n   13           FORMAT (\"Cyclic end \",I0,\", to \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              END IF\t\t\t\t\n            END IF\t\t\t\n          ELSE\t\t\t\t\n            IF (L .GE. ROPE) THEN\t\t\n              WRITE (THIS,11) L,\"non-terminating?\"\t\n              CALL REPORT(ADJUSTR(THIS))\t\t\n             ELSE\t\t\t\t\n              L = L + 1\t\t\t\n              TRAIL(L) = SF\t\t\t\n              GO TO 10\t\t\t\t\n            END IF\t\t\t\n          END IF\t\t\n         RETURN\t\t\n         CONTAINS\t\t\n          SUBROUTINE REPORT(WHAT)\t\n           CHARACTER*(*) WHAT\t\t\n            WRITE (6,1) WHAT,TRAIL(1:L)\n    1       FORMAT (A28,1X,12(I0:\",\"))\t\n          END SUBROUTINE REPORT\t\n        END SUBROUTINE CLASSIFY\t\n       END MODULE FACTORSTUFF\t\n       PROGRAM CLASSIFYTHEM\t\n       USE FACTORSTUFF\t\t\n       INTEGER*8 I,N\t\t\n       INTEGER*8 THIS(14)\t\n       DATA THIS/11,12,28,496,220,1184,12496,1264460,790,909,     \n     1  562,1064,1488,15355717786080/\t\n         CALL PREPARESUMF\t\t\n         DO I = 1,10\t\t\t\n          CALL CLASSIFY(I)\n        END DO\n         DO I = 1,SIZE(THIS)\t\t\n          CALL CLASSIFY(THIS(I))\n        END DO\n       END\t\t\t\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 411570, "name": "Aliquot sequence classifications", "source": "Translate Fortran to Python:       MODULE FACTORSTUFF\t\nConcocted by R.N.McLean, MMXV.\nc       INTEGER*4 I4LIMIT\nc       PARAMETER (I4LIMIT = 2147483647)\n       INTEGER*8 TOOBIG\t\t\n       PARAMETER (TOOBIG = 2**47)\t\n       INTEGER LOTS\t\t\t\n       PARAMETER (LOTS = 10000)\t\n       INTEGER*8 KNOWNSUM(LOTS)\t\n       CONTAINS\t\t\t\n        INTEGER*8 FUNCTION SUMF(N)\t\n         INTEGER*8 N\t\t\t\n         INTEGER*8 F,F2\t\t\n         INTEGER*8 S,INC,BOOST\t\t\n          IF (N.LE.LOTS) THEN\t\t\n            SUMF = KNOWNSUM(N)\t\t\t\n           ELSE\t\t\t\nCould use SUMF in place of S, but some compilers have been confused by such usage.\n            S = 1\t\t\t\n            F = 1\t\t\t\n            INC = 1\t\t\t\n            IF (MOD(N,2) .EQ. 1) INC = 2\n    1       F = F + INC\t\t\t\n            F2 = F*F\t\t\t\t\n            IF (F2 .LT. N) THEN\t\t\t\n              IF (MOD(N,F) .EQ. 0) THEN\t\t\n                BOOST = F + N/F\t\t\t\n                IF (S .GT. TOOBIG - BOOST) GO TO 666\t\n                S = S + BOOST\t\t\t\n              END IF\t\t\t\t\n              GO TO 1\t\t\t\t\n            END IF\t\t\t\n            IF (F2 .EQ. N) THEN\t\n              IF (S .GT. TOOBIG - F) GO TO 666\t\n              S = S + F\t\t\t\n            END IF\t\t\t\n            SUMF = S\t\t\t\n          END IF\t\t\t\n         RETURN\t\t\t\nCannot calculate the sum, because it exceeds the INTEGER*8 limit.\n  666     SUMF = -666\t\t\n        END FUNCTION SUMF\t\n         SUBROUTINE PREPARESUMF\t\nConvert the Sieve of Eratoshenes to have each slot contain the sum of the proper divisors of its slot number.\nChanges to instead count the number of factors, or prime factors, etc. would be simple enough.\n         INTEGER*8 F\t\t\n          KNOWNSUM(1) = 0\t\t\n          KNOWNSUM(2:LOTS) = 1\t\t\n          DO F = 2,LOTS/2\t\t\n            FORALL(I = F + F:LOTS:F) KNOWNSUM(I) = KNOWNSUM(I) + F\t\n          END DO\t\t\t\n        END SUBROUTINE PREPARESUMF\t\n         SUBROUTINE CLASSIFY(N)\t\n         INTEGER*8 N\t\t\n         INTEGER ROPE\t\t\n         PARAMETER(ROPE = 16)\t\n         INTEGER*8 TRAIL(ROPE)\t\n         INTEGER*8 SF\t\t\n         INTEGER I,L\t\t\n         CHARACTER*28 THIS\t\n          L = 1\t\t\n          TRAIL(1) = N\t\t\n          SF = N\t\t\n   10     SF = SUMF(SF)\t\t\n          IF (SF .LT. 0) THEN\t\t\n            WRITE (THIS,11) L,\"overflows\n   11       FORMAT (\"After \",I0,\", \",A)\t\t\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (SF .EQ. 0) THEN\t\t\n            WRITE (THIS,11) L,\"terminates\n            CALL REPORT(ADJUSTR(THIS))\t\t\n          ELSE IF (ANY(TRAIL(1:L) .EQ. SF)) THEN\t\n            IF (L .EQ. 1) THEN\t\t\t\t\n              CALL REPORT(\"Perfect\n            ELSE IF (L .EQ. 2) THEN\t\t\t\n              CALL REPORT(\"Amicable:\")\t\t\t\n            ELSE\t\t\t\t\t\n              I = MINLOC(ABS(TRAIL(1:L) - SF),DIM=1)\t\n              IF (I .EQ. 1) THEN\t\t\n                WRITE (THIS,12) L\t\t\n   12           FORMAT (\"Sociable \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              ELSE IF (I .EQ. L) THEN\t\t\n                CALL REPORT(\"Aspiring:\")\t\n              ELSE\t\t\t\t\n                WRITE (THIS,13) L - I + 1,SF\t\n   13           FORMAT (\"Cyclic end \",I0,\", to \",I0,\":\")\t\n                CALL REPORT(ADJUSTR(THIS))\t\n              END IF\t\t\t\t\n            END IF\t\t\t\n          ELSE\t\t\t\t\n            IF (L .GE. ROPE) THEN\t\t\n              WRITE (THIS,11) L,\"non-terminating?\"\t\n              CALL REPORT(ADJUSTR(THIS))\t\t\n             ELSE\t\t\t\t\n              L = L + 1\t\t\t\n              TRAIL(L) = SF\t\t\t\n              GO TO 10\t\t\t\t\n            END IF\t\t\t\n          END IF\t\t\n         RETURN\t\t\n         CONTAINS\t\t\n          SUBROUTINE REPORT(WHAT)\t\n           CHARACTER*(*) WHAT\t\t\n            WRITE (6,1) WHAT,TRAIL(1:L)\n    1       FORMAT (A28,1X,12(I0:\",\"))\t\n          END SUBROUTINE REPORT\t\n        END SUBROUTINE CLASSIFY\t\n       END MODULE FACTORSTUFF\t\n       PROGRAM CLASSIFYTHEM\t\n       USE FACTORSTUFF\t\t\n       INTEGER*8 I,N\t\t\n       INTEGER*8 THIS(14)\t\n       DATA THIS/11,12,28,496,220,1184,12496,1264460,790,909,     \n     1  562,1064,1488,15355717786080/\t\n         CALL PREPARESUMF\t\t\n         DO I = 1,10\t\t\t\n          CALL CLASSIFY(I)\n        END DO\n         DO I = 1,SIZE(THIS)\t\t\n          CALL CLASSIFY(THIS(I))\n        END DO\n       END\t\t\t\n", "target": "from proper_divisors import proper_divs\nfrom functools import lru_cache\n\n\n@lru_cache()\ndef pdsum(n): \n    return sum(proper_divs(n))\n    \n    \ndef aliquot(n, maxlen=16, maxterm=2**47):\n    if n == 0:\n        return 'terminating', [0]\n    s, slen, new = [n], 1, n\n    while slen <= maxlen and new < maxterm:\n        new = pdsum(s[-1])\n        if new in s:\n            if s[0] == new:\n                if slen == 1:\n                    return 'perfect', s\n                elif slen == 2:\n                    return 'amicable', s\n                else:\n                    return 'sociable of length %i' % slen, s\n            elif s[-1] == new:\n                return 'aspiring', s\n            else:\n                return 'cyclic back to %i' % new, s\n        elif new == 0:\n            return 'terminating', s + [0]\n        else:\n            s.append(new)\n            slen += 1\n    else:\n        return 'non-terminating', s\n                \nif __name__ == '__main__':\n    for n in range(1, 11): \n        print('%s: %r' % aliquot(n))\n    print()\n    for n in [11, 12, 28, 496, 220, 1184,  12496, 1264460, 790, 909, 562, 1064, 1488, 15355717786080]: \n        print('%s: %r' % aliquot(n))\n"}
{"id": 411571, "name": "Mersenne primes", "source": "Translate Fortran to Python: program mersenne\n    use iso_fortran_env, only: output_unit, INT64\n    implicit none\n\n    integer, parameter  :: l=INT64\n    integer(kind=l)     :: base\n    integer             :: pow\n\n    base = 2\n\n    do pow = 1, 32\n        if (is_prime(base-1)) then\n            write(output_unit,'(A2,x,I0,x,A3)') \"2^\", pow, \"- 1\"\n        end if\n        base = base * 2\n    end do\ncontains\n    pure function is_prime(n)\n        integer(kind=l), intent(in) :: n\n        logical                     :: is_prime\n        integer(kind=l)             :: test\n\n        is_prime = .false.\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        test = 5\n        do\n            if (test**2 >= n) then\n                is_prime = .true.\n                return\n            end if\n\n            if (modulo(n, test) == 0) return\n            test = test + 2\n            if (modulo(n, test) == 0) return\n            test = test + 4\n        end do\n    end function is_prime\nend program mersenne\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 411572, "name": "Mersenne primes", "source": "Translate Fortran to Python: program mersenne\n    use iso_fortran_env, only: output_unit, INT64\n    implicit none\n\n    integer, parameter  :: l=INT64\n    integer(kind=l)     :: base\n    integer             :: pow\n\n    base = 2\n\n    do pow = 1, 32\n        if (is_prime(base-1)) then\n            write(output_unit,'(A2,x,I0,x,A3)') \"2^\", pow, \"- 1\"\n        end if\n        base = base * 2\n    end do\ncontains\n    pure function is_prime(n)\n        integer(kind=l), intent(in) :: n\n        logical                     :: is_prime\n        integer(kind=l)             :: test\n\n        is_prime = .false.\n        if (n < 2) return\n        if (modulo(n, 2) == 0) then\n            is_prime = n==2\n            return\n        end if\n        if (modulo(n, 3) == 0) then\n            is_prime = n==3\n            return\n        end if\n\n        test = 5\n        do\n            if (test**2 >= n) then\n                is_prime = .true.\n                return\n            end if\n\n            if (modulo(n, test) == 0) return\n            test = test + 2\n            if (modulo(n, test) == 0) return\n            test = test + 4\n        end do\n    end function is_prime\nend program mersenne\n", "target": "import random\n\n\ndef MillerRabinPrimalityTest(number):\n    \n    if number == 2:\n        return True\n    elif number == 1 or number % 2 == 0:\n        return False\n    \n    \n    \n    \n    oddPartOfNumber = number - 1\n    \n    \n    timesTwoDividNumber = 0\n    \n    \n    while oddPartOfNumber % 2 == 0:\n        oddPartOfNumber = oddPartOfNumber / 2\n        timesTwoDividNumber = timesTwoDividNumber + 1 \n     \n    \n    for time in range(3):\n        \n        \n        while True:\n            \n            randomNumber = random.randint(2, number)-1\n            if randomNumber != 0 and randomNumber != 1:\n                break\n        \n        \n        randomNumberWithPower = pow(randomNumber, oddPartOfNumber, number)\n        \n        \n        if (randomNumberWithPower != 1) and (randomNumberWithPower != number - 1):\n            \n            iterationNumber = 1\n            \n            \n            while (iterationNumber <= timesTwoDividNumber - 1) and (randomNumberWithPower != number - 1):\n                \n                randomNumberWithPower = pow(randomNumberWithPower, 2, number)\n                \n                \n                iterationNumber = iterationNumber + 1\n            \n            if (randomNumberWithPower != (number - 1)):\n                return False\n            \n    \n    return True\n\n\nMAX = 20\np = 2\ncount = 0\nwhile True:\n    m = (2 << (p - 1)) - 1\n    if MillerRabinPrimalityTest(m):\n        print \"2 ^ {} - 1\".format(p)\n        count = count + 1\n        if count == MAX:\n            break\n    \n    while True:\n        p = p + 2 if (p > 2) else 3\n        if MillerRabinPrimalityTest(p):\n            break\nprint \"done\"\n"}
{"id": 411573, "name": "Taxicab numbers", "source": "Translate Fortran to Python: \n     PROGRAM POOKA\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  NVARS = 25\n\n\n\n      REAL  ::  f1\n      REAL  ::  f2\n      INTEGER  ::  hits\n      INTEGER  ::  s\n      INTEGER  ::  TAXICAB\n\n      hits = 0\n      s = 0\n      f1 = SECOND()\n      DO WHILE ( hits<NVARS )\n         s = s + 1\n         hits = hits + TAXICAB(s)\n      END DO\n      f2 = SECOND()\n      PRINT * , 'elapsed time = ' , f2 - f1 , 'For ' , NVARS , ' Variables'\n      STOP\n      END PROGRAM POOKA\n \n      FUNCTION TAXICAB(N)\n      IMPLICIT NONE\n\n\n\n      INTEGER  ::  N\n      INTEGER  ::  TAXICAB\n      INTENT (IN) N\n\n\n\n      INTEGER  ::  holder\n      INTEGER  ::  oldx\n      INTEGER  ::  oldy\n      INTEGER  ::  s\n      INTEGER  ::  x\n      INTEGER  ::  y\n      real*8,parameter :: xpon=(1.0D0/3.0D0)\n\n      x = 0\n      holder = 0\n      oldx = 0\n      oldy = 0\n      TAXICAB = 0\n      y = INT(N**xpon)\n      DO WHILE ( x<=y )\n         s = x**3 + y**3\n         IF( s<N )THEN\n            x = x + 1\n         ELSE IF( s>N )THEN\n            y = y - 1\n         ELSE\n            IF( holder==s )THEN \n               WRITE(6 , 34)s , '(' , x**3 , y**3 , ')' , '(' , oldx**3 , oldy**3 , ')'\n 34            FORMAT(1x , i12 , 10x , 1A1 , i12 , 2x , i12 , 1A1 , 10x , 1A1 , i12 , 2x ,&\n                    & i12 , 1A1)\n               TAXICAB = 1  \n            END IF\n            holder = s      \n            oldx = x       \n            oldy = y\n            x = x + 1       \n            y = y - 1\n         END IF\n      END DO\n      RETURN\n      END FUNCTION TAXICAB\n", "target": "from collections import defaultdict\nfrom itertools import product\nfrom pprint import pprint as pp\n\ncube2n = {x**3:x for x in range(1, 1201)}\nsum2cubes = defaultdict(set)\nfor c1, c2 in product(cube2n, cube2n):\n\tif c1 >= c2: sum2cubes[c1 + c2].add((cube2n[c1], cube2n[c2]))\n\t\ntaxied = sorted((k, v) for k,v in sum2cubes.items() if len(v) >= 2)\n\n\nfor t in enumerate(taxied[:25], 1):\n    pp(t)\nprint('...')    \nfor t in enumerate(taxied[2000-1:2000+6], 2000):\n    pp(t)\n"}
{"id": 411574, "name": "Left factorials", "source": "Translate Fortran to Python:       MODULE LAIROTCAF\t\n       CONTAINS\t\t\n        INTEGER*8 FUNCTION FACT(N)\t\n         INTEGER N\t\n         INTEGER I\t\n          FACT = 1\t\n          DO I = 2,N\t\t\n            FACT = FACT*I\t\t\n            IF (FACT.LE.0) STOP \"Factorial: Overflow\n          END DO\t\t\n        END FUNCTION FACT\t\n\n        INTEGER*8 FUNCTION LFACT(N)\t\n         INTEGER N\t\n         INTEGER K\t\n          LFACT = 0\t\n          DO K = 0,N - 1\t\n            LFACT = LFACT + FACT(K)\t\n            IF (LFACT.LE.0) STOP \"Lfact: Overflow\n          END DO\t\t\n        END FUNCTION LFACT\t\n      END MODULE LAIROTCAF\t\n\n      PROGRAM POKE\n      USE LAIROTCAF\n      INTEGER I\n\n      WRITE (6,*) \"Left factorials, from 0 to 10...\"\n      DO I = 0,10\n        WRITE (6,1) I,LFACT(I)\n    1   FORMAT (\"\n      END DO\n\n      WRITE (6,*) \"Left factorials, from 20 to 110 by tens...\"\n      DO I = 20,110,10\n        WRITE (6,1) I,LFACT(I)\n      END DO\n      END\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 411575, "name": "Left factorials", "source": "Translate Fortran to Python:       MODULE LAIROTCAF\t\n       CONTAINS\t\t\n        INTEGER*8 FUNCTION FACT(N)\t\n         INTEGER N\t\n         INTEGER I\t\n          FACT = 1\t\n          DO I = 2,N\t\t\n            FACT = FACT*I\t\t\n            IF (FACT.LE.0) STOP \"Factorial: Overflow\n          END DO\t\t\n        END FUNCTION FACT\t\n\n        INTEGER*8 FUNCTION LFACT(N)\t\n         INTEGER N\t\n         INTEGER K\t\n          LFACT = 0\t\n          DO K = 0,N - 1\t\n            LFACT = LFACT + FACT(K)\t\n            IF (LFACT.LE.0) STOP \"Lfact: Overflow\n          END DO\t\t\n        END FUNCTION LFACT\t\n      END MODULE LAIROTCAF\t\n\n      PROGRAM POKE\n      USE LAIROTCAF\n      INTEGER I\n\n      WRITE (6,*) \"Left factorials, from 0 to 10...\"\n      DO I = 0,10\n        WRITE (6,1) I,LFACT(I)\n    1   FORMAT (\"\n      END DO\n\n      WRITE (6,*) \"Left factorials, from 20 to 110 by tens...\"\n      DO I = 20,110,10\n        WRITE (6,1) I,LFACT(I)\n      END DO\n      END\n", "target": "from itertools import islice\n\ndef lfact():\n    yield 0\n    fact, summ, n = 1, 0, 1 \n    while 1:\n        fact, summ, n = fact*n, summ + fact, n + 1\n        yield summ\n\nprint('first 11:\\n  %r' % [lf for i, lf in zip(range(11), lfact())])\nprint('20 through 110 (inclusive) by tens:')\nfor lf in islice(lfact(), 20, 111, 10):\n    print(lf)\nprint('Digits in 1,000 through 10,000 (inclusive) by thousands:\\n  %r' \n      % [len(str(lf)) for lf in islice(lfact(), 1000, 10001, 1000)] )\n"}
{"id": 411576, "name": "Increasing gaps between consecutive Niven numbers", "source": "Translate Fortran to Python:        program nivengaps      \n       implicit none\n       integer*8 prev /1/, gap /0/, sum /0/\n       integer*8 nividx /0/, niven /1/\n       integer gapidx /1/\n       \n       character*13 idxfmt\n       character*14 nivfmt\n       write (*,*) 'Gap no  Gap   Niven index    Niven number '\n       write (*,*) '------  ---  -------------  --------------'\n       \n 10    call divsum(niven, sum)\n       if (mod(niven, sum) .EQ. 0) then\n          if (niven .GT. prev + gap) then\n             gap = niven - prev\n             call fmtint(nividx,13,idxfmt)\n             call fmtint(prev,14,nivfmt)\n             write (*,20) gapidx,gap,idxfmt,nivfmt\n             gapidx = gapidx + 1\n          end if\n          prev = niven\n          nividx = nividx + 1\n       end if          \n       niven = niven + 1\n       if (gapidx .LE. 32) go to 10\n       \n       stop\n 20    format (i7,'  ',i3,'  ',a13,'  ',a14)       \n       end program\n\nC      Sum of divisors of NN, given the sum of divisors of NN-1       \n       subroutine divsum(nn,sum)\n          implicit none\n          integer*8 n,nn,sum\n          n = nn          \n          sum = sum + 1\n 30       if (n.GT.0 .AND. mod(n,10).EQ.0) then\n             sum = sum - 9\n             n = n / 10\n             go to 30\n          end if\n       end subroutine  \n \n       integer*8 function mod(a,b)\n          implicit none\n          integer*8 a,b\n          mod = a - a/b * b\n       end function\n\nC      Format a positive integer with ',' as the thousands separator.\n       subroutine fmtint(num, len, str)\n          implicit none \n          integer*8 n, num\n          integer pos, len, th\n          character(*) str\n          n=num\n          pos=len\n          th=2\n 40       if (pos.GT.0) then\n             if (n.EQ.0) then\n                str(pos:pos) = ' '\n             else\n                str(pos:pos) = achar(mod(n,10) + iachar('0'))\n                if (th.EQ.0 .AND. n.GE.10 .AND. pos.GT.1) then\n                    th = 2\n                    pos = pos-1\n                    str(pos:pos) = ','\n                else\n                    th = th-1\n                end if\n            end if\n            pos = pos - 1\n            n = n/10\n            go to 40\n          end if    \n       end subroutine\n", "target": "\n\n\n\n\n\ndef digit_sum(n, sum):\n    sum += 1\n    while n > 0 and n % 10 == 0:\n        sum -= 9\n        n /= 10\n    \n    return sum\n    \nprevious = 1\ngap = 0\nsum = 0\nniven_index = 0\ngap_index = 1\n \nprint(\"Gap index  Gap    Niven index    Niven number\")\n\nniven = 1\n\nwhile gap_index <= 22:\n    sum = digit_sum(niven, sum)\n    if niven % sum == 0:\n        if niven > previous + gap:\n            gap = niven - previous;\n            print('{0:9d} {1:4d}  {2:13d}     {3:11d}'.format(gap_index, gap, niven_index, previous))\n            gap_index += 1\n        previous = niven\n        niven_index += 1\n    niven += 1\n"}
{"id": 411577, "name": "Old Russian measure of length", "source": "Translate Fortran to Python: PROGRAM RUS\n IMPLICIT NONE\n REAL, PARAMETER:: E_m = 1.\n REAL, PARAMETER:: E_mm = 1.E-3\n REAL, PARAMETER:: E_km = 1.E+3\n REAL, PARAMETER:: E_cm = 1.E-2\n REAL, PARAMETER:: E_arshin = 71.12 * E_cm\n REAL, PARAMETER:: E_fut = 3./7. * E_arshin\n REAL, PARAMETER:: E_piad = 1./4. * E_arshin\n REAL, PARAMETER:: E_vershok = 1./16. * E_arshin\n REAL, PARAMETER:: E_dyuim = 1./28. * E_arshin\n REAL, PARAMETER:: E_liniya = 1./280. * E_arshin\n REAL, PARAMETER:: E_tochka = 1./2800. * E_arshin\n REAL, PARAMETER:: E_ladon = 7.5 * E_cm\n REAL, PARAMETER:: E_lokot = 45 * E_cm\n REAL, PARAMETER:: E_sazhen = 3. * E_arshin\n REAL, PARAMETER:: E_versta = 1500. * E_arshin\n REAL, PARAMETER:: E_milya = 10500. * E_arshin\n INTEGER, PARAMETER:: N = 16\n CHARACTER(LEN=7), DIMENSION(N):: nam = (/&\n  &'m      ', 'mm     ', 'km     ', 'cm     ',&\n  &'arshin ', 'fut    ', 'piad   ', 'vershok',&\n  &'dyuim  ', 'liniya ', 'tochka ', 'ladon  ',&\n  &'lokot  ', 'sazhen ', 'versta ', 'milya  ' /)\n REAL, DIMENSION(N):: wert = (/ &\n  &1., E_mm, E_km, E_cm,&\n  &E_arshin, E_fut, E_piad, E_vershok,&\n  &E_dyuim, E_liniya, E_tochka, E_ladon,&\n  &E_lokot, E_sazhen, E_versta, E_milya /)\n CHARACTER(LEN=7):: RD_U\n REAL:: RD_V\n INTEGER:: I, J\n DO I=1, N\n  WRITE(*, '(A, \" \")', ADVANCE='NO')  nam(I)\n END DO\n WRITE (*, *)\n WRITE(*, '(A)', ADVANCE='NO') 'value unit -> '\n READ(*, *) RD_V, RD_U\n RD_U = ADJUSTL(RD_U)\n J = 1\n DO WHILE (NAM(J) .NE. RD_U)\n  J = J + 1\n  IF (J .GT. N) STOP \"Unit not known: \"//RD_U\n END DO\n RD_V = RD_V * wert(J)\n DO I=1, N\n  J = J + 1\n  IF (J .GT. N) J = 1\n  WRITE (*, '(F20.3, \" \", A)') RD_V / wert(J), nam(J)\n END DO\nEND PROGRAM RUS\n", "target": "from sys import argv\n \nunit2mult = {\"arshin\": 0.7112, \"centimeter\": 0.01,     \"diuym\":   0.0254,\n             \"fut\":    0.3048, \"kilometer\":  1000.0,   \"liniya\":  0.00254,\n             \"meter\":  1.0,    \"milia\":      7467.6,   \"piad\":    0.1778,\n             \"sazhen\": 2.1336, \"tochka\":     0.000254, \"vershok\": 0.04445,\n             \"versta\": 1066.8}\n \nif __name__ == '__main__':\n    assert len(argv) == 3, 'ERROR. Need two arguments - number then units'\n    try:\n        value = float(argv[1])\n    except:\n        print('ERROR. First argument must be a (float) number')\n        raise\n    unit = argv[2]\n    assert unit in unit2mult, ( 'ERROR. Only know the following units: ' \n                                + ' '.join(unit2mult.keys()) )\n\n    print(\"%g %s to:\" % (value, unit))\n    for unt, mlt in sorted(unit2mult.items()):\n        print('  %10s: %g' % (unt, value * unit2mult[unit] / mlt))\n"}
{"id": 411578, "name": "Test integerness", "source": "Translate Fortran to Python:       MODULE ZERMELO\t\n       CONTAINS\n        LOGICAL FUNCTION ISINTEGRAL(X)\t\n         REAL*8 X\t\n         INTEGER*8 N\t\n          IF (ISNAN(X)) THEN\t\n            ISINTEGRAL = .FALSE.\t\n          ELSE\t\t\t\n            N = KIDINT(X)\t\t\n            ISINTEGRAL = N .EQ. X\t\n          END IF\t\t\n        END FUNCTION ISINTEGRAL\t\n\n        LOGICAL FUNCTION ISINTEGRALZ(Z)\t\n         DOUBLE COMPLEX Z\t\n          ISINTEGRALZ = ISINTEGRAL(DBLE(Z)) .AND. ISINTEGRAL(DIMAG(Z))\t\n        END FUNCTION ISINTEGRALZ\n      END MODULE ZERMELO\t\n\n      PROGRAM TEST\n      USE ZERMELO\n      DOUBLE COMPLEX Z\n\n      WRITE (6,*) \"See if some numbers are integral...\"\n      WRITE (6,*) ISINTEGRAL(666D0),666D0\n      Z = DCMPLX(-3D0,4*ATAN(1D0))\n      WRITE (6,*) ISINTEGRALZ(Z),Z\n      END\n", "target": ">>> def isint(f): \n    return complex(f).imag == 0 and complex(f).real.is_integer()\n\n>>> [isint(f) for f in (1.0, 2, (3.0+0.0j), 4.1, (3+4j), (5.6+0j))]\n[True, True, True, False, False, False]\n\n>>> \n...\n>>> isint(25.000000)\nTrue\n>>> isint(24.999999)\nFalse\n>>> isint(25.000100)\nFalse\n>>> isint(-2.1e120)\nTrue\n>>> isint(-5e-2)\nFalse\n>>> isint(float('nan'))\nFalse\n>>> isint(float('inf'))\nFalse\n>>> isint(5.0+0.0j)\nTrue\n>>> isint(5-5j)\nFalse\n"}
{"id": 411579, "name": "Linux CPU utilization", "source": "Translate Fortran to Python: Program CPUusage\n    implicit none\n    integer :: ios, i\n    integer :: oldidle, oldsum, sumtimes = 0\n    real :: percent = 0.\n    character(len = 4) lineID \n    integer, dimension(9) :: times = 0\n\n    write(*, *) 'CPU Usage'\n    write(*, *) 'Press Ctrl<C> to end'\n    do while (.true.)\n        open(unit = 7, file = '/proc/stat', status = 'old', action = 'read', iostat = ios)\n        if (ios /= 0) then\n            print *, 'Error opening /proc/stat'\n            stop\n        else\n            read(unit = 7, fmt = *, iostat = ios) lineID, (times(i), i = 1, 9)\n            close(7)\n            if (lineID /= 'cpu ') then\n                print *, 'Error reading /proc/stat'\n                stop\n            end if\n            sumtimes = sum(times)\n            percent = (1. - real((times(4) - oldidle)) / real((sumtimes - oldsum))) * 100.\n            write(*, fmt = '(F6.2,A2)') percent, '%'\n            oldidle = times(4)\n            oldsum = sumtimes\n            call sleep(1)\n        end if\n    end do\nend program CPUusage\n", "target": "from __future__ import print_function\nfrom time import sleep\n\n\nlast_idle = last_total = 0\nwhile True:\n    with open('/proc/stat') as f:\n        fields = [float(column) for column in f.readline().strip().split()[1:]]\n    idle, total = fields[3], sum(fields)\n    idle_delta, total_delta = idle - last_idle, total - last_total\n    last_idle, last_total = idle, total\n    utilisation = 100.0 * (1.0 - idle_delta / total_delta)\n    print('%5.1f%%' % utilisation, end='\\r')\n    sleep(5)\n"}
{"id": 411580, "name": "Find largest left truncatable prime in a given base", "source": "Translate Fortran to Python:       USE PRIMEBAG\t\nCalculates the largest \"left-truncatable\" digit sequence that is a prime number, in various bases.\n      INTEGER LBASE,MANY,ENUFF\t\n      PARAMETER (LBASE = 13, MANY = 66666, ENUFF = 66)\n      INTEGER NS,START(LBASE)\t\n      INTEGER NH,LH\t\t\n      INTEGER N,HORDEN(MANY)\t\t\n      INTEGER*1 HORDED(ENUFF,MANY)\t\n      INTEGER B,D,DB\t\n      INTEGER L\t\t\n      INTEGER P\t\t\n      INTEGER I\t\t\n\n      MSG = 6\t\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n      NS = 0\t\n      P = 1\t\n    1 P = NEXTPRIME(P)\t\n      IF (P.LE.LBASE) THEN\t\n        NS = NS + 1\t\t\n        START(NS) = P\t\t\n        GO TO 1\t\t\t\n      END IF\t\t\n      WRITE (MSG,2) LBASE,NS,START(1:NS)\t\n    2 FORMAT (\"Working in bases 3 to \",I0,\" there are \",I0,\t\n     * \" single-digit primes: \",666(I0:\", \"))\t\n      WRITE (MSG,3)\t\t\n    3 FORMAT (/\"Base Digits Count Max. Value = (in base)\")\n\n   10 DO B = 3,LBASE\t\n        NH = 0\t\t\t\n        DO I = 1,NS\t\t\n          IF (START(I).GE.B) EXIT\t\n          NH = NH + 1\t\t\t\n          HORDEN(NH) = START(I)\t\t\n          HORDED(1,NH) = START(I)\t\n        END DO\t\t\t\n        L = 0\t\n        DB = 1\t\n\n   20   L = L + 1\t\n        IF (L.GE.ENUFF) STOP \"Too many digits\n        DB = DB*B\t\n        IF (DB.LE.0) GO TO 29\t\n        LH = NH\t\t\n        DO I = 1,LH\t\n          N = HORDEN(I)\t\n          DO D = 1,B - 1\t\n            P = D*DB + N\t\t\n            IF (P.LE.0) GO TO 29\t\n            IF (ISPRIME(P)) THEN\t\n              IF (NH.GE.MANY) STOP \"Too many sequences\n              NH = NH + 1\t\t\t\n              HORDEN(NH) = P\t\t\t\n              HORDED(1:L,NH) = HORDED(1:L,I)\t\n              HORDED(L + 1,NH) = D\t\t\n            END IF\t\t\t\n          END DO\t\t\n        END DO\t\n\n        N = NH - LH\t\t\n        IF (N.GT.0) THEN\t\n          DO I = 1,MIN(LH,N)\t\t\n            HORDEN(I) = HORDEN(NH)\t\t\n            HORDED(1:L + 1,I) = HORDED(1:L + 1,NH)\t\n            NH = NH - 1\t\t\t\t\n          END DO\t\t\t\n          NH = N\t\t\t\n          LH = NH\t\t\t\n          GO TO 20\t\t\t\n        END IF\t\t\t\n        GO TO 30\t\t\n   29   WRITE (MSG,28) B,L,NH,DB,P\t\n   28   FORMAT (I4,I7,I6,28X,\"Integer overflow\n        CYCLE\t\t\t\n\n   30   I = MAXLOC(HORDEN(1:NH),DIM = 1)\t\n        WRITE (MSG,31) B,L,NH,HORDEN(I),HORDED(L:1:-1,I)\t\n   31   FORMAT (I4,I7,I6,I11,\" = \"666(I0:\".\"))\t\n\n      END DO\t\t\n      END\t\n", "target": "import random\n\ndef is_probable_prime(n,k):\n    \n    if n==0 or n==1:\n        return False\n    if n==2:\n        return True\n    if n % 2 == 0:\n        return False\n    s = 0\n    d = n-1\n\n    while True:\n        quotient, remainder = divmod(d, 2)\n        if remainder == 1:\n            break\n        s += 1\n        d = quotient\n\n    def try_composite(a):\n        if pow(a, d, n) == 1:\n            return False\n        for i in range(s):\n            if pow(a, 2**i * d, n) == n-1:\n                return False\n        return True \n \n    for i in range(k):\n        a = random.randrange(2, n)\n        if try_composite(a):\n            return False\n \n    return True \n    \n    \ndef largest_left_truncatable_prime(base):    \n    radix = 0\n    candidates = [0]\n    while True:\n        new_candidates=[]\n        multiplier = base**radix\n        for i in range(1,base):\n            new_candidates += [x+i*multiplier for x in candidates if is_probable_prime(x+i*multiplier,30)]\n        if len(new_candidates)==0:\n            return max(candidates)\n        candidates = new_candidates\n        radix += 1\n\nfor b in range(3,24):\n    print(\"%d:%d\\n\" % (b,largest_left_truncatable_prime(b)))\n"}
{"id": 411581, "name": "24 game_Solve", "source": "Translate Fortran to Python: program solve_24\n  use helpers\n  implicit none\n  real                 :: vector(4), reals(4), p, q, r, s\n  integer              :: numbers(4), n, i, j, k, a, b, c, d\n  character, parameter :: ops(4) = (/ '+', '-', '*', '/' /)\n  logical              :: last\n  real,parameter       :: eps = epsilon(1.0)\n\n  do n=1,12\n    call random_number(vector)\n    reals   = 9 * vector + 1\n    numbers = int(reals)\n    call Insertion_Sort(numbers)\n    \n    permutations: do\n      a = numbers(1); b = numbers(2); c = numbers(3); d = numbers(4)\n      reals = real(numbers)\n      p = reals(1);   q = reals(2);   r = reals(3);   s = reals(4)\n      \n      do i=1,4\n        do j=1,4\n          do k=1,4\n            if      ( abs(op(op(op(p,i,q),j,r),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '((',a,ops(i),b,')',ops(j),c,')',ops(k),d\n              exit permutations\n            else if ( abs(op(op(p,i,op(q,j,r)),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),'(',b,ops(j),c,'))',ops(k),d\n              exit permutations\n            else if ( abs(op(p,i,op(op(q,j,r),k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'((',b,ops(j),c,')',ops(k),d,')'\n              exit permutations\n            else if ( abs(op(p,i,op(q,j,op(r,k,s)))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'(',b,ops(j),'(',c,ops(k),d,'))'\n              exit permutations\n            else if ( abs(op(op(p,i,q),j,op(r,k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),b,')',ops(j),'(',c,ops(k),d,')'\n              exit permutations\n            end if\n          end do\n        end do\n      end do\n      call nextpermutation(numbers,last)  \n      if ( last ) then\n        write (*,*) numbers, '\u00a0: no solution.'\n        exit permutations\n      end if\n    end do permutations\n\n  end do\n\ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in)    :: x,y\n    select case ( ops(c) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n\nend program solve_24\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 411582, "name": "24 game_Solve", "source": "Translate Fortran to Python: program solve_24\n  use helpers\n  implicit none\n  real                 :: vector(4), reals(4), p, q, r, s\n  integer              :: numbers(4), n, i, j, k, a, b, c, d\n  character, parameter :: ops(4) = (/ '+', '-', '*', '/' /)\n  logical              :: last\n  real,parameter       :: eps = epsilon(1.0)\n\n  do n=1,12\n    call random_number(vector)\n    reals   = 9 * vector + 1\n    numbers = int(reals)\n    call Insertion_Sort(numbers)\n    \n    permutations: do\n      a = numbers(1); b = numbers(2); c = numbers(3); d = numbers(4)\n      reals = real(numbers)\n      p = reals(1);   q = reals(2);   r = reals(3);   s = reals(4)\n      \n      do i=1,4\n        do j=1,4\n          do k=1,4\n            if      ( abs(op(op(op(p,i,q),j,r),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '((',a,ops(i),b,')',ops(j),c,')',ops(k),d\n              exit permutations\n            else if ( abs(op(op(p,i,op(q,j,r)),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),'(',b,ops(j),c,'))',ops(k),d\n              exit permutations\n            else if ( abs(op(p,i,op(op(q,j,r),k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'((',b,ops(j),c,')',ops(k),d,')'\n              exit permutations\n            else if ( abs(op(p,i,op(q,j,op(r,k,s)))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'(',b,ops(j),'(',c,ops(k),d,'))'\n              exit permutations\n            else if ( abs(op(op(p,i,q),j,op(r,k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),b,')',ops(j),'(',c,ops(k),d,')'\n              exit permutations\n            end if\n          end do\n        end do\n      end do\n      call nextpermutation(numbers,last)  \n      if ( last ) then\n        write (*,*) numbers, '\u00a0: no solution.'\n        exit permutations\n      end if\n    end do permutations\n\n  end do\n\ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in)    :: x,y\n    select case ( ops(c) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n\nend program solve_24\n", "target": "\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \n    digilen = len(digits)\n    \n    exprlen = 2 * digilen - 1\n    \n    digiperm = sorted(set(permutations(digits)))\n    \n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    \n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) \n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] \n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                \n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n"}
{"id": 411583, "name": "Doubly-linked list_Definition", "source": "Translate Fortran to Python: module dlist\n  implicit none\n  type node\n     type(node), pointer :: next => null()\n     type(node), pointer :: prev => null()\n     integer :: data\n  end type node\n\n  type dll\n     type(node), pointer :: head => null()\n     type(node), pointer :: tail => null()\n     integer :: num_nodes = 0\n  end type dll\n\n  public  :: node, dll, append, prepend, insert, dump, reverse_dump, tidy\n  private :: init\n\ncontains\n  \n  elemental type(dll) function new_dll()\n    new_dll = dll(null(),null(),0)\n    return\n  end function new_dll\n\n  \n  elemental subroutine append(dl2, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: value\n\n    type(node), pointer :: np\n\n    \n    if (dl2%num_nodes == 0) then\n       call init(dl2, value)\n       return\n    end if\n\n    \n    dl2%num_nodes = dl2%num_nodes + 1\n    np => dl2%tail\n    allocate(dl2%tail)\n    dl2%tail%data = value\n    dl2%tail%prev => np\n    dl2%tail%prev%next => dl2%tail\n  end subroutine append\n\n  \n  elemental subroutine prepend(dl2, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: value\n\n    type(node), pointer :: np\n\n    if (dl2%num_nodes == 0) then\n       call init(dl2, value)\n       return\n    end if\n\n    dl2%num_nodes = dl2%num_nodes + 1\n    np => dl2%head\n    allocate(dl2%head)\n    dl2%head%data = value\n    dl2%head%next => np\n    dl2%head%next%prev => dl2%head\n  end subroutine prepend\n\n  \n  elemental subroutine insert(dl2, index, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: index\n    integer, intent(in)      :: value\n\n    type(node), pointer :: element\n    type(node), pointer :: np1, np2\n    integer             :: i\n\n    if (dl2%num_nodes == 0) then\n       call init(dl2, value)\n       return\n    end if\n\n    \n    if (index > dl2%num_nodes) then\n       call append(dl2, value)\n       return\n    end if\n\n    \n    if (index <= 1) then\n       call prepend(dl2, value)\n       return\n    end if\n\n    \n    np1 => dl2%head\n    do i=1, index-2\n       np1 => np1%next\n    end do\n    np2 => np1%next\n\n    \n    allocate(element)\n    element%data = value\n\n    \n    element%prev => np1\n    element%next => np2\n    np1%next => element\n    np2%prev => element\n    dl2%num_nodes = dl2%num_nodes + 1\n  end subroutine insert\n\n  subroutine dump(dl2)\n    type(dll), intent(in) :: dl2\n    type(node), pointer :: current\n    integer :: i\n\n    write(*,fmt='(a,i0,a)',advance='no') 'Doubly-linked list has ',dl2%num_nodes,' element - fwd = '\n    current => dl2%head\n    i = 1\n    write(*,fmt='(i0,a)',advance='no') current%data,', '\n    do\n       current => current%next\n       if (.not. associated(current)) then\n          exit\n       end if\n       i = i + 1\n       if (i == dl2%num_nodes) then\n          write(*,'(i0)') current%data\n       else\n          write(*,fmt='(i0,a)',advance='no') current%data,', '\n       end if\n    end do\n  end subroutine dump\n\n  subroutine reverse_dump(dl2)\n    type(dll), intent(in) :: dl2\n    type(node), pointer :: current\n    integer :: i\n\n    write(*,fmt='(a,i0,a)',advance='no') 'Doubly-linked list has ',dl2%num_nodes,' element - bwd = '\n    current => dl2%tail\n    write(*,fmt='(i0,a)',advance='no') current%data,', '\n    i = 1\n    do\n       current => current%prev\n       if (.not. associated(current)) then\n          exit\n       end if\n       i = i + 1\n       if (i == dl2%num_nodes) then\n          write(*,'(i0)') current%data\n       else\n          write(*,fmt='(i0,a)',advance='no') current%data,', '\n       end if\n    end do\n  end subroutine reverse_dump\n\n  \n  elemental subroutine tidy(dl2)\n    type(dll), intent(inout) :: dl2\n    type(node), pointer :: current, last\n\n    current => dl2%head\n    do\n       last => current\n       current => current%next\n       if (associated(last)) then\n          deallocate(last)\n       end if\n       if (associated(current, dl2%tail)) then\n          deallocate(current)\n          exit\n       end if\n    end do\n  end subroutine tidy\n\n  elemental subroutine init(dl2, value)\n    type(dll), intent(inout) :: dl2\n    integer, intent(in)      :: value\n    allocate(dl2%head)\n    dl2%tail => dl2%head\n    dl2%tail%data = value\n    dl2%num_nodes = 1\n    return\n  end subroutine init\n\nend module dlist\n\nprogram dl\n  use dlist\n  implicit none\n\n  type(dll) :: mydll\n\n  mydll = new_dll()\n  call append(mydll, 5)\n  call append(mydll, 7)\n  call prepend(mydll, 3)\n  call prepend(mydll, 1)\n  call insert(mydll, 3, 4)\n  call dump(mydll)\n\n  call reverse_dump(mydll)\n\n  call tidy(mydll)\nend program dl\n", "target": "from collections import deque\n\nsome_list = deque([\"a\", \"b\", \"c\"])\nprint(some_list)\n\nsome_list.appendleft(\"Z\")\nprint(some_list)\n\nfor value in reversed(some_list):\n    print(value)\n"}
{"id": 411584, "name": "Special variables", "source": "Translate Fortran to Python:            INQUIRE(FILE = FILENAME(1:L),EXIST = EXIST,\t\n     1      ERR = 666,IOSTAT = IOSTAT) \t\t\n           IF (EXIST) THEN\t\n           ...etc.\n", "target": "names = sorted((set(globals().keys()) | set(__builtins__.__dict__.keys())) - set('_ names i'.split()))\nprint( '\\n'.join(' '.join(names[i:i+8]) for i in range(0, len(names), 8)) )\n"}
{"id": 411585, "name": "Sequence of primorial primes", "source": "Translate Fortran to Python:       PROGRAM PRIMORIALP\t\n      USE PRIMEBAG\t\t\n      USE BIGNUMBERS\t\t\n      TYPE(BIGNUM) B\t\t\n      INTEGER MAXF\t\t\n      PARAMETER (MAXF = 18000000)\t\n      INTEGER I\t\t\t\n      INTEGER FU,FD\t\t\n      INTEGER NHIT,HIT(666)\t\n      CHARACTER*4 WOT\t\t\n      CHARACTER*66 ALINE\t\n      REAL T0,T1\t\t\n      MSG = 6\t\n      WRITE (MSG,1) BIGLIMIT,BIGBASE,HUGE(I)\t\n    1 FORMAT ('Calculates primorial \"primes\"',/,\n     1 \"A primorial prime is a value N such that\",/,\n     2 \"    Primorial(N) - 1 is prime, OR\",/,\n     3 \"    Primorial(N) + 1 is prime, or both.\",/,\n     4 \"and Primorial(N) is the product of the first N prime numbers.\",/\n     5 \"Working with up to \",I0,\" digits in base \",I0,\".\"/\n     6 \"The integer limit is \",I0,/)\n\nc      CALL PREPARE PRIMES\t\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n      WRITE (MSG,2)\n    2 FORMAT (\"Primorial#\",3X,\"Approx.\",8X,\" -1 Factor +1 Factor Hit\")\n\nCommence prime mashing.\n  100 NHIT = 0\t\t\n      B.LAST = 1\t\n      B.DIGIT(1) = 1\t\n      CALL CPU_TIME(T0)\t\n      DO I = 1,30\t\n        CALL BIGMULTN(B,PRIME(I))\t\nc        WRITE (MSG,101) I,PRIME(I),I,B.DIGIT(B.LAST:1:-1)\t\n  101   FORMAT (\"Prime(\",I0,\") = \",I0,\", Primorial(\",I0,\") = \",\t\n     1   I0,9I<BIGORDER>.<BIGORDER>,/,(10I<BIGORDER>.<BIGORDER>))\t\n        FU = -1\t\t\n        FD = -1\t\t\n        CALL BIGADDN(B,+1)\t\n        FU = BIGFACTOR(B,MAXF)\t\n        CALL BIGADDN(B,-2)\t\n        IF (FU.NE.1) FD = BIGFACTOR(B,MAXF)\t\n        IF (FU.EQ.1 .OR. FD.EQ.1) THEN\t\n          WOT = \"Yes\n          NHIT = NHIT + 1\t\t\t\n          HIT(NHIT) = I\t\t\t\t\n        ELSE IF (FU.GT.1 .AND. FD.GT.1) THEN\t\n          WOT = \"No.\"\t\t\t\t\n        ELSE\t\t\t\t\n          WOT = \"?\"\t\t\t\t\n        END IF\t\t\t\t\n        CALL BIGADDN(B,1)\t\t\n        WRITE (ALINE,102) I,BIGVALUE(B),FD,FU,WOT\t\n  102   FORMAT (I10,1PE18.10,I10,I10,1X,A)\t\n        IF (FD.EQ.-1) ALINE(37:38) = \"\"\t\t\n        IF (FD.EQ. 0) ALINE(38:38) = \"?\"\t\n        IF (FU.EQ. 0) ALINE(48:48) = \"?\"\t\n        WRITE (MSG,\"(A)\") ALINE\t\t\n      END DO\t\t\n      CALL CPU_TIME(T1)\t\n\nCast forth some pearls.\n      WRITE (MSG,201) HIT(1:NHIT)\t\n  201 FORMAT (/,\"Hit list: \",I0,666(\",\",I0:))\t\n      WRITE (MSG,*) \"CPU time:\",T1 - T0\t\n      END\t\n", "target": "import pyprimes\n\ndef primorial_prime(_pmax=500):\n    isprime = pyprimes.isprime\n    n, primo = 0, 1\n    for prime in pyprimes.nprimes(_pmax):\n        n, primo = n+1, primo * prime\n        if isprime(primo-1) or isprime(primo+1):\n            yield n\n        \nif __name__ == '__main__':\n    \n    pyprimes.warn_probably = False  \n    for i, n in zip(range(20), primorial_prime()):\n        print('Primorial prime %2i at primorial index: %3i' % (i+1, n))\n"}
{"id": 411586, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Fortran to Python: program CalcPi\n    \n    use iso_fortran_env, only: rf => real128\n    implicit none\n    real(rf) :: a,g,s,old_pi,new_pi\n    real(rf) :: a1,g1,s1\n    integer :: k,k1,i\n\n    old_pi = 0.0_rf;\n    a = 1.0_rf; g = 1.0_rf/sqrt(2.0_rf); s = 0.0_rf; k = 0\n\n    do i=1,100\n        call approx_pi_step(a,g,s,k,a1,g1,s1,k1)\n        new_pi = 4.0_rf * (a1**2.0_rf) / (1.0_rf - s1)\n        if (abs(new_pi - old_pi).lt.(2.0_rf*epsilon(new_pi))) then\n            \n            \n            exit\n        end if\n        write(*,*) 'Iteration:',k1,' Diff:',abs(new_pi - old_pi),' Pi:',new_pi\n        old_pi = new_pi\n        a = a1; g = g1; s = s1; k = k1\n    end do\n\n    contains\n\n    subroutine approx_pi_step(x,y,z,n,a,g,s,k)\n        real(rf), intent(in) :: x,y,z\n        integer, intent(in) :: n\n        real(rf), intent(out) :: a,g,s\n        integer, intent(out) :: k\n\n        a = 0.5_rf*(x+y)\n        g = sqrt(x*y)\n        k = n + 1\n        s = z + (2.0_rf)**(real(k)+1.0_rf) * (a**(2.0_rf) - g**(2.0_rf))\n    end subroutine\nend program CalcPi\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 411587, "name": "Arithmetic-geometric mean_Calculate Pi", "source": "Translate Fortran to Python: program CalcPi\n    \n    use iso_fortran_env, only: rf => real128\n    implicit none\n    real(rf) :: a,g,s,old_pi,new_pi\n    real(rf) :: a1,g1,s1\n    integer :: k,k1,i\n\n    old_pi = 0.0_rf;\n    a = 1.0_rf; g = 1.0_rf/sqrt(2.0_rf); s = 0.0_rf; k = 0\n\n    do i=1,100\n        call approx_pi_step(a,g,s,k,a1,g1,s1,k1)\n        new_pi = 4.0_rf * (a1**2.0_rf) / (1.0_rf - s1)\n        if (abs(new_pi - old_pi).lt.(2.0_rf*epsilon(new_pi))) then\n            \n            \n            exit\n        end if\n        write(*,*) 'Iteration:',k1,' Diff:',abs(new_pi - old_pi),' Pi:',new_pi\n        old_pi = new_pi\n        a = a1; g = g1; s = s1; k = k1\n    end do\n\n    contains\n\n    subroutine approx_pi_step(x,y,z,n,a,g,s,k)\n        real(rf), intent(in) :: x,y,z\n        integer, intent(in) :: n\n        real(rf), intent(out) :: a,g,s\n        integer, intent(out) :: k\n\n        a = 0.5_rf*(x+y)\n        g = sqrt(x*y)\n        k = n + 1\n        s = z + (2.0_rf)**(real(k)+1.0_rf) * (a**(2.0_rf) - g**(2.0_rf))\n    end subroutine\nend program CalcPi\n", "target": "from decimal import *\n\nD = Decimal\ngetcontext().prec = 100\na = n = D(1)\ng, z, half = 1 / D(2).sqrt(), D(0.25), D(0.5)\nfor i in range(18):\n    x = [(a + g) * half, (a * g).sqrt()]\n    var = x[0] - a\n    z -= var * var * n\n    n += n\n    a, g = x    \nprint(a * a / z)\n"}
{"id": 411588, "name": "Biorhythms", "source": "Translate Fortran to Python: C     ------------------------------------------------------------------\n      PROGRAM BIORHYTHM\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION GETJD\n      CHARACTER*3 DOW\n      \n      DOUBLE PRECISION JD0, JD1, JD2, PI2, DIF\n      \n      INTEGER BYEAR, BMON, BDAY, TYEAR, TMON, TDAY\n      INTEGER I, J, PHY, EMO, MEN, NDAY, DNUM, YR, DOY\n      CHARACTER*3 DNAME\n      CHARACTER*1 GRID, ROW(65)\nC     ------------------------------------------------------------------\n\n      PI2 = ACOS(-1.0D0)*2.0D0\n      \n      WRITE(*,*) 'ENTER YOUR BIRTHDAY YYYY MM DD'\n      READ(*,*) BYEAR, BMON, BDAY\n\n      WRITE(*,*) 'ENTER START DATE YYYY MM DD'\n      READ(*,*) TYEAR, TMON, TDAY\n\n      WRITE(*,*) 'ENTER NUMBER OF DAYS TO PLOT'\n      READ(*,*) NDAY\n\n      JD0 = GETJD( TYEAR, 1,  1 )\n      JD1 = GETJD( BYEAR, BMON, BDAY )\n      JD2 = GETJD( TYEAR, TMON, TDAY )\n\n      WRITE(*,1010)\n      WRITE(*,1000) DOW(JD1), INT( JD2-JD1 )\n      WRITE(*,1010)\n      WRITE(*,1020)\n      DO I=1,NDAY\n         DIF = JD2 - JD1\n         PHY = INT(3.3D1+3.2D1*SIN( PI2 * DIF / 2.3D1 ))\n         EMO = INT(3.3D1+3.2D1*SIN( PI2 * DIF / 2.8D1 ))\n         MEN = INT(3.3D1+3.2D1*SIN( PI2 * DIF / 3.3D1 ))\n\n         IF ( PHY.LT.1  ) PHY = 1\n         IF ( EMO.LT.1  ) EMO = 1\n         IF ( MEN.LT.1  ) MEN = 1\n         IF ( PHY.GT.65 ) PHY = 65\n         IF ( EMO.GT.65 ) EMO = 65\n         IF ( MEN.GT.65 ) MEN = 65\n         \n         DNAME = DOW(JD2)\n         DOY = INT(JD2-JD0)+1\n         IF ( DNAME.EQ.'SUN' ) THEN\n            GRID = '.'\n         ELSE\n            GRID = ' '\n         END IF\n         DO J=1,65\n            ROW(J) = GRID\n         END DO\n         ROW(1)  = '|'\n         ROW(17) = ':'\n         ROW(33) = '|'\n         ROW(49) = ':'\n         ROW(65) = '|'\n         ROW(PHY) = 'P'\n         ROW(EMO) = 'E'\n         ROW(MEN) = 'M'\n         IF ( PHY.EQ.EMO ) ROW(PHY) = '*'\n         IF ( PHY.EQ.MEN ) ROW(PHY) = '*'\n         IF ( EMO.EQ.MEN ) ROW(EMO) = '*'\n         WRITE(*,1030) ROW,DNAME,DOY\n         JD2 = JD2 + 1.0D0\n      END DO\n      WRITE(*,1010)\n\nC     ------------------------------------------------------------------\n      \n 1000 FORMAT( 'YOU WERE BORN ON A (', A3, ') YOU WERE ',I0,\n     $        ' DAYS OLD AT THE START.' )\n 1010 FORMAT( 75('=') )\n 1020 FORMAT( '-1',31X,'0',30X,'+1     DOY' )\n 1030 FORMAT( 1X,65A1, 1X, A3, 1X, I3 )\n\n      STOP\n      END\n\nC     ------------------------------------------------------------------\n      FUNCTION DOW( JD )\nC     ------------------------------------------------------------------\nC     RETURN THE ABBREVIATION FOR THE DAY OF THE WEEK\nC     JD  JULIAN DATE - GREATER THAN 1721423.5 (JAN 1, 0001 SATURDAY)\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION JD\n      INTEGER IDX\n      CHARACTER*3 DOW, NAMES(7)\n      DATA NAMES/'SAT','SUN','MON','TUE','WED','THR','FRI'/\n\n      IDX = INT(MODULO(JD-1.721423500D6,7.0D0)+1)\n\n      DOW = NAMES(IDX)\n      RETURN\n      END\n      \nC     ------------------------------------------------------------------\n      FUNCTION ISGREG( Y, M, D )\nC     ------------------------------------------------------------------\nC     IS THIS DATE ON IN THE GREGORIAN CALENDAR\nC     DATES BEFORE OCT  5 1582 ARE JULIAN\nC     DATES AFTER  OCT 14 1582 ARE GREGORIAN\nC     DATES OCT 5-14 1582 INCLUSIVE DO NOT EXIST\nC     ------------------------------------------------------------------\nC     YEAR    1-ANYTHING\nC     MONTH   1-12\nC     DAY     1-31\nC     ------------------------------------------------------------------\n      LOGICAL ISGREG\n      INTEGER Y, M, D\nC     ------------------------------------------------------------------\n      ISGREG=.TRUE.\n      IF ( Y.LT.1582 ) GOTO 888\n      IF ( Y.GT.1582 ) GOTO 999\n      IF ( M.LT.10 )   GOTO 888\n      IF ( M.GT.10 )   GOTO 999\n      IF ( D.LT.5 )    GOTO 888\n      IF ( D.GT.14 )   GOTO 999\n\n      WRITE(*,*) Y,M,D,' DOES NOT EXIST'\n      GOTO 999\n\n 888  CONTINUE\n      ISGREG=.FALSE.\n 999  CONTINUE\n      RETURN\n      END\n      \nC     ------------------------------------------------------------------\n      FUNCTION GETJD( YEAR, MONTH, DAY )\nC     ------------------------------------------------------------------\nC     RETURN THE JULIAN DATE\nC     YEAR    1-ANYTHING\nC     MONTH   1-12\nC     DAY     1-31\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION GETJD\n      INTEGER YEAR, MONTH, DAY\n      INTEGER Y, M, D, A, B, P1, P2\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION TEMP\n      LOGICAL ISGREG, IG\n\n      IG = ISGREG( YEAR, MONTH, DAY )\n      Y  = YEAR\n      M  = MONTH\n      D  = DAY\n\n      IF (M.LT.3) THEN\n         Y = Y - 1\n         M = M + 12\n      ENDIF\n\n      IF (IG) THEN\n         A =         FLOOR( DBLE(Y) * 1.0D-2 )\n         B = 2 - A + FLOOR( DBLE(A) * 2.5D-1 )\n      ELSE\n         A = 0\n         B = 0\n      ENDIF\n     \n      P1 = FLOOR( 3.65250D2 * DBLE(Y + 4716) )\n      P2 = FLOOR( 3.06001D1 * DBLE(M + 1) )\n\n      GETJD = DBLE(P1 + P2 + D + B) - 1.5245D3\n      \n      RETURN\n      END\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 411589, "name": "Biorhythms", "source": "Translate Fortran to Python: C     ------------------------------------------------------------------\n      PROGRAM BIORHYTHM\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION GETJD\n      CHARACTER*3 DOW\n      \n      DOUBLE PRECISION JD0, JD1, JD2, PI2, DIF\n      \n      INTEGER BYEAR, BMON, BDAY, TYEAR, TMON, TDAY\n      INTEGER I, J, PHY, EMO, MEN, NDAY, DNUM, YR, DOY\n      CHARACTER*3 DNAME\n      CHARACTER*1 GRID, ROW(65)\nC     ------------------------------------------------------------------\n\n      PI2 = ACOS(-1.0D0)*2.0D0\n      \n      WRITE(*,*) 'ENTER YOUR BIRTHDAY YYYY MM DD'\n      READ(*,*) BYEAR, BMON, BDAY\n\n      WRITE(*,*) 'ENTER START DATE YYYY MM DD'\n      READ(*,*) TYEAR, TMON, TDAY\n\n      WRITE(*,*) 'ENTER NUMBER OF DAYS TO PLOT'\n      READ(*,*) NDAY\n\n      JD0 = GETJD( TYEAR, 1,  1 )\n      JD1 = GETJD( BYEAR, BMON, BDAY )\n      JD2 = GETJD( TYEAR, TMON, TDAY )\n\n      WRITE(*,1010)\n      WRITE(*,1000) DOW(JD1), INT( JD2-JD1 )\n      WRITE(*,1010)\n      WRITE(*,1020)\n      DO I=1,NDAY\n         DIF = JD2 - JD1\n         PHY = INT(3.3D1+3.2D1*SIN( PI2 * DIF / 2.3D1 ))\n         EMO = INT(3.3D1+3.2D1*SIN( PI2 * DIF / 2.8D1 ))\n         MEN = INT(3.3D1+3.2D1*SIN( PI2 * DIF / 3.3D1 ))\n\n         IF ( PHY.LT.1  ) PHY = 1\n         IF ( EMO.LT.1  ) EMO = 1\n         IF ( MEN.LT.1  ) MEN = 1\n         IF ( PHY.GT.65 ) PHY = 65\n         IF ( EMO.GT.65 ) EMO = 65\n         IF ( MEN.GT.65 ) MEN = 65\n         \n         DNAME = DOW(JD2)\n         DOY = INT(JD2-JD0)+1\n         IF ( DNAME.EQ.'SUN' ) THEN\n            GRID = '.'\n         ELSE\n            GRID = ' '\n         END IF\n         DO J=1,65\n            ROW(J) = GRID\n         END DO\n         ROW(1)  = '|'\n         ROW(17) = ':'\n         ROW(33) = '|'\n         ROW(49) = ':'\n         ROW(65) = '|'\n         ROW(PHY) = 'P'\n         ROW(EMO) = 'E'\n         ROW(MEN) = 'M'\n         IF ( PHY.EQ.EMO ) ROW(PHY) = '*'\n         IF ( PHY.EQ.MEN ) ROW(PHY) = '*'\n         IF ( EMO.EQ.MEN ) ROW(EMO) = '*'\n         WRITE(*,1030) ROW,DNAME,DOY\n         JD2 = JD2 + 1.0D0\n      END DO\n      WRITE(*,1010)\n\nC     ------------------------------------------------------------------\n      \n 1000 FORMAT( 'YOU WERE BORN ON A (', A3, ') YOU WERE ',I0,\n     $        ' DAYS OLD AT THE START.' )\n 1010 FORMAT( 75('=') )\n 1020 FORMAT( '-1',31X,'0',30X,'+1     DOY' )\n 1030 FORMAT( 1X,65A1, 1X, A3, 1X, I3 )\n\n      STOP\n      END\n\nC     ------------------------------------------------------------------\n      FUNCTION DOW( JD )\nC     ------------------------------------------------------------------\nC     RETURN THE ABBREVIATION FOR THE DAY OF THE WEEK\nC     JD  JULIAN DATE - GREATER THAN 1721423.5 (JAN 1, 0001 SATURDAY)\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION JD\n      INTEGER IDX\n      CHARACTER*3 DOW, NAMES(7)\n      DATA NAMES/'SAT','SUN','MON','TUE','WED','THR','FRI'/\n\n      IDX = INT(MODULO(JD-1.721423500D6,7.0D0)+1)\n\n      DOW = NAMES(IDX)\n      RETURN\n      END\n      \nC     ------------------------------------------------------------------\n      FUNCTION ISGREG( Y, M, D )\nC     ------------------------------------------------------------------\nC     IS THIS DATE ON IN THE GREGORIAN CALENDAR\nC     DATES BEFORE OCT  5 1582 ARE JULIAN\nC     DATES AFTER  OCT 14 1582 ARE GREGORIAN\nC     DATES OCT 5-14 1582 INCLUSIVE DO NOT EXIST\nC     ------------------------------------------------------------------\nC     YEAR    1-ANYTHING\nC     MONTH   1-12\nC     DAY     1-31\nC     ------------------------------------------------------------------\n      LOGICAL ISGREG\n      INTEGER Y, M, D\nC     ------------------------------------------------------------------\n      ISGREG=.TRUE.\n      IF ( Y.LT.1582 ) GOTO 888\n      IF ( Y.GT.1582 ) GOTO 999\n      IF ( M.LT.10 )   GOTO 888\n      IF ( M.GT.10 )   GOTO 999\n      IF ( D.LT.5 )    GOTO 888\n      IF ( D.GT.14 )   GOTO 999\n\n      WRITE(*,*) Y,M,D,' DOES NOT EXIST'\n      GOTO 999\n\n 888  CONTINUE\n      ISGREG=.FALSE.\n 999  CONTINUE\n      RETURN\n      END\n      \nC     ------------------------------------------------------------------\n      FUNCTION GETJD( YEAR, MONTH, DAY )\nC     ------------------------------------------------------------------\nC     RETURN THE JULIAN DATE\nC     YEAR    1-ANYTHING\nC     MONTH   1-12\nC     DAY     1-31\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION GETJD\n      INTEGER YEAR, MONTH, DAY\n      INTEGER Y, M, D, A, B, P1, P2\nC     ------------------------------------------------------------------\n      DOUBLE PRECISION TEMP\n      LOGICAL ISGREG, IG\n\n      IG = ISGREG( YEAR, MONTH, DAY )\n      Y  = YEAR\n      M  = MONTH\n      D  = DAY\n\n      IF (M.LT.3) THEN\n         Y = Y - 1\n         M = M + 12\n      ENDIF\n\n      IF (IG) THEN\n         A =         FLOOR( DBLE(Y) * 1.0D-2 )\n         B = 2 - A + FLOOR( DBLE(A) * 2.5D-1 )\n      ELSE\n         A = 0\n         B = 0\n      ENDIF\n     \n      P1 = FLOOR( 3.65250D2 * DBLE(Y + 4716) )\n      P2 = FLOOR( 3.06001D1 * DBLE(M + 1) )\n\n      GETJD = DBLE(P1 + P2 + D + B) - 1.5245D3\n      \n      RETURN\n      END\n", "target": "\n\nfrom datetime import date, timedelta\nfrom math import floor, sin, pi\n\ndef biorhythms(birthdate,targetdate):\n    \n    \n    \n    \n    print(\"Born: \"+birthdate+\" Target: \"+targetdate)    \n    \n    \n    \n    birthdate = date.fromisoformat(birthdate)\n    targetdate = date.fromisoformat(targetdate)\n    \n    \n    \n    days = (targetdate - birthdate).days\n    \n    print(\"Day: \"+str(days))\n    \n    \n    \n    cycle_labels = [\"Physical\", \"Emotional\", \"Mental\"]\n    cycle_lengths = [23, 28, 33]\n    quadrants = [(\"up and rising\", \"peak\"), (\"up but falling\", \"transition\"),\n                   (\"down and falling\", \"valley\"), (\"down but rising\", \"transition\")]\n    \n    for i in range(3):\n        label = cycle_labels[i]\n        length = cycle_lengths[i]\n        position = days % length\n        quadrant = int(floor((4 * position) / length))\n        percentage = int(round(100 * sin(2 * pi * position / length),0))\n        transition_date = targetdate + timedelta(days=floor((quadrant + 1)/4 * length) - position)\n        trend, next = quadrants[quadrant]\n        \n        if percentage > 95:\n            description = \"peak\"\n        elif percentage < -95:\n             description = \"valley\"\n        elif abs(percentage) < 5:\n             description = \"critical transition\"\n        else:\n             description = str(percentage)+\"% (\"+trend+\", next \"+next+\" \"+str(transition_date)+\")\"\n        print(label+\" day \"+str(position)+\": \"+description)\n    \n    \nbiorhythms(\"1943-03-09\",\"1972-07-11\")\n"}
{"id": 411590, "name": "Primorial numbers", "source": "Translate Fortran to Python:       B.DIGIT(I) = MOD(D,BIGBASE)\n      C = D/BIGBASE\n", "target": "from pyprimes import nprimes\nfrom functools import reduce\n\n\nprimelist = list(nprimes(1000001))    \n\ndef primorial(n):\n    return reduce(int.__mul__, primelist[:n], 1)\n\nif __name__ == '__main__':\n    print('First ten primorals:', [primorial(n) for n in range(10)])\n    for e in range(7):\n        n = 10**e\n        print('primorial(%i) has %i digits' % (n, len(str(primorial(n)))))\n"}
{"id": 411591, "name": "Numerical integration_Gauss-Legendre Quadrature", "source": "Translate Fortran to Python: \n\n\n\nprogram gauss\n  implicit none\n  integer, parameter :: p = 16 \n  integer            :: n = 10, k\n  real(kind=p), allocatable :: r(:,:)\n  real(kind=p)       :: z, a, b, exact\n  do n = 1,20\n    a = -3; b = 3\n    r = gaussquad(n)\n    z = (b-a)/2*dot_product(r(2,:),exp((a+b)/2+r(1,:)*(b-a)/2))\n    exact = exp(3.0_p)-exp(-3.0_p)\n    print \"(i0,1x,g0,1x,g10.2)\",n, z, z-exact\n  end do\n  \n  contains \n\n  function gaussquad(n) result(r)\n  integer                 :: n\n  real(kind=p), parameter :: pi = 4*atan(1._p)\n  real(kind=p)            :: r(2, n), x, f, df, dx\n  integer                 :: i,  iter\n  real(kind = p), allocatable :: p0(:), p1(:), tmp(:)\n  \n  p0 = [1._p]\n  p1 = [1._p, 0._p]\n  \n  do k = 2, n\n     tmp = ((2*k-1)*[p1,0._p]-(k-1)*[0._p, 0._p,p0])/k\n     p0 = p1; p1 = tmp\n  end do\n  do i = 1, n\n    x = cos(pi*(i-0.25_p)/(n+0.5_p))\n    do iter = 1, 10\n      f = p1(1); df = 0._p\n      do k = 2, size(p1)\n        df = f + x*df\n        f  = p1(k) + x * f\n      end do\n      dx =  f / df\n      x = x - dx\n      if (abs(dx)<10*epsilon(dx)) exit\n    end do\n    r(1,i) = x\n    r(2,i) = 2/((1-x**2)*df**2)\n  end do\n  end function\nend program\n", "target": "from numpy import *\n \n\n\ndef Legendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0+1.0\n\telif (n==1):\n\t\treturn x\n\telse:\n\t\treturn ((2.0*n-1.0)*x*Legendre(n-1,x)-(n-1)*Legendre(n-2,x))/n\n \n\n\ndef DLegendre(n,x):\n\tx=array(x)\n\tif (n==0):\n\t\treturn x*0\n\telif (n==1):\n\t\treturn x*0+1.0\n\telse:\n\t\treturn (n/(x**2-1.0))*(x*Legendre(n,x)-Legendre(n-1,x))\n\n\ndef LegendreRoots(polyorder,tolerance=1e-20):\n\tif polyorder<2:\n\t\terr=1 \n\telse:\n\t\troots=[]\n\t\t\n\t\tfor i in range(1,int(polyorder)/2 +1):\n\t\t\tx=cos(pi*(i-0.25)/(polyorder+0.5))\n\t\t\terror=10*tolerance\n\t\t        iters=0\n\t\t        while (error>tolerance) and (iters<1000):\n\t\t                dx=-Legendre(polyorder,x)/DLegendre(polyorder,x)\n\t\t                x=x+dx\n\t\t                iters=iters+1\n\t\t                error=abs(dx)\n\t\t\troots.append(x)\n\t\t\n\t\troots=array(roots)\n\t\tif polyorder%2==0:\n\t\t\troots=concatenate( (-1.0*roots, roots[::-1]) )\n\t\telse:\n\t\t\troots=concatenate( (-1.0*roots, [0.0], roots[::-1]) )\n\t\terr=0 \n\treturn [roots, err]\n\n\ndef GaussLegendreWeights(polyorder):\n\tW=[]\n\t[xis,err]=LegendreRoots(polyorder)\n\tif err==0:\n\t\tW=2.0/( (1.0-xis**2)*(DLegendre(polyorder,xis)**2) )\n\t\terr=0\n\telse:\n\t\terr=1 \n\treturn [W, xis, err]\n\n\n\n\n\n\ndef GaussLegendreQuadrature(func, polyorder, a, b):\n\t[Ws,xs, err]= GaussLegendreWeights(polyorder)\n\tif err==0:\n\t\tans=(b-a)*0.5*sum( Ws*func( (b-a)*0.5*xs+ (b+a)*0.5 ) )\n\telse: \n\t\t\n\t\terr=1\n\t\tans=None\n\treturn [ans,err]\n\n\ndef func(x):\n\treturn exp(x)\n\n\n \norder=5\n[Ws,xs,err]=GaussLegendreWeights(order)\nif err==0:\n\tprint \"Order   \u00a0: \", order\n\tprint \"Roots   \u00a0: \", xs\n\tprint \"Weights \u00a0: \", Ws\nelse:\n\tprint \"Roots/Weights evaluation failed\"\n \n\n[ans,err]=GaussLegendreQuadrature(func , order, -3,3)\nif err==0:\n\tprint \"Integral\u00a0: \", ans\nelse:\n\tprint \"Integral evaluation failed\"\n"}
{"id": 411592, "name": "Chaos game", "source": "Translate Fortran to Python: PROGRAM CHAOS\n IMPLICIT NONE\n REAL, DIMENSION(3):: KA, KN \n REAL, DIMENSION(3):: DA, DB, DC \n INTEGER:: I, Z\n INTEGER, PARAMETER:: UT = 17\n \n DA = (/    0., 0.,   0. /)\n DB = (/  600., 0.,   0. /)\n DC = (/  500., 0., 400. /)\n \n KA = (/  500., 0., 100. /)\n OPEN (UNIT = UT, FILE = 'aus.csv')\n DO I=1, 1000000\n  Z = ZAHL()\n  WRITE (UT, '(3(F12.6, \";\"))') KA\n  SELECT CASE (Z)\n   CASE (1)\n    CALL MITTELP(KA, DA, KN)\n   CASE (2)\n    CALL MITTELP(KA, DB, KN)\n   CASE (3)\n    CALL MITTELP(KA, DC, KN)\n  END SELECT\n  KA = KN\n END DO\n CLOSE (UT)\n CONTAINS\n  \n  SUBROUTINE MITTELP(P1, P2, MP)\n   REAL, INTENT(IN), DIMENSION(3):: P1, P2\n   REAL, INTENT(OUT), DIMENSION(3):: MP\n   MP = (P1 + P2) / 2.\n  END SUBROUTINE MITTELP\n  \n  INTEGER FUNCTION ZAHL()\n   REAL:: ZZ\n   CALL RANDOM_NUMBER(ZZ)\n   ZZ = ZZ * 3.\n   ZAHL = FLOOR(ZZ) + 1\n   IF (ZAHL .GT. 3) ZAHL = 3\n  END FUNCTION ZAHL\nEND PROGRAM CHAOS\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 411593, "name": "Chaos game", "source": "Translate Fortran to Python: PROGRAM CHAOS\n IMPLICIT NONE\n REAL, DIMENSION(3):: KA, KN \n REAL, DIMENSION(3):: DA, DB, DC \n INTEGER:: I, Z\n INTEGER, PARAMETER:: UT = 17\n \n DA = (/    0., 0.,   0. /)\n DB = (/  600., 0.,   0. /)\n DC = (/  500., 0., 400. /)\n \n KA = (/  500., 0., 100. /)\n OPEN (UNIT = UT, FILE = 'aus.csv')\n DO I=1, 1000000\n  Z = ZAHL()\n  WRITE (UT, '(3(F12.6, \";\"))') KA\n  SELECT CASE (Z)\n   CASE (1)\n    CALL MITTELP(KA, DA, KN)\n   CASE (2)\n    CALL MITTELP(KA, DB, KN)\n   CASE (3)\n    CALL MITTELP(KA, DC, KN)\n  END SELECT\n  KA = KN\n END DO\n CLOSE (UT)\n CONTAINS\n  \n  SUBROUTINE MITTELP(P1, P2, MP)\n   REAL, INTENT(IN), DIMENSION(3):: P1, P2\n   REAL, INTENT(OUT), DIMENSION(3):: MP\n   MP = (P1 + P2) / 2.\n  END SUBROUTINE MITTELP\n  \n  INTEGER FUNCTION ZAHL()\n   REAL:: ZZ\n   CALL RANDOM_NUMBER(ZZ)\n   ZZ = ZZ * 3.\n   ZAHL = FLOOR(ZZ) + 1\n   IF (ZAHL .GT. 3) ZAHL = 3\n  END FUNCTION ZAHL\nEND PROGRAM CHAOS\n", "target": "from __future__ import division\n\nsize(300, 260)\n\nbackground(255)  \n\nx = floor(random(width))\ny = floor(random(height))\n\nfor _ in range(30000):\n    v = floor(random(3))\n    if v == 0:\n        x = x / 2\n        y = y / 2\n        colour = color(0, 255, 0)  \n    elif v == 1:\n        x = width / 2 + (width / 2 - x) / 2\n        y = height - (height - y) / 2\n        colour = color(255, 0, 0)  \n    elif v == 2:\n        x = width - (width - x) / 2\n        y = y / 2\n        colour = color(0, 0, 255)  \n\n    set(x, height - y, colour)\n"}
{"id": 411594, "name": "Parsing_Shunting-yard algorithm", "source": "Translate Fortran to Python:       MODULE COMPILER\t\n       INTEGER KBD,MSG\t\t\n\n       INTEGER ENUFF\t\t\n       PARAMETER (ENUFF = 66)\t\n       CHARACTER*(ENUFF) RP\t\n       INTEGER LR\t\t\n\n       INTEGER\t\tOPSYMBOLS\t\t\n       PARAMETER\t(OPSYMBOLS = 11)\t\n       TYPE SYMB\t\t\n        CHARACTER*1\tIS\t\t\n        INTEGER*1\tPRECEDENCE\t\n        CHARACTER*48\tUSAGE\t\t\n       END TYPE SYMB\t\t\n       TYPE(SYMB) SYMBOL(0:OPSYMBOLS)\t\n       PARAMETER (SYMBOL =(/\t\n     o  SYMB(\" \", 0,\"Not recognised as an operator's symbol.\"),\n     1  SYMB(\" \", 1,\"separates symbols and aids legibility.\"),\n     2  SYMB(\")\", 4,\"opened with ( to bracket a sub-expression.\"),\n     3  SYMB(\"]\", 4,\"opened with [ to bracket a sub-expression.\"),\n     4  SYMB(\"}\", 4,\"opened with { to bracket a sub-expression.\"),\n     5  SYMB(\"+\",11,\"addition, and unary + to no effect.\"),\n     6  SYMB(\"-\",11,\"subtraction, and unary - for neg. numbers.\"),\n     7  SYMB(\"*\",12,\"multiplication.\"),\n     8  SYMB(\"\u00d7\",12,\"multiplication, if you can find this.\"),\n     9  SYMB(\"/\",12,\"division.\"),\n     o  SYMB(\"\u00f7\",12,\"division for those with a fancy keyboard.\"),\nC                13 is used so that stacked ^ will have lower priority than incoming ^, thus delivering right-to-left evaluation.\n     1  SYMB(\"^\",14,\"raise to power. Not recognised is **.\")/))\n       CHARACTER*3\tBRAOPEN,BRACLOSE\t\n       PARAMETER\t(BRAOPEN = \"([{\", BRACLOSE = \")]}\")\t\n       INTEGER\t\tBRALEVEL\t\t\n       INTEGER\t\tPRBRA,PRPOW\t\t\n       PARAMETER (PRBRA = SYMBOL( 3).PRECEDENCE)\t\n       PARAMETER (PRPOW = SYMBOL(11).PRECEDENCE)\t\n\n       CHARACTER*10 DIGIT\t\t\n       PARAMETER (DIGIT = \"0123456789\")\t\n\n       INTEGER STACKLIMIT\t\t\n       PARAMETER (STACKLIMIT = 66)\t\n       TYPE DEFERRED\t\t\t\n        CHARACTER*1\tOPC\t\t\n        INTEGER*1\tPRECEDENCE\t\n       END TYPE DEFERRED\t\t\n       TYPE(DEFERRED) OPSTACK(0:STACKLIMIT)\t\n       INTEGER OSP\t\t\t\n\n       INTEGER INCOMING,TOKENTYPE,NOTHING,ANUMBER,OPENBRA,HUH\t\t\n       PARAMETER (NOTHING = 0, ANUMBER = -1, OPENBRA = -2, HUH = -3)\t\n       CONTAINS\t\n        SUBROUTINE EMIT(STUFF)\t\n         CHARACTER*(*) STUFF\t\n         INTEGER L\t\t\n          WRITE (MSG,1) STUFF\t\n    1     FORMAT (\"Emit  \",A)\t\n          IF (STUFF.EQ.\"\") RETURN\t\n          L = LEN(STUFF)\t\n          IF (LR + L.GE.ENUFF) STOP \"Too much RPN for RP\n          IF (LR.GT.0) THEN\t\n            LR = LR + 1\t\t\t\n            RP(LR:LR) = \" \"\t\t\n          END IF\t\t\n          RP(LR + 1:LR + L) = STUFF\t\n          LR = LR + L\t\t\t\n        END SUBROUTINE EMIT\t\n\n        SUBROUTINE STACKOP(C,P)\t\n         CHARACTER*1 C\t\n         INTEGER P\t\n          OSP = OSP + 1\t\t\n          IF (OSP.GT.STACKLIMIT) STOP \"OSP overtopped\n          OPSTACK(OSP).OPC = C\t\t\n          OPSTACK(OSP).PRECEDENCE = P\t\n          WRITE (MSG,1) C,OPSTACK(1:OSP)\t\n    1     FORMAT (\"Stack \",A1,9X,\",OpStk=\",33(A1,I2:\",\"))\n        END SUBROUTINE STACKOP\t\n\n        LOGICAL FUNCTION COMPILE(TEXT)\t\n         CHARACTER*(*) TEXT\t\n         INTEGER L1,L2\t\t\n         CHARACTER*1 C\t\t\n         INTEGER HAPPY\t\t\n          LR = 0\t\t\n          OSP = 0\t\t\n          OPSTACK(0).OPC = \"\"\t\t\n          OPSTACK(0).PRECEDENCE = 0\t\n          BRALEVEL = 0\t\t\n          HAPPY = +1\t\t\n          L2 = 1\t\t\nChew into an operand, possibly obstructed by an open bracket.\n  100     CALL FORASIGN\t\t\n          IF (TOKENTYPE.EQ.NOTHING) THEN\t\n            IF (OSP.GT.0) CALL GRUMP(\"Another operand or one of \"\t\n     1       //BRAOPEN//\" is expected.\")\t\t\t\t\n          ELSE IF (TOKENTYPE.EQ.ANUMBER) THEN\t\n            CALL EMIT(TEXT(L1:L2 - 1))\t\t\t\n          ELSE IF (TOKENTYPE.EQ.OPENBRA) THEN\t\n            CALL STACKOP(C,PRBRA - 1)\t\t\t\n            GO TO 100\t\t\t\t\t\nC         ELSE IF (TOKENTYPE.EQ.ANAME) THEN\t\nC           CALL EMIT(TEXT(L1:L2 - 1))\t\t\t\n          ELSE\t\t\t\t\t\n            CALL GRUMP(\"Huh? Unexpected \"//C)\t\t\n          END IF\t\t\t\t\nChase after an operator, possibly interrupted by a close bracket,.\n  200     CALL FORASIGN\t\t\n          IF (TOKENTYPE.LT.0) THEN\t\n            CALL GRUMP(\"Operator expected, not \"//C)\t\n           ELSE\t\t\t\n            WRITE (MSG,201) C,INCOMING,OPSTACK(1:OSP)\t\n  201       FORMAT (\"Oprn=>\",A1,\"< Prec=\",I2,\t\t\n     1       \",OpStk=\",33(A1,I2:\",\"))\t\t\t\n            DO WHILE(OPSTACK(OSP).PRECEDENCE .GE. INCOMING)\t\n              IF (OPSTACK(OSP).PRECEDENCE .EQ. PRBRA - 1)\t\t\n     1         CALL GRUMP(\"Unbalanced \"//OPSTACK(OSP).OPC)\t\t\n              CALL EMIT(OPSTACK(OSP).OPC)\t\t\t\t\n              OSP = OSP - 1\t\t\t\t\t\t\n            END DO\t\t\t\t\t\t\n            IF (TOKENTYPE.GT.NOTHING) THEN\t\n              IF (INCOMING.EQ.PRBRA) THEN\t\t\n                CALL BALANCEBRA(C)\t\t\t\n                BRALEVEL = BRALEVEL - 1\t\t\t\n                GO TO 200\t\t\t\t\n               ELSE\t\t\t\t\n                IF (C.EQ.\"^\") INCOMING = PRPOW - 1\t\n                CALL STACKOP(C,INCOMING)\t\t\n              END IF\t\t\t\n            END IF\t\t\t\n          END IF\t\t\nCarry on?\n          IF (HAPPY .GT. 0) GO TO 100 \t\nCompleted.\n          COMPILE = HAPPY.GE.0\t\n         CONTAINS\t\n          SUBROUTINE GRUMP(GROWL)\t\n           CHARACTER*(*) GROWL\t\n            WRITE (MSG,1) GROWL\t\n            IF (L1.GT. 1)        WRITE (MSG,1) \"Tasty:\",TEXT( 1:L1 - 1)\t\n            IF (L2.GT.L1)        WRITE (MSG,1) \"Nasty:\",TEXT(L1:L2 - 1)\t\n            IF (L2.LE.LEN(TEXT)) WRITE (MSG,1) \"Misty:\",TEXT(L2:)\t\n    1       FORMAT (4X,A,1X,A)\t\n            HAPPY = -1\t.\t\n          END SUBROUTINE GRUMP\t\n\n          SUBROUTINE BALANCEBRA(B)\t\n           CHARACTER*1 B\t\n           CHARACTER*1 O\t\n           INTEGER IT,L\t\t\n           CHARACTER*88 GROWL\t\n            O = OPSTACK(OSP).OPC\t\n            WRITE (MSG,1) O,B\t\t\n    1       FORMAT (\"Match \",2A)\t\n            IT = INDEX(BRAOPEN,O)\t\n            IF (IT .EQ. INDEX(BRACLOSE,B)) THEN\t\n              OSP = OSP - 1\t\t\t\n             ELSE\t\n              GROWL = \"Unbalanced {[(...)]} bracketing\n     1         //B//\" is unmatched.\"\t\t\t\t\n              IF (IT.GT.0) GROWL(62:) =  \"A \"//BRACLOSE(IT:IT)\t\n     1         //\" would be better.\"\t\t\n              CALL GRUMP(GROWL)\t\t\n            END IF\t\t\t\n          END SUBROUTINE BALANCEBRA\t\n\n          SUBROUTINE FORASIGN\t\n           INTEGER I\t\n            L1 = L2\t\t\n   10       IF (L1.GT.LEN(TEXT)) THEN\t\n              C = \"\"\t\t\t\n              L2 = L1\t\t\t\n              TOKENTYPE = NOTHING\t\n              INCOMING = SYMBOL(1).PRECEDENCE\t\n              HAPPY = 0\t\t\t\n             ELSE\t\nCheck for spaces and move past them.\n              C = TEXT(L1:L1)\t\n              IF (C.LE.\" \") THEN\t\n                L1 = L1 + 1\t\t\n                GO TO 10\t\t\n              END IF\t\t\nCaught something to inspect.\n              L2 = L1 + 1\t\t\n              IF (INDEX(DIGIT,C).GT.0) THEN\t\n                TOKENTYPE = ANUMBER \t\t\n   20           IF (L2.LE.LEN(TEXT)) THEN\t\n                  IF (INDEX(DIGIT,TEXT(L2:L2)).GT.0) THEN\t\n                    L2 = L2 + 1\t\t\t\n                    GO TO 20\t\t\t\n                  END IF\t\t\t\n                END IF\t\t\t\nC             ELSE IF (INDEX(LETTERS,C).GT.0) THEN\t\nC               advance L2 while in NAMEISH.\n              ELSE IF (INDEX(BRAOPEN,C).GT.0) THEN\t\n                TOKENTYPE = OPENBRA\t\t\t\n              ELSE\t\t\t\n                DO I = OPSYMBOLS,1,-1\t\n                  IF (SYMBOL(I).IS .EQ. C) EXIT\t\n                END DO\t\t\t\n                IF (I.LE.0) THEN\t\n                  TOKENTYPE = HUH\t\t\n                  INCOMING = SYMBOL(0).PRECEDENCE\t\n                 ELSE\t\t\t\n                  TOKENTYPE = I\t\t\t\n                  INCOMING = SYMBOL(I).PRECEDENCE\t\n                END IF\t\t\t\n              END IF\t\t\n            END IF\t\n            WRITE (MSG,30) C,INCOMING,TOKENTYPE\t\t\n   30       FORMAT (\"Next=>\",A1,\"< Prec=\",I2,\",Ttype=\",I2)\t\n          END SUBROUTINE FORASIGN\t\n        END FUNCTION COMPILE\t\n      END MODULE COMPILER\t\n\n      PROGRAM POKE\n      USE COMPILER\n      CHARACTER*66 TEXT\n      LOGICAL HIC\n      MSG = 6\n      KBD = 5\n      WRITE (MSG,1)\n    1 FORMAT (\"Produce RPN from infix...\",/)\n\n   10 WRITE (MSG,11)\n   11 FORMAT(\"Infix: \",$)\n      READ(KBD,12) TEXT\n   12 FORMAT (A)\n      IF (TEXT.EQ.\"\") STOP \"Enough.\"\n      HIC = COMPILE(TEXT)\n      WRITE (MSG,13) HIC,RP(1:LR)\n   13 FORMAT (L6,\" RPN: >\",A,\"<\")\n      GO TO 10\n      END\n", "target": "from collections import namedtuple\nfrom pprint import pprint as pp\n\nOpInfo = namedtuple('OpInfo', 'prec assoc')\nL, R = 'Left Right'.split()\n\nops = {\n '^': OpInfo(prec=4, assoc=R),\n '*': OpInfo(prec=3, assoc=L),\n '/': OpInfo(prec=3, assoc=L),\n '+': OpInfo(prec=2, assoc=L),\n '-': OpInfo(prec=2, assoc=L),\n '(': OpInfo(prec=9, assoc=L),\n ')': OpInfo(prec=0, assoc=L),\n }\n\nNUM, LPAREN, RPAREN = 'NUMBER ( )'.split()\n\n\ndef get_input(inp = None):\n    'Inputs an expression and returns list of (TOKENTYPE, tokenvalue)'\n    \n    if inp is None:\n        inp = input('expression: ')\n    tokens = inp.strip().split()\n    tokenvals = []\n    for token in tokens:\n        if token in ops:\n            tokenvals.append((token, ops[token]))\n        \n        \n        else:    \n            tokenvals.append((NUM, token))\n    return tokenvals\n\ndef shunting(tokenvals):\n    outq, stack = [], []\n    table = ['TOKEN,ACTION,RPN OUTPUT,OP STACK,NOTES'.split(',')]\n    for token, val in tokenvals:\n        note = action = ''\n        if token is NUM:\n            action = 'Add number to output'\n            outq.append(val)\n            table.append( (val, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        elif token in ops:\n            t1, (p1, a1) = token, val\n            v = t1\n            note = 'Pop ops from stack to output' \n            while stack:\n                t2, (p2, a2) = stack[-1]\n                if (a1 == L and p1 <= p2) or (a1 == R and p1 < p2):\n                    if t1 != RPAREN:\n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            break\n                    else:        \n                        if t2 != LPAREN:\n                            stack.pop()\n                            action = '(Pop op)'\n                            outq.append(t2)\n                        else:    \n                            stack.pop()\n                            action = '(Pop & discard \"(\")'\n                            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                            break\n                    table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n                    v = note = ''\n                else:\n                    note = ''\n                    break\n                note = '' \n            note = '' \n            if t1 != RPAREN:\n                stack.append((token, val))\n                action = 'Push op token to stack'\n            else:\n                action = 'Discard \")\"'\n            table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n    note = 'Drain stack to output'\n    while stack:\n        v = ''\n        t2, (p2, a2) = stack[-1]\n        action = '(Pop op)'\n        stack.pop()\n        outq.append(t2)\n        table.append( (v, action, ' '.join(outq), ' '.join(s[0] for s in stack), note) )\n        v = note = ''\n    return table\n\nif __name__ == '__main__':\n    infix = '3 + 4 * 2 / ( 1 - 5 ) ^ 2 ^ 3'\n    print( 'For infix expression: %r\\n' % infix )\n    rp = shunting(get_input(infix))\n    maxcolwidths = [len(max(x, key=len)) for x in zip(*rp)]\n    row = rp[0]\n    print( ' '.join('{cell:^{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n    for row in rp[1:]:\n        print( ' '.join('{cell:<{width}}'.format(width=width, cell=cell) for (width, cell) in zip(maxcolwidths, row)))\n\n    print('\\n The final output RPN is: %r' % rp[-1][2])\n"}
{"id": 411595, "name": "Perlin noise", "source": "Translate Fortran to Python: PROGRAM PERLIN\nIMPLICIT NONE\nINTEGER :: i\nINTEGER, DIMENSION(0:511) :: p\nINTEGER, DIMENSION(0:255), PARAMETER :: permutation = (/151,160,137,91,90,15,    &\n    131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23, &\n    190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33, &\n    88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166, &\n    77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244, &\n    102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196, &\n    135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123, &\n    5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42, &\n    223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9, &\n    129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228, &\n    251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107, &\n    49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254, &\n    138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180/)\n\nDO i=0, 255\n    p(i) = permutation(i)\n    p(256+i) = permutation(i)\nEND DO\n\nWRITE(*,\"(F19.17)\") NOISE(3.14d0, 42d0, 7d0)\n\nCONTAINS\n\nDOUBLE PRECISION FUNCTION NOISE(x_in, y_in, z_in)\n    DOUBLE PRECISION, INTENT(IN) :: x_in, y_in, z_in\n    DOUBLE PRECISION :: x, y, z\n    INTEGER :: xx, yy, zz, a, aa, ab, b, ba, bb\n    DOUBLE PRECISION :: u, v, w\n\n    x = x_in\n    y = y_in\n    z = z_in\n\n    xx = IAND(FLOOR(x), 255)\n    yy = IAND(FLOOR(y), 255)\n    zz = IAND(FLOOR(z), 255)\n\n    x = x - FLOOR(x)\n    y = y - FLOOR(y)\n    z = z - FLOOR(z)\n\n    u = FADE(x)\n    v = FADE(y)\n    w = FADE(z)\n\n    a  = p(xx)   + yy\n    aa = p(a)    + zz\n    ab = p(a+1)  + zz\n    b  = p(xx+1) + yy\n    ba = p(b)    + zz\n    bb = p(b+1)  + zz\n\n    NOISE = LERP(w, LERP(v, LERP(u, GRAD(p(aa),   x,   y,   z),     &\n                                    GRAD(p(ba),   x-1, y,   z)),    &\n                            LERP(u, GRAD(p(ab),   x,   y-1, z),     &\n                                    GRAD(p(bb),   x-1, y-1, z))),   &\n                    LERP(v, LERP(u, GRAD(p(aa+1), x,   y,   z-1),   &\n                                    GRAD(p(ba+1), x-1, y,   z-1)),  &\n                            LERP(u, GRAD(p(ab+1), x,   y-1, z-1),   &\n                                    GRAD(p(bb+1), x-1, y-1, z-1))))\nEND FUNCTION\n\n\nDOUBLE PRECISION FUNCTION FADE(t)\n    DOUBLE PRECISION, INTENT(IN) :: t\n\n    FADE = t ** 3 * (t * ( t * 6 - 15) + 10)\nEND FUNCTION\n\n\nDOUBLE PRECISION FUNCTION LERP(t, a, b)\n    DOUBLE PRECISION, INTENT(IN) :: t, a, b\n\n    LERP = a + t * (b - a)\nEND FUNCTION\n\n\nDOUBLE PRECISION FUNCTION GRAD(hash, x, y, z)\n    INTEGER, INTENT(IN) :: hash\n    DOUBLE PRECISION, INTENT(IN) :: x, y, z\n    INTEGER :: h\n    DOUBLE PRECISION :: u, v\n\n    h = IAND(hash, 15)\n\n    u = MERGE(x, y, h < 8)\n\n    v = MERGE(y, MERGE(x, z, h == 12 .OR. h == 14), h < 4)\n\n    GRAD = MERGE(u, -u, IAND(h, 1) == 0) + MERGE(v, -v, IAND(h, 2) == 0)\nEND FUNCTION\n\n\nEND PROGRAM\n", "target": "import math\n\ndef perlin_noise(x, y, z):\n    X = math.floor(x) & 255                  \n    Y = math.floor(y) & 255                  \n    Z = math.floor(z) & 255\n    x -= math.floor(x)                                \n    y -= math.floor(y)                                \n    z -= math.floor(z)\n    u = fade(x)                                \n    v = fade(y)                                \n    w = fade(z)\n    A = p[X  ]+Y; AA = p[A]+Z; AB = p[A+1]+Z      \n    B = p[X+1]+Y; BA = p[B]+Z; BB = p[B+1]+Z      \n \n    return lerp(w, lerp(v, lerp(u, grad(p[AA  ], x  , y  , z   ),  \n                                   grad(p[BA  ], x-1, y  , z   )), \n                           lerp(u, grad(p[AB  ], x  , y-1, z   ),  \n                                   grad(p[BB  ], x-1, y-1, z   ))),\n                   lerp(v, lerp(u, grad(p[AA+1], x  , y  , z-1 ),  \n                                   grad(p[BA+1], x-1, y  , z-1 )), \n                           lerp(u, grad(p[AB+1], x  , y-1, z-1 ),\n                                   grad(p[BB+1], x-1, y-1, z-1 ))))\n                                   \ndef fade(t): \n    return t ** 3 * (t * (t * 6 - 15) + 10)\n    \ndef lerp(t, a, b):\n    return a + t * (b - a)\n    \ndef grad(hash, x, y, z):\n    h = hash & 15                      \n    u = x if h<8 else y                \n    v = y if h<4 else (x if h in (12, 14) else z)\n    return (u if (h&1) == 0 else -u) + (v if (h&2) == 0 else -v)\n\np = [None] * 512\npermutation = [151,160,137,91,90,15,\n   131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,\n   190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,\n   88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,\n   77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,\n   102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,\n   135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,\n   5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,\n   223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,\n   129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,\n   251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,\n   49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,\n   138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180]\nfor i in range(256):\n    p[256+i] = p[i] = permutation[i]\n\nif __name__ == '__main__':\n    print(\"%1.17f\" % perlin_noise(3.14, 42, 7))\n"}
{"id": 411596, "name": "Vector", "source": "Translate Fortran to Python: MODULE ROSETTA_VECTOR\n    IMPLICIT NONE\n\n    TYPE VECTOR\n        REAL :: X, Y\n    END TYPE VECTOR\n\n\n    INTERFACE OPERATOR(+)\n       MODULE PROCEDURE VECTOR_ADD\n    END INTERFACE\n\n    INTERFACE OPERATOR(-)\n       MODULE PROCEDURE VECTOR_SUB\n    END INTERFACE\n\n    INTERFACE OPERATOR(/)\n       MODULE PROCEDURE VECTOR_DIV\n    END INTERFACE\n\n    INTERFACE OPERATOR(*)\n       MODULE PROCEDURE VECTOR_MULT\n    END INTERFACE\n\n    CONTAINS\n\n    FUNCTION VECTOR_ADD(VECTOR_1, VECTOR_2)\n        TYPE(VECTOR), INTENT(IN) :: VECTOR_1, VECTOR_2\n        TYPE(VECTOR) :: VECTOR_ADD\n        VECTOR_ADD%X = VECTOR_1%X+VECTOR_2%X\n        VECTOR_ADD%Y = VECTOR_1%Y+VECTOR_2%Y\n    END FUNCTION VECTOR_ADD\n\n    FUNCTION VECTOR_SUB(VECTOR_1, VECTOR_2)\n        TYPE(VECTOR), INTENT(IN) :: VECTOR_1, VECTOR_2\n        TYPE(VECTOR) :: VECTOR_SUB\n        VECTOR_SUB%X = VECTOR_1%X-VECTOR_2%X\n        VECTOR_SUB%Y = VECTOR_1%Y-VECTOR_2%Y\n    END FUNCTION VECTOR_SUB\n\n    FUNCTION VECTOR_DIV(VEC, SCALAR)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        REAL, INTENT(IN) :: SCALAR\n        TYPE(VECTOR) :: VECTOR_DIV\n        VECTOR_DIV%X = VEC%X/SCALAR\n        VECTOR_DIV%Y = VEC%Y/SCALAR\n    END FUNCTION VECTOR_DIV\n\n    FUNCTION VECTOR_MULT(VEC, SCALAR)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        REAL, INTENT(IN) :: SCALAR\n        TYPE(VECTOR) :: VECTOR_MULT\n        VECTOR_MULT%X = VEC%X*SCALAR\n        VECTOR_MULT%Y = VEC%Y*SCALAR\n    END FUNCTION VECTOR_MULT\n\n    FUNCTION FROM_RTHETA(R, THETA)\n        REAL :: R, THETA\n        TYPE(VECTOR) :: FROM_RTHETA\n        FROM_RTHETA%X = R*SIN(THETA)\n        FROM_RTHETA%Y = R*COS(THETA)\n    END FUNCTION FROM_RTHETA\n\n    FUNCTION FROM_XY(X, Y)\n        REAL :: X, Y\n        TYPE(VECTOR) :: FROM_XY\n        FROM_XY%X = X\n        FROM_XY%Y = Y\n    END FUNCTION FROM_XY\n\n    FUNCTION PRETTY_PRINT(VEC)\n        TYPE(VECTOR), INTENT(IN) :: VEC\n        CHARACTER(LEN=100) PRETTY_PRINT\n        WRITE(PRETTY_PRINT,\"(A, F0.5, A, F0.5, A)\") \"[\", VEC%X, \", \", VEC%Y, \"]\"\n    END FUNCTION PRETTY_PRINT\nEND MODULE ROSETTA_VECTOR\n\nPROGRAM VECTOR_DEMO\n    USE ROSETTA_VECTOR\n    IMPLICIT NONE\n\n    TYPE(VECTOR) :: VECTOR_1, VECTOR_2\n    REAL, PARAMETER :: PI = 4*ATAN(1.0)\n    REAL :: SCALAR\n\n    SCALAR = 2.0\n\n    VECTOR_1 = FROM_XY(2.0, 3.0)\n    VECTOR_2 = FROM_RTHETA(2.0, PI/6.0)\n\n    WRITE(*,*) \"VECTOR_1 (X: 2.0, Y: 3.0)     \u00a0: \", PRETTY_PRINT(VECTOR_1)\n    WRITE(*,*) \"VECTOR_2 (R: 2.0, THETA: PI/6)\u00a0: \", PRETTY_PRINT(VECTOR_2)\n    WRITE(*,*) NEW_LINE('A')\n    WRITE(*,*) \"VECTOR_1  +  VECTOR_2          = \", PRETTY_PRINT(VECTOR_1+VECTOR_2)\n    WRITE(*,*) \"VECTOR_1  -  VECTOR_2          = \", PRETTY_PRINT(VECTOR_1-VECTOR_2)\n    WRITE(*,*) \"VECTOR_1  /  2.0               = \", PRETTY_PRINT(VECTOR_1/SCALAR)\n    WRITE(*,*) \"VECTOR_1  *  2.0               = \", PRETTY_PRINT(VECTOR_1*SCALAR)\nEND PROGRAM VECTOR_DEMO\n", "target": "v1 = PVector(5, 7)\nv2 = PVector(2, 3)\n\nprintln('{} {} {} {}\\n'.format( v1.x, v1.y, v1.mag(), v1.heading()))\n\n\nprintln(v1 + v2) \nprintln(v1 - v2) \nprintln(v1 * 11) \nprintln(v1 / 2)  \nprintln('')\n\n\nprintln(v1.sub(v1))  \nprintln(v1.add(v2))  \nprintln(v1.mult(10)) \nprintln(v1.div(10))  \n"}
{"id": 411597, "name": "Prime conspiracy", "source": "Translate Fortran to Python:       PROGRAM INHERIT\t\n      USE PRIMEBAG\t\n      INTEGER MBASE,P0,NHIC\t\n      PARAMETER (MBASE = 13, P0 = 2, NHIC = 100000000)\t\n      INTEGER N(0:MBASE - 1,0:MBASE - 1,2:MBASE)\t\n      INTEGER I,B,D1,D2\t\n      INTEGER P,PP\t\n\n      MSG = 6\t\t\n      WRITE (MSG,1) MBASE,P0,NHIC\t\n    1 FORMAT (\"Working in base 2 to \",I0,\" count the transitions \"\n     1 \"from the low-order digit of one prime number \",/,\n     2 \"to the low-order digit of its successor. Starting with \",I0,\n     3 \" and making \",I0,\" advances.\")\n      IF (.NOT.GRASPPRIMEBAG(66)) STOP \"Gan't grab my file\n\nChug through the primes.\n   10 N = 0\t\n      P = P0\t\n      DO I = 1,NHIC\t\n        PP = P\t\t\t\n        P = NEXTPRIME(P)\t\n        DO B = 2,MBASE\t\t\n          D1 = MOD(PP,B)\t\t\n          D2 = MOD(P,B)\t\t\t\n          N(D1,D2,B) = N(D1,D2,B) + 1\t\n        END DO\t\t\t\n      END DO\t\t\n      WRITE (MSG,11) P\t\n   11 FORMAT (\"Ending with \",I0)\t\n\nCast forth the results.\n   20 DO B = 2,MBASE\t\n        WRITE (MSG,21) B\t\t\n   21   FORMAT (/,\"For base \",I0)\t\n        WRITE (MSG,22) (D1, D1 = 0,B - 1)\t\n   22   FORMAT (\" Last digit ending  \",I2,66I9)\t\n        DO D2 = 0,B - 1\t\t\n          IF (ALL(N(0:B - 1,D2,B).EQ.0)) CYCLE\t\n          WRITE (MSG,23) D2,N(0:B - 1,D2,B)\t\n   23     FORMAT (\" next prime ends\",I3,\":\",I2,66I9)\t\n        END DO\t\t\t\n      END DO\t\t\n      END\t\n", "target": "def isPrime(n):\n    if n < 2:\n        return False\n    if n % 2 == 0:\n        return n == 2\n    if n % 3 == 0:\n        return n == 3\n\n    d = 5\n    while d * d <= n:\n        if n % d == 0:\n            return False\n        d += 2\n\n        if n % d == 0:\n            return False\n        d += 4\n    return True\n\ndef generatePrimes():\n    yield 2\n    yield 3\n\n    p = 5\n    while p > 0:\n        if isPrime(p):\n            yield p\n        p += 2\n        if isPrime(p):\n            yield p\n        p += 4\n\ng = generatePrimes()\ntransMap = {}\nprev = None\nlimit = 1000000\nfor _ in xrange(limit):\n    prime = next(g)\n    if prev:\n        transition = (prev, prime %10)\n        if transition in transMap:\n            transMap[transition] += 1\n        else:\n            transMap[transition] = 1\n    prev = prime % 10\n\nprint \"First {:,} primes. Transitions prime\u00a0% 10 > next-prime\u00a0% 10.\".format(limit)\nfor trans in sorted(transMap):\n    print \"{0} -> {1} count {2:5} frequency: {3}%\".format(trans[0], trans[1], transMap[trans], 100.0 * transMap[trans] / limit)\n"}
{"id": 411598, "name": "Statistics_Normal distribution", "source": "Translate Fortran to Python: program Normal_Distribution\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: r64 = selected_real_kind(15)\n  integer(i64), parameter :: samples = 1000000_i64\n  real(r64) :: mean, stddev\n  real(r64) :: sumn = 0, sumnsq = 0\n  integer(i64) :: n = 0 \n  integer(i64) :: bin(-50:50) = 0\n  integer :: i, ind\n  real(r64) :: ur1, ur2, nr1, nr2, s\n  \n  n = 0\n  do while(n <= samples)\n    call random_number(ur1)\n    call random_number(ur2)\n    ur1 = ur1 * 2.0 - 1.0\n    ur2 = ur2 * 2.0 - 1.0\n    \n    s = ur1*ur1 + ur2*ur2  \n    if(s >= 1.0_r64) cycle\n      \n    nr1 = ur1 * sqrt(-2.0*log(s)/s)\n    ind = floor(5.0*nr1)\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + nr1\n    sumnsq = sumnsq + nr1*nr1\n    \n    nr2 = ur2 * sqrt(-2.0*log(s)/s)\n    ind = floor(5.0*nr2)\n    bin(ind) = bin(ind) + 1_i64\n    sumn = sumn + nr2\n    sumnsq = sumnsq + nr2*nr2\n    n = n + 2_i64\n  end do\n \n  mean = sumn / n\n  stddev = sqrt(sumnsq/n - mean*mean)\n  \n  write(*, \"(a, i0)\") \"sample size = \", samples\n  write(*, \"(a, f17.15)\") \"Mean\u00a0:   \", mean,\n  write(*, \"(a, f17.15)\") \"Stddev\u00a0: \", stddev\n  \n  do i = -15, 15 \n    write(*, \"(f4.1, a, a)\") real(i)/5.0, \": \", repeat(\"=\", int(bin(i)*500/samples))\n  end do\n       \nend program\n", "target": "from __future__ import division\nimport matplotlib.pyplot as plt \nimport random\n\nmean, stddev, size = 50, 4, 100000\ndata = [random.gauss(mean, stddev) for c in range(size)]\n\nmn = sum(data) / size\nsd = (sum(x*x for x in data) / size \n      - (sum(data) / size) ** 2) ** 0.5\n\nprint(\"Sample mean = %g; Stddev = %g; max = %g; min = %g for %i values\" \n      % (mn, sd, max(data), min(data), size))\n\nplt.hist(data,bins=50)\n"}
{"id": 411599, "name": "K-means++ clustering", "source": "Translate Fortran to Python: ***********************************************************************\n* KMPP - K-Means++ - Traditional data clustering with a special initialization\n* Public Domain - This program may be used by any person for any purpose.\n*\n* Origin:\n*    Hugo Steinhaus, 1956\n*\n* Refer to:\n*    \"kmeans++: the advantages of careful seeding\"\n*    David Arthur and Sergei Vassilvitskii\n*    Proceedings of the eighteenth annual ACM-SIAM symposium \n*      on Discrete algorithms, 2007\n*\n*____Variable_______I/O_______Description___________________Type_______\n*    X(P,N)         In        Data points                   Real\n*    P              In        Dimension of the data         Integer\n*    N              In        Number of points              Integer\n*    K              In        # clusters                    Integer\n*    C(P,K)         Out       Center points of clusters     Real\n*    Z(N)           Out       What cluster a point is in    Integer\n*    WORK(N)        Neither                                 Real\n*    IFAULT         Out       Error code                    Integer\n************************************************************************\n      SUBROUTINE KMPP (X, P, N, K, C, Z, WORK, IFAULT)\n       \n       IMPLICIT NONE\n       INTEGER P, N, K, Z, IFAULT\n       REAL X, C, WORK\n       DIMENSION X(P,N), C(P,K), Z(N), WORK(N)\n  \n*               constants\n       INTEGER ITER                 \n       REAL BIG                     \n       PARAMETER (ITER = 1000,\n     $            BIG = 1E33)\n                 \n*                local variables\n       INTEGER \n     $         H,          \n     $         I,          \n     $         I1,         \n     $         J,          \n     $         L,          \n     $         L0,         \n     $         L1          \n     \n       REAL \n     $      BEST,                 \n     $      D2,                   \n     $      TOT,                  \n     $      W                     \n     \n       LOGICAL CHANGE             \n\n************************************************************************\n*           Begin.\n************************************************************************\n       IFAULT = 0\n       IF (K < 1 .OR. K > N) THEN       \n         IFAULT = 3\n         RETURN\n       END IF\n       DO I = 1, N                       \n         Z(I) = 0\n       END DO\n        \n************************************************************************\n*        initial centers\n************************************************************************\n       DO I = 1, N\n         WORK(I) = BIG\n       END DO\n\n       CALL RANDOM_NUMBER (W)\n       I1 = MIN(INT(W * FLOAT(N)) + 1, N)  \n       DO J = 1, P\n         C(J,1) = X(J,I1)\n       END DO\n       \n       DO L = 2, K                    \n         TOT = 0.\n         DO I = 1, N                     \n           BEST = WORK(I)\n           D2 = 0.                         \n           DO J = 1, P\n             D2 = D2 + (X(J,I) - C(J,L-1)) **2  \n             IF (D2 .GE. BEST) GO TO 10               \n           END DO                          \n           IF (D2 < BEST) BEST = D2          \n           WORK(I) = BEST \n  10       TOT = TOT + BEST             \n         END DO                      \n         \n************************************************************************\n* Choose center with probability proportional to its squared distance\n*     from existing centers.\n************************************************************************\n         CALL RANDOM_NUMBER (W)\n         W = W * TOT    \n         TOT = 0.\n         DO I = 1, N\n           I1 = I\n           TOT = TOT + WORK(I)\n           IF (TOT > W) GO TO 20\n         END DO                \n  20     CONTINUE\n         DO J = 1, P         \n           C(J,L) = X(J,I1)\n         END DO\n       END DO               \n\n************************************************************************\n*                      main loop\n************************************************************************\n       DO H = 1, ITER\n         CHANGE = .FALSE.\n\n*             find nearest center for each point \n         DO I = 1, N\n           L0 = Z(I)\n           L1 = 0\n           BEST = BIG\n           DO L = 1, K\n             D2 = 0.\n             DO J = 1, P\n               D2 = D2 + (X(J,I) - C(J,L)) **2\n               IF (D2 .GE. BEST) GO TO 30\n             END DO\n  30         CONTINUE\n             IF (D2 < BEST) THEN           \n               BEST = D2\n               L1 = L\n             END IF             \n           END DO        \n        \n           IF (L0 .NE. L1) THEN\n             Z(I) = L1                   \n             CHANGE = .TRUE.\n           END IF\n         END DO         \n         IF (.NOT. CHANGE) RETURN      \n\n************************************************************************\n*           find cluster centers\n************************************************************************\n         DO L = 1, K              \n           WORK(L) = 0.\n         END DO\n         DO L = 1, K               \n           DO J = 1, P\n             C(J,L) = 0.\n           END DO\n         END DO\n\n         DO I = 1, N\n           L = Z(I)\n           WORK(L) = WORK(L) + 1.             \n           DO J = 1, P\n             C(J,L) = C(J,L) + X(J,I)         \n           END DO\n         END DO\n           \n         DO L = 1, K\n           IF (WORK(L) < 0.5) THEN          \n             IFAULT = 1                     \n             RETURN\n           END IF\n           W = 1. / WORK(L)\n           DO J = 1, P\n             C(J,L) = C(J,L) * W     \n           END DO\n         END DO\n             \n       END DO                   \n       IFAULT = 2                \n       RETURN\n    \n      END  \n\n\n************************************************************************\n*             test program (extra credit #1)\n************************************************************************\n      PROGRAM TPEC1\n       IMPLICIT NONE\n       INTEGER N, P, K\n       REAL TWOPI\n       PARAMETER (N = 30 000,\n     $            P = 2,\n     $            K = 6,\n     $            TWOPI = 6.2831853)\n       INTEGER I, L, Z(N), IFAULT\n       REAL X(P,N), C(P,K), R, THETA, W, WORK(N)\n\n*             Begin\n       CALL RANDOM_SEED()\n       DO I = 1, N                      \n         CALL RANDOM_NUMBER (W)\n         R = SQRT(W)                      \n         CALL RANDOM_NUMBER (W)\n         THETA = W * TWOPI                \n         X(1,I) = R * COS(THETA)          \n         X(2,I) = R * SIN(THETA)\n       END DO\n       \n*             Call subroutine\n       CALL KMPP (X, P, N, K, C, Z, WORK, IFAULT)\n       PRINT *, 'kmpp returns with error code ', IFAULT\n       \n*            Print lists of points in each cluster\n       DO L = 1, K\n         PRINT *, 'Cluster ', L, ' contains points: '\n  10     FORMAT (I6, $)\n  20     FORMAT ()\n         DO I = 1, N\n           IF (Z(I) .EQ. L) PRINT 10, I\n         END DO\n         PRINT 20\n       END DO\n       \n*         Write CSV file with Y-coordinates in different columns by cluster\n       OPEN (UNIT=1, FILE='tpec1.csv', STATUS='NEW', IOSTAT=IFAULT)\n       IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble opening file'\n  30   FORMAT (F8.4, $)\n  40   FORMAT (',', $)\n  50   FORMAT (F8.4)\n       DO I = 1, N\n         WRITE (UNIT=1, FMT=30, IOSTAT=IFAULT) X(1,I)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing X-coord'\n         DO L = 1, Z(I)                     \n           WRITE (UNIT=1, FMT=40, IOSTAT=IFAULT)\n           IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing comma'\n         END DO\n         WRITE (UNIT=1, FMT=50, IOSTAT=IFAULT) X(2,I)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing Y-coord'\n       END DO\n       \n*           Write the centroids in the far column\n       DO L = 1, K\n         WRITE (UNIT=1, FMT=30, IOSTAT=IFAULT) C(1,L)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing X-coord'\n         DO I = 1, K+1\n           WRITE (UNIT=1, FMT=40, IOSTAT=IFAULT)\n           IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing comma'\n         END DO\n         WRITE (UNIT=1, FMT=50, IOSTAT=IFAULT) C(2,L)\n         IF (IFAULT .NE. 0) PRINT *, 'tpec1: trouble writing Y-coord'\n       END DO\n       CLOSE (UNIT=1)\n       \n      END  \n", "target": "from math import pi, sin, cos\nfrom collections import namedtuple\nfrom random import random, choice\nfrom copy import copy\n\ntry:\n    import psyco\n    psyco.full()\nexcept ImportError:\n    pass\n\n\nFLOAT_MAX = 1e100\n\n\nclass Point:\n    __slots__ = [\"x\", \"y\", \"group\"]\n    def __init__(self, x=0.0, y=0.0, group=0):\n        self.x, self.y, self.group = x, y, group\n\n\ndef generate_points(npoints, radius):\n    points = [Point() for _ in xrange(npoints)]\n\n    \n    for p in points:\n        r = random() * radius\n        ang = random() * 2 * pi\n        p.x = r * cos(ang)\n        p.y = r * sin(ang)\n\n    return points\n\n\ndef nearest_cluster_center(point, cluster_centers):\n    \n    def sqr_distance_2D(a, b):\n        return (a.x - b.x) ** 2  +  (a.y - b.y) ** 2\n\n    min_index = point.group\n    min_dist = FLOAT_MAX\n\n    for i, cc in enumerate(cluster_centers):\n        d = sqr_distance_2D(cc, point)\n        if min_dist > d:\n            min_dist = d\n            min_index = i\n\n    return (min_index, min_dist)\n\n\ndef kpp(points, cluster_centers):\n    cluster_centers[0] = copy(choice(points))\n    d = [0.0 for _ in xrange(len(points))]\n\n    for i in xrange(1, len(cluster_centers)):\n        sum = 0\n        for j, p in enumerate(points):\n            d[j] = nearest_cluster_center(p, cluster_centers[:i])[1]\n            sum += d[j]\n\n        sum *= random()\n\n        for j, di in enumerate(d):\n            sum -= di\n            if sum > 0:\n                continue\n            cluster_centers[i] = copy(points[j])\n            break\n\n    for p in points:\n        p.group = nearest_cluster_center(p, cluster_centers)[0]\n\n\ndef lloyd(points, nclusters):\n    cluster_centers = [Point() for _ in xrange(nclusters)]\n\n    \n    kpp(points, cluster_centers)\n\n    lenpts10 = len(points) >> 10\n\n    changed = 0\n    while True:\n        \n        for cc in cluster_centers:\n            cc.x = 0\n            cc.y = 0\n            cc.group = 0\n\n        for p in points:\n            cluster_centers[p.group].group += 1\n            cluster_centers[p.group].x += p.x\n            cluster_centers[p.group].y += p.y\n\n        for cc in cluster_centers:\n            cc.x /= cc.group\n            cc.y /= cc.group\n\n        \n        changed = 0\n        for p in points:\n            min_i = nearest_cluster_center(p, cluster_centers)[0]\n            if min_i != p.group:\n                changed += 1\n                p.group = min_i\n\n        \n        if changed <= lenpts10:\n            break\n\n    for i, cc in enumerate(cluster_centers):\n        cc.group = i\n\n    return cluster_centers\n\n\ndef print_eps(points, cluster_centers, W=400, H=400):\n    Color = namedtuple(\"Color\", \"r g b\");\n\n    colors = []\n    for i in xrange(len(cluster_centers)):\n        colors.append(Color((3 * (i + 1) % 11) / 11.0,\n                            (7 * i % 11) / 11.0,\n                            (9 * i % 11) / 11.0))\n\n    max_x = max_y = -FLOAT_MAX\n    min_x = min_y = FLOAT_MAX\n\n    for p in points:\n        if max_x < p.x: max_x = p.x\n        if min_x > p.x: min_x = p.x\n        if max_y < p.y: max_y = p.y\n        if min_y > p.y: min_y = p.y\n\n    scale = min(W / (max_x - min_x),\n                H / (max_y - min_y))\n    cx = (max_x + min_x) / 2\n    cy = (max_y + min_y) / 2\n\n    print \"%%!PS-Adobe-3.0\\n%%%%BoundingBox: -5 -5 %d %d\" % (W + 10, H + 10)\n\n    print (\"/l {rlineto} def /m {rmoveto} def\\n\" +\n           \"/c { .25 sub exch .25 sub exch .5 0 360 arc fill } def\\n\" +\n           \"/s { moveto -2 0 m 2 2 l 2 -2 l -2 -2 l closepath \" +\n           \"   gsave 1 setgray fill grestore gsave 3 setlinewidth\" +\n           \" 1 setgray stroke grestore 0 setgray stroke }def\")\n\n    for i, cc in enumerate(cluster_centers):\n        print (\"%g %g %g setrgbcolor\" %\n               (colors[i].r, colors[i].g, colors[i].b))\n\n        for p in points:\n            if p.group != i:\n                continue\n            print (\"%.3f %.3f c\" % ((p.x - cx) * scale + W / 2,\n                                    (p.y - cy) * scale + H / 2))\n\n        print (\"\\n0 setgray %g %g s\" % ((cc.x - cx) * scale + W / 2,\n                                        (cc.y - cy) * scale + H / 2))\n\n    print \"\\n%%%%EOF\"\n\n\ndef main():\n    npoints = 30000\n    k = 7 \n\n    points = generate_points(npoints, 10)\n    cluster_centers = lloyd(points, k)\n    print_eps(points, cluster_centers)\n\n\nmain()\n"}
{"id": 411600, "name": "Decimal floating point number to binary", "source": "Translate Fortran to Python:       MODULE REBASE\t\n       CHARACTER*36 DIGIT\t\n       PARAMETER (DIGIT = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\t\n       CONTAINS\t\t\n        LOGICAL FUNCTION EATNUM(ACARD,BASE,V)\t\nChews into the likes of 666, -666.666, .666 with their variations.\nCompletes with the value in V, success as the result.\nCould check that no digit exceeds the specified BASE usage, but that would mean an error message...\nConcocted by R.N.McLean (whom God preserve) May XXMM.\nClunky usage of ICHAR encourages the compaq compiler to employ single-character-at-a-time usage.\n         CHARACTER*(*) ACARD\t\n         INTEGER BASE\t\t\n         DOUBLE PRECISION V\t\n         DOUBLE PRECISION X\t\n         INTEGER D,DD\t\t\n         INTEGER L2,LC\t\t\n         INTEGER*1 C\t\t\n         LOGICAL ADIGIT,XNEG\t\n          ADIGIT = .FALSE.\t\n          XNEG = .FALSE.\t\n          DD = 0\t\t\n          X = 0\t\t\t\n          L2 = 1\t\t\n          LC = LEN(ACARD)\t\n          IF (L2.GT.LC) GO TO 20\t\nChew into the number. Admit a possible leading sign, then digits.\n          C = ICHAR(ACARD(L2:L2))\t\n          IF (C.EQ.ICHAR(\"+\")) GO TO 1\t\n          IF (C.NE.ICHAR(\"-\")) GO TO 2\t\n          XNEG = .TRUE.\t\t\n    1     L2 = L2 + 1\t\t\n          IF (L2.GT.LC) GO TO 20\t\n    2     D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 10\t\n          X = D\t\t\t\t\n          ADIGIT = .TRUE.\t\t\n    3     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D .LT. 0) GO TO 10\t\n          X = X*BASE + D\t\t\n          GO TO 3\t\t\t\nConsider any decimal digits, introduced by a decimal point.\n   10     IF (ICHAR(ACARD(L2:L2)).EQ.ICHAR(\".\")) GO TO 11\t\n          IF (ICHAR(ACARD(L2:L2)).NE.ICHAR(\"\u00b7\")) GO TO 20\t\n   11     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 20\t\n          X = X*BASE + D\t\t\n          DD = 1\t\t\t\n          ADIGIT = .TRUE.\t\t\n   12     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D < 0 .OR. 9 < D) GO TO 20\t\n          X = X*BASE + D\t\t\t\n          DD = DD + 1\t\t\t\n          GO TO 12\t\t\t\nCan't consider any exponent part, started by an \"E\" or \"D\", as these may be possible digit symbols.\n   20     IF (DD .GT. 0) X = X/BASE**DD\t\n          IF (XNEG) X = -X\t\t\n          V = X\t\t\t\t\n          EATNUM = ADIGIT\t\t\n        END FUNCTION EATNUM\t\n\n        SUBROUTINE FP8DIGITS(X,BASE,TEXT,L)\t\nConverts a number X to a specified BASE. For integers, successive division by BASE, for fractions, successive multiplication.\n         REAL*8 X,T\t\t\n         INTEGER BASE\t\t\n         CHARACTER*(*) TEXT\t\n         INTEGER L\t\t\n         INTEGER N,ND\t\t\n         INTEGER D\t\t\n         LOGICAL NEG\t\t\n          IF (BASE.LE.1 .OR. BASE.GT.LEN(DIGIT)) BASE = 10\t\n          WRITE (TEXT,1) BASE\t\n    1     FORMAT (\"Base\",I3)\t\n          T = X\t\t\t\n          N = T\t\t\t\n          T = ABS(T - N)\t\n          NEG = N .LT. 0\t\n          IF (NEG) N = -N\t\n          L = LEN(TEXT)\t\t\n          ND = 0\t\t\nCrunch the integer part. Use the tail end of TEXT as a scratchpad, as the size of N is unassessed.\n   10     D = MOD(N,BASE)\t\t\n          TEXT(L:L) = DIGIT(D+1:D+1)\t\n          ND = ND + 1\t\t\t\n          N = N/BASE\t\t\t\n          L = L - 1\t\t\t\n          IF (L.LE.0) THEN\t\t\n            TEXT = \"Overflow\n            L = MIN(9,LEN(TEXT))\t\n           RETURN\t\t\t\n          END IF\t\t\t\n          IF (N.GT.0) GO TO 10\t\t\n          IF (NEG) THEN\t\t\t\n            TEXT(L:L) = \"-\"\t\t\n            L = L - 1\t\t\t\n          END IF\t\t\t\n          N = LEN(TEXT) - L\t\t\n          TEXT(9:9 + N - 1) = TEXT(L + 1:)\t\n          L = 9 + N\t\t\t\n          TEXT(L:L) = \".\"\t\t\nCrunch through the fractional part until nothing remains.\n          DO WHILE(T.GT.0)\t\n            IF (L.GE.LEN(TEXT)) THEN\t\n              L = LEN(TEXT)\t\t\n              TEXT(L:L) = \"~\"\t\t\n             RETURN\t\t\n            END IF\t\t\n            T = T*BASE\t\t\n            N = T\t\t\n            T = T - N\t\t\n            L = L + 1\t\t\n            TEXT(L:L) = DIGIT(N+1:N+1)\t\n            ND = ND + 1\t\t\n          END DO\t\t\nCast forth an addendum, to save the reader from mumbling while counting long strings of digits.\n          IF (LEN(TEXT) - L .GT. 11) THEN\t\n            WRITE (TEXT(L + 2:),11) ND\t\t\n   11       FORMAT (\"Digits:\",I3)\t\t\n            L = L + 1 + 10\t\t\t\n          END IF\t\t\t\t\n        END SUBROUTINE FP8DIGITS\t\n      END MODULE REBASE\t\n\n      PROGRAM TESTSOME\nCheck some conversions from one base to another.\n      USE REBASE\n      INTEGER N\t\t\n      PARAMETER (N = 5)\t\t\n      CHARACTER*12 TEXT(N)\t\n      DATA TEXT/\"23.34375\",\"10111.01011\",\"1011.1101\",\"11.90625\",\"-666\"/\t\n      DOUBLE PRECISION V\t\n      INTEGER I,L,BASE\t\t\n      CHARACTER*88 BACK\t\t\n\n      WRITE (6,1)\t\n    1 FORMAT (\"Test text in base\",3X,\"Value in base 10\")\nChug through the tests.\n      DO BASE = 10,2,-8\t\n        DO I = 1,N\t\t\n          WRITE (6,11) TEXT(I),BASE\t\n   11     FORMAT (A,I5,$)\t\t\n          IF (.NOT.EATNUM(TEXT(I),BASE,V)) THEN\t\n            WRITE (6,*) \"Not a good number\n           ELSE\t\t\t\t\n            WRITE (BACK,*) V\t\t\t\n            WRITE (6,12) BACK(1:20)\t\t\n   12       FORMAT (A,$)\t\t\t\n            CALL FP8DIGITS(V,2,BACK,L)\t\t\n            WRITE (6,13) BACK(1:L)\t\t\n   13       FORMAT (A)\t\t\t\t\n            CALL FP8DIGITS(V,10,BACK,L)\t\t\n            WRITE (6,14) BACK(1:L)\t\t\n   14       FORMAT (37X,A)\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n      END DO\t\t\n      END\t\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 411601, "name": "Decimal floating point number to binary", "source": "Translate Fortran to Python:       MODULE REBASE\t\n       CHARACTER*36 DIGIT\t\n       PARAMETER (DIGIT = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\t\n       CONTAINS\t\t\n        LOGICAL FUNCTION EATNUM(ACARD,BASE,V)\t\nChews into the likes of 666, -666.666, .666 with their variations.\nCompletes with the value in V, success as the result.\nCould check that no digit exceeds the specified BASE usage, but that would mean an error message...\nConcocted by R.N.McLean (whom God preserve) May XXMM.\nClunky usage of ICHAR encourages the compaq compiler to employ single-character-at-a-time usage.\n         CHARACTER*(*) ACARD\t\n         INTEGER BASE\t\t\n         DOUBLE PRECISION V\t\n         DOUBLE PRECISION X\t\n         INTEGER D,DD\t\t\n         INTEGER L2,LC\t\t\n         INTEGER*1 C\t\t\n         LOGICAL ADIGIT,XNEG\t\n          ADIGIT = .FALSE.\t\n          XNEG = .FALSE.\t\n          DD = 0\t\t\n          X = 0\t\t\t\n          L2 = 1\t\t\n          LC = LEN(ACARD)\t\n          IF (L2.GT.LC) GO TO 20\t\nChew into the number. Admit a possible leading sign, then digits.\n          C = ICHAR(ACARD(L2:L2))\t\n          IF (C.EQ.ICHAR(\"+\")) GO TO 1\t\n          IF (C.NE.ICHAR(\"-\")) GO TO 2\t\n          XNEG = .TRUE.\t\t\n    1     L2 = L2 + 1\t\t\n          IF (L2.GT.LC) GO TO 20\t\n    2     D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 10\t\n          X = D\t\t\t\t\n          ADIGIT = .TRUE.\t\t\n    3     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D .LT. 0) GO TO 10\t\n          X = X*BASE + D\t\t\n          GO TO 3\t\t\t\nConsider any decimal digits, introduced by a decimal point.\n   10     IF (ICHAR(ACARD(L2:L2)).EQ.ICHAR(\".\")) GO TO 11\t\n          IF (ICHAR(ACARD(L2:L2)).NE.ICHAR(\"\u00b7\")) GO TO 20\t\n   11     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = INDEX(DIGIT,ACARD(L2:L2)) - 1\t\n          IF (D .LT. 0) GO TO 20\t\n          X = X*BASE + D\t\t\n          DD = 1\t\t\t\n          ADIGIT = .TRUE.\t\t\n   12     L2 = L2 + 1\t\t\t\n          IF (L2.GT.LC) GO TO 20\t\n          D = ICHAR(ACARD(L2:L2)) - ICHAR(\"0\")\t\n          IF (D < 0 .OR. 9 < D) GO TO 20\t\n          X = X*BASE + D\t\t\t\n          DD = DD + 1\t\t\t\n          GO TO 12\t\t\t\nCan't consider any exponent part, started by an \"E\" or \"D\", as these may be possible digit symbols.\n   20     IF (DD .GT. 0) X = X/BASE**DD\t\n          IF (XNEG) X = -X\t\t\n          V = X\t\t\t\t\n          EATNUM = ADIGIT\t\t\n        END FUNCTION EATNUM\t\n\n        SUBROUTINE FP8DIGITS(X,BASE,TEXT,L)\t\nConverts a number X to a specified BASE. For integers, successive division by BASE, for fractions, successive multiplication.\n         REAL*8 X,T\t\t\n         INTEGER BASE\t\t\n         CHARACTER*(*) TEXT\t\n         INTEGER L\t\t\n         INTEGER N,ND\t\t\n         INTEGER D\t\t\n         LOGICAL NEG\t\t\n          IF (BASE.LE.1 .OR. BASE.GT.LEN(DIGIT)) BASE = 10\t\n          WRITE (TEXT,1) BASE\t\n    1     FORMAT (\"Base\",I3)\t\n          T = X\t\t\t\n          N = T\t\t\t\n          T = ABS(T - N)\t\n          NEG = N .LT. 0\t\n          IF (NEG) N = -N\t\n          L = LEN(TEXT)\t\t\n          ND = 0\t\t\nCrunch the integer part. Use the tail end of TEXT as a scratchpad, as the size of N is unassessed.\n   10     D = MOD(N,BASE)\t\t\n          TEXT(L:L) = DIGIT(D+1:D+1)\t\n          ND = ND + 1\t\t\t\n          N = N/BASE\t\t\t\n          L = L - 1\t\t\t\n          IF (L.LE.0) THEN\t\t\n            TEXT = \"Overflow\n            L = MIN(9,LEN(TEXT))\t\n           RETURN\t\t\t\n          END IF\t\t\t\n          IF (N.GT.0) GO TO 10\t\t\n          IF (NEG) THEN\t\t\t\n            TEXT(L:L) = \"-\"\t\t\n            L = L - 1\t\t\t\n          END IF\t\t\t\n          N = LEN(TEXT) - L\t\t\n          TEXT(9:9 + N - 1) = TEXT(L + 1:)\t\n          L = 9 + N\t\t\t\n          TEXT(L:L) = \".\"\t\t\nCrunch through the fractional part until nothing remains.\n          DO WHILE(T.GT.0)\t\n            IF (L.GE.LEN(TEXT)) THEN\t\n              L = LEN(TEXT)\t\t\n              TEXT(L:L) = \"~\"\t\t\n             RETURN\t\t\n            END IF\t\t\n            T = T*BASE\t\t\n            N = T\t\t\n            T = T - N\t\t\n            L = L + 1\t\t\n            TEXT(L:L) = DIGIT(N+1:N+1)\t\n            ND = ND + 1\t\t\n          END DO\t\t\nCast forth an addendum, to save the reader from mumbling while counting long strings of digits.\n          IF (LEN(TEXT) - L .GT. 11) THEN\t\n            WRITE (TEXT(L + 2:),11) ND\t\t\n   11       FORMAT (\"Digits:\",I3)\t\t\n            L = L + 1 + 10\t\t\t\n          END IF\t\t\t\t\n        END SUBROUTINE FP8DIGITS\t\n      END MODULE REBASE\t\n\n      PROGRAM TESTSOME\nCheck some conversions from one base to another.\n      USE REBASE\n      INTEGER N\t\t\n      PARAMETER (N = 5)\t\t\n      CHARACTER*12 TEXT(N)\t\n      DATA TEXT/\"23.34375\",\"10111.01011\",\"1011.1101\",\"11.90625\",\"-666\"/\t\n      DOUBLE PRECISION V\t\n      INTEGER I,L,BASE\t\t\n      CHARACTER*88 BACK\t\t\n\n      WRITE (6,1)\t\n    1 FORMAT (\"Test text in base\",3X,\"Value in base 10\")\nChug through the tests.\n      DO BASE = 10,2,-8\t\n        DO I = 1,N\t\t\n          WRITE (6,11) TEXT(I),BASE\t\n   11     FORMAT (A,I5,$)\t\t\n          IF (.NOT.EATNUM(TEXT(I),BASE,V)) THEN\t\n            WRITE (6,*) \"Not a good number\n           ELSE\t\t\t\t\n            WRITE (BACK,*) V\t\t\t\n            WRITE (6,12) BACK(1:20)\t\t\n   12       FORMAT (A,$)\t\t\t\n            CALL FP8DIGITS(V,2,BACK,L)\t\t\n            WRITE (6,13) BACK(1:L)\t\t\n   13       FORMAT (A)\t\t\t\t\n            CALL FP8DIGITS(V,10,BACK,L)\t\t\n            WRITE (6,14) BACK(1:L)\t\t\n   14       FORMAT (37X,A)\t\t\t\n          END IF\t\t\t\n        END DO\t\t\t\n      END DO\t\t\n      END\t\n", "target": "hex2bin = dict('{:x} {:04b}'.format(x,x).split() for x in range(16))\nbin2hex = dict('{:b} {:x}'.format(x,x).split() for x in range(16))\n\ndef float_dec2bin(d):\n    neg = False\n    if d < 0:\n        d = -d\n        neg = True\n    hx = float(d).hex()\n    p = hx.index('p')\n    bn = ''.join(hex2bin.get(char, char) for char in hx[2:p])\n    return (('-' if neg else '') + bn.strip('0') + hx[p:p+2]\n            + bin(int(hx[p+2:]))[2:])\n\ndef float_bin2dec(bn):\n    neg = False\n    if bn[0] == '-':\n        bn = bn[1:]\n        neg = True\n    dp = bn.index('.')\n    extra0 = '0' * (4 - (dp % 4))\n    bn2 = extra0 + bn\n    dp = bn2.index('.')\n    p = bn2.index('p')\n    hx = ''.join(bin2hex.get(bn2[i:min(i+4, p)].lstrip('0'), bn2[i])\n                 for i in range(0, dp+1, 4))\n    bn3 = bn2[dp+1:p]\n    extra0 = '0' * (4 - (len(bn3) % 4))\n    bn4 = bn3 + extra0\n    hx += ''.join(bin2hex.get(bn4[i:i+4].lstrip('0'))\n                  for i in range(0, len(bn4), 4))\n    hx = (('-' if neg else '') + '0x' + hx + bn2[p:p+2]\n          + str(int('0b' + bn2[p+2:], 2)))\n    return float.fromhex(hx)\n"}
{"id": 411602, "name": "The sieve of Sundaram", "source": "Translate Fortran to Python:       PROGRAM SUNDARAM\n      IMPLICIT NONE\n\n\n\n      INTEGER(8)  ::  curr_index\n      INTEGER(8)  ::  i\n      INTEGER(8)  ::  j\n      INTEGER  ::  lim\n      INTEGER(8)  ::  mid\n      INTEGER  ::  primcount\n      LOGICAL*1 , ALLOCATABLE , DIMENSION(:)  ::  primes \n      lim = 10000000 \n      ALLOCATE(primes(lim))\n      primes(1:lim) = .TRUE.\n                        \n      mid = lim/2\n \n\n      DO j = 1 , mid\n         DO i = 1 , j\n            curr_index = i + j + (2*i*j)\n            IF( curr_index>lim )EXIT        \n            primes(curr_index) = .FALSE.    \n         END DO\n      END DO\n\n      i = 0\n      j = 0\n      WRITE(6 , *)'The first 100 primes:'\n      DO WHILE ( i < 100 )\n         j = j + 1\n         IF( primes(j) )THEN\n            WRITE(6 , 34 , ADVANCE = 'no')j*2 + 1   \n 34         FORMAT(I0 , 1x)\n            i = i + 1                       \n            IF( MOD(i,10)==0 )WRITE(6 , *)' '\n         END IF\n      END DO\n\n      primcount = 0\n      DO i = 1 , lim\n         IF( primes(i) )THEN\n            primcount = primcount + 1\n            IF( primcount==1000000 )THEN\n               WRITE(6 , 35)'1 millionth Prime Found: ' , (i*2) + 1\n 35            FORMAT(/ , a , i0)\n               EXIT\n            END IF\n         END IF\n      END DO\n      DEALLOCATE(primes)\n      STOP\n      END PROGRAM SUNDARAM\n", "target": "from numpy import log\n\ndef sieve_of_Sundaram(nth, print_all=True):\n    \n    assert nth > 0, \"nth must be a positive integer\"\n    k = int((2.4 * nth * log(nth)) // 2)  \n    integers_list = [True] * k\n    for i in range(1, k):\n        j = i\n        while i + j + 2 * i * j < k:\n            integers_list[i + j + 2 * i * j] = False\n            j += 1\n    pcount = 0\n    for i in range(1, k + 1):\n        if integers_list[i]:\n            pcount += 1\n            if print_all:\n                print(f\"{2 * i + 1:4}\", end=' ')\n                if pcount % 10 == 0:\n                    print()\n\n            if pcount == nth:\n                print(f\"\\nSundaram primes start with 3. The {nth}th Sundaram prime is {2 * i + 1}.\\n\")\n                break\n\n\n\nsieve_of_Sundaram(100, True)\n\nsieve_of_Sundaram(1000000, False)\n"}
{"id": 411603, "name": "Gauss-Jordan matrix inversion", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n      SUBROUTINE GJINV (A, LDA, N, B, LDB, IERR)\n       IMPLICIT NONE\n       INTEGER LDA, N, LDB, IERR\n       REAL A(LDA,N), B(LDB,N)\n\n       REAL EPS                                  \n       PARAMETER (EPS = 1.1920929E-07)\n       INTEGER I, J, K, P                        \n       REAL F, TOL\n\n\n\n\n       IF (N < 1) THEN            \n         IERR = -1\n         RETURN\n       ELSE IF (N > LDA .OR. N > LDB) THEN\n         IERR = -2\n         RETURN\n       END IF\n       IERR = 0\n\n       F = 0.                     \n       DO J = 1, N\n         DO I = 1, N\n           F = F + A(I,J)**2\n         END DO\n       END DO\n       F = SQRT(F)\n       TOL = F * EPS\n\n       DO J = 1, N                \n         DO I = 1, N\n           IF (I .EQ. J) THEN\n             B(I,J) = 1.\n           ELSE\n             B(I,J) = 0.\n           END IF\n         END DO\n       END DO\n\n\n       DO K = 1, N\n         F = ABS(A(K,K))          \n         P = K\n         DO I = K+1, N\n           IF (ABS(A(I,K)) > F) THEN\n             F = ABS(A(I,K))\n             P = I\n           END IF\n         END DO\n\n         IF (F < TOL) THEN        \n           IERR = 1\n           RETURN\n         END IF\n\n         IF (P .NE. K) THEN       \n           DO J = K, N\n             F = A(K,J)\n             A(K,J) = A(P,J)\n             A(P,J) = F\n           END DO\n           DO J = 1, N\n             F = B(K,J)\n             B(K,J) = B(P,J)\n             B(P,J) = F\n           END DO\n         END IF\n\n         F = 1. / A(K,K)          \n         DO J = K, N\n           A(K,J) = A(K,J) * F\n         END DO\n         DO J = 1, N\n           B(K,J) = B(K,J) * F\n         END DO\n\n         DO 10 I = 1, N           \n           IF (I .EQ. K) GO TO 10\n           F = A(I,K)\n           DO J = K, N\n             A(I,J) = A(I,J) - A(K,J) * F\n           END DO\n           DO J = 1, N\n             B(I,J) = B(I,J) - B(K,J) * F\n           END DO\n  10     CONTINUE\n       END DO\n\n       RETURN\n      END  \n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 411604, "name": "Gauss-Jordan matrix inversion", "source": "Translate Fortran to Python: \n\n\n\n\n\n\n\n\n\n\n\n\n      SUBROUTINE GJINV (A, LDA, N, B, LDB, IERR)\n       IMPLICIT NONE\n       INTEGER LDA, N, LDB, IERR\n       REAL A(LDA,N), B(LDB,N)\n\n       REAL EPS                                  \n       PARAMETER (EPS = 1.1920929E-07)\n       INTEGER I, J, K, P                        \n       REAL F, TOL\n\n\n\n\n       IF (N < 1) THEN            \n         IERR = -1\n         RETURN\n       ELSE IF (N > LDA .OR. N > LDB) THEN\n         IERR = -2\n         RETURN\n       END IF\n       IERR = 0\n\n       F = 0.                     \n       DO J = 1, N\n         DO I = 1, N\n           F = F + A(I,J)**2\n         END DO\n       END DO\n       F = SQRT(F)\n       TOL = F * EPS\n\n       DO J = 1, N                \n         DO I = 1, N\n           IF (I .EQ. J) THEN\n             B(I,J) = 1.\n           ELSE\n             B(I,J) = 0.\n           END IF\n         END DO\n       END DO\n\n\n       DO K = 1, N\n         F = ABS(A(K,K))          \n         P = K\n         DO I = K+1, N\n           IF (ABS(A(I,K)) > F) THEN\n             F = ABS(A(I,K))\n             P = I\n           END IF\n         END DO\n\n         IF (F < TOL) THEN        \n           IERR = 1\n           RETURN\n         END IF\n\n         IF (P .NE. K) THEN       \n           DO J = K, N\n             F = A(K,J)\n             A(K,J) = A(P,J)\n             A(P,J) = F\n           END DO\n           DO J = 1, N\n             F = B(K,J)\n             B(K,J) = B(P,J)\n             B(P,J) = F\n           END DO\n         END IF\n\n         F = 1. / A(K,K)          \n         DO J = K, N\n           A(K,J) = A(K,J) * F\n         END DO\n         DO J = 1, N\n           B(K,J) = B(K,J) * F\n         END DO\n\n         DO 10 I = 1, N           \n           IF (I .EQ. K) GO TO 10\n           F = A(I,K)\n           DO J = K, N\n             A(I,J) = A(I,J) - A(K,J) * F\n           END DO\n           DO J = 1, N\n             B(I,J) = B(I,J) - B(K,J) * F\n           END DO\n  10     CONTINUE\n       END DO\n\n       RETURN\n      END  \n", "target": "import numpy as np\nfrom numpy.linalg import inv\na = np.array([[1., 2., 3.], [4., 1., 6.],[ 7., 8., 9.]])\nainv = inv(a)\n\nprint(a)\nprint(ainv)\n"}
{"id": 411605, "name": "Welch's t-test", "source": "Translate Fortran to Python: subroutine welch_ttest(n1, x1, n2, x2, t, df, p)\n    use tdf_int\n    implicit none\n    integer :: n1, n2\n    double precision :: x1(n1), x2(n2)\n    double precision :: m1, m2, v1, v2, t, df, p\n    m1 = sum(x1) / n1\n    m2 = sum(x2) / n2\n    v1 = sum((x1 - m1)**2) / (n1 - 1)\n    v2 = sum((x2 - m2)**2) / (n2 - 1)\n    t = (m1 - m2) / sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / &\n         (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2d0 * tdf(-abs(t), df)\nend subroutine\n\nprogram pvalue\n    use betai_int\n    implicit none\n    double precision :: x(4) = [3d0, 4d0, 1d0, 2.1d0]\n    double precision :: y(3) = [490.2d0, 340.0d0, 433.9d0]\n    double precision :: t, df, p\n    call welch_ttest(4, x, 3, y, t, df, p)\n    print *, t, df, p\n    print *, betai(df / (t**2 + df), 0.5d0 * df, 0.5d0)\nend program\n", "target": "import numpy as np\nimport scipy as sp\nimport scipy.stats\n\ndef welch_ttest(x1, x2):\n    n1 = x1.size\n    n2 = x2.size\n    m1 = np.mean(x1)\n    m2 = np.mean(x2)\n    v1 = np.var(x1, ddof=1)\n    v2 = np.var(x2, ddof=1)\n    t = (m1 - m2) / np.sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2 * sp.stats.t.cdf(-abs(t), df)\n    return t, df, p\n\nwelch_ttest(np.array([3.0, 4.0, 1.0, 2.1]), np.array([490.2, 340.0, 433.9]))\n(-9.559497721932658, 2.0008523488562844, 0.01075156114978449)\n"}
{"id": 411606, "name": "Welch's t-test", "source": "Translate Fortran to Python: subroutine welch_ttest(n1, x1, n2, x2, t, df, p)\n    use tdf_int\n    implicit none\n    integer :: n1, n2\n    double precision :: x1(n1), x2(n2)\n    double precision :: m1, m2, v1, v2, t, df, p\n    m1 = sum(x1) / n1\n    m2 = sum(x2) / n2\n    v1 = sum((x1 - m1)**2) / (n1 - 1)\n    v2 = sum((x2 - m2)**2) / (n2 - 1)\n    t = (m1 - m2) / sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / &\n         (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2d0 * tdf(-abs(t), df)\nend subroutine\n\nprogram pvalue\n    use betai_int\n    implicit none\n    double precision :: x(4) = [3d0, 4d0, 1d0, 2.1d0]\n    double precision :: y(3) = [490.2d0, 340.0d0, 433.9d0]\n    double precision :: t, df, p\n    call welch_ttest(4, x, 3, y, t, df, p)\n    print *, t, df, p\n    print *, betai(df / (t**2 + df), 0.5d0 * df, 0.5d0)\nend program\n", "target": "import numpy as np\nimport scipy as sp\nimport scipy.stats\n\ndef welch_ttest(x1, x2):\n    n1 = x1.size\n    n2 = x2.size\n    m1 = np.mean(x1)\n    m2 = np.mean(x2)\n    v1 = np.var(x1, ddof=1)\n    v2 = np.var(x2, ddof=1)\n    t = (m1 - m2) / np.sqrt(v1 / n1 + v2 / n2)\n    df = (v1 / n1 + v2 / n2)**2 / (v1**2 / (n1**2 * (n1 - 1)) + v2**2 / (n2**2 * (n2 - 1)))\n    p = 2 * sp.stats.t.cdf(-abs(t), df)\n    return t, df, p\n\nwelch_ttest(np.array([3.0, 4.0, 1.0, 2.1]), np.array([490.2, 340.0, 433.9]))\n(-9.559497721932658, 2.0008523488562844, 0.01075156114978449)\n"}
{"id": 411607, "name": "Mayan calendar", "source": "Translate Fortran to Python:       PROGRAM MAYA_DRIVER\n      IMPLICIT NONE\n\n\n\n      CHARACTER(80)  ::  haab_carry\n      CHARACTER(80)  ::  long_carry\n      CHARACTER(80)  ::  nightlord\n      CHARACTER(80)  ::  tzolkin_carry\n      INTEGER,DIMENSION(8) :: DAY, MONTH, YEAR\n      INTEGER :: INDEX\n      DATA YEAR /2071,2004,2012,2012,2019,2019,2020,2020/\n      DATA MONTH /5,6,12,12,1,3,2,3/\n      DATA DAY /16,19,18,21,19,27,29,01/\n\n\n\n\n\n\n\n\n      DO INDEX = 1,8\n\n          CALL MAYA_TIME(day(INDEX) , month(INDEX) , year(INDEX) , long_carry , haab_carry , tzolkin_carry ,       &\n                       & nightlord)\n          WRITE(6,20)day(INDEX),month(INDEX),year(INDEX),TRIM(tzolkin_carry),TRIM(haab_carry),TRIM(long_carry),TRIM(nightlord)\n20    FORMAT(1X,I0,'-',I0,'-',I0,T12,A,T24,A,T38,A,T58,A)\n      END DO\n      STOP\n      END PROGRAM MAYA_DRIVER\n\n\n    subroutine maya_time(day,month,year, long_carry,haab_carry, tzolkin_carry,nightlord)\n    implicit none\n    integer(kind=4), parameter :: startdate = 584283    \n    integer(kind=4), parameter :: kin = 1\n    integer(kind=4), parameter :: winal = 20*kin\n    integer(kind=4), parameter :: tun = winal*18\n    integer(kind=4), parameter :: katun = tun*20\n    integer(kind=4), parameter :: baktun = katun*20\n    integer(kind=4), parameter :: piktun = baktun*20    \n    integer(kind=4), parameter :: longcount = baktun*20\n\n    character(len=8), dimension(20) ,parameter :: tzolkin = &\n                                             [\"Imix'   \", \"Ik\u00b4     \", \"Ak\u00b4bal  \", \"K\u00b4an    \", \"Chikchan\", \"Kimi    \", &\n                                              \"Manik\u00b4  \", \"Lamat   \", \"Muluk   \", \"Ok      \", \"Chuwen  \", \"Eb      \", &\n                                              \"Ben     \", \"Hix     \", \"Men     \", \"K\u00b4ib\u00b4   \", \"Kaban   \", \"Etz\u00b4nab\u00b4\", &\n                                              \"Kawak   \", \"Ajaw    \"]\n    character(len=8), dimension(19) ,parameter :: haab = &\n                                             [\"Pop     \", \"Wo\u00b4     \", \"Sip     \", \"Sotz\u00b4   \", \"Sek     \", \"Xul     \", &\n                                              \"Yaxk\u00b4in \", \"Mol     \", \"Ch\u00b4en   \", \"Yax     \", \"Sak\u00b4    \", \"Keh     \", &\n                                              \"Mak     \", \"K\u00b4ank\u00b4in\", \"Muwan   \", \"Pax     \", \"K\u00b4ayab  \", \"Kumk\u00b4u  \", &\n                                              \"Wayeb\u00b4  \"]\n    character(len=20), dimension(9) ,parameter :: night_lords = &\n                                             [\"(G1) Xiuhtecuhtli   \", & \n                                              \"(G2) Tezcatlipoca   \", & \n                                              \"(G3) Piltzintecuhtli\", & \n                                              \"(G4) Centeotl       \", & \n                                              \"(G5) Mictlantecuhtli\", & \n                                              \"(G6) Chalchiuhtlicue\", & \n                                              \"(G7) Tlazolteotl    \", & \n                                              \"(G8) Tepeyollotl    \", & \n                                              \"(G9) Tlaloc         \"  ] \n    integer(kind=4) :: day,month,year\n    intent(in)      :: day,month,year\n\n    integer(kind=4) :: j,l, numdays, keptdays\n    integer(kind=4) :: kin_no, winal_no, tun_no, katun_no, baktun_no, longcount_no\n    character(*) :: haab_carry, nightlord, tzolkin_carry, long_carry\n    intent(inout) :: haab_carry, nightlord, tzolkin_carry, long_carry\n    integer :: mo,da\n\n    keptdays = julday(day,month,year)           \n    numdays = keptdays                          \n\n    numdays = numdays-startdate                 \n    if (numdays .ge. longcount)then             \n        longcount_no = numdays/longcount\n        print*, ' We have more than one longcount ',longcount_no\n    endif\n\n\n    baktun_no = numdays/baktun\n    numdays = numdays - (baktun_no*baktun)      \n    katun_no = numdays/katun                    \n    numdays = numdays - (katun_no*katun)\n    tun_no = numdays/tun\n    numdays = numdays-(tun_no*tun)\n    winal_no = numdays/winal\n    numdays = numdays-(winal_no*winal)\n    kin_no = numdays                                \n    long_carry = ' '                                \n    write(long_carry,'(4(i2.2,\".\"),I2.2)') baktun_no,katun_no,tun_no,winal_no,kin_no\n\n\n\n\n    haab_carry = \" \"\n    L = mod((keptdays+65),365)\n    mo = (L/20)+1\n    da = mod(l,20)\n    if(da.ne.0)then\n        write(haab_carry,'(i2,1x,a)') da,haab(mo)\n    else\n        write(haab_carry,'(a,1x,a)') 'Chum',haab(mo)\n    endif\n\n\n\n    tzolkin_carry = \" \"                     \n    mo = mod((keptdays+16),20) + 1\n    da = mod((keptdays+5),13) + 1\n    write(tzolkin_carry,'(i2,1x,a)') da,tzolkin(mo)\n\n\n\n\n    numdays = keptdays -startdate           \n    J = mod(numdays,9)                      \n    if (j.eq.0) j = 9\n    nightlord = night_lords(j)\n    RETURN\n    contains\n\n    FUNCTION JULDAY( Id , Mm,  Iyyy)\n      IMPLICIT NONE\n\n\n\n      INTEGER , PARAMETER  ::  IGREG = 15 + 31*(10 + 12*1582)\n\n\n\n      INTEGER  ::  Id , Iyyy , Mm\n      INTEGER  ::  JULDAY\n      INTENT (IN) Id , Iyyy , Mm\n\n\n\n      INTEGER  ::  ja , jm , jy\n\n      jy = Iyyy\n      IF(jy == 0)STOP 'julday: there is no year zero'\n      IF(jy < 0)jy = jy + 1\n      IF(Mm > 2)THEN\n         jm = Mm + 1\n      ELSE\n         jy = jy - 1\n         jm = Mm + 13\n      END IF\n      JULDAY = 365*jy + INT(0.25D0*jy + 2000.D0) + INT(30.6001D0*jm) + Id + 1718995\n      IF(Id + 31*(Mm + 12*Iyyy) >= IGREG)THEN\n         ja = INT(0.01D0*jy)\n         JULDAY = JULDAY + 2 - ja + INT(0.25D0*ja)\n      END IF\n      RETURN\n          END FUNCTION JULDAY\n\n    END SUBROUTINE maya_time\n", "target": "import datetime\n\n\ndef g2m(date, gtm_correlation=True):\n    \n\n    \n\n    correlation = 584283 if gtm_correlation else 584285\n\n    long_count_days = [144000, 7200, 360, 20, 1]\n\n    tzolkin_months = ['Imix\u2019', 'Ik\u2019', 'Ak\u2019bal', 'K\u2019an', 'Chikchan', 'Kimi', 'Manik\u2019', 'Lamat', 'Muluk', 'Ok', 'Chuwen',\n                      'Eb', 'Ben', 'Hix', 'Men', 'K\u2019ib\u2019', 'Kaban', 'Etz\u2019nab\u2019', 'Kawak', 'Ajaw']  \n\n    haad_months = ['Pop', 'Wo\u2019', 'Sip', 'Sotz\u2019', 'Sek', 'Xul', 'Yaxk\u2019in', 'Mol', 'Ch\u2019en', 'Yax', 'Sak\u2019', 'Keh', 'Mak',\n                   'K\u2019ank\u2019in', 'Muwan', 'Pax', 'K\u2019ayab', 'Kumk\u2019u', 'Wayeb\u2019']  \n\n    gregorian_days = datetime.datetime.strptime(date, '%Y-%m-%d').toordinal()\n    julian_days = gregorian_days + 1721425\n\n    \n\n    long_date = list()\n    remainder = julian_days - correlation\n\n    for days in long_count_days:\n\n        result, remainder = divmod(remainder, days)\n        long_date.append(int(result))\n\n    long_date = '.'.join(['{:02d}'.format(d) for d in long_date])\n\n    \n\n    tzolkin_month = (julian_days + 16) % 20\n    tzolkin_day = ((julian_days + 5) % 13) + 1\n\n    haab_month = int(((julian_days + 65) % 365) / 20)\n    haab_day = ((julian_days + 65) % 365) % 20\n    haab_day = haab_day if haab_day else 'Chum'\n\n    lord_number = (julian_days - correlation) % 9\n    lord_number = lord_number if lord_number else 9\n\n    round_date = f'{tzolkin_day} {tzolkin_months[tzolkin_month]} {haab_day} {haad_months[haab_month]} G{lord_number}'\n\n    return long_date, round_date\n\nif __name__ == '__main__':\n\n    dates = ['2004-06-19', '2012-12-18', '2012-12-21', '2019-01-19', '2019-03-27', '2020-02-29', '2020-03-01']\n\n    for date in dates:\n\n        long, round = g2m(date)\n        print(date, long, round)\n"}
